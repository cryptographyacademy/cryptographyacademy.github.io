---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/727';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'DiSE: Distributed Symmetric-key Encryption';
const AUTHORS_HTML = 'Shashank Agrawal, Payman Mohassel, Pratyay Mukherjee, Peter Rindal';

const CONTENT = `    <p class="text-gray-300">Shashank Agrawal^{1}, Payman Mohassel^{2}, Pratyay Mukherjee^{3}, and Peter Rindal^{∗}</p>

    <p class="text-gray-300">^{1}Visa Research, shashank.agraval@gmail.com ^{2}Visa Research, payman.mohassel@gmail.com ^{3}Visa Research, pratyay85@gmail.com ^{4}Oregon State University, rindalp@oregonstate.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Threshold cryptography provides a mechanism for protecting secret keys by sharing them among multiple parties, who then jointly perform cryptographic operations. An attacker who corrupts upto a threshold number of parties cannot recover the secrets or violate security. Prior works in this space have mostly focused on definitions and constructions for public-key cryptography and digital signatures, and thus do not capture the security concerns and efficiency challenges of symmetric-key based applications which commonly use long-term (unprotected) master keys to protect data at rest, authenticate clients on enterprise networks, and secure data and payments on IoT devices.</p>

    <p class="text-gray-300">We put forth the first formal treatment for <em>distributed symmetric-key encryption</em>, proposing new notions of <em>correctness</em>, <em>privacy</em> and <em>authenticity</em> in presence of malicious attackers. We provide strong and intuitive game-based definitions that are easy to understand and yield efficient constructions.</p>

    <p class="text-gray-300">We propose a <em>generic construction</em> of threshold authenticated encryption based on <em>any</em> distributed pseudorandom function (DPRF). When instantiated with the two different DPRF constructions proposed by Naor, Pinkas and Reingold (Eurocrypt 1999) and our enhanced versions, we obtain several efficient constructions meeting different security definitions. We implement these variants and provide extensive performance comparisons. Our most efficient instantiation uses <em>only symmetric-key primitives</em> and achieves a throughput of upto <em>1 million</em> encryptions/decryptions per seconds, or alternatively a <em>sub-millisecond</em> latency with upto 18 participating parties.</p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300">*Work done as an intern at Visa Research.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Technical Challenges  4 1.2  Our Contribution  6</p>

    <p class="text-gray-300">2  Technical Overview  7 2.1  Security Requirements  7 2.2  Our Generic Construction  10</p>

    <p class="text-gray-300">3  Related Work  12</p>

    <p class="text-gray-300">4  Preliminaries  14</p>

    <p class="text-gray-300">5  Distributed Pseudo-random Functions: Definitions  15</p>

    <p class="text-gray-300">6  Threshold Symmetric-key Encryption: Definitions  17 6.1  Correctness  18 6.2  Message privacy  19 6.3  Authenticity  20</p>

    <p class="text-gray-300">7  Our Construction: DiSE  22</p>

    <p class="text-gray-300">8  Instantiations of Distributed Pseudorandom Functions  25 8.1  DDH-based construction  25 8.2  PRF-based construction  28</p>

    <p class="text-gray-300">9  Experimental Evaluation  29</p>

    <p class="text-gray-300">10 Acknowledgment  31</p>

    <p class="text-gray-300">A  Cryptographic Primitives  37 A.1  Authenticated Encryption  37 A.2  Commitment  38 A.2.1  Concrete instantiations.  39 A.3  Secret Sharing  39 A.4  Non-interactive Zero-knowledge  40</p>

    <p class="text-gray-300">B  A few failed attempts in detail  41 B.1  Attempt 1: Distributed Encryption Scheme proposed by Naor et al.  41 B.2  Attempt 2: DPRF + Authenticated Encryption  42</p>

    <p class="text-gray-300">C  Missing Proofs  42 C.1  Proof of Theorem 7.4  42 C.2  Proof of Theorem 7.5  45 C.3  Proof of Theorem 7.6  46 C.4  Proof of Theorem 8.1  48 C.5  Proof of Theorem 8.2  53 C.6  Proof of Theorem 8.4  56</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A central advantage of using cryptographic primitives such as symmetric-key encryption is that the safety of a large amount of sensitive data can be reduced to the safety of a very small key. To get any real benefit from this approach, however, the key must be protected securely. One could encrypt the key with another key, protect it using secure hardware (e.g. HSM, SGX or SE), or split it across multiple parties. Clearly, the first approach only shifts the problem to protecting another key. On the other hand secure hardware, co-processors and the like provide reasonable security but are not always available, are expensive or not scalable, lack programmability and are prone to side-channel attacks.</p>

    <p class="text-gray-300">Splitting the key among multiple parties, i.e. threshold cryptography, is an effective general-purpose solution, that has recently emerged in practice as an alternative software-only solution <em>[x10, x21]</em>. Surprisingly, prior to our work, there was no formal treatment of distributed symmetric-key encryption. Prior formal treatments of threshold cryptography typically focus on the asymmetric-key setting, namely public-key encryption and signature schemes <em>[x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23]</em> where the signing/decryption key and algorithms are distributed among multiple parties. This is despite the fact that a large fraction of applications that can benefit from stronger secret-key protection primarily use symmetric-key cryptographic primitives wherein secret keys persist for a long time. We review three such examples below:</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Secret Management Systems.</h4>

    <p class="text-gray-300">An increasing number of tools and popular open source software such as Keywhiz, Knox, and Hashicorp Vault (e.g. see <em>[x24]</em>) are designed to automate the management and protection of secrets such as sensitive data and credentials in cloud-based settings by encrypting data at rest and managing keys and authentication. These tools provide a wide range of features such as interoperability between clouds and audit/compliance support. By far, the most commonly adopted primitive for encrypting secrets in the storage backend is authenticated encryption with a master data encryption key that encrypts a large number of records. Some of these systems use secret sharing to provide limited key protection in an initialization stage but once keys are reconstructed in memory they remain unencrypted until the system is rebooted. Consider the following statement from Hashicorp Vault’s architecture documentation <em>[x25]</em>:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“Once started, the Vault is in a sealed state <span class="math">\\ldots</span> When the Vault is initialized it generates an encryption key which is used to protect all the data. That key is protected by a master key. By default, Vault uses a technique known as Shamir’s secret sharing algorithm to split the master key into 5 shares, any 3 of which are required to reconstruct the master key <span class="math">\\ldots</span> Once Vault retrieves the encryption key, it is able to decrypt the data in the storage backend, and enters the unsealed state.”</p>
    </blockquote>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Enterprise Network Authentication.</h4>

    <p class="text-gray-300">Network authentication protocols such as Kerberos <em>[x20]</em> are widely used to provide a single-sign-on experience to users by enabling them to authenticate periodically (e.g. once a day) to a ticket-granting service using their credentials, to obtain a ticket-granting ticket (TGT) that they use to get access to various services such as mail, printers and internal web. The recommended approach for generating the TGT is authenticated encryption (e.g. see <em>[x22]</em>) using a master secret key in order to provide both confidentiality and integrity for the information contained in the ticket. This renders the master secret key an important attack target, as it remains unprotected in memory over a long period.</p>

    <p class="text-gray-300">Multi-device IoT Authentication. The proliferation of a wide range of Internet of Things (IoT) has provided users with new and convenient ways to interact with the world around them. Such devices are increasingly used to store secrets that are used to authenticate users or enable secure payments. Many IoT devices are not equipped with proper environments to store secret keys, and even when they are, provide developers with little programmability for their applications. It is therefore desirable to leverage the fact that many users own multiple devices (smart phone, smart watch, smart TV, etc.) to distribute the key material among them (instead of keeping it entirely on any single device) to enable multi-device cryptographic functionalities without making strong assumptions about a device’s security features. Given the limited computation and communication power of many such IoT devices, such distributed primitives should require minimal interaction and limited cryptographic capabilities (e.g. only block-ciphers).</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Technical Challenges</h3>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Modeling security</h4>

    <p class="text-gray-300">As discussed earlier, existing threshold cryptographic definitions and constructions are primarily focused on public-key primitives such as digital signatures and public-key encryption. In fact, to the best of our knowledge, there is <em>no</em> standard symmetric-key security notions in the distributed setting.</p>

    <p class="text-gray-300">To help highlight the challenges with defining a robust security model, consider a software-based encryption/authentication service wherein long-term secret keys are shared among multiple servers who collectively perform symmetric encryption, decryption, and MAC operations to store data in the cloud in an encrypted form, or to generate authentication tokens that are used to gain access to an external service. For example, the service can be used by cloud storage customers to encrypt/decrypt data on the cloud using a key that is never reconstructed after being distributed among the servers, or can be used to generate authentication tokens for a single-sign-on access control system that provides access to multiple services. A subset of these servers (below a threshold) are corrupted by an active adversary and can behave arbitrarily malicious but a secure point-to-point channel is assumed between the honest parties.</p>

    <p class="text-gray-300">Observe that threshold authenticated encryption (TAE) is the appropriate and natural notion here as it would simultaneously solve the confidentiality and the authenticity problem, such that a ciphertext generated by the TAE scheme could be both an authentication tickets and an encrypted message. Unfortunately, while definitions for threshold public-key encryption are well-understood (e.g. see <em>[x21, x10, x12, x3]</em>), they fail to capture important subtleties that only arise in the symmetric-key setting when considering standard AE notions of message privacy and ciphertext integrity <em>[x2, x13, x16]</em>.</p>

    <p class="text-gray-300">First note that in the above scenario, servers or parties are simply workers and have no special roles in the application that uses the service. In particular, a party who initiates the ciphertext generation may not be the one initiating the decryption process, and for availability reasons, we do not assume that the same encryptor is online/available during a decryption call. This necessitates a <em>consistency</em> property where a ciphertext generated by any subset of parties should be decryptable by any other subset that is larger than a threshold.</p>

    <p class="text-gray-300">However, what truly separates TAE from threshold public-key encryption is that in TAE a corrupted party should not be able to encrypt or decrypt messages on her own or even generate valid ciphertexts, without “being online” (i.e. without interaction with the honest parties in a distributed encryption/decryption protocol), and this should hold even if the adversary engages in other distributed encryption and decryption protocols.</p>

    <p class="text-gray-300">Capturing all legitimate adversarial interactions in our security games is quite critical and subtle. For example, note that unlike the non-interactive setting, chosen plaintext attack (CPA) security is not sufficient to capture message privacy in the distributed setting where we need to guarantee message privacy not only in the presence of encryption queries but also during decryption queries initiated by the honest parties. In other words, the transcripts of such decryption queries should not reveal anything about the message being decrypted to the adversary. Second, unlike the standard (non-interactive) ciphertext integrity notions where it is shown that decryption queries cannot help the adversary and hence can be safely removed from the security game (e.g. see <em>[x11]</em>), it is easy to observe that allowing for decryption queries in the threshold setting makes the adversary strictly stronger. For instance, consider a contrived threshold scheme where all parties contacted in the decryption protocol simply return their secrets. Clearly, this scheme is not secure, but it would still satisfy a ciphertext integrity notion that does not allow the adversary to invoke the decryption protocol.</p>

    <p class="text-gray-300">Furthermore, adversarial encryption and decryption queries are of various different flavors. Those where the adversary is the initiator (i.e. the encryptor/decryptor), and those where an honest party initiates the query (indirect queries) but the adversary arbitrarily controls the corrupted parties taking part in the protocol. In case of indirect encryption queries, in the message privacy game, we let the adversary choose the message being encrypted and learn the resulting ciphertext. This captures, for example, a scenario where a cloud storage provider that uses the service is compromised and ciphertexts generated by honest encryptors are revealed. On the other hand, in the ciphertext integrity game, it is crucial not to reveal the ciphertext to the adversary in the indirect encryption queries and require that it cannot learn the full ciphertext based on its interactions. Otherwise, an honest party’s call to the encryption protocol provides the adversary with a valid ciphertext (token) that may give him access to an external service. Similar subtleties arise for decryption queries which we discuss in more detail in Section 2.</p>

    <p class="text-gray-300">Finally, unlike the non-interactive case, defining what constitutes a valid forgery in the ciphertext integrity game is non-trivial. First, note that standard AE requires that ciphertexts produced via encryption queries are distinct from the forged ciphertext. In the interactive setting where the adversary takes part in the encryption protocol, however, generated ciphertexts may not be well-defined or valid. Moreover, there are two possible ways of testing validity of a forged ciphertext in the integrity game: (i) decrypt the forgery using an honest decryption (i.e. an execution of the decryption protocol that does not involve any corruption), or (ii) run the decryption protocol wherein adversary controls the corrupted parties. This leads to two different notions of authenticity.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Performance Challenges.</h5>

    <p class="text-gray-300">In addition to not meeting our security notions, existing threshold public-key constructions are too expensive for symmetric-key use cases, as they are dominated by more expensive public-key operations and/or require extensive interaction and communication between the parties. Applications that use symmetric-key cryptography often have stringent latency or throughput requirements. Ideally, one would like the distributed encryption/decryption protocols to not be significantly more expensive than their non-distributed counterparts. In particular, the protocols should have low computation and bandwidth cost, and require minimal interaction.</p>

    <p class="text-gray-300">General-purpose multi-party computation protocols can also be used to solve the same problems by computing standard symmetric-key encryption schemes inside an MPC (e.g. see <em>[x37, x13]</em>). While this approach has the benefit of preserving the original non-interactive</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The flow of our distributed encryption protocol for  <span class="math">n = 5</span>  and  <span class="math">t = 3</span> . Client contacts servers 1, 4 and 5 to encrypt a message  <span class="math">m</span> . Servers do not communicate with each other. We show client separate from the servers for simplicity. A simplified outline of the encryption protocol is given in the box. See Figure 2 for the actual steps. The flow of decryption protocol is similar to encryption but the steps involved are different.</p>

    <p class="text-gray-300">|  DistEnc(m):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  - t← commit(m)  |</p>

    <p class="text-gray-300">|  - k1, k4, k5← query(t, {1,4,5})  |</p>

    <p class="text-gray-300">|  - k← combine(k1, k4, k5)  |</p>

    <p class="text-gray-300">|  - c← Enc(k, m)  |</p>

    <p class="text-gray-300">algorithm, the resulting protocols would be prohibitively interactive, bandwidth-intensive, and would become increasingly expensive for larger number of parties. In this paper, we aim for two-round protocols where one server sends a message to other servers and receives a response, while other servers need not exchange any messages. This minimal interaction model minimizes coordination between the servers and is ideal for low-latency applications.</p>

    <p class="text-gray-300">We review the MPC-based solutions and other related work on protecting cryptographic secrets through splitting them among multiple parties (i.e. secret sharing, threshold PKE and threshold PRFs) in the related work section (Section 3).</p>

    <p class="text-gray-300">We formalize, design and implement new protocols for distributed symmetric-key encryption. Our contributions can be summarized as follows:</p>

    <p class="text-gray-300">New security definitions. We initiate a formal study of authenticated encryption in the distributed setting. We propose novel message privacy and ciphertext integrity definitions for threshold authenticated encryption that captures the unique issues that arise in this setting, in presence of a malicious adversary that corrupts a subset of parties.</p>

    <p class="text-gray-300">Simple and lightweight protocols. We put forward a generic construction based on any distributed pseudorandom function (DPRF) in the standard model. The construction only assumes one-way functions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When we instantiate with multiple efficient DPRF constructions from Naor et al. [NPR99] and our enhanced variants, we derive a number of threshold authenticated encryption</li>

    </ul>

    <p class="text-gray-300">protocols with different security guarantees and efficiency levels (see Figure 8). All our protocols are light-weight: they require only two rounds of communication and incur minimal computation and bandwidth cost. Specifically, the party interested in encryption or decryption sends one request message to other parties and receives one response message in return (see Figure 1 for a visual depiction). In the most efficient instantiation, there are no public-key operations as parties only make PRF calls and hashing.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We provide the first formal analysis for both the PRF-based and the DDH-based instantiations of the DPRF constructions given in Naor et al. <em>[x20]</em> by proposing a strong pseudo-randomness property. We also formalize correctness of DPRFs in presence of malicious corruption and extend their DDH-based construction to satisfy this notion.</li>

      <li>Our protocols allow for an arbitrary threshold <span class="math">t</span> such that only <span class="math">t-1</span> other parties need to be contacted to encrypt or decrypt. At the same time, the protocols are resilient to the corruption of <span class="math">t-1</span> parties (clearly, this is the best one could hope for).</li>

    </ul>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Implementation and Evaluation.</h4>

    <p class="text-gray-300">We implement several variants of our protocols in C++ and perform extensive experiments to evaluate their performance for applications with high-throughput and low-latency requirements. Our most efficient instantiation achieves a throughput of upto 1 million encryptions/decryptions per seconds, or alternatively a sub-millisecond latency with upto 18 participating parties. We achieve this high level of performance through a variety of cryptographic optimization and system level engineering such as full use of hardware accelerated AES and instruction vectorization. The result is a lightweight challenge-response protocol where only one message is sent and received by the participating parties.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2 Technical Overview</h2>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.1 Security Requirements</h3>

    <p class="text-gray-300">A primary contribution of this work is to present a formal treatment of symmetric-key authenticated encryption in the distributed setting.</p>

    <p class="text-gray-300">Our definitions are inspired by the traditional game-based notions of message privacy and ciphertext integrity for standard (i.e. non-interactive) symmetric-key encryption <em>[x1, x17, x22]</em>. We intentionally avoid the Universal Composability framework <em>[x5]</em> because such definitions, proposed in prior work for standard symmetric-key encryption, are cumbersome to work with (e.g. see <em>[x18]</em>).</p>

    <p class="text-gray-300">We remark that over the past two decades, a large body of work has considered various notions of security for standard authenticated encryption <em>[x1, x24, x22, x23, x21, x16, x15, x14, x13, x12, x11, x10, x11, x12, x13]</em> to address many practical issues such as concrete security, nonce-misuse resistance, online security, and multi-user security. As the first work to formalize distributed authenticated encryption, we choose to focus on the traditional notion of AE security (i.e. message privacy + ciphertext integrity) as even extending this important notion to the threshold setting raises many new subtleties (as we will see shortly) that do not exist in the non-interactive setting. We leave it for future work to extend threshold AE to the more advanced notions mentioned above.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">The Attack Model.</h5>

    <p class="text-gray-300">In the distributed setting, we consider an attacker who controls a subset of parties and behaves <em>arbitrarily malicious</em> while the honest parties are connected via point-to-point secure channels. Moreover, to capture a more realistic scenario, we let the adversary choose its corruption set after receiving the public parameters of the scheme. As we will see shortly, this requires additional care in both the constructions and the security proof.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Threshold Symmetric-key Encryption.</h5>

    <p class="text-gray-300">Analogous to its non-interactive counterpart, we define a <em>threshold symmetric-key encryption</em> (TSE) scheme consisting of a setup algorithm Setup and two protocols, DistEnc and DistDec, for distributed encryption and decryption, respectively. The scheme is parameterized by two positive integers <span class="math">n</span> and <span class="math">t</span>, with <span class="math">n\\geq t\\geq 2</span> where <span class="math">n</span> denotes the total number of parties and <span class="math">t</span> the threshold. We allow at most <span class="math">t-1</span> corruptions which is clearly optimal in this setting. Setup generates <span class="math">n</span> private keys <span class="math">sk_{1},sk_{2},\\ldots,sk_{n}</span>, one for each party, and some public parameters <span class="math">pp</span>. In DistEnc, one of the parties, called the encryptor, who holds a message, sends a request message to <em>any</em> <span class="math">t-1</span> other parties in the protocol. The participating parties use their respective secret-keys to compute their individual responses. At the end of the protocol, only the encryptor learns a ciphertext. Analogously, in DistDec, one of the parties (decryptor) with a ciphertext performs a similar process and learns the corresponding message. Note that we do not assume that the same party plays the role of encryptor and decryptor. Our <em>consistency</em> property requires that any subset of <span class="math">t</span> parties should be able to encrypt or decrypt.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Correctness.</h5>

    <p class="text-gray-300">The natural correctness requirement in the non-interactive setting is that a ciphertext <span class="math">c</span> generated by running an encryption algorithm on a message <span class="math">m</span> must decrypt to <span class="math">m</span>. But in the threshold setting where the adversary is malicious, defining correctness becomes more subtle. Informally, correctness requires that a ciphertext that is generated by an honest encryptor but may involve corrupt parties in the encryption protocol can only be decrypted (by an honest decryptor) to the correct message or results in an abort (i.e. <span class="math">\\bot</span>) even if the decryption involves corrupted parties. This notion may already be sufficient for many applications. We also formalize a stronger notion wherein any execution of an encryption protocol that potentially involves malicious parties either produces a correct ciphertext (by correct we mean that an honest decryption produces the original message) or results in an abort. In other words, a valid ciphertext carries an implicit guarantee that an honest decryption/verification will always be successful. Looking ahead, if we do not impose the stronger correctness requirement, our instantiation is significantly faster—since to achieve the stronger form of correctness we need non-interactive zero-knowledge proofs (NIZK) that require more expensive public-key operations.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Message Privacy.</h5>

    <p class="text-gray-300">As discussed earlier, our definition has two components, message privacy and ciphertext integrity (also called <em>authenticity</em>). In the non-interactive case, message privacy is defined via a chosen plaintext attack (CPA) game where the adversary can engage in encryption queries before and after the challenge phase where the challenge stage consists of guessing between the ciphertexts for two adversarially chosen messages.</p>

    <p class="text-gray-300">In the threshold setting, we allow for two types of encryption queries in the message privacy game. First, the adversary can initiate its own encryption queries using messages of its choice and obtain both the final ciphertext as well as the transcripts of the parties it corrupts (and influence their actions during encryption). Second, we allow the adversary to perform</p>

    <p class="text-gray-300">indirect encryption queries where it invokes an honest party to initiate an encryption query using an adversary-chosen message and let the adversary learn the ciphertext (despite the fact that the TSE encryption would not necessarily leak the ciphertext to the adversary). This captures scenarios where the application using the service may unintentionally leak ciphertexts to the adversary (e.g. a cloud storage compromise or authentication token leakage). We then observe that this is not sufficient to capture full message privacy in the distributed setting. In particular, even decryption queries initiated by honest parties should preserve message privacy in presence of a malicious adversary who corrupts a subset of parties. Note that this issue does not arise in the non-interactive case where decryption queries always reveal the message. Hence, we allow these indirect decryption queries in our message privacy game and do not reveal the decrypted message to the adversary. In particular, an adversary could provide its challenge ciphertext to such an indirect decryption query and still should not be able to win the message privacy game.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Ciphertext Integrity.</h4>

    <p class="text-gray-300">In the ciphertext integrity game, the adversary engages in both encryption and decryption queries, and then needs to create a new valid ciphertext (forgery). Several subtleties arise when defining a valid forgery. Let us start with the different types of encryption/decryption queries.</p>

    <p class="text-gray-300">Similar to the message privacy game, both standard and indirect encryption queries are allowed. The ciphertexts resulting from the former are naturally not considered forgeries since the corrupt party is intended to learn it. However, in the indirect case where an honest party initiates the encryption, the security game does not provide the adversary with the resulting ciphertext. As such, the adversary is allowed to output the ciphertext of an indirect encryption query as a valid forgery if it manages to acquire one. Therefore the TSE scheme is required to prevent such attacks by making them unpredictable to him even while actively participating in the protocols.</p>

    <p class="text-gray-300">Interestingly, we allow three types of decryption queries in the ciphertext integrity game. The adversary (i) either makes a standard decryption query where it initiates the decryption using a ciphertext of its choice and learns the decryption and transcripts of all corrupted parties; or (ii) it makes an indirect decryption query where an honest party initiates the decryption query <em>using a ciphertext provided by the adversary</em>; or (iii) makes an indirect decryption query <em>using a ciphertext it does not know</em> but that was previously generated via an indirect encryption protocol initiated by an honest party. The purpose of the third type (called <em>targeted decryption</em> queries) is to ensure that the decryption protocol initiated by an honest party does not leak the computed ciphertext to the adversary if it is the result of an earlier encryption by an honest party. To capture this, we do not count these ciphertexts towards adversary’s forgery budget; in particular, the adversary wins the game if it outputs one of them as a forgery. In fact, the only decryption queries that we count towards adversary’s forgery budget are of the first type, i.e. those initiated by the adversary itself. See Remark 6.11 for a more detailed discussion and how even this can be avoided at the cost of more expensive constructions.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">One-More Ciphertext Integrity.</h4>

    <p class="text-gray-300">To define a successful forgery in the usual non-interactive setting, one could just say that the adversary must produce a ciphertext <em>that is different from the ones it receives from the encryption oracle</em> <em>[x10, x23]</em>. Alternatively, in the case of unified definitions <em>[x30]</em>, the adversary is restricted from querying the decryption oracle</p>

    <p class="text-gray-300">with a ciphertext it received from the encryption oracle². Unfortunately, one cannot take a similar approach in the distributed setting. If the adversary initiates an encryption session that involves malicious parties, the output of the session (a ciphertext) may not be available to the honest parties even if they are involved. Thus, it is not clear how to explicitly define the ciphertext learned by the adversary and therefore no straightforward way to prevent the adversary from claiming such ciphertext as a valid forgery.</p>

    <p class="text-gray-300">To circumvent the problem while keeping the definition simple, we keep track of the maximum number of ciphertexts, say <span class="math">k</span>, the adversary could learn (in an ideal sense) by interacting with honest parties and require that as his forgery, he outputs <span class="math">k + 1</span> distinct ciphertexts that successfully decrypt. This implies that at least one of the ciphertexts he outputs is a new and valid ciphertext.</p>

    <p class="text-gray-300"><strong>Two Notions of Authenticity.</strong> Our definition also needs to specify how the forged ciphertexts are decrypted to check their validity. The first option is to use an honest decryption (where all parties behave honestly). This is sufficient in applications where an external service would perform the decryption using the whole key (e.g. in case of single-sign-on access to a service). We refer to this variant as authenticity as it resembles the standard authenticity notions studied in the non-interactive setting. A second (and stronger) option is to continue using the distributed decryption protocol (where adversary actively controls a subset of parties) to decrypt the forged ciphertexts too. We refer to this variant as strong authenticity. We design and implement protocols meeting both notions trading off efficiency for higher security.</p>

    <h2 id="sec-19" class="text-2xl font-bold">2.2 Our Generic Construction</h2>

    <p class="text-gray-300">We provide a brief overview of our main construction but before doing so, we discuss a few attempts that fail to meet our efficiency or security requirements. A more detailed discussion on the failed attempts can be found in Appendix B.</p>

    <p class="text-gray-300"><strong>DPRF.</strong> All the constructions we discuss in this section use a Distributed Pseudorandom Function (DPRF) as a building block. A DPRF is a distributed analog of a standard PRF. It involves a setup where each party obtains their secret-key and the public parameters. Evaluation on an input is performed collectively by any <span class="math">t</span> parties where <span class="math">t</span> (<span class="math">\\leq n</span>) is a threshold. Importantly, at the end of the protocol, only one special party (evaluator) learns the output. A DPRF should meet two main requirements: (i) consistency: the evaluation should be independent of the participating set, and (ii) pseudorandomness: the evaluation's output should be pseudorandom to everyone else but the evaluator even if the adversary corrupts all other <span class="math">t - 1</span> parties and behaves maliciously.</p>

    <p class="text-gray-300">In the malicious case, one can think of a slightly stronger property, called (iii) correctness, where after an evaluation involving up to <span class="math">t - 1</span> malicious corruptions, an honest evaluator either receives the correct output or can detect the malicious behavior.³ Naor et al. [NPR99]</p>

    <p class="text-gray-300">²Under the unified definition, the adversary is supposed to distinguish between two worlds, a ‘real’ world where access to both encryption and decryption oracle is provided, and an ‘ideal’ world where the encryption oracle is replaced with one that just returns random bits and the decryption oracle is replaced with one that just returns <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">³Looking ahead, our TSE protocol achieves strong authenticity, in which the adversary is involved in the decryption of the forgery, only if the underlying DPRF achieves correctness.</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">propose two very efficient (two-round) instantiations of DPRF, one based only on symmetric-key cryptography and another based on the DDH assumption. We provide the first formal proof of security for these constructions under a strong pseudo-randomness requirement. These constructions, however, do not satisfy the correctness definition (against malicious adversaries). Interestingly, we note that the recommended approach of obtaining correctness by applying a NIZK to each message of the protocol runs into a subtle technical issue, and show how to circumvent it by modifying the construction such that the public parameters provide a trapdoor commitment to the secret keys of the parties.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Attempt-0: A four-round protocol.</h5>

    <p class="text-gray-300">As discussed earlier, our goal is to obtain a two-round protocol where one party sends a message to others and receives a response. But it is helpful to review a first attempt that requires four rounds of interaction and meets all our security requirements. We assume a DPRF scheme is already setup. To encrypt a message <span class="math">m</span>, parties evaluate the DPRF on a random message <span class="math">r</span> generated by the encryptor to obtain the output <span class="math">w</span>. The encryptor then encrypts the message <span class="math">m</span> using a CPA-secure symmetric-key encryption with <span class="math">w</span> as the secret-key to obtain a ciphertext <span class="math">c</span>. Parties then run the DPRF protocol one more time on <span class="math">H(c)</span> for a collision-resistance hash function <span class="math">H</span>, such that the encryptor obtains the tag <span class="math">t</span>. Encryptor outputs <span class="math">(r,c,t)</span> as the output of the encryption protocol. The decryption protocol works as expected by first recomputing and checking <span class="math">t</span> and then recovering <span class="math">w</span> to decrypt <span class="math">c</span>.</p>

    <p class="text-gray-300">It is worth noting that this construction is reminiscent of the standard <em>encrypt-then-MAC</em> approach for obtaining an authenticated encryption scheme, where in one invocation the DPRF is used to generate a fresh random key for encryption and in the second invocation it is used to compute a MAC on the ciphertext. Note that the encryption protocol requires two sequential calls to the DPRF protocol, hence yielding four rounds of interaction. Interestingly, to obtain a two-round protocol, we need to deviate from this and design a protocol that roughly follows the <em>MAC-then-encrypt</em> paradigm but nevertheless meets our strong notions of security. Next we review two 2-round proposals that fail to achieve our notions.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Failed Attempt-1 <em>[x10]</em>.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first (to the best of our knowledge) proposal for a distributed encryption is due to Naor et al. <em>[x10]</em> (NPR in short). They propose to (i) first encrypt the message <span class="math">m</span> locally to produce a ciphertext <span class="math">e=\\mathsf{SE}_{w}(m)</span> by a “standard” symmetric-key encryption scheme <span class="math">\\mathsf{SE}</span> where the key <span class="math">w</span> is chosen freshly at random; (ii) then invoke the DPRF on the input $(j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e)<span class="math"> for the encryptor to obtain </span>y<span class="math">, where </span>j<span class="math"> is the encryptor’s identity; (iii) finally mask the key </span>w<span class="math"> with </span>y<span class="math">. The final ciphertext is of the form </span>(j,y\\oplus w,e)<span class="math">. Although this achieves message privacy, it fails to achieve authenticity since the adversary, after obtaining a valid ciphertext as above, can change the key by mauling </span>w<span class="math"> to </span>w^{\\prime}<span class="math"> (and hence maul the ciphertext) and decrypt </span>e<span class="math"> with </span>w^{\\prime}<span class="math"> to produce a valid message </span>m^{\\prime}<span class="math">. The crux of the problem is in giving the adversary the flexibility to choose the encryption key </span>w$ without any checks or restrictions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Failed Attempt-2.</h5>

    <p class="text-gray-300">Another natural approach to construct distributed threshold encryption is to (i) choose a random nonce <span class="math">r</span>, (ii) compute a DPRF value <span class="math">w</span> on <span class="math">(j,r)</span> and (iii) use <span class="math">w</span> as a key for a standard authenticated encryption scheme <span class="math">\\mathsf{AE}</span> to compute <span class="math">e=\\mathsf{AE}_{w}(m)</span>. The final ciphertext is <span class="math">(j,r,e)</span>. One can easily observe that, although message private, this approach does not suffice for authenticity since an attacker can make a single encryption query to obtain <span class="math">w</span> and use it to encrypt more valid messages without violating the security</p>

    <p class="text-gray-300">of the AE scheme.</p>

    <p class="text-gray-300">Note that both attacks discussed above work even in the semi-honest setting since the corrupt parties behave honestly in all distributed protocols. In fact, the above attempts fail to achieve even a much weaker notion of authenticity which does not allow decryption queries. See Appendix B for more details.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Our Construction.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At a high level, we use a DPRF scheme to generate a pseudorandom key <span class="math">w</span> that is used to encrypt the message <span class="math">m</span>. But to avoid the recurring problem in the failed attempts above, we need to ensure that an adversary cannot use the same <span class="math">w</span> to generate any other valid ciphertext. To do so, we bind <span class="math">w</span> to the message <span class="math">m</span> (and the identity of party <span class="math">j</span>). One way to achieve that is to use $(j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)<span class="math"> as an input to the DPRF. First, note that it is necessary to put </span>j<span class="math"> inside the DPRF, otherwise a malicious attacker can easily obtain </span>w<span class="math"> by replaying the input of the DPRF in a new encryption query and thereby recovering any message encrypted by an honest encryptor. In the protocol we make sure each party checks if a message of the form </span>(j,*)<span class="math"> is indeed coming from party </span>j<span class="math">. Second, this does not suffice as it reveals </span>m<span class="math"> to all other parties during the encryption protocols originated by honest parties and as a result fails to achieve even message privacy. To overcome this, we instead input a commitment to </span>m<span class="math"> to the DPRF. The hiding property of the commitment ensures that </span>m<span class="math"> remains secret, and the binding property of the commitment binds </span>w<span class="math"> to this particular message. To enable the verification of the decommitment during the decryption, we need to also encrypt the commitment randomness along with </span>m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This almost works except that the attacker can still generate valid new ciphertexts by keeping <span class="math">m,j</span> and <span class="math">w</span> the same and using new randomness to encrypt <span class="math">m</span>. We prevent this by making the ciphertext deterministic given <span class="math">m</span> and <span class="math">w</span>: we input <span class="math">w</span> to a pseudorandom number generator to produce a pseudorandom string serving as a “one-time pad” that is used to encrypt <span class="math">m</span> just by XOR’ing (this can be thought of as applying a standard stream-cipher using <span class="math">w</span> as the “random” nonce).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To summarize, our final construction can be informally described as follows: (i) the encryptor with identity <span class="math">j</span> chooses a random <span class="math">\\rho</span> to compute <span class="math">\\alpha:=\\mathsf{Com}(m;\\rho)</span> where <span class="math">\\mathsf{Com}</span> is a commitment and sends <span class="math">(j,\\alpha)</span> to the participating parties, (ii) the participating parties then first check if the message <span class="math">(j,\\alpha)</span> is indeed sent by <span class="math">j</span> (otherwise they abort) and then evaluate the DPRF on $(j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha)<span class="math"> for the encryptor to obtain the output </span>w<span class="math">, (iii) finally, the encryptor computes </span>e=\\mathsf{PRG}(w)\\oplus(m\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math"> and outputs the ciphertext </span>(j,\\alpha,e)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 7 we show that the above construction achieves consistency, message privacy and authenticity (ciphertext integrity) against a malicious adversary who corrupts up to <span class="math">t-1</span> parties if the underlying DPRF is consistent and pseudorandom. Moreover, if the underlying DPRF satisfies our correctness definition, then our TSE achieves strong authenticity. Note that given a DPRF, the only assumption required for the transformation is one-way functions.</p>

    <h2 id="sec-24" class="text-2xl font-bold">3 Related Work</h2>

    <p class="text-gray-300">We briefly discuss several related research directions with similar motivations.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Secret-sharing.</h4>

    <p class="text-gray-300">Secret-sharing schemes can be used to share the key for symmetric-key encryption among multiple parties, say <span class="math">n</span>. They guarantee that even if up to <span class="math">n-1</span> parties are</p>

    <p class="text-gray-300">compromised, no information about the key is leaked. A popular key management tool called Vault [vaub] takes this approach. It uses Shamir's secret sharing [Sha79] to split the master secret key into shards. According to the documentation [vauc], "This allows each shard of the master key to be on a distinct machine for better security." In practice, however, the master secret key is reconstructed from the shards when the Vault server is started, and remains in the memory of several—potentially, very weakly protected—parties for extended periods of time. Certainly, Vault makes it easy for multiple applications or services to share the same key material but, at the same time, does not reduce key exposure in a significant way. Effectively, instead of being stored in a permanent way on multiple parties, the key material lives in memory.</p>

    <p class="text-gray-300">Threshold PKE. Threshold public-key encryption is a well-studied problem in cryptography [Fra90, DF90, DDFY94, SG98, CG99, NPR99, DP08]. Here, the decryption key is shared among a set of parties such that at least a threshold of them are needed to decrypt any ciphertext. In some sense, threshold PKE is an analog of the problem we study here. But as discussed earlier, being a public-key notion, neither the security notions nor the efficiency requirements meet those of symmetric-key applications.</p>

    <p class="text-gray-300">Threshold Pseudorandom Functions. To the best of our knowledge, the only threshold constructions designed for symmetric-key primitives are for pseudorandom functions [MS95, NPR99, Nie02, Dod03, DY05, DYY06, BLMR13, ECS+15]. This line of work is primarily focused on distributed PRFs (DPRF) with security in the standard model or additional properties such as verifiability or key-rotation, but does not provide definitions or constructions for the more general case of symmetric-key encryption. The only exception is the work of Naor et al. [NPR99], which also proposes a mechanism for encrypting messages using their DPRF construction. But as we have discussed (c.f. Sec 2.1, Appendix B), their proposal fails to meet our definition of threshold authenticated encryption. Nevertheless, we use Naor et al.'s DPRF constructions as the main building block in our constructions and implementations.</p>

    <p class="text-gray-300">General-purpose MPC. Secure multi-party computation (MPC) allows multiple parties to evaluate a function over their private inputs without revealing anything about their inputs beyond the function's output. Since its introduction in early 80s, MPC has grown into a rich area with a number of different solutions of various flavors. In the last decade or so, the performance of general-purpose MPC protocols (which allow arbitrary functions to be computed) has improved substantially in both the two-party and multi-party setting [mpca, mpcb, mpcc].</p>

    <p class="text-gray-300">However, all general-purpose MPC protocols work with a circuit representation of the function which seems to be an overkill to solve our specific problem. Furthermore, the communication complexity of these protocols typically scales linearly with the size of the circuit and the number of parties. Finally, the number of rounds of interactions is often more than two for all practical MPC instantiations; and the protocols require all pairs of</p>

    <p class="text-gray-300">If not the master secret key itself, then at least the encryption key remains in memory. The encryption key encrypts the actual data and the master key encrypts the encryption key. We refer to the documentation for details.</p>

    <p class="text-gray-300">A recent surge of results [GGHR14, MW16, GMPP16, GS18, GS17, BL18] construct two round MPC protocols. However, these constructions focus mainly on generic feasibility and minimizing assumptions and are far from being practical.</p>

    <p class="text-gray-300">parties to interact. Thus, a general-purpose MPC protocol for evaluating symmetric ciphers such as AES in any encryption mode <em>[x10, GRR^{+}16, x31, x16]</em> is too expensive of a solution for many applications of distributed symmetric-key encryption. On the other hand, MPC-based solutions are advantageous in scenarios where the desired encryption scheme is fixed and cannot be changed by the application (due to compatibility with other components or a compliance requirement to use standardized schemes such as AES) since MPC can be used to securely compute arbitrary cryptographic functions.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 Preliminaries</h2>

    <p class="text-gray-300">In this paper, unless mentioned otherwise, we focus on challenge-response style two-round protocols: a party sends messages to some other parties and gets a response from each one of them. In particular, the parties contacted need not communicate with each other.</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Common notation.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{N}</span> denote the set of positive integers. We use <span class="math">[n]</span> for <span class="math">n\\in\\mathbb{N}</span> to denote the set <span class="math">\\{1,2,\\ldots,n\\}</span>. A function <span class="math">f:\\mathbb{N}\\to\\mathbb{N}</span> is negligible, denoted by <span class="math">\\mathsf{negl}</span>, if for every polynomial <span class="math">p</span>, <span class="math">f(n)&lt;1/p(n)</span> for all large enough values of <span class="math">n</span>. We use <span class="math">\\mathsf{D}(x)=:y</span> or <span class="math">y:=\\mathsf{D}(x)</span> to denote that <span class="math">y</span> is the output of the <em>deterministic</em> algorithm <span class="math">\\mathsf{D}</span> on input <span class="math">x</span>. Also, <span class="math">\\mathsf{R}(x)\\to y</span> or <span class="math">y\\leftarrow\\mathsf{R}(x)</span> denotes that <span class="math">y</span> is the output of the <em>randomized</em> algorithm <span class="math">\\mathsf{R}</span> on input <span class="math">x</span>. <span class="math">\\mathsf{R}</span> can be derandomized as <span class="math">\\mathsf{R}(x;r)=:y</span>, where <span class="math">r</span> is the explicit random tape used by the algorithm. Finally, we write <span class="math">X\\sim D_{S}</span> to denote a random variables <span class="math">X</span> that follows a distribution <span class="math">D</span> over a set <span class="math">S</span>. For two random variables <span class="math">X</span> and <span class="math">Y</span> we write <span class="math">X\\approx_{comp}Y</span> to denote that they are computationally indistinguishable and <span class="math">X\\approx_{stat}Y</span> to denote that they are statistically close. Concatenation of two strings <span class="math">a</span> and <span class="math">b</span> is either denoted by $(a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b)<span class="math"> or </span>(a,b)<span class="math">. Throughout the paper, we use </span>n<span class="math"> to denote the total number of parties, </span>t<span class="math"> to denote the threshold, and </span>\\kappa<span class="math"> to denote the security parameter. We make the natural identification between players and elements of </span>\\{1,\\ldots,n\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will use <em>Lagrange interpolation</em> for evaluating a polynomial. For any polynomial <span class="math">P</span>, the <span class="math">i</span>-th Lagrange coefficient for a set <span class="math">S</span> to compute <span class="math">P(j)</span> is denoted by <span class="math">\\lambda_{j,i,S}</span>. Matching the threshold, we will mostly consider <span class="math">(t-1)</span>-degree polynomials, unless otherwise mentioned. In this case, at least <span class="math">t</span> points on <span class="math">P</span> are needed to compute any <span class="math">P(j)</span>.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Inputs and outputs.</h5>

    <p class="text-gray-300">We write <span class="math">[j:x]</span> to denote that the value <span class="math">x</span> is private to party <span class="math">j</span>. For a protocol <span class="math">\\pi</span>, we write <span class="math">[j:z^{\\prime}]\\leftarrow\\pi([i:(x,y)],[j:z],c)</span> to denote that party <span class="math">i</span> has two private inputs <span class="math">x</span> and <span class="math">y</span>; party <span class="math">j</span> has one private input <span class="math">z</span>; all the other parties have no private input; <span class="math">c</span> is a common public input; and, after the execution, only <span class="math">j</span> receives an output <span class="math">z^{\\prime}</span>. We write <span class="math">[i:x_{i}]_{\\forall i\\in S}</span> or more compactly <span class="math">\\llbracket\\mathbf{x}\\rrbracket_{S}</span> to denote that each party <span class="math">i\\in S</span> has a private value <span class="math">x_{i}</span>.</p>

    <h5 id="sec-29" class="text-base font-semibold mt-4">Network model.</h5>

    <p class="text-gray-300">We assume that all the parties are connected by point-to-point secure and authenticated channels. We also assume that there is a known upper-bound on the time it takes to deliver a message over these channels.</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Adversary model.</h5>

    <p class="text-gray-300">We allow an adversary to take control of up to <span class="math">t-1</span> parties and make them behave in an arbitrary manner (active/malicious corruption). The set of corrupt parties is not known in advance, but we assume that it does not change during protocol execution (static corruption). We use <span class="math">C</span> to denote the set of parties under the control of an adversary <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">Cryptographic primitives. We need some standard cryptographic primitives to design our protocols like commitments, secret-sharing, non-interactive zero-knowledge proofs, etc. For completeness we define them formally in Appendix A.</p>

    <p class="text-gray-300">Micali and Sydney introduced the notion of distributed pseudo-random functions in the mid 90s [MS95]. A DPRF distributes between  <span class="math">n</span>  parties the evaluation of a function  <span class="math">f</span>  which is an approximation of a random function, such that only authorized subsets of parties are able to compute  <span class="math">f</span> . A party who wants to compute  <span class="math">f(x)</span>  sends  <span class="math">x</span>  to the parties in an authorized subset and receives information which enables her to find  <span class="math">f(x)</span> . A DPRF must be consistent in the sense that for all inputs  <span class="math">x</span> , all authorized subsets should lead to the same value  <span class="math">f(x)</span> .</p>

    <p class="text-gray-300">A number of constructions and variants have been proposed over the course of more than two decades but they either involve multiple rounds of communication [Dod03], extensive interaction [Nie02, DY05], consider only passive corruption [NPR99, BLMR13], or achieve stronger properties which makes them more expensive [DYY06]. Several pseudo-randomness definitions have also been put forward in the literature, but they are not very formal or general in most cases. There are several attacks that are not explicitly captured by these definitions (though the proposed constructions may be secure against them). First, the adversary is not allowed to choose the set of parties to corrupt based on the public parameters (the only exception we know of is the definition proposed by Boneh et al. [BLMR13]). Second, it cannot obtain DPRF partial evaluations from honest parties on the challenge input (up to the threshold). Third, it is not allowed to participate in computing the DPRF on the challenge input, which may help it in distinguishing the true DPRF value from random. (Note that this last attack makes sense only under an active corruption.)</p>

    <p class="text-gray-300">We allow the adversary to do all of the above in the pseudo-randomness game, thus obtaining a much stronger security guarantee. Apart from consistency and pseudo-randomness, we also propose a correctness property which ensures that even if corrupt parties are involved in a DPRF computation, they cannot make an honest party output a wrong value. We build on the constructions of Naor et al. [NPR99] to obtain these properties from our DPRF instantiations.</p>

    <p class="text-gray-300">Naor et al. [NPR99], however, were mainly concerned with DPRF security against semihonest adversaries. They provide a security definition and two different constructions for such adversaries. They mention briefly that using non-interactive zero-knowledge (NIZK) proofs, one could make their DPRF constructions actively secure. However, they do not give a formal security definition for active security. It turns out that a naive application of NIZK proofs is in fact not sufficient to obtain security against malicious participants. We additionally need trapdoor commitments to satisfy the stronger pseudo-randomness requirement proposed here. Further, the fact that adversaries can obtain DPRF partial outputs on the challenge input and participate in computing the challenge DPRF value makes the proof more intricate.</p>

    <p class="text-gray-300">We now present a formal treatment of DPRF. Similar to NPR [NPR99], we use a threshold  <span class="math">t</span>  to capture the authorized subsets, i.e., any set of at least  <span class="math">t</span>  parties can compute the function  <span class="math">f</span> . Security is provided against any set of up to  <span class="math">t - 1</span>  corrupt parties.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 5.1 (Distributed Pseudo-random Function)</h6>

    <p class="text-gray-300">A distributed pseudo-random function (DPRF) <span class="math">\\mathsf{DP}</span> is a tuple of three algorithms (<span class="math">\\mathsf{Setup},\\mathsf{Eval},\\mathsf{Combine}</span>) who satisfy a consistency property.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\kappa},n,t)\\to((sk_{1},\\ldots,sk_{n}),pp)</span>. The setup algorithm generates <span class="math">n</span> secret keys (<span class="math">sk_{1}</span>, <span class="math">sk_{2}</span>, <span class="math">\\ldots</span>, <span class="math">sk_{n}</span>) and public parameters <span class="math">pp</span>. The <span class="math">i</span>-th secret key <span class="math">sk_{i}</span> is given to party <span class="math">i</span>.</li>

      <li><span class="math">\\mathsf{Eval}(sk_{i},x,pp)\\to z_{i}</span>. The <span class="math">\\mathsf{Eval}</span> algorithm generates pseudo-random shares for a given value. Party <span class="math">i</span> computes the <span class="math">i</span>-th share <span class="math">z_{i}</span> for a value <span class="math">x</span> by running <span class="math">\\mathsf{Eval}</span> with <span class="math">sk_{i}</span>, <span class="math">x</span> and <span class="math">pp</span>.</li>

      <li><span class="math">\\mathsf{Combine}(\\{(i,z_{i})\\}_{i\\in S},pp)=:z/\\bot</span>. The <span class="math">\\mathsf{Combine}</span> algorithm combines the partial shares <span class="math">\\{z_{i}\\}_{i\\in S}</span> from parties in the set <span class="math">S</span> to generate a value <span class="math">z</span>. If the algorithm fails, its output is denoted by <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">Consistency. For any <span class="math">n,t\\in\\mathbb{N}</span> such that <span class="math">t\\leq n</span>, all <span class="math">((sk_{1},\\ldots,sk_{n}),pp)</span> generated by <span class="math">\\mathsf{Setup}(1^{\\kappa},n,t)</span>, any input <span class="math">x</span>, any two sets <span class="math">S,S^{\\prime}\\subset[n]</span> of size at least <span class="math">t</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Combine}(\\{(i,z_{i})\\}_{i\\in S},pp)=\\mathsf{Combine}(\\{(j,z_{j}^{\\prime})\\}_{j\\in S^{\\prime}},pp)\\neq\\bot]\\geq 1-\\mathsf{negl}(\\kappa),</span></p>

    <p class="text-gray-300">where <span class="math">z_{i}\\leftarrow\\mathsf{Eval}(sk_{i},x,pp)</span> for <span class="math">i\\in S</span>, <span class="math">z_{j}^{\\prime}\\leftarrow\\mathsf{Eval}(sk_{j},x,pp)</span> for <span class="math">j\\in S^{\\prime}</span>, and the probability is over the randomness used by <span class="math">\\mathsf{Eval}</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 5.2 (Security of DPRF)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{DP}</span> be a distributed pseudo-random function. We say that <span class="math">\\mathsf{DP}</span> is <em>secure</em> against malicious adversaries if it satisfies the pseudorandomness requirement (Def. 5.3). Also, we say that <span class="math">\\mathsf{DP}</span> is <em>strongly-secure</em> against malicious adversaries if it satisfies both the pseudorandomness and correctness (Def. 5.4) requirements.</p>

    <p class="text-gray-300">A DPRF is <em>pseudorandom</em> if no adversary can guess the PRF value on an input for which it hasn’t obtained shares from at least <span class="math">t</span> parties. It is <em>correct</em> if no adversary can generate shares which lead to an incorrect PRF value. We define these properties formally below.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 5.3 (Pseudorandomness)</h6>

    <p class="text-gray-300">A DPRF <span class="math">\\mathsf{DP}:=(\\mathsf{Setup},\\mathsf{Eval},\\mathsf{Combine})</span> is <em>pseudorandom</em> if for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\mathsf{PseudoRand}_{\\mathsf{DP},\\mathcal{A}}(1^{\\kappa},0)=1\\right]-\\Pr\\left[\\mathsf{PseudoRand}_{\\mathsf{DP},\\mathcal{A}}(1^{\\kappa},1)=1\\right]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{negl}(\\kappa),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{PseudoRand}</span> is defined below.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PseudoRand}_{\\mathsf{DP},\\mathcal{A}}(1^{\\kappa},b)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialization.</em> Run <span class="math">\\mathsf{Setup}(1^{\\kappa},n,t)</span> to get <span class="math">((sk_{1},\\ldots,sk_{n}),pp)</span>. Give <span class="math">pp</span> to <span class="math">\\mathcal{A}</span>. Initialize a list <span class="math">L:=\\emptyset</span> to record the set of values for which <span class="math">\\mathcal{A}</span> may know the PRF outputs.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Corruption.</em> Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><t<span class="math">. Give the secret keys </span>\\{sk_{i}\\}_{i\\in C}<span class="math"> of these parties to </span>\\mathcal{A}<span class="math">. Define the corruption <em>gap</em> as </span>g:=t-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Pre-challenge evaluation queries.</em> In response to <span class="math">\\mathcal{A}</span>’s evaluation query <span class="math">(\\mathsf{Eval},x,i)</span> for some <span class="math">i\\in[n]\\setminus C</span>, return <span class="math">\\mathsf{Eval}(sk_{i},x,pp)</span> to <span class="math">\\mathcal{A}</span>. Repeat this step as many times as <span class="math">\\mathcal{A}</span> desires.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Build the list. Add an <span class="math">x</span> to <span class="math">L</span> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i \\mid \\mathcal{A} \\text{ made a } (\\mathsf{Eval}, x, i) \\text{ query}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq g<span class="math">. In other words, if </span>\\mathcal{A}<span class="math"> contacts at least </span>g<span class="math"> honest parties on a value </span>x<span class="math">, it has enough information to compute the PRF output on </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Post-challenge evaluation queries. Same as the pre-challenge phase except that if <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">(\\mathsf{Eval}, x^{\\star}, i)</span> for some <span class="math">i \\in [n] \\setminus C</span> and <span class="math">i</span> is the <span class="math">g</span>-th party it contacted, then output 0 and stop.</li>

      <li>Guess. Finally, <span class="math">\\mathcal{A}</span> returns a guess <span class="math">b&#x27;</span>. Output <span class="math">b&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 5.4 (Correctness)</strong> A DPRF <span class="math">\\mathsf{DP} := (\\mathsf{Setup}, \\mathsf{Eval}, \\mathsf{Combine})</span> is correct if for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that the following game outputs 1 with probability at least <span class="math">1 - \\mathsf{negl}(\\kappa)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. Run <span class="math">\\mathsf{Setup}(1^{\\kappa}, n, t)</span> to get <span class="math">((sk_1, \\ldots, sk_n), pp)</span>. Give <span class="math">pp</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Corruption. Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">. Give the secret-keys </span>\\{sk_i\\}_{i \\in C}<span class="math"> of these parties to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Evaluation. In response to <span class="math">\\mathcal{A}</span>'s evaluation query <span class="math">(\\mathsf{Eval}, x, i)</span> for some <span class="math">i \\in [n] \\setminus C</span>, return <span class="math">\\mathsf{Eval}(sk_i, x, pp)</span> to <span class="math">\\mathcal{A}</span>. Repeat this step as many times as <span class="math">\\mathcal{A}</span> desires.</li>

      <li>Computation. Receive a set <span class="math">S</span> of size at least <span class="math">t</span>, an input <span class="math">x^{\\star}</span>, and shares <span class="math">\\{(i, z_i^{\\star})\\}_{i \\in S \\cap C}</span> from <span class="math">\\mathcal{A}</span>. Let <span class="math">z_j \\gets \\mathsf{Eval}(sk_j, x^{\\star}, pp)</span> for <span class="math">j \\in S</span> and <span class="math">z_i&#x27; \\gets \\mathsf{Eval}(sk_i, x^{\\star}, pp)</span> for <span class="math">i \\in S \\setminus C</span>. Also, let <span class="math">z := \\mathsf{Combine}(\\{(j, z_j)\\}_{j \\in S}, pp)</span> and <span class="math">z^{\\star} := \\mathsf{Combine}(\\{(i, z_i&#x27;)\\}_{i \\in S \\setminus C} \\cup \\{(i, z_i^{\\star})\\}_{i \\in S \\cap C}, pp)</span>. Output 1 if <span class="math">z^{\\star} \\in \\{z, \\bot\\}</span>; else, output 0.</li>

    </ul>

    <p class="text-gray-300">In this section, we introduce threshold symmetric-key encryption (TSE) and formalize notions of correctness, message privacy, and authenticity for such schemes. We start by specifying the algorithms that constitute a TSE scheme.</p>

    <p class="text-gray-300"><strong>Definition 6.1 (Threshold Symmetric-key Encryption)</strong> A threshold symmetric-key encryption scheme TSE is given by a tuple (Setup, DistEnc, DistDec) that satisfies the consistency property below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\kappa}, n, t) \\to (\\llbracket \\mathbf{sk} \\rrbracket_{[n]}, pp)</span>: Setup is a randomized algorithm that takes the security parameter as input, and outputs <span class="math">n</span> secret keys <span class="math">sk_1, \\ldots, sk_n</span> and public parameters <span class="math">pp</span>. The <span class="math">i</span>-th secret key <span class="math">sk_i</span> is given to party <span class="math">i</span>.</li>

      <li><span class="math">\\mathsf{DistEnc}(\\llbracket \\mathbf{sk}\\rrbracket_{[n]}, [j : m, S], pp) \\to [j : c / \\bot]</span>: <span class="math">\\mathsf{DistEnc}</span> is a distributed protocol through which a party <span class="math">j</span> encrypts a message <span class="math">m</span> with the help of parties in a set <span class="math">S</span>. At the end of the protocol, <span class="math">j</span> outputs a ciphertext <span class="math">c</span> (or <span class="math">\\bot</span> to denote failure). All the other parties have no output.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DistDec<span class="math">([\\![\\mathbf{sk}]\\!]_{[n]},[j:c,S],pp)\\to[j:m/\\bot]</span> : DistDec is a distributed protocol through which a party <span class="math">j</span> decrypts a ciphertext <span class="math">c</span> with the help of parties in a set <span class="math">S</span>. At the end of the protocol, <span class="math">j</span> outputs a message <span class="math">m</span> (or <span class="math">\\bot</span> to denote failure). All the other parties have no output.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consistency. For any <span class="math">n,t\\in\\mathbb{N}</span> such that <span class="math">t\\leq n</span>, all <span class="math">([\\![\\mathbf{sk}]\\!]_{[n]},pp)</span> output by <span class="math">\\mathsf{Setup}(1^{\\kappa})</span>, for any message <span class="math">m</span>, any two sets <span class="math">S,S^{\\prime}\\subset[n]</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math">, and any two parties </span>j\\in S,j^{\\prime}\\in S^{\\prime}<span class="math">, if all the parties behave honestly, then there exists a negligible function </span>\\mathsf{negl}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[[j^{\\prime}:m]\\leftarrow\\mathsf{DistDec}([\\![\\mathbf{sk}]\\!]_{[n]},[j^{\\prime}:c,S^{\\prime}],pp)\\ \\ \\right.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">[j:c]\\leftarrow\\mathsf{DistEnc}([\\![\\mathbf{sk}]\\!]_{[n]},[j:m,S],pp)\\right]\\geq 1-\\mathsf{negl}(\\kappa),</span></p>

    <p class="text-gray-300">where the probability is over the random coin tosses of the parties involved in DistEnc and DistDec.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 6.2 (Security of TSE)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{TSE}</span> be a threshold symmetric-key encryption scheme. We say that <span class="math">\\mathsf{TSE}</span> is <em>(strongly)-secure</em> against malicious adversaries if it satisfies the (strong)-correctness (Def. 6.4), message privacy (Def. 6.6) and (strong)-authenticity (Def. 6.8) requirements.</p>

    <p class="text-gray-300">In the security requirements that follow, the adversary is allowed to make encryption and decryption queries. In a query, it will specify a special party <span class="math">j</span> who will initiate the protocol, a set of parties whom <span class="math">j</span> will contact, and the input of <span class="math">j</span> (message or ciphertext). The protocol will be executed as one would expect: challenger will play the role of all parties not in the control of adversary and exchange messages with it on their behalf. If <span class="math">j</span> is honest, then challenger will initiate the protocol, otherwise, the adversary will initiate it. For 2-round protocols, the interaction between the challenger and adversary will be quite simple. If <span class="math">j</span> is honest, then the challenger will send every message intended for a corrupt party to the adversary on behalf of <span class="math">j</span> and wait to get a response from it. Challenger will then combine the response together with the response of honest parties (which it generates itself) to get the final output. On the other hand, when <span class="math">j</span> is corrupt, the challenger is just supposed to respond to the messages that adversary sends to the honest parties.</p>

    <p class="text-gray-300">From here on, we will not be explicit about the details of a protocol execution. We will just state that an instance of encryption or decryption protocol is run when adversary requests for it. Also note that although all the games below have separate encryption and decryption phases, this is only to make the definitions easy to read. The adversary is not restricted in this sense and can alternate between encryption and decryption queries.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 6.3 (Relation with standard definitions)</h6>

    <p class="text-gray-300">Note that our security notion can also be thought of as a generalization of standard (non-interactive) authenticated encryption. In particular, setting <span class="math">n=1</span> and <span class="math">t=0</span> one gets standard CPA-security from our message privacy definition (Def. 6.6) and standard ciphertext integrity from our authenticity definition (Def. 6.8).</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">6.1 Correctness</h3>

    <p class="text-gray-300">A TSE scheme is correct if whenever DistEnc outputs a ciphertext <span class="math">c</span> for an input message <span class="math">m</span> (i.e., it does not fail), then DistDec outputs either <span class="math">m</span> or <span class="math">\\bot</span> when run with <span class="math">c</span> as input.</p>

    <p class="text-gray-300">An adversary should not be able to influence the decryption protocol to produce a message different from <span class="math">m</span>. We also consider <em>strong-correctness</em> which additionally requires that <span class="math">c</span> should only decrypt to <span class="math">m</span> (not even <span class="math">\\bot</span>) when decryption is performed honestly.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 6.4 (Correctness)</h6>

    <p class="text-gray-300">A TSE scheme <span class="math">\\mathsf{TSE}:=(\\mathsf{Setup},\\mathsf{DistEnc},\\mathsf{DistDec})</span> is <em>correct</em> if for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that the following game outputs <span class="math">1</span> with probability at least <span class="math">1-\\mathsf{negl}(\\kappa)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialization.</em> Run <span class="math">\\mathsf{Setup}(1^{\\kappa})</span> to get <span class="math">(\\llbracket\\mathbf{sk}\\rrbracket_{[n]},pp)</span>. Give <span class="math">pp</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Corruption.</em> Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><t<span class="math">. Give the secret-keys </span>\\{sk_{i}\\}_{i\\in C}<span class="math"> of these parties to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <em>Decryption.</em> Receive <span class="math">(\\mathsf{Decrypt},j^{\\prime},S^{\\prime})</span> from <span class="math">\\mathcal{A}</span> where <span class="math">j^{\\prime}\\in S^{\\prime}\\setminus C</span> and $</td>

            <td class="px-3 py-2 border-b border-gray-700">S^{\\prime}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq t<span class="math">. Initiate the protocol </span>\\mathsf{DistDec}<span class="math"> from party </span>j^{\\prime}<span class="math"> with inputs </span>c<span class="math">, </span>S^{\\prime}<span class="math"> and </span>pp$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Output.</em> Output <span class="math">1</span> if and only if <span class="math">j^{\\prime}</span> outputs <span class="math">m</span> or <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">A <em>strongly-correct</em> TSE scheme is a correct TSE scheme but with a different output step. Specifically, output <span class="math">1</span> if and only if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If all parties in <span class="math">S^{\\prime}</span> behave honestly, then <span class="math">j^{\\prime}</span> outputs <span class="math">m</span>; or,</li>

      <li>If corrupt parties in <span class="math">S^{\\prime}</span> deviate from the protocol, then <span class="math">j^{\\prime}</span> outputs <span class="math">m</span> or <span class="math">\\bot</span>.</li>

    </ul>

    <h6 id="sec-40" class="text-base font-medium mt-4">Remark 6.5 (Correctness for different applications)</h6>

    <p class="text-gray-300">In applications like key management, ciphertexts generated at some point may be decrypted much later when the plaintext is no longer available. In such cases, malformed ciphertexts must be immediately detected, hence strong correctness is needed. In applications like network authentication (Kerberos) or IoT-based payments where ciphertexts are typically decrypted shortly after encryption, the weaker notion of TSE suffices. In such cases, the outcome of decryption is known immediately and, if it is a failure, one can run another encryption session with a different set of parties.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">6.2 Message privacy</h3>

    <p class="text-gray-300">We allow for two types of encryption queries in the message privacy game: 1) the adversary can initiate an encryption session to obtain both the final ciphertext as well as the transcripts of the parties it corrupts. 2) it can make an <em>indirect</em> encryption query where it invokes an honest party to initiate an encryption session using a message of its choice. To make the definition stronger, we provide the ciphertext output by the honest party to the adversary.</p>

    <p class="text-gray-300">However, this alone is not sufficient to capture full message privacy in the distributed setting. A <em>decryption session</em> initiated by an honest party on any ciphertext of adversary’s choice (including the challenge) should not reveal what the decrypted message is either. Thus, we must allow the adversary to make such queries as well.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 6.6 (Message privacy)</h6>

    <p class="text-gray-300">A TSE scheme <span class="math">\\mathsf{TSE}:=(\\mathsf{Setup},\\mathsf{DistEnc},\\mathsf{DistDec})</span> satisfies <em>message privacy</em> if for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathrm{Pr}\\left[\\mathsf{MsgPriv}_{\\mathsf{TSE},\\mathcal{A}}(1^{\\kappa},0)=1\\right]-\\mathrm{Pr}\\left[\\mathsf{MsgPriv}_{\\mathsf{TSE},\\mathcal{A}}(1^{\\kappa},1)=1\\right]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\mathsf{negl}(\\kappa),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{MsgPriv}</span> is defined below.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{MsgPriv}_{\\mathsf{TSE},\\mathcal{A}}(1^{\\kappa},b)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialization.</em> Run <span class="math">\\mathsf{Setup}(1^{\\kappa},n,t)</span> to get <span class="math">(\\llbracket\\mathsf{sk}\\rrbracket_{[n]},pp)</span>. Give <span class="math">pp</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Corruption.</em> Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><t<span class="math">. Give the secret keys </span>\\{sk_{i}\\}_{i\\in C}<span class="math"> of these parties to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <em>Pre-challenge indirect decryption queries.</em> In response to <span class="math">\\mathcal{A}</span>’s decryption query <span class="math">(\\mathsf{Decrypt},j,c,S)</span>, where <span class="math">j\\in S\\setminus C</span> and $</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq t<span class="math">, party </span>j<span class="math"> initiates </span>\\mathsf{DistDec}<span class="math"> with inputs </span>c<span class="math"> and </span>S<span class="math">. Repeat this step as many times as </span>\\mathcal{A}$ desires.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <em>Challenge.</em> <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\mathsf{Challenge},j^{\\star},m_{0},m_{1},S^{\\star})</span> where $</td>

            <td class="px-3 py-2 border-b border-gray-700">m_{0}</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">m_{1}</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">, </span>j^{\\star}\\in S^{\\star}\\setminus C<span class="math"> and </span></td>

            <td class="px-3 py-2 border-b border-gray-700">S^{\\star}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq t<span class="math">. Initiate the protocol </span>\\mathsf{DistEnc}<span class="math"> from party </span>j^{\\star}<span class="math"> with inputs </span>m_{b}<span class="math"> and </span>S^{\\star}<span class="math">. Give </span>c^{\\star}<span class="math"> (or </span>\\bot<span class="math">) output by </span>j^{\\star}<span class="math"> as the challenge to </span>\\mathcal{A}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Post-challenge encryption queries.</em> Repeat pre-challenge encryption phase.</li>

      <li><em>Post-challenge indirect decryption queries.</em> Repeat pre-challenge decryption phase.</li>

      <li><em>Guess.</em> Finally, <span class="math">\\mathcal{A}</span> returns a guess <span class="math">b^{\\prime}</span>. Output <span class="math">b^{\\prime}</span>.</li>

    </ul>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 6.7</h6>

    <p class="text-gray-300">When <span class="math">\\mathsf{DistEnc}</span> is run in the challenge phase with <span class="math">S^{\\star}\\cap C\\neq\\emptyset</span>, corrupt parties can easily cause the protocol to fail, leading <span class="math">j^{\\star}</span> to output <span class="math">\\bot</span>. The definition above ensures that the probability that this happens cannot depend on the message <span class="math">m_{b}</span>.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">6.3 Authenticity</h3>

    <p class="text-gray-300">As discussed in the overview section (Section 2.1), we cannot directly generalize the standard (non-interactive) authenticity definition to our setting for multiple reasons. First, the ability to make decryption queries gives additional power to the adversary. Second, ciphertexts generated in indirect encryption and decryption queries should remain unpredictable to the adversary or else they would enable successful forgeries. Thus, the definition we present below departs significantly from the non-interactive version.</p>

    <p class="text-gray-300">In the definition, the variable <span class="math">g</span> captures the minimum number of honest parties an adversary must contact in order to get enough information to generate one ciphertext. The variable <span class="math">\\mathsf{ct}</span> counts the total number of times honest parties are contacted in encryption/decryption protocols initiated by corrupt parties. Thus, the definition requires that an efficient adversary should only be able to produce <span class="math">\\lfloor\\mathsf{ct}/g\\rfloor</span> ciphertexts at the end of the game.</p>

    <p class="text-gray-300">We present two variants of the definition. In the first notion, the forged ciphertexts output by an adversary at the end of the game are decrypted in an honest manner, i.e., all the parties involved in decryption follow the protocol. On the other hand, our stronger authenticity notion allows the adversary to influence the decryption process. A forged ciphertext that may otherwise not decrypt successfully, could be decryptable if corrupt parties manipulate their responses. Thus, there could be ciphertexts that are valid forgeries in the strong authenticity game but not in the standard one.</p>

    <p class="text-gray-300">Recall that a targeted decryption query provides a way for an adversary to ask an honest party to initiate a decryption session on a ciphertext that was previously generated by some honest party, since such a ciphertext may not be available to the adversary. Just as in regular encryption/decryption sessions initiated by honest parties, the counter ct is not updated in a targeted decryption session because we want to capture that the adversary does not get any useful information towards generating new ciphertexts in such a session.</p>

    <p class="text-gray-300"><strong>Definition 6.8 (Authenticity)</strong> A TSE scheme <span class="math">\\mathsf{TSE} := (\\mathsf{Setup}, \\mathsf{DistEnc}, \\mathsf{DistDec})</span> satisfies <em>authenticity</em> if for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf{AUTH}_{\\mathsf{TSE}, \\mathcal{A}} (1^{\\kappa}) = 1 \\right] \\leq \\mathsf{negl}(\\kappa),</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{AUTH}</span> is defined below.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AUTH}_{\\mathsf{TSE}, \\mathcal{A}}(1^{\\kappa})</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Initialization</em>. Run <span class="math">\\mathsf{Setup}(1^{\\kappa}, n, t)</span> to get <span class="math">(\\llbracket \\mathbf{sk} \\rrbracket_{[n]}, pp)</span>. Give <span class="math">pp</span> to <span class="math">\\mathcal{A}</span>. Initialize a counter <span class="math">\\mathsf{ct} := 0</span> and an <em>ordered</em> list <span class="math">L_{\\mathsf{ctxt}} := \\emptyset</span>. Below, we assume that for every query, the <span class="math">(j, S)</span> output by <span class="math">\\mathcal{A}</span> are such that <span class="math">j \\in S</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <em>Encryption queries</em>. On receiving <span class="math">(\\mathsf{Encrypt}, j, m, S)</span> from <span class="math">\\mathcal{A}</span>, run the protocol <span class="math">\\mathsf{DistEnc}</span> with <span class="math">m, S</span> as the inputs of <span class="math">j</span>. If <span class="math">j \\in C</span>, increment <span class="math">\\mathsf{ct}</span> by $</td>

            <td class="px-3 py-2 border-b border-gray-700">S \\setminus C</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> (number of honest parties in </span>S<span class="math">). Else, append the ciphertext output by </span>j<span class="math"> to </span>L_{\\mathsf{ctxt}}$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <em>Decryption queries</em>. On receiving <span class="math">(\\mathsf{Decrypt}, j, c, S)</span> from <span class="math">\\mathcal{A}</span>, run the protocol <span class="math">\\mathsf{DistDec}</span> with <span class="math">c, S</span> as the inputs of <span class="math">j</span>. If <span class="math">j \\in C</span>, increment <span class="math">\\mathsf{ct}</span> by $</td>

            <td class="px-3 py-2 border-b border-gray-700">S \\setminus C</td>

            <td class="px-3 py-2 border-b border-gray-700">$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Targeted decryption queries</em>. On receiving <span class="math">(\\mathsf{TargetDecrypt}, j, \\ell, S)</span> from <span class="math">\\mathcal{A}</span> for some <span class="math">j \\in S \\setminus C</span>, run <span class="math">\\mathsf{DistDec}</span> with <span class="math">c, S</span> as the inputs of <span class="math">j</span>, where <span class="math">c</span> is the <span class="math">\\ell</span>-th ciphertext in <span class="math">L_{\\mathsf{ctxt}}</span>.</li>

      <li><em>Forgery</em>. Let <span class="math">k := \\lfloor \\mathsf{ct} / g \\rfloor</span>. <span class="math">\\mathcal{A}</span> outputs <span class="math">((j_1, S_1, c_1), (j_2, S_2, c_2), \\ldots, (j_{k+1}, S_{k+1}, c_{k+1}))</span> such that <span class="math">j_1, \\ldots, j_{k+1} \\notin C</span> and <span class="math">c_u \\neq c_v</span> for any <span class="math">u \\neq v \\in [k+1]</span> (ciphertexts are not repeated). For every <span class="math">i \\in [k+1]</span>, run an instance of <span class="math">\\mathsf{DistDec}</span> with <span class="math">c_i, S_i</span> as the input of party <span class="math">j_i</span>. In that instance, all parties in <span class="math">S_i</span> behave honestly. Output 0 if any <span class="math">j_i</span> outputs <span class="math">\\perp</span>; else output 1.</li>

    </ul>

    <p class="text-gray-300">A TSE scheme satisfies <em>strong-authenticity</em> if it satisfies authenticity but with a slightly modified <span class="math">\\mathsf{AUTH}</span>: In the forgery phase, the restriction on corrupt parties in <span class="math">S_i</span> to behave honestly is removed (for all <span class="math">i \\in [k + 1]</span>).</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">Remark 6.9 (Authenticity for different applications)</p>

    <p class="text-gray-300">When protecting data at rest, an application may require that both encryption and decryption are distributed. If adversary can also interfere with decryption, the stronger version of authenticity should be used. In case of authentication tokens generated for an external service, the decryption is likely to be performed by a third party who holds the full key in a secure environment. Hence, the weaker notion of authenticity may suffice.</p>

    <p class="text-gray-300">As we will see later, our TSE construction requires a stronger property from the underlying DPRF to achieve the stronger form of authenticity and as a result require the use of zero-knowledge proofs, but the normal form of authenticity can be achieved without it.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Remark 6.10 (Integrity of plaintexts)</h6>

    <p class="text-gray-300">In the non-interactive setting for authenticated encryption, a weaker form of INT-CTXT, called integrity of plaintexts (INT-PTXT) <em>[x1]</em>, has also been studied. If a forged ciphertext decrypts to a message encrypted earlier by the adversary, then it is not considered a valid forgery in the INT-PTXT game. One can also weaken our authenticity definition in a similar fashion: a sequence of <span class="math">\\ell</span> forgeries would be accepted only if they decrypt to <span class="math">\\ell</span> unique messages. See Lemma 7.5 for how this notion comes up in the distributed setting.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 6.11 (Updating counter for decryption)</h6>

    <p class="text-gray-300">In our current authenticity definitions, we increment the counter ct only for decryption queries initiated by the adversary (not for indirect or targeted queries), implying that a ciphertext the adversary could deduce from such an interaction is not considered a successful forgery. Though it may seem at first that we are increasing the attack surface (note that direct encryption queries are already counted towards this), the extra information leakage may not make a significant difference in practice, especially when applications restrict and/or log who initiates decryption and what can be decrypted by whom.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One can modify our construction to satisfy an even stronger notion where even decryption queries initiated by the adversary are not counted towards its forgery budget. For example, in parallel to evaluating the DPRF on $j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha$, a threshold signature on the same input can be computed. Then, during decryption, parties first check the validity of the signature before responding with their partial share of the DPRF value. However, adding an invocation of a threshold signature scheme to DiSE would be a significant overhead and would eliminate the possibility of a symmetric-key only solution.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-47" class="text-2xl font-bold">7 Our Construction: DiSE</h2>

    <p class="text-gray-300">In this section, we put forward our main construction DiSE, based on any DPRF. A full description of the construction is provided in Figure 2. (See Section 2.2 for an overview.) We prove that if the DPRF is (strongly) secure, then DiSE is (strongly) secure too. We provide concrete DPRF instantiations in Section 8.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 7.1</h6>

    <p class="text-gray-300">The TSE scheme DiSE of Figure 2 is (strongly)-secure if the underlying DPRF DP is (strongly)-secure.</p>

    <p class="text-gray-300">Proof. We show each property of DiSE separately.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Consistency.</h4>

    <p class="text-gray-300">Recall that consistency is required only when all the parties behave honestly. Thus, consistency of DiSE follows easily from the consistency of DP.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: DiSE: our threshold symmetric-key encryption protocol.</p>

    <p class="text-gray-300">Proof. A TSE scheme is correct if whenever an honest party  <span class="math">j</span>  initiates DistEnc on a message  <span class="math">m</span>  to obtain a ciphertext  <span class="math">c</span>  (i.e., DistEnc does not fail), any honest party  <span class="math">j&#x27;</span>  recovers  <span class="math">m</span>  itself (or  <span class="math">\\bot</span> ) when it runs DistDec with  <span class="math">c</span>  as input (except with negligible probability). In the protocol DiSE,  <span class="math">c</span>  is of the form  <span class="math">(j, \\alpha, e)</span>  where  <span class="math">\\alpha := \\mathsf{Com}(m, pp_{\\mathsf{com}}; \\rho)</span>  is generated locally. Any decryptor must verify that the message  <span class="math">m&#x27;</span>  and randomness  <span class="math">\\rho&#x27;</span>  that it recovers (if Combine does not fail) satisfy  <span class="math">\\alpha = \\mathsf{Com}(m&#x27;, pp_{\\mathsf{com}}; \\rho&#x27;)</span>  or not. If  <span class="math">\\Sigma</span>  is a binding commitment scheme, then this verification succeeds only if  <span class="math">m = m&#x27;</span> , except with negligible probability.</p>

    <p class="text-gray-300">Lemma 7.3 (Strong-correctness) If DP satisfies the correctness property, then DiSE is a strongly-correct TSE scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. For a TSE scheme to be strongly-correct, we also need that if all the parties involved in decryption behave honestly, then a ciphertext  <span class="math">c \\coloneqq (j, \\alpha, e)</span> , where  $e \\coloneqq \\mathsf{PRG}(w) \\oplus (m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math"> , generated by an honest party (possibly involving some corrupt parties) should decrypt to the right message with high probability. Now the correctness property of DP guarantees that if all the parties involved in decryption are honest  </span>w'<span class="math">  obtained through Combine during decryption will be the same as the  </span>w<span class="math">  obtained during encryption except with negligible probability (as the input to the DPRF is the same  </span>j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha<span class="math"> ). Therefore,  </span>\\mathsf{PRG}(w') \\oplus e<span class="math">  in the last step of decryption would give  </span>\\mathsf{PRG}(w') \\oplus \\mathsf{PRG}(w) \\oplus (m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho) = m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the following three lemma, we provide a sketch here and defer formal proofs to Appendix C.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 7.4 (Message privacy)</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{DP}</span> is a secure DPRF, then DiSE is a message-private TSE scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof sketch. The challenge ciphertext <span class="math">c^{\\star}</span> has the form <span class="math">(j^{\\star},\\alpha^{\\star},e^{\\star})</span> where $e^{\\star}=\\mathsf{PRG}(w^{\\star})\\oplus(m_{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho^{\\star})<span class="math">, </span>\\alpha^{\\star}=\\mathsf{Com}(m_{b},pp_{\\mathsf{com}};\\rho^{\\star})<span class="math"> and </span>w^{\\star}<span class="math"> is the output of DPRF </span>\\mathsf{DP}<span class="math"> on </span>j^{\\star}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}<span class="math">. One can think about the masking with PRG as a symmetric-key encryption using a stream cipher. So, an adversary </span>\\mathcal{A}<span class="math"> will find it computationally hard to guess </span>b<span class="math"> if </span>w^{\\star}<span class="math"> is indistinguishable from random. The pseudorandomness property of </span>\\mathsf{DP}<span class="math"> ensures this as long as </span>\\mathcal{A}<span class="math"> has no way of evaluating the DPRF on </span>j^{\\star}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}<span class="math"> itself. (Note that </span>\\alpha^{\\star}<span class="math"> does not reveal information about </span>m_{b}<span class="math"> due to the hiding property of </span>\\Sigma$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If a corrupt party initiates an encryption protocol, then <span class="math">\\mathcal{A}</span> can learn $j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}<span class="math"> for any </span>j<span class="math"> because </span>\\alpha^{\\star}<span class="math"> is not hidden from it, but </span>j<span class="math"> would never be equal to </span>j^{\\star}<span class="math"> since </span>j^{\\star}<span class="math"> is an honest party. On the other hand, even if </span>\\mathcal{A}<span class="math"> asks party </span>j^{\\star}<span class="math"> to initiate encryption, </span>j^{\\star}<span class="math"> would compute DPRF on a value </span>\\alpha\\neq\\alpha^{\\star}<span class="math"> due to the binding property of </span>\\Sigma<span class="math">. As a result, no matter how an encryption query is crafted, </span>\\mathcal{A}<span class="math"> cannot compute the DPRF on </span>j^{\\star}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}$. See Appendix C.1 for a detailed proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 7.5 (Authenticity)</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{DP}</span> is a secure DPRF, then DiSE is a TSE scheme that satisfies authenticity.</p>

    <p class="text-gray-300">Proof sketch. Among the forged ciphertexts output by adversary, suppose there are two ciphertexts <span class="math">c_{1}</span>, <span class="math">c_{2}</span> (<span class="math">c_{1}\\neq c_{2}</span>) with the same <span class="math">j</span> and commitment <span class="math">\\alpha</span>. When these two are decrypted with possibly different sets of parties, the DPRF value recovered would be the same due to the consistency property of <span class="math">\\mathsf{DP}</span> (it is assumed that all parties involved in decryption behave honestly). As a result, <span class="math">(m_{1},\\rho_{1})</span> and <span class="math">(m_{2},\\rho_{2})</span> recovered from <span class="math">c_{1}</span> and <span class="math">c_{2}</span>, respectively, would be different. Due to the binding property of <span class="math">\\Sigma</span>, <span class="math">\\alpha</span> cannot be a commitment to both. Hence, decryption of at least one of <span class="math">c_{1}</span>, <span class="math">c_{2}</span> fails, and <span class="math">\\mathsf{AUTH}</span> outputs <span class="math">0</span>. Therefore, if an adversary must succeed, each of the <span class="math">k+1</span> ciphertexts must have unique <span class="math">(j,\\alpha)</span>.</p>

    <p class="text-gray-300">Recall that a valid adversary is allowed to contact honest parties strictly less than <span class="math">k\\cdot g</span> number of times. So one can find at least one <span class="math">(j,\\alpha)</span> among the forged ciphertexts for which adversary has not contacted <span class="math">g</span> parties. Due to the pseudorandomness property of <span class="math">\\mathsf{DP}</span>, the adversary does not know the value of DPRF on <span class="math">(j,\\alpha)</span>. Hence, it can not produce a valid ciphertext with it.</p>

    <p class="text-gray-300">A detailed proof can be found in Appendix C.2. Note that if parties involved in the decryption of forged ciphertexts are allowed to act maliciously, we cannot invoke DPRF’s consistency property. However, the adversary would still not be able to make sure that <span class="math">c_{1}</span>, <span class="math">c_{2}</span> decrypt successfully to two distinct messages because the commitment is binding. Thus, DiSE can be shown to satisfy a strong notion of an INT-PTXT-style definition in the distributed setting (see Remark 6.10).</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 7.6 (Strong-authenticity)</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{DP}</span> is a strongly-secure DPRF, then DiSE is a TSE scheme that satisfies strong-authenticity.</p>

    <p class="text-gray-300">Proof sketch. Strong authenticity gives additional power to the adversary. In the decryption of forged ciphertexts, corrupt parties can deviate from the protocol arbitrarily. Thus, unlike</p>

    <p class="text-gray-300">above, consistency of DP alone would not suffice. Using both consistency and correctness though, one can argue that even if <span class="math">c_{1}</span>, <span class="math">c_{2}</span> are decrypted with different sets of parties, the recovered DPRF values <span class="math">w_{1}</span>, <span class="math">w_{2}</span> are either the same or <span class="math">\\bot</span>. In the latter case, AUTH clearly outputs 0, and, in the former, it outputs 0 for the same reason as above.</p>

    <p class="text-gray-300">The rest of the proof is similar to the one for weak-authenticity with some minor changes in how the pseudorandomness guarantee is reduced to authenticity. See Appendix C.3 for more details.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 7.7 (Key-management application)</h6>

    <p class="text-gray-300">As discussed in the introduction (c.f. Section 1), a main motivation of this work is to strengthen the security of key-management applications like Hashicorp Vault <em>[x20]</em>. For such applications, DiSE should be viewed as distributing the role of the key-manager itself. Multiple servers would keep shares of the master secret key (which is used to encrypt various types of secrets) and know about each other’s identity. Clients of the key-management application would need to authenticate via a separate mechanism.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Remark 7.8 (Other definitions of security)</h6>

    <p class="text-gray-300">Through Theorem 7.1, we study two forms of security for TSE in this paper. The stronger form combines strong correctness with strong authenticity and the normal form combines their normal versions. One could consider other possibilities too like combining strong correctness with normal authenticity. The exact requirements would depend on the application for which TSE is being used (see remarks 6.5 and 6.9).</p>

    <h2 id="sec-56" class="text-2xl font-bold">8 Instantiations of Distributed Pseudorandom Functions</h2>

    <p class="text-gray-300">In this section, we revisit the distributed pseudo-random function (DPRF) constructions of Naor, Pinkas, and Reingold <em>[x22]</em> (henceforth NPR) and study the properties defined in Section 5.</p>

    <p class="text-gray-300">NPR proposed two different instantiations of DPRF, one based on the decisional Diffie-Hellman assumption (DDH) and another based on any PRF. They showed that their constructions are secure against semi-honest adversaries, and briefly discussed how the first construction (DDH-based) could be extended to the malicious setting. Below, we present the two instantiations in their original form, and show that both achieve our pseudorandomness requirement against malicious adversaries (Def. 5.3). As discussed in Section 5, our definition captures several attacks that were not considered before. Thus, the proofs require significantly more care. Further, building on the idea mentioned in NPR, we strengthen the DDH-based construction with a NIZK proof (specifically, Schnorr’s proof <em>[x25, x10]</em> via the Fiat-Shamir transform <em>[x12]</em>) to obtain <em>strong security</em>. However, it turns out that in addition to the application of NIZKs, we need to use trapdoor commitments to commit to secret key shares of parties in order to achieve our stronger pseudorandomness property. We also briefly discuss how to strengthen the PRF-based construction to make it strongly secure using only symmetric-key primitives.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">8.1 DDH-based construction</h3>

    <p class="text-gray-300">NPR’s first DPRF is based on any multiplicative group <span class="math">G</span> of prime order <span class="math">p</span> in which DDH holds. The PRF functionality being computed collectively can be written as <span class="math">f_{s}(x)=H(x)^{s}</span>,</p>

    <p class="text-gray-300">where  <span class="math">H:\\{0,1\\}^{*}\\to G</span>  is a hash function (modeled as a random oracle) and the key is  <span class="math">s\\in \\mathbb{Z}_p</span> . To distribute the evaluation of  <span class="math">f</span> , the secret key  <span class="math">s</span>  must be secret shared between the parties.</p>

    <p class="text-gray-300">In the setup phase, a trusted party samples a master key  <span class="math">s \\gets_{\\mathbb{S}} \\mathbb{Z}_p</span>  and uses Shamir's secret sharing scheme with a threshold  <span class="math">t</span>  to create  <span class="math">n</span>  shares  <span class="math">s_1, \\ldots, s_n</span>  of  <span class="math">s</span> . Share  <span class="math">s_i</span>  is given privately to the party  <span class="math">i</span> . We know that for any set  <span class="math">S</span>  of  <span class="math">\\ell \\geq t</span>  parties  <span class="math">S := \\{i_1, \\dots, i_\\ell\\} \\subseteq [n]</span> , there exists integers (i.e. Lagrange coefficients)  <span class="math">\\lambda_{0,1,S}, \\dots, \\lambda_{0,\\ell,S} \\in \\mathbb{Z}_p</span>  such that  <span class="math">\\sum_{j \\in S} s_{i_j} \\lambda_{0,j,S} = s</span> . Therefore, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {s} (x) = H (x) ^ {s} = H (x) ^ {\\sum_ {j = 1} ^ {\\ell} \\lambda_ {0, j, S} s _ {i _ {j}}} = \\prod_ {i = 1} ^ {\\ell} \\left(H (x) ^ {s _ {i _ {j}}}\\right) ^ {\\lambda_ {0, j, S}},</span></div>

    <p class="text-gray-300">which can be computed in a distributed manner running the protocol  <span class="math">\\Pi_{\\mathsf{DDH - DP}}</span>  as shown in Figure 3. This protocol satisfies the pseudorandomness definition (Def. 5.3), but not the correctness definition (Def. 5.4). Formally we show that:</p>

    <p class="text-gray-300">Parameters: Let  <span class="math">G = \\langle g \\rangle</span>  be a multiplicative cyclic group of prime order  <span class="math">p</span>  in which the DDH assumption holds and  <span class="math">\\mathcal{H} : \\{0,1\\}^* \\to G</span>  be a hash function modeled as a random oracle. Let SSS be Shamir's secret sharing scheme (Def. A.5).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\kappa}, n, t) \\to (\\llbracket \\mathbf{sk} \\rrbracket_{[n]}, pp)</span> : Sample  <span class="math">s \\gets_{\\S} \\mathbb{Z}_p</span>  and get  <span class="math">(s_1, \\ldots, s_n) \\gets \\mathsf{SSS}(n, t, p, s)</span> . Set  <span class="math">pp := (p, g, G)</span>  and  <span class="math">sk_i := s_i</span>  and give  <span class="math">(sk_i, pp)</span>  to party  <span class="math">i</span> , for  <span class="math">i \\in [n]</span> .</li>

      <li><span class="math">\\operatorname{Eval}(sk_i, x, pp) \\to z_i</span> : Compute  <span class="math">w \\coloneqq \\mathcal{H}(x)</span> ,  <span class="math">h_i \\coloneqq w^{sk_i}</span>  and output  <span class="math">h_i</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Combine  <span class="math">(\\{(i, z_i)\\}_{i \\in S}, pp) =: z / \\bot</span>  : If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> , output  </span>\\bot<span class="math"> . Else, parse  </span>z_i<span class="math">  as  </span>(h_i)<span class="math">  for  </span>i \\in S<span class="math"> . Output  </span>\\prod_{i \\in S} h_i^{\\lambda_{0,i,S}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: A secure DPRF protocol  <span class="math">\\Pi_{\\mathsf{DDH - DP}}</span>  based on DDH.</p>

    <p class="text-gray-300">Theorem 8.1 Protocol  <span class="math">\\Pi_{\\mathsf{DDH - DP}}</span>  in Figure 3 is a secure DPRF under the DDH assumption in the programmable random oracle model.</p>

    <p class="text-gray-300">We provide a detailed formal analysis in Appendix C.4. Here we provide a brief sketch. Consistency follows from Shamir's secret sharing in a straightforward way. The pseudorandomness property can be reduced from the hardness of DDH assumption. Intuitively, since the attacker is restricted to get at most  <span class="math">t - 1</span>  evaluations of the secret polynomial for the challenge  <span class="math">x^{\\star}</span> , it does not have enough information whether the returned value in the challenge phase lies on the secret polynomial or not. However, subtleties arise due to the fact that the adversary may obtain more than  <span class="math">t - 1</span>  evaluations through queries on  <span class="math">x \\neq x^{\\star}</span> , and hence the above argument must hold conditioned on those values. Fortunately, via a sequence of hybrids, we can gradually move to a game in which a fresh random polynomial is selected for each different  <span class="math">x</span>  that is correlated with the secret polynomial on up to  <span class="math">\\ell \\leq t - 1</span>  points, where  <span class="math">\\ell</span>  is the number of corrupt parties (as those many secrets can be obtained by the adversary via corruption). Clearly,  <span class="math">t - 1</span>  evaluations point give no information about the secret  <span class="math">(t - 1)</span> -degree polynomial. Therefore, the response on challenge  <span class="math">x^{\\star}</span>  is indistinguishable from random.</p>

    <p class="text-gray-300">Strong security Adding trapdoor commitments and NIZK proofs in the RO model (for a statement slightly different from the one suggested by NPR) appropriately to  <span class="math">\\Pi_{\\mathsf{DDH - DP}}</span> , we obtain the protocol  <span class="math">\\Pi_{\\mathsf{ZK - DDH - DP}}</span> , described in detail in Figure 4. This protocol also satisfies correctness and hence achieves strong security. Formally:</p>

    <p class="text-gray-300">Theorem 8.2 Protocol  <span class="math">\\Pi_{\\mathsf{ZK - DDH - DP}}</span>  in Figure 4 is a strongly secure DPRF under the DDH assumption in the programmable random oracle model.</p>

    <p class="text-gray-300">A detailed proof is provided in Appendix C.5. The proof for pseudorandomness follows the same structure as before. However, to accommodate the changes (trapdoor commitments and NIZK proofs), some additional effort is needed. Note that NIZK proofs are used by each party  <span class="math">i</span>  to show that they use the correct secret-share  <span class="math">s_i</span>  which is committed as  <span class="math">\\gamma_i</span>  in the public parameters. However, since the adversary is allowed to corrupt the parties after obtaining the public parameters, we need trapdoor commitments to make sure that the commitments can be opened to some different values later by the simulator with a trapdoor. The correctness property follows from the extractability of NIZK and binding of commitments.</p>

    <p class="text-gray-300">Parameters: Let  <span class="math">G = \\langle g \\rangle</span>  be a multiplicative cyclic group of prime order  <span class="math">p</span>  in which the DDH assumption holds,  <span class="math">\\mathcal{H} : \\{0,1\\}^<em> \\to G</span>  and  <span class="math">\\mathcal{H}&#x27; : \\{0,1\\}^</em> \\to \\{0,1\\}^{\\mathrm{poly}(n)}</span>  be two hash functions modeled as random oracles. Let SSS be Shamir's secret sharing scheme (Def. A.5), TDC := (Setupcom, Com) be a trapdoor commitment scheme (Def. A.3) and NIZK := (Prove <span class="math">^{\\mathcal{H}&#x27;}</span> , Verify <span class="math">^{\\mathcal{H}&#x27;}</span> ) be a simulation-sound NIZK proof system (Def. A.6).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\kappa}, n, t) \\to (\\llbracket \\mathbf{sk} \\rrbracket_{[n]}, pp)</span> . Sample  <span class="math">s \\gets_{\\S} \\mathbb{Z}_p</span>  and get  <span class="math">(s_1, \\ldots, s_n) \\gets \\mathrm{SSS}(n, t, p, s)</span> . Run Setupcom  <span class="math">(1^{\\kappa})</span>  to get  <span class="math">pp_{\\mathrm{com}}</span> . Compute a commitment  <span class="math">\\gamma_i := \\mathrm{Com}(s_i, pp_{\\mathrm{com}}; r_i)</span>  by picking  <span class="math">r_i</span>  at random. Set  <span class="math">pp = (p, g, G, \\gamma_1, \\ldots, \\gamma_n, pp_{\\mathrm{com}})</span> ,  <span class="math">sk_i := (s_i, r_i)</span>  and give  <span class="math">sk_i</span>  to party  <span class="math">i</span> , for  <span class="math">i \\in [n]</span> .</li>

      <li><span class="math">\\operatorname{Eval}(sk_i, x, pp) \\to z_i</span> . Compute  <span class="math">w := H(x)</span>  and  <span class="math">h_i := w^{s_i}</span> . Run  <span class="math">\\operatorname{Prove}^{\\mathcal{H}&#x27;}</span>  with the statement  <span class="math">\\mathsf{stmt}_i</span> :  <span class="math">\\{\\exists s, r \\text{ s.t. } h_i = w^s \\land \\gamma_i = \\mathsf{Com}(s, pp_{\\mathsf{com}}; r)\\}</span>  and witness  <span class="math">(s_i, r_i)</span>  to obtain a proof  <span class="math">\\pi_i</span> . Output  <span class="math">((w, h_i), \\pi_i)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Combine  <span class="math">\\left(\\left\\{(i, z_i)\\right\\}_{i \\in S}, pp\\right) =: z / \\bot</span> . If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> , output  </span>\\bot<span class="math"> . Else, parse  </span>z_i<span class="math">  as  </span>((w, h_i), \\pi_i)<span class="math">  and check if  </span>\\text{Verify}^{\\mathcal{H}'}(\\text{stmt}_i, \\pi_i) = 1<span class="math">  for all  </span>i \\in S<span class="math"> . If check fails for any  </span>i<span class="math"> , output  </span>\\bot<span class="math"> . Else, output  </span>\\prod_{i \\in S} h_i^{\\lambda_{0,i,S}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: A strongly secure DPRF protocol  <span class="math">\\Pi_{\\mathsf{ZK - DDH - DP}}</span>  based on DDH. Differences from  <span class="math">\\Pi_{\\mathsf{DDH - DP}}</span>  are highlighted in blue.</p>

    <p class="text-gray-300">Parameters: Let  <span class="math">G = \\langle g \\rangle</span>  be a multiplicative cyclic group of prime order  <span class="math">p</span>  in which the DDH assumption holds,  <span class="math">\\mathcal{H} : \\{0,1\\}^<em> \\to G</span>  and  <span class="math">\\mathcal{H}&#x27; : \\{0,1\\}^</em> \\to \\mathbb{Z}_p</span>  be hash functions. Let SSS be Shamir's secret sharing scheme (Def. A.5).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\kappa}, n, t) \\to (\\llbracket \\mathbf{sk} \\rrbracket_{[n]}, pp)</span> . Sample  <span class="math">s \\gets_{\\S} \\mathbb{Z}_p</span>  and get  <span class="math">(s_1, \\ldots, s_n) \\gets \\mathrm{SSS}(n, t, p, s)</span> . Sample a generator  <span class="math">h</span>  of  <span class="math">G</span>  at random. Compute a commitment  <span class="math">\\gamma_i := g^{s_i} \\cdot h^{r_i}</span>  to  <span class="math">s_i</span>  by picking  <span class="math">r_i \\gets_{\\S} \\mathbb{Z}_p</span> . Set  <span class="math">pp = (p, g, G, \\mathcal{H}, \\mathcal{H}&#x27;, \\gamma_1, \\ldots, \\gamma_n, h)</span> ,  <span class="math">sk_i := (s_i, r_i)</span>  and give  <span class="math">sk_i</span>  to party  <span class="math">i</span> , for  <span class="math">i \\in [n]</span> .</li>

      <li><span class="math">\\operatorname{Eval}(sk_i, x, pp) \\to z_i</span> . Compute  <span class="math">w := \\mathcal{H}(x)</span>  and  <span class="math">h_i := w^{s_i}</span> . Pick  <span class="math">v_i, v_i&#x27; \\gets_{\\S} \\mathbb{Z}_p</span>  and set  <span class="math">t_i := w^{v_i}</span> ,  <span class="math">t_i&#x27; := g^{v_i} \\cdot h^{v_i&#x27;}</span> . Compute a hash  <span class="math">c_i := \\mathcal{H}&#x27;(h_i, w, \\gamma_i, g, h, t_i, t_i&#x27;)</span> ,  <span class="math">u_i := v_i - c_i \\cdot s_i</span>  and  <span class="math">u_i&#x27; := v_i&#x27; - c_i \\cdot r_i</span> . Define  <span class="math">\\pi_i</span>  to be  <span class="math">(c_i, u_i, u_i&#x27;)</span>  and output  <span class="math">((w, h_i), \\pi_i)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Combine  <span class="math">\\left(\\left\\{(i, z_i)\\right\\}_{i \\in S}, pp\\right) =: z / \\bot</span> . If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> , output  </span>\\bot<span class="math"> . Else, parse  </span>z_i<span class="math">  as  </span>((w, h_i), (c_i, u_i, u_i'))<span class="math">  for  </span>i \\in S<span class="math"> . Compute  </span>t_i := w^{u_i} \\cdot h_i^{c_i}<span class="math"> ,  </span>t_i' := g^{u_i} \\cdot h^{u_i'} \\cdot \\gamma_i^{c_i}<span class="math">  and check if  </span>c_i = \\mathcal{H}'(h_i, w, \\gamma_i, g, h, t_i, t_i')<span class="math"> . If check fails for any  </span>i \\in S<span class="math"> , output  </span>\\bot<span class="math"> . Else, output  </span>\\prod_{i \\in S} h_i^{\\lambda_{0,i,S}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: A concrete instantiation of the protocol  <span class="math">\\Pi_{\\mathsf{ZK - DDH - DP}}</span>  from Figure 4 using Pedersen commitment and Schnorr-style proof (via the Fiat-Shamir transform).</p>

    <p class="text-gray-300">Parameters: Let  <span class="math">G = \\langle g \\rangle</span>  be a multiplicative cyclic group of prime order  <span class="math">p</span>  in which the DDH assumption holds,  <span class="math">\\mathcal{H} : \\{0,1\\}^<em> \\to G</span>  and  <span class="math">\\mathcal{H}&#x27; : \\{0,1\\}^</em> \\to \\mathbb{Z}_p</span>  be hash functions. Let SSS be Shamir's secret sharing scheme (Def. A.5).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\kappa}, n, t) \\to (\\llbracket \\mathbf{sk}\\rrbracket_{[n]}, pp)</span> . Sample  <span class="math">s \\gets_{\\S} \\mathbb{Z}_p</span>  and get  <span class="math">(s_1, \\ldots, s_n) \\gets \\mathsf{SSS}(n, t, p, s)</span> . Set  <span class="math">pp = (p, g, G, \\mathcal{H}, \\mathcal{H}&#x27;, g^{s_1}, \\ldots, g^{s_n})</span> ,  <span class="math">sk_i := s_i</span>  and give  <span class="math">sk_i</span>  to party  <span class="math">i</span> , for  <span class="math">i \\in [n]</span> .</li>

      <li><span class="math">\\operatorname{Eval}(sk_i, x, pp) \\to z_i</span> . Compute  <span class="math">w \\coloneqq \\mathcal{H}(x)</span>  and  <span class="math">h_i \\coloneqq w^{sk_i}</span> . Pick  <span class="math">v_i \\gets_{\\S} \\mathbb{Z}_p</span>  and set  <span class="math">t_i \\coloneqq g^{v_i}</span> . Compute a hash  <span class="math">c_i \\coloneqq \\mathcal{H}&#x27;(h_i, w, g^{sk_i}, g, t_i)</span>  and  <span class="math">u_i \\coloneqq v_i - c_i \\cdot sk_i</span> . Define  <span class="math">\\pi_i</span>  to be  <span class="math">(c_i, u_i)</span>  and output  <span class="math">((w, h_i), \\pi_i)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Combine  <span class="math">\\left(\\{(i, z_i)\\}_{i \\in S}, pp\\right) =: z / \\bot</span> . If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> , output  </span>\\bot<span class="math"> . Else, parse  </span>z_i<span class="math">  as  </span>((w, h_i), (c_i, u_i))<span class="math">  for  </span>i \\in S<span class="math"> . Compute  </span>t_i := w^{u_i} \\cdot h_i^{c_i}<span class="math">  and check if  </span>c_i = \\mathcal{H}'(h_i, w, g^{sk_i}, g, t_i)<span class="math"> . If check fails for any  </span>i \\in S<span class="math"> , output  </span>\\bot<span class="math"> . Else, output  </span>\\prod_{i \\in S} h_i^{\\lambda_{0,i,S}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6: A privately verifiable version of the protocol from Figure 5.</p>

    <p class="text-gray-300">An efficient way to instantiate trapdoor commitments and NIZK arguments of knowledge (in the random oracle model) is via Pedersen commitments and Fiat-Shamir transformation on Schnorr-style proofs. We give this concrete version of  <span class="math">\\Pi_{\\mathsf{ZK - DDH - DP}}</span>  in Figure 5 and use it for our experiments in the following section. The concrete protocol remains secure under DDH (in random oracle model).</p>

    <p class="text-gray-300">Remark 8.3 Besides correctness, protocol of Figure 4 has the additional property that each party's proof can be publicly verified, i.e. the Combine algorithm only takes public inputs and the public messages sent/received. In particular, even an external party who does not hold any secrets, given the partial DPRF values and the NIZK proofs, can publicly verify that the DPRF was computed correctly. This may be useful in applications where an external party wants to verify the correctness of a token. But if we settle for strong correctness with only private verifiability, we can obtain a more efficient protocol. In particular, instead of publicly committing to the secret keys, each party can be given  <span class="math">g^{s_i}</span>  for all  <span class="math">i</span>  as part of its secret key in the setup, and the Schnorr-based NIZK can be simplified to reduce the number of required exponentiations. In the experiment section we implement both variants and show that the privately verifiable version is  <span class="math">25\\%</span>  faster than the publicly verifiable version. A concrete construction is provided in Figure 6.</p>

    <p class="text-gray-300">NPR also presented a DPRF construction based on any PRF, e.g. AES. To obtain an  <span class="math">t</span> -out-of- <span class="math">n</span>  threshold, this protocol incurs an exponential overhead of  <span class="math">O(n^{\\min(t,n-t)})</span> . However, for  <span class="math">n &amp;lt; 20</span>  or  <span class="math">t \\approx n</span>  it can significantly outperform the previously described DDH based construction (see Section 9).</p>

    <p class="text-gray-300">In the setup phase of the protocol,  <span class="math">d \\coloneqq \\binom{n}{n-t+1}</span>  random numbers  <span class="math">k_1, \\ldots, k_d</span>  are chosen. We assume that  <span class="math">d</span>  is polynomial in the security parameter so that all the DPRF algorithms are polynomial time. Let  <span class="math">D_1, \\ldots, D_d</span>  be the  <span class="math">d</span>  distinct  <span class="math">(n-t+1)</span> -sized subsets of  <span class="math">[n]</span> . Then, the  <span class="math">i</span> -th random number is given to all parties in the set  <span class="math">D_i</span> . The DPRF is defined as  <span class="math">F_k(x) = \\bigoplus_{i=1}^{d} f_{k_i}(x)</span> , where  <span class="math">f</span>  can be any PRF. Since all the  <span class="math">d</span>  keys are needed to compute  <span class="math">F_k</span> , no set  <span class="math">S</span>  of parties of size less than  <span class="math">t</span>  can compute  <span class="math">F_k</span>  by itself (at least one of the</p>

    <p class="text-gray-300">Parameters: Let  <span class="math">f: \\{0,1\\}^{\\kappa} \\times \\{0,1\\}^{<em>} \\to \\{0,1\\}^{</em>}</span>  be a pseudo-random function.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\kappa}, n, t) \\to (\\llbracket \\mathbf{SK} \\rrbracket_{[n]}, pp)</span> : Pick  <span class="math">k_1, \\ldots, k_d \\gets \\S \\{0, 1\\}^{\\kappa}</span>  where  <span class="math">d := \\binom{n}{n-t+1}</span> . Let  <span class="math">D_1, \\ldots, D_d</span>  be the  <span class="math">d</span>  distinct  <span class="math">(n-t+1)</span> -sized subsets of  <span class="math">[n]</span> . For  <span class="math">i \\in [n]</span> , let  <span class="math">SK_i := \\{k_j \\mid i \\in D_j \\text{ for } j \\in [d]\\}</span> . Set  <span class="math">pp := (f)</span>  and give  <span class="math">(SK_i, pp)</span>  to party  <span class="math">i</span> , for  <span class="math">i \\in [n]</span> .</li>

      <li><span class="math">\\operatorname{Eval}(SK_i, x, pp) \\to z_i</span> : Compute  <span class="math">h_{i,k} \\coloneqq f_k(x)</span>  for all  <span class="math">k \\in SK_i</span>  and output  <span class="math">\\{h_{i,k}\\}_{k \\in SK_i}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Combine  <span class="math">\\left(\\left\\{\\left(i,z_{i}\\right)\\right\\}_{i\\in S},pp\\right) =: z / \\bot :</span>  If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> , output  </span>\\bot<span class="math"> . Else, parse  </span>z_{i}<span class="math">  as  </span>\\{h_{i,k}\\}_{k\\in SK_i}<span class="math">  for  </span>i\\in S<span class="math"> . Let  </span>\\{SK_i'\\}_{i\\in S}<span class="math">  be mutually disjoint sets such that  </span>\\cup_{i\\in S}SK_i' = \\{k_1,\\dots ,k_d\\}<span class="math">  and  </span>SK_{i}^{\\prime}\\subseteq SK_{i}<span class="math">  for every  </span>i<span class="math"> . Output  </span>\\oplus_{k\\in SK_i',i\\in S}h_{i,k}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: A secure DPRF protocol  <span class="math">\\Pi_{\\mathrm{f - DP}}</span>  based on any PRF.</p>

    <p class="text-gray-300"><span class="math">D_{1},\\ldots ,D_{d}</span>  subsets, say  <span class="math">D_{j}</span> , does not intersect with  <span class="math">S</span> ; thus parties in  <span class="math">S</span>  do not have  <span class="math">k_{j}</span> ). See Figure 7 for a formal description.</p>

    <p class="text-gray-300">Theorem 8.4 If  <span class="math">f</span>  is a PRF, then  <span class="math">\\Pi_{\\mathrm{f - DP}}</span>  in Figure 7 is a secure DPRF.</p>

    <p class="text-gray-300">Proof of the above theorem can be found in Appendix C.6. We also note that it is possible to augment this PRF-based construction into one that satisfies strong correctness (hence strong security) using only symmetric-key primitives. In particular, one could commit to the PRF secrets during the setup, and require that each party provides a symmetric-key NIZK of correctness of its evaluation with respect to its committed secret keys using recent techniques [GMO16,  <span class="math">\\mathrm{CDG}^{+}17</span> ]. We do not present such an instantiation since it would be quite inefficient.</p>

    <p class="text-gray-300">When we combine the constructions of Section 7 and the DPRF instantiations of Section 8, we obtain four variants (two with strong security) of a threshold authenticated encryption scheme as depicted in Figure 8. We remark that although our implementation uses a hash function modeled as a random oracle to implement the commitment scheme used in DiSE the construction itself is proven secure using any commitment scheme in the standard model.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DPRF Instantiation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Resulting TSE</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Model</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πf-DP (Fig. 7)</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">OWF</td>

            <td class="px-3 py-2 border-b border-gray-700">Standard</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΠDDH-DP (Fig. 3)</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">DDH</td>

            <td class="px-3 py-2 border-b border-gray-700">Standard</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΠZK-DDH-DP (Fig. 5)</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH (Strong)</td>

            <td class="px-3 py-2 border-b border-gray-700">DDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ROM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ΠZK-DDH-DP (Fig. 6)</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓPVDDH (Strong)</td>

            <td class="px-3 py-2 border-b border-gray-700">DDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ROM</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 8: The four TSE schemes we implemented by instantiating DiSE. There are two concrete instantiations of  <span class="math">\\Pi_{\\mathsf{ZK - DDH - DP}}</span> , depending on the verifiability feature (see Remark 8.3).</p>

    <p class="text-gray-300">We implement all four variants of our protocol in  <span class="math">\\mathrm{C}++</span> . We implement the random oracle as Blake2 [bla] and the PRF/PRGs are constructed from AES-NI. The DDH-based DPRF [NPR99] uses the Miracl library [mir] with Curve p256k1. Benchmarks were performed on a single server equipped with two 18-core Intel Xeon CPUs at 2.3Ghz and 256GB of RAM. Parties communicate through a kernel loopback device simulating two settings: LAN - 10 Gbps and 0.1ms (RTT) latency, WAN: shared 40 Mbps and 80ms latency.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput (enc/s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Latency (ms/enc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bandwidth (Throughput Mbps)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSVDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSVDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSVDDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n/3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">1,095,770</td>

            <td class="px-3 py-2 border-b border-gray-700">556</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.6</td>

            <td class="px-3 py-2 border-b border-gray-700">9.3</td>

            <td class="px-3 py-2 border-b border-gray-700">10.5</td>

            <td class="px-3 py-2 border-b border-gray-700">268</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">656,728</td>

            <td class="px-3 py-2 border-b border-gray-700">382</td>

            <td class="px-3 py-2 border-b border-gray-700">99</td>

            <td class="px-3 py-2 border-b border-gray-700">77</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4</td>

            <td class="px-3 py-2 border-b border-gray-700">15.9</td>

            <td class="px-3 py-2 border-b border-gray-700">18.8</td>

            <td class="px-3 py-2 border-b border-gray-700">481</td>

            <td class="px-3 py-2 border-b border-gray-700">0.53</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">45,434</td>

            <td class="px-3 py-2 border-b border-gray-700">297</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">21.5</td>

            <td class="px-3 py-2 border-b border-gray-700">27.6</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">0.77</td>

            <td class="px-3 py-2 border-b border-gray-700">0.40</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">902</td>

            <td class="px-3 py-2 border-b border-gray-700">173</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">7.5</td>

            <td class="px-3 py-2 border-b border-gray-700">11.2</td>

            <td class="px-3 py-2 border-b border-gray-700">36.4</td>

            <td class="px-3 py-2 border-b border-gray-700">43.1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.69</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n/2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">1,113,090</td>

            <td class="px-3 py-2 border-b border-gray-700">555</td>

            <td class="px-3 py-2 border-b border-gray-700">235</td>

            <td class="px-3 py-2 border-b border-gray-700">190</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.7</td>

            <td class="px-3 py-2 border-b border-gray-700">9.2</td>

            <td class="px-3 py-2 border-b border-gray-700">10.1</td>

            <td class="px-3 py-2 border-b border-gray-700">272</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">510,152</td>

            <td class="px-3 py-2 border-b border-gray-700">527</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0</td>

            <td class="px-3 py-2 border-b border-gray-700">11.9</td>

            <td class="px-3 py-2 border-b border-gray-700">14.3</td>

            <td class="px-3 py-2 border-b border-gray-700">249</td>

            <td class="px-3 py-2 border-b border-gray-700">0.26</td>

            <td class="px-3 py-2 border-b border-gray-700">0.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">198,020</td>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7</td>

            <td class="px-3 py-2 border-b border-gray-700">5.2</td>

            <td class="px-3 py-2 border-b border-gray-700">21.2</td>

            <td class="px-3 py-2 border-b border-gray-700">26.1</td>

            <td class="px-3 py-2 border-b border-gray-700">242</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.47</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">10,194</td>

            <td class="px-3 py-2 border-b border-gray-700">231</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">8.0</td>

            <td class="px-3 py-2 border-b border-gray-700">31.3</td>

            <td class="px-3 py-2 border-b border-gray-700">38.8</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

            <td class="px-3 py-2 border-b border-gray-700">0.50</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">38.0</td>

            <td class="px-3 py-2 border-b border-gray-700">15.9</td>

            <td class="px-3 py-2 border-b border-gray-700">54.5</td>

            <td class="px-3 py-2 border-b border-gray-700">69.6</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0.33</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2n/3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1,100,413</td>

            <td class="px-3 py-2 border-b border-gray-700">561</td>

            <td class="px-3 py-2 border-b border-gray-700">239</td>

            <td class="px-3 py-2 border-b border-gray-700">190</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9</td>

            <td class="px-3 py-2 border-b border-gray-700">10.7</td>

            <td class="px-3 py-2 border-b border-gray-700">18.6</td>

            <td class="px-3 py-2 border-b border-gray-700">269</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">1,033,592</td>

            <td class="px-3 py-2 border-b border-gray-700">399</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

            <td class="px-3 py-2 border-b border-gray-700">15.0</td>

            <td class="px-3 py-2 border-b border-gray-700">18.6</td>

            <td class="px-3 py-2 border-b border-gray-700">757</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">438,957</td>

            <td class="px-3 py-2 border-b border-gray-700">245</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">6.4</td>

            <td class="px-3 py-2 border-b border-gray-700">27.6</td>

            <td class="px-3 py-2 border-b border-gray-700">34.5</td>

            <td class="px-3 py-2 border-b border-gray-700">750</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.49</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">21,139</td>

            <td class="px-3 py-2 border-b border-gray-700">176</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">8.9</td>

            <td class="px-3 py-2 border-b border-gray-700">41.6</td>

            <td class="px-3 py-2 border-b border-gray-700">51.5</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">0.47</td>

            <td class="px-3 py-2 border-b border-gray-700">0.43</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">445</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">16.5</td>

            <td class="px-3 py-2 border-b border-gray-700">21.5</td>

            <td class="px-3 py-2 border-b border-gray-700">72.4</td>

            <td class="px-3 py-2 border-b border-gray-700">85.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n-2</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">727,273</td>

            <td class="px-3 py-2 border-b border-gray-700">203</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">7.37</td>

            <td class="px-3 py-2 border-b border-gray-700">33.1</td>

            <td class="px-3 py-2 border-b border-gray-700">44.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1598</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">524,109</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">12.6</td>

            <td class="px-3 py-2 border-b border-gray-700">55.2</td>

            <td class="px-3 py-2 border-b border-gray-700">66.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1919</td>

            <td class="px-3 py-2 border-b border-gray-700">0.49</td>

            <td class="px-3 py-2 border-b border-gray-700">0.43</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">283,822</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6</td>

            <td class="px-3 py-2 border-b border-gray-700">28.0</td>

            <td class="px-3 py-2 border-b border-gray-700">98.9</td>

            <td class="px-3 py-2 border-b border-gray-700">116.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1455</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1,058,574</td>

            <td class="px-3 py-2 border-b border-gray-700">556</td>

            <td class="px-3 py-2 border-b border-gray-700">235</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.6</td>

            <td class="px-3 py-2 border-b border-gray-700">9.56</td>

            <td class="px-3 py-2 border-b border-gray-700">10.0</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">1,037,703</td>

            <td class="px-3 py-2 border-b border-gray-700">553</td>

            <td class="px-3 py-2 border-b border-gray-700">226</td>

            <td class="px-3 py-2 border-b border-gray-700">188</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.6</td>

            <td class="px-3 py-2 border-b border-gray-700">9.6</td>

            <td class="px-3 py-2 border-b border-gray-700">10.3</td>

            <td class="px-3 py-2 border-b border-gray-700">253</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">735,294</td>

            <td class="px-3 py-2 border-b border-gray-700">404</td>

            <td class="px-3 py-2 border-b border-gray-700">176</td>

            <td class="px-3 py-2 border-b border-gray-700">151</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.6</td>

            <td class="px-3 py-2 border-b border-gray-700">9.56</td>

            <td class="px-3 py-2 border-b border-gray-700">10.4</td>

            <td class="px-3 py-2 border-b border-gray-700">180</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10</td>

            <td class="px-3 py-2 border-b border-gray-700">0.22</td>

            <td class="px-3 py-2 border-b border-gray-700">0.23</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 9: Encryption performance metrics for 10 second trials of 32 bytes messages in the LAN setting with various number of parties  <span class="math">n</span>  and threshold  <span class="math">t</span> . Throughput is computed by performing many encryptions concurrently (single thread per party). Latency is computed by performing sequential encryptions. Bandwidth is total (send + receive) bandwidth consumed at peak throughput.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput (enc/s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Latency (ms/enc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bandwidth (Throughput Mbps)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSVDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSVDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓAES</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSDDH</td>

            <td class="px-3 py-2 border-b border-gray-700">ΓSVDDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n/3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">153,332</td>

            <td class="px-3 py-2 border-b border-gray-700">570</td>

            <td class="px-3 py-2 border-b border-gray-700">238</td>

            <td class="px-3 py-2 border-b border-gray-700">190</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">51,745</td>

            <td class="px-3 py-2 border-b border-gray-700">399</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">0.39</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">31,096</td>

            <td class="px-3 py-2 border-b border-gray-700">303</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">139</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.41</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">775</td>

            <td class="px-3 py-2 border-b border-gray-700">191</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.33</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n/2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">150,783</td>

            <td class="px-3 py-2 border-b border-gray-700">571</td>

            <td class="px-3 py-2 border-b border-gray-700">239</td>

            <td class="px-3 py-2 border-b border-gray-700">188</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">76,957</td>

            <td class="px-3 py-2 border-b border-gray-700">536</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.26</td>

            <td class="px-3 py-2 border-b border-gray-700">0.38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">30,937</td>

            <td class="px-3 py-2 border-b border-gray-700">297</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

            <td class="px-3 py-2 border-b border-gray-700">0.41</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">11,776</td>

            <td class="px-3 py-2 border-b border-gray-700">235</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">92</td>

            <td class="px-3 py-2 border-b border-gray-700">141</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">0.46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.43</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">146</td>

            <td class="px-3 py-2 border-b border-gray-700">149</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0.36</td>

            <td class="px-3 py-2 border-b border-gray-700">0.33</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2n/3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">150,965</td>

            <td class="px-3 py-2 border-b border-gray-700">555</td>

            <td class="px-3 py-2 border-b border-gray-700">238</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">97</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.30</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">51,535</td>

            <td class="px-3 py-2 border-b border-gray-700">396</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

            <td class="px-3 py-2 border-b border-gray-700">77</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">122</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">0.39</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">21,484</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">123</td>

            <td class="px-3 py-2 border-b border-gray-700">152</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.40</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">14,029</td>

            <td class="px-3 py-2 border-b border-gray-700">174</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">97</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">169</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">0.47</td>

            <td class="px-3 py-2 border-b border-gray-700">0.43</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">446</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">92</td>

            <td class="px-3 py-2 border-b border-gray-700">98</td>

            <td class="px-3 py-2 border-b border-gray-700">164</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.33</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 10: Encryption performance metrics for 10 second trials of 32 bytes messages in the WAN setting (shared send+receive 40Mbps, 80ms RTT) with various number of parties  <span class="math">n</span>  and threshold  <span class="math">t</span> .</p>

    <p class="text-gray-300">Throughput. Figure 9 shows the throughput and latency of our protocols under a variety of configurations in the LAN setting. Throughput measures the maximum number of operations that can be performed given that each party has a single core. Throughput is an important metric for many tasks such as a key/token server or per row database decryption.</p>

    <p class="text-gray-300">The  <span class="math">\\Gamma_{\\mathsf{AES}}</span>  protocol is the fastest by a large margin for all  <span class="math">n \\leq 24</span>  despite having exponential overhead in the number of parties. For instance, encrypting 32 bytes with  <span class="math">n = 6</span>  and  <span class="math">t = 4</span> ,  <span class="math">\\Gamma_{\\mathsf{AES}}</span>  achieves 1 million encryption per second while  <span class="math">\\Gamma_{\\mathsf{DDH}}</span> , the next fastest, is  <span class="math">2000 \\times</span>  slower with 556 encryptions. Increasing the parameters to  <span class="math">n = 24, t = 16</span> ,  <span class="math">\\Gamma_{\\mathsf{AES}}</span>  achieves 902</p>

    <p class="text-gray-300">encryptions per second while <span class="math">\\Gamma_{\\mathsf{DDH}}</span> is still <span class="math">5\\times</span> slower with 173 encryptions. The protocol <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{S}}</span> which achieves strong correctness incurs a 2 to <span class="math">5\\times</span> overhead compared to the weaker <span class="math">\\Gamma_{\\mathsf{DDH}}</span> while the publicly verifiable variant <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{PV}}</span> has, on average, 25% lower throughput.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Latency.</h4>

    <p class="text-gray-300">Another important metric is latency. That is, the time from the start of an encryption/decryption until the result is ready. Due to various system level optimization for improved latency, the throughput and latency results shown in Figure 9 are for different configurations of the protocol, e.g. less vectorization which improves latency at the cost of a smaller throughput. <span class="math">\\Gamma_{\\mathsf{AES}}</span> achieves sub-millisecond latency for most configurations. On the other hand, <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{PV}}</span> with its strong security guarantees achieves a latency between 10 and 100ms.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Communication.</h4>

    <p class="text-gray-300">In addition to achieving the best throughput and latency, the <span class="math">\\Gamma_{\\mathsf{AES}}</span> protocol has the smallest communication overhead of <span class="math">32(t-1)</span> bytes per encryption. The <span class="math">\\Gamma_{\\mathsf{DDH}}</span> incurs slightly more communication with <span class="math">49(t-1)</span> bytes per encryption while <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{S}}</span> and <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{PV}}</span> have the most communication with <span class="math">148(t-1)</span> bytes. However, despite having comparable communication overheads, the pure symmetric-key <span class="math">\\Gamma_{\\mathsf{AES}}</span> protocol is significantly faster for small <span class="math">n</span> due to the use of much more efficient AES operations (in contrast to exponentiations).</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Key Size.</h4>

    <p class="text-gray-300">The primary advantage of the DDH-based protocols <span class="math">\\Gamma_{\\mathsf{DDH}}</span>, <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{S}}</span> and <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{PV}}</span> is that the key size is either constant (33 bytes) or linear in the threshold (<span class="math">33t</span> bytes). The <span class="math">\\Gamma_{\\mathsf{AES}}</span> protocol, on the other hand, requires that each party hold roughly <span class="math">\\binom{n}{t}\\approx O(n^{\\min(t,n-t)})</span> keys. As such, the single benchmark machine sharing 256GB of RAM was not able to handle significantly more than 24 parties. For instance, with <span class="math">n=6,t=4</span> each party must hold 80 bytes of key while the case of <span class="math">n=24,t=16</span> requires each party to hold a 8MB key. In the worst case of <span class="math">t=n/2</span> with <span class="math">n=24</span>, the key size increases to 22MB per party. However, despite this exponential blowup, the <span class="math">\\Gamma_{\\mathsf{AES}}</span> can gracefully handle cases where <span class="math">n</span> is small or the threshold <span class="math">t</span> is near 2 or <span class="math">n</span> as shown in the bottom half of Figure 9.</p>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">WAN Performance.</h4>

    <p class="text-gray-300">To measure the performance of the protocols over the Internet, we benchmark on a (simulated) network with a <em>shared</em> bandwidth of 40 Mbps and an 80ms round-trip time.</p>

    <p class="text-gray-300">As shown in Figure 10, the bandwidth restriction limits the throughput of the <span class="math">\\Gamma_{\\mathsf{AES}}</span> protocol due to it easily saturating the network. With <span class="math">n=6,t=2</span>, we observe that the throughput drops <span class="math">7\\times</span> to 153,332 encryption per second. However, this is near optimal given that simply communicating <span class="math">\\kappa</span> bits requires 37 out of the 40Mbps bandwidth limit. Additionally, the latency of the <span class="math">\\Gamma_{\\mathsf{AES}}</span> is near the optimal of 80ms in most cases. The <span class="math">\\Gamma_{\\mathsf{DDH}}</span> protocol require slightly more time of roughly 90ms in most cases while the strongly-correct <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{PV}}</span> and <span class="math">\\Gamma_{\\mathsf{DDH}}^{\\mathsf{S}}</span> protocols require between 95 and 170ms.</p>

    <h2 id="sec-64" class="text-2xl font-bold">10 Acknowledgment</h2>

    <p class="text-gray-300">We thank Saikrishna Badrinarayanan, Dan Boneh, Atul Luykx and anonymous CCS 2018 reviewers for helpful comments on earlier drafts of this paper.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AMN01] Michel Abdalla, Sara Miner, and Chanathip Namprempre. Forward-secure threshold signature schemes. In Cryptographers Track at the RSA Conference, pages 441–456. Springer, 2001.</li>

      <li>[BBH06] Dan Boneh, Xavier Boyen, and Shai Halevi. Chosen ciphertext secure public key threshold encryption without random oracles. In David Pointcheval, editor, CT-RSA 2006, volume 3860 of LNCS, pages 226–243. Springer, Heidelberg, February 2006.</li>

      <li>[BD10] Rikke Bendlin and Ivan Damgård. Threshold decryption and zero-knowledge proofs for lattice-based cryptosystems. In Daniele Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 201–218. Springer, Heidelberg, February 2010.</li>

      <li>[BGM04] Mihir Bellare, Oded Goldreich, and Anton Mityagin. The power of verification queries in message authentication and authenticated encryption. Cryptology ePrint Archive, Report 2004/309, 2004. http://eprint.iacr.org/2004/309.</li>

      <li>[BHT18] Priyanka Bose, Viet Tung Hoang, and Stefano Tessaro. Revisiting AES-GCM-SIV: Multi-user security, faster key derivation, and better bounds. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 468–499. Springer, Heidelberg, April / May 2018.</li>

      <li>[BK11] Mihir Bellare and Sriram Keelveedhi. Authenticated and misuse-resistant encryption of key-dependent data. In Phillip Rogaway, editor, CRYPTO 2011, volume 6841 of LNCS, pages 610–629. Springer, Heidelberg, August 2011.</li>

      <li>[BL18] Fabrice Benhamouda and Huijia Lin. k-round multiparty computation from k-round oblivious transfer via garbled interactive circuits. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 500–532. Springer, Heidelberg, April / May 2018.</li>

      <li>[bla] MIRACL Cryptographic SDK. https://www.miracl.com/.</li>

      <li>[BLMR13] Dan Boneh, Kevin Lewi, Hart William Montgomery, and Ananth Raghunathan. Key homomorphic PRFs and their applications. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part I, volume 8042 of LNCS, pages 410–428. Springer, Heidelberg, August 2013.</li>

      <li>[BN00] Mihir Bellare and Chanathip Namprempre. Authenticated encryption: Relations among notions and analysis of the generic composition paradigm. In Tatsuaki Okamoto, editor, ASIACRYPT 2000, volume 1976 of LNCS, pages 531–545. Springer, Heidelberg, December 2000.</li>

      <li>[Bol03] Alexandra Boldyreva. Threshold signatures, multisignatures and blind signatures based on the gap-Diffie-Hellman-group signature scheme. In Yvo Desmedt, editor, PKC 2003, volume 2567 of LNCS, pages 31–46. Springer, Heidelberg, January 2003.</li>

      <li>[BT16] Mihir Bellare and Björn Tackmann. The multi-user security of authenticated encryption: AES-GCM in TLS 1.3. In Matthew Robshaw and Jonathan Katz,</li>

    </ul>

    <p class="text-gray-300">editors, CRYPTO 2016, Part I, volume 9814 of LNCS, pages 247–276. Springer, Heidelberg, August 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Can01] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd FOCS, pages 136–145. IEEE Computer Society Press, October 2001.</li>

      <li>[CDG^{+}17] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, pages 1825–1842, 2017.</li>

      <li>[CG99] Ran Canetti and Shafi Goldwasser. An efficient threshold public key cryptosystem secure against adaptive chosen ciphertext attack. In Jacques Stern, editor, EUROCRYPT’99, volume 1592 of LNCS, pages 90–106. Springer, Heidelberg, May 1999.</li>

      <li>[CV90] David Chaum and Hans Van Antwerpen. Undeniable signatures. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 212–216. Springer, Heidelberg, August 1990.</li>

      <li>[DDFY94] Alfredo De Santis, Yvo Desmedt, Yair Frankel, and Moti Yung. How to share a function securely. In 26th ACM STOC, pages 522–533. ACM Press, May 1994.</li>

      <li>[DF90] Yvo Desmedt and Yair Frankel. Threshold cryptosystems. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 307–315. Springer, Heidelberg, August 1990.</li>

      <li>[DK01] Ivan Damgård and Maciej Koprowski. Practical threshold RSA signatures without a trusted dealer. In Birgit Pfitzmann, editor, EUROCRYPT 2001, volume 2045 of LNCS, pages 152–165. Springer, Heidelberg, May 2001.</li>

      <li>[DK10] Ivan Damgård and Marcel Keller. Secure multiparty AES. In Radu Sion, editor, FC 2010, volume 6052 of LNCS, pages 367–374. Springer, Heidelberg, January 2010.</li>

      <li>[Dod03] Yevgeniy Dodis. Efficient construction of (distributed) verifiable random functions. In Yvo Desmedt, editor, PKC 2003, volume 2567 of LNCS, pages 1–17. Springer, Heidelberg, January 2003.</li>

      <li>[DP08] Cécile Delerablée and David Pointcheval. Dynamic threshold public-key encryption. In David Wagner, editor, CRYPTO 2008, volume 5157 of LNCS, pages 317–334. Springer, Heidelberg, August 2008.</li>

      <li>[DY05] Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random function with short proofs and keys. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 416–431. Springer, Heidelberg, January 2005.</li>

      <li>[dya] Dyadic Security. https://www.dyadicsec.com.</li>

    </ul>

    <p class="text-gray-300">[DYY06] Yevgeniy Dodis, Aleksandr Yampolskiy, and Moti Yung. Threshold and proactive pseudo-random permutations. In Shai Halevi and Tal Rabin, editors, TCC 2006, volume 3876 of LNCS, pages 542–560. Springer, Heidelberg, March 2006.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ECS^{+}15] Adam Everspaugh, Rahul Chaterjee, Samuel Scott, Ari Juels, and Thomas Ristenpart. The pythia PRF service. In 24th USENIX Security Symposium (USENIX Security 15), pages 547–562, 2015.</li>

      <li>[FFL12] Ewan Fleischmann, Christian Forler, and Stefan Lucks. McOE: A family of almost foolproof on-line authenticated encryption schemes. In Anne Canteaut, editor, FSE 2012, volume 7549 of LNCS, pages 196–215. Springer, Heidelberg, March 2012.</li>

      <li>[FKMV12] Sebastian Faust, Markulf Kohlweiss, Giorgia Azzurra Marson, and Daniele Venturi. On the non-malleability of the Fiat-Shamir transform. In Steven D. Galbraith and Mridul Nandi, editors, INDOCRYPT 2012, volume 7668 of LNCS, pages 60–79. Springer, Heidelberg, December 2012.</li>

      <li>[Fra90] Yair Frankel. A practical protocol for large group oriented networks. In Jean-Jacques Quisquater and Joos Vandewalle, editors, EUROCRYPT’89, volume 434 of LNCS, pages 56–61. Springer, Heidelberg, April 1990.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[GGHR14] Sanjam Garg, Craig Gentry, Shai Halevi, and Mariana Raykova. Two-round secure MPC from indistinguishability obfuscation. In Yehuda Lindell, editor, TCC 2014, volume 8349 of LNCS, pages 74–94. Springer, Heidelberg, February 2014.</li>

      <li>[GHKR08] Rosario Gennaro, Shai Halevi, Hugo Krawczyk, and Tal Rabin. Threshold RSA for dynamic and ad-hoc groups. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 88–107. Springer, Heidelberg, April 2008.</li>

      <li>[GJKR96] Rosario Gennaro, Stanislaw Jarecki, Hugo Krawczyk, and Tal Rabin. Robust threshold DSS signatures. In Ueli M. Maurer, editor, EUROCRYPT’96, volume 1070 of LNCS, pages 354–371. Springer, Heidelberg, May 1996.</li>

      <li>[GL15] Shay Gueron and Yehuda Lindell. GCM-SIV: Full nonce misuse-resistant authenticated encryption at under one cycle per byte. In Indrajit Ray, Ninghui Li, and Christopher Kruegel:, editors, ACM CCS 15, pages 109–119. ACM Press, October 2015.</li>

      <li>[GMO16] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zero-knowledge for boolean circuits. In USENIX Security Symposium, pages 1069–1083, 2016.</li>

      <li>[GMPP16] Sanjam Garg, Pratyay Mukherjee, Omkant Pandey, and Antigoni Polychroniadou. The exact round complexity of secure computation. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 448–476. Springer, Heidelberg, May 2016.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GRR^{+}16] Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P. Smart. MPC-friendly symmetric key primitives. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors, ACM CCS 16, pages 430–443. ACM Press, October 2016.</li>

      <li>[GS17] Sanjam Garg and Akshayaram Srinivasan. Garbled protocols and two-round MPC from bilinear maps. In 58th FOCS, pages 588–599. IEEE Computer Society Press, 2017.</li>

      <li>[GS18] Sanjam Garg and Akshayaram Srinivasan. Two-round multiparty secure computation from minimal assumptions. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part II, volume 10821 of LNCS, pages 468–499. Springer, Heidelberg, April / May 2018.</li>

      <li>[HKR15] Viet Tung Hoang, Ted Krovetz, and Phillip Rogaway. Robust authenticated-encryption AEZ and the problem that it solves. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of LNCS, pages 15–44. Springer, Heidelberg, April 2015.</li>

      <li>[HRRV15] Viet Tung Hoang, Reza Reyhanitabar, Phillip Rogaway, and Damian Vizár. Online authenticated-encryption and its nonce-reuse misuse-resistance. In Rosario Gennaro and Matthew J. B. Robshaw, editors, CRYPTO 2015, Part I, volume 9215 of LNCS, pages 493–517. Springer, Heidelberg, August 2015.</li>

      <li>[kera] Kerberos: Encryption Types. http://web.mit.edu/kerberos/krb5-latest/doc/admin/enctypes.html.</li>

      <li>[kerb] Kerberos: The Network Authentication Protocol. http://web.mit.edu/kerberos/.</li>

      <li>[KT09] R. Kusters and M. Tuengerthal. Universally composable symmetric encryption. In 2009 22nd IEEE Computer Security Foundations Symposium, pages 293–307, July 2009.</li>

      <li>[KY01] Jonathan Katz and Moti Yung. Unforgeable encryption and chosen ciphertext secure modes of operation. In Bruce Schneier, editor, FSE 2000, volume 1978 of LNCS, pages 284–299. Springer, Heidelberg, April 2001.</li>

      <li>[mir] BLAKE2 - fast secure hashing. https://blake2.net/.</li>

      <li>[mpca] ePrint Archive MPC Papers. http://users-cs.au.dk/psn/list/.</li>

      <li>[mpcb] List of MPC Software. http://www.multipartycomputation.com/mpc-software.</li>

      <li>[mpcc] List of resources on MPC. https://github.com/rdragos/awesome-mpc.</li>

      <li>[MS95] Silvio Micali and Ray Sidney. A simple method for generating and sharing pseudo-random functions, with applications to clipper-like escrow systems. In Don Coppersmith, editor, CRYPTO’95, volume 963 of LNCS, pages 185–196. Springer, Heidelberg, August 1995.</li>

    </ul>

    <p class="text-gray-300">[MW16] Pratyay Mukherjee and Daniel Wichs. Two round multiparty computation via multi-key FHE. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 735–763. Springer, Heidelberg, May 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Nao91] Moni Naor. Bit commitment using pseudorandomness. Journal of Cryptology, 4(2):151–158, 1991.</li>

      <li>[Nie02] Jesper Buus Nielsen. A threshold pseudorandom function construction and its applications. In Moti Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 401–416. Springer, Heidelberg, August 2002.</li>

      <li>[NPR99] Moni Naor, Benny Pinkas, and Omer Reingold. Distributed pseudo-random functions and KDCs. In Jacques Stern, editor, EUROCRYPT’99, volume 1592 of LNCS, pages 327–346. Springer, Heidelberg, May 1999.</li>

      <li>[por] Porticor Cloud Security. http://www.porticor.com/. Acquired by Intuit.</li>

      <li>[PW12] Kenneth G. Paterson and Gaven J. Watson. Authenticated-encryption with padding: A formal security treatment. In Cryptography and Security: From Theory to Applications - Essays Dedicated to Jean-Jacques Quisquater on the Occasion of His 65th Birthday, pages 83–107, 2012.</li>

      <li>[Rog02] Phillip Rogaway. Authenticated-encryption with associated-data. In Vijayalakshmi Atluri, editor, ACM CCS 02, pages 98–107. ACM Press, November 2002.</li>

      <li>[Rog13] Philip Rogaway. The Evolution of Authenticated Encryption. https://crypto.stanford.edu/RealWorldCrypto/slides/phil.pdf, 2013.</li>

      <li>[RS06] Phillip Rogaway and Thomas Shrimpton. A provable-security treatment of the key-wrap problem. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 373–390. Springer, Heidelberg, May / June 2006.</li>

      <li>[RSS17] Dragos Rotaru, Nigel P. Smart, and Martijn Stam. Modes of operation suitable for computing on encrypted data. Cryptology ePrint Archive, Report 2017/496, 2017. http://eprint.iacr.org/2017/496.</li>

      <li>[Sch90] Claus-Peter Schnorr. Efficient identification and signatures for smart cards. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 239–252. Springer, Heidelberg, August 1990.</li>

      <li>[sec] Infrastructure Secret Management Software Overview. https://gist.github.com/maxvt/bb49a6c7243163b8120625fc8ae3f3cd.</li>

      <li>[sep] Sepior. https://sepior.com.</li>

      <li>[SG98] Victor Shoup and Rosario Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. In Kaisa Nyberg, editor, EUROCRYPT’98, volume 1403 of LNCS, pages 1–16. Springer, Heidelberg, May / June 1998.</li>

      <li>[SG02] Victor Shoup and Rosario Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. Journal of Cryptology, 15(2):75–96, 2002.</li>

    </ul>

    <p class="text-gray-300">[Sha79] Adi Shamir. How to share a secret. Communications of the Association for Computing Machinery, 22(11):612–613, November 1979.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[vaua] Vault Architecture. https://www.vaultproject.io/docs/internals/architecture.html.</li>

      <li>[vaub] Vault by HashiCorp. https://www.vaultproject.io/.</li>

      <li>[vauc] Vault Docs, Basic Concepts, Seal-Unseal. https://www.vaultproject.io/docs/concepts/seal.html.</li>

    </ul>

    <h2 id="sec-65" class="text-2xl font-bold">Appendix A Cryptographic Primitives</h2>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">A.1 Authenticated Encryption</h3>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition A.1 (Symmetric encryption)</h6>

    <p class="text-gray-300">A symmetric encryption scheme is a triple of polynomial-time algorithms (Kgen, Encrypt, Decrypt) that satisfy a correctness requirement.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Kgen(<span class="math">1^{\\kappa})\\to sk</span> : On input the security parameter, Kgen outputs a secret key <span class="math">sk</span>.</li>

      <li>Encrypt(<span class="math">sk,m)\\to c</span> : On input the secret key <span class="math">sk</span> and a message <span class="math">m</span>, Encrypt outputs a ciphertext <span class="math">c</span>.</li>

      <li>Decrypt(<span class="math">sk,c)=:m/\\bot</span> : On input the secret key <span class="math">sk</span> and a ciphertext <span class="math">c</span>, Decrypt outputs a message <span class="math">m</span> or a failure symbol <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">Correctness. For all <span class="math">\\kappa\\in\\mathbb{N}</span>, <span class="math">sk</span> output by Kgen(<span class="math">1^{\\kappa}</span>), and any message <span class="math">m</span>, there exists a negligible function negl such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[m:=\\textsf{Decrypt}(sk,c)\\ :\\ c\\leftarrow\\textsf{Encrypt}(sk,m)\\right]\\geq 1-\\textsf{negl}(\\kappa),</span></p>

    <p class="text-gray-300">where the probability is over the randomness of Encrypt.</p>

    <h5 id="sec-68" class="text-base font-semibold mt-4">Chosen-plaintext attack.</h5>

    <p class="text-gray-300">A symmetric encryption scheme <span class="math">\\Pi=(\\textsf{Kgen},\\textsf{Encrypt},\\textsf{Decrypt})</span> is secure against chosen-plaintext attacks (CPA) if for all PPT adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function negl such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\textsf{SymCPA}_{\\Pi,\\mathcal{A}}(1^{\\kappa})=1\\right]-1/2\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\textsf{negl}(\\kappa),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where SymCPA is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialize.</em> Run Kgen to get a key <span class="math">sk</span>.</li>

      <li><em>Pre-challenge encryption queries.</em> On receiving (<span class="math">\\textsf{Encrypt},m</span>) from <span class="math">\\mathcal{A}</span>, return <span class="math">c\\leftarrow\\textsf{Encrypt}(sk,m)</span>. This step can be repeated any number of times.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <em>Challenge.</em> When <span class="math">\\mathcal{A}</span> sends (<span class="math">\\textsf{Challenge},(m_{0},m_{1})</span>) such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, choose a random bit </span>b\\leftarrow_{\\S}\\{0,1\\}<span class="math"> and return </span>c^{\\star}\\leftarrow\\textsf{Encrypt}(sk,m_{b})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Post-challenge encryption queries.</em> Same as Step 2.</li>

      <li><em>Guess.</em> Finally, receive a guess <span class="math">b^{\\prime}</span> from <span class="math">\\mathcal{A}</span> and output 1 if and only if <span class="math">b^{\\prime}=b</span>.</li>

    </ol>

    <p class="text-gray-300">###</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Authenticity <em>[x1, x10, x16]</em>.</h6>

    <p class="text-gray-300">A symmetric encryption scheme <span class="math">\\Pi=(\\mathsf{Kgen},\\mathsf{Encrypt},</span> Decrypt) satisfies authenticity if for all PPT adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{SymAUTH}_{\\Pi,\\mathcal{A}}(1^{\\kappa})=1\\right]\\leq\\mathsf{negl}(\\kappa),</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{SymAUTH}</span> is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialize.</em> Run <span class="math">\\mathsf{Kgen}</span> to get a key <span class="math">sk</span>.</li>

      <li><em>Encryption queries.</em> On receiving <span class="math">(\\mathsf{Encrypt},m)</span> from <span class="math">\\mathcal{A}</span>, return <span class="math">c\\leftarrow\\mathsf{Encrypt}(sk,m)</span>. This step can be repeated any number of times.</li>

      <li><em>Forgery.</em> <span class="math">\\mathcal{A}</span> produces a ciphertext <span class="math">c^{\\star}</span>. Output 1 if and only if <span class="math">\\mathsf{Decrypt}(sk,c^{\\star})\\neq\\bot</span>.</li>

    </ol>

    <p class="text-gray-300">In the following, we use <span class="math">\\mathsf{Encrypt}_{sk}(\\cdot)</span> and <span class="math">\\mathsf{Decrypt}_{sk}(\\cdot)</span> to mean <span class="math">\\mathsf{Encrypt}(sk,\\cdot)</span> and <span class="math">\\mathsf{Decrypt}(sk,\\cdot)</span>, respectively.</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">A.2 Commitment</h3>

    <h6 id="sec-71" class="text-base font-medium mt-4">Definition A.2</h6>

    <p class="text-gray-300">A (non-interactive) commitment scheme <span class="math">\\Sigma</span> consists of two PPT algorithms <span class="math">(\\mathsf{Setup}_{\\mathsf{com}},\\mathsf{Com})</span> which satisfy hiding and binding properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}_{\\mathsf{com}}(1^{\\kappa})\\rightarrow pp_{\\mathsf{com}}:</span> It takes the security parameter as input, and outputs some public parameters.</li>

      <li><span class="math">\\mathsf{Com}(m,pp_{\\mathsf{com}};r)=:\\alpha:</span> It takes a message <span class="math">m</span>, public parameters <span class="math">pp_{\\mathsf{com}}</span> and randomness <span class="math">r</span> as inputs, and outputs a commitment <span class="math">\\alpha</span>.</li>

    </ul>

    <h4 id="sec-72" class="text-lg font-semibold mt-6">Hiding.</h4>

    <p class="text-gray-300">A commitment scheme <span class="math">\\Sigma=(\\mathsf{Setup}_{\\mathsf{com}},\\mathsf{Com})</span> is hiding if for all PPT adversaries <span class="math">\\mathcal{A}</span>, all messages <span class="math">m_{0}</span>, <span class="math">m_{1}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for <span class="math">pp_{\\mathsf{com}}\\leftarrow\\mathsf{Setup}_{\\mathsf{com}}(1^{\\kappa})</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}(pp_{\\mathsf{com}},\\mathsf{Com}(m_{0},pp_{\\mathsf{com}};r_{0}))=1]-\\Pr[\\mathcal{A}(pp_{\\mathsf{com}},\\mathsf{Com}(m_{1},pp_{\\mathsf{com}};r_{1}))=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{negl}(\\kappa),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the probability is over the randomness of <span class="math">\\mathsf{Setup}_{\\mathsf{com}}</span>, random choice of <span class="math">r_{0}</span> and <span class="math">r_{1}</span>, and the coin tosses of <span class="math">\\mathcal{A}</span>.</p>

    <h4 id="sec-73" class="text-lg font-semibold mt-6">Binding.</h4>

    <p class="text-gray-300">A commitment scheme <span class="math">\\Sigma=(\\mathsf{Setup}_{\\mathsf{com}},\\mathsf{Com})</span> is binding if for all PPT adversaries <span class="math">\\mathcal{A}</span>, if <span class="math">\\mathcal{A}</span> outputs <span class="math">m_{0}</span>, <span class="math">m_{1}</span>, <span class="math">r_{0}</span> and <span class="math">r_{1}</span> (<span class="math">(m_{0},r_{0})\\neq(m_{1},r_{1})</span>) given <span class="math">pp_{\\mathsf{com}}\\leftarrow\\mathsf{Setup}_{\\mathsf{com}}(1^{\\kappa})</span>, then there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Com}(m_{0},pp_{\\mathsf{com}};r_{0})=\\mathsf{Com}(m_{1},pp_{\\mathsf{com}};r_{1})]\\leq\\mathsf{negl}(\\kappa),</span></p>

    <p class="text-gray-300">where the probability is over the randomness of <span class="math">\\mathsf{Setup}_{\\mathsf{com}}</span> and the coin tosses of <span class="math">\\mathcal{A}</span>.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Definition A.3 (Trapdoor (Non-interactive) Commitments.)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Com}=(\\mathsf{Setup}_{\\mathsf{com}},\\mathsf{Com})</span> be a (non-interactive) commitment scheme. A trapdoor commitment scheme has two more PPT algorithms <span class="math">\\mathsf{SimSetup}</span> and <span class="math">\\mathsf{SimOpen}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{SimSetup}(1^{\\kappa})\\rightarrow(pp_{\\mathsf{com}},\\tau_{\\mathsf{com}}):</span> It takes the security parameter as input, and outputs public parameters <span class="math">pp_{\\mathsf{com}}</span> and a trapdoor <span class="math">\\tau_{\\mathsf{com}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{SimOpen}(pp_{\\mathsf{com}},\\tau_{\\mathsf{com}},m^{\\prime},(m,r))=:r^{\\prime}:</span> It takes parameters <span class="math">pp_{\\mathsf{com}}</span>, trapdoor <span class="math">\\tau_{\\mathsf{com}}</span>, a message <span class="math">m^{\\prime}</span> and a message-randomness pair <span class="math">(m,r)</span> as inputs, and outputs a randomness <span class="math">r^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">For every <span class="math">(m,r)</span> and <span class="math">m^{\\prime}</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that</p>

    <p class="text-gray-300"><span class="math">pp_{\\mathsf{com}}\\approx_{stat}pp^{\\prime}_{\\mathsf{com}}\\qquad where\\ pp_{\\mathsf{com}}\\leftarrow\\mathsf{Setup}_{\\mathsf{com}}(1^{\\kappa})\\ \\text{and}\\ (pp^{\\prime}_{\\mathsf{com}},\\tau_{\\mathsf{com}})\\leftarrow\\mathsf{SimSetup}(1^{\\kappa})</span></p>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathsf{Com}(m,pp^{\\prime}_{\\mathsf{com}};r)=\\mathsf{Com}(m^{\\prime},pp^{\\prime}_{\\mathsf{com}};r^{\\prime})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (pp^{\\prime}_{\\mathsf{com}},\\tau_{\\mathsf{com}})\\leftarrow\\mathsf{SimSetup}(1^{\\kappa});\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ r^{\\prime}:=\\mathsf{SimOpen}(pp^{\\prime}_{\\mathsf{com}},\\tau_{\\mathsf{com}},m^{\\prime},(m,r))\\right]\\geq 1-\\mathsf{negl}(\\kappa).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-75" class="text-base font-medium mt-4">Remark A.4</h6>

    <p class="text-gray-300">Clearly, a trapdoor commitment can be binding against PPT adversaries only.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">A.2.1 Concrete instantiations.</h4>

    <p class="text-gray-300">Practical commitment schemes can be instantiated under various settings:</p>

    <h5 id="sec-77" class="text-base font-semibold mt-4">Random oracle.</h5>

    <p class="text-gray-300">In the random oracle model, a commitment to a message <span class="math">m</span> is simply the hash of <span class="math">m</span> together with a randomly chosen string of length <span class="math">r</span> of an appropriate length.</p>

    <h5 id="sec-78" class="text-base font-semibold mt-4">DLOG assumption.</h5>

    <p class="text-gray-300">A popular commitment scheme secure under DLOG is Pedersen commitment. Here, <span class="math">\\mathsf{Setup}_{\\mathsf{com}}(1^{\\kappa})</span> outputs the description of a (multiplicative) group <span class="math">G</span> of prime order <span class="math">p=\\Theta(\\kappa)</span> (in which DLOG holds) and two randomly and independently chosen generators <span class="math">g,h</span>. If <span class="math">\\mathcal{H}:\\{0,1\\}^{<em>}\\to\\mathbb{Z}_{p}</span> is a collision-resistant hash function, then a commitment to a message <span class="math">m</span> is given by <span class="math">g^{\\mathcal{H}(m)}\\cdot h^{r}</span>, where <span class="math">r\\leftarrow_{\\S}\\mathbb{Z}_{p}</span>. A trapdoor is simply the discrete log of <span class="math">h</span> with respect to <span class="math">g</span>. In other words, <span class="math">\\mathsf{SimSetup}</span> picks a random generator <span class="math">g</span>, a random integer <span class="math">a</span> in <span class="math">\\mathbb{Z}_{p}^{</em>}</span> and sets <span class="math">h</span> to be <span class="math">g^{a}</span>. Given <span class="math">(m,r)</span>, <span class="math">m^{\\prime}</span> and <span class="math">a</span>, <span class="math">\\mathsf{SimOpen}</span> outputs <span class="math">[(\\mathcal{H}(m)-\\mathcal{H}(m^{\\prime}))/a]+r</span>. It is easy to check that commitment to <span class="math">m</span> with randomness <span class="math">r</span> is equal to the commitment to <span class="math">m^{\\prime}</span> with randomness <span class="math">r^{\\prime}</span>.</p>

    <h5 id="sec-79" class="text-base font-semibold mt-4">Pseudo-random generators.</h5>

    <p class="text-gray-300">Naor proposed a simple and efficient commitment scheme based on the existence of PRGs <em>[x18]</em>. We briefly describe here a non-interactive variant of the scheme for commitment to <span class="math">n</span>-bit strings. <span class="math">\\mathsf{Setup}_{\\mathsf{com}}</span> outputs a randomly chosen string <span class="math">crs</span> of length <span class="math">4n</span>. Let <span class="math">pad:\\{0,1\\}^{n}\\to\\{0,1\\}^{4n}</span> be the function that prepends <span class="math">3n</span> zeroes to its argument, <span class="math">\\mathcal{H}:\\{0,1\\}^{*}\\to\\{0,1\\}^{n}</span> be a collision-resistant hash function, and <span class="math">G:\\{0,1\\}^{n}\\to\\{0,1\\}^{4n}</span> be a pseudo-random generator. Then, a commitment to a message <span class="math">m</span> is given by <span class="math">G(r)+crs\\cdot pad(\\mathcal{H}(x))</span> with arithmetic in <span class="math">GF(2^{4n})</span>, where <span class="math">r\\leftarrow_{\\S}\\{0,1\\}^{n}</span>. We skip rest of the details.</p>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">A.3 Secret Sharing</h3>

    <h6 id="sec-81" class="text-base font-medium mt-4">Definition A.5 (Shamir’s Secret Sharing)</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime. An <span class="math">(n,t,p,s)</span>-Shamir’s secret sharing scheme is a randomized algorithm <span class="math">\\mathsf{SSS}</span> that on input four integers <span class="math">n,t,p,s</span>, where <span class="math">0&lt;t\\leq n&lt;p</span> and <span class="math">s\\in\\mathbb{Z}_{p}</span>, outputs <span class="math">n</span> shares <span class="math">s_{1},\\ldots,s_{n}\\in\\mathbb{Z}_{p}</span> such that the following two conditions hold for any set <span class="math">\\{i_{1},\\ldots,i_{\\ell}\\}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\ell\\geq t</span>, there exists fixed (i.e., independent of <span class="math">s</span>) integers <span class="math">\\lambda_{1},\\ldots,\\lambda_{\\ell}\\in\\mathbb{Z}_{p}</span> (a.k.a. Lagrange coefficients) such that <span class="math">\\sum_{j=1}^{\\ell}\\lambda_{j}s_{i_{j}}=s\\ \\mathsf{mod}\\,p</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\ell&lt;t</span>, the distribution of <span class="math">(s_{i_{1}},\\ldots,s_{i_{\\ell}})</span> is uniformly random.</li>

    </ul>

    <p class="text-gray-300">Concretely, Shamir’s secret sharing works as follows. Pick <span class="math">a_{1}</span>, <span class="math">\\ldots</span>, <span class="math">a_{t-1}\\leftarrow_{\\S}\\mathbb{Z}_{p}</span>. Let <span class="math">f(x)</span> be the polynomial <span class="math">s+a_{1}\\cdot x+a_{2}\\cdot x^{2}+\\ldots+a_{t-1}\\cdot x^{t-1}</span>. Then <span class="math">s_{i}</span> is set to be <span class="math">f(i)</span> for all <span class="math">i\\in[n]</span>.</p>

    <h3 id="sec-82" class="text-xl font-semibold mt-8">A.4 Non-interactive Zero-knowledge</h3>

    <p class="text-gray-300">Let <span class="math">R</span> be an efficiently computable binary relation. For pairs <span class="math">(s,w)\\in R</span>, we refer to <span class="math">s</span> as the statement and <span class="math">w</span> as the witness. Let <span class="math">L</span> be the language of statements in <span class="math">R</span>, i.e. <span class="math">L=\\{s:\\exists w\\text{ such that }R(s,w)=1\\}</span>. We define non-interactive zero-knowledge arguments of knowledge in the random oracle model based on the work of Faust et al. <em>[x11]</em>.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Definition A.6 (Non-interactive Zero-knowledge Argument of Knowledge)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\mathsf{poly}(\\kappa)}</span> be a hash function modeled as a random oracle. A NIZK for a binary relation <span class="math">R</span> consists of two PPT algorithms Prove and Verify with oracle access to <span class="math">\\mathcal{H}</span> defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Prove}^{\\mathcal{H}}(s,w)</span> takes as input a statement <span class="math">s</span> and a witness <span class="math">w</span>, and outputs a proof <span class="math">\\pi</span> if <span class="math">(s,w)\\in R</span> and <span class="math">\\bot</span> otherwise.</li>

      <li><span class="math">\\mathsf{Verify}^{\\mathcal{H}}(s,\\pi)</span> takes as input a statement <span class="math">s</span> and a candidate proof <span class="math">\\pi</span>, and outputs a bit <span class="math">b\\in\\{0,1\\}</span> denoting acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">These two algorithms must satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect completeness: For any <span class="math">(s,w)\\in R</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathsf{Verify}^{\\mathcal{H}}(s,\\pi)=1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\pi\\leftarrow\\mathsf{Prove}^{\\mathcal{H}}(s,w)\\right]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero-knowledge: There must exist a pair of PPT simulators <span class="math">(\\mathcal{S}_{1},\\mathcal{S}_{2})</span> such that for all PPT adversary <span class="math">\\mathcal{A}</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}^{\\mathcal{H},\\mathsf{Prove}^{\\mathcal{H}}}(1^{\\kappa})=1]-\\Pr[\\mathcal{A}^{\\mathcal{S}_{1}(\\cdot),\\mathcal{S}_{2}^{\\prime}(\\cdot,\\cdot)}(1^{\\kappa})=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{negl}(\\kappa)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for some negligible function <span class="math">\\mathsf{negl}</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}_{1}</span> simulates the random oracle <span class="math">\\mathcal{H}</span>;</li>

      <li><span class="math">\\mathcal{S}_{2}^{\\prime}</span> returns a simulated proof <span class="math">\\pi\\leftarrow\\mathcal{S}_{2}(s)</span> on input <span class="math">(s,w)</span> if <span class="math">(s,w)\\in R</span> and <span class="math">\\bot</span> otherwise;</li>

      <li><span class="math">\\mathcal{S}_{1}</span> and <span class="math">\\mathcal{S}_{2}</span> share states.</li>

      <li>Argument of knowledge: There must exist a PPT simulator <span class="math">\\mathcal{S}_{1}</span> such that for all PPT adversary <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}^{\\mathcal{A}}</span> such that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[(s,w)\\notin R\\text{ and }\\mathsf{Verify}^{\\mathcal{H}}(s,\\pi)=1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hskip 14.22636pt(s,\\pi)\\leftarrow\\mathcal{A}^{\\mathcal{S}_{1}(\\cdot)}(1^{\\kappa});w\\leftarrow\\mathcal{E}^{\\mathcal{A}}(s,\\pi,Q)\\Big{]}\\leq\\mathsf{negl}(\\kappa)</span></p>

    <p class="text-gray-300">for some negligible function <span class="math">\\mathsf{negl}</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}_{1}</span> is like above;</li>

      <li><span class="math">Q</span> is the list of (query, response) pairs obtained from <span class="math">\\mathcal{S}_{1}</span></li>

    </ul>

    <p class="text-gray-300">Fiat-Shamir transform. Let  <span class="math">(\\text{Prove},\\text{Verify})</span>  be a three-round public-coin honest-verifier zero-knowledge interactive proof system (a sigma protocol) with unique responses. Let  <span class="math">\\mathcal{H}</span>  be a function with range equal to the space of the verifier's coins. In the random oracle model, the proof system  <span class="math">(\\text{Prove}^{\\mathcal{H}},\\text{Verify}^{\\mathcal{H}})</span>  derived from  <span class="math">(\\text{Prove},\\text{Verify})</span>  by applying the Fiat-Shamir transform satisfies the zero-knowledge and argument of knowledge properties defined above. See Definition 1, 2 and Theorem 1, 3 in Faust et al. [FKMV12] for more details. (They actually show that these properties hold even when adversary can ask for proofs of false statements.)</p>

    <p class="text-gray-300">The work of Naor et al. [NPR99], which puts forward the DPRF constructions we use in this paper, also proposes the only distributed symmetric-key encryption proposal we are aware of. Their proposal appeared before any formal treatment of threshold symmetric-key existed, and in fact even prior to the introduction of authenticated encryption in the non-distributed setting. Hence, it is only natural that their scheme does not meet the strong security notions we introduce here. We review their protocol in Figure 11 and argue why it fails to meet the security definitions introduced in this paper. <span class="math">^{10}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(In)-security of  <span class="math">\\Pi_{\\mathsf{NPR}}</span> . The protocol  <span class="math">\\Pi_{\\mathsf{NPR}}</span>  is CPA-secure against malicious adversaries if the underlying DPRF satisfies weak-malicious security. The formal proof is similar to the proof of the CPA-security of our protocol (c.f. Theorem 7.4) and hence we omit it. However, we argue that  <span class="math">\\Pi_{\\mathsf{NPR}}</span>  does not satisfy authenticity (c.f. Definition 6.8) even when the corrupt parties follow the protocol. To see this, first observe that a ciphertext in this protocol is a tuple  <span class="math">c := (j,k,e)</span>  where  <span class="math">k = y \\oplus w</span> ,  $y := \\mathsf{DP}(j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e)<span class="math">  and  </span>e \\gets \\mathsf{sENC.Encrypt}_w(m)<span class="math">  for some message  </span>m<span class="math"> . After obtaining this ciphertext, an adversary can go &quot;off-line&quot; and compute another ciphertext  </span>c' = (j,k',e)<span class="math">  which now decrypts to  </span>m' := \\mathsf{sENC.Decrypt}_{w'}(e)<span class="math">  where  </span>w' = k' \\oplus y<span class="math"> . This is possible since CPA-security does not guarantee that a ciphertext  </span>c<span class="math">  can not be decrypted with another secret-key  </span>w'<span class="math">  (although the message  </span>m'<span class="math">  will not reveal any information about  </span>m<span class="math">  by CPA-security). So the adversary could produce many valid ciphertexts by running just one encryption session, and thus win the authenticity game. (If we consider adversaries that choose their own  </span>w$ , then it becomes even harder to make the scheme secure.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The authors also mention that "in order [to] combat changes to the stored information one should use parts of  <span class="math">y</span>  as an authentication key to  <span class="math">e</span>  and  <span class="math">w</span> " (symbols in the quote have been replaced with the equivalent ones here). As we interpret, one can additionally use a message-authentication code (MAC) so that the ciphertext would look like  <span class="math">c := (j, k, e, t)</span>  where  <span class="math">k := w \\oplus y_1</span> ,  $t = \\mathsf{MAC}_{y_2}(e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math">  and  </span>(y_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_2) := \\mathsf{DP}(j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e)<span class="math"> . However, the modified construction still does not satisfy the authenticity requirement (c.f. Def. 6.8) because once an adversary gets the MAC key  </span>y_2<span class="math">  through an encryption session, it can re-launch the same attack, this time attaching a correct MAC computed with  </span>y_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 11: Description of the protocol  <span class="math">\\Pi_{\\mathsf{NPR}}</span></p>

    <p class="text-gray-300">Another natural proposal for encryption is to generate a fresh pseudorandom key using a DPRF and use it to encrypt the message via a symmetric-key authenticated encryption scheme. This was our first attempt for a secure construction. It is helpful to review this construction (Fig. 12) and show why it fails to meet our notion of authenticity, even when the corrupt parties do not deviate from the protocol.</p>

    <p class="text-gray-300">To see why the above scheme does not meet our authenticity notion, consider an attacker who runs a single distributed encryption session to learn an encryption key  <span class="math">w</span>  and uses it to encrypt many messages "off-line", thereby generating many new valid ciphertexts.</p>

    <p class="text-gray-300">We use a sequence of hybrids to prove security, with the first hybrid being the message privacy game MsgPriv. We first write down the challenge phase of MsgPriv in detail:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.  <span class="math">\\mathcal{A}</span>  outputs (Challenge,  <span class="math">j^{\\star},m_0,m_1,S^{\\star})</span>  where  <span class="math">j\\in S^{\\star}\\setminus C</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\star}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send  <span class="math">\\alpha^{\\star}</span>  to  <span class="math">\\mathcal{A}</span>  and get back  <span class="math">\\hat{z}_i</span>  for every  <span class="math">i\\in S^{\\star}\\cap C</span></li>

    </ol>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 12: Description of the protocol  <span class="math">\\Pi_{\\mathsf{DP} + \\mathsf{AE}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Run Combine  <span class="math">\\{(i,z_i)\\}_{i\\in S^{\\star}\\backslash C}\\cup \\{(i,\\hat{z}_i)\\}_{i\\in S^{\\star}\\cap C},pp)</span>  to get  <span class="math">w^{\\star}</span>  or  <span class="math">\\perp</span>  . In the latter case, give  <span class="math">\\perp</span>  to  <span class="math">\\mathcal{A}</span>  . Otherwise, compute  $e^{\\star}:= \\mathsf{PRG}(w^{\\star})\\oplus (m_b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho^{\\star})<span class="math">  and give  </span>c^{\\star}:= (j^{\\star},\\alpha^{\\star},e^{\\star})<span class="math">  to  </span>\\mathcal{A}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define five hybrids. With every hybrid, we only mention the difference from the previous hybrid (consider MsgPriv to be  <span class="math">\\mathsf{Hyb}_0</span> ).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_1</span> : Whenever an honest party initiates an encryption session (including the challenge phase) and generates a commitment that is not unique (among all the commitments generated so far by honest parties), notify the adversary and stop.</li>

      <li><span class="math">\\mathsf{Hyb}_2</span> : In Step 4 (see breakdown of challenge phase above), use a randomly chosen  <span class="math">w^{\\star}</span>  to compute  <span class="math">e^{\\star}</span>  (instead of the one obtained through Combine).</li>

      <li><span class="math">\\mathsf{Hyb}_3</span> : Replace  <span class="math">\\mathsf{PRG}(w^{\\star})</span>  with a randomly chosen string of the same length.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathsf{Hyb}_4</span> : Set  <span class="math">e^{\\star}</span>  to be a random string of length  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\kappa$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_5</span> : Set  <span class="math">\\alpha^{\\star}</span>  to be a commitment to a random message.</li>

    </ul>

    <p class="text-gray-300">Except with negligible probability, the commitments generated by honest parties are all unique due to the binding property of  <span class="math">\\Sigma</span>  (a fresh  <span class="math">\\rho</span>  is chosen every time). Thus  <span class="math">\\mathsf{MsgPriv}</span>  is indistinguishable from  <span class="math">\\mathsf{Hyb}_1</span> . Indistinguishability of  <span class="math">\\mathsf{Hyb}_2</span> ,  <span class="math">\\mathsf{Hyb}_3</span>  and  <span class="math">\\mathsf{Hyb}_4</span>  is easy to see. Further,  <span class="math">\\mathsf{Hyb}_4</span>  and  <span class="math">\\mathsf{Hyb}_5</span>  are indistinguishable due to the hiding property of  <span class="math">\\Sigma</span> .</p>

    <p class="text-gray-300">We are only left to show that  <span class="math">\\mathsf{Hyb}_1</span>  and  <span class="math">\\mathsf{Hyb}_2</span>  are indistinguishable. On the contrary, suppose there exists a PPT adversary  <span class="math">\\mathcal{A}</span>  who can distinguish between  <span class="math">\\mathsf{Hyb}_1</span>  and  <span class="math">\\mathsf{Hyb}_2</span>  with</p>

    <p class="text-gray-300">a non-negligible probability. We use <span class="math">\\mathcal{A}</span> to build another PPT adversary <span class="math">\\mathcal{B}</span> who succeeds in PseudoRand for the DPRF DP (Definition 5.3) with the same probability.</p>

    <p class="text-gray-300">Let Chal denote the challenger in PseudoRand. <span class="math">\\mathcal{B}</span> acts as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. Get <span class="math">pp_{\\mathsf{DP}}</span> from Chal and run <span class="math">\\Sigma</span>.Setup<span class="math">(1^{\\kappa})</span> to get <span class="math">pp_{\\mathsf{com}}</span>. Give <span class="math">(pp_{\\mathsf{DP}}, pp_{\\mathsf{com}})</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Corruption. Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">. Pass it on to Chal. When Chal returns </span>\\{sk_i\\}_{i \\in C}<span class="math">, forward them to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">j</span> is honest, compute <span class="math">\\alpha := \\operatorname{Com}(m, pp_{\\operatorname{com}}; \\rho)</span> for a randomly chosen <span class="math">\\rho</span>. If <span class="math">\\alpha</span> is not unique among all the commitments generated so far, notify <span class="math">\\mathcal{A}</span> and stop; else, send <span class="math">\\alpha</span> to it. <span class="math">\\mathcal{A}</span> responds with a <span class="math">z_i</span> for every <span class="math">i \\in S \\cap C</span>. At the same time, send $(\\operatorname{Eval}, j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha, i)<span class="math"> to Chal and get back a response </span>z_i<span class="math"> for every </span>i \\in S \\setminus C<span class="math">. Now run Combine(</span>\\{(i, z_i)\\}_{i \\in S}, pp<span class="math">) to get </span>w<span class="math"> or </span>\\bot<span class="math">. In the latter case, send </span>\\bot<span class="math"> to </span>\\mathcal{A}<span class="math">. Otherwise, compute </span>e := \\operatorname{PRG}(w) \\oplus (m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho)<span class="math"> and send </span>c := (j, \\alpha, e)<span class="math"> to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Pre-challenge indirect decryption queries. Suppose <span class="math">\\mathcal{A}</span> outputs (Decrypt, <span class="math">j, c, S</span>), where <span class="math">j \\in S \\setminus C</span> and $</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq t<span class="math">. If </span>c<span class="math"> parses to </span>(j', \\alpha, e)<span class="math">, send </span>j' \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha<span class="math"> to </span>\\mathcal{A}<span class="math">. Ignore any response from </span>\\mathcal{A}$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Challenge. <span class="math">\\mathcal{A}</span> outputs (Challenge, <span class="math">j^{\\star}, m_0, m_1, S^{\\star}</span>) where $</td>

            <td class="px-3 py-2 border-b border-gray-700">m_0</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">m_1</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">, </span>j^{\\star} \\in S^{\\star} \\setminus C<span class="math"> and </span></td>

            <td class="px-3 py-2 border-b border-gray-700">S^{\\star}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\geq t<span class="math">. Compute </span>\\alpha^{\\star} := \\operatorname{Com}(m_b, pp_{\\operatorname{com}}; \\rho^{\\star})<span class="math"> by picking </span>\\rho^{\\star}<span class="math"> at random and, based on the uniqueness of </span>\\alpha^{\\star}<span class="math">, do the same thing as before. For every </span>i \\in S^{\\star} \\cap C<span class="math">, </span>\\mathcal{A}<span class="math"> provides a value </span>\\hat{z}_i<span class="math">. Send (Challenge, </span>j^{\\star} \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha^{\\star}, S, \\{(i, \\hat{z}_i)\\}_{i \\in S^{\\star} \\cap C}<span class="math">) to Chal. If Chal returns </span>\\bot<span class="math">, forward the same to </span>\\mathcal{A}<span class="math">. Otherwise, use Chal&#x27;s response </span>w^{\\star}<span class="math"> to compute </span>e^{\\star} := \\operatorname{PRG}(w^{\\star}) \\oplus (m_b \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\rho^{\\star})<span class="math">, and give </span>c^{\\star} := (j^{\\star}, \\alpha^{\\star}, e^{\\star})<span class="math"> to </span>\\mathcal{A}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Post-challenge encryption queries. This is same as the pre-challenge encryption phase.</li>

      <li>Post-challenge indirect decryption queries. This is same as the pre-challenge decryption phase.</li>

      <li>Guess. Finally, <span class="math">\\mathcal{A}</span> returns a guess <span class="math">b&#x27;</span>. Output <span class="math">b&#x27;</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{B}</span> makes an Eval request in the (pre- or post-challenge) encryption phase only. When <span class="math">j</span> is honest, a request is made only when <span class="math">\\alpha</span> is unique. When <span class="math">j</span> is corrupt, $j \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x<span class="math"> can not be equal to </span>j^{\\star} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}<span class="math"> because </span>j^{\\star}<span class="math"> is honest. As a result, </span>\\mathcal{B}<span class="math"> never requests any evaluation on </span>j^{\\star} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}<span class="math">. Therefore, the challenge message it sends to Chal is valid. Now it is easy to see that when </span>w^{\\star} := \\text{Combine}(\\{(i, z_i)\\}_{i \\in S^{\\star} \\setminus C} \\cup \\{(i, \\hat{z}_i)\\}_{i \\in S^{\\star} \\cap C}, pp)<span class="math">, </span>\\mathcal{B}<span class="math"> perfectly simulates </span>\\mathsf{Hyb}_1<span class="math">, and when </span>w^{\\star}<span class="math"> is random, it perfectly simulates </span>\\mathsf{Hyb}_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">C.2 Proof of Theorem 7.5</p>

    <p class="text-gray-300">We first write down the last step of the authenticity game <span class="math">\\mathsf{AUTH}</span>, forgery, in detail. Recall that <span class="math">\\mathsf{ct}</span> counts the total number of times honest parties are contacted in encryption/decryption protocols initiated by corrupt parties and <span class="math">g</span> captures the minimum number of honest parties an adversary must contact in order to get enough information to generate one ciphertext. Let <span class="math">k:=\\lfloor\\mathsf{ct}/g\\rfloor</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathcal{A}</span> outputs <span class="math">((j_{1},S_{1},c_{1}),\\ (j_{2},S_{2},c_{2}),\\ \\ldots,\\ (j_{k+1},S_{k+1},c_{k+1}))</span> s.t. <span class="math">j_{\\ell}\\in S\\setminus C</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math"> for </span>\\ell\\in[k+1]<span class="math"> and </span>c_{u}\\neq c_{v}<span class="math"> for any </span>u\\neq v\\in[k+1]<span class="math">. Let </span>c_{\\ell}:=(j_{\\ell},\\alpha_{\\ell},e_{\\ell})<span class="math"> for </span>\\ell\\in[k+1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define a new authenticity game called <span class="math">\\mathsf{AUTH}</span>-<span class="math">\\mathsf{U}</span> (U stands for unique). It differs from <span class="math">\\mathsf{AUTH}</span> in the first step of forgery:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{A}</span> outputs <span class="math">((j_{1},S_{1},c_{1}),\\ (j_{2},S_{2},c_{2}),\\ \\ldots,\\ (j_{k+1},S_{k+1},c_{k+1}))</span> s.t. <span class="math">j_{\\ell}\\in S\\setminus C</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math"> for </span>\\ell\\in[k+1]<span class="math"> and </span>c_{u}\\neq c_{v}<span class="math"> for any </span>u\\neq v\\in[k+1]<span class="math">. Let </span>c_{\\ell}:=(j_{\\ell},\\alpha_{\\ell},e_{\\ell})<span class="math"> for </span>\\ell\\in[k+1]<span class="math">. Output </span>0<span class="math"> if for any </span>u\\neq v<span class="math">, </span>j_{u}=j_{v}<span class="math"> and </span>\\alpha_{u}=\\alpha_{v}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that <span class="math">\\mathsf{AUTH}</span> is indistinguishable from <span class="math">\\mathsf{AUTH}</span>-<span class="math">\\mathsf{U}</span>. Suppose an adversary outputs <span class="math">k+1</span> distinct ciphertexts s.t. there are two ciphertexts <span class="math">c_{u}</span> and <span class="math">c_{v}</span> for which <span class="math">j_{u}=j_{v}</span> and <span class="math">\\alpha_{u}=\\alpha_{v}</span> (thus, <span class="math">e_{u}\\neq e_{v}</span>). We show that in this case even <span class="math">\\mathsf{AUTH}</span> will output <span class="math">0</span>. Since all the parties involved in decrypting forged ciphertexts are assumed to behave honestly, <span class="math">w_{u}=w_{v}</span> with high probability due to the consistency property of <span class="math">\\mathsf{DP}</span>. Together with <span class="math">e_{u}\\neq e_{v}</span>, this implies that $m_{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{u}\\neq m_{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{v}<span class="math">. As a result, </span>\\mathsf{Com}(m_{u},pp_{\\mathsf{com}};\\rho_{u})\\neq\\mathsf{Com}(m_{v},pp_{\\mathsf{com}};\\rho_{v})<span class="math"> with all but negligible probability (binding property of </span>\\Sigma$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now show that if there exists a PPT adversary <span class="math">\\mathcal{A}</span> such that <span class="math">\\mathsf{AUTH}</span>-<span class="math">\\mathsf{U}</span> outputs <span class="math">1</span> with probability at least <span class="math">\\varepsilon</span>, then one can use it to build another PPT adversary <span class="math">\\mathcal{B}</span> for the pseudorandomness game <span class="math">\\mathsf{PseudoRand}</span> (Definition 5.3) whose advantage is at least <span class="math">\\varepsilon-\\mathsf{negl}</span> for some negligible function <span class="math">\\mathsf{negl}</span>. Let <span class="math">\\mathsf{Chal}</span> denote the challenger for the pseudorandomness game. <span class="math">\\mathcal{B}</span> acts as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialization.</em> Get <span class="math">pp_{\\mathsf{DP}}</span> from <span class="math">\\mathsf{Chal}</span> and run <span class="math">\\Sigma.\\mathsf{Setup}(1^{\\kappa})</span> to get <span class="math">pp_{\\mathsf{com}}</span>. Give <span class="math">(pp_{\\mathsf{DP}},pp_{\\mathsf{com}})</span> to <span class="math">\\mathcal{A}</span>. Initialize an ordered list <span class="math">L_{\\mathsf{p}\\text{-}\\mathsf{ctxt}}:=\\emptyset</span> and a counter <span class="math">\\mathsf{ct}_{j,\\alpha}:=0</span> for every <span class="math">(j,\\alpha)</span>. (Here, <span class="math">\\mathsf{p}\\text{-}\\mathsf{ctxt}</span> stands for partial ciphertext.)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Corruption.</em> Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><t<span class="math">. Pass it on to </span>\\mathsf{Chal}<span class="math">. When </span>\\mathsf{Chal}<span class="math"> returns </span>\\{sk_{i}\\}_{i\\in C}<span class="math">, forward them to </span>\\mathcal{A}<span class="math">. Set </span>g:=t-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">j</span> is honest, send <span class="math">\\alpha\\leftarrow\\mathsf{Com}(m,pp_{\\mathsf{com}};\\rho)</span> to <span class="math">\\mathcal{A}</span>, where <span class="math">\\rho</span> is picked at random. Ignore any response from <span class="math">\\mathcal{A}</span>. Append <span class="math">(j,\\alpha)</span> to <span class="math">L_{\\mathsf{p}\\text{-}\\mathsf{ctxt}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">j</span> is corrupt, <span class="math">\\mathcal{A}</span> expects the honest parties in <span class="math">S</span> to help compute a DPRF value. For a message <span class="math">x</span> sent to an honest party <span class="math">j^{\\prime}</span> in <span class="math">S</span>, send $(\\mathsf{Eval},j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x,j^{\\prime})<span class="math"> to </span>\\mathsf{Chal}<span class="math">. Forward </span>\\mathsf{Chal}<span class="math">’s response to </span>\\mathcal{A}<span class="math"> and increment </span>\\mathsf{ct}_{j,x}<span class="math"> by </span>1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Decryption queries. Suppose <span class="math">\\mathcal{A}</span> outputs <span class="math">(\\texttt{Decrypt}, j&#x27;, c, S)</span>, where <span class="math">j&#x27; \\in S</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math">. Parse </span>c<span class="math"> into </span>(j, \\alpha, e)$. Now:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">j&#x27;</span> is honest, send <span class="math">j \\parallel \\alpha</span> to <span class="math">\\mathcal{A}</span>. Ignore any response from <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">j&#x27;</span> is corrupt, for a message <span class="math">x</span> sent to an honest party <span class="math">j&#x27;&#x27; \\in S</span> by <span class="math">\\mathcal{A}</span>, check if <span class="math">x</span> is of the form $j^{\\star} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha^{\\star}<span class="math"> for some </span>j^{\\star} \\in [n]<span class="math">. If not, return </span>\\bot<span class="math"> to </span>\\mathcal{A}<span class="math">. Else, send </span>(\\texttt{Eval}, x, j'')<span class="math"> to Chal and forward its response to </span>\\mathcal{A}<span class="math">. Increment </span>\\mathsf{ct}_{j^{\\star}, \\alpha^{\\star}}$ by 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Targeted decryption queries. Suppose <span class="math">\\mathcal{A}</span> outputs (TargetDecrypt, <span class="math">j&#x27;, \\ell, S</span>), where <span class="math">j&#x27; \\in S \\setminus C</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math">. Let </span>(j, \\alpha)<span class="math"> be the </span>\\ell<span class="math">-th entry of </span>L_{\\mathsf{p}\\text{-}\\mathsf{ctxt}}<span class="math">. Send </span>j \\parallel \\alpha<span class="math"> to </span>\\mathcal{A}<span class="math">. Ignore any response from </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Forgery. <span class="math">\\mathcal{A}</span> outputs <span class="math">((j_1, S_1, c_1), (j_2, S_2, c_2), \\ldots, (j_\\tau, S_\\tau, c_\\tau))</span> s.t. <span class="math">j_\\ell \\in S \\setminus C</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math"> for </span>\\ell \\in [\\tau]<span class="math"> and </span>c_u \\neq c_v<span class="math"> for any </span>u \\neq v \\in [\\tau]<span class="math">. Let </span>c_\\ell := (j_\\ell, \\alpha_\\ell, e_\\ell)<span class="math"> for </span>\\ell \\in [\\tau]$. Now:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If for any <span class="math">u \\neq v</span>, <span class="math">j_u = j_v</span> and <span class="math">\\alpha_u = \\alpha_v</span>, output 1 as the guess and stop.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Pick a <span class="math">c_{\\ell^{\\star}}</span> such that <span class="math">\\mathsf{ct}_{j_{\\ell^{\\star}}, \\alpha_{\\ell^{\\star}}} &amp;lt; g</span>. Send (Challenge, $j_{\\ell^{\\star}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{\\ell^{\\star}}, S_{\\ell^{\\star}}, \\emptyset<span class="math">) to Chal. Let </span>w^{\\star}<span class="math"> be Chal&#x27;s response. If </span>w^{\\star} = \\bot<span class="math">, output 1; else, compute </span>m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho := \\mathsf{PRG}(w^{\\star}) \\oplus e_{\\ell^{\\star}}<span class="math"> and check if </span>\\alpha_{\\ell^{\\star}} = \\mathsf{Com}(m, pp_{\\mathsf{com}}; \\rho)$. If the check fails, output 1; else, output 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the sum of <span class="math">\\mathsf{ct}_{j,\\alpha}</span> for all <span class="math">(j,\\alpha)</span> is at most <span class="math">\\mathsf{ct}</span>, the variable in AUTH-U that keeps track of the number of times honest parties are contacted. In turn, <span class="math">\\mathsf{ct}</span> must be less than <span class="math">\\tau \\cdot g</span> as required by AUTH-U. Thus, there must exist a <span class="math">c_{\\ell^{\\star}}</span> such that <span class="math">\\mathsf{ct}_{j_{\\ell^{\\star}},\\alpha_{\\ell^{\\star}}} &amp;lt; g</span>. This ensures that $j_{\\ell^{\\star}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{\\ell^{\\star}}<span class="math"> is not in the list </span>L$ maintained by Chal.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> simulates AUTH-U perfectly for <span class="math">\\mathcal{A}</span>. Let <span class="math">b&#x27;</span> denote the bit output by <span class="math">\\mathcal{B}</span> at the end. Suppose the bit <span class="math">b</span> in PseudoRand is 0. From the third item in the first paragraph of this section, we can see that AUTH-U outputs 1 only if <span class="math">w_{\\ell} \\neq \\bot</span> and <span class="math">\\alpha_{\\ell} = \\mathsf{Com}(m_{\\ell}, pp_{\\mathsf{com}}; \\rho_{\\ell})</span> succeeds for all <span class="math">\\ell</span> — and, in particular, for <span class="math">\\ell = \\ell^{\\star}</span>. We have assumed that AUTH-U outputs 1 with probability at least <span class="math">\\varepsilon</span>. Thus, <span class="math">\\operatorname{Pr}[b&#x27; = 1 \\mid b = 0] \\leq 1 - \\varepsilon</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the other hand, when <span class="math">b = 1</span>, <span class="math">w^{\\star}</span> is picked at random, so $m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho<span class="math"> is a pseudo-random value. The probability that </span>\\alpha_{\\ell^{\\star}} = \\mathsf{Com}(m, pp_{\\mathsf{com}}; \\rho)<span class="math"> is at most </span>\\mathsf{negl}<span class="math"> for some negligible function </span>\\mathsf{negl}<span class="math"> due to the binding property of </span>\\Sigma<span class="math">. Therefore, </span>\\operatorname{Pr}[b' = 1 \\mid b = 1] \\geq 1 - \\mathsf{negl}$. So,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b ^ {\\prime} = 1 \\mid b = 0 \\right] - \\Pr \\left[ b ^ {\\prime} = 1 \\mid b = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\varepsilon - \\text {n e g l}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-89" class="text-2xl font-bold">C.3 Proof of Theorem 7.6</h2>

    <p class="text-gray-300">In the case of strong authenticity, we cannot assume anymore that the corrupt parties involved in decrypting forged ciphertexts behave honestly. As a result, first of all, we cannot use the consistency property of DPRF alone to argue the indistinguishability of AUTH and AUTH-U. We will need the correctness property too.</p>

    <p class="text-gray-300">We first define a notion called validity for DPRFs which combines both consistency and correctness. Formally, an <span class="math">(n,t)</span>-DPRF DP := (Setup, Eval, Combine) is valid if for all PPT adversaries <span class="math">\\mathcal{A}</span>, there exists a negligible function negl such that the following game outputs 1 with probability at least <span class="math">1 - \\mathrm{negl}(\\kappa)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. Run <span class="math">\\mathsf{Setup}(1^{\\kappa}, n, t)</span> to get <span class="math">((sk_1, \\ldots, sk_n), pp)</span>. Give <span class="math">pp</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Corruption. Receive the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math">. Give the secret-keys </span>\\{sk_i\\}_{i \\in C}<span class="math"> of these parties to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">46</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Evaluation. In response to <span class="math">\\mathcal{A}</span>'s evaluation query <span class="math">(\\text{Eval}, x, i)</span> for some <span class="math">i \\in [n] \\setminus C</span>, return <span class="math">\\text{Eval}(sk_i, x, pp)</span> to <span class="math">\\mathcal{A}</span>. Repeat this step as many times as <span class="math">\\mathcal{A}</span> desires.</li>

      <li>Computation. Receive two sets <span class="math">S_0, S_1</span> of size at least <span class="math">t</span>, an input <span class="math">x^{\\star}</span>, and shares <span class="math">\\{(i, z_{0,i}^{\\star})\\}_{i \\in S_0 \\cap C}</span>, <span class="math">\\{(i, z_{1,i}^{\\star})\\}_{i \\in S_1 \\cap C}</span> from <span class="math">\\mathcal{A}</span>. Let <span class="math">z_{0,j} \\gets \\text{Eval}(sk_j, x^{\\star}, pp)</span> for <span class="math">j \\in S_0 \\setminus C</span> and <span class="math">z_{1,j} \\gets \\text{Eval}(sk_j, x^{\\star}, pp)</span> for <span class="math">j \\in S_1 \\setminus C</span>. Let <span class="math">z_b^{\\star} := \\text{Combine}(\\{j, z_{b,j}\\}_{j \\in S_b \\setminus C} \\cup \\{(i, z_{b,i}^{\\star})\\}_{i \\in S_b \\cap C}, pp)</span> for <span class="math">b \\in \\{0, 1\\}</span>. Output 1 if <span class="math">z_0^{\\star} = \\bot</span> or <span class="math">z_1^{\\star} = \\bot</span> or <span class="math">z_0^{\\star} = z_1^{\\star}</span>; else, output 0.</li>

    </ul>

    <p class="text-gray-300">Notice that validity is different from consistency in the sense that corrupt parties also contribute to DPRF evaluation, and it is different from correctness in the sense that both DPRF evaluations involve corrupt parties (instead of just one).</p>

    <p class="text-gray-300">Fix a PPT adversary <span class="math">\\mathcal{A}</span> for the validity game defined above. Let <span class="math">Z_0^{\\star}</span> and <span class="math">Z_1^{\\star}</span> be random variables that capture the distribution of <span class="math">z_0^{\\star}</span> and <span class="math">z_1^{\\star}</span> in the game, respectively. Define two adversaries <span class="math">\\mathcal{A}_0</span> and <span class="math">\\mathcal{A}_1</span> for the correctness game based on <span class="math">\\mathcal{A}</span> as follows: for <span class="math">b \\in \\{0, 1\\}</span>, <span class="math">\\mathcal{A}_b</span> runs <span class="math">\\mathcal{A}</span> up to the end of the evaluation phase and, when <span class="math">\\mathcal{A}</span> produces its output for the computation phase, <span class="math">\\mathcal{A}_b</span> outputs the <span class="math">b</span>-th part of it (i.e., <span class="math">S_b</span>, <span class="math">x^{\\star}</span> and <span class="math">\\{(i, z_{b,i}^{\\star})\\}_{i \\in S_b \\cap C}</span>). Let <span class="math">\\overline{Z}_b</span> and <span class="math">\\overline{Z}_b^{\\star}</span> be random variables that capture the distribution of <span class="math">z</span> (the true DPRF value) and <span class="math">z^{\\star}</span> in the correctness game with <span class="math">\\mathcal{A}_b</span>, for <span class="math">b \\in \\{0, 1\\}</span>.</p>

    <p class="text-gray-300">On account of DPRF DP being correct, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\bar {Z} _ {b} ^ {\\star} \\in \\{\\bar {Z} _ {b}, \\bot \\} \\right] \\geq 1 - \\varepsilon_ {b} (\\kappa)</span></div>

    <p class="text-gray-300">for <span class="math">b \\in \\{0,1\\}</span> and a negligible function <span class="math">\\varepsilon_{b}</span>. Further, the consistency of DP gives us that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\bar {Z} _ {0} = \\bar {Z} _ {1} \\neq \\bot \\right] \\geq 1 - \\varepsilon</span></div>

    <p class="text-gray-300">for some negligible function <span class="math">\\varepsilon</span>. Now, observe that <span class="math">Z_{b}^{\\star}</span> is identically distributed to <span class="math">\\overline{Z}_b^\\star</span> for <span class="math">b\\in \\{0,1\\}</span> due to the definition of the validity and correctness games as well as the construction of <span class="math">\\mathcal{A}_0</span>, <span class="math">\\mathcal{A}_1</span> from <span class="math">\\mathcal{A}</span>. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\text{Validity game outputs 1} \\right] = \\Pr \\left[ Z _ {0} ^ {\\star} = \\bot \\vee Z _ {1} ^ {\\star} = \\bot \\vee Z _ {0} ^ {\\star} = Z _ {1} ^ {\\star} \\right] \\\\ = \\Pr \\left[ \\bar {Z} _ {0} ^ {\\star} = \\bot \\vee \\bar {Z} _ {1} ^ {\\star} = \\bot \\vee \\bar {Z} _ {0} ^ {\\star} = \\bar {Z} _ {1} ^ {\\star} \\right] \\\\ \\geq \\Pr \\left[ \\begin{array}{c} \\overline {{Z}} _ {0} ^ {\\star} \\in \\{\\overline {{Z}} _ {0}, \\bot \\} \\wedge \\overline {{Z}} _ {1} ^ {\\star} \\in \\{\\overline {{Z}} _ {1}, \\bot \\} \\\\ \\wedge \\overline {{Z}} _ {0} = \\overline {{Z}} _ {1} \\end{array} \\right] \\\\ \\geq 1 - \\left(\\varepsilon_ {0} + \\varepsilon_ {1} + \\varepsilon\\right). \\end{array}</span></div>

    <p class="text-gray-300">Therefore, validity game outputs 1 with all but negligible probability. Since the above analysis holds for any PPT adversary, DP is a valid DPRF.</p>

    <p class="text-gray-300">We now turn to arguing the indistinguishability of AUTH and AUTH-U. The forgery step of AUTH is now different from the previous case. We first write it down in detail here:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathcal{A}</span> outputs <span class="math">((j_1, S_1, c_1), (j_2, S_2, c_2), \\ldots, (j_{k+1}, S_{k+1}, c_{k+1}))</span> s.t. <span class="math">j_\\ell \\in S \\setminus C</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math"> for </span>\\ell \\in [k+1]<span class="math"> and </span>c_u \\neq c_v<span class="math"> for any </span>u \\neq v \\in [k+1]<span class="math">. Let </span>c_\\ell := (j_\\ell, \\alpha_\\ell, e_\\ell)<span class="math"> for </span>\\ell \\in [k+1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\ell \\in [k + 1]</span>,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for <span class="math">i \\in S_{\\ell} \\cap C</span>, send $j_{\\ell} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{\\ell}<span class="math"> to </span>\\mathcal{A}<span class="math"> and get back </span>z_{\\ell,i}^{\\star}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">47</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Compute <span class="math">w_{\\ell} := \\mathsf{Combine}(\\{(i, z_{\\ell,i}^{\\star})\\}_{i \\in S_{\\ell} \\cap C} \\cup \\{(i, z_{\\ell,i}\\}_{i \\in S_{\\ell} \\setminus C}, pp)</span> for <span class="math">\\ell \\in [k + 1]</span>. Output 0 if any <span class="math">w_{\\ell} = \\bot</span>. Else, compute $m_{\\ell} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{\\ell} := \\mathsf{PRG}(w_{\\ell}) \\oplus e_{\\ell}<span class="math"> and check if </span>\\alpha_{\\ell} = \\mathsf{Com}(m_{\\ell}, pp_{\\mathsf{com}}; \\rho_{\\ell})<span class="math">. Output 0 if the check fails for any </span>\\ell$. Else, output 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that corrupt parties can now provide arbitrary shares of DPRF values during the decryption of forged ciphertexts (step 2).</p>

    <p class="text-gray-300">AUTH-U is different from AUTH in the same way as before. Specifically, the difference is in the first step of forgery:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{A}</span> outputs <span class="math">((j_1, S_1, c_1), (j_2, S_2, c_2), \\ldots, (j_{k+1}, S_{k+1}, c_{k+1}))</span> s.t. <span class="math">j_\\ell \\in S \\setminus C</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math"> for </span>\\ell \\in [k + 1]<span class="math"> and </span>c_u \\neq c_v<span class="math"> for any </span>u \\neq v \\in [k + 1]<span class="math">. Let </span>c_\\ell := (j_\\ell, \\alpha_\\ell, e_\\ell)<span class="math"> for </span>\\ell \\in [k + 1]<span class="math">. Output 0 if for any </span>u \\neq v<span class="math">, </span>j_u = j_v<span class="math"> and </span>\\alpha_u = \\alpha_v$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">E</span> denote the event that among the ciphertexts output by the adversary, there exists <span class="math">u \\neq v</span> such that <span class="math">j_u = j_v</span> and <span class="math">\\alpha_u = \\alpha_v</span>. Clearly, the probability that <span class="math">E</span> happens is the same in AUTH and AUTH-U.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix any PPT adversary <span class="math">\\mathcal{A}</span>. We now informally describe an adversary <span class="math">\\mathcal{B}&#x27;</span> who simulates AUTH for <span class="math">\\mathcal{A}</span> with the help of the challenger, say Chal', of the validity game. <span class="math">\\mathcal{B}&#x27;</span> will be able to handle all the encryption and decryption queries of <span class="math">\\mathcal{A}</span> by making evaluation queries to Chal'. When <span class="math">\\mathcal{A}</span> outputs <span class="math">k + 1</span> forgeries, <span class="math">\\mathcal{B}&#x27;</span> will check if the event <span class="math">E</span> occurs or not. If not, then it aborts. Otherwise, <span class="math">\\mathcal{B}&#x27;</span> will pick any <span class="math">u \\neq v</span> s.t. <span class="math">j_u = j_v</span> and <span class="math">\\alpha_u = \\alpha_v</span>. For all <span class="math">\\ell \\in [k + 1] \\setminus \\{u, v\\}</span>, <span class="math">\\mathcal{B}&#x27;</span> will evaluate <span class="math">w_\\ell</span> by making evaluation queries. Then, it will send $(S_u, S_v, j_u \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_u, \\{(i, z_{u,i}^\\star)\\}_{i \\in S_u \\cap C}, \\{(i, z_{v,i}^\\star)\\}_{i \\in S_v \\cap C})<span class="math"> to Chal&#x27;. Assume, for simplicity, that Chal&#x27; returns </span>z_0^\\star<span class="math"> and </span>z_1^\\star<span class="math"> to </span>\\mathcal{B}'<span class="math">, which we refer to as </span>w_u<span class="math"> and </span>w_v<span class="math">, respectively. Now, given </span>w_1, \\ldots, w_{k+1}<span class="math">, </span>\\mathcal{B}'$ outputs the final bit in the same way as AUTH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To show that AUTH and AUTH-U are indistinguishable, all we need to do is argue that when <span class="math">E</span> occurs, AUTH also outputs 0 with high probability. When <span class="math">E</span> occurs, <span class="math">\\mathcal{B}&#x27;</span> is a valid adversary for the validity game. Hence, <span class="math">w_u = \\bot</span>, <span class="math">w_v = \\bot</span> or <span class="math">w_u = w_v</span> with all but negligible probability. In the first two cases, <span class="math">\\mathcal{B}&#x27;</span> clearly outputs 0. Further, in the last case, by the same argument as in the previous proof, <span class="math">\\mathcal{B}&#x27;</span> outputs 0 with high probability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, when using an advantage in AUTH-U to break the pseudorandomness of DP like in the previous proof, the construction of <span class="math">\\mathcal{B}</span> needs to change slightly. Since corrupt parties are involved in the final decryption, they will provide partial shares of DPRF too. Therefore, instead of sending (Challenge, $j_{\\ell^{\\star}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{\\ell^{\\star}}, S_{\\ell^{\\star}}, \\emptyset<span class="math">) to Chal in the forgery step, </span>\\mathcal{B}<span class="math"> will send (Challenge, </span>j_{\\ell^{\\star}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{\\ell^{\\star}}, S_{\\ell^{\\star}}, \\{(i, z_{\\ell^{\\star}, i}^{\\star})_{i \\in S_{\\ell} \\cap C}\\}<span class="math">) instead, where for </span>\\ell \\in [\\tau]<span class="math"> and </span>i \\in S_{\\ell} \\cap C<span class="math">, </span>z_{\\ell, i}^{\\star}<span class="math"> is returned by </span>\\mathcal{A}<span class="math"> when </span>j_{\\ell} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{\\ell}<span class="math"> is sent to it. This change does not affect the argument that if AUTH-U outputs 1 with probability </span>\\varepsilon<span class="math"> then </span>\\mathcal{B}$ will be able to get a similar advantage in the pseudorandomness game.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-90" class="text-2xl font-bold">C.4 Proof of Theorem 8.1</h2>

    <p class="text-gray-300">Recall that a secure DPRF protocol is supposed to provide consistency and pseudo-randomness guarantees but not necessarily correctness. First, it is straightforward to see that <span class="math">\\Pi_{\\mathsf{DDH-DP}}</span> is consistent due to the properties of Shamir's secret sharing.</p>

    <p class="text-gray-300"><strong>Pseudorandomness.</strong> We show that if the DDH assumption holds in group <span class="math">G</span>, then <span class="math">\\Pi_{\\mathsf{DDH-DP}}</span> satisfies the pseudorandomness property in the random oracle model. We will go through several hybrids to establish this. For any PPT adversary <span class="math">\\mathcal{A}</span>, let us first consider the real game <span class="math">\\mathsf{PseudoRand}_{\\Pi_{\\mathsf{DDH-DP}},\\mathcal{A}}(1^{\\kappa},b)</span>. For simplicity, let us denote the game just by <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}}(b)</span>.</p>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">PseudoRand<span class="math">{}_{\\mathcal{A}}(b):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Give the public parameters <span class="math">pp:=(p,g,G)</span> (<span class="math">G</span> is a cyclic group of order <span class="math">p</span> and <span class="math">g</span> is a generator of <span class="math">G</span>) to <span class="math">\\mathcal{A}</span>.</li>

      <li>Program the random oracle <span class="math">\\mathcal{H}</span> as follows: Initialize <span class="math">\\mathcal{L}_{\\mathcal{H}}:=\\emptyset</span>. For random oracle call with input <span class="math">x</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If there exists a tuple <span class="math">(x,r,h)\\in\\mathcal{L}_{H}</span>, output <span class="math">h</span>.</li>

      <li>Otherwise, choose <span class="math">r\\leftarrow_{\\S}\\mathbb{Z}_{p}</span> and set <span class="math">h:=g^{r}</span>. Update <span class="math">\\mathcal{L}_{\\mathcal{H}}:=\\mathcal{L}_{\\mathcal{H}}\\cup(x,r,h)</span> and output <span class="math">h</span>.</li>

    </ol>

    <p class="text-gray-300">Give random oracle access to <span class="math">\\mathcal{A}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a <span class="math">(t-1)</span>-degree random polynomial <span class="math">f</span>. Define <span class="math">s_{i}:=f(i)</span> for <span class="math">i\\in[n]\\cup\\{0\\}</span>. Get the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>. Without loss of generality assume that <span class="math">C=\\{1,\\ldots\\ell\\}</span>. Then send the corresponding secret keys <span class="math">\\{s_{1},\\ldots,s_{\\ell}\\}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>On an evaluation query <span class="math">(\\textsf{Eval},x,i)</span> for an honest <span class="math">i</span>, return <span class="math">\\mathcal{H}(x)^{s_{i}}</span>.</li>

      <li>On the challenge query <span class="math">(\\textsf{Challenge},x^{\\star},S,g_{1}^{\\star},\\ldots,g_{u}^{\\star})</span> for <span class="math">u\\leq\\ell</span> (without loss of generality assume that <span class="math">S\\cap C=[u]</span>):</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If <span class="math">\\mathcal{A}</span> has already made at least $t-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries of the form </span>(\\textsf{Eval},x^{\\star},*)<span class="math">, then output </span>0$ and stop.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">g_{i}^{\\star}:=\\mathcal{H}(x^{\\star})^{s_{i}}</span> for <span class="math">i\\in S\\setminus C</span>.</li>

      <li>Depending on <span class="math">b</span> do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=0</span> then compute <span class="math">z:=\\prod_{i\\in S}g_{i}^{\\star\\lambda_{0,i,S}}</span>.</li>

      <li>Else, choose a random <span class="math">z\\leftarrow_{\\S}G</span>.</li>

      <li>Send <span class="math">z</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Continue answering evaluation queries as before, but if <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">(\\textsf{Eval},x^{\\star},i)</span> for some <span class="math">i\\in[n]\\setminus C</span> and <span class="math">i</span> is the <span class="math">g</span>-th party it contacted, then output <span class="math">0</span> and stop.</li>

      <li>Receive a guess <span class="math">b^{\\prime}</span> from <span class="math">\\mathcal{A}</span>; output <span class="math">b^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">For any adversary <span class="math">\\mathcal{A}</span> that asks evaluation queries on <span class="math">q_{E}</span> distinct <span class="math">x</span>, we now define hybrid games <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{(k)}(b)</span> for <span class="math">k\\in[q_{E}]</span> and <span class="math">b\\in\\{0,1\\}</span>. The only difference between <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{k-1}(b)</span> and <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{k}(b)</span> is the way the evaluation queries for the <span class="math">k</span>-th distinct <span class="math">x</span> are answered. Specifically, in the <span class="math">k</span>-th hybrid these queries are answered using a randomly chosen <span class="math">(t-1)</span>-degree polynomial <span class="math">f^{(k)}</span>, where evaluations of exactly <span class="math">\\ell</span> points match with that of “real polynomial” <span class="math">f</span>, and <span class="math">f^{(k)}</span> is only used to reply to such queries. On the other hand, in the <span class="math">(k-1)</span>-th hybrid the queries on <span class="math">k</span>-th distinct <span class="math">x</span> are answered according to <span class="math">f</span> itself. However, in both the games the evaluation queries for the first <span class="math">k-1</span> distinct <span class="math">x</span> are answered using randomly chosen polynomials and all the subsequent queries (for the <span class="math">(k+1)</span>-th distinct <span class="math">x</span> onwards) are answered using <span class="math">f</span>.</p>

    <p class="text-gray-300">We will formally specify hybrid <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{k}(b)</span> now. Differences with the game PseudoRand are highlighted in red.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(k)}(b):</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Give the public parameters <span class="math">pp := (p, g, G)</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Program the random oracle <span class="math">\\mathcal{H}</span> as follows: Initialize <span class="math">\\mathcal{L}_{\\mathcal{H}} := \\emptyset</span>. For random oracle call with input <span class="math">x</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If there exists a tuple <span class="math">(x, r, h) \\in \\mathcal{L}_{\\mathcal{H}}</span>, output <span class="math">h</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, choose <span class="math">r \\gets_{\\S} \\mathbb{Z}_p</span> and set <span class="math">h := g^r</span>. Update <span class="math">\\mathcal{L}_{\\mathcal{H}} := \\mathcal{L}_{\\mathcal{H}} \\cup (x, r, h)</span> and output <span class="math">h</span>.</li>

    </ol>

    <p class="text-gray-300">Give random oracle access to <span class="math">\\mathcal{A}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a <span class="math">(t - 1)</span>-degree random polynomial <span class="math">f</span>. Define <span class="math">s_i := f(i)</span> for <span class="math">i \\in [n] \\cup \\{0\\}</span>. Get the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>. Without loss of generality assume that <span class="math">C = \\{1, \\ldots, \\ell\\}</span>. Then send the corresponding secret keys <span class="math">\\{s_1, \\ldots, s_\\ell\\}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">k</span> <span class="math">(t - 1)</span>-degree random polynomials <span class="math">f^{(1)}, \\ldots, f^{(k)}</span> with the constraint that for all <span class="math">i \\in [\\ell]</span> and all <span class="math">j \\in [k]</span>, <span class="math">f^{(j)}(i) = s_i</span>. Define <span class="math">\\tilde{s}_i^{(j)} = f^{(j)}(i)</span> for <span class="math">i \\in [n], j \\in [k]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define a function <span class="math">\\mathsf{pc}</span> as follows:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{pc}(x, j, i) := \\left\\{ \\begin{array}{l} \\mathcal{H}(x)^{\\tilde{s}_i^{(j)}} \\text{ if } j \\leq k \\\\ \\mathcal{H}(x)^{s_i} \\text{ otherwise}, \\end{array} \\right.</span></div>

    <p class="text-gray-300">for <span class="math">i \\in [n]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On an evaluation query <span class="math">(\\mathsf{Eval}, x, i)</span> for an honest <span class="math">i</span>, if <span class="math">x</span> is the <span class="math">j</span>-th distinct value, then return <span class="math">\\mathsf{pc}(x, j, i)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On the challenge query (Challenge, <span class="math">x^{\\star}, S, g_1^{\\star}, \\ldots, g_u^{\\star}</span>):</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x^{\\star}</span> was queried in the evaluation phase and it was the <span class="math">j</span>-th distinct value, then let <span class="math">j^{\\star} := j</span>. Else, let <span class="math">j^{\\star} := q_E + 1</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. If <span class="math">\\mathcal{A}</span> has already made at least $t -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries of the form </span>(\\mathsf{Eval}, x^{\\star}, *)$, then output 0 and stop.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">g_i^{\\star} := \\mathsf{pc}(x^{\\star}, j^{\\star}, i)</span> for <span class="math">i \\in S \\setminus C</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Depending on <span class="math">b</span> do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b = 0</span> then compute <span class="math">z := \\prod_{i \\in S} g_i^{\\star \\lambda_{0,i,S}}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else, choose a random <span class="math">z \\gets_{\\S} G</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">z</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue answering evaluation queries as before, but if <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">(\\mathsf{Eval}, x^{\\star}, i)</span> for some <span class="math">i \\in [n] \\setminus C</span> and <span class="math">i</span> is the <span class="math">g</span>-th party it contacted, then output 0 and stop.</li>

    </ol>

    <p class="text-gray-300">50</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive a guess <span class="math">b&#x27;</span> from <span class="math">\\mathcal{A}</span>; output <span class="math">b&#x27;</span>.</li>

    </ol>

    <p class="text-gray-300">It is easy to check that the view of <span class="math">\\mathcal{A}</span> in <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(0)}(b)</span> is identical to that in <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}}(b)</span>. We now prove the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma C.1</strong> For any <span class="math">b \\in \\{0,1\\}</span> and <span class="math">k \\in [q_E]</span>, the outputs of hybrids <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(k-1)}(b)</span> and <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(k)}(b)</span> are computationally indistinguishable.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We show that if there exists a PPT adversary <span class="math">\\mathcal{A}</span> that can distinguish between the hybrids <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{k-1}(b)</span> and <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{k}(b)</span> with non-negligible probability then we can construct a PPT adversary <span class="math">\\mathcal{A}&#x27;</span> that can break an extended version of the DDH assumption with non-negligible probability using <span class="math">\\mathcal{A}</span> as a sub-routine.</p>

    <p class="text-gray-300">A DDH-tuple over a cyclic group <span class="math">G</span> is given by <span class="math">(g, g^{\\alpha}, g^{\\beta}, y)</span> where <span class="math">\\alpha, \\beta \\gets_{\\S} \\mathbb{Z}_p</span> and <span class="math">y</span> is equal to <span class="math">g^{\\alpha \\beta}</span> or a random element in <span class="math">G</span>. The extended version of DDH we consider here is given by <span class="math">(g, g^{\\alpha_0}, g^{\\alpha_1}, g^{\\alpha_w}, g^{\\beta}, y_0, y_1, \\ldots, y_w)</span> where <span class="math">y_i = g^{\\alpha_i \\beta}</span> or random for all <span class="math">i \\in \\{0, \\ldots, w\\}</span>. One can easily show that this extended version of DDH follows from DDH itself (with some polynomial security loss) as long as <span class="math">w</span> is a polynomial.</p>

    <p class="text-gray-300">We now construct <span class="math">\\mathcal{A}&#x27;</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Forward the public parameters <span class="math">pp \\coloneqq (p, g, G)</span> from the DDH challenger to <span class="math">\\mathcal{A}</span>. Receive a DDH-tuple <span class="math">(g^{\\alpha}, g^{\\beta}, y)</span> from the DDH challenger.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Program the random oracle <span class="math">\\mathcal{H}</span> as follows: Initialize <span class="math">\\mathcal{L}_{\\mathcal{H}} := \\emptyset</span>. Let <span class="math">q_{\\mathcal{H}}</span> be the total number of random oracle queries asked in this game. Guess an index <span class="math">\\eta^{*} \\gets_{\\S} [q_{\\mathcal{H}}]</span> randomly. For random oracle call with input <span class="math">x</span>,</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If there exists a tuple <span class="math">(x, r, h) \\in \\mathcal{L}_H</span>, output <span class="math">h</span>.</li>

    </ol>

    <p class="text-gray-300">Otherwise,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if this is the <span class="math">\\eta^*</span>-th call, set <span class="math">r := \\bot</span> and <span class="math">h := g^\\beta</span>, where <span class="math">g^\\beta</span> is from the DDH tuple;</li>

      <li>else, choose <span class="math">r \\gets_{\\S} \\mathbb{Z}_p</span> and set <span class="math">h := g^r</span>.</li>

    </ol>

    <p class="text-gray-300">Update <span class="math">\\mathcal{L}_{\\mathcal{H}} := \\mathcal{L}_{\\mathcal{H}} \\cup (x, r, h)</span> and output <span class="math">h</span>.</p>

    <p class="text-gray-300">Give random oracle access to <span class="math">\\mathcal{A}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Get the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>. Without loss of generality assume that <span class="math">C = \\{1, \\ldots, \\ell\\}</span>. Then proceed as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose random <span class="math">s_i \\gets_{\\S} \\mathbb{Z}_p</span> and define <span class="math">\\hat{g}_i := g^{s_i}</span> for <span class="math">i \\in [\\ell]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Then let <span class="math">\\hat{g}_0 := g^{\\alpha_0}</span> and <span class="math">\\hat{g}_i := g^{\\alpha_i}</span> for <span class="math">i \\in [\\ell + 1, t - 1]</span>, where <span class="math">g^{\\alpha_0}, g^{\\alpha_{\\ell + 1}}, \\ldots, g^{\\alpha_{t - 1}}</span> comes from the DDH-tuple. The values <span class="math">\\alpha_0, s_1, \\ldots, s_\\ell, \\alpha_{\\ell + 1}, \\ldots, \\alpha_{t - 1}</span> define a <span class="math">(t - 1)</span>-degree polynomial <span class="math">f</span>. Setting <span class="math">T := \\{0\\} \\cup [t - 1]</span>, compute <span class="math">\\hat{g}_i := \\prod_{j \\in T} \\hat{g}_j^{\\lambda_{i,j,T}}</span> for all <span class="math">i \\in \\{t, \\ldots, n\\}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">\\{s_1, \\ldots, s_\\ell\\}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">k - 1</span> <span class="math">(t - 1)</span>-degree random polynomials, <span class="math">f^{(1)}, \\ldots, f^{(k - 1)}</span> with the constraint that for all <span class="math">i \\in [\\ell]</span> and all <span class="math">j \\in [k - 1]</span>, <span class="math">f^{(j)}(i) = s_i</span>. Define <span class="math">\\tilde{s}_i^{(j)} := f^{(j)}(i)</span> for <span class="math">i \\in [n], j \\in [k - 1]</span>.</li>

    </ol>

    <p class="text-gray-300">51</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\bar{g}_i := (g^\\beta)^{s_i}</span> for all <span class="math">i \\in [\\ell]</span>. Set <span class="math">\\bar{g}_0 := y_0</span> and <span class="math">\\bar{g}_i := y_i</span> for <span class="math">i \\in [\\ell + 1, t - 1]</span>, where <span class="math">y_0, y_{\\ell + 1}, \\ldots, y_{t - 1}</span> are from the DDH-tuple. Then compute <span class="math">\\bar{g}_i := \\prod_{j \\in T} \\bar{g}_j^{\\lambda_{i,j,T}}</span> for all <span class="math">i \\in \\{t, \\ldots, n\\}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define a function <span class="math">\\mathsf{pc}</span> as follows. On input <span class="math">(x,i,j)</span> for <span class="math">i\\in [n]</span>, <span class="math">\\mathsf{pc}</span> first invokes RO on <span class="math">x</span>. This associates a tuple <span class="math">(x,r,h)</span> with <span class="math">x</span> in <span class="math">\\mathcal{L}_H</span> if there wasn't one already. Now, <span class="math">\\mathsf{pc}</span> returns</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{H}(x)^{\\bar{s}_i^{(j)}}</span> if <span class="math">j &amp;lt; k</span>,</li>

      <li><span class="math">\\bar{g}_i</span> if <span class="math">j = k</span>,</li>

      <li><span class="math">\\hat{g}_i^r</span> if <span class="math">j &amp;gt; k</span> (if <span class="math">r = \\bot</span>, return <span class="math">\\bot</span>).</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On an evaluation query <span class="math">(\\mathsf{Eval}, x, i)</span> for an honest <span class="math">i</span>, if <span class="math">x</span> is the <span class="math">j</span>-th distinct value, then return <span class="math">\\mathsf{pc}(x, j, i)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On the challenge query (Challenge, <span class="math">x^{\\star}, S, g_1^{\\star}, \\ldots, g_u^{\\star}</span>):</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x^{\\star}</span> was queried in the evaluation phase and it was the <span class="math">j</span>-th distinct value, then let <span class="math">j^{\\star} := j</span>. Else, let <span class="math">j^{\\star} := q_E + 1</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. If <span class="math">\\mathcal{A}</span> has already made at least $t -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries of the form </span>(\\mathsf{Eval}, x^{\\star}, *)$, then output 0 and stop.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">g_i^{\\star} \\coloneqq \\mathsf{pc}(x^{\\star}, j^{\\star}, i)</span> for <span class="math">i \\in S \\setminus C</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Depending on <span class="math">b</span> do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b = 0</span> then compute <span class="math">z := \\prod_{i \\in S} g_i^{\\star \\lambda_{0,i,S}}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else, choose a random <span class="math">z \\gets_{\\S} G</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">z</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue answering evaluation queries as before, but if <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">(\\mathsf{Eval}, x^{\\star}, i)</span> for some <span class="math">i \\in [n] \\setminus C</span> and <span class="math">i</span> is the <span class="math">g</span>-th party it contacted, then output 0 and stop.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive a guess <span class="math">b&#x27;</span> from <span class="math">\\mathcal{A}</span>; output <span class="math">b&#x27;</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">x_j</span> denote the <span class="math">j</span>-th distinct <span class="math">x</span> on which an evaluation/challenge query is made. Suppose the first RO query made on <span class="math">x_k</span> is the <span class="math">\\eta</span>-th one. Let us consider the case when <span class="math">\\eta^{\\star} = \\eta</span>. First of all, <span class="math">\\mathsf{pc}</span> never returns <span class="math">\\bot</span> in Step 6. Because <span class="math">r</span> is set to <span class="math">\\bot</span> only for the <span class="math">\\eta^{\\star}</span>-th call and we have assumed that this call is for the <span class="math">k</span>-th distinct <span class="math">x</span>. Secondly, note that RO returns <span class="math">g^\\beta</span> when queried on <span class="math">x_k</span> and <span class="math">\\beta</span> is associated with <span class="math">x_k</span> only.</p>

    <p class="text-gray-300">Let's consider the two possibilities for <span class="math">y_0, y_{\\ell+1}, \\ldots, y_{t-1}</span>. When they are equal to <span class="math">g^{\\alpha_0 \\beta}</span>, <span class="math">g^{\\alpha_{\\ell+1} \\beta}</span>, ..., <span class="math">g^{\\alpha_{t-1} \\beta}</span>, respectively, then <span class="math">\\mathsf{pc}</span>'s return value <span class="math">\\tilde{g}_i</span> on <span class="math">j = k</span> is equal to <span class="math">\\mathcal{H}(x_k)^{f^{(k)}(i)}</span> where <span class="math">f^{(k)}</span> is the <span class="math">(t-1)</span>-degree polynomial that satisfies <span class="math">f^{(k)}(0) = \\alpha_0</span>, <span class="math">f^{(k)}(1) = s_1</span>, ..., <span class="math">f^{(k)}(\\ell) = s_\\ell</span>, <span class="math">f^{(k)}(\\ell+1) = \\alpha_{\\ell+1}</span>, ..., <span class="math">f^{(k)}(t-1) = \\alpha_{t-1}</span>. This is exactly the same polynomial <span class="math">f</span> as defined in Step 3.. Thus <span class="math">\\mathcal{A}&#x27;</span> perfectly simulates <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{k-1}(b)</span> in this case.</p>

    <p class="text-gray-300">When <span class="math">y_0, y_{\\ell+1}, \\ldots, y_{t-1}</span> are random, <span class="math">f^{(k)}</span> is a completely random polynomial except that it "matches" with <span class="math">f</span> on <span class="math">s_1, \\ldots, s_\\ell</span>. Thus, in this case, <span class="math">\\mathcal{A}&#x27;</span> simulates <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^k(b)</span> perfectly.</p>

    <p class="text-gray-300">As a result, when <span class="math">\\eta^{\\star} = \\eta</span>, which happens with probability <span class="math">1 / q_{\\mathcal{H}}</span>, <span class="math">\\mathcal{A}&#x27;</span> distinguishes between the two possibilities described above with non-negligible probability. Since <span class="math">q_{\\mathcal{H}}</span> is polynomial in the security parameter, this breaks the (extended version of) DDH assumption.</p>

    <p class="text-gray-300">52</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, we claim that the views of any adversary in the games <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(q_E)}(0)</span> and <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(q_E)}(1)</span> are statistically close. Irrespective of whether <span class="math">x^{\\star}</span> is queried in the evaluation phase or not, a unique <span class="math">(t - 1)</span>-degree polynomial, say <span class="math">f&#x27;</span>, is used for it. <span class="math">f&#x27;</span> "matches" with any other polynomial only on <span class="math">1, \\ldots, \\ell</span>, and is completely random otherwise. Adversary is allowed to make up to <span class="math">g - 1 = t - \\ell - 1</span> evaluation queries on <span class="math">x^{\\star}</span>. Thus, it could learn <span class="math">\\mathcal{H}(x^{\\star})^{f&#x27;(i)}</span> for <span class="math">g - 1</span> additional values of <span class="math">i</span>. In total, information-theoretically, adversary learns the value of <span class="math">f&#x27;</span> on at most <span class="math">t - 1</span> points. As a result, the product <span class="math">\\prod_{i \\in S} g_i^{\\star \\lambda_{0,i,S}}</span> ($</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math">) computed in the </span>b = 0<span class="math"> case has at least one </span>g_i^{\\star}<span class="math"> for which adversary has no information. So the product appears random to the adversary, making the </span>b = 0<span class="math"> case indistinguishable from </span>b = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-91" class="text-2xl font-bold">C.5 Proof of Theorem 8.2</h2>

    <p class="text-gray-300">A strongly secure DPRF needs to be consistent, pseudorandom and correct. Consistency easily follows from the properties of Shamir's secret sharing and completeness of NIZK.</p>

    <p class="text-gray-300"><strong>Pseudorandomness.</strong> The overall approach is the same as the proof of Theorem 8.1 in Appendix C.4 but due to the presence NIZK and commitments, we need to go through a couple of hybrids. We will use the zero-knowledge property of NIZKs to simulate proofs and the trapdoor property of commitments to produce fake commitments.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}}&#x27;(b)</span> be a shorthand for the game <span class="math">\\mathsf{PseudoRand}_{\\Pi_{\\mathsf{ZK - DDH - DP}},\\mathcal{A}}(1^{\\kappa},b)</span>. We first describe this game in detail, highlighting differences from the game <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}}(b)</span> of Appendix C.4.</p>

    <p class="text-gray-300"><strong>PseudoRand' (b):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">G</span> be a cyclic group of order <span class="math">p</span> and <span class="math">g</span> a generator of <span class="math">G</span>. Sample <span class="math">s \\gets_{\\S} \\mathbb{Z}_p</span> and get <span class="math">(s_1, \\ldots, s_n) \\gets \\mathsf{SSS}(n, t, p, s)</span>. Run <span class="math">\\mathsf{Setup}_{\\mathrm{com}}(1^{\\kappa})</span> to get <span class="math">pp_{\\mathrm{com}}</span>. Compute a commitment <span class="math">\\gamma_i := \\mathsf{Com}(s_i, pp_{\\mathrm{com}}; r_i)</span> by picking <span class="math">r_i</span> at random. Send public parameters <span class="math">pp = (p, g, G, \\gamma_1, \\ldots, \\gamma_n, pp_{\\mathrm{com}})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Get the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>. Without loss of generality assume that <span class="math">C = \\{1, \\ldots, \\ell\\}</span>. Send the corresponding secret keys <span class="math">\\{(s_1, r_1), \\ldots, (s_\\ell, r_\\ell)\\}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>On an evaluation query <span class="math">(\\mathsf{Eval}, x, i)</span> for an honest <span class="math">i</span>, compute <span class="math">w := H(x)</span> and <span class="math">h_i := w^{s_i}</span>. Run <span class="math">\\mathsf{Prove}^{\\mathcal{H}&#x27;}</span> with the statement <span class="math">\\mathsf{stmt}_i</span>: <span class="math">\\{\\exists s, r \\text{ s.t. } h_i = w^s \\wedge \\gamma_i = \\mathsf{Com}(s, pp_{\\mathrm{com}}; r)\\}</span> and witness <span class="math">(s_i, r_i)</span> to obtain a proof <span class="math">\\pi_i</span>. Return <span class="math">((w, h_i), \\pi_i)</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>On the challenge query (Challenge, <span class="math">x^{\\star}, S, ((w, g_1^{\\star}), \\pi_1), \\ldots, ((w, g_u^{\\star}), \\pi_u)</span>) for <span class="math">u \\leq \\ell</span> (without loss of generality assume that <span class="math">S \\cap C = [u]</span>):</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If <span class="math">\\mathcal{A}</span> has already made at least $t -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries of the form </span>(\\mathsf{Eval}, x^{\\star}, *)$, then output 0 and stop.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{Verify}^{\\mathcal{H}&#x27;}(\\mathsf{stmt}_i, \\pi_i) \\neq 1</span> for any <span class="math">i \\in [u]</span>, output 0 and stop.</li>

      <li>Set <span class="math">g_i^{\\star} \\coloneqq \\mathcal{H}(x^{\\star})^{s_i}</span> for <span class="math">i \\in S \\setminus C</span>.</li>

      <li>Depending on <span class="math">b</span> do as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b = 0</span> then compute <span class="math">z := \\prod_{i \\in S} g_i^{\\star \\lambda_{0,i,S}}</span>.</li>

      <li>Else, choose a random <span class="math">z \\gets_{\\S} G</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">z</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Continue answering evaluation queries as before, but if <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">(\\textsf{Eval},x^{\\star},i)</span> for some <span class="math">i\\in[n]\\setminus C</span> and <span class="math">i</span> is the <span class="math">g</span>-th party it contacted, then output <span class="math">0</span> and stop.</li>

      <li>Receive a guess <span class="math">b^{\\prime}</span> from <span class="math">\\mathcal{A}</span>; output <span class="math">b^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">First hybrid. Define a hybrid <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{(zk)}(b)</span> which is similar to <span class="math">\\textsf{PseudoRand}_{\\mathcal{A}}^{\\prime}(b)</span> except that real proofs <span class="math">\\pi_{i}</span> in Step 3. and 5. are replaced with simulated proofs. (As a result, the witness <span class="math">(s_{i},r_{i})</span> is not needed anymore.) <span class="math">\\textsf{PseudoRand}_{\\mathcal{A}}^{\\prime}(b)</span> is indistinguishable from <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{(zk)}(b)</span> for any PPT <span class="math">\\mathcal{A}</span> and <span class="math">b\\in\\{0,1\\}</span> due to the zero-knowledge property of NIZKs.</p>

    <p class="text-gray-300">Second hybrid. Define a hybrid <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{(com)}(b)</span> which is similar to the previous one except:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In step 1., SimSetup of TDC is run to get <span class="math">(pp_{\\textsf{com}}^{\\prime},\\tau_{\\textsf{com}})</span>, <span class="math">pp_{\\textsf{com}}</span> is replaced by <span class="math">pp_{\\textsf{com}}^{\\prime}</span> in the public parameters, and <span class="math">\\gamma_{i}</span> becomes a commitment to some fixed value <span class="math">s^{\\star}</span> for all <span class="math">i\\in[n]</span>.</li>

      <li>In step 2., SimOpen<span class="math">(pp_{\\textsf{com}}^{\\prime},\\tau_{\\textsf{com}},s_{i},(s^{\\star},r_{i}))</span> is run to get randomness <span class="math">r^{\\prime}_{i}</span>, and <span class="math">(s_{1},r^{\\prime}_{1}),\\ldots,</span> <span class="math">(s_{\\ell},r^{\\prime}_{\\ell})</span> is sent to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <p class="text-gray-300">One can see that <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{(zk)}(b)</span> is indistinguishable from <span class="math">\\textsf{Hyb}_{\\mathcal{A}}^{(com)}(b)</span> for any PPT <span class="math">\\mathcal{A}</span> and <span class="math">b\\in\\{0,1\\}</span> due to the trapdoor property of commitments.</p>

    <p class="text-gray-300">Reduction. We now show that if a PPT adversary <span class="math">\\mathcal{A}</span> can distinguish between the <span class="math">b=0</span> and <span class="math">b=1</span> cases in the hybrid game above with a non-negligible probability, then one can build a PPT adversary <span class="math">\\mathcal{A}^{\\prime}</span> to break the pseudorandomness property of the scheme <span class="math">\\Pi_{\\textsf{DDH-DP}}</span>, which would be in contradiction to Theorem 8.1. Let Chal denote the challenger in <span class="math">\\textsf{PseudoRand}_{\\Pi_{\\textsf{DDH-DP}},\\mathcal{A}^{\\prime}}(1^{\\kappa},b)</span>, described in Appendix C.4 using the shorthand <span class="math">\\textsf{PseudoRand}_{\\mathcal{A}^{\\prime}}(b)</span>. We construct <span class="math">\\mathcal{A}^{\\prime}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Get group parameters <span class="math">(p,g,G)</span> from Chal. Run SimSetup of TDC to get <span class="math">pp_{\\textsf{com}}^{\\prime}</span> and <span class="math">\\tau_{\\textsf{com}}</span>. Generate <span class="math">n</span> commitments <span class="math">\\gamma_{1}^{\\prime},\\ldots,\\gamma_{n}^{\\prime}</span> to the fixed value <span class="math">s^{\\star}</span> using randomness <span class="math">r_{1},\\ldots,r_{n}</span>. Send <span class="math">(p,g,G,\\gamma_{1}^{\\prime},\\ldots,\\gamma_{n}^{\\prime},pp_{\\textsf{com}}^{\\prime})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Get the set of corrupt parties <span class="math">C=\\{1,\\ldots,\\ell\\}</span> from <span class="math">\\mathcal{A}</span>. Pass it along to Chal and get back shares <span class="math">s_{1},\\ldots,s_{\\ell}</span>. Run SimOpen<span class="math">(pp_{\\textsf{com}}^{\\prime},\\tau_{\\textsf{com}},s_{i},(\\vec{0},r_{i}))</span> to get randomness <span class="math">r^{\\prime}_{i}</span>. Send <span class="math">(s_{1},r^{\\prime}_{1}),\\ldots,(s_{\\ell},r^{\\prime}_{\\ell})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>On an evaluation query <span class="math">(\\textsf{Eval},x,i)</span> for an honest <span class="math">i</span> from <span class="math">\\mathcal{A}</span>, send the same query to Chal and get back <span class="math">h_{i}</span>. Compute <span class="math">w:=\\mathcal{H}(x)</span> and a simulated proof <span class="math">\\pi^{\\prime}_{i}</span>. Return <span class="math">((w,h_{i}),\\pi^{\\prime}_{i})</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- On the challenge query <span class="math">(\\textsf{Challenge},x^{\\star},S,((w,g_{1}^{\\star}),\\pi_{1}),\\ldots,((w,g_{u}^{\\star}),\\pi_{u}))</span> from <span class="math">\\mathcal{A}</span>, if <span class="math">\\mathcal{A}</span> has already made at least $t-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries of the form </span>(\\textsf{Eval},x^{\\star},*)<span class="math"> or one of the proofs does not verify, then output </span>0<span class="math"> and stop. Query Chal with </span>(\\textsf{Challenge},x^{\\star},S,g_{1}^{\\star},\\ldots,g_{u}^{\\star})<span class="math"> and get back </span>z<span class="math">. Return </span>z<span class="math"> to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue answering evaluation queries as before, but if <span class="math">\\mathcal{A}</span> makes a query of the form <span class="math">(\\textsf{Eval},x^{\\star},i)</span> for some <span class="math">i\\in[n]\\setminus C</span> and <span class="math">i</span> is the <span class="math">g</span>-th party it contacted, then output <span class="math">0</span> and stop.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive a guess <span class="math">b&#x27;</span> from <span class="math">\\mathcal{A}</span>; output <span class="math">b&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300">Observe that for <span class="math">b \\in \\{0,1\\}</span>, when <span class="math">\\mathcal{A}&#x27;</span> is in the game <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}&#x27;}(b)</span>, the view of <span class="math">\\mathcal{A}</span> in the reduction is exactly the same as that in <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(com)}(b)</span>. Thus, if the output of <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(com)}(0)</span> is computationally distinguishable from <span class="math">\\mathsf{Hyb}_{\\mathcal{A}}^{(com)}(1)</span>, the output of <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}&#x27;}(0)</span> would also be so from <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}&#x27;}(1)</span>.</p>

    <p class="text-gray-300"><strong>Correctness.</strong> To prove correctness of <span class="math">\\Pi_{\\mathsf{ZK-DDH-DP}}</span>, we will exploit the extractibility property of proofs and the binding property of commitments. We first describe the correctness game (Definition 5.4) in detail. (The first three steps are same as that of <span class="math">\\mathsf{PseudoRand}_{\\mathcal{A}}&#x27;(b)</span> in Appendix C.5.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">G</span> be a cyclic group of order <span class="math">p</span> and <span class="math">g</span> a generator of <span class="math">G</span>. Sample <span class="math">s \\gets_{\\S} \\mathbb{Z}_p</span> and get <span class="math">(s_1, \\ldots, s_n) \\gets \\mathsf{SSS}(n, t, p, s)</span>. Run <span class="math">\\mathsf{Setup}_{\\mathsf{com}}(1^{\\kappa})</span> to get <span class="math">pp_{\\mathsf{com}}</span>. Compute a commitment <span class="math">\\gamma_i := \\mathsf{Com}(s_i, pp_{\\mathsf{com}}; r_i)</span> by picking <span class="math">r_i</span> at random. Send public parameters <span class="math">pp = (p, g, G, \\gamma_1, \\ldots, \\gamma_n, pp_{\\mathsf{com}})</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>Get the set of corrupt parties <span class="math">C</span> from <span class="math">\\mathcal{A}</span>. Without loss of generality assume that <span class="math">C = \\{1, \\ldots, \\ell\\}</span>. Send the corresponding secret keys <span class="math">\\{(s_1, r_1), \\ldots, (s_\\ell, r_\\ell)\\}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>On an evaluation query <span class="math">(\\mathsf{Eval}, x, i)</span> for an honest <span class="math">i</span>, compute <span class="math">w := H(x)</span> and <span class="math">h_i := w^{s_i}</span>. Run <span class="math">\\mathsf{Prove}^{\\mathcal{H}&#x27;}</span> with the statement <span class="math">\\mathsf{stmt}_i</span>: <span class="math">\\{\\exists s, r \\text{ s.t. } h_i = w^s \\land \\gamma_i = \\mathsf{Com}(s, pp_{\\mathsf{com}}; r)\\}</span> and witness <span class="math">(s_i, r_i)</span> to obtain a proof <span class="math">\\pi_i</span>. Return <span class="math">((w, h_i), \\pi_i)</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li>On the challenge query (Challenge, <span class="math">x^{\\star}, S, ((w, g_1^{\\star}), \\pi_1), \\ldots, ((w, g_n^{\\star}), \\pi_n)</span>) for <span class="math">u \\leq \\ell</span> (without loss of generality assume that <span class="math">S \\cap C = [u]</span>):</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; t<span class="math"> or any of </span>\\pi_1, \\ldots, \\pi_n$ do not verify, output 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else, compute <span class="math">g_j := \\mathcal{H}(x^\\star)^{s_j}</span> for <span class="math">j \\in S</span>, <span class="math">g_i^\\star := \\mathcal{H}(x^\\star)^{s_i}</span> for <span class="math">i \\in S \\setminus C</span>, <span class="math">z := \\prod_{i \\in S} g_i^{\\lambda_{0,i,S}}</span> and <span class="math">z^\\star := \\prod_{i \\in S} g_i^{\\star \\lambda_{0,i,S}}</span>. If <span class="math">z^\\star = z</span>, output 1.</li>

      <li>Else, output 0.</li>

    </ol>

    <p class="text-gray-300">Suppose there exists an adversary <span class="math">\\mathcal{A}</span> s.t. the correctness game reaches the very last step (3.), leading the challenger to output 0, with non-negligible probability. We will show that this leads to a contradiction. Towards this, we define a few intermediate hybrid games. In the first hybrid game, the hash function <span class="math">\\mathcal{H}&#x27;</span> is replaced with the simulator <span class="math">S_1</span> guaranteed by the zero-knowledge property of NIZK.</p>

    <p class="text-gray-300">In the second hybrid, instead of producing a zero in the very last step (3.), the challenger:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>finds an <span class="math">i^{\\star} \\in [u]</span> s.t. <span class="math">g_{i^{\\star}}^{\\star} \\neq g_{i^{\\star}}</span> (such an <span class="math">i^{\\star}</span> exists because <span class="math">z^{\\star} \\neq z</span>);</li>

      <li>invokes the extractor <span class="math">\\mathcal{E}</span> guaranteed by the argument of knowledge property on the adversary with inputs <span class="math">(\\mathsf{stmt}_{i^{\\star}}, \\pi_{i^{\\star}}, Q)</span> (<span class="math">Q</span> is the list of queries made to <span class="math">S_1</span> and their responses); and,</li>

      <li>outputs whatever the extractor does.</li>

    </ul>

    <p class="text-gray-300">If the first hybrid game reaches the very last step, it means that all the proofs provided by <span class="math">\\mathcal{A}</span> were valid. Thus, if the game outputs 0 with non-negligible probability, the challenger will output a witness <span class="math">(s_{i^{\\star}}^{\\prime}, r_{i^{\\star}}^{\\prime})</span> for <span class="math">\\mathsf{stmt}_i</span> with non-negligible probability.</p>

    <p class="text-gray-300">55</p>

    <p class="text-gray-300">In the last hybrid, the challenger outputs <span class="math">(s_{i^{\\star}},r_{i^{\\star}})</span> along with the extracted witness. Since <span class="math">g_{i^{\\star}}^{\\star}\\neq g_{i^{\\star}}</span>, <span class="math">s_{i^{\\star}}^{\\prime}\\neq s_{i^{\\star}}</span>. Therefore, the challenger finds two distinct pairs <span class="math">(s_{i^{\\star}},r_{i^{\\star}})</span> and <span class="math">(s_{i^{\\star}}^{\\prime},r_{i^{\\star}}^{\\prime})</span> that produce the same committed value (with non-negligible probability). This breaks the binding property of TDC.</p>

    <h3 id="sec-92" class="text-xl font-semibold mt-8">C.6 Proof of Theorem 8.4</h3>

    <p class="text-gray-300">First observe that the consistency property is trivially true. Next, we construct a <span class="math">PPT</span> adversary <span class="math">\\mathcal{B}</span> that breaks the security of PRF <span class="math">f</span> if there exists a <span class="math">PPT</span> adversary <span class="math">\\mathcal{A}</span> that gains a non-negligible advantage in the pseudo-randomness game PseudoRand.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> gets access to <span class="math">f_{k^{\\star}}</span> for a randomly chosen <span class="math">k^{\\star}</span> in the PRF game. It can make an arbitrary polynomial number of queries to <span class="math">f_{k^{\\star}}</span>, and output a value <span class="math">x^{\\star}</span> at some point. Then, <span class="math">\\mathcal{B}</span> is supposed to distinguish between <span class="math">f_{k^{\\star}}(x^{\\star})</span> and a random value from the range of <span class="math">f</span>, provided that <span class="math">x^{\\star}</span> was never queried. Let <span class="math">\\gamma</span> denote the PRF challenge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that in PseudoRand adversary is allowed to query on the challenge input in the evaluation phase, but it must make less than $t-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> queries, where </span>C<span class="math"> denotes the set of corrupt parties. Therefore, there is a set of size </span>n-t+1<span class="math"> honest parties that the adversary never queries. We denote this set by </span>D^{\\star}<span class="math">. In the following reduction, </span>\\mathcal{B}<span class="math"> will guess this set at the beginning of the game, and (implicitly) set the key for it to be </span>k^{\\star}<span class="math">. Recall that we have assumed that </span>d:=\\binom{n}{n-t+1}$ is polynomial in the security parameter. So we only suffer a polynomial loss in the security reduction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> plays the role of challenger in PseudoRand with <span class="math">\\mathcal{A}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Initialization and corruption.</em> Define <span class="math">d</span> and <span class="math">D_{1},\\ldots,D_{d}</span> in the same manner as Setup. Pick a subset <span class="math">D^{\\star}</span> of <span class="math">[n]\\setminus C</span> of size <span class="math">n-t+1</span> at random. Implicitly set the key for <span class="math">D^{\\star}</span> to be <span class="math">k^{\\star}</span>. Pick all the other PRF keys at random, use them to define <span class="math">\\{SK_{j}\\}_{j\\in C}</span>, and give <span class="math">\\{SK_{j}\\}_{j\\in C}</span> to <span class="math">\\mathcal{A}</span>. Initialize list <span class="math">L</span> and gap <span class="math">g</span> as in PseudoRand. Add elements to <span class="math">L</span> in the same way as well.</li>

      <li><em>Pre-challenge evaluation queries.</em> Let <span class="math">(\\texttt{Eval},x,i)</span> be an evaluation query for some <span class="math">i\\in[n]\\setminus C</span>. Send <span class="math">h_{i,k}:=f_{k}(x)</span> for all <span class="math">k\\in SK_{i}</span> to <span class="math">\\mathcal{A}</span>. When <span class="math">k=k^{\\star}</span>, query the PRF to get <span class="math">f_{k^{\\star}}(x)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Challenge.</em> Let <span class="math">(\\texttt{Challenge},x^{\\star},S,\\{(i,z_{i}^{\\star})\\}_{i\\in U})</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math"> and </span>U\\subseteq S\\cap C<span class="math"> be the challenge query. If </span>x^{\\star}\\in L<span class="math">, output </span>0<span class="math"> and stop. Let </span>V<span class="math"> be the set of parties queried on </span>x^{\\star}<span class="math"> in the previous phase. If </span>V\\cap D^{\\star}\\neq\\emptyset<span class="math">, then abort. Else, output </span>x^{\\star}<span class="math"> to the PRF challenger and get </span>\\gamma<span class="math"> in return. For </span>i\\in S\\setminus U<span class="math">, compute </span>z_{i}<span class="math"> by evaluating </span>h_{i,k}:=f_{k}(x)<span class="math"> for all </span>k\\in SK_{i}<span class="math">. Whenever </span>k=k^{\\star}<span class="math"> in these evaluations, use </span>\\gamma<span class="math"> as the value for </span>f_{k^{\\star}}(x^{\\star})<span class="math">. Send </span>z^{\\star}:=\\texttt{Combine}(\\{(i,z_{i})\\}_{i\\in S\\setminus U}\\cup\\{(i,z_{i}^{\\star})\\}_{i\\in U},pp)<span class="math"> to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Post-challenge evaluation queries.</em> Same as before. If at any point <span class="math">\\mathcal{A}</span> makes a query of type <span class="math">(\\texttt{Eval},x^{\\star},i)</span> for some <span class="math">i\\in[n]\\setminus C</span> so that <span class="math">i\\in D^{\\star}</span>, then abort.</li>

      <li><em>Guess.</em> Finally, <span class="math">\\mathcal{A}</span> returns a guess <span class="math">b^{\\prime}</span>. Output <span class="math">b^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">As long as <span class="math">\\mathcal{B}</span> does not abort, it perfectly simulates PseudoRand for <span class="math">\\mathcal{A}</span>. If <span class="math">\\gamma=f_{k^{\\star}}(x^{\\star})</span>, then <span class="math">\\mathcal{A}</span> gets the view with <span class="math">b=0</span>, and if <span class="math">\\gamma</span> is random, then <span class="math">\\mathcal{A}</span> gets the view with <span class="math">b=1</span>.</p>

    <h2 id="sec-93" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="DiSE: Distributed Symmetric-key Encryption (2018/727)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/727
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
