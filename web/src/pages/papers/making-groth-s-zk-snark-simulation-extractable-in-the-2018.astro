---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/187';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Making Groth&#x27;s zk-SNARK Simulation Extractable in the Random Oracle Model';
const AUTHORS_HTML = 'Sean Bowe, Ariel Gabizon';

const CONTENT = `    <p class="text-gray-300">Sean Bowe sean@z.cash</p>

    <p class="text-gray-300">Ariel Gabizon ariel@z.cash</p>

    <p class="text-gray-300">Zcash</p>

    <p class="text-gray-300">The purpose of this note is to provide a variant of Groth's zk-SNARK [5] that satisfies simulation extractability, which is a strong form of adaptive non-malleability. Let us call such a construction a zk-SE-SNARK for brevity. A straightforward alteration of the construction gives a succinct Signature of Knowledge (SoK). Our construction of both primitives uses a bilinear group <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T)</span> and a proof/signature requires three <span class="math">\\mathbb{G}_1</span> elements and two <span class="math">\\mathbb{G}_2</span> elements.</p>

    <p class="text-gray-300">Groth and Maller [6] recently gave a construction of zk-SE-SNARKs and SoKs. Their zk-SE-SNARK has the advantage of requiring only 2 <span class="math">\\mathbb{G}_1</span> elements and 1 <span class="math">\\mathbb{G}_2</span> element as in [5]. Their SoK requires an additional string to be output. Furthermore, they rely on concrete assumptions holding in the Generic Group Model, together with a collision-resistant hash function only for the SoK; whereas our analysis for both primitives requires the full generic group model as in [5] together with the random oracle model.<span class="math">^1</span></p>

    <p class="text-gray-300">On the other hand, our work has the practical advantage of the prover/signer requiring only two group operations more than the prover of [5]; whereas [6], as a result of relying on Square Arithmetic Programs [3] rather than Quadratic Arithmetic Programs [4], require twice as many <span class="math">\\mathbb{G}_2</span> operations</p>

    <p class="text-gray-300"><span class="math">^1</span>As discussed with Jens Groth and Mary Maller, it is possible to phrase a concrete assumption holding in the Generic Group Model under which our construction and [5] are secure; however this assumption would be quite strong and have an ad-hoc flavor, and in particular would still be stronger than the assumptions in [6] with one exception: [6] require an assumption following from an “asymmetric” group model where there is no efficient isomorphism from <span class="math">\\mathbb{G}_1</span> to <span class="math">\\mathbb{G}_2</span> or from <span class="math">\\mathbb{G}_2</span> to <span class="math">\\mathbb{G}_1</span>. Our work, as [5], does not require assuming this, and the analysis works in particular when <span class="math">\\mathbb{G}_1 = \\mathbb{G}_2</span>.</p>

    <p class="text-gray-300">as <em>[5]</em>. As <span class="math">\\mathbb{G}_{2}</span> operations are typically much more expensive than <span class="math">\\mathbb{G}_{1}</span> operations, this significantly increases the total running time of the prover <em>[1]</em>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Definitions</h2>

    <p class="text-gray-300">For a relation <span class="math">\\mathsf{R}</span> we denote</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$L_{\\mathsf{R}}:=\\left\\{\\mathbf{x}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\exists\\omega\\;s.t.\\;(\\mathbf{x},\\omega)\\in\\mathsf{R}\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Random oracles</h4>

    <p class="text-gray-300">We assume all parties have access to a random oracle mapping arbitrary strings to uniform elements of a certain domain <span class="math">\\mathcal{D}</span>. When discussing NILPs it will be convenient to assume <span class="math">\\mathcal{D}=\\mathbb{F}_{p}^{<em>}</span> and when discussing SNARKs we’ll assume <span class="math">\\mathcal{D}=\\mathbb{G}_{1}^{</em>}</span>. To clarify we refer to parties as <span class="math">\\mathbb{F}_{p}^{<em>}</span>-oracle machines in the first case, and <span class="math">\\mathbb{G}_{1}^{</em>}</span>-oracle machines in the second.</p>

    <p class="text-gray-300">For a string <span class="math">\\mathsf{s}</span> we’ll denote by <span class="math">y_{\\mathsf{s}}</span> the output of the random oracle on <span class="math">\\mathsf{s}</span>. And we’ll denote <span class="math">Y:=\\{y_{\\mathsf{s}}\\}</span> the set of all such outputs.</p>

    <p class="text-gray-300">We will at times below discuss circuits/algorithms running in time <span class="math">\\mathrm{poly}(\\lambda)</span> doing linear operations on the (infinite) vector <span class="math">Y</span>. What we mean by this is that when the party chooses the matrix <span class="math">\\Pi</span> describing the linear operation, it also chooses a <span class="math">\\mathrm{poly}(\\lambda)</span>-length sequence <span class="math">X</span> of strings <span class="math">\\mathsf{s}</span> all of length <span class="math">\\mathrm{poly}(\\lambda)</span>. And in fact, only applies <span class="math">\\Pi</span> on the vector <span class="math">(Y_{\\mathsf{s}})_{\\mathsf{s}\\in X}</span>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Asymptotics</h4>

    <p class="text-gray-300">Implicitly, all algorithms/circuits and parameters described below depend on an integer security parameter <span class="math">\\lambda</span>. For example, when we discuss a relation <span class="math">\\mathsf{R}</span> we mean an infinite sequence of relations indexed by <span class="math">\\lambda</span>. When we refer in Section 2.1 to a prime field <span class="math">\\mathbb{F}_{p}</span>, we also refer to an infinite sequence of prime fields indexed by <span class="math">\\lambda</span>.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Notation</h4>

    <p class="text-gray-300">For a domain <span class="math">\\mathcal{D}</span> we denote by <span class="math">\\bm{(}\\mathcal{D}\\bm{)}</span> the set of vectors over <span class="math">\\mathcal{D}</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 NILPs</h3>

    <p class="text-gray-300">What we define here as a NILP is what <em>[5]</em> in fact calls a split-NILP, with the addition of participants having access to a random oracle over <span class="math">\\mathbb{F}_{p}^{*}</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.1 (NILPs with a random oracle).</h6>

    <p class="text-gray-300">A Non-Interactive Linear Proof system <span class="math">\\mathscr{N}</span> in the Random-Oracle model (RO-NILP) over prime field <span class="math">\\mathbb{F}_{p}</span> for relation <span class="math">\\mathsf{R}</span> consists of four possibly randomized algorithms <span class="math">(\\mathsf{Gen},\\mathrm{P},\\mathrm{V},\\mathrm{P}^{\\mathrm{sim}})</span> that are <span class="math">\\mathbb{F}_{p}^{*}</span>-oracle machines running in time <span class="math">\\mathrm{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300">######</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}</span> outputting a trapdoor <span class="math">\\tau</span> and common reference string <span class="math">\\sigma=(\\sigma_{1},\\sigma_{2})\\in(\\mathbb{F}_{p})</span>.</li>

      <li><span class="math">\\mathrm{P}</span> that takes as input <span class="math">\\sigma</span> and <span class="math">(\\mathbf{x},\\omega)\\in\\mathsf{R}</span>. <span class="math">\\mathrm{P}</span> first computes, as a function of <span class="math">\\mathbf{x},\\omega</span> only, <span class="math">\\Pi_{1},\\Pi_{2}</span> where <span class="math">\\Pi_{i}</span> is a matrix over <span class="math">\\mathbb{F}_{p}</span>. Then <span class="math">\\mathrm{P}</span> outputs <span class="math">\\pi=(\\pi_{1},\\pi_{2})=(\\Pi_{1}\\cdot(\\sigma_{1},Y),\\Pi_{2}\\cdot\\sigma_{2})</span>. (See explanation about <span class="math">Y</span> in Section 2, “Random Oracles”.)</li>

      <li><span class="math">\\mathrm{V}(\\sigma,\\mathbf{x},\\pi)</span> computes matrices <span class="math">T_{1},\\ldots,T_{d}</span> depending only on <span class="math">\\mathbf{x}</span>. It then outputs <span class="math">\\mathsf{acc}</span> iff for each <span class="math">i\\in[d]</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\sigma_{1},Y,\\pi_{1})\\cdot T_{i}(\\sigma_{2},\\pi_{2})=0.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{P}^{\\mathrm{sim}}</span> taking as input <span class="math">\\mathbf{x}</span>, <span class="math">\\tau</span> and outputting <span class="math">\\pi</span>.</li>

    </ol>

    <p class="text-gray-300">We assume for any <span class="math">\\mathbf{x}\\in L_{\\mathsf{R}}</span> the first coordinate of <span class="math">\\mathbf{x}</span> is one (to enable <span class="math">\\mathrm{P}</span> to always take affine functions of <span class="math">\\sigma</span>).</p>

    <p class="text-gray-300">We say <span class="math">\\mathscr{N}</span> as above is a <em>Simulation-Extractable Non-Interactive Linear Proof system in the Random Oracle model</em> (RO-SE-NILP) over <span class="math">\\mathbb{F}_{p}</span> for <span class="math">\\mathsf{R}</span> if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: for any <span class="math">(\\mathbf{x},\\omega)\\in\\mathsf{R}</span>, if <span class="math">\\pi=\\mathrm{P}(\\mathbf{x},\\omega)</span> then <span class="math">\\mathrm{V}(\\pi)=\\mathsf{acc}</span> with probability one.</li>

      <li>Zero-Knowledge: For any output <span class="math">(\\tau,\\sigma)</span> of <span class="math">\\mathsf{Gen}</span> and <span class="math">(\\mathbf{x},\\omega)\\in\\mathsf{R}</span>, the distribution <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau,\\mathbf{x})</span> is identical to <span class="math">\\mathrm{P}(\\sigma,\\mathbf{x},\\omega)</span>.</li>

      <li>Simulation-Extractability: For any efficient <span class="math">\\mathcal{A}</span> there exists an efficient <span class="math">\\chi</span> such that the following holds: Fix any output <span class="math">(\\tau,\\sigma)</span> of <span class="math">\\mathsf{Gen}</span>. Suppose that <span class="math">\\mathcal{A}</span> makes a non-adaptive sequence of queries <span class="math">Q=\\{\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{\\ell}\\}</span> to <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau,\\cdot)</span>, that returns answers <span class="math">A=\\{(\\mathbf{x}_{1},\\pi_{1}),\\ldots,(\\mathbf{x}_{\\ell},\\pi_{\\ell})\\}</span>. Finally <span class="math">\\mathcal{A}</span> computes matrices <span class="math">T_{1},T_{2}</span> depending only on <span class="math">\\mathbf{x}</span> and outputs <span class="math">\\pi=(\\pi_{1},\\pi_{2})</span> with <span class="math">\\pi_{i}:=(A,\\sigma_{i})\\cdot T_{i}</span>. <span class="math">\\chi</span> given <span class="math">\\mathbf{x},T_{1},T_{2}</span> outputs <span class="math">\\omega</span>. The probability that</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> “wins”: <span class="math">(\\mathbf{x},\\pi)\\notin A</span> and also <span class="math">\\mathrm{V}(\\mathbf{x},\\pi)=\\mathsf{acc}</span>, while</li>

      <li><span class="math">\\chi</span> “loses”: <span class="math">(\\mathbf{x},\\omega)\\notin\\mathsf{R}</span></li>

    </ul>

    <p class="text-gray-300">is <span class="math">\\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We say a NILP over <span class="math">\\mathbb{F}_{p}</span> has degree <span class="math">d</span> if <span class="math">\\mathsf{Gen}</span> and <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span> consist of sampling a random vector <span class="math">\\mathbf{z}</span> over <span class="math">\\mathbb{F}_{p}</span> and outputting <span class="math">\\left\\{P_{i}(\\mathbf{z})\\right\\}_{i\\in[s]}</span> where <span class="math">P_{i}</span> is a polynomial over <span class="math">\\mathbb{F}_{p}</span> of degree at most <span class="math">d</span>.</p>

    <p class="text-gray-300">The set of polynomials <span class="math">\\left\\{P_{i}\\right\\}_{i\\in[s]}</span> possibly depends on <span class="math">\\mathbf{x}</span> in the case of <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span>, but must not depend on the value of <span class="math">\\tau</span> in both cases.</p>

    <p class="text-gray-300">2.2 Adaptive NILP adversaries</p>

    <p class="text-gray-300">In the regular soundness and simulation extractability definitions of a NILP, the adversary must choose his matrices and the resultant output as a function only of the public input <span class="math">\\mathbf{x}</span>. We give a definition of a more adaptive adversary that may check if a certain bilinear relation holds amongst the CRS elements, and take into account the result of these checks when constructing his proof. This exactly captures the power of an adversary in the generic group model when we compile the NILP into a SNARK as in <em>[5]</em> using a bilinear group. We will encorporate into our definition the interaction of the adversary with a party like <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span> and his access to a random oracle with <span class="math">\\mathbb{F}_{p}^{*}</span> output.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.2 (Adaptive bilinear adversary).</h6>

    <p class="text-gray-300">An <em>adaptive bilinear adversary</em> <span class="math">\\mathcal{A}</span> over <span class="math">\\mathbb{F}_{p}</span> is a <span class="math">\\mathbb{F}_{p}^{*}</span>-oracle machine operating as follows. It begins with an explicit input <span class="math">\\mathbf{x}</span>, and auxiliary inputs <span class="math">\\sigma_{1},\\sigma_{2}\\in(\\mathbb{F}_{p})</span>. It initializes an empty vector <span class="math">U</span> that will hold boolean values. At each step <span class="math">\\mathcal{A}</span> does the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Depending only on <span class="math">\\mathbf{x}</span> and the value of the vector <span class="math">U</span>, it chooses matrices <span class="math">\\Pi_{1},\\Pi_{2},T</span> over <span class="math">\\mathbb{F}_{p}</span> and possibly also a message <span class="math">m</span>.</li>

      <li>If <span class="math">\\mathcal{A}</span> is in interaction with a party <span class="math">\\mathsf{P}</span> it may send <span class="math">\\mathsf{P}</span> the message <span class="math">m</span>, and if <span class="math">\\mathsf{P}</span> replies with a vector <span class="math">v_{1}</span> of <span class="math">\\mathbb{G}_{1}</span> elements and <span class="math">v_{2}</span> of <span class="math">\\mathbb{G}_{2}</span> elements, <span class="math">\\mathcal{A}</span> appends <span class="math">v_{1}</span> to <span class="math">\\sigma_{1}</span> and <span class="math">v_{2}</span> to <span class="math">\\sigma_{2}</span>.</li>

      <li>It then checks if <span class="math">(\\sigma_{1},Y)\\cdot(T\\cdot\\sigma_{2})=0</span> and adds the value <span class="math">0</span> to <span class="math">U</span> if so, and adds the value <span class="math">1</span> to <span class="math">U</span> otherwise.</li>

    </ol>

    <p class="text-gray-300">After each step <span class="math">\\mathcal{A}</span> decides whether to continue or terminate, in which case it outputs matrices <span class="math">\\Pi_{1},\\Pi_{2}</span> and the values <span class="math">(\\sigma_{1},Y)\\cdot\\Pi_{1},\\sigma_{2}\\cdot\\Pi_{2}</span>. All decisions (on whether to terminate and what values to output), depend only on <span class="math">\\mathbf{x}</span> and the values in <span class="math">U</span> at that point.</p>

    <p class="text-gray-300">We say that an RO-SE-NILP <span class="math">\\mathscr{N}</span> is an <em>Adaptively-Bilinear Simulation-Extractable NILP</em> (AB-SE-NILP) if the simulation extractability property holds also with respect to adpatively bilinear adversaries making at most <span class="math">\\mathrm{poly}(\\lambda)</span> steps, adaptively making queries <span class="math">\\{\\mathbf{x}_{i}\\}</span> to <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau,\\cdot)</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 2.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathscr{N}</span> is a degree <span class="math">d</span> RO-SE-NILP over <span class="math">\\mathbb{F}_{p}</span> for a relation <span class="math">\\mathsf{R}</span>, where $d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{negl}(\\lambda)<span class="math">, then it is also an AB-SE-NILP over </span>\\mathbb{F}_{p}<span class="math"> for </span>\\mathsf{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is based on Lemma 1 and Theorem 2 of <em>[5]</em>. Let <span class="math">\\mathcal{A}</span> be an adaptive bilinear adversary. We assume for simplicity <span class="math">\\mathcal{A}</span> is deterministic (if there exists a randomized circuit <span class="math">\\mathcal{A}</span> breaking simulation extractability there</p>

    <p class="text-gray-300">exists a fixing of its randomness where it breaks simulation extractability). We construct a non-adaptive adversary <span class="math">\\mathcal{A}</span>’ such that for any <span class="math">\\mathbf{x}</span>, the probability over the randomness of <span class="math">\\mathsf{Gen}</span> when outputting <span class="math">\\sigma</span> and the randomness of <span class="math">\\mathrm{P}^{\\text{sim}}</span> in its replies that <span class="math">\\mathcal{A}(\\mathbf{x},\\sigma)\\neq\\mathcal{A}^{\\prime}(\\mathbf{x},\\sigma)</span> is <span class="math">\\mathrm{negl}(\\lambda)</span>. This means that the extractor <span class="math">\\chi</span> for <span class="math">\\mathcal{A}</span>’ guaranteed to exist by the properties of an RO-SE-NILP is also good for <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{A}</span>’ works as follows. He begins running <span class="math">\\mathcal{A}</span> on <span class="math">(\\sigma,\\mathbf{x})</span>. In the first step he is able to choose the matrices <span class="math">\\Pi_{1},\\Pi_{2},T</span> and message <span class="math">m</span> to <span class="math">\\mathrm{P}^{\\text{sim}}</span> (consisting of the desired inputs <span class="math">\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{\\ell}</span> on which <span class="math">\\mathcal{A}</span> wishes to see simulated proofs), as <span class="math">\\mathcal{A}</span> would have chosen them, as in the first step these depend only on <span class="math">\\mathbf{x}</span> and the empty vector <span class="math">U</span>.</p>

    <p class="text-gray-300">The main question is what to do when <span class="math">\\mathcal{A}</span> wishes to do the bilinear check:</p>

    <p class="text-gray-300"><span class="math">(\\sigma_{1},Y)\\cdot(T\\cdot\\sigma_{2})\\stackrel{{\\scriptstyle?}}{{=}}0.</span></p>

    <p class="text-gray-300">and insert its result into <span class="math">U</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we denote by <span class="math">\\mathbf{z}</span> the variables used by <span class="math">\\mathsf{Gen}</span> and <span class="math">\\mathrm{P}^{\\text{sim}}</span>, the main point is that this equation corresponds to an equation of degree at most <span class="math">2d</span> between polynomials in <span class="math">\\mathbf{z},Y</span>. It follows from the Schwartz-Zippel Lemma that if the equation is not a polynomial identity, equality will hold with probability at most $2d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{negl}(\\lambda)<span class="math">. Motivated by this, </span>\\mathcal{A}<span class="math">’ returns </span>0<span class="math"> to </span>\\mathcal{A}<span class="math"> if the equation is a polynomial identity and </span>1<span class="math"> otherwise. He proceeds to run </span>\\mathcal{A}<span class="math"> until the next bilinear check, where again the check will be a polynomial equation (<em>fully determined by the matrices chosen by </span>\\mathcal{A}<span class="math"> up to this point</em>), and he responds to </span>\\mathcal{A}$ using the same strategy.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, <span class="math">\\mathcal{A}</span>’ outputs <span class="math">(\\mathcal{A})</span>’s output in the end of this process. The probability that their outputs differ is at most the probability that one of <span class="math">(\\mathcal{A})</span>’s responses to the bilinear checks was different from the correct response given the values of <span class="math">\\sigma</span> and <span class="math">\\mathrm{P}^{\\text{sim}}</span>’s replies. This probability is union bounded by <span class="math">\\mathrm{poly}(\\lambda)\\cdot\\mathrm{negl}(\\lambda)=\\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-12" class="text-2xl font-bold">3 The construction</h2>

    <p class="text-gray-300">We describe our NILP construction. It is based on the variant of <em>[5]</em> described in <em>[2]</em> where the CRS is slightly extended (this extension was important to <em>[2]</em> for their multi-party computation protocol, and is not crucial here). We use the same notation regarding QAPs as in <em>[2, 5]</em>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathscr{Q}=\\left\\{\\{u_{i}\\}_{i\\in[0..m]},\\{v_{i}\\}_{i\\in[0..m]},\\{w_{i}\\}_{i\\in[0..m]},t\\right\\}</span> be a QAP over <span class="math">\\mathbb{F}_{p}</span> of degree <span class="math">n</span> and size <span class="math">m</span>. Let <span class="math">0&lt;\\ell&lt;m</span> be an integer. We define the relation <span class="math">\\mathsf{R}</span></p>

    <p class="text-gray-300">to consist of all pairs <span class="math">(\\mathbf{x} = (a_0 = 1, a_1, \\ldots, a_\\ell), \\omega = (a_{\\ell + 1}, \\ldots, a_m))</span> such that <span class="math">(a_0, \\ldots, a_m)</span> satisfies <span class="math">\\mathcal{Q}</span> (see [5] for a definition of QAPs in this notation).</p>

    <p class="text-gray-300">We use the shorthand <span class="math">\\mathsf{ic} \\coloneqq \\sum_{i=0}^{\\ell} a_i (\\beta u_i(x) + \\alpha v_i(x) + w_i(x))</span> below. This is the element relating to the primary QAP input <span class="math">\\mathbf{x} = (a_0 = 1, a_1, \\ldots, a_\\ell)</span>.</p>

    <p class="text-gray-300">We present a NILP for the relation <span class="math">\\mathsf{R}</span>.</p>

    <p class="text-gray-300">The idea is to have the prover randomize the <span class="math">\\delta</span> element of the CRS with a secret scalar, and require her to prove knowledge of this secret scalar. This creates a situation where the adversary <span class="math">\\mathcal{A}</span> must use his own different randomization of <span class="math">\\delta</span>, making it hard for him to use elements from <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span>'s simulated proofs.</p>

    <p class="text-gray-300"><strong>Generator Gen:</strong> Choose uniform elements <span class="math">\\alpha, \\beta, \\delta, x \\in \\mathbb{F}_p^*</span>.</p>

    <p class="text-gray-300">Output:</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {1} := \\left\\{\\alpha , \\beta , \\delta , \\left\\{x ^ {i} \\right\\} _ {i \\in [ 0.. 2 n - 2 ]}, \\left\\{\\alpha x ^ {i} \\right\\} _ {i \\in [ 1.. n - 1 ]}, \\left\\{\\beta x ^ {i} \\right\\} _ {i \\in [ 1.. n - 1 ]}, \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left. \\left\\{\\frac {\\beta u _ {i} (x) + \\alpha v _ {i} (x) + w _ {i} (x)}{\\delta} \\right\\} _ {i \\in [ \\ell + 1.. m ]}, \\left\\{\\frac {x ^ {i} \\cdot t (x)}{\\delta} \\right\\} _ {i \\in [ 0.. n - 2 ]} \\right\\} \\\\ \\sigma_ {2} := \\left\\{\\beta , \\delta , \\left\\{x ^ {i} \\right\\} _ {i \\in [ 0.. n - 1 ]} \\right\\} \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><strong>Prover P:</strong> Fix public input <span class="math">a_1, \\ldots, a_\\ell</span>. P, given witness <span class="math">\\omega = (a_{\\ell+1}, \\ldots, a_m)</span> does the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>She chooses a random element <span class="math">d \\in \\mathbb{F}_p^*</span>, and computes <span class="math">\\delta&#x27; := d \\cdot \\delta</span>.</li>

      <li>She chooses random <span class="math">r, s \\in \\mathbb{F}_p</span>.</li>

      <li>She computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A := \\alpha + \\sum_ {i = 0} ^ {m} a _ {i} u _ {i} (x) + r \\delta^ {\\prime}, B := \\beta + \\sum_ {i = 0} ^ {m} b _ {i} v _ {i} (x) + s \\delta^ {\\prime}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>She computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C := \\frac {\\sum_ {i = \\ell + 1} ^ {m} a _ {i} (\\beta u _ {i} (x) + \\alpha v _ {i} (x) + w _ {i} (x)) + h (x) t (x)}{\\delta^ {\\prime}} + A s + B r - r s \\delta^ {\\prime}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\mathsf{s} \\coloneqq (A, B, C, \\delta&#x27;)</span>, and <span class="math">z \\coloneqq y_{\\mathsf{s}} \\cdot d</span>.</li>

      <li>She outputs <span class="math">\\pi_1 = (A, C, z), \\pi_2 = (B, \\delta&#x27;)</span>.</li>

    </ol>

    <p class="text-gray-300">Verifier V: Given <span class="math">A, B, C, \\delta&#x27;, z</span>, check that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A \\cdot B = \\alpha \\cdot \\beta + \\mathrm{i}c + C \\cdot \\delta&#x27;</span>.</li>

      <li><span class="math">y_{\\mathfrak{s}} \\cdot \\delta&#x27; = z \\cdot \\delta</span>; for <span class="math">\\mathfrak{s} := (A, B, C, \\delta&#x27;)</span>.</li>

    </ol>

    <p class="text-gray-300">Simulator <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span>: Given <span class="math">\\alpha, \\beta, \\delta, x</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose random <span class="math">\\delta&#x27; \\in \\mathbb{F}_p^*</span>.</li>

      <li>Choose random <span class="math">A, B \\in \\mathbb{F}_p</span> and let</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C := \\frac {A \\cdot B - \\mathrm{i} \\mathrm{c} - \\alpha \\beta}{\\delta^ {\\prime}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathfrak{s} := (A, B, C, \\delta&#x27;)</span>, and <span class="math">z := y_{\\mathfrak{s}} \\cdot (\\delta&#x27; / \\delta)</span>.</li>

      <li>Output <span class="math">\\pi_1 = (A, C, z), \\pi_2 = (B, \\delta&#x27;)</span>.</li>

    </ol>

    <p class="text-gray-300">Theorem 4.1. The above construction is an RO-SE-NILP for <span class="math">\\mathsf{R}</span> over <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300">An immediate corollary from Theorem 2.3 is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 4.2. If we are starting from a QAP of degree <span class="math">d</span> over <span class="math">\\mathbb{F}_p</span>, and $d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)$; then the above construction is an AB-SE-NILP.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. (of Theorem 4.1) Completeness and Zero-Knowledge are straightforward and almost identical to [5]. We concentrate on simulation extractability. Suppose <span class="math">\\mathcal{A}</span> has made a sequence of queries <span class="math">\\mathbf{x}_1, \\ldots, \\mathbf{x}_v</span> to <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau, \\cdot)</span>, and received answers <span class="math">\\{\\pi_j = (A_j, B_j, C_j, \\delta_j, z_j)\\}_{j \\in [v]}</span>. Denote <span class="math">\\mathfrak{s}_j := (A_j, B_j, C_j, \\delta_j)</span>. Let <span class="math">Q&#x27;</span> be the union of elements in the CRS <span class="math">(\\sigma_1, \\sigma_2)</span> together with those from the random oracle and <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span>'s replies; so</p>

    <div class="my-4 text-center"><span class="math-block">Q&#x27; := \\left\\{\\delta, \\left\\{x^i \\right\\}_{i \\in [0..2n-2]}, \\left\\{\\alpha x^i, \\beta x^i \\right\\}_{i \\in [0..n-1]}, \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left. \\left\\{\\frac {\\beta u _ {i} (x) + \\alpha v _ {i} (x) + w _ {i} (x)}{\\delta} \\right\\} _ {i \\in [\\ell+1..m]}, \\left\\{\\frac {x ^ {i} \\cdot t (x)}{\\delta} \\right\\} _ {i \\in [0..n-2]} \\right\\} \\cup</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cup \\left\\{Y _ {\\mathfrak {s}} \\right\\} _ {s t r i n g \\mathfrak {s}} \\cup \\left\\{A _ {j}, B _ {j}, C _ {j} = \\frac {A _ {j} B _ {j} - \\alpha \\beta - \\mathrm {i} \\mathrm {c} _ {j}}{\\delta_ {j}}, \\delta_ {j}, \\frac {\\delta_ {j} Y _ {\\mathfrak {s} _ {j}}}{\\delta} \\right\\} _ {j \\in [v]}.</span></div>

    <p class="text-gray-300">We emphasize that we think of <span class="math">x,\\alpha,\\beta,\\delta,\\{A_{j},B_{j},\\delta_{j}\\}\\,,\\{Y_{\\mathsf{s}}\\}</span> as formal variables in this proof. Thus, the elements of <span class="math">Q^{\\prime}</span>, and all other elements discussed here, belong to the ring of Laurent polynomials in these variables, i.e.</p>

    <p class="text-gray-300"><span class="math">K:=\\mathbb{F}_{p}\\left[x,x^{-1},\\alpha,\\alpha^{-1},\\beta,\\beta^{-1},\\delta,\\delta^{-1},\\left\\{A_{j},B_{j},\\delta_{j},A_{j}^{-1},B_{j}^{-1},\\delta_{j}^{-1}\\right\\},\\left\\{Y_{\\mathsf{s}},Y_{\\mathsf{s}}^{-1}\\right\\}\\right]</span></p>

    <p class="text-gray-300">Motivated by this, when we use the term <em>monomial</em> henceforth, we mean a Laurent monomial, i.e. a ratio of two monomials, in the variables <span class="math">\\{x,\\alpha,\\beta,\\delta,\\{A_{j},B_{j},\\delta_{j}\\}\\,,\\{Y_{\\mathsf{s}}\\}\\}</span> with no common factors between numerator and denumerator, e.g. <span class="math">\\frac{\\alpha A_{3}}{\\delta_{2}}</span>.</p>

    <p class="text-gray-300">Observe that the elements of <span class="math">Q^{\\prime}</span> are linearly independent over <span class="math">\\mathbb{F}_{p}</span>, thus any element in <span class="math">\\mathrm{span}(Q^{\\prime})</span> has a unique representation as an <span class="math">\\mathbb{F}_{p}</span>-linear combination of elements of <span class="math">Q^{\\prime}</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{A}</span> has produced elements <span class="math">A,B,C,\\delta^{\\prime},z\\in\\mathrm{span}(Q^{\\prime})</span> such that</p>

    <p class="text-gray-300"><span class="math">A\\cdot B\\equiv C\\cdot\\delta^{\\prime}+\\mathsf{i}\\mathsf{c}+\\alpha\\beta</span></p>

    <p class="text-gray-300">and, for <span class="math">\\mathsf{s}:=(A,B,C,\\delta^{\\prime})</span>,</p>

    <p class="text-gray-300"><span class="math">\\delta^{\\prime}\\cdot Y_{\\mathsf{s}}\\equiv\\delta\\cdot z.</span></p>

    <p class="text-gray-300">For <span class="math">M\\in Q^{\\prime}</span> and <span class="math">P\\in\\{A,B,C,\\delta^{\\prime},z\\}</span>, we denote by <span class="math">P(M)</span> the coefficient of <span class="math">M</span> when writing <span class="math">P</span> as a linear combination of elements of <span class="math">Q^{\\prime}</span>.</p>

    <p class="text-gray-300">Denote <span class="math">V:=\\left\\{\\left\\{\\delta_{j},A_{j},B_{j}\\right\\}_{j\\in\\left[v\\right]},\\left\\{Y_{\\mathsf{s}}\\right\\}_{\\mathrm{string}\\ \\mathsf{s}}\\right\\}</span></p>

    <p class="text-gray-300">These are the new variables not appearing in <span class="math">(\\sigma_{1},\\sigma_{2})</span> - which is exactly the CRS of <em>[2]</em>.</p>

    <p class="text-gray-300">We show that <span class="math">A,B,C</span> do not use elements of <span class="math">Q^{\\prime}</span> involving the variables <span class="math">V</span> and thus <span class="math">\\mathcal{A}</span> only uses the elements in the CRS of <em>[2]</em> to generate <span class="math">A,B,C</span>. From this point the proofs in <em>[2, 5]</em> imply that a witness <span class="math">\\omega</span> with <span class="math">(\\mathbf{x},\\omega)\\in\\mathsf{R}</span> can be extracted from <span class="math">A,B,C</span> except with probability <span class="math">\\mathrm{negl}(\\lambda)</span>. We first introduce some terminology.</p>

    <p class="text-gray-300">For a <em>monic</em> monomial <span class="math">M</span> and <span class="math">P\\in K</span>, we write <span class="math">M\\in P\\setminus\\{A,B\\}</span> to mean <span class="math">M</span> appears with non-zero coefficient when writing <span class="math">P</span> as a linear combination of monic monomials. (For <span class="math">P\\in\\{A,B\\}</span> we will use the same notation instead for elements of <span class="math">M\\in Q^{\\prime}</span> to indicate whether <span class="math">M</span> is used with non-zero coefficient when writing <span class="math">P</span> as a combination of <span class="math">Q^{\\prime}</span> elements.)</p>

    <p class="text-gray-300">For <span class="math">P\\in K,P\\neq A,B,C,\\delta^{\\prime},z</span>, we denote by <span class="math">P(M)</span> the coefficient of <span class="math">M</span> when writing <span class="math">P</span> as a linear combination of monic monomials.</p>

    <p class="text-gray-300">For two monomials <span class="math">M,M^{\\prime}</span> we use the notation <span class="math">M\\sim M^{\\prime}</span> to mean <span class="math">M=c\\cdot M^{\\prime}</span> for some <span class="math">c\\in\\mathbb{F}_{p}^{*}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">At times below, it will be convenient to work with the following set <span class="math">Q</span> of monic monomials such that <span class="math">\\operatorname{span}(Q&#x27;) \\subseteq \\operatorname{span}(Q)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">Q := \\{\\delta\\} \\cup \\left\\{x^{i}, \\alpha x^{i}, \\beta x^{i}, x^{i}/\\delta, \\alpha x^{i}/\\delta, \\beta x^{i}/\\delta\\right\\}_{i \\in [0..2n-2]} \\cup \\left\\{Y_{\\mathbf{s}}\\right\\}_{\\text{string } \\mathbf{s}} \\cup</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{A_{j}, B_{j}, \\frac{A_{j}B_{j}}{\\delta_{j}}, \\frac{\\alpha\\beta}{\\delta_{j}}, \\left\\{x^{i}/\\delta_{j}, \\alpha x^{i}/\\delta_{j}, \\beta x^{i}/\\delta_{j}\\right\\}_{i \\in [0..n-1]}, \\delta_{j}, \\frac{\\delta_{j}Y_{\\mathbf{s}_{j}}}{\\delta}\\right\\}_{j \\in [v]}.</span></div>

    <p class="text-gray-300">The second equation implies</p>

    <div class="my-4 text-center"><span class="math-block">z \\equiv \\frac{\\delta&#x27;}{\\delta} \\cdot Y_{\\mathbf{s}}.</span></div>

    <p class="text-gray-300">This means that if <span class="math">M \\in z</span>, we have <span class="math">M \\in Q</span> and <span class="math">M\\delta / Y_{\\mathbf{s}} \\in Q</span>, because <span class="math">z, \\delta&#x27; \\in \\operatorname{span}(Q)</span>. Inspection shows the possibilities for such monic <span class="math">M</span> are <span class="math">Y_{\\mathbf{s}}</span>, and in the case <span class="math">\\mathbf{s} = \\mathbf{s}_j</span> for some <span class="math">j \\in [v]</span>, also <span class="math">\\frac{\\delta_j Y_{\\mathbf{s}_j}}{\\delta}</span>. We wish to rule out the second: Note that for a verifying proof <span class="math">\\pi</span>, the value of <span class="math">z</span> is determined by <span class="math">A, B, C, \\delta&#x27;</span>. Hence if two verifying proofs agree on the first four elements <span class="math">A, B, C, \\delta&#x27;</span>, they are identical. Conversely, if <span class="math">\\pi \\neq \\pi_j, \\forall j \\in [v]</span> we also have <span class="math">\\mathbf{s} \\neq \\mathbf{s}_j, \\forall j \\in [v]</span>.</p>

    <p class="text-gray-300">So we must have <span class="math">z \\sim Y_{\\mathbf{s}}</span>. This implies <span class="math">\\delta&#x27; \\sim \\delta</span>.</p>

    <p class="text-gray-300">We introduce some more notation before proceeding. Denote <span class="math">C^* := C \\cdot \\delta&#x27;, C_0 := \\mathrm{i}\\mathbf{c} + \\alpha\\beta</span>. Thus, we have</p>

    <div class="my-4 text-center"><span class="math-block">AB \\equiv C^* + C_0</span></div>

    <p class="text-gray-300">Denote</p>

    <div class="my-4 text-center"><span class="math-block">Q_0 := \\left\\{x^{i}, \\alpha x^{i}, \\beta x^{i}\\right\\}_{i \\in [0..2n-2]} \\cup \\{\\alpha\\beta\\}</span></div>

    <p class="text-gray-300">Note that <span class="math">C_0 \\in \\operatorname{span}(Q_0)</span>. We often use the argument below that if <span class="math">M \\in AB</span> but <span class="math">M \\notin \\operatorname{span}(Q_0)</span> we must have <span class="math">M \\in C^*</span> and therefore <span class="math">M/\\delta&#x27; \\in C</span>; and since we showed <span class="math">\\delta&#x27; \\sim \\delta</span> this means that <span class="math">M/\\delta \\in C</span>.</p>

    <p class="text-gray-300">We now show that <span class="math">\\alpha \\in A, \\beta \\in B</span> or <span class="math">\\alpha \\in B, \\beta \\in A</span>:</p>

    <p class="text-gray-300">For this we first claim that <span class="math">\\alpha\\beta \\in AB</span>: We have <span class="math">\\alpha\\beta \\in C_0</span>. It suffices to show <span class="math">\\alpha\\beta \\notin C \\cdot \\delta&#x27;</span>. <span class="math">\\alpha\\beta \\in C \\cdot \\delta&#x27;</span> implies <span class="math">\\alpha\\beta/\\delta&#x27; \\in C</span>; and thus <span class="math">\\alpha\\beta/\\delta \\in C</span>. But <span class="math">\\alpha\\beta/\\delta \\notin Q</span>.</p>

    <p class="text-gray-300">We can thus assume <span class="math">\\alpha\\beta \\in AB</span>.</p>

    <p class="text-gray-300">Looking at <span class="math">Q&#x27;</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">AB(\\alpha\\beta) = A(\\alpha)B(\\beta) + A(\\beta)B(\\alpha) + A(C_j)B(\\delta_j) + A(\\delta_j)B(C_j)</span></div>

    <p class="text-gray-300">Assume for contradiction that the first two terms are zero.</p>

    <p class="text-gray-300">Then we have</p>

    <div class="my-4 text-center"><span class="math-block">A(C_j)B(\\delta_j) + A(\\delta_j)B(C_j) \\neq 0</span></div>

    <p class="text-gray-300">We look at two cases</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A(A_{j})B(B_{j})+A(B_{j})B(A_{j})=0</span>. In this case we have <span class="math">C^{*}(A_{j}B_{j})=A(C_{j})B(\\delta_{j})+A(\\delta_{j})B(C_{j})=AB(\\alpha\\beta)\\neq 0</span>. which means either <span class="math">A_{j}B_{j}\\in C_{0}</span> which is false, or <span class="math">A_{j}B_{j}/\\delta\\in C</span>, but <span class="math">A_{j}B_{j}/\\delta\\notin{\\rm span}(Q^{\\prime})</span>.</li>

      <li>We have <span class="math">A(A_{j})B(B_{j})+A(B_{j})B(A_{j})\\neq 0</span>. We claim that we can’t have <span class="math">A(A_{j}),B(A_{j})\\neq 0</span>: <span class="math">AB(A_{j}^{2})=C^{*}(A_{j}^{2})=A(A_{j})B(A_{j})</span>. But <span class="math">A_{j}^{2}/\\delta\\notin Q</span>, so either <span class="math">A_{j}\\notin A</span> or <span class="math">A_{j}\\notin B</span>. Now assume <span class="math">A_{j}\\in A,A_{j}\\notin B</span>. Look at two cases:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta_{j}\\in B</span>: Then <span class="math">AB(A_{j}\\delta_{j})=C^{*}(A_{j}\\delta_{j})=A(A_{j})B(\\delta_{j})\\neq 0</span>. But <span class="math">A_{j}\\delta_{j}/\\delta\\notin Q</span>.</li>

      <li><span class="math">C_{j}\\in B</span>: Then <span class="math">AB(A_{j}^{2}B_{j}/\\delta_{j})=C^{*}(A_{j}^{2}B_{j}/\\delta_{j})=A(A_{j})B(C_{j})\\neq 0</span>. But <span class="math">A_{j}^{2}B_{j}/(\\delta_{j}\\delta)\\notin Q</span>.</li>

    </ol>

    <p class="text-gray-300">The case <span class="math">A_{j}\\notin A,B_{j}\\in A</span> is refuted similarly.</p>

    <p class="text-gray-300">Assume w.l.g. from now on that <span class="math">A(\\alpha),B(\\beta)\\neq 0</span> (otherwise flip <span class="math">A</span> and <span class="math">B</span>, this doesn’t change the verification equation holding).</p>

    <p class="text-gray-300">We show that <span class="math">\\beta\\notin A,\\alpha\\notin B</span>:</p>

    <p class="text-gray-300">Assume for contradiction <span class="math">\\beta\\in A</span>. We have</p>

    <p class="text-gray-300"><span class="math">AB(\\beta^{2})=A(\\beta)B(\\beta)\\neq 0</span></p>

    <p class="text-gray-300">Since <span class="math">\\beta^{2}\\notin C_{0}</span>, we have <span class="math">\\beta^{2}/\\delta\\in C</span>. But <span class="math">\\beta^{2}/\\delta\\notin Q</span> which is a contradiction.</p>

    <p class="text-gray-300">An analogous argument shows <span class="math">\\alpha\\notin B</span>.</p>

    <p class="text-gray-300">Now suppose <span class="math">C_{j}\\in A</span>. Then,</p>

    <p class="text-gray-300"><span class="math">AB(A_{j}B_{j}\\beta/\\delta_{j})=A(C_{j})B(\\beta)\\neq 0.</span></p>

    <p class="text-gray-300">Hence <span class="math">A_{j}B_{j}\\beta/(\\delta_{j}\\delta)\\in C</span> - a contradiction as this monomial is not in <span class="math">Q</span>. An analogous argument shows <span class="math">C_{j}\\notin B</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">A_{j}\\in A</span>.Then,</p>

    <p class="text-gray-300"><span class="math">AB(A_{j}\\beta)=A(A_{j})B(\\beta)\\neq 0.</span></p>

    <p class="text-gray-300">Then <span class="math">A_{j}\\beta/\\delta\\in C</span> a contradiction as this monomial is not in <span class="math">Q</span>. Analgous arguments show <span class="math">B_{j}\\notin A,A_{j}\\notin B,B_{j}\\notin B</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">Y_{s}\\in A</span> for some string <span class="math">s</span>. Then</p>

    <p class="text-gray-300"><span class="math">AB(Y_{s}\\beta)=A(Y_{s})B(\\beta)\\neq 0.</span></p>

    <p class="text-gray-300">Hence <span class="math">Y_{s}\\beta/\\delta\\in C</span> - a contradiction. An analogous argument shows <span class="math">Y_{\\tt s}\\notin B</span></p>

    <p class="text-gray-300">Suppose <span class="math">\\frac{\\delta_j Y_{s_j}}{\\delta} \\in A</span> for some <span class="math">j \\in [v]</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">AB \\left(\\frac{\\delta_j Y_{s_j} \\beta}{\\delta}\\right) = A \\left(\\frac{\\delta_j Y_{s_j}}{\\delta}\\right) B(\\beta) \\neq 0.</span></div>

    <p class="text-gray-300">Hence <span class="math">\\frac{\\delta_j Y_{s_j} \\beta}{\\delta^2} \\in C</span> - a contradiction. An analogous argument shows <span class="math">\\frac{\\delta_j Y_{s_j}}{\\delta} \\notin B</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">\\delta_j \\in A</span> for some <span class="math">j \\in [v]</span>.</p>

    <div class="my-4 text-center"><span class="math-block">AB(\\delta_j \\beta) = A(\\delta_j) B(\\beta) \\neq 0.</span></div>

    <p class="text-gray-300">Hence <span class="math">\\delta_j \\beta / \\delta \\in C</span> - a contradiction. An analogous argument shows <span class="math">\\delta_j \\notin B</span>. We have shown that no monomials involving the variables in <span class="math">V</span> appear in <span class="math">A</span> or <span class="math">B</span>. It is left to show they do not appear in <span class="math">C</span> either.</p>

    <p class="text-gray-300">But if such a monomial <span class="math">M</span> appeared in <span class="math">C</span>, the monomial <span class="math">M\\delta</span> (that also involves variables of <span class="math">V</span>) appears in <span class="math">AB</span> which means a monomial involving variables from <span class="math">V</span> appears in <span class="math">A</span> or <span class="math">B</span> - a contradiction.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">We proceed to translate our NILP into a SNARK using bilinear groups. The translation is the same as in [5] and straightforward given previous works.</p>

    <h2 id="sec-15" class="text-2xl font-bold">Group generators and generic oracle adversaries</h2>

    <p class="text-gray-300">Let <span class="math">F = \\{\\mathbb{F}_p(\\lambda)\\}_{\\lambda \\in \\mathbb{N}}</span> be a sequence of prime fields. A group generator <span class="math">\\mathcal{G}</span> for <span class="math">F</span> is an algorithm that given integer parameter <span class="math">\\lambda</span> runs in time <span class="math">\\mathrm{poly}(\\lambda)</span>; and outputs groups <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> written additively and <span class="math">\\mathbb{G}_T</span> written multiplicatively all of order <span class="math">p</span>, uniformly chosen generators <span class="math">g_1 \\in \\mathbb{G}_1, g_2 \\in \\mathbb{G}_2</span> and circuits of size <span class="math">\\mathrm{poly}(\\lambda)</span> for computing group operations in the three groups and a non-degenerate bilinear pairing <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>.</p>

    <p class="text-gray-300">For <span class="math">a \\in \\mathbb{F}_p</span>, we denote below <span class="math">[a]_1 := a \\cdot g_1, [a]_2 := a \\cdot g_2</span>. Before defining SNARKs we define a generic oracle adversary.</p>

    <p class="text-gray-300"><strong>Definition 5.1 (Generic oracle adversary).</strong> A generic <span class="math">\\mathcal{G}</span>-oracle adversary <span class="math">\\mathcal{A}</span> is a <span class="math">\\mathbb{G}_1^*</span>-oracle machine operating as follows. It begins with an explicit input <span class="math">\\mathbf{x}</span>, and encoded inputs <span class="math">[\\sigma_1]_1 \\in (\\mathbb{G}_1), [\\sigma_2]_2 \\in (\\mathbb{G}_2)</span> where <span class="math">\\sigma_i</span> is a vector over <span class="math">\\mathbb{F}_p</span>. It initializes an empty vector <span class="math">U</span>. At each step <span class="math">\\mathcal{A}</span> does the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Depending only on <span class="math">\\mathbf{x}</span> and the value of the vector <span class="math">U</span>, it chooses matrices <span class="math">\\Pi_1, \\Pi_2, T</span> over <span class="math">\\mathbb{F}_p</span> and possibly also a message <span class="math">m</span>.</li>

      <li>It computes <span class="math">y_1 \\coloneqq \\Pi_1 \\cdot v_1</span> where <span class="math">v_1</span> is the set of <span class="math">\\mathbb{G}_1</span> elements it computed so far, and add the elements of <span class="math">y_1</span> to <span class="math">v_1</span>. It does the analogous thing in <span class="math">\\mathbb{G}_2</span>.</li>

      <li>If <span class="math">\\mathcal{A}</span> is in interaction with a party <span class="math">\\mathsf{P}</span> it may send <span class="math">\\mathsf{P}</span> the message <span class="math">m</span>, and if <span class="math">\\mathsf{P}</span> replies with a set of <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> elements <span class="math">\\mathcal{A}</span> may add them to <span class="math">v_1</span> and <span class="math">v_2</span>.</li>

      <li>It then checks if <span class="math">v_1 \\cdot (T \\cdot v_2) = 0</span> and adds the value 0 to <span class="math">U</span> if so, and adds the value 1 to <span class="math">U</span> otherwise.</li>

    </ol>

    <p class="text-gray-300">At a certain point it decides to terminate outputting matrices <span class="math">\\Pi_1, \\Pi_2</span>.</p>

    <p class="text-gray-300"><strong>Definition 5.2.</strong> Let <span class="math">\\mathcal{G}</span> be a group generator for a prime field <span class="math">\\mathbb{F}_p</span>, and <span class="math">\\mathsf{R} \\subset (\\mathbb{F}_p)</span> a relation. An RO-SE-SNARK <span class="math">\\mathcal{S}</span> (zero-knowledge Simulation Extractable Succinct Non-interactive Argument of Knowledge in the Random Oracle model) against <span class="math">\\mathcal{G}</span> for <span class="math">\\mathsf{R}</span> consists of the following four possibly randomized algorithms.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gen outputting a trapdoor <span class="math">\\tau</span> and common reference string <span class="math">\\sigma</span>.</li>

      <li>P that takes as input <span class="math">\\sigma</span> and <span class="math">(\\mathbf{x},\\omega) \\in \\mathsf{R}</span> and outputs <span class="math">\\pi</span>.</li>

      <li>V that takes as input a common reference string <span class="math">\\sigma</span>, an input <span class="math">\\mathbf{x}</span>, and a proof <span class="math">\\pi</span>, and outputs a value in <span class="math">\\{\\text{acc}, \\text{rej}\\}</span>.</li>

      <li><span class="math">\\mathrm{P}^{\\mathrm{sim}}</span> taking as input <span class="math">\\mathbf{x}</span>, and trapdoor <span class="math">\\tau</span> and outputting <span class="math">\\pi</span>. (It will be convenient to think of <span class="math">\\mathrm{P}^{\\mathrm{sim}}</span> as returning <span class="math">(\\mathbf{x}, \\pi)</span>.)</li>

    </ol>

    <p class="text-gray-300">All algorithms are <span class="math">\\mathbb{G}_1^*</span>-oracle machines running in time <span class="math">\\mathrm{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300">The quadruple of algorithms <span class="math">\\mathcal{S} = (\\mathrm{Gen}, \\mathrm{P}, \\mathrm{V}, \\mathrm{P}^{\\mathrm{sim}})</span> is satisfies</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness:</strong> For any common reference string <span class="math">\\sigma</span> output by <span class="math">\\mathrm{Gen}</span>, and any <span class="math">(\\mathbf{x}, \\omega) \\in \\mathsf{R}</span>, if <span class="math">\\pi = \\mathrm{P}(\\sigma, \\mathbf{x}, \\omega)</span> then <span class="math">\\mathrm{V}(\\sigma, \\mathbf{x}, \\pi) = \\mathrm{acc}</span> with probability one.</li>

      <li><strong>Perfect Zero-Knowledge:</strong> For any output <span class="math">(\\tau, \\sigma)</span> of <span class="math">\\mathrm{Gen}</span> and <span class="math">(\\mathbf{x}, \\omega) \\in \\mathsf{R}</span>, the distribution of <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau, \\mathbf{x})</span> is identical to that of <span class="math">\\mathrm{P}(\\sigma, \\mathbf{x}, \\omega)</span>.</li>

    </ol>

    <p class="text-gray-300">12</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulation-Extractability:</li>

    </ol>

    <p class="text-gray-300">Fix any output <span class="math">(\\tau, \\sigma)</span> of <span class="math">\\mathsf{Gen}</span>. For any <span class="math">\\mathcal{G}</span>-generic oracle adversary <span class="math">\\mathcal{A}</span> making <span class="math">\\mathrm{poly}(\\lambda)</span> steps, there exists a circuit <span class="math">\\chi</span> of size <span class="math">\\mathrm{poly}(\\lambda)</span> such that the following holds: Suppose that <span class="math">\\mathcal{A}</span> adaptively makes queries <span class="math">Q = \\{\\mathbf{x}_1, \\ldots, \\mathbf{x}_{\\ell}\\}</span> to <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau, \\cdot)</span>, that returns answers <span class="math">A = \\{(\\mathbf{x}_1, \\pi_1), \\ldots, (\\mathbf{x}_{\\ell}, \\pi_{\\ell})\\}</span>. Finally <span class="math">\\mathcal{A}</span> outputs a pair <span class="math">(\\mathbf{x}, \\pi)</span> and <span class="math">\\chi</span> seeing the sequences <span class="math">Q, A</span> and <span class="math">\\mathsf{rand}_{\\mathcal{A}}</span>, outputs <span class="math">\\omega</span>. The probability that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> "wins": <span class="math">(\\mathbf{x}, \\pi) \\notin A</span> and also <span class="math">\\mathrm{V}(\\mathbf{x}, \\pi) = \\mathrm{acc}</span>, while</li>

      <li><span class="math">\\chi</span> "loses": <span class="math">(\\mathbf{x}, \\omega) \\notin \\mathsf{R}</span></li>

    </ul>

    <p class="text-gray-300">is <span class="math">\\mathrm{negl}(\\lambda)</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">5.1 SE-NILPs to SE-SNARKs</h2>

    <p class="text-gray-300">Given a group generator <span class="math">\\mathcal{G}</span> and a NILP <span class="math">\\mathcal{N} = (\\mathsf{Gen}, \\mathrm{P}, \\mathrm{V}, \\mathrm{P}^{\\mathrm{sim}})</span> for the same prime field <span class="math">\\mathbb{F}_p</span>, we define the SNARK <span class="math">\\mathcal{N}_{\\mathcal{G}} = (\\mathsf{Gen}_{\\mathcal{G}}, \\mathrm{P}_{\\mathcal{G}}, \\mathrm{V}_{\\mathcal{G}}, \\mathrm{P}^{\\mathrm{sim}}_{\\mathcal{G}})</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}_{\\mathcal{G}}</span>: Run <span class="math">\\mathsf{Gen}</span> to obtain output <span class="math">(\\tau, \\sigma_1, \\sigma_2)</span>. Output <span class="math">\\tau, \\sigma&#x27; = (\\sigma_1&#x27;, \\sigma_2&#x27;)</span>; where <span class="math">\\sigma_1&#x27; = [\\sigma_1]_1</span> and <span class="math">\\sigma_2&#x27; = [\\sigma_2]_2</span>.</li>

      <li><span class="math">\\mathrm{P}_{\\mathcal{G}}</span>: Run the first phase of <span class="math">\\mathrm{P}</span> on input <span class="math">(\\mathbf{x}, \\omega)</span> to obtain matrices <span class="math">\\Pi_1, \\Pi_2</span>. Output <span class="math">\\pi_1 = \\Pi_1 \\cdot (\\sigma_1&#x27;, Y), \\pi_2 = \\Pi_2 \\cdot \\sigma_2&#x27;</span>.</li>

      <li><span class="math">\\mathrm{V}_{\\mathcal{G}}</span>: Run the first phase of <span class="math">\\mathrm{V}(\\sigma, \\mathbf{x}, \\pi)</span> to obtain matrices <span class="math">T_1, \\ldots, T_d</span>. Output accept iff for each <span class="math">i \\in [d]</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\sigma_1, Y, \\pi_1) \\cdot T_i(\\sigma_2, \\pi_2) = 0</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{P}^{\\mathrm{sim}}_{\\mathcal{G}}(\\tau, \\mathbf{x})</span>: Run <span class="math">\\mathrm{P}^{\\mathrm{sim}}(\\tau, \\mathbf{x})</span> to obtain <span class="math">(\\pi_1, \\pi_2)</span>. Output <span class="math">[\\pi_1]_1, [\\pi_2]_2</span>.</li>

    </ul>

    <p class="text-gray-300">The following is clear.</p>

    <p class="text-gray-300"><strong>Theorem 5.3.</strong> Suppose that <span class="math">\\mathcal{G}</span> is a group generator for <span class="math">\\mathbb{F}_p</span> and <span class="math">\\mathcal{N}</span> is a degree <span class="math">d = o(2^{\\lambda})</span> AB-SE-NILP for <span class="math">\\mathsf{R}</span> over <span class="math">\\mathbb{F}_p</span>. Then <span class="math">\\mathcal{N}_{\\mathcal{G}}</span> as defined above is a RO-SE-SNARK against <span class="math">\\mathcal{G}</span> for <span class="math">\\mathsf{R}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Corollary 5.4.</strong> Let <span class="math">\\mathbb{F}_p</span> be a prime finite field. Suppose we are given a QAP relation <span class="math">\\mathsf{R}</span> of degree <span class="math">d</span> over <span class="math">\\mathbb{F}_p</span>, and a group generator <span class="math">\\mathcal{G}</span> for <span class="math">\\mathbb{F}_p</span>, such that $d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)<span class="math">. Then we can construct an RO-SE-SNARK against </span>\\mathcal{G}<span class="math"> for </span>\\mathsf{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">13</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Signatures of Knowledge</h4>

    <p class="text-gray-300">We do not give full details and definitions. Suppose <span class="math">m</span> is the message we wish to sign. Then the construction of section 3 is modified in the descriptions of P,V and P<span class="math">{}^{\\text{sim}}</span> simply by concatenating <span class="math">m</span> to what is called s there.</p>

    <h2 id="sec-18" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Matthew D. Green for helpful conversations. We thank Jens Groth and Mary Maller for discussions on their construction.</p>

    <h2 id="sec-19" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] https://github.com/scipr-lab/libsnark/tree/master/libsnark/zk_proof_systems/ppzksnark.</li>

      <li>[2] S. Bowe, A. Gabizon, and I. Miers. Scalable multi-party computation for zk-snark parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. https://eprint.iacr.org/2017/1050.</li>

      <li>[3] G. Danezis, C. Fournet, J. Groth, and M. Kohlweiss. Square span programs with applications to succinct NIZK arguments. In Advances in Cryptology - ASIACRYPT 2014 - 20th International Conference on the Theory and Application of Cryptology and Information Security, Kaoshiung, Taiwan, R.O.C., December 7-11, 2014. Proceedings, Part I, pages 532–550, 2014.</li>

      <li>[4] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, pages 626–645, 2013.</li>

      <li>[5] J. Groth. On the size of pairing-based non-interactive arguments. In Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, pages 305–326, 2016.</li>

      <li>[6] J. Groth and M. Maller. Snarky signatures: Minimal signatures of knowledge from simulation-extractable snarks. In Advances in Cryp</li>

    </ul>

    <p class="text-gray-300">tology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part II, pages 581–612, 2017.</p>`;
---

<BaseLayout title="Making Groth&#x27;s zk-SNARK Simulation Extractable in the Random... (2018/187)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/187
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
