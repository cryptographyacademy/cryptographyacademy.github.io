---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/633';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="Vision Mark-32: ZK-Friendly Hash over Binary Towers (2024/633)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Vision Mark-32: ZK-Friendly Hash Function Over Binary
        Tower Fields
      </h1>
      <p class="text-gray-400 mb-2">
        Tomer Ashur, Mohammad Mahzoun, Jim Posen,
        Danilo &Scaron;ija&ccaron;i&cacute;
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; Full Version &middot; eprint 2024/633
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">Vision</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">Weil Descent</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">Fake Weil Descent</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">Binary Towers</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Vision Mark-32</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">Inverse Function</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Linearized Affine Layer</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">MDS Matrix</a>
            </li>
            <li>
              <a href="#sec-3.4"
                class="hover:text-white">
                Sponge Construction</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Security of Vision Mark-32</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Differential Cryptanalysis</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Linear Cryptanalysis</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Interpolation Attacks</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Gr&ouml;bner Basis Attacks</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Implementation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Tower Field Arithmetic</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Vision Mark-32 Permutation</a>
            </li>
            <li>
              <a href="#sec-5.3"
                class="hover:text-white">
                Performance Comparison</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Conclusion</a>
        </li>
        <li>
          <a href="#acknowledgments"
            class="hover:text-white">Acknowledgments</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ol>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Abstract</h2>
      <p class="text-gray-300">
        Zero-knowledge proof systems are widely used in various
        online applications. Among these, Zero-Knowledge Succinct
        Non-Interactive Argument of Knowledge (SNARKs) systems are
        popular due to their fast verification time and small proof
        size. The efficiency of these systems is crucial for
        usability, leading to the development of
        arithmetization-oriented ciphers. In this work, we introduce
        Vision Mark-32, a modified version of the Vision cipher,
        optimized with an efficient Maximum Distance Separable (MDS)
        matrix and a reduced number of rounds. We implement a
        fully-pipelined Vision Mark-32 permutation on the Alveo U55C
        FPGA accelerator card, demonstrating significantly improved
        hardware efficiency compared to the Poseidon hash function.
        Our Vision Mark-32 implementation operates at 250 MHz,
        utilizing 398,000 Look-Up Tables (LUTs) and 104,000
        Flip-Flops (FFs).
      </p>
      <p class="text-gray-400 text-sm mt-4">
        <strong>Keywords:</strong> Vision, SNARKs,
        Arithmetization-oriented Hash, Zero-Knowledge Proofs,
        FPGA, Hardware
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">1. Introduction</h2>

      <p class="text-gray-300">
        Zero-knowledge (ZK) proof systems are the core components
        of various applications such as blockchains,
        cryptocurrencies, and web3 technologies. Among ZK proof
        systems, succinct non-interactive arguments of knowledge
        (SNARKs), are popular choices particularly due to their
        small proof size, fast verification, and viable scalability
        in blockchain protocols. As ZK systems are increasingly
        deployed in different applications, there is a need to
        enhance their efficiency. The primary computational
        bottleneck in ZK systems lies in the underlying hash
        functions they employ. Traditional hash functions (e.g.,
        [Gau09, Ber11]) designed over binary fields are optimized for
        computational efficiency. However, they have high
        arithmetization costs, leading to excessively large trace
        matrices that lead to poor performance within ZK systems.
      </p>

      <p class="text-gray-300">
        In response, a myriad of arithmetization-oriented ciphers
        emerged to enhance the efficiency of hash functions and
        encryption within advanced cryptographic protocols, such as
        ZK systems, fully homomorphic encryption (FHE), and
        multiparty computation (MPC). Examples of
        arithmetization-oriented designs are
        [Ash22, 27, 15, 1, 16, 41, 23, 34, 22, 17, 19, 33, Sze23].
      </p>

      <p class="text-gray-300">
        For hashing in ZK proof systems, the popular choices are
        Poseidon [Gra21], which is analyzed in various works
        [Bey20, 37, 8, 4, Ste24a], Rescue [Aly20], and XHash [AA23]. The popular
        choices of ZK-friendly hash functions all operate over
        finite fields of large
        (<span class="math">\approx 2^&#123;64&#125;</span>) prime
        characteristic. Diamond and Posen [DP23] introduce Binius, a
        novel SNARK, designed over binary tower fields. Binary
        fields are widespread in cryptographic algorithms (e.g.
        AES [Dae02]) and are known for their computational efficiency.
        Since Binius operates over binary fields, the common choices
        for ZK-friendly hash functions are not usable. Therefore,
        there is a need for a ZK-hash function that operates over
        the binary tower fields. A natural choice for such function
        is Vision [Aly20] instantiated in Sponge [Ber08] construction.
      </p>

      <p class="text-gray-300">
        In this paper, we specify an instance of Vision, defined
        over Fan&ndash;Paar tower fields [FP97]. We describe how to
        implement Vision Mark-32 in hardware efficiently. We write
        RTL code in SystemVerilog, and present implementation
        results on the Alveo U55C datacenter card.
      </p>

      <p class="text-gray-300">
        Vision Mark-32 is a Sponge construction instantiated based
        on the Vision permutation with a modified number of rounds
        as the underlying cryptographic primitive. The result of our
        implementation can be found in Section 5. Our primary
        contribution is the introduction of Vision Mark-32, with an
        optimized number of rounds and efficient MDS matrix, for an
        efficient hashing process within SNARKs. We summarize our
        contributions as follows:
      </p>

      <ul class="list-disc list-inside space-y-3 text-gray-300
        ml-4">
        <li>
          <strong>Introduce Vision Mark-32:</strong> Vision Mark-32
          is a sponge construction using a specific instance of
          Vision operating over
          <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>
          with state size 24. The permutation used in Vision Mark-32
          has fewer rounds than the original Vision design, which
          makes it perform better. The security arguments of Vision
          have been reworked for Vision Mark-32 to ensure it
          provides the level of security needed.
        </li>
        <li>
          <strong>Efficient hardware implementation of inversion
          using binary towers:</strong> We implement the inversion
          of field elements over
          <span class="math">\mathbb&#123;F&#125;_&#123;2^m&#125;</span>
          efficiently using binary towers introduced in [FP97]. The
          cost of inversion is then 1.58 times that of
          multiplication, improving over the standard approach
          requiring normal 32 multiplications when using XGCD or
          Lagrange theorem.
        </li>
        <li>
          <strong>Efficient MDS matrix:</strong> We introduce an
          efficient MDS matrix for the linear layer of Vision
          Mark-32. The matrix is derived from a systematic
          Reed&ndash;Solomon code over an affine subspace of the
          binary field, and admits an efficient multiplication
          procedure due to the additive NTT [SJ14].
        </li>
        <li>
          <strong>Efficient implementation of the linearized affine
          layer:</strong> The linearized affine polynomial used in
          Vision is of high degree and is a dense polynomial.
          Conversely, the linearized affine polynomial used in
          Vision Mark-32 requires 32 constant multiplication, 32
          additions, and 32 squaring in
          <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>.
          We use a simple and efficient approach to convert the
          affine linearized polynomial over
          <span class="math">\mathbb&#123;F&#125;_&#123;2^m&#125;</span>
          to a binary matrix over
          <span class="math">\mathbb&#123;F&#125;_2</span>, which
          can be seen as 32 multiplications of field elements, and
          32 additions over
          <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>,
          this significantly improves the cost of the affine layer.
        </li>
        <li>
          <strong>Re-evaluation of security of Vision Mark-32
          against Gr&ouml;bner basis attacks:</strong> In [Aly20], the
          complexity of the Gr&ouml;bner basis attack was argued by
          the infeasibility of computing the Gr&ouml;bner basis in
          <em>grevlex</em> order. We improve the security argument
          by analyzing the number of solutions of the polynomial
          system that describes Vision and show that even if the
          Gr&ouml;bner basis calculation in a specific weighted
          monomial ordering is free [Ste24a, Ste24b, Bar24], still the degree
          of the ideal generated by the polynomial system is large
          enough to guarantee the security of Vision Mark-32.
        </li>
      </ul>

      <p class="text-gray-300">
        <strong>Related Work.</strong> Arithmetization-oriented
        designs can be categorized by their performance in the
        corresponding applications.
      </p>

      <p class="text-gray-300">
        For zero-knowledge proof systems, the performance metrics
        for the hash functions are Rank-One Constraint Satisfaction
        (R1CS) and Plonk for ZK-SNARKs, and Algebraic Intermediate
        Representation (AIR) for ZK-STARKs. The performance of the
        hash functions is then measured using characteristics of
        polynomial representation, such as depth, number of
        multiplications, etc. Therefore, to obtain a more efficient
        hash function and simpler polynomial representation, it is
        preferred to design primitives that operate over finite
        fields of large prime characteristics. Important ZK-friendly
        hash functions over prime fields are Rescue [Aly20],
        Rescue-Prime [Sze20], RPO [Ash22b], XHash [AA23],
        ReinforcedConcrete [Gra22b], Monolith [Gra23b], Poseidon [Gra21b],
        Griffin [Gra23], Anemoi [Bou23].
      </p>

      <p class="text-gray-300">
        In the case of fully homomorphic encryption, most
        arithmetization-oriented designs typically operate over
        binary fields. Examples of designs over
        <span class="math">\mathbb&#123;F&#125;_2</span> are
        Kreyvium [Can18], FLIP [Mea16], FiLIP [Mea19] that are for FHE with
        bootstrapping. LowMC [Alb+15], Rasta [Dob18], Dasta [Heb20],
        Fasta [Cid22], Pasta [Dob23], and Chagri [Ash22] for BGV and BFV.
        Yet, all such designs are slow and unusable for efficient ZK
        applications.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">2. Preliminaries</h2>

      <p class="text-gray-300">
        In this section, we introduce necessary definitions and
        theoretical background required to follow the paper.
      </p>

      <!-- 2.1 Vision -->
      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Vision
      </h3>

      <p class="text-gray-300">
        Vision [Aly20] is a keyed permutation based on the Marvelous
        design strategy. Vision operates over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>
        and each round consists of two steps that differ only in the
        linearized affine polynomial. We denote the input state of
        the
        <span class="math">i</span>-th round by
        <span class="math">S_i = (s_&#123;i,0&#125;,
        \ldots, s_&#123;i,m-1&#125;)</span> where
        <span class="math">s_&#123;i,j&#125; \in
        \mathbb&#123;F&#125;_&#123;2^n&#125;</span>. Each step in
        one round of Vision consists of three operations on the
        state:
      </p>

      <ul class="list-disc list-inside space-y-2 text-gray-300
        ml-4">
        <li>
          Inverse function:
          <span class="math">\pi(s_&#123;i,j&#125;) =
          s_&#123;i,j&#125;^&#123;-1&#125;</span>.
        </li>
        <li>
          Linearized affine polynomial:
          <span class="math">B(s_&#123;i,j&#125;) =
          \sum_&#123;k=0&#125;^&#123;n-1&#125;
          \beta_j s_&#123;i,j&#125;^&#123;2^k&#125; +
          \beta_n</span>.
        </li>
        <li>
          MDS matrix:
          <span class="math">L(S_i) =
          \mathcal&#123;M&#125; \cdot S_i</span>.
        </li>
      </ul>

      <p class="text-gray-300">
        The only difference between the two steps is the linearized
        affine polynomial. The linearized affine polynomial of the
        second step has the form:
      </p>

      <div class="math-block">
        B(x) = \beta_0 x + \beta_1 x^2 + \beta_2 x^4 + \beta_3,
      </div>

      <p class="text-gray-300">
        which is a sparse polynomial. The linearized affine
        polynomial of the first step is
        <span class="math">B^&#123;-1&#125;</span>, which is dense
        with a high degree.
      </p>

      <!-- 2.2 Weil Descent -->
      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Weil Descent
      </h3>

      <p class="text-gray-300">
        Let <span class="math">q</span> be a power of a prime
        number, <span class="math">n</span> be a positive integer,
        and
        <span class="math">\mathcal&#123;P&#125; \subseteq
        \mathbb&#123;F&#125;_&#123;q^n&#125;[x]</span>. Let
        <span class="math">\&#123;\alpha_0,\ldots,
        \alpha_&#123;n-1&#125;\&#125;</span> be a basis of
        <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125; /
        \mathbb&#123;F&#125;_q</span>, then
        <span class="math">X = \sum_&#123;i=0&#125;^&#123;n-1&#125;
        \alpha_i x_i</span>. Let
        <span class="math">p \in
        \mathbb&#123;F&#125;_&#123;q^n&#125;[x]</span>, define
        <span class="math">[p]_i \in
        \mathbb&#123;F&#125;_q[x_1,\ldots,x_n]</span> by:
      </p>

      <div class="math-block">
        p(X) = p\left(\sum_&#123;i=0&#125;^&#123;n-1&#125;
        \alpha_i x_i\right) \equiv
        \sum_&#123;i=0&#125;^&#123;n-1&#125; \alpha_i [p]_i
        \mod (x_0^q - x_0, \dots, x_&#123;n-1&#125;^q -
        x_&#123;n-1&#125;),
      </div>

      <p class="text-gray-300">
        where
        <span class="math">\deg([p]_i) &lt; q</span> for all
        <span class="math">0 \le i &lt; n</span>. The system
      </p>

      <div class="math-block">
        \mathcal&#123;P&#125;' = \&#123; [p]_i : p \in
        \mathcal&#123;P&#125;, \ 0 \le i &lt; n \&#125;
        \cup \&#123; x_i^q - x_i : 0 \le i &lt; n \&#125;
      </div>

      <p class="text-gray-300">
        is called Weil descent system of
        <span class="math">\mathcal&#123;P&#125;</span>, and
        solutions of
        <span class="math">\mathcal&#123;P&#125;</span> in
        <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125;</span>
        are same as the solutions of
        <span class="math">\mathcal&#123;P&#125;'</span> in
        <span class="math">\mathbb&#123;F&#125;_q</span>.
      </p>

      <!-- 2.3 Fake Weil Descent -->
      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Fake Weil Descent
      </h3>

      <p class="text-gray-300">
        Fake Weil descent system is introduced in [MD15] and is a
        powerful tool to study the hardness of solving polynomial
        systems. We use fake Weil descent systems to improve the
        efficiency of computing affine linearized polynomials. Let
        <span class="math">e &lt; q^n</span> be a positive integer,
        <span class="math">x^e \in
        \mathbb&#123;F&#125;_&#123;q^n&#125;[x]</span>, then
        <span class="math">x^e</span> can be written as:
      </p>

      <div class="math-block">
        \overline&#123;x^e&#125; =
        \prod_&#123;i=0&#125;^&#123;n-1&#125;
        x_i^&#123;e_i'&#125; \in
        \mathbb&#123;F&#125;_&#123;q^n&#125;[x_1, \dots, x_n],
      </div>

      <p class="text-gray-300">
        in base <span class="math">q</span>. Using the same
        approach, polynomials in
        <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125;[x]</span>
        can be written as polynomials in
        <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125;[x_0,
        \ldots, x_&#123;n-1&#125;]</span>. Let
        <span class="math">\mathcal&#123;P&#125; \subseteq
        \mathbb&#123;F&#125;_&#123;q^n&#125;[x]</span>,
        <span class="math">\mathcal&#123;P&#125;' \subseteq
        \mathbb&#123;F&#125;_q[x_0, \ldots,
        x_&#123;n-1&#125;]</span> the Weil descent system of
        <span class="math">\mathcal&#123;P&#125;</span>, and
        <span class="math">\mathcal&#123;P&#125;^f \subseteq
        \mathbb&#123;F&#125;_&#123;q^n&#125;[x_0, \ldots,
        x_&#123;n-1&#125;]</span> the fake Weil descent system of
        <span class="math">\mathcal&#123;P&#125;</span>. Then, the
        solutions of
        <span class="math">\mathcal&#123;P&#125;^f</span> over
        <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125;</span>
        is the same as the solutions of
        <span class="math">\mathcal&#123;P&#125;'</span> over
        <span class="math">\mathbb&#123;F&#125;_q</span> up to an
        isomorphism [MD15].
      </p>

      <p class="text-gray-300">
        <strong>Code Listing 1:</strong> Sage code for computing
        the fake Weil descent system of a monomial.
      </p>

      <pre><code>F.&lt;a&gt; = GF(2^n)
R = PolynomialRing(F, n, names='X')
X = R.gens()
f = sum(X[i]*a^i for i in range(n))
I = R.ideal([g^p - g for g in X])
P = sum(vector(b)*m.reduce(I) for b,m in f^t)</code></pre>

      <!-- 2.4 Binary Towers -->
      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 Binary Towers
      </h3>

      <p class="text-gray-300">
        The tower of field extensions introduced in [Wie88], and
        further discussed in [Coh92, FP97, Bla+93] is a recursive
        construction of fields extensions where each field extension
        is constructed by using an irreducible polynomial and the
        previous field extension. More precisely, let
        <span class="math">\mathcal&#123;T&#125;_0 =
        \mathbb&#123;F&#125;_&#123;2^m&#125;</span>, then the
        binary tower is defined as:
      </p>

      <div class="math-block">
        \mathcal&#123;T&#125;_1 =
        \mathcal&#123;T&#125;_0[x_0] / F_1(x_0)
      </div>

      <div class="math-block">
        \vdots
      </div>

      <div class="math-block">
        \mathcal&#123;T&#125;_n =
        \mathcal&#123;T&#125;_&#123;n-1&#125;[x_&#123;n-1&#125;]
        / F_n(x_&#123;n-1&#125;),
      </div>

      <p class="text-gray-300">
        where
        <span class="math">F_i(x_&#123;i-1&#125;)</span> is an
        irreducible polynomial of degree 2 in
        <span class="math">\mathcal&#123;T&#125;_&#123;n-1&#125;</span>
        and
        <span class="math">\mathcal&#123;T&#125;_n</span> is the
        finite field
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;m
        \cdot 2^n&#125;&#125;</span>. In the design of Vision
        Mark-32,
        <span class="math">\mathcal&#123;T&#125;_0 =
        \mathbb&#123;F&#125;_2</span>, and
        <span class="math">F_i(x_&#123;i-1&#125;) =
        x_&#123;i-1&#125;^2 + x_&#123;i-1&#125; \cdot
        x_&#123;i-2&#125; + 1</span> which was shown to be
        irreducible in [Wie88]. The recursive construction of extension
        fields obtains the following binary field tower:
      </p>

      <div class="math-block">
        \mathcal&#123;T&#125;_0 \subset
        \mathcal&#123;T&#125;_1 \subset \ldots \subset
        \mathcal&#123;T&#125;_n
      </div>

      <p class="text-gray-300">
        where
        <span class="math">\mathcal&#123;T&#125;_n</span> is a
        vector space over
        <span class="math">\mathcal&#123;T&#125;_0</span> with
        dimension
        <span class="math">2^n</span> with respect to the following
        lexicographic basis [DP23]:
      </p>

      <div class="math-block">
        \&#123;x_0, x_1, x_0 x_1, \dots,
        x_0 x_1 \dots x_&#123;n-1&#125;\&#125;.
      </div>

      <p class="text-gray-300">
        Each vector
        <span class="math">v \in
        \mathcal&#123;T&#125;_n</span>, of length
        <span class="math">2^n</span>, can be written as
        <span class="math">v = v_0 + x_&#123;n-1&#125;
        v_1</span>. Arithmetic operations of the field
        <span class="math">\mathcal&#123;T&#125;_n</span> can be
        executed more efficiently using the binary towers.
      </p>

      <p class="text-gray-300">
        We denote the complexity of addition, constant
        multiplication, multiplication of field elements, and
        inversion over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;m
        \cdot 2^n&#125;&#125;</span> with
        <span class="math">\mathcal&#123;A&#125;_n,
        \mathcal&#123;C&#125;_n, \mathcal&#123;M&#125;_n</span>,
        and
        <span class="math">\mathcal&#123;I&#125;_n</span>
        respectively. Then, the complexity of each operation is
        analyzed in [FP97] as follows.
      </p>

      <p class="text-gray-300">
        <strong>Addition.</strong> The addition of field elements is
        cheap regardless of whether using binary tower fields. For
        the case of fields with characteristic 2, the addition
        <span class="math">v_1, v_2 \in
        \mathcal&#123;T&#125;_n</span>, corresponds to their
        bitwise XOR
        <span class="math">v_1 \oplus v_2</span>. The complexity
        of addition is
        <span class="math">\mathcal&#123;A&#125;_n = 2^n
        \mathcal&#123;A&#125;_0</span> where
        <span class="math">\mathcal&#123;A&#125;_0</span> is the
        cost of addition over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^m&#125;</span>.
      </p>

      <p class="text-gray-300">
        <strong>Multiplication by constant.</strong> Multiplication
        of
        <span class="math">v \in
        \mathcal&#123;T&#125;_n</span> with the constant
        <span class="math">x_&#123;n-1&#125;</span> can be
        executed in
        <span class="math">\Theta(2^n)</span>. The complexity of
        multiplication with constant is
      </p>

      <div class="math-block">
        \mathcal&#123;C&#125;_n = \mathcal&#123;C&#125;_0 +
        (2^n - 1)\mathcal&#123;A&#125;_0.
      </div>

      <p class="text-gray-300">
        <strong>Multiplication of field elements.</strong>
        Multiplication of
        <span class="math">v_1 = \alpha_1 x_&#123;n-1&#125;
        + \alpha_0</span> and
        <span class="math">v_2 = \beta_1 x_&#123;n-1&#125;
        + \beta_0</span>, is done via three multiplications in
        <span class="math">\mathcal&#123;T&#125;_&#123;n-1&#125;</span>.
        In general:
      </p>

      <div class="math-block">
        v_1 \cdot v_2 = (\alpha_0 \beta_1 + \beta_0 \alpha_1
        + \alpha_1 \beta_1 x_&#123;n-2&#125;) x_&#123;n-1&#125;
        + \alpha_0 \beta_0 + \alpha_1 \beta_1,
      </div>

      <p class="text-gray-300">
        which can be computed by [DP23]:
      </p>

      <div class="math-block">
        \alpha_1 \beta_1 x_&#123;n-1&#125;^2 +
        (\alpha_0 \beta_1 + \alpha_1 \beta_0) x_&#123;n-1&#125;
        + \alpha_0 \beta_0 - \alpha_1 \beta_1
        (x_&#123;n-1&#125;^2 + x_&#123;n-2&#125;
        x_&#123;n-1&#125; + 1).
      </div>

      <p class="text-gray-300">
        The complexity of multiplication is:
      </p>

      <div class="math-block">
        \mathcal&#123;M&#125;_n = 3^n
        \mathcal&#123;M&#125;_0 + 6(3^n - 2^n)
        \mathcal&#123;A&#125;_0 +
        \frac&#123;3^n - 1&#125;&#123;2&#125;
        (\mathcal&#123;C&#125;_0 -
        \mathcal&#123;A&#125;_0).
      </div>

      <p class="text-gray-300">
        A similar approach to multiplication is also known as
        Karatsuba method [Kar62], that has complexity of
        <span class="math">\mathcal&#123;O&#125;(n^&#123;\log_2
        (3)&#125;)</span>.
      </p>

      <p class="text-gray-300">
        <strong>Squaring.</strong> The square of vector
        <span class="math">v = \alpha_1 x_&#123;n-1&#125;
        + \alpha_0</span> is:
      </p>

      <div class="math-block">
        (\alpha_1^2 x_&#123;n-2&#125;) x_&#123;n-1&#125; +
        (\alpha_0^2 + \alpha_1^2).
      </div>

      <p class="text-gray-300">
        The complexity of squaring a field element is:
      </p>

      <div class="math-block">
        \mathcal&#123;S&#125;_n = 2^n
        \mathcal&#123;S&#125;_0 + n 2^n
        \mathcal&#123;A&#125;_0 + (2^n - 1)
        (\mathcal&#123;C&#125;_0 -
        \mathcal&#123;A&#125;_0).
      </div>

      <p class="text-gray-300">
        <strong>Inversion.</strong> The inverse of a field element
        <span class="math">v = \alpha_1 x_&#123;n-1&#125;
        + \alpha_0</span> is:
      </p>

      <div class="math-block">
        v^&#123;-1&#125; = (\alpha_1 x_&#123;n-1&#125; +
        \alpha_0)^&#123;-1&#125; = (\alpha_1
        \Delta^&#123;-1&#125;) + \Delta^&#123;-1&#125;
        (\alpha_0 + \alpha_1 x_&#123;n-2&#125;),
      </div>

      <p class="text-gray-300">
        where
        <span class="math">\Delta = \alpha_0(\alpha_0 +
        \alpha_1 x_&#123;n-2&#125;) +
        \alpha_1^2</span>. Computing the inverse of an element has
        asymptotic complexity of
        <span class="math">\mathcal&#123;O&#125;(n^&#123;\log_2(3)&#125;)</span>.
        For the detailed analysis of the complexity of inversion,
        we refer to [FP97, Section IV].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. VISION MARK-32                                            -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        3. Vision Mark-32
      </h2>

      <p class="text-gray-300">
        Vision Mark-32 is a hash function instantiating a Sponge
        construction using the Vision permutation [Aly20]. Vision
        Mark-32 has 8 rounds and operates over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>,
        with state size of
        <span class="math">m = 24</span>, and capacity of
        <span class="math">c = 8</span>. The security level
        guaranteed by Vision Mark-32 is 128 bits. In Algorithm 1,
        the pseudocode of Vision Mark-32 hash function is described.
        <span class="math">M</span> is the MDS matrix and its
        structure is described in Subsection 3.3, and
        <span class="math">C_&#123;r,1&#125;, C_&#123;r,2&#125;
        \in
        \mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;^&#123;24&#125;</span>
        are round constants for the
        <span class="math">r</span>-th round.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Algorithm 1 &mdash; Underlying permutation of Vision
          Mark-32 with 8 rounds and state size 24.
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300 mb-2">
            <strong>Input:</strong> State
            <span class="math">S = (s_1, \ldots, s_&#123;24&#125;)
            \in
            \mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;^&#123;24&#125;</span>
          </p>
          <p class="text-gray-300 mb-2">
            <strong>Output:</strong> Result of applying Vision
            Mark-32 permutation on
            <span class="math">S</span>
          </p>
          <pre><code>1: for r = 1 to 8 do
2:   for i = 1 to 24 do
3:     S[i] = S[i]^(-1)
4:     S[i] = B^(-1)(S[i])
5:   S = M * S + C_(r,1)
6:   for i = 1 to 24 do
7:     S[i] = S[i]^(-1)
8:     S[i] = B(S[i])
9:   S = M * S + C_(r,2)
10: return S</code></pre>
        </div>
      </div>

      <!-- 3.1 Inverse Function -->
      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Inverse Function
      </h3>

      <p class="text-gray-300">
        The inverse function is the only non-linear operation in the
        round function of Vision Mark-32. To efficiently implement
        inversion over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>,
        the construction proposed by Wiedemann [Wie88] is used. That
        is, each element of
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>
        is represented as
        <span class="math">\alpha = a + x_4 b</span>, where
        <span class="math">a, b \in
        \mathbb&#123;F&#125;_&#123;2^&#123;16&#125;&#125;</span>,
        with the irreducible polynomial
        <span class="math">F(x_4) = x_4^2 + x_3 x_4 +
        1</span>. To inverse
        <span class="math">\alpha</span>, we compute:
      </p>

      <div class="math-block">
        \alpha^&#123;-1&#125; = b \Delta^&#123;-1&#125; +
        \Delta^&#123;-1&#125;(a + b x_3),
      </div>

      <p class="text-gray-300">
        where
        <span class="math">\Delta = a(a + b x_3) +
        b^2</span>. To compute
        <span class="math">\Delta^&#123;-1&#125;</span>, we
        recursively compute inversion in the subfield
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;16&#125;&#125;</span>,
        which itself requires inversion in the subfield
        <span class="math">\mathbb&#123;F&#125;_&#123;2^8&#125;</span>.
        This way, inversion is reduced to inversion over
        <span class="math">\mathbb&#123;F&#125;_2</span> which is
        trivial. In our implementation, the cost of the inversion
        operation over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>
        is 1.58 times the cost of multiplication, whereas normal
        inversion using XGCD requires
        <span class="math">\approx 32</span> multiplications.
      </p>

      <!-- 3.2 Linearized Affine Layer -->
      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Linearized Affine Layer
      </h3>

      <p class="text-gray-300">
        The linearized affine layer is one of the main bottlenecks
        of performance in hardware implementation. Mainly because of
        its density and large number of multiplications over the
        operating field,
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>.
        A linearized affine layer over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^n&#125;</span>
        has the form:
      </p>

      <div class="math-block">
        B(x) = \sum_&#123;k=0&#125;^&#123;n-1&#125;
        \beta_k x^&#123;2^k&#125; + \beta_n.
      </div>

      <p class="text-gray-300">
        The polynomial
        <span class="math">B(x)</span> has
        <span class="math">n</span> terms, and evaluating it
        directly requires
        <span class="math">n</span> constant multiplication,
        <span class="math">n</span> additions, and
        <span class="math">n</span> squaring in
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>.
      </p>

      <p class="text-gray-300">
        However,
        <span class="math">B(x)</span> is an affine function over
        <span class="math">\mathbb&#123;F&#125;_2</span>. To
        efficiently compute
        <span class="math">B(x)</span> for any
        <span class="math">x \in
        \mathbb&#123;F&#125;_&#123;2^n&#125;</span> we convert
        <span class="math">x</span> to a binary vector
        <span class="math">V = (V_0, \dots, V_&#123;n-1&#125;)
        \in \mathbb&#123;F&#125;_2^n</span> and transform the
        linearized polynomial to a matrix over
        <span class="math">\mathbb&#123;F&#125;_2</span>.
        Converting monomials of
        <span class="math">B(x)</span> to their Weil descent system
        using Code Listing 1 is time-consuming and impractical.
        However, to compute the Weil descent system of
        <span class="math">B(x)</span>, we only need to compute the
        matrix
        <span class="math">M_1</span> for the monomial
        <span class="math">x^2</span>, using
        <span class="math">M_1</span> we then can compute the
        matrix for
        <span class="math">x^&#123;2^i&#125;</span> as
        <span class="math">M_i = M_1^i</span>. The matrix
        representation of
        <span class="math">B(x)</span> in
        <span class="math">GL_n(2)</span> is:
      </p>

      <div class="math-block">
        M(V) = \sum_&#123;i=0&#125;^&#123;n-1&#125;
        \mathcal&#123;B&#125;_i \cdot M_i(V) +
        \mathcal&#123;B&#125;_n, \tag&#123;1&#125;
      </div>

      <p class="text-gray-300">
        where
        <span class="math">\mathcal&#123;B&#125;</span> is a matrix
        representing the constant multiplication. The matrix
        <span class="math">M(V)</span> can be computed using
        <span class="math">n</span> matrix squaring once the matrix
        <span class="math">M_1</span> is calculated.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Algorithm 2 &mdash; Matrix representation of affine
          polynomial over
          <span class="math">GL_n(2)</span>.
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300 mb-2">
            <strong>Input:</strong> Affine polynomial
            <span class="math">B(x) =
            \sum_&#123;k=0&#125;^&#123;n-1&#125;
            \beta_k x^&#123;2^k&#125; + \beta_n</span>.
          </p>
          <p class="text-gray-300 mb-2">
            <strong>Output:</strong> Matrix
            <span class="math">M \in GL_n(2)</span> corresponding
            to <span class="math">B</span>.
          </p>
          <pre><code>1: M[0] = Matrix of monomial x.
2: M[1] = Matrix of the monomial x^2.
3: for i = 2 to n-1 do
     M[i] = M[i-1] * M[1]        // M[i] is the matrix of x^(2^i)
5: for i = 0 to n-1 do
     C[i] = matrix for constant beta_i
6:   M[i] = C[i] * M[i]
7: return sum(M[i] for i=0..n-1) + C[n]</code></pre>
        </div>
      </div>

      <!-- 3.3 MDS Matrix -->
      <h3 id="sec-3.3" class="text-xl font-semibold mt-8 mb-3">
        3.3 MDS Matrix
      </h3>

      <p class="text-gray-300">
        In [SJ14], a novel basis of polynomials over a finite field of
        characteristic 2 is introduced for efficient encoding and
        decoding of Reed&ndash;Solomon erasure codes. The same basis
        is used in Vision Mark-32 to generate the MDS matrix. We fix
        a binary field
        <span class="math">K =
        \mathbb&#123;F&#125;_&#123;2^n&#125;</span> with
        <span class="math">\mathbb&#123;F&#125;_2</span>-basis
        <span class="math">\langle \beta_0, \ldots,
        \beta_&#123;n-1&#125; \rangle</span>. For each
        <span class="math">j \in \&#123;0, \ldots,
        2^n - 1\&#125;</span>, we define
        <span class="math">\omega_j := j_0 \cdot \beta_0 +
        \ldots + j_&#123;n-1&#125; \cdot
        \beta_&#123;n-1&#125;</span>, where
        <span class="math">(j_0, \ldots, j_&#123;n-1&#125;)</span>
        are <span class="math">j</span>&rsquo;s bits.
      </p>

      <p class="text-gray-300">
        Writing
        <span class="math">U_i := \langle \beta_0, \dots,
        \beta_&#123;i-1&#125; \rangle</span> for the
        <span class="math">i</span>-dimensional
        <span class="math">\mathbb&#123;F&#125;_2</span>-subspace
        generated by the first
        <span class="math">i</span> basis elements, we set
        <span class="math">W_i(X) := \prod_&#123;u \in
        U_i&#125; (X - u)</span>, a subspace polynomial of degree
        <span class="math">2^i</span>; its evaluation map
        <span class="math">W_i : K \to K</span> is
        <span class="math">\mathbb&#123;F&#125;_2</span>-linear.
      </p>

      <p class="text-gray-300">
        <span class="math">\hat&#123;W&#125;_i(X) :=
        \frac&#123;W_i(X)&#125;&#123;W_i(\beta_i)&#125;</span>
        is its normalized variant; moreover, it satisfies
        <span class="math">\hat&#123;W&#125;_i(\beta_i) =
        1</span>, and is also
        <span class="math">\mathbb&#123;F&#125;_2</span>-linear.
      </p>

      <p class="text-gray-300">
        Finally, for each
        <span class="math">j \in \&#123;0, \dots,
        2^n - 1\&#125;</span>, we set:
      </p>

      <div class="math-block">
        X_j(X) = \prod_&#123;i=0&#125;^&#123;n-1&#125;
        (\hat&#123;W&#125;_i(X))^&#123;j_i&#125;,
      </div>

      <p class="text-gray-300">
        where again
        <span class="math">(j_0, \ldots, j_&#123;n-1&#125;)</span>
        are <span class="math">j</span>&rsquo;s bits. Since each
        <span class="math">X_j(X)</span> is of degree
        <span class="math">j</span>, the set
      </p>

      <div class="math-block">
        \&#123;(X_0(X), \ldots,
        X_&#123;2^n - 1&#125;(X))\&#125;
      </div>

      <p class="text-gray-300">
        yields a
        <span class="math">K</span>-basis of
        <span class="math">K[X]</span>.
      </p>

      <p class="text-gray-300">
        For a state size of
        <span class="math">m</span>,
        <span class="math">U[i][j]</span> will contain
        <span class="math">W_i(\beta_j)</span>, for each
        <span class="math">i \in \&#123;0, \ldots,
        \lceil \log m \rceil\&#125;</span> and
        <span class="math">j \in \&#123;0, \ldots,
        \lceil \log m \rceil + 1\&#125;</span>. This information
        alone is enough to compute
        <span class="math">W_i(\omega_j)</span> for each
        <span class="math">j \in \&#123;0, \ldots,
        2 \cdot \log m - 1\&#125;</span>, using merely some
        additions, since the
        <span class="math">W_i</span>&rsquo;s are
        <span class="math">\mathbb&#123;F&#125;_2</span>-linear
        (in particular, additively homomorphic). In order to compute
        the row
        <span class="math">W_i(\beta_0), \ldots,
        W_i(\beta_&#123;\lceil \log m \rceil + 1&#125;)</span>,
        given the respective values of
        <span class="math">W_&#123;i-1&#125;</span> on these
        points, we use the recursive identity
        <span class="math">W_i(X) = W_&#123;i-1&#125;(X) \cdot
        (W_&#123;i-1&#125;(X) +
        W_&#123;i-1&#125;(\beta_&#123;i-1&#125;))</span>.
      </p>

      <p class="text-gray-300">
        <strong>Code Listing 2:</strong> Sage code to initialize
        <span class="math">U[i][j]</span> and normalizing it.
      </p>

      <pre><code>#mds_field is a binary tower.
U = [[self.mds_field.from_integer(2^j)
      for j in range(ceil(log(m,2)) + 1)]]
for i in range(1, ceil(log(m,2))):
    U.append([U[i-1][j] * (U[i-1][j] + U[i-1][i-1])
              for j in range(ceil(log(m,2)) + 1)])

for i in range(ceil(log(m,2))):
    nc = self.mds_field.from_integer(1) / U[i][i]
    U[i] = [U[i][j] * nc
            for j in range(ceil(log(m,2)) + 1)]</code></pre>

      <p class="text-gray-300">
        The next step is to expand the matrix horizontally.
        <span class="math">W[i][j]</span> will contain
        <span class="math">\hat&#123;W&#125;_i(\omega_j)</span>
        for each
        <span class="math">i \in \&#123;0, \dots,
        \lceil \log m \rceil\&#125;</span> and
        <span class="math">j \in \&#123;0, \dots,
        2 \cdot \log m - 1\&#125;</span>. This can be done by only
        using additions, having computed the values of
        <span class="math">U[i][j]</span>.
      </p>

      <p class="text-gray-300">
        <strong>Code Listing 3:</strong> Sage code for horizontal
        expansion of the matrix.
      </p>

      <pre><code>W = []
for i in range(ceil(log(m,2))):
    W_i = [self.mds_field.from_integer(0)]
    for j in range(ceil(log(m,2)) + 1):
        # W_i will contain all subset sums of U[i].
        W_i += [W_i[k] + U[i][j]
                for k in range(1 &lt;&lt; j)]
    W.append(W_i[: 2 * self.m])</code></pre>

      <p class="text-gray-300">
        To expand the matrix vertically,
        <span class="math">X[j][i]</span> will contain
        <span class="math">X_i(\omega_j)</span> for each
        <span class="math">i \in \&#123;0, \ldots,
        m - 1\&#125;</span> and
        <span class="math">j \in \&#123;0, \ldots,
        2 \cdot \log m - 1\&#125;</span>. We can again compute
        these from the
        <span class="math">\hat&#123;W&#125;_i(\omega_j)</span>
        values using a binary expansion; now multiplying instead of
        adding. Indeed, this is the definition of
        <span class="math">X_i</span>.
      </p>

      <p class="text-gray-300">
        <strong>Code Listing 4:</strong> Sage code for vertical
        expansion of the matrix.
      </p>

      <pre><code>X = []
for j in range(2 * self.m):
    X_j = [self.mds_field.from_integer(1)]
    for i in range(ceil(log(m,2))):
        # standard binary expansion, with multiplying
        # instead of adding
        X_j += [X_j[k] * W[i][j]
                for k in range(1 &lt;&lt; i)]
    X.append(X_j[: self.m])</code></pre>

      <p class="text-gray-300">
        Since the evaluation of a polynomial for the basis [SJ14] is a
        Reed&ndash;Solomon encoding, multiplication by the matrix
        <span class="math">X</span> gives us that
        Reed&ndash;Solomon encoding in matrix form. Its rate is
        <span class="math">1/2</span>, i.e., it&rsquo;s the matrix
        that takes the novel-basis coefficients of a polynomial of
        degree
        <span class="math">&lt; m</span> and returns its
        evaluations over the domain
        <span class="math">(\omega_0, \ldots,
        \omega_&#123;2m-1&#125;)</span>. We use the
        &ldquo;row convention&rdquo;: encoding is multiplying a row
        vector on the right by a wide matrix.
      </p>

      <p class="text-gray-300">
        We obtain a systematic version of the same code by
        performing row reduction echelon form (RREF) on
        <span class="math">G</span>. This code differs from the one
        above by precomposition with a
        <span class="math">K</span>-isomorphism on the message
        space. Indeed, RREF simply amounts to left-multiplying the
        <span class="math">m \times 2m</span> matrix by an
        <span class="math">m \times m</span> invertible matrix. The
        result of RREF has the identity as its left-hand half and
        our desired MDS matrix on the right. Indeed, one definition
        of an MDS matrix is simply the
        &ldquo;nonsystematic&rdquo; part of a systematic MDS code
        of rate
        <span class="math">1/2</span>. In other words, it&rsquo;s
        the extrapolation matrix, which takes the values of some
        polynomial of degree less than
        <span class="math">m</span> on the set
        <span class="math">\omega_0, \ldots,
        \omega_&#123;m-1&#125;</span>, and returns the evaluations
        of the same polynomial on
        <span class="math">\omega_m, \ldots,
        \omega_&#123;2m-1&#125;</span>.
      </p>

      <!-- 3.4 Sponge Construction -->
      <h3 id="sec-3.4" class="text-xl font-semibold mt-8 mb-3">
        3.4 Sponge Construction
      </h3>

      <p class="text-gray-300">
        The state of the permutation consists of
        <span class="math">R = 16</span> rate elements, followed by
        <span class="math">C = 8</span> capacity elements in
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>.
        If the number of field elements in the message is not a
        multiple of the rate, it must be padded with the smallest
        number of zero elements so the number of field elements in
        the message is the multiple of the rate. The first two
        capacity elements are initialized to the 64-bit
        little-endian unsigned integer representing the message
        byte-length. The remaining elements are initialized to zero.
        The first block is absorbed by overwriting 16 input rate
        elements with a message block. The remaining blocks are
        absorbed by overwriting 16 input rate elements with a
        message block and overwriting the 8 input capacity elements
        with the first 8 output rate elements of the preceding
        permutation. A digest is squeezed by reading the first 8
        output rate elements from the final permutation.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. SECURITY OF VISION MARK-32                                -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        4. Security of Vision Mark-32
      </h2>

      <p class="text-gray-300">
        The security of Vision Mark-32 relies on the security of the
        Marvelous family [Aly20], and generic security offered by Sponge
        constructions. The complexity of different attacks using
        state-of-the-art approaches against Vision Mark-32 is
        described in Table 1.
      </p>

      <table class="w-full text-sm">
        <caption class="text-gray-400 text-sm mb-2">
          Table 1: Cryptanalysis Techniques. The required number of
          rounds shows the number of rounds to ensure security
          against a specific attack.
        </caption>
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">
              Type of Attack</th>
            <th class="text-left py-2 px-3 text-gray-300">
              Required Number of Rounds</th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Differential Cryptanalysis</td>
            <td class="py-2 px-3">1</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Linear Cryptanalysis</td>
            <td class="py-2 px-3">1</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Higher Order Differentials</td>
            <td class="py-2 px-3">2</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Interpolation Attacks</td>
            <td class="py-2 px-3">3</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Gr&ouml;bner Basis Attacks</td>
            <td class="py-2 px-3">4</td>
          </tr>
        </tbody>
      </table>

      <!-- 4.1 Differential Cryptanalysis -->
      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Differential Cryptanalysis
      </h3>

      <p class="text-gray-300">
        To argue the security of Vision Mark-32 against differential
        cryptanalysis attacks, we use the wide trail strategy [Dae02].
        For the binary field
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>,
        the differential uniformity of inverse function
        <span class="math">f(x) = x^&#123;-1&#125;</span> is
        <span class="math">\delta = 2^&#123;-30&#125;</span>.
        Since the MDS matrix activates 25 S-boxes in each round, the
        probability of an
        <span class="math">N</span>-round differential is
        <span class="math">2^&#123;-750N&#125;</span>, and a
        differential cryptanalysis attack is not feasible, even for a
        small number of rounds. For a more detailed analysis of the
        Vision family against differential attacks, we refer to [Aly20b].
      </p>

      <!-- 4.2 Linear Cryptanalysis -->
      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Linear Cryptanalysis
      </h3>

      <p class="text-gray-300">
        Similar to the differential cryptanalysis in
        Subsection 4.1, the security against linear cryptanalysis is
        argued using the wide trail strategy. For the binary field
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>,
        the linearity of inverse function
        <span class="math">f(x) = x^&#123;-1&#125;</span> is
        <span class="math">\lambda = 2^&#123;-15&#125;</span>, and
        the probability of
        <span class="math">N</span>-round linear approximation is
        <span class="math">2^&#123;-375N&#125;</span>. Therefore,
        Vision Mark-32 is safe against linear cryptanalysis. Indeed,
        since the operating field is large, statistical attacks are
        not likely to be successful in breaking the security of
        Vision Mark-32.
      </p>

      <!-- 4.3 Interpolation Attacks -->
      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 Interpolation Attacks
      </h3>

      <p class="text-gray-300">
        The round function of Vision Mark-32 has two mappings of
        high degree, the inverse function, and the affine polynomial
        <span class="math">B^&#123;-1&#125;</span>. Indeed, no
        matter what direction the system is modeled as polynomials,
        either <span class="math">B</span> or
        <span class="math">B^&#123;-1&#125;</span> has a high
        degree. In [Aly20b], the upper bound for the number of rounds
        that can be attacked using meet-in-the-middle approach is
        computed as 3, and for Vision Mark-32, the same security
        argument works.
      </p>

      <!-- 4.4 Grobner Basis Attacks -->
      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 Gr&ouml;bner Basis Attacks
      </h3>

      <p class="text-gray-300">
        Arguing the security of a cryptographic primitive against
        Gr&ouml;bner basis attacks is usually done via arguing the
        hardness of computing the Gr&ouml;bner basis in
        <em>grevlex</em> order, which is believed to be the most
        efficient way to compute the Gr&ouml;bner basis for a
        general system. The complexity of computing Gr&ouml;bner
        basis in <em>grevlex</em> order is:
      </p>

      <div class="math-block">
        \mathcal&#123;O&#125;\left(\binom&#123;n+d&#125;&#123;d&#125;^&#123;\omega&#125;\right),
      </div>

      <p class="text-gray-300">
        where <span class="math">n</span> is the number of
        variables in the system,
        <span class="math">d</span> is the solving degree of the
        system, and
        <span class="math">2 &lt; \omega &lt; 3</span> is the
        linear algebra constant. Estimating the solving degree
        <span class="math">d</span> for structured systems, such as
        the systems describing cryptographic hash functions, is not
        a straightforward task. In [Aly20], the authors computed the
        solving degree for a toy version of Vision with small
        parameters and extrapolated the behavior of solving degree
        using linear regression. Yet, the extrapolation of solving
        degree is a heuristic approach and its correctness has not
        been proven. Recently, in [Ste24a, Ste24b, Bar24] the authors described
        an approach to computing the Gr&ouml;bner basis for free in
        a tailored weighted term ordering and estimate the hardness
        of solving the system as the complexity of transforming such
        Gr&ouml;bner basis to the <em>lex</em> ordering, in which
        the system is triangular and easy to solve using univariate
        polynomial solving and substituting the roots in the rest of
        the system. In this case, the complexity of transforming the
        basis to Gr&ouml;bner basis in <em>lex</em> order is:
      </p>

      <div class="math-block">
        \mathcal&#123;O&#125;\left(n D^&#123;\omega&#125;\right),
      </div>

      <p class="text-gray-300">
        where <span class="math">D</span> is the degree of the
        ideal formed by the polynomial system that describes the
        hash function. The degree <span class="math">D</span> of
        the ideal of the system represents the number of solutions
        to the polynomial system over the algebraic closure of the
        field and can be estimated using the B&eacute;zout theorem.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 1 (B&eacute;zout Theorem)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">F</span> be a field and let
            <span class="math">\overline&#123;F&#125;</span> be the
            algebraic closure of
            <span class="math">F</span>, let
            <span class="math">f_1, \ldots, f_n \in F[x_1, \ldots,
            x_m]</span> be homogeneous polynomials where degree of
            <span class="math">f_i</span> is
            <span class="math">d_i</span>, the number of solutions
            of
            <span class="math">f_1 = \ldots = f_n = 0</span>, is
            given by:
          </p>
          <div class="math-block">
            \prod_&#123;i=1&#125;^&#123;n&#125; d_i,
          </div>
          <p class="text-gray-300">
            if the ideal
            <span class="math">\langle f_1, \ldots,
            f_n \rangle</span> is zero-dimensional.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The asymptotic complexity of converting a Gr&ouml;bner basis
        to lexicographic (lex) monomial order using sparse FGLM
        algorithm is [JC17]:
      </p>

      <div class="math-block">
        O\left(\sqrt&#123;\frac&#123;6&#125;&#123;n\pi&#125;&#125;
        D^&#123;2 + \frac&#123;n-1&#125;&#123;n&#125;&#125;\right).
        \tag&#123;2&#125;
      </div>

      <p class="text-gray-300">
        <strong>Complexity of Step 3:</strong> When the ideal is
        zero-dimensional, the Gr&ouml;bner basis in lexicographic
        order is structured according to the shape lemma. This
        structure includes a unique univariate polynomial that can
        be factored and used to solve the entire system iteratively.
        Once the unique univariate polynomial is factored, it
        provides a partial solution to the system. By iteratively
        substituting these partial solutions into other polynomials
        and similarly factoring them, a complete solution is
        obtained. To solve a univariate polynomial system of degree
        <span class="math">D</span> over the finite field
        <span class="math">\mathbb&#123;F&#125;_p</span>, the
        Cantor/Zassenhaus algorithm can be used. This algorithm has
        a complexity of:
      </p>

      <div class="math-block">
        O(D^2 (\log D \log \log D)(\log p + \log D)).
      </div>

      <!-- 4.4.1 Determined System -->
      <h4 class="text-lg font-semibold mt-6 mb-3">
        4.4.1 Determined System
      </h4>

      <p class="text-gray-300">
        The first approach is to model the Vision Mark-32 as a
        determined system of polynomials as described in [Aly20]. Each
        round can be described as [Aly20b]:
      </p>

      <div class="math-block">
        S_&#123;2r-2&#125;[j] \cdot B\left(\sum_&#123;k=1&#125;^&#123;24&#125;
        M^&#123;-1&#125;[j,k] \left(S_&#123;2r-1&#125;[k] -
        C_&#123;r,1&#125;\right)\right) - 1 = 0
      </div>

      <div class="math-block">
        \left(S_&#123;2r-1&#125;[j]\right)^4 \cdot
        B\left(S_&#123;2r-1&#125;[j]^&#123;-1&#125;\right) -
        \left(S_&#123;2r-1&#125;[j]\right)^4
        \left(\sum_&#123;k=1&#125;^&#123;24&#125;
        M^&#123;-1&#125;[j,k]
        \left(S_&#123;2r&#125;[k] -
        C_&#123;r,2&#125;\right)\right) - 1 = 0,
      </div>

      <p class="text-gray-300">
        where
        <span class="math">1 \le j \le 24</span>. In total, the
        polynomial system describing Vision Mark-32 has 384
        polynomials in 384 variables, and solving degree of the
        polynomial system is estimated to be 1513 [Aly20b]. Assuming that
        Gr&ouml;bner basis can be computed for free, the degree of
        the ideal of Vision for state size
        <span class="math">m</span> and number of variables
        <span class="math">n</span> with rate
        <span class="math">r</span> and capacity
        <span class="math">c</span>, can be computed as:
      </p>

      <div class="math-block">
        \prod_&#123;i=1&#125;^&#123;2mn&#125; d_i =
        5^&#123;rc&#125; \cdot 4^&#123;r&#125; \cdot
        5^&#123;c&#125; + 5^&#123;2m(n-1)&#125;.
      </div>

      <p class="text-gray-300">
        Therefore, we re-evaluate the complexity of Gr&ouml;bner
        basis attack against Vision Mark-32 by analyzing the number
        of the solutions to the system. In any case, the complexity
        of the attack is more than an exhaustive search of the input
        space.
      </p>

      <!-- 4.4.2 Overdetermined System -->
      <h4 class="text-lg font-semibold mt-6 mb-3">
        4.4.2 Overdetermined System
      </h4>

      <p class="text-gray-300">
        In [Liu24], a new approach to analyze the security of the
        instances of Vision is described. The modeling proposed in
        [Liu24] represents Vision as an over-determined system of
        polynomials. The premise is that having more equations
        enhances the performance of solving the system. Specifically,
        the model comprises
        <span class="math">5m + 14m(N-1)</span> quadratic equations
        in
        <span class="math">3m + 6m(N-1)</span> variables. For
        Vision Mark-32, this corresponds to a quadratic system of
        equations with 2472 equations in 1080 variables.
        Consequently, the degree of regularity of the system is the
        smallest non-positive coefficient of the Hilbert series:
      </p>

      <div class="math-block">
        \frac&#123;\left(1 - X^2\right)^&#123;2472&#125;&#125;&#123;\left(1 - X\right)^&#123;1080&#125;&#125;,
      </div>

      <p class="text-gray-300">
        which is 87, and therefore complexity of Gr&ouml;bner basis
        attack is lower bounded by:
      </p>

      <div class="math-block">
        \binom&#123;87 + 1080&#125;&#123;87&#125;^2 \ge 442.
      </div>

      <p class="text-gray-300">
        It is important to mention that this complexity is a lower
        bound for the complexity of the attack suggested in [Liu24], as
        the complexity is computed under the assumption that the
        resulting system is semi-regular. However, the system is not
        semi-regular, and the solving degree in reality would be
        higher.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. IMPLEMENTATION                                            -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">5. Implementation</h2>

      <p class="text-gray-300">
        We implement Vision Mark-32 in SystemVerilog targeting Alveo
        U55C High Performance Compute Card featuring Xilinx VU47P
        FPGA. We aim to use a Gen4 PCIe shell with 512-bit interface
        running at 250 MHz.
      </p>

      <!-- 5.1 Tower field arithmetic -->
      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 Tower Field Arithmetic
      </h3>

      <p class="text-gray-300">
        Tower field arithmetic is known for its efficiency in
        hardware. Table 2 shows the resource cost of basic
        arithmetic blocks for the 32-bit binary tower. For
        comparison, we present the resource cost of a single-cycle
        32-bit unsigned integer multiplier. Multiplication and
        squaring circuits require a single clock cycle, while the
        inversion is fully pipelined and requires 3 cycles.
      </p>

      <table class="w-full text-sm">
        <caption class="text-gray-400 text-sm mb-2">
          Table 2: Arithmetic circuit complexity implemented at
          250 MHz for: multiply (MUL), square (SQR) and invert
          (INV) operations.
        </caption>
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">
              Circuit</th>
            <th class="text-right py-2 px-3 text-gray-300">
              LUT</th>
            <th class="text-right py-2 px-3 text-gray-300">
              FF</th>
            <th class="text-right py-2 px-3 text-gray-300">
              CARRY8</th>
            <th class="text-right py-2 px-3 text-gray-300">
              Max Freq. [MHz]</th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">32-bit tower MUL</td>
            <td class="py-2 px-3 text-right">521</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">378</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">32-bit tower SQR</td>
            <td class="py-2 px-3 text-right">43</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">791</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">32-bit tower INV</td>
            <td class="py-2 px-3 text-right">821</td>
            <td class="py-2 px-3 text-right">111</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">280</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">32-bit integer MUL</td>
            <td class="py-2 px-3 text-right">1107</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">96</td>
            <td class="py-2 px-3 text-right">192</td>
          </tr>
        </tbody>
      </table>

      <p class="text-gray-300">
        We acknowledge that 32-bit integer multiplication can be
        implemented using 2&ndash;3 DSP48E2 units. However, as these
        are hard IP blocks, i.e. ASIC components within the FPGA, a
        more representative comparison in terms of silicon efficiency
        can be made this way. We allow the use of fast CARRY8 chains
        for carry propagation &mdash; the critical path of the
        integer arithmetic circuits. The single-cycle 32-bit tower
        multiplier is over 4 times more efficient in terms of
        LUT-delay product compared to its unsigned integer
        counterpart. Squaring is nearly free in this tower field,
        whereas integer squaring is approximately the same as
        multiplication. Tower field inversion is only 1.58 times
        more expensive than multiplication.
      </p>

      <p class="text-gray-300">
        Lastly, integer multiplier does not include modular
        reduction, whereas all tower operations do so by design.
      </p>

      <!-- 5.2 Vision Mark-32 permutation -->
      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Vision Mark-32 Permutation
      </h3>

      <p class="text-gray-300">
        Single round of Vision Mark-32 permutation consists of 48
        round constant additions, 48 tower-field inversions, 48
        affine linearized polynomial evaluations and 2 MDS matrix
        multiplications. We implement a fully pipelined permutation
        round with 28 stages.
      </p>

      <p class="text-gray-300">
        Table 3 shows total resource utilization of a single Vision
        Mark-32 permutation round broken down into components.
      </p>

      <table class="w-full text-sm">
        <caption class="text-gray-400 text-sm mb-2">
          Table 3: Vision Mark-32 permutation round circuit
          complexity, implemented at 250 MHz.
        </caption>
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">
              Component</th>
            <th class="text-right py-2 px-3 text-gray-300">
              LUT</th>
            <th class="text-right py-2 px-3 text-gray-300">
              FF</th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Inversion</td>
            <td class="py-2 px-3 text-right">40.2 k</td>
            <td class="py-2 px-3 text-right">6.8 k</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Evaluate
              <span class="math">B</span></td>
            <td class="py-2 px-3 text-right">0.3 k</td>
            <td class="py-2 px-3 text-right">0.8 k</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Evaluate
              <span class="math">B^&#123;-1&#125;</span></td>
            <td class="py-2 px-3 text-right">0.3 k</td>
            <td class="py-2 px-3 text-right">0.8 k</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">MDS matrix
              multiplication</td>
            <td class="py-2 px-3 text-right">9.2 k</td>
            <td class="py-2 px-3 text-right">4.6 k</td>
          </tr>
          <tr class="border-b border-gray-700">
            <td class="py-2 px-3 font-semibold">Total</td>
            <td class="py-2 px-3 text-right font-semibold">
              50.0 k</td>
            <td class="py-2 px-3 text-right font-semibold">
              13.0 k</td>
          </tr>
        </tbody>
      </table>

      <p class="text-gray-300">
        Sponge absorb and squeeze do not use any additional
        resources other than wiring.
      </p>

      <!-- 5.3 Performance comparison -->
      <h3 id="sec-5.3" class="text-xl font-semibold mt-8 mb-3">
        5.3 Performance Comparison
      </h3>

      <p class="text-gray-300">
        Due to the large volume of data that needs to be processed
        in the context of ZKP, throughput is the most pressing
        bottleneck. Therefore, fully pipelined implementations are
        favorable. We compare 3 fully-pipelined implementations,
        each capable of performing 400 M hashes per second. This
        limitation is dictated by the Gen4 PCIe link, capable of
        providing 512-bits at 250 MHz.
      </p>

      <p class="text-gray-300">
        Table 4 compares fully-pipelined implementation of Vision
        Mark-32 with Gr&oslash;stl-256 [Gau09] and Poseidon [Gra21b]. The
        former is a SHA3 competition finalist, designed with
        traditional symmetric cryptography practices. The latter is
        an arithmetization-friendly hash function.
      </p>

      <table class="w-full text-sm">
        <caption class="text-gray-400 text-sm mb-2">
          Table 4: Performance comparison, implemented at 250 MHz.
          LUT numbers are reported by Xilinx Vivado 2022.2.
          Comparison is made in the zero-knowledge setting where
          high throughput is the primary goal.
        </caption>
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">
              Hash</th>
            <th class="text-right py-2 px-3 text-gray-300">
              LUT</th>
            <th class="text-right py-2 px-3 text-gray-300">
              FF</th>
            <th class="text-right py-2 px-3 text-gray-300">
              CARRY8</th>
            <th class="text-right py-2 px-3 text-gray-300">
              DSP</th>
            <th class="text-right py-2 px-3 text-gray-300">
              Latency</th>
            <th class="text-right py-2 px-3 text-gray-300">
              Throughput</th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Gr&oslash;stl</td>
            <td class="py-2 px-3 text-right">132 k</td>
            <td class="py-2 px-3 text-right">62 k</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">82</td>
            <td class="py-2 px-3 text-right">64 Gbit/s</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Vision Mark-32</td>
            <td class="py-2 px-3 text-right">398 k</td>
            <td class="py-2 px-3 text-right">104 k</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">0</td>
            <td class="py-2 px-3 text-right">112</td>
            <td class="py-2 px-3 text-right">128 Gbit/s</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Poseidon</td>
            <td class="py-2 px-3 text-right">868 k</td>
            <td class="py-2 px-3 text-right">909 k</td>
            <td class="py-2 px-3 text-right">79 k</td>
            <td class="py-2 px-3 text-right">5192</td>
            <td class="py-2 px-3 text-right">870</td>
            <td class="py-2 px-3 text-right">128 Gbit/s</td>
          </tr>
        </tbody>
      </table>

      <p class="text-gray-300">
        LUTs are the bottleneck for both Gr&oslash;stl and Vision
        Mark-32. Since Poseidon uses DSPs it is difficult to make a
        direct comparison with LUT-only designs. Assuming the 32-bit
        unsigned multiplier from Table 2 corresponds to 2 DSPs used
        to implement 32-bit multipliers we can estimate the LUT cost
        of the fully-pipelined Poseidon hasher to 3.74 million LUTs.
        Table 5 provides a comparison in terms of hardware
        efficiency expressed as throughput per LUT, as well as
        qualitative metrics.
      </p>

      <p class="text-gray-300">
        As a SHA3 finalist Gr&oslash;stl has undergone thorough
        scrutiny of the community and stood the test of time.
        Moreover, Gr&oslash;stl is based on AES, the most
        scrutinized algorithm of all. Marvelous design strategy is
        based on AES design strategy too. On the other hand,
        Poseidon is a more novel design.
      </p>

      <p class="text-gray-300">
        Unlike Gr&oslash;stl, Poseidon was designed with efficient
        arithmetization in mind. However, 64-bit Goldilocks field on
        which Poseidon is based can be up to 64 times less efficient
        when dealing with 1-bit values.
      </p>

      <p class="text-gray-300">
        Gr&oslash;stl-256 is a Merkle&ndash;Damg&aring;rd
        construction with a 512-bit compression function, and thus
        hashes an input of size 256 bits per compression. Both
        Vision Mark-32 and Poseidon are Sponge constructions with
        rates of 512 bits. Despite being arithmetization friendly,
        Vision Mark-32 is only 33% less efficient than Gr&oslash;stl
        in terms of throughput per LUT.
      </p>

      <table class="w-full text-sm">
        <caption class="text-gray-400 text-sm mb-2">
          Table 5: Additional comparisons.
          Arithmetization-friendly in this context refers to the
          underlying finite field that the hash function operates on
          to be efficiently implemented for zero-knowledge
          applications.
        </caption>
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">
              Hash</th>
            <th class="text-right py-2 px-3 text-gray-300">
              kbps/LUT</th>
            <th class="text-left py-2 px-3 text-gray-300">
              Arithmetization-friendly</th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Gr&oslash;stl</td>
            <td class="py-2 px-3 text-right">485</td>
            <td class="py-2 px-3">&mdash;</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Vision Mark-32</td>
            <td class="py-2 px-3 text-right">322</td>
            <td class="py-2 px-3">Yes (strong)</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Poseidon</td>
            <td class="py-2 px-3 text-right">34</td>
            <td class="py-2 px-3">Yes</td>
          </tr>
        </tbody>
      </table>
    </section>

    <!-- ============================================================ -->
    <!-- 6. CONCLUSION                                                -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">6. Conclusion</h2>

      <p class="text-gray-300">
        We introduced Vision Mark-32, a hash function for
        zero-knowledge applications, which is a sponge construction
        instantiated with a modified version of Vision with an
        optimized number of rounds and an efficient MDS matrix. We
        implement Vision Mark-32 in hardware, targeting a popular
        data center card. We delineated the efficient implementation
        of each step. Furthermore, we showed the advantages of tower
        arithmetic introduced in [FP97]. Efficient binary operations,
        especially often prohibitively expensive inversion, open new
        venues for design of cryptographic primitives. In this
        particular instance, we attain hardware efficiency of a fast
        classical algorithm, while still allowing efficient
        arithmetization described in [DP23].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGMENTS                                              -->
    <!-- ============================================================ -->

    <section id="acknowledgments" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Acknowledgments</h2>

      <p class="text-gray-300">
        We would like to acknowledge our colleagues at Irreducible,
        Ben Diamond and Kabir Peshawaria, for their valuable input,
        optimizations to the MDS matrix, and assistance with Sage
        programming.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">References</h2>

      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li id="ref-Alb+15">
          <span class="text-gray-500">[Alb+15]</span>
          M. R. Albrecht et al. &ldquo;Ciphers for MPC and
          FHE.&rdquo; In: <em>Advances in Cryptology &ndash;
          EUROCRYPT 2015</em>, pp. 430&ndash;454. Springer, 2015.
        </li>
        <li id="ref-Aly20">
          <span class="text-gray-500">[Aly20]</span>
          A. Aly et al. &ldquo;Design of Symmetric-Key Primitives
          for Advanced Cryptographic Protocols.&rdquo; In:
          <em>IACR Trans. Symmetric Cryptol.</em> 2020.3 (2020),
          pp. 1&ndash;45.
        </li>
        <li id="ref-Aly20b">
          <span class="text-gray-500">[Aly20b]</span>
          A. Aly et al. &ldquo;Design of Symmetric-Key Primitives
          for Advanced Cryptographic Protocols.&rdquo; In:
          <em>IACR Trans. Symmetric Cryptol.</em> 2020.3 (2020),
          pp. 1&ndash;45.
        </li>
        <li id="ref-Ash23">
          <span class="text-gray-500">[Ash23]</span>
          T. Ashur, T. Buschman, and M. Mahzoun. <em>Algebraic
          cryptanalysis of POSEIDON.</em> Tech. rep. Under
          submission, 2023.
        </li>
        <li id="ref-AA23">
          <span class="text-gray-500">[AA23]</span>
          T. Ashur, Al Kindi, and M. Mahzoun. &ldquo;XHash8 and
          XHash12: Efficient STARK-friendly Hash Functions.&rdquo;
          In: <em>IACR Cryptol. ePrint Arch.</em> (2023), p. 1045.
        </li>
        <li id="ref-Ash22">
          <span class="text-gray-500">[Ash22]</span>
          T. Ashur, M. Mahzoun, and D. Toprakhisar.
          &ldquo;Chaghri &ndash; A FHE-friendly Block
          Cipher.&rdquo; In: <em>CCS 2022</em>,
          pp. 139&ndash;150.
        </li>
        <li id="ref-Ash22b">
          <span class="text-gray-500">[Ash22b]</span>
          T. Ashur et al. <em>Rescue-Prime Optimized.</em>
          Cryptology ePrint Archive, Paper 2022/1577. 2022.
          <a href="/papers/rescue-prime-optimized-2022"
            class="text-blue-400 hover:text-blue-300"
            >[page on this site]</a>
        </li>
        <li id="ref-Bar22">
          <span class="text-gray-500">[Bar22]</span>
          A. Bariant et al. &ldquo;Algebraic Attacks against Some
          Arithmetization-Oriented Primitives.&rdquo; In:
          <em>IACR Trans. Symmetric Cryptol.</em> 2022.3 (2022),
          pp. 73&ndash;101.
        </li>
        <li id="ref-Bar24">
          <span class="text-gray-500">[Bar24]</span>
          A. Bariant et al. <em>The Algebraic Freelunch: Efficient
          Gr&ouml;bner Basis Attacks Against
          Arithmetization-Oriented Primitives.</em> ePrint
          2024/347. 2024.
        </li>
        <li id="ref-Ber08">
          <span class="text-gray-500">[Ber08]</span>
          G. Bertoni et al. &ldquo;On the Indifferentiability of
          the Sponge Construction.&rdquo; In: <em>Advances in
          Cryptology &ndash; EUROCRYPT 2008</em>,
          pp. 181&ndash;197.
        </li>
        <li id="ref-Ber11">
          <span class="text-gray-500">[Ber11]</span>
          G. Bertoni et al. <em>The Keccak Reference.</em> Keccak
          Team, 2011.
        </li>
        <li id="ref-Bey20">
          <span class="text-gray-500">[Bey20]</span>
          T. Beyne et al. &ldquo;Out of Oddity &ndash; New
          Cryptanalytic Techniques Against Symmetric Primitives
          Optimized for Integrity Proof Systems.&rdquo; In:
          <em>Advances in Cryptology &ndash; CRYPTO 2020</em>,
          pp. 299&ndash;328.
          <a href="/papers/out-of-oddity-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Bla+93">
          <span class="text-gray-500">[Bla+93]</span>
          I. F. Blake et al. <em>Applications of Finite
          Fields.</em> Springer, 1993.
        </li>
        <li id="ref-Bou23">
          <span class="text-gray-500">[Bou23]</span>
          C. Bouvier et al. &ldquo;New Design Techniques for
          Efficient Arithmetization-Oriented Hash Functions:
          Anemoi Permutations and Jive Compression Mode.&rdquo;
          In: <em>CRYPTO 2023</em>, pp. 507&ndash;539.
          <a href="/papers/anemoi-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Bou22">
          <span class="text-gray-500">[Bou22]</span>
          C. Bouvier et al. <em>New Design Techniques for
          Efficient Arithmetization-Oriented Hash Functions.</em>
          ePrint 2022/840. 2022.
          <a href="/papers/anemoi-2022"
            class="text-blue-400 hover:text-blue-300"
            >[page on this site]</a>
        </li>
        <li id="ref-Can18">
          <span class="text-gray-500">[Can18]</span>
          A. Canteaut et al. &ldquo;Stream Ciphers: A Practical
          Solution for Efficient Homomorphic-Ciphertext
          Compression.&rdquo; In: <em>Journal of Cryptology</em>
          31.3 (2018), pp. 885&ndash;916.
        </li>
        <li id="ref-Cid22">
          <span class="text-gray-500">[Cid22]</span>
          C. Cid, J. P. Indr&oslash;y, and H. Raddum.
          &ldquo;FASTA &ndash; A Stream Cipher for Fast FHE
          Evaluation.&rdquo; In: <em>CT-RSA 2022</em>,
          pp. 451&ndash;483.
        </li>
        <li id="ref-Coh92">
          <span class="text-gray-500">[Coh92]</span>
          S. D. Cohen. &ldquo;The explicit construction of
          irreducible polynomials over finite fields.&rdquo; In:
          <em>Designs, Codes and Cryptography</em> 2.2 (1992),
          pp. 169&ndash;174.
        </li>
        <li id="ref-Cos22">
          <span class="text-gray-500">[Cos22]</span>
          O. Cosseron et al. &ldquo;Towards Case-Optimized Hybrid
          Homomorphic Encryption.&rdquo; In: <em>ASIACRYPT
          2022</em>, pp. 32&ndash;67.
        </li>
        <li id="ref-Dae02">
          <span class="text-gray-500">[Dae02]</span>
          J. Daemen and V. Rijmen. <em>The design of Rijndael: AES
          &mdash; the Advanced Encryption Standard.</em>
          Springer-Verlag, 2002.
        </li>
        <li id="ref-DP23">
          <span class="text-gray-500">[DP23]</span>
          B. E. Diamond and J. Posen. <em>Succinct Arguments over
          Towers of Binary Fields.</em> ePrint 2023/1784. 2023.
        </li>
        <li id="ref-Dob23">
          <span class="text-gray-500">[Dob23]</span>
          C. Dobraunig et al. &ldquo;Pasta: A Case for Hybrid
          Homomorphic Encryption.&rdquo; In: <em>IACR Trans.
          Cryptogr. Hardw. Embed. Syst.</em> 2023.3 (2023),
          pp. 30&ndash;73.
        </li>
        <li id="ref-Dob18">
          <span class="text-gray-500">[Dob18]</span>
          C. Dobraunig et al. &ldquo;Rasta: A Cipher with Low
          ANDdepth and Few ANDs per Bit.&rdquo; In: <em>Advances
          in Cryptology &ndash; CRYPTO 2018</em>,
          pp. 662&ndash;692.
        </li>
        <li id="ref-FP97">
          <span class="text-gray-500">[FP97]</span>
          J. L. Fan and C. Paar. &ldquo;On efficient inversion in
          tower fields of characteristic two.&rdquo; In:
          <em>Proc. IEEE ISIT</em>, 1997, pp. 20&ndash;.
        </li>
        <li id="ref-JC17">
          <span class="text-gray-500">[JC17]</span>
          J.-C. Faug&egrave;re and C. Mou. &ldquo;Sparse FGLM
          algorithms.&rdquo; In: <em>Journal of Symbolic
          Computation</em> 80 (2017), pp. 538&ndash;569.
        </li>
        <li id="ref-Gau09">
          <span class="text-gray-500">[Gau09]</span>
          P. Gauravaram et al. &ldquo;Gr&oslash;stl &ndash; a
          SHA-3 candidate.&rdquo; In: <em>Symmetric Cryptography,
          Dagstuhl Seminar Proceedings</em>, 2009.
        </li>
        <li id="ref-Gra22">
          <span class="text-gray-500">[Gra22]</span>
          L. Grassi et al. <em>Horst Meets Fluid-SPN: Griffin for
          Zero-Knowledge Applications.</em> ePrint 2022/403. 2022.
          <a href="/papers/griffin-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Gra23">
          <span class="text-gray-500">[Gra23]</span>
          L. Grassi et al. &ldquo;Horst Meets Fluid-SPN: Griffin
          for Zero-Knowledge Applications.&rdquo; In:
          <em>CRYPTO 2023</em>, pp. 573&ndash;606.
          <a href="/papers/griffin-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Gra23b">
          <span class="text-gray-500">[Gra23b]</span>
          L. Grassi et al. <em>Monolith: Circuit-Friendly Hash
          Functions with New Nonlinear Layers.</em> ePrint
          2023/1025. 2023.
        </li>
        <li id="ref-Gra21">
          <span class="text-gray-500">[Gra21]</span>
          L. Grassi et al. &ldquo;Poseidon: A New Hash Function
          for Zero-Knowledge Proof Systems.&rdquo; In:
          <em>USENIX Security 2021</em>, pp. 519&ndash;535.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Gra21b">
          <span class="text-gray-500">[Gra21b]</span>
          L. Grassi et al. &ldquo;Poseidon: A New Hash Function
          for Zero-Knowledge Proof Systems.&rdquo; In:
          <em>USENIX Security 2021</em>, pp. 519&ndash;535.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Gra22b">
          <span class="text-gray-500">[Gra22b]</span>
          L. Grassi et al. &ldquo;Reinforced Concrete: A Fast Hash
          Function for Verifiable Computation.&rdquo; In:
          <em>CCS 2022</em>, pp. 1323&ndash;1335.
          <a href="/papers/reinforced-concrete-2021" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Ha22">
          <span class="text-gray-500">[Ha22]</span>
          J. Ha et al. &ldquo;Rubato: Noisy Ciphers for
          Approximate Homomorphic Encryption.&rdquo; In:
          <em>EUROCRYPT 2022</em>, pp. 581&ndash;610.
        </li>
        <li id="ref-Heb20">
          <span class="text-gray-500">[Heb20]</span>
          P. Hebborn and G. Leander. &ldquo;Dasta &ndash;
          Alternative Linear Layer for Rasta.&rdquo; In:
          <em>IACR Trans. Symmetric Cryptol.</em> 2020.3 (2020),
          pp. 46&ndash;86.
        </li>
        <li id="ref-MD15">
          <span class="text-gray-500">[MD15]</span>
          M.-D. A. Huang, M. Kosters, and S. L. Yeo. &ldquo;Last
          Fall Degree, HFE, and Weil Descent Attacks on
          ECDLP.&rdquo; In: <em>CRYPTO 2015</em>,
          pp. 581&ndash;600.
        </li>
        <li id="ref-Kar62">
          <span class="text-gray-500">[Kar62]</span>
          A. Karatsuba and Y. Ofman. &ldquo;Multiplication of
          Multidigit Numbers on Automata.&rdquo; In: <em>Soviet
          Physics Doklady</em> 7 (1962), p. 595.
        </li>
        <li id="ref-Kel21">
          <span class="text-gray-500">[Kel21]</span>
          N. Keller and A. Rosemarin. &ldquo;Mind the Middle
          Layer: The HADES Design Strategy Revisited.&rdquo; In:
          <em>EUROCRYPT 2021</em>, pp. 35&ndash;63.
          <a href="/papers/hades-revisited-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-SJ14">
          <span class="text-gray-500">[SJ14]</span>
          S.-J. Lin, W.-H. Chung, and Y. S. Han. &ldquo;Novel
          Polynomial Basis and Its Application to Reed-Solomon
          Erasure Codes.&rdquo; In: <em>IEEE FOCS 2014</em>,
          pp. 316&ndash;325.
        </li>
        <li id="ref-Liu24">
          <span class="text-gray-500">[Liu24]</span>
          F. Liu, M. Mahzoun, and W. Meier. <em>Modelling Ciphers
          with Overdefined Systems of Quadratic Equations:
          Application to Friday, Vision, RAIN and Biscuit.</em>
          ePrint 2024/786. 2024.
        </li>
        <li id="ref-Mea19">
          <span class="text-gray-500">[Mea19]</span>
          P. M&eacute;aux et al. &ldquo;Improved Filter
          Permutators for Efficient FHE.&rdquo; In:
          <em>INDOCRYPT 2019</em>, pp. 68&ndash;91.
        </li>
        <li id="ref-Mea16">
          <span class="text-gray-500">[Mea16]</span>
          P. M&eacute;aux et al. &ldquo;Towards Stream Ciphers
          for Efficient FHE with Low-Noise Ciphertexts.&rdquo; In:
          <em>EUROCRYPT 2016</em>, pp. 311&ndash;343.
        </li>
        <li id="ref-Ste24a">
          <span class="text-gray-500">[Ste24a]</span>
          M. J. Steiner. <em>A Zero-Dimensional Gr&ouml;bner Basis
          for Poseidon.</em> ePrint 2024/310. 2024.
        </li>
        <li id="ref-Ste24b">
          <span class="text-gray-500">[Ste24b]</span>
          M. J. Steiner. <em>Zero-Dimensional Gr&ouml;bner Bases
          for Rescue-XLIX.</em> ePrint 2024/468. 2024.
        </li>
        <li id="ref-Sze20">
          <span class="text-gray-500">[Sze20]</span>
          A. Szepieniec, T. Ashur, and S. Dhooghe.
          &ldquo;Rescue-Prime: a Standard Specification
          (SoK).&rdquo; In: <em>IACR Cryptol. ePrint Arch.</em>
          (2020), p. 1143.
          <a href="/papers/rescue-prime-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Sze23">
          <span class="text-gray-500">[Sze23]</span>
          A. Szepieniec et al. <em>The Tip5 Hash Function for
          Recursive STARKs.</em> ePrint 2023/107. 2023.
          <a href="/papers/tip5-2023" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-Wie88">
          <span class="text-gray-500">[Wie88]</span>
          D. Wiedemann. &ldquo;An Iterated Quadratic Extension of
          GF(2).&rdquo; In: <em>The Fibonacci Quarterly</em> 26.4
          (1988), pp. 290&ndash;295.
        </li>
      </ul>
    </section>

  </article>
</BaseLayout>
