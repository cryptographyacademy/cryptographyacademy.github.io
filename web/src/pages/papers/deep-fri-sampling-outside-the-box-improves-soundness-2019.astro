---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/336';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'DEEP-FRI: Sampling Outside the Box Improves Soundness';
const AUTHORS_HTML = 'Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, Shubhangi Saraf';

const CONTENT = `    <p class="text-gray-300">Eli Ben-Sasson<sup>∗</sup> Lior Goldberg<sup>∗</sup> Swastik Kopparty† Shubhangi Saraf‡</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Motivated by the quest for scalable and succinct zero knowledge arguments, we revisit worstcase-to-average-case reductions for linear spaces, raised by [Rothblum, Vadhan, Wigderson, STOC 2013]. The previous state of the art by [Ben-Sasson, Kopparty, Saraf, CCC 2018] showed that if some member of an affine space U is δ-far in relative Hamming distance from a linear code V — this is the worst-case assumption — then most elements of U are almost-δ-far from V — this is the average case. However, this result was known to hold only below the "double Johnson" function of the relative distance δ<sup>V</sup> of the code V , i.e., only when δ < 1 − (1 − δ<sup>V</sup> ) 1/4 .</p>

    <p class="text-gray-300">First, we increase the soundness-bound to the "one-and-a-half Johnson" function of δ<sup>V</sup> and show that the average distance of U from V is nearly δ for any worst-case distance δ smaller than 1 − (1 − δ<sup>V</sup> ) 1/3 . This bound is tight, which is somewhat surprising because the one-and-a-half Johnson function is unfamiliar in the literature on error correcting codes.</p>

    <p class="text-gray-300">To improve soundness further for Reed Solomon codes we sample outside the box. We suggest a new protocol in which the verifier samples a single point z outside the box D on which codewords are evaluated, and asks the prover for the value at z of the interpolating polynomial of a random element of U. Intuitively, the answer provided by the prover "forces" it to choose one codeword from a list of "pretenders" that are close to U. We call this technique Domain Extending for Eliminating Pretenders (DEEP).</p>

    <p class="text-gray-300">The DEEP method improves the soundness of the worst-case-to-average-case reduction for RS codes up their list decoding radius. This radius is bounded from below by the Johnson bound, implying average distance is approximately δ for all δ < 1 − (1 − δ<sup>V</sup> ) 1/2 . Under a plausible conjecture about the list decoding radius of Reed-Solomon codes, average distance from V is approximately δ for all δ. The DEEP technique can be generalized to all linear codes, giving improved reductions for capacity-achieving list-decodable codes.</p>

    <p class="text-gray-300">Finally, we use the DEEP technique to devise two new protocols:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An Interactive Oracle Proof of Proximity (IOPP) for RS codes, called DEEP-FRI. This soundness of the protocol improves upon that of the FRI protocol of [Ben-Sasson et al., ICALP 2018] while retaining linear arithmetic proving complexity and logarithmic verifier arithmetic complexity.</li>

      <li>An Interactive Oracle Proof (IOP) for the Algebraic Linking IOP (ALI) protocol used to construct zero knowledge scalable transparent arguments of knowledge (ZK-STARKs) in [Ben-Sasson et al., eprint 2018]. The new protocol, called DEEP-ALI, improves soundness of this crucial step from a small constant < 1/8 to a constant arbitrarily close to 1.</li>

    </ul>

    <p class="text-gray-300"><sup>∗</sup>StarkWare Industries Ltd. {eli,lior}@starkware.co</p>

    <p class="text-gray-300"><sup>†</sup>Department of Mathematics and Department of Computer Science, Rutgers University. Research supported in part by NSF grants CCF-1253886, CCF-1540634, CCF-1814409 and CCF-1412958, and BSF grant 2014359. Some of this research was done while visiting the Institute for Advanced Study. swastik.kopparty@gmail.com</p>

    <p class="text-gray-300"><sup>‡</sup>Department of Mathematics and Department of Computer Science, Rutgers University. Research supported in part by NSF grants CCF-1350572, CCF-1540634 and CCF-1412958, BSF grant 2014359, a Sloan research fellowship and the Simons Collaboration on Algorithms and Geometry. Some of this research was done while visiting the Institute for Advanced Study. shubhangi.saraf@gmail.com</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Arithmetization is a marvelous technique that can be used to reduce problems in computational complexity, like verifying membership in a nondeterministic language, to questions about membership of vectors in algebraic codes like Reed-Solomon (RS) and Reed-Muller (RM) codes [Raz87, LFKN92]. One of the end-points of such a reduction is the RS proximity testing (RPT) problem. It is a problem of inherent theoretical interest, but also of significant practical importance because it is used in recent constructions of succinct zero knowledge (ZK) arguments including Ligero [AHIV17], Aurora [BCR<sup>+</sup>18], and Scalable Transparent ARguments of Knowledge (ZK-STARKs) [BBHR18a]. We discuss this connection after describing the problem and our results.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the RPT problem a verifier is given oracle access to a function  <span class="math">f:D\\to\\mathbb{F}</span> , we call  <span class="math">D\\subset\\mathbb{F}</span>  the evaluation domain, and is tasked with distinguishing between the "good" case that f is a polynomial of degree at most d and the "bad" case in which f is  <span class="math">\\delta</span> -far in relative Hamming distance from all degree-d polynomials. To achieve succinct verification time, poly-logarithmic in d, we must allow the verifier some form of interaction with a prover — the party claiming that  <span class="math">\\deg(f) \\leq d</span> . Initially, this interaction took the form of oracle access to a probabilistically checkable proof of proximity (PCPP) [BGH+06] provided by the prover in addition to f. Indeed, in this model the RPT problem can be "solved" with PCPPs of quasilinear size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">poly  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , constant query complexity and constant soundness [BS08, Din07]. However, the concrete complexity of prover time, verifier time and communication complexity are rather large, even when considering practical settings that involve moderately small instance sizes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To improve prover, verifier, and communication complexity for concrete (non-asymptotic) size problems, the Interactive Oracle Proofs of Proximity (IOPP) model is more suitable [RRR16, BCS16, BCF<sup>+</sup>16]. This model can be viewed as a multi-round PCPP. Instead of having the prover write down a single proof  <span class="math">\\pi</span> , in the IOPP setting the proof oracle is produced over a number of rounds of interaction, during which the verifier sends random bits and the prover responds with additional (long) messages to which the verifier is allowed oracle access. The additional rounds of interaction allow for a dramatic improvement in the asymptotic and concrete complexity of solving the RPT problem. In particular, the Fast RS IOPP (FRI) protocol of [BBHR18b] has linear prover arithmetic complexity, logarithmic verifier arithmetic complexity and constant soundness. Our goal here is to improve soundness of this protocol and to suggest better protocols in terms of soundness in the high-error regime (also known as the "list decoding" regime).</p>

    <p class="text-gray-300">Soundness analysis of FRI reduces to the following natural "worst-case-to-average-case" question regarding linear spaces, which is also independently very interesting for the case of general (non-RS) codes. This question was originally raised in a different setting by [RVW13] and we start by discussing it for general linear codes before focusing on the special, RS code, case.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.1 Maximum distance vs average distance to a linear code</h4>

    <p class="text-gray-300">Suppose that  <span class="math">U \\subset \\mathbb{F}^D</span>  is a "line", a 1-dimensional<sup>1</sup> affine space over  <span class="math">\\mathbb{F}</span> . Let  <span class="math">u^<em> \\in \\mathbb{F}^D</span>  denote the origin of this line and u be its slope, so that  <span class="math">U = \\{u_x = u^</em> + xu \\mid x \\in \\mathbb{F}\\}</span> . For a fixed linear space  <span class="math">V \\subset \\mathbb{F}^D</span> , pick  <span class="math">u^*</span>  to be the element in U that is farthest from V, denoting by  <span class="math">\\delta_{\\max}</span>  its relative Hamming distance (from V). This is our worst-case assumption. Letting  <span class="math">\\delta_x = \\Delta(u_x, V)</span>  where  <span class="math">\\Delta</span></p>

    <p class="text-gray-300"><span id="page-1-0"></span><sup>&</sup>lt;sup>1</sup>The generalization of our results to spaces U of dimension > 1 is straightforward by partitioning U into lines through  <span class="math">u^*</span>  and applying these results to each line.</p>

    <p class="text-gray-300">denotes relative Hamming distance, what can be said about the <em>expected</em> distance  <span class="math">\\mathbf{E}_{x \\in \\mathbb{F}}[\\delta_x]</span>  of  <span class="math">u_x</span>  from V?</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rothblum, Vadhan and Wigderson showed that  <span class="math">\\mathbf{E}_x[\\delta_x] \\geq \\frac{\\delta_{\\max}}{2} - o(1)</span>  for all spaces U and V, where, here and below, o(1) denotes negligible terms that approach 0 as  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\to \\infty<span class="math">  [RVW13]. A subset of the co-authors of this paper improved this to  </span>\\mathbf{E}[\\delta_x] \\geq 1 - \\sqrt{1 - \\delta_{\\max}} - o(1)<span class="math"> , showing the average distance scales roughly like the Johnson list-decoding function of  </span>\\delta_{\\max}<span class="math"> , where  </span>J(x) := 1 - \\sqrt{1 - x}<span class="math">  [BKS18a]. In both of these bounds the expected distance is strictly smaller than  </span>\\delta_{\\max}<span class="math"> . However, the latter paper also showed that when V is a (linear) error correcting code with large relative distance  </span>\\delta_V<span class="math"> , if  </span>\\delta_{\\max}<span class="math">  is smaller than the &quot;double Johnson&quot; function of  </span>\\delta_V<span class="math"> , given by  </span>J^{(2)}(x) := J(J(x))$ , then the average distance hardly deteriorates,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-2-0"></span> <span class="math-block">\\mathbf{E}[\\delta_x] \\ge \\min\\left(\\delta_{\\max}, J^{(2)}(\\delta_V)\\right) - o(1) = \\min\\left(\\delta_{\\max}, 1 - \\sqrt[4]{1 - \\delta_V}\\right) - o(1) \\tag{1}</span></p>

    <p class="text-gray-300">and the equation above summarizes the previous state of affairs on this matter.</p>

    <p class="text-gray-300">Our first result is an improvement of Equation (1) to the "one-and-a-half-Johnson" function  <span class="math">J^{(1.5)}(x) = 1 - (1-x)^{1/3}</span> . Lemma 3.1 says that for codes V of relative Hamming distance  <span class="math">\\delta_V</span> ,</p>

    <p class="text-gray-300"><span id="page-2-1"></span> <span class="math-block">\\mathbf{E}[\\delta_x] \\ge \\min\\left(\\delta_{\\max}, J^{(1.5)}(\\delta_V)\\right) - o(1) = \\min\\left(\\delta_{\\max}, 1 - \\sqrt[3]{1 - \\delta_V}\\right) - o(1). \\tag{2}</span></p>

    <p class="text-gray-300">Our second result shows that Equation (2) is tight, even for the special case of V being an RS code. We find this result somewhat surprising because the  <span class="math">J^{(1.5)}(x)</span>  function is not known to be related to any meaningful coding theoretic notion. The counter-example showing the tightness of Equation (2) arises for very special cases, in which (i)  <span class="math">\\mathbb{F}</span>  is a binary field (of characteristic 2), (ii) the rate  <span class="math">\\rho</span>  is precisely  <span class="math">1/8 = 2^{-3}</span>  and, most importantly, (iii) the evaluation domain D equals all of  <span class="math">\\mathbb{F}</span>  (see Section 3.1). Roughly speaking, the counter-example uses functions  <span class="math">u^<em>, u : \\mathbb{F}_{2^n} \\to \\mathbb{F}_{2^n}</span>  that are  <span class="math">3/4 = 1 - \\rho^{2/3}</span> -far from polynomials of degree  <span class="math">\\rho 2^n</span>  yet pretend to be low-degree because for all  <span class="math">x \\in \\mathbb{F}_{2^n} \\setminus \\{0\\}</span>  the function  <span class="math">u^</em> + xu</span>  is  <span class="math">1/2 = \\sqrt[3]{\\rho}</span> -close to a polynomial of degree  <span class="math">\\rho 2^n</span> . See Lemma 3.3 for details.</p>

    <p class="text-gray-300">Our next set of results, which we discuss below, show how to go beyond the above limitation through a new interactive proximity proving technique.</p>

    <h2 id="sec-5" class="text-2xl font-bold">1.2 Domain Extension for Eliminating Pretenders (DEEP)</h2>

    <p class="text-gray-300">The case that interests us most is when V is an RS code (although we will return to the discussion of general linear codes later). Henceforth, the RS code of rate  <span class="math">\\rho</span>  evaluated over D is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{RS}[\\mathbb{F},D,\\rho] := \\left\\{ f: D \\to \\mathbb{F} \\mid \\deg(f) < \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">RS codes are maximum distance separable (MDS), meaning that  <span class="math">\\delta_V = 1 - \\rho</span>  and so Equation (2) simplifies to</p>

    <p class="text-gray-300"><span id="page-2-2"></span> <span class="math-block">\\mathbf{E}[\\delta_x] \\ge \\min(\\delta_{\\max}, 1 - \\sqrt[3]{\\rho}) - o(1). \\tag{3}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This improved bound can be translated, using some extra work, to FRI soundness analysis with similar guarantees. Specifically, Equation (3) implies that for  <span class="math">f:D\\to\\mathbb{F}</span>  that is  <span class="math">\\delta</span> -far from RS[ <span class="math">\\mathbb{F},D,\\rho</span> ], the soundness error of a single invocation of the FRI QUERY test (which requires  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  queries) is at most max </span>\\{1-\\delta,\\sqrt[3]{\\rho}\\}<span class="math"> , and this can be plugged into ZK-STARKs like [BBHR18a] and ZK-SNARGs like Aurora [BCR&lt;sup&gt;+&lt;/sup&gt;18]. Roughly speaking, if the rejection probability is of  </span>\\delta$ -far words</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is  <span class="math">\\max(\\delta, \\delta_0)</span>  then to reach soundness error less than  <span class="math">2^{-\\lambda}</span>  for codes of blocklength n, communication complexity (and verifier complexity) scale roughly like  <span class="math">\\frac{\\lambda}{\\log \\delta_0} \\cdot c \\cdot \\log n</span>  for some constant c. Thus, the improvement from Equation (1) to Equation (2) translates to a 25% reduction in verifier complexity (from  <span class="math">\\frac{4\\lambda}{\\log \\rho} \\cdot c \\cdot \\log n</span>  to  <span class="math">\\frac{3\\lambda}{\\log \\rho} \\cdot c \\cdot \\log n</span> ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To break the soundness bound of Equation (2) and thereby further reduce verifier complexity in the afore-mentioned systems, we suggest a new method. We discuss it first for RS codes, then generalize to arbitrary linear codes. If  <span class="math">u^<em>, u: D \\to \\mathbb{F}</span>  are indeed the evaluation of two degree d polynomials, say,  <span class="math">P^</em></span>  and P, our verifier will artificially extend the domain D to a larger one  <span class="math">\\overline{D}</span> , sample uniformly  <span class="math">z \\in \\overline{D}</span>  and ask for the evaluation of  <span class="math">P^<em>(z)</span>  and P(z). The answers provided by the prover can now be applied to modify each of  <span class="math">u^</em></span>  and u in a local manner to reflect the new knowledge, and along the way also prune down the large list of polynomials which  <span class="math">u^<em></span>  and u might pretend to be. If  <span class="math">\\alpha_z^</em> = P^<em>(z), \\alpha_z = P(z)</span>  are the honest prover's answers to the query z, then (X-z) divides  <span class="math">P^</em>(X) - \\alpha_z^*</span>  and likewise  $(X-z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(X) - \\alpha_z<span class="math"> . Letting  </span>\\alpha_x = \\alpha^<em> + x\\alpha<span class="math">  and  </span>P_x(X) = P^</em>(X) + xP(X)<span class="math">  it follows that  </span>(X-z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_x(X) - \\alpha_x<span class="math"> . Consider now the soundness of this procedure. In the extreme case that  </span>u^<em><span class="math">  has a small list of polynomials that, each, somewhat agree with it, then with high probability over z, any answer provided by the prover will agree with at most one of the polynomials in this list. The proof of our main technical result, Theorem 4.1, formalizes this intuition. For radius  </span>\\delta<span class="math"> , let  </span>L_{\\delta}^</em>$  be the maximal list size,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$L_{\\delta}^<em> = \\max_{u^</em> \\in \\mathbb{F}^D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{v \\in V \\mid \\Delta(u^*, v) < \\delta\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\Delta</span>  denotes relative Hamming distance. Let  $V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{u_x(z)=\\alpha_x}<span class="math">  be the restriction of V to codewords that are evaluations of polynomials of degree at most d that, additionally, evaluate to  </span>\\alpha_x<span class="math">  on z. Our main Theorem 4.1 shows that if  </span>\\Delta(u^<em>,V)=\\delta_{\\max}<span class="math">  then for any pair of answers  </span>\\alpha_z^</em><span class="math"> ,  </span>\\alpha_z$  given in response to query z,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-3-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{E}_{z,x} \\left[ \\Delta(u_x, V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{u_x(z) = \\alpha_x}) \\right] \\ge \\delta_{\\max} - L_{\\delta}^* \\cdot \\left( \\frac{\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\right)^{1/3} - o(1). \\tag{4}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Johnson bound (Theorem 2.2) says that when  <span class="math">\\delta &lt; J(1-\\rho) = 1 - \\sqrt{\\rho}</span>  we have  <span class="math">L_{\\delta}^* = O(1)</span>  and this improves the worst-case-to-average-case result from that of Equation (2) to a bound that matches the Johnson bound:</p>

    <p class="text-gray-300"><span id="page-3-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{E}_{z,x}[\\Delta(u_x, V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{u_x(z)=\\alpha_x})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] \\ge \\min\\left(\\delta_{\\max}, J(\\delta_V)\\right) - o(1) = \\min\\left(\\delta_{\\max}, \\sqrt{\\rho}\\right) - o(1). \\tag{5}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The exact behavior of the list size of Reed-Solomon codes beyond the Johnson bound is a famous open problem. It may be the case that the list size is small for radii far greater than the Johnson bound; in fact, for most domains D this is roughly known to hold [RW14]. If it holds that that list sizes are small all the way up to radius equal to the distance  <span class="math">\\delta_V = 1 - \\rho</span>  (i.e., if Reed-Solomon codes meet list-decoding capacity), then Equation (5) implies that the technique suggested here has optimal soundness for (nearly) all distance parameters.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generalization to arbitrary linear codes The DEEP method can be used to improve worst-to-average-case reductions for general linear codes. Viewing codewords in V as evaluations of linear forms of a domain D, we ask for the evaluation of the linear forms that supposedly correspond to  <span class="math">u^*</span>  and u on a random location  <span class="math">z \\in \\bar{D}</span>  where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Lemma 4.6 generalizes Theorem 4.1 and says that if V has near-capacity list-decoding radius (with small list size) and  </span>\\bar{D}$  corresponds to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(columns of a generating matrix of) a good error correcting code, then we have  <span class="math">\\mathbf{E}_x[\\delta_x] \\approx \\delta_{\\max}</span> . The main difference between the RS case and that of general linear codes is that in the former, the prover-answers  <span class="math">\\alpha^*(x), \\alpha(x)</span>  can be processed to modify locally the entries of  <span class="math">u_x</span>  to reduce the degree of the resulting function; this is something we cannot carry out (to best of our understanding) for all linear codes.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.3 DEEP-FRI</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applying the technique of domain extension for eliminating pretenders to the FRI protocol requires a modification that we discuss next. The FRI protocol can be described as a process of "randomly folding" an (inverse) Fast Fourier Transform (iFFT) computation. In the "classical" iFFT, one starts with a function  <span class="math">f^{(0)}:\\langle\\omega\\rangle\\to\\mathbb{F}</span>  where  <span class="math">\\omega</span>  generates a multiplicative group of order  <span class="math">2^k</span>  for integer k. The iFFT computes (in arithmetic complexity  <span class="math">O(k2^k)</span> ) the interpolating polynomial  <span class="math">\\tilde{f}(X)</span>  of the function f. This computation follows by computing (in linear time) a pair of functions  <span class="math">f_0, f_1:\\langle\\omega^2\\rangle\\to\\mathbb{F}</span> , recalling  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\omega^2\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\frac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\omega\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Their interpolants  </span>\\tilde{f}_0, \\tilde{f}_1<span class="math">  are then used to compute in linear time the original interpolant  </span>\\tilde{f}$  of f.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As explained in [BBHR18b], in the FRI protocol the prover first commits to f as above. Then the verifier samples a random  <span class="math">x^{(0)} \\in \\mathbb{F}</span>  and the protocol continues with the single function  <span class="math">f^{(1)}</span> :  <span class="math">\\langle \\omega^2 \\rangle \\to \\mathbb{F}</span>  which is supposedly  <span class="math">f^{(1)} := f_0 + x^{(0)} f_1</span> . It turns out that if f is indeed of degree less than  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\omega \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  then for all x we have that  </span>f^{(1)}<span class="math">  is of degree less than  </span>\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\omega^2 \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  as well. The tricky part is showing that when f is  </span>\\delta<span class="math"> -far from RS[ </span>\\mathbb{F}<span class="math"> ,  </span>\\langle \\omega \\rangle<span class="math"> ,  </span>\\rho<span class="math"> ] this also holds with high probability (over x) for  </span>f^{(1)}<span class="math">  and some  </span>\\delta'<span class="math">  that is as close as possible to  </span>\\delta<span class="math"> . (One can show that invariably we have  </span>\\delta' \\leq \\delta$ , i.e., the green line of Figure 1 is an upper bound on soundness of both FRI and the new DEEP-FRI protocol described below.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The worst-case-to-average-case results of Equation (2) and Lemma 3.1 can be converted to similar improvements for FRI, showing that for  <span class="math">\\delta &lt; 1 - \\sqrt[3]{\\rho}</span>  we have  <span class="math">\\delta&#x27; \\approx \\delta</span> . This follows directly from the techniques of [BKS18a, Section 7] (see the red line in Figure 1). But to use the new DEEP technique of Equation (4) and Theorem 4.1 in order to improve soundness of an RS-IOPP, we need to modify the FRI protocol, leading to a new protocol that is aptly called DEEP-FRI. Instead of constructing  <span class="math">f^{(1)}</span>  directly, our verifier first samples  <span class="math">z^{(0)} \\in \\mathbb{F}</span>  and queries the prover for the evaluation of the interpolant of  <span class="math">f^{(0)}</span>  on  <span class="math">z^{(0)}</span>  and  <span class="math">-z^{(0)}</span> . After the answers  <span class="math">\\alpha_{z^{(i)}}, \\alpha_{-z^{(i)}}</span>  have been recorded, the verifier proceeds by sampling  <span class="math">x^{(0)}</span>  and expects the prover to submit  <span class="math">f^{(1)}</span>  which is the linear combination of  <span class="math">f&#x27;_0, f&#x27;_1</span>  derived from the modification f' of f that takes into account the answers  <span class="math">\\alpha_{z^{(i)}}, \\alpha_{-z^{(i)}}</span> . Assuming  <span class="math">\\tilde{f}</span>  is the interpolant of f, an honest prover would set  <span class="math">f&#x27;(X) := (\\tilde{f}(X) - U(X))/(Z(X))</span>  where U(X) is the degree  <span class="math">\\leq 1</span>  polynomial that evaluates to  <span class="math">\\alpha_{z^{(0)}}</span>  on  <span class="math">z^{(0)}</span>  and to  <span class="math">\\alpha_{-z^{(0)}}</span>  on  <span class="math">-z^{(0)}</span>  and Z(X) is the monic degree 2 polynomial whose roots are  <span class="math">z^{(0)}</span>  and  <span class="math">-z^{(0)}</span> . As shown in Section 5, the soundness bounds of Equation (4) and Theorem 4.1 now apply to DEEP-FRI. This shows that the soundness of DEEP-FRI, i.e., the rejection probability of words that are  <span class="math">\\delta</span> -far from RS[ <span class="math">\\mathbb{F}</span> , D,  <span class="math">\\rho</span> ] is roughly  <span class="math">\\delta</span>  for any  <span class="math">\\delta</span>  that is smaller than the maximal radius for which list-sizes are "small". Figure 1 summarizes the results described here.</p>

    <h2 id="sec-7" class="text-2xl font-bold">1.4 DEEP Algebraic Linking IOP (DEEP-ALI)</h2>

    <p class="text-gray-300">In Section 1.3 we only discussed results improving the soundness of Reed-Solomon Proximity Testing (RPT). We now discuss how to improve the soundness of IOP-based argument systems (such as [BBHR18a, BCR<sup>+</sup>18]) that use RPT solutions. In order to reap the benefits of the improved</p>

    <p class="text-gray-300"><img src="_page_5_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-5-0"></span>Figure 1: FRI and DEEP-FRI soundness threshold  <span class="math">\\delta_0</span>  as a function of RS code rate  <span class="math">\\rho</span> , for a single invocation of the QUERY phase, as field size  <span class="math">q \\to \\infty</span> .  <span class="math">\\delta_0(\\rho)</span>  is defined to be the largest distance parameter  <span class="math">\\delta</span>  for which soundness (rejection probability) of a single invocation of the FRI/DEEP-FRI QUERY is  <span class="math">\\delta - o(1)</span> . Higher lines are better. The top line is the trivial upper bound on soundness which applies to both FRI and DEEP-FRI; the bottom line is the soundness of the original analysis of [BBHR18b]. Dashed lines represent prior results. The red line is the (tight) soundness lower bound for FRI and the blue line is a lower bound on DEEP-FRI soundness. Under a plausible conjecture for Reed-Solomon list-decodability (Conjecture 2.3), the actual soundness is as high as the green line.</p>

    <p class="text-gray-300">soundness of RPT, we need reductions that produce instances of the RPT problem that are very far from the relevant RS code when the input instance is unsatisfiable. One such protocol is the Algebraic Linking IOP (ALI) of [BBHR18a]. The instances of the RPT problem derived from an unsatisfiable instance in ALI are proven to be somewhat far from low-degree but the distance bound proved in that paper is less than 1/8, even when used with RS codes of negligible rate  <span class="math">\\rho</span>  (nevertheless it is conjectured and assumed in both ZK-STARK [BBHR18a] and Aurora [BCR<sup>+</sup>18] that the distance is significantly greater). In Section 6 we use the DEEP technique to modify the ALI protocol in a manner similar to the DEEP-FRI modification. The result of this modification allows us to apply the soundness results of Equation (4) to the DEEP-ALI protocol and show that, when provided with unsatisfiable instances, the distance of the received words that result from that protocol is provably at least  <span class="math">1 - \\sqrt{\\rho} - o(1)</span>  (and may be greater, assuming more favourable bounds on the list decoding radius for RS codes, as in Conjecture 2.3).</p>

    <p class="text-gray-300">Organization of the rest of the paper Section 2 presents general notation. Section 3 gives an improved worst-to-average case reductions for general spaces and shows that the bound in the reduction is tight (Lemma 3.3). Section 4 presents our main technical result, showing that the DEEP method improves worst-to-average case reductions for RS codes up to the Johnson bound (provably) and perhaps even beyond. Section 5 presents the DEEP-FRI protocol that obtains better soundness than the state of the art FRI protocol, and Section 6 discusses the DEEP-ALI protocol.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Functions</strong> For a set D, we will be working with the space of functions  <span class="math">u:D\\to\\mathbb{F}</span> , denoted  <span class="math">\\mathbb{F}^D</span> . For  <span class="math">u\\in\\mathbb{F}^D</span>  we use u(z) to denote the zth entry of u, for  <span class="math">z\\in D</span> . For  <span class="math">C\\subset D</span>  we use  $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C<span class="math">  to denote the restriction of f to C. For two functions  </span>f,g:D\\to\\mathbb{F}<span class="math">  we write f=g when the two functions are equal as elements in  </span>\\mathbb{F}^D<span class="math">  and similarly say  </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C=g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C<span class="math">  when their restrictions are equal as elements in  </span>\\mathbb{F}^C$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Distance</strong> We use  <span class="math">\\Delta_D(u,v) = \\Pr_{z \\in D} [u(z) \\neq v(z)]</span>  for relative Hamming distance, and omit D when it is clear from context. For a set  <span class="math">S \\subset \\mathbb{F}^D</span>  we use  <span class="math">\\Delta_D(v,S) = \\min_{s \\in S} \\Delta_D(v,s)</span>  and  <span class="math">\\Delta_D(S) = \\min_{s \\neq s&#x27; \\in S} \\Delta_D(s,s&#x27;)</span>  denotes the minimal relative distance of S. For  <span class="math">u \\in \\mathbb{F}^D</span>  let  <span class="math">B(u,\\delta)</span>  denote the Hamming ball in  <span class="math">\\mathbb{F}^D</span>  of normalized radius  <span class="math">\\delta</span>  centered at u,</p>

    <div class="my-4 text-center"><span class="math-block">B(u,\\delta) = \\left\\{ u&#x27; \\in \\mathbb{F}^D \\mid \\Delta_D(u,u&#x27;) &lt; \\delta \\right\\}.</span></div>

    <p class="text-gray-300"><strong>Linear codes</strong> An  <span class="math">[n,k,d]_q</span> -linear error correcting code is a linear space  <span class="math">V \\subset \\mathbb{F}_q^n</span>  of dimension k over  <span class="math">\\mathbb{F}_q</span>  with minimal Hamming distance d. A generating matrix for V is a matrix  <span class="math">G \\in \\mathbb{F}_q^{n \\times k}</span>  of rank k such that  <span class="math">V = \\{Gx \\mid x \\in \\mathbb{F}_q^k\\}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Polynomials and RS codes</strong> The <em>interpolant</em> of  <span class="math">f:D\\to\\mathbb{F}_q</span>  is the unique polynomial of degree <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">whose evaluation on D is f. The degree of f, denoted  <span class="math">\\deg(f)</span> , is the degree of its interpolant. The RS code evaluated over domain  <span class="math">D\\subset\\mathbb{F}</span>  and rate  <span class="math">\\rho</span>  is denoted  $\\mathsf{RS}[\\mathbb{F},D,\\rho]=\\{f:D\\to\\mathbb{F}\\mid \\deg(f)<\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> . Sometimes it will be more convenient to work with degree rather than rate, in which case we abuse notation and define  </span>\\mathsf{RS}[\\mathbb{F},D,d]=\\{f:D\\to\\mathbb{F}\\mid \\deg(f)< d\\}<span class="math"> . We use capital letters like P,Q to denote polynomials and when we say  </span>P\\in\\mathsf{RS}[\\mathbb{F},D,\\rho]<span class="math">  we mean that  </span>\\deg(P)<\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and associate P with the RS codeword that is its evaluation on D. We also use  </span>\\tilde{f}$  to denote the interpolant of a function f.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-9" class="text-2xl font-bold">2.1 List Decoding</h2>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (List size for Reed-Solomon Codes). For  <span class="math">u \\in \\mathbb{F}^D</span> , a set  <span class="math">V \\subset \\mathbb{F}^D</span> , and distance parameter  <span class="math">\\delta \\in [0,1]</span> , let  <span class="math">\\mathsf{List}(u,V,\\delta)</span>  be the set of elements in V that are at most  <span class="math">\\delta</span> -far from u in relative Hamming distance. Formally, using  <span class="math">B(u,\\delta)</span>  to denote the Hamming ball of relative radius  <span class="math">\\delta</span>  centered around u, we have  <span class="math">\\mathsf{List}(u,V,\\delta) = B(u,\\delta) \\cap V</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The code V is said to be  <span class="math">(\\delta, L)</span> -list-decodable if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{List}(u, V, \\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L<span class="math">  for all  </span>u \\in \\mathbb{F}_q^D$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">D \\subseteq \\mathbb{F}_q</span> , let  <span class="math">\\mathcal{L}(\\mathbb{F}_q, D, d, \\delta)</span>  be the maximum size of  <span class="math">\\mathsf{List}(u, V, \\delta)</span>  taken over all  <span class="math">u \\in \\mathbb{F}_q^D</span>  for  $V = \\mathsf{RS}[\\mathbb{F}_q, D, \\rho = d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We recall the fundamental Johnson bound, which says that sets with large minimum distance have nontrivial list-decodability. The particular version below follows, e.g., from [Gur07, Theorem 3.3] by setting  $d = (1 - \\rho)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>e = (1 - \\sqrt{\\rho} - \\varepsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  there.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-6-0"></span><strong>Theorem 2.2</strong> (Johnson bound). Let  <span class="math">V \\subset \\mathbb{F}^D</span>  be a code with minimum relative distance  <span class="math">1 - \\rho</span> , for  <span class="math">\\rho \\in (0,1)</span> . Then V is  <span class="math">(1-\\sqrt{\\rho}-\\varepsilon,1/(2\\varepsilon\\sqrt{\\rho}))</span> -list-decodable for every  <span class="math">\\varepsilon \\in (0,1-\\sqrt{\\rho})</span> .</p>

    <p class="text-gray-300">In particular, for Reed-Solomon codes this implies the following list-decodability bound:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathcal{L}(\\mathbb{F}_q, D, d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 1 - \\sqrt{\\rho} - \\varepsilon) \\le O\\left(\\frac{1}{\\varepsilon\\sqrt{\\rho}}\\right).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Extremely optimistically, we could hope that Reed-Solomon codes are list-decodable all the way up to their distance with moderate list sizes. Staying consistent with the known limitations [BSKR10], we have the following brave conjecture.</p>

    <p class="text-gray-300"><span id="page-7-1"></span>Conjecture 2.3 (List decodability of Reed-Solomon Codes up to Capacity). For every  <span class="math">\\rho &gt; 0</span> , there is a constant  <span class="math">C_{\\rho}</span>  such that every Reed-Solomon code of length n and rate  <span class="math">\\rho</span>  is list-decodable from  <span class="math">1 - \\rho - \\varepsilon</span>  fraction errors with list size  <span class="math">\\left(\\frac{n}{\\varepsilon}\\right)^{C_{\\rho}}</span> . That is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathcal{L}(\\mathbb{F}_q, D, d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 1 - \\rho - \\varepsilon) \\le \\left(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\varepsilon}\\right)^{C_\\rho}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our first result gives better distance preservation results for linear codes V of relative distance  <span class="math">\\lambda</span> . The previous state-of-the-art [BKS18a] said that when a 1-dimensional affine space U contains some element  <span class="math">u^<em></span>  that is  <span class="math">\\delta_{\\max} = \\Delta(u^</em>, V)</span>  far from V, then</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{E}_{u \\in U}[\\Delta(u, V)] \\ge \\min(\\delta_{\\max}, 1 - J^{(2)}(\\lambda)) - o(1).</span></div>

    <p class="text-gray-300">The following lemma improves the average-case distance to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{E}_{u \\in U}[\\Delta(u, V)] \\ge \\min(\\delta_{\\max}, 1 - J^{(1.5)}(\\lambda)) - o(1).</span></div>

    <p class="text-gray-300"><span id="page-7-0"></span>Later on, in Section 3.1, we will show that this result is tight (for a sub-family of RS codes).</p>

    <p class="text-gray-300"><strong>Lemma 3.1</strong> (One-and-half Johnson distance preservation). Let  <span class="math">V \\subseteq \\mathbb{F}_q^n</span>  be a linear code of distance  <span class="math">\\lambda = \\Delta(V)</span> . Let  <span class="math">\\epsilon, \\delta &gt; 0</span>  with  <span class="math">\\epsilon &lt; 1/3</span>  and  <span class="math">\\delta &lt; 1 - (1 - \\lambda + \\epsilon)^{1/3}</span> .</p>

    <p class="text-gray-300">Suppose  <span class="math">u^<em> \\in \\mathbb{F}_q^n</span>  is such that  <span class="math">\\Delta(u^</em>, V) &gt; \\delta + \\epsilon</span> . Then for all  <span class="math">u \\in \\mathbb{F}_q^n</span> , there are at most  <span class="math">2/\\epsilon^2</span>  values of  <span class="math">x \\in \\mathbb{F}_q</span>  such that  <span class="math">\\Delta(u^* + xu, V) &lt; \\delta</span> .</p>

    <p class="text-gray-300"><span id="page-7-2"></span>This result is the contra-positive statement of the following, more informative, version of it, that we prove below.</p>

    <p class="text-gray-300"><strong>Lemma 3.2</strong> (One-and-half Johnson distance preservation — positive form). Let  <span class="math">V \\subseteq \\mathbb{F}_q^D</span>  be a linear code of distance  <span class="math">\\lambda = \\Delta(V)</span> . Let  <span class="math">\\epsilon, \\delta &gt; 0</span>  with  <span class="math">\\epsilon &lt; 1/3</span>  and  <span class="math">\\delta &lt; 1 - (1 - \\lambda + \\epsilon)^{1/3}</span> . Let  <span class="math">u, u^* \\in \\mathbb{F}_q^D</span>  satisfy</p>

    <p class="text-gray-300"><span id="page-7-4"></span> <span class="math-block">\\Pr_{x \\in \\mathbb{F}_q} [\\Delta(u^* + xu, V) &lt; \\delta] \\ge \\frac{2}{\\epsilon^2 q}.</span>  (6)</p>

    <p class="text-gray-300">Then there exist  <span class="math">v, v^* \\in V</span>  and  <span class="math">C \\subseteq D</span>  such that the following three statements hold simultaneously:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge (1 \\delta \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">•</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$u^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C = v^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Observe that if  <span class="math">u, u^<em></span>  satisfy Equation (6) then the  <span class="math">v, v^</em>, C</span>  deduced by Lemma 3.2 have the property that for all  <span class="math">x \\in \\mathbb{F}_q</span> , we have  <span class="math">\\Delta(u^<em> + xu, V) \\leq \\delta + \\epsilon</span> . In other words, the existence of  <span class="math">v, v^</em></span>  and C almost completely explains Equation (6).</p>

    <p class="text-gray-300">Quantitatively weaker statements in this vein were proved by [PS94, BBHR18b] in the low-error case, and by [CMS17, BKS18a] in the high-error case. The proofs of the latter two results used combinatorial tools (the Kőváry-Sós-Turán bound and the Johnson bound respectively) that are closely related to one another. Our improved proof below is direct, and is based on the same convexity principle that underlies both the Kőváry-Sós-Turán and Johnson bounds.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">u_x = u^* + xu</span> . Let</p>

    <div class="my-4 text-center"><span class="math-block">A = \\{x \\mid \\Delta(u^* + xu, V) &lt; \\delta\\}.</span></div>

    <p class="text-gray-300">For each  <span class="math">x \\in A</span> , let  <span class="math">v_x \\in V</span>  be an element of V that is closest to  <span class="math">u_x</span> , and let  <span class="math">S_x \\subseteq D</span>  be the agreement set of  <span class="math">u_x</span>  and  <span class="math">v_x</span> , defined as  <span class="math">S_x = \\{y \\in D \\mid u_x(y) = v_x(y)\\}.</span></p>

    <p class="text-gray-300">For  <span class="math">x, \\beta, \\gamma</span>  picked uniformly from A and y picked uniformly from D, we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{aligned} \\mathbf{E}_{x,\\beta,\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n] &= \\mathbf{E}_{y,x,\\beta,\\gamma}[1_{y \\in S_x \\cap S_\\beta \\cap S_\\gamma}] \\\\ &= \\mathbf{E}_y[\\mathbf{E}_x[1_{y \\in S_x}]^3] \\\\ &\\geq \\mathbf{E}_{y,x}[1_{y \\in S_x}]^3 \\\\ &\\geq (1-\\delta)^3 \\\\ &> 1-\\lambda+\\epsilon. \\end{aligned}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The second equality above follows from the independence of the events  <span class="math">y \\in S_x, y \\in S_\\beta, y \\in S_\\gamma</span>  given  <span class="math">y \\in D</span> . The first inequality is Jensen's and the last inequality is by assumption on  <span class="math">\\delta, \\gamma, \\epsilon</span> .</p>

    <p class="text-gray-300">Thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{x,\\beta,\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge (1-\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] \\ge \\epsilon.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  <span class="math">\\Pr_{x,\\beta,\\gamma}[x,\\beta,\\gamma]</span>  are not all distinct  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Since  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2/\\epsilon^2 > \\frac{6}{\\epsilon}<span class="math"> , we have that  </span>3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon/2<span class="math">  and hence  </span>x,\\beta,\\gamma<span class="math">  are all distinct with probability at least  </span>1-\\epsilon/2<span class="math"> . Thus with probability at least  </span>\\epsilon/2<span class="math">  over the choice of  </span>x,\\beta,\\gamma<span class="math"> , we have that  </span>x,\\beta,\\gamma<span class="math">  are all distinct and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> (1-\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This means that there are distinct  <span class="math">x_0, \\beta_0</span>  such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{x_0} \\cap S_{\\beta_0} \\cap S_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> (1-\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">] \\ge \\epsilon/2.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fix a  <span class="math">\\gamma</span>  where this happens. Let  <span class="math">S = S_{x_0} \\cap S_{\\beta_0} \\cap S_{\\gamma}</span> . We have that</p>

    <div class="my-4 text-center"><span class="math-block">(x_0, u_{x_0}), (\\beta_0, u_{\\beta_0}), (\\gamma, u_{\\gamma})</span></div>

    <p class="text-gray-300">are collinear. Thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$(x_0, u_{x_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S), (\\beta_0, u_{\\beta_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S), (\\gamma, u_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">are all collinear. By definition of S, we get that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$(x_0, v_{x_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S), (\\beta_0, v_{\\beta_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S), (\\gamma, v_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_S)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">are all collinear. Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> (1 - \\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (and recalling that  </span>\\lambda<span class="math">  is the distance of V), we get that  </span>v_{\\gamma}<span class="math">  is determined by  </span>v_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S}$  via a linear map. This means that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(x_0, v_{x_0}), (\\beta_0, v_{\\beta_0}), (\\gamma, v_{\\gamma})</span></div>

    <p class="text-gray-300">are all collinear.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus  <span class="math">\\epsilon/2</span> -fraction of the  <span class="math">\\gamma \\in A</span>  have the "good" property that  <span class="math">(\\gamma, v_{\\gamma})</span>  is on the line passing through  <span class="math">(x_0, v_{x_0})</span>  and  <span class="math">(\\beta_0, v_{\\beta_0})</span> . Write this line as  <span class="math">v^<em> + xv</span>  and notice that for all "good"  <span class="math">\\gamma</span>  we have  <span class="math">v_{\\gamma} = v^</em> + \\gamma v</span> . Let  <span class="math">A&#x27; \\subseteq A</span>  denote the set of good elements for this line, recording that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\epsilon/2 \\geq 1/\\epsilon$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus for  <span class="math">x \\in A&#x27;</span> ,  <span class="math">\\Delta(u^<em> + xu, v^</em> + xv) &lt; \\delta</span> .</p>

    <p class="text-gray-300">Consider the set  <span class="math">C \\subset D</span>  defined by</p>

    <div class="my-4 text-center"><span class="math-block">C = \\{ y \\in D \\mid u^*(y) = v^*(y) \\text{ AND } u(y) = v(y) \\}.</span></div>

    <p class="text-gray-300">For each  <span class="math">y \\in D \\setminus C</span>  there exists at most a single value of  <span class="math">x \\in \\mathbb{F}_q</span>  satisfying  <span class="math">u^<em>(y) + x \\cdot u(y) = v^</em>(y) + x \\cdot v(y)</span>  because</p>

    <div class="my-4 text-center"><span class="math-block">(u^*(y) - v^*(y)) + x \\cdot (u(y) - v(y))</span></div>

    <p class="text-gray-300">has at most one value x on which it vanishes.</p>

    <p class="text-gray-300">This implies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta \\geq \\mathbf{E}_{x \\in A'}[\\Delta_D(u_x, v_x)] \\geq \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\setminus C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\left(1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\geq \\left(1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot (1 - \\epsilon) \\geq 1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\epsilon.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rearranging, we get  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\ge 1 - (\\delta + \\epsilon)$  and this completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-11" class="text-2xl font-bold">3.1 Tightness of the one-and-a-half Johnson bound</h2>

    <p class="text-gray-300">Lemma 3.1 says that when V is a linear code with minimum distance  <span class="math">\\lambda</span> , and  <span class="math">u^*</span>  is some element that is  <span class="math">\\delta</span> -far from V, then for any u we have with high probability</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta(u^* + xu, V) \\ge \\min(\\delta, J^{(1.5)}(\\lambda) = 1 - (1 - \\lambda)^{1/3}).</span></div>

    <p class="text-gray-300">The rightmost term seems quite strange, as the  <span class="math">J^{(1.5)}(\\cdot)</span>  function is unfamiliar in other settings of coding theory. However, as we show next, in certain settings this function gives the correct bound!</p>

    <p class="text-gray-300"><span id="page-9-0"></span><strong>Lemma 3.3</strong> (Tightness of one-and-a-half Johnson bound). For every member  <span class="math">V_n</span>  of following family of RS codes  <span class="math">\\{V_n = \\mathsf{RS}[\\mathbb{F}_{2^n}, \\mathbb{F}_{2^n}, \\rho = 2^{-3}] \\mid n \\in \\mathbb{N}\\}</span>  there exist  <span class="math">u_n^*, u_n \\in \\mathbb{F}_{2^n}^{\\mathbb{F}_{2^n}}</span>  satisfying the following:</p>

    <p class="text-gray-300">• <span class="math-block">\\delta_{\\text{max}} \\triangleq \\Delta(u_n^*, V_n) = \\Delta(u_n, V_n) = \\frac{3}{4} = 1 - \\rho^{2/3}</span></p>

    <p class="text-gray-300">• <span class="math-block">\\forall x \\neq 0, \\Delta(u_n^* + xu_n, V_n) \\leq \\frac{1}{2} = 1 - \\rho^{1/3} = J^{(1.5)}(\\Delta(V_n))</span></p>

    <p class="text-gray-300">Consequently, <span class="math-block">\\mathbf{E}[\\delta_x] \\le J^{(1.5)}(V_n) + o(1) \\le \\delta_{\\max} - \\frac{1}{4} + o(1)</span> .</p>

    <p class="text-gray-300"><span id="page-9-2"></span>We shall need to following claim in our proof of the lemma.</p>

    <p class="text-gray-300">Claim 3.4. For every  <span class="math">x \\in \\mathbb{F}_{2^n} \\setminus \\{0\\}</span>  there exists a polynomial  <span class="math">P_x(Y) \\in \\mathbb{F}_{2^n}[Y]</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">P_x(Y) = Y^{2^{n-1}} + xY^{2^{n-2}} + \\tilde{P}_x, \\quad \\deg(\\tilde{P}_x) &lt; 2^{n-3}.</span></div>

    <p class="text-gray-300">that has  <span class="math">2^{n-1}</span>  distinct roots in  <span class="math">\\mathbb{F}_{2^n}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For  <span class="math">x \\neq 0</span>  let  <span class="math">\\beta_x = 1/x^2</span> , noticing  <span class="math">\\beta_x</span>  is unique because the map  <span class="math">\\beta \\mapsto \\beta^2</span>  is bijective on  <span class="math">\\mathbb{F}_{2^n}</span> . Let  <span class="math">\\mathsf{Tr}(Z) \\triangleq \\sum_{i=0}^{n-1} Z^{2^i}</span>  be the trace function from  <span class="math">\\mathbb{F}_{2^n}</span>  to  <span class="math">\\mathbb{F}_2</span> . Define</p>

    <div class="my-4 text-center"><span class="math-block">S_x = \\{ y \\in \\mathbb{F}_{2^n} \\mid \\mathsf{Tr}(\\beta_x y) = 0 \\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is well known that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{n-1}<span class="math">  because the trace function has  </span>2^{n-1}<span class="math">  roots in  </span>\\mathbb{F}_{2^n}$ . So we define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">P_x(Y) = \\frac{1}{\\beta_x^{2^{n-1}}} \\cdot \\operatorname{Tr}(\\beta_x Y) = Y^{2^{n-1}} + \\frac{1}{\\beta_x^{2^{n-2}}} Y^{2^{n-2}} + \\tilde{P}_x = Y^{2^{n-1}} + xY^{2^{n-2}} + \\tilde{P}_x, \\quad \\deg(\\tilde{P}_x(Y)) &lt; 2^{n-3}.</span></div>

    <p class="text-gray-300">The last equality follows because  <span class="math">\\beta_x^{2^{n-2}} = x</span> .</p>

    <p class="text-gray-300">Proof of Lemma 3.3. Consider  <span class="math">V_n</span>  in this family and let  <span class="math">\\mathbb{F} = \\mathbb{F}_{2^n}</span> . Define  <span class="math">u^<em> : \\mathbb{F} \\to \\mathbb{F}</span>  to be the function  <span class="math">u^</em>(y) = y^{2^{n-1}}</span>  and let  <span class="math">u : \\mathbb{F} \\to \\mathbb{F}</span>  be the function  <span class="math">u(y) = y^{2^{n-2}}</span> .</p>

    <p class="text-gray-300">By Claim 3.4, for every  <span class="math">x \\in \\mathbb{F} \\setminus \\{0\\}</span>  there is some  <span class="math">v_x \\in V_n</span>  and  <span class="math">P_x</span>  with  <span class="math">2^{n-1}</span>  roots in  <span class="math">\\mathbb{F}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">P_x - (u^* + xu) + v_x = 0.</span></div>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta(u^* + xu, v_x) = \\Pr_{y \\in \\mathbb{F}}[u^*(y) + xu(y) \\neq v_x(y)] = \\Pr_y[P_x(y) \\neq 0] = 1/2.</span></div>

    <p class="text-gray-300">Thus we get that for all  <span class="math">x \\in \\mathbb{F} \\setminus \\{0\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Delta(u^* + xu, V) \\le 1/2.</span></div>

    <p class="text-gray-300">On the other hand,</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta(u,V) \\geq 3/4,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">because for all  <span class="math">v \\in V_n</span> , u - v is a polynomial of degree at most  $2^{n-2} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/4$ . This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 3.5.</strong> Since this example is based on Reed-Solomon codes, it also easily translates into a limitation on the soundness of FRI. In particular, it means that the improvement to the soundness of FRI given in Remark 5.2 is optimal.</p>

    <p class="text-gray-300"><span id="page-10-0"></span><strong>Discussion</strong> Lemma 3.3 raises the question of whether the one-and-a-half Johnson bound of Lemma 3.1 is tight for all RS codes, including non-binary fields and evaluation domains that are strict subsets of the ambient field. We point out that the technique used to prove Lemma 3.3 deteriorates rapidly even for binary fields, and even when the evaluation domain is an  <span class="math">\\mathbb{F}_2</span> -linear space which resembles the case above.</p>

    <p class="text-gray-300">Indeed, consider an evaluation domain  <span class="math">D \\subset \\mathbb{F}_{2^n}</span>  that is a d+1-dimensional linear space over  <span class="math">\\mathbb{F}_2</span> , where n > d+1. There are  <span class="math">2^{d+1}</span>  subspaces of dimension d in V. For such  <span class="math">U \\subset V</span> ,  <span class="math">\\dim(U) = d</span> , the polynomial  <span class="math">P_U(X) = \\prod_{\\alpha \\in U} (X - \\alpha)</span>  is of the form</p>

    <div class="my-4 text-center"><span class="math-block">P_U(Y) = Y^{2^d} + x_U Y^{2^d - 1} + \\hat{P}_U(Y)</span></div>

    <p class="text-gray-300">which resembles the structure of Claim 3.4. Moreover, as was the case there, for  <span class="math">U&#x27; \\neq U, U&#x27; \\subset V</span> ,  <span class="math">\\dim(U&#x27;) = d</span>  we have  <span class="math">x_U \\neq x_{U&#x27;}</span> . This is because  <span class="math">P_U - P_{U&#x27;}</span>  is a non-zero polynomial with  <span class="math">2^{d-1}</span>  roots, because  <span class="math">\\dim(U \\cap U&#x27;) = d - 1</span> . Thus, we cannot have  <span class="math">x_U = x_{U&#x27;}</span>  as this would imply  <span class="math">\\deg(P_U - P_{U&#x27;}) \\leq 2^{d-2} &lt; 2^{d-1}</span> , contradiction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in Lemma 3.3, taking  <span class="math">u^*</span>  to be the evaluation of  <span class="math">Y^{2^d}</span>  on D and u be the evaluation of  <span class="math">Y^{2^{d-1}}</span>  on the same space, we conclude there exists a set  $A \\subset \\mathbb{F},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^d<span class="math"> , such that for  </span>x \\in A<span class="math">  we have that  </span>u^* + xu<span class="math">  agrees with some RS codeword of rate  </span>2^{-3}$  on half of the evaluation domain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, notice that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^n = 2^{-(n-d)}<span class="math"> , meaning that the probability of sampling  </span>x \\in A$  deteriorates exponentially with the difference n-d. Thus the above counterexample fails to rule out an improvement to Lemma 3.1 when the length of the code n is much smaller than the size of the field q.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Conceivably, both Lemma 3.1 and the analysis of FRI can be improved significantly under the assumption  <span class="math">n \\ll q</span> . This is the case of most importance to practical implementations of STARKs.</p>

    <p class="text-gray-300">We now come to the statement of our improved-soundness distance preservation result. We describe it first for the special case of RS codes. A weighted variant of the theorem is shown in Section 4.2 because it is used later in the DEEP-FRI protocol (Section 5). We end with Section 4.3 in which we present a general version of the following result, that applies to all linear codes.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4.1 DEEP Theorem for RS codes</h2>

    <p class="text-gray-300">The vectors  <span class="math">u^<em>, u</span>  discussed in the previous section are now viewed as functions  <span class="math">u^</em>, u: D \\to \\mathbb{F}_q</span>  and we are interested in the distance of a random linear combination  <span class="math">u_x = u^<em> + x \\cdot u</span>  from the code  <span class="math">V = \\mathsf{RS}[\\mathbb{F}_q, D, \\rho]</span> , where  <span class="math">x \\in \\mathbb{F}_q</span>  is sampled uniformly. Lemma 3.1 established that if  <span class="math">\\max(\\Delta(u^</em>, V), \\Delta(u, V)) = \\delta_{\\max}</span> , then with high probability (over x), the function  <span class="math">u_x</span>  will have distance at least  <span class="math">\\approx \\min(\\delta_{\\max}, 1 - \\rho^{1/3})</span>  from V.</p>

    <p class="text-gray-300">Lemma 3.2 roughly gets used in the following way in the FRI protocol. There are two functions  <span class="math">u^<em>, u: D \\to \\mathbb{F}_q</span>  and there is a prover who claims that both are evaluations of low degree polynomials. In order to verify this, the verifier uniformly samples  <span class="math">x \\in \\mathbb{F}_q</span>  and considers the function  <span class="math">u_x = u^</em> + x \\cdot u</span> . Lemma 3.2 shows that if any of  <span class="math">u^<em>, u</span>  is far from being evaluations of a low degree polynomial, then so is  <span class="math">u^</em> + x \\cdot u</span> . This then gets exploited in the FRI protocol using FFT type ideas.</p>

    <p class="text-gray-300">We now precede the random process of sampling  <span class="math">x \\in \\mathbb{F}_q</span>  with a step of domain extension, explained next. Assume a prover claims that both u and  <span class="math">u^<em></span>  are evaluations of low degree polynomials (say P(Y) and  <span class="math">P^</em>(Y)</span> ). So these polynomials can be evaluated also outside of D. Based on this, a verifier first samples  <span class="math">z \\in \\mathbb{F}_q</span>  uniformly and asks the prover to reply with two field elements  <span class="math">a^<em>, a \\in \\mathbb{F}_q</span>  which are supposedly equal to  <span class="math">P^</em>(z), P(z)</span> , respectively. After receiving these answers, the verifier proceeds as before, sampling uniformly  <span class="math">x \\in \\mathbb{F}_q</span> . Then, setting  <span class="math">b = a^* + x \\cdot a</span> , we examine the distance of  <span class="math">u_x</span>  from the sub-code  <span class="math">V_{z,b} \\subset V</span>  comprised of all members of V whose interpolating polynomial evaluates to  <span class="math">v_x</span> 0 on input  <span class="math">v_x</span> 2. The code  <span class="math">v_x</span> 3 is the additive coset (shifted by  <span class="math">v_x</span> 4) of a low-degree ideal, the ideal generated by  <span class="math">v_x</span> 5 (cf. Lemma 5.3).</p>

    <p class="text-gray-300">Using the Johnson Bound (Theorem 2.2) we prove that with high probability  <span class="math">u_x</span>  is at least  <span class="math">\\approx \\min(\\delta_{\\max}, 1 - \\rho^{1/2})</span>  far from  <span class="math">V_{z,b}</span> . Assuming RS codes have a larger list-decoding radius (Conjection)</p>

    <p class="text-gray-300">ture 2.3), we show that with high probability  <span class="math">u_x</span>  is  <span class="math">\\approx \\delta_{\\max}</span> -far from  <span class="math">V_{z,b}</span>  for nearly all values of  <span class="math">\\delta_{\\max}</span> . Later, in Section 5, we shall use the improved distance preservation to construct the DEEP-FRI protocol for testing proximity to the RS code with improved soundness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The statement we give below is given more generally in terms of the list size bound  $\\mathcal{L}(\\mathbb{F}_q, D, d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\delta)$ ; we instantiate it later with the Johnson bound and with Conjecture 2.3. It is useful to keep in mind that this will be used in a setting where q is much larger than</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(and hence d), and where  <span class="math">L_{\\delta}^*</span>  is small.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-12-0"></span><strong>Theorem 4.1</strong> (DEEP method for RS codes). Let  <span class="math">\\rho &gt; 0</span>  and let  <span class="math">V = \\mathsf{RS}[\\mathbb{F}_q, D, \\rho]</span> . For  <span class="math">z, b \\in \\mathbb{F}_q</span> , we let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$V_{z,b} = \\{Q(Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D \\in V \\mid Q(z) = b\\}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">\\delta &gt; 0</span>  let  $L_{\\delta}^* = \\mathcal{L}(\\mathbb{F}_q, D, d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\delta)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">u, u^* \\in \\mathbb{F}_q^D</span> . For each  <span class="math">z \\in \\mathbb{F}_q</span> , let  <span class="math">B_z(X) \\in \\mathbb{F}_q[X]</span>  be an arbitrary linear function. Suppose that for some  <span class="math">1/3 &gt; \\epsilon &gt; 0</span>  the following holds,</p>

    <p class="text-gray-300"><span id="page-12-1"></span> <span class="math-block">\\Pr_{x,z\\in\\mathbb{F}_q}\\left[\\Delta(u^<em>+xu,V_{z,B_z(x)})&lt;\\delta\\right] \\ge \\max\\left(2L_\\delta^</em>\\left(\\frac{d}{q}+\\epsilon\\right)^{1/3},\\frac{4}{\\epsilon^2q}\\right),\\tag{7}</span></p>

    <p class="text-gray-300">Then there exist  <span class="math">v, v^* \\in V</span>  and  <span class="math">C \\subset D</span>  such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge (1 \\delta \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ,</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $u^*</td>

            <td class="px-3 py-2 border-b border-gray-700">_C = v^*</td>

            <td class="px-3 py-2 border-b border-gray-700">_C$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, we have  <span class="math">\\Delta(u, V), \\Delta(u^*, V) \\leq \\delta + \\epsilon</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> To simplify notation set  <span class="math">\\eta = \\max\\left(2L_{\\delta}^<em>\\left(\\frac{d}{q} + \\epsilon\\right)^{1/3}, \\frac{4}{\\epsilon^2 q}\\right)</span> , and let  <span class="math">u_x = u^</em> + xu</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{E}[x,z]</span>  denote the event " <span class="math">\\exists P(Y) \\in \\mathsf{List}(u_x,V,\\delta), P(z) = B_z(x)</span> ".</p>

    <p class="text-gray-300">The assumption of Equation (7) now reads as</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{x,z\\in\\mathbb{F}_q}[\\mathcal{E}[x,z]] \\ge \\eta.</span></div>

    <p class="text-gray-300">Thus we get,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{x}[\\Pr_{z}[\\mathcal{E}[x,z]] \\ge \\eta/2] \\ge \\eta/2 \\tag{8}</span></div>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">A = \\left\\{ x \\in \\mathbb{F}_q \\mid \\Pr_z[\\mathcal{E}[x,z]] \\geq \\eta/2] \\right\\}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and notice  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge \\eta q/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">x \\in \\mathbb{F}_q</span> , pick  <span class="math">P_x \\in V</span>  to be a member  <span class="math">P \\in \\mathsf{List}(u_x, V, \\delta)</span>  that maximizes  <span class="math">\\Pr_{z \\in \\mathbb{F}_q}[P(z) = B_z(x)]</span> . Let  <span class="math">S_x = \\{z \\in \\mathbb{F}_q \\mid P_x(z) = B_z(x)\\}</span>  and set  $\\mu_x =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/q<span class="math"> . By definition,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{List}(u_x, V, \\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L_\\delta^<em><span class="math"> , and so by the pigeonhole principle, for each  </span>x \\in A<span class="math">  we have  </span>\\mu_x \\geq \\frac{\\eta}{2L_s^</em>}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For  <span class="math">x, \\beta, \\gamma</span>  picked uniformly from A, and z picked uniformly from  <span class="math">\\mathbb{F}_q</span> , we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{E}_{x,\\beta,\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x\\cap S_\\beta\\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/q] = \\mathbf{E}_{z,x,\\beta,\\gamma}[1_{z\\in S_x\\cap S_\\beta\\cap S_\\gamma}]$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">= \\mathbf{E}_{z} [\\mathbf{E}_{x} [1_{z \\in S_{x}}]^{3}]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\mathbf{E}_{z,x} [1_{z \\in S_{x}}]^{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\left(\\frac{\\eta}{2L_{\\delta}^{*}}\\right)^{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\frac{d}{q} + \\epsilon.</span></div>

    <p class="text-gray-300">The second equality above follows from the independence of  <span class="math">x, \\beta, \\gamma</span> . The first inequality is an application of Jensen's inequality and the last inequality is by assumption on  <span class="math">\\eta</span> .</p>

    <p class="text-gray-300">Thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{x,\\beta,\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> d] \\ge \\epsilon.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  <span class="math">\\Pr_{x,\\beta,\\gamma}[x,\\beta,\\gamma]</span>  are not all distinct  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\le 3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Since  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge \\eta q/2 \\ge 2/\\epsilon^2 \\ge 6/\\epsilon<span class="math">  we have  </span>3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\le \\epsilon/2<span class="math"> . Thus  </span>\\Pr_{x,\\beta,\\gamma}[x,\\beta,\\gamma]<span class="math">  are all distinct and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> d \\ge \\epsilon/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This means that there are distinct  <span class="math">x_0, \\beta_0</span>  such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{x_0} \\cap S_{\\beta_0} \\cap S_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> d] \\ge \\epsilon/2.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider some  <span class="math">\\gamma</span>  where this happens. Let  <span class="math">S = S_{x_0} \\cap S_{\\beta_0} \\cap S_{\\gamma}</span> . By construction we know that for all  <span class="math">z \\in \\mathbb{F}_q</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">(x_0, B_z(x_0)), (\\beta_0, B_z(\\beta_0)), (\\gamma, B_z(\\gamma))</span></div>

    <p class="text-gray-300">are collinear. So, in particular, for  <span class="math">z \\in S</span>  this holds.</p>

    <p class="text-gray-300">By definition of S, we get that for each  <span class="math">z \\in S</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">(x_0, P_{x_0}(z)), (\\beta_0, P_{\\beta_0}(z)), (\\gamma, P_{\\gamma}(z)) \\in \\mathbb{F}_q \\times \\mathbb{F}_q</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">are collinear. Since</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> d, we have that  <span class="math">P_{\\gamma}</span>  is uniquely determined by  $P_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S}$  by a linear map. This allows us to conclude that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(x_0, P_{x_0}), (\\beta_0, P_{\\beta_0}), (\\gamma, P_{\\gamma}) \\in \\mathbb{F}_q \\times \\mathbb{F}_q[Y]</span></div>

    <p class="text-gray-300">are collinear in the  <span class="math">\\mathbb{F}_q</span> -vector space  <span class="math">\\mathbb{F}_q \\times \\mathbb{F}_q[Y]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, an  <span class="math">\\epsilon/2</span> -fraction of the  <span class="math">\\gamma \\in A</span>  have the "good" property that  <span class="math">(\\gamma, P_{\\gamma})</span>  is on the line passing through  <span class="math">(x_0, P_{x_0})</span>  and  <span class="math">(\\beta_0, P_{\\beta_0})</span> . Write this line as  <span class="math">P^<em> + xP</span>  and notice that for all "good"  <span class="math">\\gamma</span>  we have  <span class="math">P_{\\gamma} = P^</em> + \\gamma P</span> . Let  <span class="math">A&#x27; \\subseteq A</span>  denote the set of good elements for this line, recording that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\epsilon/2 \\ge 1/\\epsilon<span class="math"> . By definition of  </span>\\mathsf{List}(u_x, V, \\delta)<span class="math">  and the assumption  </span>P_x \\in \\mathsf{List}(u_x, V, \\delta)<span class="math"> , we have that  </span>\\Delta(u_x, P_x) < \\delta<span class="math">  for  </span>x \\in A'$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider the set  <span class="math">C \\subset D</span>  defined by</p>

    <div class="my-4 text-center"><span class="math-block">C = \\{ y \\in D \\mid u^*(y) = P^*(y) \\text{ AND } u(y) = P(y) \\}.</span></div>

    <p class="text-gray-300">For each  <span class="math">y \\in D \\setminus C</span>  there exists at most a single value of  <span class="math">x \\in \\mathbb{F}_q</span>  satisfying  <span class="math">u_x(y) = P_x(y)</span>  because</p>

    <div class="my-4 text-center"><span class="math-block">u_x(y) - P_x(y) = (u^*(y) - P^*(y)) + x \\cdot (u(y) - P(y))</span></div>

    <p class="text-gray-300">has at most one value x on which it vanishes. This implies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta \\geq \\mathbf{E}_{x \\in A'}[\\Delta_D(u_x, v_x)] \\geq \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D \\setminus C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\left(1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\geq \\left(1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot (1 - \\epsilon) \\geq 1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\epsilon.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rearranging, we get  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\ge 1 - (\\delta + \\epsilon)<span class="math"> . Taking v = P and  </span>v^<em> = P^</em>$  completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 4.2.</strong> One could extend the domain even further, and sample z from an extension field  <span class="math">\\mathbb{F}_{q^a}</span> . This gives even better soundness; the expression  <span class="math">2L_{\\delta}^<em> \\cdot \\left(\\frac{d}{q} + \\epsilon\\right)^{1/3}</span>  by  <span class="math">2L_{\\delta}^</em> \\cdot \\left(\\frac{d}{q^a} + \\epsilon\\right)^{1/3}</span> . This can give interesting results even if  <span class="math">L_{\\delta}^* = q^{O(1)}</span>  by taking a = O(1).</p>

    <h2 id="sec-14" class="text-2xl font-bold">4.2 Weighted version</h2>

    <p class="text-gray-300">For application to Reed-Solomon Proximity Testing, it is more convenient to have a weighted version of the previous result. We briefly introduce some notation for dealing with weights, and then state the new version.</p>

    <p class="text-gray-300">Let  <span class="math">u, v \\in \\mathbb{F}_q^D</span> . Let  <span class="math">\\eta \\in [0, 1]^D</span>  be a vector of weights. We define the  <span class="math">\\eta</span> -agreement between u and v by:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{agree}_{\\eta}(u,v) = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{i \\in D \\mid u_i = v_i} \\eta(i).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For a subspace  <span class="math">V \\subseteq \\mathbb{F}_q^n</span> , we define</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{agree}_{\\eta}(u,V) = \\max_{v \\in V} \\mathsf{agree}_{\\eta}(u,v).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-14-1"></span><strong>Theorem 4.3.</strong> Let  <span class="math">\\rho &gt; 0</span>  and let  $V = \\mathsf{RS}[\\mathbb{F}_q, D, d = \\rho \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> . For  </span>z, b \\in \\mathbb{F}_q$ , we let</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">V_{z,b} = \\{Q(Y) \\in V \\mid Q(z) = b\\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">\\alpha &lt; 1</span> , let  $L^* = \\mathcal{L}(\\mathbb{F}_q, D, d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 1-\\alpha)<span class="math">  be the list-size for list-decoding V from  </span>(1-\\alpha)$ -fraction errors (without weights).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">u, u^* \\in \\mathbb{F}_q^D</span> . For each  <span class="math">z \\in \\mathbb{F}_q</span> , let  <span class="math">B_z(X) \\in \\mathbb{F}_q[X]</span>  be an arbitrary linear function. Suppose that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{x,z\\in\\mathbb{F}_q}[\\mathsf{agree}_{\\eta}(u^* + xu, V_{z,B_z(x)}) &gt; \\alpha] \\ge \\max\\left(2L^*\\left(\\frac{d}{q} + \\epsilon\\right)^{1/3}, \\frac{4}{\\epsilon^2 q}\\right),\\tag{9}</span></div>

    <p class="text-gray-300">Then there exist  <span class="math">v, v^* \\in V</span>  and  <span class="math">C \\subset D</span>  such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\sum_{y \\in C} \\eta(y) > (\\alpha \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ,</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $\\bullet \\ u^*</td>

            <td class="px-3 py-2 border-b border-gray-700">_C = v^*</td>

            <td class="px-3 py-2 border-b border-gray-700">_C.$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> <span class="math">Consequently, \\ we \\ have \\ \\mathrm{agree}_{\\eta}(u,V), \\mathrm{agree}_{\\eta}(u^*,V) \\geq \\alpha - \\epsilon.</span></p>

    <p class="text-gray-300">The proof is nearly identical to the proof of Theorem 4.1 so we only highlight the changes. First, we observe that if  <span class="math">\\eta_1:D\\to[0,1]</span>  is the the constant function with value 1, then  <span class="math">\\mathsf{agree}_\\eta(u,v)\\leq \\mathsf{agree}_{\\eta_1}(u,v)=1-\\Delta(u,v)</span> . Thus the set</p>

    <div class="my-4 text-center"><span class="math-block">\\{Q(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(Q) \\leq d, \\mathsf{agree}_{\\eta}(u^* + xu, Q) &gt; \\alpha\\}</span></div>

    <p class="text-gray-300">is contained in</p>

    <div class="my-4 text-center"><span class="math-block">\\{Q(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(Q) \\le d, \\Delta(u^* + xu, Q) &lt; 1 - \\alpha\\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The size of this latter set is bounded by  <span class="math">L^*</span> , and thus the size of the former set is too. The proof then proceeds as before, until the very end, where we have a set  <span class="math">A&#x27; \\subseteq \\mathbb{F}_q</span> , with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\frac{2}{\\epsilon}$ , and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomials  <span class="math">P, P^<em> \\in V</span>  such that for each  <span class="math">x \\in A&#x27;</span> ,  <span class="math">\\operatorname{agree}_{\\eta}(u^</em> + xu, P^<em> + xP) &gt; \\alpha</span> . Then we take  <span class="math">C = \\{y \\in C \\mid u^</em>(y) = P^*(y), u(y) = P(y)\\}</span> , and our goal is to show that  $\\sum_{y \\in C} \\eta(y) > (\\alpha - \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . To this end, consider:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} &\\alpha < \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{x \\in A'} \\mathsf{agree}_{\\eta} \\big( u^<em> + xu, P^</em> + xP \\big) \\\\ &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{x \\in A'} \\sum_{y \\in D} \\big( \\eta(y) \\cdot 1_{u^<em>(y) + xu(y) = P^</em>(y) + xP(y)} \\big) \\\\ &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{y \\in D} \\eta(y) \\left( \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{x \\in A'} 1_{u^<em>(y) + xu(y) = P^</em>(y) + xP(y)} \\right) \\\\ &\\leq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{y \\in C} \\eta(y) + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{y \\in D \\backslash C} \\eta(y) \\cdot \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\ &\\leq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{y \\in C} \\eta(y) + \\epsilon/2. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This implies that  $\\sum_{y \\in C} \\eta(y) > (\\alpha - \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , and the rest of the proof is the same as before.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-15" class="text-2xl font-bold">4.3 DEEP Lemma for general linear codes</h2>

    <p class="text-gray-300">Theorem 4.1 can be generalized to apply to arbitrary linear codes, and this is the focus of this section. We explain the basic principles for an  <span class="math">[n, k, d]_q</span> -linear code V with generating matrix  <span class="math">G \\in \\mathbb{F}_q^{k \\times n}</span> , viewing codewords as evaluations of linear forms on the columns of G.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">D \\subset \\mathbb{F}_q^k</span>  be the set of columns of G. A linear form  <span class="math">\\ell \\in F_q^k</span>  can be "evaluated" at any any element x of D. Similarly, if we fix a set of points  <span class="math">S \\subseteq \\mathbb{F}_q^k</span>  (thinking  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ), we may evaluate the linear form  </span>\\ell$  at any point of S – this corresponds to evaluation outside the original domain D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we are given a function  <span class="math">u: D \\to \\mathbb{F}_q</span>  which is supposed to be the evaluations of a linear form  <span class="math">\\ell</span>  on D, we can ask about what the evaluation of this linear form at a point  <span class="math">z \\in S</span>  is. This is the viewpoint from which the DEEP lemma generalizes to general codes.</p>

    <p class="text-gray-300">We start with two functions  <span class="math">u, u^<em> : D \\to \\mathbb{F}_q</span>  (which are supposed to correspond to linear forms, say  <span class="math">\\ell \\in \\mathbb{F}_q^k</span>  and  <span class="math">\\ell^</em> \\in \\mathbb{F}_q^k</span> . We have a verifier who samples  <span class="math">z \\in S</span>  and asking for  <span class="math">a = \\ell(z)</span>  and  <span class="math">a^<em> = \\ell^</em>(z)</span> . Given these answers, the verifier now samples  <span class="math">x \\in \\mathbb{F}_q</span>  and computes  <span class="math">b = a^<em> + xa</span>  which is supposedly equal to  <span class="math">\\ell^</em>(z) + \\ell(z)</span>  (if  <span class="math">u^<em></span>  and u are indeed codewords of V). The result below says that if S is the set of columns of an error correcting code with good distance, and V has small list size for list-decoding up to radius  <span class="math">\\delta</span> , then with high probability, the function  <span class="math">u_x = u^</em> + xu</span>  has distance at least  <span class="math">\\approx \\min\\{\\Delta(u^*, V), \\delta\\}</span>  from the sub-code of V corresponding to the linear forms that evaluate to b on z.</p>

    <p class="text-gray-300"><strong>Definition 4.4</strong> (Robust). A set  <span class="math">S \\subseteq \\mathbb{F}^k</span>  is called  <span class="math">\\sigma</span> -robust if every subset of S of size  <span class="math">\\sigma</span>  contains a basis for  <span class="math">\\mathbb{F}^k</span> .</p>

    <p class="text-gray-300">The following claim is well-known in coding theory (cf. [Rot06, Problem 2.8]).</p>

    <p class="text-gray-300"><span id="page-15-0"></span>Claim 4.5. Fix a full-rank matrix  <span class="math">G \\in \\mathbb{F}_q^{k \\times N}</span> ,  <span class="math">N \\geq k</span> , and let  <span class="math">C = \\{x \\cdot M \\mid x \\in \\mathbb{F}_q^k\\}</span>  be the linear code generated by it. Then the set of columnss of G is  <span class="math">\\sigma</span> -robust if and only if the minimum distance of C is at least  <span class="math">N - \\sigma + 1</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4.6</strong> (DEEP method for general linear codes). Let V be an  <span class="math">[n, k, d]_q</span> -code that is  <span class="math">(\\delta, L_{\\delta}^*)</span> -list decodable for some  <span class="math">\\delta &gt; 0</span> , and fix  <span class="math">G \\in \\mathbb{F}_q^{k \\times n}</span>  to be its generating matrix. Let  <span class="math">S \\subset \\mathbb{F}_q^k</span>  be a  <span class="math">\\sigma</span> -robust set of size N. For  <span class="math">z \\in S</span> ,  <span class="math">b \\in \\mathbb{F}_q</span> , let</p>

    <div class="my-4 text-center"><span class="math-block">V_{z,b} = \\{ v \\in V \\mid v = G \\cdot \\ell_v \\ AND \\ \\langle \\ell_v, z \\rangle = b \\}</span></div>

    <p class="text-gray-300">where  <span class="math">\\langle v, z \\rangle = \\sum_{i=1}^{k} v_i, z_i</span> .</p>

    <p class="text-gray-300">Let  <span class="math">u, u^* \\in \\overline{\\mathbb{F}_q}^n</span> . For each  <span class="math">z \\in S</span> , let  <span class="math">B_z(X) \\in \\mathbb{F}_q[X]</span>  be an arbitrary linear function. Suppose that for some  <span class="math">\\epsilon &gt; 0</span>  the following holds,</p>

    <p class="text-gray-300"><span id="page-16-1"></span> <span class="math-block">\\Pr_{x \\in \\mathbb{F}_q, z \\in S} [\\Delta(u^<em> + xu, V_{z, B_z(x)}) &lt; \\delta] \\ge \\max\\left(2L_\\delta^</em> \\left(\\frac{\\sigma}{N} + \\epsilon\\right)^{1/3}, \\frac{4}{\\epsilon^2 q}\\right),\\tag{10}</span></p>

    <p class="text-gray-300">Then there exist  <span class="math">v, v^* \\in V</span>  and  <span class="math">C \\subset [n]</span>  such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge (1 \\delta \\epsilon)n$ ,</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $u^*</td>

            <td class="px-3 py-2 border-b border-gray-700">_C = v^*</td>

            <td class="px-3 py-2 border-b border-gray-700">_C$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, we have  <span class="math">\\Delta(u, V), \\Delta(u^*, V) \\leq \\delta + \\epsilon</span> .</p>

    <p class="text-gray-300">The proof is analogous to the proof in the Reed-Solomon case, and appears in Appendix A.</p>

    <p class="text-gray-300"><strong>Discussion</strong> For the special case of RS codes, the DEEP method can be used to locally modify the problem and reduce degree. Indeed, the subcode  <span class="math">V_{z,b}</span>  in the case of RS codes corresponds is comprised of functions  <span class="math">f:D\\to\\mathbb{F}</span>  that are evaluations of polynomials of degree d whose interpolating polynomial  <span class="math">P_f</span>  satisfies  <span class="math">P_f(z)=b</span> . From such a codeword, one can construct a new codeword  <span class="math">f_{z,b}:D\\to\\mathbb{F}</span>  defined by  <span class="math">f_{z,b}(x)=\\frac{f(x)-b}{z}</span> , which is well-defined for all  <span class="math">z\\not\\in D</span> . Notice that the transformation from f to  <span class="math">f_{z,b}</span>  is 1-local, meaning that each entry of  <span class="math">f_{z,b}</span>  is constructed by making a single query to f. Furthermore, this transformation maps a subset of the code  <span class="math">RS[\\mathbb{F},D,d]</span>  to the code  <span class="math">RS[\\mathbb{F},D,d-1]</span> , so we may use this transformation in RS IOPPs (as will done in the following section).</p>

    <p class="text-gray-300">In contrast, for a general k-dimensional linear code V, the subcode  <span class="math">V_{z,b}</span> , while being an affine subspace of V, has less structure. In particular, it is not clear how to locally convert this subcode to a "nice" code of dimension k-1. An interesting middle ground, left to future work, is the case of algebraic codes like Reed Muller codes and Algebraic Geometry codes which resemble RS codes.</p>

    <h2 id="sec-16" class="text-2xl font-bold">5 DEEP-FRI</h2>

    <p class="text-gray-300">In this section we describe the new fast RS IOPP, called DEEP-FRI. We start by recalling the FRI protocol from [BBHR18b], describing it nearly verbatim as in [BKS18b, Section 7].</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6"><strong>5.1</strong> FRI</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our starting point is a function  <span class="math">f^{(0)}:L^{(0)}\\to\\mathbb{F}</span>  where  <span class="math">\\mathbb{F}</span>  is a finite field, the evaluation domain  <span class="math">L^{(0)}\\subset\\mathbb{F}</span>  is a coset of a group<sup>2</sup> contained in  <span class="math">\\mathbb{F}</span> , and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{k^{(0)}}<span class="math"> . We assume the target rate is  </span>\\rho=2^{-\\mathcal{R}}<span class="math">  for some positive integer  </span>\\mathcal{R}<span class="math"> . The FRI protocol is a two-phase protocol (the two phases are called COMMIT and QUERY) that convinces a verifier that  </span>f^{(0)}<span class="math">  is close to the Reed-Solomon code  </span>\\mathsf{RS}[\\mathbb{F},L^{(0)},\\rho]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The COMMIT phase of the FRI protocol involves  <span class="math">\\mathbf{r} = k^{(0)} - \\mathcal{R}</span>  rounds. Before any communication, the prover and verifier agree on a sequence of (cosets of) sub-groups  <span class="math">L^{(i)}</span> , where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{k^{(0)} - i}<span class="math"> . Let  </span>\\mathsf{RS}^{(i)}<span class="math">  denote the Reed-Solomon code  </span>\\mathsf{RS}[\\mathbb{F}, L^{(i)}, \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main ingredient of the FRI protocol is a special algebraic hash function  <span class="math">H_x</span> , which takes a seed  <span class="math">x \\in \\mathbb{F}</span> , and given as input a function  <span class="math">f: L^{(i)} \\to \\mathbb{F}</span> , it produces as output a hash whose length is 1/2 as long as f. More concretely,  <span class="math">H_x[f]</span>  is a function</p>

    <div class="my-4 text-center"><span class="math-block">H_x[f]:L^{(i+1)}\\to\\mathbb{F}</span></div>

    <p class="text-gray-300">with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. <strong>locality:</strong> For any  <span class="math">s \\in L^{(i+1)}</span> ,  <span class="math">H_x<a href="s">f</a></span>  can be computed by querying f at just two points in its domain (these two points are  <span class="math">(q^{(i)})^{-1}(s)</span> ).</li>

      <li>2. <strong>completeness:</strong> If  <span class="math">f \\in \\mathsf{RS}^{(i)}</span> , then for all  <span class="math">x \\in \\mathbb{F}</span> , we have that  <span class="math">H_x[f] \\in \\mathsf{RS}^{(i+1)}</span> .</li>

      <li>3. <strong>soundness:</strong> If f is far from  <span class="math">RS^{(i)}</span> , then with high probability over the choice of seed x,  <span class="math">H_x[f]</span>  is quite far from  <span class="math">RS^{(i+1)}</span> .</li>

    </ul>

    <p class="text-gray-300">These last two properties roughly show that for random x,  <span class="math">H_x</span>  preserves distance to Reed-Solomon codes. For the precise description of  <span class="math">H_x</span>  see Appendix B and [BKS18a].</p>

    <p class="text-gray-300">The high-level idea of the FRI protocol can then be described as follows. First we are in the COMMIT phase of the protocol. The verifier picks a random  <span class="math">x^{(0)} \\in \\mathbb{F}</span>  and asks the prover to write down the hash  <span class="math">H_{x^{(0)}}[f^{(0)}]:L^{(1)} \\to \\mathbb{F}</span> . By Properties 2 and 3 above, our original problem of estimating the distance of  <span class="math">f^{(0)}</span>  to  <span class="math">\\mathrm{RS}^{(0)}</span>  reduces to estimating the distance of  <span class="math">H_{x^{(0)}}[f^{(0)}]</span>  to  <span class="math">\\mathrm{RS}^{(1)}</span>  (which is a problem of 1/2 the size). This process is then repeated: the verifier picks a random  <span class="math">x^{(1)} \\in \\mathbb{F}</span>  and asks the prover to write down  <span class="math">H_{x^{(1)}}[H_{x^{(0)}}[f^{(0)}]]</span> , and so on. After r rounds of this, we are reduced to a constant sized problem which can be solved in a trivial manner. However, the verifier cannot blindly trust that the functions  <span class="math">f^{(1)},\\ldots</span>  that were written down by the prover truly are obtained by repeatedly hashing  <span class="math">f^{(0)}</span> . This has to be checked, and the verifier does this in the QUERY phase of the protocol, using Property 1 above.</p>

    <p class="text-gray-300">We describe the phases of the protocol below.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6"><strong>COMMIT Phase:</strong></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. For i = 0 to r 1:</li>

      <li>(a) The verifier picks uniformly random  <span class="math">x^{(i)} \\in \\mathbb{F}</span>  and sends it to the prover.</li>

      <li>(b) The prover writes down a function  <span class="math">f^{(i+1)}:L^{(i+1)}\\to\\mathbb{F}</span> . (In the case of an honest prover,  <span class="math">f^{(i+1)}=H_{x^{(i)}}[f^{(i)}]</span> .)</li>

    </ul>

    <p class="text-gray-300"><span id="page-17-0"></span><sup>&</sup>lt;sup>2</sup>The group can be additive, in which case 𝔻 is a binary field, or multiplicative, in which case it is not.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover writes down a value <sup>C</sup> <sup>∈</sup> <sup>F</sup>q. (In the case of an honest prover, <sup>f</sup> (r) is the constant function with value = C).</li>

    </ol>

    <h2 id="sec-19" class="text-2xl font-bold">QUERY Phase: (executed by the Verifier)</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Repeat ℓ times:</li>

      <li>(a) Pick s (0) <sup>∈</sup> <sup>L</sup> (0) uniformly at random.</li>

      <li>(b) For i = 0 to r − 1:</li>

      <li>i. Define s (i+1) <sup>∈</sup> <sup>L</sup> (i+1) by s (i+1) = q (i) (s (i) ).</li>

      <li>ii. Compute Hx(i) <a href="s (i+1">f (i) </a>) by making 2 queries to f (i) .</li>

      <li>iii. If f (i+1)(s (i+1)) <sup>6</sup><sup>=</sup> <sup>H</sup>x(i) <a href="s (i+1"><sup>f</sup> (i) </a>), then REJECT.</li>

      <li>(c) If f (r) (s (r) ) 6= C, then REJECT.</li>

    </ul>

    <h2 id="sec-20" class="text-2xl font-bold">2. ACCEPT</h2>

    <p class="text-gray-300">The previous state of the art regarding the soundness of FRI is given by the following statement from [\\[BKS18a\\]](#page-29-8). In what follows let Jǫ(x) = 1 − p 1 − x(1 − ǫ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 5.1 (FRI soundness (informal)). <em>Suppose</em> δ (0) , ∆(f (0) , RS(0)) <sup>&</sup>gt; <sup>0</sup><em>. Let</em> <sup>n</sup> <sup>=</sup> <sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></sup><sup>L</sup> (0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>. Then for any</em> ǫ > 0 <em>there exists</em> ǫ ′ > 0 <em>so that with probability at least</em></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$1 - \\frac{2\\log n}{\\epsilon^3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\tag{11}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>over the randomness of the verifier during the</em> COMMIT <em>phase, and for any (adaptively chosen) prover oracles</em> f (1), . . . , f(r) <em>, the</em> QUERY <em>protocol with repetition parameter</em> ℓ <em>outputs</em> accept <em>with probability at most</em></p>

    <p class="text-gray-300"><span class="math-block">\\left(1 - \\min\\left\\{\\delta^{(0)}, 1 - (\\rho^{1/4} + \\epsilon&#x27;)\\right\\} + \\epsilon \\log n\\right)^{\\ell}.</span> (12)</p>

    <p class="text-gray-300"><span id="page-18-0"></span>Remark 5.2. <em>Using the improved distance preservation of Lemma <a href="#page-7-2">3.2</a> in the analysis of</em> FRI <em>from [\\[BKS18a\\]](#page-29-8), one immediately improves the factor</em> 1/4 <em>in the exponent in Equation</em> <a href="#page-21-0">\\(14\\)</a> <em>to an exponent of</em> 1/3 <em>(details omitted).</em></p>

    <h2 id="sec-21" class="text-2xl font-bold">5.2 DEEP-FRI</h2>

    <p class="text-gray-300">We now describe our variation of FRI, that we call DEEP-FRI, for which we can give improved soundness guarantees, at the cost of a small increase in the query complexity (but no increase in the proof length or the number of queries to committed proofs – which is important in applications).</p>

    <p class="text-gray-300">Before we can describe our protocol we introduce the operation of "quotienting", which allows us to focus our attention on polynomials taking certain values at certain points.</p>

    <h2 id="sec-22" class="text-2xl font-bold">5.2.1 Quotienting</h2>

    <p class="text-gray-300">Suppose we a set  <span class="math">L \\subseteq \\mathbb{F}_q</span>  and a function  <span class="math">f: L \\to \\mathbb{F}_q</span> . Suppose further that we are given a point  <span class="math">z \\in \\mathbb{F}_q</span>  and a value  <span class="math">b \\in \\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">We define the function  <span class="math">\\mathsf{QUOTIENT}(f,z,b):L\\to\\mathbb{F}_q</span>  as follows. Let  <span class="math">Z(Y)\\in\\mathbb{F}_q[Y]</span>  be the polynomial Z(Y)=Y-z. Then we define  <span class="math">\\mathsf{QUOTIENT}(f,z,b)</span>  to be the function  <span class="math">g:L\\to\\mathbb{F}_q</span>  given by:</p>

    <div class="my-4 text-center"><span class="math-block">g(y) = \\frac{f(y) - b}{Z(y)}</span></div>

    <p class="text-gray-300"><span id="page-19-0"></span>(or more succinctly,  <span class="math">g = \\frac{f-b}{Z}</span> ).</p>

    <p class="text-gray-300"><strong>Lemma 5.3.</strong> Let  <span class="math">L \\subseteq \\mathbb{F}_q</span> . Let  <span class="math">z \\in \\mathbb{F}_q</span>  with  <span class="math">z \\notin L</span> . Let  <span class="math">d \\ge 1</span>  be an integer. Let  <span class="math">f: L \\to \\mathbb{F}_q</span> , and  <span class="math">b \\in \\mathbb{F}_q</span> . Let  <span class="math">g = \\mathsf{QUOTIENT}(f, z, b)</span> . Then the following are equivalent:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a polynomial  <span class="math">Q(X) \\in \\mathbb{F}_q[X]</span>  of degree at most d-1 such that  <span class="math">\\Delta(g,Q) &lt; \\delta</span> .</li>

      <li>There exists a polynomial  <span class="math">R(X) \\in \\mathbb{F}_q[X]</span>  of degree at most d such that  <span class="math">\\Delta(f,R) &lt; \\delta</span>  and R(z) = b.</li>

    </ul>

    <p class="text-gray-300"><em>Proof.</em> If there is such a polynomial  <span class="math">Q, \\deg(Q) \\leq d-1</span>  that agrees with g on all but a  <span class="math">\\delta</span> -fraction of entries, we can take R = QZ + b. Notice  <span class="math">\\deg(R) \\leq d</span>  because  <span class="math">\\deg(Z) = 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conversely, if there is such a polynomial R that agrees with f on all but a  <span class="math">\\delta</span> -fraction of entries, we can take Q = (R - b)/Z. This is indeed a polynomial because R - b vanishes on z, so Z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(R - b) in the ring of polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, by construction R agrees with f whenever g agrees with R and this completes the proof.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">5.3 DEEP-FRI</h4>

    <p class="text-gray-300">Recall: We have linear spaces  <span class="math">L_0^{(0)}, L_0^{(1)}, \\dots, L_0^{(r)}</span> , with dimensions  <span class="math">k, k-1, \\dots, k-r</span> . We further have 1 dimensional subspaces  <span class="math">L_0^{(0)}, L_0^{(1)}, \\dots, L_0^{(r)}</span>  with  <span class="math">L_0^{(i)} \\subseteq L^{(i)}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For this, it will be helpful to keep in mind the case that the domain  <span class="math">L^{(0)}</span>  is much smaller than the field  <span class="math">\\mathbb{F}_q</span>  (maybe  $q =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\Theta(1)}$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-24" class="text-2xl font-bold">Protocol 5.4 (DEEP-FRI).</h2>

    <p class="text-gray-300">Input: a function  <span class="math">f^{(0)}: L^{(0)} \\to \\mathbb{F}_q</span>  which is supposed to be of degree  <span class="math">&lt; d^{(0)}</span> .</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6"><strong>COMMIT Phase:</strong></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. For each  <span class="math">i \\in [0, r 1]</span> :</li>

      <li>(a) The verifier picks a uniformly random  <span class="math">z^{(i)} \\in \\mathbb{F}_q.</span></li>

      <li>(b) The prover writes down a degree one polynomial  <span class="math">B_{z^{(i)}}^{(i)}(X) \\in \\mathbb{F}_q[X]</span>  (which is supposed to be such that  <span class="math">B_{z^{(i)}}^{(i)}(x)</span>  equals the evaluation of the low degree polynomial  <span class="math">H_x[f^{(i)}]</span>  at  <span class="math">z^{(i)}</span> ).</li>

      <li>(c) The verifier picks uniformly random  <span class="math">x^{(i)} \\in \\mathbb{F}_q</span> .</li>

    </ul>

    <p class="text-gray-300">(d) The prover writes down a function</p>

    <div class="my-4 text-center"><span class="math-block">f^{(i+1)}:L^{(i+1)}\\to \\mathbb{F}_q.</span></div>

    <p class="text-gray-300">(which on input y is supposed to equal  <span class="math">\\mathsf{QUOTIENT}(H_{x^{(i)}}[f^{(i)}], z^{(i)}, B_{z^{(i)}}^{(i)}(x))</span> .)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover writes down a value  <span class="math">C \\in \\mathbb{F}_q</span> .</li>

    </ol>

    <h2 id="sec-26" class="text-2xl font-bold"><strong>QUERY Phase:</strong></h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Repeat  <span class="math">\\ell</span>  times:</li>

      <li>(a) The verifier picks a uniformly random  <span class="math">s^{(0)} \\in D</span> .</li>

      <li>(b) For each  <span class="math">i \\in [0, \\mathsf{r} 1]</span> :</li>

      <li>i. Define  <span class="math">s^{(i+1)} \\in L^{(i+1)}</span>  by  <span class="math">s^{(i+1)} = q^{(i)}(s^{(i)})</span> .</li>

      <li>ii. Compute  <span class="math">H_{x^{(i)}}<a href="s^{(i+1">f^{(i)}</a>})</span>  by making 2 queries to  <span class="math">f^{(i)}</span> .</li>

      <li>iii. If  <span class="math">H_{x^{(i)}}<a href="s^{(i+1">f^{(i)}</a>}) \\neq f^{(i+1)}(s^{(i+1)}) \\cdot (s^{(i+1)} z^{(i)}) + B_{z^{(i)}}^{(i)}(x^{(i)})</span> , then REJECT.</li>

      <li>(c) If  <span class="math">f^{(r)}(s^{(r)}) \\neq C</span> , then REJECT.</li>

      <li>2. ACCEPT.</li>

    </ul>

    <h2 id="sec-27" class="text-2xl font-bold">5.4 Analysis</h2>

    <p class="text-gray-300"><span id="page-20-0"></span>The following theorem proves the soundness of the DEEP-FRI protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 5.5</strong> (DEEP-FRI). Fix degree bound  <span class="math">d^{(0)} = 3 \\cdot 2^{\\mathsf{r}} - 2</span>  and  <span class="math">\\mathsf{RS}^{(0)} = \\mathsf{RS}[\\mathbb{F}_q, L^{(0)}, d^{(0)}]</span> . Let  $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For some  <span class="math">\\epsilon, \\delta &gt; 0</span> , let</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\delta^* &amp;= \\delta - 2\\mathsf{r}\\epsilon, \\\\ \\mathcal{L}^* &amp;= \\mathcal{L}(\\mathbb{F}_q, L^{(0)}, d^{(0)}, \\delta^*), \\\\ \\nu^* &amp;= 2\\mathcal{L}^* \\left(\\frac{d^{(0)}}{q} + \\epsilon\\right)^{1/3} + \\frac{4}{\\epsilon^2 q}. \\end{split}</span></div>

    <p class="text-gray-300">Then the following properties hold when the DEEP-FRI protocol is invoked on oracle  <span class="math">f^{(0)}:L^{(0)}\\to \\mathbb{F}_q</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Prover complexity is O(n) arithmetic operations over  <span class="math">\\mathbb{F}</span></li>

      <li>2. Verifier complexity is  <span class="math">O(\\log n)</span>  arithmetic operations over  <span class="math">\\mathbb{F}</span>  for a single invocation of the QUERY phase; this also bounds communication and query complexity (measured in field elements).</li>

      <li>3. Completeness If  <span class="math">f^{(0)} \\in \\mathsf{RS}^{(0)}</span>  and  <span class="math">f^{(1)}, \\ldots, f^{(r)}</span>  are computed by the prover specified in the COMMIT phase, then the DEEP-FRI verifier outputs accept with probability 1.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness Suppose  <span class="math">\\Delta(f^{(0)}, RS^{(0)}) &gt; \\delta</span> . Then with all but probability</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{err}_{\\mathsf{COMMIT}} \\le \\mathsf{r} \\cdot \\nu^* \\le (\\log n) \\cdot \\nu^*. \\tag{13}</span></div>

    <p class="text-gray-300">and for any (adaptively chosen) prover oracles  <span class="math">f^{(1)}, \\ldots, f^{(r)}</span> , the QUERY protocol with repetition parameter  <span class="math">\\ell</span>  outputs accept with probability at most</p>

    <p class="text-gray-300"><span id="page-21-0"></span> <span class="math-block">\\operatorname{err}_{\\mathsf{QUERY}} \\le (1 - \\delta^* + (\\log n) \\cdot \\epsilon)^{\\ell} \\tag{14}</span></p>

    <p class="text-gray-300">Consequently, the soundness error of FRI is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{err}(\\delta) \\le (\\log n) \\cdot \\nu^* + (1 - \\delta^* + (\\log n) \\cdot \\epsilon)^{\\ell} \\tag{15}</span></div>

    <p class="text-gray-300"><span id="page-21-1"></span>We give a consequence below with a specific setting of parameters based on the Johnson bound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Example 5.6.</strong> Continuing with the notation of Theorem 5.5, fix degree bound  <span class="math">d^{(0)} = 3 \\cdot 2^{\\mathsf{r}} - 2</span>  and assume  $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< \\sqrt{q}<span class="math"> . Let  </span>\\mathsf{RS}^{(0)} = \\mathsf{RS}[\\mathbb{F}_q, L^{(0)}, d^{(0)}]<span class="math">  and let  </span>\\rho = d^{(0)}/n$  be its rate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">f^{(0)}: L^{(0)} \\to \\mathbb{F}_q</span>  be a function, and let  <span class="math">\\delta^{(0)} = \\Delta(f^{(0)}, RS^{(0)})</span> . Then with all but probability  <span class="math">\\operatorname{err}_{\\mathsf{COMMIT}} \\leq O(q^{-\\Omega(1)})</span> , the query phase will accept with probability at most:  <span class="math">\\operatorname{err}_{\\mathsf{QUERY}} \\leq (\\max(1 - \\delta^{(0)}, \\sqrt{\\rho}) + o(1))^{\\ell}</span>  as  <span class="math">n \\to \\infty</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Note that  <span class="math">d^{(0)} \\leq n \\leq \\sqrt{q}</span> .</p>

    <p class="text-gray-300">Set  <span class="math">\\delta = \\min(\\delta^{(0)}, 1 - \\sqrt{\\rho} - q^{-1/13})</span> , and apply the previous theorem. Theorem 2.2 implies that  <span class="math">\\mathcal{L}^* &lt; q^{1/13}/(2\\sqrt{\\rho}) = O(q^{1/13})</span> . Set  <span class="math">\\epsilon = q^{-6/13}</span> . Hence</p>

    <div class="my-4 text-center"><span class="math-block">\\nu^* = 2\\mathcal{L}^* \\left( d^{(0)} q^{-1} + q^{-6/13} \\right)^{1/3} + 4q^{-6/13} = O(q^{-1/13}),</span></div>

    <p class="text-gray-300">which implies  <span class="math">err_{COMMIT} \\leq \\tilde{O}(q^{-1/13})</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\delta = \\delta^{(0)}</span> , then  <span class="math">1 - \\delta^* + (\\log n)\\epsilon = 1 - \\delta + o(1)</span> . Otherwise  <span class="math">\\delta = 1 - \\sqrt{\\rho} - q^{-1/13}</span> , and so</p>

    <div class="my-4 text-center"><span class="math-block">1 - \\delta^* + (\\log n)\\epsilon = \\sqrt{\\rho} + q^{-1/13} + (\\log n)\\epsilon = \\sqrt{\\rho} + q^{-1/13} + (\\log n)q^{-6/13}.</span></div>

    <p class="text-gray-300">Thus  <span class="math">\\operatorname{err}_{\\mathsf{QUERY}} \\leq (\\max(1 - \\delta, \\sqrt{\\rho}) + o(1))^{\\ell}</span> .</p>

    <p class="text-gray-300">We now give an example setting of DEEP-FRI under the optimistic Conjecture 2.3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Example 5.7.</strong> Assume Conjecture 2.3. Continuing with the notation of Theorem 5.5, fix degree bound  <span class="math">d^{(0)} = 3 \\cdot 2^{\\mathsf{r}} - 2</span>  and  $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Let  </span>\\mathsf{RS}^{(0)} = \\mathsf{RS}[\\mathbb{F}_q, L^{(0)}, d^{(0)}]<span class="math">  and let  </span>\\rho = d^{(0)}/n<span class="math">  be its rate. Let  </span>C = C_\\rho<span class="math">  be the constant given by Conjecture 2.3. Suppose  </span>q > n^{24C}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">f^{(0)}: L^{(0)} \\to \\mathbb{F}_q</span>  be a function, and let  <span class="math">\\delta^{(0)} = \\Delta(f^{(0)}, RS^{(0)})</span> . Then with all but probability  <span class="math">\\operatorname{err}_{\\mathsf{COMMIT}} \\leq O(q^{-\\Omega(1)})</span> , the query phase will accept with probability at most:  <span class="math">\\operatorname{err}_{\\mathsf{QUERY}} \\leq (1 - \\delta^{(0)} + o(1))^{\\ell}</span>  as  <span class="math">n \\to \\infty</span> .</p>

    <p class="text-gray-300">Proof. Set  <span class="math">\\epsilon = q^{-1/(6C)}</span> .</p>

    <p class="text-gray-300">Set  <span class="math">\\delta = \\min(\\delta^{(0)}, 1 - \\rho - q^{-1/(6C)})</span> . Conjecture 2.3 gives us:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}^* &lt; n^C q^{1/6}.</span></div>

    <p class="text-gray-300">We then apply the previous theorem. We get  <span class="math">\\nu^<em> \\ll O(\\mathcal{L}^</em> \\cdot (d/q + \\epsilon)^{1/3} + \\frac{1}{\\epsilon^2 q}) \\ll q^{-1/12}</span> , and this gives us the claimed bound on err<sub>COMMIT</sub>.</p>

    <p class="text-gray-300">For the bound on err<sub>QUERY</sub>, we note that  <span class="math">\\delta = \\delta^{(0)} + o(1)</span> . This is because <em>every</em> function is within distance  <span class="math">1 - \\rho</span>  of RS<sup>(0)</sup> (this follows easily from polynomial interpolation). Thus</p>

    <div class="my-4 text-center"><span class="math-block">1 - \\delta^* + (\\log n)\\epsilon = \\delta + o(1),</span></div>

    <p class="text-gray-300">and we get the desired bound on err<sub>COMMIT</sub>.</p>

    <p class="text-gray-300">The prover and verifier complexity as well as completeness follow by construction (see, e.g., [BBHR18b] for detailed analysis of these aspects). In the rest of the section we prove the soundness bound of Theorem 5.5.</p>

    <h2 id="sec-28" class="text-2xl font-bold">5.5 Preparations</h2>

    <p class="text-gray-300">We do the analysis below for the case  <span class="math">\\ell=1</span> . The generalization to arbitrary  <span class="math">\\ell</span>  easily follows.</p>

    <p class="text-gray-300">Define  <span class="math">d^{(0)} = 3 \\cdot 2^{\\mathsf{r}} - 2</span> , and  <span class="math">d^{(i+1)} = d^{(i)}/2 - 1</span> . It is easy to check that  <span class="math">d^{(\\mathsf{r})} = 1</span> . Define  <span class="math">\\mathsf{RS}^{(i)} = \\mathsf{RS}[\\mathbb{F}_q, L^{(i)}, d^{(i)}]</span> . In the case of the honest prover (when  <span class="math">f^{(0)} \\in \\mathsf{RS}^{(0)}</span> ), we will have  <span class="math">f^{(i)} \\in \\mathsf{RS}^{(i)}</span>  for all i.</p>

    <p class="text-gray-300">Our analysis of the above protocol will track the agreement of  <span class="math">f^{(i)}</span>  with  <span class="math">RS^{(i)}</span> . This agreement will be measured in a certain weighted way, which we define next.</p>

    <h2 id="sec-29" class="text-2xl font-bold"><strong>5.5.1</strong> The success probability at <span class="math">s \\in L^{(i)}</span></h2>

    <p class="text-gray-300">There is a natural directed forest that one can draw on the vertex set</p>

    <div class="my-4 text-center"><span class="math-block">L^{(0)} \\cup L^{(1)} \\cup \\ldots \\cup L^{(\\mathsf{r})},</span></div>

    <p class="text-gray-300">namely, where  <span class="math">s \\in L^{(i)}</span>  is joined to  <span class="math">q^{(i)}(s) \\in L^{(i+1)}</span>  (and we say that s is a child of  <span class="math">q^{(i)}(s)</span> ). Note that every vertex not in  <span class="math">L^{(0)}</span>  has two children.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">i \\leq \\mathsf{r} - 1</span>  and  <span class="math">s_0 \\in L^{(i)}</span> . Let  <span class="math">s \\in L^{(i+1)}</span>  be the parent of  <span class="math">s_0</span> , and let  <span class="math">s_1 \\in L^{(i)}</span>  the sibling of  <span class="math">s_0</span> . We color  <span class="math">s_0</span>  GREEN if  <span class="math">f^{(i+1)}(s)</span>  is consistent with  $f^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{s_0,s_1\\}}$  according to the test</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">H_{x^{(i)}}[f^{(i)}](s) = f^{(i+1)}(s) \\cdot (s - z^{(i)}) + B_{z^{(i)}}^{(i)}(x^{(i)})</span></div>

    <p class="text-gray-300">and we color  <span class="math">s_0</span>  RED otherwise. Notice that a vertex and its sibling get the same color.</p>

    <p class="text-gray-300">For  <span class="math">s \\in L^{(r)}</span> , we color s GREEN if  <span class="math">f^{(r)}(s) = C</span>  and RED otherwise.</p>

    <p class="text-gray-300">The QUERY phase of the protocol can be summarized as follows: we pick a uniformly random  <span class="math">s^{(0)} \\in L^{(0)}</span>  and consider the path  <span class="math">s^{(0)}, s^{(1)}, s^{(2)}, \\ldots, s^{(r)}</span>  going through all its ancestors. If all these vertices are GREEN, then we ACCEPT, otherwise we REJECT.</p>

    <p class="text-gray-300">To capture this, we define functions  <span class="math">\\eta^{(i)}:L^{(i)}\\to\\mathbb{R}</span>  as follows. For  <span class="math">s\\in L^{(i)}</span> , let  <span class="math">\\eta^{(i)}(s)</span>  be the fraction of leaf-descendants  <span class="math">s^{(0)}</span>  of s for which the path from  <span class="math">s^{(0)}</span>  to s (including  <span class="math">s^{(0)}</span>  but not including s) consists exclusively of GREEN vertices. Observe that  <span class="math">p_{ACCEPT}=\\mathbb{E}_{s\\in L^{(r)}}[\\eta^{(r)}(s)\\cdot 1_{f^{(r)}(s)=C}]</span>  equals the probability that the QUERY phase accepts.</p>

    <p class="text-gray-300">The exact quantity that we will track is as i increases is the weighted agreement:</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(i)} = \\mathsf{agree}_{\\eta^{(i)}}[f^{(i)}, \\mathsf{RS}^{(i)}].</span></div>

    <p class="text-gray-300">Notice that</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(0)} = 1 - \\Delta(f^{(0)}, \\mathsf{RS}^{(0)}),</span></div>

    <p class="text-gray-300">and the acceptance probability,  <span class="math">p_{ACCEPT}</span>  satisfies:</p>

    <div class="my-4 text-center"><span class="math-block">p_{ACCEPT} \\le \\alpha^{(\\mathsf{r})}.</span></div>

    <p class="text-gray-300">Our main intermediate claim is that with high probability over the choice of  <span class="math">x^{(i)}, z^{(i)}, B_{z^{(i)}}^{(i)}</span> , we have that  <span class="math">\\alpha^{(i+1)}</span>  is not much more than  <span class="math">\\alpha^{(i)}</span> . This gives us that  <span class="math">p_{ACCEPT}</span>  is not much more than  <span class="math">1 - \\Delta(f^{(0)}, \\mathsf{RS}^{(0)})</span> , as desired.</p>

    <h2 id="sec-30" class="text-2xl font-bold">5.5.2 Operations AVG and ZERO</h2>

    <p class="text-gray-300">We define two important operations.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AVG. For a function  <span class="math">w: L^{(i-1)} \\to \\mathbb{R}</span> , we define the function  <span class="math">\\mathsf{AVG}[w]: L^{(i)} \\to \\mathbb{R}</span>  as follows. Let  <span class="math">s \\in L^{(i)}</span> , and let  <span class="math">\\{s_0, s_1\\} = (q^{(i-1)})^{-1}(s)</span> . Then define:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">AVG[w](s) = \\frac{w(s_0) + w(s_1)}{2}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ZERO. For a function  <span class="math">w: L^{(i)} \\to \\mathbb{R}</span> , and a set  <span class="math">S \\subseteq L^{(i)}</span> , we define the function  <span class="math">\\mathsf{ZERO}[w, S] : L^{(i)} \\to \\mathbb{R}</span>  as follows. For  <span class="math">s \\in L^{(i)}</span> , we set:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{ZERO}[w,S](s) = \\begin{cases} 0 &amp; s \\in S \\\\ w(s) &amp; s \\not \\in S \\end{cases}.</span></div>

    <p class="text-gray-300">We can use these two operations to express  <span class="math">\\eta^{(i+1)}</span>  in terms of  <span class="math">\\eta^{(i)}</span> . Let  <span class="math">E^{(i+1)}</span>  denote the set of all  <span class="math">s \\in S^{(i+1)}</span>  both of whose children are RED (i.e., the test</p>

    <div class="my-4 text-center"><span class="math-block">H_{x^{(i)}}[f^{(i)}](s) = f^{(i+1)}(s) \\cdot (s - z^{(i)}) + B_{z^{(i)}}^{(i)}(x^{(i)})</span></div>

    <p class="text-gray-300">fails at s).</p>

    <p class="text-gray-300">Define  <span class="math">\\theta^{(i+1)}: L^{(i+1)} \\to \\mathbb{R}</span>  by</p>

    <div class="my-4 text-center"><span class="math-block">\\theta^{(i+1)} = \\mathsf{AVG}[\\eta^{(i)}].</span></div>

    <p class="text-gray-300">Then we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\eta^{(i+1)} = \\mathsf{ZERO}(\\theta^{(i+1)}, E^{(i+1)}).</span></div>

    <p class="text-gray-300">Analogous to our definition of</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(i)} = \\mathsf{agree}_{\\eta^{(i)}}(f^{(i)}, \\mathsf{RS}^{(i)}),</span></div>

    <p class="text-gray-300">we define</p>

    <div class="my-4 text-center"><span class="math-block">\\beta^{(i+1)} = \\mathsf{agree}_{\\theta^{(i+1)}}(H_{x^{(i)}}[f^{(i)}], \\{P(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(P) \\leq d^{(i+1)} \\text{ and } P(z^{(i)}) = B_{z^{(i)}}^{(i)}(x^{(i)})\\}).</span></div>

    <p class="text-gray-300"><span id="page-23-0"></span>The following two lemmas control the growth of  <span class="math">\\alpha^{(i)}</span>  and  <span class="math">\\beta^{(i)}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.8.</strong> For all i, with probability at least  <span class="math">1 - \\nu^*</span>  over the choice of  <span class="math">x^{(i)}, z^{(i)}</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\beta^{(i+1)} \\le \\max(\\alpha^{(i)}, 1 - \\delta^*) + \\epsilon.</span></div>

    <p class="text-gray-300"><span id="page-24-1"></span>We prove this using Theorem 4.3 in Appendix C.</p>

    <p class="text-gray-300">Lemma 5.9. For all i,</p>

    <p class="text-gray-300"><span class="math-block">\\alpha^{(i)} \\le \\beta^{(i)}</span> .</p>

    <p class="text-gray-300">We prove this using Lemma 5.3 in Appendix C. We can now complete the proof of Theorem 5.5.</p>

    <p class="text-gray-300"><em>Proof.</em> As observed earlier,  <span class="math">\\alpha^{(0)} = 1 - \\Delta(f^{(0)}, \\mathsf{RS}^{(0)}) &lt; 1 - \\delta</span> . The two lemmas above imply that with probability at least  <span class="math">1 - r\\nu^*</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(\\mathsf{r})} \\leq \\max(\\alpha^{(0)}, 1 - \\delta^*) + \\mathsf{r} \\cdot \\epsilon &lt; (1 - \\min(\\delta, \\delta^*) + \\mathsf{r} \\cdot \\epsilon).</span></div>

    <p class="text-gray-300">Finally, we use the observation that  <span class="math">p_{ACCEPT} \\leq \\alpha^{(r)}</span>  to complete the proof.</p>

    <p class="text-gray-300">The techniques used earlier in Theorem 4.1 and Section 5 can also be used to improve soundness in other parts of an interactive oracle proof (IOP) protocol. We apply them here to obtain a Scalable Transparent IOP of Knowledge (STIK) [BBHR18a, Definition 3.3] with better soundness than the prior state of the art, given in [BBHR18a, Theorem 3.4].</p>

    <p class="text-gray-300">Proof systems typically use a few steps of reduction to convert problems of membership in a nondeterministic language L to algebraic problems regarding proximity of a function (or a sequence of functions) to an algebraic code like Reed-Solomon (or, in earlier works, Reed-Muller). The goal of such a reduction is to maintain a large proximity gap  <span class="math">\\gamma</span> , meaning that for instances in L, an honest prover will provide information that leads to codewords, whereas for instances not in L, any oracles submitted by the prover will be converted by the reduction, with high probability, to functions that are  <span class="math">\\gamma</span> -far from the code. Considerable effort is devoted to increasing  <span class="math">\\gamma</span>  because it is the input to the proximity protocols (like FRI and DEEP-FRI) and the soundness of those protocols is correlated to  <span class="math">\\gamma</span>  (as discussed earlier, e.g., in Theorem 5.5).</p>

    <p class="text-gray-300">The STIK protocol is a special case of this paradigm. It requires the prover to provide oracle access to a function  <span class="math">f:D\\to\\mathbb{F}</span>  that is supposedly an RS encoding of a witness for membership of the input instance in L. A set of t-local constraints is applied to f to construct a function  <span class="math">g:D\\to\\mathbb{F}</span> , along with a gap-gurantee: If f is indeed an encoding of a valid witness for the instance, then the resulting function  <span class="math">g:D\\to\\mathbb{F}</span>  is also be a member of an RS code. One of the tests that the verifier performs is a consistency test between f and g, and, prior to this work, this consistency test was applied to the functions f and g directly. This leads to a rather small gap  <span class="math">\\gamma \\leq \\frac{1}{8}</span>  which results in a small soundness guarantee from the RPT protocol applied to f,g later on.</p>

    <p class="text-gray-300">In this section we apply the DEEP technique to this setting. After f and g have been provided, the verifier samples a random  <span class="math">z \\in \\mathbb{F}_q</span>  and asks for the values of the interpolating polynomials of f,g on all t entries needed to check the consistency test. Our verifier now applies the QUOTIENT operation to f,g, using the information obtained from the prover. Crucially, we prove that a single consistency test, conducted over a large domain  <span class="math">D&#x27; \\supset D</span> , suffices to improve the proximity gap to roughly  <span class="math">1 - \\sqrt{\\rho}</span> , a value that approaches 1 as  <span class="math">\\rho \\to 0</span> . Assuming Conjecture 2.3 the proximity gap is nearly-optimal, at  <span class="math">\\gamma \\approx 1 - \\rho</span>  (compare with with the value  <span class="math">\\gamma \\le 1/8</span>  obtained by prior works). Details follow.</p>

    <p class="text-gray-300">We focus on the the Algebraic linking IOP protocol (ALI) of [BBHR18a, Theorem B.15], and present a new protocol that we call DEEP-ALI (Protocol 6.4) that obtains the aforementioned improved proximity gap(s).</p>

    <p class="text-gray-300">In what follows, we will first recall (a variant of) the language (or, more accurately, binary relation) which was the input to the ALI protocol of [BBHR18a] and is likewise the input to our DEEP-ALI protocol. The description of the protocol follows in Section 6.2. Its basic properties are specified in Section 6.3 and we analyze its soundness in Theorem 6.2 and Section 6.4.</p>

    <h2 id="sec-32" class="text-2xl font-bold">6.1 The Algebraic Placement and Routing (APR) Relation</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In what follows we use the notation  <span class="math">\\tilde{f}</span>  to refer to a polynomial in  <span class="math">\\mathbb{F}[x]</span> . Note that the operator  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D<span class="math">  for  </span>D \\subseteq \\mathbb{F}<span class="math">  takes a polynomial to a function:  </span>\\tilde{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D \\colon D \\to \\mathbb{F}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We start by defining a simplified version of the Algebraic placement and routing relation (APR). See [BBHR18a, Definition B.10]. In particular, we only use one witness polynomial. This relation will be the input to the reduction used in Protocol 6.4.</p>

    <p class="text-gray-300"><span id="page-25-0"></span><strong>Definition 6.1.</strong> The relation  <span class="math">R_{APR}</span>  is the set of pairs (x, w) satisfying:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Instance format: The instance x is a tuple  <span class="math">(\\mathbb{F}_q, d, \\mathcal{C})</span>  where:</li>

      <li><span class="math">\\mathbb{F}_q</span>  is a finite field of size q.</li>

      <li><span class="math">\\bullet</span>  d is an integer representing a bound on the degree of the witness.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{C}</span>  is a set of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  tuples  </span>(M^i, P^i, Q^i)<span class="math">  representing constraints.  </span>M^i<span class="math">  is the mask which is a sequence of field elements  </span>M^i = \\{M^i_j \\in \\mathbb{F}_q\\}_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> .  </span>P^i<span class="math">  is the condition of the constraint which is a polynomial with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  variables.  </span>Q^i \\in \\mathbb{F}_q[x]$  is the domain polynomial of the constraint which should vanish on the locations where the constraint should hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We further introduce the following notation:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  $\\mathcal{M} = \\{M_j^i \\mid 1 \\leq i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ and } 1 \\leq j \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} \\subseteq \\mathbb{F}_q \\text{ be the full mask.}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">d_{\\mathcal{C}} = \\max_i \\deg(P^i)</span>  be the maximal total degree of the  <span class="math">P^i</span> s.</li>

      <li>Let  <span class="math">Q_{lcm} \\in \\mathbb{F}_q[x]</span>  be the least common multiple of the  <span class="math">Q^is</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2. Witness format: The witness w is a polynomial  <span class="math">\\tilde{f} \\in \\mathbb{F}_q[x]</span> . A constraint (M, P, Q) is said to hold at a location  <span class="math">x \\in \\mathbb{F}_q</span>  if  $P(\\tilde{f}(x \\cdot M_1), \\dots, \\tilde{f}(x \\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})) = 0<span class="math"> . We say that  </span>\\tilde{f}<span class="math">  satisfies the constraint if the constraint holds at every  </span>x \\in \\mathbb{F}_q$  for which Q(x) = 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that w satisfies the instance if and only if  <span class="math">\\deg(\\tilde{f}) &lt; d</span>  and  <span class="math">\\tilde{f}</span>  satisfies all of the constraints.</p>

    <p class="text-gray-300">To see that the notion of the  <span class="math">R_{\\text{APR}}</span>  relation defined above is strong enough, we follow the ideas from [BBHR18a] and show a reduction from an Algebraic Intermediate Representation (AIR, see [BBHR18a, Definition B.3]) to an APR. The following uses the notation from [BBHR18a, Definition B.3]. Let  <span class="math">\\mathbf{x} = (\\mathbb{F}_q, T, \\mathbf{w}, \\mathcal{P}, C, \\mathbf{B})</span>  be an instance of  <span class="math">R_{\\text{AIR}}</span> . Pick a multiplicative subgroup  <span class="math">\\langle \\gamma \\rangle \\subseteq \\mathbb{F}_q^{\\times}</span>  of size  <span class="math">T \\cdot \\mathbf{w}</span>  and pick  <span class="math">\\tilde{f}</span>  such that  <span class="math">\\tilde{f}(\\gamma^{tw+j}) = w_j(t)</span>  for  <span class="math">t \\in [T]</span>  and  <span class="math">i \\in [\\mathbf{w}]</span>  (here  <span class="math">[n] = \\{0, \\dots, n-1\\}</span> ). For all the constraints in  <span class="math">\\mathcal{P}</span> , choose the mask  <span class="math">M = \\{1, \\gamma, \\dots, \\gamma^{2w-1}\\}</span>  and choose the domain polynomial whose zeros are  <span class="math">\\{\\gamma^{tw}\\}_{t \\in [T-1]}</span>   <span class="math">(Q(x) = (x^T - 1)/(x - \\gamma^{-w}))</span> . Replace each boundary constraint  <span class="math">(i, j, \\alpha) \\in \\mathbf{B}</span>  with a regular constraint with mask  <span class="math">M = \\{1\\}</span> ,  <span class="math">P(x) = x - \\alpha</span>  and  <span class="math">Q(x) = x - \\gamma^{iw+j}</span> .</p>

    <h2 id="sec-33" class="text-2xl font-bold">6.2 The DEEP-ALI protocol</h2>

    <p class="text-gray-300"><span id="page-26-2"></span>We now describe our new protocol, that achieves improved soundness, as stated in the following theorem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 6.2</strong> (DEEP-ALI soundness). Fix a code rate  <span class="math">0 &lt; \\rho &lt; 1</span>  and a distance parameter  <span class="math">0 &lt; \\delta \\le 1 - \\rho</span> . Let  <span class="math">D, D&#x27; \\subseteq \\mathbb{F}_q</span>  be two evaluation domains such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d\\rho^{-1}<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d \\cdot d_{\\mathcal{C}}\\rho^{-1}<span class="math"> . Let  </span>\\operatorname{RPT}_D<span class="math"> ,  </span>\\operatorname{RPT}_{D'}<span class="math">  be two IOPPs with perfect completeness for the codes  </span>\\operatorname{RS}[\\mathbb{F}_q, D, (d-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">])<span class="math">  and  </span>\\operatorname{RS}[\\mathbb{F}_q, D', (dd_{\\mathcal{C}} - 1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">])<span class="math">  respectively. Let  </span>\\epsilon, \\epsilon'<span class="math">  be the bounds on the soundness error (acceptance probability) for words that are at least  </span>\\delta$ -far from the corresponding code. Denote</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">L = \\max\\{\\mathcal{L}(\\mathbb{F}_q, D, d, \\delta), \\mathcal{L}(\\mathbb{F}_q, D&#x27;, d \\cdot d_{\\mathcal{C}}, \\delta)\\}.</span></div>

    <p class="text-gray-300">Then, there exists an IOP for  <span class="math">R_{APR}</span>  with perfect completeness and soundness error  <span class="math">\\epsilon + \\epsilon&#x27; + \\frac{2L^2(d \\cdot d_{\\mathcal{C}} + \\deg(Q_{lcm}))}{q}</span> .</p>

    <p class="text-gray-300"><strong>Example 6.3.</strong> Fix a code rate  <span class="math">0 &lt; \\rho &lt; 1</span> . Choosing DEEP-FRI as the RPT protocol and setting  <span class="math">\\delta = 1 - \\sqrt{\\rho} - q^{-1/13}</span>  as in Example 5.6, using  <span class="math">\\ell</span>  repetitions, we obtain an IOP for  <span class="math">R_{APR}</span>  with perfect completeness and soundness error that approaches  <span class="math">2\\rho^{\\ell/2}</span>  as  <span class="math">q \\to \\infty</span>  assuming the parameters d,  <span class="math">d_{\\mathcal{C}}</span> ,  <span class="math">\\deg(Q_{lcm})</span>  of the APR are constant with respect to q.</p>

    <p class="text-gray-300"><em>Proof.</em> Theorem 2.2 implies that  <span class="math">L \\leq q^{1/13}/(2\\sqrt{\\rho}) = O(q^{1/13})</span> . Hence the expression  <span class="math">2L^2(d \\cdot d_{\\mathcal{C}} + \\deg(Q_{\\mathrm{lcm}}))/q</span>  approaches 0 as  <span class="math">q \\to \\infty</span> . Moreover, Example 5.6 implies that  <span class="math">\\epsilon, \\epsilon&#x27;</span>  approach  <span class="math">\\rho^{\\ell/2}</span> .  <span class="math">\\square</span></p>

    <p class="text-gray-300"><span id="page-26-0"></span>We now describe the protocol that achieves the soundness of Theorem 6.2.</p>

    <h2 id="sec-34" class="text-2xl font-bold">Protocol 6.4 (DEEP-ALI).</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. The prover sends an oracle  <span class="math">f: D \\to \\mathbb{F}</span>  (which should be  $\\tilde{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D$ ).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- 3. The prover sends an oracle  <span class="math">g_{\\alpha}: D&#x27; \\to F</span>  (which should be  $\\tilde{g}_{\\alpha}</td>

            <td class="px-3 py-2 border-b border-gray-700">_{D'}$ , where</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-26-3"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\tilde{g}_{\\alpha}(x) = \\sum_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_i \\cdot \\frac{P^i(\\tilde{f}(x \\cdot M_1^i), \\dots, \\tilde{f}(x \\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^i))}{Q^i(x)}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(16)</p>

    <p class="text-gray-300">Note that  <span class="math">deg(\\tilde{g}_{\\alpha}) &lt; d \\cdot d_{\\mathcal{C}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4. The verifier sends a random value  <span class="math">z \\in \\mathbb{F}_q</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 5. Denote  $\\mathcal{M}_z = \\{z \\cdot M_j^i \\mid 1 \\le i \\le</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ and } 1 \\le j \\le</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> . The prover sends  </span>a_{\\alpha,z} : \\mathcal{M}_z \\to \\mathbb{F}<span class="math">  (which should be  </span>\\tilde{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{M}_z}<span class="math"> ). The verifier deduces  </span>b_{\\alpha,z}<span class="math"> , the alleged value of  </span>\\tilde{g}_{\\alpha}(z)$ , using Equation (16).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>6. Let U(x), Z(x) as defined in Section 5.2.1 for QUOTIENT <span class="math">(f, a_{\\alpha,z})</span>  and let</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">h^1(x) = h^1_{\\alpha,z}(x) = \\mathsf{QUOTIENT}(f,a_{\\alpha,z}) = \\frac{f(x) - U(x)}{Z(x)},</span></div>

    <div class="my-4 text-center"><span class="math-block">h^2(x) = h^2_{\\alpha,z}(x) = \\mathsf{QUOTIENT}(g_\\alpha, \\{z \\mapsto b_{\\alpha,z}\\}) = \\frac{g_\\alpha(x) - b_{\\alpha,z}}{x - z},</span></div>

    <p class="text-gray-300">and note that the verifier has oracle access to  <span class="math">h^1</span>  and  <span class="math">h^2</span>  using the oracles f and  <span class="math">g_{\\alpha}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. They use RPT<sub>D</sub> and RPT<sub>D'</sub> to prove that  <span class="math">h^1</span>  is at most  <span class="math">\\delta</span> -far from RS[ <span class="math">\\mathbb{F}_q</span> , D,  $(d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ] (in other words, it is close to a polynomial of degree  </span>< d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ) and that  </span>h^2<span class="math">  is at most  </span>\\delta<span class="math"> -far from RS[ </span>\\mathbb{F}_q<span class="math"> , D&#x27;,  </span>(dd_{\\mathcal{C}} - 1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-35" class="text-2xl font-bold">6.3 Properties of DEEP-ALI</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that in the original ALI protocol, the equivalent to the expression  $P^i(\\tilde{f}(x\\cdot M_1^i),\\ldots,\\tilde{f}(x\\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^i))/Q^i(x)$  is sampled at Q random locations from the evaluation domain, where Q is the number of queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main idea in DEEP-ALI is to use Quotienting to allow the verifier to choose <em>one</em> random element z from the <em>entire</em> field, and check the consistency between  <span class="math">\\tilde{f}</span>  and  <span class="math">\\tilde{g}</span>  only at x=z.</p>

    <p class="text-gray-300">The fact that DEEP-ALI allows to sample from the entire field introduces several advantages over the ALI protocol from [BBHR18a]:</p>

    <p class="text-gray-300"><strong>Soundness</strong> As described above, the reduction in ALI has lower bound 1/8 on the distance from the code for inputs that are not in the language, even for  <span class="math">\\rho \\to 0</span> . In DEEP-ALI the lower bound on the distance is  <span class="math">1 - \\sqrt{\\rho}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Query complexity In ALI the verifier queries  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathsf{Q}<span class="math">  field elements as we need  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  elements to evaluate  </span>P^i(\\tilde{f}(x \\cdot M_1^i), \\dots, \\tilde{f}(x \\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^i))<span class="math"> . In DEEP-ALI the verifier queries  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{Q})<span class="math">  field elements as the evaluation of  </span>P^i$  is done once.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Verifier complexity Previously, the verifier complexity was  <span class="math">\\Omega(Q \\cdot T_{\\text{arith}})</span>  (where  <span class="math">T_{\\text{arith}}</span>  is the arithmetic complexity of evaluating all the constraints). The verifier complexity in DEEP-ALI depends on  <span class="math">Q + T_{\\text{arith}}</span>  as we evaluate the constraints only once.</p>

    <p class="text-gray-300"><strong>Prover complexity</strong> It is possible to alter Definition 6.1 and DEEP-ALI to work with several witness polynomials  <span class="math">f_1, \\ldots, f_w</span>  (as was done in ALI). The prover complexity in this case will depend on  <span class="math">(\\mathsf{w}\\rho^{-1} + d_{\\mathcal{C}}\\rho^{-1} + T_{\\mathrm{arith}}d_{\\mathcal{C}}) \\cdot d</span>  instead of  <span class="math">(\\mathsf{w}d_{\\mathcal{C}}\\rho^{-1} + T_{\\mathrm{arith}}d_{\\mathcal{C}}) \\cdot d</span>  (in ALI).</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">6.4 Soundness analysis</h4>

    <p class="text-gray-300">The proof of Theorem 6.2 will follow from the following lemma:</p>

    <p class="text-gray-300"><strong>Lemma 6.5.</strong> Let  <span class="math">\\mathcal{E}</span>  be the event that the DEEP-ALI verifier accepts. If</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathcal{E}] \\ge \\epsilon + \\epsilon&#x27; + \\frac{2L^2(d \\cdot d_{\\mathcal{C}} + \\deg(Q_{\\text{lcm}}))}{q},</span></div>

    <p class="text-gray-300">then there exists a polynomial of degree < d satisfying the constraints.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Proof.</em> Let  <span class="math">L(f) \\subseteq \\mathsf{RS}[\\mathbb{F}_q, D, \\rho]</span>  be the set of codewords that are at most  <span class="math">\\delta</span> -far from f. Similarly define  <span class="math">L(g_\\alpha)</span> . We have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L(f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L(g_\\alpha)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\mathcal{E}_1</span>  be the event where the verifier accepts and  <span class="math">h^1</span>  and  <span class="math">h^2</span>  are at most  <span class="math">\\delta</span> -far from the corresponding codes. Denote  <span class="math">\\eta = 2L^2(d \\cdot d_{\\mathcal{C}} + \\deg(Q_{\\mathrm{lcm}}))/q</span> . Then,  <span class="math">\\Pr[\\mathcal{E}_1] \\geq \\eta</span> .  <span class="math">\\mathcal{E}_1</span>  implies that there exists a polynomial  <span class="math">\\tilde{h}^1 = \\tilde{h}^1_{\\alpha,z}</span>  of degree  $< d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  such that  </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{ x \\in D : \\tilde{h}^1(x) \\neq \\frac{f(x) - U(x)}{Z(x)} \\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< \\delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Hence  </span>Z(x) \\cdot \\tilde{h}^1(x) + U(x) \\in L(f)<span class="math"> . Similarly there exists a polynomial  </span>\\tilde{h}^2 = \\tilde{h}^2_{\\alpha,z}<span class="math">  of degree  </span>< d \\cdot d_{\\mathcal{C}} - 1<span class="math">  such that  </span>(x - z)\\tilde{h}^2(x) + b \\in L(g_{\\alpha})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fix  <span class="math">\\tilde{r}^1(x)</span>  (independent of  <span class="math">\\alpha</span>  and z) to be the element in L(f) maximizing the probability that  <span class="math">\\tilde{r}^1(x) = Z(x) \\cdot \\tilde{h}^1(x) + U(x)</span>  given  <span class="math">\\mathcal{E}_1</span> . Let  <span class="math">\\mathcal{E}_2 \\subseteq \\mathcal{E}_1</span>  be the event that  <span class="math">\\tilde{r}^1(x) = Z(x) \\cdot \\tilde{h}^1(x) + U(x)</span> . It follows that  <span class="math">\\Pr[\\mathcal{E}_2] \\ge \\eta/L</span> .</p>

    <p class="text-gray-300">Fix  <span class="math">\\tilde{r}_{\\alpha}^2(x) \\in L(g_{\\alpha})</span>  maximizing the probability that  <span class="math">\\tilde{r}_{\\alpha}^2(x) = (x-z)\\tilde{h}^2(x) + b</span>  given  <span class="math">\\mathcal{E}_2</span>  (note that  <span class="math">\\tilde{r}_{\\alpha}^2</span>  depends on  <span class="math">\\alpha</span>  as the oracle  <span class="math">g_{\\alpha}</span>  was sent only after the verifier sent  <span class="math">\\alpha</span> ), and let  <span class="math">\\mathcal{E}_3 \\subseteq \\mathcal{E}_2</span>  be the event where  <span class="math">\\tilde{r}_{\\alpha}^2(x) = (x-z)\\tilde{h}^2(x) + b</span> . We have  <span class="math">\\Pr[\\mathcal{E}_3] \\geq \\eta/L^2</span> . This implies,  <span class="math">\\Pr_{\\alpha}[\\Pr_{z}[\\mathcal{E}_3] \\geq \\eta/(2L^2)] \\geq \\eta/(2L^2)</span> .</p>

    <p class="text-gray-300">The event  <span class="math">\\mathcal{E}_3</span>  implies</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{r}^1 \\mid_{\\mathcal{M}_z} = U \\mid_{\\mathcal{M}_z} = a_{\\alpha,z},</span></div>

    <p class="text-gray-300"> <span class="math">\\tilde{r}^2_{\\alpha}(z) = b_{\\alpha,z}.</span></p>

    <p class="text-gray-300">Recall that  <span class="math">b_{\\alpha,z}</span>  was defined according to (16), so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$b_{\\alpha,z} = \\sum_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_i \\cdot \\frac{P^i(a_{\\alpha,z}(z \\cdot M_1^i), \\dots, a_{\\alpha,z}(z \\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^i))}{Q^i(z)}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Substituting values for  <span class="math">a_{\\alpha,z}</span>  and  <span class="math">b_{\\alpha,z}</span>  and multiplying by  <span class="math">Q_{\\rm lcm}(z)</span>  we obtain:</p>

    <p class="text-gray-300"><span id="page-28-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Q_{\\rm lcm}(z) \\cdot \\tilde{r}_{\\alpha}^{2}(z) = \\sum_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_{i} \\cdot P^{i}(\\tilde{r}^{1}(z \\cdot M_{1}^{i}), \\dots, \\tilde{r}^{1}(z \\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{i})) \\cdot \\frac{Q_{\\rm lcm}(z)}{Q^{i}(z)}. \\tag{17}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Both sides of the equation are polynomials of degree  <span class="math">\\langle d \\cdot d_{\\mathcal{C}} + \\deg(Q_{\\text{lcm}}) \\text{ in } z</span> . For every  <span class="math">\\alpha</span>  for which  <span class="math">\\Pr_z[\\mathcal{E}_3] \\geq \\eta/(2L^2) = (d \\cdot d_{\\mathcal{C}} + \\deg(Q_{\\text{lcm}}))/q</span> , we have at least  <span class="math">d \\cdot d_{\\mathcal{C}} + \\deg(Q_{\\text{lcm}})</span>  many z's satisfying (17) and thus the two polynomials in (17) are identical. Let  <span class="math">G_{\\alpha}(x)</span>  denote the tright-hand side of (17) (replacing z with x).</p>

    <p class="text-gray-300">So far we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\alpha}[G_{\\alpha}(x) \\text{ is divisible by } Q_{\\text{lcm}}(x)] \\geq \\eta/(2L^2) &gt; 1/q.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the set of  <span class="math">\\alpha</span> 's satisfying this event forms a vector space. If its dimension was less than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  then the probability would have been  </span>\\leq 1/q<span class="math"> . Hence this event holds for every  </span>\\alpha<span class="math"> . Substituting the elements of the standard basis, we get that for every  </span>1 \\leq i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$P^i(\\tilde{r}^1(x\\cdot M_1^i),\\ldots,\\tilde{r}^1(x\\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^i))\\cdot \\frac{Q_{\\mathrm{lcm}}(x)}{Q^i(x)}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> is divisible by  <span class="math">Q_{\\mathrm{lcm}}(x)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Substituting any x for which  <span class="math">Q^i(x)=0</span>  gives  $P^i(\\tilde{r}^1(x\\cdot M_1^i),\\ldots,\\tilde{r}^1(x\\cdot M_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^i))=0<span class="math">  which implies that  </span>\\tilde{r}^1$  satisfies all the constraints, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-37" class="text-2xl font-bold">6.5 Further optimizations for practical implementation</h2>

    <p class="text-gray-300">As we saw, it makes sense to work with several witness polynomials rather than one, as it improves the prover complexity. Another optimization is to apply the RPT only once for both  <span class="math">h^1</span>  and  <span class="math">h^2</span>  by taking a random linear combination of the two (and using Theorem 4.1). To make this work, the prover writes the degree  <span class="math">\\langle d \\cdot d_{\\mathcal{C}} \\rangle</span>  polynomial  <span class="math">\\tilde{g}(x)</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{g}(x) = \\sum_{i=0}^{d_{\\mathcal{C}}-1} x^i \\tilde{g}_i(x^{d_{\\mathcal{C}}}),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the  <span class="math">\\tilde{g}_i</span> s are of degree < d, and it sends oracles to  <span class="math">\\tilde{g}_i \\mid_D</span>  instead of  <span class="math">\\tilde{g} \\mid_{D&#x27;}</span> . In total, we will have to run RPT on  <span class="math">\\mathsf{w} + d_{\\mathcal{C}}</span>  polynomials of degree < d, so we choose only one evaluation domain  <span class="math">D \\subseteq \\mathbb{F}_q</span>  satisfying  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d\\rho^{-1}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-38" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-29-0"></span>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In <em>Proceedings of the 24th ACM Conference on Computer and Communications Security</em>, October 2017.</li>

      <li><span id="page-29-2"></span>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. Available at https://eprint.iacr.org/2018/046.</li>

      <li><span id="page-29-7"></span>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Ynon Horesh, and Michael Riabzev. Fast Reed-Solomon Interactive Oracle Proofs of Proximity. In <em>Proceedings of the 45th International Colloquium on Automata, Languages, and Programming (ICALP)</em>, 2018.</li>

      <li><span id="page-29-6"></span>[BCF<sup>+</sup>16] Eli Ben-Sasson, Alessandro Chiesa, Michael A. Forbes, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. On probabilistic checking in perfect zero knowledge. Electronic Colloquium on Computational Complexity (ECCC), 23:156, 2016.</li>

      <li><span id="page-29-1"></span>[BCR<sup>+</sup>18] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. <em>IACR Cryptology ePrint Archive</em>, 2018:828, 2018.</li>

      <li><span id="page-29-5"></span>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Theory of Cryptography - 14th International Conference, TCC 2016-B, Beijing, China, October 31 - November 3, 2016, Proceedings, Part II, pages 31–60, 2016.</li>

      <li><span id="page-29-3"></span>[BGH<sup>+</sup>06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Robust PCPs of proximity, shorter PCPs, and applications to coding. <em>SIAM Journal on Computing</em>, 36(4):889–974, 2006.</li>

      <li><span id="page-29-8"></span>[BKS18a] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In 33rd Computational Complexity Conference, CCC 2018, June 22-24, 2018, San Diego, CA, USA, pages 24:1–24:23, 2018.</li>

      <li><span id="page-29-10"></span>[BKS18b] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. <em>Electronic Colloquium on Computational Complexity (ECCC)</em>, 25:90, 2018.</li>

      <li><span id="page-29-4"></span>[BS08] Eli Ben-Sasson and Madhu Sudan. Short PCPs with polylog query complexity. SIAM Journal on Computing, 38(2):551–607, 2008. Preliminary version appeared in STOC '05.</li>

      <li><span id="page-29-9"></span>[BSKR10] Eli Ben-Sasson, Swastik Kopparty, and Jaikumar Radhakrishnan. Subspace polynomials and limits to list decoding of reed-solomon codes. <em>IEEE Trans. Information Theory</em>, 56(1):113–120, 2010.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-30-8"></span>[CMS17] Alessandro Chiesa, Peter Manohar, and Igor Shinkar. On axis-parallel tests for tensor product codes. In <em>Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, APPROX/RANDOM 2017, August 16-18, 2017, Berkeley, CA, USA</em>, pages 39:1–39:22, 2017.</li>

      <li><span id="page-30-2"></span>[Din07] Irit Dinur. The PCP theorem by gap amplification. <em>Journal of the ACM</em>, 54(3):12, 2007.</li>

      <li><span id="page-30-6"></span>[Gur07] Venkatesan Guruswami. Algorithmic results in list decoding. <em>Foundations and Trends</em> <sup>R</sup> <em>in Theoretical Computer Science</em>, 2(2):107–195, 2007.</li>

      <li><span id="page-30-1"></span>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. <em>Journal of the ACM</em>, 39(4):859–868, 1992.</li>

      <li><span id="page-30-7"></span>[PS94] Alexander Polishchuk and Daniel A. Spielman. Nearly-linear size holographic proofs. In <em>Proceedings of the 26th Annual ACM Symposium on Theory of Computing</em>, STOC '94, pages 194–203, 1994.</li>

      <li><span id="page-30-0"></span>[Raz87] Alexander A. Razborov. Lower bounds on the size of bounded depth circuits over a complete basis with logical addition. <em>Mathematical notes of the Academy of Sciences of the USSR</em>, 41(4):333–338, 1987.</li>

      <li><span id="page-30-9"></span>[Rot06] Ron M. Roth. <em>Introduction to coding theory</em>. Cambridge University Press, 2006.</li>

      <li><span id="page-30-3"></span>[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In <em>Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2016, Cambridge, MA, USA, June 18-21, 2016</em>, pages 49–62, 2016.</li>

      <li><span id="page-30-4"></span>[RVW13] Guy N. Rothblum, Salil Vadhan, and Avi Wigderson. Interactive proofs of proximity: delegating computation in sublinear time. In <em>Proceedings of the forty-fifth annual ACM symposium on Theory of computing</em>, pages 793–802. ACM, 2013.</li>

      <li><span id="page-30-5"></span>[RW14] Atri Rudra and Mary Wootters. Every list-decodable code for high noise has abundant near-optimal rate puncturings. In <em>Symposium on Theory of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014</em>, pages 764–773, 2014.</li>

    </ul>

    <p class="text-gray-300"><em>Proof of Lemma <a href="#page-15-0">4.6.</a></em> To simplify notation set η = max 2L ∗ δ σ <sup>N</sup> + ǫ 1/<sup>3</sup> , 4 ǫ 2q , and let u<sup>x</sup> = u <sup>∗</sup>+xu. Let E[x, z] denote the event "∃v ∈ List(ux, V, δ),hv, zi = Bz(x)". The assumption of Equation <a href="#page-16-1">\\(10\\)</a> now reads as</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{x \\in \\mathbb{F}_q, z \\in S} [\\mathcal{E}[x, z]] \\ge \\eta.</span></div>

    <p class="text-gray-300">Thus we get,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{x \\in \\mathbb{F}_q} \\left[ \\Pr_{z \\in S} [\\mathcal{E}[x, z]] \\ge \\eta/2 \\right] \\ge \\eta/2 \\tag{18}</span></div>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">A = \\left\\{ x \\in \\mathbb{F}_q \\mid \\Pr_{z \\in S} [\\mathcal{E}[x, z]] \\ge \\eta/2] \\right\\}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and notice  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\eta q/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">x \\in \\mathbb{F}_q</span> , pick  <span class="math">v_x \\in V</span>  to be a member of  <span class="math">\\mathsf{List}(u_x, V, \\delta)</span>  that maximizes  <span class="math">\\Pr_{z \\in S}[P(z) = B_z(x)]</span> . Let  <span class="math">S_x = \\{z \\in S \\mid \\langle v_x, z \\rangle = B_z(x)\\}</span>  and set  $\\mu_x =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/s<span class="math"> . By definition,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{List}(u_x, V, \\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L_{\\delta}^<em><span class="math"> , and so by the pigeonhole principle, for each  </span>x \\in A<span class="math">  we have  </span>\\mu_x \\geq \\frac{\\eta}{2L_{\\delta}^</em>}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For  <span class="math">x, \\beta, \\gamma</span>  picked uniformly from A we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\mathbf{E}_{x,\\beta,\\gamma\\in A} \\left[ \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{s} \\right] &= \\mathbf{E}_{z\\in S,x,\\beta,\\gamma\\in\\mathbb{F}_q} [1_{z\\in S_x\\cap S_\\beta\\cap S_\\gamma}] \\\\ &= \\mathbf{E}_{z\\in S} [\\mathbf{E}_{x\\in\\mathbb{F}_q} [1_{z\\in S_x}]^3] \\\\ &\\geq \\mathbf{E}_{z\\in S,x\\in\\mathbb{F}_q} [1_{z\\in S_x}]^3 \\\\ &\\geq \\left(\\frac{\\eta}{2L_\\delta^*}\\right)^3 \\\\ &> \\frac{\\sigma}{N} + \\epsilon. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The second equality above follows from the independence of  <span class="math">x, \\beta, \\gamma</span> . The first inequality is an application of Jensen's inequality and the last inequality is by assumption on  <span class="math">\\eta</span> .</p>

    <p class="text-gray-300">Thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{x,\\beta,\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> \\sigma] \\ge \\epsilon.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  <span class="math">\\Pr_{x,\\beta,\\gamma}[x,\\beta,\\gamma]</span>  are not all distinct</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge \\eta q/2 \\ge 2/\\epsilon^2 \\ge 6/\\epsilon<span class="math">  we have  </span>3/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\le \\epsilon/2<span class="math"> . Thus  </span>\\Pr_{x,\\beta,\\gamma}[x,\\beta,\\gamma]<span class="math">  are all distinct and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_x \\cap S_\\beta \\cap S_\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> \\sigma \\ge \\epsilon/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This means that there are distinct  <span class="math">x_0, \\beta_0</span>  such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{\\gamma}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{x_0} \\cap S_{\\beta_0} \\cap S_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> d] \\ge \\epsilon/2.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider some  <span class="math">\\gamma</span>  where this happens. Let  <span class="math">\\tilde{S} = S_{x_0} \\cap S_{\\beta_0} \\cap S_{\\gamma}</span> . Extend each of  <span class="math">u^<em></span> , u to functions over domain S by defining for all  <span class="math">z \\in S \\setminus [n]</span>   <span class="math">u^</em>(z) = B_z(0)</span>  and  <span class="math">u(z) = B_z(1)</span> , and for  <span class="math">x \\in \\mathbb{F}_q</span>  let  <span class="math">u_x(z) = u^*(z) + xu(z)</span> . Since V is systematic, we define  $v_x(z) = \\langle v_x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{[k]}, z \\rangle<span class="math">  and thus extend  </span>v_x<span class="math">  to domain  </span>\\tilde{S}$ . By construction we know</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(x_0, u_{x_0}), (\\beta_0, u_{\\beta_0}), (\\gamma, u_{\\gamma})</span></div>

    <p class="text-gray-300">are collinear. So, in particular,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$(x_0, u_{x_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}), (\\beta_0, u_{\\beta_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}), (\\gamma, u_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}) \\in \\mathbb{F}_q \\times \\mathbb{F}_q^{\\tilde{S}}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">are likewise collinear, as a special case. By definition of  <span class="math">\\tilde{S}</span> , we get that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$(x_0, v_{x_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}), (\\beta_0, v_{\\beta_0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}), (\\gamma, v_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}) \\in \\mathbb{F}_q \\times \\mathbb{F}_q^{\\tilde{S}}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">are also collinear. Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> \\sigma<span class="math">  and S is  </span>\\sigma<span class="math"> -robust we conclude that  </span>v_{\\gamma}<span class="math">  is uniquely determined by  </span>v_{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{S}}$ . This allows us to conclude that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(x_0, v_{x_0}), (\\beta_0, v_{\\beta_0}), (\\gamma, v_{\\gamma}) \\in \\mathbb{F}_q \\times \\mathbb{F}_q^n</span></div>

    <p class="text-gray-300">are all collinear, recalling that  <span class="math">v_{x_0} \\in \\text{List}(u_{x_0}, V, \\delta)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, an  <span class="math">\\epsilon/2</span> -fraction of the  <span class="math">\\gamma \\in A</span>  have the "good" property that  <span class="math">(\\gamma, v_{\\gamma})</span>  is on the line passing through  <span class="math">(x_0, v_{x_0})</span>  and  <span class="math">(\\beta_0, v_{\\beta_0})</span> . Write this line as  <span class="math">v^<em> + xv</span>  and notice that for all "good"  <span class="math">\\gamma</span>  we have  <span class="math">v_{\\gamma} = v^</em> + \\gamma v</span> . Let  <span class="math">A&#x27; \\subseteq A</span>  denote the set of good elements for this line, recording that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\epsilon/2 \\ge 1/\\epsilon<span class="math"> . By definition of  </span>\\mathsf{List}(u_x, V, \\delta)<span class="math">  and the assumption  </span>v_x \\in \\mathsf{List}(u_x, V, \\delta)<span class="math"> , we have that  </span>\\Delta(u_x, v_x) < \\delta<span class="math">  for  </span>x \\in A'$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider the set  <span class="math">C \\subset [n]</span>  defined by</p>

    <div class="my-4 text-center"><span class="math-block">C = \\{ y \\in [n] \\mid u^*(y) = v^*(y) \\text{ AND } u(y) = v(y) \\}.</span></div>

    <p class="text-gray-300">For each  <span class="math">y \\in [n] \\setminus C</span>  there exists at most a single value of  <span class="math">x \\in \\mathbb{F}_q</span>  satisfying  <span class="math">u_x(y) = v_x(y)</span>  because</p>

    <div class="my-4 text-center"><span class="math-block">u_x(y) - v_x(y) = (u^*(y) - v^*(y)) + x \\cdot (u(y) - v(y))</span></div>

    <p class="text-gray-300">has at most one value x on which it vanishes. This implies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta \\geq \\mathbf{E}_{x \\in A'}[\\Delta_{[n]}(u_x, v_x)] \\geq \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[n] \\setminus C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n} \\cdot \\left(1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\geq \\left(1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n}\\right) \\cdot (1 - \\epsilon) \\geq 1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n} - \\epsilon.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rearranging, we get  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n} \\ge 1 - (\\delta + \\epsilon)$  and this completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now describe the algebraic hash function  <span class="math">H_x</span> .</p>

    <p class="text-gray-300">The description of the hash function requires fixing some choices of certain subspaces. For each  <span class="math">i \\in [0, r]</span>  we choose  <span class="math">\\mathbb{F}_2</span> -subspaces  <span class="math">L_0^{(i)}</span>  and  <span class="math">L^{(i)}</span> , satisfying the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">L_0^{(i)} \\subseteq L^{(i)}</span>  with  <span class="math">\\dim(L_0^{(i)}) = 1</span> ,</li>

      <li>2.  <span class="math">L^{(i+1)} = q^{(i)}(L^{(i)})</span> , where  <span class="math">q^{(i)}(X)</span>  is the subspace polynomial of  <span class="math">L_0^{(i)}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">q^{(i)}(X) = \\prod_{\\alpha \\in L_0^{(i)}} (X - \\alpha),</span></div>

    <p class="text-gray-300">thus this is an  <span class="math">\\mathbb{F}_2</span> -linear map with kernel  <span class="math">L_0^{(i)}</span> ). In particular,  <span class="math">\\dim(L^{(i+1)}) = \\dim(L^{(i)}) - 1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{S}^{(i)}</span>  denote the set of cosets of  <span class="math">L_0^{(i)}</span>  contained in  <span class="math">L^{(i)}</span> .</p>

    <p class="text-gray-300">Given  <span class="math">x \\in \\mathbb{F}</span>  and  <span class="math">f: L^{(i)} \\to \\mathbb{F}</span> , the hash of f with seed x is defined to be the function  <span class="math">H_x[f]: L^{(i+1)} \\to \\mathbb{F}</span>  as follows. For  <span class="math">s \\in L^{(i+1)}</span> , let  <span class="math">s_0, s_1 \\in L^{(i)}</span>  be the two roots of  <span class="math">q^{(i)}(X) - s</span> . Let  <span class="math">P_{f,s}(X) \\in \\mathbb{F}[X]</span>  be the unique degree  <span class="math">\\leq 1</span>  polynomial satisfying</p>

    <div class="my-4 text-center"><span class="math-block">P_{f,s}(s_0) = f(s_0),</span></div>

    <div class="my-4 text-center"><span class="math-block">P_{f,s}(s_1) = f(s_1).</span></div>

    <p class="text-gray-300">Then we define</p>

    <div class="my-4 text-center"><span class="math-block">H_x[f](s) = P_{f,s}(x). \\tag{19}</span></div>

    <p class="text-gray-300">Observe that  <span class="math">H_x<a href="s">f</a></span>  can be computed by querying f on the set  <span class="math">\\{s_0, s_1\\}</span>  (this set is a coset of  <span class="math">L_0^{(i)}</span> , and we denote it by  <span class="math">S_s^{(i)}</span> ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To understand  <span class="math">H_x</span>  better, it is instructive to see what it does to  <span class="math">\\mathsf{RS}^{(i)}</span> . Let  <span class="math">f \\in \\mathsf{RS}^{(i)}</span> . The underlying polynomial f(X) thus has degree at most  $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . We may write f(X) in base  </span>q^{(i)}(X)$  as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-33-1"></span> <span class="math-block">f(X) = a_0(X) + a_1(X)q^{(i)}(X) + \\dots + a_t(X)(q^{(i)}(X))^t,</span> (20)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where each  <span class="math">a_i(X)</span>  has degree at most 1, and  $t \\leq \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2<span class="math"> . Since the polynomials f(X) and  </span>P_{f,s}(X)<span class="math">  agree on the roots of q(X)-s, we get that  </span>f(X) \\equiv P_{f,s}(X) \\mod (q^{(i)}(X)-s)$ . From Equation (20), we get that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">P_{f,s}(X) = a_0(X) + a_1(X)s + \\dots + a_t(X)s^t.</span></div>

    <p class="text-gray-300">In particular, for all  <span class="math">x \\in \\mathbb{F}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">H_x[f](s) = P_{f,s}(x) = a_0(x) + a_1(x)s + \\dots + a_t(x)s^t,</span></div>

    <p class="text-gray-300">and thus</p>

    <p class="text-gray-300"><span class="math-block">H_x[f] \\in \\mathsf{RS}^{(i+1)}</span> .</p>

    <h2 id="sec-41" class="text-2xl font-bold">C Proof of Lemma 5.8 and Lemma 5.9</h2>

    <p class="text-gray-300">We first prove Lemma 5.8.</p>

    <p class="text-gray-300"><em>Proof.</em> Set  <span class="math">\\gamma = \\max(\\alpha^{(i)}, 1 - \\delta^*)</span> .</p>

    <p class="text-gray-300">For simplicity, denote  <span class="math">f^{(i)}</span>  by f.</p>

    <p class="text-gray-300">Recall the notation  <span class="math">P_{f,s}</span>  from the definition of the algebraic hash function  <span class="math">H_x</span>  in Section B. We have that for each  <span class="math">s \\in L^{(i+1)}</span> ,  <span class="math">H_x<a href="s">f</a> = P_{f,s}(x)</span>  is a linear function of x. Thus we can write  <span class="math">H_x[f] = u^<em> + xu</span>  for  <span class="math">u^</em>, u \\in \\mathbb{F}_q^{L^{(i+1)}}</span> , and for any fixed s, we have the formal polynomial equality  <span class="math">P_{f,s}(X) = u^*(s) + Xu(s)</span> .</p>

    <p class="text-gray-300">We are interested in bounding the probability of the event  <span class="math">\\beta^{(i+1)} &gt; \\gamma + \\epsilon</span> . In other words, we want to bound the probability that there exists a polynomial  <span class="math">Q(Y) \\in \\mathbb{F}_q[Y]</span>  with  <span class="math">\\deg(Q) &lt; d^{(i+1)} + 1</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bullet \\ \\operatorname{agree}_{\\theta^{(i+1)}}(u^*+xu,Q) &gt; \\gamma + \\epsilon,</span></li>

      <li><span class="math">Q(z^{(i)}) = B_{z^{(i)}}^{(i)}(x)</span> .</li>

    </ul>

    <p class="text-gray-300">This is exactly the scenario of Theorem 4.3. That Lemma tells us that if the probability in question is larger than  <span class="math">\\nu^<em></span> , then there exist polynomials  <span class="math">P(Y), P^</em>(Y)</span>  of degree  <span class="math">\\leq d^{(i+1)}</span>  and a set  <span class="math">T \\subseteq L^{(i+1)}</span>  such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{s \\in L^{(i+1)}} \\theta^{(i+1)} > \\gamma,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\bullet \\ u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_T = P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_T,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{P}(X,Y) \\triangleq P^*(Y) + X \\cdot P(Y)</span></div>

    <p class="text-gray-300">and notice that  <span class="math">\\deg_X(\\hat{P}) \\leq 1</span> ,  <span class="math">\\deg_Y(\\hat{P}) \\leq d^{(i+1)}</span> .</p>

    <p class="text-gray-300">Consider the polynomial  <span class="math">R(X) \\triangleq \\hat{P}(X, q^{(i)}(X))</span> . We have</p>

    <div class="my-4 text-center"><span class="math-block">\\deg(R) \\le 2d^{(i+1)} + 1 = d^{(i)} - 1 &lt; d^{(i)}.</span></div>

    <p class="text-gray-300">We claim that R agrees with f on  <span class="math">\\tilde{T} = \\bigcup_{s \\in T} S_s^{(i)}</span> .</p>

    <p class="text-gray-300">Take any  <span class="math">s \\in T</span>  and let  <span class="math">S_s^{(i)} = \\{s_0, s_1\\} \\in \\mathcal{S}^{(i)}</span>  be the pair of roots of the polynomial  <span class="math">q^{(i)}(X) - s</span> . First we show that the polynomials  <span class="math">P_{f,s}(X)</span>  and  <span class="math">\\hat{P}(X,s)</span>  are identical. Indeed,  <span class="math">\\hat{P}(X,s) = P^<em>(s) + XP(s) = u^</em>(s) + Xu(s) = P_{f,s}(X)</span> . It follows that</p>

    <div class="my-4 text-center"><span class="math-block">f(s_0) = \\hat{P}(s_0, s) = \\hat{P}(s_0, q^{(i)}(s_0)) = R(s_0)</span></div>

    <p class="text-gray-300">and similarly  <span class="math">f(s_1) = R(s_1)</span> . Therefore, R and f agree on  <span class="math">\\tilde{T}</span> , as claimed.</p>

    <p class="text-gray-300">We now use the above information to show that  <span class="math">\\alpha^{(i)} = \\mathsf{agree}_{\\eta^{(i)}}(f, R) &gt; \\gamma</span> , which contradicts the definition of  <span class="math">\\gamma</span> . Indeed,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\operatorname{agree}_{\\eta^{(i)}}(f,R) &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{r \\in L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(r) = R(r)} \\eta^{(i)}(r) \\\\ &\\geq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{r \\in \\tilde{T}} \\eta^{(i)}(r) \\\\ &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{s \\in T} \\sum_{r \\in S_s^{(i)}} \\eta^{(i)}(r) \\\\ &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{s \\in T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_s^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\theta^{(i)}(s) \\quad \\text{Since } \\theta(s) \\text{ equals the average of } \\eta(r) \\mid r \\in S_s^{(i)} \\\\ &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{s \\in T} \\theta^{(i)}(s) \\\\ &> \\gamma. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This is the desired contradiction.</p>

    <p class="text-gray-300">Next we prove Lemma 5.9.</p>

    <p class="text-gray-300"><em>Proof.</em> By definition,</p>

    <div class="my-4 text-center"><span class="math-block">\\beta^{(i)} = \\mathsf{agree}_{\\theta^{(i)}}(H_{x^{(i-1)}}[f^{(i-1)}], \\{P(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(P) \\leq d^{(i)} \\text{ and } P(z^{(i-1)}) = B_{z^{(i-1)}}^{(i-1)}(x^{(i-1)})\\})</span></div>

    <p class="text-gray-300">Next, by the properties of quotienting, Lemma 5.3,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\beta^{(i)} &amp;= \\mathsf{agree}_{\\theta^{(i)}}(H_{x^{(i-1)}}[f^{(i-1)}], \\{P(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(P) \\leq d^{(i)} \\text{ and } P(z^{(i-1)}) = B_{z^{(i-1)}}^{(i-1)}(x^{(i-1)}) \\}) \\\\ &amp;= \\mathsf{agree}_{\\theta^{(i)}}(\\mathsf{QUOTIENT}(H_{x^{(i-1)}}[f^{(i-1)}], z^{(i-1)}, B_{z^{(i-1)}}^{(i-1)}(x^{(i-1)})), \\{P(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(P) \\leq d^{(i)} - 1 \\}). \\end{split}</span></div>

    <p class="text-gray-300">Now observe that  <span class="math">\\eta^{(i)}</span>  is obtained from  <span class="math">\\theta^{(i)}</span>  by zeroing out coordinates in  <span class="math">E^{(i)}</span> , and the only coordinates where  <span class="math">f^{(i)}</span>  can differ from  <span class="math">\\mathsf{QUOTIENT}(H_{x^{(i-1)}}[f^{(i-1)}],z^{(i-1)},B_{z^{(i-1)}}^{(i-1)}(x^{(i-1)}))</span>  are in  <span class="math">E^{(i)}</span> . Thus:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\beta^{(i)} &amp;\\geq \\mathsf{agree}_{\\theta^{(i)}}(f^{(i)}, \\{P(Y) \\in \\mathbb{F}_q[Y] \\mid \\deg(P) \\leq d^{(i)} - 1\\}) \\\\ &amp;= \\mathsf{agree}_{\\theta^{(i)}}(f^{(i)}, \\mathsf{RS}^{(i)}) \\\\ &amp;= \\alpha^{(i)}. \\end{split}</span></div>

    <p class="text-gray-300">This completes the proof.</p>`;
---

<BaseLayout title="DEEP-FRI: Sampling Outside the Box Improves Soundness (2019/336)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/336
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
