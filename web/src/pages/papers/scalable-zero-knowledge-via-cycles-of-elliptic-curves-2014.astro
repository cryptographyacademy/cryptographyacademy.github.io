---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/595';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Scalable Zero Knowledge via Cycles of Elliptic Curves';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, Madars Virza';

const CONTENT = `    <p class="text-gray-300">(extended version)</p>

    <p class="text-gray-300">Eli Ben-Sasson</p>

    <p class="text-gray-300">Alessandro Chiesa</p>

    <p class="text-gray-300">eli@cs.technion.ac.il</p>

    <p class="text-gray-300">alexch@mit.edu</p>

    <p class="text-gray-300">Technion</p>

    <p class="text-gray-300">MIT</p>

    <p class="text-gray-300">Eran Tromer</p>

    <p class="text-gray-300">Madars Virza</p>

    <p class="text-gray-300">tromer@cs.tau.ac.il</p>

    <p class="text-gray-300">madars@mit.edu MIT</p>

    <p class="text-gray-300">Tel Aviv University</p>

    <p class="text-gray-300">September 18, 2016</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Non-interactive zero-knowledge proofs of knowledge for general NP statements are a powerful cryptographic primitive, both in theory and in practical applications. Recently, much research has focused on achieving an additional property, <em>succinctness</em>, requiring the proof to be very short and easy to verify. Such proof systems are known as <em>zero-knowledge succinct non-interactive arguments of knowledge</em> (zk-SNARKs), and are desired when communication is expensive, or the verifier is computationally weak.</p>

    <p class="text-gray-300">Existing zk-SNARK implementations have severe scalability limitations, in terms of space complexity as a function of the size of the computation being proved (e.g., running time of the NP statement's decision program). First, the size of the proving key is quasilinear in the upper bound on the computation size. Second, producing a proof requires "writing down" all intermediate values of the entire computation, and then conducting global operations such as FFTs.</p>

    <p class="text-gray-300">The bootstrapping technique of Bitansky et al. (STOC '13), following Valiant (TCC '08), offers an approach to scalability, by recursively composing proofs: proving statements about acceptance of the proof system's own verifier (and correctness of the program's latest step). Alas, recursive composition of known zk-SNARKs has never been realized in practice, due to enormous computational cost.</p>

    <p class="text-gray-300">Using new elliptic-curve cryptographic techniques, and methods for exploiting the proof systems' field structure and nondeterminism, we achieve the first zk-SNARK implementation that practically achieves recursive proof composition. Our zk-SNARK implementation runs random-access machine programs and produces proofs of their correct execution, on today's hardware, for any program running time. It takes constant time to generate the keys that support <em>all</em> computation sizes. Subsequently, the proving process only incurs a constant multiplicative overhead compared to the original computation's time, and an essentially-constant additive overhead in memory. Thus, our zk-SNARK implementation is the first to have a well-defined, albeit low, clock rate of "verified instructions per second".</p>

    <p class="text-gray-300">Keywords: computationally-sound proofs, proof-carrying data, zero knowledge, elliptic curves</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.1<br>Scalability limitations of prior zk-SNARK implementations<br></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.2<br>What we know from theory<br></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.3<br>Contributions<br></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.4<br>Summary of challenges and techniques</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.5<br>Follow-up work<br></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.6<br>Roadmap</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Preliminaries</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.2<br>Proof-carrying data<br></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.3<br>The bootstrapping approach</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">PCD-friendly preprocessing zk-SNARKs</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.1<br>PCD-friendly cycles of elliptic curves</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.2<br>Two-cycles based on MNT curves</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.3<br>A matched pair of preprocessing zk-SNARKs</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A higher-security 2-cycle<br>3.4<br></td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof-carrying data from PCD-friendly zk-SNARKs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.2<br>Construction</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.3<br>Security<br></td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constructions of arithmetic circuits</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2<br>Arithmetic circuits for collision-resistant hashing</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Scalable zk-SNARKs</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.1<br>Specifying a machine<br></td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.2<br>Construction summary</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.3<br>Arithmetic circuits for secure loads and stores<br></td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.4<br>The RAM compliance predicate</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6.5<br>The new zk-SNARK construction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Open problems</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acknowledgments</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">31</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.1<br>Arithmetic circuits</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A.2<br>Random-access machines</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">Pairings and elliptic curves</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.1<br>Pairings<br></td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.2<br>Elliptic curves</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Preprocessing zk-SNARKs for arithmetic circuit satisfiability</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">36</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C.2<br>Instantiations via elliptic curves</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C.3<br>The zk-SNARK verifier protocol<br></td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof-carrying data for arithmetic compliance predicates</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scalable zk-SNARKs for random-access machines</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">42</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                      |    |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">References</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">Non-interactive zero-knowledge proofs of knowledge <a href="#page-43-1">\\[BFM88,</a> <a href="#page-46-0">NY90,</a> [BDSMP91\\]](#page-43-2) are a powerful tool, studied extensively both in theoretical and applied cryptography. Recently, much research has focused on achieving an additional property, <em>succinctness</em>, that requires the proof to be very short and easy to verify. A proof system with this additional property is called a <em>zero-knowledge Succinct Non-interactive ARgument of Knowledge</em> (zk-SNARK). Because succinctness is a desirable, sometimes critical, property in numerous security applications, prior work has investigated zk-SNARK implementations. Unfortunately, all implementations to date suffer from severe scalability limitations, due to high space complexity, as we now explain.</p>

    <p class="text-gray-300">Expensive preprocessing. As in any non-interactive zero-knowledge proof, a zk-SNARK requires a onetime trusted setup of public parameters: a <em>key generator</em> samples a proving key (used to generate proofs) and a verification key (used to check proofs); the key pair is then published as the proof system's parameters.</p>

    <p class="text-gray-300">Most zk-SNARK constructions <a href="#page-45-0">\\[Gro10,</a> <a href="#page-46-1">Lip12,</a> <a href="#page-43-3">BCIOP13,</a> <a href="#page-45-1">GGPR13,</a> <a href="#page-46-2">PGHR13,</a> <a href="#page-43-4">BCGTV13a,</a> <a href="#page-46-3">Lip13,</a> <a href="#page-43-5">BCTV14,</a> <a href="#page-46-4">Lip14,</a> <a href="#page-45-2">KPPS</a>+14, <a href="#page-48-0">ZPK14,</a> <a href="#page-45-3">DFGK14,</a> <a href="#page-48-1">WSRBW15,</a> [BBFR15\\]](#page-43-6), including published implementations <a href="#page-46-2">\\[PGHR13,</a> <a href="#page-43-4">BCGTV13a,</a> <a href="#page-43-5">BCTV14,</a> <a href="#page-45-2">KPPS</a>+14, <a href="#page-48-0">ZPK14,</a> <a href="#page-48-1">WSRBW15,</a> [BBFR15\\]](#page-43-6), require <em>expensive preprocessing</em> during key generation. The key generator takes as input an upper bound on the computation size, e.g., an explicit NP decision circuit C output by a <em>circuit generator</em>; then, the key generator's space complexity, as well as the size of the output proving key, depends at least linearly on this upper bound. Essentially, the circuit C is explicitly laid out and encoded so as to produce the proof system's parameters.</p>

    <p class="text-gray-300">One way to mitigate the costs of expensive preprocessing is to make C universal, i.e., design C so that it can handle more than one choice of program [\\[BCTV14\\]](#page-43-5). Yet, C <em>still</em> depends on upper bounds on the program size and number of execution steps. Moreover, even if key generation is carried out only once per circuit C, the resulting large proving key must be stored, and accessed, <em>each time a proof is generated</em>. Prior implementations of zk-SNARKs quickly become space-bound already for modest computation sizes, e.g., with proving keys of over 4 GB for circuits of only 16 million gates [\\[BCTV14\\]](#page-43-5).<a href="#page-0-0">1</a></p>

    <p class="text-gray-300">Thus, expensive preprocessing severely limits scalability of a zk-SNARK.</p>

    <p class="text-gray-300">Space-intensive proof generation. Related in part to the aforementioned expensive preprocessing, the prover in all published zk-SNARK implementations has large space complexity. Essentially, the proving process requires writing down the <em>entire</em> computation (e.g., the evaluation of the circuit C) all at once, and then conduct a global computation (such as Fast Fourier transforms, or multi-exponentiations) based on it. In particular, if C expresses the execution of a program, then proving requires writing down the full trace of intermediate states throughout the program execution.</p>

    <p class="text-gray-300">Tradeoffs are possible, using block-wise versions of the global algorithms, and repeating the computation to reproduce segments of the trace. These decrease the prover's space complexity but significantly increase its time complexity, and thus do not adequately address scalability.</p>

    <p class="text-gray-300">Remark 1.1. Even when relaxing the goal (allowing interaction, "theorem batching", or non-zero-knowledge proofs), all published implementations of proof systems for outsourcing NP computations <a href="#page-47-0">\\[SBW11,</a> <a href="#page-47-1">SMBW12,</a> <a href="#page-47-2">SVPB</a>+12, <a href="#page-47-3">SBVB</a>+13, <a href="#page-44-0">BFRS</a>+13] also suffer from both of the above scalability limitations. (In contrast, when outsourcing P computations, there are implementations without expensive preprocessing: <a href="#page-44-1">\\[CMT12,</a> <a href="#page-47-4">TRMP12,</a> [Tha13\\]](#page-47-5) consider low-depth circuits, and [\\[CRR11\\]](#page-44-2) consider outsourcing to multiple provers at least one of which is honest.)</p>

    <p class="text-gray-300"><sup>1</sup>Even worse, the reported numbers are for "data at rest": the proving key consists of a list of elliptic-curve points, which are <em>compressed</em> when not in use. However, when the prover uses the proving key to produce a proof, the points are uncompressed (and represented via projective or Jacobian coordinates), and take about three times as much space in memory.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 What we know from theory</h3>

    <p class="text-gray-300">Ideally, we would like to implement a zk-SNARK that does not suffer from either of the scalability limitations mentioned in the previous section, i.e., a zk-SNARK where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key generation is <em>cheap</em> (i.e., its running time only depends on the security parameter) and <em>suffices for all computations</em> (of polynomial size). Such a zk-SNARK is called fully succinct.</li>

      <li>Proof generation is carried out <em>incrementally</em>, alongside the original computation, by updating, at each step, a proof of correctness of the computation so far. Such a zk-SNARK is called incrementally computable. Work in cryptography tells us that the above properties can be achieved in theoretical zk-SNARK constructions. Namely, building on the work of Valiant on incrementally-verifiable computation [\\[Val08\\]](#page-47-6) and the work of Chiesa and Tromer on proof-carrying data <a href="#page-44-3">\\[CT10,</a> [CT12\\]](#page-44-4), Bitansky et al. [\\[BCCT13\\]](#page-43-7) showed how to construct zk-SNARKs that are fully-succinct and incrementally-computable.</li>

    </ul>

    <p class="text-gray-300">Concretely, the approach of [\\[BCCT13\\]](#page-43-7) consists of a transformation that takes as input a <em>preprocessing</em> zk-SNARK (such as one from existing implementations), and <em>bootstraps</em> it, via recursive proof composition, into a new zk-SNARK that is fully-succinct and incrementally-computable. In recursive proof composition, a prover produces a proof about an NP statement that, among other checks, also ensures the accepting computation of the proof system's own verifier. In a zk-SNARK, proof verification is asymptotically cheaper than merely verifying the corresponding NP statement; so recursive proof composition is viable, in theory. In practice, however, this step introduces concretely enormous costs: even if zk-SNARK verifiers can be executed in just a few milliseconds on a modern desktop <a href="#page-46-2">\\[PGHR13,</a> [BCTV14\\]](#page-43-5), zk-SNARK verifiers still take millions of machine cycles to execute. Hence, known zk-SNARK implementations cannot achieve <em>even one step</em> of recursive proof composition in practical time. Thus, whether recursive proof composition can be realized in practice, with any reasonable efficiency, has so far remained an intriguing open question.</p>

    <p class="text-gray-300">Remark 1.2 (PCPs). Suitably instantiating Micali's "computationally-sound proofs" [\\[Mic00\\]](#page-46-5) yields fullysuccinct zk-SNARKs. However, it is not known how to also achieve incremental computation with this approach (without also invoking the aforementioned approach of Bitansky et al. [\\[BCCT13\\]](#page-43-7)). Indeed, [\\[Mic00\\]](#page-46-5) requires probabilistically-checkable proofs (PCPs) [\\[BFLS91\\]](#page-43-8), where one can achieve a prover that runs in quasilinear-time [\\[BCGT13b\\]](#page-43-9), but only by requiring space-intensive computations — again due to the need to write down the entire computation and conducting global operations on it.</p>

    <p class="text-gray-300">We present the first prototype implementation that practically achieves recursive composition of zk-SNARKs. This enables us to achieve the following results:</p>

    <p class="text-gray-300">(i) Scalable zk-SNARKs. We present the first implementation of a zk-SNARK that is fully succinct and incrementally computable. Our implementation follows the approach of Bitansky et al. [\\[BCCT13\\]](#page-43-7).</p>

    <p class="text-gray-300">Our zk-SNARK works for proving/verifying computations on a general notion of random-access machine. The key generator takes as input a <em>machine specification</em>, consisting of settings for random-access memory (number of addresses and number of bits at each address) and a CPU circuit, defining the machine's behavior. The keys sampled by the key generator support proving/verifying computations, of any polynomial length, on this machine. Thus, our zk-SNARK implementation directly supports many architectures (e.g., floating-point processors, SIMD-based processors, etc.) — one only needs to specify memory settings and a CPU circuit.</p>

    <p class="text-gray-300">Compared to the original machine computation, our zk-SNARK only imposes a constant multiplicative overhead in time and an essentially-constant additive overhead in space. Indeed, the proving process steps through the machine's computation, each time producing a new proof that the computation is correct so far, by relying on the prior proof; each proof asserts the satisfiability of a constant-size circuit, and requires few resources in time and space to produce. Our zk-SNARK scales, on today's hardware, to any computation size.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(ii) <strong>Proof-carrying data.</strong> The main tool in [BCCT13]'s approach is <em>proof-carrying data</em> (PCD) [CT10, CT12], a cryptographic primitive that encapsulates the security guarantees provided by recursive proof composition. Thus, as a stepping stone towards the aforementioned zk-SNARK implementation, we also achieve the first implementation of PCD, for arithmetic circuits.</li>

      <li>(iii) Evaluation on vnTinyRAM. We evaluate our zk-SNARK on a specific choice of random-access machine: vnTinyRAM, a simple RISC von Neumann architecture that is supported by the most recent preprocessing zk-SNARK implementation [BCTV14]. The evaluation confirms our expectations that our approach is slower for small computations but achieves scalability to large computations.</li>

    </ul>

    <p class="text-gray-300">We evaluated our prototype on 16-bit and 32-bit vnTinyRAM with 16 registers (as in [BCTV14]). For instance, for 32-bit vnTinyRAM, our prototype incrementally proves correct program execution at the cost of 26.2 seconds per program step, using a  <span class="math">55\\,\\mathrm{MB}</span>  proving key and  <span class="math">993\\,\\mathrm{MB}</span>  of additional memory. In contrast, for a T-step program, the system of [BCTV14] requires roughly  <span class="math">0.05 \\cdot T</span>  seconds, provided that roughly  <span class="math">3.1 \\cdot T\\,\\mathrm{MB}</span>  of main memory are available. Thus for T > 321 our system is more space-efficient, and the savings in space continue to grow as T increases. (These numbers are for an 80-bit security level.)</p>

    <p class="text-gray-300"><strong>The road ahead.</strong> Obtaining scalable zk-SNARKs is but one application of PCD. More generally, PCD enables efficient "distributed theorem proving", which has applications ranging from securing the IT supply chain, to information flow control, and to distributed programming-language semantics [CT10, CT12, CTV13]. Now that a first prototype of PCD has been achieved, these applications are waiting to be explored in practice.</p>

    <p class="text-gray-300"><strong>Remark 1.3</strong> (parametrization). In this work we describe a concrete implementation of a cryptographic system, whose efficiency scales with the security parameter and other quantities (e.g., wordsize of a machine, size of random-access memory, and so on). Since we make several concrete choices (e.g., fixing the security level at 80 bits, fixing vnTinyRAM's wordsize to 16 or 32 bits as in [BCTV14]) many asymptotic dependencies "collapse" to constants. We focus on scalability as a function of the computation size, i.e., the number of steps and amount of memory in the original program's execution on the concrete random-access machine.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.4 Summary of challenges and techniques</h4>

    <p class="text-gray-300">As we recall in Section 2, bootstrapping zk-SNARKs involves two main ingredients: a collision-resistant hash function and a preprocessing zk-SNARK. Practical implementations of both ingredients exist. So one may conclude that "practical bootstrapping" is merely a matter of stitching together implementations of these two ingredients. As we now explain, this conclusion is mistaken, because bootstrapping a zk-SNARK in practice poses several challenges that must be tackled in order to obtain any reasonable efficiency.</p>

    <p class="text-gray-300">Common theme: leverage field structure. The techniques that we employ to overcome efficiency barriers leverage the fact that the "native" NP language whose membership is proved/verified by the zk-SNARK is the satisfiability of  <span class="math">\\mathbb{F}</span> -arithmetic circuits, for a certain finite field  <span class="math">\\mathbb{F}</span> . While any NP statement can be reduced to  <span class="math">\\mathbb{F}</span> -arithmetic circuits, the proof system is most efficient for statements expressible as  <span class="math">\\mathbb{F}</span> -arithmetic circuits of small size. Prior work only partially leveraged this fact, by using circuits that conduct large-integer arithmetic or "pack" bits into field elements for non-bitwise checks (e.g., equality) [PGHR13, BCGTV13a, BFRS<sup>+</sup>13, BCTV14]. In this paper, we go further and, for improved efficiency, use circuits that conduct <em>field operations</em>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.4.1 Challenge: how to efficiently "close the loop"?</h4>

    <p class="text-gray-300">By far the most prominent challenge is efficiently "closing the loop". In the bootstrapping approach, each step requires proving a statement that (i) verifies the validity of previous zk-SNARK proofs; and (ii) checks another execution step. For recursive composition, this statement needs to be expressed as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C_{pcd}</span> , so that it can be proved using the very same zk-SNARK. In particular, we need to <em>implement the verifier</em> V as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C_V</span>  (a subcircuit of  <span class="math">C_{pcd}</span> ).</p>

    <p class="text-gray-300">In principle, constructing  <span class="math">C_V</span>  is possible, because circuits are a universal model of computation. And not just in principle: much research has been devoted to improve the efficiency and functionality of circuit generators in practice [SVPB+12, BCGT13a, SBVB+13, PGHR13, BCGTV13a, BCTV14]. Hence, a reasonable approach to construct  <span class="math">C_V</span>  is to apply a suitable circuit generator to a suitable software implementation of V.</p>

    <p class="text-gray-300">However, such an approach is likely to be inefficient. Circuit generators strive to support complex program computations, by providing ways to efficiently handle data-dependent control flow, memory accesses, and so on. Instead, verifiers in preprocessing zk-SNARK constructions are "circuit-like" programs, consisting of few pairing-based arithmetic checks that do not use complex data-dependent control flow or memory accesses.</p>

    <p class="text-gray-300">Thus, we want to avoid circuit generators, and somehow directly construct  <span class="math">C_V</span>  so that its size is not huge. As we shall explain (see Section 3), this is not merely a programmatic difficulty, but there are <em>mathematical obstructions</em> to constructing  <span class="math">C_V</span>  efficiently.</p>

    <p class="text-gray-300">Main technique: PCD-friendly cycles of elliptic curves. In our underlying preprocessing zk-SNARK, the verifier V consists mainly of operations in an elliptic curve over a field  <span class="math">\\mathbb{F}&#x27;</span> , and is thus expressed, most efficiently, as a  <span class="math">\\mathbb{F}&#x27;</span> -arithmetic circuit. We observe that if this field  <span class="math">\\mathbb{F}&#x27;</span>  is the same as the aforementioned native field  <span class="math">\\mathbb{F}</span>  of the zk-SNARK's statement, then recursive composition can be orders of magnitude more efficient than otherwise. Unfortunately, as we shall explain, the "field matching"  <span class="math">\\mathbb{F} = \\mathbb{F}&#x27;</span>  is mathematically impossible.</p>

    <p class="text-gray-300">In contrast, we show how to circumvent this obstruction by using multiple, suitably-chosen elliptic curves, that lie on a <em>PCD-friendly cycle</em>. For example, a PCD-friendly 2-cycle consists of two curves such that the (prime) size of the base field of one curve equals the group order of the other curve, and vice versa. Our implementation uses a PCD-friendly cycle of elliptic curves (found at a great computational expense) to attain zk-SNARKs that are <em>tailored</em> for recursive proof composition.</p>

    <p class="text-gray-300">Additional technique: nondeterministic verification of pairings. The zk-SNARK verifier involves, more specifically, several pairing-based checks over its elliptic curve. Yet, each pairing evaluation is very expensive, if not carefully performed. To further improve efficiency, we exploit the fact that the zk-SNARK supports NP statements, and provide a hand-optimized circuit implementation of the zk-SNARK verifier that leverages nondeterminism for improved efficiency. For instance, in our construction, we make heavy use of <em>affine</em> coordinates for both curve arithmetic and divisor evaluations [LMN10], because these are particularly efficient to <em>verify</em> (as opposed to <em>computing</em>, for which projective or Jacobian coordinates are known to be faster).</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">1.4.2 Challenge: how to efficiently verify collision-resistant hashing?</h4>

    <p class="text-gray-300">Bootstrapping zk-SNARKs uses, at multiple places, a collision-resistant hash function H and an arithmetic circuit  <span class="math">C_H</span>  for verifying computations of H. If not performed efficiently, this would be another bottleneck.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For instance, the aforementioned circuit  <span class="math">C_{pcd}</span> , besides verifying prior zk-SNARK proofs, is also tasked with verifying one step of machine execution. This involves not only checking the CPU execution but also the validity of loads and stores to random-access memory, done via memory-checking techniques based on Merkle trees [BEGKN91, BCGT13a]. Thus  <span class="math">C_{pcd}</span>  also needs to have a subcircuit to check Merkle-tree authentication paths. Constructing such circuits is straightforward, given a circuit  <span class="math">C_H</span>  for verifying computations of H. But the main question here is how to pick H so that  <span class="math">C_H</span>  can be small. Indeed, if random-access memory consists of A addresses, then checking an authentication path requires at least  $\\lceil \\log A \\rceil \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  gates. If  </span>C_H<span class="math">  is large, this subcircuit dwarfs the CPU, and &quot;wastes&quot; most of the size of  </span>C_{pcd}$  for a single load/store.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Merely picking some standard choice of hash function H (e.g., SHA-256 or Keccak) yields  <span class="math">C_H</span>  with tens of thousands of gates [PGHR13, BCGG<sup>+</sup>14], making hash verifications very expensive. Is this inherent?</p>

    <p class="text-gray-300"><strong>Additional technique: field-specific hashes.</strong> We select a hash H that is tailored to efficient verification in the field  <span class="math">\\mathbb{F}</span> . In our setting,  <span class="math">\\mathbb{F}</span>  has prime order p, so its additive group is isomorphic to  <span class="math">\\mathbb{Z}_p</span> . Thus, a natural approach is to let H be a <em>modular subset-sum</em> function over  <span class="math">\\mathbb{Z}_p</span> . For suitable parameter choices and for random coefficients, subset-sum functions are collision-resistant [Ajt96, GGH96]. In this paper we base all</p>

    <p class="text-gray-300">of our collision-resistant hashing on suitable subset sums, and thereby greatly reduce the burden of hashing.<sup>2</sup></p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.5 Follow-up work</h3>

    <p class="text-gray-300">Since the publication of the conference version of this work in CRYPTO 2014, there has been follow-up research building on it. Chiesa et al. [CTV15] extend and then apply PCD to construct zero-knowledge proofs for a class of cluster computations in which the proving process is itself a cluster computation. Costello et al. [CFHK+15] build on our idea of obtaining bounded recursive proof composition, using PCD-friendly <em>chains</em> of elliptic curves found via the Cocks–Pinch method (see Remark 3.2 and Footnote 8), in order to construct a zk-SNARK that is inbetween a preprocessing zk-SNARK and a fully-succinct one.</p>

    <p class="text-gray-300">The rest of this paper is organized as follows. In Section 2 we recall the main ideas of [BCCT13]'s approach. Then we discuss our construction in more detail, in the following three steps:</p>

    <p class="text-gray-300"><img src="_page_6_Figure_5.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">In Section 7, we evaluate our system on the machine vnTinyRAM. In Section 8, we discuss open problems.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2 Preliminaries</h3>

    <p class="text-gray-300">We give here the essential definitions needed for the technical discussions in the body of the paper; more detailed definitions can be found in the appendices (where some definitions are taken verbatim from [BCTV14]).</p>

    <p class="text-gray-300">We denote by  <span class="math">\\mathbb{F}</span>  a field, and by  <span class="math">\\mathbb{F}_n</span>  the field of size n. Throughout, we assume familiarity with finite fields; for background on these, see the book of Lidl and Niederreiter [LN97].</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}</span> , the <em>circuit satisfaction problem</em> of an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C \\colon \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  is defined by the relation  <span class="math">\\mathcal{R}_C = \\{(x,a) \\in \\mathbb{F}^n \\times \\mathbb{F}^h : C(x,a) = 0^l\\}</span> ; its language is  <span class="math">\\mathcal{L}_C = \\{x \\in \\mathbb{F}^n : \\exists \\ a \\in \\mathbb{F}^h, \\ C(x,a) = 0^l\\}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A <strong>preprocessing zk-SNARK</strong> for  <span class="math">\\mathbb F</span> -arithmetic circuit satisfiability (see, e.g., [BCIOP13]) is a triple of polynomial-time algorithms (G,P,V), called <em>key generator</em>, <em>prover</em>, and <em>verifier</em>. The key generator G, given a security parameter  <span class="math">\\lambda</span>  and an  <span class="math">\\mathbb F</span> -arithmetic circuit  <span class="math">C\\colon \\mathbb F^n\\times \\mathbb F^h\\to \\mathbb F^l</span> , samples a <em>proving key</em> pk and a <em>verification key</em> vk; these are the proof system's public parameters, which need to be generated only once per circuit. After that, anyone can use pk to generate non-interactive proofs for the language  <span class="math">\\mathcal L_C</span> , and anyone can use the vk to check these proofs. Namely, given pk and any  <span class="math">(x,a)\\in \\mathcal R_C</span> , the honest prover  <span class="math">P(\\operatorname{pk},x,a)</span>  produces a proof  <span class="math">\\pi</span>  attesting that  <span class="math">x\\in \\mathcal L_C</span> ; the verifier  <span class="math">V(\\operatorname{vk},x,\\pi)</span>  checks that  <span class="math">\\pi</span>  is a valid proof for  <span class="math">x\\in \\mathcal L_C</span> . A proof  <span class="math">\\pi</span>  is a proof of knowledge, as well as a (statistical) zero-knowledge proof. The succinctness property requires that  <span class="math">\\pi</span>  has length  <span class="math">O_\\lambda(1)</span>  and V runs in time  $O_\\lambda(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , where  </span>O_\\lambda<span class="math">  hides a (fixed) polynomial in  </span>\\lambda$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Appendix C for details.</p>

    <h2 id="sec-15" class="text-2xl font-bold">2.2 Proof-carrying data</h2>

    <p class="text-gray-300">Proof-carrying data (PCD) [CT10, CT12] is a cryptographic primitive that encapsulates the security guarantees obtainable via recursive composition of proofs. Since recursive proof composition naturally involves multiple (physical or virtual) parties, PCD is phrased in the language of a dynamically-evolving <em>distributed computation</em></p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>2</sup>We note that subset-sum functions were also used in [BFRS<sup>+</sup>13], but, crucially, they were <em>not</em> tailored to the field. This is a key difference in usage and efficiency. (E.g., our hash function can be verified in  <span class="math">\\leq 300</span>  gates, while [BFRS<sup>+</sup>13] report 13,000.)</p>

    <p class="text-gray-300">among mutually-untrusting computing nodes, who perform local computations, based on local data and previous messages, and then produce output messages. Given a <em>compliance predicate</em>  <span class="math">\\Pi</span>  to express local checks, the goal of PCD is to ensure that any given message z in the distributed computation is  <span class="math">\\Pi</span> -compliant, i.e., is consistent with a history in which each node's local computation satisfies  <span class="math">\\Pi</span> . This formulation includes as special cases incrementally-verifiable computation [Val08] and targeted malleability [BSW12].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concretely, a proof-carrying data (PCD) system is a triple of polynomial-time algorithms  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span> , called <em>key generator</em>, <em>prover</em>, and <em>verifier</em>. The key generator  <span class="math">\\mathbb{G}</span>  is given as input a predicate  <span class="math">\\Pi</span>  (specified as an arithmetic circuit), and outputs a proving key pk and a verification key vk; these keys allow anyone to prove/verify that a piece of data z is  <span class="math">\\Pi</span> -compliant. This is achieved by attaching a short and easy-to-verify proof to each piece of data. Namely, given pk, received messages  <span class="math">\\vec{z}_{\\text{in}}</span>  with proofs  <span class="math">\\vec{\\pi}_{\\text{in}}</span> , local data  <span class="math">z_{\\text{loc}}</span> , and a claimed outgoing message z,  <span class="math">\\mathbb{P}</span>  computes a new proof  <span class="math">\\pi</span>  to attach to z, which attests that z is  <span class="math">\\Pi</span> -compliant; the verifier  <span class="math">\\mathbb{V}(\\mathsf{vk}, z, \\pi)</span>  verifies that z is  <span class="math">\\Pi</span> -compliant. A proof  <span class="math">\\pi</span>  is a proof of knowledge, as well as a (statistical) zero-knowledge proof; succinctness requires that  <span class="math">\\pi</span>  has length  <span class="math">O_{\\lambda}(1)</span>  and  <span class="math">\\mathbb{V}</span>  runs in time  $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, note that since  <span class="math">\\Pi</span>  is expressed as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit for a given field  <span class="math">\\mathbb{F}</span> , the size of messages and local data are fixed; we denote these sizes by  <span class="math">n_{\\mathsf{msg}}, n_{\\mathsf{loc}} \\in \\mathbb{N}</span> . Similarly, the number of input messages is also fixed; we call this the arity, and denote it by  <span class="math">s \\in \\mathbb{N}</span> . Moreover, for convenience,  <span class="math">\\Pi</span>  also takes as input a flag  <span class="math">b_{\\mathsf{base}} \\in \\{0,1\\}</span>  denoting whether the node has no predecessors (i.e.,  <span class="math">b_{\\mathsf{base}}</span>  is a "base-case" flag). Overall,  <span class="math">\\Pi</span>  takes an input  <span class="math">(z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, b_{\\mathsf{base}}) \\in \\mathbb{F}^{n_{\\mathsf{msg}}} \\times \\mathbb{F}^{n_{\\mathsf{loc}}} \\times \\mathbb{F}^{s \\cdot n_{\\mathsf{msg}}} \\times \\mathbb{F}</span> .</p>

    <p class="text-gray-300">See Appendix D for details.</p>

    <p class="text-gray-300">Our implementation follows [BCCT13], which we now review. The approach consists of a transformation that, on input a preprocessing zk-SNARK and a collision-resistant hash function, outputs a scalable zk-SNARK. Thus, the input zk-SNARK is <em>bootstrapped</em> into one with improved scalability properties.</p>

    <p class="text-gray-300">So fix a preprocessing zk-SNARK (G, P, V) and collision-resistant function H. The goal is to construct a fully-succinct incrementally-computable zk-SNARK  <span class="math">(G^{\\star}, P^{\\star}, V^{\\star})</span>  for proving/verifying the correct execution on a given random-access machine  <span class="math">\\mathbf{M}</span> . Informally, we describe the transformation in four steps.</p>

    <p class="text-gray-300"><strong>Step 1: from zk-SNARKs to PCD.</strong> The first step, independent of M, is to construct a PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span> , by using the zk-SNARK (G, P, V). This step involves recursive composition of zk-SNARK proofs.</p>

    <p class="text-gray-300">Step 2: delegate the machine's memory. The second step is to reduce the footprint of the machine M, by delegating its random-access memory to an untrusted storage, via standard memory-checking techniques based on Merkle trees [BEGKN91, BCGT13a]. We thus modify M so that its "CPU" receives values loaded from memory as nondeterministic guesses, along with corresponding authentication paths that are checked against the root of a Merkle tree based on the hash function H. Thus, the entire state of M only consists of a (short) CPU state, and a (short) root of the Merkle tree that "summarizes" memory.<sup>3</sup></p>

    <p class="text-gray-300">Step 3: design a predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  for step-wise verification. The third step is to design a compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  that ensures that the only  <span class="math">\\Pi_{\\mathbf{M},H}</span> -compliant messages z are the ones that result from the correct execution of the (modified) machine  <span class="math">\\mathbf{M}</span> , one step at a time; this is analogous to the notion of incremental computation [Val08]. Crucially, because  <span class="math">\\Pi_{\\mathbf{M},H}</span>  is only asked to verify one step of execution at a time, we can implement  <span class="math">\\Pi_{\\mathbf{M},H}</span> 's requisite checks with a circuit of merely constant size.</p>

    <p class="text-gray-300">Step 4: construct new proof system. The new zk-SNARK  <span class="math">(G^<em>, P^</em>, V^<em>)</span>  is constructed as follows. The new key generator  <span class="math">G^</em></span>  is set to the PCD generator  <span class="math">\\mathbb G</span>  invoked on  <span class="math">\\Pi_{\\mathbf M,H}</span> . The new prover  <span class="math">P^*</span>  uses the PCD prover  <span class="math">\\mathbb P</span>  to prove correct execution of  <span class="math">\\mathbf M</span> , one step at a time and conducting the incremental distributed</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>3</sup> Similarly to [BCCT13] and our realization thereof, Braun et al. [BFRS<sup>+</sup>13] leverage memory-checking techniques based on Merkle trees [BEGKN91] for the purpose of enabling a circuit to "securely" load from and store to an untrusted storage. However, the systems' goals (delegation of MapReduce computations via a 2-move protocol) and techniques are different (cf. Footnote 2).</p>

    <p class="text-gray-300">computation "in his head". The new verifier  <span class="math">V^*</span>  simply uses the PCD verifier  <span class="math">\\mathbb{V}</span>  to verify  <span class="math">\\Pi_{\\mathbf{M},H}</span> -compliance. In sum, since  <span class="math">\\Pi_{\\mathbf{M},H}</span>  is small and suffices for all computations, the new zk-SNARK is scalable: it is fully succinct; moreover, because the new prover computes a proof for each new step based on the previous one, it is also incrementally computable. (See Appendix E for definitions of these properties.)</p>

    <p class="text-gray-300">Our goal is to realize the above approach in a practical implementation.</p>

    <p class="text-gray-300"><strong>Security of recursive proof composition.</strong> Security in [BCCT13] is proved by using the <em>proof-of-knowledge property</em> of zk-SNARKs; we refer the interested reader to [BCCT13] for details. One aspect that must be addressed from a theoretical standpoint is the <em>depth</em> of composition. Depending on assumption strength, one may have to recursively compose proofs in "proof trees above the message chain", rather than along the chain. From a practical perspective we make the heuristic assumption that depth of composition does not affect security of the zk-SNARK, because no evidence suggests otherwise for the constructions that we use.</p>

    <p class="text-gray-300">We first construct preprocessing zk-SNARKs that are tailored for efficient recursive composition of proofs. Later, in Section 5, we discuss how we use such zk-SNARKs to construct a PCD system.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a finite field, and (G,P,V) a preprocessing zk-SNARK for  <span class="math">\\mathbb{F}</span> -arithmetic satisfiability. The idea of recursive proof composition is to prove/verify satisfiability of an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C_{pcd}</span>  that checks the validity of previous proofs (among other things). Thus, we need to implement the verifier V as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C_V</span> , to be used as a sub-circuit of  <span class="math">C_{pcd}</span> .</p>

    <p class="text-gray-300">How to write  <span class="math">C_V</span>  depends on the algorithm of V, which in turn depends on which elliptic curve is used to instantiate the pairing-based zk-SNARK. For prime r, in order to prove statements about  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit satisfiability, one instantiates (G, P, V) using an elliptic curve E defined over some finite field  <span class="math">\\mathbb{F}_q</span> , where the group  <span class="math">E(\\mathbb{F}_q)</span>  of  <span class="math">\\mathbb{F}_q</span> -rational points has order  <span class="math">r=\\#E(\\mathbb{F}_q)</span>  (or, more generally, r divides  <span class="math">\\#E(\\mathbb{F}_q)</span> ). Then, all of V's arithmetic computations are over  <span class="math">\\mathbb{F}_q</span> , or extensions of  <span class="math">\\mathbb{F}_q</span>  up to degree k, where k is the embedding degree of E with respect to r (i.e., the smallest integer k such that r divides  <span class="math">q^k-1</span> ). (See Appendix C.2.)</p>

    <p class="text-gray-300">We motivate our approach by first describing two "failed attempts".</p>

    <p class="text-gray-300">Attempt #1: pick curve with q = r. Ideally, we would like to select a curve E with q = r, so that V's arithmetic is over the <em>same field</em> for which V's native NP language is defined. Unfortunately, this cannot happen: the condition that E has embedding degree k with respect to r implies that r divides  <span class="math">q^k - 1</span> , which implies that  <span class="math">q \\neq r</span> . The same implication holds even if  <span class="math">E(\\mathbb{F}_q)</span>  has a non-prime order n and the prime r (with respect to which k is defined) only divides n. So, while appealing, this idea cannot even be instantiated.<sup>4</sup></p>

    <p class="text-gray-300">Attempt #2: long arithmetic. Since we are stuck with  <span class="math">q \\neq r</span> , we may consider doing "long arithmetic": simulating  <span class="math">\\mathbb{F}_q</span>  operations via  <span class="math">\\mathbb{F}_r</span>  operations, by working with bit chunks to perform integer arithmetic, and modding out by q when needed. Alas, having to work at the "bit level" implies a blowup on the order of  <span class="math">\\log q</span>  compared to native arithmetic. So, while this approach can at least be instantiated, it is very expensive.<sup>5</sup></p>

    <p class="text-gray-300">Our approach: cycle through multiple curves. We formulate, and instantiate, a new property for elliptic curves that enables us to completely circumvent long arithmetic, even with  <span class="math">q \\neq r</span> . In short, our idea is to base recursive proof composition, not on a single zk-SNARK, but on <em>multiple</em> zk-SNARKs, each instantiated on a different elliptic curve, that <em>jointly</em> satisfy a special property.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>4</sup>Besides, the condition  <span class="math">q = \\#E(\\mathbb{F}_q)</span>  is undesirable even when not ruled out (e.g., when  <span class="math">k = \\infty</span> ): on such curves, known as <em>anomalous</em>, discrete logarithms can be computed in polynomial time via the SSSA attack [Sem98, Sma99, SA98].</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>5</sup>Showing that it is <em>provably</em> expensive requires stronger circuit lower bounds than currently known [Raz87, Smo87, GLS09].</p>

    <p class="text-gray-300">For the simplest case, suppose we have two primes  <span class="math">q_{\\alpha}</span>  and  <span class="math">q_{\\beta}</span> , and elliptic curves  <span class="math">E_{\\alpha}/\\mathbb{F}_{q_{\\alpha}}</span>  and  <span class="math">E_{\\beta}/\\mathbb{F}_{q_{\\beta}}</span>  such that  <span class="math">q_{\\alpha}=\\#E_{\\beta}(\\mathbb{F}_{q_{\\beta}})</span>  and  <span class="math">q_{\\beta}=\\#E_{\\alpha}(\\mathbb{F}_{q_{\\alpha}})</span> , i.e., the size of the base field of one curve equals the group order of the other curve, and vice versa. We then construct two preprocessing zk-SNARKs  <span class="math">(G_{\\alpha},P_{\\alpha},V_{\\alpha})</span>  and  <span class="math">(G_{\\beta},P_{\\beta},V_{\\beta})</span> , respectively instantiated on the two curves  <span class="math">E_{\\alpha}/\\mathbb{F}_{q_{\\alpha}}</span>  and  <span class="math">E_{\\beta}/\\mathbb{F}_{q_{\\beta}}</span> .</p>

    <p class="text-gray-300">Now note that  <span class="math">(G_{\\alpha}, P_{\\alpha}, V_{\\alpha})</span>  works for  <span class="math">\\mathbb{F}_{q_{\\beta}}</span> -arithmetic circuit satisfiability, but all of  <span class="math">V_{\\alpha}</span> 's arithmetic computations are over  <span class="math">\\mathbb{F}_{q_{\\alpha}}</span>  (or extensions thereof); while  <span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span>  works for  <span class="math">\\mathbb{F}_{q_{\\alpha}}</span> -arithmetic circuits, but  <span class="math">V_{\\beta}</span> 's arithmetic computations are over  <span class="math">\\mathbb{F}_{q_{\\beta}}</span>  (or extensions thereof). Instead of having each zk-SNARK handle statements about its own verifier, as in the prior attempts (i.e., writing  <span class="math">V_{\\alpha}</span>  as a  <span class="math">\\mathbb{F}_{q_{\\beta}}</span> -arithmetic circuit, or  <span class="math">V_{\\beta}</span>  as a  <span class="math">\\mathbb{F}_{q_{\\alpha}}</span> -arithmetic circuit), we instead let each zk-SNARK handle statements about the verifier of the other zk-SNARK. That is, we write  <span class="math">V_{\\alpha}</span>  as a  <span class="math">\\mathbb{F}_{q_{\\alpha}}</span> -arithmetic circuit  <span class="math">C_{V_{\\alpha}}</span> , and  <span class="math">V_{\\beta}</span>  as a  <span class="math">\\mathbb{F}_{q_{\\beta}}</span> -arithmetic circuit  <span class="math">C_{V_{\\beta}}</span> .</p>

    <p class="text-gray-300">We can then perform recursive proof composition by <em>alternating</em> between the two proof systems. Roughly, one can use  <span class="math">P_{\\alpha}</span>  to prove successful verification of a proof by  <span class="math">C_{V_{\\beta}}</span>  and, conversely,  <span class="math">P_{\\beta}</span>  to prove successful verification of a proof by  <span class="math">C_{V_{\\alpha}}</span> . Doing so in alternation ensures that fields "match up", and no long arithmetic is needed. (This sketch omits key technical details; see Section 4.)</p>

    <p class="text-gray-300">Since  <span class="math">E_{\\alpha}</span>  and  <span class="math">E_{\\beta}</span>  facilitate constructing PCD, we say that  <span class="math">(E_{\\alpha}, E_{\\beta})</span>  is a <em>PCD-friendly 2-cycle of elliptic curves</em>. More generally, the idea extends to cycling through  <span class="math">\\ell</span>  curves satisfying this definition:</p>

    <p class="text-gray-300"><span id="page-9-2"></span><strong>Definition 3.1.</strong> Let  <span class="math">E_0, \\ldots, E_{\\ell-1}</span>  be elliptic curves, respectively defined over finite fields  <span class="math">\\mathbb{F}_{q_0}, \\ldots, \\mathbb{F}_{q_{\\ell-1}}</span> , with each  <span class="math">q_i</span>  a prime. We say that  <span class="math">(E_0, \\ldots, E_{\\ell-1})</span>  is a <strong>PCD-friendly cycle</strong> of length  <span class="math">\\ell</span>  if each  <span class="math">E_i</span>  is pairing friendly and, moreover,  <span class="math">\\forall i \\in \\{0, \\ldots, \\ell-1\\}, \\ q_i = \\#E_{i+1 \\mod \\ell}(\\mathbb{F}_{q_{i+1} \\mod \\ell})</span> .</p>

    <p class="text-gray-300">To our knowledge this notion has not been explicitly sought before.<sup>6</sup> Though, fortunately, a family that satisfies this notion is already known, as discussed in the next subsection.</p>

    <p class="text-gray-300"><span id="page-9-1"></span><strong>Remark 3.2</strong> (relaxation). One can relax Definition 3.1 to require a weaker, but still useful, condition: for each  <span class="math">i \\in \\{0, \\dots, \\ell-1\\}</span> ,  <span class="math">q_i</span>  divides  <span class="math">\\#E(\\mathbb{F}_{i+1 \\bmod \\ell})</span> . Even if weaker, this condition is <em>still</em> very strong. For instance, it implies that each curve  <span class="math">E_i</span>  has  <span class="math">\\rho</span> -value  <span class="math">\\approx 1</span> , i.e., that each  <span class="math">E_i</span>  has near-prime order. Constructing pairing-friendly curves with such good  <span class="math">\\rho</span> -values is challenging even without the cycle condition!</p>

    <p class="text-gray-300">Hence, generic methods such as Cocks–Pinch [CP01] and Dupont–Enge–Morain [DEM05], which yield (with high probability) curves with  <span class="math">\\rho</span> -values > 1 (specifically,  <span class="math">\\approx 2</span> ), cannot be used to construct PCD-friendly cycles.<sup>8</sup> This also applies to generalizations of the Cocks–Pinch method [BLS03, BW05, SB06] that improve the  <span class="math">\\rho</span> -value to be  <span class="math">1 &lt; \\rho &lt; 2</span> . In this work we do not investigate the above relaxation because, we can fulfill Definition 3.1 with  <span class="math">\\ell = 2</span> , the minimal length possible.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">3.2 Two-cycles based on MNT curves</h4>

    <p class="text-gray-300">We construct pairs of elliptic curves,  <span class="math">E_4</span>  and  <span class="math">E_6</span> , that form PCD-friendly 2-cycles  <span class="math">(E_4, E_6)</span> . These are MNT curves [MNT01] of embedding degrees 4 and 6. Our construction also ensures that  <span class="math">E_4</span>  and  <span class="math">E_6</span>  are sufficiently 2-adic (see below), a desirable property for efficient implementations of preprocessing zk-SNARKs.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>6</sup>Definition 3.1 is reminiscent, but different from, the notion of an <em>aliquot cycle</em> of elliptic curves by Silverman and Stange [SS11]. An aliquot cycle considers a <em>single</em> curve (over  <span class="math">\\mathbb Q</span> ) reduced at  <span class="math">\\ell</span>  primes, rather than  <span class="math">\\ell</span>  curves, and does not require pairing-friendliness.</p>

    <p class="text-gray-300"><sup>7</sup>For each  <span class="math">i \\in \\{0, \\dots, \\ell-1\\}</span> , the condition that  <span class="math">q_{i-1}</span>  divides # <span class="math">E(\\mathbb F_i)</span>  implies, via the Hasse bound, that  <span class="math">h_i q_{i-1} \\leq q_i \\cdot (1+2/\\sqrt{q_i})</span>  for some cofactor  <span class="math">h_i \\in \\mathbb N</span> ; hence  <span class="math">\\log q_{i-1} \\leq \\log q_i + \\log(1+2/\\sqrt{q_i}) - \\log h_i</span> , and thus  <span class="math">\\frac{\\log q_{i-1}}{\\log q_i} \\leq 1 + \\frac{\\log(1+2/\\sqrt{q_i})}{\\log q_i} \\leq 1 + \\frac{2}{\\sqrt{q_i}\\log q_i} = 1 + a_i</span>  for  <span class="math">a_i := \\frac{2}{\\sqrt{q_i}\\log q_i}</span> . Note that each  <span class="math">a_i</span>  is exponentially small. Therefore, for each  <span class="math">i \\in \\{0, \\dots, \\ell-1\\}</span> , we can upper bound the  <span class="math">\\rho</span> -value of  <span class="math">E_i</span> , equal to  <span class="math">\\frac{\\log q_i}{\\log q_{i-1}}</span> , as follows:  <span class="math">\\frac{\\log q_i}{\\log q_{i-1}} = \\prod_{j \\neq i} \\frac{\\log q_{j-1}}{\\log q_j} \\leq \\prod_{j \\neq i} (1 + a_j) = 1 + \\sum_{j \\neq i} a_j + \\prod_{j \\neq i} a_j</span> . In sum, the  <span class="math">\\rho</span> -value of  <span class="math">E_i</span>  is upper bounded by  <span class="math">1 + \\epsilon_i</span> , where the quantity  <span class="math">\\epsilon_i := \\sum_{j \\neq i} a_j + \\prod_{j \\neq i} a_j</span>  is exponentially small.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>8</sup> At best, such methods can be used to construct PCD-friendly "chains", which can be used to reduce the space complexity of preprocessing zk-SNARKs via a limited application of recursive proof composition. But the large  <span class="math">\\rho</span> -values would imply that each recursive composition roughly doubles the cost of the zk-SNARK so that long chains do not seem to be advantageous.</p>

    <p class="text-gray-300">MNT curves and the KT correspondence. Miyaji, Nakabayashi, and Takano [MNT01] characterized prime-order elliptic curves with embedding degrees k=3,4,6; such curves are now known as MNT curves. Given an elliptic curve E defined over a prime field  <span class="math">\\mathbb{F}_q</span> , they gave necessary and sufficient conditions on the pair (q,t), where t is the trace of E over  <span class="math">\\mathbb{F}_q</span> , for E to have embedding degree k=3,4,6. We refer to an MNT curve with embedding degree k as an MNTk curve. Karabina and Teske [KT08] proved an explicit 1-to-1 correspondence between MNT4 and MNT6 curves:</p>

    <p class="text-gray-300"><strong>Theorem 3.3</strong> ([KT08]). Let r, q > 64 be primes. Then the following two conditions are equivalent:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. r and q represent an elliptic curve  <span class="math">E_4/\\mathbb{F}_q</span>  with embedding degree k=4 and  <span class="math">r=\\#E(\\mathbb{F}_q)</span> ;</li>

      <li>2. r and q represent an elliptic curve  <span class="math">E_6/\\mathbb{F}_r</span>  with embedding degree k=6 and  <span class="math">q=\\#E(\\mathbb{F}_r)</span> .</li>

    </ul>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">PCD-friendly 2-cycles on MNT curves. The above theorem implies that:</h3>

    <p class="text-gray-300">Each MNT6 curve lies on a PCD-friendly 2-cycle with the corresponding MNT4 curve (and vice versa).</p>

    <p class="text-gray-300">Thus, a PCD-friendly 2-cycle can be obtained by constructing an MNT4 curve and its corresponding MNT6 curve. Next, we explain at high level how this can be done.</p>

    <p class="text-gray-300"><strong>Constructing PCD-friendly 2-cycles.</strong> First, we recall the only known method to construct MNTk curves [MNT01]. It consists of two steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step I: curve discovery. Find suitable  <span class="math">(q,t) \\in \\mathbb{N}^2</span>  such that there exists an ordinary elliptic curve  <span class="math">E/\\mathbb{F}_q</span>  of prime order r := q+1-t and embedding degree k.</li>

      <li>Step II: curve construction. Starting from (q, t), use the Complex-Multiplication method (CM method) [AM93] to compute the equation of E over  <span class="math">\\mathbb{F}_q</span> .</li>

    </ul>

    <p class="text-gray-300">The complexity of Step II depends on the discriminant D of E, which is the square-free part of  <span class="math">4q-t^2</span> . At present, the CM method is feasible for discriminants D up to size  <span class="math">10^{16}</span>  [Sut12]. Thus, Step I is conducted in a way that results in candidate parameters (q,t) inducing relatively-small discriminants, to aid Step II. (Instead, "most" (q,t) induce a discriminant D of size  <span class="math">\\sqrt{q}</span> , which is too large to handle.) Concretely, [MNT01] derived, for  <span class="math">k \\in \\{3,4,6\\}</span>  and discriminant D, Pell-type equations whose solutions yield candidate parameters (q,t) for MNTk curves  <span class="math">E/\\mathbb{F}_q</span>  of trace t and discriminant t. So Step I can be performed by iteratively solving the MNTk Pell-type equation, for increasing discriminant size, until a suitable (q,t) is found.</p>

    <p class="text-gray-300">The above strategy can be extended, in a straightforward way, to construct PCD-friendly 2-cycles. First perform Step I to obtain suitable parameters  <span class="math">(q_4,t_4)</span>  for an MNT4 curve  <span class="math">E_4/\\mathbb{F}_{q_4}</span> ; the parameters  <span class="math">(q_6,t_6)</span>  for the corresponding MNT6 curve  <span class="math">E_6/\\mathbb{F}_{q_6}</span>  are  <span class="math">q_6:=q_4+1-t_4</span>  and  <span class="math">t_6:=2-t_4</span> . Then perform Step II for  <span class="math">(q_4,t_4)</span>  to compute the equation of  <span class="math">E_4</span> , and then also for  <span class="math">(q_6,t_6)</span>  to compute that of  <span class="math">E_6</span> . The complexity in both cases is the same: one can verify that  <span class="math">E_4</span>  and  <span class="math">E_6</span>  have the same discriminant. The two curves  <span class="math">E_4</span>  and  <span class="math">E_6</span>  form a PCD-friendly 2-cycle  <span class="math">(E_4,E_6)</span> .</p>

    <p class="text-gray-300"><strong>Suitable cycle parameters.</strong> We now explain what "suitable  <span class="math">(q_4, t_4)</span> " means in our context, by specifying a list of additional properties that we wish a PCD-friendly cycle to satisfy.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bit lengths. In a 2-cycle  <span class="math">(E_4, E_6)</span> , the curve  <span class="math">E_4</span>  is "less secure" than  <span class="math">E_6</span> , because  <span class="math">E_4</span>  has embedding degree 4 while  <span class="math">E_6</span>  has embedding degree 6. Thus, we use  <span class="math">E_4</span>  to set lower bounds on bit lengths. Since we aim at a security level of 80 bits, we need  <span class="math">r_4 \\ge 2^{160}</span>  and  <span class="math">q_4 \\ge 2^{240}</span>  (so that  <span class="math">\\sqrt{r_4} \\ge 2^{80}</span>  and  <span class="math">q_4^4 \\ge 2^{960}</span>  [FST10]). Since  <span class="math">\\log r_4 \\approx \\log q_4</span>  for MNT4 curves, we only need to ensure that  <span class="math">q_4</span>  has at least 240 bits.</li>

      <li>Towering friendliness. We restrict our focus to moduli  <span class="math">q_4</span>  and  <span class="math">q_6</span>  that are towering friendly (i.e., congruent to 1 modulo 6) [BS10]; this improves the efficiency of arithmetic in  <span class="math">\\mathbb{F}_{q_4}^4</span>  and  <span class="math">\\mathbb{F}_{q_6}^6</span>  (and their subfields).</li>

    </ul>

    <p class="text-gray-300"><sup>&</sup>lt;sup>9</sup>Alas, since  <span class="math">E_4</span>  has a low embedding degree, the ECDLP in  <span class="math">E(\\mathbb{F}_{q_4})</span>  and DLP in  <span class="math">\\mathbb{F}_{q_4}^4</span>  are "unbalanced": the former provides 120 bits of security, while the latter only 80. Moreover, the same is true for  <span class="math">E_6</span> : the ECDLP in  <span class="math">E(\\mathbb{F}_{q_6})</span>  provides 120 bits of security, while the DLP in  <span class="math">\\mathbb{F}_{q_4}^6</span>  only 80. Finding PCD-friendly cycles without these inefficiencies is an open problem (see Section 8).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">• 2-adicity. As discussed in [BCGTV13a, BCTV14], if a pairing-based preprocessing zk-SNARK (G, P, V) is instantiated with an elliptic curve  <span class="math">E/\\mathbb{F}_q</span>  of prime order r (or with  <span class="math">\\#E(\\mathbb{F}_q)</span>  divisible by a prime r), it is important, for efficiency reasons, that r-1 is divisible by a large power of 2, i.e.,  <span class="math">\\nu_2(r-1)</span>  is large. (Recall that  <span class="math">\\nu_2(n)</span> , the 2-adic order of n, is the largest power of 2 dividing n.) Concretely, if G is invoked on an  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit C, it is important that  $\\nu_2(r-1) \\geq \\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> . We call  </span>\\nu_2(r-1)$  the 2-adic order of E, or the 2-adicity of E. (See Appendix C.2 for more details.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So let  <span class="math">\\ell_4</span>  and  <span class="math">\\ell_6</span>  be the target values for  <span class="math">\\nu_2(r_4-1)</span>  and  <span class="math">\\nu_2(r_6-1)</span> . One can verify that, for any MNT-based PCD-friendly 2-cycle  <span class="math">(E_4,E_6)</span> , it holds that  <span class="math">\\nu_2(r_4-1)=2\\cdot\\nu_2(r_6-1)</span> ; in other words,  <span class="math">E_4</span>  is always "twice as 2-adic" as  <span class="math">E_6</span> . Thus, to achieve the target 2-adic orders, it suffices to ensure that  <span class="math">\\nu_2(r_4-1)\\geq \\max\\{\\ell_4,2\\ell_6\\}</span>  (where, as before,  <span class="math">r_4:=q_4+1-t_4</span> ). As we shall see (in Section 5), in this paper it will suffice to take  <span class="math">\\nu_2(r_4-1)\\geq 34</span> .</p>

    <p class="text-gray-300">Of the above properties, the most restrictive one is 2-adicity, because it requires seeing enough curves until, "by sheer statistics", one finds  <span class="math">(q_4,t_4)</span>  with a high-enough value for  <span class="math">\\nu_2(r_4-1)</span> . Collecting enough samples is costly because, as discriminant size increases, the density of MNT curves decreases: empirically, one finds that the number MNT curves with discriminant  <span class="math">D \\leq N</span>  is (approximately) less than  <span class="math">\\sqrt{N}</span>  [KT08].</p>

    <p class="text-gray-300">An extensive computation for a suitable cycle. Overall, finding and constructing a suitable cycle required a substantial computational effort.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Cycle discovery. In order to find suitable parameters for a cycle, we explored a large space: all discriminants up to  <span class="math">1.1 \\cdot 10^{15}</span> , requiring about 610,000 core-hours on a large cluster of modern x86 servers. Our search algorithm is a modification of [KT08, Algorithm 3]. Among all the 2-cycles that we found, we selected parameters  <span class="math">(q_4, t_4)</span>  and  <span class="math">(q_6, t_6)</span>  for a 2-cycle  <span class="math">(E_4, E_6)</span>  of curves such that: (i)  <span class="math">q_4, q_6</span>  each have 298 bits; (ii)  <span class="math">q_4, q_6</span>  are towering friendly; and (iii)  <span class="math">\\nu_2(r_4 1) = 34</span>  and  <span class="math">\\nu_2(r_6 1) = 17</span> . The bit length of  <span class="math">q_4, q_6</span>  is higher than the lower bound of 240; we entail this cost so to pick a rare cycle with high 2-adicity, which helps the zk-SNARK's efficiency more than the slowdown incurred by the higher bit length.</li>

      <li>Cycle construction. Both  <span class="math">E_4</span>  and  <span class="math">E_6</span>  have discriminant 614144978799019, whose size requires state-of-the-art techniques in the CM method [Sut11, ES10, Sut12] in order to explicitly construct the curves. Below, we report the parameters and equations for the 2-cycle  <span class="math">(E_4, E_6)</span>  that we selected.</li>

    </ul>

    <pre><code class="language-text">\\begin{split} E_4/\\mathbb{F}_{q_4}: y^2 &amp;= x^3 + A_4x + B_4 \\text{ where} \\\\ A_4 &amp;= 2, \\\\ B_4 &amp;= 423894536526684178289416011533888240029318103673896002803341544124054745019340795360841685, \\\\ q_4 &amp;= 475922286169261325753349249653048451545124879242694725395555128576210262817955800483758081. \\end{split}</code></pre>

    <p class="text-gray-300"><span class="math-block">E_6/\\mathbb{F}_{q_6}: y^2 = x^3 + A_6x + B_6</span>  where  <span class="math">A_6 = 11</span> .</p>

    <p class="text-gray-300"> <span class="math">B_6 = 106700080510851735677967319632585352256454251201367587890185989362936000262606668469523074, \\\\ q_6 = 475922286169261325753349249653048451545124878552823515553267735739164647307408490559963137.</span></p>

    <p class="text-gray-300"><strong>Security.</strong> One may wonder if curves lying on PCD-friendly cycles are weak (e.g., in terms of DL hardness). Yet, MNT4 and MNT6 curves of suitable parameters are widely believed to be secure, and they <em>all</em> fall in PCD-friendly 2-cycles. The additional requirement of high 2-adicity is not known to cause weakness either.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.3 A matched pair of preprocessing zk-SNARKs</h3>

    <p class="text-gray-300">Based on the PCD-friendly cycle  <span class="math">(E_4, E_6)</span> , we designed and constructed two preprocessing zk-SNARKs for arithmetic circuit satisfiability:  <span class="math">(G_4, P_4, V_4)</span>  based on the curve  <span class="math">E_4</span> , and  <span class="math">(G_6, P_6, V_6)</span>  on  <span class="math">E_6</span> . The software</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>10</sup>The authors are grateful to Andrew V. Sutherland for generous help in running the CM method on such a large discriminant.</p>

    <p class="text-gray-300">implementation follows [\\[BCTV14\\]](#page-43-5), the fastest preprocessing zk-SNARK implementation for circuits at the time of writing. We thus adapt the techniques in [\\[BCTV14\\]](#page-43-5) to our algebraic setting, which consists of the two MNT curves E<sup>4</sup> and E6, and achieve efficient implementations of (G4, P4, V4) and (G6, P6, V6).</p>

    <p class="text-gray-300">The implementation itself entails many algorithmic and engineering details, and we refer the reader to [\\[BCTV14\\]](#page-43-5) for a discussion of these techniques. We only provide a high-level efficiency comparison between the preprocessing zk-SNARK of [\\[BCTV14\\]](#page-43-5) based on Edwards curves (also at 80-bit security), and our implementations of (G4, P4, V4) and (G6, P6, V6); see Figure <a href="#page-12-1">1.</a> Our implementation is slower, because of two main reasons: (i) MNT curves do not enjoy advantageous properties that Edwards curves do; and (ii) the modulus sizes are larger (298 bits in our case vs. 180 bits in [\\[BCTV14\\]](#page-43-5)). On the other hand, the fact that MNT curves lie on a PCD-friendly 2-cycle is crucial for the PCD construction described next.</p>

    <p class="text-gray-300">|               | 80 bits of security |              |              |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------------</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key generator</td>

            <td class="px-3 py-2 border-b border-gray-700">12.4 s</td>

            <td class="px-3 py-2 border-b border-gray-700">33.9 s</td>

            <td class="px-3 py-2 border-b border-gray-700">48.8 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover</td>

            <td class="px-3 py-2 border-b border-gray-700">13.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">36.5 s</td>

            <td class="px-3 py-2 border-b border-gray-700">49.4 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">9.1 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">16.7 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">230 B</td>

            <td class="px-3 py-2 border-b border-gray-700">337 B</td>

            <td class="px-3 py-2 border-b border-gray-700">374 B</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-12-1"></span>Figure 1: Comparison of (GEd, PEd, VEd), (G4, P4, V4), and (G6, P6, V6), on a circuit C with 2 <sup>17</sup> gates and inputs of 10 field elements. The size of C was chosen so that the 2-adicity of each zk-SNARK's curve is high enough (i.e., ν2(r<sup>i</sup> − 1) ≥ 17 for i = Ed, 4, 6). The experiment was conducted on our benchmarking machine (described in Section <a href="#page-28-0">7\\)</a>, running in single-thread mode. (The reported times are the average of 10 experiments, with standard deviation less than 1%.)</p>

    <p class="text-gray-300">We also found and constructed a 2-cycle with higher security, by (significantly) increasing the modulus. This 2-cycle can be used in place of the previous 2-cycle, albeit with moderate performance overheads.</p>

    <p class="text-gray-300"><span class="math-block">E_4/\\mathbb{F}_{q_4}: y^2 = x^3 + A_4x + B_4</span>  where  <span class="math">A_4 = 2</span> ,</p>

    <p class="text-gray-300">B<sup>4</sup> = 0x01373684A8C9DCAE7A016AC5D7748D3313CD8E39051C596560835DF0C9E50A5B59B882A92C78 DC537E51A16703EC9855C77F C3D8BB21C8D68BB8CF B9DB4B8C8F BA773111C36C8B1B4E8F1ECE 940EF9EAAD265458E06372009C9A0491678EF4,</p>

    <p class="text-gray-300">q<sup>4</sup> = 0x01C4C62D92C41110229022EEE2CDADB7F997505B8F AF ED5EB7E8F96C97D87307F DB925E8A 0ED8D99D124D9A15AF79DB117E776F218059DB80F0DA5CB537E38685ACCE9767254A4638810719AC4 25F0E39D54522CDD119F5E9063DE245E8001.</p>

    <p class="text-gray-300"><span class="math-block">E_6/\\mathbb{F}_{q_6}: y^2 = x^3 + A_6x + B_6</span>  where  <span class="math">A_6 = 11</span> ,</p>

    <p class="text-gray-300">B<sup>6</sup> = 0x7DA285E70863C79D56446237CE2E1468D14AE9BB64B2BB01B10E60A5D5DF E0A25714B798599 3F62F03B22A9A3C737A1A1E0F CF2C43D7BF847957C34CCA1E3585F9A80A95F401867C4E80F4747F D E5ABA7505BA6F CF2485540B13DF C8468A,</p>

    <p class="text-gray-300">q<sup>6</sup> = 0x01C4C62D92C41110229022EEE2CDADB7F997505B8F AF ED5EB7E8F96C97D87307F DB925E8A 0ED8D99D124D9A15AF79DB26C5C28C859A99B3EEBCA9429212636B9DF F97634993AA4D6C381BC3F 0057974EA099170F A13A4F D90776E240000001.</p>

    <p class="text-gray-300">In Section 3 we formulated, and instantiated, PCD-friendly cycles of elliptic curves (see Definition 3.1); this notion was motivated by efficiency considerations arising when recursively composing zk-SNARK proofs. Roughly, given two zk-SNARKs based on elliptic curves forming a PCD-friendly 2-cycle, one can alternate between the two proof systems, and the 2-cycle property ensures that fields "match up" at each recursive verification, allowing for an efficient circuit implementation of the verifier of both proof systems.</p>

    <p class="text-gray-300">The discussion so far, however, is only a sketch of the approach and omits key technical details. We now spell out these by describing how to construct a PCD system, given the two zk-SNARKs. So let  <span class="math">(E_{\\alpha}, E_{\\beta})</span>  be a PCD-friendly 2-cycle of elliptic curves, and let  <span class="math">(G_{\\alpha}, P_{\\alpha}, V_{\\alpha})</span>  and  <span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span>  be two preprocessing zk-SNARKs respectively instantiated with the two elliptic curves  <span class="math">E_{\\alpha}/\\mathbb{F}_{q_{\\alpha}}</span>  and  <span class="math">E_{\\beta}/\\mathbb{F}_{q_{\\beta}}</span> . Note that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(G_{\\alpha}, P_{\\alpha}, V_{\\alpha})</span>  works for  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit satisfiability, while  <span class="math">V_{\\alpha}</span> 's computations are over  <span class="math">\\mathbb{F}_{q_{\\alpha}}</span> ; and</li>

      <li><span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span>  works for  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> -arithmetic circuit satisfiability, while  <span class="math">V_{\\beta}</span> 's computations are over  <span class="math">\\mathbb{F}_{q_{\\beta}}</span> . Due to the 2-cycle property,  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span>  equals  <span class="math">\\mathbb{F}_{q_{\\beta}}</span> , and  <span class="math">\\mathbb{F}_{r_{\\beta}}</span>  equals  <span class="math">\\mathbb{F}_{q_{\\alpha}}</span> . Our goal is to use  <span class="math">(G_{\\alpha}, P_{\\alpha}, V_{\\alpha})</span>  and  <span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span> , along with other ingredients, to construct a PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 4.1</strong> (longer cycles). As we have PCD-friendly cycles of length  <span class="math">\\ell=2</span> , the PCD construction described in this section (including our code) is specialized to this case. One can extend the construction to work with (preprocessing zk-SNARKs based on) PCD-friendly cycles of length  <span class="math">\\ell&gt;2</span> .</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">4.1 Intuition</h4>

    <p class="text-gray-300">We begin by giving the intuition behind our construction of the PCD generator  <span class="math">\\mathbb{G}</span> , prover  <span class="math">\\mathbb{P}</span> , and verifier  <span class="math">\\mathbb{V}</span> . For simplicity, for now, we focus on the case where each node receives a single input message (i.e., the special case of "message chains" having arity s=1).</p>

    <p class="text-gray-300"><strong>Starting point.</strong> A natural first attempt is to construct two arithmetic circuits,  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  over  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  over  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> , that, for a given compliance predicate  <span class="math">\\Pi</span> , work as follows.</p>

    <pre><code class="language-text">\\begin{array}{lll} \\frac{C_{\\mathrm{pcd},\\alpha}(x,a)}{1. \\ \\ \\mathrm{Parse \\ the \\ input} \\ x \\ \\mathrm{as} \\ (\\mathsf{vk}_\\alpha,\\mathsf{vk}_\\beta,z).} &amp; \\frac{C_{\\mathrm{pcd},\\beta}(x,a)}{1. \\ \\ \\mathrm{Parse \\ the \\ input} \\ x \\ \\mathrm{as} \\ (\\mathsf{vk}_\\alpha,\\mathsf{vk}_\\beta,z).} \\\\ 2. \\ \\ \\mathrm{Parse \\ the \\ witness} \\ a \\ \\mathrm{as} \\ (z_{\\mathrm{loc}},z_{\\mathrm{in}},\\pi_{\\mathrm{in}}). \\\\ 3. \\ \\ \\mathrm{If} \\ \\pi_{\\mathrm{in}} = 0 \\ (\\mathrm{base \\ case}), \\, \\mathrm{set} \\ b_{\\mathrm{base}} := 1. \\\\ 4. \\ \\ \\mathrm{If} \\ \\pi_{\\mathrm{in}} \\neq 0 \\ (\\mathrm{not \\ base \\ case}), \\, \\mathrm{set} \\ b_{\\mathrm{base}} := 0 \\ \\mathrm{and} \\\\ \\ \\ \\ \\mathrm{check \\ that} \\ V_\\beta \\big(\\mathsf{vk}_\\beta, \\big(\\mathsf{vk}_\\alpha, \\mathsf{vk}_\\beta, z_{\\mathrm{in}}\\big), \\pi_{\\mathrm{in}}\\big) \\ \\mathrm{accepts}. \\\\ 5. \\ \\ \\mathrm{Check \\ that} \\ \\Pi(z, z_{\\mathrm{loc}}, z_{\\mathrm{in}}, b_{\\mathrm{base}}) = 0. \\\\ \\end{array}</code></pre>

    <p class="text-gray-300">In other words,  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  checks  <span class="math">\\Pi</span> -compliance at a node and also verifies a previous proof, relative to  <span class="math">V_{\\beta}</span> ; while  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  does the same, but verifies a previous proof relative to  <span class="math">V_{\\alpha}</span> . Also note that the input x, but not the witness a (over which we have no control), specifies the choice of verification keys.</p>

    <p class="text-gray-300">More precisely, on input  <span class="math">\\Pi</span> , the PCD generator  <span class="math">\\mathbb G</span>  would work as follows: (i) construct  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  from  <span class="math">\\Pi</span> ; (ii) sample two key pairs,  <span class="math">(\\mathsf{pk}_\\alpha,\\mathsf{vk}_\\alpha) \\leftarrow G_4(C_{\\mathsf{pcd},\\alpha})</span>  and  <span class="math">(\\mathsf{pk}_\\beta,\\mathsf{vk}_\\beta) \\leftarrow G_6(C_{\\mathsf{pcd},\\beta})</span> ; and (iii) output  <span class="math">\\mathsf{pk} := (\\mathsf{pk}_\\alpha,\\mathsf{pk}_\\beta,\\mathsf{vk}_\\alpha,\\mathsf{vk}_\\beta)</span>  and  <span class="math">\\mathsf{vk} := (\\mathsf{vk}_\\alpha,\\mathsf{vk}_\\beta)</span> . On input proving key  <span class="math">\\mathsf{pk}</span> , outgoing message z, local data  <span class="math">z_{\\mathsf{loc}}</span> , and incoming message  <span class="math">z_{\\mathsf{in}}</span> , the PCD prover  <span class="math">\\mathbb P</span>  would invoke  <span class="math">P_\\alpha(\\mathsf{pk}_\\alpha,x,a)</span>  if  <span class="math">\\pi_{\\mathsf{in}}</span>  is relative to  <span class="math">V_\\beta</span>  or  <span class="math">P_\\beta(\\mathsf{pk}_\\beta,x,a)</span>  if  <span class="math">\\pi_{\\mathsf{in}}</span>  is relative to  <span class="math">V_\\alpha</span> , where  <span class="math">x := (\\mathsf{vk}_\\alpha,\\mathsf{vk}_\\beta,z)</span>  and  <span class="math">a := (z_{\\mathsf{loc}},z_{\\mathsf{in}},\\pi_{\\mathsf{in}})</span> . Finally, on input verification key  <span class="math">\\mathsf{vk}</span> , message z, and proof  <span class="math">\\pi</span> , the PCD verifier  <span class="math">\\mathbb V</span>  would either invoke  <span class="math">V_\\alpha(\\mathsf{vk}_\\alpha,x,\\pi)</span>  or  <span class="math">V_\\beta(\\mathsf{vk}_\\beta,x,\\pi)</span> , where  <span class="math">x := (\\mathsf{vk}_\\alpha,\\mathsf{vk}_\\beta,z)</span> .</p>

    <p class="text-gray-300">However, the above simple sketch suffers from two main problems, which we now describe.</p>

    <p class="text-gray-300"><strong>Problem #1.</strong> The compliance predicate  <span class="math">\\Pi</span>  is an arithmetic circuit. However, should  <span class="math">\\Pi</span>  be defined over  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span>  or  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> ? If  <span class="math">\\Pi</span>  is defined over  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> , then the  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> -arithmetic circuit  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  will be very inefficient, because it has to evaluate  <span class="math">\\Pi</span>  over the "wrong" field; conversely, if  <span class="math">\\Pi</span>  is defined over  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> , then  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  will be very inefficient.</p>

    <p class="text-gray-300"><strong>Problem #2.</strong> In known preprocessing zk-SNARK constructions, including the one underlying  <span class="math">(G_{\\alpha}, P_{\\alpha}, V_{\\alpha})</span>  and  <span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span> , a verification key has length  <span class="math">\\ell(n) &gt; n</span> , where n is the size of the input to the circuit with respect to which the key was created. Thus, it is not possible to obtain either  <span class="math">\\mathsf{vk}_{\\alpha}</span>  or  <span class="math">\\mathsf{vk}_{\\beta}</span>  that works for inputs of the form  <span class="math">x = (\\mathsf{vk}_{\\alpha}, \\mathsf{vk}_{\\beta}, z)</span> .</p>

    <p class="text-gray-300">Our solution (at high level). To address the first problem, we simply "pick one side": only one of  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  evaluates  <span class="math">\\Pi</span> , while the other circuit merely enables the PCD prover to translate a proof relative to one zk-SNARK verifier to one relative to the other zk-SNARK verifier. Arbitrarily, we pick  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  to be the one that evaluates  <span class="math">\\Pi</span> ; in particular,  <span class="math">\\Pi</span>  will be an  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit. (The choice of  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  is without loss of generality, since we can always relabel: if  <span class="math">(E_{\\alpha}, E_{\\beta})</span>  is PCD-friendly 2-cycle, so is  <span class="math">(E_{\\beta}, E_{\\alpha})</span> .)</p>

    <p class="text-gray-300">To address the second problem, the ideal solution is to simply hardcode  <span class="math">\\mathsf{vk}_\\beta</span>  in  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">\\mathsf{vk}_\\alpha</span>  in  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  (and let an input x consist only of a message z). However, this is not possible:  <span class="math">\\mathsf{vk}_\\beta</span>  depends on  <span class="math">C_{\\mathsf{pcd},\\beta}</span> , while  <span class="math">\\mathsf{vk}_\\alpha</span>  depends on  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  (i.e., there is a circular dependency). We thus proceed as follows. We hardcode  <span class="math">\\mathsf{vk}_\\alpha</span>  in  <span class="math">C_{\\mathsf{pcd},\\beta}</span> . Then, for  <span class="math">\\mathsf{vk}_\\beta</span> , we rely on collision-resistant hashing. Namely, inputs x have the form  <span class="math">(\\chi_\\beta,z)</span>  where, allegedly,  <span class="math">\\chi_\\beta</span>  is the hash of  <span class="math">\\mathsf{vk}_\\beta</span> . We modify  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  to check that this holds:  <span class="math">C_{\\mathsf{pcd},\\alpha}</span> 's witness is extended to (allegedly) contain  <span class="math">\\mathsf{vk}_\\beta</span>  and then  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  checks that  <span class="math">H_\\alpha(\\mathsf{vk}_\\beta) = \\chi_\\beta</span> , where  <span class="math">H_\\alpha \\colon \\{0,1\\}^{m_{H,\\alpha}} \\to \\mathbb{F}^{d_{H,\\alpha}}_{r_\\alpha}</span>  is a suitable collision-resistant hash function.</p>

    <p class="text-gray-300">The above modifications to  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  yield the following construction.</p>

    <pre><code class="language-text">\\begin{array}{l} \\frac{C_{\\mathrm{pcd},\\alpha}(x,a)}{1. \\text{ Parse the input } x \\text{ as } (\\chi_{\\beta},z).} \\\\ 2. \\text{ Parse the witness } a \\text{ as } (\\mathsf{vk}_{\\beta},z_{\\mathsf{loc}},z_{\\mathsf{in}},\\pi_{\\mathsf{in}}). \\\\ 3. \\text{ Check that } H_{\\alpha}(\\mathsf{vk}_{\\beta}) = \\chi_{\\beta}. \\\\ 4. \\text{ If } \\pi_{\\mathsf{in}} = 0 \\text{ (base case), set } b_{\\mathsf{base}} := 1. \\\\ 5. \\text{ If } \\pi_{\\mathsf{in}} \\neq 0 \\text{ (not base case), set } b_{\\mathsf{base}} := 0 \\text{ and } \\\\ \\text{ check that } V_{\\beta}(\\mathsf{vk}_{\\beta},(\\chi_{\\beta},z_{\\mathsf{in}}),\\pi_{\\mathsf{in}}) \\text{ accepts.} \\\\ 6. \\text{ Check that } \\Pi(z,z_{\\mathsf{loc}},z_{\\mathsf{in}},b_{\\mathsf{base}}) = 0. \\\\ \\end{array}</code></pre>

    <p class="text-gray-300">Unfortunately, while the above two fixes make  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  well-defined, the use of hashing makes  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  large, as we now explain. The verification key  <span class="math">\\mathsf{vk}_\\beta</span>  consists of various points on the elliptic curve  <span class="math">E_\\beta/\\mathbb{F}_{q_\\beta}</span>  (or a twist of it). Recalling that  <span class="math">\\mathbb{F}_{q_\\beta}</span>  equals  <span class="math">\\mathbb{F}_{r_\\alpha}</span>  (the field of definition of  <span class="math">C_{\\mathsf{pcd},\\alpha}</span> ), we represent  <span class="math">\\mathsf{vk}_\\beta</span>  as a list of elements of  <span class="math">\\mathbb{F}_{q_\\beta}</span> , because the (circuit implementing the) verifier  <span class="math">V_\\beta</span>  uses  <span class="math">\\mathsf{vk}_\\beta</span>  for computations in  <span class="math">\\mathbb{F}_{q_\\beta}</span> . Unfortunately,  <span class="math">H_\\alpha</span>  only accepts binary strings as input, and the translation from  <span class="math">\\mathsf{vk}_\\beta</span>  to its binary representation incurs a  <span class="math">\\log q_\\beta</span>  blow up — a nontrivial cost. We do not know how to eliminate this cost.  <span class="math">^{12}</span></p>

    <p class="text-gray-300">Thus, instead, we further modify  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  to shorten  <span class="math">\\mathsf{vk}_\\beta</span> . Indeed, if  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  accepts inputs of n elements in  <span class="math">\\mathbb{F}_{r_\\beta}</span> , then  <span class="math">\\mathsf{vk}_\\beta</span>  consists of  <span class="math">\\ell_{\\mathsf{vk},\\beta}(n)</span>  elements in  <span class="math">\\mathbb{F}_{q_\\beta}</span> ; hence, we seek to reduce n. To do so, instead of working with messages of the form  <span class="math">x=(\\chi_\\beta,z)</span> , we work with messages of the form  <span class="math">x=(\\chi_\\beta)</span> , by also hashing z along with  <span class="math">\\mathsf{vk}_\\beta</span>  (both of which are now supplied in the witness), as follows.</p>

    <pre><code class="language-text">\\begin{array}{l} \\frac{C_{\\mathsf{pcd},\\alpha}(x,a)}{1. \\text{ Parse the input } x \\text{ as } (\\chi_{\\beta}).} \\\\ 2. \\text{ Parse the witness } a \\text{ as } (\\mathsf{vk}_{\\beta},z,z_{\\mathsf{loc}},z_{\\mathsf{in}},\\pi_{\\mathsf{in}}).} \\\\ 3. \\text{ Check that } H_{\\alpha}(\\mathsf{vk}_{\\beta}\\|z) = \\chi_{\\beta}.} \\\\ 4. \\text{ If } \\pi_{\\mathsf{in}} = 0 \\text{ (base case), set } b_{\\mathsf{base}} := 1.} \\\\ 5. \\text{ If } \\pi_{\\mathsf{in}} \\neq 0 \\text{ (not base case), set } b_{\\mathsf{base}} := 0 \\text{ and } \\\\ \\text{ check that } V_{\\beta}(\\mathsf{vk}_{\\beta},H_{\\alpha}(\\mathsf{vk}_{\\beta}\\|z_{\\mathsf{in}}),\\pi_{\\mathsf{in}}) \\text{ accepts.}} \\\\ 6. \\text{ Check that } \\Pi(z,z_{\\mathsf{loc}},z_{\\mathsf{in}},b_{\\mathsf{base}}) = 0.} \\\\ \\end{array}</code></pre>

    <p class="text-gray-300"><sup>&</sup>lt;sup>11</sup>Alternatively, we could restrict  <span class="math">\\Pi</span>  to be a boolean circuit, so that it can be easily evaluated by  <span class="math">C_{pcd,\\alpha}</span>  and  <span class="math">C_{pcd,\\beta}</span> . But this foregoes  <span class="math">\\Pi</span> 's ability to conduct field operations in large prime fields. Thus, it is more efficient to "give up" on  <span class="math">C_{pcd,\\beta}</span> , and only let  <span class="math">C_{pcd,\\alpha}</span>  evaluate  <span class="math">\\Pi</span> , and retain the expressive power of arithmetic circuits. (Other alternatives are possible, but we do not explore them.)</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>12</sup>As explained in Section 5.2, we are not aware of a collision-resistant hash function  <span class="math">\\hat{H}_{\\alpha}</span> , which can be easily verified over  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> , that accepts inputs represented as strings of elements in  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> . So, we are "stuck" with binary inputs.</p>

    <p class="text-gray-300"><strong>Further details.</strong> The above discussion omits various technical details and optimizations.</p>

    <p class="text-gray-300">For instance, thus far we have ignored the fact that, while  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  expects inputs over  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> ,  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  expects inputs over  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> . Since  <span class="math">x = \\chi_{\\beta}</span>  lies in  <span class="math">\\mathbb{F}_{r_{\\alpha}}^{d_{H,\\alpha}}</span>  (as it is the output of  <span class="math">H_{\\alpha}</span> ), we cannot use the same representation of it for both  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span> ; instead, we need two representations:  <span class="math">x_{\\alpha} \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}}</span>  for  <span class="math">C_{\\mathsf{pcd},\\alpha}</span> , and  <span class="math">x_{\\beta} \\in \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}</span> for  <span class="math">C_{\\mathsf{pcd},\\beta}</span> . Naturally, for the first, we can set  <span class="math">n_{\\alpha} := d_{H,\\alpha}</span> , and let  <span class="math">x_{\\alpha} := \\chi_{\\beta}</span> . For the second, merely letting  <span class="math">x_{\\beta}</span>  be the list of  <span class="math">n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil</span>  bits in  <span class="math">\\chi_{\\beta}</span>  is <em>not</em> efficient: it would cause  <span class="math">\\mathsf{vk}_{\\beta}</span>  to have length  <span class="math">\\ell_{\\mathsf{vk},\\beta}(n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil)</span> . Instead, we let  <span class="math">x_{\\beta}</span>  store these bits into as few elements of  <span class="math">\\mathbb{F}_{r_{\\beta}}</span>  as possible; specifically,  <span class="math">n_{\\beta} := \\lceil \\frac{n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil}{\\lceil \\log r_{\\beta} \\rceil} \\rceil</span>  of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">S_{\\alpha \\to \\beta} \\colon \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}} \\to \\mathbb{F}_{r_{\\alpha}}^{n_{\\beta} \\cdot \\lceil \\log r_{\\beta} \\rceil}</span>  denote the function that maps  <span class="math">x_{\\alpha}</span>  to (the binary representation of)  <span class="math">x_{\\beta}</span> ; and  <span class="math">S_{\\alpha \\leftarrow \\beta} \\colon \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}} \\to \\mathbb{F}_{r_{\\beta}}^{n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil}</span>  denote the function that maps  <span class="math">x_{\\beta}</span>  back to (the binary representation of)  <span class="math">x_{\\alpha}</span> . The above implies that we need to further modify  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span> , and include explicit subcircuits  <span class="math">C_{S,\\alpha\\to\\beta}</span> and  <span class="math">C_{S,\\alpha\\leftarrow\\beta}</span>  to carry out these "type conversions"; both of these circuits are simple to construct, and have size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{S,\\alpha\\to\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{S,\\alpha\\leftarrow\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n_\\alpha \\cdot \\lceil \\log r_\\alpha \\rceil$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, we leverage precomputation techniques [BCTV14]. A zk-SNARK verifier V can be viewed as two functions; an "offline" function  <span class="math">V^{\\text{offline}}</span>  that, given the verification key vk, computes a processed verification key pvk; and an "online" function  <span class="math">V^{\\text{online}}</span>  that, given pvk, an input x, and proof  <span class="math">\\pi</span> , computes the decision bit. (I.e.,  <span class="math">V(\\mathsf{vk}, x, \\pi) := V^{\\text{online}}(V^{\\text{offline}}(\\mathsf{vk}), x, \\pi)</span> .) Precomputation offers a tradeoff: while  <span class="math">V^{\\text{online}}</span> is cheaper to compute than V, pvk is larger than vk (in each case, the difference is an additive constant). In our setting, it turns out that it pays off to use precomputation techniques only in  <span class="math">C_{pcd,\\beta}</span>  but not in  <span class="math">C_{pcd,\\alpha}</span> .</p>

    <p class="text-gray-300">We address all the details in the next subsection, where we give the construction of the PCD system.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Construction</h4>

    <p class="text-gray-300">We now describe in more detail our construction of the PCD generator  <span class="math">\\mathbb{G}</span> , prover  <span class="math">\\mathbb{P}</span> , and verifier  <span class="math">\\mathbb{V}</span> . Throughout, we fix a message size  <span class="math">n_{\\mathsf{msg}} \\in \\mathbb{N}</span> , local-data size  <span class="math">n_{\\mathsf{loc}} \\in \\mathbb{N}</span> , and arity  <span class="math">s \\in \\mathbb{N}</span> . The construction will then work for  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic compliance predicates  <span class="math">\\Pi \\colon \\mathbb{F}_{r_{\\alpha}}^{n_{\\text{msg}}} \\times \\mathbb{F}_{r_{\\alpha}}^{n_{\\text{loc}}} \\times \\mathbb{F}_{r_{\\alpha}}^{s \\cdot n_{\\text{msg}}} \\times \\mathbb{F}_{r_{\\alpha}} \\to \\mathbb{F}_{r_{\\alpha}}^{l}</span>  (i.e., for message size  <span class="math">n_{\\text{msg}}</span> , local-data size  <span class="math">n_{\\text{loc}}</span> , arity s, and some output size  <span class="math">l \\in \\mathbb{N}</span> ). In terms of ingredients, we make use of the following arithmetic circuits:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit  <span class="math">C_{H,\\alpha}</span> , implementing a collision-resistant function  <span class="math">H_{\\alpha} \\colon \\{0,1\\}^{m_{H,\\alpha}} \\to \\mathbb{F}_{r_{\\alpha}}^{d_{H,\\alpha}}</span>  such that  <span class="math">m_{H,\\alpha} \\geq \\left(\\ell_{\\mathsf{vk},\\beta}(n_{\\beta}) + n_{\\mathsf{msg}}\\right) \\cdot \\lceil \\log r_{\\alpha} \\rceil</span> , where  <span class="math">n_{\\alpha} := d_{H,\\alpha}</span>  and  <span class="math">n_{\\beta} := \\lceil \\frac{n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil}{\\lceil \\log r_{\\beta} \\rceil} \\rceil</span> .</li>

      <li>An  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit  <span class="math">C_{S,\\alpha \\to \\beta}</span> , implementing  <span class="math">S_{\\alpha \\to \\beta} \\colon \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}} \\to \\mathbb{F}_{r_{\\alpha}}^{n_{\\beta} \\cdot \\lceil \\log r_{\\beta} \\rceil}</span> . An  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> -arithmetic circuit  <span class="math">C_{S,\\alpha \\leftarrow \\beta}</span> , implementing  <span class="math">S_{\\alpha \\leftarrow \\beta} \\colon \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}} \\to \\mathbb{F}_{r_{\\beta}}^{n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil}</span> .</li>

      <li>An  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit  <span class="math">C_{V,\\alpha}^{\\text{online}}</span> , implementing  <span class="math">V_{\\alpha}^{\\text{online}}</span>  for inputs of  <span class="math">n_{\\alpha}</span>  elements in  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> ; an input  <span class="math">x_{\\alpha} \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}}</span> is given to  <span class="math">C_{V,\\alpha}^{\\text{online}}</span>  as a string of  <span class="math">n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil</span>  elements in  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> , each carrying a bit of  <span class="math">x_{\\alpha}</span> .</li>

      <li>An  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit  <span class="math">C_{V,\\beta}</span> , implementing  <span class="math">V_{\\beta}</span>  for inputs of  <span class="math">n_{\\beta}</span>  elements in  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> ; an input  <span class="math">x_{\\beta} \\in \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}</span>  is given to  <span class="math">C_{V,\\beta}</span>  as a string of  <span class="math">n_{\\beta} \\cdot \\lceil \\log r_{\\beta} \\rceil</span>  elements in  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> , each carrying a bit of  <span class="math">x_{\\beta}</span> .</li>

    </ul>

    <p class="text-gray-300">For now we take the above circuits as given; later, in Section 5 we discuss our concrete instantiations of them. Also, we generically denote by bits<sub>\\alpha</sub> a function that, given an input y in  <span class="math">\\mathbb{F}_{r_{\\alpha}}^{\\ell}</span>  (for some  <span class="math">\\ell</span> ), outputs y's binary representation; the corresponding  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit is denoted  <span class="math">C_{\\mathsf{bits},\\alpha}</span> , and has  <span class="math">\\ell \\cdot \\lceil \\log r_{\\alpha} \\rceil</span>  gates.<sup>13</sup></p>

    <p class="text-gray-300">For reference, pseudocode for the triple  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  is given in Figure 2.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>13</sup>More precisely, for each  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -element  <span class="math">y_i</span>  in the vector y, bits<sub> <span class="math">\\alpha</span> </sub> outputs bits  <span class="math">b_1, \\ldots, b_{\\lceil \\log r_{\\alpha} \\rceil}</span>  such that  <span class="math">\\sum_{j=0}^{\\lceil \\log r_{\\alpha} \\rceil - 1} b_j 2^j = y_i</span> , where arithmetic is conducted over  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> . Due to wrap around, some elements in  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span>  have two such representations; if so, bits<sub>\\alpha</sub> outputs the lexicographically-first one. None the less, we construct  <span class="math">C_{\\mathsf{bits},\\alpha}</span>  to only check for either of these two representations, because: (i) discriminating between representations costs an additional  <span class="math">\\ell \\cdot \\lceil \\log r_{\\alpha} \\rceil</span>  gates; and (ii) doing so does not affect completeness or soundness of our construction.</p>

    <p class="text-gray-300">The PCD generator. The PCD generator  <span class="math">\\mathbb G</span>  takes as input an  <span class="math">\\mathbb F_{r_\\alpha}</span> -arithmetic compliance predicate  <span class="math">\\Pi</span> , and outputs a key pair (pk, vk) for proving/verifying  <span class="math">\\Pi</span> -compliance. The PCD generator works as follows: (i) it uses  <span class="math">C_{H,\\alpha}, C_{S,\\alpha\\to\\beta}, C_{V,\\beta}, \\Pi</span>  to construct the circuit  <span class="math">C_{\\mathrm{pcd},\\alpha}</span> ; (ii) it samples a key pair, (pk <span class="math">_\\alpha</span> , vk <span class="math">_\\alpha</span> )  <span class="math">\\leftarrow G_4(C_{\\mathrm{pcd},\\alpha})</span> ; (iii) it uses vk <span class="math">_\\alpha</span> ,  <span class="math">C_{S,\\alpha\\leftarrow\\beta}</span> ,  <span class="math">C_{V,\\alpha}^{\\mathrm{online}}</span>  to construct the other circuit  <span class="math">C_{\\mathrm{pcd},\\beta}</span> ; (iv) it samples another key pair, (pk <span class="math">_\\beta</span> , vk <span class="math">_\\beta</span> )  <span class="math">\\leftarrow G_6(C_{\\mathrm{pcd},\\beta})</span> ; and (v) it outputs pk := (pk <span class="math">_\\alpha</span> , pk <span class="math">_\\beta</span> , vk <span class="math">_\\alpha</span> , vk <span class="math">_\\beta</span> ) and vk := (vk <span class="math">_\\alpha</span> , vk <span class="math">_\\beta</span> ).</p>

    <p class="text-gray-300">We now describe  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and  <span class="math">C_{\\mathsf{pcd},\\beta}</span> . The circuit  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  acts as a "proof converter": it takes an input  <span class="math">x_\\beta \\in \\mathbb{F}^{n_\\beta}_{r_\\beta}</span>  and a witness  <span class="math">a_\\beta \\in \\mathbb{F}^{h_\\beta}_{r_\\beta}</span> , parses  <span class="math">a_\\beta</span>  as a zk-SNARK proof  <span class="math">\\pi_\\alpha</span>  for  <span class="math">V_\\alpha</span> , and simply checks that  <span class="math">C^{\\text{online}}_{V,\\alpha} \\big( \\mathsf{vk}_\\alpha, C_{S,\\alpha \\leftarrow \\beta}(x_\\beta), \\pi_\\alpha \\big) = 1</span> . (The verification key  <span class="math">\\mathsf{vk}_\\alpha</span>  is hardcoded in  <span class="math">C_{\\mathsf{pcd},\\beta}</span> .)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In contrast, the circuit  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  verifies  <span class="math">\\Pi</span> -compliance: it takes an input  <span class="math">x_{\\alpha} \\in \\mathbb{F}^{n_{\\alpha}}_{r_{\\alpha}}</span>  and a witness  <span class="math">a_{\\alpha} \\in \\mathbb{F}^{h_{\\alpha}}_{r_{\\alpha}}</span> , parses  <span class="math">a_{\\alpha}</span>  as  <span class="math">(\\mathsf{vk}_{\\beta}, z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, b_{\\mathsf{base}}, \\vec{\\pi}_{\\mathsf{in}}, b_{\\mathsf{res}})</span> , and verifies that  $x_{\\alpha} = C_{H,\\alpha}(C_{\\mathsf{bits},\\alpha}(\\mathsf{vk}_{\\beta}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{bits},\\alpha}(z))<span class="math">  and that  </span>\\Pi(z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, b_{\\mathsf{base}}) = 0<span class="math"> . Moreover, if  </span>b_{\\mathsf{base}} = 0<span class="math">  (not the base case),  </span>C_{\\mathsf{pcd},\\alpha}<span class="math">  also recursively verifies  </span>\\Pi<span class="math"> -compliance of previous messages: for each corresponding pair  </span>(z_{\\mathsf{in}}, \\pi_{\\mathsf{in}})<span class="math">  in  </span>(\\vec{z}_{\\mathsf{in}}, \\vec{\\pi}_{\\mathsf{in}})<span class="math"> , it verifies that  </span>C_{V,\\beta}(\\mathsf{vk}_{\\beta}, x_{\\mathsf{in},\\beta}, \\pi_{\\mathsf{in}}) = 1<span class="math">  where  </span>x_{\\mathsf{in},\\beta} = C_{S,\\alpha \\to \\beta}(C_{H,\\alpha}(C_{\\mathsf{bits},\\alpha}(\\mathsf{vk}_{\\beta}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{bits},\\alpha}(z_{\\mathsf{in}})))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Figure 2 for details. Overall, the two circuits have the following sizes:</p>

    <p class="text-gray-300"><span id="page-16-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{aligned}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{pcd},\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&\\approx \\left(\\ell_{\\mathsf{vk},\\beta}(n_\\beta) + (1+s)n_{\\mathsf{msg}}\\right) \\cdot \\lceil \\log r_\\alpha \\rceil +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{H,\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ s \\cdot \\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{H,\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{S,\\alpha \\to \\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{V,\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) \\;, \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{pcd},\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{S,\\alpha \\leftarrow \\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{V,\\alpha}^{\\mathrm{online}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;. \\end{aligned} \\tag{1}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The PCD prover. The PCD prover  <span class="math">\\mathbb{P}</span>  takes as input a proving key pk, outgoing message z, local data  <span class="math">z_{loc}</span> , and incoming messages  <span class="math">\\vec{z}_{in}</span> ; when not in the base case, it also takes as input proofs  <span class="math">\\vec{\\pi}_{in}</span> , each attesting that a message in  <span class="math">\\vec{z}_{in}</span>  is  <span class="math">\\Pi</span> -compliant. The PCD prover outputs a proof  <span class="math">\\pi</span>  attesting to the fact that z is  <span class="math">\\Pi</span> -compliant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At high level, the PCD prover performs not one, but two, steps of recursive composition, "going around the PCD-friendly 2-cycle". The first step is relative to  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  and checks  <span class="math">\\Pi</span> -compliance; the second step is relative to  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  and merely converts the proof produced by the first step to the other verifier. More precisely, the PCD prover constructs  $x_\\alpha := H_\\alpha(\\mathsf{bits}_\\alpha(\\mathsf{vk}_\\beta) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bits}_\\alpha(z)) \\in \\mathbb{F}_{r_\\alpha}^{n_\\alpha}<span class="math">  and then uses  </span>P_\\alpha<span class="math">  to produce a proof  </span>\\pi_\\alpha<span class="math">  attesting that  </span>x_\\alpha \\in \\mathcal{L}_{C_{\\mathsf{pcd},\\alpha}}<span class="math"> . In the base case,  </span>C_{\\mathsf{pcd},\\alpha}<span class="math">  only verifies that  </span>\\Pi(z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, 1) = 0<span class="math"> ; but, when previous proofs  </span>\\vec{\\pi}_{\\mathsf{in}}<span class="math">  are supplied,  </span>C_{\\mathsf{pcd},\\alpha}<span class="math">  verifies instead that  </span>\\Pi(z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, 0) = 0<span class="math">  and, for each pair  </span>(z_{\\mathsf{in}}, \\pi_{\\mathsf{in}})<span class="math"> , that  </span>V_\\beta(\\mathsf{vk}_\\beta, x_{\\beta,\\mathsf{in}}, \\pi_{\\mathsf{in}}) = 1<span class="math">  where  </span>x_{\\beta,\\mathsf{in}} := S_{\\alpha \\to \\beta}(H_\\alpha(\\mathsf{bits}_\\alpha(\\mathsf{vk}_\\beta) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bits}_\\alpha(z_{\\mathsf{in}}))) \\in \\mathbb{F}_{r_\\beta}^{n_\\beta}<span class="math"> . Next, the PCD prover uses  </span>P_\\beta<span class="math">  to convert  </span>\\pi_\\alpha<span class="math">  into a proof  </span>\\pi<span class="math">  attesting that  </span>x_\\beta \\in \\mathcal{L}_{C_{\\mathsf{pcd},\\beta}}<span class="math"> , where  </span>x_\\beta := S_{\\alpha \\to \\beta}(x_\\alpha) \\in \\mathbb{F}_{r_\\beta}^{n_\\beta}<span class="math"> ; this is merely a translation because  </span>C_{\\mathsf{pcd},\\beta}<span class="math">  only verifies that  </span>\\pi_\\alpha<span class="math">  is valid. The proof  </span>\\pi<span class="math">  is  </span>\\mathbb{P}$ 's output.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>The PCD verifier.</strong> The PCD verifier  <span class="math">\\mathbb V</span>  takes as input a verification key vk, message z, and proof  <span class="math">\\pi</span> . Proofs relative to  <span class="math">(G_{\\alpha}, P_{\\alpha}, V_{\\alpha})</span>  are never "seen" outside the PCD prover, because the prover converts them to proofs relative to  <span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span> . Hence, the proof  <span class="math">\\pi</span>  is relative to  <span class="math">(G_{\\beta}, P_{\\beta}, V_{\\beta})</span> , and the PCD verifier checks that z is  <span class="math">\\Pi</span> -compliant by checking that  <span class="math">V_{\\beta}(\\mathsf{vk}_{\\beta}, x_{\\beta}, \\pi) = 1</span> , where  $x_{\\beta} := S_{\\alpha \\to \\beta}(H_{\\alpha}(\\mathsf{bits}_{\\alpha}(\\mathsf{vk}_{\\beta})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bits}_{\\alpha}(z))) \\in \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">4.3 Security</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The intuition for the security of  <span class="math">(\\mathbb{G},\\mathbb{P},\\mathbb{V})</span>  is straightforward. Suppose that a malicious polynomial-size prover  <span class="math">\\tilde{P}</span>  outputs a message z and proof  <span class="math">\\pi</span>  that are accepted by the PCD verifier  <span class="math">\\mathbb{V}</span> . Our goal is to deduce that z is  <span class="math">\\Pi</span> -compliant. By construction of  <span class="math">\\mathbb{V}</span> , we deduce that  $S_{\\alpha \\to \\beta}(H_{\\alpha}(\\mathrm{bits}_{\\alpha}(\\mathsf{vk}_{\\beta})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{bits}_{\\alpha}(z))) \\in \\mathcal{L}_{C_{\\mathrm{pcd},\\beta}}<span class="math"> . In turn, by construction of  </span>C_{\\mathrm{pcd},\\beta}<span class="math"> , we deduce that  </span>H_{\\alpha}(\\mathrm{bits}_{\\alpha}(\\mathsf{vk}_{\\beta})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{bits}_{\\alpha}(z)) \\in \\mathcal{L}_{C_{\\mathrm{pcd},\\alpha}}<span class="math"> . In turn, by construction of  </span>C_{\\mathrm{pcd},\\alpha}<span class="math"> , we deduce that there is local data  </span>z_{\\mathrm{loc}}<span class="math">  and previous messages  </span>\\vec{z}_{\\mathrm{in}}<span class="math">  such that one of the following holds: (i)  </span>\\Pi(z,z_{\\mathrm{loc}},\\vec{z}_{\\mathrm{in}},1)=0<span class="math"> , which is the base case; or (ii)  </span>\\Pi(z,z_{\\mathrm{loc}},\\vec{z}_{\\mathrm{in}},0)=0<span class="math">  and, for each incoming message  </span>z_{\\mathrm{in}}<span class="math"> ,  </span>S_{\\alpha\\to\\beta}(H_{\\alpha}(\\mathrm{bits}_{\\alpha}(\\mathrm{vk}_{\\beta})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{bits}_{\\alpha}(z_{\\mathrm{in}})))\\in\\mathcal{L}_{C_{\\mathrm{pcd},\\beta}}<span class="math">  (and thus, by induction, that each  </span>z_{\\mathrm{in}}<span class="math">  is  </span>\\Pi<span class="math"> -compliant). In either case, we conclude that z is  </span>\\Pi$ -compliant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above argument can be formalized by using the <em>proof-of-knowledge property</em> of zk-SNARKs. Yet, as explained in Section 2.3, a formal argument lies beyond the scope of this paper, which instead focuses on practical aspects of PCD systems; see [BCCT13] for more details.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8"><span class="math">\\mathsf{MakePCDCircuitA}(C_{H,\\alpha}, C_{S,\\alpha \\to \\beta}, C_{V,\\beta}, \\Pi)</span></h3>

    <p class="text-gray-300">Output the  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  that, given input  <span class="math">x_{\\alpha} \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}}</span>  and witness  <span class="math">a_{\\alpha} \\in \\mathbb{F}_{r_{\\alpha}}^{h_{\\alpha}}</span> , works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Parse  <span class="math">a_{\\alpha}</span>  as  <span class="math">(\\mathsf{vk}_{\\beta}, z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, b_{\\mathsf{base}}, \\vec{\\pi}_{\\mathsf{in}}, b_{\\mathsf{res}})</span> .</li>

      <li>2. Compute  <span class="math">\\sigma_{\\mathsf{vk},\\beta} := C_{\\mathsf{bits},\\alpha}(\\mathsf{vk}_{\\beta})</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3. Check that  $x_{\\alpha} = C_{H,\\alpha}(\\sigma_{\\mathsf{vk},\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{bits},\\alpha}(z))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4. Check that  <span class="math">\\Pi(z, z_{loc}, \\vec{z}_{in}, b_{base}) = 0</span> .</li>

      <li>5. For each  <span class="math">(z_{in}, \\pi_{in}) \\in (\\vec{z}_{in}, \\vec{\\pi}_{in})</span> :</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (a) Compute  $x_{\\mathsf{in},\\alpha} := C_{H,\\alpha}(\\sigma_{\\mathsf{vk},\\beta} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{bits},\\alpha}(z_{\\mathsf{in}})) \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(b) Compute  <span class="math">x_{\\mathsf{in},\\beta} := C_{S,\\alpha\\to\\beta}(x_{\\mathsf{in},\\alpha}) \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\beta} \\cdot \\lceil \\log r_{\\beta} \\rceil}</span> .</li>

      <li>(c) Check that  <span class="math">C_{V,\\beta}(\\mathsf{vk}_\\beta, x_{\\mathsf{in},\\beta}, \\pi_{\\mathsf{in}}) = b_{\\mathsf{res}}</span> .</li>

      <li>6. Check that  <span class="math">b_{\\mathsf{base}}, b_{\\mathsf{res}} \\in \\{0, 1\\}</span>  and  <span class="math">(1 b_{\\mathsf{base}})(1 b_{\\mathsf{res}}) = 0</span> .</li>

    </ul>

    <h3 id="sec-28" class="text-xl font-semibold mt-8"><span class="math">\\mathsf{MakePCDCircuitB}(\\mathsf{pvk}_{\\alpha}, C_{S, \\alpha \\leftarrow \\beta}, C_{V, \\alpha}^{\\mathrm{online}})</span></h3>

    <p class="text-gray-300">Output the  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> -arithmetic circuit  <span class="math">C_{\\mathsf{pcd},\\beta}</span>  that, given input  <span class="math">x_{\\beta} \\in \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}</span>  and witness  <span class="math">a_{\\beta} \\in \\mathbb{F}_{r_{\\beta}}^{h_{\\beta}}</span> , works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Parse  <span class="math">a_{\\beta}</span>  as a zk-SNARK proof  <span class="math">\\pi_{\\alpha}</span> .</li>

      <li>2. Compute  <span class="math">x_{\\alpha} := C_{S,\\alpha \\leftarrow \\beta}(x_{\\beta}) \\in \\mathbb{F}_{r_{\\beta}}^{n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil}</span> .</li>

      <li>3. Check that  <span class="math">C_{V,\\alpha}^{\\text{online}}(\\operatorname{pvk}_{\\alpha}, x_{\\alpha}, \\pi_{\\alpha}) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">PARAMETERS. Message size  <span class="math">n_{\\mathsf{msg}} \\in \\mathbb{N}</span> , local-data size  <span class="math">n_{\\mathsf{loc}} \\in \\mathbb{N}</span> , and arity  <span class="math">s \\in \\mathbb{N}</span> .</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6"><strong>PCD</strong> generator <strong>G</strong></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS: a compliance predicate  <span class="math">\\Pi \\colon \\mathbb{F}^{n_{\\mathsf{msg}}}_{r_{\\alpha}} \\times \\mathbb{F}^{n_{\\mathsf{loc}}}_{r_{\\alpha}} \\times \\mathbb{F}^{s \\cdot n_{\\mathsf{msg}}}_{r_{\\alpha}} \\times \\mathbb{F}_{r_{\\alpha}} \\to \\mathbb{F}^{l}_{r_{\\alpha}}</span>  (for some  <span class="math">l \\in \\mathbb{N}</span> )</li>

      <li>OUTPUTS: proving key pk and verification key vk</li>

      <li>1. Set  <span class="math">n_{\\alpha} := d_{H,\\alpha}</span>  and  <span class="math">n_{\\beta} := \\lceil \\frac{n_{\\alpha} \\cdot \\lceil \\log r_{\\alpha} \\rceil}{\\lceil \\log r_{\\beta} \\rceil} \\rceil</span> .</li>

      <li>2. Construct  <span class="math">C_{H,\\alpha}</span> , the  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit implementing  <span class="math">H_{\\alpha} \\colon \\{0,1\\}^{m_{H,\\alpha}} \\to \\mathbb{F}_{r_{\\alpha}}^{d_{H,\\alpha}}</span> .</li>

      <li>3. Construct  <span class="math">C_{S,\\alpha\\to\\beta}</span> , the  <span class="math">\\mathbb{F}_{r_\\alpha}</span> -arithmetic circuit implementing  <span class="math">S_{\\alpha\\to\\beta}\\colon \\mathbb{F}_{r_\\alpha}^{n_\\alpha}\\to \\mathbb{F}_{r_\\alpha}^{n_\\beta\\lceil\\log r_\\beta\\rceil}</span></li>

      <li>4. Construct  <span class="math">C_{S,\\alpha\\leftarrow\\beta}</span> , the  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> -arithmetic circuit implementing  <span class="math">S_{\\alpha\\leftarrow\\beta}\\colon \\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}\\to \\mathbb{F}_{r_{\\beta}}^{n_{\\alpha}\\cdot\\lceil\\log r_{\\alpha}\\rceil}</span> .</li>

      <li>5. Construct  <span class="math">C_{V,\\beta}</span> , the  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> -arithmetic circuit implementing  <span class="math">V_{\\beta}</span>  for inputs of  <span class="math">n_{\\beta}</span>  elements in  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> .</li>

      <li>6. Construct  <span class="math">C_{V,\\alpha}^{\\text{online}}</span> , the  <span class="math">\\mathbb{F}_{r_{\\beta}}</span> -arithmetic circuit implementing  <span class="math">V_{\\alpha}^{\\text{online}}</span>  for inputs of  <span class="math">n_{\\alpha}</span>  elements in  <span class="math">\\mathbb{F}_{r_{\\alpha}}</span> .</li>

      <li>7. Compute  <span class="math">C_{\\mathsf{pcd},\\alpha} := \\mathsf{MakePCDCircuitA}(C_{H,\\alpha}, C_{S,\\alpha \\to \\beta}, C_{V,\\beta}, \\Pi)</span> .</li>

      <li>8. Compute  <span class="math">(\\mathsf{pk}_{\\alpha}, \\mathsf{vk}_{\\alpha}) := G_{\\alpha}(C_{\\mathsf{pcd}, \\alpha})</span> .</li>

      <li>9. Compute  <span class="math">\\operatorname{pvk}_{\\alpha} := V_{\\alpha}^{\\operatorname{offline}}(\\operatorname{vk}_{\\alpha}).</span></li>

      <li>10. Compute  <span class="math">C_{\\mathsf{pcd},\\beta} := \\mathsf{MakePCDCircuitB}(\\mathsf{pvk}_{\\alpha}, C_{S,\\alpha \\leftarrow \\beta}, C_{V,\\alpha}^{\\mathrm{online}})</span> .</li>

      <li>11. Compute  <span class="math">(\\mathsf{pk}_{\\beta}, \\mathsf{vk}_{\\beta}) := G_{\\beta}(C_{\\mathsf{pcd},\\beta})</span> .</li>

      <li>12. Set  <span class="math">pk := (pk_{\\alpha}, pk_{\\beta}, vk_{\\alpha}, vk_{\\beta})</span>  and  <span class="math">vk := (vk_{\\alpha}, vk_{\\beta})</span> .</li>

      <li>13. Output (pk, vk).</li>

    </ul>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">PCD prover <span class="math">\\mathbb{P}</span></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

      <li>proving key pk</li>

      <li>outgoing message  <span class="math">z \\in \\mathbb{F}^{n_{\\mathrm{msg}}}_{r_{\\alpha}}</span></li>

      <li>local data  <span class="math">z_{\\text{loc}} \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\text{loc}}}</span></li>

      <li>incoming messages  <span class="math">\\vec{z}_{\\text{in}} \\in \\mathbb{F}_{r_{\\alpha}}^{s \\cdot n_{\\text{msg}}}</span></li>

      <li>previous proofs  <span class="math">\\vec{\\pi}_{in}</span>  ( <span class="math">\\vec{\\pi}_{in} = \\bot</span>  in the base case, as there is no previous proofs)</li>

      <li>OUTPUTS: proof  <span class="math">\\pi</span>  for the outgoing message z</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. Compute  $x_{\\alpha} := H_{\\alpha}(\\mathsf{bits}_{\\alpha}(\\mathsf{vk}_{\\beta}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bits}_{\\alpha}(z)) \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}}<span class="math">  and  </span>x_{\\beta} := S_{\\alpha \\to \\beta}(x_{\\alpha}) \\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\beta} \\cdot \\lceil \\log r_{\\beta} \\rceil}<span class="math"> , and parse  </span>x_{\\beta}<span class="math">  as lying in  </span>\\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. If base case (i.e.,  <span class="math">\\vec{\\pi}_{in} = \\bot</span> ), then set  <span class="math">a_{\\alpha} := (\\mathsf{vk}_{\\beta}, z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, 1, <em>, </em>)</span> , where \\* is any assignment (of the correct length).</li>

      <li>3. If not base case (i.e.,  <span class="math">\\vec{\\pi}_{in} \\neq \\bot</span> ), then set  <span class="math">a_{\\alpha} := (vk_{\\beta}, z, z_{loc}, \\vec{z}_{in}, 0, \\vec{\\pi}_{in}, 1)</span> .</li>

      <li>4. Compute  <span class="math">\\pi_{\\alpha} := P_{\\alpha}(\\mathsf{pk}_{\\alpha}, x_{\\alpha}, a_{\\alpha}).</span></li>

      <li>5. Set  <span class="math">a_{\\beta} := (\\pi_{\\alpha})</span> .</li>

      <li>6. Compute  <span class="math">\\pi := P_{\\beta}(\\mathsf{pk}_{\\beta}, x_{\\beta}, a_{\\beta})</span> .</li>

      <li>7. Output  <span class="math">\\pi</span> .</li>

    </ul>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">PCD verifier <span class="math">\\mathbb{V}</span></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS: verification key vk, message  <span class="math">z \\in \\mathbb{F}^{n_{\\text{msg}}}_{r_{\\alpha}}</span> , and proof  <span class="math">\\pi</span></li>

      <li>OUTPUTS: decision bit</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. Compute  $x_{\\alpha}:=H_{\\alpha}(\\mathsf{bits}_{\\alpha}(\\mathsf{vk}_{\\beta})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bits}_{\\alpha}(z))\\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\alpha}}<span class="math">  and  </span>x_{\\beta}:=S_{\\alpha\\to\\beta}(x_{\\alpha})\\in \\mathbb{F}_{r_{\\alpha}}^{n_{\\beta}\\cdot\\lceil\\log r_{\\beta}\\rceil}<span class="math"> , and parse  </span>x_{\\beta}<span class="math">  as lying in  </span>\\mathbb{F}_{r_{\\beta}}^{n_{\\beta}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. Compute  <span class="math">b := V_{\\beta}(\\mathsf{vk}_{\\beta}, x_{\\beta}, \\pi)</span>  and output b.</li>

    </ul>

    <p class="text-gray-300">Figure 2: Construction of a PCD system from two PCD-friendly preprocessing zk-SNARKs, along with other arithmetic circuits.</p>

    <h2 id="sec-32" class="text-2xl font-bold">5 Constructions of arithmetic circuits</h2>

    <p class="text-gray-300">In Section 4 we gave a construction of a PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  in terms of two preprocessing zk-SNARKs, based on a PCD-friendly 2-cycle  <span class="math">(E_{\\alpha}, E_{\\beta})</span> , and various arithmetic circuits. We now discuss concrete implementations of these arithmetic circuits, which determine the sizes of  <span class="math">C_{pcd,\\alpha}</span>  and  <span class="math">C_{pcd,\\beta}</span>  (see Equation 1).</p>

    <p class="text-gray-300">In our code implementation,  <span class="math">(E_{\\alpha}, E_{\\beta})</span>  equals  <span class="math">(E_4, E_6)</span> , a specific 2-cycle based on MNT curves of embedding degree 4 and 6, selected to have high 2-adicity (see Section 3.2). Thus, in the text below, " <span class="math">\\alpha = 4</span>  and  <span class="math">\\beta = 6</span> ". We obtain the following efficiency for the two circuits  <span class="math">C_{\\text{pcd},4}</span>  and  <span class="math">C_{\\text{pcd},6}</span> .</p>

    <p class="text-gray-300"><span id="page-18-4"></span><strong>Lemma 5.1</strong> (informal). Let  <span class="math">\\Pi: \\mathbb{F}_{r_4}^{n_{\\mathsf{msg}}} \\times \\mathbb{F}_{r_4}^{n_{\\mathsf{loc}}} \\times \\mathbb{F}_{r_4}^{s \\cdot n_{\\mathsf{msg}}} \\times \\mathbb{F}_{r_4} \\to \\mathbb{F}_{r_4}^l</span>  be an  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic compliance predicate for message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , arity s (and some output size l). The  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic circuit  <span class="math">C_{\\mathsf{pcd},6}</span>  have the following number of gates.</p>

    <p class="text-gray-300">| Gate count for <span class="math">C_{pcd,4}</span>        |                                          |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----------------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">------------------------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">(1+s)</span> copies of <span class="math">C_{H,6}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">(1+s)\\times 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s copies of <span class="math">C_{S,4\\leftarrow6}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">s \\times 298</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s copies of <span class="math">C_{V,6}</span> for <span class="math">n_6=2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">s \\times 89113</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">П</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> \\Pi </span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">misc.</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> \\Pi  + s \\cdot 89412</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|                                   | <span class="math">+(1+s) \\cdot n_{msg} \\cdot 298 + 11925</span> |  |</p>

    <p class="text-gray-300"><span id="page-18-2"></span></p>

    <p class="text-gray-300">| Gate count for <span class="math">C_{pcd,6}</span>                                   |              |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------------------------------------------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">32027</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we discuss the various subcircuits: for the zk-SNARK verifiers and for collision-resistant hashing.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-18-3"></span>Remark 5.2. We selected the PCD-friendly 2-cycle  <span class="math">(E_4, E_6)</span>  to have high 2-adicity: it has  <span class="math">\\nu_2(r_4-1)=34</span>  and  <span class="math">\\nu_2(r_6-1)=17</span> . These values are not accidental, but were chosen so that the 2-cycle  <span class="math">(E_4, E_6)</span>  suffices for "essentially all practical uses" of our PCD system. Specifically, recall that we would like, for efficiency reasons, that (i)  $\\nu_2(r_4-1) \\geq \\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{pcd},4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math">  and (ii)  </span>\\nu_2(r_6-1) \\geq \\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{pcd},6}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math">  (see Section 3.2 and Appendix C.2). First, since  </span>\\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{pcd},6}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil = 15<span class="math"> , Condition (ii) holds always. As for Condition (i), it depends on  </span>\\Pi<span class="math"> ; however, since  </span>\\nu_2(r_4-1)=34<span class="math">  is so large, it is not a limitation for practically-feasible choices of  </span>\\Pi$ . 15</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">5.1 Arithmetic circuits for zk-SNARK verifiers</h4>

    <p class="text-gray-300">We seek arithmetic circuits for the two zk-SNARK verifiers: an  <span class="math">\\mathbb{F}_{r_6}</span> -arithmetic circuit  <span class="math">C_{V,4}</span>  implementing  <span class="math">V_4</span>  and an  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic circuit  <span class="math">C_{V,6}</span>  implementing  <span class="math">V_6</span> . Note the field characteristics:  <span class="math">V_4</span> 's arithmetic operations are over  <span class="math">\\mathbb{F}_{q_4}</span>  (which is equal to  <span class="math">\\mathbb{F}_{r_4}</span> ) and  <span class="math">V_6</span> 's operations are over  <span class="math">\\mathbb{F}_{q_6}</span>  (which is equal to  <span class="math">\\mathbb{F}_{r_4}</span> ).</p>

    <p class="text-gray-300">We design and construct  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span> , each consisting of two subcircuits for the "offline" and "online" parts of the verifier (see Section 4.1), and achieve the following efficiency:</p>

    <p class="text-gray-300"><strong>Lemma 5.3</strong> (informal). Let  <span class="math">n, l \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">• There is an  <span class="math">\\mathbb{F}_{q_4}</span> -arithmetic circuit  <span class="math">C_{V,4}</span>  with size</p>

    <div class="my-4 text-center"><span class="math-block">(10 \\cdot l - 4) \\cdot n + 43,767</span></div>

    <p class="text-gray-300">that implements  <span class="math">V_4</span>  for all inputs  <span class="math">x \\in \\mathbb{F}^n_{r_4}</span>  such that each  <span class="math">x_i</span>  has at most l bits. (Naturally,  <span class="math">l \\leq \\lceil \\log r_4 \\rceil</span> .) Moreover,  <span class="math">C_{V,4}</span>  consists of two subcircuits,  <span class="math">C_{V,4}^{\\text{offline}}</span>  and  <span class="math">C_{V,4}^{\\text{offline}}</span> , implementing  <span class="math">V_4^{\\text{offline}}</span>  and  <span class="math">V_4^{\\text{offline}}</span> , with sizes</p>

    <p class="text-gray-300"><span class="math-block">12270</span>  and  <span class="math">(10 \\cdot l - 4) \\cdot n + 31,497</span> .</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>14</sup>The choice  <span class="math">(E_{\\alpha}, E_{\\beta}) = (E_4, E_6)</span> , rather than  <span class="math">(E_{\\alpha}, E_{\\beta}) = (E_6, E_4)</span> , is intentional. We expect  <span class="math">C_{\\text{pcd},\\alpha}</span>  to be larger than  <span class="math">C_{\\text{pcd},\\beta}</span>  (due to a larger number of checks), so that  <span class="math">E_{\\alpha}</span>  should be the curve with the higher 2-adicity. In this case,  <span class="math">E_4</span>  is twice as 2-adic as  <span class="math">E_6</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>&</sup>lt;sup>15</sup>More precisely, if we take  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ s \\cdot 89412<span class="math">  to be the leading terms in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{pcd,4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (which we expect to be the case), we obtain that  </span>\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ s \\cdot 89412) \\le 1 + \\max\\{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 17 + \\log s\\}$ , which is likely to be well below 34.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">• There is an  <span class="math">\\mathbb{F}_{q_6}</span> -arithmetic circuit  <span class="math">C_{V,6}</span>  with size</p>

    <div class="my-4 text-center"><span class="math-block">(10 \\cdot l - 4) \\cdot n + 83{,}181</span></div>

    <p class="text-gray-300">that implements  <span class="math">V_6</span>  for all inputs  <span class="math">x \\in \\mathbb{F}_{r_6}^n</span>  such that each  <span class="math">x_i</span>  has at most l bits. (Naturally,  <span class="math">l \\leq \\lceil \\log r_6 \\rceil</span> .) Moreover,  <span class="math">C_{V,6}</span>  consists of two subcircuits,  <span class="math">C_{V,6}^{\\text{offline}}</span>  and  <span class="math">C_{V,6}^{\\text{online}}</span> , implementing  <span class="math">V_6^{\\text{offline}}</span>  and  <span class="math">V_6^{\\text{online}}</span> , with sizes</p>

    <p class="text-gray-300"><span class="math-block">23325</span>  and  <span class="math">(10 \\cdot l - 4) \\cdot n + 59,856</span> .</p>

    <p class="text-gray-300">(In,  <span class="math">C_{\\mathsf{pcd},4}</span>  and  <span class="math">C_{\\mathsf{pcd},6}</span> , we set  <span class="math">(n,l) = (2, \\lfloor \\log r_6 \\rfloor)</span>  and  <span class="math">(n,l) = (1, \\lceil \\log r_4 \\rceil)</span>  for  <span class="math">C_{V,6}</span>  and  <span class="math">C_{V,4}</span> , respectively. Also, in Lemma 5.1, the reported size for  <span class="math">C_{V,4}^{\\mathrm{online}}</span>  is even smaller than  <span class="math">(10 \\cdot \\lceil \\log r_4 \\rceil - 4) \\cdot 1 + 31,497</span>  because we hardcode the processed verification key  <span class="math">\\mathsf{pvk}_4</span>  into  <span class="math">C_{V,4}^{\\mathrm{online}}</span> , which provides additional savings.)</p>

    <p class="text-gray-300">The zk-SNARK verifier protocol. The protocol of the zk-SNARK verifier V (recalled in Appendix C.3) consists of two parts: (a) use the verification key vk and input  <span class="math">\\vec{x} \\in \\mathbb{F}_r^n</span>  to compute an element  <span class="math">vk_{\\vec{x}} \\in \\mathbb{G}_1</span> ; and (b) use the verification key vk, element  <span class="math">vk_{\\vec{x}}</span> , and proof  <span class="math">\\pi</span> , to compute 12 pairings for the required checks.</p>

    <p class="text-gray-300"><strong>Prior techniques for fast program execution of</strong> V<strong>.</strong> The first part of V requires O(n) scalar multiplications in  <span class="math">\\mathbb{G}_1</span> , and can be efficiently performed via a suitable choice of variable-base multi-scalar multiplication techniques. The second part dominates V's efficiency for small n, and an efficient implementation is algorithmically more complex. Ben-Sasson at al. [BCTV14] address this second part by (i) obtaining optimized implementations of sub-components of a pairing, and then (ii) combining these in a way that is tailored to V's protocol. In short, after breaking a pairing into its two main parts, the <em>Miller loop</em> and the <em>final exponentiation</em>, and implementing both (using optimal pairings [Ver10] and other methods [SBCDPK09, GS10, KKC13]), they apply precomputation techniques to the verification key [GHS02, BLS03, Sc007] and share subcomputations of the Miller loop and final exponentiations across V's different pairing evaluations [Sol03, Sc005, GS06, Sc007].</p>

    <p class="text-gray-300">Our techniques for fast circuit verification of V. The high-level structure of our construction of  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span>  mirrors that of our software implementation of  <span class="math">V_4</span>  and  <span class="math">V_6</span> , itself based on techniques from [BCTV14]. Namely, both  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span>  also break an (optimal) pairing into a Miller loop and final exponentiation, and combine these components in a way that is tailored to the verifier protocol.</p>

    <p class="text-gray-300">However, our construction differs in how these two components are implemented, especially with regard to the Miller loop. This is because, in our setting, two main operations come "for free": (a) field operations over the circuit's field, and (b) nondeterministic guessing (i.e., auxiliary advice). In particular, <em>field divisions cost the same as field multiplications</em> (since we can guess the answer and check it).</p>

    <p class="text-gray-300">Traditional software implementions go to great lengths to avoid expensive field divisions (e.g., by use of projective coordinates instead of affine ones, and in "addition" and "doubling" steps in the Miller loop). By contrast, both  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span>  perform the Miller loop by using <em>affine</em> coordinates for both curve arithmetic and divisor evaluations [LMN10], which can be done very efficiently by nondeterministic arithmetic circuits.</p>

    <p class="text-gray-300">Moreover, sharing Miller loop subcomputation traditionally only applies to products of pairings, of which there are only two in the verifier. Instead, in our setting, such techniques extend to <em>ratios of products</em> of pairings, and can thus be applied to <em>every</em> pairing check in the verifier, to further improve efficiency.</p>

    <p class="text-gray-300">Overall, in our software implementation, the number of field multiplications used to <em>compute</em> the checks of  <span class="math">V_4</span> ,  <span class="math">V_6</span>  is  <span class="math">3.8 \\times, 3.2 \\times</span>  more than the number of those used by  <span class="math">C_{V,4}</span> ,  <span class="math">C_{V,6}</span>  to <em>verify</em> them, respectively.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">5.2 Arithmetic circuits for collision-resistant hashing</h4>

    <p class="text-gray-300">We also require arithmetic circuits for hashing: an  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic circuit  <span class="math">C_{H,4}</span>  for a collision-resistant function  <span class="math">H_4\\colon\\{0,1\\}^{m_{H,4}}\\to\\mathbb{F}^{d_{H,4}}_{r_4}</span>  such that  <span class="math">m_{H,4}\\geq \\left(\\ell_{\\mathsf{vk},6}(\\lceil\\frac{d_{H,4}\\cdot\\lceil\\log r_4\\rceil}{\\lfloor\\log r_6\\rfloor}\\rceil)+n_{\\mathsf{msg}}\\right)\\cdot\\lceil\\log r_4\\rceil;</span>  indeed,  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  uses  <span class="math">H_4</span>  to hash (the binary representation of) both the verification key  <span class="math">\\mathsf{vk}_6</span>  and a message z.</p>

    <p class="text-gray-300">We base collision-resistant hashing on subset-sum functions [Ajt96, GGH96], chosen to have an especially compact representation as arithmetic circuits over the zk-SNARK's "native field".</p>

    <p class="text-gray-300"><strong>Subset sums.</strong> For  <span class="math">p,d,m\\in\\mathbb{N}</span>  with p prime and  <span class="math">M\\in\\mathbb{Z}_p^{d\\times m}</span> , the subset-sum function  <span class="math">H_M\\colon\\{0,1\\}^m\\to\\mathbb{Z}_p^d</span>  maps an m-bit string x to  <span class="math">\\sum_{i=1}^m x_i M(i)</span> , where M(i) is the i-th column of M.<sup>16</sup> Designing and constructing an  <span class="math">\\mathbb{F}_p</span> -arithmetic circuit that verifies  <span class="math">H_M</span>  is straightforward, and only requires d gates (the j-th gate computes the j-th linear combination). The entries of M should be drawn at random. (To remove suspicion of trapdoors, M can be chosen, e.g., according to the digits of  <span class="math">\\pi</span> .)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Parameters.</strong> We set  <span class="math">H_4 := H_{M_4}</span>  for a random matrix  <span class="math">M_4 \\in \\mathbb{Z}_{r_4}^{d_{H,4} \\times m_{H,4}}</span>  and integers  <span class="math">d_{H,4}, m_{H,4} \\in \\mathbb{N}</span> . We have fixed the prime of the subset sum to be  <span class="math">r_4</span> ; this ensures that  <span class="math">C_{H,4}</span> , which is defined over  <span class="math">\\mathbb{F}_{r_4}</span> , works over the correct ring, and only requires  <span class="math">d_{H,4}</span>  gates. Next, for any given dimension  <span class="math">d_{H,4}</span>  and PCD message length  <span class="math">n_{\\text{msg}}</span> , we set the input length to  <span class="math">m_{H,4} := \\left(\\ell_{\\text{vk},6}(\\lceil \\frac{d_{H,4} \\cdot \\lceil \\log r_4 \\rceil}{\\lceil \\log r_6 \\rceil} \\rceil) + n_{\\text{msg}}\\right) \\cdot \\lceil \\log r_4 \\rceil</span> , to ensure the aforementioned condition on the input and output lengths. There remains to fix the output length  <span class="math">d_{H,4}</span> . This is delicate, because it affects security (and recall we aim at 80-bit security). Since  <span class="math">r_4</span>  is a 298-bit prime, it appears heuristically sufficient to fix  <span class="math">d_{H,4} = 1</span>  [JJ98]. In particular, this yields  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{H,4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 5.4 (boolean input). Ideally, we would like a collision-resistant function whose "natural" domain is strings of  <span class="math">\\mathbb{F}_{r_4}</span> -elements, rather than strings of bits (as in subset-sum functions). Indeed, converting a string  <span class="math">x \\in \\mathbb{F}_p^m</span>  to its binary representation  <span class="math">s \\in \\{0,1\\}^{m \\cdot \\lceil \\log p \\rceil}</span>  (in order to "prepare" the function's input) costs  <span class="math">m \\cdot \\lceil \\log p \\rceil</span>  gates, which is a nontrivial contribution to the size of  <span class="math">C_{\\text{pcd},\\alpha}</span>  unless one keeps m quite small (see Section 4). While a subset-sum function  <span class="math">H_M : \\{0,1\\}^m \\to \\mathbb{Z}_p^d</span>  continues to remain collision-resistant even for domains consisting of "small-norm" vectors (of which binary strings are a special case),  <span class="math">H_M</span>  is not collision-resistant (or even one-way) when the domain is enlarged to include all elements in  <span class="math">\\mathbb{Z}_p^m</span>  (simply because, being a linear function, it can be efficiently inverted). It is an open question whether the cost of converting to binary strings can be avoided, via some other choice of hash function.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">6 Scalable zk-SNARKs</h4>

    <p class="text-gray-300">Having constructed a PCD system (see Section 4 and Section 5), we use it to obtain a new zk-SNARK that is <em>scalable</em> (i.e., fully succinct and incrementally computable).</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">6.1 Specifying a machine</h4>

    <p class="text-gray-300">A notable feature of our zk-SNARK is generality: it can prove/verify correctness of executions on any given random-access machine M, specified by a memory configuration and a corresponding CPU circuit. For instance, M may encode a floating-point-arithmetic processor for running quantitative analysis programs; or, M may encode a SIMD-based architecture for running multimedia programs.</p>

    <p class="text-gray-300"><strong>Parameters.</strong> More precisely, a machine M is specified by a tuple  <span class="math">(A, W, N, CPU_{exe}, CPU_{ver})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A, W \\in \\mathbb{N}</span>  specify that (random-access) memory contains A addresses each storing W bits, i.e., that memory is a function  <span class="math">\\mathcal{M}: [A] \\to \\{0,1\\}^W</span> ;</li>

      <li><span class="math">N \\in \\mathbb{N}</span>  specifies the length, in bits, of a CPU state;</li>

      <li>CPU<sub>exe</sub> is a (stateful) function for <em>executing</em> the CPU;</li>

      <li>CPU<sub>ver</sub> is an F-arithmetic circuit for <em>verifying</em> the CPU's execution.</li>

    </ul>

    <p class="text-gray-300">We now elaborate on the above parameters. For more details, see Appendix A.2.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>16</sup>We do not require the hash function to be universal, so we do not need to add a random vector to the subset sum.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>17</sup>Recent works [LM06, PR06, LMPR08, ADLM<sup>+</sup>08, BLPRS13] use a small modulus and larger dimension, but our "native" modulus is already a large one.</p>

    <p class="text-gray-300"><strong>Execution on M.</strong> A computation on M proceeds in steps, as determined by  <span class="math">\\mathrm{CPU}_{\\mathsf{exe}}</span> , which can be thought of as M's "processor": step after step,  <span class="math">\\mathrm{CPU}_{\\mathsf{exe}}</span>  takes the previous state and instruction (and its address), executes the instruction, communicates with random-access memory, and produces the next state and instruction address. More precisely, each step consists of two phases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Instruction fetch. Given the current CPU state  <span class="math">s_{cpu} \\in \\{0,1\\}^N</span>  and address  <span class="math">a_{pc} \\in [A]</span>  of the instruction to be executed, the new instruction to be executed is fetched:  <span class="math">v_{pc} := \\mathcal{M}(a_{pc}) \\in \\{0,1\\}^W</span> .</li>

      <li>Instruction execution. For an auxiliary input  <span class="math">g \\in \\{0,1\\}^W</span> ,  <span class="math">CPU_{\\text{exe}}</span>  receives  <span class="math">(s_{\\text{cpu}}, a_{\\text{pc}}, v_{\\text{pc}}, g)</span>  and outputs  <span class="math">(a_{\\text{mem}}, v_{\\text{st}}, f_{\\text{st}})</span> , where  <span class="math">a_{\\text{mem}} \\in [A]</span>  is an address,  <span class="math">v_{\\text{st}} \\in \\{0,1\\}^W</span>  a value, and  <span class="math">f_{\\text{st}} \\in \\{0,1\\}</span>  a store flag Afterwards,  <span class="math">CPU_{\\text{exe}}</span>  receives  <span class="math">v_{\\text{Id}} := \\mathcal{M}(a_{\\text{mem}}) \\in \\{0,1\\}^W</span>  (i.e., the value at the address) and outputs a new CPU state  <span class="math">s&#x27;_{\\text{cpu}} \\in \\{0,1\\}^N</span> , an address  <span class="math">a&#x27;_{\\text{pc}} \\in [A]</span>  for the next instruction, and a flag  <span class="math">f&#x27;_{\\text{acc}} \\in \\{0,1\\}</span>  denoting whether the machine has accepted. Meanwhile, if a store was requested, it is performed: if  <span class="math">f_{\\text{st}} = 1</span>  then  <span class="math">\\mathcal{M}(a_{\\text{mem}}) := v_{\\text{st}}</span> . Finally, at the end of every step,  <span class="math">CPU_{\\text{exe}}</span> 's state is reset.</li>

    </ul>

    <p class="text-gray-300">See Figure 3 for a diagram of these two phases.</p>

    <p class="text-gray-300"><strong>Verification of the CPU.</strong> The circuit  <span class="math">CPU_{\\text{ver}}</span>  verifies the correct input/output relationship of  <span class="math">CPU_{\\text{exe}}</span>  (but <em>not</em> memory consistency). In other words  <span class="math">CPU_{\\text{exe}}</span>  satisfies the following property:</p>

    <pre><code class="language-text">Fix s_{\\sf cpu}, s&#x27;_{\\sf cpu} \\in \\{0,1\\}^N, a_{\\sf pc}, a_{\\sf mem}, a&#x27;_{\\sf pc} \\in [A], v_{\\sf pc}, v_{\\sf st}, v_{\\sf ld}, g \\in \\{0,1\\}^W, f_{\\sf st}, f&#x27;_{\\sf acc} \\in \\{0,1\\}, and let x_{\\sf ver} be the concatenation of all these. There is a witness a_{\\sf ver} such that {\\sf CPU}_{\\sf ver}(x_{\\sf ver}, a_{\\sf ver}) = 0 iff (a_{\\sf mem}, v_{\\sf st}, f_{\\sf st}) \\leftarrow {\\sf CPU}_{\\sf exe}(s_{\\sf cpu}, a_{\\sf pc}, v_{\\sf pc}, g) and, afterwards, (s&#x27;_{\\sf cpu}, a&#x27;_{\\sf pc}, f&#x27;_{\\sf acc}) \\leftarrow {\\sf CPU}_{\\sf exe}(v_{\\sf ld}). Moreover, a_{\\sf ver} can be efficiently computed from x_{\\sf ver}.</code></pre>

    <p class="text-gray-300"><span id="page-21-1"></span>While we do not care about how the function  <span class="math">CPU_{\\text{exe}}</span>  is specified (e.g., it can be a computed program),  <span class="math">CPU_{\\text{ver}}</span>  must be an arithmetic circuit; if  <span class="math">CPU_{\\text{ver}}</span>  is defined over  <span class="math">\\mathbb{F}</span> , we say that  <span class="math">\\mathbf{M}</span>  has <em>verification over</em>  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300"><img src="_page_21_Figure_7.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 3: The two phases in one step of execution of a random-access machine M.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8"><strong>6.2</strong> Construction summary</h3>

    <p class="text-gray-300">The construction of the new zk-SNARK consists of the following transformation:</p>

    <p class="text-gray-300"> The transformation's outline is as follows (see Section 2.3). First, given  <span class="math">\\mathbf{M}</span> , we design a compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  for the incremental verification of  <span class="math">\\mathbf{M}</span> 's execution, when its random-access memory  <span class="math">\\mathcal{M}</span>  is delegated via memory-checking techniques based on a collision-resistant hash H [BEGKN91, BCGT13a]. Then, we use the PCD system  <span class="math">(\\mathbb{G},\\mathbb{P},\\mathbb{V})</span>  to enforce the compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span> , and thereby construct the algorithms zk-SNARK  <span class="math">(G^\\star,P^\\star,V^\\star)</span>  of the new zk-SNARK, which is fully-succinct and incrementally-computable.</p>

    <p class="text-gray-300">For the first part, we again use field-specific subset-sum functions for constructing circuits that verify authentication paths (Section 6.3), and then combine these, together with M's CPU circuit, to construct  <span class="math">\\Pi_{\\mathbf{M},H}</span>  (Section 6.4). For the second part, the construction of the new zk-SNARK's three algorithms is fairly straightforward in light of previous work, and we include its details for completeness (Section 6.5).</p>

    <p class="text-gray-300">Later, in Section 7, we evaluate our scalable zk-SNARK when the machine M equals vnTinyRAM.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">6.3 Arithmetic circuits for secure loads and stores</h4>

    <p class="text-gray-300">We construct arithmetic circuits for checking loads/stores of an untrusted random-access memory, relative to a (trusted) root of a Merkle tree over the memory; this task is known as <em>memory checking</em> (see Remark 6.1).</p>

    <p class="text-gray-300">Let  <span class="math">A, W \\in \\mathbb{N}</span>  specify that memory contains A addresses each storing W bits, i.e., that memory is a function  <span class="math">\\mathcal{M} \\colon [A] \\to \\{0,1\\}^W</span> . Let  <span class="math">H \\colon \\{0,1\\}^m \\to \\{0,1\\}^\\ell</span>  be a collision-resistant function suitable for building binary Merkle trees over  <span class="math">\\mathcal{M}</span>  (i.e.,  <span class="math">m \\geq W</span>  and  <span class="math">m/\\ell \\geq 2</span> ); we say that H is (A, W)-good. For a field  <span class="math">\\mathbb{F}</span> , let  <span class="math">C_H</span>  be an  <span class="math">\\mathbb{F}</span> -arithmetic circuit that verifies H; we construct the following two  <span class="math">\\mathbb{F}</span> -arithmetic circuits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Secure load. A secure-load circuit  <span class="math">C_{\\mathsf{SecLd}}</span>  that, for a given address a, checks the validity of a loaded value v against a Merkle-tree root  <span class="math">\\rho</span> . More precisely, the circuit  <span class="math">C_{\\mathsf{SecLd}}</span>  satisfies the following property: for any root  <span class="math">\\rho \\in \\{0,1\\}^\\ell</span> , address  <span class="math">a \\in [A]</span> , value  <span class="math">v \\in \\{0,1\\}^W</span> , and authentication path  <span class="math">\\mathbf{p} \\in \\{0,1\\}^{W+(\\lceil \\log A \\rceil - 1)\\ell}</span> ,  <span class="math">C_{\\mathsf{SecLd}}(\\rho,a,v,\\mathbf{p})=0</span>  if and only if  <span class="math">\\mathbf{p}</span>  is a valid authentication path for the value v as the a-th leaf in a Merkle tree of root  <span class="math">\\rho</span> . One can verify that the size of such a circuit is  $\\lceil \\log A \\rceil \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2\\ell)<span class="math"> , because the check can be performed via  </span>\\lceil \\log A \\rceil<span class="math">  invocations of H plus  </span>2\\ell<span class="math">  gates per level.  </span>^{18}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Secure load-then-store. A secure-load-then-store circuit  <span class="math">C_{\\mathsf{SecLdSt}}</span>  that, for a given address a, checks: (i) the validity of a loaded value  <span class="math">v_{\\mathsf{Id}}</span>  against a Merkle-tree root  <span class="math">\\rho</span> ; and (ii) the validity of storing  <span class="math">v_{\\mathsf{st}}</span> , to the same address, against a (possibly different) Merkle-tree root  <span class="math">\\rho&#x27;</span> . More precisely, the circuit  <span class="math">C_{\\mathsf{SecLdSt}}</span>  satisfies the following property: for any two roots  <span class="math">\\rho, \\rho&#x27; \\in \\{0, 1\\}^{\\ell}</span> , address  <span class="math">a \\in [A]</span> , two values  <span class="math">v_{\\mathsf{Id}}, v_{\\mathsf{st}} \\in \\{0, 1\\}^{W}</span> , and authentication path  <span class="math">\\mathbf{p} \\in \\{0, 1\\}^{W+(\\lceil \\log A \\rceil - 1)\\ell}</span> ,  <span class="math">C_{\\mathsf{SecLdSt}}(\\rho, \\rho&#x27;, a, v_{\\mathsf{Id}}, v_{\\mathsf{st}}, \\mathbf{p}) = 0</span>  if and only if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>p is a valid authentication path for the value  <span class="math">v_{ld}</span>  as the a-th leaf in a Merkle tree of root  <span class="math">\\rho</span> , AND</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbf{p}</span>  is a valid authentication path for the value  <span class="math">v_{\\text{st}}</span>  as the a-th leaf in a Merkle tree of root  <span class="math">\\rho&#x27;</span> . One can verify that the size of such a circuit is  $\\lceil \\log A \\rceil \\cdot (2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 4\\ell)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Instantiation with subset-sum functions.</strong> We are left to choose the function H and construct  <span class="math">C_H</span> , required to obtain the two circuits  <span class="math">C_{SecLd}</span>  and  <span class="math">C_{SecLdSt}</span> .</p>

    <p class="text-gray-300">As in Section 5.2, subset-sum functions are a natural candidate, for efficiency considerations. Namely, since  <span class="math">\\mathbb{F}</span>  has prime order p, its additive group is isomorphic to  <span class="math">\\mathbb{Z}_p</span> ; hence, for  <span class="math">M \\in \\mathbb{Z}_p^{d \\times m}</span> , the subset-sum function  <span class="math">H_M \\colon \\{0,1\\}^m \\to \\mathbb{Z}_p^d</span>  can be computed with only d gates over  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Unlike Section 5.2, however, both  <span class="math">C_{\\mathsf{SecLd}}</span>  and  <span class="math">C_{\\mathsf{SecLdSt}}</span>  require H's outputs to be inputs to other invocations of H. Thus, here we treat a subset-sum function as having binary output:  <span class="math">H_M \\colon \\{0,1\\}^m \\to \\{0,1\\}^\\ell</span>  where  <span class="math">\\ell := d \\cdot \\lceil \\log p \\rceil</span> . Doing so requires additional gates, summing up to a total of  <span class="math">d + \\ell = d \\cdot (1 + \\lceil \\log p \\rceil)</span>  gates over  <span class="math">\\mathbb F</span>  to compute  <span class="math">H_M</span> . Moreover, the condition on input length is different: here we need to ensure that the function is (A, W)-good, which requires that  <span class="math">m \\ge \\max\\{W, 2\\ell\\} = \\max\\{W, 2d\\lceil \\log p \\rceil\\}</span> .</p>

    <p class="text-gray-300">Overall, if we set  <span class="math">H := H_M</span>  (for a random M), we can achieve circuit sizes that are:</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>18</sup>Specifically, in the <em>i</em>-th level,  <span class="math">\\ell</span>  gates ensure booleanity of the <em>i</em>-th chunk of the authentication path <strong>p</strong>, while another  <span class="math">\\ell</span>  gates prepare the correct input to the next invocation of H, depending on the <em>i</em>-th address bit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLd}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lceil \\log A \\rceil \\cdot d \\cdot (1 + 3\\lceil \\log p \\rceil)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In terms of concrete numbers, recalling from Section 5.2 that d=1 and  <span class="math">\\lceil \\log p \\rceil = 298</span> , we get that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLd}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lceil \\log A \\rceil \\cdot 895 \\text{ and }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLdSt}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lceil \\log A \\rceil \\cdot 1{,}790.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-23-1"></span><strong>Remark 6.1</strong> (memory checking). <em>Memory checking</em> was introduced by Blum et al. [BEGKN91]; they showed how to use Merkle hashing to delegate a machine's memory to an untrusted storage, and dynamically verify its consistency using only a small  <span class="math">poly(\\lambda)</span> -size "trusted" memory.</p>

    <p class="text-gray-300">Blum et al. instantiated Merkle hashing with <em>universal one-way hash functions</em> [NY89, Rom90]. Yet, in general, a machine's computation includes a "nondeterministic component", e.g., an auxiliary input. In such a case (as in this paper), Merkle hashing must be based on hash functions that are <em>collision resistant</em>.</p>

    <p class="text-gray-300">Memory checking techniques have found numerous practical applications for securing untrusted storages [MVS00, MS01, GSCvDD03, GSMB03, KRSWF03]. Ben-Sasson et al. [BCGT13a] suggested that verification of memory via Merkle hashing can be a useful computational alternative to the information-theoretic use of nondeterministic routing for efficient circuit generators. For instance, the recent circuit generator of Braun et al. [BFRS+13] uses memory checking to verify accesses to an untrusted storage.</p>

    <p class="text-gray-300">Given a random-access machine M and a (suitable) collision-resistant function H, we construct a compliance predicate  <span class="math">\\Pi_{M,H}</span>  that checks a step of execution of M. The transformation is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{array}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Briefly, a message z for  <span class="math">\\Pi_{\\mathbf{M},H}</span>  encodes a short representation of  <span class="math">\\mathbf{M}</span> 's state at a given time step. Then, at a node with input message  <span class="math">z_{\\text{in}}</span>  and output message  <span class="math">z_{\\text{out}}</span> , the compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  checks that the transition from the state in  <span class="math">z_{\\text{in}}</span>  to the state in  <span class="math">z_{\\text{out}}</span>  is a valid transition of the machine  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">Below, we make this plan more concrete by describing the format of messages and local data for  <span class="math">\\Pi_{M,H}</span> , and by describing the checks performed by  <span class="math">\\Pi_{M,H}</span> . See Figure 5 for details (and Appendix A.2 as reference).</p>

    <p class="text-gray-300">Format of messages. A message z summarizes M's entire state at a given time t, by storing the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a timestamp t, denoting how many computation steps have occurred;</li>

      <li>a root  <span class="math">\\rho</span>  of a Merkle tree of random-access memory (after t computation steps);</li>

      <li>a CPU state  <span class="math">s_{cpu}</span>  (after t computation steps); and</li>

      <li><span class="math">\\bullet</span>  a flag  <span class="math">f_{\\sf acc}</span>  denoting whether the machine has accepted (after t computation steps).</li>

    </ul>

    <p class="text-gray-300">Furthermore, z also stores  <span class="math">\\rho_0</span> , the root of a Merkle tree over initial memory, so to "remember" M's input. Note that a message z is short because the large memory is "summarized" by the short root of a Merkle tree.</p>

    <p class="text-gray-300"><strong>Format of local data.</strong> Now consider a node with input message  <span class="math">z_{in}</span>  and output message  <span class="math">z_{out}</span> . The goal of  <span class="math">\\Pi_{\\mathbf{M},H}</span>  is to verify  <span class="math">\\mathbf{M}</span> 's transition from  <span class="math">z_{in}</span>  to  <span class="math">z_{out}</span> , using two main tools:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CPU<sub>ver</sub> for checking CPU transitions, <em>given</em> consistent memory accesses ("what you store is what you get");</li>

      <li><span class="math">\\bullet</span>   <span class="math">C_{\\mathsf{SecLd}}</span>  and  <span class="math">C_{\\mathsf{SecLdSt}}</span>  for checking memory accesses.</li>

    </ul>

    <p class="text-gray-300">Thus, in the local data  <span class="math">z_{\\text{loc}}</span>  provided at a node, we store whatever auxiliary information is needed by  <span class="math">\\Pi_{\\mathbf{M},H}</span>  to evaluate  <span class="math">\\mathrm{CPU}_{\\text{ver}}</span>  (e.g., requested memory addresses, memory values, flags, etc.) and  <span class="math">C_{\\text{SecLd}}</span>  and  <span class="math">C_{\\text{SecLdSt}}</span>  (e.g., addresses, values, and authentication paths). Furthermore,  <span class="math">z_{\\text{loc}}</span>  includes a flag  <span class="math">f_{\\text{halt}}</span>  specifying whether the computation should halt or not (as, in such a case,  <span class="math">\\Pi_{\\mathbf{M},H}</span>  will perform a different set of checks).</p>

    <p class="text-gray-300">Construction. The compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  takes an input  <span class="math">(z_{\\mathsf{out}}, z_{\\mathsf{loc}}, z_{\\mathsf{in}}, b_{\\mathsf{base}})</span> , where  <span class="math">z_{\\mathsf{out}}</span>  is the outgoing message,  <span class="math">z_{\\mathsf{loc}}</span>  the local data,  <span class="math">z_{\\mathsf{in}}</span>  the incoming message, and  <span class="math">b_{\\mathsf{base}}</span>  the base-case flag, and must verify  <span class="math">\\mathbf{M}</span> 's transition from  <span class="math">z_{\\mathsf{in}}</span>  to  <span class="math">z_{\\mathsf{out}}</span> . (Thus,  <span class="math">\\Pi_{\\mathbf{M},H}</span>  has arity s=1.) Our construction of  <span class="math">\\Pi_{\\mathbf{M},H}</span>  goes as follows.</p>

    <p class="text-gray-300">In the base case (i.e.,  <span class="math">b_{\\mathsf{base}} = 1</span> ),  <span class="math">\\Pi_{\\mathbf{M},H}</span>  ensures that  <span class="math">z_{\\mathsf{in}}</span>  is correctly initialized: its timestamp, CPU state, instruction address, accept flag should all be set to zero;  <span class="math">\\Pi_{\\mathbf{M},H}</span>  also checks that the root of the Merkle tree of memory is equal to that of the Merkle tree of initial memory.</p>

    <p class="text-gray-300">Moreover, regardless of base case or not,  <span class="math">\\Pi_{M,H}</span>  always checks that the root of the Merkle tree of initial memory is preserved from  <span class="math">z_{\\text{in}}</span>  to  <span class="math">z_{\\text{out}}</span> , in order to not "forget" what the initial state of the machine was.</p>

    <p class="text-gray-300">When the computation does not halt (i.e.,  <span class="math">f_{\\mathsf{halt}} = 0</span> ),  <span class="math">\\Pi_{\\mathbf{M},H}</span>  checks that the timestamp is incremented by 1 and that  <span class="math">\\mathrm{CPU}_{\\mathsf{ver}}</span>  (on the appropriate inputs) accepts; furthermore, it uses  <span class="math">C_{\\mathsf{SecLd}}</span>  to check that the instruction was correctly loaded and  <span class="math">C_{\\mathsf{SecLdSt}}</span>  to check that the memory access (a load or a store) was correctly performed.</p>

    <p class="text-gray-300">When the computation does halt (i.e.,  <span class="math">f_{halt} = 1</span> ),  <span class="math">\\Pi_{M,H}</span>  first of all ensures that the computation has in fact accepted so far; then it clears out the root of the Merkle tree over memory and the CPU state (as these may leak information about the private auxiliary input) and ensures that the time step in  <span class="math">z_{out}</span>  is at least as large as the number of steps so far. (Again for privacy reasons,  <span class="math">\\Pi_{M,H}</span>  does not force  <span class="math">z_{out}</span>  to carry the exact number of computation steps, but only a number that is at least that much.)</p>

    <p class="text-gray-300">Overall, the above checks suffice for  <span class="math">\\Pi_{\\mathbf{M},H}</span>  to ensure that any  <span class="math">\\Pi_{\\mathbf{M},H}</span> -compliant distributed computation corresponds to correctly initializing, stepping through, and halting an accepting computation of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> By implementing  <span class="math">\\Pi_{\\mathbf{M},H}</span>  as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit, we obtain the following efficiency:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{\\mathbf{M},H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{CPU}_{\\mathsf{ver}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLd}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLdSt}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\varepsilon$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">,</p>

    <p class="text-gray-300">where  <span class="math">\\varepsilon</span>  is a "small but ugly" term, depending on  <span class="math">d, N, \\mathbb{F}</span> , that can be upper bounded as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon \\leq 2 \\cdot \\left(301 + 4N + 2\\ell + \\left\\lceil \\frac{301 + 4N + 2\\ell}{\\lfloor \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rfloor} \\right\\rceil \\right) + 24 \\left\\lceil \\frac{N}{\\lfloor \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rfloor} \\right\\rceil + 2N + 12 \\left\\lceil \\frac{\\ell}{\\lfloor \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rfloor} \\right\\rceil + \\ell + 10 \\enspace .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Crucially,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{\\mathbf{M},H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  only depends (nicely) on  </span>\\mathbf{M}<span class="math">  and H, but is independent of the computation length on  </span>\\mathbf{M}<span class="math"> : the term  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{CPU}_{\\mathsf{ver}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the cost of verifying  </span>\\mathbf{M}<span class="math"> &#x27;s CPU (and depends on &quot;how complex&quot; is the CPU); while the term  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLd}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLdSt}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lceil \\log A \\rceil \\cdot d \\cdot (3 + 9 \\lceil \\log p \\rceil)$  is the per-cycle cost to ensure memory consistency via collision-resistant hashing (see Section 6.3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-24-0"></span>In Section 7, we consider the case when M equals vnTinyRAM (a simple RISC von Neumann machine), with wordsizes  <span class="math">w \\in \\{16,32\\}</span>  and k=16 registers. In Figure 4 we report, for these cases, the size of  <span class="math">\\Pi_{\\mathbf{M},H}</span> , its sub-circuits, and the resulting PCD circuits  <span class="math">C_{\\mathsf{pcd},4}</span>  and  <span class="math">C_{\\mathsf{pcd},6}</span>  (which affect the PCD system's efficiency).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16-bit vnTinyRAM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32-bit vnTinyRAM</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(w,k) = (16,16)</td>

            <td class="px-3 py-2 border-b border-gray-700">(w,k) = (32,16)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CPU <sub>ver</sub></td>

            <td class="px-3 py-2 border-b border-gray-700">766</td>

            <td class="px-3 py-2 border-b border-gray-700">1,108</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> C_{SecLd} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">12,530</td>

            <td class="px-3 py-2 border-b border-gray-700">25,955</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> C_{SecLdSt} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">25,060</td>

            <td class="px-3 py-2 border-b border-gray-700">51,910</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">3501</td>

            <td class="px-3 py-2 border-b border-gray-700">4867</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> \\Pi_{\\mathbf{M},H} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">41,857</td>

            <td class="px-3 py-2 border-b border-gray-700">83,840</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">146 174</td>

            <td class="px-3 py-2 border-b border-gray-700">100.240</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> C_{pcd,4} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">146,174</td>

            <td class="px-3 py-2 border-b border-gray-700">189,349</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> C_{pcd,6} </span></td>

            <td class="px-3 py-2 border-b border-gray-700">32,027</td>

            <td class="px-3 py-2 border-b border-gray-700">32,027</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Sizes of the compliance predicate  <span class="math">\\Pi_{M,H}</span>  (and its sub-circuits) and the corresponding PCD circuits, for 16-bit and 32-bit vnTinyRAM.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark 6.2.</strong> The per-cycle cost of ensuring memory consistency via collision-resistant hashing (i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLd}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathsf{SecLdSt}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ) is typically much larger than that incurred when using nondeterministic routing (in [BCTV14], it is less than 1000). However, collision-resistant hashing ultimately enables scalability, whereas nondeterministic routing is not known to be useful for scalability (also see Section 8).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In particular, while in Section 7 we focus on the case  <span class="math">\\mathbf{M} = \\text{vnTinyRAM}</span> , for which  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{CPU}_{\\text{ver}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 10^3<span class="math"> , we could have chosen more complex machines. Indeed, even if  </span>\\mathrm{CPU}_{\\text{ver}}<span class="math">  had a few tens of thousands of gates, the size of  </span>\\Pi_{\\mathbf{M},H}<span class="math">  would remain on the order of  </span>10^5$  gates. In other words, our scalable zk-SNARK can accommodate much more complex machines at a relatively small additional cost.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-25-0"></span>Format of messages for  <span class="math">\\Pi_{M,H}</span> . A message z for the compliance predicate  <span class="math">\\Pi_{M,H}</span>  is a tuple</p>

    <pre><code class="language-text">z = (\\rho_0, t, \\rho, s_{\\text{cpu}}, f_{\\text{acc}})
where:
• \\rho_0 \\in \\{0,1\\}^{\\ell} is an output of H; allegedly, it is the root of a Merkle tree whose leaves are a program \\mathcal{P} (i.e., initial memory).
• t \\in \\{0,1\\}^{300} is a timestamp; allegedly, it is the number of computation steps so far.
   (For concreteness, we bound all computations to 2^{300} steps, which is big enough to accommodate computations in the foreseeable future.)
• \\rho \\in \\{0,1\\}^{\\ell} is an output of H; allegedly, it is the root of a Merkle tree whose leaves are \\mathcal{M}_t (memory after t steps).
• s_{cpu} \\in \\{0,1\\}^N is a CPU state; allegedly, it is the machine&#x27;s CPU state after t steps of computation.
• f_{acc} \\in \\{0,1\\} is a flag which denotes whether the machine has accepted so far or not.
The length n_{\\text{msg}} of a message is equal to 2\\ell + 300 + N + 1.
Format of local data for \\Pi_{M,H}. Local data z_{loc} for the compliance predicate \\Pi_{M,H} is a tuple
                                            z_{\\rm loc} = (a_{\\rm pc}, a_{\\rm mem}, a_{\\rm pc}&#x27;, v_{\\rm pc}, v_{\\rm st}, v_{\\rm ld}, g, f_{\\rm st}, f_{\\rm halt}, a_{\\rm ver}, \\mathbf{p}_{\\rm pc}, \\mathbf{p}_{\\rm mem})
where:
• a_{pc}, a_{mem}, a&#x27;_{pc} \\in [A] are memory addresses.
• v_{\\text{pc}}, v_{\\text{st}}, v_{\\text{Id}} \\in \\{0, 1\\}^W are memory values.
• g \\in \\{0,1\\}^W is a non-deterministic guess.
• f_{st}, f_{halt} \\in \\{0, 1\\} are flags.
• a_{\\text{ver}} is a witness for the \\mathbb{F}-arithmetic circuit CPU_{\\text{ver}}.
• \\mathbf{p}_{pc}, \\mathbf{p}_{mem} \\in \\{0,1\\}^{W+(\\lceil \\log A \\rceil - 1)\\ell} are authentication paths for Merkle trees over memory.
The length n_{loc} of local data is equal to (3+2\\ell) \\cdot \\lceil \\log A \\rceil + 6W + 2 - 2\\ell + |a_{ver}|.
Compliance predicate \\Pi_{M,H}.
• INPUTS:
   - output PCD message z_{\\text{out}} = (\\rho&#x27;_0, t&#x27;, \\rho&#x27;, s&#x27;_{\\text{cpu}}, f&#x27;_{\\text{acc}}) \\in \\{0, 1\\}^{n_{\\text{msg}}}
   - local data z_{\\text{loc}} = (a_{\\text{pc}}, a_{\\text{mem}}, a&#x27;_{\\text{pc}}, v_{\\text{pc}}, v_{\\text{st}}, v_{\\text{ld}}, g, f_{\\text{st}}, f_{\\text{halt}}, a_{\\text{ver}}, \\mathbf{p}_{\\text{pc}}, \\mathbf{p}_{\\text{mem}}) \\in \\{0, 1\\}^{n_{\\text{loc}}}
   - input PCD message z_{in} = (\\rho_0, t, \\rho, s_{cpu}, f_{acc}) \\in \\{0, 1\\}^{n_{msg}}
   - base case flag b_{\\mathsf{base}} \\in \\{0, 1\\}
• OUTPUTS: 0 iff all checks passed
1. If b_{\\text{base}} = 1 (i.e., base case):
      (a) Check that t=0, s_{\\text{cpu}}=0^N, a_{\\text{pc}}=0, f_{\\text{acc}}=0.
     (b) Check that the root of the Merkle tree of current memory is correctly initialized: \\rho&#x27; = \\rho_0.
2. Check that the root of the Merkle tree of initial memory is copied over: \\rho&#x27;_0 = \\rho_0.
3. If f_{halt} = 0 (i.e., do not halt):
      (a) Check that the timestamp is incremented: t&#x27; = t + 1.
      (b) Set x_{\\mathsf{ver}} := (s_{\\mathsf{cpu}}, s&#x27;_{\\mathsf{cpu}}, a_{\\mathsf{pc}}, a_{\\mathsf{mem}}, a&#x27;_{\\mathsf{pc}}, v_{\\mathsf{pc}}, v_{\\mathsf{st}}, v_{\\mathsf{ld}}, g, f_{\\mathsf{st}}, f&#x27;_{\\mathsf{acc}}) and check that \\mathrm{CPU}_{\\mathsf{ver}}(x_{\\mathsf{ver}}, a_{\\mathsf{ver}}) = 0 .
      (c) Check that the instruction is correctly loaded: C_{\\rm SecLd}(\\rho,a_{\\rm pc},v_{\\rm pc},{\\bf p}_{\\rm pc})=0 .
      (d) If f_{st} = 0 (i.e., no store), then check that v_{ld} = v_{st}.
      (e) Check that the load-then-store is correct: C_{\\text{SecLdSt}}(\\rho, \\rho&#x27;, a_{\\text{mem}}, v_{\\text{ld}}, v_{\\text{st}}, \\mathbf{p}_{\\text{mem}}) = 0.
4. If f_{halt} = 1 (i.e., do halt):
      (a) Check that the machine has accepted: f_{\\rm acc}=1 .
      (b) Check that the root and the CPU state have been cleared: \\rho&#x27; = 0^{\\ell}, s&#x27;_{\\text{cpu}} = 0^{N}.
      (c) Check that the timestamp is not less than the computation time: t&#x27; \\geq t.
      (d) Check that the accept flag is copied over: f&#x27;_{acc} = f_{acc}.</code></pre>

    <p class="text-gray-300">Figure 5: Construction of the compliance predicate  <span class="math">\\Pi_{M,H}</span>  from M and H.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">6.5 The new zk-SNARK construction</h4>

    <p class="text-gray-300">We now explain how to use a PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span> , invoked on  <span class="math">\\Pi_{\\mathbf{M}, H}</span> , to construct a scalable zk-SNARK for random-access machines; see Figure 6 for the construction's pseudocode.</p>

    <p class="text-gray-300">Construction of  <span class="math">G^<em></span> . The key generator  <span class="math">G^</em></span>  takes a random-access machine  <span class="math">\\mathbf{M}</span>  as input, and must output a key pair that enables anyone to prove/verify correctness of computations on  <span class="math">\\mathbf{M}</span> . Recall that the PCD generator  <span class="math">\\mathbb{G}</span>  expects as input an  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate. Thus,  <span class="math">G^*</span>  constructs the  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span> , for a suitable choice of collision-resistant function H; it invokes  <span class="math">\\mathbb{G}</span>  on  <span class="math">\\Pi_{\\mathbf{M},H}</span>  to generate a key pair  <span class="math">(\\mathsf{pk}_{\\mathsf{pcd}}, \\mathsf{vk}_{\\mathsf{pcd}})</span> ; and, finally, it outputs  <span class="math">(\\mathsf{pk}, \\mathsf{vk})</span>  where  <span class="math">\\mathsf{pk} := (\\mathbf{M}, H, \\mathsf{pk}_{\\mathsf{pcd}})</span>  and  <span class="math">\\mathsf{vk} := (\\mathbf{M}, H, \\mathsf{vk}_{\\mathsf{pcd}})</span> .</p>

    <p class="text-gray-300">More precisely, the key pair (pk, vk) allows to prove/verify membership of instances in the language  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span>  of accepting computations on  <span class="math">\\mathbf{M}</span> , i.e., the language consisting of pairs  <span class="math">(\\mathcal{P},T)</span>  such that: (i)  <span class="math">\\mathcal{P}</span>  is a program for  <span class="math">\\mathbf{M}</span>  (a program is just an initial memory state); (ii) T is a time bound; (iii) there exists an auxiliary input  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span>  accepts in at most T steps. (See Definition A.2 for a more formal discussion of  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span> .)</p>

    <p class="text-gray-300">Construction of  <span class="math">P^<em></span> . The prover  <span class="math">P^</em></span>  takes as input a proving key pk, program  <span class="math">\\mathcal{P}</span> , time bound T, and auxiliary input  <span class="math">\\mathcal{G}</span> , and must output a proof  <span class="math">\\pi</span>  for the claim " <span class="math">(\\mathcal{P},T)\\in\\mathcal{L}_{\\mathbf{M}}</span> ". Recall that the PCD prover  <span class="math">\\mathbb{P}</span>  expects as input a proving key  <span class="math">\\operatorname{pk}_{\\operatorname{pcd}}</span> , output message z, local data  <span class="math">z_{\\operatorname{loc}}</span> , input message  <span class="math">z_{\\operatorname{in}}</span> , and (in the non-base case) also a corresponding proof  <span class="math">\\pi_{\\operatorname{in}}</span> . Thus,  <span class="math">P^<em></span>  steps through the computation of  <span class="math">\\mathbf{M}</span>  on  <span class="math">\\mathcal{P}</span> , at each step generating a new message and proof, by using a previous message and proof; throughout,  <span class="math">P^</em></span>  maintains a Merkle tree over random-access memory. Concretely, at each step,  <span class="math">P^<em></span>  executes the CPU of  <span class="math">\\mathbf{M}</span> , handles any memory loads or stores, and prepares the necessary  <span class="math">\\Pi_{\\mathbf{M},H}</span> -compliant inputs for  <span class="math">\\mathbb{P}</span>  in order to compute the next proof; and then it continues to the next step. After T steps of computation,  <span class="math">P^</em></span>  produces a final proof, relative to a specially-constructed message  <span class="math">z_{\\operatorname{fin}}</span> , which clears from a message all but essential information (so not to compromise zero knowledge), and outputs the final proof.</p>

    <p class="text-gray-300">Construction of  <span class="math">V^<em></span> . The verifier  <span class="math">V^</em></span>  takes as input a verification key vk, program  <span class="math">\\mathcal{P}</span> , time bound T, and proof  <span class="math">\\pi</span> , and must output a bit indicating whether  <span class="math">\\pi</span>  is a convincing proof for the claim " <span class="math">(\\mathcal{P},T)\\in\\mathcal{L}_{\\mathbf{M}}</span> ". Recall that the PCD verifier  <span class="math">\\mathbb{V}</span>  expects as input a verification key vk<sub>pcd</sub>, message z, and proof  <span class="math">\\pi</span> . Thus,  <span class="math">V^*</span>  constructs a message z, corresponding to a "halted and accepted" computation of  <span class="math">\\mathbf{M}</span>  on  <span class="math">\\mathcal{P}</span>  (cf. the construction of  <span class="math">\\Pi_{\\mathbf{M},H}</span> ), and then accepts if and only if  <span class="math">\\mathbb{V}(\\mathsf{pk}_{\\mathsf{pcd}},z,\\pi)</span>  does.</p>

    <p class="text-gray-300">Preparing the message z requires computing the root  <span class="math">\\rho_0</span>  of a Merkle tree over the program  <span class="math">\\mathcal{P}</span> . In fact, computing  <span class="math">\\rho_0</span>  can be done even before receiving the proof  <span class="math">\\pi</span> , as it only requires knowledge of H and  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300"><strong>Security.</strong> Suppose that  <span class="math">V^*</span>  accepts a proof  <span class="math">\\pi</span>  for an instance  <span class="math">(\\mathcal{P},T)</span> . Then the PCD verifier  <span class="math">\\mathbb{V}</span>  accepted  <span class="math">\\pi</span>  for a message z, constructed from  <span class="math">\\mathcal{P}</span>  and T, that corresponds to a "halted and accepted" computation. By construction of the compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  and the security of  <span class="math">\\mathbb{V}</span> , we deduce that  <span class="math">(\\mathcal{P},T)\\in\\mathcal{L}_{\\mathbf{M}}</span> . (And proof of knowledge is inherited from the proof of knowledge of the PCD system.)</p>

    <p class="text-gray-300"><strong>Scalability.</strong> From the above description (and the pseudocode in Figure 6), one can verify that  <span class="math">(G^<em>, P^</em>, V^*)</span>  is both fully succinct and incrementally computable.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>&</sup>lt;sup>19</sup>Of course, to perform this step in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , one should not explicitly build a Merkle tree over all of memory, but instead build the Merkle tree by considering only the <em>non-zero</em> memory entries specified by  </span>\\mathcal{P}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <pre><code class="language-text">New zk-SNARK generator G
                                ?
 • INPUTS: a random-access machine M = (A, W, N, CPUexe, CPUver) with verification over F
 • OUTPUTS: proving key pk and verification key vk
 1. Select any (A, W)-good collision-resistant hash function H.
 2. Construct CH, an F-arithmetic circuit implementing H.
 3. Use M and CH to construct the compliance predicate ΠM,H.
 4. Compute (pkpcd, vkpcd) := G(ΠM,H).
 5. Set pk := (M, H, pkpcd) and vk := (M, H, vkpcd).
 6. Output (pk, vk).
 New zk-SNARK prover P
                             ?
 • INPUTS: proving key pk, program P, time bound T, and auxiliary input G = (g0, g1, . . . , gT −1)
 • OUTPUTS: proof π for the instance (P, T)
 1. Use H to compute ρ0, the root of the Merkle tree over P.
 2. Initialize memory to the given program: M0 := P.
 3. Initialize the CPU state and instruction address to zero: scpu,0 := 0N and apc,0 := 0.
 4. Initialize the first message: zmsg,0 := (ρ0, 0, ρ0, scpu,0, 0).
 5. Initialize the first proof to empty: π0 := ⊥.
 6. For i = 0, . . . , T − 1, compute the next message zmsg,i+1 and proof πi+1 as follows:
     (a) Give CPUexe
         • the current CPU state (scpu,i ∈ {0, 1}
                                                  N ),
         • address of the instruction to be executed (apc,i ∈ [A]),
         • instruction to be executed (vpc,i := Mi(apc,i) ∈ {0, 1}
                                                                    W ), and
         • guess (gi ∈ {0, 1}
                               W ).
     (b) Get from CPUexe
         • an address (amem,i ∈ [A]),
         • value (vst,i ∈ {0, 1}
                                 W ), and
         • store flag (fst,i ∈ {0, 1}).
     (c) Give CPUexe the value at the address (vld,i := Mi(amem,i) ∈ {0, 1}
                                                                               W ).
     (d) Set Mi+1 to equal Mi; if a store was requested (i.e., fst,i = 1), do it (i.e., Mi+1(amem,i) := vst,i).
     (e) Compute ρi+1 (the root of the Merkle tree over Mi+1) from ρi.
     (f) Get from CPUexe
         • a new CPU state (scpu,i+1 ∈ {0, 1}
                                                N ),
         • an address for the next instruction (apc,i+1 ∈ [A]), and
         • a flag denoting whether the machine has accepted (facc,i+1 ∈ {0, 1}).
         Reset CPUexe&#x27;s state.
     (g) Create the next message: zmsg,i+1 := (ρ0, i + 1, ρi+1, scpu,i+1, facc,i+1).
     (h) Deduce aver from xver := (scpu,i, scpu,i+1, apc,i, amem,i, apc,i+1, vpc,i, vst,i, vld,i, gi, fst,i, facc,i+1).
     (i) Let ppc,i (resp., pmem,i) be the authentication path for address apc,i (resp., amem,i) in Mi.
     (j) Create local data: zloc,i+1 := (apc,i, amem,i, apc,i+1, vpc,i, vst,i, vld,i, gi, facc,i+1, 0, aver, ppc,i, pmem,i).
     (k) Compute the next proof: πi+1 := P(pkpcd, zmsg,i+1, zloc,i+1, zi, πi).
 7. Prepare the final message: zmsg,fin := (ρ0, T, 0
                                                   \`
                                                    , 0
                                                       N , 1).
 8. Prepare the final local data: zloc,fin := (∗, ∗, ∗, ∗, ∗, ∗, ∗, ∗, 1, ∗, ∗, ∗), where ∗ can be set to anything of the right length.
 9. Compute the final proof: π := P(pkpcd, zmsg,fin, zloc,fin, zT , πT ).
10. Output π.
 New zk-SNARK verifier V
                             ?
 • INPUTS: verification key vk, program P, time bound T, and proof π
 • OUTPUTS: decision bit
 1. Use H to compute ρ0, the root of the Merkle tree over P. (This can also be done beforehand.)
 2. Construct the message z := (ρ0, T, 0
                                          \`
                                           , 0
                                             N , 1).
 3. Accept if and only if V(vkpcd, z, π) = 1.</code></pre>

    <p class="text-gray-300">Figure 6: Construction of a scalable zk-SNARK for random-access machines.</p>

    <p class="text-gray-300">We evaluate our scalable zk-SNARK when the given random-access machine M equals vnTinyRAM, a simple RISC von Neumann architecture [BCTV14, BCGTV13b]. For comparison, we also compare [BCTV14]'s preprocessing zk-SNARK (which also supports vnTinyRAM) with our scalable zk-SNARK.</p>

    <p class="text-gray-300">We ran our experiments on a desktop PC with a 3.40 GHz Intel Core i7-4770 CPU and 16 GB of RAM available. Unless otherwise specified, all times are in single-thread mode; as for our multi-core experiments, we enabled one thread for each of the CPU's 4 cores (for a total of 4 threads).</p>

    <p class="text-gray-300"><strong>Recalling</strong> vnTinyRAM. The architecture vnTinyRAM is parametrized by the <em>word size</em>, denoted w, and the <em>number of registers</em>, denoted k. In terms of instructions, vnTinyRAM includes load and store instructions for accessing random-access memory (in byte or word blocks), as well as simple integer, shift, logical, compare, move, and jump instructions. Thus, vnTinyRAM can efficiently implement control flow, loops, subroutines, recursion, and so on. Complex instructions (e.g., floating-point arithmetic) are not directly supported and can be implemented "in software". See Appendix A.3 for how vnTinyRAM can be expressed in our random-access machine formalism (i.e., given w, k, how to construct M to express w-bit vnTinyRAM with k registers).</p>

    <p class="text-gray-300">Costs on vnTinyRAM. The performance of our zk-SNARK  <span class="math">(G^<em>, P^</em>, V^<em>)</span>  on vnTinyRAM is easy to characterize, because it is determined by few quantities. For the key generator  <span class="math">G^</em></span> , the relevant quantities are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the constant time and space complexity of  <span class="math">G^*</span> , when given as input a description of vnTinyRAM; and</li>

      <li>the constant sizes of the generated proving key pk and verification key vk.</li>

    </ul>

    <p class="text-gray-300">For the proving algorithm  <span class="math">P^*</span> , which proceeds step by step alongside the original computation, they are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the constant time necessary to incrementally compute the new (constant-size) proof at each step; and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the constant space needed to compute the new proof (on top of the space needed by the original program). Finally, the verifier  <span class="math">V^*</span>  takes as input a program  <span class="math">\\mathcal P</span>  and a time bound T, and runs in time  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log T)<span class="math"> ; in our implementation, we fix  </span>T \\leq 2^{300}<span class="math">  (plenty enough), so that  </span>V^*<span class="math">  runs in time  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Figure 7, we report our measurements for two settings of vnTinyRAM: (w,k)=(16,16) and (w,k)=(32,16), i.e., 16-bit and 32-bit vnTinyRAM with 16 registers. (The same settings as in [BCTV14].)</p>

    <p class="text-gray-300"><strong>Comparison with [BCTV14].</strong> In Figure 8, we compare the efficiency of [BCTV14]'s preprocessing zk-SNARK and our scalable zk-SNARK, for a (random) program  <span class="math">\\mathcal{P}</span>  of  <span class="math">10^4</span>  instructions, as a function of T (the number of vnTinyRAM computation steps).</p>

    <p class="text-gray-300">The (approximate) asymptotic efficiency for [BCTV14] was obtained by linearly interpolating [BCTV14]'s measurements (which were collected on a machine with similar characteristics as our benchmarking machine). As for our measurements, we use the relevant numbers from Figure 7.</p>

    <p class="text-gray-300"><strong>Conclusion.</strong> Our experiments demonstrate that, as expected, our approach is slower for small computations but, on the other hand, offers scalability to large computations by avoiding any space-intensive computations. Indeed, [BCTV14] (as well as other preprocessing zk-SNARK implementations [PGHR13, BCGTV13a])</p>

    <p class="text-gray-300">require space-intensive computations to maintain their efficiency. As T grows, such approaches simply run out of memory, and must resort to "computing in blocks", sacrificing time complexity.<sup>21</sup></p>

    <p class="text-gray-300">In contrast, our zk-SNARK, while requiring more time per execution step, merely requires a constant amount of memory to prove any number of execution steps. In particular, our zk-SNARK becomes more space-efficient than [BCTV14]'s zk-SNARK when T>422 for 16-bit vnTinyRAM, and when T>321 for 32-bit vnTinyRAM; moreover, these savings in space grow unbounded as T increases.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>20</sup>The prover also needs to store the Merkle tree's intermediate hashes, which incurs a linear overhead in the program's space complexity. Since this overhead is small, and can even be reduced by saving only the high levels of the Merkle tree (and recomputing, "on demand", the local neighborhood of accessed leaves), we focus on the fixed additive overhead needed to generate the proof.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>21</sup>Extending known preprocessing zk-SNARK implementations with block-computing techniques, and precisely quantifying their cost, remains a challenging open question that we leave to future work.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16-bit vnTinyRAM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32-bit vnTinyRAM</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(w, k) = (16, 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">(w, k) = (32, 16)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">key generator G?</h4>

    <p class="text-gray-300"><span id="page-29-0"></span></p>

    <p class="text-gray-300">|         | TIME     |                      |                       |          |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----------</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">33.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9 s<br>42.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15.5 s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|         | SPACE    |                      |                       |          |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">memory</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">861 MB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,125 MB<br>1,068 MB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,343 MB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">vk size</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 kB</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">prover P ?</h4>

    <p class="text-gray-300">|          | TIME     |                       |        |           |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----------</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">per step</td>

            <td class="px-3 py-2 border-b border-gray-700">24.2 s</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3 s</td>

            <td class="px-3 py-2 border-b border-gray-700">26.2 s</td>

            <td class="px-3 py-2 border-b border-gray-700">9.0 s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|          | SPACE    |                       |        |           |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">memory</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">800 MB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,063 MB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">993 MB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,268 MB</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">verifier V ?</h4>

    <p class="text-gray-300">|            | TIME                      |                           |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">--</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P  = 102</td>

            <td class="px-3 py-2 border-b border-gray-700">23.7 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">24.5 ms</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P  = 103</td>

            <td class="px-3 py-2 border-b border-gray-700">29.8 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">30.8 ms</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P  = 104</td>

            <td class="px-3 py-2 border-b border-gray-700">90.9 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">94.2 ms</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">in general</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ (23.08 + 0.00676 P ) ms</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ (23.78 + 0.00702 P ) ms</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: Performance of our scalable zk-SNARK on 16-bit and 32-bit vnTinyRAM. (The reported times are the average of 20 experiments, with standard deviation less than 1%.)</p>

    <p class="text-gray-300"><span id="page-29-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">key generator</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">key sizes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">TIME</td>

            <td class="px-3 py-2 border-b border-gray-700">SPACE</td>

            <td class="px-3 py-2 border-b border-gray-700">pk</td>

            <td class="px-3 py-2 border-b border-gray-700">vk</td>

            <td class="px-3 py-2 border-b border-gray-700">TIME</td>

            <td class="px-3 py-2 border-b border-gray-700">SPACE</td>

            <td class="px-3 py-2 border-b border-gray-700">TIME</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16-bit vnTinyRAM</td>

            <td class="px-3 py-2 border-b border-gray-700">[BCTV14]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08 · T s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8 · T MB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3 · T MB</td>

            <td class="px-3 py-2 border-b border-gray-700">40.4 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04 · T s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9 · T MB</td>

            <td class="px-3 py-2 border-b border-gray-700">24.2 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(w, k) = (16, 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">33.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">861 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">43 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">24.2 · T s</td>

            <td class="px-3 py-2 border-b border-gray-700">800 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">90.9 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32-bit vnTinyRAM</td>

            <td class="px-3 py-2 border-b border-gray-700">[BCTV14]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13 · T s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1 · T MB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4 · T MB</td>

            <td class="px-3 py-2 border-b border-gray-700">80.3 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05 · T s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1 · T MB</td>

            <td class="px-3 py-2 border-b border-gray-700">41.0 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(w, k) = (32, 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">42.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">1,068 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">55 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">26.2 · T s</td>

            <td class="px-3 py-2 border-b border-gray-700">993 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">94.2 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 8: Comparison between [\\[BCTV14\\]](#page-43-5)'s preprocessing zk-SNARK and our scalable zk-SNARK.</p>

    <p class="text-gray-300"><strong>VIPS.</strong> Finally, being scalable, our zk-SNARK implementation is the first to achieve a well-defined clock rate of <em>verified instructions per second</em> (VIPS). For vnTinyRAM, we obtain the following VIPS values:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16-bit vnTinyRAM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32-bit vnTinyRAM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(w,k) = (16,16)</td>

            <td class="px-3 py-2 border-b border-gray-700">(w,k) = (32,16)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 thread</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">VIPS = \\frac{1}{24.2}Hz</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">VIPS = \\frac{1}{26.2}Hz</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 threads</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">VIPS = \\frac{1}{8.3}Hz</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">VIPS = \\frac{1}{9.0}Hz</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">While perhaps too slow for most applications, our prototype empirically demonstrates the feasibility of the bootstrapping approach as a way to achieve scalability of zk-SNARKs and, more generally, to achieve the rich functionality of proof-carrying data.</p>

    <p class="text-gray-300"><strong>Higher clock rate.</strong> There are ample opportunities for improving the clock rate of "verified instructions per second". Besides potential improvements in the cryptographic protocol and elliptic curves, there is also an engineering challenge. In particular, the algorithms are highly amenable to parallelism and hardware support. Since each step of proof generation in our zk-SNARK is a <em>constant-size</em> operation, it could even be carefully optimized and wholly implemented in a fixed-sized, general-purpose "proving processor" hardware.</p>

    <p class="text-gray-300">Other PCD-friendly cycles. The PCD-friendly 2-cycle proposed in this paper facilitates a great improvement in the efficiency of recursively composing pairing-based zk-SNARKs. Do there exist any other PCD-friendly 2-cycles, not based on MNT curves? Or cycles of length greater than 2? Are these easier to find, achieve smaller bit size and higher 2-adicity, or admit faster nondeterministic pairing verification? Investigating these questions may lead to further efficiency improvements to recursive proof composition. Another consideration is that, with MNT-based PCD-friendly cycles, increasing the security level is costly, since one of the curves has low embedding degree (k = 4, for which 128-bit security requires  <span class="math">q_4 \\ge 2^{750}</span>  [FST10]).</p>

    <p class="text-gray-300">Alternative zk-SNARKs constructions. What are the advantages or disadvantages of pairing-based zk-SNARKs in which the pairing is not instantiated via a pairing-friendly elliptic curve, but instead via lattice techniques [GGH13]? Moreover, are there preprocessing zk-SNARKs that are not based on pairings? (E.g., can they be based on groups without bilinear maps?)</p>

    <p class="text-gray-300">We thank Andrew V. Sutherland for generous help in running the CM method on elliptic curves with large discriminants. We thank Damien Stehlé and Daniele Micciancio for discussions about the security of subset-sum functions. We thank Koray Karabina for answering questions about algorithms in [KT08].</p>

    <p class="text-gray-300">This work was supported by: the Broadcom Foundation and Tel Aviv University Authentication Initiative; the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370; the Check Point Institute for Information Security; the European Community's Seventh Framework Programme (FP7/2007-2013) under grant agreement number 240258; the Israeli Centers of Research Excellence I-CORE program (center 4/11); the Israeli Ministry of Science and Technology; the Leona M. & Harry B. Helmsley Charitable Trust; the Simons Foundation, with a Simons Award for Graduate Students in Theoretical Computer Science; and the Skolkovo Foundation with agreement dated 10/26/2011.</p>

    <p class="text-gray-300">We introduce notions and notations for two computation models used in this paper: <em>arithmetic circuits</em> (see Appendix A.1) and <em>random-access machines</em> (see Appendix A.2).</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">A.1 Arithmetic circuits</h3>

    <p class="text-gray-300">We work with circuits that are not boolean but <em>arithmetic</em>. Given a field  <span class="math">\\mathbb{F}</span> , an  <span class="math">\\mathbb{F}</span> -arithmetic circuit takes inputs that are elements in  <span class="math">\\mathbb{F}</span> , and its gates output elements in  <span class="math">\\mathbb{F}</span> . We naturally associate a circuit with the function it computes. The circuits we consider only have <em>bilinear gates</em>, <sup>22</sup> and a circuit's <em>size</em> is defined as the number of gates. To model nondeterminism we consider circuits with an <em>input</em>  <span class="math">x \\in \\mathbb{F}^n</span>  and an auxiliary input  <span class="math">a \\in \\mathbb{F}^h</span> , called a <em>witness</em>. Arithmetic circuit satisfiability is analogous to the boolean case, as follows.</p>

    <p class="text-gray-300"><strong>Definition A.1.</strong> Let  <span class="math">n, h, l \\in \\mathbb{N}</span>  respectively denote the input, witness, and output size. The <strong>circuit satisfaction problem</strong> of an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C \\colon \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  (with bilinear gates) is defined by the relation  <span class="math">\\mathcal{R}_C = \\{(x, a) \\in \\mathbb{F}^n \\times \\mathbb{F}^h : C(x, a) = 0^l\\}</span> ; its language is  <span class="math">\\mathcal{L}_C = \\{x \\in \\mathbb{F}^n : \\exists a \\in \\mathbb{F}^h, C(x, a) = 0^l\\}</span> .</p>

    <p class="text-gray-300">At times, we also write C(x,a)=0 to mean  <span class="math">C(x,a)=0^l</span>  for an unspecified l. All the arithmetic circuits we consider are over fields  <span class="math">\\mathbb{F}_p</span>  with p prime (that is at most exponential in the security parameter  <span class="math">\\lambda</span> ).</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">A.2 Random-access machines</h3>

    <p class="text-gray-300">There are many possible definitions of <em>random-access machines</em> [CR72, AV77]. Here we formulate a concrete, yet relatively flexible, definition that suffices for the purposes of this paper. Informally, a machine is specified by a configuration for random-access memory (number of addresses, and number of bits stored at each address) and a CPU. At each step, the CPU gets the current state and the next instruction from memory; executes the instruction; communicates with memory (by storing or loading data); and then outputs the next state and the address for the next instruction. (Thus, random-access memory contains both program and data.)</p>

    <p class="text-gray-300">More precisely, a (non-deterministic) <strong>random-access machine</strong> with verification over a finite field  <span class="math">\\mathbb{F}</span>  is a tuple  <span class="math">\\mathbf{M} = (A, W, N, \\mathrm{CPU}_{\\mathsf{exe}}, \\mathrm{CPU}_{\\mathsf{ver}})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A, W \\in \\mathbb{N}</span>  specify that (random-access) memory  <span class="math">\\mathcal{M}</span>  contains A addresses each storing W bits (i.e., that memory is a function  <span class="math">\\mathcal{M}: [A] \\to \\{0,1\\}^W</span> ).</li>

      <li><span class="math">N \\in \\mathbb{N}</span>  specifies the length, in bits, of a CPU state.</li>

      <li><span class="math">\\bullet~{\\rm CPU}_{\\rm exe}</span>  is a (stateful) function for  <span class="math">\\it executing</span>  the CPU (see below).</li>

      <li>CPU<sub>ver</sub> is an F-arithmetic circuit for <em>verifying</em> the CPU's execution (see below).</li>

    </ul>

    <p class="text-gray-300">The machine M takes as input a program  <span class="math">\\mathcal{P}</span>  and an auxiliary input  <span class="math">\\mathcal{G}</span> , and computes on them. More precisely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <strong>program</strong> for M is a function  <span class="math">\\mathcal{P}: [A] \\to \\{0,1\\}^W</span>  that specifies the initial memory contents. The program  <span class="math">\\mathcal{P}</span>  is typically represented in sparse form, by listing the (few) addresses and values for non-zero memory entries, which may store any code and data to the machine.</li>

      <li>An auxiliary input for M is a sequence  <span class="math">\\mathcal{G} = (g_0, g_1, g_2, \\dots)</span> . Each  <span class="math">g_i</span>  consists of W bits and is accessed at the <em>i</em>-th computation step. The auxiliary input is treated as a <em>nondeterministic guess</em>.</li>

    </ul>

    <p class="text-gray-300">Then, the <strong>computation</strong> of <strong>M</strong> on program  <span class="math">\\mathcal{P}</span>  and auxiliary input  <span class="math">\\mathcal{G}</span> , denoted  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span> , proceeds as follows. Initialize the CPU state and instruction address to zero:  <span class="math">s_{\\mathsf{cpu},0} := 0^N</span> ,  <span class="math">a_{\\mathsf{pc},0} := 0</span> . Next, for  <span class="math">i = 0, 1, 2 \\ldots</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. CPU<sub>exe</sub> is given the current CPU state  <span class="math">(s_{\\text{cpu},i} \\in \\{0,1\\}^N)</span> , address of the instruction to be executed  <span class="math">(a_{\\text{pc},i} \\in [A])</span> , instruction to be executed  <span class="math">(v_{\\text{pc},i} := \\mathcal{M}_i(a_{\\text{pc},i}) \\in \\{0,1\\}^W)</span> , and guess  <span class="math">(g_i \\in \\{0,1\\}^W)</span> .</li>

      <li>2.  <span class="math">CPU_{exe}</span>  outputs an address  <span class="math">(a_{mem,i} \\in [A])</span> , a value  <span class="math">(v_{st,i} \\in \\{0,1\\}^W)</span> , and a store flag  <span class="math">(f_{st,i} \\in \\{0,1\\})</span> .</li>

    </ul>

    <p class="text-gray-300"><sup>22</sup>A gate with inputs  <span class="math">x_1, \\ldots, x_m \\in \\mathbb{F}</span>  is <em>bilinear</em> if the output is  <span class="math">(\\alpha_0 + \\sum_{i=1}^m \\alpha_i x_i) \\cdot (\\beta_0 + \\sum_{i=1}^m \\beta_i x_i)</span>  for some  <span class="math">\\alpha, \\beta \\in \\mathbb{F}^{m+1}</span> . In particular, these include addition, multiplication, and constant gates.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3. CPU<sub>exe</sub> is given the value at the address  <span class="math">(v_{\\mathsf{Id},i} := \\mathcal{M}_i(a_{\\mathsf{mem},i}) \\in \\{0,1\\}^W)</span> . Set  <span class="math">\\mathcal{M}_{i+1}</span>  equal to  <span class="math">\\mathcal{M}_i</span> ; if a store was requested (i.e.,  <span class="math">f_{\\mathsf{st},i} = 1</span> ), do it (i.e.,  <span class="math">\\mathcal{M}_{i+1}(a_{\\mathsf{mem},i}) := v_{\\mathsf{st},i}</span> ).</li>

      <li>4. CPU<sub>exe</sub> outputs a new CPU state  <span class="math">(s_{\\text{cpu},i+1} \\in \\{0,1\\}^N)</span> , an address for the next instruction  <span class="math">(a_{\\text{pc},i+1} \\in [A])</span> , and a flag denoting whether the machine has accepted  <span class="math">(f_{\\text{acc},i+1} \\in \\{0,1\\})</span> . CPU<sub>exe</sub>'s state is reset.</li>

    </ul>

    <p class="text-gray-300">Thus  <span class="math">CPU_{\\text{exe}}</span>  can be thought of as M's "processor": step after step,  <span class="math">CPU_{\\text{exe}}</span>  takes the previous state and instruction (and its address), executes the instruction, communicates with random-access memory, and produces the next state and instruction address. In contrast,  <span class="math">CPU_{\\text{ver}}</span>  is a predicate that verifies the correct input/output relationship of  <span class="math">CPU_{\\text{exe}}</span> . In other words  <span class="math">CPU_{\\text{exe}}</span>  satisfies the following property:</p>

    <pre><code class="language-text">Fix s_{\\sf cpu}, s&#x27;_{\\sf cpu} \\in \\{0,1\\}^N, a_{\\sf pc}, a_{\\sf mem}, a&#x27;_{\\sf pc} \\in [A], v_{\\sf pc}, v_{\\sf st}, v_{\\sf ld}, g \\in \\{0,1\\}^W, f_{\\sf st}, f&#x27;_{\\sf acc} \\in \\{0,1\\}, and let x_{\\sf ver} be the concatenation of all these. There is a witness a_{\\sf ver} such that {\\sf CPU}_{\\sf ver}(x_{\\sf ver}, a_{\\sf ver}) = 0 iff (a_{\\sf mem}, v_{\\sf st}, f_{\\sf st}) \\leftarrow {\\sf CPU}_{\\sf exe}(s_{\\sf cpu}, a_{\\sf pc}, v_{\\sf pc}, g) and, afterwards, (s&#x27;_{\\sf cpu}, a&#x27;_{\\sf pc}, f&#x27;_{\\sf acc}) \\leftarrow {\\sf CPU}_{\\sf exe}(v_{\\sf ld}). Moreover, a_{\\sf ver} can be efficiently computed from x_{\\sf ver}.</code></pre>

    <p class="text-gray-300">Of course,  <span class="math">CPU_{ver}</span>  may simply internally execute  <span class="math">CPU_{exe}</span>  to perform its verification; but, having access to additional advice  <span class="math">a_{ver}</span> ,  <span class="math">CPU_{ver}</span>  may instead perform "smarter", and more efficient, checks.</p>

    <p class="text-gray-300">We are not concerned about how the function  <span class="math">CPU_{\\text{exe}}</span>  is specified (e.g., it can be a computed program), but  <span class="math">CPU_{\\text{ver}}</span>  must be specified as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit (for an appropriate  <span class="math">\\mathbb{F}</span>  that we will discuss).</p>

    <p class="text-gray-300">The language of accepting computations. We define the language of accepting computations on M. A program  <span class="math">\\mathcal{P}</span>  is treated as "given", while the auxiliary input  <span class="math">\\mathcal{G}</span>  is treated as a nondeterministic advice.</p>

    <p class="text-gray-300"><span id="page-32-1"></span><strong>Definition A.2.</strong> For a random-access machine M, the language  <span class="math">\\mathcal{L}_{M}</span>  consists of pairs  <span class="math">(\\mathcal{P}, T)</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P is a program for M;</li>

      <li><em>T is a time bound;</em></li>

      <li>there exists an auxiliary input  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span>  accepts in at most T steps. We denote by  <span class="math">\\mathcal{R}_{\\mathbf{M}}</span>  the relation corresponding to  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span> .</li>

    </ul>

    <p class="text-gray-300">In this paper we obtain an implementation of scalable zk-SNARKs for proving/verifying membership in the above language (see Appendix E for a definition). We evaluate our system for a specific choice of machine: vnTinyRAM, a simple RISC von Neumann architecture introduced by [BCTV14] (see below). Of course, other choices of random-access machines are possible, and our implementation supports them.</p>

    <p class="text-gray-300">We evaluate our scalable zk-SNARK on an architecture that previously appeared in (preprocessing) zk-SNARK implementations: vnTinyRAM [BCTV14]. (See Section 7.) We explain how to set " <span class="math">\\mathbf{M} = vnTinyRAM</span> ", i.e., how to specify the architecture vnTinyRAM via the formalism introduced above (and used by our prototype).</p>

    <p class="text-gray-300">Given w,k, we want to construct a tuple  <span class="math">\\mathbf{M}=(A,W,N,\\mathrm{CPU_{exe}},\\mathrm{CPU_{ver}})</span>  that implements w-bit vnTinyRAM with k registers. First we need to specify the parameters  <span class="math">A,W\\in\\mathbb{N}</span>  for random access memory. vnTinyRAM accesses memory, consisting of  <span class="math">2^w</span>  bytes, either as bytes or as words; moreover, vnTinyRAM instructions (which are stored in memory) take two words to encode in memory. Thus, we set A,W so that memory consists of  <span class="math">A:=\\frac{8\\cdot 2^w}{2w}</span>  addresses, each storing W:=2w bits. Next, we set the CPU state length to N:=(1+k)w+1 because, in vnTinyRAM, a CPU state consists of the  <span class="math">program\\ counter\\ (w\\ bits),\\ k</span>  general-purpose  <span class="math">program\\ counter\\ (w\\ bits)</span> , and a  <span class="math">program\\ counter\\ (w\\ bits)</span> , while  <span class="math">program\\ counter\\ (w\\ bits)</span>  finally,  <span class="math">program\\ counter\\ (w\\ bits)</span>  for verifying the input-output relationship of  <span class="math">program\\ counter\\ (w\\ bits)</span>  is a prime field of  <span class="math">program\\ counter\\ (w\\ bits)</span>  bits (since  <span class="math">program\\ counter\\ (w\\ bits)</span> ), and we get the following sizes for the two settings we consider:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for (w, k) = (16, 16),  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CPU_{ver}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 766$ ; and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The cryptographic primitives we study are based on <em>pairings</em>, which we briefly recall in Appendix B.1. Pairings can, in turn, be based on <em>pairing-friendly elliptic curves</em>; in Appendix B.2 we review basic notions about these.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  be cyclic groups of a prime order r. We denote elements of  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  via calligraphic letters such as  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{Q}</span> . We write  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  in additive notation. Let  <span class="math">\\mathcal{P}_1</span>  be a generator of  <span class="math">\\mathbb{G}_1</span> , i.e.,  <span class="math">\\mathbb{G}_1 = \\{\\alpha \\mathcal{P}_1\\}_{\\alpha \\in \\mathbb{F}_r}</span> ; let  <span class="math">\\mathcal{P}_2</span>  be a generator for  <span class="math">\\mathbb{G}_2</span> . (We also view  <span class="math">\\alpha</span>  as an integer, so that  <span class="math">\\alpha \\mathcal{P}_1</span>  is well-defined.)</p>

    <p class="text-gray-300">A <strong>pairing</strong> is an efficient map  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_T</span>  is also a cyclic group of order r (which we write in multiplicative notation), satisfying the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BILINEARITY. For every nonzero elements  <span class="math">\\alpha, \\beta \\in \\mathbb{F}_r</span> , it holds that  <span class="math">e(\\alpha \\mathcal{P}_1, \\beta \\mathcal{P}_2) = e(\\mathcal{P}_1, \\mathcal{P}_2)^{\\alpha \\beta}</span> .</li>

      <li>NON-DEGENERACY.  <span class="math">e(\\mathcal{P}_1, \\mathcal{P}_2)</span>  is not the identity in  <span class="math">\\mathbb{G}_T</span> .</li>

    </ul>

    <p class="text-gray-300">When describing cryptographic primitives at high level, the choice of instantiation of  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e</span>  often does not matter. In this paper, however, we discuss implementation details, and such choices matter a great deal. Typically, pairings are based on (pairing-friendly) elliptic curves, discussed next.</p>

    <p class="text-gray-300">We assume familiarity with elliptic curves; here, we only recall the basic definitions in order to fix notation. See, e.g., [Was08, Sil09, FST10, CFAD <span class="math">^+</span> 12] for more details.</p>

    <p class="text-gray-300"><strong>Definition and curve groups.</strong> Given a field K, an <em>elliptic curve</em> E defined over K, denoted E/K, is a smooth projective curve of genus 1 (defined over K) with a distinguished K-rational point. We denote by E(K) the group of K-rational points on E; when finite, we denote the cardinality of this group by #E(K). For any  <span class="math">r \\in \\mathbb{N}</span> , E[r] denotes the group of r-torsion points in E(K), and E(K)[r] the group of r-torsion points in E(K). In this paper, we only consider elliptic curves where K is a finite field  <span class="math">\\mathbb{F}_q</span> ; so the definitions below are specific to this case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Trace and CM discrminant.</strong> The trace of  <span class="math">E/\\mathbb{F}_q</span>  is  <span class="math">t:=q+1-\\#E(\\mathbb{F}_q)</span> . The Hasse bound states that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\sqrt{q}<span class="math"> . If  </span>\\gcd(q,t)=1<span class="math"> , then  </span>E/\\mathbb{F}_q<span class="math">  is ordinary; otherwise, it is supersingular. If  </span>E/\\mathbb{F}_q<span class="math">  is ordinary, the CM discriminant of E is the square-free part D of the integer  </span>4q-t^2$ , non-negative by the Hasse bound.<sup>23</sup></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>ECDLP.</strong> The <em>elliptic-curve discrete logarithm problem</em> (ECDLP) is the following: given  <span class="math">E/\\mathbb{F}_q</span> ,  <span class="math">\\mathcal{P} \\in E(\\mathbb{F}_q)</span> , and  <span class="math">\\mathcal{Q} \\in \\langle \\mathcal{P} \\rangle</span> , find  <span class="math">a \\in \\mathbb{N}</span>  such that  <span class="math">\\mathcal{Q} = a\\mathcal{P}</span> . There are several methods to solve, with different time and space complexities, the ECDLP. For instance: the Pohlig–Hellman algorithm [PH78] (which reduces the problem to subgroups of prime order); Shanks' [Sha71] baby-step-giant-step method; Pollard's methods (the rho method [Pol78] and the kangaroo method [Pol00], and their parallel variants by van Oorschot and Wiener [vOW99]); the Menezes–Okamoto–Vanstone (MOV) attack using the Weil pairing [MOV91]; the Frey–Rück attack using the Tate pairing [FR94]; and the SSSA attack for curves of trace t=1 [Sem98, Sma99, SA98].</p>

    <p class="text-gray-300">Cryptographic uses require the ECDLP to be hard (typically, intractable for polynomial-time adversaries). For points  <span class="math">\\mathcal P</span>  of large prime order r, this is widely believed to be the case. Thus, one only considers curves E with trace  <span class="math">t \\neq 1</span>  and having cyclic subgroups of  <span class="math">E(\\mathbb F_q)</span>  of large prime order r. So  <span class="math">\\#E(\\mathbb F_q)</span>  is either a prime r, or hr for a small  <span class="math">cofactor\\ h</span> .</p>

    <p class="text-gray-300"><strong>Pairings.</strong> For cryptographic uses that require efficient computation of pairings (such as the uses considered in this paper), suitable elliptic curves need to satisfy additional requirements, as we now recall.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>23</sup>Alternatively, some authors define the discriminant to be -D, or the discriminant of the imaginary quadratic field  <span class="math">\\mathbb{Q}(\\sqrt{-D})</span> .</p>

    <p class="text-gray-300">For any  <span class="math">r \\in \\mathbb{N}</span>  with  <span class="math">\\gcd(q,r)=1</span> , the <em>embedding degree</em> k of  <span class="math">E/\\mathbb{F}_q</span>  (with respect to r) is the smallest integer such that r divides  <span class="math">q^k-1</span> ; for such r, a bilinear map  <span class="math">e_r \\colon E[r] \\times E[r] \\to \\mu_r</span>  can be defined, where  <span class="math">\\mu_r \\subset \\mathbb{F}_{q^k}^<em></span>  is the subgroup of r-th roots of unity in  <span class="math">\\overline{\\mathbb{F}_q}</span> . The map  <span class="math">e_r</span>  is known as the </em>Weil pairing*.</p>

    <p class="text-gray-300">The Weil pairing is not the only bilinear map that can be defined. Depending on properties of the curve E other, sometimes more efficient, pairings can be defined, e.g., the Tate pairing [FR94, FMR06], the Eta pairing [BGOhM07], and the Ate pairing [HSV06]. In each of these cases, the pairing computation requires arithmetic in  <span class="math">\\mathbb{F}_{q^k}</span> , so that k cannot be too large. On the other hand, the ECDLP can be translated (via the pairing itself [MOV91, FR94]) to the discrete logarithm problem over  <span class="math">\\mathbb{F}_{q^k}^<em></span> , which is susceptible to subexponential-time attacks via index calculus [Odl85], so that k has to be large enough to achieve the desired level of hardness for the DLP in  <span class="math">\\mathbb{F}_{q^k}^</em></span> .</p>

    <p class="text-gray-300">In light of the above considerations, an (ordinary) elliptic curve  <span class="math">E/\\mathbb{F}_q</span>  is said to be <em>pairing friendly</em> if (i)  <span class="math">E(\\mathbb{F}_q)</span>  contains a subgroup of large prime order r, and (ii) E has embedding degree k (with respect to r) that is not too large (i.e., computations in the field  <span class="math">\\mathbb{F}_{q^k}</span>  are feasible) and not too small (i.e., the DLP in  <span class="math">\\mathbb{F}_{q^k}^<em></span>  is hard enough). The ideal case is when E has prime order r, and the embedding degree k is such that the ECDLP in  <span class="math">E(\\mathbb{F}_q)</span>  and the DLP in  <span class="math">\\mathbb{F}_{q^k}^</em></span>  have approximately the same hardness, i.e., are <em>balanced</em>.</p>

    <p class="text-gray-300"><strong>Instantiations of pairings.</strong> A pairing is specified by a prime  <span class="math">r \\in \\mathbb{N}</span> , three cyclic groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  of order r, and an efficient bilinear map  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> . (See Appendix B.1.) Suppose one uses a curve  <span class="math">E/\\mathbb{F}_q</span>  with embedding degree k to instantiate the pairing. Then  <span class="math">\\mathbb{G}_T</span>  is set to  <span class="math">\\mu_r \\subset \\mathbb{F}_{q^k}^*</span> . The instantiation of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  depends on the choice of e; typically,  <span class="math">\\mathbb{G}_1</span>  is instantiated as an order-r subgroup of  <span class="math">E(\\mathbb{F}_q)</span> , while, for efficiency reasons [BKLS02, BLS04],  <span class="math">\\mathbb{G}_2</span>  as an order-r subgroup of  <span class="math">E&#x27;(\\mathbb{F}_{k/d})</span>  where E' is a d-th twist of E.</p>

    <p class="text-gray-300">At high-level, a <em>preprocessing</em> zk-SNARK for arithmetic-circuit satisfiability is a cryptographic primitive that provides short and easy-to-verify non-interactive zero-knowledge proofs of knowledge for the satisfiability of arithmetic circuits. A public proving key is used to generate proofs, and a public verification key is used to verify them; the two keys are jointly generated once, and can then be used any number of times. The adjective "preprocessing" denotes the fact that the key pair <em>depends</em> on the arithmetic circuit C whose satisfiability is being proved/verified; in particular, the time to generate a key pair for C is at least linear in the size of C. Below, we informally define this primitive; we refer the reader to, e.g., [BCIOP13] for a formal definition.</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}</span> , <sup>24</sup> a <strong>preprocessing zk-SNARK</strong> for  <span class="math">\\mathbb{F}</span> -arithmetic circuit satisfiability (see Appendix A.1) is a triple of polynomial-time algorithms (G, P, V), with V deterministic, <sup>25</sup> working as follows.</p>

    <p class="text-gray-300">•  <span class="math">G(1^{\\lambda},C) \\to (\\mathsf{pk},\\mathsf{vk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and an  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, the <em>key generator</em> G probabilistically samples a proving key  <span class="math">\\mathsf{pk}</span>  and a verification key  <span class="math">\\mathsf{vk}</span> . We assume, without loss of generality, that  <span class="math">\\mathsf{pk}</span>  contains (a description of) the circuit C.</p>

    <p class="text-gray-300">The keys pk and vk are published as public parameters and can be used, any number of times, to prove/verify membership in the language  <span class="math">\\mathcal{L}_C</span> , as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P(\\mathsf{pk}, x, a) \\to \\pi</span> . On input a proving key  <span class="math">\\mathsf{pk}</span>  and any  <span class="math">(x, a) \\in \\mathcal{R}_C</span> , the <em>prover</em> P outputs a non-interactive proof  <span class="math">\\pi</span>  for the statement " <span class="math">x \\in \\mathcal{L}_C</span> ".</li>

      <li><span class="math">V(vk, x, \\pi) \\to b</span> . On input a verification key vk, an input x, and a proof  <span class="math">\\pi</span> , the <em>verifier</em> V outputs b = 1 if he is convinced by  <span class="math">\\pi</span>  that  <span class="math">x \\in \\mathcal{L}_C</span> .</li>

    </ul>

    <p class="text-gray-300">The triple (G, P, V) satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> The honest prover can convince the verifier for any instance in the language. Namely, for every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, and instance  <span class="math">x \\in \\mathcal{L}_C</span>  with a witness a,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[V(\\mathsf{vk},x,\\pi) = 1 \\;\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\; \\begin{array}{c} (\\mathsf{pk},\\mathsf{vk}) \\leftarrow G(1^\\lambda,C) \\\\ \\pi \\leftarrow P(\\mathsf{pk},x,a) \\end{array}\\right] = 1 \\;\\;.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Succinctness.</strong> For every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, and  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\in G(1^{\\lambda}, C)</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda}(1)</span>  bits;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">V(vk, x, \\pi)</span>  runs in time  $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above,  <span class="math">O_{\\lambda}</span>  hides a (fixed) polynomial factor in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof for an instance, the prover "knows" a witness for that instance. (Thus, soundness holds.) Namely, for every constant c>0 and every polynomial-size adversary A there is a polynomial-size witness extractor E such that, for every large-enough security parameter  <span class="math">\\lambda</span> , for every  <span class="math">\\mathbb{F}</span> -arithmetic circuit C of size  <span class="math">\\lambda^c</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} V(\\mathsf{vk}, x, \\pi) = 1 \\\\ (x, a) \\notin \\mathcal{R}_C \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G(1^\\lambda, C) \\\\ (x, \\pi) \\leftarrow A(\\mathsf{pk}, \\mathsf{vk}) \\\\ a \\leftarrow E(\\mathsf{pk}, \\mathsf{vk}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Statistical zero knowledge.</strong> An honestly-generated proof is statistical zero knowledge. Namely, there is a polynomial-time stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are negligibly-close:</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>24</sup>More precisely, a field family indexed by the security parameter  <span class="math">\\lambda</span>  where the field size grows at most exponentially in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{25}&lt;/sup&gt;</span> In this paper we use the technique of recursive proof composition, which relies on V being deterministic (i.e., no coin flips are needed during proof verification). All known zk-SNARK constructions satisfy this property, so this is effectively not a restriction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} C \\leftarrow D(1^{\\lambda}) \\\\ (x,a) \\in \\mathcal{R}_C \\\\ \\mathcal{D}(\\pi) = 1 \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} C \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G(1^{\\lambda}, C) \\\\ (x,a) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow P(\\mathsf{pk}, x, a) \\end{array} \\right] \\quad \\text{and} \\quad \\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} C \\leftarrow D(1^{\\lambda}) \\\\ (x,a) \\in \\mathcal{R}_C \\\\ D(\\pi) = 1 \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} C \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow S(1^{\\lambda}, C) \\\\ (x,a) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow S(x) \\end{array} \\right] \\right].$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-36-2"></span><strong>Remark C.1.</strong> All known preprocessing zk-SNARK constructions can in fact be made <em>perfect</em> zero knowledge, at the only expense of a negligible probability of error in completeness.</p>

    <p class="text-gray-300">There are many preprocessing zk-SNARK constructions in the literature [Gro10, Lip12, BCIOP13, GGPR13, PGHR13, BCGTV13a, Lip13, BCTV14]. The most efficient ones are based on <em>quadratic arithmetic programs</em> (QAPs) [GGPR13, BCIOP13, PGHR13, BCGTV13a, BCTV14]; such constructions provide a linear-time G, quasilinear-time P, and linear-time V.</p>

    <p class="text-gray-300">Three of the above works [PGHR13, BCGTV13a, BCTV14] also investigate and provide implementations of preprocessing zk-SNARKs. As we discuss in Section 3.3, in this work we follow the implementation of [BCTV14], which, at the time of writing, is the fastest one.</p>

    <p class="text-gray-300">Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diffie-Hellman assumptions in bilinear groups [Gro10, BB04, Gen04]. Knowledge-of-exponent assumptions are fairly strong, but there is evidence that such assumptions may be inherent for constructing zk-SNARKs [GW11, BCCT12].</p>

    <p class="text-gray-300"><span id="page-36-3"></span><strong>Remark C.2</strong> (auxiliary input). More generally, the security of zk-SNARKs relies on the <em>extractability</em> of certain functions. Extractability is a delicate property that, depending on how it is stated, yields conditions of different relative strength. One aspect that affects this is the choice of <em>auxiliary input</em> (a discussion of which was omitted in the informal definition above). For instance, if the adversary is allowed <em>any</em> auxiliary input (perhaps even by way of maliciously chosen circuits <em>C</em>), extraction may be difficult because the auxiliary input may encode an obfuscated strategy [BCCT12]; such intuition can in fact be formalized to yield limitations to extractability [BCPR13]. On the other end of the spectrum, certain notions of extractability can be achieved [BCP13], and also no limitations are known for certain 'benign looking' inputs.</p>

    <p class="text-gray-300">The focus of this paper is practical aspects of zk-SNARKs so our perspective on extractability here is that, similarly to the Fiat–Shamir paradigm [FS87], knowledge-of-exponent assumptions, despite not being fully understood, provide solid heuristics in practice since no effective attacks against them are known.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">C.2 Instantiations via elliptic curves</h4>

    <p class="text-gray-300">Known preprocessing zk-SNARK constructions are based on <em>pairings</em> (see Appendix B.1), which can in turn be based on <em>pairing-friendly elliptic curves</em> (see Appendix B.2). We recall two facts, used in this paper.</p>

    <p class="text-gray-300"><strong>Field for the circuit language.</strong> Let E be an elliptic curve that is defined over a finite field  <span class="math">\\mathbb{F}_q</span> , has a group  <span class="math">E(\\mathbb{F}_q)</span>  of  <span class="math">\\mathbb{F}_q</span> -rational points with a prime order r (or order divisible by a large prime r), and has embedding degree k with respect to r. Suppose that a preprocessing zk-SNARK (G, P, V) is instantiated with E. Then,</p>

    <p class="text-gray-300">(G, P, V) works for  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit satisfiability, but all of V's arithmetic computations are over  <span class="math">\\mathbb{F}_q</span>  (or extensions of  <span class="math">\\mathbb{F}_q</span>  up to degree k).<sup>26</sup></p>

    <p class="text-gray-300">This fact motivates most of the discussions in Section 3.1.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{26}&lt;/sup&gt;</span> Intuitively, this is because: (a) the groups  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  for a pairing  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  on E have prime order r, so that discrete logarithms for elements in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , which encode information about the arithmetic circuit, "live" in  <span class="math">\\mathbb{F}_r</span> ; while (b)  <span class="math">\\mathbb{G}_1</span> -arithmetic,  <span class="math">\\mathbb{G}_2</span> -arithmetic, and pairing computations are conducted over  <span class="math">\\mathbb{F}_q</span>  (or extensions of  <span class="math">\\mathbb{F}_q</span>  up to degree k).</p>

    <p class="text-gray-300"><strong>2-adicity of a curve.</strong> Prior work identified the <em>2-adicity</em> of a curve as an important ingredient for efficient implementations of the generator and, especially, the prover [BCGTV13a, BCTV14].</p>

    <p class="text-gray-300">An elliptic curve  <span class="math">E/\\mathbb{F}_q</span>  has 2-adicity  <span class="math">2^\\ell</span>  if the large prime r dividing  <span class="math">\\#E(\\mathbb{F}_q)</span>  is such that  <span class="math">2^\\ell</span>  divides r-1. This property ensures that the multiplicative group of  <span class="math">\\mathbb{F}_r</span>  contains a  <span class="math">2^\\ell</span> -th root of unity, which significantly improves the efficiency of interpolation and evaluation of functions defined over certain domains in  <span class="math">\\mathbb{F}_r</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When instantiating a preprocessing zk-SNARK (G,P,V) with E, the zk-SNARK works for  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit satisfiability, and both G and P need to solve interpolation/evaluation problems over domains of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, where C is the  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit given as input to G. Thus, efficiency can be improved if E is sufficiently 2-adic. Concretely, to fully take advantage of the efficiency benefits of 2-adicity, one requires that  $2^\\ell \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , i.e.,  </span>\\nu_2(r-1) \\geq \\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math">  where  </span>\\nu_2(\\cdot)$  denotes the 2-adic order function.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This fact motivates much of the extensive search for suitable curve parameters, described in Section 3.2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark C.3</strong> (lack of 2-adicity). One can consider other/weaker requirements (e.g.,  $\\nu_3(r-1) \\geq \\lceil \\log_3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> , or r-1 is divisible by a smooth number  </span>M \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ) which would still somewhat simplify interpolation/evaluation problems over</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-size domains in  <span class="math">\\mathbb{F}_r</span> . The above requirement that  $\\nu_2(r-1) \\geq \\lceil \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil$  is, in a sense, the "ideal" one. Moreover, even if E does not satisfy these other/weaker requirements, it is still possible to instantiate the zk-SNARK, but at a higher computational cost (both asymptotically and in practice), due to the necessary use of "heavier" techniques applying to "generic" fields [PGHR13].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The (pairing-based) preprocessing zk-SNARKs that we use follow those of [BCTV14] (see Section 3.3); in turn, these improve upon and implement those of [PGHR13]. In this paper, we construct arithmetic circuits for verifying the evaluation of the zk-SNARK verifier V: a circuit  <span class="math">C_{V,4}</span>  for an instantiation based on the curve  <span class="math">E_4</span> , and a circuit  <span class="math">C_{V,6}</span>  for one based on the curve  <span class="math">E_6</span>  (see Section 5.1). For completeness, in Figure 9 we summarize V's abstract protocol.</p>

    <p class="text-gray-300">We see that V's protocol consists of two main parts: (a) use the verification key vk and input  <span class="math">\\vec{x} \\in \\mathbb{F}_r^n</span>  to compute  <span class="math">vk_{\\vec{x}}</span>  (see Step 1); and (b) use the verification key vk, value  <span class="math">vk_{\\vec{x}}</span> , and proof  <span class="math">\\pi</span> , to compute 12 pairings and perform the required checks (see Step 2, Step 3, Step 4). Thus, the first part requires O(n) scalar multiplications in  <span class="math">\\mathbb{G}_1</span> , while the second part requires O(1) pairing evaluations.</p>

    <p class="text-gray-300">For additional details regarding V (and, more generally, the preprocessing zk-SNARK construction), we refer the reader to [BCTV14, PGHR13]. Indeed, our focus in this work is not  <span class="math">why\\ V</span>  executes these checks, but how we can efficiently verify its checks via suitable arithmetic circuits.</p>

    <pre><code class="language-text">ALGEBRAIC SETUP. A prime r, two cyclic groups \\mathbb{G}_1 and \\mathbb{G}_2 of order r with generators \\mathcal{P}_1 and \\mathcal{P}_2 respectively, and a pairing e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T, where \\mathbb{G}_T is also cyclic of order r. (See Appendix B.1 for a pairing&#x27;s definition.)</code></pre>

    <h4 id="sec-58" class="text-lg font-semibold mt-6"><span class="math">{\\bf zk\\text{-}SNARK} \\ {\\bf verifier} \\ V \\ {\\bf for \\ inputs \\ of \\ size} \\ n</span></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUTS:</li>

      <li>verification key  <span class="math">vk = (vk_A, vk_B, vk_C, vk_{\\gamma}, vk_{\\beta\\gamma}^1, vk_{\\beta\\gamma}^2, vk_Z, vk_{IC})</span> , where</li>

      <li>\\*  <span class="math">\\mathsf{vk}_{\\mathsf{B}}, \\mathsf{vk}_{\\beta\\gamma}^1</span>  are in  <span class="math">\\mathbb{G}_1</span></li>

      <li>\\*  <span class="math">\\mathsf{vk}_{\\mathsf{A}}, \\mathsf{vk}_{\\mathsf{C}}, \\mathsf{vk}_{\\gamma}, \\mathsf{vk}_{\\beta\\gamma}^2, \\mathsf{vk}_{\\mathsf{Z}} \\text{ are in } \\mathbb{G}_2</span></li>

      <li><span class="math">* \\ \\mathsf{vk}_{\\mathsf{IC}} = (\\mathsf{vk}_{\\mathsf{IC},0},\\mathsf{vk}_{\\mathsf{IC},1},\\dots,\\mathsf{vk}_{\\mathsf{IC},n}) \\in \\mathbb{G}_1^{1+n}</span></li>

      <li>input  <span class="math">\\vec{x} = (x_1, \\dots, x_n)</span> , where  <span class="math">x_i \\in \\mathbb{F}_r</span></li>

      <li>proof  <span class="math">\\pi = (\\pi_A, \\pi&#x27;_A, \\pi_B, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_K, \\pi_H)</span> , where  <span class="math">\\pi_A, \\pi&#x27;_A, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_K, \\pi_H \\in \\mathbb{G}_1</span>  and  <span class="math">\\pi_B \\in \\mathbb{G}_2</span></li>

      <li>OUTPUTS: decision bit</li>

      <li><span id="page-38-1"></span>1. Compute  <span class="math">\\mathsf{vk}_{\\vec{x}} := \\mathsf{vk}_{\\mathsf{IC},0} + \\sum_{i=1}^n x_i \\mathsf{vk}_{\\mathsf{IC},i} \\in \\mathbb{G}_1</span> .</li>

      <li><span id="page-38-2"></span>2. Check validity of knowledge commitments:  <span class="math">e(\\pi_A, vk_A) = e(\\pi&#x27;_A, \\mathcal{P}_2)</span> ,  <span class="math">e(vk_B, \\pi_B) = e(\\pi&#x27;_B, \\mathcal{P}_2)</span> ,  <span class="math">e(\\pi_C, vk_C) = e(\\pi&#x27;_C, \\mathcal{P}_2)</span> .</li>

      <li><span id="page-38-3"></span>3. Check same coefficients were used:  <span class="math">e(\\pi_K, \\mathsf{vk}_\\gamma) = e(\\mathsf{vk}_{\\vec{x}} + \\pi_\\mathsf{A} + \\pi_\\mathsf{C}, \\mathsf{vk}_{\\beta\\gamma}^2) \\cdot e(\\mathsf{vk}_{\\beta\\gamma}^1, \\pi_\\mathsf{B})</span> .</li>

      <li><span id="page-38-4"></span>4. Check QAP divisibility:  <span class="math">e(vk_{\\vec{x}} + \\pi_A, \\pi_B) = e(\\pi_H, vk_Z) \\cdot e(\\pi_C, \\mathcal{P}_2)</span> .</li>

      <li>5. Accept if and only if all the above checks succeeded.</li>

    </ul>

    <p class="text-gray-300">Figure 9: Summary of the checks performed by the zk-SNARK verifier  <span class="math">{\\cal V}.</span></p>

    <p class="text-gray-300">We define a <em>proof-carrying data system</em> (PCD system), which is a cryptographic primitive that captures the notion of proof-carrying data [CT10, CT12]. More precisely, we define <em>preprocessing</em> PCD systems [BCCT13]. The definitions here are somewhat informal; for details, we refer the reader to [BCCT13].</p>

    <p class="text-gray-300"><strong>Proof-carrying data at a glance.</strong> Fix a predicate  <span class="math">\\Pi</span> . Consider a distributed computation where nodes perform computations; each computation takes as input messages and outputs a new output message. The security goal is to ensure that each output message is <em>compliant</em> with the predicate  <span class="math">\\Pi</span> . Proof-carrying data ensures this goal by attaching short and easy-to-verify proofs of  <span class="math">\\Pi</span> -compliance to each message.</p>

    <p class="text-gray-300">Concretely, a <em>key generator</em>  <span class="math">\\mathbb{G}</span>  first sets up a proving key and a verification key. Anyone can then use a <em>prover</em>  <span class="math">\\mathbb{P}</span> , which is given as input the proving key, prior messages  <span class="math">\\vec{z}_{in}</span>  with proofs  <span class="math">\\vec{\\pi}_{in}</span> , and an output message z, to generate a proof  <span class="math">\\pi</span>  attesting that z is  <span class="math">\\Pi</span> -compliant. Anyone can use a <em>verifier</em>  <span class="math">\\mathbb{V}</span> , which is given as input the verification key, a message z, and a proof, to verify that z is  <span class="math">\\Pi</span> -compliant.</p>

    <p class="text-gray-300">Crucially, proof generation and proof verification time are "history independent": the first only depends on the time to execute  <span class="math">\\Pi</span>  on input a node's messages, while the second only on the message length.</p>

    <p class="text-gray-300">We now spell out more details, by first specifying the notion of distributed computation, and then that of compliance with a predicate  <span class="math">\\Pi</span> . Our discussion is specific to predicates specified as  <span class="math">\\mathbb{F}</span> -arithmetic circuits.</p>

    <p class="text-gray-300"><strong>Transcripts.</strong> Given  <span class="math">n_{\\mathsf{msg}}, n_{\\mathsf{loc}}, s \\in \\mathbb{N}</span>  and field  <span class="math">\\mathbb{F}</span> , an  <span class="math">\\mathbb{F}</span> -arithmetic <strong>transcript</strong> (for message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , and arity s) is a triple  <span class="math">\\mathsf{T} = (G, \\mathsf{loc}, \\mathsf{data})</span> , where G = (V, E) is a directed acyclic graph G, loc:  <span class="math">V \\to \\mathbb{F}^{n_{\\mathsf{loc}}}</span>  are node labels, and data:  <span class="math">E \\to \\mathbb{F}^{n_{\\mathsf{msg}}}</span>  are edge labels. The <em>output of</em>  <span class="math">\\mathsf{T}</span> , denoted out( <span class="math">\\mathsf{T}</span> ), equals data( <span class="math">\\tilde{u}, \\tilde{v}</span> ) where ( <span class="math">\\tilde{u}, \\tilde{v}</span> ) is the lexicographically-first edge with  <span class="math">\\tilde{v}</span>  a sink.</p>

    <p class="text-gray-300">Intuitively, the label loc(v) of a node v represents the  <span class="math">local\\ data</span>  used by v in his local computation; the edge label data(u,v) of a directed edged (u,v) represents the message sent from node u to node v. Typically, a party at node v uses the local data loc(v) and "input messages"  <span class="math">(data(u,v))_{u \\in parents(v)}</span>  to compute an "output message" data(v,w) for each child  <span class="math">w \\in children(v)</span> .</p>

    <p class="text-gray-300">Compliance. Given field  <span class="math">\\mathbb F</span>  and  <span class="math">n_{\\mathsf{msg}}, n_{\\mathsf{loc}}, s \\in \\mathbb N</span> , an  <span class="math">\\mathbb F</span> -arithmetic compliance predicate  <span class="math">\\Pi</span>  (for message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , and arity s) is an  <span class="math">\\mathbb F</span> -arithmetic circuit with domain  <span class="math">\\mathbb F^{n_{\\mathsf{msg}}} \\times \\mathbb F^{n_{\\mathsf{loc}}} \\times \\mathbb F^{s \\cdot n_{\\mathsf{msg}}} \\times \\mathbb F</span> . The compliance predicate  <span class="math">\\Pi</span>  specifies whether a given transcript  <span class="math">\\mathsf T</span>  is compliant or not, as follows. Consider any transcript  <span class="math">\\mathsf T</span>  with message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , and arity s. We say that  <span class="math">\\mathsf T = (G, \\mathsf{loc}, \\mathsf{data})</span>  is  <span class="math">\\Pi</span> -compliant, denoted  <span class="math">\\Pi(\\mathsf T) = 0</span> , if, for every  <span class="math">v \\in V</span>  and  <span class="math">w \\in \\mathsf{children}(v)</span> , it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pi \\Big( \\mathsf{data}(v,w), \\mathsf{loc}(v), \\big( \\mathsf{data}(u,v) \\big)_{u \\in \\mathsf{parents}(v)}, b_{\\mathsf{base}} \\Big) = 0 \\enspace ,</span></div>

    <p class="text-gray-300">where  <span class="math">b_{\\mathsf{base}} \\in \\{0,1\\}</span>  is the <em>base case flag</em> (i.e., equals 1 if and only if v is a source). Furthermore, we say that a message z is  <span class="math">\\Pi</span> -compliant if there is  <span class="math">\\mathsf{T}</span>  such that  <span class="math">\\Pi(\\mathsf{T}) = 0</span>  and  <span class="math">\\mathsf{out}(\\mathsf{T}) = z</span> .</p>

    <p class="text-gray-300">We are now ready to describe the syntax, semantics, and security of a proof-carrying data system.</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}</span> , a (<strong>preprocessing</strong>) <strong>proof-carrying data system</strong> (PCD system) for  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicates is a triple of polynomial-time algorithms  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  working as follows.</p>

    <p class="text-gray-300">•  <span class="math">\\mathbb{G}(1^{\\lambda},\\Pi) \\to (\\mathsf{pk},\\mathsf{vk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and an  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate  <span class="math">\\Pi</span> , the <em>key generator</em>  <span class="math">\\mathbb{G}</span>  probabilistically samples a proving key pk and a verification key vk. We assume, without loss of generality, that pk contains (a description of) the predicate  <span class="math">\\Pi</span> .</p>

    <p class="text-gray-300">The keys pk and vk are published as public parameters and can be used, any number of times, to prove/verify  <span class="math">\\Pi</span> -compliance of messages.</p>

    <p class="text-gray-300">•  <span class="math">\\mathbb{P}(\\mathsf{pk}, z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, \\vec{\\pi}_{\\mathsf{in}}) \\to \\pi</span> . On input a proving key  <span class="math">\\mathsf{pk}</span> , outgoing message z, local data  <span class="math">z_{\\mathsf{loc}}</span> , and incoming messages  <span class="math">\\vec{z}_{\\mathsf{in}}</span>  with proofs  <span class="math">\\vec{\\pi}_{\\mathsf{in}}</span> , the <em>prover</em>  <span class="math">\\mathbb{P}</span>  outputs a proof  <span class="math">\\pi</span>  for the statement "z is  <span class="math">\\Pi</span> -compliant".</p>

    <p class="text-gray-300">•  <span class="math">\\mathbb{V}(\\mathsf{vk}, z, \\pi) \\to b</span> . On input a verification key  <span class="math">\\mathsf{vk}</span> , a message z, and a proof  <span class="math">\\pi</span> , the <em>verifier</em>  <span class="math">\\mathbb{V}</span>  outputs b = 1 if he is convinced by  <span class="math">\\pi</span>  that z is  <span class="math">\\Pi</span> -compliant.</p>

    <p class="text-gray-300">The triple  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> The honest prover can convince the verifier that the output of any compliant transcript is indeed compliant. Namely, for every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate  <span class="math">\\Pi</span> , and distributed-computation generator S (see below),</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\Pi(\\mathsf{T}) = 0 & (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathbb{G}(1^\\lambda, \\Pi) \\\\ \\mathbb{V}\\big(\\mathsf{vk}, \\mathsf{out}(\\mathsf{T}), \\pi\\big) \\neq 1 & (\\mathsf{T}, \\pi) \\leftarrow \\mathsf{ProofGen}(S, \\mathsf{pk}, \\mathbb{P}) \\end{array}\\right] = 0 \\enspace .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above, ProofGen is an interactive protocol between a <em>distributed-computation generator</em> S and the PCD prover  <span class="math">\\mathbb{P}</span> , in which both are given the compliance predicate  <span class="math">\\Pi</span>  and the proving key pk. Essentially, at every time step, S chooses to do one of the following actions: add a new unlabeled vertex to the computation transcript so far (this corresponds to adding a new computing node to the computation), label an unlabeled vertex (this corresponds to a choice of local data by a computing node), or add a new labeled edge (this corresponds to a new message from one node to another). In case S chooses the third action, the PCD prover  <span class="math">\\mathbb{P}</span>  produces a proof for the  <span class="math">\\Pi</span> -compliance of the new message, and adds this new proof as an additional label to the new edge. When S halts, the interactive protocol outputs the distributed computation transcript T, as well as T's output and corresponding proof. Intuitively, the completeness property requires that if T is compliant with  <span class="math">\\Pi</span> , then the proof attached to the output (which is the result of dynamically invoking  <span class="math">\\mathbb{P}</span>  for each message in T, as T was being constructed by S) is accepted by the verifier.</p>

    <p class="text-gray-300"><strong>Succinctness.</strong> For every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic predicate  <span class="math">\\Pi</span> , and  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\in \\mathbb{G}(1^{\\lambda}, \\Pi)</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda}(1)</span>  bits;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbb{V}(\\mathsf{vk}, z, \\pi)</span>  runs in time  $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above,  <span class="math">O_{\\lambda}</span>  hides a (fixed) polynomial factor in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof for a message, the prover "knows" a compliant transcript T with output z. (Thus, soundness holds.) Namely, for every constant c>0 and every polynomial-size adversary A there is a polynomial-size witness extractor E such that, for every large-enough security parameter  <span class="math">\\lambda</span> , for every  <span class="math">\\mathbb F</span> -arithmetic compliance predicate  <span class="math">\\Pi</span>  of size  <span class="math">\\lambda^c</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathbb{V}(\\mathsf{vk},z,\\pi) = 1 \\\\ \\left(\\mathsf{out}(\\mathsf{T}) \\neq z \\ \\lor \\ \\Pi(\\mathsf{T}) \\neq 0\\right) & (\\mathsf{pk},\\mathsf{vk}) \\leftarrow \\mathbb{G}(1^\\lambda,\\Pi) \\\\ \\mathsf{T} \\leftarrow E(\\mathsf{pk},\\mathsf{vk}) \\end{array}\\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Statistical zero knowledge.</strong> An honestly-generated proof is statistical zero knowledge. <sup>27</sup> Namely, there is a polynomial-time stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are negligibly-close:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c} \\Phi = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\Pi \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathbb{G}(1^{\\lambda}, \\Pi) \\\\ (z, z_{\\mathsf{loc}}, \\vec{z_{\\mathsf{in}}}, \\vec{\\pi_{\\mathsf{in}}}) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow \\mathbb{P}(\\mathsf{pk}, z, z_{\\mathsf{loc}}, \\vec{z_{\\mathsf{in}}}, \\vec{\\pi_{\\mathsf{in}}}) \\end{array} \\right] \\quad \\text{and} \\quad \\Pr\\left[\\begin{array}{c} \\Pi \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow S(1^{\\lambda}, \\Pi) \\\\ (z, z_{\\mathsf{loc}}, \\vec{z_{\\mathsf{in}}}, \\vec{\\pi_{\\mathsf{in}}}) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow S(z) \\end{array} \\right] \\right.,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where, above,  <span class="math">\\Phi=1</span>  if and only if: (i) if  <span class="math">\\vec{\\pi}_{\\rm in}=\\bot</span> , then  <span class="math">\\Pi(z,z_{\\rm loc},\\vec{z}_{\\rm in},1)=0</span> ; (ii) if  <span class="math">\\vec{\\pi}_{\\rm in}\\ne\\bot</span> , then  <span class="math">\\Pi(z,z_{\\rm loc},\\vec{z}_{\\rm in},0)=0</span>  and, for each corresponding pair  <span class="math">(z_{\\rm in},\\pi_{\\rm in})</span> ,  <span class="math">\\mathbb{V}({\\sf vk},z_{\\rm in},\\pi_{\\rm in})=1</span> ; and (iii)  <span class="math">D(\\pi)=1</span> .</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>27</sup>In this paper, we construct PCD systems from preprocessing zk-SNARKs. Hence, analogously to preprocessing zk-SNARKs (cf. Remark C.1) <em>perfect</em> zero knowledge can be achieved at the only expense of a negligible error in completeness.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">E Scalable zk-SNARKs for random-access machines</h4>

    <p class="text-gray-300">At high-level, a zk-SNARK for random-access machines is a cryptographic primitive that provides short and easy-to-verify non-interactive zero-knowledge proofs of knowledge for the correct execution of programs. A public proving key is used to generate proofs, and a public verification key is used to verify them; the two keys are jointly generated once, and can then be used any number of times.</p>

    <p class="text-gray-300">In this work, we seek, and obtain an implementation of, zk-SNARKs that are scalable, i.e., that are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Fully succinct.</strong> This property requires that a <em>single</em> pair of keys suffices for computations of <em>any</em> (polynomial) size. In particular, the time to generate a key pair is short (i.e., bounded by a fixed polynomial in the security parameter) and so is the key length.</li>

      <li><strong>Incrementally computable.</strong> This property requires that proof generation is carried out <em>incrementally</em>, along the original computation, by updating, at each step, a proof of correctness of the computation so far.</li>

    </ul>

    <p class="text-gray-300">Below, we informally define fully-succinct zk-SNARKs for random-access machines, as well as the additional property of incremental computation. We refer the reader to, e.g., [BCCT13] for a formal treatment. (Also see Remark C.2 for a technical comment that applies here too.)</p>

    <p class="text-gray-300">A <strong>fully-succinct zk-SNARK</strong> for random-access machines (see Appendix A.2) is a triple of polynomial-time algorithms  <span class="math">(G^<em>, P^</em>, V^*)</span>  working as follows.</p>

    <p class="text-gray-300">•  <span class="math">G^{\\star}(1^{\\lambda}, \\mathbf{M}) \\to (\\mathsf{pk}, \\mathsf{vk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and a random-access machine  <span class="math">\\mathbf{M}</span> , the <em>key generator</em>  <span class="math">G^{\\star}</span>  probabilistically samples a proving key pk and a verification key vk. We assume, without loss of generality, that pk contains (a description of) the machine  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">The keys pk and vk are published as public parameters and can be used, any number of times, to prove/verify membership of instances in the language  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span>  of accepting computations on  <span class="math">\\mathbf{M}</span>  (see Definition A.2). The key generator  <span class="math">G^{\\star}</span>  is thus <em>succinct and universal</em> (i.e., it does not depend on the program  <span class="math">\\mathcal{P}</span> , or even computation size, but only on the machine  <span class="math">\\mathbf{M}</span>  used to run programs). The keys pk and vk are used as follows.<sup>28</sup></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P^<em>(\\mathsf{pk}, \\mathcal{P}, T, \\mathcal{G}) \\to \\pi</span> . On input a program  <span class="math">\\mathcal{P}</span> , time bound T, and auxiliary input  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\mathbf{M}(\\mathcal{P}; \\mathcal{G})</span>  accepts in  <span class="math">\\leq T</span>  steps, the </em>prover<em>  <span class="math">P^</em></span>  outputs a non-interactive proof  <span class="math">\\pi</span>  for the statement " <span class="math">(\\mathcal{P}, T) \\in \\mathcal{L}_{\\mathbf{M}}</span> ".</li>

      <li><span class="math">V^{\\star}(\\mathsf{vk}, \\mathcal{P}, T, \\pi) \\to b</span> . On input a program  <span class="math">\\mathcal{P}</span> , time bound T, and proof  <span class="math">\\pi</span> , the <em>verifier</em>  <span class="math">V^{\\star}</span>  outputs b = 1 if he is convinced by  <span class="math">\\pi</span>  that  <span class="math">(\\mathcal{P}, T) \\in \\mathcal{L}_{\\mathbf{M}}</span> .</li>

    </ul>

    <p class="text-gray-300">The triple  <span class="math">(G^{\\star}, P^{\\star}, V^{\\star})</span>  satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> The honest prover can convince the verifier for any instance in the language. Namely, for every security parameter  <span class="math">\\lambda</span> , random-access machine  <span class="math">\\mathbf{M}</span> , and instance  <span class="math">(\\mathcal{P}, T) \\in \\mathcal{L}_{\\mathbf{M}}</span>  with a witness  <span class="math">\\mathcal{G}</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[V^{\\star}(\\mathsf{vk}, \\mathcal{P}, T, \\pi) = 1 \\, \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, \\begin{array}{c} (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G^{\\star}(1^{\\lambda}, \\mathbf{M}) \\\\ \\pi \\leftarrow P^{\\star}(\\mathsf{pk}, \\mathcal{P}, T, \\mathcal{G}) \\end{array} \\right] = 1 \\ .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Succinctness.</strong> For every security parameter  <span class="math">\\lambda</span> , random-access machine  <span class="math">\\mathbf{M}</span> , and  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\in G^{\\star}(1^{\\lambda}, \\mathbf{M})</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda,\\mathbf{M}}(1)</span>  bits;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">V^*(\\mathsf{vk}, \\mathcal{P}, T, \\pi)</span>  runs in time  $O_{\\lambda, \\mathbf{M}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log T)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>&</sup>lt;sup>28</sup>Both pk and vk are public and only consist of  <span class="math">O_{\\lambda,\\mathbf{M}}(1)</span>  bits; so, one could think of them as a single <em>common reference string</em> crs := (pk, vk). We choose not to do so, because it will be more natural to think of them as separate data structures.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above,  <span class="math">O_{\\lambda,\\mathbf{M}}</span>  hides a (fixed) polynomial factor in  <span class="math">\\lambda</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . (In our implementation,  </span>\\lambda<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  are constants.) <strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof for a polynomial-size computation, the prover &quot;knows&quot; a witness for the instance. (Thus, soundness holds.) Namely, for every constant c&gt;0 and every polynomial-size adversary A there is a polynomial-size witness extractor E such that, for every large enough security parameter  </span>\\lambda<span class="math"> , for every random-access machine  </span>\\mathbf{M}$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr \\left[ \\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} T \\leq \\lambda^c & \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ } (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G^\\star(1^\\lambda, \\mathbf{M}) \\\\ V^\\star(\\mathsf{vk}, \\mathcal{P}, T, \\pi) = 1 & \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathcal{P}, T, \\pi) \\leftarrow A(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\left( (\\mathcal{P}, T), \\mathcal{G} \\right) \\notin \\mathcal{R}_\\mathbf{M} & \\mathcal{G} \\leftarrow E(\\mathsf{pk}, \\mathsf{vk}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Statistical zero knowledge.</strong> An honestly-generated proof is statistical zero knowledge. <sup>29</sup> Namely, there is a polynomial-time stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are negligibly-close:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} (\\mathcal{P},T),\\mathcal{G}) \\in \\mathcal{R}_{\\mathbf{M}} & \\mathbf{M} \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk},\\mathsf{vk}) \\leftarrow G^{\\star}(1^{\\lambda},\\mathbf{M}) \\\\ \\mathcal{D}(\\pi) = 1 & (\\mathcal{P},T,\\mathcal{G}) \\leftarrow D(\\mathsf{pk},\\mathsf{vk}) \\\\ & \\pi \\leftarrow P^{\\star}(\\mathsf{pk},\\mathcal{P},T,\\mathcal{G}) \\end{array}\\right] \\text{ and } \\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} (\\mathcal{P},T),\\mathcal{G}) \\in \\mathcal{R}_{\\mathbf{M}} & \\mathbf{M} \\leftarrow D(1^{\\lambda}) \\\\ (\\mathcal{P},T),\\mathcal{G}) \\in \\mathcal{R}_{\\mathbf{M}} & (\\mathsf{pk},\\mathsf{vk}) \\leftarrow S(1^{\\lambda},\\mathbf{M}) \\\\ D(\\pi) = 1 & (\\mathcal{P},T,\\mathcal{G}) \\leftarrow D(\\mathsf{pk},\\mathsf{vk}) \\\\ & \\pi \\leftarrow S(\\mathcal{P},T) \\end{array}\\right].$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, a fully-succinct zk-SNARK is also <strong>incrementally computable</strong> if there exist two algorithms, a <em>computation supervisor</em> SV and a <em>sub-prover</em> SP, such that, for every security parameter  <span class="math">\\lambda</span> , random-access machine  <span class="math">\\mathbf{M}</span> , instance  <span class="math">(\\mathcal{P},T) \\in \\mathcal{L}_{\\mathbf{M}}</span>  with a witness  <span class="math">\\mathcal{G}=(g_0,\\ldots,g_{T-1})</span> , key pair  <span class="math">(\\mathsf{pk},\\mathsf{vk}) \\in G^\\star(1^\\lambda,\\mathbf{M})</span> , and letting  <span class="math">\\pi_T:=P^\\star(\\mathsf{pk},\\mathcal{P},T,\\mathcal{G})</span> , the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For i = 1, ..., T,  <span class="math">\\pi_i = SP(pk, aux_i, \\pi_{i-1})</span> .</li>

      <li>For  <span class="math">i=1,\\ldots,T</span> ,  <span class="math">\\mathsf{aux}_i</span>  is the final state of memory when  <span class="math">\\mathsf{SV}(\\mathbf{M},g_i)</span>  has read-write random access to a memory initialized to the state  <span class="math">\\mathsf{aux}_{i-1}</span> . Moreover, each  <span class="math">\\mathsf{aux}_i</span>  has size  <span class="math">O_{\\lambda,\\mathbf{M}}(S_i)</span> , where  <span class="math">S_i</span>  is the space usage of  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span>  at time i.</li>

      <li>The proof  <span class="math">\\pi_0</span>  is defined as  <span class="math">\\bot</span> , and  <span class="math">\\mathsf{aux}_0</span>  as  <span class="math">\\mathcal{P}</span> . In particular, SV and SP have time and space complexity  <span class="math">O_{\\lambda,\\mathbf{M}}(1)</span> ; these costs are incurred each time a new proof is generated from an old one.</li>

    </ul>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">E.1 Known constructions and security</h4>

    <p class="text-gray-300">Theoretical constructions of fully-succinct zk-SNARKs are known, based on various cryptographic assumptions [Mic00, Val08, BCCT13]. Despite achieving essentially-optimal asymptotics [BFLS91, BGHSV05, BCGT13b, BCGT13a, BCCT13] no implementations of them have been reported in the literature to date.</p>

    <p class="text-gray-300">Of the above, the only approach that also achieves incremental computation is the one of Bitansky et al. [BCCT13], which we follow in this paper. Security in [BCCT13] is based on the security of <em>preprocessing</em> zk-SNARKs (see Appendix C.1) and collision-resistant hash functions.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>29</sup>In this paper, we construct fully-succinct zk-SNARKs from preprocessing ones. Hence, analogously to preprocessing zk-SNARKs (cf. Remark C.1) <em>perfect</em> zero knowledge can be achieved at the only expense of a negligible error in completeness.</p>

    <p class="text-gray-300"><sup>&</sup>lt;sup>30</sup>In our implementation,  <span class="math">aux_i</span>  has size  <span class="math">\\approx S_i</span> . Thus, the effective space overhead, compared to the original computation, is the <em>additive, constant</em> cost to run SV and SP.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-43-15"></span>[ADLM<sup>+</sup>08] Yuriy Arbitman, Gil Dogon, Vadim Lyubashevsky, Daniele Micciancio, Chris Peikert, and Alon Rosen. SWIFFTX: a proposal for the SHA-3 standard, 2008.</li>

      <li><span id="page-43-13"></span>[Ajt96] Miklos Ajtai. Generating hard instances of lattice problems. In ´ <em>Proceedings of the 28th Annual ACM Symposium on the Theory of Computing</em>, STOC '96, pages 99–108, 1996.</li>

      <li><span id="page-43-14"></span>[AM93] A. O. L. Atkin and F. Morain. Elliptic curves and primality proving. <em>Mathematics of Computation</em>, 61:29–68, 1993.</li>

      <li><span id="page-43-17"></span>[AV77] Dana Angluin and Leslie G. Valiant. Fast probabilistic algorithms for hamiltonian circuits and matchings. In <em>Proceedings on 9th Annual ACM Symposium on Theory of Computing</em>, STOC '77, pages 30–41, 1977.</li>

      <li><span id="page-43-18"></span>[BB04] Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, CRYPTO '04, pages 443–459, 2004.</li>

      <li><span id="page-43-6"></span>[BBFR15] Michael Backes, Manuel Barbosa, Dario Fiore, and Raphael M. Reischuk. ADSNARK: nearly practical and privacypreserving proofs on authenticated data. In <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>, S&P '15, pages 271–286, 2015.</li>

      <li><span id="page-43-19"></span>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ITCS '12, pages 326–349, 2012.</li>

      <li><span id="page-43-7"></span>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 111–120, 2013.</li>

      <li><span id="page-43-12"></span>[BCGG<sup>+</sup>14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In <em>Proceedings of the 2014 IEEE Symposium on Security and Privacy</em>, SP '14, pages 459–474, 2014.</li>

      <li><span id="page-43-10"></span>[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In <em>Proceedings of the 4th Innovations in Theoretical Computer Science Conference</em>, ITCS '13, pages 401–414, 2013.</li>

      <li><span id="page-43-9"></span>[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete efficiency of probabilisticallycheckable proofs. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 585–594, 2013.</li>

      <li><span id="page-43-4"></span>[BCGTV13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In <em>Proceedings of the 33rd Annual International Cryptology Conference</em>, CRYPTO '13, pages 90–108, 2013.</li>

      <li><span id="page-43-16"></span>[BCGTV13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. TinyRAM architecture specification v2.00, 2013. URL: <http://scipr-lab.org/tinyram>.</li>

      <li><span id="page-43-3"></span>[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In <em>Proceedings of the 10th Theory of Cryptography Conference</em>, TCC '13, pages 315–333, 2013.</li>

      <li><span id="page-43-21"></span>[BCP13] Nir Bitansky, Ran Canetti, and Omer Paneth. How to construct extractable one-way functions against uniform adversaries. Cryptology ePrint Archive, Report 2013/468, 2013.</li>

      <li><span id="page-43-20"></span>[BCPR13] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. Indistinguishability obfuscation vs. auxiliary-input extractable functions: One must fall. Cryptology ePrint Archive, Report 2013/641, 2013.</li>

      <li><span id="page-43-5"></span>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In <em>Proceedings of the 23rd USENIX Security Symposium</em>, Security '14, pages 781–796, 2014. Available at <http://eprint.iacr.org/2013/879>.</li>

      <li><span id="page-43-2"></span>[BDSMP91] Manuel Blum, Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. Non-interactive zero-knowledge. <em>SIAM Journal on Computing</em>, 20(6):1084–1118, 1991.</li>

      <li><span id="page-43-11"></span>[BEGKN91] Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. Checking the correctness of memories. In <em>Proceedings of the 32nd Annual Symposium on Foundations of Computer Science</em>, FOCS '91, pages 90–99, 1991.</li>

      <li><span id="page-43-8"></span>[BFLS91] Laszl ´ o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. ´ In <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>, STOC '91, pages 21–32, 1991.</li>

      <li><span id="page-43-1"></span>[BFM88] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications. In <em>Proceedings of the 20th Annual ACM Symposium on Theory of Computing</em>, STOC '88, pages 103–112, 1988.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-44-0"></span>[BFRS<sup>+</sup>13] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Verifying computations with state. In <em>Proceedings of the 25th ACM Symposium on Operating Systems Principles</em>, SOSP '13, pages 341–357, 2013.</li>

      <li><span id="page-44-20"></span>[BGHSV05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs verifiable in polylogarithmic time. In <em>Proceedings of the 20th Annual IEEE Conference on Computational Complexity</em>, CCC '05, pages 120–134, 2005.</li>

      <li><span id="page-44-17"></span>[BGOhM07] Paulo S. Barreto, Steven D. Galbraith, Colm O h ´ Eigeartaigh, and Scott Michael. Efficient pairing computation on ´ supersingular abelian varieties. <em>Designs, Codes and Cryptography</em>, 42(3):239–271, 2007.</li>

      <li><span id="page-44-18"></span>[BKLS02] Paulo S. L. M. Barreto, Hae Yong Kim, Ben Lynn, and Michael Scott. Efficient algorithms for pairing-based cryptosystems. In <em>Proceedings of the 22Nd Annual International Cryptology Conference</em>, CRYPTO '02, pages 354–368, 2002.</li>

      <li><span id="page-44-14"></span>[BLPRS13] Zvika Brakerski, Adeline Langlois, Chris Peikert, Oded Regev, and Damien Stehle. Classical hardness of learning ´ with errors. In <em>Proceedings of the 45th Annual ACM Symposium on Symposium on Theory of Computing</em>, STOC '13, pages 575–584, 2013.</li>

      <li><span id="page-44-11"></span>[BLS03] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Constructing elliptic curves with prescribed embedding degrees. In <em>Proceedings of the 3rd International Conference on Security in Communication Networks</em>, SCN '02, pages 257–267, 2003.</li>

      <li><span id="page-44-19"></span>[BLS04] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Efficient implementation of pairing-based cryptosystems. <em>Journal of Cryptology</em>, 17(4):321–334, 2004.</li>

      <li><span id="page-44-13"></span>[BS10] Naomi Benger and Michael Scott. Constructing tower extensions of finite fields for implementation of pairing-based cryptography. In <em>Proceedings of the 3rd International Conference on Arithmetic of Finite Fields</em>, WAIFI '10, pages 180–195, 2010.</li>

      <li><span id="page-44-8"></span>[BSW12] Dan Boneh, Gil Segev, and Brent Waters. Targeted malleability: Homomorphic encryption for restricted computations. In <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ITCS '12, pages 350–366, 2012.</li>

      <li><span id="page-44-12"></span>[BW05] Friederike Brezing and Annegret Weng. Elliptic curves suitable for pairing based cryptography. <em>Designs, Codes and Cryptography</em>, 37(1):133–141, 2005.</li>

      <li><span id="page-44-16"></span>[CFAD<sup>+</sup>12] Henri Cohen, Gerhard Frey, Roberto Avanzi, Christophe Doche, Tanja Lange, Kim Nguyen, and Frederik Vercauteren. <em>Handbook of Elliptic and Hyperelliptic Curve Cryptography</em>. Chapman & Hall/CRC, 2 edition, 2012.</li>

      <li><span id="page-44-7"></span>[CFHK<sup>+</sup>15] Craig Costello, Cedric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, ´ and Samee Zahur. Geppetto: Versatile verifiable computation. In <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>, S&P '15, pages 253–270, 2015.</li>

      <li><span id="page-44-1"></span>[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. Practical verified computation with streaming interactive proofs. In <em>Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science</em>, ITCS '12, pages 90–112, 2012.</li>

      <li><span id="page-44-9"></span>[CP01] C. Cocks and Richard G. E. Pinch. Identity-based cryptosystems based on the weil pairing. Unpublished manuscript, 2001.</li>

      <li><span id="page-44-15"></span>[CR72] Stephen A. Cook and Robert A. Reckhow. Time-bounded random access machines. In <em>Proceedings of the 4th Annual ACM Symposium on Theory of Computing</em>, STOC '72, pages 73–80, 1972.</li>

      <li><span id="page-44-2"></span>[CRR11] Ran Canetti, Ben Riva, and Guy N. Rothblum. Practical delegation of computation using multiple servers. In <em>Proceedings of the 18th ACM Conference on Computer and Communications Security</em>, CCS '11, pages 445–454, 2011.</li>

      <li><span id="page-44-3"></span>[CT10] Alessandro Chiesa and Eran Tromer. Proof-carrying data and hearsay arguments from signature cards. In <em>Proceedings of the 1st Symposium on Innovations in Computer Science</em>, ICS '10, pages 310–331, 2010.</li>

      <li><span id="page-44-4"></span>[CT12] Alessandro Chiesa and Eran Tromer. Proof-carrying data: Secure computation on untrusted platforms (high-level description). <em>The Next Wave: The National Security Agency's review of emerging technologies</em>, 19(2):40–46, 2012.</li>

      <li><span id="page-44-5"></span>[CTV13] Stephen Chong, Eran Tromer, and Jeffrey A. Vaughan. Enforcing language semantics using proof-carrying data. Cryptology ePrint Archive, Report 2013/513, 2013.</li>

      <li><span id="page-44-6"></span>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. Cluster computing in zero knowledge. In <em>Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '15, pages 371–403, 2015.</li>

      <li><span id="page-44-10"></span>[DEM05] Regis Dupont, Andreas Enge, and Fran ´ c¸ois Morain. Building curves with arbitrary small MOV degree over finite prime fields. <em>Journal of Cryptology</em>, 18(2):79–89, 2005.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-45-3"></span>[DFGK14] George Danezis, Cedric Fournet, Jens Groth, and Markulf Kohlweiss. Square span programs with applications to ´ succinct NIZK arguments. In <em>Proceedings of the 20th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '14, pages 532–550, 2014.</li>

      <li><span id="page-45-7"></span>[ES10] Andreas Enge and Andrew V. Sutherland. Class invariants by the CRT method. In <em>Proceedings of the 9th International Symposium on Algorithmic Number Theory</em>, ANTS '10, pages 142–156, 2010.</li>

      <li><span id="page-45-17"></span>[FMR06] Gerhard Frey, Michael Muller, and Hans-Georg R ¨ uck. The Tate pairing and the discrete logarithm applied to elliptic ¨ curve cryptosystems. <em>IEEE Transactions on Information Theory</em>, 45(5):1717–1719, 2006.</li>

      <li><span id="page-45-16"></span>[FR94] Gerhard Frey and Hans-Georg Ruck. A remark concerning m-divisibility and the discrete logarithm in the divisor ¨ class group of curves. <em>Mathematics of Computation</em>, 62(206):865–874, 1994.</li>

      <li><span id="page-45-21"></span>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: practical solutions to identification and signature problems. In <em>Proceedings of the 6th Annual International Cryptology Conference</em>, CRYPTO '87, pages 186–194, 1987.</li>

      <li><span id="page-45-6"></span>[FST10] David Freeman, Michael Scott, and Edlyn Teske. A taxonomy of pairing-friendly elliptic curves. <em>Journal of Cryptology</em>, 23(2):224–280, 2010.</li>

      <li><span id="page-45-19"></span>[Gen04] Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, CRYPTO '04, pages 220–236, 2004.</li>

      <li><span id="page-45-4"></span>[GGH96] Oded Goldreich, Shafi Goldwasser, and Shai Halevi. Collision-free hashing from lattice problems. Technical report, 1996. ECCC TR95-042.</li>

      <li><span id="page-45-15"></span>[GGH13] Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear maps from ideal lattices. In <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '13, pages 1–17, 2013.</li>

      <li><span id="page-45-1"></span>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '13, pages 626–645, 2013.</li>

      <li><span id="page-45-10"></span>[GHS02] Steven D. Galbraith, Keith Harrison, and David Soldera. Implementing the Tate pairing. In <em>Proceedings of the 5th International Symposium on Algorithmic Number Theory</em>, ANTS '02, pages 324–337, 2002.</li>

      <li><span id="page-45-5"></span>[GLS09] Parikshit Gopalan, Shachar Lovett, and Amir Shpilka. On the complexity of boolean functions in different characteristics. In <em>Proceedings of the 24th Annual IEEE Conference on Computational Complexity</em>, CCC '09, pages 173–183, 2009.</li>

      <li><span id="page-45-0"></span>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '10, pages 321–340, 2010.</li>

      <li><span id="page-45-11"></span>[GS06] R. Granger and Nigel Smart. On computing products of pairings. Cryptology ePrint Archive, Report 2006/172, 2006.</li>

      <li><span id="page-45-8"></span>[GS10] Robert Granger and Michael Scott. Faster squaring in the cyclotomic subgroup of sixth degree extensions. In <em>Proceedings of the 13th international conference on Practice and Theory in Public Key Cryptography</em>, PKC'10, pages 209–223, 2010.</li>

      <li><span id="page-45-13"></span>[GSCvDD03] Blaise Gassend, G. Edward Suh, Dwaine E. Clarke, Marten van Dijk, and Srinivas Devadas. Caches and hash trees for efficient memory integrity verification. In <em>Proceedings of the 9th International Symposium on High-Performance Computer Architecture</em>, HPCA '03, pages 295–306, 2003.</li>

      <li><span id="page-45-14"></span>[GSMB03] Eu-Jin Goh, Hovav Shacham, Nagendra Modadugu, and Dan Boneh. SiRiUS: Securing remote untrusted storage. In <em>Proceedings of the Network and Distributed System Security Symposium</em>, NDSS '03, 2003.</li>

      <li><span id="page-45-20"></span>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In <em>Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</em>, STOC '11, pages 99–108, 2011.</li>

      <li><span id="page-45-18"></span>[HSV06] F. Hess, N. P. Smart, and F. Vercauteren. The Eta pairing revisited. <em>IEEE Transactions on Information Theory</em>, 52(10):4595–4602, 2006.</li>

      <li><span id="page-45-12"></span>[JJ98] Antoine Joux and Stern Jacques. Lattice reduction: A toolbox for the cryptanalyst. <em>Journal of Cryptology</em>, 11(3):161– 185, 1998.</li>

      <li><span id="page-45-9"></span>[KKC13] Taechan Kim, Sungwook Kim, and Jung Hee Cheon. On the final exponentiation in Tate pairing computations. <em>IEEE Transactions on Information Theory</em>, 59(6):4033–4041, 2013.</li>

      <li><span id="page-45-2"></span>[KPPS<sup>+</sup>14] Ahmed E. Kosba, Dimitrios Papadopoulos, Charalampos Papamanthou, Mahmoud F. Sayed, Elaine Shi, and Nikos Triandopoulos. TRUESET: Faster verifiable set computations. In <em>Proceedings of the 23rd USENIX Security Symposium</em>, USENIX Security '14, pages 765–780, 2014.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-46-17"></span>[KRSWF03] Mahesh Kallahalla, Erik Riedel, Ram Swaminathan, Qian Wang, and Kevin Fu. Plutus: Scalable secure file sharing on untrusted storage. In <em>Proceedings of the 2003 Conference on File and Storage Technologies</em>, FAST '03, 2003.</li>

      <li><span id="page-46-10"></span>[KT08] Koray Karabina and Edlyn Teske. On prime-order elliptic curves with embedding degrees k = 3, 4, and 6. In <em>Proceedings of the 8th International Conference on Algorithmic Number Theory</em>, ANTS-VIII '08, pages 102–117, 2008.</li>

      <li><span id="page-46-1"></span>[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography</em>, TCC '12, pages 169–189, 2012.</li>

      <li><span id="page-46-3"></span>[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In <em>Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '13, pages 41–60, 2013.</li>

      <li><span id="page-46-4"></span>[Lip14] Helger Lipmaa. Efficient NIZK arguments via parallel verification of Benes networks. In ˇ <em>Proceedings of the 9th International Conference on Security and Cryptography for Networks</em>, SCN '14, pages 416–434, 2014.</li>

      <li><span id="page-46-11"></span>[LM06] Vadim Lyubashevsky and Daniele Micciancio. Generalized compact knapsacks are collision resistant. In <em>Proceedings of the 33rd International Conference on Automata, Languages and Programming</em>, ICALP '06, pages 144–155, 2006.</li>

      <li><span id="page-46-6"></span>[LMN10] Kristin Lauter, Peter L. Montgomery, and Michael Naehrig. An analysis of affine coordinates for pairing computation. In <em>Proceedings of the 4th International Conference on Pairing-based Cryptography</em>, Pairing '10, pages 1–20, 2010.</li>

      <li><span id="page-46-13"></span>[LMPR08] Vadim Lyubashevsky, Daniele Micciancio, Chris Peikert, and Alon Rosen. SWIFFT: a modest proposal for FFT hashing. In <em>Proceedings of the 15th International Workshop on Fast Software Encryption</em>, FSE '08, pages 54–72, 2008.</li>

      <li><span id="page-46-7"></span>[LN97] Rudolf Lidl and Harald Niederreiter. <em>Finite Fields</em>. Cambridge University Press, second edition edition, 1997.</li>

      <li><span id="page-46-5"></span>[Mic00] Silvio Micali. Computationally sound proofs. <em>SIAM Journal on Computing</em>, 30(4):1253–1298, 2000. Preliminary version appeared in FOCS '94.</li>

      <li><span id="page-46-9"></span>[MNT01] Atsuko Miyaji, Masaki Nakabayashi, and Shunzo Takano. New explicit conditions of elliptic curve traces for FR-reduction. <em>IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences</em>, 84(5):1234–1243, 2001.</li>

      <li><span id="page-46-21"></span>[MOV91] Alfred Menezes, Tatsuaki Okamoto, and Scott Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. In <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>, STOC '91, pages 80–89, 1991.</li>

      <li><span id="page-46-16"></span>[MS01] David Mazieres and Dennis Shasha. Don't trust your file server. In \` <em>Proceedings of the 8th Workshop on Hot Topics in Operating Systems</em>, HotOS '01, pages 113–118, 2001.</li>

      <li><span id="page-46-15"></span>[MVS00] Umesh Maheshwari, Radek Vingralek, and William Shapiro. How to build a trusted database system on untrusted storage. In <em>Proceedings of the 4th Conference on Symposium on Operating System Design & Implementation</em>, OSDI '00, pages 10–10, 2000.</li>

      <li><span id="page-46-14"></span>[NY89] Moni Naor and Moti Yung. Universal one-way hash functions and their cryptographic applications. In <em>Proceedings of the 21st Annual ACM Symposium on Theory of Computing</em>, STOC '89, pages 33–43, 1989.</li>

      <li><span id="page-46-0"></span>[NY90] Moni Naor and Moti Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In <em>Proceedings of the 22nd Annual ACM Symposium on Theory of Computing</em>, STOC '90, pages 427–437, 1990.</li>

      <li><span id="page-46-22"></span>[Odl85] Andrew M. Odlyzko. Discrete logarithms in finite fields and their cryptographic significance. In <em>Proceedings of the 3rd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '85, pages 224–314, 1985.</li>

      <li><span id="page-46-2"></span>[PGHR13] Brian Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>Proceedings of the 34th IEEE Symposium on Security and Privacy</em>, Oakland '13, pages 238–252, 2013.</li>

      <li><span id="page-46-18"></span>[PH78] Stephen Pohlig and Martin Hellman. An improved algorithm for computing logarithms over gf(p) and its cryptographic significance. <em>Journal IEEE Transactions on Information Theory</em>, 24(1):106–110, 1978.</li>

      <li><span id="page-46-19"></span>[Pol78] John M. Pollard. Monte Carlo methods for index computation (mod p). <em>Mathematics of Computation</em>, 32(143):918– 924, 1978.</li>

      <li><span id="page-46-20"></span>[Pol00] John M. Pollard. Kangaroos, monopoly and discrete logarithms. <em>Journal of Cryptology</em>, 13:437–447, 2000.</li>

      <li><span id="page-46-12"></span>[PR06] Chris Peikert and Alon Rosen. Efficient collision-resistant hashing from worst-case assumptions on cyclic lattices. In <em>Proceedings of the 3rd Conference on Theory of Cryptography</em>, TCC '06, pages 145–166, 2006.</li>

      <li><span id="page-46-8"></span>[Raz87] Alexander A. Razborov. Lower bounds on the size of bounded depth circuits over a complete basis with logical addition. <em>Mathematical notes of the Academy of Sciences of the USSR</em>, 41(4):333–338, 1987.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-47-20"></span>[Rom90] John Rompel. One-way functions are necessary and sufficient for secure signatures. In <em>Proceedings of the 22nd Annual ACM Symposium on Theory of Computing</em>, STOC '90, pages 387–394, 1990.</li>

      <li><span id="page-47-9"></span>[SA98] Takakazu Satoh and Kiyomichi Araki. Fermat quotients and the polynomial time discrete log algorithm for anomalous elliptic curves. <em>Commentarii Mathematici Universitatis Sancti Pauli</em>, 47(1):81–92, 1998.</li>

      <li><span id="page-47-11"></span>[SB06] Michael Scott and Paulo S. Barreto. Generating more MNT elliptic curves. <em>Designs, Codes and Cryptography</em>, 38(2):209–217, 2006.</li>

      <li><span id="page-47-16"></span>[SBCDPK09] Michael Scott, Naomi Benger, Manuel Charlemagne, Luis J. Dominguez Perez, and Ezekiel J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. In <em>Proceedings of the 3rd International Conference Palo Alto on Pairing-Based Cryptography</em>, Pairing '09, pages 78–88, 2009.</li>

      <li><span id="page-47-3"></span>[SBVB<sup>+</sup>13] Srinath Setty, Benjamin Braun, Victor Vu, Andrew J. Blumberg, Bryan Parno, and Michael Walfish. Resolving the conflict between generality and plausibility in verified computation. In <em>Proceedings of the 8th EuoroSys Conference</em>, EuroSys '13, pages 71–84, 2013.</li>

      <li><span id="page-47-0"></span>[SBW11] Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Toward practical and unconditional verification of remote computations. In <em>Proceedings of the 13th USENIX Conference on Hot Topics in Operating Systems</em>, HotOS '11, pages 29–29, 2011.</li>

      <li><span id="page-47-19"></span>[Sco05] Michael Scott. Computing the Tate pairing. In <em>Proceedings of the The Cryptographers' Track at the RSA Conference 2005</em>, CT-RSA '05, pages 293–304, 2005.</li>

      <li><span id="page-47-17"></span>[Sco07] Michael Scott. Implementing cryptographic pairings. In <em>Proceedings of the 1st First International Conference on Pairing-Based Cryptography</em>, Pairing '07, pages 177–196, 2007.</li>

      <li><span id="page-47-7"></span>[Sem98] Igor A. Semaev. Evaluation of discrete logarithms in a group of p-torsion points of an elliptic curve in characteristic p. <em>Mathematics of Computation</em>, 67(221):353–356, 1998.</li>

      <li><span id="page-47-22"></span>[Sha71] Daniel Shanks. Class number, a theory of factorization, and genera. <em>Symposia on Pure Mathematics</em>, 20:415–440, 1971.</li>

      <li><span id="page-47-21"></span>[Sil09] Joseph H. Silverman. <em>The Arithmetic of Elliptic Curves</em>. Springer, 2 edition, 2009.</li>

      <li><span id="page-47-8"></span>[Sma99] Nigel P. Smart. The discrete logarithm problem on elliptic curves of trace one. <em>Journal of Cryptology</em>, 12(3):193–196, 1999.</li>

      <li><span id="page-47-1"></span>[SMBW12] Srinath Setty, Michael McPherson, Andrew J. Blumberg, and Michael Walfish. Making argument systems for outsourced computation practical (sometimes). In <em>Proceedings of the 2012 Network and Distributed System Security Symposium</em>, NDSS '12, 2012.</li>

      <li><span id="page-47-10"></span>[Smo87] Roman Smolensky. Algebraic methods in the theory of lower bounds for boolean circuit complexity. In <em>Proceedings of the 19th Annual ACM Symposium on Theory of Computing</em>, STOC '87, pages 77–82, 1987.</li>

      <li><span id="page-47-18"></span>[Sol03] Jerome A. Solinas. Id-based digital signature algorithms. <a href="http://cacr.uwaterloo.ca/conferences/2003/ecc2003/solinas.pdf">http://cacr.uwaterloo.ca/conferences/</a> <a href="http://cacr.uwaterloo.ca/conferences/2003/ecc2003/solinas.pdf">2003/ecc2003/solinas.pdf</a>, 2003.</li>

      <li><span id="page-47-12"></span>[SS11] Joseph H. Silverman and Katherine E. Stange. Amicable pairs and aliquot cycles for elliptic curves. <em>Experimental Mathematics</em>, 20(3):329–357, 2011.</li>

      <li><span id="page-47-14"></span>[Sut11] Andrew V. Sutherland. Computing Hilbert class polynomials with the Chinese remainder theorem. <em>Mathematics of Computation</em>, 80(273):501–538, 2011.</li>

      <li><span id="page-47-13"></span>[Sut12] Andrew V. Sutherland. Accelerating the CM method. <em>LMS Journal of Computation and Mathematics</em>, 15:172–204, 12 2012.</li>

      <li><span id="page-47-2"></span>[SVPB<sup>+</sup>12] Srinath Setty, Victor Vu, Nikhil Panpalia, Benjamin Braun, Andrew J. Blumberg, and Michael Walfish. Taking proof-based verified computation a few steps closer to practicality. In <em>Proceedings of the 21st USENIX Security Symposium</em>, Security '12, pages 253–268, 2012.</li>

      <li><span id="page-47-5"></span>[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In <em>Proceedings of the 33rd Annual International Cryptology Conference</em>, CRYPTO '13, pages 71–89, 2013.</li>

      <li><span id="page-47-4"></span>[TRMP12] Justin Thaler, Mike Roberts, Michael Mitzenmacher, and Hanspeter Pfister. Verifiable computation with massively parallel interactive proofs. <em>CoRR</em>, abs/1202.1350, 2012.</li>

      <li><span id="page-47-6"></span>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In <em>Proceedings of the 5th Theory of Cryptography Conference</em>, TCC '08, pages 1–18, 2008.</li>

      <li><span id="page-47-15"></span>[Ver10] Frederik Vercauteren. Optimal pairings. <em>IEEE Transactions on Information Theory</em>, 56(1):455–461, 2010.</li>

      <li><span id="page-47-23"></span>[vOW99] Paul C. van Oorschot and Michael J. Wiener. Parallel collision search with cryptanalytic applications. <em>Journal of Cryptology</em>, 12(1):1–28, 1999.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-48-2"></span>[Was08] Lawrence C. Washington. <em>Elliptic Curves: Number Theory and Cryptography</em>. Chapman & Hall/CRC, 2 edition, 2008.</li>

      <li><span id="page-48-1"></span>[WSRBW15] Riad S. Wahby, Srinath Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. Efficient RAM and control flow in verifiable outsourced computation. In <em>Proceedings of the 22nd Network and Distributed System Security Symposium</em>, NDSS '15, 2015.</li>

      <li><span id="page-48-0"></span>[ZPK14] Yupeng Zhang, Charalampos Papamanthou, and Jonathan Katz. Alitheia: Towards practical verifiable graph processing. In <em>Proceedings of the 21st ACM Conference on Computer and Communications Security</em>, CCS '14, pages 856–867, 2014.</li>

    </ul>`;
---

<BaseLayout title="Scalable Zero Knowledge via Cycles of Elliptic Curves (2014/595)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/595
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
