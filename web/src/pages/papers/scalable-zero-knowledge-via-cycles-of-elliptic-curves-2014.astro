---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/595';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Scalable Zero Knowledge via Cycles of Elliptic Curves';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, Madars Virza';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Non-interactive zero-knowledge proofs of knowledge for general NP statements are a powerful cryptographic primitive, both in theory and in practical applications. Recently, much research has focused on achieving an additional property, succinctness, requiring the proof to be very short and easy to verify. Such proof systems are known as zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARKs), and are desired when communication is expensive, or the verifier is computationally weak.

Existing zk-SNARK implementations have severe scalability limitations, in terms of space complexity as a function of the size of the computation being proved (e.g., running time of the NP statement&rsquo;s decision program). First, the size of the proving key is quasilinear in the upper bound on the computation size. Second, producing a proof requires &quot;writing down&quot; all intermediate values of the entire computation, and then conducting global operations such as FFTs.

The bootstrapping technique of Bitansky et al. (STOC &rsquo;13), following Valiant (TCC &rsquo;08), offers an approach to scalability, by recursively composing proofs: proving statements about acceptance of the proof system&rsquo;s own verifier (and correctness of the program&rsquo;s latest step). Alas, recursive composition of known zk-SNARKs has never been realized in practice, due to enormous computational cost.

Using new elliptic-curve cryptographic techniques, and methods for exploiting the proof systems&rsquo; field structure and nondeterminism, we achieve the first zk-SNARK implementation that practically achieves recursive proof composition. Our zk-SNARK implementation runs random-access machine programs and produces proofs of their correct execution, on today&rsquo;s hardware, for any program running time. It takes constant time to generate the keys that support all computation sizes. Subsequently, the proving process only incurs a constant multiplicative overhead compared to the original computation&rsquo;s time, and an essentially-constant additive overhead in memory. Thus, our zk-SNARK implementation is the first to have a well-defined, albeit low, clock rate of &quot;verified instructions per second&quot;.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> computationally-sound proofs &middot; proof-carrying data &middot; zero knowledge &middot; elliptic curves</p>
    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Constructions of arithmetic circuits</h2>

    <p class="text-gray-300">In Section 4 we gave a construction of a PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  in terms of two preprocessing zk-SNARKs, based on a PCD-friendly 2-cycle  <span class="math">(E_{\\alpha}, E_{\\beta})</span> , and various arithmetic circuits. We now discuss concrete implementations of these arithmetic circuits, which determine the sizes of  <span class="math">C_{pcd,\\alpha}</span>  and  <span class="math">C_{pcd,\\beta}</span>  (see Equation 1).</p>

    <p class="text-gray-300">In our code implementation,  <span class="math">(E_{\\alpha}, E_{\\beta})</span>  equals  <span class="math">(E_4, E_6)</span> , a specific 2-cycle based on MNT curves of embedding degree 4 and 6, selected to have high 2-adicity (see Section 3.2). Thus, in the text below, &quot; <span class="math">\\alpha = 4</span>  and  <span class="math">\\beta = 6</span> &quot;. We obtain the following efficiency for the two circuits  <span class="math">C_{\\text{pcd},4}</span>  and  <span class="math">C_{\\text{pcd},6}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.1</strong> (informal). Let  <span class="math">\\Pi: \\mathbb{F}_{r_4}^{n_{\\mathsf{msg}}} \\times \\mathbb{F}_{r_4}^{n_{\\mathsf{loc}}} \\times \\mathbb{F}_{r_4}^{s \\cdot n_{\\mathsf{msg}}} \\times \\mathbb{F}_{r_4} \\to \\mathbb{F}_{r_4}^l</span>  be an  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic compliance predicate for message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , arity s (and some output size l). The  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic circuit  <span class="math">C_{\\mathsf{pcd},6}</span>  have the following number of gates.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Gate count for <span class="math">C_{pcd,4}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">booleanity checks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">11920 + (1+s) \\cdot n_{msg} \\cdot 298</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(1+s)</span> copies of <span class="math">C_{H,6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(1+s)\\times 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s copies of <span class="math">C_{S,4\\leftarrow6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s \\times 298</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s copies of <span class="math">C_{V,6}</span> for <span class="math">n_6=2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s \\times 89113</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&#1055;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Pi $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">misc.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Total</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Pi  + s \\cdot 89412$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">+(1+s) \\cdot n_{msg} \\cdot 298 + 11925</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Gate count for <span class="math">C_{pcd,6}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_{S,4\\leftarrow 6}</span> <span class="math">C_{V,4}^{\\text{conline}}</span> for <span class="math">n_4=1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">298<br>31729</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Total</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32027</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Next, we discuss the various subcircuits: for the zk-SNARK verifiers and for collision-resistant hashing.</p>

    <p class="text-gray-300">Remark 5.2. We selected the PCD-friendly 2-cycle  <span class="math">(E_4, E_6)</span>  to have high 2-adicity: it has  <span class="math">\\nu_2(r_4-1)=34</span>  and  <span class="math">\\nu_2(r_6-1)=17</span> . These values are not accidental, but were chosen so that the 2-cycle  <span class="math">(E_4, E_6)</span>  suffices for &quot;essentially all practical uses&quot; of our PCD system. Specifically, recall that we would like, for efficiency reasons, that (i)  <span class="math">\\nu_2(r_4-1) \\geq \\lceil \\log |C_{\\mathsf{pcd},4}| \\rceil</span>  and (ii)  <span class="math">\\nu_2(r_6-1) \\geq \\lceil \\log |C_{\\mathsf{pcd},6}| \\rceil</span>  (see Section 3.2 and Appendix C.2). First, since  <span class="math">\\lceil \\log |C_{\\mathsf{pcd},6}| \\rceil = 15</span> , Condition (ii) holds always. As for Condition (i), it depends on  <span class="math">\\Pi</span> ; however, since  <span class="math">\\nu_2(r_4-1)=34</span>  is so large, it is not a limitation for practically-feasible choices of  <span class="math">\\Pi</span> . 15</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Arithmetic circuits for zk-SNARK verifiers</h3>

    <p class="text-gray-300">We seek arithmetic circuits for the two zk-SNARK verifiers: an  <span class="math">\\mathbb{F}_{r_6}</span> -arithmetic circuit  <span class="math">C_{V,4}</span>  implementing  <span class="math">V_4</span>  and an  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic circuit  <span class="math">C_{V,6}</span>  implementing  <span class="math">V_6</span> . Note the field characteristics:  <span class="math">V_4</span> 's arithmetic operations are over  <span class="math">\\mathbb{F}_{q_4}</span>  (which is equal to  <span class="math">\\mathbb{F}_{r_4}</span> ) and  <span class="math">V_6</span> 's operations are over  <span class="math">\\mathbb{F}_{q_6}</span>  (which is equal to  <span class="math">\\mathbb{F}_{r_4}</span> ).</p>

    <p class="text-gray-300">We design and construct  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span> , each consisting of two subcircuits for the &quot;offline&quot; and &quot;online&quot; parts of the verifier (see Section 4.1), and achieve the following efficiency:</p>

    <p class="text-gray-300"><strong>Lemma 5.3</strong> (informal). Let  <span class="math">n, l \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">&bull; There is an  <span class="math">\\mathbb{F}_{q_4}</span> -arithmetic circuit  <span class="math">C_{V,4}</span>  with size</p>

    <p class="text-gray-300"><span class="math">$(10 \\cdot l - 4) \\cdot n + 43,767</span>$</p>

    <p class="text-gray-300">that implements  <span class="math">V_4</span>  for all inputs  <span class="math">x \\in \\mathbb{F}^n_{r_4}</span>  such that each  <span class="math">x_i</span>  has at most l bits. (Naturally,  <span class="math">l \\leq \\lceil \\log r_4 \\rceil</span> .) Moreover,  <span class="math">C_{V,4}</span>  consists of two subcircuits,  <span class="math">C_{V,4}^{\\text{offline}}</span>  and  <span class="math">C_{V,4}^{\\text{offline}}</span> , implementing  <span class="math">V_4^{\\text{offline}}</span>  and  <span class="math">V_4^{\\text{offline}}</span> , with sizes</p>

    <p class="text-gray-300"><span class="math">$12270</span>$
and  <span class="math">(10 \\cdot l - 4) \\cdot n + 31,497</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;14</sup>The choice  <span class="math">(E_{\\alpha}, E_{\\beta}) = (E_4, E_6)</span> , rather than  <span class="math">(E_{\\alpha}, E_{\\beta}) = (E_6, E_4)</span> , is intentional. We expect  <span class="math">C_{\\text{pcd},\\alpha}</span>  to be larger than  <span class="math">C_{\\text{pcd},\\beta}</span>  (due to a larger number of checks), so that  <span class="math">E_{\\alpha}</span>  should be the curve with the higher 2-adicity. In this case,  <span class="math">E_4</span>  is twice as 2-adic as  <span class="math">E_6</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;15</sup>More precisely, if we take  <span class="math">|\\Pi| + s \\cdot 89412</span>  to be the leading terms in  <span class="math">|C_{pcd,4}|</span>  (which we expect to be the case), we obtain that  <span class="math">\\log(|\\Pi| + s \\cdot 89412) \\le 1 + \\max\\{\\log|\\Pi|, 17 + \\log s\\}</span> , which is likely to be well below 34.</p>

    <p class="text-gray-300">&bull; There is an  <span class="math">\\mathbb{F}_{q_6}</span> -arithmetic circuit  <span class="math">C_{V,6}</span>  with size</p>

    <p class="text-gray-300"><span class="math">$(10 \\cdot l - 4) \\cdot n + 83{,}181</span>$</p>

    <p class="text-gray-300">that implements  <span class="math">V_6</span>  for all inputs  <span class="math">x \\in \\mathbb{F}_{r_6}^n</span>  such that each  <span class="math">x_i</span>  has at most l bits. (Naturally,  <span class="math">l \\leq \\lceil \\log r_6 \\rceil</span> .) Moreover,  <span class="math">C_{V,6}</span>  consists of two subcircuits,  <span class="math">C_{V,6}^{\\text{offline}}</span>  and  <span class="math">C_{V,6}^{\\text{online}}</span> , implementing  <span class="math">V_6^{\\text{offline}}</span>  and  <span class="math">V_6^{\\text{online}}</span> , with sizes</p>

    <p class="text-gray-300"><span class="math">$23325</span>$
and  <span class="math">(10 \\cdot l - 4) \\cdot n + 59,856</span> .</p>

    <p class="text-gray-300">(In,  <span class="math">C_{\\mathsf{pcd},4}</span>  and  <span class="math">C_{\\mathsf{pcd},6}</span> , we set  <span class="math">(n,l) = (2, \\lfloor \\log r_6 \\rfloor)</span>  and  <span class="math">(n,l) = (1, \\lceil \\log r_4 \\rceil)</span>  for  <span class="math">C_{V,6}</span>  and  <span class="math">C_{V,4}</span> , respectively. Also, in Lemma 5.1, the reported size for  <span class="math">C_{V,4}^{\\mathrm{online}}</span>  is even smaller than  <span class="math">(10 \\cdot \\lceil \\log r_4 \\rceil - 4) \\cdot 1 + 31,497</span>  because we hardcode the processed verification key  <span class="math">\\mathsf{pvk}_4</span>  into  <span class="math">C_{V,4}^{\\mathrm{online}}</span> , which provides additional savings.)</p>

    <p class="text-gray-300">The zk-SNARK verifier protocol. The protocol of the zk-SNARK verifier V (recalled in Appendix C.3) consists of two parts: (a) use the verification key vk and input  <span class="math">\\vec{x} \\in \\mathbb{F}_r^n</span>  to compute an element  <span class="math">vk_{\\vec{x}} \\in \\mathbb{G}_1</span> ; and (b) use the verification key vk, element  <span class="math">vk_{\\vec{x}}</span> , and proof  <span class="math">\\pi</span> , to compute 12 pairings for the required checks.</p>

    <p class="text-gray-300"><strong>Prior techniques for fast program execution of</strong> V<strong>.</strong> The first part of V requires O(n) scalar multiplications in  <span class="math">\\mathbb{G}_1</span> , and can be efficiently performed via a suitable choice of variable-base multi-scalar multiplication techniques. The second part dominates V's efficiency for small n, and an efficient implementation is algorithmically more complex. Ben-Sasson at al. [BCTV14] address this second part by (i) obtaining optimized implementations of sub-components of a pairing, and then (ii) combining these in a way that is tailored to V's protocol. In short, after breaking a pairing into its two main parts, the <em>Miller loop</em> and the <em>final exponentiation</em>, and implementing both (using optimal pairings [Ver10] and other methods [SBCDPK09, GS10, KKC13]), they apply precomputation techniques to the verification key [GHS02, BLS03, Sc007] and share subcomputations of the Miller loop and final exponentiations across V's different pairing evaluations [Sol03, Sc005, GS06, Sc007].</p>

    <p class="text-gray-300">Our techniques for fast circuit verification of V. The high-level structure of our construction of  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span>  mirrors that of our software implementation of  <span class="math">V_4</span>  and  <span class="math">V_6</span> , itself based on techniques from [BCTV14]. Namely, both  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span>  also break an (optimal) pairing into a Miller loop and final exponentiation, and combine these components in a way that is tailored to the verifier protocol.</p>

    <p class="text-gray-300">However, our construction differs in how these two components are implemented, especially with regard to the Miller loop. This is because, in our setting, two main operations come &quot;for free&quot;: (a) field operations over the circuit's field, and (b) nondeterministic guessing (i.e., auxiliary advice). In particular, <em>field divisions cost the same as field multiplications</em> (since we can guess the answer and check it).</p>

    <p class="text-gray-300">Traditional software implementions go to great lengths to avoid expensive field divisions (e.g., by use of projective coordinates instead of affine ones, and in &quot;addition&quot; and &quot;doubling&quot; steps in the Miller loop). By contrast, both  <span class="math">C_{V,4}</span>  and  <span class="math">C_{V,6}</span>  perform the Miller loop by using <em>affine</em> coordinates for both curve arithmetic and divisor evaluations [LMN10], which can be done very efficiently by nondeterministic arithmetic circuits.</p>

    <p class="text-gray-300">Moreover, sharing Miller loop subcomputation traditionally only applies to products of pairings, of which there are only two in the verifier. Instead, in our setting, such techniques extend to <em>ratios of products</em> of pairings, and can thus be applied to <em>every</em> pairing check in the verifier, to further improve efficiency.</p>

    <p class="text-gray-300">Overall, in our software implementation, the number of field multiplications used to <em>compute</em> the checks of  <span class="math">V_4</span> ,  <span class="math">V_6</span>  is  <span class="math">3.8 \\times, 3.2 \\times</span>  more than the number of those used by  <span class="math">C_{V,4}</span> ,  <span class="math">C_{V,6}</span>  to <em>verify</em> them, respectively.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Arithmetic circuits for collision-resistant hashing</h3>

    <p class="text-gray-300">We also require arithmetic circuits for hashing: an  <span class="math">\\mathbb{F}_{r_4}</span> -arithmetic circuit  <span class="math">C_{H,4}</span>  for a collision-resistant function  <span class="math">H_4\\colon\\{0,1\\}^{m_{H,4}}\\to\\mathbb{F}^{d_{H,4}}_{r_4}</span>  such that  <span class="math">m_{H,4}\\geq \\left(\\ell_{\\mathsf{vk},6}(\\lceil\\frac{d_{H,4}\\cdot\\lceil\\log r_4\\rceil}{\\lfloor\\log r_6\\rfloor}\\rceil)+n_{\\mathsf{msg}}\\right)\\cdot\\lceil\\log r_4\\rceil;</span>  indeed,  <span class="math">C_{\\mathsf{pcd},\\alpha}</span>  uses  <span class="math">H_4</span>  to hash (the binary representation of) both the verification key  <span class="math">\\mathsf{vk}_6</span>  and a message z.</p>

    <p class="text-gray-300">We base collision-resistant hashing on subset-sum functions [Ajt96, GGH96], chosen to have an especially compact representation as arithmetic circuits over the zk-SNARK's &quot;native field&quot;.</p>

    <p class="text-gray-300"><strong>Subset sums.</strong> For  <span class="math">p,d,m\\in\\mathbb{N}</span>  with p prime and  <span class="math">M\\in\\mathbb{Z}_p^{d\\times m}</span> , the subset-sum function  <span class="math">H_M\\colon\\{0,1\\}^m\\to\\mathbb{Z}_p^d</span>  maps an m-bit string x to  <span class="math">\\sum_{i=1}^m x_i M(i)</span> , where M(i) is the i-th column of M.<sup>16</sup> Designing and constructing an  <span class="math">\\mathbb{F}_p</span> -arithmetic circuit that verifies  <span class="math">H_M</span>  is straightforward, and only requires d gates (the j-th gate computes the j-th linear combination). The entries of M should be drawn at random. (To remove suspicion of trapdoors, M can be chosen, e.g., according to the digits of  <span class="math">\\pi</span> .)</p>

    <p class="text-gray-300"><strong>Parameters.</strong> We set  <span class="math">H_4 := H_{M_4}</span>  for a random matrix  <span class="math">M_4 \\in \\mathbb{Z}_{r_4}^{d_{H,4} \\times m_{H,4}}</span>  and integers  <span class="math">d_{H,4}, m_{H,4} \\in \\mathbb{N}</span> . We have fixed the prime of the subset sum to be  <span class="math">r_4</span> ; this ensures that  <span class="math">C_{H,4}</span> , which is defined over  <span class="math">\\mathbb{F}_{r_4}</span> , works over the correct ring, and only requires  <span class="math">d_{H,4}</span>  gates. Next, for any given dimension  <span class="math">d_{H,4}</span>  and PCD message length  <span class="math">n_{\\text{msg}}</span> , we set the input length to  <span class="math">m_{H,4} := \\left(\\ell_{\\text{vk},6}(\\lceil \\frac{d_{H,4} \\cdot \\lceil \\log r_4 \\rceil}{\\lceil \\log r_6 \\rceil} \\rceil) + n_{\\text{msg}}\\right) \\cdot \\lceil \\log r_4 \\rceil</span> , to ensure the aforementioned condition on the input and output lengths. There remains to fix the output length  <span class="math">d_{H,4}</span> . This is delicate, because it affects security (and recall we aim at 80-bit security). Since  <span class="math">r_4</span>  is a 298-bit prime, it appears heuristically sufficient to fix  <span class="math">d_{H,4} = 1</span>  [JJ98]. In particular, this yields  <span class="math">|C_{H,4}| = 1</span> .</p>

    <p class="text-gray-300">Remark 5.4 (boolean input). Ideally, we would like a collision-resistant function whose &quot;natural&quot; domain is strings of  <span class="math">\\mathbb{F}_{r_4}</span> -elements, rather than strings of bits (as in subset-sum functions). Indeed, converting a string  <span class="math">x \\in \\mathbb{F}_p^m</span>  to its binary representation  <span class="math">s \\in \\{0,1\\}^{m \\cdot \\lceil \\log p \\rceil}</span>  (in order to &quot;prepare&quot; the function's input) costs  <span class="math">m \\cdot \\lceil \\log p \\rceil</span>  gates, which is a nontrivial contribution to the size of  <span class="math">C_{\\text{pcd},\\alpha}</span>  unless one keeps m quite small (see Section 4). While a subset-sum function  <span class="math">H_M : \\{0,1\\}^m \\to \\mathbb{Z}_p^d</span>  continues to remain collision-resistant even for domains consisting of &quot;small-norm&quot; vectors (of which binary strings are a special case),  <span class="math">H_M</span>  is not collision-resistant (or even one-way) when the domain is enlarged to include all elements in  <span class="math">\\mathbb{Z}_p^m</span>  (simply because, being a linear function, it can be efficiently inverted). It is an open question whether the cost of converting to binary strings can be avoided, via some other choice of hash function.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Scalable zk-SNARKs</h2>

    <p class="text-gray-300">Having constructed a PCD system (see Section 4 and Section 5), we use it to obtain a new zk-SNARK that is <em>scalable</em> (i.e., fully succinct and incrementally computable).</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Specifying a machine</h3>

    <p class="text-gray-300">A notable feature of our zk-SNARK is generality: it can prove/verify correctness of executions on any given random-access machine M, specified by a memory configuration and a corresponding CPU circuit. For instance, M may encode a floating-point-arithmetic processor for running quantitative analysis programs; or, M may encode a SIMD-based architecture for running multimedia programs.</p>

    <p class="text-gray-300"><strong>Parameters.</strong> More precisely, a machine M is specified by a tuple  <span class="math">(A, W, N, CPU_{exe}, CPU_{ver})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">A, W \\in \\mathbb{N}</span>  specify that (random-access) memory contains A addresses each storing W bits, i.e., that memory is a function  <span class="math">\\mathcal{M}: [A] \\to \\{0,1\\}^W</span> ;</li>
      <li><span class="math">N \\in \\mathbb{N}</span>  specifies the length, in bits, of a CPU state;</li>
      <li>CPU<sub>exe</sub> is a (stateful) function for <em>executing</em> the CPU;</li>
      <li>CPU<sub>ver</sub> is an F-arithmetic circuit for <em>verifying</em> the CPU's execution.</li>
    </ul>

    <p class="text-gray-300">We now elaborate on the above parameters. For more details, see Appendix A.2.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;16</sup>We do not require the hash function to be universal, so we do not need to add a random vector to the subset sum.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;17</sup>Recent works [LM06, PR06, LMPR08, ADLM<sup>+</sup>08, BLPRS13] use a small modulus and larger dimension, but our &quot;native&quot; modulus is already a large one.</p>

    <p class="text-gray-300"><strong>Execution on M.</strong> A computation on M proceeds in steps, as determined by  <span class="math">\\mathrm{CPU}_{\\mathsf{exe}}</span> , which can be thought of as M's &quot;processor&quot;: step after step,  <span class="math">\\mathrm{CPU}_{\\mathsf{exe}}</span>  takes the previous state and instruction (and its address), executes the instruction, communicates with random-access memory, and produces the next state and instruction address. More precisely, each step consists of two phases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Instruction fetch. Given the current CPU state  <span class="math">s_{cpu} \\in \\{0,1\\}^N</span>  and address  <span class="math">a_{pc} \\in [A]</span>  of the instruction to be executed, the new instruction to be executed is fetched:  <span class="math">v_{pc} := \\mathcal{M}(a_{pc}) \\in \\{0,1\\}^W</span> .</li>
      <li>Instruction execution. For an auxiliary input  <span class="math">g \\in \\{0,1\\}^W</span> ,  <span class="math">CPU_{\\text{exe}}</span>  receives  <span class="math">(s_{\\text{cpu}}, a_{\\text{pc}}, v_{\\text{pc}}, g)</span>  and outputs  <span class="math">(a_{\\text{mem}}, v_{\\text{st}}, f_{\\text{st}})</span> , where  <span class="math">a_{\\text{mem}} \\in [A]</span>  is an address,  <span class="math">v_{\\text{st}} \\in \\{0,1\\}^W</span>  a value, and  <span class="math">f_{\\text{st}} \\in \\{0,1\\}</span>  a store flag Afterwards,  <span class="math">CPU_{\\text{exe}}</span>  receives  <span class="math">v_{\\text{Id}} := \\mathcal{M}(a_{\\text{mem}}) \\in \\{0,1\\}^W</span>  (i.e., the value at the address) and outputs a new CPU state  <span class="math">s&#x27;_{\\text{cpu}} \\in \\{0,1\\}^N</span> , an address  <span class="math">a&#x27;_{\\text{pc}} \\in [A]</span>  for the next instruction, and a flag  <span class="math">f&#x27;_{\\text{acc}} \\in \\{0,1\\}</span>  denoting whether the machine has accepted. Meanwhile, if a store was requested, it is performed: if  <span class="math">f_{\\text{st}} = 1</span>  then  <span class="math">\\mathcal{M}(a_{\\text{mem}}) := v_{\\text{st}}</span> . Finally, at the end of every step,  <span class="math">CPU_{\\text{exe}}</span> 's state is reset.</li>
    </ul>

    <p class="text-gray-300">See Figure 3 for a diagram of these two phases.</p>

    <p class="text-gray-300"><strong>Verification of the CPU.</strong> The circuit  <span class="math">CPU_{\\text{ver}}</span>  verifies the correct input/output relationship of  <span class="math">CPU_{\\text{exe}}</span>  (but <em>not</em> memory consistency). In other words  <span class="math">CPU_{\\text{exe}}</span>  satisfies the following property:</p>

    <pre><code class="language-text">Fix s_{\\sf cpu}, s&#x27;_{\\sf cpu} \\in \\{0,1\\}^N, a_{\\sf pc}, a_{\\sf mem}, a&#x27;_{\\sf pc} \\in [A], v_{\\sf pc}, v_{\\sf st}, v_{\\sf ld}, g \\in \\{0,1\\}^W, f_{\\sf st}, f&#x27;_{\\sf acc} \\in \\{0,1\\}, and let x_{\\sf ver} be the concatenation of all these. There is a witness a_{\\sf ver} such that {\\sf CPU}_{\\sf ver}(x_{\\sf ver}, a_{\\sf ver}) = 0 iff (a_{\\sf mem}, v_{\\sf st}, f_{\\sf st}) \\leftarrow {\\sf CPU}_{\\sf exe}(s_{\\sf cpu}, a_{\\sf pc}, v_{\\sf pc}, g) and, afterwards, (s&#x27;_{\\sf cpu}, a&#x27;_{\\sf pc}, f&#x27;_{\\sf acc}) \\leftarrow {\\sf CPU}_{\\sf exe}(v_{\\sf ld}). Moreover, a_{\\sf ver} can be efficiently computed from x_{\\sf ver}.
</code></pre>

    <p class="text-gray-300">While we do not care about how the function  <span class="math">CPU_{\\text{exe}}</span>  is specified (e.g., it can be a computed program),  <span class="math">CPU_{\\text{ver}}</span>  must be an arithmetic circuit; if  <span class="math">CPU_{\\text{ver}}</span>  is defined over  <span class="math">\\mathbb{F}</span> , we say that  <span class="math">\\mathbf{M}</span>  has <em>verification over</em>  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">    <img src="_page_21_Figure_7.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: The two phases in one step of execution of a random-access machine M.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8"><strong>6.2</strong> Construction summary</h3>

    <p class="text-gray-300">The construction of the new zk-SNARK consists of the following transformation:</p>

    <p class="text-gray-300">The transformation's outline is as follows (see Section 2.3). First, given  <span class="math">\\mathbf{M}</span> , we design a compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  for the incremental verification of  <span class="math">\\mathbf{M}</span> 's execution, when its random-access memory  <span class="math">\\mathcal{M}</span>  is delegated via memory-checking techniques based on a collision-resistant hash H [BEGKN91, BCGT13a]. Then, we use the PCD system  <span class="math">(\\mathbb{G},\\mathbb{P},\\mathbb{V})</span>  to enforce the compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span> , and thereby construct the algorithms zk-SNARK  <span class="math">(G^\\star,P^\\star,V^\\star)</span>  of the new zk-SNARK, which is fully-succinct and incrementally-computable.</p>

    <p class="text-gray-300">For the first part, we again use field-specific subset-sum functions for constructing circuits that verify authentication paths (Section 6.3), and then combine these, together with M's CPU circuit, to construct  <span class="math">\\Pi_{\\mathbf{M},H}</span>  (Section 6.4). For the second part, the construction of the new zk-SNARK's three algorithms is fairly straightforward in light of previous work, and we include its details for completeness (Section 6.5).</p>

    <p class="text-gray-300">Later, in Section 7, we evaluate our scalable zk-SNARK when the machine M equals vnTinyRAM.</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Arithmetic circuits for secure loads and stores</h3>

    <p class="text-gray-300">We construct arithmetic circuits for checking loads/stores of an untrusted random-access memory, relative to a (trusted) root of a Merkle tree over the memory; this task is known as <em>memory checking</em> (see Remark 6.1).</p>

    <p class="text-gray-300">Let  <span class="math">A, W \\in \\mathbb{N}</span>  specify that memory contains A addresses each storing W bits, i.e., that memory is a function  <span class="math">\\mathcal{M} \\colon [A] \\to \\{0,1\\}^W</span> . Let  <span class="math">H \\colon \\{0,1\\}^m \\to \\{0,1\\}^\\ell</span>  be a collision-resistant function suitable for building binary Merkle trees over  <span class="math">\\mathcal{M}</span>  (i.e.,  <span class="math">m \\geq W</span>  and  <span class="math">m/\\ell \\geq 2</span> ); we say that H is (A, W)-good. For a field  <span class="math">\\mathbb{F}</span> , let  <span class="math">C_H</span>  be an  <span class="math">\\mathbb{F}</span> -arithmetic circuit that verifies H; we construct the following two  <span class="math">\\mathbb{F}</span> -arithmetic circuits.</p>

    <p class="text-gray-300">Secure load. A secure-load circuit  <span class="math">C_{\\mathsf{SecLd}}</span>  that, for a given address a, checks the validity of a loaded value v against a Merkle-tree root  <span class="math">\\rho</span> . More precisely, the circuit  <span class="math">C_{\\mathsf{SecLd}}</span>  satisfies the following property: for any root  <span class="math">\\rho \\in \\{0,1\\}^\\ell</span> , address  <span class="math">a \\in [A]</span> , value  <span class="math">v \\in \\{0,1\\}^W</span> , and authentication path  <span class="math">\\mathbf{p} \\in \\{0,1\\}^{W+(\\lceil \\log A \\rceil - 1)\\ell}</span> ,  <span class="math">C_{\\mathsf{SecLd}}(\\rho,a,v,\\mathbf{p})=0</span>  if and only if  <span class="math">\\mathbf{p}</span>  is a valid authentication path for the value v as the a-th leaf in a Merkle tree of root  <span class="math">\\rho</span> . One can verify that the size of such a circuit is  <span class="math">\\lceil \\log A \\rceil \\cdot (|C_H| + 2\\ell)</span> , because the check can be performed via  <span class="math">\\lceil \\log A \\rceil</span>  invocations of H plus  <span class="math">2\\ell</span>  gates per level.  <span class="math">^{18}</span></p>

    <p class="text-gray-300">Secure load-then-store. A secure-load-then-store circuit  <span class="math">C_{\\mathsf{SecLdSt}}</span>  that, for a given address a, checks: (i) the validity of a loaded value  <span class="math">v_{\\mathsf{Id}}</span>  against a Merkle-tree root  <span class="math">\\rho</span> ; and (ii) the validity of storing  <span class="math">v_{\\mathsf{st}}</span> , to the same address, against a (possibly different) Merkle-tree root  <span class="math">\\rho&#x27;</span> . More precisely, the circuit  <span class="math">C_{\\mathsf{SecLdSt}}</span>  satisfies the following property: for any two roots  <span class="math">\\rho, \\rho&#x27; \\in \\{0, 1\\}^{\\ell}</span> , address  <span class="math">a \\in [A]</span> , two values  <span class="math">v_{\\mathsf{Id}}, v_{\\mathsf{st}} \\in \\{0, 1\\}^{W}</span> , and authentication path  <span class="math">\\mathbf{p} \\in \\{0, 1\\}^{W+(\\lceil \\log A \\rceil - 1)\\ell}</span> ,  <span class="math">C_{\\mathsf{SecLdSt}}(\\rho, \\rho&#x27;, a, v_{\\mathsf{Id}}, v_{\\mathsf{st}}, \\mathbf{p}) = 0</span>  if and only if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>p is a valid authentication path for the value  <span class="math">v_{ld}</span>  as the a-th leaf in a Merkle tree of root  <span class="math">\\rho</span> , AND</li>
      <li><span class="math">\\mathbf{p}</span>  is a valid authentication path for the value  <span class="math">v_{\\text{st}}</span>  as the a-th leaf in a Merkle tree of root  <span class="math">\\rho&#x27;</span> . One can verify that the size of such a circuit is  <span class="math">\\lceil \\log A \\rceil \\cdot (2|C_H| + 4\\ell)</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Instantiation with subset-sum functions.</strong> We are left to choose the function H and construct  <span class="math">C_H</span> , required to obtain the two circuits  <span class="math">C_{SecLd}</span>  and  <span class="math">C_{SecLdSt}</span> .</p>

    <p class="text-gray-300">As in Section 5.2, subset-sum functions are a natural candidate, for efficiency considerations. Namely, since  <span class="math">\\mathbb{F}</span>  has prime order p, its additive group is isomorphic to  <span class="math">\\mathbb{Z}_p</span> ; hence, for  <span class="math">M \\in \\mathbb{Z}_p^{d \\times m}</span> , the subset-sum function  <span class="math">H_M \\colon \\{0,1\\}^m \\to \\mathbb{Z}_p^d</span>  can be computed with only d gates over  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Unlike Section 5.2, however, both  <span class="math">C_{\\mathsf{SecLd}}</span>  and  <span class="math">C_{\\mathsf{SecLdSt}}</span>  require H's outputs to be inputs to other invocations of H. Thus, here we treat a subset-sum function as having binary output:  <span class="math">H_M \\colon \\{0,1\\}^m \\to \\{0,1\\}^\\ell</span>  where  <span class="math">\\ell := d \\cdot \\lceil \\log p \\rceil</span> . Doing so requires additional gates, summing up to a total of  <span class="math">d + \\ell = d \\cdot (1 + \\lceil \\log p \\rceil)</span>  gates over  <span class="math">\\mathbb F</span>  to compute  <span class="math">H_M</span> . Moreover, the condition on input length is different: here we need to ensure that the function is (A, W)-good, which requires that  <span class="math">m \\ge \\max\\{W, 2\\ell\\} = \\max\\{W, 2d\\lceil \\log p \\rceil\\}</span> .</p>

    <p class="text-gray-300">Overall, if we set  <span class="math">H := H_M</span>  (for a random M), we can achieve circuit sizes that are:</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;18</sup>Specifically, in the <em>i</em>-th level,  <span class="math">\\ell</span>  gates ensure booleanity of the <em>i</em>-th chunk of the authentication path <strong>p</strong>, while another  <span class="math">\\ell</span>  gates prepare the correct input to the next invocation of H, depending on the <em>i</em>-th address bit.</p>

    <p class="text-gray-300"><span class="math">$|C_{\\mathsf{SecLd}}| = \\lceil \\log A \\rceil \\cdot d \\cdot (1 + 3\\lceil \\log p \\rceil)</span>$
and  <span class="math">|C_{\\mathsf{SecLdSt}}| = \\lceil \\log A \\rceil \\cdot d \\cdot (2 + 6\\lceil \\log p \\rceil)</span> .</p>

    <p class="text-gray-300">In terms of concrete numbers, recalling from Section 5.2 that d=1 and  <span class="math">\\lceil \\log p \\rceil = 298</span> , we get that</p>

    <p class="text-gray-300"><span class="math">$|C_{\\mathsf{SecLd}}| = \\lceil \\log A \\rceil \\cdot 895 \\text{ and } |C_{\\mathsf{SecLdSt}}| = \\lceil \\log A \\rceil \\cdot 1{,}790.</span>$</p>

    <p class="text-gray-300"><strong>Remark 6.1</strong> (memory checking). <em>Memory checking</em> was introduced by Blum et al. [BEGKN91]; they showed how to use Merkle hashing to delegate a machine's memory to an untrusted storage, and dynamically verify its consistency using only a small  <span class="math">poly(\\lambda)</span> -size &quot;trusted&quot; memory.</p>

    <p class="text-gray-300">Blum et al. instantiated Merkle hashing with <em>universal one-way hash functions</em> [NY89, Rom90]. Yet, in general, a machine's computation includes a &quot;nondeterministic component&quot;, e.g., an auxiliary input. In such a case (as in this paper), Merkle hashing must be based on hash functions that are <em>collision resistant</em>.</p>

    <p class="text-gray-300">Memory checking techniques have found numerous practical applications for securing untrusted storages [MVS00, MS01, GSCvDD03, GSMB03, KRSWF03]. Ben-Sasson et al. [BCGT13a] suggested that verification of memory via Merkle hashing can be a useful computational alternative to the information-theoretic use of nondeterministic routing for efficient circuit generators. For instance, the recent circuit generator of Braun et al. [BFRS+13] uses memory checking to verify accesses to an untrusted storage.</p>

    <p class="text-gray-300">Given a random-access machine M and a (suitable) collision-resistant function H, we construct a compliance predicate  <span class="math">\\Pi_{M,H}</span>  that checks a step of execution of M. The transformation is:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c</span>$</p>

    <p class="text-gray-300">Briefly, a message z for  <span class="math">\\Pi_{\\mathbf{M},H}</span>  encodes a short representation of  <span class="math">\\mathbf{M}</span> 's state at a given time step. Then, at a node with input message  <span class="math">z_{\\text{in}}</span>  and output message  <span class="math">z_{\\text{out}}</span> , the compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  checks that the transition from the state in  <span class="math">z_{\\text{in}}</span>  to the state in  <span class="math">z_{\\text{out}}</span>  is a valid transition of the machine  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">Below, we make this plan more concrete by describing the format of messages and local data for  <span class="math">\\Pi_{M,H}</span> , and by describing the checks performed by  <span class="math">\\Pi_{M,H}</span> . See Figure 5 for details (and Appendix A.2 as reference).</p>

    <p class="text-gray-300">Format of messages. A message z summarizes M's entire state at a given time t, by storing the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a timestamp t, denoting how many computation steps have occurred;</li>
      <li>a root  <span class="math">\\rho</span>  of a Merkle tree of random-access memory (after t computation steps);</li>
      <li>a CPU state  <span class="math">s_{cpu}</span>  (after t computation steps); and</li>
      <li><span class="math">\\bullet</span>  a flag  <span class="math">f_{\\sf acc}</span>  denoting whether the machine has accepted (after t computation steps).</li>
    </ul>

    <p class="text-gray-300">Furthermore, z also stores  <span class="math">\\rho_0</span> , the root of a Merkle tree over initial memory, so to &quot;remember&quot; M's input. Note that a message z is short because the large memory is &quot;summarized&quot; by the short root of a Merkle tree.</p>

    <p class="text-gray-300"><strong>Format of local data.</strong> Now consider a node with input message  <span class="math">z_{in}</span>  and output message  <span class="math">z_{out}</span> . The goal of  <span class="math">\\Pi_{\\mathbf{M},H}</span>  is to verify  <span class="math">\\mathbf{M}</span> 's transition from  <span class="math">z_{in}</span>  to  <span class="math">z_{out}</span> , using two main tools:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>CPU<sub>ver</sub> for checking CPU transitions, <em>given</em> consistent memory accesses (&quot;what you store is what you get&quot;);</li>
      <li><span class="math">\\bullet</span>   <span class="math">C_{\\mathsf{SecLd}}</span>  and  <span class="math">C_{\\mathsf{SecLdSt}}</span>  for checking memory accesses.</li>
    </ul>

    <p class="text-gray-300">Thus, in the local data  <span class="math">z_{\\text{loc}}</span>  provided at a node, we store whatever auxiliary information is needed by  <span class="math">\\Pi_{\\mathbf{M},H}</span>  to evaluate  <span class="math">\\mathrm{CPU}_{\\text{ver}}</span>  (e.g., requested memory addresses, memory values, flags, etc.) and  <span class="math">C_{\\text{SecLd}}</span>  and  <span class="math">C_{\\text{SecLdSt}}</span>  (e.g., addresses, values, and authentication paths). Furthermore,  <span class="math">z_{\\text{loc}}</span>  includes a flag  <span class="math">f_{\\text{halt}}</span>  specifying whether the computation should halt or not (as, in such a case,  <span class="math">\\Pi_{\\mathbf{M},H}</span>  will perform a different set of checks).</p>

    <p class="text-gray-300">Construction. The compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  takes an input  <span class="math">(z_{\\mathsf{out}}, z_{\\mathsf{loc}}, z_{\\mathsf{in}}, b_{\\mathsf{base}})</span> , where  <span class="math">z_{\\mathsf{out}}</span>  is the outgoing message,  <span class="math">z_{\\mathsf{loc}}</span>  the local data,  <span class="math">z_{\\mathsf{in}}</span>  the incoming message, and  <span class="math">b_{\\mathsf{base}}</span>  the base-case flag, and must verify  <span class="math">\\mathbf{M}</span> 's transition from  <span class="math">z_{\\mathsf{in}}</span>  to  <span class="math">z_{\\mathsf{out}}</span> . (Thus,  <span class="math">\\Pi_{\\mathbf{M},H}</span>  has arity s=1.) Our construction of  <span class="math">\\Pi_{\\mathbf{M},H}</span>  goes as follows.</p>

    <p class="text-gray-300">In the base case (i.e.,  <span class="math">b_{\\mathsf{base}} = 1</span> ),  <span class="math">\\Pi_{\\mathbf{M},H}</span>  ensures that  <span class="math">z_{\\mathsf{in}}</span>  is correctly initialized: its timestamp, CPU state, instruction address, accept flag should all be set to zero;  <span class="math">\\Pi_{\\mathbf{M},H}</span>  also checks that the root of the Merkle tree of memory is equal to that of the Merkle tree of initial memory.</p>

    <p class="text-gray-300">Moreover, regardless of base case or not,  <span class="math">\\Pi_{M,H}</span>  always checks that the root of the Merkle tree of initial memory is preserved from  <span class="math">z_{\\text{in}}</span>  to  <span class="math">z_{\\text{out}}</span> , in order to not &quot;forget&quot; what the initial state of the machine was.</p>

    <p class="text-gray-300">When the computation does not halt (i.e.,  <span class="math">f_{\\mathsf{halt}} = 0</span> ),  <span class="math">\\Pi_{\\mathbf{M},H}</span>  checks that the timestamp is incremented by 1 and that  <span class="math">\\mathrm{CPU}_{\\mathsf{ver}}</span>  (on the appropriate inputs) accepts; furthermore, it uses  <span class="math">C_{\\mathsf{SecLd}}</span>  to check that the instruction was correctly loaded and  <span class="math">C_{\\mathsf{SecLdSt}}</span>  to check that the memory access (a load or a store) was correctly performed.</p>

    <p class="text-gray-300">When the computation does halt (i.e.,  <span class="math">f_{halt} = 1</span> ),  <span class="math">\\Pi_{M,H}</span>  first of all ensures that the computation has in fact accepted so far; then it clears out the root of the Merkle tree over memory and the CPU state (as these may leak information about the private auxiliary input) and ensures that the time step in  <span class="math">z_{out}</span>  is at least as large as the number of steps so far. (Again for privacy reasons,  <span class="math">\\Pi_{M,H}</span>  does not force  <span class="math">z_{out}</span>  to carry the exact number of computation steps, but only a number that is at least that much.)</p>

    <p class="text-gray-300">Overall, the above checks suffice for  <span class="math">\\Pi_{\\mathbf{M},H}</span>  to ensure that any  <span class="math">\\Pi_{\\mathbf{M},H}</span> -compliant distributed computation corresponds to correctly initializing, stepping through, and halting an accepting computation of  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> By implementing  <span class="math">\\Pi_{\\mathbf{M},H}</span>  as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit, we obtain the following efficiency:</p>

    <p class="text-gray-300"><span class="math">$|\\Pi_{\\mathbf{M},H}| = |\\mathrm{CPU}_{\\mathsf{ver}}| + |C_{\\mathsf{SecLd}}| + |C_{\\mathsf{SecLdSt}}| + \\varepsilon</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">\\varepsilon</span>  is a &quot;small but ugly&quot; term, depending on  <span class="math">d, N, \\mathbb{F}</span> , that can be upper bounded as follows</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\leq 2 \\cdot \\left(301 + 4N + 2\\ell + \\left\\lceil \\frac{301 + 4N + 2\\ell}{\\lfloor \\log |\\mathbb{F}| \\rfloor} \\right\\rceil \\right) + 24 \\left\\lceil \\frac{N}{\\lfloor \\log |\\mathbb{F}| \\rfloor} \\right\\rceil + 2N + 12 \\left\\lceil \\frac{\\ell}{\\lfloor \\log |\\mathbb{F}| \\rfloor} \\right\\rceil + \\ell + 10 \\enspace .</span>$</p>

    <p class="text-gray-300">Crucially,  <span class="math">|\\Pi_{\\mathbf{M},H}|</span>  only depends (nicely) on  <span class="math">\\mathbf{M}</span>  and H, but is independent of the computation length on  <span class="math">\\mathbf{M}</span> : the term  <span class="math">|\\mathrm{CPU}_{\\mathsf{ver}}|</span>  is the cost of verifying  <span class="math">\\mathbf{M}</span> 's CPU (and depends on &quot;how complex&quot; is the CPU); while the term  <span class="math">|C_{\\mathsf{SecLd}}| + |C_{\\mathsf{SecLdSt}}| = \\lceil \\log A \\rceil \\cdot d \\cdot (3 + 9 \\lceil \\log p \\rceil)</span>  is the per-cycle cost to ensure memory consistency via collision-resistant hashing (see Section 6.3).</p>

    <p class="text-gray-300">In Section 7, we consider the case when M equals vnTinyRAM (a simple RISC von Neumann machine), with wordsizes  <span class="math">w \\in \\{16,32\\}</span>  and k=16 registers. In Figure 4 we report, for these cases, the size of  <span class="math">\\Pi_{\\mathbf{M},H}</span> , its sub-circuits, and the resulting PCD circuits  <span class="math">C_{\\mathsf{pcd},4}</span>  and  <span class="math">C_{\\mathsf{pcd},6}</span>  (which affect the PCD system's efficiency).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16-bit vnTinyRAM</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">32-bit vnTinyRAM</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w,k) = (16,16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w,k) = (32,16)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CPU <sub>ver</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">766</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,108</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ C_{SecLd} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12,530</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25,955</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ C_{SecLdSt} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25,060</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51,910</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&epsilon;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3501</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4867</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Pi_{\\mathbf{M},H} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41,857</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83,840</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">146 174</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100.240</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ C_{pcd,4} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">146,174</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">189,349</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ C_{pcd,6} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32,027</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32,027</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 4: Sizes of the compliance predicate  <span class="math">\\Pi_{M,H}</span>  (and its sub-circuits) and the corresponding PCD circuits, for 16-bit and 32-bit vnTinyRAM.</p>

    <p class="text-gray-300"><strong>Remark 6.2.</strong> The per-cycle cost of ensuring memory consistency via collision-resistant hashing (i.e.,  <span class="math">|C_{\\mathsf{SecLd}}| + |C_{\\mathsf{SecLdSt}}|</span> ) is typically much larger than that incurred when using nondeterministic routing (in [BCTV14], it is less than 1000). However, collision-resistant hashing ultimately enables scalability, whereas nondeterministic routing is not known to be useful for scalability (also see Section 8).</p>

    <p class="text-gray-300">In particular, while in Section 7 we focus on the case  <span class="math">\\mathbf{M} = \\text{vnTinyRAM}</span> , for which  <span class="math">|\\mathrm{CPU}_{\\text{ver}}| \\approx 10^3</span> , we could have chosen more complex machines. Indeed, even if  <span class="math">\\mathrm{CPU}_{\\text{ver}}</span>  had a few tens of thousands of gates, the size of  <span class="math">\\Pi_{\\mathbf{M},H}</span>  would remain on the order of  <span class="math">10^5</span>  gates. In other words, our scalable zk-SNARK can accommodate much more complex machines at a relatively small additional cost.</p>

    <p class="text-gray-300">Format of messages for  <span class="math">\\Pi_{M,H}</span> . A message z for the compliance predicate  <span class="math">\\Pi_{M,H}</span>  is a tuple</p>

    <pre><code class="language-text">z = (\\rho_0, t, \\rho, s_{\\text{cpu}}, f_{\\text{acc}})
where:
&bull; \\rho_0 \\in \\{0,1\\}^{\\ell} is an output of H; allegedly, it is the root of a Merkle tree whose leaves are a program \\mathcal{P} (i.e., initial memory).
&bull; t \\in \\{0,1\\}^{300} is a timestamp; allegedly, it is the number of computation steps so far.
   (For concreteness, we bound all computations to 2^{300} steps, which is big enough to accommodate computations in the foreseeable future.)
&bull; \\rho \\in \\{0,1\\}^{\\ell} is an output of H; allegedly, it is the root of a Merkle tree whose leaves are \\mathcal{M}_t (memory after t steps).
&bull; s_{cpu} \\in \\{0,1\\}^N is a CPU state; allegedly, it is the machine&#x27;s CPU state after t steps of computation.
&bull; f_{acc} \\in \\{0,1\\} is a flag which denotes whether the machine has accepted so far or not.
The length n_{\\text{msg}} of a message is equal to 2\\ell + 300 + N + 1.
Format of local data for \\Pi_{M,H}. Local data z_{loc} for the compliance predicate \\Pi_{M,H} is a tuple
                                            z_{\\rm loc} = (a_{\\rm pc}, a_{\\rm mem}, a_{\\rm pc}&#x27;, v_{\\rm pc}, v_{\\rm st}, v_{\\rm ld}, g, f_{\\rm st}, f_{\\rm halt}, a_{\\rm ver}, \\mathbf{p}_{\\rm pc}, \\mathbf{p}_{\\rm mem})
where:
&bull; a_{pc}, a_{mem}, a&#x27;_{pc} \\in [A] are memory addresses.
&bull; v_{\\text{pc}}, v_{\\text{st}}, v_{\\text{Id}} \\in \\{0, 1\\}^W are memory values.
&bull; g \\in \\{0,1\\}^W is a non-deterministic guess.
&bull; f_{st}, f_{halt} \\in \\{0, 1\\} are flags.
&bull; a_{\\text{ver}} is a witness for the \\mathbb{F}-arithmetic circuit CPU_{\\text{ver}}.
&bull; \\mathbf{p}_{pc}, \\mathbf{p}_{mem} \\in \\{0,1\\}^{W+(\\lceil \\log A \\rceil - 1)\\ell} are authentication paths for Merkle trees over memory.
The length n_{loc} of local data is equal to (3+2\\ell) \\cdot \\lceil \\log A \\rceil + 6W + 2 - 2\\ell + |a_{ver}|.
Compliance predicate \\Pi_{M,H}.
&bull; INPUTS:
   - output PCD message z_{\\text{out}} = (\\rho&#x27;_0, t&#x27;, \\rho&#x27;, s&#x27;_{\\text{cpu}}, f&#x27;_{\\text{acc}}) \\in \\{0, 1\\}^{n_{\\text{msg}}}
   - local data z_{\\text{loc}} = (a_{\\text{pc}}, a_{\\text{mem}}, a&#x27;_{\\text{pc}}, v_{\\text{pc}}, v_{\\text{st}}, v_{\\text{ld}}, g, f_{\\text{st}}, f_{\\text{halt}}, a_{\\text{ver}}, \\mathbf{p}_{\\text{pc}}, \\mathbf{p}_{\\text{mem}}) \\in \\{0, 1\\}^{n_{\\text{loc}}}
   - input PCD message z_{in} = (\\rho_0, t, \\rho, s_{cpu}, f_{acc}) \\in \\{0, 1\\}^{n_{msg}}
   - base case flag b_{\\mathsf{base}} \\in \\{0, 1\\}
&bull; OUTPUTS: 0 iff all checks passed
1. If b_{\\text{base}} = 1 (i.e., base case):
      (a) Check that t=0, s_{\\text{cpu}}=0^N, a_{\\text{pc}}=0, f_{\\text{acc}}=0.
     (b) Check that the root of the Merkle tree of current memory is correctly initialized: \\rho&#x27; = \\rho_0.
2. Check that the root of the Merkle tree of initial memory is copied over: \\rho&#x27;_0 = \\rho_0.
3. If f_{halt} = 0 (i.e., do not halt):
      (a) Check that the timestamp is incremented: t&#x27; = t + 1.
      (b) Set x_{\\mathsf{ver}} := (s_{\\mathsf{cpu}}, s&#x27;_{\\mathsf{cpu}}, a_{\\mathsf{pc}}, a_{\\mathsf{mem}}, a&#x27;_{\\mathsf{pc}}, v_{\\mathsf{pc}}, v_{\\mathsf{st}}, v_{\\mathsf{ld}}, g, f_{\\mathsf{st}}, f&#x27;_{\\mathsf{acc}}) and check that \\mathrm{CPU}_{\\mathsf{ver}}(x_{\\mathsf{ver}}, a_{\\mathsf{ver}}) = 0 .
      (c) Check that the instruction is correctly loaded: C_{\\rm SecLd}(\\rho,a_{\\rm pc},v_{\\rm pc},{\\bf p}_{\\rm pc})=0 .
      (d) If f_{st} = 0 (i.e., no store), then check that v_{ld} = v_{st}.
      (e) Check that the load-then-store is correct: C_{\\text{SecLdSt}}(\\rho, \\rho&#x27;, a_{\\text{mem}}, v_{\\text{ld}}, v_{\\text{st}}, \\mathbf{p}_{\\text{mem}}) = 0.
4. If f_{halt} = 1 (i.e., do halt):
      (a) Check that the machine has accepted: f_{\\rm acc}=1 .
      (b) Check that the root and the CPU state have been cleared: \\rho&#x27; = 0^{\\ell}, s&#x27;_{\\text{cpu}} = 0^{N}.
      (c) Check that the timestamp is not less than the computation time: t&#x27; \\geq t.
      (d) Check that the accept flag is copied over: f&#x27;_{acc} = f_{acc}.
</code></pre>

    <p class="text-gray-300">Figure 5: Construction of the compliance predicate  <span class="math">\\Pi_{M,H}</span>  from M and H.</p>

      <h3 id="sec-6.5" class="text-xl font-semibold mt-8">6.5 The new zk-SNARK construction</h3>

    <p class="text-gray-300">We now explain how to use a PCD system  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span> , invoked on  <span class="math">\\Pi_{\\mathbf{M}, H}</span> , to construct a scalable zk-SNARK for random-access machines; see Figure 6 for the construction's pseudocode.</p>

    <p class="text-gray-300">Construction of  <span class="math">G^*</span> . The key generator  <span class="math">G^*</span>  takes a random-access machine  <span class="math">\\mathbf{M}</span>  as input, and must output a key pair that enables anyone to prove/verify correctness of computations on  <span class="math">\\mathbf{M}</span> . Recall that the PCD generator  <span class="math">\\mathbb{G}</span>  expects as input an  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate. Thus,  <span class="math">G^*</span>  constructs the  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span> , for a suitable choice of collision-resistant function H; it invokes  <span class="math">\\mathbb{G}</span>  on  <span class="math">\\Pi_{\\mathbf{M},H}</span>  to generate a key pair  <span class="math">(\\mathsf{pk}_{\\mathsf{pcd}}, \\mathsf{vk}_{\\mathsf{pcd}})</span> ; and, finally, it outputs  <span class="math">(\\mathsf{pk}, \\mathsf{vk})</span>  where  <span class="math">\\mathsf{pk} := (\\mathbf{M}, H, \\mathsf{pk}_{\\mathsf{pcd}})</span>  and  <span class="math">\\mathsf{vk} := (\\mathbf{M}, H, \\mathsf{vk}_{\\mathsf{pcd}})</span> .</p>

    <p class="text-gray-300">More precisely, the key pair (pk, vk) allows to prove/verify membership of instances in the language  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span>  of accepting computations on  <span class="math">\\mathbf{M}</span> , i.e., the language consisting of pairs  <span class="math">(\\mathcal{P},T)</span>  such that: (i)  <span class="math">\\mathcal{P}</span>  is a program for  <span class="math">\\mathbf{M}</span>  (a program is just an initial memory state); (ii) T is a time bound; (iii) there exists an auxiliary input  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span>  accepts in at most T steps. (See Definition A.2 for a more formal discussion of  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span> .)</p>

    <p class="text-gray-300">Construction of  <span class="math">P^*</span> . The prover  <span class="math">P^*</span>  takes as input a proving key pk, program  <span class="math">\\mathcal{P}</span> , time bound T, and auxiliary input  <span class="math">\\mathcal{G}</span> , and must output a proof  <span class="math">\\pi</span>  for the claim &quot; <span class="math">(\\mathcal{P},T)\\in\\mathcal{L}_{\\mathbf{M}}</span> &quot;. Recall that the PCD prover  <span class="math">\\mathbb{P}</span>  expects as input a proving key  <span class="math">\\operatorname{pk}_{\\operatorname{pcd}}</span> , output message z, local data  <span class="math">z_{\\operatorname{loc}}</span> , input message  <span class="math">z_{\\operatorname{in}}</span> , and (in the non-base case) also a corresponding proof  <span class="math">\\pi_{\\operatorname{in}}</span> . Thus,  <span class="math">P^*</span>  steps through the computation of  <span class="math">\\mathbf{M}</span>  on  <span class="math">\\mathcal{P}</span> , at each step generating a new message and proof, by using a previous message and proof; throughout,  <span class="math">P^*</span>  maintains a Merkle tree over random-access memory. Concretely, at each step,  <span class="math">P^*</span>  executes the CPU of  <span class="math">\\mathbf{M}</span> , handles any memory loads or stores, and prepares the necessary  <span class="math">\\Pi_{\\mathbf{M},H}</span> -compliant inputs for  <span class="math">\\mathbb{P}</span>  in order to compute the next proof; and then it continues to the next step. After T steps of computation,  <span class="math">P^*</span>  produces a final proof, relative to a specially-constructed message  <span class="math">z_{\\operatorname{fin}}</span> , which clears from a message all but essential information (so not to compromise zero knowledge), and outputs the final proof.</p>

    <p class="text-gray-300">Construction of  <span class="math">V^*</span> . The verifier  <span class="math">V^*</span>  takes as input a verification key vk, program  <span class="math">\\mathcal{P}</span> , time bound T, and proof  <span class="math">\\pi</span> , and must output a bit indicating whether  <span class="math">\\pi</span>  is a convincing proof for the claim &quot; <span class="math">(\\mathcal{P},T)\\in\\mathcal{L}_{\\mathbf{M}}</span> &quot;. Recall that the PCD verifier  <span class="math">\\mathbb{V}</span>  expects as input a verification key vk<sub>pcd</sub>, message z, and proof  <span class="math">\\pi</span> . Thus,  <span class="math">V^*</span>  constructs a message z, corresponding to a &quot;halted and accepted&quot; computation of  <span class="math">\\mathbf{M}</span>  on  <span class="math">\\mathcal{P}</span>  (cf. the construction of  <span class="math">\\Pi_{\\mathbf{M},H}</span> ), and then accepts if and only if  <span class="math">\\mathbb{V}(\\mathsf{pk}_{\\mathsf{pcd}},z,\\pi)</span>  does.</p>

    <p class="text-gray-300">Preparing the message z requires computing the root  <span class="math">\\rho_0</span>  of a Merkle tree over the program  <span class="math">\\mathcal{P}</span> . In fact, computing  <span class="math">\\rho_0</span>  can be done even before receiving the proof  <span class="math">\\pi</span> , as it only requires knowledge of H and  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300"><strong>Security.</strong> Suppose that  <span class="math">V^*</span>  accepts a proof  <span class="math">\\pi</span>  for an instance  <span class="math">(\\mathcal{P},T)</span> . Then the PCD verifier  <span class="math">\\mathbb{V}</span>  accepted  <span class="math">\\pi</span>  for a message z, constructed from  <span class="math">\\mathcal{P}</span>  and T, that corresponds to a &quot;halted and accepted&quot; computation. By construction of the compliance predicate  <span class="math">\\Pi_{\\mathbf{M},H}</span>  and the security of  <span class="math">\\mathbb{V}</span> , we deduce that  <span class="math">(\\mathcal{P},T)\\in\\mathcal{L}_{\\mathbf{M}}</span> . (And proof of knowledge is inherited from the proof of knowledge of the PCD system.)</p>

    <p class="text-gray-300"><strong>Scalability.</strong> From the above description (and the pseudocode in Figure 6), one can verify that  <span class="math">(G^*, P^*, V^*)</span>  is both fully succinct and incrementally computable.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;19</sup>Of course, to perform this step in time  <span class="math">O(|\\mathcal{P}|)</span> , one should not explicitly build a Merkle tree over all of memory, but instead build the Merkle tree by considering only the <em>non-zero</em> memory entries specified by  <span class="math">\\mathcal{P}</span> .</p>

    <pre><code class="language-text">New zk-SNARK generator G
                                ?
 &bull; INPUTS: a random-access machine M = (A, W, N, CPUexe, CPUver) with verification over F
 &bull; OUTPUTS: proving key pk and verification key vk
 1. Select any (A, W)-good collision-resistant hash function H.
 2. Construct CH, an F-arithmetic circuit implementing H.
 3. Use M and CH to construct the compliance predicate &Pi;M,H.
 4. Compute (pkpcd, vkpcd) := G(&Pi;M,H).
 5. Set pk := (M, H, pkpcd) and vk := (M, H, vkpcd).
 6. Output (pk, vk).
 New zk-SNARK prover P
                             ?
 &bull; INPUTS: proving key pk, program P, time bound T, and auxiliary input G = (g0, g1, . . . , gT &minus;1)
 &bull; OUTPUTS: proof &pi; for the instance (P, T)
 1. Use H to compute &rho;0, the root of the Merkle tree over P.
 2. Initialize memory to the given program: M0 := P.
 3. Initialize the CPU state and instruction address to zero: scpu,0 := 0N and apc,0 := 0.
 4. Initialize the first message: zmsg,0 := (&rho;0, 0, &rho;0, scpu,0, 0).
 5. Initialize the first proof to empty: &pi;0 := &perp;.
 6. For i = 0, . . . , T &minus; 1, compute the next message zmsg,i+1 and proof &pi;i+1 as follows:
     (a) Give CPUexe
         &bull; the current CPU state (scpu,i &isin; {0, 1}
                                                  N ),
         &bull; address of the instruction to be executed (apc,i &isin; [A]),
         &bull; instruction to be executed (vpc,i := Mi(apc,i) &isin; {0, 1}
                                                                    W ), and
         &bull; guess (gi &isin; {0, 1}
                               W ).
     (b) Get from CPUexe
         &bull; an address (amem,i &isin; [A]),
         &bull; value (vst,i &isin; {0, 1}
                                 W ), and
         &bull; store flag (fst,i &isin; {0, 1}).
     (c) Give CPUexe the value at the address (vld,i := Mi(amem,i) &isin; {0, 1}
                                                                               W ).
     (d) Set Mi+1 to equal Mi; if a store was requested (i.e., fst,i = 1), do it (i.e., Mi+1(amem,i) := vst,i).
     (e) Compute &rho;i+1 (the root of the Merkle tree over Mi+1) from &rho;i.
     (f) Get from CPUexe
         &bull; a new CPU state (scpu,i+1 &isin; {0, 1}
                                                N ),
         &bull; an address for the next instruction (apc,i+1 &isin; [A]), and
         &bull; a flag denoting whether the machine has accepted (facc,i+1 &isin; {0, 1}).
         Reset CPUexe&#x27;s state.
     (g) Create the next message: zmsg,i+1 := (&rho;0, i + 1, &rho;i+1, scpu,i+1, facc,i+1).
     (h) Deduce aver from xver := (scpu,i, scpu,i+1, apc,i, amem,i, apc,i+1, vpc,i, vst,i, vld,i, gi, fst,i, facc,i+1).
     (i) Let ppc,i (resp., pmem,i) be the authentication path for address apc,i (resp., amem,i) in Mi.
     (j) Create local data: zloc,i+1 := (apc,i, amem,i, apc,i+1, vpc,i, vst,i, vld,i, gi, facc,i+1, 0, aver, ppc,i, pmem,i).
     (k) Compute the next proof: &pi;i+1 := P(pkpcd, zmsg,i+1, zloc,i+1, zi, &pi;i).
 7. Prepare the final message: zmsg,fin := (&rho;0, T, 0
                                                   \`
                                                    , 0
                                                       N , 1).
 8. Prepare the final local data: zloc,fin := (&lowast;, &lowast;, &lowast;, &lowast;, &lowast;, &lowast;, &lowast;, &lowast;, 1, &lowast;, &lowast;, &lowast;), where &lowast; can be set to anything of the right length.
 9. Compute the final proof: &pi; := P(pkpcd, zmsg,fin, zloc,fin, zT , &pi;T ).
10. Output &pi;.
 New zk-SNARK verifier V
                             ?
 &bull; INPUTS: verification key vk, program P, time bound T, and proof &pi;
 &bull; OUTPUTS: decision bit
 1. Use H to compute &rho;0, the root of the Merkle tree over P. (This can also be done beforehand.)
 2. Construct the message z := (&rho;0, T, 0
                                          \`
                                           , 0
                                             N , 1).
 3. Accept if and only if V(vkpcd, z, &pi;) = 1.
</code></pre>

    <p class="text-gray-300">Figure 6: Construction of a scalable zk-SNARK for random-access machines.</p>

    <p class="text-gray-300">We evaluate our scalable zk-SNARK when the given random-access machine M equals vnTinyRAM, a simple RISC von Neumann architecture [BCTV14, BCGTV13b]. For comparison, we also compare [BCTV14]'s preprocessing zk-SNARK (which also supports vnTinyRAM) with our scalable zk-SNARK.</p>

    <p class="text-gray-300">We ran our experiments on a desktop PC with a 3.40 GHz Intel Core i7-4770 CPU and 16 GB of RAM available. Unless otherwise specified, all times are in single-thread mode; as for our multi-core experiments, we enabled one thread for each of the CPU's 4 cores (for a total of 4 threads).</p>

    <p class="text-gray-300"><strong>Recalling</strong> vnTinyRAM. The architecture vnTinyRAM is parametrized by the <em>word size</em>, denoted w, and the <em>number of registers</em>, denoted k. In terms of instructions, vnTinyRAM includes load and store instructions for accessing random-access memory (in byte or word blocks), as well as simple integer, shift, logical, compare, move, and jump instructions. Thus, vnTinyRAM can efficiently implement control flow, loops, subroutines, recursion, and so on. Complex instructions (e.g., floating-point arithmetic) are not directly supported and can be implemented &quot;in software&quot;. See Appendix A.3 for how vnTinyRAM can be expressed in our random-access machine formalism (i.e., given w, k, how to construct M to express w-bit vnTinyRAM with k registers).</p>

    <p class="text-gray-300">Costs on vnTinyRAM. The performance of our zk-SNARK  <span class="math">(G^*, P^*, V^*)</span>  on vnTinyRAM is easy to characterize, because it is determined by few quantities. For the key generator  <span class="math">G^*</span> , the relevant quantities are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the constant time and space complexity of  <span class="math">G^*</span> , when given as input a description of vnTinyRAM; and</li>
      <li>the constant sizes of the generated proving key pk and verification key vk.</li>
    </ul>

    <p class="text-gray-300">For the proving algorithm  <span class="math">P^*</span> , which proceeds step by step alongside the original computation, they are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the constant time necessary to incrementally compute the new (constant-size) proof at each step; and</li>
      <li>the constant space needed to compute the new proof (on top of the space needed by the original program). Finally, the verifier  <span class="math">V^*</span>  takes as input a program  <span class="math">\\mathcal P</span>  and a time bound T, and runs in time  <span class="math">O(|\\mathcal P| + \\log T)</span> ; in our implementation, we fix  <span class="math">T \\leq 2^{300}</span>  (plenty enough), so that  <span class="math">V^*</span>  runs in time  <span class="math">O(|\\mathcal P|)</span> .</li>
    </ul>

    <p class="text-gray-300">In Figure 7, we report our measurements for two settings of vnTinyRAM: (w,k)=(16,16) and (w,k)=(32,16), i.e., 16-bit and 32-bit vnTinyRAM with 16 registers. (The same settings as in [BCTV14].)</p>

    <p class="text-gray-300"><strong>Comparison with [BCTV14].</strong> In Figure 8, we compare the efficiency of [BCTV14]'s preprocessing zk-SNARK and our scalable zk-SNARK, for a (random) program  <span class="math">\\mathcal{P}</span>  of  <span class="math">10^4</span>  instructions, as a function of T (the number of vnTinyRAM computation steps).</p>

    <p class="text-gray-300">The (approximate) asymptotic efficiency for [BCTV14] was obtained by linearly interpolating [BCTV14]'s measurements (which were collected on a machine with similar characteristics as our benchmarking machine). As for our measurements, we use the relevant numbers from Figure 7.</p>

    <p class="text-gray-300"><strong>Conclusion.</strong> Our experiments demonstrate that, as expected, our approach is slower for small computations but, on the other hand, offers scalability to large computations by avoiding any space-intensive computations. Indeed, [BCTV14] (as well as other preprocessing zk-SNARK implementations [PGHR13, BCGTV13a])</p>

    <p class="text-gray-300">require space-intensive computations to maintain their efficiency. As T grows, such approaches simply run out of memory, and must resort to &quot;computing in blocks&quot;, sacrificing time complexity.<sup>21</sup></p>

    <p class="text-gray-300">In contrast, our zk-SNARK, while requiring more time per execution step, merely requires a constant amount of memory to prove any number of execution steps. In particular, our zk-SNARK becomes more space-efficient than [BCTV14]'s zk-SNARK when T&gt;422 for 16-bit vnTinyRAM, and when T&gt;321 for 32-bit vnTinyRAM; moreover, these savings in space grow unbounded as T increases.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;20</sup>The prover also needs to store the Merkle tree's intermediate hashes, which incurs a linear overhead in the program's space complexity. Since this overhead is small, and can even be reduced by saving only the high levels of the Merkle tree (and recomputing, &quot;on demand&quot;, the local neighborhood of accessed leaves), we focus on the fixed additive overhead needed to generate the proof.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;21</sup>Extending known preprocessing zk-SNARK implementations with block-computing techniques, and precisely quantifying their cost, remains a challenging open question that we leave to future work.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16-bit vnTinyRAM</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">32-bit vnTinyRAM</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w, k) = (16, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w, k) = (32, 16)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">key generator G?</h4>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">TIME</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 threads</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread<br>4 threads</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">total</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.8 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.9 s<br>42.0 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15.5 s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SPACE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">861 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,125 MB<br>1,068 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,343 MB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pk size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55 MB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">vk size</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">prover P ?</h4>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">TIME</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 threads<br>1 thread</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 threads</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">per step</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.2 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.3 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.2 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.0 s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SPACE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,063 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">993 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,268 MB</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">proof</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">374 B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">374 B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">verifier V ?</h4>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">TIME</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P  = 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.2 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.9 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P  = 102</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23.7 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.5 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P  = 103</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29.8 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.8 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P  = 104</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">90.9 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94.2 ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">in general</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&asymp; (23.08 + 0.00676 P ) ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&asymp; (23.78 + 0.00702 P ) ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 7: Performance of our scalable zk-SNARK on 16-bit and 32-bit vnTinyRAM. (The reported times are the average of 20 experiments, with standard deviation less than 1%.)</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">key generator</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">key sizes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">prover</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">verifier</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TIME</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SPACE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">pk</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">vk</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TIME</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SPACE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TIME</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16-bit vnTinyRAM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BCTV14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.08 &middot; T s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.8 &middot; T MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3 &middot; T MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40.4 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.04 &middot; T s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.9 &middot; T MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.2 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w, k) = (16, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">this work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.8 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">861 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24.2 &middot; T s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">90.9 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32-bit vnTinyRAM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BCTV14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.13 &middot; T s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1 &middot; T MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4 &middot; T MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80.3 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.05 &middot; T s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.1 &middot; T MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41.0 ms</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w, k) = (32, 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">this work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42.0 s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1,068 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3 kB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.2 &middot; T s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">993 MB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94.2 ms</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 8: Comparison between <a href="#page-43-5">[BCTV14]</a>'s preprocessing zk-SNARK and our scalable zk-SNARK.</p>

    <p class="text-gray-300"><strong>VIPS.</strong> Finally, being scalable, our zk-SNARK implementation is the first to achieve a well-defined clock rate of <em>verified instructions per second</em> (VIPS). For vnTinyRAM, we obtain the following VIPS values:</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16-bit vnTinyRAM</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">32-bit vnTinyRAM</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w,k) = (16,16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(w,k) = (32,16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 thread</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">VIPS = \\frac{1}{24.2}Hz</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">VIPS = \\frac{1}{26.2}Hz</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 threads</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">VIPS = \\frac{1}{8.3}Hz</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">VIPS = \\frac{1}{9.0}Hz</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">While perhaps too slow for most applications, our prototype empirically demonstrates the feasibility of the bootstrapping approach as a way to achieve scalability of zk-SNARKs and, more generally, to achieve the rich functionality of proof-carrying data.</p>

    <p class="text-gray-300"><strong>Higher clock rate.</strong> There are ample opportunities for improving the clock rate of &quot;verified instructions per second&quot;. Besides potential improvements in the cryptographic protocol and elliptic curves, there is also an engineering challenge. In particular, the algorithms are highly amenable to parallelism and hardware support. Since each step of proof generation in our zk-SNARK is a <em>constant-size</em> operation, it could even be carefully optimized and wholly implemented in a fixed-sized, general-purpose &quot;proving processor&quot; hardware.</p>

    <p class="text-gray-300">Other PCD-friendly cycles. The PCD-friendly 2-cycle proposed in this paper facilitates a great improvement in the efficiency of recursively composing pairing-based zk-SNARKs. Do there exist any other PCD-friendly 2-cycles, not based on MNT curves? Or cycles of length greater than 2? Are these easier to find, achieve smaller bit size and higher 2-adicity, or admit faster nondeterministic pairing verification? Investigating these questions may lead to further efficiency improvements to recursive proof composition. Another consideration is that, with MNT-based PCD-friendly cycles, increasing the security level is costly, since one of the curves has low embedding degree (k = 4, for which 128-bit security requires  <span class="math">q_4 \\ge 2^{750}</span>  [FST10]).</p>

    <p class="text-gray-300">Alternative zk-SNARKs constructions. What are the advantages or disadvantages of pairing-based zk-SNARKs in which the pairing is not instantiated via a pairing-friendly elliptic curve, but instead via lattice techniques [GGH13]? Moreover, are there preprocessing zk-SNARKs that are not based on pairings? (E.g., can they be based on groups without bilinear maps?)</p>

    <p class="text-gray-300">We thank Andrew V. Sutherland for generous help in running the CM method on elliptic curves with large discriminants. We thank Damien Stehl&eacute; and Daniele Micciancio for discussions about the security of subset-sum functions. We thank Koray Karabina for answering questions about algorithms in [KT08].</p>

    <p class="text-gray-300">This work was supported by: the Broadcom Foundation and Tel Aviv University Authentication Initiative; the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370; the Check Point Institute for Information Security; the European Community's Seventh Framework Programme (FP7/2007-2013) under grant agreement number 240258; the Israeli Centers of Research Excellence I-CORE program (center 4/11); the Israeli Ministry of Science and Technology; the Leona M. &amp; Harry B. Helmsley Charitable Trust; the Simons Foundation, with a Simons Award for Graduate Students in Theoretical Computer Science; and the Skolkovo Foundation with agreement dated 10/26/2011.</p>

    <p class="text-gray-300">We introduce notions and notations for two computation models used in this paper: <em>arithmetic circuits</em> (see Appendix A.1) and <em>random-access machines</em> (see Appendix A.2).</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Arithmetic circuits</h3>

    <p class="text-gray-300">We work with circuits that are not boolean but <em>arithmetic</em>. Given a field  <span class="math">\\mathbb{F}</span> , an  <span class="math">\\mathbb{F}</span> -arithmetic circuit takes inputs that are elements in  <span class="math">\\mathbb{F}</span> , and its gates output elements in  <span class="math">\\mathbb{F}</span> . We naturally associate a circuit with the function it computes. The circuits we consider only have <em>bilinear gates</em>, <sup>22</sup> and a circuit's <em>size</em> is defined as the number of gates. To model nondeterminism we consider circuits with an <em>input</em>  <span class="math">x \\in \\mathbb{F}^n</span>  and an auxiliary input  <span class="math">a \\in \\mathbb{F}^h</span> , called a <em>witness</em>. Arithmetic circuit satisfiability is analogous to the boolean case, as follows.</p>

    <p class="text-gray-300"><strong>Definition A.1.</strong> Let  <span class="math">n, h, l \\in \\mathbb{N}</span>  respectively denote the input, witness, and output size. The <strong>circuit satisfaction problem</strong> of an  <span class="math">\\mathbb{F}</span> -arithmetic circuit  <span class="math">C \\colon \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  (with bilinear gates) is defined by the relation  <span class="math">\\mathcal{R}_C = \\{(x, a) \\in \\mathbb{F}^n \\times \\mathbb{F}^h : C(x, a) = 0^l\\}</span> ; its language is  <span class="math">\\mathcal{L}_C = \\{x \\in \\mathbb{F}^n : \\exists a \\in \\mathbb{F}^h, C(x, a) = 0^l\\}</span> .</p>

    <p class="text-gray-300">At times, we also write C(x,a)=0 to mean  <span class="math">C(x,a)=0^l</span>  for an unspecified l. All the arithmetic circuits we consider are over fields  <span class="math">\\mathbb{F}_p</span>  with p prime (that is at most exponential in the security parameter  <span class="math">\\lambda</span> ).</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Random-access machines</h3>

    <p class="text-gray-300">There are many possible definitions of <em>random-access machines</em> [CR72, AV77]. Here we formulate a concrete, yet relatively flexible, definition that suffices for the purposes of this paper. Informally, a machine is specified by a configuration for random-access memory (number of addresses, and number of bits stored at each address) and a CPU. At each step, the CPU gets the current state and the next instruction from memory; executes the instruction; communicates with memory (by storing or loading data); and then outputs the next state and the address for the next instruction. (Thus, random-access memory contains both program and data.)</p>

    <p class="text-gray-300">More precisely, a (non-deterministic) <strong>random-access machine</strong> with verification over a finite field  <span class="math">\\mathbb{F}</span>  is a tuple  <span class="math">\\mathbf{M} = (A, W, N, \\mathrm{CPU}_{\\mathsf{exe}}, \\mathrm{CPU}_{\\mathsf{ver}})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">A, W \\in \\mathbb{N}</span>  specify that (random-access) memory  <span class="math">\\mathcal{M}</span>  contains A addresses each storing W bits (i.e., that memory is a function  <span class="math">\\mathcal{M}: [A] \\to \\{0,1\\}^W</span> ).</li>
      <li><span class="math">N \\in \\mathbb{N}</span>  specifies the length, in bits, of a CPU state.</li>
      <li><span class="math">\\bullet~{\\rm CPU}_{\\rm exe}</span>  is a (stateful) function for  <span class="math">\\it executing</span>  the CPU (see below).</li>
      <li>CPU<sub>ver</sub> is an F-arithmetic circuit for <em>verifying</em> the CPU's execution (see below).</li>
    </ul>

    <p class="text-gray-300">The machine M takes as input a program  <span class="math">\\mathcal{P}</span>  and an auxiliary input  <span class="math">\\mathcal{G}</span> , and computes on them. More precisely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A <strong>program</strong> for M is a function  <span class="math">\\mathcal{P}: [A] \\to \\{0,1\\}^W</span>  that specifies the initial memory contents. The program  <span class="math">\\mathcal{P}</span>  is typically represented in sparse form, by listing the (few) addresses and values for non-zero memory entries, which may store any code and data to the machine.</li>
      <li>An auxiliary input for M is a sequence  <span class="math">\\mathcal{G} = (g_0, g_1, g_2, \\dots)</span> . Each  <span class="math">g_i</span>  consists of W bits and is accessed at the <em>i</em>-th computation step. The auxiliary input is treated as a <em>nondeterministic guess</em>.</li>
    </ul>

    <p class="text-gray-300">Then, the <strong>computation</strong> of <strong>M</strong> on program  <span class="math">\\mathcal{P}</span>  and auxiliary input  <span class="math">\\mathcal{G}</span> , denoted  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span> , proceeds as follows. Initialize the CPU state and instruction address to zero:  <span class="math">s_{\\mathsf{cpu},0} := 0^N</span> ,  <span class="math">a_{\\mathsf{pc},0} := 0</span> . Next, for  <span class="math">i = 0, 1, 2 \\ldots</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>CPU<sub>exe</sub> is given the current CPU state  <span class="math">(s_{\\text{cpu},i} \\in \\{0,1\\}^N)</span> , address of the instruction to be executed  <span class="math">(a_{\\text{pc},i} \\in [A])</span> , instruction to be executed  <span class="math">(v_{\\text{pc},i} := \\mathcal{M}_i(a_{\\text{pc},i}) \\in \\{0,1\\}^W)</span> , and guess  <span class="math">(g_i \\in \\{0,1\\}^W)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">CPU_{exe}</span>  outputs an address  <span class="math">(a_{mem,i} \\in [A])</span> , a value  <span class="math">(v_{st,i} \\in \\{0,1\\}^W)</span> , and a store flag  <span class="math">(f_{st,i} \\in \\{0,1\\})</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><sup>22</sup>A gate with inputs  <span class="math">x_1, \\ldots, x_m \\in \\mathbb{F}</span>  is <em>bilinear</em> if the output is  <span class="math">(\\alpha_0 + \\sum_{i=1}^m \\alpha_i x_i) \\cdot (\\beta_0 + \\sum_{i=1}^m \\beta_i x_i)</span>  for some  <span class="math">\\alpha, \\beta \\in \\mathbb{F}^{m+1}</span> . In particular, these include addition, multiplication, and constant gates.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>CPU<sub>exe</sub> is given the value at the address  <span class="math">(v_{\\mathsf{Id},i} := \\mathcal{M}_i(a_{\\mathsf{mem},i}) \\in \\{0,1\\}^W)</span> . Set  <span class="math">\\mathcal{M}_{i+1}</span>  equal to  <span class="math">\\mathcal{M}_i</span> ; if a store was requested (i.e.,  <span class="math">f_{\\mathsf{st},i} = 1</span> ), do it (i.e.,  <span class="math">\\mathcal{M}_{i+1}(a_{\\mathsf{mem},i}) := v_{\\mathsf{st},i}</span> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>CPU<sub>exe</sub> outputs a new CPU state  <span class="math">(s_{\\text{cpu},i+1} \\in \\{0,1\\}^N)</span> , an address for the next instruction  <span class="math">(a_{\\text{pc},i+1} \\in [A])</span> , and a flag denoting whether the machine has accepted  <span class="math">(f_{\\text{acc},i+1} \\in \\{0,1\\})</span> . CPU<sub>exe</sub>'s state is reset.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Thus  <span class="math">CPU_{\\text{exe}}</span>  can be thought of as M's &quot;processor&quot;: step after step,  <span class="math">CPU_{\\text{exe}}</span>  takes the previous state and instruction (and its address), executes the instruction, communicates with random-access memory, and produces the next state and instruction address. In contrast,  <span class="math">CPU_{\\text{ver}}</span>  is a predicate that verifies the correct input/output relationship of  <span class="math">CPU_{\\text{exe}}</span> . In other words  <span class="math">CPU_{\\text{exe}}</span>  satisfies the following property:</p>

    <pre><code class="language-text">Fix s_{\\sf cpu}, s&#x27;_{\\sf cpu} \\in \\{0,1\\}^N, a_{\\sf pc}, a_{\\sf mem}, a&#x27;_{\\sf pc} \\in [A], v_{\\sf pc}, v_{\\sf st}, v_{\\sf ld}, g \\in \\{0,1\\}^W, f_{\\sf st}, f&#x27;_{\\sf acc} \\in \\{0,1\\}, and let x_{\\sf ver} be the concatenation of all these. There is a witness a_{\\sf ver} such that {\\sf CPU}_{\\sf ver}(x_{\\sf ver}, a_{\\sf ver}) = 0 iff (a_{\\sf mem}, v_{\\sf st}, f_{\\sf st}) \\leftarrow {\\sf CPU}_{\\sf exe}(s_{\\sf cpu}, a_{\\sf pc}, v_{\\sf pc}, g) and, afterwards, (s&#x27;_{\\sf cpu}, a&#x27;_{\\sf pc}, f&#x27;_{\\sf acc}) \\leftarrow {\\sf CPU}_{\\sf exe}(v_{\\sf ld}). Moreover, a_{\\sf ver} can be efficiently computed from x_{\\sf ver}.
</code></pre>

    <p class="text-gray-300">Of course,  <span class="math">CPU_{ver}</span>  may simply internally execute  <span class="math">CPU_{exe}</span>  to perform its verification; but, having access to additional advice  <span class="math">a_{ver}</span> ,  <span class="math">CPU_{ver}</span>  may instead perform &quot;smarter&quot;, and more efficient, checks.</p>

    <p class="text-gray-300">We are not concerned about how the function  <span class="math">CPU_{\\text{exe}}</span>  is specified (e.g., it can be a computed program), but  <span class="math">CPU_{\\text{ver}}</span>  must be specified as an  <span class="math">\\mathbb{F}</span> -arithmetic circuit (for an appropriate  <span class="math">\\mathbb{F}</span>  that we will discuss).</p>

    <p class="text-gray-300">The language of accepting computations. We define the language of accepting computations on M. A program  <span class="math">\\mathcal{P}</span>  is treated as &quot;given&quot;, while the auxiliary input  <span class="math">\\mathcal{G}</span>  is treated as a nondeterministic advice.</p>

    <p class="text-gray-300"><strong>Definition A.2.</strong> For a random-access machine M, the language  <span class="math">\\mathcal{L}_{M}</span>  consists of pairs  <span class="math">(\\mathcal{P}, T)</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P is a program for M;</li>
      <li><em>T is a time bound;</em></li>
      <li>there exists an auxiliary input  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span>  accepts in at most T steps. We denote by  <span class="math">\\mathcal{R}_{\\mathbf{M}}</span>  the relation corresponding to  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span> .</li>
    </ul>

    <p class="text-gray-300">In this paper we obtain an implementation of scalable zk-SNARKs for proving/verifying membership in the above language (see Appendix E for a definition). We evaluate our system for a specific choice of machine: vnTinyRAM, a simple RISC von Neumann architecture introduced by [BCTV14] (see below). Of course, other choices of random-access machines are possible, and our implementation supports them.</p>

    <p class="text-gray-300">We evaluate our scalable zk-SNARK on an architecture that previously appeared in (preprocessing) zk-SNARK implementations: vnTinyRAM [BCTV14]. (See Section 7.) We explain how to set &quot; <span class="math">\\mathbf{M} = vnTinyRAM</span> &quot;, i.e., how to specify the architecture vnTinyRAM via the formalism introduced above (and used by our prototype).</p>

    <p class="text-gray-300">Given w,k, we want to construct a tuple  <span class="math">\\mathbf{M}=(A,W,N,\\mathrm{CPU_{exe}},\\mathrm{CPU_{ver}})</span>  that implements w-bit vnTinyRAM with k registers. First we need to specify the parameters  <span class="math">A,W\\in\\mathbb{N}</span>  for random access memory. vnTinyRAM accesses memory, consisting of  <span class="math">2^w</span>  bytes, either as bytes or as words; moreover, vnTinyRAM instructions (which are stored in memory) take two words to encode in memory. Thus, we set A,W so that memory consists of  <span class="math">A:=\\frac{8\\cdot 2^w}{2w}</span>  addresses, each storing W:=2w bits. Next, we set the CPU state length to N:=(1+k)w+1 because, in vnTinyRAM, a CPU state consists of the  <span class="math">program\\ counter\\ (w\\ bits),\\ k</span>  general-purpose  <span class="math">program\\ counter\\ (w\\ bits)</span> , and a  <span class="math">program\\ counter\\ (w\\ bits)</span> , while  <span class="math">program\\ counter\\ (w\\ bits)</span>  finally,  <span class="math">program\\ counter\\ (w\\ bits)</span>  for verifying the input-output relationship of  <span class="math">program\\ counter\\ (w\\ bits)</span>  is a prime field of  <span class="math">program\\ counter\\ (w\\ bits)</span>  bits (since  <span class="math">program\\ counter\\ (w\\ bits)</span> ), and we get the following sizes for the two settings we consider:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for (w, k) = (16, 16),  <span class="math">|CPU_{ver}| = 766</span> ; and</li>
      <li>for (w, k) = (32, 16),  <span class="math">|CPU_{ver}| = 1108</span> .</li>
    </ul>

    <p class="text-gray-300">The cryptographic primitives we study are based on <em>pairings</em>, which we briefly recall in Appendix B.1. Pairings can, in turn, be based on <em>pairing-friendly elliptic curves</em>; in Appendix B.2 we review basic notions about these.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  be cyclic groups of a prime order r. We denote elements of  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  via calligraphic letters such as  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{Q}</span> . We write  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  in additive notation. Let  <span class="math">\\mathcal{P}_1</span>  be a generator of  <span class="math">\\mathbb{G}_1</span> , i.e.,  <span class="math">\\mathbb{G}_1 = \\{\\alpha \\mathcal{P}_1\\}_{\\alpha \\in \\mathbb{F}_r}</span> ; let  <span class="math">\\mathcal{P}_2</span>  be a generator for  <span class="math">\\mathbb{G}_2</span> . (We also view  <span class="math">\\alpha</span>  as an integer, so that  <span class="math">\\alpha \\mathcal{P}_1</span>  is well-defined.)</p>

    <p class="text-gray-300">A <strong>pairing</strong> is an efficient map  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_T</span>  is also a cyclic group of order r (which we write in multiplicative notation), satisfying the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>BILINEARITY. For every nonzero elements  <span class="math">\\alpha, \\beta \\in \\mathbb{F}_r</span> , it holds that  <span class="math">e(\\alpha \\mathcal{P}_1, \\beta \\mathcal{P}_2) = e(\\mathcal{P}_1, \\mathcal{P}_2)^{\\alpha \\beta}</span> .</li>
      <li>NON-DEGENERACY.  <span class="math">e(\\mathcal{P}_1, \\mathcal{P}_2)</span>  is not the identity in  <span class="math">\\mathbb{G}_T</span> .</li>
    </ul>

    <p class="text-gray-300">When describing cryptographic primitives at high level, the choice of instantiation of  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e</span>  often does not matter. In this paper, however, we discuss implementation details, and such choices matter a great deal. Typically, pairings are based on (pairing-friendly) elliptic curves, discussed next.</p>

    <p class="text-gray-300">We assume familiarity with elliptic curves; here, we only recall the basic definitions in order to fix notation. See, e.g., [Was08, Sil09, FST10, CFAD <span class="math">^+</span> 12] for more details.</p>

    <p class="text-gray-300"><strong>Definition and curve groups.</strong> Given a field K, an <em>elliptic curve</em> E defined over K, denoted E/K, is a smooth projective curve of genus 1 (defined over K) with a distinguished K-rational point. We denote by E(K) the group of K-rational points on E; when finite, we denote the cardinality of this group by #E(K). For any  <span class="math">r \\in \\mathbb{N}</span> , E[r] denotes the group of r-torsion points in E(K), and E(K)[r] the group of r-torsion points in E(K). In this paper, we only consider elliptic curves where K is a finite field  <span class="math">\\mathbb{F}_q</span> ; so the definitions below are specific to this case.</p>

    <p class="text-gray-300"><strong>Trace and CM discrminant.</strong> The trace of  <span class="math">E/\\mathbb{F}_q</span>  is  <span class="math">t:=q+1-\\#E(\\mathbb{F}_q)</span> . The Hasse bound states that  <span class="math">|t| \\leq 2\\sqrt{q}</span> . If  <span class="math">\\gcd(q,t)=1</span> , then  <span class="math">E/\\mathbb{F}_q</span>  is ordinary; otherwise, it is supersingular. If  <span class="math">E/\\mathbb{F}_q</span>  is ordinary, the CM discriminant of E is the square-free part D of the integer  <span class="math">4q-t^2</span> , non-negative by the Hasse bound.<sup>23</sup></p>

    <p class="text-gray-300"><strong>ECDLP.</strong> The <em>elliptic-curve discrete logarithm problem</em> (ECDLP) is the following: given  <span class="math">E/\\mathbb{F}_q</span> ,  <span class="math">\\mathcal{P} \\in E(\\mathbb{F}_q)</span> , and  <span class="math">\\mathcal{Q} \\in \\langle \\mathcal{P} \\rangle</span> , find  <span class="math">a \\in \\mathbb{N}</span>  such that  <span class="math">\\mathcal{Q} = a\\mathcal{P}</span> . There are several methods to solve, with different time and space complexities, the ECDLP. For instance: the Pohlig&ndash;Hellman algorithm [PH78] (which reduces the problem to subgroups of prime order); Shanks' [Sha71] baby-step-giant-step method; Pollard's methods (the rho method [Pol78] and the kangaroo method [Pol00], and their parallel variants by van Oorschot and Wiener [vOW99]); the Menezes&ndash;Okamoto&ndash;Vanstone (MOV) attack using the Weil pairing [MOV91]; the Frey&ndash;R&uuml;ck attack using the Tate pairing [FR94]; and the SSSA attack for curves of trace t=1 [Sem98, Sma99, SA98].</p>

    <p class="text-gray-300">Cryptographic uses require the ECDLP to be hard (typically, intractable for polynomial-time adversaries). For points  <span class="math">\\mathcal P</span>  of large prime order r, this is widely believed to be the case. Thus, one only considers curves E with trace  <span class="math">t \\neq 1</span>  and having cyclic subgroups of  <span class="math">E(\\mathbb F_q)</span>  of large prime order r. So  <span class="math">\\#E(\\mathbb F_q)</span>  is either a prime r, or hr for a small  <span class="math">cofactor\\ h</span> .</p>

    <p class="text-gray-300"><strong>Pairings.</strong> For cryptographic uses that require efficient computation of pairings (such as the uses considered in this paper), suitable elliptic curves need to satisfy additional requirements, as we now recall.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;23</sup>Alternatively, some authors define the discriminant to be -D, or the discriminant of the imaginary quadratic field  <span class="math">\\mathbb{Q}(\\sqrt{-D})</span> .</p>

    <p class="text-gray-300">For any  <span class="math">r \\in \\mathbb{N}</span>  with  <span class="math">\\gcd(q,r)=1</span> , the <em>embedding degree</em> k of  <span class="math">E/\\mathbb{F}_q</span>  (with respect to r) is the smallest integer such that r divides  <span class="math">q^k-1</span> ; for such r, a bilinear map  <span class="math">e_r \\colon E[r] \\times E[r] \\to \\mu_r</span>  can be defined, where  <span class="math">\\mu_r \\subset \\mathbb{F}_{q^k}^*</span>  is the subgroup of r-th roots of unity in  <span class="math">\\overline{\\mathbb{F}_q}</span> . The map  <span class="math">e_r</span>  is known as the <em>Weil pairing</em>.</p>

    <p class="text-gray-300">The Weil pairing is not the only bilinear map that can be defined. Depending on properties of the curve E other, sometimes more efficient, pairings can be defined, e.g., the Tate pairing [FR94, FMR06], the Eta pairing [BGOhM07], and the Ate pairing [HSV06]. In each of these cases, the pairing computation requires arithmetic in  <span class="math">\\mathbb{F}_{q^k}</span> , so that k cannot be too large. On the other hand, the ECDLP can be translated (via the pairing itself [MOV91, FR94]) to the discrete logarithm problem over  <span class="math">\\mathbb{F}_{q^k}^*</span> , which is susceptible to subexponential-time attacks via index calculus [Odl85], so that k has to be large enough to achieve the desired level of hardness for the DLP in  <span class="math">\\mathbb{F}_{q^k}^*</span> .</p>

    <p class="text-gray-300">In light of the above considerations, an (ordinary) elliptic curve  <span class="math">E/\\mathbb{F}_q</span>  is said to be <em>pairing friendly</em> if (i)  <span class="math">E(\\mathbb{F}_q)</span>  contains a subgroup of large prime order r, and (ii) E has embedding degree k (with respect to r) that is not too large (i.e., computations in the field  <span class="math">\\mathbb{F}_{q^k}</span>  are feasible) and not too small (i.e., the DLP in  <span class="math">\\mathbb{F}_{q^k}^*</span>  is hard enough). The ideal case is when E has prime order r, and the embedding degree k is such that the ECDLP in  <span class="math">E(\\mathbb{F}_q)</span>  and the DLP in  <span class="math">\\mathbb{F}_{q^k}^*</span>  have approximately the same hardness, i.e., are <em>balanced</em>.</p>

    <p class="text-gray-300"><strong>Instantiations of pairings.</strong> A pairing is specified by a prime  <span class="math">r \\in \\mathbb{N}</span> , three cyclic groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  of order r, and an efficient bilinear map  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> . (See Appendix B.1.) Suppose one uses a curve  <span class="math">E/\\mathbb{F}_q</span>  with embedding degree k to instantiate the pairing. Then  <span class="math">\\mathbb{G}_T</span>  is set to  <span class="math">\\mu_r \\subset \\mathbb{F}_{q^k}^*</span> . The instantiation of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  depends on the choice of e; typically,  <span class="math">\\mathbb{G}_1</span>  is instantiated as an order-r subgroup of  <span class="math">E(\\mathbb{F}_q)</span> , while, for efficiency reasons [BKLS02, BLS04],  <span class="math">\\mathbb{G}_2</span>  as an order-r subgroup of  <span class="math">E&#x27;(\\mathbb{F}_{k/d})</span>  where E' is a d-th twist of E.</p>

    <p class="text-gray-300">At high-level, a <em>preprocessing</em> zk-SNARK for arithmetic-circuit satisfiability is a cryptographic primitive that provides short and easy-to-verify non-interactive zero-knowledge proofs of knowledge for the satisfiability of arithmetic circuits. A public proving key is used to generate proofs, and a public verification key is used to verify them; the two keys are jointly generated once, and can then be used any number of times. The adjective &quot;preprocessing&quot; denotes the fact that the key pair <em>depends</em> on the arithmetic circuit C whose satisfiability is being proved/verified; in particular, the time to generate a key pair for C is at least linear in the size of C. Below, we informally define this primitive; we refer the reader to, e.g., [BCIOP13] for a formal definition.</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}</span> , <sup>24</sup> a <strong>preprocessing zk-SNARK</strong> for  <span class="math">\\mathbb{F}</span> -arithmetic circuit satisfiability (see Appendix A.1) is a triple of polynomial-time algorithms (G, P, V), with V deterministic, <sup>25</sup> working as follows.</p>

    <p class="text-gray-300">&bull;  <span class="math">G(1^{\\lambda},C) \\to (\\mathsf{pk},\\mathsf{vk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and an  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, the <em>key generator</em> G probabilistically samples a proving key  <span class="math">\\mathsf{pk}</span>  and a verification key  <span class="math">\\mathsf{vk}</span> . We assume, without loss of generality, that  <span class="math">\\mathsf{pk}</span>  contains (a description of) the circuit C.</p>

    <p class="text-gray-300">The keys pk and vk are published as public parameters and can be used, any number of times, to prove/verify membership in the language  <span class="math">\\mathcal{L}_C</span> , as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P(\\mathsf{pk}, x, a) \\to \\pi</span> . On input a proving key  <span class="math">\\mathsf{pk}</span>  and any  <span class="math">(x, a) \\in \\mathcal{R}_C</span> , the <em>prover</em> P outputs a non-interactive proof  <span class="math">\\pi</span>  for the statement &quot; <span class="math">x \\in \\mathcal{L}_C</span> &quot;.</li>
      <li><span class="math">V(vk, x, \\pi) \\to b</span> . On input a verification key vk, an input x, and a proof  <span class="math">\\pi</span> , the <em>verifier</em> V outputs b = 1 if he is convinced by  <span class="math">\\pi</span>  that  <span class="math">x \\in \\mathcal{L}_C</span> .</li>
    </ul>

    <p class="text-gray-300">The triple (G, P, V) satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> The honest prover can convince the verifier for any instance in the language. Namely, for every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, and instance  <span class="math">x \\in \\mathcal{L}_C</span>  with a witness a,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[V(\\mathsf{vk},x,\\pi) = 1 \\;\\middle|\\; \\begin{array}{c} (\\mathsf{pk},\\mathsf{vk}) \\leftarrow G(1^\\lambda,C) \\\\ \\pi \\leftarrow P(\\mathsf{pk},x,a) \\end{array}\\right] = 1 \\;\\;.</span>$</p>

    <p class="text-gray-300"><strong>Succinctness.</strong> For every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic circuit C, and  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\in G(1^{\\lambda}, C)</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>an honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda}(1)</span>  bits;</li>
      <li><span class="math">V(vk, x, \\pi)</span>  runs in time  <span class="math">O_{\\lambda}(|x|)</span> .</li>
    </ul>

    <p class="text-gray-300">Above,  <span class="math">O_{\\lambda}</span>  hides a (fixed) polynomial factor in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof for an instance, the prover &quot;knows&quot; a witness for that instance. (Thus, soundness holds.) Namely, for every constant c&gt;0 and every polynomial-size adversary A there is a polynomial-size witness extractor E such that, for every large-enough security parameter  <span class="math">\\lambda</span> , for every  <span class="math">\\mathbb{F}</span> -arithmetic circuit C of size  <span class="math">\\lambda^c</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[ \\begin{array}{c|c} V(\\mathsf{vk}, x, \\pi) = 1 \\\\ (x, a) \\notin \\mathcal{R}_C \\end{array} \\middle| \\begin{array}{c} (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G(1^\\lambda, C) \\\\ (x, \\pi) \\leftarrow A(\\mathsf{pk}, \\mathsf{vk}) \\\\ a \\leftarrow E(\\mathsf{pk}, \\mathsf{vk}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .</span>$</p>

    <p class="text-gray-300"><strong>Statistical zero knowledge.</strong> An honestly-generated proof is statistical zero knowledge. Namely, there is a polynomial-time stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are negligibly-close:</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;24</sup>More precisely, a field family indexed by the security parameter  <span class="math">\\lambda</span>  where the field size grows at most exponentially in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{25}&lt;/sup&gt;</span> In this paper we use the technique of recursive proof composition, which relies on V being deterministic (i.e., no coin flips are needed during proof verification). All known zk-SNARK constructions satisfy this property, so this is effectively not a restriction.</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} C \\leftarrow D(1^{\\lambda}) \\\\ (x,a) \\in \\mathcal{R}_C \\\\ \\mathcal{D}(\\pi) = 1 \\end{array} \\middle| \\begin{array}{c} C \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G(1^{\\lambda}, C) \\\\ (x,a) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow P(\\mathsf{pk}, x, a) \\end{array} \\right] \\quad \\text{and} \\quad \\Pr\\left[\\begin{array}{c|c} C \\leftarrow D(1^{\\lambda}) \\\\ (x,a) \\in \\mathcal{R}_C \\\\ D(\\pi) = 1 \\end{array} \\middle| \\begin{array}{c} C \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow S(1^{\\lambda}, C) \\\\ (x,a) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow S(x) \\end{array} \\right] \\right].</span>$</p>

    <p class="text-gray-300"><strong>Remark C.1.</strong> All known preprocessing zk-SNARK constructions can in fact be made <em>perfect</em> zero knowledge, at the only expense of a negligible probability of error in completeness.</p>

    <p class="text-gray-300">There are many preprocessing zk-SNARK constructions in the literature [Gro10, Lip12, BCIOP13, GGPR13, PGHR13, BCGTV13a, Lip13, BCTV14]. The most efficient ones are based on <em>quadratic arithmetic programs</em> (QAPs) [GGPR13, BCIOP13, PGHR13, BCGTV13a, BCTV14]; such constructions provide a linear-time G, quasilinear-time P, and linear-time V.</p>

    <p class="text-gray-300">Three of the above works [PGHR13, BCGTV13a, BCTV14] also investigate and provide implementations of preprocessing zk-SNARKs. As we discuss in Section 3.3, in this work we follow the implementation of [BCTV14], which, at the time of writing, is the fastest one.</p>

    <p class="text-gray-300">Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diffie-Hellman assumptions in bilinear groups [Gro10, BB04, Gen04]. Knowledge-of-exponent assumptions are fairly strong, but there is evidence that such assumptions may be inherent for constructing zk-SNARKs [GW11, BCCT12].</p>

    <p class="text-gray-300"><strong>Remark C.2</strong> (auxiliary input). More generally, the security of zk-SNARKs relies on the <em>extractability</em> of certain functions. Extractability is a delicate property that, depending on how it is stated, yields conditions of different relative strength. One aspect that affects this is the choice of <em>auxiliary input</em> (a discussion of which was omitted in the informal definition above). For instance, if the adversary is allowed <em>any</em> auxiliary input (perhaps even by way of maliciously chosen circuits <em>C</em>), extraction may be difficult because the auxiliary input may encode an obfuscated strategy [BCCT12]; such intuition can in fact be formalized to yield limitations to extractability [BCPR13]. On the other end of the spectrum, certain notions of extractability can be achieved [BCP13], and also no limitations are known for certain 'benign looking' inputs.</p>

    <p class="text-gray-300">The focus of this paper is practical aspects of zk-SNARKs so our perspective on extractability here is that, similarly to the Fiat&ndash;Shamir paradigm [FS87], knowledge-of-exponent assumptions, despite not being fully understood, provide solid heuristics in practice since no effective attacks against them are known.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Instantiations via elliptic curves</h3>

    <p class="text-gray-300">Known preprocessing zk-SNARK constructions are based on <em>pairings</em> (see Appendix B.1), which can in turn be based on <em>pairing-friendly elliptic curves</em> (see Appendix B.2). We recall two facts, used in this paper.</p>

    <p class="text-gray-300"><strong>Field for the circuit language.</strong> Let E be an elliptic curve that is defined over a finite field  <span class="math">\\mathbb{F}_q</span> , has a group  <span class="math">E(\\mathbb{F}_q)</span>  of  <span class="math">\\mathbb{F}_q</span> -rational points with a prime order r (or order divisible by a large prime r), and has embedding degree k with respect to r. Suppose that a preprocessing zk-SNARK (G, P, V) is instantiated with E. Then,</p>

    <p class="text-gray-300">(G, P, V) works for  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit satisfiability, but all of V's arithmetic computations are over  <span class="math">\\mathbb{F}_q</span>  (or extensions of  <span class="math">\\mathbb{F}_q</span>  up to degree k).<sup>26</sup></p>

    <p class="text-gray-300">This fact motivates most of the discussions in Section 3.1.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{26}&lt;/sup&gt;</span> Intuitively, this is because: (a) the groups  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  for a pairing  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  on E have prime order r, so that discrete logarithms for elements in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , which encode information about the arithmetic circuit, &quot;live&quot; in  <span class="math">\\mathbb{F}_r</span> ; while (b)  <span class="math">\\mathbb{G}_1</span> -arithmetic,  <span class="math">\\mathbb{G}_2</span> -arithmetic, and pairing computations are conducted over  <span class="math">\\mathbb{F}_q</span>  (or extensions of  <span class="math">\\mathbb{F}_q</span>  up to degree k).</p>

    <p class="text-gray-300"><strong>2-adicity of a curve.</strong> Prior work identified the <em>2-adicity</em> of a curve as an important ingredient for efficient implementations of the generator and, especially, the prover [BCGTV13a, BCTV14].</p>

    <p class="text-gray-300">An elliptic curve  <span class="math">E/\\mathbb{F}_q</span>  has 2-adicity  <span class="math">2^\\ell</span>  if the large prime r dividing  <span class="math">\\#E(\\mathbb{F}_q)</span>  is such that  <span class="math">2^\\ell</span>  divides r-1. This property ensures that the multiplicative group of  <span class="math">\\mathbb{F}_r</span>  contains a  <span class="math">2^\\ell</span> -th root of unity, which significantly improves the efficiency of interpolation and evaluation of functions defined over certain domains in  <span class="math">\\mathbb{F}_r</span> .</p>

    <p class="text-gray-300">When instantiating a preprocessing zk-SNARK (G,P,V) with E, the zk-SNARK works for  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit satisfiability, and both G and P need to solve interpolation/evaluation problems over domains of size |C|, where C is the  <span class="math">\\mathbb{F}_r</span> -arithmetic circuit given as input to G. Thus, efficiency can be improved if E is sufficiently 2-adic. Concretely, to fully take advantage of the efficiency benefits of 2-adicity, one requires that  <span class="math">2^\\ell \\geq |C|</span> , i.e.,  <span class="math">\\nu_2(r-1) \\geq \\lceil \\log |C| \\rceil</span>  where  <span class="math">\\nu_2(\\cdot)</span>  denotes the 2-adic order function.</p>

    <p class="text-gray-300">This fact motivates much of the extensive search for suitable curve parameters, described in Section 3.2.</p>

    <p class="text-gray-300"><strong>Remark C.3</strong> (lack of 2-adicity). One can consider other/weaker requirements (e.g.,  <span class="math">\\nu_3(r-1) \\geq \\lceil \\log_3 |C| \\rceil</span> , or r-1 is divisible by a smooth number  <span class="math">M \\geq |C|</span> ) which would still somewhat simplify interpolation/evaluation problems over |C|-size domains in  <span class="math">\\mathbb{F}_r</span> . The above requirement that  <span class="math">\\nu_2(r-1) \\geq \\lceil \\log |C| \\rceil</span>  is, in a sense, the &quot;ideal&quot; one. Moreover, even if E does not satisfy these other/weaker requirements, it is still possible to instantiate the zk-SNARK, but at a higher computational cost (both asymptotically and in practice), due to the necessary use of &quot;heavier&quot; techniques applying to &quot;generic&quot; fields [PGHR13].</p>

    <p class="text-gray-300">The (pairing-based) preprocessing zk-SNARKs that we use follow those of [BCTV14] (see Section 3.3); in turn, these improve upon and implement those of [PGHR13]. In this paper, we construct arithmetic circuits for verifying the evaluation of the zk-SNARK verifier V: a circuit  <span class="math">C_{V,4}</span>  for an instantiation based on the curve  <span class="math">E_4</span> , and a circuit  <span class="math">C_{V,6}</span>  for one based on the curve  <span class="math">E_6</span>  (see Section 5.1). For completeness, in Figure 9 we summarize V's abstract protocol.</p>

    <p class="text-gray-300">We see that V's protocol consists of two main parts: (a) use the verification key vk and input  <span class="math">\\vec{x} \\in \\mathbb{F}_r^n</span>  to compute  <span class="math">vk_{\\vec{x}}</span>  (see Step 1); and (b) use the verification key vk, value  <span class="math">vk_{\\vec{x}}</span> , and proof  <span class="math">\\pi</span> , to compute 12 pairings and perform the required checks (see Step 2, Step 3, Step 4). Thus, the first part requires O(n) scalar multiplications in  <span class="math">\\mathbb{G}_1</span> , while the second part requires O(1) pairing evaluations.</p>

    <p class="text-gray-300">For additional details regarding V (and, more generally, the preprocessing zk-SNARK construction), we refer the reader to [BCTV14, PGHR13]. Indeed, our focus in this work is not  <span class="math">why\\ V</span>  executes these checks, but how we can efficiently verify its checks via suitable arithmetic circuits.</p>

    <pre><code class="language-text">ALGEBRAIC SETUP. A prime r, two cyclic groups \\mathbb{G}_1 and \\mathbb{G}_2 of order r with generators \\mathcal{P}_1 and \\mathcal{P}_2 respectively, and a pairing e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T, where \\mathbb{G}_T is also cyclic of order r. (See Appendix B.1 for a pairing&#x27;s definition.)
</code></pre>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6"><span class="math">{\\bf zk\\text{-}SNARK} \\ {\\bf verifier} \\ V \\ {\\bf for \\ inputs \\ of \\ size} \\ n</span></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>INPUTS:</li>
      <li>verification key  <span class="math">vk = (vk_A, vk_B, vk_C, vk_{\\gamma}, vk_{\\beta\\gamma}^1, vk_{\\beta\\gamma}^2, vk_Z, vk_{IC})</span> , where    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>*  <span class="math">\\mathsf{vk}_{\\mathsf{B}}, \\mathsf{vk}_{\\beta\\gamma}^1</span>  are in  <span class="math">\\mathbb{G}_1</span></li>
      <li>*  <span class="math">\\mathsf{vk}_{\\mathsf{A}}, \\mathsf{vk}_{\\mathsf{C}}, \\mathsf{vk}_{\\gamma}, \\mathsf{vk}_{\\beta\\gamma}^2, \\mathsf{vk}_{\\mathsf{Z}} \\text{ are in } \\mathbb{G}_2</span></li>
      <li><span class="math">* \\ \\mathsf{vk}_{\\mathsf{IC}} = (\\mathsf{vk}_{\\mathsf{IC},0},\\mathsf{vk}_{\\mathsf{IC},1},\\dots,\\mathsf{vk}_{\\mathsf{IC},n}) \\in \\mathbb{G}_1^{1+n}</span></li>
    </ul></li>
      <li>input  <span class="math">\\vec{x} = (x_1, \\dots, x_n)</span> , where  <span class="math">x_i \\in \\mathbb{F}_r</span></li>
      <li>proof  <span class="math">\\pi = (\\pi_A, \\pi&#x27;_A, \\pi_B, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_K, \\pi_H)</span> , where  <span class="math">\\pi_A, \\pi&#x27;_A, \\pi&#x27;_B, \\pi_C, \\pi&#x27;_C, \\pi_K, \\pi_H \\in \\mathbb{G}_1</span>  and  <span class="math">\\pi_B \\in \\mathbb{G}_2</span></li>
      <li>OUTPUTS: decision bit</li>
      <li>1. Compute  <span class="math">\\mathsf{vk}_{\\vec{x}} := \\mathsf{vk}_{\\mathsf{IC},0} + \\sum_{i=1}^n x_i \\mathsf{vk}_{\\mathsf{IC},i} \\in \\mathbb{G}_1</span> .</li>
      <li>2. Check validity of knowledge commitments:  <span class="math">e(\\pi_A, vk_A) = e(\\pi&#x27;_A, \\mathcal{P}_2)</span> ,  <span class="math">e(vk_B, \\pi_B) = e(\\pi&#x27;_B, \\mathcal{P}_2)</span> ,  <span class="math">e(\\pi_C, vk_C) = e(\\pi&#x27;_C, \\mathcal{P}_2)</span> .</li>
      <li>3. Check same coefficients were used:  <span class="math">e(\\pi_K, \\mathsf{vk}_\\gamma) = e(\\mathsf{vk}_{\\vec{x}} + \\pi_\\mathsf{A} + \\pi_\\mathsf{C}, \\mathsf{vk}_{\\beta\\gamma}^2) \\cdot e(\\mathsf{vk}_{\\beta\\gamma}^1, \\pi_\\mathsf{B})</span> .</li>
      <li>4. Check QAP divisibility:  <span class="math">e(vk_{\\vec{x}} + \\pi_A, \\pi_B) = e(\\pi_H, vk_Z) \\cdot e(\\pi_C, \\mathcal{P}_2)</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Accept if and only if all the above checks succeeded.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 9: Summary of the checks performed by the zk-SNARK verifier  <span class="math">{\\cal V}.</span></p>

    <p class="text-gray-300">We define a <em>proof-carrying data system</em> (PCD system), which is a cryptographic primitive that captures the notion of proof-carrying data [CT10, CT12]. More precisely, we define <em>preprocessing</em> PCD systems [BCCT13]. The definitions here are somewhat informal; for details, we refer the reader to [BCCT13].</p>

    <p class="text-gray-300"><strong>Proof-carrying data at a glance.</strong> Fix a predicate  <span class="math">\\Pi</span> . Consider a distributed computation where nodes perform computations; each computation takes as input messages and outputs a new output message. The security goal is to ensure that each output message is <em>compliant</em> with the predicate  <span class="math">\\Pi</span> . Proof-carrying data ensures this goal by attaching short and easy-to-verify proofs of  <span class="math">\\Pi</span> -compliance to each message.</p>

    <p class="text-gray-300">Concretely, a <em>key generator</em>  <span class="math">\\mathbb{G}</span>  first sets up a proving key and a verification key. Anyone can then use a <em>prover</em>  <span class="math">\\mathbb{P}</span> , which is given as input the proving key, prior messages  <span class="math">\\vec{z}_{in}</span>  with proofs  <span class="math">\\vec{\\pi}_{in}</span> , and an output message z, to generate a proof  <span class="math">\\pi</span>  attesting that z is  <span class="math">\\Pi</span> -compliant. Anyone can use a <em>verifier</em>  <span class="math">\\mathbb{V}</span> , which is given as input the verification key, a message z, and a proof, to verify that z is  <span class="math">\\Pi</span> -compliant.</p>

    <p class="text-gray-300">Crucially, proof generation and proof verification time are &quot;history independent&quot;: the first only depends on the time to execute  <span class="math">\\Pi</span>  on input a node's messages, while the second only on the message length.</p>

    <p class="text-gray-300">We now spell out more details, by first specifying the notion of distributed computation, and then that of compliance with a predicate  <span class="math">\\Pi</span> . Our discussion is specific to predicates specified as  <span class="math">\\mathbb{F}</span> -arithmetic circuits.</p>

    <p class="text-gray-300"><strong>Transcripts.</strong> Given  <span class="math">n_{\\mathsf{msg}}, n_{\\mathsf{loc}}, s \\in \\mathbb{N}</span>  and field  <span class="math">\\mathbb{F}</span> , an  <span class="math">\\mathbb{F}</span> -arithmetic <strong>transcript</strong> (for message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , and arity s) is a triple  <span class="math">\\mathsf{T} = (G, \\mathsf{loc}, \\mathsf{data})</span> , where G = (V, E) is a directed acyclic graph G, loc:  <span class="math">V \\to \\mathbb{F}^{n_{\\mathsf{loc}}}</span>  are node labels, and data:  <span class="math">E \\to \\mathbb{F}^{n_{\\mathsf{msg}}}</span>  are edge labels. The <em>output of</em>  <span class="math">\\mathsf{T}</span> , denoted out( <span class="math">\\mathsf{T}</span> ), equals data( <span class="math">\\tilde{u}, \\tilde{v}</span> ) where ( <span class="math">\\tilde{u}, \\tilde{v}</span> ) is the lexicographically-first edge with  <span class="math">\\tilde{v}</span>  a sink.</p>

    <p class="text-gray-300">Intuitively, the label loc(v) of a node v represents the  <span class="math">local\\ data</span>  used by v in his local computation; the edge label data(u,v) of a directed edged (u,v) represents the message sent from node u to node v. Typically, a party at node v uses the local data loc(v) and &quot;input messages&quot;  <span class="math">(data(u,v))_{u \\in parents(v)}</span>  to compute an &quot;output message&quot; data(v,w) for each child  <span class="math">w \\in children(v)</span> .</p>

    <p class="text-gray-300">Compliance. Given field  <span class="math">\\mathbb F</span>  and  <span class="math">n_{\\mathsf{msg}}, n_{\\mathsf{loc}}, s \\in \\mathbb N</span> , an  <span class="math">\\mathbb F</span> -arithmetic compliance predicate  <span class="math">\\Pi</span>  (for message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , and arity s) is an  <span class="math">\\mathbb F</span> -arithmetic circuit with domain  <span class="math">\\mathbb F^{n_{\\mathsf{msg}}} \\times \\mathbb F^{n_{\\mathsf{loc}}} \\times \\mathbb F^{s \\cdot n_{\\mathsf{msg}}} \\times \\mathbb F</span> . The compliance predicate  <span class="math">\\Pi</span>  specifies whether a given transcript  <span class="math">\\mathsf T</span>  is compliant or not, as follows. Consider any transcript  <span class="math">\\mathsf T</span>  with message size  <span class="math">n_{\\mathsf{msg}}</span> , local-data size  <span class="math">n_{\\mathsf{loc}}</span> , and arity s. We say that  <span class="math">\\mathsf T = (G, \\mathsf{loc}, \\mathsf{data})</span>  is  <span class="math">\\Pi</span> -compliant, denoted  <span class="math">\\Pi(\\mathsf T) = 0</span> , if, for every  <span class="math">v \\in V</span>  and  <span class="math">w \\in \\mathsf{children}(v)</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pi \\Big( \\mathsf{data}(v,w), \\mathsf{loc}(v), \\big( \\mathsf{data}(u,v) \\big)_{u \\in \\mathsf{parents}(v)}, b_{\\mathsf{base}} \\Big) = 0 \\enspace ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">b_{\\mathsf{base}} \\in \\{0,1\\}</span>  is the <em>base case flag</em> (i.e., equals 1 if and only if v is a source). Furthermore, we say that a message z is  <span class="math">\\Pi</span> -compliant if there is  <span class="math">\\mathsf{T}</span>  such that  <span class="math">\\Pi(\\mathsf{T}) = 0</span>  and  <span class="math">\\mathsf{out}(\\mathsf{T}) = z</span> .</p>

    <p class="text-gray-300">We are now ready to describe the syntax, semantics, and security of a proof-carrying data system.</p>

    <p class="text-gray-300">Given a field  <span class="math">\\mathbb{F}</span> , a (<strong>preprocessing</strong>) <strong>proof-carrying data system</strong> (PCD system) for  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicates is a triple of polynomial-time algorithms  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  working as follows.</p>

    <p class="text-gray-300">&bull;  <span class="math">\\mathbb{G}(1^{\\lambda},\\Pi) \\to (\\mathsf{pk},\\mathsf{vk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and an  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate  <span class="math">\\Pi</span> , the <em>key generator</em>  <span class="math">\\mathbb{G}</span>  probabilistically samples a proving key pk and a verification key vk. We assume, without loss of generality, that pk contains (a description of) the predicate  <span class="math">\\Pi</span> .</p>

    <p class="text-gray-300">The keys pk and vk are published as public parameters and can be used, any number of times, to prove/verify  <span class="math">\\Pi</span> -compliance of messages.</p>

    <p class="text-gray-300">&bull;  <span class="math">\\mathbb{P}(\\mathsf{pk}, z, z_{\\mathsf{loc}}, \\vec{z}_{\\mathsf{in}}, \\vec{\\pi}_{\\mathsf{in}}) \\to \\pi</span> . On input a proving key  <span class="math">\\mathsf{pk}</span> , outgoing message z, local data  <span class="math">z_{\\mathsf{loc}}</span> , and incoming messages  <span class="math">\\vec{z}_{\\mathsf{in}}</span>  with proofs  <span class="math">\\vec{\\pi}_{\\mathsf{in}}</span> , the <em>prover</em>  <span class="math">\\mathbb{P}</span>  outputs a proof  <span class="math">\\pi</span>  for the statement &quot;z is  <span class="math">\\Pi</span> -compliant&quot;.</p>

    <p class="text-gray-300">&bull;  <span class="math">\\mathbb{V}(\\mathsf{vk}, z, \\pi) \\to b</span> . On input a verification key  <span class="math">\\mathsf{vk}</span> , a message z, and a proof  <span class="math">\\pi</span> , the <em>verifier</em>  <span class="math">\\mathbb{V}</span>  outputs b = 1 if he is convinced by  <span class="math">\\pi</span>  that z is  <span class="math">\\Pi</span> -compliant.</p>

    <p class="text-gray-300">The triple  <span class="math">(\\mathbb{G}, \\mathbb{P}, \\mathbb{V})</span>  satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> The honest prover can convince the verifier that the output of any compliant transcript is indeed compliant. Namely, for every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic compliance predicate  <span class="math">\\Pi</span> , and distributed-computation generator S (see below),</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} \\Pi(\\mathsf{T}) = 0 &amp; (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathbb{G}(1^\\lambda, \\Pi) \\\\ \\mathbb{V}\\big(\\mathsf{vk}, \\mathsf{out}(\\mathsf{T}), \\pi\\big) \\neq 1 &amp; (\\mathsf{T}, \\pi) \\leftarrow \\mathsf{ProofGen}(S, \\mathsf{pk}, \\mathbb{P}) \\end{array}\\right] = 0 \\enspace .</span>$</p>

    <p class="text-gray-300">Above, ProofGen is an interactive protocol between a <em>distributed-computation generator</em> S and the PCD prover  <span class="math">\\mathbb{P}</span> , in which both are given the compliance predicate  <span class="math">\\Pi</span>  and the proving key pk. Essentially, at every time step, S chooses to do one of the following actions: add a new unlabeled vertex to the computation transcript so far (this corresponds to adding a new computing node to the computation), label an unlabeled vertex (this corresponds to a choice of local data by a computing node), or add a new labeled edge (this corresponds to a new message from one node to another). In case S chooses the third action, the PCD prover  <span class="math">\\mathbb{P}</span>  produces a proof for the  <span class="math">\\Pi</span> -compliance of the new message, and adds this new proof as an additional label to the new edge. When S halts, the interactive protocol outputs the distributed computation transcript T, as well as T's output and corresponding proof. Intuitively, the completeness property requires that if T is compliant with  <span class="math">\\Pi</span> , then the proof attached to the output (which is the result of dynamically invoking  <span class="math">\\mathbb{P}</span>  for each message in T, as T was being constructed by S) is accepted by the verifier.</p>

    <p class="text-gray-300"><strong>Succinctness.</strong> For every security parameter  <span class="math">\\lambda</span> ,  <span class="math">\\mathbb{F}</span> -arithmetic predicate  <span class="math">\\Pi</span> , and  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\in \\mathbb{G}(1^{\\lambda}, \\Pi)</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>an honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda}(1)</span>  bits;</li>
      <li><span class="math">\\mathbb{V}(\\mathsf{vk}, z, \\pi)</span>  runs in time  <span class="math">O_{\\lambda}(|z|)</span> .</li>
    </ul>

    <p class="text-gray-300">Above,  <span class="math">O_{\\lambda}</span>  hides a (fixed) polynomial factor in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300"><strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof for a message, the prover &quot;knows&quot; a compliant transcript T with output z. (Thus, soundness holds.) Namely, for every constant c&gt;0 and every polynomial-size adversary A there is a polynomial-size witness extractor E such that, for every large-enough security parameter  <span class="math">\\lambda</span> , for every  <span class="math">\\mathbb F</span> -arithmetic compliance predicate  <span class="math">\\Pi</span>  of size  <span class="math">\\lambda^c</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} \\mathbb{V}(\\mathsf{vk},z,\\pi) = 1 \\\\ \\left(\\mathsf{out}(\\mathsf{T}) \\neq z \\ \\lor \\ \\Pi(\\mathsf{T}) \\neq 0\\right) &amp; (\\mathsf{pk},\\mathsf{vk}) \\leftarrow \\mathbb{G}(1^\\lambda,\\Pi) \\\\ \\mathsf{T} \\leftarrow E(\\mathsf{pk},\\mathsf{vk}) \\end{array}\\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .</span>$</p>

    <p class="text-gray-300"><strong>Statistical zero knowledge.</strong> An honestly-generated proof is statistical zero knowledge. <sup>27</sup> Namely, there is a polynomial-time stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are negligibly-close:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c} \\Phi = 1 \\left| \\begin{array}{c} \\Pi \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathbb{G}(1^{\\lambda}, \\Pi) \\\\ (z, z_{\\mathsf{loc}}, \\vec{z_{\\mathsf{in}}}, \\vec{\\pi_{\\mathsf{in}}}) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow \\mathbb{P}(\\mathsf{pk}, z, z_{\\mathsf{loc}}, \\vec{z_{\\mathsf{in}}}, \\vec{\\pi_{\\mathsf{in}}}) \\end{array} \\right] \\quad \\text{and} \\quad \\Pr\\left[\\begin{array}{c} \\Pi \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow S(1^{\\lambda}, \\Pi) \\\\ (z, z_{\\mathsf{loc}}, \\vec{z_{\\mathsf{in}}}, \\vec{\\pi_{\\mathsf{in}}}) \\leftarrow D(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\pi \\leftarrow S(z) \\end{array} \\right] \\right.,</span>$</p>

    <p class="text-gray-300">where, above,  <span class="math">\\Phi=1</span>  if and only if: (i) if  <span class="math">\\vec{\\pi}_{\\rm in}=\\bot</span> , then  <span class="math">\\Pi(z,z_{\\rm loc},\\vec{z}_{\\rm in},1)=0</span> ; (ii) if  <span class="math">\\vec{\\pi}_{\\rm in}\\ne\\bot</span> , then  <span class="math">\\Pi(z,z_{\\rm loc},\\vec{z}_{\\rm in},0)=0</span>  and, for each corresponding pair  <span class="math">(z_{\\rm in},\\pi_{\\rm in})</span> ,  <span class="math">\\mathbb{V}({\\sf vk},z_{\\rm in},\\pi_{\\rm in})=1</span> ; and (iii)  <span class="math">D(\\pi)=1</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;27</sup>In this paper, we construct PCD systems from preprocessing zk-SNARKs. Hence, analogously to preprocessing zk-SNARKs (cf. Remark C.1) <em>perfect</em> zero knowledge can be achieved at the only expense of a negligible error in completeness.</p>

    </section>

    <section id="app-e" class="mb-10">
      <h2 class="text-2xl font-bold">E Scalable zk-SNARKs for random-access machines</h2>

    <p class="text-gray-300">At high-level, a zk-SNARK for random-access machines is a cryptographic primitive that provides short and easy-to-verify non-interactive zero-knowledge proofs of knowledge for the correct execution of programs. A public proving key is used to generate proofs, and a public verification key is used to verify them; the two keys are jointly generated once, and can then be used any number of times.</p>

    <p class="text-gray-300">In this work, we seek, and obtain an implementation of, zk-SNARKs that are scalable, i.e., that are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Fully succinct.</strong> This property requires that a <em>single</em> pair of keys suffices for computations of <em>any</em> (polynomial) size. In particular, the time to generate a key pair is short (i.e., bounded by a fixed polynomial in the security parameter) and so is the key length.</li>
      <li><strong>Incrementally computable.</strong> This property requires that proof generation is carried out <em>incrementally</em>, along the original computation, by updating, at each step, a proof of correctness of the computation so far.</li>
    </ul>

    <p class="text-gray-300">Below, we informally define fully-succinct zk-SNARKs for random-access machines, as well as the additional property of incremental computation. We refer the reader to, e.g., [BCCT13] for a formal treatment. (Also see Remark C.2 for a technical comment that applies here too.)</p>

    <p class="text-gray-300">A <strong>fully-succinct zk-SNARK</strong> for random-access machines (see Appendix A.2) is a triple of polynomial-time algorithms  <span class="math">(G^*, P^*, V^*)</span>  working as follows.</p>

    <p class="text-gray-300">&bull;  <span class="math">G^{\\star}(1^{\\lambda}, \\mathbf{M}) \\to (\\mathsf{pk}, \\mathsf{vk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (presented in unary) and a random-access machine  <span class="math">\\mathbf{M}</span> , the <em>key generator</em>  <span class="math">G^{\\star}</span>  probabilistically samples a proving key pk and a verification key vk. We assume, without loss of generality, that pk contains (a description of) the machine  <span class="math">\\mathbf{M}</span> .</p>

    <p class="text-gray-300">The keys pk and vk are published as public parameters and can be used, any number of times, to prove/verify membership of instances in the language  <span class="math">\\mathcal{L}_{\\mathbf{M}}</span>  of accepting computations on  <span class="math">\\mathbf{M}</span>  (see Definition A.2). The key generator  <span class="math">G^{\\star}</span>  is thus <em>succinct and universal</em> (i.e., it does not depend on the program  <span class="math">\\mathcal{P}</span> , or even computation size, but only on the machine  <span class="math">\\mathbf{M}</span>  used to run programs). The keys pk and vk are used as follows.<sup>28</sup></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P^*(\\mathsf{pk}, \\mathcal{P}, T, \\mathcal{G}) \\to \\pi</span> . On input a program  <span class="math">\\mathcal{P}</span> , time bound T, and auxiliary input  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\mathbf{M}(\\mathcal{P}; \\mathcal{G})</span>  accepts in  <span class="math">\\leq T</span>  steps, the <em>prover</em>  <span class="math">P^*</span>  outputs a non-interactive proof  <span class="math">\\pi</span>  for the statement &quot; <span class="math">(\\mathcal{P}, T) \\in \\mathcal{L}_{\\mathbf{M}}</span> &quot;.</li>
      <li><span class="math">V^{\\star}(\\mathsf{vk}, \\mathcal{P}, T, \\pi) \\to b</span> . On input a program  <span class="math">\\mathcal{P}</span> , time bound T, and proof  <span class="math">\\pi</span> , the <em>verifier</em>  <span class="math">V^{\\star}</span>  outputs b = 1 if he is convinced by  <span class="math">\\pi</span>  that  <span class="math">(\\mathcal{P}, T) \\in \\mathcal{L}_{\\mathbf{M}}</span> .</li>
    </ul>

    <p class="text-gray-300">The triple  <span class="math">(G^{\\star}, P^{\\star}, V^{\\star})</span>  satisfies the following properties.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> The honest prover can convince the verifier for any instance in the language. Namely, for every security parameter  <span class="math">\\lambda</span> , random-access machine  <span class="math">\\mathbf{M}</span> , and instance  <span class="math">(\\mathcal{P}, T) \\in \\mathcal{L}_{\\mathbf{M}}</span>  with a witness  <span class="math">\\mathcal{G}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[V^{\\star}(\\mathsf{vk}, \\mathcal{P}, T, \\pi) = 1 \\, \\middle| \\, \\begin{array}{c} (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G^{\\star}(1^{\\lambda}, \\mathbf{M}) \\\\ \\pi \\leftarrow P^{\\star}(\\mathsf{pk}, \\mathcal{P}, T, \\mathcal{G}) \\end{array} \\right] = 1 \\ .</span>$</p>

    <p class="text-gray-300"><strong>Succinctness.</strong> For every security parameter  <span class="math">\\lambda</span> , random-access machine  <span class="math">\\mathbf{M}</span> , and  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\in G^{\\star}(1^{\\lambda}, \\mathbf{M})</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>an honestly-generated proof  <span class="math">\\pi</span>  has  <span class="math">O_{\\lambda,\\mathbf{M}}(1)</span>  bits;</li>
      <li><span class="math">V^*(\\mathsf{vk}, \\mathcal{P}, T, \\pi)</span>  runs in time  <span class="math">O_{\\lambda, \\mathbf{M}}(|\\mathcal{P}| + \\log T)</span> .</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;28</sup>Both pk and vk are public and only consist of  <span class="math">O_{\\lambda,\\mathbf{M}}(1)</span>  bits; so, one could think of them as a single <em>common reference string</em> crs := (pk, vk). We choose not to do so, because it will be more natural to think of them as separate data structures.</p>

    <p class="text-gray-300">Above,  <span class="math">O_{\\lambda,\\mathbf{M}}</span>  hides a (fixed) polynomial factor in  <span class="math">\\lambda</span>  and  <span class="math">|\\mathbf{M}|</span> . (In our implementation,  <span class="math">\\lambda</span> ,  <span class="math">|\\mathbf{M}|</span>  are constants.) <strong>Proof of knowledge (and soundness).</strong> If the verifier accepts a proof for a polynomial-size computation, the prover &quot;knows&quot; a witness for the instance. (Thus, soundness holds.) Namely, for every constant c&gt;0 and every polynomial-size adversary A there is a polynomial-size witness extractor E such that, for every large enough security parameter  <span class="math">\\lambda</span> , for every random-access machine  <span class="math">\\mathbf{M}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr \\left[ \\begin{array}{c|c} T \\leq \\lambda^c &amp; \\left| \\text{ } (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow G^\\star(1^\\lambda, \\mathbf{M}) \\\\ V^\\star(\\mathsf{vk}, \\mathcal{P}, T, \\pi) = 1 &amp; \\left| (\\mathcal{P}, T, \\pi) \\leftarrow A(\\mathsf{pk}, \\mathsf{vk}) \\\\ \\left( (\\mathcal{P}, T), \\mathcal{G} \\right) \\notin \\mathcal{R}_\\mathbf{M} &amp; \\mathcal{G} \\leftarrow E(\\mathsf{pk}, \\mathsf{vk}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .</span>$</p>

    <p class="text-gray-300"><strong>Statistical zero knowledge.</strong> An honestly-generated proof is statistical zero knowledge. <sup>29</sup> Namely, there is a polynomial-time stateful simulator S such that, for all stateful distinguishers D, the following two probabilities are negligibly-close:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} (\\mathcal{P},T),\\mathcal{G}) \\in \\mathcal{R}_{\\mathbf{M}} &amp; \\mathbf{M} \\leftarrow D(1^{\\lambda}) \\\\ (\\mathsf{pk},\\mathsf{vk}) \\leftarrow G^{\\star}(1^{\\lambda},\\mathbf{M}) \\\\ \\mathcal{D}(\\pi) = 1 &amp; (\\mathcal{P},T,\\mathcal{G}) \\leftarrow D(\\mathsf{pk},\\mathsf{vk}) \\\\ &amp; \\pi \\leftarrow P^{\\star}(\\mathsf{pk},\\mathcal{P},T,\\mathcal{G}) \\end{array}\\right] \\text{ and } \\Pr\\left[\\begin{array}{c|c} (\\mathcal{P},T),\\mathcal{G}) \\in \\mathcal{R}_{\\mathbf{M}} &amp; \\mathbf{M} \\leftarrow D(1^{\\lambda}) \\\\ (\\mathcal{P},T),\\mathcal{G}) \\in \\mathcal{R}_{\\mathbf{M}} &amp; (\\mathsf{pk},\\mathsf{vk}) \\leftarrow S(1^{\\lambda},\\mathbf{M}) \\\\ D(\\pi) = 1 &amp; (\\mathcal{P},T,\\mathcal{G}) \\leftarrow D(\\mathsf{pk},\\mathsf{vk}) \\\\ &amp; \\pi \\leftarrow S(\\mathcal{P},T) \\end{array}\\right].</span>$</p>

    <p class="text-gray-300">Finally, a fully-succinct zk-SNARK is also <strong>incrementally computable</strong> if there exist two algorithms, a <em>computation supervisor</em> SV and a <em>sub-prover</em> SP, such that, for every security parameter  <span class="math">\\lambda</span> , random-access machine  <span class="math">\\mathbf{M}</span> , instance  <span class="math">(\\mathcal{P},T) \\in \\mathcal{L}_{\\mathbf{M}}</span>  with a witness  <span class="math">\\mathcal{G}=(g_0,\\ldots,g_{T-1})</span> , key pair  <span class="math">(\\mathsf{pk},\\mathsf{vk}) \\in G^\\star(1^\\lambda,\\mathbf{M})</span> , and letting  <span class="math">\\pi_T:=P^\\star(\\mathsf{pk},\\mathcal{P},T,\\mathcal{G})</span> , the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For i = 1, ..., T,  <span class="math">\\pi_i = SP(pk, aux_i, \\pi_{i-1})</span> .</li>
      <li>For  <span class="math">i=1,\\ldots,T</span> ,  <span class="math">\\mathsf{aux}_i</span>  is the final state of memory when  <span class="math">\\mathsf{SV}(\\mathbf{M},g_i)</span>  has read-write random access to a memory initialized to the state  <span class="math">\\mathsf{aux}_{i-1}</span> . Moreover, each  <span class="math">\\mathsf{aux}_i</span>  has size  <span class="math">O_{\\lambda,\\mathbf{M}}(S_i)</span> , where  <span class="math">S_i</span>  is the space usage of  <span class="math">\\mathbf{M}(\\mathcal{P};\\mathcal{G})</span>  at time i.</li>
      <li>The proof  <span class="math">\\pi_0</span>  is defined as  <span class="math">\\bot</span> , and  <span class="math">\\mathsf{aux}_0</span>  as  <span class="math">\\mathcal{P}</span> . In particular, SV and SP have time and space complexity  <span class="math">O_{\\lambda,\\mathbf{M}}(1)</span> ; these costs are incurred each time a new proof is generated from an old one.</li>
    </ul>

      <h3 id="app-e.1" class="text-xl font-semibold mt-8">E.1 Known constructions and security</h3>

    <p class="text-gray-300">Theoretical constructions of fully-succinct zk-SNARKs are known, based on various cryptographic assumptions [Mic00, Val08, BCCT13]. Despite achieving essentially-optimal asymptotics [BFLS91, BGHSV05, BCGT13b, BCGT13a, BCCT13] no implementations of them have been reported in the literature to date.</p>

    <p class="text-gray-300">Of the above, the only approach that also achieves incremental computation is the one of Bitansky et al. [BCCT13], which we follow in this paper. Security in [BCCT13] is based on the security of <em>preprocessing</em> zk-SNARKs (see Appendix C.1) and collision-resistant hash functions.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;29</sup>In this paper, we construct fully-succinct zk-SNARKs from preprocessing ones. Hence, analogously to preprocessing zk-SNARKs (cf. Remark C.1) <em>perfect</em> zero knowledge can be achieved at the only expense of a negligible error in completeness.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;30</sup>In our implementation,  <span class="math">aux_i</span>  has size  <span class="math">\\approx S_i</span> . Thus, the effective space overhead, compared to the original computation, is the <em>additive, constant</em> cost to run SV and SP.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[ADLM<sup>+</sup>08] Yuriy Arbitman, Gil Dogon, Vadim Lyubashevsky, Daniele Micciancio, Chris Peikert, and Alon Rosen. SWIFFTX: a proposal for the SHA-3 standard, 2008.</p></li>
      <li><p class="text-gray-300">[Ajt96] Miklos Ajtai. Generating hard instances of lattice problems. In &acute; <em>Proceedings of the 28th Annual ACM Symposium on the Theory of Computing</em>, STOC '96, pages 99&ndash;108, 1996.</p></li>
      <li><p class="text-gray-300">[AM93] A. O. L. Atkin and F. Morain. Elliptic curves and primality proving. <em>Mathematics of Computation</em>, 61:29&ndash;68, 1993.</p></li>
      <li><p class="text-gray-300">[AV77] Dana Angluin and Leslie G. Valiant. Fast probabilistic algorithms for hamiltonian circuits and matchings. In <em>Proceedings on 9th Annual ACM Symposium on Theory of Computing</em>, STOC '77, pages 30&ndash;41, 1977.</p></li>
      <li><p class="text-gray-300">[BB04] Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, CRYPTO '04, pages 443&ndash;459, 2004.</p></li>
      <li><p class="text-gray-300">[BBFR15] Michael Backes, Manuel Barbosa, Dario Fiore, and Raphael M. Reischuk. ADSNARK: nearly practical and privacypreserving proofs on authenticated data. In <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>, S&amp;P '15, pages 271&ndash;286, 2015.</p></li>
      <li><p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ITCS '12, pages 326&ndash;349, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 111&ndash;120, 2013.</p></li>
      <li><p class="text-gray-300">[BCGG<sup>+</sup>14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In <em>Proceedings of the 2014 IEEE Symposium on Security and Privacy</em>, SP '14, pages 459&ndash;474, 2014.</p></li>
      <li><p class="text-gray-300">[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In <em>Proceedings of the 4th Innovations in Theoretical Computer Science Conference</em>, ITCS '13, pages 401&ndash;414, 2013.</p></li>
      <li><p class="text-gray-300">[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete efficiency of probabilisticallycheckable proofs. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 585&ndash;594, 2013.</p></li>
      <li><p class="text-gray-300">[BCGTV13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In <em>Proceedings of the 33rd Annual International Cryptology Conference</em>, CRYPTO '13, pages 90&ndash;108, 2013.</p></li>
      <li><p class="text-gray-300">[BCGTV13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. TinyRAM architecture specification v2.00, 2013. URL: <a href="http://scipr-lab.org/tinyram" target="_blank" rel="noopener noreferrer">http://scipr-lab.org/tinyram</a>.</p></li>
      <li><p class="text-gray-300">[BCIOP13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In <em>Proceedings of the 10th Theory of Cryptography Conference</em>, TCC '13, pages 315&ndash;333, 2013.</p></li>
      <li><p class="text-gray-300">[BCP13] Nir Bitansky, Ran Canetti, and Omer Paneth. How to construct extractable one-way functions against uniform adversaries. Cryptology ePrint Archive, Report 2013/468, 2013.</p></li>
      <li><p class="text-gray-300">[BCPR13] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. Indistinguishability obfuscation vs. auxiliary-input extractable functions: One must fall. Cryptology ePrint Archive, Report 2013/641, 2013.</p></li>
      <li><p class="text-gray-300">[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In <em>Proceedings of the 23rd USENIX Security Symposium</em>, Security '14, pages 781&ndash;796, 2014. Available at <a href="http://eprint.iacr.org/2013/879" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2013/879</a>.</p></li>
      <li><p class="text-gray-300">[BDSMP91] Manuel Blum, Alfredo De Santis, Silvio Micali, and Giuseppe Persiano. Non-interactive zero-knowledge. <em>SIAM Journal on Computing</em>, 20(6):1084&ndash;1118, 1991.</p></li>
      <li><p class="text-gray-300">[BEGKN91] Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. Checking the correctness of memories. In <em>Proceedings of the 32nd Annual Symposium on Foundations of Computer Science</em>, FOCS '91, pages 90&ndash;99, 1991.</p></li>
      <li><p class="text-gray-300">[BFLS91] Laszl &acute; o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. &acute; In <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>, STOC '91, pages 21&ndash;32, 1991.</p></li>
      <li><p class="text-gray-300">[BFM88] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications. In <em>Proceedings of the 20th Annual ACM Symposium on Theory of Computing</em>, STOC '88, pages 103&ndash;112, 1988.</p></li>
      <li><p class="text-gray-300">[BFRS<sup>+</sup>13] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Verifying computations with state. In <em>Proceedings of the 25th ACM Symposium on Operating Systems Principles</em>, SOSP '13, pages 341&ndash;357, 2013.</p></li>
      <li><p class="text-gray-300">[BGHSV05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs verifiable in polylogarithmic time. In <em>Proceedings of the 20th Annual IEEE Conference on Computational Complexity</em>, CCC '05, pages 120&ndash;134, 2005.</p></li>
      <li><p class="text-gray-300">[BGOhM07] Paulo S. Barreto, Steven D. Galbraith, Colm O h &acute; Eigeartaigh, and Scott Michael. Efficient pairing computation on &acute; supersingular abelian varieties. <em>Designs, Codes and Cryptography</em>, 42(3):239&ndash;271, 2007.</p></li>
      <li><p class="text-gray-300">[BKLS02] Paulo S. L. M. Barreto, Hae Yong Kim, Ben Lynn, and Michael Scott. Efficient algorithms for pairing-based cryptosystems. In <em>Proceedings of the 22Nd Annual International Cryptology Conference</em>, CRYPTO '02, pages 354&ndash;368, 2002.</p></li>
      <li><p class="text-gray-300">[BLPRS13] Zvika Brakerski, Adeline Langlois, Chris Peikert, Oded Regev, and Damien Stehle. Classical hardness of learning &acute; with errors. In <em>Proceedings of the 45th Annual ACM Symposium on Symposium on Theory of Computing</em>, STOC '13, pages 575&ndash;584, 2013.</p></li>
      <li><p class="text-gray-300">[BLS03] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Constructing elliptic curves with prescribed embedding degrees. In <em>Proceedings of the 3rd International Conference on Security in Communication Networks</em>, SCN '02, pages 257&ndash;267, 2003.</p></li>
      <li><p class="text-gray-300">[BLS04] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. Efficient implementation of pairing-based cryptosystems. <em>Journal of Cryptology</em>, 17(4):321&ndash;334, 2004.</p></li>
      <li><p class="text-gray-300">[BS10] Naomi Benger and Michael Scott. Constructing tower extensions of finite fields for implementation of pairing-based cryptography. In <em>Proceedings of the 3rd International Conference on Arithmetic of Finite Fields</em>, WAIFI '10, pages 180&ndash;195, 2010.</p></li>
      <li><p class="text-gray-300">[BSW12] Dan Boneh, Gil Segev, and Brent Waters. Targeted malleability: Homomorphic encryption for restricted computations. In <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ITCS '12, pages 350&ndash;366, 2012.</p></li>
      <li><p class="text-gray-300">[BW05] Friederike Brezing and Annegret Weng. Elliptic curves suitable for pairing based cryptography. <em>Designs, Codes and Cryptography</em>, 37(1):133&ndash;141, 2005.</p></li>
      <li><p class="text-gray-300">[CFAD<sup>+</sup>12] Henri Cohen, Gerhard Frey, Roberto Avanzi, Christophe Doche, Tanja Lange, Kim Nguyen, and Frederik Vercauteren. <em>Handbook of Elliptic and Hyperelliptic Curve Cryptography</em>. Chapman &amp; Hall/CRC, 2 edition, 2012.</p></li>
      <li><p class="text-gray-300">[CFHK<sup>+</sup>15] Craig Costello, Cedric Fournet, Jon Howell, Markulf Kohlweiss, Benjamin Kreuter, Michael Naehrig, Bryan Parno, &acute; and Samee Zahur. Geppetto: Versatile verifiable computation. In <em>Proceedings of the 36th IEEE Symposium on Security and Privacy</em>, S&amp;P '15, pages 253&ndash;270, 2015.</p></li>
      <li><p class="text-gray-300">[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. Practical verified computation with streaming interactive proofs. In <em>Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science</em>, ITCS '12, pages 90&ndash;112, 2012.</p></li>
      <li><p class="text-gray-300">[CP01] C. Cocks and Richard G. E. Pinch. Identity-based cryptosystems based on the weil pairing. Unpublished manuscript, 2001.</p></li>
      <li><p class="text-gray-300">[CR72] Stephen A. Cook and Robert A. Reckhow. Time-bounded random access machines. In <em>Proceedings of the 4th Annual ACM Symposium on Theory of Computing</em>, STOC '72, pages 73&ndash;80, 1972.</p></li>
      <li><p class="text-gray-300">[CRR11] Ran Canetti, Ben Riva, and Guy N. Rothblum. Practical delegation of computation using multiple servers. In <em>Proceedings of the 18th ACM Conference on Computer and Communications Security</em>, CCS '11, pages 445&ndash;454, 2011.</p></li>
      <li><p class="text-gray-300">[CT10] Alessandro Chiesa and Eran Tromer. Proof-carrying data and hearsay arguments from signature cards. In <em>Proceedings of the 1st Symposium on Innovations in Computer Science</em>, ICS '10, pages 310&ndash;331, 2010.</p></li>
      <li><p class="text-gray-300">[CT12] Alessandro Chiesa and Eran Tromer. Proof-carrying data: Secure computation on untrusted platforms (high-level description). <em>The Next Wave: The National Security Agency's review of emerging technologies</em>, 19(2):40&ndash;46, 2012.</p></li>
      <li><p class="text-gray-300">[CTV13] Stephen Chong, Eran Tromer, and Jeffrey A. Vaughan. Enforcing language semantics using proof-carrying data. Cryptology ePrint Archive, Report 2013/513, 2013.</p></li>
      <li><p class="text-gray-300">[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. Cluster computing in zero knowledge. In <em>Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '15, pages 371&ndash;403, 2015.</p></li>
      <li><p class="text-gray-300">[DEM05] Regis Dupont, Andreas Enge, and Fran &acute; c&cedil;ois Morain. Building curves with arbitrary small MOV degree over finite prime fields. <em>Journal of Cryptology</em>, 18(2):79&ndash;89, 2005.</p></li>
      <li><p class="text-gray-300">[DFGK14] George Danezis, Cedric Fournet, Jens Groth, and Markulf Kohlweiss. Square span programs with applications to &acute; succinct NIZK arguments. In <em>Proceedings of the 20th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '14, pages 532&ndash;550, 2014.</p></li>
      <li><p class="text-gray-300">[ES10] Andreas Enge and Andrew V. Sutherland. Class invariants by the CRT method. In <em>Proceedings of the 9th International Symposium on Algorithmic Number Theory</em>, ANTS '10, pages 142&ndash;156, 2010.</p></li>
      <li><p class="text-gray-300">[FMR06] Gerhard Frey, Michael Muller, and Hans-Georg R &uml; uck. The Tate pairing and the discrete logarithm applied to elliptic &uml; curve cryptosystems. <em>IEEE Transactions on Information Theory</em>, 45(5):1717&ndash;1719, 2006.</p></li>
      <li><p class="text-gray-300">[FR94] Gerhard Frey and Hans-Georg Ruck. A remark concerning m-divisibility and the discrete logarithm in the divisor &uml; class group of curves. <em>Mathematics of Computation</em>, 62(206):865&ndash;874, 1994.</p></li>
      <li><p class="text-gray-300">[FS87] Amos Fiat and Adi Shamir. How to prove yourself: practical solutions to identification and signature problems. In <em>Proceedings of the 6th Annual International Cryptology Conference</em>, CRYPTO '87, pages 186&ndash;194, 1987.</p></li>
      <li><p class="text-gray-300">[FST10] David Freeman, Michael Scott, and Edlyn Teske. A taxonomy of pairing-friendly elliptic curves. <em>Journal of Cryptology</em>, 23(2):224&ndash;280, 2010.</p></li>
      <li><p class="text-gray-300">[Gen04] Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure under concurrent man-in-the-middle attacks. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, CRYPTO '04, pages 220&ndash;236, 2004.</p></li>
      <li><p class="text-gray-300">[GGH96] Oded Goldreich, Shafi Goldwasser, and Shai Halevi. Collision-free hashing from lattice problems. Technical report, 1996. ECCC TR95-042.</p></li>
      <li><p class="text-gray-300">[GGH13] Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear maps from ideal lattices. In <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '13, pages 1&ndash;17, 2013.</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '13, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[GHS02] Steven D. Galbraith, Keith Harrison, and David Soldera. Implementing the Tate pairing. In <em>Proceedings of the 5th International Symposium on Algorithmic Number Theory</em>, ANTS '02, pages 324&ndash;337, 2002.</p></li>
      <li><p class="text-gray-300">[GLS09] Parikshit Gopalan, Shachar Lovett, and Amir Shpilka. On the complexity of boolean functions in different characteristics. In <em>Proceedings of the 24th Annual IEEE Conference on Computational Complexity</em>, CCC '09, pages 173&ndash;183, 2009.</p></li>
      <li><p class="text-gray-300">[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '10, pages 321&ndash;340, 2010.</p></li>
      <li><p class="text-gray-300">[GS06] R. Granger and Nigel Smart. On computing products of pairings. Cryptology ePrint Archive, Report 2006/172, 2006.</p></li>
      <li><p class="text-gray-300">[GS10] Robert Granger and Michael Scott. Faster squaring in the cyclotomic subgroup of sixth degree extensions. In <em>Proceedings of the 13th international conference on Practice and Theory in Public Key Cryptography</em>, PKC'10, pages 209&ndash;223, 2010.</p></li>
      <li><p class="text-gray-300">[GSCvDD03] Blaise Gassend, G. Edward Suh, Dwaine E. Clarke, Marten van Dijk, and Srinivas Devadas. Caches and hash trees for efficient memory integrity verification. In <em>Proceedings of the 9th International Symposium on High-Performance Computer Architecture</em>, HPCA '03, pages 295&ndash;306, 2003.</p></li>
      <li><p class="text-gray-300">[GSMB03] Eu-Jin Goh, Hovav Shacham, Nagendra Modadugu, and Dan Boneh. SiRiUS: Securing remote untrusted storage. In <em>Proceedings of the Network and Distributed System Security Symposium</em>, NDSS '03, 2003.</p></li>
      <li><p class="text-gray-300">[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In <em>Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</em>, STOC '11, pages 99&ndash;108, 2011.</p></li>
      <li><p class="text-gray-300">[HSV06] F. Hess, N. P. Smart, and F. Vercauteren. The Eta pairing revisited. <em>IEEE Transactions on Information Theory</em>, 52(10):4595&ndash;4602, 2006.</p></li>
      <li><p class="text-gray-300">[JJ98] Antoine Joux and Stern Jacques. Lattice reduction: A toolbox for the cryptanalyst. <em>Journal of Cryptology</em>, 11(3):161&ndash; 185, 1998.</p></li>
      <li><p class="text-gray-300">[KKC13] Taechan Kim, Sungwook Kim, and Jung Hee Cheon. On the final exponentiation in Tate pairing computations. <em>IEEE Transactions on Information Theory</em>, 59(6):4033&ndash;4041, 2013.</p></li>
      <li><p class="text-gray-300">[KPPS<sup>+</sup>14] Ahmed E. Kosba, Dimitrios Papadopoulos, Charalampos Papamanthou, Mahmoud F. Sayed, Elaine Shi, and Nikos Triandopoulos. TRUESET: Faster verifiable set computations. In <em>Proceedings of the 23rd USENIX Security Symposium</em>, USENIX Security '14, pages 765&ndash;780, 2014.</p></li>
      <li><p class="text-gray-300">[KRSWF03] Mahesh Kallahalla, Erik Riedel, Ram Swaminathan, Qian Wang, and Kevin Fu. Plutus: Scalable secure file sharing on untrusted storage. In <em>Proceedings of the 2003 Conference on File and Storage Technologies</em>, FAST '03, 2003.</p></li>
      <li><p class="text-gray-300">[KT08] Koray Karabina and Edlyn Teske. On prime-order elliptic curves with embedding degrees k = 3, 4, and 6. In <em>Proceedings of the 8th International Conference on Algorithmic Number Theory</em>, ANTS-VIII '08, pages 102&ndash;117, 2008.</p></li>
      <li><p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography</em>, TCC '12, pages 169&ndash;189, 2012.</p></li>
      <li><p class="text-gray-300">[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. In <em>Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '13, pages 41&ndash;60, 2013.</p></li>
      <li><p class="text-gray-300">[Lip14] Helger Lipmaa. Efficient NIZK arguments via parallel verification of Benes networks. In &#711; <em>Proceedings of the 9th International Conference on Security and Cryptography for Networks</em>, SCN '14, pages 416&ndash;434, 2014.</p></li>
      <li><p class="text-gray-300">[LM06] Vadim Lyubashevsky and Daniele Micciancio. Generalized compact knapsacks are collision resistant. In <em>Proceedings of the 33rd International Conference on Automata, Languages and Programming</em>, ICALP '06, pages 144&ndash;155, 2006.</p></li>
      <li><p class="text-gray-300">[LMN10] Kristin Lauter, Peter L. Montgomery, and Michael Naehrig. An analysis of affine coordinates for pairing computation. In <em>Proceedings of the 4th International Conference on Pairing-based Cryptography</em>, Pairing '10, pages 1&ndash;20, 2010.</p></li>
      <li><p class="text-gray-300">[LMPR08] Vadim Lyubashevsky, Daniele Micciancio, Chris Peikert, and Alon Rosen. SWIFFT: a modest proposal for FFT hashing. In <em>Proceedings of the 15th International Workshop on Fast Software Encryption</em>, FSE '08, pages 54&ndash;72, 2008.</p></li>
      <li><p class="text-gray-300">[LN97] Rudolf Lidl and Harald Niederreiter. <em>Finite Fields</em>. Cambridge University Press, second edition edition, 1997.</p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. Computationally sound proofs. <em>SIAM Journal on Computing</em>, 30(4):1253&ndash;1298, 2000. Preliminary version appeared in FOCS '94.</p></li>
      <li><p class="text-gray-300">[MNT01] Atsuko Miyaji, Masaki Nakabayashi, and Shunzo Takano. New explicit conditions of elliptic curve traces for FR-reduction. <em>IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences</em>, 84(5):1234&ndash;1243, 2001.</p></li>
      <li><p class="text-gray-300">[MOV91] Alfred Menezes, Tatsuaki Okamoto, and Scott Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. In <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>, STOC '91, pages 80&ndash;89, 1991.</p></li>
      <li><p class="text-gray-300">[MS01] David Mazieres and Dennis Shasha. Don't trust your file server. In \` <em>Proceedings of the 8th Workshop on Hot Topics in Operating Systems</em>, HotOS '01, pages 113&ndash;118, 2001.</p></li>
      <li><p class="text-gray-300">[MVS00] Umesh Maheshwari, Radek Vingralek, and William Shapiro. How to build a trusted database system on untrusted storage. In <em>Proceedings of the 4th Conference on Symposium on Operating System Design &amp; Implementation</em>, OSDI '00, pages 10&ndash;10, 2000.</p></li>
      <li><p class="text-gray-300">[NY89] Moni Naor and Moti Yung. Universal one-way hash functions and their cryptographic applications. In <em>Proceedings of the 21st Annual ACM Symposium on Theory of Computing</em>, STOC '89, pages 33&ndash;43, 1989.</p></li>
      <li><p class="text-gray-300">[NY90] Moni Naor and Moti Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In <em>Proceedings of the 22nd Annual ACM Symposium on Theory of Computing</em>, STOC '90, pages 427&ndash;437, 1990.</p></li>
      <li><p class="text-gray-300">[Odl85] Andrew M. Odlyzko. Discrete logarithms in finite fields and their cryptographic significance. In <em>Proceedings of the 3rd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '85, pages 224&ndash;314, 1985.</p></li>
      <li><p class="text-gray-300">[PGHR13] Brian Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>Proceedings of the 34th IEEE Symposium on Security and Privacy</em>, Oakland '13, pages 238&ndash;252, 2013.</p></li>
      <li><p class="text-gray-300">[PH78] Stephen Pohlig and Martin Hellman. An improved algorithm for computing logarithms over gf(p) and its cryptographic significance. <em>Journal IEEE Transactions on Information Theory</em>, 24(1):106&ndash;110, 1978.</p></li>
      <li><p class="text-gray-300">[Pol78] John M. Pollard. Monte Carlo methods for index computation (mod p). <em>Mathematics of Computation</em>, 32(143):918&ndash; 924, 1978.</p></li>
      <li><p class="text-gray-300">[Pol00] John M. Pollard. Kangaroos, monopoly and discrete logarithms. <em>Journal of Cryptology</em>, 13:437&ndash;447, 2000.</p></li>
      <li><p class="text-gray-300">[PR06] Chris Peikert and Alon Rosen. Efficient collision-resistant hashing from worst-case assumptions on cyclic lattices. In <em>Proceedings of the 3rd Conference on Theory of Cryptography</em>, TCC '06, pages 145&ndash;166, 2006.</p></li>
      <li><p class="text-gray-300">[Raz87] Alexander A. Razborov. Lower bounds on the size of bounded depth circuits over a complete basis with logical addition. <em>Mathematical notes of the Academy of Sciences of the USSR</em>, 41(4):333&ndash;338, 1987.</p></li>
      <li><p class="text-gray-300">[Rom90] John Rompel. One-way functions are necessary and sufficient for secure signatures. In <em>Proceedings of the 22nd Annual ACM Symposium on Theory of Computing</em>, STOC '90, pages 387&ndash;394, 1990.</p></li>
      <li><p class="text-gray-300">[SA98] Takakazu Satoh and Kiyomichi Araki. Fermat quotients and the polynomial time discrete log algorithm for anomalous elliptic curves. <em>Commentarii Mathematici Universitatis Sancti Pauli</em>, 47(1):81&ndash;92, 1998.</p></li>
      <li><p class="text-gray-300">[SB06] Michael Scott and Paulo S. Barreto. Generating more MNT elliptic curves. <em>Designs, Codes and Cryptography</em>, 38(2):209&ndash;217, 2006.</p></li>
      <li><p class="text-gray-300">[SBCDPK09] Michael Scott, Naomi Benger, Manuel Charlemagne, Luis J. Dominguez Perez, and Ezekiel J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. In <em>Proceedings of the 3rd International Conference Palo Alto on Pairing-Based Cryptography</em>, Pairing '09, pages 78&ndash;88, 2009.</p></li>
      <li><p class="text-gray-300">[SBVB<sup>+</sup>13] Srinath Setty, Benjamin Braun, Victor Vu, Andrew J. Blumberg, Bryan Parno, and Michael Walfish. Resolving the conflict between generality and plausibility in verified computation. In <em>Proceedings of the 8th EuoroSys Conference</em>, EuroSys '13, pages 71&ndash;84, 2013.</p></li>
      <li><p class="text-gray-300">[SBW11] Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Toward practical and unconditional verification of remote computations. In <em>Proceedings of the 13th USENIX Conference on Hot Topics in Operating Systems</em>, HotOS '11, pages 29&ndash;29, 2011.</p></li>
      <li><p class="text-gray-300">[Sco05] Michael Scott. Computing the Tate pairing. In <em>Proceedings of the The Cryptographers' Track at the RSA Conference 2005</em>, CT-RSA '05, pages 293&ndash;304, 2005.</p></li>
      <li><p class="text-gray-300">[Sco07] Michael Scott. Implementing cryptographic pairings. In <em>Proceedings of the 1st First International Conference on Pairing-Based Cryptography</em>, Pairing '07, pages 177&ndash;196, 2007.</p></li>
      <li><p class="text-gray-300">[Sem98] Igor A. Semaev. Evaluation of discrete logarithms in a group of p-torsion points of an elliptic curve in characteristic p. <em>Mathematics of Computation</em>, 67(221):353&ndash;356, 1998.</p></li>
      <li><p class="text-gray-300">[Sha71] Daniel Shanks. Class number, a theory of factorization, and genera. <em>Symposia on Pure Mathematics</em>, 20:415&ndash;440, 1971.</p></li>
      <li><p class="text-gray-300">[Sil09] Joseph H. Silverman. <em>The Arithmetic of Elliptic Curves</em>. Springer, 2 edition, 2009.</p></li>
      <li><p class="text-gray-300">[Sma99] Nigel P. Smart. The discrete logarithm problem on elliptic curves of trace one. <em>Journal of Cryptology</em>, 12(3):193&ndash;196, 1999.</p></li>
      <li><p class="text-gray-300">[SMBW12] Srinath Setty, Michael McPherson, Andrew J. Blumberg, and Michael Walfish. Making argument systems for outsourced computation practical (sometimes). In <em>Proceedings of the 2012 Network and Distributed System Security Symposium</em>, NDSS '12, 2012.</p></li>
      <li><p class="text-gray-300">[Smo87] Roman Smolensky. Algebraic methods in the theory of lower bounds for boolean circuit complexity. In <em>Proceedings of the 19th Annual ACM Symposium on Theory of Computing</em>, STOC '87, pages 77&ndash;82, 1987.</p></li>
      <li><p class="text-gray-300">[Sol03] Jerome A. Solinas. Id-based digital signature algorithms. <a href="http://cacr.uwaterloo.ca/conferences/2003/ecc2003/solinas.pdf" target="_blank" rel="noopener noreferrer">http://cacr.uwaterloo.ca/conferences/</a> <a href="http://cacr.uwaterloo.ca/conferences/2003/ecc2003/solinas.pdf" target="_blank" rel="noopener noreferrer">2003/ecc2003/solinas.pdf</a>, 2003.</p></li>
      <li><p class="text-gray-300">[SS11] Joseph H. Silverman and Katherine E. Stange. Amicable pairs and aliquot cycles for elliptic curves. <em>Experimental Mathematics</em>, 20(3):329&ndash;357, 2011.</p></li>
      <li><p class="text-gray-300">[Sut11] Andrew V. Sutherland. Computing Hilbert class polynomials with the Chinese remainder theorem. <em>Mathematics of Computation</em>, 80(273):501&ndash;538, 2011.</p></li>
      <li><p class="text-gray-300">[Sut12] Andrew V. Sutherland. Accelerating the CM method. <em>LMS Journal of Computation and Mathematics</em>, 15:172&ndash;204, 12 2012.</p></li>
      <li><p class="text-gray-300">[SVPB<sup>+</sup>12] Srinath Setty, Victor Vu, Nikhil Panpalia, Benjamin Braun, Andrew J. Blumberg, and Michael Walfish. Taking proof-based verified computation a few steps closer to practicality. In <em>Proceedings of the 21st USENIX Security Symposium</em>, Security '12, pages 253&ndash;268, 2012.</p></li>
      <li><p class="text-gray-300">[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In <em>Proceedings of the 33rd Annual International Cryptology Conference</em>, CRYPTO '13, pages 71&ndash;89, 2013.</p></li>
      <li><p class="text-gray-300">[TRMP12] Justin Thaler, Mike Roberts, Michael Mitzenmacher, and Hanspeter Pfister. Verifiable computation with massively parallel interactive proofs. <em>CoRR</em>, abs/1202.1350, 2012.</p></li>
      <li><p class="text-gray-300">[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In <em>Proceedings of the 5th Theory of Cryptography Conference</em>, TCC '08, pages 1&ndash;18, 2008.</p></li>
      <li><p class="text-gray-300">[Ver10] Frederik Vercauteren. Optimal pairings. <em>IEEE Transactions on Information Theory</em>, 56(1):455&ndash;461, 2010.</p></li>
      <li><p class="text-gray-300">[vOW99] Paul C. van Oorschot and Michael J. Wiener. Parallel collision search with cryptanalytic applications. <em>Journal of Cryptology</em>, 12(1):1&ndash;28, 1999.</p></li>
      <li><p class="text-gray-300">[Was08] Lawrence C. Washington. <em>Elliptic Curves: Number Theory and Cryptography</em>. Chapman &amp; Hall/CRC, 2 edition, 2008.</p></li>
      <li><p class="text-gray-300">[WSRBW15] Riad S. Wahby, Srinath Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. Efficient RAM and control flow in verifiable outsourced computation. In <em>Proceedings of the 22nd Network and Distributed System Security Symposium</em>, NDSS '15, 2015.</p></li>
      <li><p class="text-gray-300">[ZPK14] Yupeng Zhang, Charalampos Papamanthou, and Jonathan Katz. Alitheia: Towards practical verifiable graph processing. In <em>Proceedings of the 21st ACM Conference on Computer and Communications Security</em>, CCS '14, pages 856&ndash;867, 2014.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Scalable Zero Knowledge via Cycles of Elliptic Curves (2014/595)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/595
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Scalability limitations of prior zk-SNARK implementations</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">What we know from theory</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Contributions</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Summary of challenges and techniques</a></li>
            <li><a href="#sec-1.4.1" class="hover:text-white">Challenge: how to efficiently &quot;close the loop&quot;?</a></li>
            <li><a href="#sec-1.4.2" class="hover:text-white">Challenge: how to efficiently verify collision-resistant hashing?</a></li>
            <li><a href="#sec-1.5" class="hover:text-white">Follow-up work</a></li>
            <li><a href="#sec-1.6" class="hover:text-white">Roadmap</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Preprocessing zk-SNARKs for arithmetic circuits</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Proof-carrying data</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">The bootstrapping approach</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">PCD-friendly preprocessing zk-SNARKs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">PCD-friendly cycles of elliptic curves</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Two-cycles based on MNT curves</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">A matched pair of preprocessing zk-SNARKs</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">A higher-security 2-cycle</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Proof-carrying data from PCD-friendly zk-SNARKs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Intuition</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Security</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Constructions of arithmetic circuits</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Arithmetic circuits for zk-SNARK verifiers</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Arithmetic circuits for collision-resistant hashing</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Scalable zk-SNARKs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Specifying a machine</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Construction summary</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">Arithmetic circuits for secure loads and stores</a></li>
            <li><a href="#sec-6.4" class="hover:text-white">The RAM compliance predicate</a></li>
            <li><a href="#sec-6.5" class="hover:text-white">The new zk-SNARK construction</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">Evaluation on vnTinyRAM</a></li>
        <li><a href="#sec-8" class="hover:text-white">Open problems</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Computation models</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Arithmetic circuits</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Random-access machines</a></li>
            <li><a href="#app-a.3" class="hover:text-white">The architecture vnTinyRAM</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-b" class="hover:text-white">Pairings and elliptic curves</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Pairings</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Elliptic curves</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-c" class="hover:text-white">Preprocessing zk-SNARKs for arithmetic circuit satisfiability</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Known constructions and security</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Instantiations via elliptic curves</a></li>
            <li><a href="#app-c.3" class="hover:text-white">The zk-SNARK verifier protocol</a></li>
          </ol>
        </li>
        <li><a href="#app-d" class="hover:text-white">Proof-carrying data for arithmetic compliance predicates</a></li>
        <li>
          <a href="#app-e" class="hover:text-white">Scalable zk-SNARKs for random-access machines</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-e.1" class="hover:text-white">Known constructions and security</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="scalable-zero-knowledge-via-cycles-of-elliptic-curves-2014" />
  </article>
</BaseLayout>
