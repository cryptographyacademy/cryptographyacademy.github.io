---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/332';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A depth-16 circuit for the AES S-box';
const AUTHORS_HTML = 'Joan Boyar, Rene Peralta';

const CONTENT = `    <p class="text-gray-300">A depth-16 circuit for the AES S-box</p>

    <p class="text-gray-300">Joan Boyar* joan@imada.sdu.dk René Peralta† peralta@nist.gov</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">New techniques for reducing the depth of circuits for cryptographic applications are described and applied to the AES S-box. These techniques also keep the number of gates quite small. The result, when applied to the AES S-box, is a circuit with depth 16 and only 128 gates. For the inverse, it is also depth 16 and has only 127 gates. There is a shared middle part, common to both the S-box and its inverse, consisting of 63 gates.</p>

    <p class="text-gray-300">Keywords: AES; S-box; finite field inversion; circuit complexity; circuit depth.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Constructing optimal combinational circuits is an intractable problem under almost any meaningful metric (gate count, depth, energy consumption, etc.). In practice, no known techniques can reliably find optimal circuits for functions with as few as eight Boolean inputs and one Boolean output (there are <span class="math">2^{256}</span> such functions). Thus, heuristic or specialized techniques are necessary in practice.</p>

    <p class="text-gray-300">Recently, Nogami et.al. [10] presented a technique for reducing circuit depth in the forward direction of the AES S-box. Their technique was primarily to choose mixed bases for the tower-of-fields architecture in such a way that the matrices doing the linear transformations at the top and bottom had at most 4 ones in every row. In this way they were able to compute these transformations in depth 2 each, for a total of depth 4. Their technique cannot be simultaneously applied to the AES circuit in the reverse direction, as the inverse matrices do not have at most 4 ones in every row. We present more general techniques that are less dependent on the actual representation of the fields. These techniques allow us to produce circuits which are both smaller and shorter in both directions. Although the size of our construction is larger than the one reported in [1], which had only 115 gates, it is comparable to previous efforts to make a compact circuit (see [3, 8]). The latter two constructions have depths between 25 and 27. Nogami et. al. improved this, for the forward direction of the S-Box, to depth 22 at the cost of increasing size to 148. Our new circuits have depth 16 in both directions, size 128 in the forward direction, and size 127 in the reverse direction. The part that is shared between the forward and reverse directions is of size 63.</p>

    <p class="text-gray-300">*Department of Mathematics and Computer Science, University of Southern Denmark. Partially supported by the Danish Natural Science Research Council (SNF). Some of this work was done while visiting the University of California, Irvine. †Information Technology Laboratory, National Institute of Standards and Technology.</p>

    <p class="text-gray-300">2 Combinational circuit optimization</p>

    <p class="text-gray-300">Many different logically complete bases are possible for circuits. Since the operations in the basis (XOR, AND) are equivalent to addition and multiplication modulo 2 (i.e., in <span class="math">GF(2)</span>), much work on circuits for cryptographic functions uses this basis. For logical completeness, the negation operation (or the constant 1) is needed as well. In <span class="math">GF(2)</span>, negation corresponds to <span class="math">x+1</span>. For technical reasons, and for an accurate gate-count, we use XNOR gates (<span class="math">XNOR(x,y)=x+y+1</span> in <span class="math">GF(2)</span>) instead of negation. Components free of AND gates are called linear; our emphasis is on these components, though nonlinear components are also optimized.</p>

    <p class="text-gray-300">Under the basis (XOR,XNOR,AND), classic results by Shannon <em>[12]</em> and Lupanov <em>[7]</em> show that almost all predicates on <span class="math">n</span> bits have circuit complexity about <span class="math">\\frac{2^{n}}{n}</span>. The multiplicative complexity of a function is the number of AND gates necessary and sufficient to compute the function. Analogous to the Shannon-Lupanov bound, it was shown in <em>[2]</em> that almost all Boolean predicates on <span class="math">n</span> bits have multiplicative complexity about <span class="math">2^{\\frac{n}{2}}</span>. Strictly speaking, these theorems say nothing about the class of functions with polynomial circuit complexity. However, it is reasonable to expect that, in practice, the multiplicative complexity of functions is significantly smaller than their Boolean complexity. This is one of the principles that guide our design strategy.</p>

    <p class="text-gray-300">Circuits with few AND gates will naturally have large sections which are purely linear. Boyar and Peralta <em>[1]</em> have used this insight to construct circuits much smaller than previously known for a variety of applications (see http://cs-www.cs.yale.edu/homes/peralta/CircuitStuff/CMT.). The heuristic is a two-step process which first reduces multiplicative complexity and then optimizes linear components.</p>

    <p class="text-gray-300">The work presented in this paper is based on the idea that a short circuit may be obtained by starting from a small (i.e. optimized for size) circuit and performing three types of depth-decreasing optimizations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>apply a greedy heuristic to re-synthesize linear components into lower-depth constructions;</li>

      <li>use techniques from automatic theorem proving to re-synthesize non-linear components into lower-depth constructions;</li>

      <li>do simple depth-shortening local replacement along critical paths.</li>

    </ul>

    <p class="text-gray-300">As these steps are automatic heuristics that do not consider size, we also coded a final step that reduces size via depth-preserving local replacement. These techniques are explained below. They will often increase the size of the circuit, but we start with a small circuit and the techniques are designed to minimize the increase.</p>

    <h2 id="sec-1" class="text-2xl font-bold">3 The tower field construction</h2>

    <p class="text-gray-300">There are many representations of <span class="math">GF(2^{8})</span>. We construct</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">GF(2^{2})</span> by adjoining a root <span class="math">W</span> of <span class="math">x^{2}+x+1</span> over <span class="math">GF(2)</span>;</li>

      <li><span class="math">GF(2^{4})</span> by adjoining a root <span class="math">Z</span> of <span class="math">x^{2}+x+W^{2}</span> over <span class="math">GF(2^{2})</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">GF(2^{8})</span> by adjoining a root <span class="math">Y</span> of <span class="math">x^{2}+x+WZ</span> over <span class="math">GF(2^{4})</span>.</li>

    </ul>

    <p class="text-gray-300">As does Canright in <em>[3]</em>, we represent <span class="math">GF(2^{2})</span> using the basis <span class="math">(W,W^{2})</span>, <span class="math">GF(2^{4})</span> using the basis <span class="math">(Z^{2},Z^{8})</span>, and <span class="math">GF(2^{8})</span> using the basis <span class="math">(Y,Y^{16})</span>.</p>

    <p class="text-gray-300">Let <span class="math">A=a_{0}Y+a_{1}Y^{16}</span> be an arbitrary element in <span class="math">GF(2^{8})</span>. Following <em>[6]</em>, the inverse of <span class="math">A</span> can be computed as follows:</p>

    <p class="text-gray-300"><span class="math">A^{-1}</span> <span class="math">=</span> <span class="math">(AA^{16})^{-1}A^{16}</span> <span class="math">=</span> <span class="math">((a_{0}Y+a_{1}Y^{16})(a_{1}Y+a_{0}Y^{16}))^{-1}(a_{1}Y+a_{0}Y^{16})</span> <span class="math">=</span> <span class="math">((a_{0}^{2}+a_{1}^{2})Y^{17}+a_{0}a_{1}(Y^{2}+Y^{32}))^{-1}(a_{1}Y+a_{0}Y^{16})</span> <span class="math">=</span> <span class="math">((a_{0}+a_{1})^{2}Y^{17}+a_{0}a_{1}(Y+Y^{16})^{2})^{-1}(a_{1}Y+a_{0}Y^{16})</span> <span class="math">=</span> <span class="math">((a_{0}+a_{1})^{2}WZ+a_{0}a_{1})^{-1}(a_{1}Y+a_{0}Y^{16}).</span></p>

    <p class="text-gray-300">Thus computation of the inverse in <span class="math">GF(2^{8})</span> can be done using operations in <span class="math">GF(2^{4})</span> as follows:</p>

    <p class="text-gray-300"><span class="math">T_{1}</span> <span class="math">=</span> <span class="math">(a_{0}+a_{1})</span> <span class="math">T_{2}</span> <span class="math">=</span> <span class="math">(WZ)T_{1}^{2}</span> <span class="math">T_{3}</span> <span class="math">=</span> <span class="math">a_{0}a_{1}</span> <span class="math">T_{4}</span> <span class="math">=</span> <span class="math">T_{2}+T_{3}</span> <span class="math">T_{5}</span> <span class="math">=</span> <span class="math">T_{4}^{-1}</span> <span class="math">T_{6}</span> <span class="math">=</span> <span class="math">T_{5}a_{1}</span> <span class="math">T_{7}</span> <span class="math">=</span> <span class="math">T_{5}a_{0}</span></p>

    <p class="text-gray-300">The result is <span class="math">A^{-1}=T_{6}Y+T_{7}Y^{16}</span>.</p>

    <p class="text-gray-300">The <span class="math">GF(2^{4})</span> operations involved are addition, multiplication, square and scale by WZ, and inverse. Of these, only multiplication and inverse turn out to be non-linear. We derive a standard <span class="math">GF(2^{4})</span> multiplication circuit by reduction to <span class="math">GF(2^{2})</span> operations. The standard inversion circuit, however, has more gates and depth than necessary. Hence we derive a better circuit here.</p>

    <p class="text-gray-300">Let <span class="math">\\Delta=(x_{1}W+x_{2}W^{2})Z^{2}+(x_{3}W+x_{4}W^{2})Z^{8}</span> be an arbitrary element in <span class="math">GF(2^{4})</span>. It is not hard to verify that its inverse is <span class="math">\\Delta^{-1}=(y_{1}W+y_{2}W^{2})Z^{2}+(y_{3}W+y_{4}W^{2})Z^{8}</span> where the <span class="math">y_{i}</span>’s satisfy the following polynomials over <span class="math">GF(2)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">y_{1}=x_{2}x_{3}x_{4}+x_{1}x_{3}+x_{2}x_{3}+x_{3}+x_{4}</span></li>

      <li><span class="math">y_{2}=x_{1}x_{3}x_{4}+x_{1}x_{3}+x_{2}x_{3}+x_{2}x_{4}+x_{4}</span></li>

      <li><span class="math">y_{3}=x_{1}x_{2}x_{4}+x_{1}x_{3}+x_{1}x_{4}+x_{1}+x_{2}</span></li>

      <li><span class="math">y_{4}=x_{1}x_{2}x_{3}+x_{1}x_{3}+x_{1}x_{4}+x_{2}x_{4}+x_{2}</span></li>

    </ul>

    <p class="text-gray-300">The heuristic Boyar and Peralta used in <em>[1]</em> to compute the <span class="math">y_{i}</span>’s was inspired by methods from automatic theorem proving. Consider an arbitrary predicate <span class="math">f</span> on <span class="math">n</span> inputs. We refer to the last column of the truth table for <span class="math">f</span> as the signal of <span class="math">f</span>. The columns in the truth table corresponding to each of the inputs to <span class="math">f</span> are known signals. A search for a circuit for <span class="math">f</span> starts</p>

    <p class="text-gray-300">with this set  <span class="math">S</span>  of known signals. If  <span class="math">u, v</span>  are known signals for functions  <span class="math">g, h</span>  respectively, then the bit-wise XOR (AND) of  <span class="math">u</span>  and  <span class="math">v</span>  is the signal for the predicate  <span class="math">g \\oplus h</span>  ( <span class="math">g \\wedge h</span> ). We can grow the set  <span class="math">S</span>  by adding the XOR of randomly chosen signals. We call this step an XOR round. The analogous step where the AND of signals is added to  <span class="math">S</span>  is called an AND round. Each round is parameterized by the number of new signals added and the maximum number of AND gates allowed. In either an XOR round or an AND round, two signals are not combined if doing so creates a circuit with more AND gates than is allowed. The heuristic alternates between XOR and AND rounds until the target signal is found or the set  <span class="math">S</span>  becomes too large. In the latter case, since this is a randomized procedure, we start again.</p>

    <p class="text-gray-300">Boyar and Peralta [1] used this heuristic to find a circuit with only 5 AND gates and 11 XOR gates, but depth 9. In terms of size, this was a significant improvement over previous constructions. None of these constructions, however, was concerned with depth. To minimize depth, we used a different parametrization of these techniques and found a circuit with depth 4 and size 17. The straight-line program for the circuit is in Figure 1 (arithmetic is over  <span class="math">GF(2)</span> ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t1 = x2 + x3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t2 = x2 × x0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t3 = x1 + t2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t4 = x0 + x1</td>

            <td class="px-3 py-2 border-b border-gray-700">t5 = x3 + t2</td>

            <td class="px-3 py-2 border-b border-gray-700">t6 = t5 × t4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t7 = t3 × t1</td>

            <td class="px-3 py-2 border-b border-gray-700">t8 = x0 × x3</td>

            <td class="px-3 py-2 border-b border-gray-700">t9 = t4 × t8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t10 = t4 + t9</td>

            <td class="px-3 py-2 border-b border-gray-700">t11 = x1 × x2</td>

            <td class="px-3 py-2 border-b border-gray-700">t12 = t1 × t11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t13 = t1 + t12</td>

            <td class="px-3 py-2 border-b border-gray-700">y0 = t2 + t13</td>

            <td class="px-3 py-2 border-b border-gray-700">y1 = x3 + t7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y2 = t2 + t10</td>

            <td class="px-3 py-2 border-b border-gray-700">y3 = x1 + t6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Inversion in  <span class="math">GF(2^4)</span> . Input is  <span class="math">(x_0, x_1, x_2, x_3)</span>  and output is  <span class="math">(y_0, y_1, y_2, y_3)</span> .</p>

    <p class="text-gray-300">The largest linear components in our circuit are the top linear and bottom linear components. These components contain more than the linear operations defined explicitly in the definition of the AES S-box and the matrices to do the basis changes. This is because they include some of the finite field inversion operations. The top linear component is defined by the matrix  <span class="math">U</span> , a  <span class="math">22 \\times 8</span>  matrix (Figure 2). One can compute all 22 of the required outputs with only 23 XOR gates, and 23 are necessary [1, 5, 4]. But these results do not attempt to minimize depth (the depth is 7). Since there are only 8 columns in this matrix, each of the 22 outputs could clearly be calculated independently using depth at most 3, simply by using a balanced binary tree with the inputs as leaves. The challenge is to achieve the low depth without increasing the number of XOR gates drastically. The algorithm below does this. (Note that although the linear transformation at the top of Nogami et.al.'s circuit only has depth 2, they have XOR gates at depth 3, so their top linear component also has depth at least 3.)</p>

    <p class="text-gray-300">The bottom linear component is defined by the matrix  <span class="math">B</span> , an  <span class="math">8 \\times 18</span>  matrix (Figure 3). The row with the largest Hamming weight (number of ones = number of variables added together) has 12 ones, so depth at most 4 is possible for this component.</p>

    <p class="text-gray-300">The smallest circuits for these two matrices,  <span class="math">U</span>  and  <span class="math">B</span> , use the concept of cancellation</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: The top linear transformation  <span class="math">U</span> . Figure 3: The bottom linear transformation  <span class="math">B</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">of variables. Note that in <em>[1]</em>, the variable <span class="math">y_{11}</span> is computed as <span class="math">y_{20}\\oplus y_{9}</span>. Since <span class="math">y_{20}=x_{0}\\oplus x_{1}\\oplus x_{3}\\oplus x_{4}\\oplus x_{5}\\oplus x_{6}</span> and <span class="math">y_{9}=x_{0}\\oplus x_{3}</span>, the result is <span class="math">y_{11}=x_{1}\\oplus x_{4}\\oplus x_{5}\\oplus x_{6}</span>; the <span class="math">x_{0}</span> and <span class="math">x_{3}</span> are cancelled.</p>

    <p class="text-gray-300">When attempting to find small, low-depth circuits for a linear component, one expects that cancellation of variables will be of limited help, since it would often require that something with a large Hamming weight has already been computed, before adding one to the depth at the gate where the cancellation occurs. Thus, it seems reasonable to start with a technique which does not allow cancellation, and then try to add cancellation afterwards where it helps.</p>

    <p class="text-gray-300">We modify Paar’s technique <em>[11]</em>, a greedy approach which produces cancellation-free programs. Paar’s technique keeps a list of variables computed, which is initially only the inputs. Then it repeatedly determines which two variables, XORed together, occur in most outputs. One such pair is selected and XORed together. This result is added as a new variable which appears in all outputs where both variables previously appeared. This is repeated until everything has been computed. Paar’s technique is implemented by starting with the initial matrix and adding columns corresponding to the new variables which are added. When a new column is added, this corresponds to adding two variables, <span class="math">u</span> and <span class="math">v</span>. In all rows in the matrix which currently have a one in both of the columns corresponding to <span class="math">u</span> and <span class="math">v</span>, those two ones are changed to zeros, and a one is placed in the corresponding row of the new column. All other values in the new column are set to zero.</p>

    <p class="text-gray-300">The Low_Depth_Greedy algorithm maintains the greedy approach of Paar’s technique, but only allows this greediness as long as it does not increase the circuit’s depth unnecessarily. Assume that <span class="math">k</span> is the depth we are aiming for, i.e. <span class="math">k=\\lceil\\log_{2}(w)\\rceil</span>, where <span class="math">w</span> is the largest Hamming weight of any row. The Low_Depth_Greedy algorithm has <span class="math">k</span> phases, starting with <span class="math">0</span>. At the beginning of a new phase, we check if any row has Hamming weight two. Since there must be an additional gate to produce that output, we produce it at the beginning of the phase so that it affects all counting in the current phase. During phase <span class="math">i\\geq 0</span>, no row in the current matrix has Hamming weight more than <span class="math">2^{k-i}</span> and only inputs or gates already produced at depth <span class="math">i</span> or less are considered as possible inputs to gates in phase <span class="math">i</span>. Thus, the depth of gates in phase <span class="math">i</span> is at most <span class="math">i+1</span>. When choosing two possible inputs for gates, one chooses a pair which occurs most frequently in the current rows, with the restriction, of course, that both inputs are at level <span class="math">i</span> or less. Pseudo-code for this algorithm is given in Figure 4.</p>

    <p class="text-gray-300">This algorithm produces a minimum depth (optimal depth) circuit.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">When given an <span class="math">m\\times n</span> 0-1 matrix, <span class="math">M</span>, with maximum Hamming weight at most <span class="math">2^{k}</span> in any row, Algorithm Low_Depth_Greedy, produces a correct, depth-<span class="math">k</span> circuit for computing the linear component defined by the matrix. The running time is <span class="math">O(mt^{3})</span>, where <span class="math">t</span> is the final number of columns and is at most <span class="math">mn+n-m</span>.</p>

    <p class="text-gray-300">Proof. If one considers the inputs as being produced at depth zero, in phase <span class="math">i</span> of the algorithm, only variables which have been produced at depth at most <span class="math">i</span> are considered as possible inputs to XOR gates, so the XOR gates produced have depth at most <span class="math">i+1</span>. This is maintained inductively by only considering columns between <span class="math">1</span> and <span class="math">ip</span>, and <span class="math">ip</span> is reset at the end of each phase to the last column produced in that phase. Since the algorithm maintains that at the beginning of phase <span class="math">i</span>, no more than <span class="math">2^{k-i}</span> of the current variables have to be XORed to produce any output, the algorithm terminates in phase <span class="math">k-1</span>, giving maximum depth <span class="math">k</span>. Note that it will always be possible to proceed from phase <span class="math">i</span> to phase</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 4: Algorithm for creating a minimum depth circuit for linear components</p>

    <p class="text-gray-300"><span class="math">i + 1</span> , since combining the at most  <span class="math">2^{k - i}</span>  ones any row by pairs will reduce the number of ones to at most half as many, at most  <span class="math">2^{k - i - 1}</span> .</p>

    <p class="text-gray-300">For each XOR gate added, the algorithm checks every pair of columns between 1 and  <span class="math">ip &amp;lt; s</span> , where  <span class="math">s</span>  is the new column being added. For each of these pairs of columns, one checks for each row if both entries corresponding to these columns are one and then does some updating. The number of rows is  <span class="math">n</span> , so the total running time is  <span class="math">O(nt^3)</span> . Since there are at most  <span class="math">n</span>  ones in every row, each row will be computed using at most  <span class="math">n - 1</span>  XORs, and all  <span class="math">m</span>  rows will be computed with at most  <span class="math">m(n - 1)</span>  XORs. There are  <span class="math">n</span>  columns initially, so in all  <span class="math">t \\leq mn + n - m</span> .</p>

    <p class="text-gray-300">Another possibility for an algorithm to produce optimal depth circuits for linear components would have been to finish with all pairs of inputs before continuing to pairs involving gates at depth one, and then to finish with all pairs at depth one (or involving the possibly one remaining input which has not been paired), etc. However, the method chosen here allows more flexibility in choosing gates, thus allowing more possibilities to create gates which can be used more than once.</p>

    <p class="text-gray-300">After an initial attempt at minimizing depth and size in the entire circuit, we may be able to further decrease the number of gates in the top linear component since not all the XOR gates at level three (an output of the top linear component) would necessarily increase the total depth if they were at level four or more (for the AES S-box,  <span class="math">k</span>  and  <span class="math">k + 1</span>  more generally). Or, on the other hand, one might be able to reduce the depth even more</p>

    <p class="text-gray-300">by calculating some outputs of the top linear component at lower depth than the depth indicated by the matrix row with largest Hamming weight, if these “outputs” are on the critical path.</p>

    <p class="text-gray-300">It is easy to determine which outputs of the top linear component could be allowed to be at a larger depth or should be at a lower depth if possible, using a program which calculates the depth and height of every gate. If all of the outputs of the top linear component which have depth and height values adding up to exactly the total depth of the circuit are such that they could have been calculated at lower depth than their current depth, then one can probably reduce the depth of the circuit. On the other hand, when these values add up to less than the total depth of the circuit, there is some slack at that gate. For XOR gates at depth 3 (in an AES S-box circuit) which have slack, one can check if they are the sum of any two of the other outputs of the top-linear part. If they are, these other outputs were computed at depth 3, so adding them together only gives depth 4, which is acceptable when the output was originally created at a gate with slack. Note that cancellation of variables should be allowed here.</p>

    <p class="text-gray-300">The Low_Depth_Greedy algorithm can be modified to take advantage of slackness. In this case, an extra array Factor is initialized for each input to the linear transformation. Rows with no slack are given the value 1, and rows that could be at <span class="math">j</span> levels further down than the minimum are given the value <span class="math">2^{j}</span> in Factor. Then, when checking if one should proceed to the next phase, rather than check if all rows have Hamming weight at most <span class="math">2^{k-i}</span> for phase <span class="math">i</span>, one checks if its Hamming weight divided by its value in Factor is at most <span class="math">2^{k-i}</span>. This allows the possibility of choosing inputs required for these outputs at a larger depth. These techniques were not actually necessary to produce the circuits found.</p>

    <h2 id="sec-4" class="text-2xl font-bold">5 Reducing depth in linear components</h2>

    <p class="text-gray-300">There are straight-forward techniques for reducing depth in linear components via local replacement. Consider any gate in such a component. The output produced there is the XOR of several values (either inputs or outputs from other gates). These values can be XORed in any order to get this result. Thus, for example, suppose <span class="math">g=g_{1}\\oplus g_{2}</span>, <span class="math">g_{1}</span> is at depth <span class="math">d_{1}</span> and <span class="math">g_{1}=g_{3}\\oplus g_{4}</span>, <span class="math">g_{2}</span> is at depth <span class="math">d_{2}</span>, and <span class="math">g_{3}</span> is at depth <span class="math">d_{3}</span>. If <span class="math">d_{2}</span> and <span class="math">d_{3}</span> are at depth at most <span class="math">d_{1}-2</span>, then calculating <span class="math">h_{1}=g_{2}\\oplus g_{3}</span> and <span class="math">h_{2}=h_{1}\\oplus g_{4}</span> results in <span class="math">h_{1}</span> computing the same result as <span class="math">g</span>, but at depth one lower. If the result computed at <span class="math">g_{1}</span> was not used anywhere else in the circuit, then this does not increase the total number of gates. However, if <span class="math">g_{1}</span> is used elsewhere, it would still need to be computed, and the number of gates would increase by one.</p>

    <h2 id="sec-5" class="text-2xl font-bold">6 The circuits</h2>

    <p class="text-gray-300">The depth-16 circuits are shown in Figures 5, 6, 7, 8, and 9. Note that the addition and multiplication operations are modulo 2, so they are XOR and AND operations. The # operation is an XNOR (adding modulo 2 and then complementing the result). We used Algorithm Low_Depth_Greedy for the four linear transformations (here, we do not include the binary matrices corresponding to the transformations in the reverse direction of the AES S-box). The circuits are divided into three components: top linear transformations (Figures 5 and 6), shared non-linear component (Figure 7), and bottom linear transformations</p>

    <p class="text-gray-300">(Figures 8 and 9).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T1 = U0 + U3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T8 = U7 + T6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T15 = T5 + T11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T22 = T7 + T21</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T2 = U0 + U5</td>

            <td class="px-3 py-2 border-b border-gray-700">T9 = U7 + T7</td>

            <td class="px-3 py-2 border-b border-gray-700">T16 = T5 + T12</td>

            <td class="px-3 py-2 border-b border-gray-700">T23 = T2 + T22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T3 = U0 + U6</td>

            <td class="px-3 py-2 border-b border-gray-700">T10 = T6 + T7</td>

            <td class="px-3 py-2 border-b border-gray-700">T17 = T9 + T16</td>

            <td class="px-3 py-2 border-b border-gray-700">T24 = T2 + T10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T4 = U3 + U5</td>

            <td class="px-3 py-2 border-b border-gray-700">T11 = U1 + U5</td>

            <td class="px-3 py-2 border-b border-gray-700">T18 = U3 + U7</td>

            <td class="px-3 py-2 border-b border-gray-700">T25 = T20 + T17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T5 = U4 + U6</td>

            <td class="px-3 py-2 border-b border-gray-700">T12 = U2 + U5</td>

            <td class="px-3 py-2 border-b border-gray-700">T19 = T7 + T18</td>

            <td class="px-3 py-2 border-b border-gray-700">T26 = T3 + T16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T6 = T1 + T5</td>

            <td class="px-3 py-2 border-b border-gray-700">T13 = T3 + T4</td>

            <td class="px-3 py-2 border-b border-gray-700">T20 = T1 + T19</td>

            <td class="px-3 py-2 border-b border-gray-700">T27 = T1 + T12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T7 = U1 + U2</td>

            <td class="px-3 py-2 border-b border-gray-700">T14 = T6 + T11</td>

            <td class="px-3 py-2 border-b border-gray-700">T21 = U6 + U7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: Top linear transform in forward direction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T23 = U0 + U3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T19 = T22 + R5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T17 = U2 # T19</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T6 = T22 + R17</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T22 = U1 # U3</td>

            <td class="px-3 py-2 border-b border-gray-700">T9 = U7 # T1</td>

            <td class="px-3 py-2 border-b border-gray-700">T20 = T24 + R13</td>

            <td class="px-3 py-2 border-b border-gray-700">T16 = R13 + R19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T2 = U0 # U1</td>

            <td class="px-3 py-2 border-b border-gray-700">T10 = T2 + T24</td>

            <td class="px-3 py-2 border-b border-gray-700">T4 = U4 + T8</td>

            <td class="px-3 py-2 border-b border-gray-700">T27 = T1 + R18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T1 = U3 + U4</td>

            <td class="px-3 py-2 border-b border-gray-700">T13 = T2 + R5</td>

            <td class="px-3 py-2 border-b border-gray-700">R17 = U2 # U5</td>

            <td class="px-3 py-2 border-b border-gray-700">T15 = T10 + T27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T24 = U4 # U7</td>

            <td class="px-3 py-2 border-b border-gray-700">T3 = T1 + R5</td>

            <td class="px-3 py-2 border-b border-gray-700">R18 = U5 # U6</td>

            <td class="px-3 py-2 border-b border-gray-700">T14 = T10 + R18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R5 = U6 + U7</td>

            <td class="px-3 py-2 border-b border-gray-700">T25 = U2 # T1</td>

            <td class="px-3 py-2 border-b border-gray-700">R19 = U2 # U4</td>

            <td class="px-3 py-2 border-b border-gray-700">T26 = T3 + T16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T8 = U1 # T23</td>

            <td class="px-3 py-2 border-b border-gray-700">R13 = U1 + U6</td>

            <td class="px-3 py-2 border-b border-gray-700">Y5 = U0 + R17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6: Top linear transform in reverse direction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M1 = T13 x T6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M17 = M5 + T24</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M33 = M27 + M25</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M49 = M43 x T16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M2 = T23 x T8</td>

            <td class="px-3 py-2 border-b border-gray-700">M18 = M8 + M7</td>

            <td class="px-3 py-2 border-b border-gray-700">M34 = M21 x M22</td>

            <td class="px-3 py-2 border-b border-gray-700">M50 = M38 x T9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M3 = T14 + M1</td>

            <td class="px-3 py-2 border-b border-gray-700">M19 = M10 + M15</td>

            <td class="px-3 py-2 border-b border-gray-700">M35 = M24 x M34</td>

            <td class="px-3 py-2 border-b border-gray-700">M51 = M37 x T17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M4 = T19 x D</td>

            <td class="px-3 py-2 border-b border-gray-700">M20 = M16 + M13</td>

            <td class="px-3 py-2 border-b border-gray-700">M36 = M24 + M25</td>

            <td class="px-3 py-2 border-b border-gray-700">M52 = M42 x T15</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M5 = M4 + M1</td>

            <td class="px-3 py-2 border-b border-gray-700">M21 = M17 + M15</td>

            <td class="px-3 py-2 border-b border-gray-700">M37 = M21 + M29</td>

            <td class="px-3 py-2 border-b border-gray-700">M53 = M45 x T27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M6 = T3 x T16</td>

            <td class="px-3 py-2 border-b border-gray-700">M22 = M18 + M13</td>

            <td class="px-3 py-2 border-b border-gray-700">M38 = M32 + M33</td>

            <td class="px-3 py-2 border-b border-gray-700">M54 = M41 x T10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M7 = T22 x T9</td>

            <td class="px-3 py-2 border-b border-gray-700">M23 = M19 + T25</td>

            <td class="px-3 py-2 border-b border-gray-700">M39 = M23 + M30</td>

            <td class="px-3 py-2 border-b border-gray-700">M55 = M44 x T13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M8 = T26 + M6</td>

            <td class="px-3 py-2 border-b border-gray-700">M24 = M22 + M23</td>

            <td class="px-3 py-2 border-b border-gray-700">M40 = M35 + M36</td>

            <td class="px-3 py-2 border-b border-gray-700">M56 = M40 x T23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M9 = T20 x T17</td>

            <td class="px-3 py-2 border-b border-gray-700">M25 = M22 x M20</td>

            <td class="px-3 py-2 border-b border-gray-700">M41 = M38 + M40</td>

            <td class="px-3 py-2 border-b border-gray-700">M57 = M39 x T19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M10 = M9 + M6</td>

            <td class="px-3 py-2 border-b border-gray-700">M26 = M21 + M25</td>

            <td class="px-3 py-2 border-b border-gray-700">M42 = M37 + M39</td>

            <td class="px-3 py-2 border-b border-gray-700">M58 = M43 x T3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M11 = T1 x T15</td>

            <td class="px-3 py-2 border-b border-gray-700">M27 = M20 + M21</td>

            <td class="px-3 py-2 border-b border-gray-700">M43 = M37 + M38</td>

            <td class="px-3 py-2 border-b border-gray-700">M59 = M38 x T22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M12 = T4 x T27</td>

            <td class="px-3 py-2 border-b border-gray-700">M28 = M23 + M25</td>

            <td class="px-3 py-2 border-b border-gray-700">M44 = M39 + M40</td>

            <td class="px-3 py-2 border-b border-gray-700">M60 = M37 x T20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M13 = M12 + M11</td>

            <td class="px-3 py-2 border-b border-gray-700">M29 = M28 x M27</td>

            <td class="px-3 py-2 border-b border-gray-700">M45 = M42 + M41</td>

            <td class="px-3 py-2 border-b border-gray-700">M61 = M42 x T1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M14 = T2 x T10</td>

            <td class="px-3 py-2 border-b border-gray-700">M30 = M26 x M24</td>

            <td class="px-3 py-2 border-b border-gray-700">M46 = M44 x T6</td>

            <td class="px-3 py-2 border-b border-gray-700">M62 = M45 x T4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M15 = M14 + M11</td>

            <td class="px-3 py-2 border-b border-gray-700">M31 = M20 x M23</td>

            <td class="px-3 py-2 border-b border-gray-700">M47 = M40 x T8</td>

            <td class="px-3 py-2 border-b border-gray-700">M63 = M41 x T2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">M16 = M3 + M2</td>

            <td class="px-3 py-2 border-b border-gray-700">M32 = M27 x M31</td>

            <td class="px-3 py-2 border-b border-gray-700">M48 = M39 x D</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: Shared part of AES S-box circuit ( <span class="math">D = U7</span>  in the forward direction and  <span class="math">D = Y5</span>  in the reverse direction).</p>

    <p class="text-gray-300">The circuits were generated automatically using randomization for tie-resolution. Different runs of our code yield depth 16 consistently. However, size can vary by a few gates. As</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L0 = M61 + M62</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L10 = M53 + L4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L20 = L0 + L1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S0 = L6 + L24</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L1 = M50 + M56</td>

            <td class="px-3 py-2 border-b border-gray-700">L11 = M60 + L2</td>

            <td class="px-3 py-2 border-b border-gray-700">L21 = L1 + L7</td>

            <td class="px-3 py-2 border-b border-gray-700">S1 = L16 # L26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L2 = M46 + M48</td>

            <td class="px-3 py-2 border-b border-gray-700">L12 = M48 + M51</td>

            <td class="px-3 py-2 border-b border-gray-700">L22 = L3 + L12</td>

            <td class="px-3 py-2 border-b border-gray-700">S2 = L19 # L28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L3 = M47 + M55</td>

            <td class="px-3 py-2 border-b border-gray-700">L13 = M50 + L0</td>

            <td class="px-3 py-2 border-b border-gray-700">L23 = L18 + L2</td>

            <td class="px-3 py-2 border-b border-gray-700">S3 = L6 + L21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L4 = M54 + M58</td>

            <td class="px-3 py-2 border-b border-gray-700">L14 = M52 + M61</td>

            <td class="px-3 py-2 border-b border-gray-700">L24 = L15 + L9</td>

            <td class="px-3 py-2 border-b border-gray-700">S4 = L20 + L22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L5 = M49 + M61</td>

            <td class="px-3 py-2 border-b border-gray-700">L15 = M55 + L1</td>

            <td class="px-3 py-2 border-b border-gray-700">L25 = L6 + L10</td>

            <td class="px-3 py-2 border-b border-gray-700">S5 = L25 + L29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L6 = M62 + L5</td>

            <td class="px-3 py-2 border-b border-gray-700">L16 = M56 + L0</td>

            <td class="px-3 py-2 border-b border-gray-700">L26 = L7 + L9</td>

            <td class="px-3 py-2 border-b border-gray-700">S6 = L13 # L27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L7 = M46 + L3</td>

            <td class="px-3 py-2 border-b border-gray-700">L17 = M57 + L1</td>

            <td class="px-3 py-2 border-b border-gray-700">L27 = L8 + L10</td>

            <td class="px-3 py-2 border-b border-gray-700">S7 = L6 # L23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L8 = M51 + M59</td>

            <td class="px-3 py-2 border-b border-gray-700">L18 = M58 + L8</td>

            <td class="px-3 py-2 border-b border-gray-700">L28 = L11 + L14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L9 = M52 + M53</td>

            <td class="px-3 py-2 border-b border-gray-700">L19 = M63 + L4</td>

            <td class="px-3 py-2 border-b border-gray-700">L29 = L11 + L17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 8: Bottom linear transform in forward direction. Outputs are  <span class="math">S0 \\ldots S7</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P0 = M52 + M61</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P10 = M57 + P4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P20 = P4 + P6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W1 = P26 + P29</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P1 = M58 + M59</td>

            <td class="px-3 py-2 border-b border-gray-700">P11 = P0 + P3</td>

            <td class="px-3 py-2 border-b border-gray-700">P22 = P2 + P7</td>

            <td class="px-3 py-2 border-b border-gray-700">W2 = P17 + P28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P2 = M54 + M62</td>

            <td class="px-3 py-2 border-b border-gray-700">P12 = M46 + M48</td>

            <td class="px-3 py-2 border-b border-gray-700">P23 = P7 + P8</td>

            <td class="px-3 py-2 border-b border-gray-700">W3 = P12 + P22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P3 = M47 + M50</td>

            <td class="px-3 py-2 border-b border-gray-700">P13 = M49 + M51</td>

            <td class="px-3 py-2 border-b border-gray-700">P24 = P5 + P7</td>

            <td class="px-3 py-2 border-b border-gray-700">W4 = P23 + P27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P4 = M48 + M56</td>

            <td class="px-3 py-2 border-b border-gray-700">P14 = M49 + M62</td>

            <td class="px-3 py-2 border-b border-gray-700">P25 = P6 + P10</td>

            <td class="px-3 py-2 border-b border-gray-700">W5 = P19 + P24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P5 = M46 + M51</td>

            <td class="px-3 py-2 border-b border-gray-700">P15 = M54 + M59</td>

            <td class="px-3 py-2 border-b border-gray-700">P26 = P9 + P11</td>

            <td class="px-3 py-2 border-b border-gray-700">W6 = P14 + P23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P6 = M49 + M60</td>

            <td class="px-3 py-2 border-b border-gray-700">P16 = M57 + M61</td>

            <td class="px-3 py-2 border-b border-gray-700">P27 = P10 + P18</td>

            <td class="px-3 py-2 border-b border-gray-700">W7 = P9 + P16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P7 = P0 + P1</td>

            <td class="px-3 py-2 border-b border-gray-700">P17 = M58 + P2</td>

            <td class="px-3 py-2 border-b border-gray-700">P28 = P11 + P25</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P8 = M50 + M53</td>

            <td class="px-3 py-2 border-b border-gray-700">P18 = M63 + P5</td>

            <td class="px-3 py-2 border-b border-gray-700">P29 = P15 + P20</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P9 = M55 + M63</td>

            <td class="px-3 py-2 border-b border-gray-700">P19 = P2 + P3</td>

            <td class="px-3 py-2 border-b border-gray-700">W0 = P13 + P22</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 9: Bottom linear transform in reverse direction. Outputs are  <span class="math">W0 \\ldots W7</span> .</p>

    <p class="text-gray-300">long as the topology derived from the tower-of-fields method is maintained, we conjecture that it is unlikely that the size of the circuits can be significantly reduced without increasing the depth. We also conjecture that it is unlikely that the depth can be reduced without significantly increasing size. Of course, if the logical base is expanded, we may be able to do better. For example, if NAND gates are used in the circuit for inversion in  <span class="math">GF(2^4)</span> , it is not hard to reduce the number of gates by two without increasing the depth. Since there are only 256 possible inputs, we verified the circuits fully against the specifications in [9].</p>

    <p class="text-gray-300">[1] J. Boyar and R. Peralta. A new combinational logic minimization technique with applications to cryptography. In P. Festa, editor, SEA, volume 6049 of Lecture Notes in Computer Science, pages 178-189. Springer, 2010. [2] J. Boyar, R. Peralta, and D. Pochuev. On the multiplicative complexity of Boolean functions over the basis  <span class="math">(\\wedge, \\oplus, 1)</span> . Theoretical Computer Science, 235:43-57, 2000. [3] D. Canright. A very compact Rijndael S-box. Technical Report NPS-MA-05-001, Naval Postgraduate School, 2005.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[4] C. Fuhs and P. Schneider-Kamp. Optimizing the AES S-Box using SAT. In Proceedings of the 8th International Workshop on the Implementation of Logics, 2010.</li>

      <li>[5] C. Fuhs and P. Schneider-Kamp. Synthesizing shortest linear straight-line programs over GF(2) using SAT. In O. Strichman and S. Szeider, editors, SAT, volume 6175 of Lecture Notes in Computer Science, pages 71–84. Springer, 2010.</li>

      <li>[6] T. Itoh and S. Tsujii. A fast algorithm for computing multiplicative inverses in <span class="math">GF(2^{m})</span> using normal bases. Inf. Comput., 78(3):171–177, 1988.</li>

      <li>[7] O. B. Lupanov. A method of circuit synthesis. Izvestia V.U.Z. Radiofizika, 1:120–140, 1958.</li>

      <li>[8] S. Morioka and A. Satoh. An optimized S-Box circuit architecture for low power AES design. In Revised Papers from the 4th International Workshop on Cryptographic Hardware and Embedded Systems, pages 172–186, London, UK, 2003. Springer-Verlag.</li>

      <li>[9] NIST. Advanced Encryption Standard (AES) (FIPS PUB 197). National Institute of Standards and Technology, November 2001.</li>

      <li>[10] Y. Nogami, K. Nekado, T. Toyota, N. Hongo, and Y. Morikawa. Mixed bases for efficient inversion in <span class="math">f(((2^{2})^{2})^{2})</span> and conversion matrices of subbytes of AES. In S. Mangard and F.-X. Standaert, editors, CHES, volume 6225 of Lecture Notes in Computer Science, pages 234–247. Springer, 2010.</li>

      <li>[11] C. Paar. Optimized arithmetic for Reed-Solomon encoders. In IEEE International Symposium on Information Theory, page 250, 1997.</li>

      <li>[12] C. E. Shannon. The synthesis of two-terminal switching circuits. Bell System Tech. J., 28:59–98, 1949.</li>

    </ul>`;
---

<BaseLayout title="A depth-16 circuit for the AES S-box (2011/332)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/332
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
