---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/620';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'ProtoStar: Generic Efficient Accumulation/Folding for Special Sound Protocols';
const AUTHORS_HTML = 'Benedikt Bünz, Binyi Chen';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz Stanford University, Espresso Systems Binyi Chen Espresso Systems</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Accumulation is a simple yet powerful primitive that enables incrementally verifiable computation (IVC) without the need for recursive SNARKs. We provide a generic, efficient accumulation (or folding) scheme for any <span class="math">(2k-1)</span>-move special-sound protocol with a verifier that checks <span class="math">\\ell</span> degree-<span class="math">d</span> equations. The accumulation verifier only performs <span class="math">k+2</span> elliptic curve multiplications and <span class="math">k+d+O(1)</span> field/hash operations. Using the compiler from BCLMS21 (Crypto 21), this enables building efficient IVC schemes where the recursive circuit only depends on the number of rounds and the verifier degree of the underlying special-sound protocol but not the proof size or the verifier time. We use our generic accumulation compiler to build Protostar. Protostar is a non-uniform IVC scheme for Plonk that supports high-degree gates and (vector) lookups. The recursive circuit is dominated by 3 group scalar multiplications and a hash of <span class="math">d^{<em>}</span> field elements, where <span class="math">d^{</em>}</span> is the degree of the highest gate. The scheme does not require a trusted setup or pairings, and the prover does not need to compute any FFTs. The prover in each accumulation/IVC step is also only logarithmic in the number of supported circuits and independent of the table size in the lookup.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Technical overview  7 1.2  Organization  11</p>

    <p class="text-gray-300">2  Preliminaries  11 2.1  Special-sound Protocols and Fiat-Shamir Transform  11 2.2  Adaptive Fiat-Shamir transform  13 2.3  Commitment Scheme  13 2.4  Incremental Verifiable Computation (IVC)  13 2.5  Simple Accumulation  14</p>

    <p class="text-gray-300">3  Protocols  16 3.1  Special-sound Protocols  16 3.2  Commit and Open  17 3.3  Fiat-Shamir transform  18 3.4  Accumulation Scheme for <span class="math">V_{NARK}</span>  19 3.5  Compressing verification checks for high-degree verifiers  25 3.6  Computation of error terms  30 3.6.1  Dealing with branched gates  31</p>

    <p class="text-gray-300">4  Special-sound subprotocols for Protostar  32 4.1  Permutation relation  32 4.2  High-degree custom gate relation  32 4.3  Lookup relation  33 4.4  Vector-valued lookup  36 4.5  Circuit selection  39</p>

    <p class="text-gray-300">5  Special-sound protocols for Plonkup relations  39</p>

    <p class="text-gray-300">6  Protostar  41</p>

    <p class="text-gray-300">A  Accumulation Scheme for high/low degree verifier  49 B  Computation of cross error commitments for sparse witnesses  51 C  Protostar for CCS  54</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Incrementally Verifiable Computation<em>[x17]</em> is a powerful primitive that enables a possibly infinite computation to be run, such that the correctness of the state of the computation can be verified at any point. IVC, and it’s generalization to DAGs, PCD<em>[x4]</em>, have many applications, including distributed computation<em>[x1, x4]</em>, blockchains<em>[x2, x3]</em>, verifiable delay functions <em>[x1]</em>, verifiable photo editing <em>[x16]</em>, and SNARKs for machine-computations<em>[x2]</em>. An IVC-based VDF construction is the current candidate VDF for Ethereum<em>[x11]</em>. One of the most exciting applications of IVC and PCD is the ZK-EVM. This is an effort to build a proof system that can prove that Ethereum blocks, as they exist today, are valid<em>[x3]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Accumulation and folding.</h4>

    <p class="text-gray-300">Historically, IVC was built from recursive SNARKs, proving that the previous computation step had a valid SNARK that proves correctness up to that point. Recently, an exciting new approach was initiated by Halo<em>[x5]</em> and has led to a series of significant advances<em>[x2, x1, x1]</em>. The idea is related to batch verification. Instead of verifying a SNARK at every step of the computation, we can instead <em>accumulate</em> the SNARK verification check with previous checks. We define an <em>accumulator</em> such that we can combine a new SNARK and an old accumulator into a new accumulator. Checking or <em>deciding</em> the new accumulator implies that all previously accumulated SNARKs were valid. Now the recursive statement just needs to ensure the accumulation was performed correctly. Amazingly, this accumulation step can be significantly cheaper than SNARK verification<em>[x5, x2]</em>. Even more surprising, this process does not even require a SNARK but instead can be instantiated with a non-succinct NARK<em>[x1]</em>, as long as there exists an efficient accumulation scheme for that NARK. The most efficient accumulation (aka folding) scheme constructions yield IVC constructions, where the recursive circuit is dominated by as few as 2 elliptic curve scalar multiplications<em>[x1, x1]</em>. These constructions only require the discrete logarithm assumption in the random oracle model and, unlike many efficient SNARK-based IVCs, do not require a trusted setup, pairings, or FFTs. These constructions build an accumulation scheme for one fixed (but universal) R1CS language by taking a random linear combination between the accumulator and a new proof. R1CS is a minimal expression of NP, defined by three matrices <span class="math">A,B,C</span>, that close resembles arithmetic circuits with addition and multiplication gates. However, it has limited flexibility, especially as the current constructions require fixing R1CS matrices that are used for all computation steps. These limitations are especially problematic for ZK-EVMs. In a ZK-EVM, each VM instruction (OP-CODE) is encoded in a different circuit. Each circuit uses high-degree gates, instead of just multiplication, and so-called lookup gates <em>[x10]</em>. These lookup gates enable looking up that a circuit value is in some table, simplifying range proofs and bit-operations.</p>

    <p class="text-gray-300">These R1CS-based accumulation schemes contrast non-IVC SNARK developments, with an increased focus on high-degree gate<em>[x11, x10]</em> and lookup support<em>[x12]</em>. For lookups, a recent line of work has shown that if the table can be pre-computed, we can perform <span class="math">n</span> lookups in a table of size <span class="math">T</span> in time <span class="math">O(n\\log n)</span>, independent of <span class="math">T</span><em>[x30, x16, x17]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">More expressive accumulation.</h4>

    <p class="text-gray-300">There have been efforts to build accumulation schemes that overcome the limitations of fixed R1CS. SuperNova<em>[x18]</em> enables selecting the appropriate R1CS instance at runtime without a recursive circuit that is linear in all R1CS instances. The approach, however, still has limitations. The recursive circuit still requires many (though a constant number of) hashes and a hash-to-group gadget, and additionally, the accumulator, and thus the final proof, is still linear in the total size of all instances.</p>

    <p class="text-gray-300">Sangria <em>[x22]</em> describes an accumulation scheme for a Plonk-like<em>[x11]</em> constraint system with degree-2 gates. It also proposes a solution for higher-degree gates in the future work section but without security proof. Moreover, as the gate degree <span class="math">d</span> increases, the number of group operations in Sangria grows by a factor of <span class="math">d</span>, which cancels out the advantages of using the more expressive high-degree gates. Origami<em>[x32]</em> recently introduced a folding scheme for lookups using a product check and degree 7 polynomials. These accumulation schemes are built from simple underlying protocols performing a linear combination between an accumulator and a proof. However, the constructions seem ad hoc and need individual security proof. This leads us to our main research questions:</p>

    <p class="text-gray-300">Is there a general recipe for building accumulation schemes? Can we formalize this recipe, simplifying the task of constructing secure and efficient accumulation schemes? Can we build an accumulation/folding scheme for a language that combines the benefits of the most advanced proof systems today? Can we support multiple circuits, high-degree, and lookup gates?</p>

    <p class="text-gray-300">We answer both questions positively. Firstly we show a general compiler that takes any <span class="math">(2k-1)</span>-move special-sound interactive argument for an NP-complete relation <span class="math">\\mathcal{R}_{\\mathsf{NP}}</span> with an algebraic degree <span class="math">d</span> verifier and construct an efficient IVC-scheme from it. This is done in 4 simple steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We compress the prover message by committing to them in a homomorphic commitment scheme.</li>

      <li>Then we apply the Fiat-Shamir transform to yield a secure NARK. <em>[x1, x33]</em></li>

      <li>We build a simple and efficient accumulation scheme that samples a random challenge <span class="math">\\alpha</span> and takes a linear combination between the current accumulator and the new NARK.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We apply the compiler by [BCLMS21] to yield a secure IVC scheme.</li>

    </ol>

    <p class="text-gray-300">The recursive circuit of this transformation is dominated by only <span class="math">d + k - 1</span> scalar multiplications in the additive group of the commitment scheme² for a protocol with <span class="math">k</span> prover messages and a degree <span class="math">d</span> verifier. For R1CS, where <span class="math">k = 1</span> and <span class="math">d = 2</span>, this yields the same protocol and efficiency as Nova[KST22]. We can further reduce the size of the recursive circuit to only <span class="math">k + 2</span> group scalar multiplication, by compressing all verification equations using a random linear combination.</p>

    <p class="text-gray-300"><strong>Efficient simple protocols for <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span></strong>. Equipped with this compiler, we design PROTOSTAR, a simple and efficient IVC scheme for a highly expressive language <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span> that supports multiple non-uniform circuits and enables high degree and lookup gates. The schemes can be instantiated from any linearly homomorphic vector commitment, e.g., the discrete logarithm-based Pedersen commitment[Ped92], and do not require a trusted setup or the computation of large FFTs. The protocol has several advantages over prior schemes:</p>

    <p class="text-gray-300"><strong>Non-uniform IVC without overhead.</strong> Each iteration has a program counter <span class="math">\\mathbf{pc}</span> that selects one out of <span class="math">I</span> circuits. Part of the circuit constrains <span class="math">\\mathbf{pc}</span>; e.g., <span class="math">\\mathbf{pc}</span> could depend on the iteration or indicate which instruction within a VM is executed. The IVC-prover, including the recursive statement, only requires one exponentiation per non-zero bit in the witness. The prover's computation is independent of <span class="math">I</span>.</p>

    <p class="text-gray-300"><strong>Flexible high degree gates.</strong> Our protocol supports Plonk-like constraint systems with degree <span class="math">d</span> gates instead of just addition and multiplication. The recursive statement consists of 3 group scalar multiplications and <span class="math">d + O(1)</span> hash and field operations. Unlike in traditional Plonk, there is no additional cost for additional gate types (of degree less than <span class="math">d</span>) and additional selectors. This enables a high level of non-uniformity, even within a circuit.</p>

    <p class="text-gray-300"><strong>Lookup, linear and independent of table size.</strong> PROTOSTAR supports lookup gates that ensure a value is in some precomputed table <span class="math">T</span>. In each computation step, the prover commits to 2 vectors of length <span class="math">\\ell_{\\mathrm{lk}}</span>, where <span class="math">\\ell_{\\mathrm{lk}}</span> is the number of lookups. The prover, in each step, is independent of the table size (assuming free indexing in <span class="math">T</span>). We also support tables that store tuples of size <span class="math">v</span> using 1 additional challenge computations within the recursive circuit.</p>

    <p class="text-gray-300">Our protocols are built of multiple small building blocks. In the protocol for high-degree gates, the prover simply sends the witness, and the degree <span class="math">d</span> verifier checks the circuit with degree <span class="math">d</span> gates. For lookup, we leverage an insight by Haböck [Hab22] on logarithmic derivates. This yields a protocol where a prover performing <span class="math">\\ell_{\\mathrm{lk}}</span> in a table of size <span class="math">T</span> only needs</p>

    <p class="text-gray-300">²When instantiated with elliptic curve Pedersen commitments, this translates to <span class="math">d + k - 1</span> elliptic curve multiplications. This is usually the largest component of the recursive statement.</p>

    <p class="text-gray-300">5</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROSTAR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HyperNova</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SuperNova</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Language</td>

            <td class="px-3 py-2 border-b border-gray-700">Degree d Plonk/CCS</td>

            <td class="px-3 py-2 border-b border-gray-700">Degree d CCS</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS (degree 2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Non-uniform</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P native</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">G O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">d log2d) F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">G O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">d log2d) F</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">extra P native w/ lookup</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓlk</td>

            <td class="px-3 py-2 border-b border-gray-700">) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T) F</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P recursive</td>

            <td class="px-3 py-2 border-b border-gray-700">3G (d + O(1))H + Hin (d + O(1)) F</td>

            <td class="px-3 py-2 border-b border-gray-700">1G d log nH + Hin O(d log n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">2G Hin + O(1)H + 1HG</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">extra P recursive w/ lookup</td>

            <td class="px-3 py-2 border-b border-gray-700">1H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log T) H O(ℓlk log T) F</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The comparison between IVCs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to commit to two vectors of length  <span class="math">\\ell_{\\mathrm{lk}}</span> , independent of  <span class="math">T</span> . This is the most efficient lookup protocol today. While the verification is linear time, it is low degree (2) and thus compatible with our generic compiler. Combining all these yields PROSTAR, a new IVC-scheme for  <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span> . We compare PROSTAR, with SuperNova [KS22] and HyperNova [KS23], in Table 1 (for more detail see Corollary 1):  <span class="math">\\mathsf{P}</span>  native is the running time of the accumulation prover and  <span class="math">\\mathsf{P}</span>  recursive refers to the cost of implementing the accumulation verifier as a circuit. In the table,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the number of non-zero entries of the witness for circuit  </span>i<span class="math"> , and  </span>\\ell_{\\mathrm{lk}}<span class="math">  is the number of lookups in a table of size  </span>T<span class="math"> .  </span>\\mathbb{G}<span class="math">  is the cost of a group scalar multiplication.  </span>\\mathbb{F}<span class="math">  is the cost of a field multiplication.  </span>d\\mathsf{H}<span class="math">  denotes the cost of hashing  </span>d\\lambda<span class="math"> -bit numbers. We assume that the cost scales linearly with the size of the input and output. In PROSTAR  </span>d<span class="math">  field elements are hashed once and in HyperNova  </span>d<span class="math">  field elements are hashed  </span>\\log(n)<span class="math">  times.  </span>\\mathsf{H}_{\\mathbb{G}}<span class="math">  is the cost of a hash-to-group function.  </span>\\mathsf{H}_{\\mathrm{in}}<span class="math">  is the cost of hashing the public input and the accumulator instance. Note that the  </span>O(1)\\mathsf{H}$  in SuperNova's recursive circuit involves constant number of hashes to the input of two accumulator instances and one circuit verification key, by using multiset-based offline memory checking in a circuit [SAGL18].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Concurrent work. In a paper concurrent with this work, Kothapalli and Setty [KS23] introduce an IVC for high degree relations. They use a generalization of R1CS called customizable constraint systems (CCS) [STW23] that covers the Plonkish relations. It also enables gates with a high additive fan-in. PROSTAR also has no restriction to the fan-in an individual gate has, but we subsequently showed that our compiler can also be directly applied to CCS (Appendix C). HyperNova is based on so-called multi-folding schemes. They also provide a lookup argument suitable for recursive arguments. However, they do not explicitly explain how to integrate lookup to Plonk/CCS in their IVC scheme or provide any explicit constructions for non-uniform computations. Their scheme is built</p>

    <p class="text-gray-300">using sumchecks <em>[x14]</em> and the resulting IVC recursive circuit is dominated by 1 group scalar multiplication, <span class="math">d\\log n+\\ell_{\\mathsf{in}}</span> hash operations and <span class="math">O(d\\log n+\\ell_{\\mathsf{in}})</span> field multiplications where <span class="math">d</span> is the custom gate degree, <span class="math">n</span> is the number of gates and <span class="math">\\ell_{\\mathsf{in}}</span> is the public input length. In comparison, our IVC recursive circuit, even with lookup and non-uniformity support, is only dominated by 3 group scalar multiplications and <span class="math">O(\\ell_{\\mathsf{in}}+d)</span> field/hash operations, entirely independent of <span class="math">n</span>. The 2 additional group operations compared to HyperNova are likely offset by the additional lookup support <em>[x27]</em> and the significantly fewer hashes and non-native field operations (<span class="math">d</span> vs. <span class="math">d\\log(n)</span>). A detailed comparison is given in Table 1.</p>

    <p class="text-gray-300">For a lookup relation with table size <span class="math">T</span> and <span class="math">\\ell_{\\mathsf{lk}}</span> lookup gates, their accumulation/folding scheme leads to an accumulation prover whose work is dominated by <span class="math">O(T)</span> field operations and an accumulation verifier whose work is dominated by <span class="math">O(\\ell_{\\mathsf{lk}}\\log T)</span> field operations and <span class="math">O(\\log T)</span> hashes. This is undesirable when the table size <span class="math">T\\gg\\ell_{\\mathsf{lk}}</span>. In comparison, our scheme has prover complexity <span class="math">O(\\ell_{\\mathsf{lk}})</span> and the verifier is only dominated by 3 group scalar multiplications, 2 hashes and 2 field multiplications. Moreover, the lookup support adds almost no overhead to the IVC scheme for high-degree Plonk relations. In particular, it adds no group scalar multiplications. Lastly, their lookup scheme does not support vector-valued lookups, which is essential for applications like ZK-EVM and encoding bit-wise operations in circuits.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Technical overview</h3>

    <p class="text-gray-300">Given an NP-complete relation <span class="math">\\mathcal{R}</span>, we introduce a generic framework for constructing efficient incremental verifiable computation (IVC) schemes with predicates expressed in <span class="math">\\mathcal{R}</span>. For <span class="math">\\mathcal{R}</span> being the non-uniform Plonkup circuit satisfiability relation, we obtain an efficient (non-uniform) IVC scheme for proving correct program executions on stateful machines (e.g., EVM). The framework starts by designing a simple special-sound protocol <span class="math">\\Pi_{\\mathsf{sps}}</span> for relation <span class="math">\\mathcal{R}</span>, which is easy to analyze. Next, we use a generic compiler to transform <span class="math">\\Pi_{\\mathsf{sps}}</span> into a Non-interactive Argument of Knowledge Scheme (NARK) whose verification predicate is easy to accumulate/fold. Finally, we build an efficient accumulation/folding scheme for the NARK verifier, and apply the generic compiler from <em>[x3]</em> to obtain the IVC/PCD scheme for relation <span class="math">\\mathcal{R}</span>. We describe the workflow in Figure 1.</p>

    <p class="text-gray-300">The paper begins by describing the compiler from special-sound protocols to NARKs in Section 3, and presents an efficient accumulation scheme for the compiled NARK verifier in Section 3.4. Next, we describe simple and efficient special-sound protocols for Plonkup circuit-satisfiability relationsin Section 5 and extend it to support non-uniform computation in Section 6. Similarly, we extend the CCS relation <em>[x26]</em> to support non-uniform computation and lookup in Appendix C. We give an overview of our approach below.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Efficient IVCs from special-sound protocols.</h5>

    <p class="text-gray-300">Let <span class="math">\\Pi_{\\mathsf{sps}}</span> be any <em>multi-round</em> special-sound protocol for some relation <span class="math">\\mathcal{R}</span>, in which the verifier is <em>algebraic</em>, that is, the verifier</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The workflow for building an IVC from a special sound protocol. We start from a special-sound protocol  <span class="math">\\Pi_{\\mathrm{sps}}</span>  for an NP-complete relation  <span class="math">\\mathcal{R}_{\\mathrm{NP}}</span> , and transform it to  <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{sps}}]</span>  with a compressed verifier check.  <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{sps}}]</span>  is converted to a NARK FS[cm[CV[PiSps]]] via commit-and-open and the Fiat-Shamir transform. We then build a generic accumulation scheme for the NARK and apply Theorem 1 from [BCLMS21] to obtain the IVC scheme. This last connection is dotted as it requires heuristically replacing random oracles with cryptographic hash functions.</p>

    <p class="text-gray-300">algorithm only checks algebraic equations over the input and the prover messages. E.g., the following naive protocol for the Hadamard product relation over vectors  <span class="math">\\mathbf{a},\\mathbf{b},\\mathbf{c}\\in \\mathbb{F}^n</span>  is special-sound and has a degree-2 algebraic verifier: The prover simply sends the vectors  <span class="math">\\mathbf{a},\\mathbf{b},\\mathbf{c}</span>  to the verifier, and the verifier checks that  <span class="math">a_{i}\\cdot b_{i} = c_{i}</span>  for all  <span class="math">i\\in [n]</span> . However, as shown in the example, the prover message can be large in  <span class="math">\\Pi_{\\mathrm{sps}}</span>  and the folding scheme can be expensive if we directly accumulate the verifier predicate. Inspired by the splitting accumulation scheme [BCLMS21], to enable efficient accumulation/folding, we split each prover message into a short instance and a large opening, where the short instance is built from the homomorphic commitment to the prover message. Next, we use the Fiat-Shamir transform to compile the protocol into a NARK where the verifier challenges are generated from a random oracle.</p>

    <p class="text-gray-300">Now we can view the NARK transcript as an accumulator (or a relaxed NP instance-witness pair in the language of folding schemes), where the accumulator instance consists of the prover message commitments and the verifier challenges; while the accumulator witness consists of the prover messages (i.e., the opening to the commitments). Note we also need to introduce an error vector/commitment into the accumulator witness/instance to absorb the "noise" that arises after each accumulation/folding step.</p>

    <p class="text-gray-300">In the accumulation scheme, given two accumulators (or NARK proofs), the prover folds the witnesses and the instances of both accumulators via a random linear combination and generates a list of  <span class="math">d</span>  "error-correcting terms" as accumulation proof ( <span class="math">d</span>  is the degree of the NARK verifier); the verifier only needs to check that the folded accumulator instance is consistent with the accumulation proof and the original instances being folded, both of</p>

    <p class="text-gray-300">which are small. After finishing all the accumulation steps, a decider applies a final check to the accumulator, scrutinizing that (i) the accumulator witness is consistent with the commitments in the accumulator instance, and (ii) the “relaxed” NARK verifier check still passes. Here by “relaxed” we mean that the algebraic equation also involves the error vector in the accumulator. If the decider accepts, this implies that all accumulated NARKs were valid and thus that all accumulated statements are in <span class="math">\\mathcal{R}</span> (and the prover knows witnesses for these statements).</p>

    <p class="text-gray-300">Finally, given the accumulation scheme, if the relation <span class="math">\\mathcal{R}</span> is NP-complete, we can apply the compiler in <em>[x1]</em> to obtain an efficient IVC scheme with predicates expressed in <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">In Theorem 3, we show that for any <span class="math">(2k-1)</span>-move special-sound protocols with degree-<span class="math">d</span> verifiers, the resulting IVC recursive circuit only involves <span class="math">k+d+O(1)</span> hashes, <span class="math">k+1</span> non-native field operations and <span class="math">k+d-1</span> commitment group scalar multiplications. We also introduce a generic approach for further reducing the number of group operations to <span class="math">k+2</span> in Section 3.5. This is favorable for <span class="math">d\\geq 3</span>. The idea is to compress all <span class="math">\\ell</span> degree <span class="math">d</span> verification checks into a single verification check using a random linear combination with powers of a challenge <span class="math">\\beta</span>. This means that error-correcting terms are field elements and, thus, can be sent directly without committing to them. The prover also sends a single commitment to powers of <span class="math">\\beta</span> and powers of <span class="math">\\beta^{\\sqrt{\\ell}}</span>. The verification equation uses one power of <span class="math">\\beta</span> and one power of <span class="math">\\beta^{\\sqrt{\\ell}}</span>, which increases the degree of the verification check to <span class="math">d+2</span>. The verifier also checks the correctness of the powers of <span class="math">\\beta</span> using <span class="math">2\\sqrt{\\ell}</span> degree <span class="math">2</span> checks.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Special-sound protocols for (non-uniform) Plonkup relations.</h4>

    <p class="text-gray-300">Given the generic compiler above, our ultimate goal of constructing a (non-uniform) IVC scheme for zkEVM becomes much easier. It is now sufficient to design a multi-round special-sound protocol for the (non-uniform) Plonkup relation. We describe the components of the special-sound protocol in Figure 2. Note we also extend CCS relation <em>[x21]</em> to support lookup and non-uniform computation and build a special-sound protocol for it (See Figure 2). Recall that a Plonkup circuit-satisfiability relation consists of three modular relations, namely, (i) a high-degree gate relation checking that each custom gate is satisfied; (ii) a permutation (wiring-identity) relation checking that different gate values are consistent if the same wire connects them, and (iii) a lookup relation checking that a subset of gate values belongs to a preprocessed table. The special-sound protocols for the permutation and high-degree gate relations are trivial, where the prover directly sends the witness to the verifier, and the verifier checks that the permutation/high-degree gate relation holds. The degree of the permutation check is only <span class="math">1</span>, and the degree of the gate-check is the highest degree in the custom gate formula.</p>

    <p class="text-gray-300">The special-sound protocol for the lookup relation <span class="math">\\mathcal{R}_{\\text{LK}}</span> is more interesting as the statement of the lookup relation is not algebraic. Inspired by the log-derivative lookup</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: The special-sound protocols for PROTOSTAR and PROTOSTAR <span class="math">_{\\mathrm{ccs}}</span> . The special-sound protocol  <span class="math">\\Pi_{\\mathrm{mplkup}}</span>  for the multi-circuit Plonkup relation  <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span>  consists of the subprotocols for permutation, high-degree custom gate, lookup, and circuit selection relations. The special-sound protocol  <span class="math">\\Pi_{\\mathrm{mccs+}}</span>  for the extended CCS relation  <span class="math">\\mathcal{R}_{\\mathrm{mccs+}}</span>  consists of the sub-protocols for lookup, circuit selection, as well as the CCS relation [STW23]. From  <span class="math">\\Pi_{\\mathrm{mplkup}}</span>  or  <span class="math">\\Pi_{\\mathrm{mccs+}}</span> , we can apply the workflow described in Fig 1 to obtain the IVC schemes PROTOSTAR or PROTOSTAR <span class="math">_{\\mathrm{ccs}}</span> .</p>

    <p class="text-gray-300">scheme [Hab22], in Section 4.3, we design a simple 3-move special-sound protocol  <span class="math">\\Pi_{\\mathrm{LK}}</span>  for  <span class="math">\\mathcal{R}_{\\mathrm{LK}}</span> , in which the verifier degree is only 2. A great feature of  <span class="math">\\Pi_{\\mathrm{LK}}</span>  is that the number of non-zero elements in the prover messages is only proportional to the number of lookups, but independent of the table size. Thus the IVC prover complexity for computing the prover message commitments is independent of the table size, which is advantageous when the table size is much larger than the witness size. However, the prover work for computing the error terms is not independent of the table size because the accumulator is not sparse. Fortunately, we observe that the prover can efficiently update the error term commitments without recomputing the error term vectors from scratch, thus preserving the efficiency of the accumulation prover. Moreover, we extend  <span class="math">\\Pi_{\\mathrm{LK}}</span>  in Section 4.4 to further support vector-valued lookup, where each table entry is a vector of elements. This feature is useful in applications like zkEVM and for simulating bit operations in circuits.</p>

    <p class="text-gray-300">Given the special-sound protocols for permutation/high-degree gate/lookup relations, the special-sound protocol  <span class="math">\\Pi_{\\mathrm{plonkup}}</span>  for Plonkup is just a parallel composition of the three protocols. Furthermore, in Section 6, we apply a simple trick to support non-uniform IVC. More precisely, let  <span class="math">\\{\\mathcal{C}_i\\}_{i=1}^I</span>  be  <span class="math">I</span>  different branch circuits (e.g., the set of supported instructions in EVM), let  <span class="math">\\mathsf{pi} := (pc, \\mathsf{pi}&#x27;)</span>  be the public input where  <span class="math">pc \\in [I]</span>  is a program counter indicating which instruction/branch circuit is going to be executed in the next IVC step. Our goal is to prove that  <span class="math">(\\mathsf{pi}, \\mathbf{w})</span>  is in the relation  <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span>  in the sense that  <span class="math">\\mathcal{C}_{pc}(\\mathsf{pi}, \\mathbf{w}) = 0</span>  for witness  <span class="math">\\mathbf{w}</span> . The relation statement can also add additional constraints on  <span class="math">pc</span>  depending on the applications. The special-sound protocol for  <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span>  is almost</p>

    <p class="text-gray-300">identical to <span class="math">\\Pi_{\\mathrm{plonkup}}</span> for the Plonkup relation, except that the prover further sends a bool vector <span class="math">\\mathbf{b} \\in \\mathbb{F}^I</span>, and the verifier uses <span class="math">2I</span> degree 2 equations to check that <span class="math">b_{pc} = 1</span> and <span class="math">b_i = 0 \\forall i \\neq pc</span>. Additionally, each algebraic equation <span class="math">\\mathcal{G}</span> checked in <span class="math">\\Pi_{\\mathrm{plonkup}}</span> is replaced with <span class="math">\\sum_{i=1}^{I} \\mathcal{G}_i \\cdot b_i</span> where <span class="math">\\mathcal{G}_i</span> (<span class="math">1 \\leq i \\leq I</span>) is the corresponding gate in the <span class="math">i</span>-th branch circuit. The resulting special-sound protocol has 3 moves, and the verifier degree is <span class="math">d + 1</span>, where <span class="math">d</span> is the highest degree of the custom gates. This means that the IVC scheme for the non-uniform Plonkup relation adds negligible overhead to that for the Plonkup relation.</p>

    <h2 id="sec-9" class="text-2xl font-bold">1.2 Organization</h2>

    <p class="text-gray-300">We start by reviewing some relevant definitions in Section 2. In Section 3, we describe the generic protocols for transforming special-sound protocols to accumulation schemes. Particularly in Section 3.5, we present an approach to compress the verifier checks in special-sound protocols, so that the number of group operations in the resulting accumulation schemes is independent of the verifier check degree. In Section 3.6, we present efficient algorithms for computing the accumulation proofs. After that, in Section 4, we describe the special-sound subprotocols for various building block relations, and present PROTOSTAR, the compiled IVC scheme in Section 6.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300"><strong>Notation.</strong> For <span class="math">n \\in \\mathbb{N}</span>, we use <span class="math">[n]</span> to denote the set <span class="math">\\{1, 2, \\ldots, n\\}</span>; for <span class="math">a, b \\in \\mathbb{N}</span>, we use <span class="math">[a, b)</span> to denote the set <span class="math">\\{a, a + 1, \\ldots, b - 1\\}</span> and <span class="math">[a, b]</span> denote the set <span class="math">\\{a, a + 1, \\ldots, b\\}</span>. We denote <span class="math">\\lambda</span> as the security parameter and use <span class="math">\\mathbb{F}</span> to denote a field of prime order <span class="math">p</span> such that <span class="math">\\log(p) = \\Omega(\\lambda)</span>. For a vector <span class="math">\\mathbf{v} \\in \\mathbb{F}^n</span> and a subset <span class="math">S = \\{a_1, \\ldots, a_k\\} \\subseteq [n]</span> where <span class="math">a_1 &amp;lt; a_2 &amp;lt; \\dots &amp;lt; a_k</span>, we use <span class="math">\\mathbf{v}[S]</span> to denote the subvector of <span class="math">\\mathbf{v}</span> such that <span class="math">\\mathbf{v}[S] = (\\mathbf{v}_{a_1}, \\ldots, \\mathbf{v}_{a_k})</span>.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2.1 Special-sound Protocols and Fiat-Shamir Transform</h2>

    <p class="text-gray-300">We define special-soundness and non-interactive arguments according to the definitions by [AFK22].</p>

    <p class="text-gray-300"><strong>Definition 1 (Public-coin interactive proof).</strong> An interactive proof <span class="math">\\Pi = (\\mathsf{P},\\mathsf{V})</span> for relation <span class="math">\\mathcal{R}</span> is an interactive protocol between two probabilistic machines, a prover <span class="math">\\mathsf{P}</span>, and a polynomial time verifier <span class="math">\\mathsf{V}</span>. Both <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> take as public input a statement <span class="math">\\mathsf{pi}</span> and, additionally, <span class="math">\\mathsf{P}</span> takes as private input a witness <span class="math">\\mathbf{w} \\in \\mathcal{R}(\\mathsf{pi})</span>. The verifier <span class="math">\\mathsf{V}</span> outputs 0 if it accepts and a non-zero value otherwise. It's output is denoted by <span class="math">(\\mathsf{P}(\\mathbf{w}), \\mathsf{V})(\\mathsf{pi})</span>. Accordingly, we say the corresponding transcript (i.e., the set of all messages exchanged in the protocol execution) is accepting or rejecting. The protocol is public coin if the verifier randomness is public. The verifier messages are referred to as challenges. <span class="math">\\Pi</span> is a <span class="math">(2k - 1)</span>-move protocol if there are <span class="math">k</span> prover messages and <span class="math">k - 1</span> verifier messages.</p>

    <p class="text-gray-300">Definition 2 (Tree of transcript). Let <span class="math">\\mu \\in \\mathbb{N}</span> and <span class="math">(a_{1},\\ldots ,a_{\\mu})\\in \\mathbb{N}^{\\mu}</span>. An <span class="math">(a_{1},\\ldots ,a_{\\mu})</span>-tree of transcript for a <span class="math">(2\\mu +1)</span>-move public-coin interactive proof <span class="math">\\Pi</span> is a set of <span class="math">a_1\\cdot a_2\\dots a_\\mu</span> accepting transcripts arranged in a tree of depth <span class="math">\\mu</span> and arity <span class="math">a_1,\\ldots ,a_\\mu</span> respectively. The nodes in the tree correspond to the prover messages and the edges to the verifier's challenges. Every internal node at depth <span class="math">i - 1</span> (<span class="math">1\\leq i\\leq \\mu</span>) has <span class="math">a_{i}</span> children with distinct challenges. Every transcript corresponds to one path from the root to a leaf node. We simply write the transcripts as an <span class="math">(a^{\\mu})</span>-tree of transcript when <span class="math">a = a_{1} = a_{2} = \\dots = a_{\\mu}</span>.</p>

    <p class="text-gray-300">Definition 3 (Special-sound Interactive Protocol). Let <span class="math">\\mu, N \\in \\mathbb{N}</span> and <span class="math">(a_1, \\ldots, a_\\mu) \\in \\mathbb{N}^\\mu</span>. A <span class="math">(2\\mu + 1)</span>-move public-coin interactive proof <span class="math">\\Pi</span> for relation <span class="math">\\mathcal{R}</span> where the verifier samples its challenges from a set of size <span class="math">N</span> is <span class="math">(a_1, \\ldots, a_\\mu)</span>-out-of-<span class="math">N</span> special-sound if there exists a polynomial time algorithm that, on input <span class="math">\\mathsf{pi}</span> and any <span class="math">(a_1, \\ldots, a_\\mu)</span>-tree of transcript for <span class="math">\\Pi</span> outputs <span class="math">\\mathbf{w} \\in \\mathcal{R}(\\mathsf{pi})</span>. We simply denote the protocol as an <span class="math">a^\\mu</span>-out-of-<span class="math">N</span> (or <span class="math">a^\\mu</span>) special-sound protocol if <span class="math">a = a_1 = a_2 = \\dots = a_\\mu</span>.</p>

    <p class="text-gray-300">Definition 4 (Random-Oracle Non-Interactive Argument of Knowledge (RO-NARK)). A non-interactive random oracle proof for relation <span class="math">\\mathcal{R}</span> is a pair <span class="math">(\\mathsf{P},\\mathsf{V})</span> of probabilistic random-oracle algorithms, such that: Given <span class="math">(\\mathsf{pi},\\mathbf{w})\\in \\mathcal{R}</span> and access to a random oracle <span class="math">\\rho_{\\text{NARK}}</span>, the prover <span class="math">\\mathsf{P}^{\\rho_{\\text{NARK}}}(\\mathsf{pi},\\mathbf{w})</span> outputs a proof <span class="math">\\pi</span>. Given <span class="math">\\mathsf{pi}</span>, a proof <span class="math">\\pi</span>, and access to the same random oracle <span class="math">\\rho_{\\text{NARK}}</span>, the verifier <span class="math">\\mathsf{V}^{\\rho_{\\text{NARK}}}(\\mathsf{pi},\\pi)</span> outputs 0 to accept or any other value to reject.</p>

    <p class="text-gray-300">Perfect Completeness: The NARK has perfect completeness if for all <span class="math">(\\mathsf{pi},\\mathbf{w})\\in \\mathcal{R}</span></p>

    <div class="my-4 text-center"><span class="math-block">P \\left[ \\mathrm {V} ^ {\\rho_ {N A R K}} (\\mathrm {p i}, \\mathrm {P} ^ {\\rho_ {N A R K}} (\\mathrm {p i}, \\mathbf {w})) = 0 \\right] = 1</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Knowledge Soundness: The NARK has adaptive knowledge-soundness with knowledge error <span class="math">\\kappa : \\mathbb{N} \\times \\mathbb{N} \\to [0,1]</span> if there exists a knowledge extractor <span class="math">\\mathsf{Ext}</span>, with the following properties: The extractor, given input <span class="math">n</span>, and oracle-access to any polynomial-time <span class="math">Q</span>-query random oracle prover <span class="math">\\mathsf{P}^*</span> that outputs statement of size <span class="math">n</span>, runs in an expected polynomial time in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pi}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ Q<span class="math">, and outputs </span>\\{(\\mathsf{pi}, \\pi, \\mathsf{aux}, v; \\mathbf{w})\\}<span class="math"> such that a) </span>(\\mathsf{pi}, \\pi, \\mathsf{aux}, v)<span class="math"> is identically distributed to </span>\\{(\\mathsf{pi}, \\pi, \\mathsf{aux}, v)\\} : (\\mathsf{pi}, \\pi, \\mathsf{aux}) \\gets \\mathsf{P}^{*, \\rho_{\\text{NARK}}}, v \\gets \\mathsf{V}^{\\rho_{\\text{NARK}}}(\\mathsf{pi}, \\pi)$ and b)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf {p i}; \\mathbf {w}) \\in \\mathcal {R} \\\\ \\mathsf {V} ^ {\\rho_ {N A R K}} (\\mathsf {p i}, \\pi) = 0 \\end{array} : \\{( \\mathsf {p i}, \\pi , \\mathsf {a u x}, v; \\mathbf {w}) \\} \\leftarrow \\mathsf {E x t} ^ {\\mathsf {P} ^ {*}} \\right] \\geq \\frac {\\epsilon (\\mathsf {P} ^ {*}) - \\kappa (n , Q)}{\\mathsf {p o l y} (n)},</span></div>

    <p class="text-gray-300">where <span class="math">\\epsilon (\\mathsf{P}^{<em>})</span> is <span class="math">\\mathsf{P}</span>'s success probability, i.e. <span class="math">\\epsilon (\\mathsf{P}^{</em>}) = P[\\mathsf{V}^{\\rho_{\\text{NARK}}}(\\mathsf{pi},\\pi) = 0:(\\mathsf{pi},\\pi)\\gets \\mathsf{P}^{<em>,\\rho_{\\text{NARK}}}]</span>. Here, <span class="math">\\mathsf{Ext}</span> implements <span class="math">\\rho_{\\text{NARK}}</span> for <span class="math">\\mathsf{P}^{</em>}</span>; in particular, it can arbitrarily program the random oracle.</p>

    <p class="text-gray-300">Definition 5 (Fiat-Shamir Transform (adaptive)). The Fiat-Shamir transform <span class="math">\\mathsf{FS}[\\Pi] = (\\mathsf{P}_{\\mathsf{fs}}, \\mathsf{V}_{\\mathsf{fs}})</span> is a RO-NARK, where <span class="math">\\mathsf{P}^{\\rho_{\\text{NARK}}}(\\mathsf{pi}; \\mathbf{w})</span> runs <span class="math">\\mathsf{P}(\\mathsf{pi}; \\mathbf{w})</span> but instead of receiving challenge <span class="math">c_i</span>, on message <span class="math">m_i</span>, from the verifier, it computes it as follows:</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = \\rho_ {\\text {N A R K}} \\left(c _ {i - 1}, m _ {i}\\right) \\tag {1}</span></div>

    <p class="text-gray-300">and <span class="math">c_0 = \\rho_{\\text{NARK}}(\\mathfrak{pi})</span>. <span class="math">\\mathsf{P}_{\\mathrm{fs}}^{\\rho_{\\text{NARK}}}</span> outputs <span class="math">\\pi = (m_1, \\ldots, m_\\mu)</span>. The verifier <span class="math">\\mathsf{V}_{\\mathrm{fs}}^{\\rho_{\\text{NARK}}}</span> accepts, if <span class="math">\\mathsf{V}</span> accepts the transcript <span class="math">(m_1, c_1, \\ldots, m_\\mu, c_\\mu, m_{\\mu+1})</span> for input <span class="math">\\mathfrak{pi}</span> and the challenges are computed as per equation (1).</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.2 Adaptive Fiat-Shamir transform</h2>

    <p class="text-gray-300"><strong>Lemma 1</strong> (Fiat-Shamir transform of Special-sound Protocols [AFK22]). The Fiat-Shamir transform of a <span class="math">(\\alpha_{1},\\ldots ,\\alpha_{\\mu})</span>-out-of-<span class="math">N</span> special-sound interactive proof <span class="math">\\Pi</span> is knowledge sound with knowledge error</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa_{\\mathrm{fs}}(Q) = (Q + 1)\\kappa</span></div>

    <p class="text-gray-300">where <span class="math">\\kappa = 1 - \\prod \\left(1 - \\frac{\\alpha_i}{N}\\right)</span> is the knowledge error of the interactive proof <span class="math">\\Pi</span>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2.3 Commitment Scheme</h2>

    <p class="text-gray-300"><strong>Definition 6 (Commitment Scheme).</strong> <span class="math">\\mathsf{cm} = (\\mathsf{Setup},\\mathsf{Commit})</span> is a binding commitment scheme, consisting of two algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda}) \\to \\mathsf{ck}</span> takes as input the security parameter and outputs a commitment key <span class="math">\\mathsf{ck}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{ck}, \\mathbf{m} \\in \\mathcal{M}) \\to C \\in \\mathcal{C}</span>, takes as input the commitment key <span class="math">\\mathsf{ck}</span> and a message <span class="math">\\mathbf{m}</span> in <span class="math">\\mathcal{M}</span> and outputs a commitment <span class="math">C \\in \\mathcal{C}</span>.</p>

    <p class="text-gray-300">The scheme is binding if for all polynomial-time randomized algorithms <span class="math">\\mathsf{P}^*</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{m}) = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{m}^{\\prime}) &amp;amp; \\mathsf{ck} \\leftarrow \\mathsf{Setup}(1^{\\lambda}) \\\\ \\wedge &amp;amp; \\mathbf{m}, \\mathbf{m}^{\\prime} \\leftarrow \\mathsf{P}^{*}(\\mathsf{ck}) \\end{array} \\right] = \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300"><strong>Homomorphic commitment.</strong> We say the commitment is homomorphic if <span class="math">(\\mathcal{C}, +)</span> is an additive group of prime order <span class="math">p</span>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2.4 Incremental Verifiable Computation (IVC)</h2>

    <p class="text-gray-300">We adapt and simplify the definition from [BCLMS21; KST22].</p>

    <p class="text-gray-300"><strong>Definition 7 (IVC).</strong> An incremental verifiable computation (IVC) scheme for function predicates expressed in a circuit-satisfiability relation <span class="math">\\mathcal{R}_{\\mathrm{NP}}</span> is a tuple of algorithms IVC = <span class="math">(\\mathsf{P}_{\\mathrm{IVC}}, \\mathsf{V}_{\\mathrm{IVC}})</span> with the following syntax and properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathrm{IVC}}(m, z_0, z_m, z_{m-1}, \\mathbf{w}_{\\mathrm{loc}}, \\pi_{m-1}) \\to \\pi_m</span>. The IVC prover <span class="math">\\mathsf{P}_{\\mathrm{IVC}}</span> takes as input a program output <span class="math">z_m</span> at step <span class="math">m</span>, local data <span class="math">\\mathbf{w}_{\\mathrm{loc}}</span>, initial input <span class="math">z_0</span>, previous program output <span class="math">z_{m-1}</span> and proof <span class="math">\\pi_{m-1}</span> and outputs a new IVC proof <span class="math">\\pi_m</span>.</li>

      <li><span class="math">\\mathsf{V}_{\\mathrm{IVC}}(m, z_0, z_m, \\pi_m) \\to b</span>. The IVC verifier <span class="math">\\mathsf{V}_{\\mathrm{IVC}}</span> takes the initial input <span class="math">z_0</span>, the output <span class="math">z_m</span> at step <span class="math">m</span>, and an IVC proof <span class="math">\\pi_m</span>, 'accepts' by outputting <span class="math">b = 0</span> and 'rejects' otherwise.</li>

    </ul>

    <p class="text-gray-300">The scheme IVC has perfect adversarial completeness if for any function predicate <span class="math">\\phi</span> expressible in <span class="math">\\mathcal{R}_{\\mathsf{NP}}</span>, and any, possibly adversarially created, <span class="math">(m,z_0,z_m,,z_{m-1},\\mathbf{w}_{\\mathsf{loc}},\\pi_{m-1})</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\phi (z _ {0}, z _ {m}, z _ {m - 1}, \\mathbf {w} _ {\\mathsf {l o c}}) \\wedge (\\mathsf {V} _ {\\mathsf {I V C}} (m - 1, z _ {0}, z _ {m - 1}, \\pi_ {m - 1}) = 0)</span></div>

    <p class="text-gray-300">it holds that <span class="math">\\mathsf{V}_{\\mathsf{IVC}}(m,z_0,z_m,\\pi_m)</span> accepts for proof <span class="math">\\pi_{m}\\gets \\mathsf{P}_{\\mathsf{IVC}}(m,z_{0},z_{m - 1},z_{m},\\mathbf{w}_{\\mathsf{loc}},\\pi_{m - 1})</span>.</p>

    <p class="text-gray-300">The scheme IVC has knowledge soundness if for every expected polynomial-time adversary <span class="math">\\mathsf{P}^<em></span>, there exists an expected polynomial-time extractor <span class="math">\\mathsf{Ext}_{\\mathsf{P}^</em>}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {V} _ {\\mathsf {I V C}} (m, z _ {0}, z, \\pi_ {m}) = 0 \\wedge &amp;amp; [ \\phi , (m, z _ {0}, z, \\pi_ {m}) ] \\leftarrow \\mathsf {P} ^ {*} \\\\ ([ \\exists i \\in [ m ], \\neg \\phi (z _ {0}, z _ {i}, z _ {i - 1}, \\mathbf {w} _ {i}) ] &amp;amp; [ z _ {i}, \\mathbf {w} _ {i} ] _ {i = 1} ^ {m} \\leftarrow \\mathsf {E x t} _ {\\mathsf {P} ^ {*}} \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Here <span class="math">m</span> is a constant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The runtime of <span class="math">\\mathsf{P}_{\\mathsf{IVC}}</span> and <span class="math">\\mathsf{V}_{\\mathsf{IVC}}</span> as well as the size of <span class="math">\\pi_{\\mathsf{IVC}}</span> only depend on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ and are independent on the number of iterations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recently, [KS22] introduced the notion of non-uniform IVC, where the predicate <span class="math">\\phi</span> is selected from a fixed set of predicates at every step of the computation. The selection depends on the current state of the computation. Non-uniform IVC fits into our model by simply setting the predicate to be the union of all predicates, including the selection circuit. The one key difference is an additional efficiency requirement that the IVC prover in step <span class="math">i</span> only depends on the size of the predicate that is being executed in step <span class="math">i</span>. Our PROTOSTAR construction achieves this requirement.</p>

    <h2 id="sec-15" class="text-2xl font-bold">2.5 Simple Accumulation</h2>

    <p class="text-gray-300">We take definitions and proofs from [BCLMS21].</p>

    <p class="text-gray-300"><strong>Definition 8 (Accumulation Scheme).</strong> An accumulation scheme for a NARK <span class="math">(\\mathsf{P}_{\\mathsf{NARK}},\\mathsf{V}_{\\mathsf{NARK}})</span> is a triple of algorithms <span class="math">\\mathsf{acc} = (\\mathsf{P}_{\\mathsf{acc}},\\mathsf{V}_{\\mathsf{acc}},D)</span>, all of which have access to the same random oracle <span class="math">\\rho_{\\mathsf{acc}}</span> as well as <span class="math">\\rho_{\\mathsf{NARK}}</span>, the oracle for the NARK. The algorithms have the following syntax and properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{\\mathsf{acc}}(\\mathsf{pi}, \\pi = (\\pi.x, \\pi.w), \\mathsf{acc} = (\\mathsf{acc}.x, \\mathsf{acc}.w)) \\to \\{\\mathsf{acc}&#x27; = (\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w), \\mathsf{pf}\\}</span>. The accumulation prover <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> takes as input a statement <span class="math">\\mathsf{pi}</span>, NARK proof <span class="math">\\pi</span>, and an accumulator <span class="math">\\mathsf{acc}</span> and outputs a new accumulator <span class="math">\\mathsf{acc}&#x27;</span> and correction terms <span class="math">\\mathsf{pf}</span>.</li>

      <li><span class="math">\\mathsf{V}_{\\mathsf{acc}}(\\mathsf{pi}, \\pi.x, \\mathsf{acc}.x, \\mathsf{acc}&#x27;&#x27;.x, \\mathsf{pf}) \\to v</span>. The accumulation verifier takes as input the statement <span class="math">\\mathsf{pi}</span>, the instances of the NARK proof, the old and new accumulator, the correction terms, and 'accepts' by outputting 0 and 'rejects' otherwise.</li>

      <li><span class="math">D(\\mathsf{acc}) \\to v</span>. The decider on input <span class="math">\\mathsf{acc}</span> 'accepts' by outputting 0 and 'rejects' otherwise.</li>

    </ul>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">An accumulation scheme has knowledge-soundness with knowledge error <span class="math">\\kappa</span> if the RO-NARK <span class="math">(\\mathsf{P}^{\\prime},\\mathsf{V}^{\\prime})</span> has knowledge error <span class="math">\\kappa</span> for the relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{acc}}((\\mathsf{pi},\\pi.x,\\mathsf{acc}.x);(\\pi.\\mathsf{w},\\mathsf{acc}.\\mathsf{w})):(\\mathsf{V}_{\\mathsf{NARK}}(\\mathsf{pi},\\pi)=0\\wedge D(\\mathsf{acc})=0)\\ ,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{P}^{\\prime}</span> outputs <span class="math">\\mathsf{acc}^{\\prime},\\mathsf{pf}</span> and <span class="math">\\mathsf{V}^{\\prime}</span> on input <span class="math">((\\mathsf{pi},\\pi.x,\\mathsf{acc}.x),(\\mathsf{acc}^{\\prime},\\mathsf{pf}))</span> accepts if <span class="math">D(\\mathsf{acc}^{\\prime})</span> and <span class="math">\\mathsf{V}_{\\mathsf{acc}}(\\mathsf{pi},\\pi.x,\\mathsf{acc}.x,\\mathsf{acc}^{\\prime}.x,\\mathsf{pf})=0</span>.</p>

    <p class="text-gray-300">The scheme has perfect completeness if the RO-NARK <span class="math">(\\mathsf{P}^{\\prime},\\mathsf{V}^{\\prime})</span> has perfect completeness for <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 1 (IVC from accumulation<em>[x1]</em>).</h6>

    <p class="text-gray-300">Given a standard-model NARK for circuit-satisfiability and a standard-model accumulation scheme (Definition 8) for that NARK, both with negligible knowledge error, there exists an efficient transformation that outputs an IVC scheme (see Section 3.2 of <em>[x1]</em>) for constant-depth compliance predicates, assuming that the circuit complexity of the accumulation verifier <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> is sub-linear in its input.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Random Oracle.</h4>

    <p class="text-gray-300">Note that both the NARK and accumulation scheme we construct are in the random oracle model. However, Theorem 1 requires a NARK and an accumulation scheme in the standard model. It remains an open problem to construct such schemes. However, we can heuristically instantiate the random oracle with a cryptographic hash function and assume that the resulting schemes still have knowledge soundness.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 9 (Fiat-Shamir Heuristic).</h6>

    <p class="text-gray-300">The Fiat-Shamir Heuristic, relative to a secure cryptographic hash function <span class="math">\\mathsf{H}</span>, states that a random oracle NARK with negligible knowledge error yields a NARK that has negligible knowledge error in the standard (CRS) model if the random oracle is replaced with <span class="math">\\mathsf{H}</span>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Complexity.</h4>

    <p class="text-gray-300">The IVC transformation from <em>[x1]</em> recursively proves that the accumulation was performed correctly. To do that, it implements <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> as a circuit and proves that the previous accumulation step was done correctly. Note that this recursive circuit is independent of the size of <span class="math">\\pi.\\mathsf{w},\\mathsf{acc}.\\mathsf{w}</span> and the runtime of <span class="math">D</span>. The IVC prover is linear in the size of the recursive circuit plus the size of the IVC computation step expressed as a circuit. The final IVC verifier and the IVC proof size are linear in these components. This can be reduced using an additional SNARK as in <em>[x10]</em>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">PCD.</h4>

    <p class="text-gray-300">IVC can be generalized to arbitrary DAGs instead of just path graphs in a primitive called proof-carrying data<em>[x2]</em>. Accumulation schemes can be compiled into full PCD if they support accumulating an arbitrary number of accumulators and proofs<em>[x2, x1]</em>. For simplicity, we only build accumulation for one proof and one accumulator, as well as for two accumulators. This enables PCD for DAGs of degree two. By transforming higher degree graphs into degree two graphs (by converting each degree <span class="math">d</span> node into a <span class="math">\\log_{2}(d)</span> depth tree), we can achieve PCD for these graphs.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Outsourcing the decider.</h5>

    <p class="text-gray-300">In the accumulation to IVC transformation, the IVC proof is linear in the accumulator, and the IVC verifier runs the decider. The accumulation schemes we construct are linear in the witness of a single computation step. However, we can outsource the decider by providing a SNARK that, given <span class="math">\\mathsf{acc}.x</span>, proves knowledge of <span class="math">\\mathsf{acc.w}</span>, such that <span class="math">D(\\mathsf{acc})=0</span>. Nova[KST22] constructs a custom, concretely efficient SNARK for their accumulation/folding scheme. However, when outsourcing the decider, the IVC cannot continue. This breaks the strict completeness requirement of IVC, which says that any prover can continue from any valid IVC proof. Nevertheless, this may be fine for some applications of IVC.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3 Protocols</h2>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.1 Special-sound Protocols</h3>

    <p class="text-gray-300">In this section, we describe a class of special-sound protocols whose verifier is algebraic. The protocol <span class="math">\\Pi_{\\mathsf{sps}}</span> has 3 essential parameters <span class="math">k,d,\\ell\\in\\mathbb{N}</span>, meaning that <span class="math">\\Pi_{\\mathsf{sps}}</span> is a <span class="math">(2k-1)</span>-move protocol with verifier degree <span class="math">d</span> and output length <span class="math">\\ell</span> (i.e. the verifier checks <span class="math">\\ell</span> degree <span class="math">d</span> algebraic equations). In each round <span class="math">i</span> (<span class="math">1\\leq i\\leq k</span>), the prover <span class="math">\\mathsf{P}_{\\mathsf{sps}}(\\mathsf{pi},\\mathbf{w},[\\mathbf{m}_{j},r_{j}]_{j=1}^{i-1})</span> generates the next message <span class="math">\\mathbf{m}_{i}</span> on input the public input <span class="math">\\mathsf{pi}</span>, the witness <span class="math">\\mathbf{w}</span>, and the current transcript <span class="math">[\\mathbf{m}_{j},r_{j}]_{j=1}^{i-1}</span>, and sends <span class="math">\\mathbf{m}_{i}</span> to the verifier; the verifier replies with a random challenge <span class="math">r_{i}\\in\\mathbb{F}</span>. After the final message <span class="math">\\mathbf{m}_{k}</span>, the verifier computes the algebraic map <span class="math">\\mathsf{V}_{\\mathsf{sps}}</span> and checks that the output is a zero vector of length <span class="math">\\ell</span>. More precisely, <span class="math">\\deg(\\mathsf{V}_{\\mathsf{sps}})=d</span>, s.t.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{V}_{\\mathsf{sps}}(\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1}):=\\sum_{j=0}^{d}f_{j}^{\\mathsf{V}_{\\mathsf{sps}}}(\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1})\\,,</span></p>

    <p class="text-gray-300">where <span class="math">f_{j}^{\\mathsf{V}_{\\mathsf{sps}}}</span> is a homogeneous degree-<span class="math">j</span> algebraic map that outputs a vector of <span class="math">\\ell</span> field elements. We describe the special-sound protocol <span class="math">\\Pi_{\\mathsf{sps}}</span> below.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">|  Special-sound Protocol Πsps = (Psps, Vsps) for relation R with algebraic verifier  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mi← Psps(pi, w, [mj, rj]i-1j=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ri</td>

            <td class="px-3 py-2 border-b border-gray-700">ri←# F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Repeat k-1 time</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Repeat k-1 time</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Final message mk |   |</p>

    <p class="text-gray-300">|   |  | Vsps(pi, [mi]i=1, [ri]i=1) = 0l  |</p>

    <p class="text-gray-300">For a commitment scheme  <span class="math">\\mathsf{cm} = (\\mathsf{Setup},\\mathsf{Commit})</span> , consider the following relation  <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{\\mathcal{R}} = (x;\\mathbf{w},\\mathbf{m}\\in \\mathcal{M},\\mathbf{m}&#x27;\\in \\mathcal{M}):\\{(x,\\mathbf{w})\\in \\mathcal{R}\\lor (\\mathsf{Commit}(\\mathbf{m}) = \\mathsf{Commit}(\\mathbf{m}&#x27;)\\land \\mathbf{m}\\neq \\mathbf{m}&#x27;)\\}</span> . The relation's witness is either a valid witness for  <span class="math">\\mathcal{R}</span>  or a break of the commitment scheme  <span class="math">\\mathsf{cm}</span> . We now design a special-sound protocol  <span class="math">\\Pi_{\\mathsf{cm}} = (\\mathsf{P}_{\\mathsf{cm}},\\mathsf{V}_{\\mathsf{cm}})</span>  for  <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{\\mathcal{R}}</span>  given  <span class="math">\\Pi_{\\mathsf{sps}} = (\\mathsf{P}_{\\mathsf{sps}},\\mathsf{V}_{\\mathsf{sps}})</span> , a special-sound protocol for  <span class="math">\\mathcal{R}</span> .  <span class="math">\\mathsf{P}_{\\mathsf{cm}}</span>  runs  <span class="math">\\mathsf{P}_{\\mathsf{sps}}</span>  to generate the  <span class="math">i</span> th message and then commits to the message. Along with the final message,  <span class="math">\\mathsf{P}_{\\mathsf{cm}}</span>  sends the opening to the commitment. The verifier  <span class="math">\\mathsf{V}_{\\mathsf{cm}}</span>  checks the correctness of the commitments and runs  <span class="math">\\mathsf{V}_{\\mathsf{sps}}</span>  on the commitment openings.</p>

    <p class="text-gray-300">|  Special-sound Protocol Πcm for RCRm as a cm transform of Πsps = (Psps, Vsps)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  mi← Psps(pi, w, [mj, rj]i-1j=1) |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ci← Commit(ck, mi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ci</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Repeat k-1 time</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Repeat k-1 time</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ck← Commit(ck, mk)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ck</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Opening [mi]k i=1 |   |</p>

    <p class="text-gray-300">|   |  | Commit(ck, mi) = Ci∀i ∈ [k]  |</p>

    <p class="text-gray-300">|   |  | Vsp(spi, [mi]k i=1, [ri]k-1) = 0€  |</p>

    <p class="text-gray-300">Lemma 2 ( <span class="math">\\Pi_{\\mathsf{cm}}</span>  is  <span class="math">(a_1, \\ldots, a_\\mu)</span> -special-sound). Let  <span class="math">\\Pi_{\\mathsf{sps}}</span>  be an  <span class="math">(a_1, \\ldots, a_\\mu)</span> -out-of- <span class="math">N</span>  special-sound protocol for relation  <span class="math">\\mathcal{R}</span> , where the prover messages are all in a set  <span class="math">\\mathcal{M}</span> . Let (Setup, Commit) be a binding commitment scheme for messages in  <span class="math">\\mathcal{M}</span> . For  <span class="math">\\mathsf{ck} \\gets \\mathsf{Setup}_{\\mathsf{cm}}(1^{\\lambda})</span>  let  <span class="math">\\mathcal{R}_{\\mathsf{cm}} = (\\mathsf{pi}; \\mathsf{w}, m \\in \\mathcal{M}, m&#x27; \\in \\mathcal{M}) : (\\mathsf{pi}; \\mathsf{w}) \\in \\mathcal{R} \\vee (\\mathsf{Commit}(\\mathsf{ck}, m) = \\mathsf{Commit}(\\mathsf{ck}, m&#x27;) \\wedge m \\neq m&#x27;)</span> . Then  <span class="math">\\Pi_{\\mathsf{cm}} = \\mathsf{cm}[\\Pi_{\\mathsf{sps}}]</span>  is an  <span class="math">(a_1, \\ldots, a_\\mu)</span> -out-of- <span class="math">N</span>  special-sound protocol for  <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{\\mathcal{R}}</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span>  be the extractor for  <span class="math">\\Pi_{\\mathsf{sps}}</span> . We will construct  <span class="math">\\mathsf{Ext}_{\\mathsf{cm}}</span>  for  <span class="math">\\Pi_{\\mathsf{cm}}</span>  that computes a witness for  <span class="math">\\mathcal{R}_{\\mathsf{cm}}</span> , i.e., a witness for  <span class="math">\\mathcal{R}</span>  or a collision for  <span class="math">\\mathsf{cm}</span>  given an  <span class="math">(a_1, \\ldots, a_\\mu)</span> -transcript tree for  <span class="math">\\Pi_{\\mathsf{cm}}</span> . The extractor  <span class="math">\\mathsf{Ext}_{\\mathsf{cm}}</span>  first checks whether there exist two transcripts that have inconsistent final messages. That is, the final message opening is different for the nodes in the intersection of the root-to-leaf paths of these two transcripts. This means we have  <span class="math">\\mathbf{m}_i</span>  and  <span class="math">\\mathbf{m}_i&#x27;</span> , such that  <span class="math">\\mathsf{Commit}(\\mathbf{m}_i) = \\mathsf{Commit}(\\mathbf{m}_i&#x27;)</span>  and  <span class="math">\\mathbf{m}_i \\neq \\mathbf{m}_i&#x27;</span> . This is a break for  <span class="math">\\mathsf{cm}</span> , i.e., a valid witness for  <span class="math">\\mathcal{R}_{\\mathsf{cm}}</span> . Otherwise  <span class="math">\\mathsf{Ext}_{\\mathsf{cm}}</span>  builds a transcript tree for  <span class="math">\\Pi_{\\mathsf{sps}}</span>  by replacing all commitments with the openings and use  <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span>  to compute  <span class="math">\\mathbf{w} \\in \\mathcal{R}(\\mathsf{pi})</span> , such that  <span class="math">(\\mathbf{w}, \\bot, \\bot) \\in \\mathcal{R}_{\\mathsf{cm}}(\\mathsf{pi})</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\rho_{\\mathrm{NARK}}</span>  be a random oracle. Let  <span class="math">\\Pi_{\\mathrm{cm}}</span>  be the commit-and-open protocol for the special-sound protocol  <span class="math">\\Pi_{\\mathrm{sps}} = (\\mathsf{P}_{\\mathrm{sps}},\\mathsf{V}_{\\mathrm{sps}})</span> . The Fiat-Shamir Transform  <span class="math">\\mathsf{FS}[\\Pi_{\\mathrm{cm}}]</span>  of the protocol  <span class="math">\\Pi_{\\mathrm{cm}}</span>  is the following. By Lemma 1,  <span class="math">\\mathsf{FS}[\\Pi_{\\mathrm{cm}}]</span>  is knowledge sound if  <span class="math">\\Pi_{\\mathrm{sps}}</span>  is special-sound.</p>

    <p class="text-gray-300">|  Fiat-Shamir Transform FS of Special-sound Protocol Π for relation RCR: FS[Πcm]  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  r0← ρNARK(pi) |   |</p>

    <p class="text-gray-300">|  For i ∈ [k-1]: |   |</p>

    <p class="text-gray-300">|  mi← Psps(pi, w, [mj, rj]i=1j=1) |   |</p>

    <p class="text-gray-300">|  Ci← Commit(ck, mi) |   |</p>

    <p class="text-gray-300">|  ri← ρNARK(ri-1, Ci) |   |</p>

    <p class="text-gray-300">|  mk← Psps(pi, w, [mj, rj]k-1j=1) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ck← Commit(ck, mi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π.x = [Ci]k i=1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | π.w = [mi]k i=1  |</p>

    <p class="text-gray-300">|   | r0← ρNARK(x)  |</p>

    <p class="text-gray-300">|   | ri← ρNARK(ri-1, Ci) ∀i ∈ [k-1]  |</p>

    <p class="text-gray-300">|   | Commit(ck, mi) = Ci ∀i ∈ [k]  |</p>

    <p class="text-gray-300">|   | Vspps(pi, π.x, π.w, [ri]k-1i=1) = 0l  |</p>

    <p class="text-gray-300">Let  <span class="math">\\rho_{\\mathrm{acc}}</span>  and  <span class="math">\\rho_{\\mathrm{NARK}}</span>  be two random oracles, and let  <span class="math">V_{\\mathrm{NARK}}</span>  be the verifier of  <span class="math">\\mathsf{FS}[\\Pi_{\\mathsf{cm}}]</span>  in Section 3.3, whose underlying special-sound protocol is  <span class="math">\\Pi_{\\mathsf{sps}} = (\\mathsf{P}_{\\mathsf{sps}}, V_{\\mathsf{sps}})</span>  for a relation  <span class="math">\\mathcal{R}</span> . We describe the accumulation scheme for  <span class="math">V_{\\mathrm{NARK}}</span> .</p>

    <p class="text-gray-300">The accumulated predicate. The predicate to be accumulated is the "relaxed" verifier check of the NARK scheme  <span class="math">\\mathsf{FS}[\\Pi_{\\mathsf{cm}}]</span>  for relation  <span class="math">\\mathcal{R}</span> . Namely, given public input  <span class="math">\\mathsf{pi} \\in \\mathcal{M}^{\\ell_{\\mathrm{in}}}</span> , random challenges  <span class="math">[r_i]_{i=1}^{k-1} \\in \\mathbb{F}^{k-1}</span> , a NARK proof</p>

    <div class="my-4 text-center"><span class="math-block">\\pi . x = \\left[ C _ {i} \\right] _ {i = 1} ^ {k}, \\pi . \\mathbf {w} = \\left[ \\mathbf {m} _ {i} \\right] _ {i = 1} ^ {k}</span></div>

    <p class="text-gray-300">where  <span class="math">[C_i]_{i=1}^k \\in \\mathcal{C}^k</span>  are commitments and  <span class="math">[\\mathbf{m}_i]_{i=1}^k</span>  are prover messages in the special-sound protocol  <span class="math">\\Pi_{\\mathrm{sps}}</span> , and a slack variable  <span class="math">\\mu</span> , the predicate checks that (i)  <span class="math">r_i = \\rho_{\\mathrm{NARK}}(r_{i-1}, C_i)</span>  for all  <span class="math">i \\in [k-1]</span>  (where  <span class="math">r_0 := \\rho_{\\mathrm{NARK}}(\\mathrm{pi})</span> ), (ii)  <span class="math">\\mathrm{Commit}(\\mathrm{ck}, \\mathbf{m}_i) = C_i</span>  for all  <span class="math">i \\in [k]</span> , and (iii)</p>

    <div class="my-4 text-center"><span class="math-block">V _ {s p s} (\\mathsf {p i}, \\pi . x, \\pi . \\mathbf {w}, [ r _ {i} ] _ {i = 1} ^ {k - 1}, \\mu) := \\sum_ {j = 0} ^ {d} \\mu^ {d - j} \\cdot f _ {j} ^ {V _ {s p s}} (\\mathsf {p i}, \\pi . \\mathbf {w}, [ r _ {i} ] _ {i = 1} ^ {k - 1}) = \\mathbf {e}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{e} = \\mathbf{0}^{\\ell}</span>  and  <span class="math">\\mu = 1</span>  for the NARK verifier  <span class="math">V_{\\mathrm{NARK}}</span> . Here  <span class="math">f_{j}^{V_{\\mathrm{sps}}}</span>  is a degree- <span class="math">j</span>  homogeneous algebraic map that outputs  <span class="math">\\ell</span>  field elements. Degree- <span class="math">j</span>  homogeneity says that each monomial term of  <span class="math">f_{j}^{V_{\\mathrm{sps}}}</span>  has degree exactly  <span class="math">j</span> .</p>

    <p class="text-gray-300">Remark 1.</p>

    <p class="text-gray-300">Without loss of generality, we assume that the public input <span class="math">\\mathsf{pi}</span> is of constant size, as otherwise, we can set it as the hash of the original public input.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Accumulator.</h4>

    <p class="text-gray-300">The accumulator has the following format:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Accumulator instance <span class="math">\\mathsf{acc}.x\\coloneqq\\{\\mathsf{pi},[C_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1},E,\\mu\\}</span>, where <span class="math">\\mathsf{pi}\\in\\mathcal{M}^{\\ell_{\\text{in}}}</span> is the accumulated public input, <span class="math">[C_{i}]_{i=1}^{k}\\in\\mathcal{C}^{k}</span> are the accumulated commitments, <span class="math">[r_{i}]_{i=1}^{k-1}\\in\\mathbb{F}^{k-1}</span> are the accumulated challenges, <span class="math">E\\in\\mathcal{C}</span> is the accumulated commitment to the error terms, and <span class="math">\\mu\\in\\mathbb{F}</span> is a slack variable.</li>

      <li>Accumulator witness <span class="math">\\mathsf{acc.w}\\coloneqq\\{[\\mathbf{m}_{i}]_{i=1}^{k}\\}</span>, where <span class="math">[\\mathbf{m}_{i}]_{i=1}^{k}</span> are the accumulated prover messages.</li>

    </ul>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Accumulation prover.</h4>

    <p class="text-gray-300">On input commitment key <span class="math">\\mathsf{ck}</span> (which can be hardwired in the prover’s algorithm), accumulator <span class="math">\\mathsf{acc}</span>, an instance-proof pair <span class="math">(\\mathsf{pi},\\pi)</span> where</p>

    <p class="text-gray-300"><span class="math">\\mathsf{acc}\\coloneqq(\\mathsf{acc}.x=\\{\\mathsf{pi}^{\\prime},[C_{i}^{\\prime}]_{i=1}^{k},[r_{i}^{\\prime}]_{i=1}^{k-1},E,\\mu\\},\\mathsf{acc.w}=\\{[\\mathbf{m}_{i}^{\\prime}]_{i=1}^{k}\\})\\,,</span> <span class="math">\\pi\\coloneqq(\\pi.x=[C_{i}]_{i=1}^{k},\\pi.\\mathbf{w}=[\\mathbf{m}_{i}]_{i=1}^{k}),</span></p>

    <p class="text-gray-300">the accumulation prover <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> works as in Figure 3.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Accumulation verifier.</h4>

    <p class="text-gray-300">On input public input <span class="math">\\mathsf{pi}</span>, NARK proof instance <span class="math">\\pi.x</span>, accumulator instance <span class="math">\\mathsf{acc}.x</span>, accumulation proof <span class="math">\\mathsf{pf}</span>, and the updated accumulator instance <span class="math">\\mathsf{acc}^{\\prime}.x\\coloneqq\\{\\mathsf{pi}^{\\prime\\prime},[C_{i}^{\\prime\\prime}]_{i=1}^{k},[r_{i}^{\\prime\\prime}]_{i=1}^{k},E^{\\prime},\\mu^{\\prime}\\}</span>, the accumulation verifier <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> works as in Figure 4.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Decider.</h4>

    <p class="text-gray-300">On input the commitment key <span class="math">\\mathsf{ck}</span> (which can be hardwired) and an accumulator</p>

    <p class="text-gray-300"><span class="math">\\mathsf{acc}=(\\mathsf{acc}.x=\\{\\mathsf{pi},[C_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1},E,\\mu\\},\\mathsf{acc.w}=\\{[\\mathbf{m}_{i}]_{i=1}^{k}\\})\\,,</span></p>

    <p class="text-gray-300">the decider does the checks described in Figure 5.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">The accumulation scheme for <span class="math">\\mathsf{V}_{\\mathsf{NARK}}</span> is also naturally a folding scheme as defined in Nova <em>[x10]</em>, where we can view an accumulator as a <em>relaxed</em> NP instance with error terms. A NARK proof <span class="math">\\pi</span> is an accumulator with <span class="math">\\mu=1</span> and <span class="math">E=0\\in\\mathbb{G}</span>. We can use the same accumulation scheme to fold two accumulators <span class="math">(\\mathsf{acc},\\mathsf{acc}^{\\prime})</span> into a new accumulator <span class="math">\\mathsf{acc}^{\\prime\\prime}</span>. The scheme is identical to the one presented above but with non-trivial <span class="math">\\mu,\\mathsf{e},E</span> terms for <span class="math">\\mathsf{acc}</span>. The verifier performs one additional group scalar multiplication. In the language of folding schemes, we can fold two NARK instances into an accumulator; or fold a NARK instance and an accumulator into an updated accumulator; or fold two accumulators into an updated accumulator.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{\\mathrm{acc}}^{\\rho_{\\mathrm{acc}},\\rho_{\\mathrm{NARK}}}(\\mathsf{ck},\\mathsf{acc},(\\mathsf{pi},\\pi))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r_i \\gets \\rho_{\\mathsf{NARK}}(r_{i-1}, C_i) \\forall i \\in [k-1]</span>  where  <span class="math">r_0 := \\rho_{\\mathsf{NARK}}(\\mathsf{pi})</span> .</li>

      <li>Compute  <span class="math">[\\mathbf{e}_j]_{j=1}^{d-1} \\in (\\mathbb{F}^\\ell)^{d-1}</span> , such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {j = 0} ^ {d} (X + \\mu) ^ {d - j} \\cdot f _ {j} ^ {\\mathrm {V} _ {\\mathrm {q m}}} (X \\cdot \\mathrm {p i} + \\mathrm {p i} ^ {\\prime}, [ X \\cdot \\mathbf {m} _ {i} + \\mathbf {m} _ {i} ^ {\\prime} ] _ {i = 1} ^ {k}, [ X \\cdot r _ {i} + r _ {i} ^ {\\prime} ] _ {i = 1} ^ {k - 1}) \\\\ = \\sum_ {j = 0} ^ {d} \\mu^ {d - j} f _ {j} ^ {\\mathrm {V} _ {\\mathrm {q m}}} (\\mathrm {p i} ^ {\\prime}, [ \\mathbf {m} _ {i} ^ {\\prime} ] _ {i = 1} ^ {k}, [ r _ {i} ^ {\\prime} ] _ {i = 1} ^ {k - 1}) + X ^ {d} \\cdot \\mathrm {V} _ {\\mathrm {N A R K}} (\\mathrm {p i}, [ \\mathbf {m} _ {i} ] _ {i = 1} ^ {k}, [ r _ {i} ] _ {i = 1} ^ {k - 1}) + \\sum_ {j = 1} ^ {d - 1} \\mathbf {e} _ {j} X ^ {j} \\\\ = \\mathbf {e} + \\sum_ {j = 1} ^ {d - 1} \\mathbf {e} _ {j} X ^ {j} \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">E_{j}\\gets \\mathrm{Commit}(\\mathsf{ck},\\mathsf{e}_{j})\\forall j\\in [d - 1]</span></li>

      <li><span class="math">\\alpha \\gets \\rho_{\\mathrm{acc}}(\\mathrm{acc}.x,\\mathrm{pi},\\pi .x,[E_j]_{j = 1}^{d - 1})\\in \\mathbb{F}</span></li>

      <li>Set vectors</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {v} := \\left(1, \\mathrm {p i}, [ r _ {i} ] _ {i = 1} ^ {k - 1}, [ C _ {i} ] _ {i = 1} ^ {k}, [ \\mathbf {m} _ {i} ] _ {i = 1} ^ {k}\\right), \\mathbf {v} ^ {\\prime} := \\left(\\mu , \\mathrm {p i} ^ {\\prime}, [ r _ {i} ^ {\\prime} ] _ {i = 1} ^ {k - 1}, [ C _ {i} ^ {\\prime} ] _ {i = 1} ^ {k}, [ \\mathbf {m} _ {i} ^ {\\prime} ] _ {i = 1} ^ {k}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{v}&#x27;&#x27; := \\left(\\mu&#x27;, \\mathsf{pi}&#x27;&#x27;, [r_i&#x27;&#x27;]_{i=1}^{k-1}, [C_i&#x27;&#x27;]_{i=1}^{k}, [\\mathbf{m}_i&#x27;&#x27;]_{i=1}^k\\right) \\gets \\alpha \\cdot \\mathbf{v} + \\mathbf{v}&#x27;</span> .</li>

      <li><span class="math">E^{\\prime}\\gets E + \\sum_{j = 1}^{d - 1}\\alpha^{j}\\cdot E_{j}</span></li>

      <li>Set  <span class="math">\\mathsf{acc}^{\\prime}.x\\coloneqq \\{\\mathsf{pi}^{\\prime \\prime},[C_i^{\\prime \\prime}]_{i = 1}^k,[r_i^{\\prime \\prime}]_{i = 1}^k,E&#x27;,\\mu &#x27;\\}</span> <span class="math">\\mathsf{acc}^{\\prime}.\\mathbf{w}\\coloneqq \\{[\\mathbf{m}_i^{\\prime \\prime}]_{i = 1}^k\\}</span></li>

      <li>Set accumulation proof  <span class="math">\\mathsf{pf} \\coloneqq [E_j]_{j=1}^{d-1}</span></li>

    </ol>

    <p class="text-gray-300">Figure 3: Accumulation Prover for low-degree Fiat-Shamired NARKs</p>

    <p class="text-gray-300"><span class="math">\\mathsf{V}_{\\mathrm{acc}}^{\\rho_{\\mathrm{acc}},\\rho_{\\mathrm{NARK}}}(\\mathsf{pi},\\pi .x = [C_i]_i = 1^k,\\mathsf{acc}.x = (\\mathsf{pi}&#x27;,[C_i&#x27;]_i = 1^k,[r_i&#x27;]_i = 1^k,E,\\mu),\\mathsf{pf} = [E_j]_{j = 1}^{d - 1},\\mathsf{acc}&#x27;\\cdot x)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r_i \\gets \\rho_{\\mathsf{NARK}}(r_{i-1}, C_i) \\forall i \\in [k-1]</span>  where  <span class="math">r_0 \\coloneqq \\rho_{\\mathsf{NARK}}(\\mathsf{pi})</span> .</li>

      <li><span class="math">\\alpha \\gets \\rho_{\\mathrm{acc}}(\\mathrm{acc}.x,\\mathrm{pi},\\pi .x,\\mathrm{pf})</span></li>

      <li>Set vectors</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {v} := \\left(1, \\mathrm {p i}, [ r _ {i} ] _ {i = 1} ^ {k - 1}, [ C _ {i} ] _ {i = 1} ^ {k}\\right), \\mathbf {v} ^ {\\prime} := \\operatorname {a c c}. x. \\left(\\mu , \\mathrm {p i} ^ {\\prime}, [ r _ {i} ^ {\\prime} ] _ {i = 1} ^ {k - 1}, [ C _ {i} ^ {\\prime} ] _ {i = 1} ^ {k}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check  <span class="math">\\mathsf{acc}^{\\prime}.x</span> .  <span class="math">\\left(\\mu^{\\prime},\\mathsf{pi}^{\\prime \\prime},[r_i^{\\prime \\prime}]_{i = 1}^{k - 1},[C_i^{\\prime \\prime}]_{i = 1}^k\\right)\\stackrel {?}{=}\\alpha \\cdot \\mathbf{v} + \\mathbf{v}&#x27;</span></li>

      <li>Check  <span class="math">\\mathsf{acc}^{\\prime}.x.E^{\\prime}\\stackrel {?}{=}\\mathsf{acc}.x.E + \\sum_{j = 1}^{d - 1}\\alpha^{j}\\cdot E_{j}.</span></li>

    </ol>

    <p class="text-gray-300">Figure 4: Accumulation Verifier for low-degree Fiat-Shamired NARKs</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 5: Accumulation Decider for low-degree Fiat-Shamired NARKs</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity. Let  <span class="math">\\Pi_{\\mathrm{sps}}</span>  be a  <span class="math">(2k - 1)</span> -move special-sound protocol with the verifier checking  <span class="math">\\ell</span>  degree- <span class="math">d</span>  equations. Denote by  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  the number of elements in prover messages and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  the number of non-zero elements in the prover messages. Assume that  </span>\\mathsf{pi}<span class="math">  is a hash with length 1 (this saves the call  </span>r_0 \\coloneqq \\rho_{\\mathsf{NARK}}(\\mathsf{pi})<span class="math"> ), and let  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  be the number of elements in verifier's challenges. We analyze the computational complexity of the accumulation scheme:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation prover</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>asks  <span class="math">k - 1</span>  queries to  <span class="math">\\rho_{\\mathsf{NARK}}</span>  and 1 query to  <span class="math">\\rho_{\\mathsf{acc}}</span> ;</li>

      <li>computes  <span class="math">E_{j} = \\mathsf{Commit}(\\mathsf{ck},\\mathbf{e}_{j})</span>  for all  <span class="math">j\\in [d - 1]</span> , where  <span class="math">\\mathbf{e}_j\\in \\mathbb{F}^\\ell</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- performs  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2<span class="math">  F-ops to combine  </span>(\\mu, \\mathsf{pi}, [r_i]_{i=1}^{k-1}, [\\mathbf{m}_i]_{i=1}^k)$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>performs  <span class="math">k</span>  G-ops to combine  <span class="math">[C_i]_{i=1}^k</span> ;</li>

      <li>computes the coefficients of  <span class="math">\\ell</span>  degree- <span class="math">d</span>  polynomials for  <span class="math">[\\mathbf{e}_j]_{j=1}^{d-1}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation verifier performs</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>asks  <span class="math">k - 1</span>  constant size queries to  <span class="math">\\rho_{\\mathsf{NARK}}</span>  and 1  <span class="math">d</span> -sized query to  <span class="math">\\rho_{\\mathsf{acc}}</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2<span class="math">  F-ops to combine  </span>(\\mu, \\mathsf{pi}, [r_i]_{i=1}^{k-1})$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k</span>  G-ops to combine  <span class="math">[C_i]_{i=1}^k</span> ;</li>

      <li><span class="math">d - 1</span>  G-ops to add  <span class="math">[E_j]_{j=1}^{d-1}</span>  onto  <span class="math">E</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The decider</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- computes  <span class="math">C_i = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{m}_i)</span>  for  <span class="math">i \\in [k]</span>  and  <span class="math">E = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e})</span> , with total complexity around  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell$  G-ops.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>evaluate  <span class="math">\\ell</span>  degree- <span class="math">d</span>  multivariate polynomials to compute vector  <span class="math">\\mathbf{e}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2. Let  <span class="math">(\\mathsf{P}_{\\mathsf{NARK}},\\mathsf{V}_{\\mathsf{NARK}})</span>  be the RO-NARK defined in Section 3.3. Let  <span class="math">\\mathsf{cm} =</span>  (Setup, Commit) be a binding, homomorphic commitment scheme. Let  <span class="math">\\rho_{\\mathrm{acc}}</span>  be another random oracle. The accumulation scheme  <span class="math">(\\mathsf{P}_{\\mathrm{acc}},\\mathsf{V}_{\\mathrm{acc}},D_{\\mathrm{acc}})</span>  for  <span class="math">\\mathsf{V}_{\\mathsf{NARK}}</span>  satisfies perfect completeness and has knowledge error  $(Q + 1)\\frac{d + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} +\\mathsf{negl}(\\lambda)<span class="math">  as defined in Definition 8, against any randomized polynomial-time  </span>Q$ -query adversary.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Completeness.</h5>

    <p class="text-gray-300">Consider any tuple <span class="math">((\\mathsf{pi},\\pi),\\mathsf{acc})\\in\\mathcal{R}_{\\mathsf{acc}}</span>, that is, <span class="math">\\mathsf{V}_{\\mathsf{NARK}}(\\mathsf{pi},\\pi)</span> and <span class="math">D(\\mathsf{acc})</span> both accept. Let <span class="math">(\\mathsf{acc}^{\\prime},\\mathsf{pf})</span> denote the output of the accumulation prover <span class="math">\\mathsf{P}_{\\mathsf{acc}}(\\mathsf{ck},\\mathsf{acc},(\\mathsf{pi},\\pi))</span>. We argue that both the decider <span class="math">D(\\mathsf{acc}^{\\prime})</span> and the accumulation verifier <span class="math">\\mathsf{V}_{\\mathsf{acc}}(\\mathsf{pi},\\pi.x,\\mathsf{acc}.x,\\mathsf{pf},\\mathsf{acc}^{\\prime}.x)</span> will accept, which finishes the proof of perfect completeness by Definition 8.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> accepts as <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> and <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> go through the same process of computing challenges <span class="math">[r_{i}]_{i=1}^{k-1}</span> and <span class="math">\\alpha</span>, thus the linear combinations of <span class="math">\\mathsf{acc}.x</span> and <span class="math">(\\mathsf{pi},\\pi.x;\\mathsf{pf},[r_{i}]_{i=1}^{k-1})</span> via <span class="math">\\alpha</span> will be consistent.</p>

    <p class="text-gray-300">We prove that <span class="math">D(\\mathsf{acc}^{\\prime})</span> accepts by scrutinizing the following decider checks.</p>

    <p class="text-gray-300">The check <span class="math">\\mathsf{acc}^{\\prime}.C_{i}\\stackrel{{\\scriptstyle?}}{{=}}\\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc}^{\\prime}.\\mathbf{m}_{i})</span> succeeds for all <span class="math">i\\in[k]</span>. This is because</p>

    <p class="text-gray-300"><span class="math">\\mathsf{acc}^{\\prime}.\\{C_{i},\\mathbf{m}_{i}\\}=\\mathsf{acc}.\\{C_{i},\\mathbf{m}_{i}\\}+\\alpha\\cdot\\pi.\\{C_{i},\\mathbf{m}_{i}\\}</span></p>

    <p class="text-gray-300">for all <span class="math">i\\in[k]</span>, where <span class="math">\\pi.C_{i}=\\mathsf{Commit}(\\mathsf{ck},\\pi.\\mathbf{m}_{i})</span> because <span class="math">\\mathsf{V}_{\\mathsf{NARK}}(\\mathsf{pi},\\pi)</span> accepts, and <span class="math">\\mathsf{acc}.C_{i}=\\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc}.\\mathbf{m}_{i})</span> because <span class="math">D(\\mathsf{acc})</span> accepts. Thus the check succeeds by the homomorphism of the commitment scheme.</p>

    <p class="text-gray-300">The decider computes <span class="math">\\mathbf{e}^{\\prime}\\leftarrow\\sum_{j=0}^{d}(\\mathsf{acc}^{\\prime}.\\mu)^{d-j}f_{j}^{\\mathsf{V}_{\\mathsf{eps}}}(\\mathsf{acc}^{\\prime}.\\{\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1}\\})</span> such that for <span class="math">\\mathbf{e}=\\sum_{j=0}^{d}\\mathsf{acc}.\\mu^{(d-j)}\\cdot f_{j}^{\\mathsf{V}_{\\mathsf{eps}}}(\\mathsf{acc}.\\{\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1}\\})</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}^{\\prime}</span> <span class="math">=\\mathbf{e}+\\sum_{j=1}^{d-1}\\alpha^{j}\\cdot\\mathsf{pf}.\\mathbf{e}_{j}</span> <span class="math">=\\sum_{j=0}^{d}(\\alpha+\\mathsf{acc}.\\mu)^{d-j}\\cdot f_{j}^{\\mathsf{V}_{\\mathsf{eps}}}(\\alpha\\cdot\\{\\mathsf{pi},\\pi.[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1}\\}+\\mathsf{acc}.\\{\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1}\\})\\,.</span></p>

    <p class="text-gray-300">By the definition of <span class="math">\\mathsf{pf}.\\mathbf{e}_{j}</span> and the homomorphism of the commitment scheme, and because <span class="math">D(\\mathsf{acc})</span> accepts and checks <span class="math">E=\\mathsf{Commit}(\\mathsf{ck},\\mathbf{e})</span>, we have that <span class="math">E^{\\prime}=\\mathsf{Commit}(\\mathsf{ck},\\mathbf{e}^{\\prime})</span>.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Knowledge-Soundness.</h5>

    <p class="text-gray-300">We show that the scheme has knowledge-soundness by showing that there exists an underlying <span class="math">(d+1)</span>-special-sound protocol and then applying the Fiat-Shamir transform to show that the accumulation scheme is knowledge sound. Consider the public-coin interactive protocol <span class="math">\\Pi_{I}=(\\mathsf{P}_{I}(\\mathsf{pi},\\pi,\\mathsf{acc}),\\mathsf{V}_{I}(\\mathsf{pi},\\pi.x,\\mathsf{acc}.x))</span> where <span class="math">\\mathsf{P}_{I}</span> sends <span class="math">\\mathsf{pf}=[E_{j}]_{j=1}^{d-1}\\in\\mathbb{G}^{d-1}</span> as computed by <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span> to <span class="math">\\mathsf{V}_{I}</span>. The verifier sends a random challenge <span class="math">\\alpha\\in\\mathbb{F}</span>, and the prover <span class="math">\\mathsf{P}_{I}</span> responds with <span class="math">\\mathsf{acc}^{\\prime}</span> as computed by <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span>. <span class="math">\\mathsf{V}_{I}</span> accepts if <span class="math">D_{\\mathsf{acc}}(\\mathsf{acc}^{\\prime})=0</span> and <span class="math">\\mathsf{V}_{\\mathsf{acc}}(\\mathsf{pi},\\pi.x,\\mathsf{acc}.x,\\mathsf{pf},\\mathsf{acc}^{\\prime}.x)=0</span> using the random challenge <span class="math">\\alpha</span>, instead of a Fiat-shamir challenge.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Claim 1: <span class="math">\\Pi_{I}</span> is <span class="math">(d+1)</span>-special-sound</h5>

    <p class="text-gray-300">Consider the relation <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span> where <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span> is defined in Definition 8. Consider <span class="math">d+1</span> accepting transcripts for <span class="math">\\Pi_{I}</span> :</p>

    <p class="text-gray-300"><span class="math">\\{\\mathcal{T}_{i}\\coloneqq(\\mathsf{pi},\\pi.x,\\mathsf{acc}.x;\\mathsf{acc}_{i}^{\\prime},\\mathsf{pf}_{i})\\}_{i=1}^{d+1}.</span></p>

    <p class="text-gray-300">We construct an extractor <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span> that extracts a witness for <span class="math">\\mathcal{R}_{\\mathsf{acc}}(\\mathsf{pi}.\\pi.x,\\mathsf{acc}.x)</span> given <span class="math">\\mathcal{T}</span>.</p>

    <p class="text-gray-300">For all <span class="math">i\\in[d+1]</span>,</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{acc}_{i}^{\\prime})=(\\mu_{i}^{\\prime},\\mathsf{pi}_{i}^{\\prime},[C_{i,j}^{\\prime}]_{j=1}^{k},[r_{i,j}]_{j=1}^{k-1},E_{i}^{\\prime},[\\mathbf{m}_{i,j}^{\\prime}]_{j=1}^{k})</span></p>

    <p class="text-gray-300">and <span class="math">\\mathsf{pf}_{i}=\\mathsf{pf}=[E_{j}]_{j=1}^{d-1}</span>.</p>

    <p class="text-gray-300">Given that the transcripts are accepting, i.e. both <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> and <span class="math">D_{\\mathsf{acc}}</span> accept, we have that <span class="math">\\mathsf{Commit}(\\mathsf{ck},\\mathbf{e}_{i}^{\\prime})=E_{i}^{\\prime}=\\mathsf{acc}.E+\\sum_{j=1}^{d-1}\\alpha_{i}^{j}E_{j}</span> for all <span class="math">i\\in[d+1]</span>, whereas</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_{i}^{\\prime}:=\\sum_{j=0}^{d}\\mu_{i}^{\\prime\\,d-j}f_{j}^{\\mathcal{R}}(\\pi_{i}^{\\prime},[\\mathbf{m}_{i,j}^{\\prime}]_{j=1}^{k},[r_{i,j}]_{j=1}^{k-1})\\,.</span></p>

    <p class="text-gray-300">Using a Vandermonde matrix of the challenges <span class="math">\\alpha_{1},\\ldots,\\alpha_{d}</span> we can compute <span class="math">\\mathbf{e},[\\mathbf{e}_{j}]_{j=1}^{d-1}</span> such that <span class="math">E_{j}=\\mathsf{Commit}(\\mathsf{ck},\\mathbf{e}_{j})</span> and <span class="math">\\mathsf{acc}.E=\\mathsf{Commit}(\\mathsf{ck},\\mathbf{e})</span> from the equations above. Therefore we have that <span class="math">\\mathbf{e}_{i}^{\\prime}=\\mathbf{e}+\\sum_{j=1}^{d-1}\\alpha_{i}^{j}\\mathbf{e}_{j}</span> for all <span class="math">i\\in[d+1]</span>.</p>

    <p class="text-gray-300">Additionally using two challenges <span class="math">(\\alpha_{1},\\alpha_{2})</span>, <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span> can compute <span class="math">\\pi.\\mathbf{w}=[\\mathbf{m}_{j}]_{j=1}^{k}=[\\frac{\\mathsf{acc}^{\\prime}.\\mathbf{m}_{1,j}-\\mathsf{acc}^{\\prime}.\\mathbf{m}_{2,j}}{\\alpha_{1}-\\alpha_{2}}]_{j=1}^{k}</span>. It holds that <span class="math">\\mathsf{acc}.\\mathbf{m}_{j}=\\mathsf{acc}^{\\prime}.\\mathbf{m}_{1,j}-\\alpha_{1}\\cdot\\pi.\\mathbf{m}_{j}\\forall j\\in[k]</span>, such that <span class="math">\\pi.C_{j}=\\mathsf{Commit}(\\mathsf{ck},\\pi.\\mathbf{m}_{j})</span> and <span class="math">\\mathsf{acc}.C_{j}=\\mathsf{Commit}(\\mathsf{ck},\\mathsf{acc}.\\mathbf{m}_{j})</span>. If for any other challenge and any <span class="math">j</span>, <span class="math">\\mathsf{acc}^{\\prime}.\\mathbf{m}_{j}\\neq\\alpha\\pi.\\mathbf{m}_{j}+\\mathsf{acc}.\\mathbf{m}_{j}</span>, then this can be used to compute a break of the commitment scheme <span class="math">\\mathsf{cm}</span>. This happens with negligible probability by assumption.</p>

    <p class="text-gray-300">Otherwise, we have that <span class="math">\\sum_{j=0}\\mu_{i}^{d-j}f_{j}^{\\mathcal{R}}(\\pi_{j},[\\mathbf{m}_{i,j}]_{i=1}^{k},[r_{i,j}]_{i=1}^{k-1})-\\mathbf{e}_{i}=0</span> for all <span class="math">i\\in[d+1]</span>. Together this implies that the degree <span class="math">d</span> polynomial</p>

    <p class="text-gray-300"><span class="math">p(X)</span> <span class="math">=\\sum_{j=0}^{d}(X+\\mathsf{acc}.\\mu)^{d-j}\\cdot f_{j}^{\\mathsf{V}_{\\mathsf{spn}}}(X\\cdot\\mathsf{pi}+\\mathsf{acc}.\\mathsf{pi},[X\\cdot\\mathbf{m}_{i}+\\mathsf{acc}.\\mathbf{m}_{i}]_{i=1}^{k},[X\\cdot r_{i}+\\mathsf{acc}.r_{i}]_{i=1}^{k-1})</span> <span class="math">-\\mathbf{e}-\\sum_{j=1}^{d-1}\\mathbf{e}_{j}X^{j}\\,,</span> (2)</p>

    <p class="text-gray-300">is zero on <span class="math">d+1</span> points <span class="math">(\\alpha_{1},\\ldots,\\alpha_{d+1})</span>, i.e. is zero everywhere. The constant term of this polynomial is</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=0}^{d}\\mathsf{acc}.\\mu^{d-j}\\cdot f_{j}^{\\mathsf{V}_{\\mathsf{spn}}}(\\mathsf{acc}.\\mathsf{pi},[\\mathsf{acc}.\\mathbf{m}_{i}]_{i=1}^{k},[\\mathsf{acc}.r_{i}]_{i=1}^{k-1})-\\mathbf{e}\\,.</span></p>

    <p class="text-gray-300">It being <span class="math">0</span> implies that <span class="math">D(\\mathsf{acc})=0</span>. Additionally, the degree <span class="math">d</span> term of the polynomial is</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=0}^{d}f_{j}^{\\mathsf{V}_{\\mathsf{spn}}}(\\mathsf{pi},[\\pi.\\mathbf{m}_{i}]_{i=1}^{k},[\\pi.r_{i}]_{i=1}^{k-1})\\,.</span></p>

    <p class="text-gray-300">Together with <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span> checking that the challenges <span class="math">r_{i}</span> are computed correctly this implies that <span class="math">\\mathsf{V}_{\\mathsf{NARK}}(\\mathsf{pi},\\pi)=0</span>. <span class="math">\\mathsf{Ext}</span> thus outputs a valid witness <span class="math">(\\pi.\\mathbf{w},\\mathsf{acc}.\\mathbf{w})\\in\\mathcal{R}_{\\mathsf{acc}}(\\mathsf{pi},\\pi.x,\\mathsf{acc}.x)</span> and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">thus <span class="math">\\Pi_I</span> is <span class="math">(d + 1)</span>-special-sound. Using Lemma 1, we have that <span class="math">\\Pi_{AS} = \\mathsf{FS}[\\Pi_I]</span> is a NARK for <span class="math">\\mathcal{R}_{\\mathrm{acc}}</span> with knowledge soundness $(Q + 1) \\cdot \\frac{d + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\mathrm{negl}(\\lambda)<span class="math">. This implies that </span>\\mathrm{acc}<span class="math"> is an accumulation scheme with </span>((Q + 1) \\cdot \\frac{d + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\mathrm{negl}(\\lambda))$-knowledge soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-35" class="text-2xl font-bold">3.5 Compressing verification checks for high-degree verifiers</h2>

    <p class="text-gray-300">Observe that the accumulation prover needs to perform <span class="math">\\Omega(d\\ell)</span> group operations to commit to the <span class="math">d - 1</span> error vectors <span class="math">\\mathbf{e}_j \\in \\mathbb{F}^\\ell</span> (<span class="math">1 \\leq j &amp;lt; d</span>); and the accumulation verifier needs to check the combination of <span class="math">d</span> error vector commitments. This can be a bottleneck when the verifier degree <span class="math">d</span> is high. In this circumstance, we can optimize the accumulation complexity by transforming the underlying special-sound protocol <span class="math">\\Pi_{\\mathrm{sps}}</span> into a new special-sound protocol <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{sps}}]</span> for the same relation <span class="math">\\mathcal{R}</span>. This optimization compresses the <span class="math">\\ell</span> degree-<span class="math">d</span> equations checked by the verifier into a single degree-<span class="math">(d + 2)</span> equation using a random linear combination, with the tradeoff of additionally checking <span class="math">2\\sqrt{\\ell}</span> degree-2 equations. We describe the generic transformation below.</p>

    <p class="text-gray-300"><strong>Compressing verification checks.</strong> W.l.o.g. assume <span class="math">\\ell</span> is a perfect square, then we can transform <span class="math">\\Pi_{\\mathrm{sps}}</span> into a special-sound protocol <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{sps}}]</span> where the <span class="math">\\mathsf{V}_{\\mathrm{sps}}</span> reduces from <span class="math">\\ell</span> degree-<span class="math">d</span> checks to 1 degree-<span class="math">(d + 2)</span> check and additionally <span class="math">2\\sqrt{\\ell}</span> degree-2 checks. Instead of checking the output of <span class="math">\\mathsf{V}_{\\mathrm{sps}}</span> to be <span class="math">\\ell</span> zeroes, we take a random linear combination of the <span class="math">\\ell</span> verification equations using powers of a challenge <span class="math">\\beta</span>. For example, if the map is <span class="math">\\mathsf{V}_{\\mathrm{sps}}(x_1,x_2) := (\\mathsf{V}_{\\mathrm{sps},1}(x_1,x_2),\\mathsf{V}_{\\mathrm{sps},2}(x_1,x_2)) = (x_1 + x_2,x_1x_2)</span> we can set the new algebraic map as <span class="math">\\mathsf{V}_{\\mathrm{sps}}&#x27;(x_1,x_2,\\beta) := \\mathsf{V}_{\\mathrm{sps},1}(x_1,x_2) + \\beta \\cdot \\mathsf{V}_{\\mathrm{sps},2}(x_1,x_2) = (x_1 + x_2) + \\beta x_1x_2</span> for a random <span class="math">\\beta</span>. Doing this naively reduces the output length to 1 but also requires the verifier to compute the appropriate powers of <span class="math">\\beta</span>. This would increase the degree by <span class="math">\\ell</span>, an undesirable tradeoff. To mitigate this, we can have the prover precompute powers of <span class="math">\\beta</span>, i.e. <span class="math">\\beta, \\beta^2, \\ldots, \\beta^\\ell</span> and send them to the verifier. The verifier then only needs to check consistency between the powers of <span class="math">\\beta</span>, which can be done using a degree 2 check, e.g. <span class="math">\\beta^{i+1} = \\beta^i \\cdot \\beta</span> and the degree <span class="math">d</span> verification equation increases in degree by 1. This mitigates the degree increase but requires the prover to send another message of length <span class="math">\\ell</span>. To achieve a more optimal tradeoff, we write each <span class="math">i = j + k \\cdot \\sqrt{\\ell}</span> for <span class="math">j, k \\in [1, \\sqrt{\\ell}]</span>. The prover then sends <span class="math">\\sqrt{\\ell}</span> powers of <span class="math">\\beta</span> and <span class="math">\\sqrt{\\ell} - 1</span> powers of <span class="math">\\beta^{\\sqrt{\\ell}}</span>. From these, each power of <span class="math">\\beta</span> from 1 to <span class="math">\\ell</span> can be recomputed using just one multiplication. This results in the prover sending an additional message of length <span class="math">2\\sqrt{\\ell}</span>, the original <span class="math">\\ell</span> verification checks being transformed into a single degree <span class="math">d + 2</span> check and additionally <span class="math">2\\sqrt{\\ell}</span> degree 2 checks for the consistency of the powers of <span class="math">\\beta</span>.</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">|  Transformed Protocol CV[Πsps] = (Psps, V'sps) for relation R  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mi← Psps(pi, w, [mj, rj]i-1j=1)</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ri</td>

            <td class="px-3 py-2 border-b border-gray-700">ri←$ F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Repeat k-1 time</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Repeat k-1 time</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Message mk |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β←$ F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[βj'← βj√k]√k-1j=1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V'sps(pi, [mi]k+1i=1, ([ri]k-1i=1, β)) = 0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | βi+1 = βi · β∀i ∈ [1, √k-2]  |</p>

    <p class="text-gray-300">|   |  | βi' + 1 = βi' · βi' ∀i ∈ [1, √k-2]  |</p>

    <p class="text-gray-300">|   |  | β1 = β, β1' = β√k-1 · β  |</p>

    <p class="text-gray-300">Figure 6: Compressed verification of  <span class="math">\\Pi_{\\mathrm{sps}}</span></p>

    <p class="text-gray-300">We describe the transformed protocol in Figure 6, where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{V}_{\\mathsf{sps}}^{\\prime}(\\mathsf{pi}, [\\mathbf{m}_i]_{i=1}^{k+1}, ([r_i]_{i=1}^{k-1}, \\beta)) := \\sum_{i=0}^{\\sqrt{\\ell}-1} \\sum_{j=0}^{\\sqrt{\\ell}-1} \\beta_i \\cdot \\beta_j&#x27; \\cdot \\mathsf{V}_{\\mathsf{sps}, i+j\\sqrt{\\ell}}(\\mathsf{pi}, [\\mathbf{m}_i]_{i=1}^{k}, [r_i]_{i=1}^{k-1}) \\\\ = \\sum_{j=0}^{\\ell-1} \\beta^j \\cdot \\mathsf{V}_{\\mathsf{sps}, j}(\\mathsf{pi}, [\\mathbf{m}_i]_{i=1}^{k}, [r_i]_{i=1}^{k-1}) \\end{array}</span></div>

    <p class="text-gray-300">and <span class="math">\\mathsf{V}_{\\mathsf{sps},j}(\\mathsf{pi}, [\\mathbf{m}_i]_{i=1}^k, [r_i]_{i=1}^{k-1})</span> is the <span class="math">(j+1)</span>-th <span class="math">(0 \\leq j &amp;lt; \\ell)</span> equation checked by <span class="math">\\mathsf{V}_{\\mathsf{sps}}</span>. The transformed protocol is a <span class="math">(2k+1)</span>-move special-sound protocol for the same relation <span class="math">\\mathcal{R}</span>. The transformed verifier now checks 1 degree-<span class="math">(d+2)</span> equation and additionally <span class="math">2\\sqrt{\\ell}</span> degree-2 equations.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">\\Pi_{\\mathsf{sps}}</span> be a <span class="math">(2k-1)</span>-move protocol for relation <span class="math">\\mathcal{R}</span> with <span class="math">(a_1, \\ldots, a_{k-1})</span>-special-soundness, in which the verifier outputs <span class="math">\\ell</span> elements. The transformed protocol <span class="math">\\mathsf{CV}[\\Pi_{\\mathsf{sps}}]</span> of <span class="math">\\Pi_{\\mathsf{sps}}</span> is <span class="math">(a_1, \\ldots, a_{k-1}, \\ell)</span>-special-sound.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span> be the extractor for <span class="math">\\Pi_{\\mathsf{sps}}</span>. We construct a extractor <span class="math">\\mathsf{Ext}_{\\mathsf{CV}}</span> of <span class="math">\\mathsf{CV}[\\Pi_{\\mathsf{sps}}]</span> for the same relation <span class="math">\\mathcal{R}</span>. Given an <span class="math">(a_1, \\ldots, a_{k-1}, \\ell)</span>-tree <span class="math">\\mathcal{T}</span> of accepting transcripts, <span class="math">\\mathsf{Ext}_{\\mathsf{CV}}</span> invokes <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span> on input the depth-<span class="math">(k-1)</span> transcript subtree of <span class="math">\\mathcal{T}</span>, and return what <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span> outputs.</p>

    <p class="text-gray-300">We prove that the extractor succeeds. For each internal node <span class="math">u</span> at depth <span class="math">k - 1</span>, it has <span class="math">\\ell</span> children where each child maps to a distinct value of <span class="math">\\beta \\in \\mathbb{F}</span>. Fix the messages <span class="math">\\mathsf{msg} = (\\mathsf{pi}, [\\mathbf{m}_i]_{i=1}^k, [r_i]_{i=1}^{k-1})</span> at node <span class="math">u</span> and let <span class="math">\\mathsf{V}_{\\mathsf{sps}} := (\\mathsf{V}_{\\mathsf{sps},1}, \\ldots, \\mathsf{V}_{\\mathsf{sps},\\ell})</span> be the verifier of <span class="math">\\Pi_{\\mathsf{sps}}</span>. Define the degree <span class="math">\\ell - 1</span> univariate polynomial</p>

    <div class="my-4 text-center"><span class="math-block">p(X) := \\sum_{j=0}^{\\ell-1} X^j \\cdot c_j</span></div>

    <p class="text-gray-300">where <span class="math">c_j \\coloneqq \\mathsf{V}_{\\mathsf{sps},j}(\\mathsf{msg}) \\in \\mathbb{F}</span> is <span class="math">\\mathsf{V}_{\\mathsf{sps},j}</span>'s output on message msg. Since the transcripts are accepting, it holds that <span class="math">p</span> evaluates to zero on the <span class="math">\\ell</span> different values of <span class="math">\\beta</span> that correspond to the <span class="math">\\ell</span> children of node <span class="math">u</span>. Thus the univariate polynomial <span class="math">p</span> is a zero polynomial, which implies that <span class="math">\\mathsf{V}_{\\mathsf{sps}}</span> outputs zero vector on message msg. Therefore for every node <span class="math">u</span> at depth <span class="math">k - 1</span>, the sub-transcript from root to node <span class="math">u</span> is an accepting transcript to <span class="math">\\Pi_{\\mathsf{sps}}</span>. Therefore the input to <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span> is a valid <span class="math">(a_1, \\ldots, a_{k-1})</span>-tree of accepting transcripts, and <span class="math">\\mathsf{Ext}_{\\mathsf{sps}}</span> will output the correct witness.</p>

    <p class="text-gray-300"><strong>High-low degree accumulation.</strong> After the transformation, the error vectors <span class="math">\\mathbf{e}_j</span> (<span class="math">1 \\leq j \\leq d + 1</span>) become single field elements, and we can use the trivial commitment <span class="math">E_j \\coloneqq \\mathsf{Commit}(\\mathsf{ck}, e_j) \\coloneqq e_j</span> without group operations. Additionally, we can use a separate error vector <span class="math">\\mathbf{e}&#x27; \\in \\mathbb{F}^{2\\sqrt{\\ell}}</span> to keep track of the error terms for the <span class="math">2\\sqrt{\\ell}</span> degree-2 checks, and set</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300"><span class="math">E^{\\prime} \\coloneqq \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e}^{\\prime}) \\in \\mathbb{G}</span>  to be the corresponding error commitment. The accumulation prover only needs to perform  <span class="math">O(\\sqrt{\\ell})</span>  additional group operations to commit  <span class="math">\\mathbf{m}_{k+1}</span>  and  <span class="math">\\mathbf{e}^{\\prime}</span> , and compute the coefficients of a degree- <span class="math">(d+2)</span>  univariate polynomial, which is described as the sum of  <span class="math">O(\\ell)</span>  polynomials. The accumulator instance needs to include one more challenge  <span class="math">\\beta</span>  and two commitments (for  <span class="math">\\mathbf{m}_{k+1}</span>  and  <span class="math">\\mathbf{e}^{\\prime}</span> ). The accumulator verifier needs to do only  <span class="math">k+2</span>  (rather than  <span class="math">k+d-1</span> ) group scalar multiplications, with the tradeoff of 1 more hash and  <span class="math">O(d)</span>  more field operations. This high-low degree accumulation is described in detail in Appendix A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3 (IVC for high-degree special-sound protocols). Let  <span class="math">\\mathbb{F}</span>  be a finite field, such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math">  and  </span>\\mathsf{cm} = (\\mathsf{Setup}, \\mathsf{Commit})<span class="math">  be a binding homomorphic commitment scheme for vectors in  </span>\\mathbb{F}<span class="math"> . Let  </span>\\Pi_{\\mathsf{sps}} = (\\mathsf{P}_{\\mathsf{sps}}, \\mathsf{V}_{\\mathsf{sps}})<span class="math">  be a special-sound protocol for an NP-complete relation  </span>\\mathcal{R}_{\\mathsf{NP}}$  with the following properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It's  <span class="math">(2k - 1)</span>  move.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- It's  <span class="math">(a_{1},\\ldots ,a_{k - 1})</span>  -out-of-  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  special-sound. Such that the knowledge error  </span>\\kappa = 1 - \\prod_{i = 1}^{k - 1}(1 - \\frac{a_i}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) = \\mathrm{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The inputs are in  <span class="math">\\mathbb{F}^{\\ell_{\\mathrm{in}}}</span></li>

      <li>The verifier is degree  <span class="math">d = \\mathrm{poly}(\\lambda)</span>  with output in  <span class="math">\\mathbb{F}^{\\ell}</span></li>

    </ul>

    <p class="text-gray-300">Then, under the Fiat-Shamir heuristic for a cryptographic hash function  <span class="math">\\mathsf{H}</span>  (Definition 9), there exist two IVC schemes  <span class="math">\\mathsf{IVC} = (\\mathsf{P}_{\\mathsf{IVC}},\\mathsf{V}_{\\mathsf{IVC}})</span>  and  <span class="math">\\mathsf{IVC}_{\\mathsf{CV}} = (\\mathsf{P}_{\\mathsf{CV},\\mathsf{IVC}},\\mathsf{V}_{\\mathsf{CV},\\mathsf{IVC}})</span>  with predicates expressed in  <span class="math">\\mathcal{R}_{\\mathsf{NP}}</span>  with the following efficiencies:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">No CV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CV</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PIVC native</td>

            <td class="px-3 py-2 border-b border-gray-700">∑i=1k</td>

            <td class="px-3 py-2 border-b border-gray-700">mi*</td>

            <td class="px-3 py-2 border-b border-gray-700">+(d-1)ℓG PspS+L(VspS,d)</td>

            <td class="px-3 py-2 border-b border-gray-700">∑i=1k</td>

            <td class="px-3 py-2 border-b border-gray-700">mi*</td>

            <td class="px-3 py-2 border-b border-gray-700">+O(√ℓ)G PspS+L'(VspS,d+2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PIVC recursive</td>

            <td class="px-3 py-2 border-b border-gray-700">k+d-1G k+ℓinF (k+d+O(1))H+1Hin</td>

            <td class="px-3 py-2 border-b border-gray-700">k+2G k+ℓin+d+1F (k+d+O(1))H+1Hin</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VIVC:</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ+∑i=1k</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700">G VspS</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√ℓ)+∑i=1k</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700">G O(ℓ)+VspS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πIVC</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">k+ℓinF k+1G ∑i=1k</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">k+ℓin+1F k+2G ∑i=1k</td>

            <td class="px-3 py-2 border-b border-gray-700">mi</td>

            <td class="px-3 py-2 border-b border-gray-700">+O(√ℓ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The first row displays the native operations of the IVC prover (i.e., the complexity of running the accumulation prover). The second row describes the size of the recursive statement representing the accumulation verifier for which  <span class="math">\\mathsf{P}_{\\mathsf{IVC}}</span>  creates a proof. The third row is the computation of  <span class="math">\\mathsf{V}_{\\mathsf{IVC}}</span> , and the last row is the size of the proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the table, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{m}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the prover message length; </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{m}_i^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the number of non-zero elements in </span>\\mathbf{m}_i<span class="math">; </span>\\mathbb{G}<span class="math"> for rows 1-3 is the total length of the messages committed using Commit. </span>\\mathbb{F}<span class="math"> are field operations. </span>\\mathsf{H}<span class="math"> denotes the total input length to a cryptographic hash, and </span>\\mathsf{H}_{\\mathrm{in}}<span class="math"> is the hash to the public input and accumulator instance. </span>\\mathsf{P}_{\\mathrm{sps}}<span class="math"> (and </span>\\mathsf{V}_{\\mathrm{sps}}<span class="math">) is the cost of running the prover (and the algebraic verifier) of the special-sound protocol, respectively. </span>L(\\mathsf{V}_{\\mathrm{sps}},d)<span class="math"> is the cost of computing the coefficients of the degree </span>d$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{e}(X) := \\sum_{j=0}^{d} (\\mu + X)^{d-j} \\cdot f_{j}^{\\mathrm{V}_{\\mathrm{sps}}} (\\mathrm{acc} + X \\cdot \\pi), \\tag{3}</span></div>

    <p class="text-gray-300">and <span class="math">L&#x27;(\\mathsf{V}_{\\mathrm{sps}}, d + 2)</span> is the cost of computing the coefficients of the degree <span class="math">d + 2</span> polynomial</p>

    <div class="my-4 text-center"><span class="math-block">e(X) := \\sum_{a=0}^{\\sqrt{\\ell}-1} \\sum_{b=0}^{\\sqrt{\\ell}-1} (X \\cdot \\pi \\cdot \\beta_{a} + \\mathrm{acc} \\cdot \\beta_{a}) (X \\cdot \\pi \\cdot \\beta_{b}&#x27; + \\mathrm{acc} \\cdot \\beta_{b}&#x27;) \\sum_{j=0}^{d} (\\mu + X)^{d-j} \\cdot f_{j,a+b\\sqrt{\\ell}}^{\\mathrm{V}_{\\mathrm{sps}}} (\\mathrm{acc} + X \\cdot \\pi), \\tag{4}</span></div>

    <p class="text-gray-300">where all inputs are linear functions in a formal variable <span class="math">X^4</span>, and <span class="math">f_{j,i}^{\\mathsf{V}_{\\mathsf{sps}}}</span> is the <span class="math">i</span>th (<span class="math">0 \\leq i \\leq \\ell - 1</span>) component of <span class="math">f_{j}^{\\mathsf{V}_{\\mathsf{sps}}}</span>'s output. For the proof size, <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{F}</span> are the number of commitments and field elements, respectively.</p>

    <p class="text-gray-300">Proof. The construction first defines the two NARKs</p>

    <div class="my-4 text-center"><span class="math-block">\\Pi_{\\text{NARK}} = \\left(\\mathrm{P}_{\\text{NARK}}, \\mathrm{V}_{\\text{NARK}}\\right) = \\mathrm{FS}[\\mathrm{cm}[\\Pi_{\\mathrm{sps}}]],</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pi_{\\text{NARK}, \\mathrm{CV}} = \\left(\\mathrm{P}_{\\text{NARK}}, \\mathrm{V}_{\\text{NARK}}\\right) = \\mathrm{FS}[\\mathrm{cm}[\\mathrm{CV}[\\Pi_{\\mathrm{sps}}]]].</span></div>

    <p class="text-gray-300">Then we construct the accumulation scheme <span class="math">(\\mathsf{P}_{\\mathrm{acc}},\\mathsf{V}_{\\mathrm{acc}}) = \\mathrm{acc}[\\Pi_{\\mathrm{NARK}}]</span> using the accumulation scheme from Section 3.4 and <span class="math">(\\mathsf{P}_{\\mathrm{acc,HL}}\\mathsf{V}_{\\mathrm{acc,HL}}) = \\mathrm{acc}_{\\mathrm{HL}}[\\Pi_{\\mathrm{NARK,CV}}]</span> using the accumulation scheme from Appendix A. Then we apply the transformation from Theorem 1 to construct the IVC schemes IVC and <span class="math">\\mathsf{IVC}_{\\mathsf{CV}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security: By Lemmas 1,2, we have that <span class="math">\\Pi_{\\mathsf{NARK}}</span> has $(Q + 1) \\cdot \\left[1 - \\prod_{i=1}^{k-1} \\left(1 - \\frac{a_i}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\right]<span class="math"> knowledge error for relation </span>\\mathcal{R}_{\\mathsf{cm}}^{\\mathcal{R}_{\\mathsf{NP}}}<span class="math"> for a polynomial-time </span>Q<span class="math">-query RO-adversary. Witnesses for </span>\\mathcal{R}_{\\mathsf{cm}}^{\\mathcal{R}_{\\mathsf{NP}}}<span class="math"> are either a witness for </span>\\mathcal{R}_{\\mathsf{NP}}<span class="math"> or a break of the binding property of cm. Assuming that cm is a binding commitment scheme, the probability that a polynomial time adversary and a polynomial time extractor can compute such a break is </span>\\mathrm{negl}(\\lambda)<span class="math">. Thus </span>\\Pi_{\\mathsf{NARK}}<span class="math"> has knowledge error </span>\\kappa = (Q + 1) \\cdot \\left[1 - \\prod_{i=1}^{k-1} \\left(1 - \\frac{a_i}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\right] + \\mathrm{negl}(\\lambda)<span class="math"> for </span>\\mathcal{R}_{\\mathsf{NP}}<span class="math">. Analogously and using Lemma 3, </span>\\Pi_{\\mathsf{NARK}, \\mathsf{CV}}<span class="math"> has knowledge soundness with knowledge error </span>\\kappa' = (Q + 1) \\cdot$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">29</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left[1-(1-\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\prod_{i=1}^{k-1}(1-\\frac{a_{i}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\right]+\\mathsf{negl}(\\lambda)<span class="math"> for </span>\\mathcal{R}_{\\mathsf{NP}}<span class="math">. By assumption, </span>\\kappa<span class="math"> and </span>\\kappa^{\\prime}<span class="math"> are negligible in </span>\\lambda<span class="math">. Using Theorem 2 and Corollary 2 we can construct accumulation schemes </span>\\mathsf{acc}<span class="math"> and </span>\\mathsf{acc}_{\\mathsf{CV}}<span class="math"> for </span>\\Pi_{\\mathsf{NARK}}<span class="math"> and </span>\\Pi_{\\mathsf{NARK},\\mathsf{CV}}<span class="math">, respectively. The accumulation schemes have negligible knowledge error as </span>d=\\mathsf{poly}(\\lambda)<span class="math">. Under the Fiat-Shamir heuristic for </span>\\mathsf{H}$ we can turn the NARKs and the accumulation schemes into secure schemes in the standard model.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Theorem 1, this yields <span class="math">\\mathsf{IVC}</span> and <span class="math">\\mathsf{IVC}_{\\mathsf{CV}}</span>, secure IVC schemes with predicates expressed in <span class="math">\\mathcal{R}_{\\mathsf{NP}}</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Efficiency:</h4>

    <p class="text-gray-300">We first analyze the efficiency for <span class="math">\\mathsf{IVC}</span>. The IVC-prover runs <span class="math">\\mathsf{P}_{\\mathsf{sps}}</span> to compute all prover messages. It also commits to all the <span class="math">\\mathsf{P}_{\\mathsf{sps}}</span> messages using <span class="math">\\mathsf{cm}</span>. Finally, it needs to compute all error terms <span class="math">\\mathbf{e}_{1},\\ldots,\\mathbf{e}_{d-1}</span> and commit to them. The error terms are computed by symbolically evaluating the polynomial <span class="math">e(X)</span> in Equation 4 with linear functions as inputs. The recursive circuit combines a new proof <span class="math">\\pi.x</span> with an accumulator <span class="math">\\mathsf{acc}.x</span>. The size of the accumulator instance is <span class="math">\\ell_{\\mathsf{in}}</span> field elements for the input, <span class="math">k-1</span> field elements for the interactive-proof challenges, <span class="math">1</span> field element for the accumulator challenge, and <span class="math">k</span> commitments for the <span class="math">\\mathsf{P}_{\\mathsf{sps}}</span> messages and <span class="math">d-1</span> commitments for the error terms. The IVC verifier checks the correctness of the commitments and runs <span class="math">\\mathsf{V}_{\\mathsf{sps}}</span>.</p>

    <p class="text-gray-300">For <span class="math">\\mathsf{IVC}_{\\mathsf{CV}}</span>, the prover needs to additionally commit to a message <span class="math">\\mathbf{m}_{k+1}</span> with length <span class="math">O(\\sqrt{\\ell})</span>; the number of error terms also increases from <span class="math">d-1</span> to <span class="math">d+1</span>. Fortunately, the error terms are only one element in <span class="math">\\mathbb{F}</span>, so we can use the identity function as the trivial commitment scheme. Thus, there is no cost for committing to the <span class="math">d+1</span> error terms when using <span class="math">\\mathsf{CV}</span>. However, there is another separate error term <span class="math">\\mathbf{e}^{\\prime}\\in\\mathbb{F}^{2\\sqrt{\\ell}}</span> for the additional <span class="math">O(\\sqrt{\\ell})</span> degree-<span class="math">2</span> checks, thus the prover needs to commit to <span class="math">E^{\\prime}=\\mathsf{Commit}(\\mathbf{e}^{\\prime})</span>. The size of the accumulator instance is <span class="math">\\ell_{\\mathsf{in}}</span> field elements for the input, <span class="math">k</span> field elements for the interactive-proof challenges, <span class="math">1</span> field element for the accumulator challenge, <span class="math">k+1</span> commitments for the prover messages, <span class="math">d+1</span> field elements for the error terms of the high-degree checks, and <span class="math">1</span> commitment for the additional error term <span class="math">\\mathbf{e}^{\\prime}</span>. ∎</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">For simplicity, we assume that the public input, the prover messages, and the verifier challenges are all in the same field <span class="math">\\mathbb{F}</span>. This isn’t strictly necessary; for example, the challenges could be drawn from a subset of <span class="math">\\mathbb{F}</span>. More generally, we can also allow prover messages to be group elements in <span class="math">\\mathbb{G}</span> given a homomorphic commitment scheme to group elements(e.g. <em>[x1]</em>).</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">3.6 Computation of error terms</h3>

    <p class="text-gray-300">We now give an explicit algorithm for efficiently computing the error terms, that is, computing the polynomial <span class="math">e(X)</span> as defined in (4) (the degree of <span class="math">e(X)</span> is <span class="math">d^{\\prime}=d+2</span>). The algorithm has similarities with computing the round polynomials in a single round of the sumcheck protocol<em>[x12]</em>.</p>

    <p class="text-gray-300">####</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i = 0</span> to <span class="math">d</span> define</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e^{(i)}(X) := \\sum_{a=0}^{\\sqrt{\\ell}-1} \\sum_{b=0}^{\\sqrt{\\ell}-1} (X \\cdot \\pi \\cdot \\beta_a + \\mathsf{acc} \\cdot \\beta_a)(X \\cdot \\pi \\cdot \\beta_b&#x27; + \\mathsf{acc} \\cdot \\beta_b&#x27;) \\cdot f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}(\\mathsf{acc} + X \\cdot \\pi) \\tag{5}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">e^{(i)}(j)</span> for all <span class="math">j \\in [0, i + 2]</span>. Use these evaluations to interpolate <span class="math">e^{(i)}(X)</span> using fast interpolation methods, e.g. an iFFT</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the coefficient form of <span class="math">e(X) = \\sum_{i=0}^{d} e^{(i)}(X) \\cdot (\\mu + X)^{d-i}</span>. This is done by computing the coefficients of <span class="math">e^{(i)}(X) \\cdot (\\mu + X)^{d-i}</span> for every <span class="math">i \\in [0, d]</span> using FFTs, and recover <span class="math">e(X)</span> using coefficient-wise addition. The complexity is <span class="math">O(d^2 \\log d)</span>.</li>

    </ol>

    <p class="text-gray-300">In the worst case, this algorithm is equivalent to evaluating the circuit at <span class="math">d + 2</span> different inputs. However, it can perform much better in practice. The reason is that many of the <span class="math">n</span> gates may only be low degree. E.g. <span class="math">90\\%</span> of the gates are degree 1 or 2 addition and multiplication gates, and <span class="math">10\\%</span> are more high degree gates. Then the prover only has to evaluate the <span class="math">10\\%</span> of the circuit at <span class="math">d + 2</span> points and <span class="math">90\\%</span> of the circuit only at 4 points. Note that the selector polynomials are static in the classification of NP plonkup (defined in Section 5). This means that each gate has precisely the degree of the active component. This stands in contrast to relations such as high-degree Plonk, where the selectors are pre-processed, and the selectors are preprocessed witnesses. In Plonk and related systems, each gate essentially has the same degree.</p>

    <h2 id="sec-39" class="text-2xl font-bold">3.6.1 Dealing with branched gates</h2>

    <p class="text-gray-300">In some scenarios, the NARK proof <span class="math">\\pi</span> has the property that each gate <span class="math">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}(\\mathsf{acc} + X \\cdot \\pi)</span> in Formula 5 can be represented as the sum of <span class="math">I</span> parts where at most one part is related to <span class="math">\\pi</span>, that is, for some gates <span class="math">g_1, \\ldots, g_I</span> and some index <span class="math">pc \\in [I]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}(\\mathsf{acc} + X \\cdot \\pi) = g_{pc}(\\mathsf{acc} + X \\cdot \\pi) + \\sum_{j \\in [I] \\setminus \\{pc\\}} g_j(\\mathsf{acc}).</span></div>

    <p class="text-gray-300">In this case, for any gate <span class="math">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}</span>, we present a caching algorithm for evaluating <span class="math">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}(\\mathsf{acc} + k \\cdot \\pi)</span> at all evaluation points <span class="math">k \\in [0, i + 2]</span>. The complexity is only proportional to the evaluation complexity of <span class="math">g_{pc}</span> rather than <span class="math">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize <span class="math">V \\coloneqq \\sum_{j=1}^{I} g_j(\\mathsf{acc})</span>.</li>

      <li>Upon receiving a new NARK proof <span class="math">\\pi</span> during accumulation, set <span class="math">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}(\\mathsf{acc}) = V</span>, compute <span class="math">U = g_{pc}(\\mathsf{acc})</span>, and for every <span class="math">k \\in [1, i + 2]</span>, compute <span class="math">f_{i,a+b\\sqrt{\\ell}}^{\\mathsf{V}_{\\mathrm{sp}}}(\\mathsf{acc} + k \\cdot \\pi) = V + g_{pc}(\\mathsf{acc} + k \\cdot \\pi) - U</span>.</li>

    </ol>

    <p class="text-gray-300">31</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>After the accumulation, let  <span class="math">\\alpha \\in \\mathbb{F}</span>  be the folding challenge and update  <span class="math">V \\gets V + g_{pc}(\\mathsf{acc} + \\alpha \\cdot \\pi) - U</span> .</li>

    </ol>

    <p class="text-gray-300">The algorithm is correct because  <span class="math">V</span>  is always  <span class="math">\\sum_{j\\in [I]}g_j(\\mathsf{acc})</span>  where  <span class="math">\\mathsf{acc}</span>  is the current accumulator.</p>

    <p class="text-gray-300">In this section, we present special-sound protocols for permutation, high-degree gate, circuit selection and lookup relations, which are the building blocks for the (non-uniform) Plonkish circuit-satisfiability relations. We can build accumulation schemes for (and thus IVCs from) these special-sound protocols via the framework presented in Section 3.</p>

    <p class="text-gray-300">Definition 10. Let  <span class="math">\\sigma : [n] \\to [n]</span>  be a permutation, the relation  <span class="math">\\mathcal{R}_{\\sigma}</span>  is the set of tuples  <span class="math">\\mathbf{w} \\in \\mathbb{F}^n</span>  such that  <span class="math">\\mathbf{w}_i = \\mathbf{w}_{\\sigma(i)}</span>  for all  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">|  Special-sound protocol Πσ for permutation relation Rσ  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">Check wi - wσ(i) = 0∀i ∈ [n]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{\\sigma}</span>  is a 1-move protocol (i.e.  <span class="math">k = 1</span> ); the degree of the verifier is 1.</p>

    <p class="text-gray-300">Definition 11. Given configuration  <span class="math">\\mathcal{C}_{GATE} \\coloneqq (n, c, d, [\\mathbf{s}_i \\in \\mathbb{F}^n, G_i]_{i=1}^m)</span>  where  <span class="math">n</span>  is the number of gates,  <span class="math">c</span>  is the arity per gate,  <span class="math">d</span>  is the gate degree,  <span class="math">[\\mathbf{s}_i]_{i=1}^m</span>  are the selector vectors, and  <span class="math">[G_i]_{i=1}^m</span>  are the gate formulas, the relation  <span class="math">\\mathcal{R}_{GATE}</span>  is the set of tuples  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{cn}</span>  such that  <span class="math">\\sum_{j=1}^{m} \\mathbf{s}_{j,i} \\cdot G_j(\\mathbf{w}_i, \\mathbf{w}_{i+n}, \\ldots, \\mathbf{w}_{i+(c-1)\\cdot n}) = 0</span>  for all  <span class="math">i \\in [n]</span> .</p>

    <p class="text-gray-300">Special-sound protocol  <span class="math">\\Pi_{\\mathrm{GATE}}</span>  for relation  <span class="math">\\mathcal{R}_{\\mathrm{GATE}}</span></p>

    <p class="text-gray-300">Prover  <span class="math">\\mathsf{P}(\\mathcal{C}_{\\mathbf{GATE}},\\mathbf{w}\\in \\mathbb{F}^{cn})</span>  Verifier  <span class="math">\\mathsf{V}(\\mathcal{C}_{\\mathbf{GATE}})</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300"><span class="math">\\sum_{j = 1}^{m}\\mathbf{s}_{j,i}\\cdot G_{j}(\\mathbf{w}_{i},\\mathbf{w}_{i + n},\\dots ,\\mathbf{w}_{i + (c - 1)\\cdot n})</span></p>

    <p class="text-gray-300"><span class="math">\\stackrel{?}{=} 0 \\forall i \\in [n]</span></p>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{\\mathrm{GATE}}</span>  is a 1-move protocol (i.e.  <span class="math">k = 1</span> ) with verifier degree  <span class="math">d</span> .</p>

    <p class="text-gray-300">Definition 12. Given configuration  <span class="math">\\mathcal{C}_{LK} \\coloneqq (T, \\ell, \\mathbf{t})</span>  where  <span class="math">\\ell</span>  is the number of lookups and  <span class="math">\\mathbf{t} \\in \\mathbb{F}^T</span>  is the lookup table, the relation  <span class="math">\\mathcal{R}_{LK}</span>  is the set of tuples  <span class="math">\\mathbf{w} \\in \\mathbb{F}^\\ell</span>  such that  <span class="math">\\mathbf{w}_i \\in \\mathbf{t}</span>  for all  <span class="math">i \\in [\\ell]</span> .</p>

    <p class="text-gray-300">We recall a useful lemma for lookup relation from [Hab22], and present a special-sound protocol for the lookup relation.</p>

    <p class="text-gray-300">Lemma 4 (Lemma 5 of [Hab22]). Let  <span class="math">\\mathbb{F}</span>  be a field of characteristic  <span class="math">p &amp;gt; \\max (\\ell ,T)</span> . Given two sequences of field elements  <span class="math">[\\mathbf{w}_i]_{i = 1}^{\\ell}</span>  and  <span class="math">[\\mathbf{t}_i]_{i = 1}^T</span> , we have  <span class="math">\\{\\mathbf{w}_i\\} \\subseteq \\{\\mathbf{t}_i\\}</span>  as sets (with multiples of values removed) if and only if there exists a sequence  <span class="math">[\\mathbf{m}_i]_{i = 1}^T</span>  of field elements such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 1} ^ {\\ell} \\frac {1}{X + \\mathbf {w} _ {i}} = \\sum_ {i = 1} ^ {T} \\frac {\\mathbf {m} _ {i}}{X + \\mathbf {t} _ {i}}. \\tag {6}</span></div>

    <p class="text-gray-300">|  Special-sound protocol ΠLK for RLK  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute m ∈ FT such that |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mi := ∑j=1l(wwj = ti) ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w, m</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | r  |</p>

    <p class="text-gray-300">|  Compute h ∈ Fℓ, g ∈ FT |   |</p>

    <p class="text-gray-300">|  hi := 1/wi + r ∀i ∈ [ℓ] |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gi := mi/ti + r ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h, g</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ∑i=1lhi = ∑i=1Tgi  |</p>

    <p class="text-gray-300">|   | hi · (wi + r) = 1 ∀i ∈ [ℓ]  |</p>

    <p class="text-gray-300">|   | gi · (ti + r) = mi ∀i ∈ [T]  |</p>

    <p class="text-gray-300">Achieving perfect completeness. Note that the protocol does not have perfect completeness. If there exists an  <span class="math">\\mathbf{w}_i</span>  or  <span class="math">\\mathbf{t}_i</span>  such that  <span class="math">\\mathbf{w}_i + r = 0</span> ,  <span class="math">\\mathbf{t}_i + r = 0</span>  then the prover message is undefined. We can achieve perfect completeness by having the verifier set  <span class="math">\\mathbf{h}_i = 0</span>  or  <span class="math">\\mathbf{g}_i = 0</span>  in this case and changing the verification equations to</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {w} _ {i} + r\\right) \\cdot \\left(\\mathbf {h} _ {i} \\cdot \\left(\\mathbf {w} _ {i} + r\\right) - 1\\right) = 0</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {t} _ {i} + r\\right) \\cdot \\left(\\mathbf {g} _ {i} \\cdot \\left(\\mathbf {t} _ {i} + r\\right) - \\mathbf {m} _ {i}\\right) = 0.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">These checks ensure that either  <span class="math">\\mathbf{h}_i = \\frac{1}{\\mathbf{w}_i + r}</span>  or  <span class="math">\\mathbf{w}_i + r = 0</span> . The checks increase the verifier degree to 3. Without these checks, the protocol has a negligible completeness error of  $\\frac{\\ell + T}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ . This completeness error can likely be ignored in practice, and these checks do not need to be implemented. However, to achieve the full definition of PCD (which has perfect completeness) and use Theorem 1 by [BCLMS21], we require that all protocols have perfect completeness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{\\mathrm{LK}}</span>  is a 3-move protocol (i.e.  <span class="math">k = 2</span> ); the degree of the verifier is 2; the number of non-zero elements in the prover message is at most  <span class="math">4\\ell</span> .</p>

    <p class="text-gray-300">Accumulation with <span class="math">O(\\ell)</span> prover complexity. The prover complexity of <span class="math">\\Pi_{\\mathrm{LK}}</span> is due to the sparseness of <span class="math">\\mathbf{g} \\in \\mathbb{F}^T</span> and <span class="math">\\mathbf{m} \\in \\mathbb{F}^T</span>. However, there is no guarantee that when building an accumulation scheme for <span class="math">\\Pi_{\\mathrm{LK}}</span>, the accumulated <span class="math">\\mathsf{acc.g}</span> and <span class="math">\\mathsf{acc.m}</span> are sparse. This is an issue, as the prover needs to compute the error term <span class="math">\\mathbf{e}_1</span>. If we expand the accumulation procedures, we see that the three verification checks lead to three components of the error term <span class="math">\\mathbf{e}_1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{e}_1^{(1)} = \\left(\\sum_{i=1}^{\\ell} \\mathsf{acc.h}_i - \\sum_{i=1}^{T} \\mathsf{acc.g}_i\\right) + \\mu \\left(\\sum_{i=1}^{\\ell} \\pi \\cdot \\mathbf{h}_i - \\sum_{i=1}^{T} \\pi \\cdot \\mathbf{g}_i\\right) \\in \\mathbb{F}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{e}_1^{(2)} = \\mathsf{acc.h} \\circ (\\pi \\cdot \\mathbf{w} + \\pi \\cdot r \\cdot \\mathbf{1}^\\ell) + \\pi \\cdot \\mathbf{h} \\circ (\\mathsf{acc.w} + \\mathsf{acc.r} \\cdot \\mathbf{1}^\\ell) - 2\\mu \\cdot \\mathbf{1}^\\ell \\in \\mathbb{F}^\\ell</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{e}_1^{(3)} = \\mathsf{acc.g} \\circ (\\mathbf{t} + \\pi \\cdot r \\cdot \\mathbf{1}^T) + \\pi \\cdot \\mathbf{g} \\circ (\\mu \\cdot \\mathbf{t} + \\mathsf{acc.r} \\cdot \\mathbf{1}^T) - \\mu \\cdot \\pi \\cdot \\mathbf{m} - \\mathsf{acc.m} \\in \\mathbb{F}^T.</span></div>

    <p class="text-gray-300">We examine all three components below.</p>

    <p class="text-gray-300">For <span class="math">\\mathbf{e}_1^{(1)}</span>, we see that <span class="math">(\\sum_{i=1}^{\\ell} \\pi \\cdot \\mathbf{h}_i - \\sum_{i=1}^{T} \\pi \\cdot \\mathbf{g}_i) = 0</span> by the assumption that <span class="math">\\pi</span> is valid, and <span class="math">(\\sum_{i=1}^{\\ell} \\mathsf{acc.h}_i - \\sum_{i=1}^{T} \\mathsf{acc.g}_i) = \\mathsf{acc.e}^{(1)} / \\mathsf{acc.}\\mu</span> (where <span class="math">\\mathsf{acc.e}^{(1)}</span> is the first component of the error vector for <span class="math">\\mathsf{acc}</span>). Thus <span class="math">\\mathbf{e}_1^{(1)} = \\mathsf{acc.e}^{(1)} / \\mathsf{acc.}\\mu</span>. We observe that since in IVC the accumulator <span class="math">\\mathsf{acc.e}^{(1)}</span> is initiated with 0, this implies that for all iterations <span class="math">\\mathbf{e}_1^{(1)} = 0</span>.</p>

    <p class="text-gray-300">For <span class="math">\\mathbf{e}_1^{(2)}</span>, it is computed from terms of size <span class="math">\\ell</span>, so can be computed in time <span class="math">O(\\ell)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">\\mathbf{e}_1^{(3)}</span>, note that <span class="math">\\mathsf{acc.}\\mu</span>, <span class="math">\\mathsf{acc.r}</span> and <span class="math">\\pi \\cdot r</span> are all scalars. Also note that the accumulation prover only needs to compute the commitment $E_1 = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e}_1) = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e}_1^{(1)}) + \\mathsf{Commit}(\\mathsf{ck}, 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}_1^{(2)}) + \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{0}^{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}_1^{(3)})<span class="math">, not the actual vector </span>\\mathbf{e}_1<span class="math">. We will compute </span>E_1^{(3)} = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e}_1^{(3)})$ homomorphically from the commitments below (dropping the zero padding for readability):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G = \\mathsf{Commit}(\\mathsf{ck}, \\pi \\cdot \\mathbf{g})</span>,</li>

      <li><span class="math">G&#x27; = \\mathsf{Commit}(\\mathsf{ck}, \\mathsf{acc.g})</span>,</li>

      <li><span class="math">M = \\mathsf{Commit}(\\mathsf{ck}, \\pi \\cdot \\mathbf{m})</span>,</li>

      <li><span class="math">M&#x27; = \\mathsf{Commit}(\\mathsf{ck}, \\mathsf{acc.m})</span>,</li>

      <li><span class="math">GT = \\mathsf{Commit}(\\mathsf{ck}, \\pi \\cdot \\mathbf{g} \\circ \\mathbf{t})</span>,</li>

      <li><span class="math">GT&#x27; = \\mathsf{Commit}(\\mathsf{ck}, \\mathsf{acc.g} \\circ \\mathbf{t})</span>.</li>

    </ol>

    <p class="text-gray-300">Given these commitments, we can compute</p>

    <div class="my-4 text-center"><span class="math-block">E_1^{(3)} = GT&#x27; + \\pi \\cdot r \\cdot G&#x27; + \\mathsf{acc.}\\mu \\cdot GT + \\mathsf{acc.r} \\cdot G - \\mathsf{acc.}\\mu \\cdot M - M&#x27;.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This reduces the problem to the problem of efficiently computing and updating the commitments. <span class="math">G, M</span> and <span class="math">GT</span> are all commitments to <span class="math">\\ell</span>-sparse vectors, thus can be efficiently computed. The prover can cache the commitments <span class="math">G&#x27;, M&#x27;</span>, and <span class="math">GT&#x27;</span> and efficiently update them during accumulation. That is <span class="math">G&#x27;&#x27; \\gets G&#x27; + \\alpha G</span>, <span class="math">M&#x27;&#x27; \\gets M&#x27; + \\alpha M</span> and <span class="math">GT&#x27;&#x27; \\gets GT&#x27; + \\alpha GT</span>. Additionally, we need to update the accumulation witnesses: <span class="math">\\mathsf{acc&#x27;.m} \\gets \\mathsf{acc.m} + \\alpha \\pi \\cdot \\mathbf{m}</span> and <span class="math">\\mathsf{acc&#x27;.g} \\gets \\mathsf{acc.g} + \\alpha \\pi \\cdot \\mathbf{g}</span>. Again because <span class="math">\\pi \\cdot \\mathbf{g}, \\pi \\cdot \\mathbf{m}</span> are sparse this can be done in time <span class="math">O(\\ell)</span> independent of $T =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathrm{LK}}</span> is used in composition with another special-sound protocol with a higher degree <span class="math">d</span>, the accumulation is made homogeneous using a <span class="math">(X+\\mu)^{d-2}</span> factor when computing the error terms. The contribution to the error terms <span class="math">\\mathbf{e}_{i}</span> (<span class="math">1\\leq i\\leq d-1</span>) is still a linear function in <span class="math">\\mathsf{acc.g}</span>, <span class="math">\\mathsf{acc.m}</span> and <span class="math">\\mathsf{acc.g}\\circ\\mathbf{t}</span>, and thus can be computed homomorphically from commitments to these values.</p>

    <p class="text-gray-300">Finally, we note that the algorithm above can be generalized to support polynomial <span class="math">\\mathbf{e}(X)</span> with more general formats and with higher degrees. We refer to Appendix B for more details.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Special-soundness.</h4>

    <p class="text-gray-300">We prove special-soundness for the perfect complete version of <span class="math">\\Pi_{\\mathrm{LK}}</span>, the proof for <span class="math">\\Pi_{\\mathrm{LK}}</span> is almost identical (but even simpler).</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">The perfect complete version of <span class="math">\\Pi_{\\mathrm{LK}}</span> is <span class="math">2(\\ell+T)</span>-special-sound.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We construct an extractor <span class="math">\\mathsf{Ext}</span> that outputs <span class="math">\\mathbf{w}</span>. To show that the witness is valid, we look at the <span class="math">2(\\ell+T)</span> transcripts that all have <span class="math">\\mathbf{w},\\mathbf{m}</span> as the first message but different <span class="math">(r^{(j)},\\mathbf{h}^{(j)}\\in\\mathbb{F}^{\\ell},\\mathbf{g}^{(j)}\\in\\mathbb{F}^{T})</span> as the second message. Note that by the pigeonhole principle, there must exist a subset of <span class="math">S\\subseteq[2(\\ell+T)]</span> transcripts such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell+T<span class="math"> and </span>\\mathbf{w}_{i}+r^{(j)}\\neq 0<span class="math"> for all </span>i\\in[\\ell]<span class="math"> and </span>j\\in S<span class="math">, and </span>\\mathbf{t}_{i}+r^{(j)}\\neq 0<span class="math"> for all </span>i\\in[T]<span class="math"> and </span>j\\in S<span class="math">. For these transcripts, we have that </span>\\mathbf{h}_{i}=\\frac{1}{\\mathbf{w}_{i}+r^{(j)}}<span class="math"> and </span>\\mathbf{g}_{i}=\\frac{\\mathbf{m}_{i}}{\\mathbf{t}_{i}+r^{(j)}}<span class="math">. Define the degree </span>\\ell+T-1$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">p(X)=\\prod_{k=1}^{\\ell}(X+\\mathbf{w}_{k})\\cdot\\prod_{j=1}^{T}(X+\\mathbf{t}_{j})\\cdot\\left(\\sum_{i=1}^{\\ell}\\frac{1}{X+\\mathbf{w}_{i}}-\\sum_{i=1}^{T}\\frac{\\mathbf{m}_{i}}{X+\\mathbf{t}_{i}}\\right)\\,.</span></p>

    <p class="text-gray-300">If <span class="math">p(X)</span> is the zero polynomial then <span class="math">\\sum_{i=1}^{\\ell}\\frac{1}{X+\\mathbf{w}_{i}}=\\sum_{i=1}^{T}\\frac{\\mathbf{m}_{i}}{X+\\mathbf{t}_{i}}</span> and by Lemma 4 (<span class="math">\\mathcal{C}_{\\mathrm{LK}};\\mathbf{w})\\in\\mathcal{R}_{\\mathrm{LK}}</span>. Since we have <span class="math">\\ell+T</span> points <span class="math">r^{(j)}</span> at which <span class="math">p(r_{j})=0</span> we get that <span class="math">p=0</span> and thus that the extracted witness <span class="math">\\mathbf{w}</span> is valid. ∎</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">4.4 Vector-valued lookup</h3>

    <p class="text-gray-300">In some applications (e.g., simulating bit operations in circuits), we need to support lookup for a vector, i.e., each table value is a vector of field elements. In this section, we adapt the scheme in Section 4.3 to support vector lookups.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 13.</h6>

    <p class="text-gray-300">Consider configuration <span class="math">\\mathcal{C}_{\\mathit{VLK}}:=(T,\\ell,v\\in\\mathbb{N},\\mathbf{t})</span> where <span class="math">\\ell</span> is the number of lookups, and <span class="math">\\mathbf{t}\\in(\\mathbb{F}^{v})^{T}</span> is a lookup table in which the <span class="math">i</span>th <span class="math">(1\\leq i\\leq T)</span> entry is</p>

    <p class="text-gray-300"><span class="math">\\mathbf{t}_{i}:=(\\mathbf{t}_{i,1},\\ldots,\\mathbf{t}_{i,v})\\in\\mathbb{F}^{v}\\,.</span></p>

    <p class="text-gray-300">A sequence of vectors <span class="math">\\mathbf{w}\\in(\\mathbb{F}^{v})^{\\ell}</span> is in relation <span class="math">\\mathcal{R}_{\\mathit{VLK}}</span> if and only if for all <span class="math">i\\in[\\ell]</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{w}_{i}:=(\\mathbf{w}_{i,1},\\ldots,\\mathbf{w}_{i,v})\\in\\mathbf{t}\\,.</span></p>

    <p class="text-gray-300">As noted in Section 3.4 of [Hab22], we can extend Lemma 4 and replace Equation 6 with</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{\\ell} \\frac{1}{X + w_i(Y)} = \\sum_{i=1}^{T} \\frac{\\mathbf{m}_i}{X + t_i(Y)} \\tag{7}</span></div>

    <p class="text-gray-300">where the polynomials are defined as</p>

    <div class="my-4 text-center"><span class="math-block">w_i(Y) := \\sum_{j=1}^{v} \\mathbf{w}_{i,j} \\cdot Y^{j-1}, \\quad t_i(Y) := \\sum_{j=1}^{v} \\mathbf{t}_{i,j} \\cdot Y^{j-1},</span></div>

    <p class="text-gray-300">which represent the witness vector <span class="math">\\mathbf{w}_i \\in \\mathbb{F}^v</span> and the table vector <span class="math">\\mathbf{t}_i \\in \\mathbb{F}^v</span>. We, therefore, can describe a special-sound protocol for the vector lookup relation as follows.</p>

    <p class="text-gray-300">|  Special-sound protocol <span class="math">\\Pi_{VLK}^v</span> for <span class="math">\\mathcal{R}_{VLK}</span>  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute <span class="math">\\mathbf{m} \\in \\mathbb{F}^T</span> such that |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{m}_i := \\sum_{j=1}^{\\ell} \\mathbb{1}(\\mathbf{w}_j = \\mathbf{t}_i)\\forall i \\in [T]</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{w}, \\mathbf{m}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | <span class="math">\\perp</span> |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">r</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">r \\leftarrow \\# \\mathbb{F}</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute <span class="math">[\\beta_i = \\beta^{i-1}]_{i=1}^v</span> |  |   |</p>

    <p class="text-gray-300">|  and <span class="math">\\mathbf{h} \\in \\mathbb{F}^\\ell</span>, <span class="math">\\mathbf{g} \\in \\mathbb{F}^T</span> |  |   |</p>

    <p class="text-gray-300">|  <span class="math">\\mathbf{h}_i := \\frac{1}{w_i(\\beta) + r} \\forall i \\in [\\ell]</span> |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{g}_i := \\frac{\\mathbf{m}_i}{t_i(\\beta) + r} \\forall i \\in [T]</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">[\\beta_i]_{i=1}^v, \\mathbf{h}, \\mathbf{g}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | <span class="math">\\sum_{i=1}^{\\ell} \\mathbf{h}_i \\stackrel{?}{=} \\sum_{i=1}^{T} \\mathbf{g}_i</span>  |</p>

    <p class="text-gray-300">|   |  | <span class="math">\\mathbf{h}_i \\cdot \\left[ \\left( \\sum_{j=1}^{v} \\mathbf{w}_{i,j} \\cdot \\beta_j \\right) + r \\right] \\stackrel{?}{=} 1 \\forall i \\in [\\ell]</span>  |</p>

    <p class="text-gray-300">|   |  | <span class="math">\\mathbf{g}_i \\cdot \\left[ \\left( \\sum_{j=1}^{v} \\mathbf{t}_{i,j} \\cdot \\beta_j \\right) + r \\right] \\stackrel{?}{=} \\mathbf{m}_i \\forall i \\in [T]</span>  |</p>

    <p class="text-gray-300">|   |  | <span class="math">\\beta_{i+1} \\stackrel{?}{=} \\beta_i \\cdot \\beta \\forall i \\in [v-1], \\beta_1 \\stackrel{?}{=} 1</span>  |</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Achieving perfect completeness.</h4>

    <p class="text-gray-300">We can use the same trick in Section 4.3 to achieve perfect completeness for <span class="math">\\Pi^{v}_{\\mathrm{VLK}}</span>. Namely, the verifier sets <span class="math">\\mathbf{h}_{i}=0</span> or <span class="math">\\mathbf{g}_{i}=0</span> when <span class="math">w_{i}(\\beta)+r=0</span> or <span class="math">t_{i}(\\beta)+r=0</span> respectively. The verification equations become</p>

    <p class="text-gray-300"><span class="math">(w_{i}(\\beta_{1},\\ldots,\\beta_{v})+r)\\cdot(\\mathbf{h}_{i}\\cdot(w_{i}(\\beta_{1},\\ldots,\\beta_{v})+r)-1)=0</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">(t_{i}(\\beta_{1},\\ldots,\\beta_{v})+r)\\cdot(\\mathbf{g}_{i}\\cdot(t_{i}(\\beta_{1},\\ldots,\\beta_{v})+r)-\\mathbf{m}_{i})=0\\,,</span></p>

    <p class="text-gray-300">where <span class="math">w_{i}(\\beta_{1},\\ldots,\\beta_{v}):=\\left(\\sum_{j=1}^{v}\\mathbf{w}_{i,j}\\cdot\\beta_{j}\\right)</span> and <span class="math">t_{i}(\\beta_{1},\\ldots,\\beta_{v}):=\\left(\\sum_{j=1}^{v}\\mathbf{t}_{i,j}\\cdot\\beta_{j}\\right)</span>. The degree of the verifier is 5. In practice, the negligible completeness error can likely be ignored without implementing these checks.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Accumulation complexity.</h4>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathrm{VLK}}</span> is a 5-move protocol (i.e. <span class="math">k=3</span>) with the 2nd prover message being empty; the degree of the verifier is 3; the number of non-zero elements in the prover message is at most <span class="math">(v+3)\\ell+v</span>. To ensure that the accumulation procedure only requires <span class="math">O(v\\ell)</span> operations independent of <span class="math">T</span>, we can apply the same trick as in Section 4.3.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Special-soundness.</h4>

    <p class="text-gray-300">We prove that the perfect complete version of <span class="math">\\Pi^{v}_{\\mathrm{VLK}}</span> is special-sound.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">For any <span class="math">v\\in\\mathbb{N}</span>, the perfect complete version of <span class="math">\\Pi^{v}_{\\mathrm{VLK}}</span> is <span class="math">[1+(v-1)\\cdot(\\ell+T-1),2(\\ell+T)]</span>-special-sound.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct an extractor <span class="math">\\mathsf{Ext}</span> that outputs <span class="math">\\mathbf{w}</span>. To show that the witness is valid, we look at the <span class="math">[1+(v-1)\\cdot(\\ell+T-1),2(\\ell+T)]</span>-tree of accepting transcripts. Note that for each depth-1 internal node <span class="math">u</span> that fixes the message <span class="math">(\\mathbf{w},\\mathbf{m},\\beta)</span>, it has <span class="math">2(\\ell+T)</span> different choices of challenge <span class="math">r^{(j)}</span>. By the pigeonhole principle, there exists at least <span class="math">\\ell+T</span> challenges <span class="math">r</span> such that <span class="math">t_{i}(\\beta)+r\\neq 0</span> for all <span class="math">i\\in[T]</span> and <span class="math">w_{i}(\\beta)+r\\neq 0</span> for all <span class="math">i\\in[\\ell]</span>. Let <span class="math">\\mathbf{h},\\mathbf{g}</span> be the last prover message in the corresponding leaf node. Since the transcript is accepting, we have that <span class="math">\\mathbf{h}_{i}=1/(w_{i}(\\beta)+r)</span> for all <span class="math">i\\in[\\ell]</span>, <span class="math">\\mathbf{g}_{i}=\\mathbf{m}_{i}/(t_{i}(\\beta)+r)</span> for all <span class="math">i\\in[T]</span>, and <span class="math">\\sum_{i=1}^{\\ell}\\mathbf{h}_{i}=\\sum_{i=1}^{T}\\mathbf{g}_{i}</span>.</p>

    <p class="text-gray-300">Define the bivariate polynomial where the degree of <span class="math">X</span> is <span class="math">\\ell+T-1</span> and the degree of <span class="math">Y</span> is at most <span class="math">(v-1)\\cdot(\\ell+T-1)</span>,</p>

    <p class="text-gray-300"><span class="math">p(X,Y)</span> <span class="math">=</span> <span class="math">\\prod_{k=1}^{\\ell}(X+w_{k}(Y))\\cdot\\prod_{j=1}^{T}(X+t_{j}(Y))\\cdot\\left(\\sum_{i=1}^{\\ell}\\frac{1}{X+w_{i}(Y)}-\\sum_{i=1}^{T}\\frac{\\mathbf{m}_{i}}{X+t_{i}(Y)}\\right)\\,.</span></p>

    <p class="text-gray-300">For every depth-1 internal node <span class="math">u</span>, we denote by <span class="math">(r,\\beta)</span> the partial transcript for one of the <span class="math">u</span>’s children whose challenge <span class="math">r</span> satisfies <span class="math">t_{i}(\\beta)+r\\neq 0</span> for all <span class="math">i\\in[T]</span> and <span class="math">w_{i}(\\beta)+r\\neq 0</span> for all <span class="math">i\\in[\\ell]</span>. As argued in the previous paragraph, we observe that <span class="math">\\sum_{i=1}^{\\ell}\\frac{1}{r+w_{i}(\\beta)}-\\sum_{i=1}^{T}\\frac{\\mathbf{m}_{i}}{r+t_{i}(\\beta)}=0</span>, hence <span class="math">p</span> evaluates to zero at point <span class="math">(r,\\beta)</span>. Note that there are <span class="math">(v-1)\\cdot(\\ell+T-1)+1</span></p>

    <p class="text-gray-300">depth-1 internal nodes (i.e.  <span class="math">(v - 1)\\cdot (\\ell +T - 1) + 1</span>  different  <span class="math">\\beta s</span> ) and each node has  <span class="math">\\ell +T</span>  children (i.e.  <span class="math">\\ell +T</span>  different  <span class="math">r</span> ) such that  <span class="math">p</span>  evaluates to zero at point  <span class="math">(r,\\beta)</span> . Hence  <span class="math">p</span>  is the zero polynomial and  <span class="math">\\sum_{i = 1}^{\\ell}\\frac{1}{X + w_i(Y)} = \\sum_{i = 1}^{T}\\frac{\\mathbf{m}_i}{X + t_i(Y)}</span> . Then by the extension of Lemma 4 described in Equation 7, we have  <span class="math">(\\mathcal{C}_{\\mathrm{VLK}},\\mathbf{w})\\in \\mathcal{R}_{\\mathrm{VLK}}</span>  and the extracted witness is valid.</p>

    <p class="text-gray-300">We provide a sub-protocol for showing that a vector has a single one-bit (and zeros otherwise) at the location of a program counter  <span class="math">pc</span> . This is later used to select the appropriate circuit.</p>

    <p class="text-gray-300">Definition 14. For an integer  <span class="math">n</span>  the relation  <span class="math">\\mathcal{R}_{\\text{select}}</span>  is the set of tuples  <span class="math">(\\mathbf{b}, pc) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  such that  <span class="math">b_i = 0 \\forall i \\in [n] \\setminus \\{pc\\}</span>  and if  <span class="math">pc \\in [n]</span>  then  <span class="math">b_{pc} = 1</span> .</p>

    <p class="text-gray-300">|  Special-sound protocol Πselect for circuit selecting relation Rselect  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b, pc</td>

            <td class="px-3 py-2 border-b border-gray-700">bi · (pc - i) = 0∀i ∈ [n]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | bi · (bi - 1) = 0∀i ∈ [n]  |</p>

    <p class="text-gray-300">|   | ∑i∈[n] bi = 1  |</p>

    <p class="text-gray-300">Complexity and security.  <span class="math">\\Pi_{\\mathrm{select}}</span>  is a 1-move protocol (i.e.  <span class="math">k = 1</span> ); the degree of the verifier is 2.</p>

    <p class="text-gray-300">The protocol trivially satisfies completeness. Note that the protocol is also sound: the checks  <span class="math">b_{i} \\cdot (b_{i} - 1) = 0</span>  ensure that the vector  <span class="math">\\mathbf{b}</span>  is Boolean; the checks  <span class="math">b_{i} \\cdot (pc - i) = 0</span>  ensures that  <span class="math">b_{i} = 0</span>  if  <span class="math">i \\neq pc</span> ; finally, the last check guarantees that  <span class="math">b_{pc} = 1 - \\sum_{i \\in [n] \\setminus \\{pc\\}} b_{i} = 1</span>  as  <span class="math">b_{i} = 0</span>  for all  <span class="math">i \\in [n] \\setminus \\{pc\\}</span> .</p>

    <p class="text-gray-300">Definition 15. Consider configuration  <span class="math">\\mathcal{C}_{\\text{plonkup}} := (n, T; \\sigma; c, d, [\\mathbf{s}_i, G_i]_{i=1}^m; L, \\mathbf{t})</span>  where  <span class="math">\\sigma : [cn] \\to [cn]</span>  is a permutation,  <span class="math">(c, d, [\\mathbf{s}_i, G_i]_{i=1}^m)</span>  are the parameters for the high-degree custom gates,  <span class="math">L \\subseteq [cn]</span>  is the subset of indices for variables that have a lookup gate,  <span class="math">\\mathbf{t} \\in \\mathbb{F}^T</span>  is the lookup table. The relation  <span class="math">\\mathcal{R}_{\\text{plonkup}}</span>  is the set of tuples  <span class="math">(\\mathsf{pi} \\in \\mathbb{F}^{\\ell_{\\mathrm{in}}}, \\mathbf{w} \\in \\mathbb{F}^{cn})</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {w} \\in \\mathcal {R} _ {\\sigma} \\wedge \\mathbf {w} \\in \\mathcal {R} _ {G A T E} \\wedge \\mathbf {w} _ {L} \\in \\mathcal {R} _ {L K} \\wedge \\mathbf {w} [ 1.. \\ell_ {\\mathrm {i n}} ] = \\mathrm {p i}.</span></div>

    <p class="text-gray-300">We present the special-sound protocol for the Plonkup relation  <span class="math">\\mathcal{R}_{\\mathrm{plonkup}}</span>  below.</p>

    <p class="text-gray-300">|  Special-sound protocol Πplonkup for relation Rplonkup  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Compute m ∈ FT such that |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mi := ∑j∈L 1(wj = ti) ∀i ∈ [T]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w, m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">wi - wσ(i) ≡ 0 ∀i ∈ [cn]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | ∑j=1m sj,i · Gj(wi, ..., wi+cn-n)  |</p>

    <p class="text-gray-300">|   |  | ≡ 0 ∀i ∈ [n]  |</p>

    <p class="text-gray-300">|   |  | wi ≡ pi ∀i ∈ [l̅in]  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r ←$ F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">hi := 1/wLi + r ∀i ∈ [</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">gi := mi/ti + r ∀i ∈ [T]</td>

            <td class="px-3 py-2 border-b border-gray-700">h, g</td>

            <td class="px-3 py-2 border-b border-gray-700">∑i=1</td>

            <td class="px-3 py-2 border-b border-gray-700">Li</td>

            <td class="px-3 py-2 border-b border-gray-700">hi ≡ ∑i=1T gi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">hi · (wLi + r) ≡ 1 ∀i ∈ [</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | gi · (ti + r) ≡ mi ∀i ∈ [T]  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity.  <span class="math">\\Pi_{\\mathrm{plonkup}}</span>  is a 3-move protocol (i.e.  <span class="math">k = 2</span> ); the degree of the verifier is  <span class="math">d</span> ; the number of non-zero elements in the prover message is at most  $cn + 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completeness and security. We need to add the checks described in Section 4.3 to achieve perfect completeness. This changes the verification degree to  <span class="math">\\max(d, 3)</span> . Without these checks, the protocol still has all but negligible completeness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 7.  <span class="math">\\Pi_{\\text{plonkup}}</span>  is  $2(T +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -special-sound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The protocol is a parallel composition of  <span class="math">\\Pi_{\\sigma}, \\Pi_{\\mathrm{GATE}}</span>  and  <span class="math">\\Pi_{\\mathrm{LK}}</span>  plus a public input check. In  <span class="math">\\Pi_{\\sigma}</span>  and  <span class="math">\\Pi_{\\mathrm{GATE}}</span> , the prover simply sends the witness, and the verifier checks it is in the relation. These protocols are thus trivially 1-special-sound, i.e. perfectly sound. The public input relation also trivially holds as the verifier checks  <span class="math">\\mathbf{w}_i = \\mathsf{pi}_i</span>  for all  <span class="math">i \\in [\\ell_{\\mathrm{in}}]</span> . By Lemma 5  <span class="math">\\Pi_{\\mathrm{LK}}</span>  is  $2(T +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -special-sound. Thus  </span>\\Pi_{\\mathrm{plonkup}}<span class="math">  is  </span>2(T +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -special-sound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we describe PROTOSTAR. PROTOSTAR is built using a special-sound protocol for capturing non-uniform Plonkup circuit computations. In particular, the relation is checking that one of the <span class="math">I</span> circuits is satisfied, where the index of the target circuit is determined by a part of the public input called program counter <span class="math">pc</span>. The non-uniform Plonkup circuit can add arbitrary constraints on input <span class="math">pc</span>. For example, let the <span class="math">I</span> circuits be the opcodes supported by EVM, the program counter <span class="math">pc</span> can be computed from the online public input, or derived from <span class="math">pc&#x27;</span> and the register state in the previous step.⁵ The circuit will further check that <span class="math">\\mathsf{opcode}[pc]</span> is executed correctly in the current step. For another application, we can consider the <span class="math">I</span> circuits as the predicates of <span class="math">I</span> smart contracts (or transaction types), a user can call one of the smart contracts/transaction types by specifying the index <span class="math">pc</span>, and the cost of proving correct execution is only proportional to the size of an individual smart contract/transaction type rather than the sum of the sizes of the supported smart contracts/transaction types.</p>

    <p class="text-gray-300">For ease of exposition, we assume that the <span class="math">I</span> circuits have the same</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>number of gates <span class="math">n</span>;</li>

      <li>gate arity <span class="math">c</span>;</li>

      <li>maximum gate degree <span class="math">d</span>;</li>

      <li>number of gate types <span class="math">m</span>;</li>

      <li>number of public inputs <span class="math">\\ell_{\\mathrm{in}}</span>;</li>

      <li>number of lookup gates <span class="math">\\ell_{\\mathrm{lk}}</span>.</li>

    </ul>

    <p class="text-gray-300">The scheme naturally extends when different branch circuits have different parameters.</p>

    <p class="text-gray-300"><strong>Definition 16.</strong> Consider configuration <span class="math">\\mathcal{C}_{mplkup} := \\left(\\mathsf{pp} = [n, T, c, d, m, \\ell_{\\mathrm{in}}, \\ell_{\\mathrm{lk}}]; [\\mathcal{C}_i]_{i=1}^I; \\mathbf{t}\\right)</span> where the <span class="math">i</span>th <span class="math">(1 \\leq i \\leq I)</span> branch circuit has configuration <span class="math">\\mathcal{C}_i := (\\mathsf{pp}, \\sigma_i, [\\mathbf{s}_{i,j}, G_{i,j}]_{j=1}^m, L_i)</span>, and <span class="math">\\mathbf{t} \\in \\mathbb{F}^T</span> is the global lookup table. For a public input <span class="math">\\mathsf{pi} := (pc, \\mathsf{pi}&#x27;) \\in \\mathbb{F}^{\\ell_{\\mathrm{in}}}</span> where <span class="math">pc \\in [I]</span> is a program counter, we say that a instance-witness pair <span class="math">(\\mathsf{pi}, \\mathbf{w} \\in \\mathbb{F}^{cn})</span> is in the relation <span class="math">\\mathcal{R}_{mplkup}</span> if and only if <span class="math">(\\mathsf{pi}, \\mathbf{w}) \\in \\mathcal{R}_{plonkup}</span> w.r.t. circuit configuration <span class="math">(\\mathcal{C}_{pc}, \\mathbf{t})</span>.</p>

    <p class="text-gray-300">⁵We refer to Figure 4 of [KST22] for constraining the relation between <span class="math">pc</span> and <span class="math">pc&#x27;</span>.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathrm{mplkup}} = \\langle \\mathsf{P}(\\mathcal{C}_{\\mathrm{mplkup}}, \\mathsf{pi}, \\mathbf{w}), \\mathsf{V}(\\mathcal{C}_{\\mathrm{mplkup}}, \\mathsf{pi} = (pc \\in [I], \\mathsf{pi}&#x27;) \\rangle</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P sends V vector <span class="math">\\mathbf{b} = (0, \\dots, 0, b_{pc} = 1, 0, \\dots, 0) \\in \\mathbb{F}^I</span>.</li>

      <li>V checks that <span class="math">b_i \\cdot (1 - b_i) \\stackrel{?}{=} 0</span> and <span class="math">b_i \\cdot (i - pc) \\stackrel{?}{=} 0</span> for all <span class="math">i \\in [I]</span>, and <span class="math">\\sum_{i \\in [I]} b_i \\stackrel{?}{=} 1</span>.</li>

      <li>P sends vector <span class="math">\\mathbf{m} \\in \\mathbb{F}^T</span> such that <span class="math">\\mathbf{m}_i := \\sum_{j \\in L_{pc}} \\mathbb{1}(\\mathbf{w}_j = \\mathbf{t}_i) \\forall i \\in [T]</span>.</li>

      <li>P sends V a sparse vector <span class="math">\\mathbf{w}^{\\star} := (\\mathbf{w}^{(1)}, \\ldots, \\mathbf{w}^{(I)}) \\in \\mathbb{F}^{Icn}</span> where <span class="math">\\mathbf{w}^{(i)} = 0^{cn}</span> for all <span class="math">i \\in [I] \\setminus \\{pc\\}</span> and <span class="math">\\mathbf{w}^{(pc)} = \\mathbf{w}</span>.</li>

      <li>V checks that</li>

    </ol>

    <p class="text-gray-300">Permutation check: <span class="math">\\sum_{j=1}^{I} b_j (\\mathbf{w}_i^{(j)} - \\mathbf{w}_{\\sigma_j(i)}^{(j)}) \\stackrel{?}{=} 0</span> for all <span class="math">i \\in [cn]</span>.</p>

    <p class="text-gray-300">Public input check: <span class="math">\\sum_{j=1}^{I} b_j \\cdot \\mathbf{w}^{(j)}[1..\\ell_{\\mathrm{in}}] \\stackrel{?}{=} \\mathsf{pi}</span>.</p>

    <p class="text-gray-300">Gate check: for all <span class="math">i \\in [n]</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=1}^{I} b_j \\cdot \\mathsf{GT}_{j,i} \\left(\\mathbf{w}_i^{(j)}, \\dots, \\mathbf{w}_{i + cn - n}^{(j)}\\right) = 0</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{GT}_{j,i}(x_1,\\ldots ,x_c)\\coloneqq \\sum_{k = 1}^{m}\\mathbf{s}_{j,k}[i]\\cdot G_{j,k}(x_1,\\ldots ,x_c)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V samples and sends P random challenge <span class="math">r \\leftarrow \\mathbb{F}</span>.</li>

      <li>P computes vectors <span class="math">\\mathbf{h} \\in \\mathbb{F}^{\\ell_{\\mathrm{lk}}}</span>, <span class="math">\\mathbf{g} \\in \\mathbb{F}^T</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{h}_i := \\frac{1}{\\mathbf{w}_{L_{pc}[i]} + r} \\forall i \\in [\\ell_{\\mathrm{lk}}], \\quad \\mathbf{g}_i := \\frac{\\mathbf{m}_i}{\\mathbf{t}_i + r} \\forall i \\in [T].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V checks that <span class="math">\\sum_{i=1}^{\\ell_{\\mathrm{lk}}} \\mathbf{h}_i \\stackrel{?}{=} \\sum_{i=1}^{T} \\mathbf{g}_i</span> and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{j=1}^{I} b_j \\cdot \\left[ \\mathbf{h}_i \\cdot \\left(\\mathbf{w}_{L_j[i]}^{(j)} + r\\right) \\right] \\stackrel{?}{=} 1 \\quad \\forall i \\in [\\ell_{\\mathrm{lk}}], \\\\ \\mathbf{g}_i \\cdot (\\mathbf{t}_i + r) \\stackrel{?}{=} \\mathbf{m}_i \\quad \\forall i \\in [T] \\end{array}</span></div>

    <p class="text-gray-300">We present the special-sound protocol <span class="math">\\Pi_{\\mathrm{mplkup}}</span> for the multi-circuit Plonkup relation.</p>

    <p class="text-gray-300">Remark 4. The public input check <span class="math">\\sum_{j=1}^{I} b_j \\cdot \\mathbf{w}^{(j)}[1..\\ell_{\\mathrm{in}}] \\stackrel{?}{=} \\mathsf{pi}</span> is equivalent to <span class="math">\\mathbf{w}[1..\\ell_{\\mathrm{in}}] = \\mathbf{w}_{pc}[1..\\ell_{\\mathrm{in}}] \\stackrel{?}{=} \\mathsf{pi}</span> if the vector <span class="math">\\mathbf{b}</span> passes the check at Step 2. Thus we guarantee that <span class="math">\\mathbf{w}[1] = pc</span>, and the circuit relation can add constraints on <span class="math">pc</span> depending on the applications.</p>

    <p class="text-gray-300">Special-soundness.</p>

    <p class="text-gray-300">We prove the special-soundness property of <span class="math">\\Pi_{\\mathrm{mplkup}}</span> below.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 8.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{mplkup}</span> is <span class="math">2(T+\\ell_{\\mathsf{lk}})</span>-special-sound.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}</span> outputs the witness <span class="math">\\mathbf{w}=\\mathbf{w}^{(pc)}</span> sent by the prover. Note that if the verifier checks in step 2 pass, it must be the case that <span class="math">\\mathbf{b}</span> is a bool vector with a single non-zero element <span class="math">b_{pc}</span>. Also, note that given <span class="math">2(T+\\ell_{\\mathsf{lk}})</span> accepting transcripts with distinct challenges <span class="math">r</span>, the vector <span class="math">\\mathbf{b}</span> won’t change. Therefore the sub-transcript after step 2 is essentially a transcript for a Plonkup special-sound protocol <span class="math">\\Pi_{\\mathrm{plonkup}}</span> with configuration <span class="math">\\mathcal{C}_{\\mathrm{plonkup}}:=(n,T,c,d,\\mathcal{C}_{pc},\\mathbf{t})</span>. By Lemma 7, it holds that <span class="math">\\Pi_{\\mathrm{mplkup}}</span> is <span class="math">2(T+\\ell_{\\mathsf{lk}})</span>-special-sound. ∎</p>

    <p class="text-gray-300">We will now use <span class="math">\\Pi_{\\mathrm{mplkup}}</span> and our compiler described in Theorem 3 to design Protostar. Before that, we address two efficiency issues regarding supporting multiple branch circuits and combining high-degree gates with sparse lookups.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Efficient accumulation for supporting many branch circuits.</h4>

    <p class="text-gray-300">Let <span class="math">I</span> be the number of branch circuits. At first glance, the message <span class="math">\\mathbf{w}^{<em>}</span> has length <span class="math">O(In)</span> and seems the accumulation prover needs to take <span class="math">O(In)</span> time to fold the witness. Fortunately, the prover message <span class="math">\\mathbf{w}^{</em>}:=(\\mathbf{w}^{(1)},\\ldots,\\mathbf{w}^{(I)})\\in\\mathbb{F}^{Icn}</span> is sparse: only the witness <span class="math">\\mathbf{w}^{(pc)}</span> for the single activated branch circuit <span class="math">\\mathcal{C}_{pc}</span> is non-zero (where <span class="math">\\mathbf{w}^{(pc)}</span> can be determined at runtime). Thus, using the commitment to <span class="math">\\mathsf{acc.w}^{<em>}</span> and the commitments homomorphism, the complexity for the prover to fold <span class="math">\\mathbf{w}^{</em>}</span> onto <span class="math">\\mathsf{acc.w}^{*}</span> is only <span class="math">O(n)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the other hand, the accumulation prover also needs to compute the error terms <span class="math">[\\mathbf{e}_{j}]_{j=1}^{d-1}</span> described at Step 2 of Fig. 3. Note that each gate check can be split into <span class="math">I</span> parts where at most one part is active, that is, <span class="math">\\sum_{j=1}^{I}b_{j}\\cdot\\mathsf{GT}_{j,i}(\\mathbf{w}_{i}^{(j)},\\ldots,\\mathbf{w}_{i+cn-n}^{(j)})</span> can be split into <span class="math">I</span> branch gates where the <span class="math">j</span>-th (<span class="math">1\\leq j\\leq I</span>) branch gate is <span class="math">b_{j}\\cdot\\mathsf{GT}_{j,i}(\\mathbf{w}_{i}^{(j)},\\ldots,\\mathbf{w}_{i+cn-n}^{(j)})</span>. Thus we can use the caching algorithm described in Section 3.6.1 to achieve $O(d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{pc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> computational complexity rather than </span>O(d(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\cdots+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{I}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> where </span>\\mathcal{C}_{i}<span class="math"> (</span>1\\leq i\\leq I<span class="math">) is the evaluation cost of the </span>i$-th branch circuit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we address the issue of combining the high-degree gate and sparse lookup protocols with the generic transform <span class="math">\\mathsf{CV}</span> in Section 3.5.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Efficient accumulation of <span class="math">\\mathsf{CV}[\\Pi_{\\mathbf{mplkup}}]</span>.</h4>

    <p class="text-gray-300"><span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{GATE}}]</span> reduces the number of degree-<span class="math">d</span> verification checks in <span class="math">\\Pi_{\\mathrm{GATE}}</span> from <span class="math">n</span> to <span class="math">1</span>, with the tradeoff of <span class="math">O(\\sqrt{n})</span> additional degree-<span class="math">2</span> checks. In the resulting accumulation scheme, the error terms for high-degree gates are, thus, only of length <span class="math">1</span>. This enables using the trivial identity commitment for these error terms and thus reduces the number of group operations by the accumulation verifier. Unfortunately, applying <span class="math">\\mathsf{CV}</span> to <span class="math">\\mathrm{mplkup}</span> seems to have a major tradeoff. The number of verification checks is <span class="math">n+\\ell_{\\mathsf{lk}}+T+c\\cdot n</span>. This requires using a) <span class="math">\\mathsf{CV}[\\mathrm{mplkup}]</span> and b) is</p>

    <p class="text-gray-300">not composable with the sparseness optimizations for lookup described in Sections 4.3 and Appendix B. These optimizations make the prover computation independent of  <span class="math">T</span> .</p>

    <p class="text-gray-300">Fortunately, a closer look at the verification of mplkup reveals that only  <span class="math">n</span>  of these verification checks are of high degree  <span class="math">d</span> , namely the checks in  <span class="math">\\Pi_{\\mathrm{GATE}}</span> . The other checks are of degree 2 or lower. With a slight abuse of notation, we can define  <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{mplkup}}]</span>  as applying the generic transform  <span class="math">\\mathsf{CV}</span>  only to the  <span class="math">\\Pi_{\\mathrm{GATE}}</span>  part of  <span class="math">\\Pi_{\\mathrm{mplkup}}</span> . This means that there are  <span class="math">d + 1</span>  cross error vectors (each of length 1) for the degree  <span class="math">d + 2</span>  check in  <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{GATE}}]</span> ; and 1 cross error vector of length  <span class="math">T + \\ell_{\\mathrm{lk}} + cn + O(\\sqrt{n})</span>  for the rest checks—namely the low-degree checks in  <span class="math">\\Pi_{\\mathrm{mplkup}}</span>  and the  <span class="math">O(\\sqrt{n})</span>  degree-2 checks in  <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{GATE}}]</span> . By leveraging the error separation technique described in Sect. 3.5, we can use the identity function to commit to the field elements and a vector commitment to commit to the long error term. Again we leverage homomorphism as described in Section 4.3 to make the prover independent of  <span class="math">T</span> .</p>

    <p class="text-gray-300">Corollary 1 (PROTOSTAR protocol). Consider the configuration</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C} _ {m p l k u p} := (n, T, c, d, m, \\ell_ {\\mathrm {i n}}, \\ell_ {\\mathrm {l k}}; [ \\mathcal {C} _ {i} ] _ {i = 1} ^ {I}; \\mathbf {t}).</span></div>

    <p class="text-gray-300">Given a binding homomorphic commitment scheme  <span class="math">\\mathsf{cm} = (\\mathsf{Setup},\\mathsf{Commit})</span> , and under the Fiat-Shamir Heuristic (Definition 9) for a hash function  <span class="math">\\mathsf{H}</span> , there exists an IVC scheme PROTOSTAR for  <span class="math">\\mathcal{R}_{mplkup}</span>  relations with the following efficiencies for  <span class="math">m = 1</span>  (i.e. each circuit has a single degree- <span class="math">d</span>  gate type), public input length  <span class="math">\\ell_{\\mathrm{in}} = 1</span> : (we omit cost terms that are negligible compared to the dominant parts)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PProtostar native</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PProtostar recursive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VProtostar</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πProtostar</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">+ ℓlk)G</td>

            <td class="px-3 py-2 border-b border-gray-700">3G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(c·n + T + ℓlk)G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(c·n + T + ℓlk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L'(Cpc, d + 2) + 2ℓlkF</td>

            <td class="px-3 py-2 border-b border-gray-700">d + 4F</td>

            <td class="px-3 py-2 border-b border-gray-700">n + ∑i=1I Ci + T + ℓlkF</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq cn<span class="math">  is the number of non-zero entries in the witness,  </span>\\sum_{i=1}^{I} \\mathcal{C}_i<span class="math">  is the cost of evaluating all circuits on some random input, and  </span>L'(\\mathcal{C}_{pc}, d)<span class="math">  is the cost of computing the coefficients of the polynomial  </span>e(X)<span class="math">  defined in Equation 4 using techniques from Section 6.6.  </span>\\mathsf{H}_{\\mathrm{in}}$  is the cost of hashing the public input and the (constant-sized) accumulator instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathsf{SPS} - \\mathsf{IVC}[\\Pi] = \\mathsf{IVC}[\\mathsf{acc}[\\mathsf{FS}[\\mathsf{cm}[\\mathsf{CV}[\\Pi]]]]]</span>  be the transformation from a special-sound protocol to an IVC-scheme described by Theorem 3 (including CV). Then given a commitment scheme  <span class="math">\\mathsf{cm}</span>  by that theorem PROTOSTAR =  <span class="math">\\mathsf{SPS} - \\mathsf{IVC}[\\Pi_{\\mathsf{mplkup}}]</span>  is an IVC scheme for predicates expressed in  <span class="math">\\mathcal{R}_{\\mathsf{mplkup}}</span> . We apply Theorem 3 to get the efficiencies in the table above.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security: Since <span class="math">\\mathsf{CV}[\\Pi_{\\mathrm{GATE}}]</span> is only applied to <span class="math">\\Pi_{\\mathrm{GATE}}</span> which has perfect soundness, by Lemma 8 and Lemma 3, the NARK scheme <span class="math">\\mathsf{FS}[\\mathsf{cm}[\\mathsf{CV}[\\Pi]]]</span> for <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span> has knowledge soundness with knowledge error $(Q + 1)\\cdot \\frac{n + 2(T + \\ell_{\\mathrm{lk}})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} +\\mathsf{negl}(\\lambda)<span class="math">, where </span>Q<span class="math"> is the number of RO queries by the adversary. Using Theorem 2 and Corollary 2 we can construct a accumulation scheme for the NARK scheme </span>\\mathsf{FS}[\\mathsf{cm}[\\mathsf{CV}[\\Pi]]]<span class="math">. The accumulation scheme has negligible knowledge error as </span>d = \\mathsf{poly}(\\lambda)<span class="math">. Therefore, under the Fiat-Shamir heuristic and by Theorem 1, </span>\\mathsf{SPS} - \\mathsf{IVC}[\\Pi]$ is a secure IVC scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Acknowledgments. We would like to thank Ariel Gabizon and Liam Eagen for the inspiring discussions about optimizing the generic transformation protocol in Section 3.5. We'd like to thank Zachary Williamson, Sean Bowe, Srinath Setty, Shang Gao, Joseph Johnston and Nicholas Mohnblatt for pointing out typos and minor mistakes.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFGHO10] Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. “Structure-Preserving Signatures and Commitments to Group Elements”. In: CRYPTO 2010. Ed. by Tal Rabin. Vol. 6223. LNCS. Springer, Heidelberg, Aug. 2010, pp. 209–236. doi: 10.1007/978-3-642-14623-7_12.</li>

      <li>[AFK22] Thomas Attema, Serge Fehr, and Michael Klooß. “Fiat-Shamir Transformation of Multi-round Interactive Proofs”. In: TCC 2022, Part I. Ed. by Eike Kiltz and Vinod Vaikuntanathan. Vol. 13747. LNCS. Springer, Heidelberg, Nov. 2022, pp. 113–142. doi: 10.1007/978-3-031-22318-1_5.</li>

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. “Verifiable Delay Functions”. In: CRYPTO 2018, Part I. Ed. by Hovav Shacham and Alexandra Boldyreva. Vol. 10991. LNCS. Springer, Heidelberg, Aug. 2018, pp. 757–788. doi: 10.1007/978-3-319-96884-1_25.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. “Recursive composition and bootstrapping for SNARKS and proof-carrying data”. In: 45th ACM STOC. Ed. by Dan Boneh, Tim Roughgarden, and Joan Feigenbaum. ACM Press, June 2013, pp. 111–120. doi: 10.1145/2488608.2488623.</li>

      <li>[BCLMS21] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Heidelberg, Aug. 2021, pp. 681–710. doi: 10.1007/978-3-030-84242-0_24.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. “Recursive Proof Composition from Accumulation Schemes”. In: TCC 2020, Part II. Ed. by Rafael Pass and Krzysztof Pietrzak. Vol. 12551. LNCS. Springer, Heidelberg, Nov. 2020, pp. 1–18. doi: 10.1007/978-3-030-64378-2_1.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: CRYPTO 2014, Part II. Ed. by Juan A. Garay and Rosario Gennaro. Vol. 8617. LNCS. Springer, Heidelberg, Aug. 2014, pp. 276–294. doi: 10.1007/978-3-662-44381-1_16.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. https://eprint.iacr.org/2019/1021. 2019.</li>

    </ul>

    <p class="text-gray-300">[BMRS20] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. <em>Coda: Decentralized Cryptocurrency at Scale</em>. Cryptology ePrint Archive, Report 2020/352. https://eprint.iacr.org/2020/352. 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[But22] Vitalik Buterin. <em>The different types of ZK EVM</em>. https://vitalik.ca/general/2022/08/04/zkevm.html. Accessed: 2023-04-27. 2022.</li>

      <li>[CBBZ22] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. <em>HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates</em>. Cryptology ePrint Archive, Report 2022/1355. https://eprint.iacr.org/2022/1355. 2022.</li>

      <li>[CT10] Alessandro Chiesa and Eran Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: <em>ICS 2010</em>. Ed. by Andrew Chi-Chih Yao. Tsinghua University Press, Jan. 2010, pp. 310–331.</li>

      <li>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. “Cluster Computing in Zero Knowledge”. In: <em>EUROCRYPT 2015, Part II</em>. Ed. by Elisabeth Oswald and Marc Fischlin. Vol. 9057. LNCS. Springer, Heidelberg, Apr. 2015, pp. 371–403. doi: 10.1007/978-3-662-46803-6_13.</li>

      <li>[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. <em>cq: Cached quotients for fast lookups</em>. Cryptology ePrint Archive, Report 2022/1763. https://eprint.iacr.org/2022/1763. 2022.</li>

      <li>[GW20] Ariel Gabizon and Zachary J. Williamson. <em>plookup: A simplified polynomial protocol for lookup tables</em>. Cryptology ePrint Archive, Report 2020/315. https://eprint.iacr.org/2020/315. 2020.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. <em>PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</em>. Cryptology ePrint Archive, Report 2019/953. https://eprint.iacr.org/2019/953. 2019.</li>

      <li>[Hab22] Ulrich Haböck. <em>Multivariate lookups based on logarithmic derivatives</em>. Cryptology ePrint Archive, Report 2022/1530. https://eprint.iacr.org/2022/1530. 2022.</li>

      <li>[KB20] Assimakis Kattis and Joseph Bonneau. <em>Proof of Necessary Work: Succinct State Verification with Fairness Guarantees</em>. Cryptology ePrint Archive, Report 2020/190. https://eprint.iacr.org/2020/190. 2020.</li>

      <li>[KMT22] Dmitry Khovratovich, Mary Maller, and Pratyush Ranjan Tiwari. <em>MinRoot: Candidate Sequential Function for Ethereum VDF</em>. Cryptology ePrint Archive, Report 2022/1626. https://eprint.iacr.org/2022/1626. 2022.</li>

    </ul>

    <p class="text-gray-300">[KS22] Abhiram Kothapalli and Srinath Setty. SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive, Report 2022/1758. https://eprint.iacr.org/2022/1758. 2022.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KS23] Abhiram Kothapalli and Srinath Setty. “HyperNova: Recursive arguments for customizable constraint systems”. In: Cryptology ePrint Archive (2023).</li>

      <li>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: CRYPTO 2022, Part IV. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13510. LNCS. Springer, Heidelberg, Aug. 2022, pp. 359–388. doi: 10.1007/978-3-031-15985-5_13.</li>

      <li>[LFKN90] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. “Algebraic Methods for Interactive Proof Systems”. In: 31st FOCS. IEEE Computer Society Press, Oct. 1990, pp. 2–10. doi: 10.1109/FSCS.1990.89518.</li>

      <li>[Moh23] Nicholas Mohnblatt. Sangria: A Folding Scheme for PLONK. https://github.com/geometryresearch/technical_notes/blob/main/sangria_folding_plonk.pdf. Accessed: 2023-04-27. 2023.</li>

      <li>[NT16] Assa Naveh and Eran Tromer. “PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations”. In: 2016 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2016, pp. 255–271. doi: 10.1109/SP.2016.23.</li>

      <li>[Ped92] Torben P. Pedersen. “Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing”. In: CRYPTO’91. Ed. by Joan Feigenbaum. Vol. 576. LNCS. Springer, Heidelberg, Aug. 1992, pp. 129–140. doi: 10.1007/3-540-46766-1_9.</li>

      <li>[PK22] Jim Posen and Assimakis A. Kattis. Caulk+: Table-independent lookup arguments. Cryptology ePrint Archive, Report 2022/957. https://eprint.iacr.org/2022/957. 2022.</li>

      <li>[SAGL18] Srinath Setty, Sebastian Angel, Trinabh Gupta, and Jonathan Lee. “Proving the correct execution of concurrent services in zero-knowledge”. In: 13th USENIX Symposium on Operating Systems Design and Implementation (OSDI 18). 2018, pp. 339–356.</li>

      <li>[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. “Customizable constraint systems for succinct arguments”. In: Cryptology ePrint Archive (2023).</li>

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: TCC 2008. Ed. by Ran Canetti. Vol. 4948. LNCS. Springer, Heidelberg, Mar. 2008, pp. 1–18. doi: 10.1007/978-3-540-78524-8_1.</li>

    </ul>

    <p class="text-gray-300">[Wik21] Douglas Wikström. Special Soundness in the Random Oracle Model. Cryptology ePrint Archive, Report 2021/1265. https://eprint.iacr.org/2021/1265. 2021.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[XCZBFKC22] Alex Luoyuan Xiong, Binyi Chen, Zhenfei Zhang, Benedikt Bünz, Ben Fisch, Fernando Krell, and Philippe Camacho. VERI-ZEXE: Decentralized Private Computation with Universal Setup. Cryptology ePrint Archive, Report 2022/802. https://eprint.iacr.org/2022/802. 2022.</li>

      <li>[ZBKMNS22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. “Caulk: Lookup Arguments in Sublinear Time”. In: ACM CCS 2022. Ed. by Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi. ACM Press, Nov. 2022, pp. 3121–3134. doi: 10.1145/3548606.3560646.</li>

      <li>[ZGKMR22] Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla Ràfols. Baloo: Nearly Optimal Lookup Arguments. Cryptology ePrint Archive, Report 2022/1565. https://eprint.iacr.org/2022/1565. 2022.</li>

      <li>[ZV23] Yan X Zhang and Ard Vark. Origami - A Folding Scheme for Halo2 Lookups. https://hackmd.io/\\spacefactor\\@m{}aardvark/rkHqa3NZ2. Accessed: 2023-07-12. 2023.</li>

    </ul>

    <h2 id="sec-61" class="text-2xl font-bold">Appendix A Accumulation Scheme for high/low degree verifier</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We describe a modification for the accumulation scheme in Section 3.4 that can be useful if <span class="math">\\mathsf{V_{sps}}</span> has both a single high-degree verification check and multiple low-degree checks. E.g. assume that $\\mathsf{V_{sps}}=\\mathsf{V_{sps,1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{V_{sps,2}}<span class="math"> where </span>\\mathsf{V_{sps,1}}:(\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1})\\to\\mathbb{F}<span class="math"> is degree </span>d<span class="math"> and </span>\\mathsf{V_{sps,2}}:(\\mathsf{pi},[\\mathbf{m}_{i}]_{i=1}^{k},[r_{i}]_{i=1}^{k-1})\\to\\mathbb{F}^{\\ell}<span class="math"> is degree </span>2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For simplicity, we assume that <span class="math">\\mathsf{V_{sps,1}}</span> maps to a single field element and that <span class="math">\\mathsf{V_{sps,2}}</span> is degree <span class="math">2</span>, but this naturally extends to more arbitrary degrees, sizes and more components.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The accumulation scheme <span class="math">\\mathsf{acc_{HL}}=(\\mathsf{P_{acc,HL}},\\mathsf{V_{acc,HL}})</span> for $\\mathsf{FS}[\\mathsf{V_{sps,1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{V_{sps,2}}]<span class="math"> is essentially a parallel composition of the accumulation presented Section 3.4 applied to </span>\\mathsf{V_{sps,1}}<span class="math"> and </span>\\mathsf{V_{sps,2}}$. Concretely there are the following modifications to the scheme from Section 3.4:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computes error terms separately for <span class="math">\\mathsf{V_{sps,1}}</span> and <span class="math">\\mathsf{V_{sps,2}}</span>. This means there are <span class="math">d-1</span> constant size error terms and <span class="math">1</span> error term vector of length <span class="math">\\ell</span>.</li>

      <li>The prover uses the identity function to commit to the <span class="math">d</span> error terms and a homomorphic vector commitment <span class="math">\\mathsf{cm}=(\\mathsf{Setup},\\mathsf{Commit})</span> to commit to the single length <span class="math">\\ell</span> error term.</li>

      <li>The accumulator stores two error terms, one for each verifier. One is a field element <span class="math">e</span>, and the other is a commitment <span class="math">E</span> to a length <span class="math">\\ell</span> vector.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation verifier checks the correct accumulation for each error term separately, thus performing <span class="math">d - 1</span> field operations and 1 homomorphic commitment scalar multiplication.</li>

    </ul>

    <p class="text-gray-300"><strong>Complexity and security.</strong> The scheme has the following complexity:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation prover</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>asks <span class="math">k - 1</span> queries to <span class="math">\\rho_{\\mathsf{NARK}}</span> with constant-sized inputs and 1 query to <span class="math">\\rho_{\\mathrm{acc}}</span> with input size <span class="math">d + O(1)</span>;</li>

      <li>computes the coefficients of</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e(X) = \\sum_{j=0}^{d} (\\mu + X)^{d-j} f_j^{\\mathsf{V}_{\\mathrm{sps},1}} (X \\cdot \\mathsf{pi} + \\mathsf{acc}. \\mathsf{pi}, [X \\cdot \\mathbf{m}_i + \\mathsf{acc}. \\mathbf{m}_i]_{i=1}^k, [X \\cdot r_i + \\mathsf{acc}. r_i]_{i=1}^{k-1}) \\in \\mathbb{F}[X]</span></div>

    <p class="text-gray-300">and computes <span class="math">\\mathbf{e} \\in \\mathbb{F}^\\ell</span>, which are the coefficients of <span class="math">X</span> in the polynomials</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=0}^{2} (\\mu + X)^{2-j} f_j^{\\mathsf{V}_{\\mathrm{sps},2}} (X \\cdot \\mathsf{pi} + \\mathsf{acc}. \\mathsf{pi}, [X \\cdot \\mathbf{m}_i + \\mathsf{acc}. \\mathbf{m}_i]_{i=1}^k, [X \\cdot r_i + \\mathsf{acc}. r_i]_{i=1}^{k-1}) \\in (\\mathbb{F}[X])^\\ell</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>commits to <span class="math">\\mathbf{e}</span> using <span class="math">\\ell \\mathbb{G}</span> ops.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- performs $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2<span class="math"> </span>\\mathbb{F}<span class="math">-ops to combine </span>(\\mu, \\mathsf{pi}, [r_i]_{i=1}^{k-1}, [\\mathbf{m}_i]_{i=1}^k)<span class="math"> (where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the number of challenges and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is the number of non-zero elements in prover messages);</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>performs <span class="math">k</span> <span class="math">\\mathbb{G}</span>-ops to combine <span class="math">[C_i]_{i=1}^k</span>;</li>

      <li>performs 1 <span class="math">\\mathbb{G}</span>-op to add <span class="math">E = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e})</span> to <span class="math">\\mathsf{acc}.E</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The accumulation verifier performs</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>asks <span class="math">k - 1</span> queries to <span class="math">\\rho_{\\mathsf{NARK}}</span> and 1 query to <span class="math">\\rho_{\\mathrm{acc}}</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2<span class="math"> </span>\\mathbb{F}<span class="math">-ops to combine </span>(\\mu, \\mathsf{pi}, [r_i]_{i=1}^{k-1})$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k</span> <span class="math">\\mathbb{G}</span>-ops to combine <span class="math">[C_i]_{i=1}^k</span>;</li>

      <li><span class="math">d - 1</span> <span class="math">\\mathbb{F}</span>-ops to add <span class="math">[e_j]_{j=1}^{d-1}</span> onto <span class="math">\\mathsf{acc}.e</span>.</li>

      <li><span class="math">1</span> <span class="math">\\mathbb{G}</span>-op to add <span class="math">E = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e})</span> to <span class="math">\\mathsf{acc}.E</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The decider</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- computes <span class="math">C_i = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{m}_i)</span> for <span class="math">i \\in [k]</span> and <span class="math">E = \\mathsf{Commit}(\\mathsf{ck}, \\mathbf{e})</span>, with total complexity around $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell<span class="math"> </span>\\mathbb{G}$-ops.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>evaluate <span class="math">[f_i^{\\mathsf{V}_{\\mathrm{sps},1}}]_{i=0}^d</span> and <span class="math">[f_i^{\\mathsf{V}_{\\mathrm{sps},2}}]_{i=0}^2</span> to verify <span class="math">e</span> and <span class="math">\\mathbf{e}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Corollary 2 (Hi-LowAccumulation).</strong> Let $(\\mathsf{P}_{\\mathsf{NARK},\\mathsf{HL}},\\mathsf{V}_{\\mathsf{NARK},\\mathsf{HL}}) = \\mathsf{FS}[\\mathsf{V}_{\\mathsf{sps},1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{V}_{\\mathsf{sps},2}]<span class="math"> be an RO-NARK as defined above. Let </span>\\mathsf{cm}<span class="math"> be a binding, homomorphic commitment scheme and </span>\\rho_{\\mathrm{acc}}<span class="math"> be a random oracle. The accumulation scheme </span>\\mathsf{acc}_{\\mathsf{HL}}<span class="math"> for </span>\\mathsf{V}_{\\mathsf{NARK}}<span class="math"> satisfies perfect completeness and has knowledge-error </span>(Q + 1)\\frac{d + 4}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\mathsf{negl}(\\lambda)$, as defined in Definition 8.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">50</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof sketch: Perfect completeness follows immediately from Theorem 2. For knowledge-soundness, consider that <span class="math">\\mathsf{acc}_{\\mathsf{HL}}</span> is a parallel composition of two accumulation schemes applied to a high-degree and a low-degree verifier. Given an adversary that can break the knowledge soundness of <span class="math">\\mathsf{acc}_{\\mathsf{HL}}</span>, we can construct an adversary that can break the knowledge soundness of either the high or the low-degree accumulation. By union bound, this leads to a knowledge error of $(Q+1)\\frac{d+4}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-62" class="text-2xl font-bold">Appendix B Computation of cross error commitments for sparse witnesses</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the witness of the NARK proof <span class="math">\\pi</span> is sparse, i.e., the number of non-zeros in <span class="math">\\pi.\\mathbf{w}</span> is $m\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi.\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we can compute the accumulation proof (i.e., the cross-error commitments) more efficiently where the complexity is independent of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi.\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. However, the algorithm is not fully compatible with the technique in Sect. 3.5 for compressing the number of verifier checks. We leave it an open problem for integrating the algorithm with the CV trick.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">m</span> denote the number of non-zero entries in the NARK proof <span class="math">\\pi</span>. Suppose the polynomial <span class="math">\\mathbf{e}(X)</span> in Eqn. 3 has the form</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{c}a_{i}(\\mathsf{acc}+X\\cdot\\pi)\\cdot\\mathbf{T}_{i}\\circ\\mathbf{h}_{i,1}(\\mathsf{acc}+X\\cdot\\pi)\\circ\\cdots\\circ\\mathbf{h}_{i,d-\\nu_{i}}(\\mathsf{acc}+X\\cdot\\pi)</span> (8)</p>

    <p class="text-gray-300">where <span class="math">c</span> is a constant, and for every <span class="math">i\\in[c]</span>: <span class="math">a_{i}(\\mathsf{acc}+X\\cdot\\pi)</span> is a degree-<span class="math">\\nu_{i}</span> polynomial for which the coefficients can be computed in time <span class="math">O(d^{3}m)</span>; <span class="math">\\mathbf{T}_{i}\\in\\mathbb{F}^{\\ell}</span> is a preprocessed vector; and for every <span class="math">j\\in[d-\\nu_{i}]</span>, <span class="math">\\mathbf{h}_{i,j}(\\mathsf{acc}+X\\pi)</span> is a linear polynomial and <span class="math">\\mathbf{h}_{i,j}(\\mathbf{x})\\in\\mathbb{F}^{\\ell}</span> is sparse if <span class="math">\\mathbf{x}</span> is, that is, the number of non-zeros in <span class="math">\\mathbf{h}_{i,j}(\\mathbf{x})\\in\\mathbb{F}^{\\ell}</span> is no more than <span class="math">\\mu</span> times that in <span class="math">\\mathbf{x}</span> where <span class="math">\\mu</span> is a constant parameter. For ease of exposition, we set <span class="math">\\mu=1</span> in the following context.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300">The Eqn. 8 is homogeneous as each of the <span class="math">c</span> terms has exactly degree <span class="math">d</span>. This is without loss of generality because recall that we pad with <span class="math">(\\mathsf{acc}.\\mu+X)^{d-i}</span> if a term of the NARK verifier check has degree <span class="math">i</span> less than <span class="math">d</span>.</p>

    <p class="text-gray-300">Denote by <span class="math">\\mathbf{e}_{j}</span> (<span class="math">1\\leq j&lt;d</span>) the degree-<span class="math">j</span> coefficients of polynomials <span class="math">\\mathbf{e}(X)</span>. Next, we describe the algorithm for computing <span class="math">E_{j}=\\mathsf{Commit}(\\mathsf{ck},\\mathbf{e}_{j})</span> for every <span class="math">j\\in[d-1]</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">i\\in[c]</span>, initialize <span class="math">U_{i}=\\mathsf{Commit}(\\mathsf{ck},\\mathbf{T}_{i}\\circ\\mathbf{h}_{i,1}(\\mathsf{acc})\\circ\\cdots\\circ\\mathbf{h}_{i,d-\\nu_{i}}(\\mathsf{acc}))</span>. The algorithm additionally stores the accumulator <span class="math">\\mathsf{acc}</span> as well as <span class="math">\\mathbf{T}_{i}</span> for every <span class="math">i\\in[c]</span>.</li>

      <li>Upon receiving a new NARK proof <span class="math">\\pi</span>, for every <span class="math">i\\in[c]</span> and <span class="math">k\\in[d-\\nu_{i}]</span>, compute commitments <span class="math">V_{i,k}</span> to the vector <span class="math">\\mathbf{v}_{i,k}</span> defined as</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{v}_{i,k}:=\\sum_{S\\subseteq[d-\\nu_{i}]:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k}\\mathbf{T}_{i}\\circ\\bigodot_{j\\in S}\\mathbf{h}_{i,j}(\\pi)\\bigodot_{j\\in[d-\\nu_{i}]\\setminus S}\\mathbf{h}_{i,j}(\\mathsf{acc})$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">where <span class="math">\\bigodot</span> denotes the Hadamard products of multiple vectors.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">i\\in[c]</span> and <span class="math">k\\in[0,d]</span>, compute the degree-<span class="math">k</span> coefficient <span class="math">a_{i,k}\\in\\mathbb{F}</span> of the polynomial <span class="math">a_{i}(\\mathsf{acc}+X\\pi)</span>. Note that <span class="math">a_{i,k}=0</span> for all <span class="math">k&gt;\\nu_{i}</span>. The coefficients can be computed in <span class="math">O(d^{3}m)</span> field operations by the second property satisfied above.</li>

      <li>For every <span class="math">i\\in[c]</span> and every <span class="math">j\\in[d-\\nu_{i}+1,d)</span>, we denote <span class="math">V_{i,j}</span> as the commitment to the zero vector. For every <span class="math">j\\in[d-1]</span>, compute the target commitment</li>

    </ol>

    <p class="text-gray-300"><span class="math">E_{j}=\\sum_{i=1}^{c}\\left(a_{i,j}\\cdot U_{i}+\\sum_{\\mu=0}^{j-1}a_{i,\\mu}\\cdot V_{i,j-\\mu}\\right)\\,.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>After the accumulation, let <span class="math">\\alpha\\in\\mathbb{F}</span> denote the folding challenge. For every <span class="math">i\\in[c]</span>, update <span class="math">U_{i}\\leftarrow U_{i}+\\sum_{j=1}^{d-\\nu_{i}}\\alpha^{j}\\cdot V_{i,j}</span>.</li>

    </ol>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">The above algorithm can be run using <span class="math">O(d^{3}m)</span> field operations and <span class="math">O(d^{2}m)</span> group operations.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It is easy to scrutinize that all steps except for step 2 perform <span class="math">O(d^{3}m)</span> field operations plus a constant number of group operations. Next, we present an efficient algorithm for running step 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix any <span class="math">i\\in[c]</span>, we focus on computing the vectors <span class="math">\\mathbf{v}_{i,k}</span> for all <span class="math">k\\in[d-\\nu_{i}]</span>. For notational convenience, we set <span class="math">d^{\\prime}=d-\\nu_{i}</span>. The algorithm first extracts the set of indices <span class="math">S^{<em>}\\subseteq[\\ell_{2}]</span> such that for every <span class="math">u\\in S^{</em>}</span>, the <span class="math">u</span>-th element of <span class="math">\\mathbf{h}_{i,j}(\\pi)</span> is non-zero for <em>at least one</em> <span class="math">j\\in[d^{\\prime}]</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq d^{\\prime}m<span class="math"> because </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{h}_{i,j}(\\pi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><m<span class="math"> for every </span>j\\in[d^{\\prime}]<span class="math">, and for every index </span>\\mathsf{id}<span class="math"> outside </span>S^{<em>}<span class="math">, </span>\\mathbf{v}_{i,k}[\\mathsf{id}]=0<span class="math"> for every </span>k\\in[d^{\\prime}]<span class="math">. We show how to compute </span>\\mathbf{v}_{k}^{</em>}[S^{<em>}]:=\\mathbf{v}_{i,k}[S^{</em>}]<span class="math"> for all </span>k\\in[d^{\\prime}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Initialize <span class="math">\\mathbf{f}_{0}^{(0)}[S^{<em>}]={\\mathbf{T}}_{i}[S^{</em>}]</span> and $\\mathbf{f}_{k}^{(0)}[S^{*}]={\\mathbf{0}}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> for all </span>k\\in[d^{\\prime}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j=1,2,\\ldots,d^{\\prime}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\mathbf{f}_{0}^{(j)}[S^{<em>}]={\\mathbf{f}}_{0}^{(j)}[S^{</em>}]\\circ\\mathbf{h}_{i,j}(\\mathsf{acc})[S^{*}]</span>.</li>

      <li>For <span class="math">k=1,2,\\ldots,j</span>, compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{f}_{k}^{(j)}[S^{<em>}]={\\mathbf{f}}_{k-1}^{(j-1)}[S^{</em>}]\\circ\\mathbf{h}_{i,j}(\\pi)[S^{<em>}]+\\mathbf{f}_{k}^{(j-1)}[S^{</em>}]\\circ\\mathbf{h}_{i,j}(\\mathsf{acc})[S^{*}]\\,.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The algorithm takes $O(d^{\\prime 2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=O(d^{\\prime 3}m)<span class="math"> field operations. Moreover, by definition of </span>\\mathbf{v}_{i,k}<span class="math"> (Eqn 9), it holds that </span>\\mathbf{f}_{k}^{(d)}[S^{<em>}]={\\mathbf{v}}_{i,k}[S^{</em>}]<span class="math"> for every </span>k\\in[d]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In summary, fix any <span class="math">i\\in[c]</span>, we obtain an algorithm for computing the vectors <span class="math">\\mathbf{v}_{i,k}</span> for all <span class="math">k\\in[d-\\nu_{i}]</span> in <span class="math">O((d-\\nu_{i})^{3}m)</span> field operations. Moreover, since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{h}_{i,j}(\\pi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><m<span class="math"> for every </span>j\\in[d-\\nu_{i}]<span class="math">, each vector </span>\\mathbf{v}_{i,k}<span class="math"> has at most </span>(d-\\nu_{i})m<span class="math"> non-zero entries by its definition, thus it takes </span>O((d-\\nu_{i})m)<span class="math"> group operations to commit to each vector </span>\\mathbf{v}_{i,k}<span class="math"> (</span>1\\leq k\\leq[d-\\nu_{i}]<span class="math">). Since </span>c<span class="math"> is a constant and </span>d-\\nu_{i}\\leq d<span class="math"> for every </span>i\\in[c]<span class="math">, the computational complexity of step 2 is </span>O(d^{3}m)<span class="math"> field operations and </span>O(d^{2}m)$ group operations. Thus the lemma holds. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300"><span class="math">E_{j}</span> is the commitment to the degree-<span class="math">j</span> coefficients of <span class="math">\\mathbf{e}(X)</span> for all <span class="math">j\\in[d-1]</span>.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall polynomial <span class="math">\\mathbf{e}(X)</span> has the form in Equation 8 where <span class="math">a_{i}(\\mathsf{acc}+X\\cdot\\pi)=\\sum_{j=0}^{d-\\nu_{i}}a_{i,j}X^{j}</span> is of degree <span class="math">d-\\nu_{i}</span> and <span class="math">\\mathbf{h}_{i,j}(\\mathsf{acc}+X\\cdot\\pi)</span> are linear polynomials for all <span class="math">i\\in[c]</span> and <span class="math">j\\in[d-\\nu_{i}]</span>. By definition of <span class="math">\\mathbf{e}(X)</span>, the coefficient form of <span class="math">\\mathbf{e}(X)=\\sum_{i=0}^{d}\\mathbf{f}_{i}X^{i}</span> satisfies that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{f}_{j}=\\sum_{i=1}^{c}\\left(\\sum_{\\mu=0}^{j}a_{i,\\mu}\\cdot\\mathbf{v}_{i,j-\\mu}\\right)</span></p>

    <p class="text-gray-300">for every <span class="math">j\\in[d-1]</span>, where <span class="math">\\mathbf{v}_{i,j-\\mu}</span> is defined as in Eqn. 9 for every <span class="math">\\mu&lt;j</span>, and <span class="math">\\mathbf{v}_{i,0}=\\mathbf{T}_{i}\\circ\\mathbf{h}_{i,1}(\\mathsf{acc})\\circ\\cdots\\circ\\mathbf{h}_{i,d-\\nu_{i}}(\\mathsf{acc})</span> is the vector committed in <span class="math">U_{i}</span>. By the homomorphic property of the commitment scheme, we obtain that <span class="math">E_{j}</span> is the commitment to <span class="math">\\mathbf{f}_{j}</span> for every <span class="math">j\\in[d-1]</span>, thus the lemma holds. ∎</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">For every <span class="math">i\\in[c]</span>, <span class="math">U_{i}+\\sum_{j=1}^{d-\\nu_{i}}\\alpha^{j}\\cdot V_{i,j}</span> is the commitment to vector <span class="math">\\mathbf{T}_{i}\\circ\\mathbf{h}_{i,1}(\\mathsf{acc}^{\\prime})\\circ\\cdots\\circ\\mathbf{h}_{i,d-\\nu_{i}}(\\mathsf{acc}^{\\prime})</span> where <span class="math">\\mathsf{acc}^{\\prime}=\\mathsf{acc}+\\alpha\\cdot\\pi</span> is the updated accumulator.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that for every <span class="math">k\\in[d-\\nu_{i}]</span>, <span class="math">V_{i,k}</span> is the commitment to the vector <span class="math">\\mathbf{v}_{i,k}</span> in Eqn. 9, and <span class="math">U_{i}</span> is the commitment to vector <span class="math">\\mathbf{v}_{i,0}:=\\mathbf{T}_{i}\\circ\\mathbf{h}_{i,1}(\\mathsf{acc})\\circ\\cdots\\circ\\mathbf{h}_{i,d-\\nu_{i}}(\\mathsf{acc})</span>. Therefore, by the homomorphic property of the commitment scheme, <span class="math">U_{i}+\\sum_{j=1}^{d-\\nu_{i}}\\alpha^{j}\\cdot V_{i,j}</span> is the commitment to the vector <span class="math">\\sum_{j=0}^{d-\\nu_{i}}\\alpha^{j}\\mathbf{v}_{i,j}</span>, which is the evaluation of the polynomial</p>

    <p class="text-gray-300"><span class="math">\\mathbf{T}_{i}\\circ\\mathbf{h}_{i,1}(\\mathsf{acc}+X\\cdot\\pi)\\circ\\cdots\\circ\\mathbf{h}_{i,d-\\nu_{i}}(\\mathsf{acc}+X\\cdot\\pi)</span></p>

    <p class="text-gray-300">at point <span class="math">\\alpha</span>. Thus the lemma holds. ∎</p>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">Example applications.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The algorithm can be used in Sect. 4.3 to obtain a table-size independent accumulation prover that computes the cross-error term commitments efficiently. The time complexity is <span class="math">O(\\ell)\\ll T</span> where <span class="math">\\ell</span> is the number of lookups per accumulation step and <span class="math">T</span> is the lookup table size. For a vector <span class="math">\\mathbf{v}</span>, we use <span class="math">\\mathsf{intp}_{\\mathbf{v}}(X)</span> to denote the linear polynomial <span class="math">\\mathsf{acc}.\\mathbf{v}+X\\cdot\\pi.\\mathbf{v}</span>. Recall that in the special sound protocol for lookup in Sect. 4.3, the cross error term vector <span class="math">\\mathbf{e}_{1}</span> is the degree-<span class="math">1</span> coefficient of the polynomial $\\mathbf{e}(X)=(\\mathbf{e}^{(1)}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}^{(2)}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}^{(3)}(X))$ where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{e}^{(1)}(X)=\\mathsf{intp}_{\\mu}(X)\\cdot\\left(\\sum_{i=1}^{\\ell}\\mathsf{intp}_{\\mathbf{h}_{i}}(X)-\\sum_{i=1}^{T}\\mathsf{intp}_{\\mathbf{g}_{i}}(X))\\right)</span> <span class="math">\\mathbf{e}^{(2)}(X)=\\mathsf{intp}_{\\mathbf{h}}(X)\\circ(\\mathsf{intp}_{\\mathbf{w}}(X)+\\mathsf{intp}_{r}(X)\\cdot\\mathbf{1}^{\\ell})-\\mathsf{intp}_{\\mu}(X)^{2}\\cdot\\mathbf{1}^{\\ell}</span> <span class="math">\\mathbf{e}^{(3)}(X)=\\mathsf{intp}_{\\mathbf{g}}(X)\\circ(\\mathsf{intp}_{\\mu}(X)\\cdot\\mathbf{t}+\\mathsf{intp}_{r}(X)\\cdot\\mathbf{1}^{T})-\\mathsf{intp}_{\\mu}(X)\\cdot\\mathsf{intp}_{\\mathbf{m}}(X)</span></p>

    <p class="text-gray-300">It is sufficient to show that <span class="math">\\mathbf{e}(X)</span> has the form as in Eqn. 8. We set:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Degree <span class="math">d=2</span>, the number of terms is <span class="math">c=7</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the 1st term is for <span class="math">\\mathbf{e}^{(1)}(X)</span>, where <span class="math">a_{1}(\\mathsf{acc}+X\\pi)=\\mathbf{e}^{(1)}(X)</span> has degree 2, and the preprocessed vector $\\mathbf{T}_{1}=[1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{\\ell+T}]$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the next 3 terms are for <span class="math">\\mathbf{e}^{(2)}(X)</span>, where</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">a_{2}(\\mathsf{acc}+X\\pi)=1</span>, $\\mathbf{T}_{2}=[0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1^{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{T}]<span class="math">, </span>\\mathbf{h}_{2,1}(\\mathsf{acc}+X\\pi)=[0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{intp}_{\\mathbf{h}}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{T}]<span class="math">, </span>\\mathbf{h}_{2,2}(\\mathsf{acc}+X\\pi)=[0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{intp}_{\\mathbf{w}}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{T}]$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">a_{4}(\\mathsf{acc}+X\\pi)=-\\mathsf{intp}_{\\mu}(X)^{2}</span>, $\\mathbf{T}_{4}=[0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1^{\\ell}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0^{T}]$;</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the last 3 terms are for <span class="math">\\mathbf{e}^{(3)}(X)</span>, where</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">a_{5}(\\mathsf{acc}+X\\pi)=\\mathsf{intp}_{\\mu}(X)</span>, $\\mathbf{T}_{5}=[0^{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}]<span class="math">, and </span>\\mathbf{h}_{5,1}(\\mathsf{acc}+X\\pi)=[0^{\\ell+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{intp}_{\\mathbf{g}}(X)]$;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">a_{7}(\\mathsf{acc}+X\\pi)=-\\mathsf{intp}_{\\mu}(X)</span>, $\\mathbf{T}_{7}=[0^{\\ell+1}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1^{T}]<span class="math">, and </span>\\mathbf{h}_{7,1}(\\mathsf{acc}+X\\pi)=[0^{\\ell+1}</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{intp}_{\\mathbf{m}}(X)]$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is easy to check that all of the <span class="math">\\mathbf{h}</span> vectors are sparse (i.e., with no more than <span class="math">\\ell</span> non-zero entries), and <span class="math">\\mathbf{e}(X)</span> satisfies Eqn. 8 given the above setup.</p>

    <h2 id="sec-71" class="text-2xl font-bold">Appendix C Protostar for CCS</h2>

    <p class="text-gray-300">Recently, Setty, Thaler and Wahby introduced Customizable Constraint System (CCS), a new characterization of NP that is a generalization of R1CS[STW23]. It enables the use of high-degree gates while not requiring permutation arguments. It is also powerful enough to capture both R1CS and Plonk constraints. As described in the introduction, HyperNova builds an accumulation scheme and, thus, IVC for CCS. However, HyperNova does not natively support non-uniform circuits and both the recursion cost, as well as the cost for lookups is more expensive than Protostar, which is built for mplkup. However, mplkup still requires a permutation argument and so-called copy-constraints. We show that our general compiler is powerful enough to port the benefits of Protostar directly to CCS. The starting point is the trivial special-sound protocol for CCS:</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Definition 17 (<em>[STW23]</em>).</h6>

    <p class="text-gray-300">Given public parameters <span class="math">m,n,N,\\ell_{\\mathsf{in}},t,q,d\\in\\mathbb{N}</span> where <span class="math">n&gt;\\ell</span>, let <span class="math">M_{1},\\ldots,M_{t}\\in\\mathbb{F}^{m\\times n}</span> be matrices with at most <span class="math">N</span> total non-zero entries. Let <span class="math">S_{1},\\ldots S_{q}</span> be multisets over domain <span class="math">[t]</span> and each multiset has cardinality at most <span class="math">d</span>. Let <span class="math">c_{1},\\ldots,c_{q}\\in\\mathbb{F}</span> be constants. A tuple <span class="math">(\\mathsf{pi},\\mathbf{w})\\in\\mathbb{F}^{\\ell_{\\mathsf{in}}}\\times\\mathbb{F}^{n-\\ell_{\\mathsf{in}}-1}</span> is in the relation <span class="math">\\mathcal{R}_{\\text{ccs}}</span> if and only if</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{q-1}c_{i}\\cdot\\bigcirc_{j\\in S_{j}}M_{j}\\cdot\\mathbf{z}=\\mathbf{0}^{m}\\,,</span></p>

    <p class="text-gray-300">where <span class="math">z=(1,\\mathsf{pi},\\mathbf{w})</span>. <span class="math">\\bigcirc</span> denotes the Hadamard product between vectors.</p>

    <p class="text-gray-300">Special-sound protocol  <span class="math">\\Pi_{\\mathrm{ccs}}</span>  for relation  <span class="math">\\mathcal{R}_{\\mathrm{ccs}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover P(Cccs, pi ∈ Fℓin, w ∈ Fn-ℓin-1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier V(Cccs, pi)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">z = (1, pi, w) ∈ Fn</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ∑i=0q-1ci · ○j∈SjMj · z ≠ 0m  |</p>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{\\mathrm{ccs}}</span>  is a 1-move protocol (i.e.  <span class="math">k = 1</span> ) with verifier degree  <span class="math">d</span> .</p>

    <p class="text-gray-300">Next, we present the special-sound protocol  <span class="math">\\Pi_{\\mathrm{mccs + }}</span>  for the extended CCS relation that has multi-circuits and lookup support. Compared to  <span class="math">\\Pi_{\\mathrm{mplkup}}</span>  in Section 6, the protocol  <span class="math">\\Pi_{\\mathrm{mccs + }}</span>  removes the need of a permutation check.</p>

    <p class="text-gray-300">Definition 18. Consider configuration  <span class="math">\\mathcal{C}_{mccs+} := (\\mathsf{pp} = [m, n, N, \\ell_{\\mathrm{in}}, t, q, d, T, \\ell_{\\mathrm{lk}}]; [\\mathcal{C}_i]_{i=1}^I; \\mathbf{t})</span>  where the  <span class="math">i</span> th  <span class="math">(1 \\leq i \\leq I)</span>  branch circuit has configuration  <span class="math">\\mathcal{C}_i := (\\mathsf{pp}, [M_{j,i}]_{j=1}^t, [S_{j,i}, c_{j,i}]_{j=1}^q, L_i)</span> , and  <span class="math">\\mathbf{t} \\in \\mathbb{F}^T</span>  is the global lookup table. For a public input  <span class="math">\\mathsf{pi} := (pc, \\mathsf{pi}&#x27;) \\in \\mathbb{F}^{\\ell_{\\mathrm{in}}}</span>  where  <span class="math">pc \\in [I]</span>  is a program counter, we say that a instance-witness pair  <span class="math">(\\mathsf{pi}, \\mathbf{w}) \\in \\mathbb{F}^{n-1}</span>  is in the relation  <span class="math">\\mathcal{R}_{mccs+}</span>  if and only if  <span class="math">(\\mathsf{pi}, \\mathbf{w}) \\in \\mathcal{R}_{ccs}</span>  w.r.t. circuit configuration  <span class="math">\\mathcal{C}_{pc}</span>  and  <span class="math">\\mathbf{w}_{L_{pc}} \\subseteq \\mathbf{t}</span> .</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{\\mathrm{mccs} + } = \\langle \\mathsf{P}(\\mathcal{C}_{\\mathrm{mccs} + },\\mathsf{pi},\\mathbf{w}),\\mathsf{V}(\\mathcal{C}_{\\mathrm{mccs} + },\\mathsf{pi} = (pc\\in [I],\\mathsf{pi}^{\\prime}))\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  vector  <span class="math">\\mathbf{b} = (0,\\dots ,0,b_{pc} = 1,0,\\dots ,0)\\in \\mathbb{F}^I</span></li>

      <li><span class="math">\\mathsf{V}</span>  checks that  <span class="math">b_{i}\\cdot (1 - b_{i})\\stackrel {?}{=}0</span>  and  <span class="math">b_{i}\\cdot (i - pc)\\stackrel {?}{=}0</span>  for all  <span class="math">i\\in [I]</span> , and  <span class="math">\\sum_{i\\in [I]}b_i\\stackrel {?}{=}1</span></li>

      <li><span class="math">\\mathsf{P}</span>  sends vector  <span class="math">\\mathbf{m} \\in \\mathbb{F}^T</span>  such that  <span class="math">\\mathbf{m}_i := \\sum_{j \\in L_{pc}} \\mathbb{1}(\\mathbf{w}_j = \\mathbf{t}_i) \\forall i \\in [T]</span> .</li>

      <li><span class="math">\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  a sparse vector  <span class="math">\\mathbf{w}^{*} := (\\mathbf{w}^{(1)},\\dots,\\mathbf{w}^{(I)})</span>  where  <span class="math">\\mathbf{w}^{(i)} = 0^{n - \\ell_{\\mathrm{in}} - 1}</span>  for all  <span class="math">i\\in [I]\\setminus \\{pc\\}</span>  and  <span class="math">\\mathbf{w}^{(pc)} = \\mathbf{w}</span> .</li>

      <li><span class="math">\\mathsf{V}</span>  computes  <span class="math">\\mathbf{z}^{(k)} = (1, \\mathsf{pi}, \\mathbf{w}^{(k)}) \\in \\mathbb{F}^n</span>  for all  <span class="math">k \\in [I]</span>  and checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {k = 1} ^ {I} b _ {k} \\cdot \\sum_ {i = 1} ^ {q} c _ {i, k} \\cdot \\bigcirc_ {j \\in S _ {i, k}} M _ {j, k} \\cdot \\mathbf {z} ^ {(k)} = \\mathbf {0} ^ {m}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V samples and sends P random challenge  <span class="math">r \\gets \\# \\mathbb{F}</span> .</li>

      <li>P computes vectors  <span class="math">\\mathbf{h} \\in \\mathbb{F}^{\\ell_{\\mathrm{lk}}}</span> ,  <span class="math">\\mathbf{g} \\in \\mathbb{F}^T</span>  such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {h} _ {i} := \\frac {1}{\\mathbf {w} _ {L _ {p c} [ i ]} + r} \\forall i \\in [ \\ell_ {\\mathrm {l k}} ], \\quad \\mathbf {g} _ {i} := \\frac {\\mathbf {m} _ {i}}{\\mathbf {t} _ {i} + r} \\forall i \\in [ T ].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V checks that  <span class="math">\\sum_{i=1}^{\\ell_{\\mathrm{lk}}} \\mathbf{h}_i \\stackrel{?}{=} \\sum_{i=1}^{T} \\mathbf{g}_i</span>  and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {j = 1} ^ {I} b _ {j} \\cdot \\left[ \\mathbf {h} _ {i} \\cdot \\left(\\mathbf {w} _ {L _ {j} [ i ]} ^ {(j)} + r\\right) \\right] \\stackrel {?} {=} 1 \\quad \\forall i \\in [ \\ell_ {\\mathrm {l k}} ], \\\\ \\mathbf {g} _ {i} \\cdot (\\mathbf {t} _ {i} + r) \\stackrel {?} {=} \\mathbf {m} _ {i} \\quad \\forall i \\in [ T ]. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Complexity.  <span class="math">\\Pi_{\\mathrm{mccs + }}</span>  is a 3-move protocol (i.e.  <span class="math">k = 2</span> ); the degree of the verifier is  <span class="math">d + 1</span> ; the number of non-zero elements in the prover message is at most  <span class="math">n + 3\\ell_{\\mathrm{lk}}</span> ; the prover message length is at most  <span class="math">I + n + 3T</span> . Hence in the resulting accumulation scheme, the accumulation prover complexity is only  <span class="math">O(n + \\ell_{\\mathrm{lk}})</span>  that is independent of the table size, and the accumulator size is  <span class="math">O(n + T + I)</span>  that is independent of the sum of the sizes of the branch circuits. We detail the efficiency of the resulting IVC scheme in the table below. The efficiency is almost identical to the PROTOSTAR scheme for  <span class="math">\\mathcal{R}_{\\mathrm{mplkup}}</span> . However, the cost of computing the error terms  <span class="math">L^{\\prime}(\\mathrm{ccs}_{pc},d + 2)</span>  now depends on the  <span class="math">pc</span> -th CCS instance.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PProtOSTAR,mccs+ native</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PProtOSTAR,mccs+ recursive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VProtOSTAR,mccs+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πProtOSTAR,mccs+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">+ℓlk)G</td>

            <td class="px-3 py-2 border-b border-gray-700">3G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n+T+ℓlk)G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n+T+ℓlk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L'(ccspc,d+2)+2ℓlkF</td>

            <td class="px-3 py-2 border-b border-gray-700">d+4F</td>

            <td class="px-3 py-2 border-b border-gray-700">n+I·N+T+ℓlkF</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="ProtoStar: Generic Efficient Accumulation/Folding for Specia... (2023/620)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/620
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
