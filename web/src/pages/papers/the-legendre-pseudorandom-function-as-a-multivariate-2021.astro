---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/182';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Legendre Pseudorandom Function as a Multivariate Quadratic Cryptosystem: Security and Applications';
const AUTHORS_HTML = 'István András Seres, Máté Horváth, Péter Burcsi';

const CONTENT = `    <p class="text-gray-300">István András Seres^{1}, Máté Horváth^{2,3}, and Péter Burcsi^{1} ^{1}Eötvös Loránd University, Faculty of Informatics, 3in Research Group ^{2}Budapest University of Technology and Economics, CrySyS Lab ^{3}Bergische Universität Wuppertal</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Sequences of consecutive Legendre and Jacobi symbols as pseudorandom bit generators were proposed for cryptographic use in 1988. Major interest has been shown towards pseudorandom functions (PRF) recently, based on the Legendre and power residue symbols, due to their efficiency in the multi-party setting. The security of these PRFs is not known to be reducible to standard cryptographic assumptions.</p>

    <p class="text-gray-300">In this work, we show that key-recovery attacks against the Legendre PRF are equivalent to solving a specific family of multivariate quadratic (MQ) equation system over a finite prime field. This new perspective sheds some light on the complexity of key-recovery attacks against the Legendre PRF. We conduct algebraic cryptanalysis on the resulting MQ instance. We show that the currently known techniques and attacks fall short in solving these sparse quadratic equation systems. Furthermore, we build novel cryptographic applications of the Legendre PRF, e.g., verifiable random function and (verifiable) oblivious (programmable) PRFs.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero-knowledge proofs (ZKP) and secure multi-party computation (MPC) protocols are ubiquitous in cryptography. These advanced cryptographic tools are applied and deployed in many applications, e.g., privacy-preserving cryptocurrencies, threshold cryptography and secure instant-messaging. The widespread adoption of ZKPs and MPC protocols necessitates novel symmetric-key primitives <em>[GRR^{+}16]</em>. Traditional symmetric-key primitives, e.g., AES, cause significant overhead in ZKPs or MPC due to their vast multiplicative complexity.</p>

    <p class="text-gray-300">Therefore, recently, revived interest has been shown towards algebraic symmetric key primitives with low multiplicative depth <em>[GRR^{+}16]</em>. Lately, several novel algebraic MACs <em>[x10, x11]</em>, hash functions <em>[AGR^{+}16, GKR^{+}21]</em> or algebraic pseudorandom functions <em>[x12]</em> have been proposed for cryptographic use. New algebraic constructions with low multiplicative complexity are especially attractive due to their distinguished efficiency properties in ZKPs or MPC protocols. However, this new algebraic design paradigm possibly opens up new avenues for attacks <em>[AABS^{+}20]</em>. The cryptanalysis of these new symmetric-key primitives is an active research field with notable published works. For instance, Albrecht et al. conducted an algebraic cryptanalysis of MARVELlous <em>[x1]</em> and MiMC hash functions <em>[ACG^{+}19]</em>, while Li and Preneel refined interpolation attacks on low algebraic degree cryptosystems <em>[x20]</em>. One of the most promising cryptosystems for use in ZKPs and MPC protocols is a pseudorandom function (PRF) that is based on quadratic and power residue symbols. Recall that if <span class="math">p</span> is a prime, the Legendre symbol <span class="math">\\binom{a}{p}</span> is <span class="math">1</span> if <span class="math">a</span> is a square modulo <span class="math">p</span> and <span class="math">-1</span> otherwise (the symbol of <span class="math">0</span> mod <span class="math">p</span> is <span class="math">0</span> by convention). In this work, we focus on the cryptographic security of a PRF family, called the Legendre PRF, and its extensions that are derived from the evaluation of the Legendre symbol.</p>

    <p class="text-gray-300">There exists vast mathematics literature asserting that Legendre and power residue symbols are particularly well suited to be applied in pseudorandom functions since they exhibit high pseudorandomness. One of the first results is due to Pólya and Vinogradov (1918), and later Davenport (1931) cf.<em>[x33, x13]</em>. They assert that character sums behave like independent fair coin tosses, i.e., <span class="math">\\sum_{a=M+1}^{M+N}\\binom{a}{p}\\leq\\sqrt{p}\\log p</span>. In the</p>

    <p class="text-gray-300">case of Legendre symbols, Peralta extended this result by showing that for any fixed <span class="math">n</span>, <span class="math">n</span>-grams of Legendre symbols are asymptotically equally distributed <em>[x23]</em>. Mauduit and Sárközy introduced several metrics to measure the pseudorandomness of binary sequences and argued that “Legendre symbol sequences are the most natural candidate for pseudorandomness” <em>[x25]</em>. Ding et al. confirmed the high linear complexity of Legendre symbol sequences <em>[x10]</em>. Tóth and Gyarmati et al. introduced new pseudorandomness measures and asserted high values of those in Legendre symbol sequences <em>[x34, x16]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Related work.</h4>

    <p class="text-gray-300">In spite of the above results, surprisingly, the security guarantees of the Legendre PRF from a cryptographic standpoint are poorly understood. The quantum case is settled whenever a quantum oracle is available for the attacker as polynomial quantum algorithms are known to recover the key of a Legendre PRF <em>[x28, x26]</em>. However, if the oracle can only be queried classically, then no efficient quantum algorithm is known. In concurrent and independent work, Frixons and Schrottenloher <em>[x11]</em> investigated the quantum security of the Legendre PRF without quantum random-access to an oracle. While they presented two new attacks in this setting, both of them remain impractical for key-recovery, strengthening the security intuition. On the other hand, in the classical setting, only exponential key-recovery algorithms are known due to Khovratovich <em>[x18]</em>, Beullens et al. <em>[x3]</em> and Kaluderovic et al. <em>[x19]</em>. One might ask, whether there could be sub-exponential key-recovery attacks on the Legendre PRF. Damgård in 1988 proposed as an open problem to assess the security and complexity of predicting Legendre or Jacobi symbols. He was contemplating on reducing well-known number-theoretic assumptions to the problem of predicting Legendre or Jacobi symbol sequences <em>[x12]</em>. In this paper, we show connections of the Legendre and Jacobi sequences to a different branch of cryptography, namely, multivariate quadratic cryptography. This study is useful in establishing the security of various cryptographic applications derived from the Legendre PRF, e.g. the digital signature scheme by Beullens et al. <em>[x2]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Our contributions.</h4>

    <p class="text-gray-300">In this work, we make the following contributions.</p>

    <p class="text-gray-300">We show that key-recovery attacks on the Legendre PRF are equivalent to solving a specific family of sparse multivariate quadratic equation system over a finite field. Moreover, the weak unpredictability of the PRF is reducible to the decidability of the aforementioned equation system. These connections naturally extend to higher-degree Legendre PRFs and power residue symbol PRFs. We conduct the first algebraic cryptanalysis on the MQ instance induced by the Legendre PRF. We find that the Legendre PRF is immune to interpolation, direct (Gröbner basis) and rank attacks. We also present algebraic geometric arguments to support the complexity of finding solutions in these sparse MQ instances over a finite field. However, all these standard cryptanalytic tools from multivariate cryptography do not improve the state of the art key recovery attacks against the Legendre PRF <em>[x18, x2, x19]</em>. On the other hand, we find that the induced MQ instances behave like random MQ instances in terms of degree of regularity, i.e., the corresponding ideals are semi-regular. This observation might be interpreted as evidence of the difficulty of breaking the Legendre PRF. Besides assessing the security of the Legendre PRF, we utilise its special properties to apply it in various cryptographic tasks. Expressing the Legendre PRF as an MQ instance facilitates novel cryptographic applications, i.e., verifiable random functions. Moreover, we exploit its multiplicativity to construct (verifiable) oblivious (programmable) pseudorandom functions. Due to their efficiency, these novel extensions can be applied in several cryptographic protocols, such as state-of-the-art private set intersection (PSI) protocols.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Organisation.</h4>

    <p class="text-gray-300">This paper is organised as follows. In Section 2, we provide the necessary background on Legendre symbols and related hard cryptographic problems. In Section 3, we show that key-recovery attacks against the Legendre PRF are equivalent to solving a specific MQ instance. In Section 4, we analyze the security of the MQ instance induced by the Legendre PRF. We realize several cryptographic primitives from the Legendre PRF in Section 5. Finally, we conclude our paper in Section 6 by pointing out future directions.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Notations.</h4>

    <p class="text-gray-300">Whenever we sample <span class="math">x</span> from set <span class="math">S</span> uniformly at random we write <span class="math">x\\in_{R}S</span>. Let <span class="math">p</span> be an odd prime and let <span class="math">K\\in_{R}\\mathbb{F}_{p}</span> be a secret key. The modular square root algorithm <span class="math">\\mod p</span> is denoted as <span class="math">\\mathsf{sqrt}_{p}(\\cdot)</span>. Vectors of group elements are denoted in bold. In the following, <span class="math">n,m</span> denote the number of variables and</p>

    <p class="text-gray-300">equations, respectively. Throughout this work, we will work in the multivariate polynomial ring <span class="math">\\mathbb{F}_{p}[x_{1},\\ldots,x_{n}]</span> over a finite field <span class="math">\\mathbb{F}_{p}</span>. <span class="math">\\mathsf{LT}(I)</span> denotes the ideal generated by the leading terms of the ideal <span class="math">I</span>. For the ease of exposition we use <span class="math">[x]</span> to denote a secret share of the value <span class="math">x\\in\\mathbb{F}_{p}</span>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Background on the Legendre PRF.</h4>

    <p class="text-gray-300">Damgård proposed using the sequence of consecutive Legendre symbols with respect to a large prime <span class="math">p</span> for “pseudorandom bit generation” <em>[x10]</em>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2.1 (Sequential Legendre PRF)</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime, depending on the security parameter <span class="math">\\lambda</span>, then let <span class="math">\\{a\\}_{K}</span> denote the following sequence:</p>

    <p class="text-gray-300"><span class="math">\\{a\\}_{K}:=\\bigg{(}\\frac{K}{p}\\bigg{)},\\bigg{(}\\frac{K+1}{p}\\bigg{)},\\ldots,\\bigg{(}\\frac{K+a-1}{p}\\bigg{)}.</span></p>

    <p class="text-gray-300">Damgård conjectured that the sequence is pseudorandom, when starting at a secret <span class="math">K</span>. Sometimes, it is easier to work with bits, rather than the original Legendre symbols themselves, therefore the Legendre PRF is defined with Boolean output (for a key- and input-space <span class="math">\\mathbb{F}_{p}</span>).</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.2 (Legendre pseudorandom function)</h6>

    <p class="text-gray-300">The function <span class="math">L_{K}(x)</span> is defined by mapping the corresponding Legendre symbol to <span class="math">\\{\\,0,1\\}</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">L_{K}(x)=\\Big{\\lfloor}\\frac{1}{2}\\Big{(}1-\\bigg{(}\\frac{K+x}{p}\\bigg{)}\\Big{)}\\Big{\\rfloor}.</span></p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 2.3 (Weak Unpredictability)</h6>

    <p class="text-gray-300">A pseudo-random bit-generator <span class="math">\\mathcal{X}_{\\lambda}(s):\\{0,1\\}^{\\lambda}\\to\\{0,1\\}^{l(\\lambda)}</span>, where <span class="math">s</span> is a seed and <span class="math">l(\\cdot)</span> is an expansion factor, is next bit unpredictable (sometimes weakly unpredictable) if for all probabilistic polynomial time algorithm <span class="math">\\mathcal{A}</span>, there is a negligible function <span class="math">\\mathsf{negl}(\\lambda)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{A}(x_{1},x_{2},\\ldots,x_{l(\\lambda)-1})=x_{l(\\lambda)}]\\leq\\frac{1}{2}+\\mathsf{negl}(\\lambda)\\,,</span></p>

    <p class="text-gray-300">where the sequence <span class="math">X=x_{1}x_{2}\\ldots x_{l(\\lambda)}</span> is generated by <span class="math">\\mathcal{X}_{\\lambda}(s)</span> with <span class="math">s\\in_{R}\\{0,1\\}^{\\lambda}</span>.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Assumptions.</h4>

    <p class="text-gray-300">Grassi et al. formulated the following problem that underpins the security of the Legendre PRF <em>[GRR^{+}16]</em>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2.4 (Shifted Legendre Symbol (SLS) Problem)</h6>

    <p class="text-gray-300">Let <span class="math">K</span> be uniformly sampled from <span class="math">\\mathbb{F}_{p}</span>, and define <span class="math">\\mathcal{O}_{Leg}</span> to be an oracle that takes <span class="math">x\\in\\mathbb{F}_{p}</span> and outputs <span class="math">\\left(\\frac{K+x}{p}\\right)</span>. Then the Shifted Legendre Symbol (SLS) problem is to find <span class="math">K</span> given oracle access to <span class="math">\\mathcal{O}_{Leg}</span> with non-negligible probability.</p>

    <p class="text-gray-300">It is conjectured that no classical adversary running in sub-exponential time could recover the hidden shift <span class="math">K</span>. One might also consider generalisations of the problem, such as changing the linear polynomial to a secret degree-<span class="math">d</span> polynomial in the Legendre symbol evaluations or changing the quadratic symbol to an <span class="math">r</span>th power residue symbol.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2.5 (Multivariate Quadratic (MQ) problem)</h6>

    <p class="text-gray-300">Given random quadratic polynomials over a finite field, i.e., <span class="math">(f_{1}(x_{1},\\ldots,x_{n}),\\ldots,f_{m}(x_{1},\\ldots,x_{n}))\\in\\mathbb{F}[x_{1},\\ldots,x_{n}]^{m}</span>, find a common zero <span class="math">\\mathbf{x}\\in\\mathbb{F}^{n}</span> of the polynomials <span class="math">f_{1},\\ldots,f_{m}</span>.</p>

    <p class="text-gray-300">It is well-known that the MQ problem is NP-hard for any choice of finite field <span class="math">\\mathbb{F}</span> <em>[x13]</em>. In cryptographic applications, <span class="math">\\mathbb{F}</span> is often <span class="math">\\mathbb{F}_{2}</span> or an extension of it. However, throughout this work, we consider MQ problems over <span class="math">\\mathbb{F}_{p}</span>, for some large prime <span class="math">p</span>. The MQ problem is one of the major candidates on which post-quantum secure cryptosystems can be based. Currently, there are no known sub-exponential algorithms to solve the MQ problem.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">NIZK Arguments.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since in our VRF proposal we make use of non-interactive zero-knowledge (NIZK) arguments, we recall the relevant syntax following <em>[x3]</em> and for the details and exact security requirements we refer to <em>[x3]</em>. NIZK arguments consist of four PPT algorithms that are defined with respect to a relation generator algorithm <span class="math">\\mathcal{R}\\text{-}\\mathsf{Gen}(1^{\\lambda})</span> that, upon receiving some security parameter <span class="math">\\lambda</span>, outputs a polynomial time decidable relation <span class="math">\\mathcal{R}:\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}</span> for which in our case $\\{(\\phi,\\mathsf{w})\\in\\mathcal{R}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\phi(\\mathsf{w})=0\\}<span class="math">, where the statement </span>\\phi<span class="math"> is a MQ equation system over </span>\\mathbb{F}_{p}<span class="math"> and a valid witness </span>\\mathsf{w}$ is a solution of the system.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>NIZK.Setup(<span class="math">\\mathcal{R}</span>) <span class="math">\\to(\\sigma,\\tau)</span>. For the relation <span class="math">\\mathcal{R}</span> the setup produces a common reference string <span class="math">\\sigma</span> and a simulation trapdoor <span class="math">\\tau</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>NIZK.Prove<span class="math">(\\mathcal{R},\\sigma,\\phi,\\mathsf{w})\\to\\pi</span>. Upon the <span class="math">(\\phi,\\mathsf{w})\\in\\mathcal{R}</span> and the common reference string <span class="math">\\sigma</span>, the prover returns an argument <span class="math">\\pi</span>.</li>

      <li>NIZK.Vfy<span class="math">(\\mathcal{R},\\sigma,\\phi,\\pi)\\to\\{0,1\\}</span>. Upon the common reference string <span class="math">\\sigma</span>, the statement <span class="math">\\phi</span> and an argument <span class="math">\\pi</span> the verification algorithm returns <span class="math">0</span> or <span class="math">1</span>.</li>

      <li>NIZK.Sim<span class="math">(\\mathcal{R},\\tau,\\phi)\\to\\pi</span>. Using the simulation trapdoor <span class="math">\\tau</span> and statement <span class="math">\\phi</span> the simulator returns an argument <span class="math">\\pi</span>.</li>

    </ul>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 2.6 (Perfect NIZK argument <em>[x1]</em>)</h6>

    <p class="text-gray-300">We say that a NIZK is a perfect NIZK argument for <span class="math">\\mathcal{R}</span> if it has perfect completeness, perfect zero-knowledge and computational soundness as defined in <em>[x1]</em>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3 The Legendre PRF as an MQ instance</h2>

    <p class="text-gray-300">Hereby, we describe how to express the sequential Legendre PRF, cf. Definition 2.1, as a multivariate quadratic equation system. We remark that in a similar fashion, all the variants (higher-degree) and extensions (power-residue and Jacobi PRF) of the sequential Legendre PRF could be expressed as a suitable MQ instance. Most of our results and observations can be easily ported to those MQ instances as well. Therefore, in this work, we solely focus on the sequential Legendre PRF.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.1 The Ideal</h3>

    <p class="text-gray-300">Let us fix an arbitrary quadratic non-residue <span class="math">r\\in\\mathbb{Z}_{p}^{*}</span>. Furthermore, it is assumed that we are given <span class="math">\\{a\\}_{K}</span>, often <span class="math">a\\approx\\log(p)</span>. Let <span class="math">b_{i}:=\\left(\\frac{K+i}{p}\\right)</span> and <span class="math">x_{i}</span> be the corresponding unknown. We think of the unknown <span class="math">x_{i}</span> as the square root of <span class="math">K+i</span> if <span class="math">b_{i}=1</span>, otherwise <span class="math">x_{i}</span> denotes the square root of <span class="math">r(K+i)</span>, which is a quadratic residue. Therefore, for each pair of neighboring Legendre symbols <span class="math">(b_{i},b_{i+1})</span>, we define a unique quadratic equation. If <span class="math">b_{i}=b_{i+1}=1</span>, then we know that <span class="math">x_{i+1}^{2}=K+i+1</span> and <span class="math">x_{i}^{2}=K+i</span>, hence</p>

    <p class="text-gray-300"><span class="math">x_{i+1}^{2}-x_{i}^{2}=1.</span> (1)</p>

    <p class="text-gray-300">If <span class="math">b_{i}=b_{i+1}=-1</span>, then we have that <span class="math">x_{i+1}^{2}=r(K+i+1)</span> and <span class="math">x_{i}^{2}=r(K+i)</span>, hence</p>

    <p class="text-gray-300"><span class="math">x_{i+1}^{2}-x_{i}^{2}=r.</span> (2)</p>

    <p class="text-gray-300">Finally if <span class="math">b_{i}=1=-b_{i+1}</span> or <span class="math">b_{i}=-1=-b_{i+1}</span> then we obtain the following two quadratic equations:</p>

    <p class="text-gray-300"><span class="math">x_{i+1}^{2}-rx_{i}^{2}=r,\\qquad x_{i+1}^{2}-r^{-1}x_{i}^{2}=1.</span> (3)</p>

    <p class="text-gray-300">Altogether, this allows us to efficiently transform any Legendre symbol sequence into an equivalent multivariate quadratic equation system. If we have <span class="math">n</span> Legendre symbols, then we obtain <span class="math">m=n-1</span> independent equations in <span class="math">n</span> variables, hence the MQ instance is underdefined. Note, that the equation system is extremely sparse.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Example 1</h6>

    <p class="text-gray-300">We consider the following example to illustrate the quadratic equation system induced by the Legendre PRF. Let <span class="math">p=\\texttt{0xffffffffffffffffffffffdd}</span> and <span class="math">K=\\texttt{0x27aaa97c746c22e12d10}</span>. The smallest quadratic non-residue modulo <span class="math">p</span> is <span class="math">2</span>. We display the MQ instance induced by the evaluation of the sequential Legendre PRF, <span class="math">\\{5\\}_{K}=(1,1,-1,-1,1)</span>. Each consecutive Legendre symbol pairs define an equation. The ideal corresponding to <span class="math">\\{5\\}_{K}</span> has the following form:</p>

    <p class="text-gray-300"><span class="math">\\langle x_{1}^{2}-x_{0}^{2}-1,x_{2}^{2}-2x_{1}^{2}-2,x_{3}^{2}-x_{2}^{2}-2,x_{4}^{2}-2^{-1}x_{3}^{2}-1\\rangle.</span></p>

    <p class="text-gray-300">Let <span class="math">I:=\\langle f_{1},f_{2},\\ldots,f_{m}\\rangle</span> be the ideal generated by the quadratic polynomials defined by Equations 1, 2 and 3. We want to solve simultaneously this equation system, i.e., finding points in the variety <span class="math">V(I)</span>. If the sequence of Legendre symbols is long enough, heuristically <span class="math">\\mathcal{O}(\\log p)</span>, then there are <span class="math">\\mathcal{O}(1)</span> solutions in <span class="math">\\mathbb{F}_{p}</span> (only considering solutions where <span class="math">x_{i}\\in[0,\\frac{p-1}{2}]</span> for all <span class="math">i</span>) and one of them corresponds to the secret key <span class="math">K</span> of the PRF. Note that <span class="math">V(I)</span> might contain additional solutions when considered above the algebraic closure <span class="math">\\overline{\\mathbb{F}}_{p}</span>.</p>

    <p class="text-gray-300">3.2 The Gröbner basis</p>

    <p class="text-gray-300">To better understand the variety <span class="math">V(I)</span>, first we describe the Gröbner basis of <span class="math">I</span> <em>[x1]</em>. Interestingly, we can easily compute the Gröbner basis of <span class="math">I</span> regardless of the size of <span class="math">p</span> or the length of the Legendre sequence <span class="math">\\{a\\}_{K}</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 3.1</h6>

    <p class="text-gray-300">Given a Legendre symbol sequence <span class="math">\\{n\\}_{K}=(b_{0},\\ldots,b_{n-1})</span> and its corresponding ideal <span class="math">I=\\langle f_{1},f_{2},\\ldots,f_{m}\\rangle</span>, where <span class="math">m=n-1</span> as defined by the Equations 1, 2 and 3, its Gröbner basis with respect to the (graded) lexicographic ordering, consists of the polynomials <span class="math">g_{i}</span>, for <span class="math">i\\in[0,n-2]</span> such that,</p>

    <p class="text-gray-300">\\[ g_{i}=\\begin{cases}x_{i}^{2}-x_{n-1}^{2}+(n-i),if\\,b_{n-1}=1\\wedge b_{i}=1\\\\ x_{i}^{2}-rx_{n-1}^{2}+r(n-i),if\\,b_{n-1}=1\\wedge b_{i}=-1\\\\ x_{i}^{2}-r^{-1}x_{n-1}^{2}+(n-i),if\\,b_{n-1}=-1\\wedge b_{i}=1\\\\ x_{i}^{2}-x_{n-1}^{2}+r(n-i),if\\,b_{n-1}=-1\\wedge b_{i}=-1\\end{cases} \\] (4)</p>

    <p class="text-gray-300">Specifically, <span class="math">I=\\langle g_{0},\\ldots,g_{n-2}\\rangle</span> and <span class="math">G:=(g_{i})_{i=0}^{n-2}</span> is a reduced Gröbner basis.</p>

    <p class="text-gray-300">Proof: With a case distinction one can show that <span class="math">G</span> generates <span class="math">I</span>. For instance, if <span class="math">b_{i}=b_{j}=b_{n-1}=1</span>, then <span class="math">g_{i}-g_{j}=f_{i}</span>. The other cases are similar. Thus <span class="math">I\\subset\\langle G\\rangle</span>.</p>

    <p class="text-gray-300">By the Buchberger-criterion, we only need to verify that for all <span class="math">i,j</span>, it holds that the <span class="math">S</span>-polynomial <span class="math">S(g_{i},g_{j})</span> divided by the Gröbner basis has no remainder, i.e., <span class="math">\\overline{S(g_{i},g_{j})}^{G}=0</span>. This follows from Buchberger’s product criterion but we include the following simple proof for completeness. We let <span class="math">i&lt;j</span> and hereby solely consider the case when <span class="math">b_{i}=b_{j}=b_{n-1}=1</span>. The rest of the cases result in a similar calculation. By the definition of the <span class="math">S</span>-polynomials, we have <span class="math">S(g_{i},g_{j})=x_{j}^{2}g_{i}-x_{i}^{2}g_{j}</span>. First, we divide <span class="math">S(g_{i},g_{j})</span> by <span class="math">g_{i}</span>. We observe that the remainder of the polynomial division is <span class="math">g_{j}(x_{n-1}^{2}-(n-i))</span>, which is divisible by <span class="math">g_{j}</span>. Therefore, indeed <span class="math">\\overline{S(g_{i},g_{j})}^{G}=0</span>. Hence, the polynomials in <span class="math">G</span> indeed form a Gröbner basis.</p>

    <p class="text-gray-300"><span class="math">G</span> is reduced, since all of its basis polynomials have a leading coefficient one. Moreover, <span class="math">\\langle\\mathsf{LT}(g_{i})\\rangle=\\langle\\mathsf{LT}(I)\\rangle</span> and no trailing term of any <span class="math">g_{i}\\in G</span> lies in <span class="math">\\langle\\mathsf{LT}(I)\\rangle</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Example 2</h6>

    <p class="text-gray-300">The Gröbner basis of the polynomials corresponding to the Legendre symbol sequence <span class="math">\\{5\\}_{K}</span>, from Example 1, consists of the following quadratic bi-variate polynomials:</p>

    <p class="text-gray-300"><span class="math">\\langle x_{0}^{2}-x_{4}^{2}+4,x_{1}^{2}-x_{4}^{2}+3,x_{2}^{2}-2x_{4}^{2}+4,x_{3}^{2}-2x_{4}^{2}+2\\rangle.</span></p>

    <p class="text-gray-300">We remark that one can view the resulting equation system as a simultaneous Pell-equation system over <span class="math">\\mathbb{F}_{p}</span>. Each polynomial in the Gröbner basis is quadratic, bi-variate and has <span class="math">p-1</span> solutions in <span class="math">\\mathbb{F}_{p}</span>. Put differently, seemingly no elimination ideal turns out to be helpful in finding a common zero.</p>

    <p class="text-gray-300">First, we observe that the polynomials in <span class="math">I</span> lack any special internal structure, i.e., the only relations holding are the trivial ones. More formally, the <span class="math">m=n-1</span> multivariate quadratic polynomials of <span class="math">I</span> in <span class="math">n</span> variables define a regular ideal, i.e., <span class="math">V(I)</span> is a <span class="math">1</span>-dimensional variety, namely, it contains an infinite number of solutions in <span class="math">\\overline{\\mathbb{F}}_{p}</span>. The proof of the following lemma is in Appendix B.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 3.2</h6>

    <p class="text-gray-300"><span class="math">I</span> is a regular ideal.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">3.3 The Field Equations</h3>

    <p class="text-gray-300">As we have seen previously the corresponding variety <span class="math">V(I)</span> of the ideal <span class="math">I</span> has dimension <span class="math">1</span>. However, in the cryptanalysis of the Legendre PRF, we wish to obtain a <span class="math">0</span>-dimensional variety that contains the secret key <span class="math">K</span> of the PRF. As we show, this can be achieved by adding the field equations to the ideal <span class="math">I</span>.</p>

    <p class="text-gray-300">A sequence <span class="math">\\{n\\}_{K}</span> can be described with polynomials in <span class="math">\\mathbb{F}_{p}[x_{0},x_{1},\\ldots,x_{n}]</span>. Let us define <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$I_{\\mathsf{F}\\mathsf{E}}=I+\\{x_{i}^{p}-x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i\\in[0,n]\\}.$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-25" class="text-base font-medium mt-4">Example 3</h6>

    <p class="text-gray-300">We illustrate the ideal <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> complemented with the field equations with parameters <span class="math">p=191</span> and <span class="math">\\{9\\}_{45}=(1,1,-1,1,1,1,1,1,-1)</span>. The smallest quadratic non-residue is <span class="math">r=7</span> mod <span class="math">191</span>.</p>

    <p class="text-gray-300"><span class="math">I_{\\mathsf{F}\\mathsf{E}}=\\langle-x_{0}^{2}+x_{1}^{2}-1,-7x_{1}^{2}+x_{2}^{2}-7,-x_{2}^{2}+7x_{3}^{2}-7,-x_{3}^{2}+x_{4}^{2}-1,</span> <span class="math">-x_{4}^{2}+x_{5}^{2}-1,-x_{5}^{2}+x_{6}^{2}-1,-x_{6}^{2}+x_{7}^{2}-1,-7x_{7}^{2}+x_{8}^{2}-7,</span> <span class="math">x_{0}^{191}-x_{0},x_{1}^{191}-x_{1},x_{2}^{191}-x_{2},x_{3}^{191}-x_{3},x_{4}^{191}-x_{4},</span> <span class="math">x_{5}^{191}-x_{5},x_{6}^{191}-x_{6},x_{7}^{191}-x_{7},x_{8}^{191}-x_{8}\\rangle.</span></p>

    <p class="text-gray-300">The corresponding Gröbner basis has the following form,</p>

    <p class="text-gray-300"><span class="math">\\langle x_{0}^{2}-45,x_{1}^{2}-46,x_{2}^{2}+53,x_{3}^{2}-48,x_{4}^{2}-49,x_{5}^{2}-50,x_{6}^{2}-51,x_{7}^{2}-52,x_{8}^{2}+11\\rangle.</span></p>

    <p class="text-gray-300">Note how helpful the Gröbner bases are in obtaining the secret key <span class="math">K</span>. In addition, one can also read off all the evaluated points from the Gröbner bases. If the variable <span class="math">x_{i}</span> corresponds to a residue, then <span class="math">x_{i}^{2}</span> is one of the evaluated points in the PRF. Alternatively, if <span class="math">x_{i}</span> corresponds to a non-residue, then <span class="math">r^{-1}x_{i}^{2}\\bmod p</span> is the evaluated point in the PRF.</p>

    <p class="text-gray-300">Using the intuition of the Example 3, we can show in general the structure of the Gröbner basis of <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 3.3</h6>

    <p class="text-gray-300">Let <span class="math">\\{n\\}_{K}=(b_{0},\\ldots,b_{n-1})</span> be a Legendre symbol sequence for which there exists a unique key <span class="math">K</span>. We consider its corresponding ideal complemented with the field equations <span class="math">I_{\\mathsf{F}\\mathsf{E}}=\\langle f_{1},f_{2},\\ldots,f_{m}\\rangle</span>, where <span class="math">m=2(n-1)+1</span> as defined by Equation 5. Then the Gröbner basis of <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> with respect to the (graded) lexicographic ordering, consists of the polynomials <span class="math">g_{i}</span>, for <span class="math">i\\in[0,n-1]</span> such that,</p>

    <p class="text-gray-300">\\[ g_{i}=\\begin{cases}x_{i}^{2}-(K+i),\\text{if }b_{i}=1\\\\ x_{i}^{2}-r(K+i),\\text{if }b_{i}=-1\\end{cases} \\] (6)</p>

    <p class="text-gray-300">Moreover, <span class="math">G:=(g_{i})_{i=0}^{n-1}</span> is a reduced Gröbner basis.</p>

    <p class="text-gray-300">Proof: <span class="math">G</span> generates the ideal <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span>, since each <span class="math">f_{i}</span> can be expressed by using the generators <span class="math">g_{i}</span>. The generating polynomials <span class="math">f_{i}</span> of the ideal <span class="math">I</span> can be expressed as <span class="math">f_{i}=r^{L_{0}(K+i+1)}g_{i+1}-r^{L_{0}(K+i)}g_{i}</span>. The field polynomials can be also expressed using the generators of <span class="math">G</span>. Specifically, let us denote the modular square roots of <span class="math">r^{L_{0}(K+i)}(K+i)</span> as <span class="math">b</span> and <span class="math">c</span>. Then, <span class="math">x_{i}^{p}-x_{i}=g_{i}\\Pi_{a\\neq b,c}(x-a)</span>. Hence, <span class="math">I_{\\mathsf{F}\\mathsf{E}}\\subset\\langle G\\rangle</span>. By the uniqueness of <span class="math">K</span>, we also have that <span class="math">\\langle G\\rangle\\subset I_{\\mathsf{F}\\mathsf{E}}</span>, since the corresponding varieties are equal above the algebraic closure.</p>

    <p class="text-gray-300">Next, we verify that the Buchberger-criterion holds for the polynomials in <span class="math">G</span>. In this case, <span class="math">S(g_{i},g_{j})=x_{j}^{2}g_{i}-x_{i}^{2}g_{j}</span>. Depending on the residuosity of <span class="math">b_{i},b_{j}</span> we have four cases, but for the sake of simplicity we only consider here the case of <span class="math">b_{i}=b_{j}=1</span>. The other cases follow similarly. The <span class="math">S</span>-polynomial is divisible by <span class="math">G</span>, since <span class="math">S(g_{i},g_{j})=x_{j}^{2}(x_{i}^{2}-(K+i))-x_{i}^{2}(x_{j}^{2}-(K+j))=-(K+i)x_{j}^{2}+(K+j)x_{i}^{2}=(K+j)g_{i}-(K+i)g_{j}</span>, that is clearly divisible by the polynomials of <span class="math">G</span>.</p>

    <p class="text-gray-300"><span class="math">G</span> is clearly a reduced Gröbner basis as each leading coefficient is one and no monomial of <span class="math">g_{i}</span> lies in <span class="math">\\langle\\mathsf{L}\\mathsf{T}(G\\setminus g_{i})\\rangle</span>.</p>

    <p class="text-gray-300">In Section 4, we evaluate empirically the time complexity of computing the Gröbner basis of MQ instances (the <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> ideal) induced by Legendre PRF sequences. The ideal <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> cannot be regular as it contains more polynomials than variables. However, the Gröbner basis of <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> allows us to observe easily that in <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> there are no internal dependencies between the ideal’s generating polynomials. More precisely, we prove the following lemma in Appendix B.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 3.4</h6>

    <p class="text-gray-300"><span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> is a semi-regular ideal, if the conditions of Theorem 3.3 are met.</p>

    <p class="text-gray-300">The asymptotic behavior of the degree of regularity of semi-regular ideals is well understood <em>[x1]</em>. The degree of regularity <span class="math">d_{reg}</span> of an ideal is a measure to assess the theoretical complexity of computing the Gröbner basis of an ideal. For a precise definition, the reader is referred to <em>[x10]</em>. Finally, we show the usefulness of <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> in connection with the Legendre PRF.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 3.5</h6>

    <p class="text-gray-300">A successful Legendre key-recovery attack is equivalent in polynomial time to solving the MQ system defined by the ideal <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span>. On the other hand, the weak unpredictability of the Legendre PRF is equivalent to the decidability of the induced MQ instance over the finite prime field.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof: Let us define the variety <span class="math">V</span> and ideal <span class="math">I</span> defined by the Legendre PRF evaluation <span class="math">\\{n\\}_{K}</span>. More precisely, we fix a quadratic non-residue <span class="math">r\\in\\mathbb{F}_{p}</span>. In polynomial-time, we construct $V^{*}=\\{(x_{0},x_{1},\\ldots,x_{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}=\\pm\\mathsf{sqrt}_{p}(r^{L_{K}(i)}(K+i)),i\\in[0,n-1]\\}<span class="math">. The corresponding ideal is denoted as </span>I^{<em>}<span class="math">. We show that </span>V^{</em>}=V(I_{\\mathsf{F}\\mathsf{E}})<span class="math">. First, </span>V^{<em>}\\subset V(I_{\\mathsf{F}\\mathsf{E}})<span class="math">, because this is how the polynomials in </span>I_{\\mathsf{F}\\mathsf{E}}<span class="math"> are constructed, such that all the points in </span>V^{</em>}<span class="math"> vanish on the polynomials of </span>I_{\\mathsf{F}\\mathsf{E}}<span class="math">. The other inclusion is trivial by the construction of the polynomials of </span>I_{\\mathsf{F}\\mathsf{E}}<span class="math">. </span>I_{\\mathsf{F}\\mathsf{E}}<span class="math"> is a radical ideal, since every ideal that contains its field equations is a radical ideal <em>[x23, Lemma 2.2.3.]</em>. Hence, </span>I_{\\mathsf{F}\\mathsf{E}}<span class="math"> is the smallest ideal that vanishes on </span>V^{*}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for the unpredictability of the Legendre PRF, if the MQ system corresponding to a purported PRF evaluation is not solvable, then it is sure that the psuedorandom sequence is not obtained by evaluating the Legendre PRF.</p>

    <p class="text-gray-300">We highlight again the sparsity of the induced MQ instance. This is in contrast with most MQ public-key cryptosystems, where the MQ instance is generated uniformly at random by the signer or encryptor.</p>

    <p class="text-gray-300">Typically, a random MQ instance has many non-zero coefficients resulting in large public keys. Contrarily, in the case of the Legendre PRF, the MQ instances exhibit a specific structure (cf. Example 1, 3) stemming from the multiplicative group of <span class="math">\\mathbb{F}_p</span>. Interestingly, if a single coefficient in the Legendre MQ instance became 0, then the whole equation system suddenly would be trivially solvable by "back-substitution".</p>

    <p class="text-gray-300">In Section 4, we turn our attention to assessing the security of the MQ instance induced by the Legendre PRF. In particular, we assess the complexity of solving the particular equation systems. According to [HLY12], in order to prove the security of a multivariate PRF, it suffices to show that the family of MQ instances <span class="math">\\mathbf{f}</span> induced by the PRF is hard to solve. This is because then the distributions <span class="math">D_{1} = (\\mathbf{f},\\mathbf{f}(x_{0},x_{1},\\ldots ,x_{n - 1}))</span> and <span class="math">D_{2} = (\\mathbf{f},U_{m})</span> are computationally indistinguishable, where <span class="math">U_{m}</span> is a uniform distribution over <span class="math">\\mathbb{F}_p^m</span> [HLY12].</p>

    <p class="text-gray-300">In this section, we evaluate the complexity of a key recovery attack on the Legendre PRF as an MQ instance. We find that direct attacks, solvers and other traditional algebraic attacks (interpolation attacks, MinRank etc.) do not improve on the state-of-the-art classical attack due to Kaluderovic et al [KKK20].</p>

    <p class="text-gray-300">Interpolation Attacks Interpolation attacks aim to interpolate a cryptosystem's polynomial without knowing its secret key [JK97]. In a single party setting, the Legendre PRF is typically evaluated more than once for a particular key <span class="math">K</span>, i.e., <span class="math">\\{a\\}_K</span> is used as a pseudorandom bit-string, where <span class="math">a &amp;gt; 0</span>. In these cases, the resulting bit-string is mapped to integers, for instance, in the following way,</p>

    <div class="my-4 text-center"><span class="math-block">F _ {K} (a) = \\sum_ {i = 0} ^ {a - 1} 2 ^ {a - 1 - i} (K + i) ^ {\\frac {p - 1}{2}} \\mod p \\tag {7}</span></div>

    <p class="text-gray-300">Note that <span class="math">\\deg(F_K(a)) = \\frac{p - 1}{2}</span>, i.e., the degree of the polynomial representing the Legendre PRF has almost full degree over <span class="math">\\mathbb{F}_p</span>, that is exponential in the security parameter. The polynomial is dense (all possible monomials appear) and no coefficient is dependent on the key <span class="math">K</span>. These properties make interpolation attacks infeasible as they would require at least <span class="math">\\frac{p - 1}{2} + 1</span> pairs of keys and pseudorandom field elements to interpolate <span class="math">F_K(a)</span>.</p>

    <p class="text-gray-300">Direct Algebraic Attacks Direct algebraic attacks, i.e., computing the Gröbner basis [Buc65], aim to directly solve the cryptosystem's underlying MQ instance. The computational complexity of these attacks is equivalent to that of computing the Gröbner basis [SKI04], which in turn depends on the degree of regularity, <span class="math">d_{reg}</span>, of the MQ instance at hand. Hence, it is of great interest to compute <span class="math">d_{reg}</span> of an MQ cryptosystem. However, in many cases, this is not possible without actually calculating the Gröbner basis itself. For <span class="math">m</span> equations of degree at most <span class="math">d</span> in <span class="math">n</span> variables, the arithmetic complexity of Gröbner basis computation are <span class="math">2^{2^{\\mathcal{O}(n)}}</span> in general and <span class="math">\\mathcal{O}\\left(m\\cdot \\binom{n+d_{reg}-1}{n}^{\\omega}\\right)</span> in case of 0-dimensional regular systems, where <span class="math">2\\leq \\omega \\leq 3</span> is the linear algebra constant of matrix multiplication.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The maximum degree in the Gröbner basis (left) and the exponential time complexity of computing the Gröbner bases (right) for the ideals <span class="math">I_{\\mathsf{FE}}</span> defined by the Legendre PRF.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2: The maximum degrees in the Gröbner basis of the ideal  <span class="math">I_{\\mathrm{FE}}</span>  as a function of the Legendre PRF sequence length. Figure 3: The genus of the algebraic curves containing the solutions corresponding to a Legendre symbol sequence of length  <span class="math">m + 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">genus</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">769</td>

            <td class="px-3 py-2 border-b border-gray-700">1793</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We empirically evaluated the performance of computing the Gröbner basis for the ideal  <span class="math">I_{\\mathsf{FE}}</span>  induced by the PRF evaluations, see Figure 1. We sampled random small primes with a given bit-length and evaluated the Legendre PRF for a sequence of length seven and nine. We computed and recorded the time it takes to compute the Gröbner basis of the corresponding ideal  <span class="math">I_{\\mathsf{FE}}</span> . We repeated the experiment 10 times. We observe that computing the Gröbner basis takes exponential time in the bit-length of the prime modulus. We expect that launching key-recovery against the Legendre PRF using Gröbner basis methods is hopeless for cryptographic parameter sets, i.e., for primes of size  <span class="math">\\approx 2^{128}</span> . Attaining lower and upper bounds for  <span class="math">d_{reg}</span>  to assess the exact complexity of the Gröbner basis computation of  <span class="math">I_{FE}</span>  is an interesting open problem.</p>

    <p class="text-gray-300">MinRank Attacks The MinRank attack is a powerful tool in the cryptanalysis of multivariate cryptography. MinRank attacks broke numerous multivariate cryptosystems, such as the cryptanalysis of HFE due to Kipnis and Shamir [KS99] or the cryptanalysis of SRP encryption system [PPST17]. In the following, we show that the Legendre PRF has high Q-rank, therefore it is immune to MinRank attacks. For the complete calculation the reader is referred to Appendix E.1.</p>

    <p class="text-gray-300">We give an algebraic-geometric argument on the security of the Legendre PRF. In Section 3.1, we showed that the PRF seed lies in the intersection of multiple Pell-conics. The solutions of a single Pell-equation over  <span class="math">\\mathbb{F}_p</span>  form a cyclic Abelian-group [Dec07]. These groups were previously suggested for use in cryptography as it is believed that the discrete logarithm problem is hard in these groups [Lem03]. A single Pell conic has genus 0. The intersection of two Pell-conics yields a nonsingular elliptic curve with genus 1. Specifically, if one wants to find every secret key  <span class="math">K</span>  that results in a 3-long specific binary sequence produced by the Legendre PRF, e.g.  <span class="math">(1, -1, 1)</span> , then every satisfying secret key  <span class="math">K</span>  is a rational point on a sequence-specific elliptic curve. However, if one considers longer sequences, then the resulting curve has a genus greater than 1, cf. Figure 3. Hence, the solutions of those algebraic curves do not have an Abelian group structure equipped with them. In the following, we compute the genus of the high-degree surfaces induced by the Legendre PRF in the general case.</p>

    <p class="text-gray-300">We want to calculate the genus of the algebraic curve containing the solutions of a Legendre PRF key-recovery attack. More formally, we want to compute  <span class="math">1 - P(0)</span> , where  <span class="math">P(\\cdot)</span>  is the Hilbert-polynomial of the curve defined by the intersection of several Pell conics. Let  <span class="math">(f_1, f_2, \\ldots, f_m)</span>  be the given Pell conics in variables  <span class="math">x_0, x_1, \\ldots, x_n</span>  and  <span class="math">I</span>  the corresponding ideal generated by them. Note that  <span class="math">n</span>  denotes the length of the given Legendre sequence. For  <span class="math">N \\gg 0</span> , we have that  <span class="math">P(N)</span>  is the dimension over  <span class="math">\\mathbb{F}_p</span>  of the degree- <span class="math">N</span>  homogeneous part of  <span class="math">\\mathbb{F}_p[x_0, \\ldots, x_n] / I</span>  [Har13]. This is a linear polynomial. Since for all  <span class="math">i, j, i \\neq j</span>  we have</p>

    <p class="text-gray-300"><span class="math">(f_{i},f_{j})=1</span>, we obtain the following inclusion-exclusion type equation,</p>

    <p class="text-gray-300"><span class="math">P_{n}(N)=g_{n}(N)-\\binom{n-1}{1}g_{n}(N-2)+\\binom{n-1}{2}g_{n}(N-4)-\\ldots,</span> (8)</p>

    <p class="text-gray-300">where <span class="math">g_{n}(N)</span> denotes the number of <span class="math">N</span>-degree monomials in <span class="math">\\mathbb{F}_{p}[x_{0},\\ldots,x_{n}]</span>. Therefore, <span class="math">g_{n}(N)=\\binom{N+n}{n}</span>. For concreteness and as an example let us consider the case of four intersecting Pell-conics, i.e., Legendre-sequences of length five. We have the following expression for the Hilbert-polynomial, when <span class="math">n=4</span>:</p>

    <p class="text-gray-300"><span class="math">P_{4}(N)=\\binom{N+4}{4}-3\\binom{N+2}{4}+3\\binom{N}{4}-\\binom{N-2}{4}.</span> (9)</p>

    <p class="text-gray-300">By substituting <span class="math">N=0</span>, we have that <span class="math">P_{4}(0)=-4</span>, namely the arithmetic genus is <span class="math">1-P_{4}(0)=5</span>. We obtain the following closed formula for the Hilbert-polynomial:</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Lemma 4.1</h6>

    <p class="text-gray-300"><span class="math">P_{n}(N)=2^{(n-1)}\\cdot N-(n-3)\\cdot 2^{(n-2)}</span>.</p>

    <p class="text-gray-300">Proof: The proof is enclosed in Appendix E.2</p>

    <h2 id="sec-33" class="text-2xl font-bold">5 Extensions of the Legendre PRF</h2>

    <p class="text-gray-300">In this section, we construct various extensions of the Legendre PRF and compare them with other state-of-the-art constructions. We build verifiable random functions in Section 5.1, oblivious pseudorandom functions (OPRF) in Section 5.2 and verifiable OPRF in Appendix G.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">5.1 Verifiable Random Functions from the Legendre PRF</h3>

    <p class="text-gray-300">Verifiable random functions (VRFs) are natural extensions of PRFs <em>[x20]</em>. In a VRF, the PRF evaluator can produce a publicly verifiable proof about the correct evaluation of the PRF <span class="math">F_{K}(x)</span> given the PRF input <span class="math">x</span>, the output <span class="math">F_{K}(x)=y</span> and a public verification key, without revealing anything about the secret key <span class="math">K</span>. In many applications, in addition to the efficient production of pseudorandom strings, one also needs to prove the correctness of those pseudorandom bits, e.g., proof-of-stake consensus algorithms <em>[GHM^{+}17]</em>.</p>

    <p class="text-gray-300">An advantage of the Legendre PRF arithmetization as an MQ instance, is that it allows to model the PRF as a low-degree polynomial equation system. This arithmetization easily facilitates the construction of efficient Legendre VRFs. By contrast, if one models the Legendre PRF as a high-degree <span class="math">\\frac{p-1}{2}</span> univariate polynomial by Euler’s criterion, then it hinders applying efficient proof systems for the correct evaluation statement. Building on this observation and using NIZK with the Legendre PRF (following the high-level approach sketched in <em>[x20]</em>), we propose a new VRF that admits post-quantum secure instantiations with comparable performance to the state of the art.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Syntax and Security of VRFs</h4>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 5.1</h6>

    <p class="text-gray-300">A verifiable random function is comprised of the following four polynomial-time algorithms <span class="math">\\mathcal{VRF}=(\\textsf{VRF.PPGen},\\textsf{VRF.Gen},\\textsf{VRF.Eval},\\textsf{VRF.Vfy})</span> with the following functionality:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textsf{VRF.PPGen}(1^{\\lambda})\\rightarrow\\mathsf{pp}_{\\mathsf{vrf}}</span>. Upon the security parameter <span class="math">\\lambda</span>, the algorithm samples the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}</span>.</li>

      <li><span class="math">\\textsf{VRF.Gen}(\\mathsf{pp}_{\\mathsf{vrf}})\\rightarrow(\\mathsf{sk},\\mathsf{vk})</span>. Upon <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}</span>, the algorithm samples secret and verification keys <span class="math">(\\mathsf{sk},\\mathsf{vk})</span>.</li>

      <li><span class="math">\\textsf{VRF.Eval}(\\mathsf{pp}_{\\mathsf{vrf}},\\mathsf{sk},X)\\rightarrow(Y,\\pi)</span>. This algorithm evaluates a PRF <span class="math">F:\\{0,1\\}^{\\lambda}\\times\\{0,1\\}^{\\lambda}\\rightarrow\\{0,1\\}^{\\lambda}</span> using the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}</span>, secret key <span class="math">\\mathsf{sk}</span> and PRF input <span class="math">X</span> and outputs the PRF value <span class="math">Y</span> and a proof of honest evaluation <span class="math">\\pi</span>.</li>

      <li><span class="math">\\textsf{VRF.Vfy}(\\mathsf{pp}_{\\mathsf{vrf}},\\mathsf{vk},X,Y,\\pi)\\rightarrow\\{0,1\\}</span>. Upon the public parameters <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}</span>, verification key <span class="math">\\mathsf{vk}</span>, PRF input-output pair <span class="math">X,Y</span> and proof <span class="math">\\pi</span>, the verification algorithm either outputs <span class="math">1</span> (accept) or <span class="math">0</span> (reject).</li>

    </ul>

    <p class="text-gray-300">Furthermore, the following requirements must hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: <span class="math">\\forall\\lambda\\in\\mathbb{N}</span>, <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}\\longleftrightarrow\\textsf{VRF.PPGen}(1^{\\lambda})</span>, input <span class="math">X\\in\\{0,1\\}^{\\lambda}</span>, keys <span class="math">(\\mathsf{vk},\\mathsf{sk})\\longleftrightarrow\\textsf{VRF.Gen}(\\mathsf{pp}_{\\mathsf{vrf}})</span>, and <span class="math">(Y,\\pi)\\longleftrightarrow\\textsf{VRF.Eval}(\\mathsf{pp}_{\\mathsf{vrf}},\\mathsf{sk},X)</span> it must hold that <span class="math">\\textsf{VRF.Vfy}(\\mathsf{pp}_{\\mathsf{vrf}},\\mathsf{vk},X,Y,\\pi)=1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\boxed{\\mathrm{Trusted}^1}</span>  computational <span class="math">^2</span>  unique provability:  <span class="math">\\forall \\lambda \\in \\mathbb{N}, X \\in \\{0,1\\}^\\lambda</span>  and PPT adversary  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">\\mathrm{negl}(\\lambda)</span>  s.t.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l l l} \\operatorname {V R F}. \\operatorname {V f y} \\left(\\mathrm {p p} _ {\\mathrm {v r f}}, \\mathrm {v k}, X, Y _ {0}, \\pi_ {0}\\right) &amp; = &amp; \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\boxed {\\mathrm {p p} _ {\\mathrm {v r f}} \\leftrightarrow \\mathrm {V R F}. \\mathrm {P P G e n} \\left(1 ^ {\\lambda}\\right)} \\\\ (\\mathrm {v k}, X, Y _ {0}, Y _ {1}, \\pi_ {0}, \\pi_ {1}) \\leftrightarrow \\mathcal {A} (\\mathrm {p p} _ {\\mathrm {v r f}}) \\\\ Y _ {0} \\neq Y _ {1} \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\lambda) \\end{array} \\right. \\tag {10}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pseudorandomness: Let  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  be an attacker with oracle access to VRF.Eval(ppvrf, sk,  <span class="math">\\cdot</span> ) in the following pseudoramndomness game:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\mathcal {G} _ {\\mathcal {A}} ^ {\\mathcal {V R F}} (1 ^ {\\lambda}) \\\\ \\mathrm {p p} _ {\\mathrm {v r f}} \\leftrightarrows \\mathrm {V R F . P P G e n} (1 ^ {\\lambda}) \\\\ (\\mathrm {v k}, \\mathrm {s k}) \\leftrightarrows \\mathrm {V R F . G e n} (\\mathrm {p p} _ {\\mathrm {v r f}}), \\rho_ {\\mathcal {A}} \\leftrightarrows \\{0, 1 \\} ^ {\\lambda} \\\\ (X ^ {*}, \\mathrm {s t}) \\leftrightarrows \\mathcal {A} _ {1} ^ {\\mathrm {V R F . E v a l} (\\mathrm {p p} _ {\\mathrm {v r f}}, \\mathrm {s k}, \\cdot)} (\\mathrm {p p} _ {\\mathrm {v r f}}, \\mathrm {v k}, \\rho_ {\\mathcal {A}}) \\\\ (Y _ {0}, \\pi) := \\mathrm {V R F . E v a l} (\\mathrm {p p} _ {\\mathrm {v r f}}, \\mathrm {s k}, X ^ {*}) \\\\ Y _ {1} \\leftrightarrows \\mathcal {Y} \\\\ b \\leftrightarrows \\{0, 1 \\} \\\\ b ^ {\\prime} := \\mathcal {A} _ {2} ^ {\\mathrm {V R F . E v a l} (\\mathrm {p p} _ {\\mathrm {v r f}}, \\mathrm {s k}, \\cdot)} (Y _ {b}, \\mathrm {s t}) \\\\ \\text {r e t u r n} b = = b ^ {\\prime} \\end{array}</span></div>

    <p class="text-gray-300">Denoting the oracle queries of  <span class="math">\\mathcal{A}</span>  in the game with  <span class="math">\\mathcal{Q} = (X_1, \\ldots, X_Q)</span> , we say that  <span class="math">\\mathcal{A}</span>  is legitimate if for any random coin choices  <span class="math">\\rho_{\\mathcal{A}} \\in \\{0, 1\\}^{\\lambda}</span>  of  <span class="math">\\mathcal{A}</span> , there exists no  <span class="math">i \\in [Q]</span>  for which  <span class="math">X_i = X^<em></span>  would hold. We say that a  <span class="math">\\mathcal{VRF}</span>  is pseudorandom, if for all legitimate  <span class="math">\\mathcal{A}</span> , its advantage in game  <span class="math">\\mathcal{G}_{\\mathcal{A}}^{\\mathcal{VRF}}(1^{\\lambda})</span>  is at most negligible, i.e.,  <span class="math">[\\operatorname</em>{Pr}\\left[\\mathcal{G}_{\\mathcal{A}}^{\\mathcal{VRF}}(1^{\\lambda}) = 1\\right] - \\frac{1}{2}] \\leq \\operatorname{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">We proceed with the construction of the Legendre VRF.</p>

    <p class="text-gray-300">Intuition. We face two challenges in creating a Legendre VRF. First, we need a verification key  <span class="math">\\mathsf{vk}</span> . For  <span class="math">\\mathsf{sk} = K \\in_{R} \\mathbb{F}_{p}</span> , we let  <span class="math">\\mathsf{vk} = \\{c \\cdot \\log p\\}_{K}</span> . Heuristic arguments imply that a long enough symbol sequence is unique if its length is roughly  <span class="math">\\log p</span>  [Per92]. Hence, a unique symbol sequence acts as a "commitment" to  <span class="math">\\mathsf{sk}</span> . Second, we need to verify efficiently the correct evaluation of the Legendre PRF. We can leverage NIZK argument systems, since we can express the correct PRF evaluation statement as a low-degree polynomial equation system.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VRF.PPGen  <span class="math">(1^{\\lambda})\\to \\mathsf{pp}_{\\mathsf{vrf}}</span>  . On receiving the security parameter  <span class="math">1^{\\lambda}</span>  , the public parameter generation algorithm runs  <span class="math">(\\mathcal{R},\\mathsf{aux})\\gets \\mathcal{R}</span>  -Gen and  <span class="math">(\\sigma ,\\tau)\\gets \\mathsf{NIZK.Setup}(\\mathcal{R})</span>  and output  <span class="math">\\mathsf{pp}_{\\mathsf{vrf}} = (\\sigma ,\\mathcal{R})</span></li>

      <li>VRF.Gen  <span class="math">(\\mathsf{pp}_{\\mathsf{vrf}})\\to (\\mathsf{vk},\\mathsf{sk})</span>  . Using the public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}</span>  , the key generation algorithm samples random  <span class="math">\\mathsf{sk} = K\\in_R\\mathbb{F}_p</span>  , compute the Legendre sequence  <span class="math">\\mathsf{vk}\\coloneqq \\{c\\cdot \\log p\\}_{K}</span>  that serves as a "commitment" to  <span class="math">K</span>  (for a fixed constant  <span class="math">c</span></li>

      <li>VRF.Eval  <span class="math">(\\mathsf{pp}_{\\mathsf{vrf}},\\mathsf{sk},X)\\to (Y,\\pi)</span> . The evaluation of the VRF takes the public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{vrf}}</span> , the secret key  <span class="math">\\mathsf{sk} = K</span>  and an input  <span class="math">X</span>  to the PRF. Let  <span class="math">Y</span>  be  <span class="math">\\lambda</span>  consecutive Legendre symbols, i.e.,  <span class="math">Y = \\{\\lambda \\}_{K + X\\lambda}</span> , so that for all  <span class="math">X</span>  we evaluate the symbol on disjoint intervals (we constrain  <span class="math">X\\leq p / \\lambda</span> ). Disjointness is used to ensure the pseudorandomness of the VRF, see the proof in Appendix F. Let  <span class="math">\\pi \\gets \\mathsf{NIZK.Prove}(\\mathcal{R},\\sigma ,\\phi ,\\mathsf{w})</span> , where the witness  <span class="math">\\mathsf{w} = \\mathsf{sk}</span>  and  <span class="math">\\phi</span>  corresponds to a MQ equation system that consists of</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>quadratic equations corresponding to the evaluation of the Legendre PRF as defined in Section 3.1. For an illustrative example, the reader is referred to Figure 4.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Similar equations showing the relation of  <span class="math">\\mathsf{sk}</span>  and  <span class="math">\\mathsf{sk} + X\\lambda</span> , i.e., the  <span class="math">i</span> th bits of  <span class="math">\\mathsf{vk}</span>  and  <span class="math">Y</span>  correspond to Legendre symbols of values with distance  <span class="math">X\\lambda</span> . For instance, in case of two quadratic residues, we have  <span class="math">x_{i}^{2} - x_{\\mathsf{vk}_{i}}^{2} = X\\lambda</span> , cf. Equation 1. The equations corresponding to the other cases can be similarly adapted from the quadratic equations of Section 3.1.</li>

    </ul>

    <p class="text-gray-300">The algorithm outputs  <span class="math">(Y,\\pi)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- VRF.  <span class="math">\\mathsf{Vfy}(\\mathsf{pp}_{\\mathsf{vf}}, \\mathsf{vk}, X, Y, \\pi) \\to \\{0, 1\\}</span> . On receiving the public parameters  <span class="math">\\mathsf{pp}_{\\mathsf{vf}} = (\\mathcal{R}, \\sigma)</span> , verification key  <span class="math">\\mathsf{vk}</span> , a VRF input-output pair  <span class="math">X, Y</span>  with a proof  <span class="math">\\pi</span> , the verification algorithm first determines  <span class="math">\\phi</span>  based on  <span class="math">\\mathsf{vk}, X, Y</span> , and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> , then runs NIZK.  </span>\\mathsf{Vfy}(\\mathcal{R}, \\sigma, \\phi, \\pi)$  and returns its output.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following theorem, which we prove in Appendix F, formalizes the security of the Legendre VRF.</p>

    <p class="text-gray-300">Theorem 5.2 Assuming the hardness of the SLS problem (Definition 2.1) the Legendre VRF is secure according to Definition 5.1, if the underlying NIZK argument fulfils the perfect completeness, perfect zero-knowledge and computational soundness requirements (defined in [BFM19]).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Arithmetic circuit representation of the ZKP statement that proves the relation  <span class="math">\\mathcal{R}_{PRF} = \\{\\{5\\}_K = (1,1, - 1, - 1,1),K\\}</span>  from Example 1 where 2 is the least quadratic non-residue. Applying our Legendre PRF arithmetization, the PRF evaluator proves that it knows the zeros of the following polynomials  <span class="math">(2x_{4}^{2} - x_{3}^{2} = 2,x_{3}^{2} - x_{2}^{2} = 2,x_{2}^{2} - x_{1}^{2} = 2,x_{1}^{2} - x_{0}^{2} = 1)</span> . Secret input nodes are colored with yellow, while public output nodes are colored with green. Nodes with  <span class="math">2x</span>  denote a multiplication gate, where one of the inputs is the constant quadratic non-residue 2. Note, that for any Legendre PRF statement  <span class="math">\\mathcal{R}_{PRF}^{*}</span>  the arithmetic circuit has a constant multiplicative depth of two.</p>

    <p class="text-gray-300">We instantiate our VRF with the state of the art succinct NIZK [Gro16]. However, it does not provide post-quantum security. Another proof system family of zero-knowledge succinct transparent arguments of knowledge (zkSTARK) was pioneered by the work of Ben-Sasson et al. [BSBHR18]. STARK proof systems provide post-quantum security and does not rely on trusted setups. The performance evaluation of [BSBHR18] shows, that the proof of a Legendre PRF statement with  <span class="math">2^{21}</span>  multiplication gates, i.e., verifying  <span class="math">\\approx 2^{19}</span>  Legendre symbols, can be generated in less than a second, while can be verified in 100ms. The proof size is  <span class="math">\\approx 50\\mathrm{KB}</span> . An even more efficient VRF instantiation can be obtained by applying the NIZK of Beullens and Delpech de Saint [BdSG20]. In Table 5.1, we compare the proposed VRF to the state of the art. The Legendre VRF is a potential contender for being the most efficient post-quantum secure VRF in terms of proof size, prover and verifier complexity.</p>

    <p class="text-gray-300">An oblivious PRF (OPRF) [NR97, FIPR05] is a two-party secure computation protocol (2PC) to evaluate a PRF  <span class="math">F(\\cdot, \\cdot)</span>  in an oblivious fashion. Specifically, it allows a sender and a receiver with inputs  <span class="math">K</span>  and  <span class="math">x</span> , respectively, to compute  <span class="math">F(K, x)</span>  such that the sender does not learn anything new from the protocol messages, while the receiver can output  <span class="math">F(K, x)</span>  without obtaining information about the used key  <span class="math">K</span> . In this section, we show how to build an OPRF relying on the hardness of the SLS problem and also extend this result to two variants of OPRFs, namely to programmable and to verifiable OPRFs (denoted as OPPRF and VOPRF respectively).</p>

    <p class="text-gray-300">These protocols are extensively used in various tasks. A non-exhaustive list of OPRF applications include secure keyword search [FIPR05], private set intersection (PSI) [HL10, JL09, KKRT16, KLS+17], secure deduplicated storage [KBR13], password-protected secret sharing [JKKX16], password-authenticated key exchange [JKX18]. OPPRFs were used to build two-party PSI [PSTY19, KK20], multi-party PSI [KMP+17]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(λ = 128)</td>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GNP+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

            <td class="px-3 py-2 border-b border-gray-700">0.34KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1H + 1G</td>

            <td class="px-3 py-2 border-b border-gray-700">1H + 1G</td>

            <td class="px-3 py-2 border-b border-gray-700">Factoring</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[PWH+17]</td>

            <td class="px-3 py-2 border-b border-gray-700">1G + 2Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">768 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">3H + 2G</td>

            <td class="px-3 py-2 border-b border-gray-700">3H + 4G</td>

            <td class="px-3 py-2 border-b border-gray-700">EC-DDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BGLS03]</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

            <td class="px-3 py-2 border-b border-gray-700">377 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">2H + 1G</td>

            <td class="px-3 py-2 border-b border-gray-700">1P</td>

            <td class="px-3 py-2 border-b border-gray-700">co-DH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[DY05]</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

            <td class="px-3 py-2 border-b border-gray-700">377 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">1G + 1Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">2G + 2P</td>

            <td class="px-3 py-2 border-b border-gray-700">q-DBDHI</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[LBM20]</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

            <td class="px-3 py-2 border-b border-gray-700">377 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

            <td class="px-3 py-2 border-b border-gray-700">1P</td>

            <td class="px-3 py-2 border-b border-gray-700">q-DDHE</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[EKS+20]†</td>

            <td class="px-3 py-2 border-b border-gray-700">O(k+l)</td>

            <td class="px-3 py-2 border-b border-gray-700">5KB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kl)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kl)</td>

            <td class="px-3 py-2 border-b border-gray-700">Module-SIS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BDE+21] (SL-VRF)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">40KB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">LowMC, ROM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$5.1+SNARK</td>

            <td class="px-3 py-2 border-b border-gray-700">3G</td>

            <td class="px-3 py-2 border-b border-gray-700">209 bytes</td>

            <td class="px-3 py-2 border-b border-gray-700">9nG</td>

            <td class="px-3 py-2 border-b border-gray-700">nG + 3P</td>

            <td class="px-3 py-2 border-b border-gray-700">SLS, KEA</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$5.1+STARK</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(n))G</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 50KB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log(n))G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(n))G</td>

            <td class="px-3 py-2 border-b border-gray-700">SLS, ROM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$5.1+ [BdSG20]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 30KB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">SLS, ROM</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 5.1: Overview of various VRF constructions. Hashing, group operations, exponentiation and pairings are denoted as  <span class="math">\\mathsf{H},\\mathbb{G},\\mathbb{F}_p,P</span>  , respectively. Note that  <span class="math">[\\mathrm{EKS}^{+}20]</span>  only provides a few-time VRF. Module-SIS and module-LWE ranks are denoted as  <span class="math">k</span>  and  <span class="math">l</span>  , respectively.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the number of AND gates of the LowMC  </span>[\\mathrm{ARS}^{+}15]<span class="math">  PRF applied in  </span>[\\mathrm{BDE}^{+}21]<span class="math">  . Here  </span>n$  is the length of the Legendre symbol sequence being proved. Assumptions written in green are post-quantum secure, while those written in red are not.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and circuit-PSI that enables secure function evaluation on the intersection of sets [CGS22]. Finally, VOPRF is the cornerstone of Privacy Pass, a privacy-preserving lightweight authentication mechanism  <span class="math">\\left[\\mathrm{DGS}^{+}18\\right]</span>  and password-protected secret sharing [JKK14]. The importance of (V)OPRF is also indicated by the ongoing effort to standardize them [DFHSW21].</p>

    <p class="text-gray-300">Motivated by the wide range of applications, our goal is to present a novel pathway to the realization of OPRFs that we formally define in Figure 5a.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (a) The ideal OPRF functionality. Together with the extensions in blue, we get the OPPRF ideal functionality. Figure 5: Ideal functionalities.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (b) Ideal preprocessing functionality.</p>

    <p class="text-gray-300">We observe that the distributed protocol for evaluating the Legendre PRF of  <span class="math">\\left[\\mathrm{GRR}^{+}16\\right]</span>  yields an OPRF. For completeness, we include their protocol presented in the language of OPRFs. The key ingredient - that was used in  <span class="math">\\left[\\mathrm{GRR}^{+}16\\right]</span>  for the secure computation of the Legendre PRF in the multi-party setting - is that the key of the PRF can be masked without changing the PRF value by utilizing the multiplicative property of the Legendre symbol. Namely, if we choose a random square and multiply it with some number, the Legendre symbol of the resulting value will be equal to the symbol of the original number. This fact gives rise to the arithmetic sharing-based <span class="math">^3</span>  OPRF protocol  <span class="math">\\Pi_{\\text{Legendre}}^{\\text{OPRF}}</span> , depicted in Figure 6a. The protocol is divided into online and offline parts. In an offline preprocessing phase the parties can compute the shares of the previously mentioned random square and a so-called Beaver multiplication triple  <span class="math">[a], [b], [ab]</span>  (for some random  <span class="math">a, b</span> ) both of which operations are entirely independent of the inputs of the participants. For simplicity, we abstract away the underlying details of preprocessing and use the necessary operations in a black-box manner through the ideal functionality of Figure 5b. The realization of  <span class="math">\\mathcal{F}_{\\text{Prep}}</span>  is possible using a 2PC framework in the semi-honest model, such as ABY by [DSZ15].</p>

    <p class="text-gray-300">After exchanging secret shares of their inputs, both participants execute the same computation on their shares in the online phase. While the addition of secret shares is for free, i.e., corresponds to ordinary local addition, share multiplication, which we denote with  <span class="math">\\square</span> , consumes one multiplication triple and requires one round of interaction and 2 group elements of communication. Concretely,  <span class="math">[x] \\square [y] = [xy]</span>  can be computed by revealing  <span class="math">(x + a)</span>  and  <span class="math">(y + b)</span>  (that does not disclose information about  <span class="math">x</span>  and  <span class="math">y</span> , because  <span class="math">a, b</span>  are random), then  <span class="math">(x + a) \\cdot (y + b) - (x + a) \\cdot [b] - (y + b) \\cdot [a] + [ab] = [xy]</span>  can be evaluated. The resulting online part then consists of three rounds of interaction and 5 group elements of communication.</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{\\mathrm{Legendre}}^{OPRF}</span>  {pigment}</p>

    <p class="text-gray-300">Participants: sender  <span class="math">S</span> , receiver  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Preprocessing:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>execute  <span class="math">\\mathcal{F}_{\\mathrm{Prep}}</span>  .RandSquare,</li>

      <li>execute  <span class="math">\\mathcal{F}_{\\mathrm{Prep}}</span>  .TripleGen.</li>

    </ol>

    <p class="text-gray-300">Input:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}\\colon K\\in \\mathbb{F}_p</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}\\colon x\\in \\mathbb{F}_p</span></p>

    <p class="text-gray-300">Evaluation:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> ,  <span class="math">\\mathcal{R}</span>  share  <span class="math">[K],[x]</span>  with each other,</li>

      <li>both compute  <span class="math">[e] = [e^2 ]\\square ([K] + [x])</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  <span class="math">S</span>  sends  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to  </span>\\mathcal{R}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{R}</span>  outputs  <span class="math">L_{p}(e) = L_{p}(K + x)</span> .</li>

    </ol>

    <p class="text-gray-300">(a) Legendre OPRF based on  <span class="math">[\\mathrm{GRR}^{+}16]</span> .</p>

    <p class="text-gray-300">Algorithm OPPRF.KeyGen(1 <span class="math">\\lambda</span> , K,  <span class="math">(x_{1},y_{1}),\\ldots,(x_{n},y_{n}))\\to p</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">y_{i}(-1)^{\\frac{(q - 1)(\\mathcal{R} + x_{i} - 1)}{2}} = \\left(\\frac{p}{K + x_{i}}\\right)</span> .</li>

      <li>identify  <span class="math">m_i \\in \\mathbb{Z}_{K + x_i}</span> , e.t.  <span class="math">\\left(\\frac{m_i}{K + x_i}\\right) = y_i(-1)^{\\frac{(q - 1)(\\mathcal{R} + x_i - 1)}{2}}</span> ,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  <span class="math">\\forall i</span>  let  $M_{i} = \\left\\{m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m\\in \\mathbb{Z}_{a},\\wedge h_{i}(-1)^{\\frac{(q - 1)(\\mathcal{R} + x_{i} - 1)}{2}} = \\left(\\frac{m}{K + x_{i}}\\right)\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall m_{ij}\\in M_i</span>  and  <span class="math">i\\in [1,n]</span>  solve the following system of congruences for  <span class="math">p</span>  using the Chinese-Renaender Theorem:  <span class="math">p\\equiv m_{ij}</span>  mod  <span class="math">K + x_{i}</span></li>

    </ol>

    <p class="text-gray-300">Output:  <span class="math">p</span></p>

    <p class="text-gray-300">(b) Programming the Legendre OPRF of Figure 5a by appropriate parameter selection. For ease of exposition, we assume that all the programmed points  <span class="math">x_{i}</span>  are primes.</p>

    <p class="text-gray-300">Figure 6: Legendre OPRF and the algorithm to extend it to be an OPPRF.</p>

    <p class="text-gray-300">Theorem 5.3 The protocol  <span class="math">\\Pi_{\\mathrm{Legendre}}^{OPRF}</span>  securely computes the functionality  <span class="math">\\mathcal{F}_{OPRF}</span>  in the  <span class="math">\\mathcal{F}_{\\mathrm{Prep}}</span> -hybrid model, if the SLS problem is hard.</p>

    <p class="text-gray-300">For brevity, we omit the proof since it follows the blueprint of the proof of  <span class="math">\\left[\\mathrm{GRR}^{+}16\\right.</span> , Theorem 2.]. We note that  <span class="math">\\Pi_{\\mathrm{Legendre}}^{OPRF}</span>  is only statistically correct as with probability  <span class="math">1 / p = \\operatorname*{Pr}(s^2 = 0)</span>  the output is necessarily zero. For perfect correctness, we need to use RandSquare' in the preprocessing phase to rule out  <span class="math">s^2 = 0</span>  the cost of which appears in the round complexity, resulting in expected constant (one) round. Our efficiency comparisons in Table 5.2 show that in terms of both message size and computational complexity, the Legendre OPRF is a promising candidate for a post-quantum OPRF since the underlying SLS problem is not known to be vulnerable to post-quantum attacks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">OPRF</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comm. Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comp. Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">Msg. Size</td>

            <td class="px-3 py-2 border-b border-gray-700">Concr. eff.</td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OPRF</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">0.77KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1H + 2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">ROM</td>

            <td class="px-3 py-2 border-b border-gray-700">1-more-RSA-inv</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[JKK14]</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">64 byte</td>

            <td class="px-3 py-2 border-b border-gray-700">1H + 2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">ROM/Standard</td>

            <td class="px-3 py-2 border-b border-gray-700">EC-DDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[KKRT16]†</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">2λ bits</td>

            <td class="px-3 py-2 border-b border-gray-700">256 bits</td>

            <td class="px-3 py-2 border-b border-gray-700">1H + 2XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">2H + 2XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">ROM</td>

            <td class="px-3 py-2 border-b border-gray-700">OT*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[ADDS19]</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λc) Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 1MB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λc) Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λc) Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">QROM</td>

            <td class="px-3 py-2 border-b border-gray-700">RLWE</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Figure 6a</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5λ G</td>

            <td class="px-3 py-2 border-b border-gray-700">13.44KB</td>

            <td class="px-3 py-2 border-b border-gray-700">17λ G</td>

            <td class="px-3 py-2 border-b border-gray-700">17λ G</td>

            <td class="px-3 py-2 border-b border-gray-700">ROM</td>

            <td class="px-3 py-2 border-b border-gray-700">SLS, OT*</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5.2: Comparing the online costs of various Oblivious PRF protocols. In the columns of communication and computation complexity  <span class="math">\\mathbb{G}</span>  denotes a group element or group operation, while H denotes a hashing operation. Concrete efficiency of obtaining  <span class="math">\\lambda</span>  pseudorandom bits with the corresponding OPRFs were computed with  <span class="math">\\lambda = 128</span>  bit-security. (Q)ROM stands for the (quantum) random oracle model. Note, that the PRF of [KKRT16] is only a relaxed PRF. RLWE is the abbreviation for the ring-learning with errors assumption. Oblivious transfer (OT) can be instantiated both with classic and post-quantum security. Non post-quantum secure assumptions are written in red, while assumptions written in green are secure even against quantum attackers.</p>

    <p class="text-gray-300">The notion of oblivious programmable PRF (OPPRF) was introduced by Kolesnikov et al.  <span class="math">\\left[\\mathrm{KMP}^{+}17\\right]</span> . A PRF is an OPPRF if it is in addition to being an OPRF, also allows the sender to program the output of the OPRF at certain evaluation points (see Figure 5a). Kolesnikov et al.  <span class="math">\\left[\\mathrm{KMP}^{+}17\\right]</span>  formulated three generic OPPRF constructions, that can turn any OPRF into an OPPRF. We follow the terminology of these generic constructions and introduce two algorithms that aims to turn an OPRF into an OPPRF:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OPPRF.KeyGen(1 <span class="math">\\lambda</span> ,  <span class="math">\\mathcal{P}</span> )  <span class="math">\\rightarrow</span>  (K, hint): Given a security parameter and set of programmed points  <span class="math">\\mathcal{P} = \\{(x_1, y_1), \\ldots, (x_n, y_n)\\}</span>  with distinct  <span class="math">x_i</span> -values, generates a PRF key  <span class="math">K</span>  and (public) auxiliary information hint.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OPPRF.Eval  <span class="math">\\left(F(K,x),\\mathrm{hint}\\right)\\rightarrow y</span>  : Using the hint turns the OPRF output into the OPPRF output  <span class="math">y</span></li>

    </ul>

    <p class="text-gray-300">We require from an OPPRF the following high-level security notions to hold (for the formal security definitions, the reader is referred to  <span class="math">\\mathrm{[KMP^{+}17]}</span> ):</p>

    <p class="text-gray-300"><span class="math">(x,y)\\in \\mathcal{P}\\wedge ((K,\\mathrm{hint})\\gets \\mathsf{OPPRF.KeyGen}(\\mathcal{P}))\\Rightarrow \\mathsf{OPPRF.Eval}\\big(F(K,x),\\mathrm{hint}\\big) = y.</span></p>

    <p class="text-gray-300"><span class="math">(n,t)</span> -security: No efficient adversary is able to distinguish the  <span class="math">n</span>  programmed points from non-programmed points given oracle access to the PRF using  <span class="math">t</span>  queries. Note that this definition implies that unprogrammed PRF outputs (i.e., those not set by the input to OPPRF.KeyGen) are pseudorandom.</p>

    <p class="text-gray-300">Programming the Legendre OPRF. We show how one can program efficiently the output of the Legendre PRF by carefully choosing the prime modulus, which defines our OPPRF.KeyGen algorithm. This strategy already highlights the strength of the resulting OPPRF: it does not require an explicit hint beyond the prime modulus that is a public parameter anyway. Moreover, the OPPRF.Eval algorithm can simply return the output of the Legendre OPRF.</p>

    <p class="text-gray-300">The naive way to program the Legendre PRF would be to generate primes randomly and hope that the PRF outputs match the desired values  <span class="math">y_{i}</span>  at the programmed points  <span class="math">x_{i}</span>  for a given key  <span class="math">K</span> . This certainly works for small number of programmed points, however, this naive PRF programming method incurs an exponential time-complexity in the number of programmed points. To circumvent the exponential time-complexity of the programming, we take a different approach, cf. Figure 6b. The goal of the algorithm is to find a prime  <span class="math">p</span> , such that</p>

    <div class="my-4 text-center"><span class="math-block">i \\in [ 0, n): y _ {i} = \\left(\\frac {K + x _ {i}}{p}\\right) = \\left(\\frac {p}{K + x _ {i}}\\right) (- 1) ^ {\\frac {(p - 1) (K + x _ {i} - 1)}{4}}.</span></div>

    <p class="text-gray-300">Without loss of generality, we search  <span class="math">p</span>  in the form  <span class="math">p \\equiv 1 \\mod 4</span> . Moreover, we assume that the programmed points  <span class="math">K + x_{i}</span>  are prime numbers. This assumption is natural and eases our exposition. This is because programming the PRF output at a composite  <span class="math">K + x_{i}</span>  is reducible to programming the PRF output at the prime factors of  <span class="math">K + x_{i}</span>  due to the multiplicativity of the Legendre symbol. For each  <span class="math">K + x_{i}</span>  the value  <span class="math">\\left(\\frac{p}{K + x_{i}}\\right)</span>  establishes possible residue classes for  <span class="math">p \\mod K + x_{i}</span> . The appropriate modulus  <span class="math">p</span>  can be obtained via the Chinese remainder theorem. Therefore, the "programmability" of the Legendre PRF is rather space-inefficient, since  <span class="math">p \\approx \\prod_{i=1}^{n} K + x_{i}</span> . Hence, the number of programmed points is somewhat limited with our algorithm. We note that the main ideas of this programming method were already proposed in a different context (secure comparison protocols) by Yu [Yu11]. In a similar fashion, one could generalize the approach of Figure 6b to power residue symbols, i.e., programming power residue symbol PRFs. Such generalization was shown recently by Cascudo et al. [CS20] who proposed as an open question to find concrete applications for their protocol. We note that their methods can be applied to program power residue symbol OPRFs.</p>

    <p class="text-gray-300">Hint size and batch OPPRFs. As our novel programming methods - specifically designed for the Legendre OPRF - minimize the necessary auxiliary information for the OPPRF evaluation, it outperforms all existing solutions in this metric. For a detailed comparison, we refer to Table 5.3. Finally, we note that [PSTY19] uses a so-called "Batch OPPRF" that - informally - invokes independent OPPRF instances with a total number of programmed points  <span class="math">\\sigma</span>  (the number of programmed points per instance may vary but has to remain hidden) and only uses a single hint with size linear in  <span class="math">\\sigma</span> . Since the hint size of the Legendre OPPRF is independent of the number of programmed points, it naturally fulfils the requirement of Batch OPPRFs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">OPPRF</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Programming complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hint size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Online communication complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraint on no. of programmed points</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">No. of evaluations</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lagrange interpol.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">(n + kn) G</td>

            <td class="px-3 py-2 border-b border-gray-700">space-efficiency</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Garbled Bloom Filter</td>

            <td class="px-3 py-2 border-b border-gray-700">O(nλBF)</td>

            <td class="px-3 py-2 border-b border-gray-700">nλBF</td>

            <td class="px-3 py-2 border-b border-gray-700">(60n + kn) G</td>

            <td class="px-3 py-2 border-b border-gray-700">space-efficiency</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Table-based</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">(n + kn) G</td>

            <td class="px-3 py-2 border-b border-gray-700">space-efficiency</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Legendre (Fig. 6b)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) G</td>

            <td class="px-3 py-2 border-b border-gray-700">depends on λ</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Legendre brute-force</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">time-efficiency</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5.3: Comparison of the generic OPPRF constructions of  <span class="math">\\left[\\mathrm{KMP}^{+}17\\right]</span>  (which can be based on an OPRF, e.g. that of [KKRT16]) and the Legendre OPRF that was shown to be programmable in Section 5.2.2. The number of programmed input positions is denoted as  <span class="math">n</span> ,  <span class="math">\\lambda_{\\mathsf{BF}}</span>  is the soundness parameter of the Bloom filter, and  <span class="math">k</span>  denotes the number of base-OTs, typically  <span class="math">k \\approx 4\\lambda</span> .</p>

    <p class="text-gray-300">6 Future Directions</p>

    <p class="text-gray-300">We perceive three main areas for future work. There is still quite some work to be done on the <em>provable security</em> part of the Legendre PRF. It would be fascinating to find new connections to other post-quantum secure cryptographic assumptions, e.g. LWE. For instance, note that the probability distribution of the coefficients of the quadratic terms in the induced MQ instance follows a discrete Gaussian distribution. Could one reframe the MQ instance as an LWE instance for a suitable change in the variables? Moreover, it would be fruitful to establish concrete and asymptotic lower bounds on the degree of regularity of the Legendre PRF’s MQ instances. That would pave the path for settling the provable security of this PRF. It is quintessential to improve on existing key-recovery attacks or find new, more performant cryptanalytic approaches. It would allow us to better estimate the <em>bit-security</em> of the Legendre PRF and other variants. We foresee many more <em>novel cryptographic applications</em> of the Legendre PRF due to its homomorphic properties and MPC-friendliness. For instance, it seems accessible to prove the existence of related-key secure PRFs or key-homomorphic PRFs from quadratic and power residue symbol PRFs.</p>

    <h2 id="sec-43" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We are grateful for the insightful conversations to Gergő Zábrádi. The first and the third author were supported by the Ministry of Innovation and Technology and the National Research, Development and Innovation Office within the Quantum Information National Laboratory of Hungary.</p>

    <h2 id="sec-44" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AABS^{+}20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. IACR Transactions on Symmetric Cryptology, pages 1–45, 2020.</li>

      <li>[ACG^{+}19] Martin R. Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, and Markus Schofnegger. Algebraic cryptanalysis of stark-friendly designs: Application to marvellous and mimic. In ASIACRYPT (3), volume 11923 of Lecture Notes in Computer Science, pages 371–397. Springer, 2019.</li>

      <li>[AD18] Tomer Ashur and Siemen Dhooghe. Marvellous: a stark-friendly family of cryptographic primitives. IACR Cryptol. ePrint Arch., 2018:1098, 2018.</li>

      <li>[ADDS19] Martin R Albrecht, Alex Davidson, Amit Deo, and Nigel P Smart. Round-optimal verifiable oblivious pseudorandom functions from ideal lattices. IACR Cryptol. ePrint Arch., 2019:1271, 2019.</li>

      <li>[ADDS21] Martin R. Albrecht, Alex Davidson, Amit Deo, and Nigel P. Smart. Round-optimal verifiable oblivious pseudorandom functions from ideal lattices. In Public Key Cryptography (2), volume 12711 of Lecture Notes in Computer Science, pages 261–289. Springer, 2021.</li>

      <li>[AGR^{+}16] Martin Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In International Conference on the Theory and Application of Cryptology and Information Security, pages 191–219. Springer, 2016.</li>

      <li>[ARS^{+}15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In EUROCRYPT (1), volume 9056 of Lecture Notes in Computer Science, pages 430–454. Springer, 2015.</li>

      <li>[BBUV20] Ward Beullens, Tim Beyne, Aleksei Udovenko, and Giuseppe Vitto. Cryptanalysis of the legendre prf and generalizations. IACR Transactions on Symmetric Cryptology, pages 313–330, 2020.</li>

      <li>[BD18] Zvika Brakerski and Nico Döttling. Two-message statistically sender-private OT from LWE. In TCC (2), volume 11240 of Lecture Notes in Computer Science, pages 370–390. Springer, 2018.</li>

      <li>[BDE^{+}21] Maxime Buser, Rafael Dowsley, Muhammed F. Esgin, Shabnam Kasra Kermanshahi, Veronika Kuchta, Joseph K. Liu, Raphael Phan, and Zhenfei Zhang. Post-quantum verifiable random function from symmetric primitives in pos blockchain. IACR Cryptol. ePrint Arch., page 302, 2021.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BdSG20] Ward Beullens and Cyprien Delpech de Saint Guilhem. Legroast: Efficient post-quantum signatures from the legendre prf. In International Conference on Post-Quantum Cryptography, pages 130–150. Springer, 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BFM19] Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications. In Providing Sound Foundations for Cryptography: On the Work of Shafi Goldwasser and Silvio Micali, pages 329–349. 2019.</li>

      <li>[BFSY05] Magali Bardet, Jean-Charles Faugere, Bruno Salvy, and Bo-Yin Yang. Asymptotic behaviour of the degree of regularity of semi-regular polynomial systems. In Proc. of MEGA, volume 5, 2005.</li>

      <li>[BGI^{+}17] Saikrishna Badrinarayanan, Sanjam Garg, Yuval Ishai, Amit Sahai, and Akshay Wadia. Two-message witness indistinguishability and secure computation in the plain model from new assumptions. In ASIACRYPT (3), volume 10626 of Lecture Notes in Computer Science, pages 275–303. Springer, 2017.</li>

      <li>[BGLS03] Dan Boneh, Craig Gentry, Ben Lynn, and Hovav Shacham. Aggregate and verifiably encrypted signatures from bilinear maps. In International Conference on the Theory and Applications of Cryptographic Techniques, pages 416–432. Springer, 2003.</li>

      <li>[BSBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch., 2018:46, 2018.</li>

      <li>[Buc65] Bruno Buchberger. Ein algorithms zum auffinden der basiselemente des restklassenringes nach einem nulldimensionalen polynomideal. PhD thesis, Universitat Insbruck, 1965.</li>

      <li>[CGS22] Nishanth Chandran, Divya Gupta, and Akash Shah. Circuit-psi with linear complexity via relaxed batch opprf. In 22nd Privacy Enhancing Technologies Symposium (PETS 2022), June 2022.</li>

      <li>[CJS14] Ran Canetti, Abhishek Jain, and Alessandra Scafuro. Practical UC security with a global random oracle. In CCS, pages 597–608. ACM, 2014.</li>

      <li>[CL07] Melissa Chase and Anna Lysyanskaya. Simulatable vrfs with applications to multi-theorem NIZK. In CRYPTO, volume 4622 of Lecture Notes in Computer Science, pages 303–322. Springer, 2007.</li>

      <li>[CLO13] David Cox, John Little, and Donal O’Shea. Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media, 2013.</li>

      <li>[CMZ14] Melissa Chase, Sarah Meiklejohn, and Greg Zaverucha. Algebraic macs and keyed-verification anonymous credentials. In CCS, pages 1205–1216. ACM, 2014.</li>

      <li>[CS20] Ignacio Cascudo and Reto Schnyder. A note on secure multiparty computation via higher residue symbol techniques. IACR Cryptol. ePrint Arch., 2020:183, 2020.</li>

      <li>[Dam88] Ivan Damgård. On the randomness of legendre and jacobi sequences. In CRYPTO, volume 403 of Lecture Notes in Computer Science, pages 163–172. Springer, 1988.</li>

      <li>[Dav31] Harold Davenport. On the distribution of quadratic residues (mod p). Journal of the London Mathematical Society, 1(1):49–54, 1931.</li>

      <li>[Déc07] Isabelle Déchene. Generalized Jacobians in cryptography. ProQuest, 2007.</li>

      <li>[DFHSW21] Alex Davidson, Armando Faz-Hernández, Nick Sullivan, and Christopher Wood. Oblivious pseudorandom functions (OPRFs) using prime-order groups, 2021. https://datatracker.ietf.org/doc/draft-irtf-cfrg-voprf/.</li>

      <li>[DGS^{+}18] Alex Davidson, Ian Goldberg, Nick Sullivan, George Tankersley, and Filippo Valsorda. Privacy pass: Bypassing internet challenges anonymously. Proc. Priv. Enhancing Technol., 2018(3):164–180, 2018.</li>

      <li>[DHS98] Cunsheng Ding, Tor Helleseth, and Weijuan Shan. On the linear complexity of legendre sequences. IEEE Trans. Inf. Theory, 44(3):1276–1278, 1998.</li>

    </ul>

    <p class="text-gray-300">[DKPW12] Yevgeniy Dodis, Eike Kiltz, Krzysztof Pietrzak, and Daniel Wichs. Message authentication, revisited. In EUROCRYPT, volume 7237 of Lecture Notes in Computer Science, pages 355–374. Springer, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DSZ15] Daniel Demmler, Thomas Schneider, and Michael Zohner. ABY - A framework for efficient mixed-protocol secure two-party computation. In NDSS. The Internet Society, 2015.</li>

      <li>[DY05] Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random function with short proofs and keys. In Public Key Cryptography, volume 3386 of Lecture Notes in Computer Science, pages 416–431. Springer, 2005.</li>

      <li>[EKS^{+}20] Muhammed F Esgin, Veronika Kuchta, Amin Sakzad, Ron Steinfeld, Zhenfei Zhang, Shifeng Sun, and Shumo Chu. Practical post-quantum few-time verifiable random function with applications to algorand. IACR Cryptol. ePrint Arch, 2020:1222, 2020.</li>

      <li>[FIPR05] Michael J. Freedman, Yuval Ishai, Benny Pinkas, and Omer Reingold. Keyword search and oblivious pseudorandom functions. In TCC, volume 3378 of Lecture Notes in Computer Science, pages 303–324. Springer, 2005.</li>

      <li>[FS21] Paul Frixons and André Schrottenloher. Quantum security of the legendre PRF. IACR Cryptol. ePrint Arch., page 149, 2021.</li>

      <li>[GHM^{+}17] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. Algorand: Scaling byzantine agreements for cryptocurrencies. In SOSP, pages 51–68. ACM, 2017.</li>

      <li>[GJ79] Michael R Garey and David S Johnson. Computers and intractability, volume 174. freeman San Francisco, 1979.</li>

      <li>[GKR^{+}21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. In USENIX Security Symposium, pages 519–535. USENIX Association, 2021.</li>

      <li>[GMS14] Katalin Gyarmati, Christian Mauduit, and András Sárközy. The cross-correlation measure for families of binary sequences., 2014.</li>

      <li>[GNP^{+}15] Sharon Goldberg, Moni Naor, Dimitrios Papadopoulos, Leonid Reyzin, Sachin Vasant, and Asaf Ziv. Nsec5: Provably preventing dnssec zone enumeration. In NDSS, 2015.</li>

      <li>[GNPR16] Sharon Goldberg, Moni Naor, Dimitrios Papadopoulos, and Leonid Reyzin. NSEC5 from elliptic curves: Provably preventing dnssec zone enumeration with shorter responses. Cryptology ePrint Archive, Report 2016/083, 2016. https://ia.cr/2016/083.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 305–326. Springer, 2016.</li>

      <li>[GRR^{+}16] Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P. Smart. Mpc-friendly symmetric key primitives. In CCS, pages 430–443. ACM, 2016.</li>

      <li>[Har13] Robin Hartshorne. Algebraic geometry, volume 52. Springer Science & Business Media, 2013.</li>

      <li>[HL10] Carmit Hazay and Yehuda Lindell. Efficient protocols for set intersection and pattern matching with security against malicious and covert adversaries. J. Cryptol., 23(3):422–456, 2010.</li>

      <li>[HLY12] Yun-Ju Huang, Feng-Hao Liu, and Bo-Yin Yang. Public-key cryptography from new multivariate quadratic assumptions. In International Workshop on Public Key Cryptography, pages 190–205. Springer, 2012.</li>

      <li>[IKO^{+}11] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, Manoj Prabhakaran, and Amit Sahai. Efficient non-interactive secure computation. In EUROCRYPT, volume 6632 of Lecture Notes in Computer Science, pages 406–425. Springer, 2011.</li>

      <li>[JK97] Thomas Jakobsen and Lars R Knudsen. The interpolation attack on block ciphers. In International Workshop on Fast Software Encryption, pages 28–40. Springer, 1997.</li>

      <li>[JKK14] Stanislaw Jarecki, Aggelos Kiayias, and Hugo Krawczyk. Round-optimal password-protected secret sharing and T-PAKE in the password-only model. In ASIACRYPT (2), volume 8874 of Lecture Notes in Computer Science, pages 233–253. Springer, 2014.</li>

    </ul>

    <p class="text-gray-300">[JKKX16] Stanislaw Jarecki, Aggelos Kiayias, Hugo Krawczyk, and Jiayu Xu. Highly-efficient and composable password-protected secret sharing (or: How to protect your bitcoin wallet online). In 2016 IEEE European Symposium on Security and Privacy (EuroS&P), pages 276–291. IEEE, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JKX18] Stanislaw Jarecki, Hugo Krawczyk, and Jiayu Xu. Opaque: an asymmetric pake protocol secure against pre-computation attacks. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 456–486. Springer, 2018.</li>

      <li>[JL09] Stanislaw Jarecki and Xiaomin Liu. Efficient oblivious pseudorandom function with applications to adaptive OT and secure computation of set intersection. In TCC, volume 5444 of Lecture Notes in Computer Science, pages 577–594. Springer, 2009.</li>

      <li>[KBR13] Sriram Keelveedhi, Mihir Bellare, and Thomas Ristenpart. Dupless: Server-aided encryption for deduplicated storage. In 22nd {USENIX} Security Symposium ({USENIX} Security 13), pages 179–194, 2013.</li>

      <li>[Kho19] Dmitry Khovratovich. Key recovery attacks on the legendre prfs within the birthday bound. Cryptology ePrint Archive, Report 2019/862, 2019.</li>

      <li>[KK20] Ferhat Karakoç and Alptekin Küpçü. Linear complexity private set intersection for secure two-party protocols. In CANS, volume 12579 of Lecture Notes in Computer Science, pages 409–429. Springer, 2020.</li>

      <li>[KKK20] Novak Kaluderovic, Thorsten Kleinjung, and Dusan Kostic. Improved key recovery on the legendre prf. IACR Cryptol. ePrint Arch., 2020:98, 2020.</li>

      <li>[KKRT16] Vladimir Kolesnikov, Ranjit Kumaresan, Mike Rosulek, and Ni Trieu. Efficient batched oblivious PRF with applications to private set intersection. In CCS, pages 818–829. ACM, 2016.</li>

      <li>[KLS^{+}17] Ágnes Kiss, Jian Liu, Thomas Schneider, N. Asokan, and Benny Pinkas. Private set intersection for unequal set sizes with mobile applications. Proc. Priv. Enhancing Technol., 2017(4):177–197, 2017.</li>

      <li>[KMP^{+}17] Vladimir Kolesnikov, Naor Matania, Benny Pinkas, Mike Rosulek, and Ni Trieu. Practical multi-party private set intersection from symmetric-key techniques. In CCS, pages 1257–1272. ACM, 2017.</li>

      <li>[KO04] Jonathan Katz and Rafail Ostrovsky. Round-optimal secure two-party computation. In CRYPTO, volume 3152 of Lecture Notes in Computer Science, pages 335–354. Springer, 2004.</li>

      <li>[KS99] Aviad Kipnis and Adi Shamir. Cryptanalysis of the hfe public key cryptosystem by relinearization. In Annual International Cryptology Conference, pages 19–30. Springer, 1999.</li>

      <li>[LBM20] Bei Liang, Gustavo Banegas, and Aikaterini Mitrokotsa. Statically aggregate verifiable random functions and application to e-lottery. Cryptography, 4(4):37, 2020.</li>

      <li>[Lem03] Franz Lemmermeyer. Conics-a poor man’s elliptic curves. arXiv preprint math/0311306, 2003.</li>

      <li>[LP19] Chaoyun Li and Bart Preneel. Improved interpolation attacks on cryptographic primitives of low algebraic degree. In International Conference on Selected Areas in Cryptography, pages 171–193. Springer, 2019.</li>

      <li>[MR17] Payman Mohassel and Mike Rosulek. Non-interactive secure 2pc in the offline/online and batch settings. In EUROCRYPT (3), volume 10212 of Lecture Notes in Computer Science, pages 425–455, 2017.</li>

      <li>[MRV99] Silvio Micali, Michael Rabin, and Salil Vadhan. Verifiable random functions. In 40th annual symposium on foundations of computer science (cat. No. 99CB37039), pages 120–130. IEEE, 1999.</li>

      <li>[MS97] Christian Mauduit and András Sárközy. On finite pseudorandom binary sequences i: Measure of pseudorandomness, the legendre symbol. Acta Arithmetica, 82(4):365–377, 1997.</li>

      <li>[NR97] Moni Naor and Omer Reingold. Number-theoretic constructions of efficient pseudo-random functions. In FOCS, pages 458–467. IEEE Computer Society, 1997.</li>

    </ul>

    <p class="text-gray-300">[Osp16] Daniel Esteban Escudero Ospina. Groebner bases and applications to the security of multivariate public key cryptosystems. PhD thesis, Ph. D. dissertation, Escuela de Matemáticas, Univ. Nacional de Colombia …, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Per92] Rene Peralta. On the distribution of quadratic residues and nonresidues modulo a prime number. Mathematics of Computation, 58(197):433–440, 1992.</li>

      <li>[PPST17] Ray Perlner, Albrecht Petzoldt, and Daniel Smith-Tone. Total break of the srp encryption scheme. In International Conference on Selected Areas in Cryptography, pages 355–373. Springer, 2017.</li>

      <li>[PSTY19] Benny Pinkas, Thomas Schneider, Oleksandr Tkachenko, and Avishay Yanai. Efficient circuit-based PSI with linear communication. In EUROCRYPT (3), volume 11478 of Lecture Notes in Computer Science, pages 122–153. Springer, 2019.</li>

      <li>[PWH^{+}17] Dimitrios Papadopoulos, Duane Wessels, Shumon Huque, Moni Naor, Jan Včelák, Leonid Reyzin, and Sharon Goldberg. Making nsec5 practical for dnssec. Cryptology ePrintArchive, Report 2017/099, 2017.</li>

      <li>[RS04] Alexander Russell and Igor E Shparlinski. Classical and quantum function reconstruction via character evaluation. Journal of Complexity, 20(2-3):404–422, 2004.</li>

      <li>[SKI04] M Sugita, M Kawazoe, and H Imai. Relation between xl algorithm and gröbner bases algorithms, iacr eprint server, 2004.</li>

      <li>[Tót07] Viktória Tóth. Collision and avalanche effect in families of pseudorandom binary sequences. Periodica Mathematica Hungarica, 55(2):185–196, 2007.</li>

      <li>[Ull12] Ehsan Ullah. New techniques for polynomial system solving. 2012.</li>

      <li>[vDHI06] Wim van Dam, Sean Hallgren, and Lawrence Ip. Quantum algorithms for some hidden shift problems. SIAM J. Comput., 36(3):763–778, 2006.</li>

      <li>[Vin16] Ivan Matveevich Vinogradov. Elements of number theory. Courier Dover Publications, 2016.</li>

      <li>[Yu11] Ching-Hua Yu. Sign modules in secure arithmetic circuits. IACR Cryptol. ePrint Arch., 2011:539, 2011.</li>

    </ul>

    <h2 id="sec-45" class="text-2xl font-bold">Appendix A Background</h2>

    <p class="text-gray-300">For completeness, we define possible generalisations of the Legendre PRF.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition A.1 (Higher-degree Legendre PRF)</h6>

    <p class="text-gray-300">In case of the Higher-degree Legendre PRF with a secret polynomial <span class="math">f\\in_{R}\\mathbb{F}_{p}[x]</span>, let <span class="math">\\{a\\}_{f}</span> denote the following sequence:</p>

    <p class="text-gray-300"><span class="math">\\{a\\}_{f}:=\\bigg{(}\\frac{f(0)}{p}\\bigg{)},\\bigg{(}\\frac{f(1)}{p}\\bigg{)},\\ldots,\\bigg{(}\\frac{f(a-1)}{p}\\bigg{)}.</span></p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition A.2 (<span class="math">\\prime</span>th power residue function)</h6>

    <p class="text-gray-300">Let <span class="math">p\\equiv 1\\mod r</span> and <span class="math">g\\in\\mathbb{F}_{p}^{\\times}</span> a generator. The <span class="math">r</span>th power residue function <span class="math">l^{(r)}:\\mathbb{F}_{p}\\rightarrow\\mathbb{Z}_{r}</span> is defined as</p>

    <p class="text-gray-300">\\[ l^{(r)}(a):=\\begin{cases}k,&\\text{if}\\quad a\\not\\equiv 0\\mod p\\wedge a/g^{k}\\text{is an <span class="math">r</span>th power}\\mod p\\\\ 0,&\\text{if}\\quad a\\equiv 0\\mod p.\\end{cases} \\]</p>

    <p class="text-gray-300">Similarly to Definitions 2.1 and A.1, we might introduce the power residue PRF and its higher-degree variants, relying on the power residue function. Once again, we note that our results and observations can be generalized to the higher-degree and other variants of the Legendre PRF.</p>

    <p class="text-gray-300">B Proofs from Section 3</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma B.1</h6>

    <p class="text-gray-300"><span class="math">I</span> is a regular ideal.</p>

    <p class="text-gray-300">Proof: Let <span class="math">I=\\langle f_{1},\\ldots,f_{m}\\rangle</span> be the ideal induced by the Legendre PRF, and we assume that <span class="math">f_{i}</span> forms a reduced Gröbner basis. For a homogeneous sequence of polynomials <span class="math">(f_{1},\\ldots,f_{m})</span> being regular, we need to show that if for all <span class="math">i\\in[1,m]</span> and <span class="math">g</span> such that <span class="math">gf_{i}\\in\\langle f_{1},\\ldots,f_{i-1}\\rangle</span>, then <span class="math">g\\in\\langle f_{1},\\ldots,f_{i-1}\\rangle</span>. An affine sequence of polynomials <span class="math">(f_{1},\\ldots,f_{m})</span> is regular by definition, if the homogeneous sequence <span class="math">(f_{1}^{h},\\ldots,f_{m}^{h})</span> is regular, where <span class="math">f_{i}^{h}</span> is the homogeneous part of <span class="math">f_{i}</span> of highest degree with respect to the (graded) lexicographic monomial ordering. In our case <span class="math">(f_{1}^{h},f_{2}^{h},\\ldots,f_{m}^{h})=(x_{1}^{2},x_{2}^{2},\\ldots,x_{m}^{2})</span>.</p>

    <p class="text-gray-300">Since <span class="math">f_{i}^{h}=x_{i}^{2}</span>, in our case for every <span class="math">i</span>, therefore the ideal <span class="math">I_{i-1}:=\\langle f_{1}^{h},\\ldots,f_{i-1}^{h}\\rangle</span> is a monomial ideal. If <span class="math">gf_{i}^{h}\\in I_{i-1}</span>, then <span class="math">gf_{i}^{h}</span> is divisible by a generator of <span class="math">I_{i-1}</span>, since <span class="math">I_{i-1}</span> is a monomial ideal <em>[x10]</em>. Since <span class="math">(f_{i},f_{j})=1</span>, for every <span class="math">j\\in[1,i-1]</span>, thus it is necessary that <span class="math">g</span> is divisible by some <span class="math">f_{j}^{h}=x_{j}^{2}\\in I_{i-1}</span>, for <span class="math">j\\leq i-1</span>. Namely <span class="math">g=x_{j}^{2}g^{\\prime}\\in I_{i-1}</span>, for some polynomial <span class="math">g^{\\prime}</span>. This completes the proof.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma B.2</h6>

    <p class="text-gray-300"><span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> is a semi-regular ideal, if the conditions of Theorem 3.3 are met.</p>

    <p class="text-gray-300">Proof: The proof’s blueprint is the same as that of Lemma 3.2. We consider the generating set for <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span> provided by the Gröbner basis, i.e., <span class="math">I_{\\mathsf{F}\\mathsf{E}}=(f_{1},\\ldots,f_{m})</span>. By definition, a homogeneous sequence of polynomials <span class="math">(f_{1},\\ldots,f_{m})</span> is semi-regular if for all <span class="math">i=1,\\ldots,m</span> and <span class="math">g</span> such that <span class="math">gf_{i}\\in\\langle f_{1},\\ldots,f_{i-1}\\rangle\\wedge deg(gf_{i})&lt;d_{reg}</span> then <span class="math">g</span> is also in <span class="math">\\langle f_{1},\\ldots,f_{i-1}\\rangle</span>. An affine sequence of polynomials <span class="math">(f_{1},\\ldots,f_{m})</span> is semi-regular if the sequence <span class="math">(f_{1}^{h},\\ldots,f_{m}^{h})</span> is semi-regular, where <span class="math">f_{i}^{h}</span> is the homogeneous part of <span class="math">f_{i}</span> of highest degree. In our case <span class="math">(f_{1}^{h},\\ldots,f_{m}^{h}))=(x_{1}^{2},\\ldots,x_{m}^{2})</span>. Previously in the proof of Lemma 3.2, we saw why <span class="math">(x_{1}^{2},\\ldots,x_{m}^{2})</span> forms a regular ideal.</p>

    <h2 id="sec-50" class="text-2xl font-bold">Appendix C Adding More Polynomials to the Ideal of the PRF</h2>

    <p class="text-gray-300">As we have seen in Section 3.3, the Legendre key-recovery attack is equivalent to solving an overtetermined MQ instance. However, when <span class="math">p\\equiv 3\\mod 4</span> or <span class="math">p\\equiv 5\\mod 8</span>, we might decrease the complexity of solving the resulting MQ instance by adding new equations. Observe that in these cases, we can express the modular square roots as follows:</p>

    <p class="text-gray-300">\\[ \\mathsf{sqrt}_{p}(x):y=\\begin{cases}\\pm x^{\\frac{p+1}{4}}\\mod p,\\text{ if }p\\equiv 3\\mod 4\\\\ \\pm x(2x)^{\\frac{p-5}{8}}(4x^{\\frac{p-1}{4}}-1)\\mod p,\\text{ if }p\\equiv 5\\mod 8.\\end{cases} \\] (11)</p>

    <p class="text-gray-300">If <span class="math">p\\equiv 1\\mod 8</span>, it is not possible to express easily the <span class="math">\\mathsf{sqrt}_{p}(\\cdot)</span> algorithm as a polynomial function, since in that case the root-finding Tonelli-Shank algorithm is a probabilistic algorithm. Nevertheless, we can obtain <span class="math">\\mathcal{O}(\\log^{2}p)</span> new polynomials in the other cases, one for each quadratic term <span class="math">x_{i}x_{j}</span>:</p>

    <p class="text-gray-300"><span class="math">x_{i}x_{j}=\\mathsf{sqrt}_{p}(x_{i}^{2}x_{j}^{2}).</span> (12)</p>

    <p class="text-gray-300">Similarly, we can add new polynomials to the system involving the linear terms of the unknowns for every <span class="math">i\\neq j</span>,</p>

    <p class="text-gray-300"><span class="math">x_{i}=\\mathsf{sqrt}_{p}(r^{L_{0}(x_{i})-L_{0}(x_{j})}(x_{j}^{2}-r^{L_{0}(x_{j})}(j-i))).</span> (13)</p>

    <p class="text-gray-300">All polynomials in Equations 12 and 13 have degree <span class="math">\\approx p</span>. Therefore, the addition of each of those polynomials incur the inclusion of <span class="math">\\approx\\log p</span> new quadratic equations in <span class="math">\\approx\\log p</span> new variables in order to break down the almost full degree polynomials to quadratic polynomials. All in all, we end up with an equation system in <span class="math">n</span> variables and <span class="math">m=n+k</span> equations, where <span class="math">m,n\\in\\mathcal{O}(\\log^{3}p)</span> and <span class="math">k\\approx\\log^{2}p</span>. We leave it as future work to analyze the independence of the newly introduced polynomials of Equation 12 and 13 from the polynomials of the ideal <span class="math">I_{\\mathsf{F}\\mathsf{E}}</span>. We suspect that adding these high-degree polynomials to the ideal does not significantly speed up the Gröbner basis computation. Hence, these new polynomials might not have cryptanalytic relevance.</p>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix D Group Structure of the Solutions of a Legendre PRF key-recovery attack</h2>

    <p class="text-gray-300">In Section 4.2, we showed that if there exists a probabilistic polynomial-time algorithm that breaks the SLS problem, then it could be used to find solutions of high order algebraic curves over <span class="math">\\mathbb{F}_{p}</span>. This is essentially an equivalent restatement of viewing the Legendre PRF as an MQ instance.</p>

    <p class="text-gray-300">Moreover, the resulting algebraic curves have a genus greater than <span class="math">1</span>, implying that the solutions lying on the curve lack an Abelian group structure. However, in the case of shorter sequences, e.g. Legendre sequences of length three, all the points that result in a specific Legendre symbol sequence of length three lie on a sequence-specific non-singular elliptic curve. In the sequel, we show how to obtain the Legendre-sequence specific elliptic curve equation by elementary methods.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">D.1 The Case of Consecutive Legendre symbol triplets</h3>

    <p class="text-gray-300">Let us suppose that one wants to generate key candidates <span class="math">K^{{}^{\\prime}}</span>, whose subsequent Legendre symbols match the first three symbols of a sequence, i.e. <span class="math">\\left(\\left(\\frac{K^{{}^{\\prime}}}{p}\\right),\\left(\\frac{K^{{}^{\\prime}}+1}{p}\\right),\\left(\\frac{K^{{}^{\\prime}}+2}{p}\\right)\\right)=(b_{0},b_{1},b_{2})</span>. Hereby, we show that such key candidates can be obtained as solutions of an elliptic curve over <span class="math">\\mathbb{F}_{p}</span>. One might generalise this approach to potentially speed up key-recovery attacks against the Legendre PRF and reduce its security to finding rational points on higher order algebraic curves over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">For the sake of concreteness, let us assume that <span class="math">(b_{0},b_{1},b_{2})=(1,1,1)</span>. Similar techniques apply for other bit-sequence patterns. Put it differently, the shifted Legendre sequence starts with <span class="math">3</span> quadratic residues. Let us denote the corresponding square roots as <span class="math">a,b,c\\mod p</span>. Therefore we wish to solve the following equations:</p>

    <p class="text-gray-300"><span class="math">c^{2}-b^{2}=b^{2}-a^{2}=1</span></p>

    <p class="text-gray-300">We introduce the following notation: <span class="math">s:=b-a</span>, <span class="math">\\frac{1}{s}:=b+a</span> and <span class="math">\\frac{c-b}{b-a}=\\lambda</span>. We have that <span class="math">2b=s+\\frac{1}{s}</span> and <span class="math">2b=\\frac{1}{s\\lambda}-s\\lambda</span>. This implies the following:</p>

    <p class="text-gray-300"><span class="math">s+\\frac{1}{s}=\\frac{1}{s\\lambda}-s\\lambda</span> <span class="math">s^{2}\\lambda+\\lambda=1-s^{2}\\lambda^{2}</span> <span class="math">s^{2}=\\frac{1-\\lambda}{\\lambda^{2}+\\lambda}</span> <span class="math">s^{2}(1+\\lambda)^{2}\\lambda^{2}=(1-\\lambda)(1+\\lambda)\\lambda</span> (14)</p>

    <p class="text-gray-300">By denoting the left hand side of Equation 14. as <span class="math">t^{2}</span>, we finally obtain the following nonsingular elliptic curve of genus <span class="math">1</span>:</p>

    <p class="text-gray-300"><span class="math">t^{2}=\\lambda^{3}-\\lambda.</span></p>

    <p class="text-gray-300">4-symbol case (sketch): Now, let us assume we have an additional <span class="math">b_{3}=1</span>. Let <span class="math">d</span> be the square-root of <span class="math">K+3</span>. Furhtermore, let <span class="math">r:=c-b</span> and <span class="math">\\mu:=\\frac{d-c}{c-b}</span>. Given Equation 14, we also have that</p>

    <p class="text-gray-300"><span class="math">r^{2}(1+\\mu)^{2}\\mu^{2}=(1-\\mu)(1+\\mu)\\mu</span> (15)</p>

    <p class="text-gray-300">Since, <span class="math">r=s\\lambda</span> we can squeeze Equation 14 and Equation 15 into a single two-variable quartic equation:</p>

    <p class="text-gray-300"><span class="math">\\lambda^{2}\\mu^{2}+\\lambda^{2}\\mu-\\lambda\\mu^{2}-\\lambda\\mu+\\lambda-\\mu-\\lambda\\mu+1=0</span></p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">D.2 An Alternative View</h3>

    <p class="text-gray-300">We view the resulting equation system globally and assess the probability distribution of each coefficient to appear in the MQ instance. Adjacent pairs of Legendre symbols are asymptotically equi-distributed <em>[x23]</em>. Therefore we can easily describe the discrete probability distribution of the coefficients in the induced equation system. Let <span class="math">X_{q}^{(i,j)},X_{l}^{(i)},X_{c}</span> be the random discrete variables corresponding to the <span class="math">i</span>th unknown’s quadratic, linear and constant terms. For the equation system’s coefficients, we have the following discrete probability distributions given Equations 1, 2 and 3. For the constant terms, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{c}=1]=\\Pr[X_{c}=r]=\\frac{1}{2}.</span> (16)</p>

    <p class="text-gray-300">Every linear term is zero, namely,</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{l}^{(i)}=0]=1,\\forall i\\in[1,n].</span> (17)</p>

    <p class="text-gray-300">Finally, the quadratic terms’ coefficients have the following probability distribution. The <span class="math">\\Pr[X_{q}^{(i,j)}=0]=1</span>, if <span class="math">i\\neq j,</span>. Otherwise, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{q}^{(i,i)}=1]=\\frac{1}{n},\\quad\\Pr[X_{q}^{(i,i)}=-1]=\\frac{1}{2n},</span> (18) <span class="math">\\Pr[X_{q}^{(i,i)}=-r]=\\Pr[X_{q}^{(i,i)}=-\\,r^{-1}]=\\frac{1}{4n},\\quad\\Pr[X_{q}^{(i,i)}=0]=1-\\frac{2}{n}.</span></p>

    <p class="text-gray-300">We remark that the discrete probability distribution of the quadratic terms is reminiscent of a discrete normal Gaussian distribution with average <span class="math">0</span>, whenever <span class="math">n</span> goes to infinity. If the linear terms, cf. Equation 17, would follow a uniformly random distribution after a suitable change in the variables, the resulting MQ instance could be seen asymptotically as a learning with errors (LWE) instance. We leave this as an interesting future direction to investigate further connections to other post-quantum secure assumptions.</p>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix E Algebraic Cryptanalysis of the Legendre PRF</h2>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">E.1 Computing the Q-rank of the Legendre PRF</h3>

    <p class="text-gray-300">The Q-rank of a MQ cryptosystem plays a crucial role in cryptanalysis. Every multivariate quadratic equation system <span class="math">\\mathbf{f}</span> can be lifted to a quadratic form <span class="math">\\mathcal{Q}</span> in an extension field. Let <span class="math">\\mathbb{E}</span> denote an extension field over <span class="math">\\mathbb{F}_{p}</span>. Informally, Q-rank is the rank of the quadratic form <span class="math">\\mathcal{Q}</span> as a matrix over the field <span class="math">\\mathbb{E}</span>. Low Q-rank is detrimental, since it facilitates successful cryptanalysis (key-recovery, decryption etc.) <em>[x13, x15]</em>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition E.1 (Q-rank)</h6>

    <p class="text-gray-300">The Q-rank of a multivariate quadratic map <span class="math">\\mathbf{f}:\\mathbb{F}_{q}^{n}\\rightarrow\\mathbb{F}_{q}^{n}</span> over the finite field <span class="math">\\mathbb{F}_{q}</span> is the rank of the quadratic form <span class="math">\\mathcal{Q}</span> on the extension field <span class="math">\\mathbb{E}[X_{0},\\ldots,X_{n-1}]</span> defined by <span class="math">Q(X_{0},\\ldots,X_{n-1})=\\phi\\circ\\mathbf{f}\\circ\\phi^{-1}(X,X^{q},\\ldots,X^{q^{n-1}})</span>, under the identification <span class="math">\\phi</span>: <span class="math">X_{0}=X,X_{1}=X^{q},\\ldots,X_{n-1}=X^{q^{n-1}}</span>.</p>

    <p class="text-gray-300">We compute now the Q-rank (cf. Definition E.1) of the Legendre PRF equation system <em>[x14]</em>. We rewrite each generator polynomial <span class="math">f_{i}</span> in the ideal <span class="math">I=\\langle f_{1},\\ldots,f_{m}\\rangle</span> induced by the Legendre PRF, as folllows:</p>

    <p class="text-gray-300"><span class="math">f_{i}(x_{1},\\ldots,x_{n})=\\sum_{i,j=1}^{n}a_{ij}x_{i}x_{j}+\\sum_{i=1}^{n}b_{i}x_{i}+c=\\mathbf{x}^{T}A_{i}\\mathbf{x}+B_{i}\\mathbf{x}+c,</span> (19)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{x}=[x_{1},\\ldots,x_{n}]^{T},A_{i}\\in\\mathcal{M}_{n\\times n}(\\mathbb{F})</span> is the matrix <span class="math">[a_{ij}]_{ij}</span> and <span class="math">B_{i}\\in\\mathcal{M}_{1\\times n}(\\mathbb{F})</span> is the matrix <span class="math">[b_{i}]_{1i}</span>. We note, that in the case of the Legendre PRF, <span class="math">B_{i}=\\mathbf{0}</span>. Each polynomial <span class="math">f_{i}</span> can be represented in the extension field, in the following form:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{i}(X)=\\sum_{i,j=1}^{n}\\alpha_{ij}X^{q^{i-1}+q^{j-1}}+\\sum_{i=1}^{n}\\beta_{i}X^{q^{i-1}}+\\gamma=\\mathbf{X}^{T}M_{i}\\mathbf{X}+N_{i}\\mathbf{X}+\\gamma,</span> (20)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{X}=[X^{q^{0}},\\ldots,X^{q^{n-1}}]^{T},M_{i}\\in\\mathcal{M}_{n\\times n}(\\mathbb{E})</span> is the matrix <span class="math">[\\alpha_{ij}]_{ij}</span> and <span class="math">B\\in\\mathcal{M}_{1\\times n}(\\mathbb{F})</span> is the matrix <span class="math">[\\beta_{i}]_{1i}</span>. It is well-known that a quadratic polynomial equation system <span class="math">F</span> defined by the generating polynomials <span class="math">f_{i}</span> of <span class="math">I</span>, can be lifted to the extension field by</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Lft}(F)(X)=\\phi^{-1}\\circ\\mathcal{F}\\circ\\phi(X)=\\mathbf{X}^{T}M\\mathbf{X}+N\\mathbf{X}+\\gamma,</span> (21)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{x}=\\phi(X)</span>. Our goal is to establish the rank of the matrix <span class="math">M\\in\\mathcal{M}_{n\\times n}(\\mathbb{E})</span>. We start off by defining <span class="math">\\mathbf{X}=\\Delta\\cdot\\phi(X)</span>, where <span class="math">\\Delta</span> is the following invertible matrix,</p>

    <p class="text-gray-300">\\[ \\Delta=\\begin{bmatrix}y^{0}&y^{1}&\\ldots&y^{n-2}&y^{n-1}\\\\ (y^{0})^{q^{1}}&(y^{1})^{q^{1}}&\\ldots&(y^{n-2})^{q^{1}}&(y^{n-1})^{q^{1}}\\\\ (y^{0})^{q^{2}}&(y^{1})^{q^{2}}&\\ldots&(y^{n-2})^{q^{2}}&(y^{n-1})^{q^{2}}\\\\ \\vdots&\\vdots&\\ddots&\\vdots&\\vdots\\\\ (y^{0})^{q^{n-1}}&(y^{1})^{q^{n-1}}&\\ldots&(y^{n-2})^{q^{n-1}}&(y^{n-1})^{q^{n-1}}\\end{bmatrix} \\] (22)</p>

    <p class="text-gray-300">Equipped with all this, we can now define <span class="math">M\\in\\mathcal{M}_{n\\times n}(\\mathbb{F}),N\\in\\mathcal{M}_{1\\times n}(\\mathbb{F})</span> and <span class="math">\\gamma\\in\\mathbb{E}</span> from the lifting Equation 21. We define <span class="math">\\gamma=c_{1}+c_{2}y+\\cdots+c_{n}y^{n-1}</span> and the matrices as,</p>

    <p class="text-gray-300"><span class="math">M=(\\Delta^{T})^{-1}\\bigg{(}\\sum_{i=1}^{n}y^{i-1}A_{i}\\bigg{)}\\Delta^{-1}\\qquad\\text{and}\\qquad N=\\bigg{(}\\sum_{i=1}^{n}y^{i-1}B_{i}\\bigg{)}\\Delta^{-1}.</span> (23)</p>

    <p class="text-gray-300">Note that in case of the Legendre PRF MQ instance, <span class="math">N=0</span>, since <span class="math">B_{i}=\\mathbf{0}</span> for all <span class="math">i</span>. The second term in matrix <span class="math">M</span>, <span class="math">\\sum y^{i-1}A_{i}</span> is a double diagonal non-singular matrix. Hence, <span class="math">M</span> has full rank, since it is the product of non-singular matrices.</p>

    <p class="text-gray-300">E.2 Group Structure of the Legendre PRF MQ Instances’ Solutions</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma E.2</h6>

    <p class="text-gray-300"><span class="math">P_{n}(N)=2^{(n-1)}\\cdot N-(n-3)\\cdot 2^{(n-2)}</span>.</p>

    <p class="text-gray-300">Proof: We first determine the linear coefficient by considering the difference polynomial <span class="math">Q_{n}(N)=P_{n}(N+1)-P_{n}(N)</span>, which is a constant by the linearity of <span class="math">P_{n}</span>. Using the inclusion-exclusion argument again, we see that <span class="math">Q_{n}(N)</span> is also a Hilbert-polynomial. To obtain an ideal with <span class="math">Q_{n}(N)</span> as its Hilbert polynomial, take an <span class="math">(n-1)</span>-variable ring and <span class="math">n-1</span> polynomials, each of which is quadratic in a distinct single variable. The ideal generated by these polynomials is zero-dimensional, and therefore has a constant Hilbert polynomial whose value is the size of the corresponding variety, i.e., <span class="math">2^{n-1}</span>. For the constant term, first note that for any real value of <span class="math">x</span>, <span class="math">\\binom{x}{n}=(-1)^{n}\\binom{-x+n-1}{n}</span>. Therefore, by substituting <span class="math">N=(n-3)/2</span> into (8), the terms <span class="math">g_{n}(N-2k)\\binom{n-1}{k}</span> and <span class="math">g_{n}(N-2(n-k))\\binom{n-1}{n-k}</span> cancel, and the middle term (for odd <span class="math">n</span>) is <span class="math">0</span>, hence <span class="math">P_{n}(n-3/2)=0</span>, which gives the constant term.</p>

    <h2 id="sec-58" class="text-2xl font-bold">Appendix F Proof of Theorem 5.2</h2>

    <p class="text-gray-300">Next, we sketch the security proof of the Legendre VRF.</p>

    <p class="text-gray-300">Proof: To prove the theorem, we show that the requirements of Definition 5.1 are fulfilled by the Legendre VRF. <em>Correctness</em> directly follows from the prefect correctness of NIZK. To see that <em>pseudorandomness</em> holds, notice that game <span class="math">\\mathcal{G}^{\\mathcal{VRF}}_{\\mathcal{A}}(1^{\\lambda})</span> is indistinguishable from the pseudorandomness game for PRFs as long as the honestly evaluated <span class="math">\\pi</span> in the answers for <span class="math">\\mathcal{A}</span>’s evaluation queries can be substituted by simulated <span class="math">\\pi</span>. Indeed, the game knows <span class="math">\\tau,\\mathcal{R},\\phi</span> for such simulation. Since the perfect zero-knowledge property of NIZK guarantees this, the proposed VRF is pseudorandom if the Legendre PRF is pseudorandom, i.e., assuming the hardness of the SLS problem.</p>

    <p class="text-gray-300">We prove <em>trusted computational unique provability</em> indirectly. Therefore, let us assume that there exists a PPT <span class="math">\\mathcal{A}</span> for which the probability in equation (10) is greater than <span class="math">\\mathsf{negl}(\\lambda)</span>. As the values <span class="math">\\mathsf{vk},X,Y</span> determine <span class="math">\\phi</span>, it follows that for the above <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ccc}\\mathsf{NIZK.Vfy}(\\mathcal{R},\\sigma,\\phi_{0},\\pi_{0})&=&\\mathsf{pp}_{\\mathsf{vrf}}\\leftarrow{}_{\\mathsf{s}}\\mathsf{VRF.PPGen}(1^{\\lambda})\\\\ \\mathsf{NIZK.Vfy}(\\mathcal{R},\\sigma,\\phi_{1},\\pi_{1})&=1&\\mathsf{(vk},X,Y_{0},Y_{1},\\pi_{0},\\pi_{1})\\leftarrow{}_{\\mathsf{s}}\\mathcal{A}(\\mathsf{pp}_{\\mathsf{vrf}})\\\\ Y_{0}\\neq Y_{1}\\end{array}\\right]>\\mathsf{negl}(\\lambda)\\,. \\]</p>

    <p class="text-gray-300">This only holds if either <span class="math">\\mathsf{NIZK.Vfy}</span> accepts false statements with non-negligible probability or both statements are true. As the first option would contradict with the assumed computational soundness of NIZK, both statements has to be true, i.e., <span class="math">(\\phi_{0},\\mathsf{w}_{0}),(\\phi_{1},\\mathsf{w}_{1})\\in\\mathcal{R}</span>. Two Legendre sequences of the same length are equal if their starting points are equal, so <span class="math">Y_{0}\\neq Y_{1}\\implies K_{0}+X\\lambda\\neq K_{1}+X\\lambda\\implies\\mathsf{sk}_{0}=K_{0}\\neq K_{1}=\\mathsf{sk}_{1}</span>. However, both statements <span class="math">\\phi_{0}</span> and <span class="math">\\phi_{1}</span> ensures that <span class="math">\\{c\\cdot\\log p\\}_{K_{0}}=\\{c\\cdot\\log p\\}_{K_{1}}=\\mathsf{vk}</span> implying that the values of these different Legendre sequences must collide with non-negligible probability. This is contradiction since we know from <em>[x13]</em> that the probability of such collision is <span class="math">1/2^{c\\log p}=1/2^{c\\lambda}&lt;\\mathsf{negl}(\\lambda)</span>.</p>

    <h2 id="sec-59" class="text-2xl font-bold">Appendix G The Legendre Verifiable OPRF</h2>

    <p class="text-gray-300">In Section 5.2, we built an OPRF relying on semi-honest 2PC that clearly cannot prevent the participants from deviating the protocol. What is even more problematic in practice is that sometimes the server is supposed to behave consistently in multiple OPRF evaluations, namely, it is assumed to use the same key. To check this on the receiver side – without obtaining information about the key – active security alone is not enough, but in an initialization phase the sender has to commit to the key(s) it wishes to use. Such commitments can then be published (as a “public key”) to enable the receiver the verification of whether distinct OPRF evaluations happened under the same or different keys. OPRF protocols that guarantee such verifiability are called verifiable OPRFs (VOPRFs). In Figure 7(a), we recall the ideal functionality as defined in <em>[x1]</em>, for the precise security definition we also refer to this work. We note that different formalizations of VOPRF exist, e.g. <em>[x16]</em> considered in the concurrent setting when defining the universal composable VOPRF.</p>

    <p class="text-gray-300">Turning our attention to the realization, it seems obvious that special purpose protocols beat general ones in all efficiency metrics. Indeed, known realizations <em>[x16, x1, x11]</em> try to avoid generic tools such as 2PC that leads to efficient solutions in case of constructions using pre-quantum assumptions but not when aiming protocols that offer post-quantum security. Besides their theoretical post-quantum solutions, Albrecht et al. <em>[x1]</em> mention an alternative pathway towards post-quantum VOPRFs that has comparable efficiency with their lattice-based solutions. This solution consists of a hash commitment to a key <span class="math">K</span>, and an actively secure MPC evaluation of the AES circuit on inputs <span class="math">K</span> and <span class="math">x</span> (from <span class="math">\\mathcal{S}</span></p>

    <p class="text-gray-300">respectively) together with comparison of the hash of the used key with the committed key, after which  <span class="math">\\mathcal{R}</span>  receives output iff the check goes through. At this point, one may recall the Legendre OPRF of Figure 6a that requires a single multiplication in the online phase for one bit output (or 128 multiplications for 128 bits). This is in contrast to the 960 multiplication of the AES circuit evaluation [GRR+16]. This observation motivates our Legendre VOPRF protocol, that is described in details in Figure 7b.</p>

    <p class="text-gray-300">Participants: sender  <span class="math">S</span> , receiver  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Parameters: a PRF  <span class="math">F:\\mathcal{K}\\times \\mathcal{X}\\to \\{0,1\\}</span>  for key-space  <span class="math">\\kappa</span>  input-space  <span class="math">\\mathcal{X}</span></p>

    <p class="text-gray-300">Init-  <span class="math">S</span>  : On input init from  <span class="math">S</span>  the functionality waits for an input  <span class="math">K</span>  from  <span class="math">S</span>  . If  <span class="math">S</span>  returns abort then the functionality aborts. Otherwise, it stores the value  <span class="math">K</span>  if it is a valid key (i.e., conforming to a predefined distribution.) and aborts if not.</p>

    <p class="text-gray-300">Init-  <span class="math">\\mathcal{R}</span>  : On input of init from  <span class="math">\\mathcal{R}</span>  , the functionality will return abort if Init-  <span class="math">S</span>  has not successfully completed.</p>

    <p class="text-gray-300">Query: On input of (query;  <span class="math">x</span> ) from  <span class="math">\\mathcal{R}</span> , if  <span class="math">x \\neq \\bot</span>  then the functionality waits for an input from  <span class="math">S</span> . If  <span class="math">S</span>  returns deliver then the functionality sends  <span class="math">y = F(K, x)</span>  to  <span class="math">\\mathcal{R}</span> . If  <span class="math">S</span>  returns abort then the functionality aborts.</p>

    <p class="text-gray-300">(a) Ideal functionality for VOPRF adapted from [ADDS21].</p>

    <p class="text-gray-300">Participants: sender  <span class="math">S</span> , receiver  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Initialization of  <span class="math">S_{1}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>samples and stores  <span class="math">K, r \\in \\mathbb{F}_p</span> ,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- computes and publishes commitment  $h = H(K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S\\colon K,r\\in \\mathbb{F}_p</span></li>

      <li><span class="math">\\mathcal{R}</span> :  <span class="math">x\\in \\mathbb{F}_p,h</span></li>

    </ul>

    <p class="text-gray-300">Evaluation:  <span class="math">\\hat{S}</span>  and  <span class="math">\\mathcal{R}</span>  run a secure 2-party computation with the above inputs to</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sample a random non-zero square  <span class="math">s^2 \\in \\mathbb{F}_p</span> ,</li>

      <li>compute  <span class="math">c = s^2 \\cdot (K + x)</span> ,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  $h\\gets (h\\neq H(K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r))<span class="math">  , where  </span>h\\in \\{0,1\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>output to  <span class="math">\\mathcal{R}</span> :  <span class="math">c&#x27; = (b \\cdot \\bot) + (1 - b) \\cdot c</span> .</li>

    </ol>

    <p class="text-gray-300">Finally  <span class="math">\\mathcal{R}</span>  computes  <span class="math">L_{p}(c^{\\prime}) = L_{p}(K + x)\\Leftrightarrow K</span>  is consistent to  <span class="math">h</span></p>

    <p class="text-gray-300">(b) Legendre VOPRF based on actively secure 2PC and collision-resistant hash  <span class="math">H</span> .</p>

    <p class="text-gray-300">Figure 7: Legendre VOPRF.</p>

    <p class="text-gray-300">Theorem G.1 (Informal) When instantiated with actively secure 2PC, protocol  <span class="math">\\Pi_{\\text{Legendre}}^{\\text{VOPRF}}</span>  securely realizes  <span class="math">\\mathcal{F}_{\\text{VOPRF}}</span>  under the SLS assumption and the assumptions which the 2PC protocol relies on and if  <span class="math">H</span>  is a collision-resistant hash.</p>

    <p class="text-gray-300">The generality of the utilized 2PC protocol leads to various instantiation opportunities causing that the above result can have several different flavours. We mention some of these. [KO04] showed that actively secure 2PC in the standard model requires 5 rounds of interaction. With some relaxations, namely by allowing the simulator to run in superpolynomial time while the adversary is still restricted to polynomial time (a.k.a. SPS security), actively secure non-interactive secure computation (NIZK) is possible in the plain model under the subexponential security of the LWE assumption  <span class="math">\\mathrm{[BGI^{+}17, BD18]}</span>  leading to a VOPRF realization under the same assumptions. Leaving the plain model, it is also possible to instantiate our VOPRF utilizing NIZK built on oblivious transfer (OT) in the OT-hybrid model  <span class="math">\\mathrm{[IKO^{+}11]}</span> , in the common reference string model [MR17] or in the global random oracle model [CJS14].</p>`;
---

<BaseLayout title="The Legendre Pseudorandom Function as a Multivariate Quadrat... (2021/182)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/182
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
