---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/654';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proximity Gaps for Reed-Solomon Codes';
const AUTHORS_HTML = 'Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, Shubhangi Saraf';

const CONTENT = `    <p class="text-gray-300">Proximity Gaps for Reed-Solomon Codes</p>

    <p class="text-gray-300">Eli Ben-Sasson<em>  Dan Carmon</em>  Yuval Ishai†  Swastik Kopparty ‡ Shubhangi Saraf§</p>

    <p class="text-gray-300">July 3, 2021</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">A collection of sets displays a proximity gap with respect to some property if for every set in the collection, either (i) all members are <span class="math">\\delta</span>-close to the property in relative Hamming distance or (ii) only a tiny fraction of members are <span class="math">\\delta</span>-close to the property. In particular, no set in the collection has roughly half of its members <span class="math">\\delta</span>-close to the property and the others <span class="math">\\delta</span>-far from it.</p>

    <p class="text-gray-300">We show that the collection of affine spaces displays a proximity gap with respect to Reed-Solomon (RS) codes, even over small fields, of size polynomial in the dimension of the code, and the gap applies to any <span class="math">\\delta</span> smaller than the Johnson/Guruswami-Sudan list-decoding bound of the RS code. We also show near-optimal gap results, over fields of (at least) linear size in the RS code dimension, for <span class="math">\\delta</span> smaller than the unique decoding radius. Concretely, if <span class="math">\\delta</span> is smaller than half the minimal distance of an RS code <span class="math">V \\subset \\mathbb{F}_q^n</span>, every affine space is either entirely <span class="math">\\delta</span>-close to the code, or alternatively at most an <span class="math">(n/q)</span>-fraction of it is <span class="math">\\delta</span>-close to the code. Finally, we discuss several applications of our proximity gap results to distributed storage, multi-party cryptographic protocols, and concretely efficient proof systems.</p>

    <p class="text-gray-300">We prove the proximity gap results by analyzing the execution of classical algebraic decoding algorithms for Reed-Solomon codes (due to Berlekamp-Welch and Guruswami-Sudan) on a formal element of an affine space. This involves working with Reed-Solomon codes whose base field is an (infinite) rational function field. Our proofs are obtained by developing an extension (to function fields) of a strategy of Arora and Sudan for analyzing low-degree tests.</p>

    <p class="text-gray-300">*StarkWare Industries Ltd. {eli,dancar}@starkware.co †Computer Science Department, Technion. Supported by ERC Project NTSC (742754), NSF-BSF grant 2015782, BSF grant 2018393, and a grant from the Ministry of Science and Technology, Israel and Department of Science and Technology, Government of India. Work done in part while participating in the Simons Institute program on Proofs, Consensus, and Decentralizing Society. yuvali@cs.technion.ac.il ‡Department of Mathematics and Department of Computer Science, Rutgers University. Research supported in part by NSF grants CCF-1540634 and CCF-1814409 and BSF grant 2014359. Work done in part while attending a workshop at the Simons Institute program on Proofs, Consensus, and Decentralizing Society. swastik.kopparty@gmail.com §Department of Mathematics and Department of Computer Science, Rutgers University. Research supported in part by NSF grants CCF-1540634 and CCF-1909683, BSF grant 2014359, a Sloan research fellowship and the Simons Collaboration on Algorithms and Geometry. shubhangi.saraf@gmail.com</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A variety of protocols, arising in the contexts of interactive proofs, distributed storage and cryptography, give rise to the following problem regarding proximity to a linear code <span class="math">V\\subset\\mathbb{F}_{q}^{n}</span> over a finite field <span class="math">\\mathbb{F}_{q}</span> of minimal relative distance <span class="math">\\delta_{V}</span>. These myriad protocols assume oracle access to a batch of vectors <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{n}</span> and their soundness requires that each and every vector <span class="math">u_{i}</span> be close to <span class="math">V</span> in relative Hamming distance. Furthermore, soundness deteriorates as a function of the largest distance between some vector <span class="math">u_{i}</span> and the code <span class="math">V</span>. Thus, we seek protocols that minimize the number of queries to the entries of the vectors in <span class="math">\\mathbf{u}</span>, while maximizing the probability of recognizing when some vector <span class="math">u_{i}</span> is significantly far from <span class="math">V</span>.</p>

    <p class="text-gray-300">The linearity of <span class="math">V</span> suggests a natural approach, first explored by Rothblum, Vadhan and Wigderson <em>[x20]</em>: sample a uniformly random vector <span class="math">u^{\\prime}</span> in the span of <span class="math">\\mathbf{u}</span> (denoted <span class="math">\\text{span}(\\mathbf{u})</span>) and view the distance between <span class="math">u^{\\prime}</span> and <span class="math">V</span>, denoted <span class="math">\\Delta(u^{\\prime},V)</span>, as a proxy for the maximal distance between some member of <span class="math">\\mathbf{u}</span> and <span class="math">V</span>. To argue soundness, we would like to show that if even a single <span class="math">u_{i}</span> is <span class="math">\\delta</span>-far from (all members of) <span class="math">V</span>, then a randomly chosen <span class="math">u^{\\prime}</span> is also far from <span class="math">V</span>. Indeed, the paper <em>[x20]</em> that suggested this approach also showed for any <span class="math">V</span>, that whenever a single <span class="math">u_{i}</span> is <span class="math">\\delta</span>-far from <span class="math">V</span>, then nearly all samples <span class="math">u^{\\prime}</span> are at least <span class="math">\\delta/2</span>-far from <span class="math">V</span>. Here and henceforth, we use <span class="math">\\Delta</span> to denote relative Hamming distance and say “<span class="math">u</span> is <span class="math">\\delta</span>-close to <span class="math">V</span>”, denoted <span class="math">\\Delta(u,V)\\leq\\delta</span>, when <span class="math">\\Delta(u,v)\\leq\\delta</span> for some <span class="math">v\\in V</span>; otherwise we say “<span class="math">u</span> is <span class="math">\\delta</span>-far from <span class="math">V</span>” (denoted <span class="math">\\Delta(u,V)&gt;\\delta</span>).</p>

    <p class="text-gray-300">Note that the result above incurs a <span class="math">2\\times</span> degradation in the proximity parameter <span class="math">\\delta</span>: the worst-case assumption — that some <span class="math">u_{i}</span> is <span class="math">\\delta</span>-far from <span class="math">V</span> — implies an average-case distance that is only <span class="math">\\delta/2</span>. Eliminating the proximity degradation is easy when the field size is exponential in the code length. More concretely, if <span class="math">q\\gg 2^{nH(\\delta)}</span>, where <span class="math">H</span> is the binary entropy function, then a union bound over agreement sets shows that for <span class="math">\\delta&lt;\\delta_{V}</span>, if <span class="math">u_{i}</span> is <span class="math">\\delta</span>-far from <span class="math">V</span> then so are nearly all <span class="math">u^{\\prime}\\in\\text{span}(\\mathbf{u})</span>. However, exponential field size is prohibitively large in the context of the motivating applications. Obtaining similar results over fields of sub-exponential size appears to be much more challenging.</p>

    <p class="text-gray-300">A number of works looked at this question and were able to remove the degradation in <span class="math">\\delta</span> with polynomial field size. Ames et al. <em>[x1]</em> showed that for proximity parameters <span class="math">\\delta</span> that are smaller than half of the unique-decoding radius of <span class="math">V</span> (i.e., when <span class="math">\\delta&lt;\\delta_{V}/4</span>), nearly all <span class="math">u^{\\prime}\\in\\text{span}(\\mathbf{u})</span> are <span class="math">\\delta</span>-far from <span class="math">V</span>. The proximity bound was subsequently improved to <span class="math">\\delta&lt;\\delta_{V}/3</span> by Roth and Zémor <em>[x22]</em>. Ben-Sasson et al. <em>[x5]</em> showed similar results for <span class="math">\\delta</span> above the unique decoding radius, holding for any <span class="math">\\delta&lt;1-\\sqrt[4]{1-\\delta_{V}}</span>, and the state of the art was given in <em>[x6]</em>, holding for any <span class="math">\\delta&lt;1-\\sqrt[3]{1-\\delta_{V}}</span>. In fact, this latter result was shown to be tight for certain RS codes, in particular, of maximal blocklength <span class="math">n=q</span>.</p>

    <p class="text-gray-300">Ames et al., who were the first to show that in certain cases the average-case distance of <span class="math">u^{\\prime}\\in\\text{span}(\\mathbf{u})</span> from <span class="math">V</span> is nearly-always equal to the worst-case distance of <span class="math">u_{i}\\in\\mathbf{u}</span> from <span class="math">V</span>, also raised the following intriguing question, which is at the focus of our investigation here: For which codes and what range of <span class="math">\\delta</span> does the following statement hold?</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>If some <span class="math">u^{*}\\in\\text{span}(\\mathbf{u})</span> is <span class="math">\\delta</span>-far from <span class="math">V</span>, then so are nearly all <span class="math">u^{\\prime}\\in\\text{span}(\\mathbf{u})</span>.</p>
    </blockquote>

    <p class="text-gray-300">One implication of our main result is that when <span class="math">V</span> is an RS code over a sufficiently large field — polynomially large in the code’s blocklength — and when <span class="math">\\delta</span> is smaller than the Johnson/Guruswami–Sudan list decoding bound, the above phenomenon holds. We refer to it as a proximity gap, as explained next.</p>

    <p class="text-gray-300">1.1 Gaps and proximity gaps</p>

    <p class="text-gray-300">When a “gap” is mentioned in theoretical computer science, it usually refers to a situation where all objects under consideration must fall into one of two categories, and these categories display a large gap according to some metric. Striking examples are given by PCP reductions whose outputs are constraint satisfaction problems that lie in one of two categories: satisfiable instances in which some assignment satisfies all constraints, and unsatisfiable instances in which all assignments fail to satisfy more than an <span class="math">\\epsilon</span> fraction of constraints. Another gap example underlies randomized algorithms. For instance, the Miller–Rabin primality test relies on a gap between primes and composites: in the latter case (composites), at least three-quarters of the integers serve as composite witnesses whereas for primes none do, leading to a “gap” of measure <span class="math">3/4</span>.</p>

    <p class="text-gray-300">Our main result can be phrased as a <em>proximity gap</em> according to the following definition.</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Definition 1.1 (Proximity gap).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{P}\\subset\\Sigma^{n}</span> be a property and <span class="math">\\mathsf{C}\\subset 2^{\\Sigma^{n}}</span> be a collection of sets. Let <span class="math">\\Delta</span> be a distance measure on <span class="math">\\Sigma^{n}</span>. We say that <span class="math">\\mathsf{C}</span> displays a <span class="math">(\\delta,\\epsilon)</span>-proximity gap with respect to <span class="math">\\mathsf{P}</span> under <span class="math">\\Delta</span> if every <span class="math">\\mathsf{S}\\in\\mathsf{C}</span> satisfies exactly one of the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pr_{s\\in\\mathsf{S}}[\\Delta(s,\\mathsf{P})\\leq\\delta]=1</span>.</li>

      <li><span class="math">\\Pr_{s\\in\\mathsf{S}}[\\Delta(s,\\mathsf{P})\\leq\\delta]\\leq\\epsilon</span>.</li>

    </ol>

    <p class="text-gray-300">We call <span class="math">\\delta</span> the <em>proximity parameter</em> and <span class="math">\\epsilon</span> is the <em>error parameter</em>. By default, <span class="math">\\Delta</span> denotes the relative Hamming distance measure.</p>

    <p class="text-gray-300">Using this definition, our main result can be informally stated as follows: if <span class="math">V\\subset\\mathbb{F}^{n}</span> is an RS code and <span class="math">A\\subset\\mathbb{F}^{n}</span> is an affine space, then either all elements of <span class="math">A</span> are close to <span class="math">V</span>, or otherwise, nearly all elements of <span class="math">A</span> are far from <span class="math">V</span>. In other words, there is no affine <span class="math">A</span> in which roughly half of the elements are close to <span class="math">V</span> while the other half are far from <span class="math">V</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout this paper, <span class="math">\\mathbb{F}_{q}</span> denotes the field of size <span class="math">q</span>, and <span class="math">\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span> is the RS code of <em>dimension</em> <span class="math">k+1</span> and <em>blocklength</em> $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> containing as its codewords the polynomials of degree </span>\\leq k<span class="math">, evaluated on </span>\\mathcal{D}<span class="math">. We use </span>\\rho<span class="math"> to denote the <em>rate</em> </span>\\rho=\\frac{k+1}{n}<span class="math"> of the code. The letter </span>\\delta<span class="math"> will typically denote relative Hamming distance to the relevant RS code and </span>\\epsilon$ will denote an error parameter, the probability that a “bad event” occurs (with varying definitions of the term “bad event”).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following result has two parts and each part has its own proof. The first part holds only below the unique decoding radius but has a smaller error parameter, denoted <span class="math">\\epsilon_{\\mathsf{U}}</span>, which is in fact essentially tight; the second part holds for proximity parameters up to the Johnson/Guruswami–Sudan bound (which is greater than the unique decoding bound) but has a larger error bound <span class="math">\\epsilon_{\\mathsf{J}}</span> (the proof of the second part is also significantly harder).</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Theorem 1.2 (Proximity gap for RS codes).</h6>

    <p class="text-gray-300">The collection <span class="math">\\mathsf{C}_{\\mathsf{Affine}}</span> of affine spaces in <span class="math">\\mathbb{F}_{q}^{\\mathcal{D}}</span> displays a <span class="math">(\\delta,\\epsilon)</span>-proximity gap with respect to the RS code <span class="math">V:=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span> of blocklength <span class="math">n</span> and rate <span class="math">\\rho=\\frac{k+1}{n}</span>, for any <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span>, and <span class="math">\\epsilon=\\epsilon(q,n,\\rho,\\delta)</span> defined as the following piecewise function:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Unique decoding bound: For <span class="math">\\delta\\in\\left(0,\\frac{1-\\rho}{2}\\right]</span>, the error parameter <span class="math">\\epsilon</span> is</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon=\\epsilon_{\\mathsf{U}}=\\epsilon_{\\mathsf{U}}(q,n):=\\frac{n}{q}.</span> (1.1)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Johnson bound: For <span class="math">\\delta\\in\\left(\\frac{1-\\rho}{2},1-\\sqrt{\\rho}\\right)</span>, setting <span class="math">\\eta\\coloneqq 1-\\sqrt{\\rho}-\\delta</span>, the error parameter <span class="math">\\epsilon</span> is</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon=\\epsilon_{\\mathsf{J}}=\\epsilon_{\\mathsf{J}}(q,n,\\rho,\\delta):=\\frac{(k+1)^{2}}{\\left(2\\min\\left(\\eta,\\frac{\\sqrt{\\rho}}{20}\\right)\\right)^{7}q}=O\\left(\\frac{1}{(\\eta\\rho)^{O(1)}}\\cdot\\frac{n^{2}}{q}\\right)</span> (1.2)</p>

    <p class="text-gray-300">There are two striking aspects to this result. First, the proximity parameter <span class="math">\\delta</span> can take any value smaller than the famous Johnson/Guruswami–Sudan bound, which is the largest distance for which we know of efficient (list) decoding algorithms. (Looking ahead, the Guruswami–Sudan algorithm will play a crucial, though non-algorithmic, role in our proofs.) Second, the size of the field needed to achieve this result is relatively small — linear in the blocklength when <span class="math">\\delta</span> is below the unique decoding radius <span class="math">\\delta&lt;(1-\\rho)/2</span> and, for fixed rate, quadratic in blocklength for larger <span class="math">\\delta</span> up to the list decoding bound.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Remark 1.1 (On the tightness of our results).</h6>

    <p class="text-gray-300">We make several comments on the margins for possible improvement.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proximity parameter <span class="math">\\delta</span>. The maximal proximity parameter <span class="math">\\delta</span> for which Theorem 1.2 applies happens to coincide with the Johnson/Guruswami–Sudan list-decoding bound <span class="math">(1-\\sqrt{\\rho})</span>. This evidently follows from the techniques we use here, which rely on list-decoding algorithms that reach that bound. However, we conjecture that Theorem 1.2 holds even for larger proximity parameters, up to capacity <span class="math">(1-\\rho)</span>. See Conjecture 8.4 and the discussion there.</li>

      <li>Field size <span class="math">q</span>. The bound in Eq. (1.2) which reaches the Johnson bound becomes nontrivial only for fields of size <span class="math">q</span> that are at least quadratically larger than the blocklength <span class="math">n</span>. In contrast, the bound for smaller proximity parameters, below the unique decoding radius, works for <span class="math">q=O(n)</span> (see Eq. (1.1)). We point out that for certain combinations of fields and rate parameters one cannot hope to reach the Johnson bound with linear size fields, as this would contradict prior results from <em>[x1]</em>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Error parameter <span class="math">\\epsilon</span>. In the unique decoding regime, our bound on the error <span class="math">\\epsilon</span> is sharp in the sense that affine spaces do not all display a proximity gap with <span class="math">q\\cdot\\epsilon</span> being sublinear in <span class="math">n</span>, for fixed distance parameter <span class="math">\\delta</span>. A simple example is of the affine line <span class="math">\\{u_{0}+zu_{1}:z\\in\\mathbb{F}_{q}\\}</span>, where <span class="math">u_{0},u_{1}:\\mathcal{D}\\to\\mathbb{F}_{q}</span> are such that on a set <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n(1-\\delta)-1<span class="math"> we have </span>u_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}^{\\prime}}=u_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}^{\\prime}}=0<span class="math">, and on the complement we have that </span>u_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}}=1<span class="math">, and </span>u_{0}<span class="math"> takes </span>\\delta n+1<span class="math"> distinct non-zero values. We then have </span>\\Delta(u_{0}+zu_{1},V)\\leq\\delta<span class="math"> for each of the </span>\\delta n+1<span class="math"> values of </span>z\\in\\mathbb{F}_{q}<span class="math"> for which </span>-z<span class="math"> is in the image of </span>u_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}}<span class="math">, but that </span>\\Delta(u_{0},V)=\\delta+\\frac{1}{n}>\\delta<span class="math">, thus this line does not display a </span>(\\delta,\\frac{\\delta n}{q})$ proximity gap with respect to the code.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Concentration bounds</h3>

    <p class="text-gray-300">Theorem 1.2 implies the following concentration bound, saying that for any affine space in which the element farthest from the RS code is within the Johnson/Guruswami–Sudan radius, nearly all elements are at exactly the same distance from the code(!).</p>

    <p class="text-gray-300">For two sets <span class="math">U,V\\subset\\Sigma^{n}</span> define the divergence of <span class="math">U</span> from <span class="math">V</span> as <span class="math">\\mathsf{D}(U,V):=\\max_{u\\in U}\\Delta(u,V)</span>.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Corollary 1.3 (Concentration bounds).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">U\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> be an affine space over <span class="math">\\mathbb{F}_{q}</span> and denote <span class="math">\\delta^{<em>}:=\\mathsf{D}(U,V)</span>. If <span class="math">\\delta^{</em>}</span> is smaller than the Johnson/Guruswami–Sudan bound, then nearly all elements of <span class="math">U</span> have distance exactly <span class="math">\\delta^{<em>}</span> from the code. In other words, if <span class="math">\\delta^{</em>}\\in(0,1-\\sqrt{\\rho})</span>, then</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\left[\\Delta(u,V)\\neq\\delta^{*}\\right]\\leq\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon=\\epsilon(q,n,\\rho,\\delta^{*})</span> is as defined in Theorem 1.2.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define <span class="math">\\delta=\\frac{\\lceil n\\delta^{<em>}\\rceil-1}{n}&lt;\\delta^{</em>}</span>. Note that because the values of <span class="math">\\Delta</span> are integer multiples of <span class="math">\\frac{1}{n}</span>, we have for all <span class="math">u\\in U</span>, <span class="math">\\Delta(u,V)&lt;\\delta^{<em>}\\iff\\Delta(u,V)\\leq\\delta</span>. On the other hand by the maximality of <span class="math">\\delta^{</em>}</span>, we have <span class="math">\\Delta(u,V)\\neq\\delta^{<em>}\\iff\\Delta(u,V)&lt;\\delta^{</em>}</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\left[\\Delta(u,V)\\neq\\delta^{<em>}\\right]=\\Pr_{u\\in U}\\left[\\Delta(u,V)&lt;\\delta^{</em>}\\right]=\\Pr_{u\\in U}\\left[\\Delta(u,V)\\leq\\delta\\right].</span></p>

    <p class="text-gray-300">This probability cannot equal <span class="math">1</span>, since <em>some</em> <span class="math">u\\in U</span> exists with <span class="math">\\Delta(u,V)=\\delta^{*}</span>, by definition. Thus the proximity gap from Theorem 1.2 gives</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\left[\\Delta(u,V)\\neq\\delta^{<em>}\\right]=\\Pr_{u\\in U}\\left[\\Delta(u,V)\\leq\\delta\\right]\\leq\\epsilon(q,n,\\rho,\\delta)\\leq\\epsilon(q,n,\\rho,\\delta^{</em>})=\\epsilon,</span></p>

    <p class="text-gray-300">where the last inequality is due to <span class="math">\\epsilon</span> being monotone non-decreasing as a function of the <span class="math">\\delta</span> parameter. ∎</p>

    <p class="text-gray-300">When the divergence of <span class="math">U</span> from the RS code <span class="math">V</span> is greater than the Johnson/Guruswami–Sudan bound (<span class="math">\\delta^{<em>}&gt;1-\\sqrt{\\rho}</span>) we may still use Theorem 1.2 to conclude that nearly all elements of <span class="math">U</span> are <span class="math">\\approx(1-\\sqrt{\\rho})</span>-far from <span class="math">V</span>, but what remains an interesting open problem is whether nearly all members of <span class="math">U</span> are maximally far (<span class="math">\\delta^{</em>}</span>-far) from <span class="math">V</span>. An example from <em>[x1]</em> shows that this need not be the case for RS codes where <span class="math">q=O(n)</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.3 Correlated agreement</h3>

    <p class="text-gray-300">Next, we state the main technical theorem proved in the paper. Consider two vectors <span class="math">u_{0},u_{1}\\in\\mathbb{F}^{\\mathcal{D}}</span>. The result says that if sufficiently many elements in the <span class="math">1</span>-dimensional affine space <span class="math">A=\\{u_{0}+zu_{1}:z\\in\\mathbb{F}\\}</span> are sufficiently close (<span class="math">\\delta</span>-close) to the RS code <span class="math">V</span>, then there must be a nontrivial subdomain <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> of density <span class="math">1-\\delta</span> in <span class="math">\\mathcal{D}</span>, such that restricting <span class="math">u_{0},u_{1}</span> to <span class="math">\\mathcal{D}^{\\prime}</span> gives a valid RS codeword (evaluated over <span class="math">\\mathcal{D}^{\\prime}</span>). We refer to the property that such a <span class="math">\\mathcal{D}^{\\prime}</span> exists as <em>correlated agreement</em>, in the sense that <span class="math">u_{0},u_{1}</span> and the elements of <span class="math">A</span> do not only have large agreement with the RS code individually, but also share a common large agreement set. The result has two ranges of parameters, as in prior statements in this paper. For proximity parameters in the unique decoding regime this is proved in Theorem 4.1, and for proximity parameters in the list decoding regime this is proved in Theorem 5.1.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 1.4 (Main Theorem — Correlated agreement over lines).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. For <span class="math">u_{0},u_{1}\\in\\mathbb{F}_{q}^{\\mathcal{D}}</span>, if <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span> and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{z\\in\\mathbb{F}_{q}}\\left[\\Delta(u_{0}+z\\cdot u_{1},V)\\leq\\delta\\right]&gt;\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2, then there exist <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> and <span class="math">v_{0},v_{1}\\in V</span> satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Density: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\delta$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Agreement: <span class="math">v_{0}</span> agrees with <span class="math">u_{0}</span> and <span class="math">v_{1}</span> agrees with <span class="math">u_{1}</span> on all of <span class="math">\\mathcal{D}^{\\prime}</span>.</li>

    </ul>

    <h6 id="sec-9" class="text-base font-medium mt-4">Remark 1.2 (Sampling from extension fields).</h6>

    <p class="text-gray-300">One may sample <span class="math">z</span> from a finite extension field <span class="math">\\mathbb{F}_{q^{\\prime}}</span> of <span class="math">\\mathbb{F}_{q}</span>. In this case, the statement above holds with <span class="math">\\epsilon_{\\mathsf{U}}</span> and <span class="math">\\epsilon_{\\mathsf{J}}</span> modified by replacing <span class="math">q</span> with <span class="math">q^{\\prime}</span> in the denominators of Eqs. (1.1) and (1.2), respectively. Note that even in this setting, the vectors <span class="math">v_{0},v_{1}</span> deduced to exist in Theorem 1.4 belong to <span class="math">\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span>, not just in <span class="math">\\mathsf{RS}[\\mathbb{F}_{q^{\\prime}},\\mathcal{D},k]</span>, because <span class="math">v_{0},v_{1}</span> have high agreement with <span class="math">u_{0},u_{1}\\in\\mathbb{F}_{q}^{\\mathcal{D}}</span>. The ability to sample from a larger field (and incur smaller error) applies to the other statements of this section but for simplicity we state all of them using a single field <span class="math">\\mathbb{F}_{q}</span> to both define <span class="math">V</span> and sample <span class="math">z</span> from.</p>

    <p class="text-gray-300">Motivated by applications (described later), we generalize the theorem above to two interesting cases: (i) low-degree parameterized curves, and (ii) higher-dimensional affine spaces; details follow.</p>

    <p class="text-gray-300">Correlated agreement over parameterized curves</p>

    <p class="text-gray-300">The first extension of Theorem 1.4 extends it from the case of a “line” passing through <span class="math">u_{0}</span> and <span class="math">u_{1}</span> (the line being <span class="math">\\{u_{0}+zu_{1}:z\\in\\mathbb{F}\\}</span>) to a “low-degree curve” with coefficients <span class="math">u_{0},u_{1},\\ldots,u_{l}</span>, as described below. This result is of particular importance for two reasons. First, it leads to derandomized testing of verifiable secret sharing and other multi-party protocols (cf. Section 8.1). Second, it improves the soundness analysis of the Fast RS IOPP (FRI) protocol <em>[x1]</em>, which is used in concretely efficient and transparent (public coin) proof systems <em>[x1, x2, BCG^{+}18, x10, x11]</em>. We discuss this application in Sections 3.2 and 8.2.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span>. The <em>parameterized curve</em> of degree <span class="math">l</span> that is generated by <span class="math">\\mathbf{u}</span> is the following collection of vectors in <span class="math">\\mathbb{F}_{q}^{\\mathcal{D}}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{curve}(\\mathbf{u}):=\\left\\{u_{z}:=\\sum_{i=0}^{l}z^{i}\\cdot u_{i}\\;\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;z\\in\\mathbb{F}_{q}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.5 (Correlated agreement for low-degree parameterized curves).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span>. If <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span> and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in\\mathsf{curve}(\\mathbf{u})}[\\Delta(u,V)\\leq\\delta]&gt;l\\cdot\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2, then there exist <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> and <span class="math">v_{0},\\ldots,v_{l}\\in V</span> satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Density: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\delta$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Agreement: for all <span class="math">i\\in\\{0,\\ldots,l\\}</span>, the functions <span class="math">u_{i}</span> and <span class="math">v_{i}</span> agree on all of <span class="math">\\mathcal{D}^{\\prime}</span>.</li>

    </ul>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Correlated agreement for affine spaces</h4>

    <p class="text-gray-300">The second generalization of our Main Theorem 1.4, extends it from the 1-dimensional case (affine line) to an affine space of arbitrary dimension. Theorem 1.2 follows directly from the following statement. Note that Main Theorem 1.4 is actually a case of the following result (for 1-dimensional spaces). However, we stated that special case separately because we prove it first, and from it deduce the more general case (see Section 6.3).</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.6 (Correlated agreement over affine spaces).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. For <span class="math">u_{0},u_{1},\\ldots u_{l}\\in\\mathbb{F}_{q}^{\\mathcal{D}}</span> let <span class="math">U=u_{0}+\\mathrm{span}\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> be an affine subspace. If <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span> and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\left[\\Delta(u,V)\\leq\\delta\\right]&gt;\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2, then there exist <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> and <span class="math">v_{0},\\ldots,v_{l}\\in V</span> satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Density: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\delta$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Agreement: for all <span class="math">i\\in\\{0,\\ldots,l\\}</span>, the functions <span class="math">u_{i}</span> and <span class="math">v_{i}</span> agree on all of <span class="math">\\mathcal{D}^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">Furthermore, in the unique decoding regime <span class="math">\\delta\\in\\left(0,\\frac{1-\\rho}{2}\\right]</span>, there exists a unique <em>maximal <span class="math">\\mathcal{D}^{\\prime}</span></em> satisfying the above, with unique <span class="math">v_{i}</span>.</p>

    <p class="text-gray-300">Correlated agreement (Theorem 1.6) is a sufficient condition for proximity gaps with the same error and proximity parameters (Theorem 1.2). We leave as open problems (i) whether correlated agreement is also a necessary condition for a proximity gap. And, if the answer to this question is negative, an intriguing possibility arises: (ii) obtaining proximity gaps for <span class="math">\\delta&gt;1-\\sqrt{\\rho}</span> while bypassing the correlated agreement approach we took here.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Organization of the rest of the paper:</h4>

    <p class="text-gray-300">We start with an overview of the proof of Main Theorem 1.4 in Section 2. In Section 3 we survey several applications of our results. Section 4 gives the (simper) proof of the unique decoding radius part of Main Theorem 1.4. Section 5 gives the proof of the (harder) list decoding radius part of that theorem, by reducing it to a different, more parameterized format (Appendix A provides the preliminary algebraic setup for the proof). In Section 6 we prove the generalizations of Main Theorem 1.4 to curves (Theorem 1.5) and higher dimensional affine spaces (Theorem 1.6). In Section 7 we state and prove weighted versions of our theorems. Section 8 concludes with more details on selected applications — verifiable secret sharing (VSS) and Fast RS IOPs of Proximity (FRI).</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Acknowledgments</h4>

    <p class="text-gray-300">We thank Venkatesan Guruswami and Amnon Ta-Shma for carefully auditing this paper and suggesting valuable improvements to it, and the Ethereum Foundation for funding their audit.</p>

    <p class="text-gray-300">We thank Ronald Cramer and Jade Nardi for pointing out a flaw in the cited version of the Polishchuk–Spielman lemma and suggesting possible fixes.</p>

    <h2 id="sec-15" class="text-2xl font-bold">2 Proof Overview</h2>

    <p class="text-gray-300">In this section, we give an overview of our proof strategy of our main result, Theorem 1.4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall the setup. <span class="math">V=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span> of degree <span class="math">k</span> polynomials evaluated at the points of <span class="math">\\mathcal{D}\\subseteq\\mathbb{F}_{q}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">. We have functions </span>u_{0},u_{1}:\\mathcal{D}\\to\\mathbb{F}_{q}<span class="math"> such that for many </span>z\\in\\mathbb{F}_{q}<span class="math">, the function </span>u_{0}+zu_{1}<span class="math"> is </span>\\delta<span class="math">-close to </span>V<span class="math">. We want to deduce that </span>u_{0}<span class="math"> and </span>u_{1}<span class="math"> are themselves close to </span>V$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main conceptual idea of our analysis is to work with the function field <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> with a formal variable <span class="math">Z</span>, and to study the various received words <span class="math">u_{0}+zu_{1}</span> for the code <span class="math">V</span> simultaneously by considering the formal received word <span class="math">w=u_{0}+Zu_{1}:\\mathcal{D}\\to\\mathbb{K}</span> for the (big field) Reed–Solomon code <span class="math">\\mathsf{RS}[\\mathbb{K},\\mathcal{D},k]</span>. It turns out that showing that <span class="math">w</span> is close to a (well-structured) codeword of this Reed–Solomon code is sufficient to show that <span class="math">u_{0}</span> and <span class="math">u_{1}</span> are both close to the original Reed–Solomon code <span class="math">V</span>. With this viewpoint, our proof strategy is to run a decoding algorithm for Reed–Solomon codes on this received word <span class="math">w=u_{0}+Zu_{1}</span>. Our goal is to analyze the execution of this algorithm to show that it succeeds in finding a nearby Reed–Solomon codeword. We do such an analysis by relating it to the execution of that decoding algorithm on the various received words <span class="math">u_{0}+zu_{1}</span> for the Reed–Solomon code <span class="math">V</span> over the small field <span class="math">\\mathbb{F}_{q}</span>.</p>

    <p class="text-gray-300">This strategy is instantiated with two different decoding algorithms for Reed–Solomon codes: the Berlekamp–Welch unique decoding algorithm, and the Guruswami–Sudan list decoding algorithm <em>[x10]</em>. Both instantiations give rise to intriguing algebraic questions about polynomials, which we resolve using nontrivial tools from algebraic geometry and the theory of algebraic function fields.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Instantiation with the Berlekamp–Welch Algorithm</h4>

    <p class="text-gray-300">Over a field <span class="math">\\mathbb{F}</span> and an evaluation domain <span class="math">\\mathcal{D}</span>, given a received word <span class="math">r:\\mathcal{D}\\to\\mathbb{F}</span>, the Berlekamp–Welch decoding algorithm for finding the (unique) nearby polynomial <span class="math">P(X)\\in\\mathbb{F}[X]</span> close to <span class="math">r</span> works as follows. First it searches for low-degree polynomials <span class="math">A(X),B(X)\\in\\mathbb{F}[X]</span> such that for each <span class="math">x\\in\\mathcal{D}</span>:</p>

    <p class="text-gray-300"><span class="math">A(x)r(x)=B(x).</span></p>

    <p class="text-gray-300">Then the nearby polynomial <span class="math">P(X)</span> is recovered as <span class="math">B(X)/A(X)</span> (which a priori may be a rational function).</p>

    <p class="text-gray-300">In our setting, we first run the Berlekamp–Welch algorithm with received word <span class="math">w=u_{0}+Zu_{1}:\\mathcal{D}\\to\\mathbb{K}</span> over the big field <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> (we will sometimes view this as a function <span class="math">w(x,z)</span> with <span class="math">w:\\mathcal{D}\\times\\mathbb{F}_{q}\\to\\mathbb{F}_{q}</span>). Our goal is to find a nearby Reed–Solomon codeword (low-degree polynomial) <span class="math">P(X)\\in\\mathbb{K}[X]</span> which has the special form <span class="math">P_{0}(X)+ZP_{1}(X)</span>, where each <span class="math">P_{i}(X)\\in\\mathbb{F}_{q}[X]</span>. The first step of the Berlekamp–Welch algorithm gives us <span class="math">A(X),B(X)\\in\\mathbb{K}[X]=\\mathbb{F}_{q}(Z)[X]</span>. Making the <span class="math">Z</span> dependence explicit, we write these as <span class="math">A(X,Z),B(X,Z)</span>. This gives us a candidate, namely <span class="math">A(X,Z)/B(X,Z)</span>, for being a Reed–Solomon codeword close to <span class="math">w</span>. We will show two things: that <span class="math">A(X,Z)/B(X,Z)</span> is a polynomial in <span class="math">\\mathbb{F}_{q}(Z)[X]</span> (a priori it is only a rational function), and that it is close to <span class="math">w</span>.</p>

    <p class="text-gray-300">The crucial step is to substitute <span class="math">Z=z</span> into <span class="math">A(X,Z)</span> and <span class="math">B(X,Z)</span> for various values of <span class="math">z\\in\\mathbb{F}_{q}</span>. Letting <span class="math">w_{z}=u_{0}+zu_{1}:\\mathcal{D}\\to\\mathbb{K}</span> (the result of substituting <span class="math">Z=z</span> into <span class="math">w</span>), it turns out that <span class="math">A(X,z),B(X,z)\\in\\mathbb{F}_{q}[X]</span> are what we would get if we run the Berlekamp–Welch algorithm (over the small field <span class="math">\\mathbb{F}_{q}</span>) on received word <span class="math">w_{z}</span>. In particular, for many <span class="math">z</span> we get that <span class="math">B(X,z)</span> is divisible by <span class="math">A(X,z)</span> in <span class="math">\\mathbb{F}_{q}[X]</span>, and <span class="math">B(X,z)/A(X,z)</span> equals the Reed–Solomon codeword close to <span class="math">w_{z}</span>. This then allows us to use the Polishchuk–Spielman lemma (a strengthening of the classical Bezout theorem, which deduces divisibility of bivariate polynomials from divisibility of univariate restrictions) to conclude that <span class="math">B(X,Z)/A(X,Z)</span> is in fact a polynomial <span class="math">P(X,Z)</span> in <span class="math">\\mathbb{K}[X]</span> of low degree in <span class="math">X</span>.</p>

    <p class="text-gray-300">The final step is to show that <span class="math">P(X,Z)</span>, when viewed as a function from <span class="math">\\mathcal{D}</span> to <span class="math">\\mathbb{K}</span>, is close to <span class="math">w</span>, and that that the <span class="math">Z</span> dependence of <span class="math">P(X,Z)</span> is simple (just linear in <span class="math">Z</span>). This is again achieved by considering <span class="math">Z</span> substitutions. We know that for many <span class="math">z</span>, <span class="math">P(X,z)</span> is the degree at most <span class="math">k</span> polynomial <span class="math">P_{z}(X)</span> that is close to <span class="math">w_{z}</span>. This means that the <span class="math">X</span> degree of <span class="math">P(X,z)</span> is at most <span class="math">k</span>, and that for many <span class="math">x\\in\\mathcal{D}</span> and <span class="math">z</span> there is agreement between <span class="math">P(x,z)</span> and <span class="math">w_{z}(x)=w(x,z)</span>. On the other hand, for any <span class="math">x\\in\\mathcal{D}</span>, <span class="math">w(x,\\cdot)</span> is a linear function, and <span class="math">P(x,\\cdot)</span> is a low degree rational function, and so they cannot agree on too many points unless the low degree rational function <span class="math">P(x,\\cdot)</span> formally equals the linear function <span class="math">w(x,\\cdot)</span>. Therefore this formal equality must happen for many <span class="math">x\\in\\mathcal{D}</span>, i.e., <span class="math">P(\\cdot,Z)</span> is close to <span class="math">w</span>. Finally, by simple linear algebra, if <span class="math">P(x,Z)</span> is linear in <span class="math">Z</span> for many <span class="math">x</span>, we conclude that <span class="math">P(X,Z)</span> is linear in <span class="math">Z</span>. This gives us our desired conclusion.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Instantiation with the Guruswami–Sudan Algorithm</h4>

    <p class="text-gray-300">Over a field <span class="math">\\mathbb{F}</span> and an evaluation domain <span class="math">\\mathcal{D}</span>, given a received word <span class="math">r:\\mathcal{D}\\to\\mathbb{F}</span>, the Sudan and Guruswami–Sudan decoding algorithms for finding all nearby polynomials <span class="math">P(X)\\in\\mathbb{F}[X]</span> close to <span class="math">r</span> work as follows. First one searches for a low-degree polynomial <span class="math">Q(X,Y)\\in\\mathbb{F}[X,Y]</span> such that for each <span class="math">x\\in\\mathcal{D}</span>,</p>

    <p class="text-gray-300"><span class="math">Q(x,r(x))=0.</span></p>

    <p class="text-gray-300">(This is the Sudan algorithm; for the Guruswami–Sudan algorithm we ask that <span class="math">Q</span> vanishes at each <span class="math">(x,r(x))</span> with high multiplicity.) Then every nearby polynomial <span class="math">P(X)</span> turns out to have the property that <span class="math">Y-P(X)</span> divides <span class="math">Q(X,Y)</span> in the bivariate polynomial ring <span class="math">\\mathbb{F}_{q}[X,Y]</span>. This means that all such <span class="math">P(X)</span> can be found by factoring <span class="math">Q(X,Y)</span>.</p>

    <p class="text-gray-300">In our setting, we run the Guruswami–Sudan algorithm with received word <span class="math">w=u_{0}+Zu_{1}:\\mathcal{D}\\to\\mathbb{K}</span> over the big field <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span>. Our goal is to find a nearby low-degree polynomial <span class="math">P(X)\\in\\mathbb{K}[X]</span> which has the special form <span class="math">P_{0}(X)+ZP_{1}(X)</span>, where each <span class="math">P_{i}(X)\\in\\mathbb{F}_{q}[X]</span>. The first step of the Guruswami–Sudan algorithm gives us a bivariate polynomial <span class="math">Q(X,Y)\\in\\mathbb{K}[X,Y]</span> such that <span class="math">Q(x,w(x))=0</span> for each <span class="math">x\\in\\mathcal{D}</span>. Again, we write <span class="math">Q(X,Y)</span> as <span class="math">Q(X,Y,Z)\\in\\mathbb{F}_{q}(Z)[X,Y]</span> to make the <span class="math">Z</span> dependence explicit (and we can clear denominators in <span class="math">Z</span> without affecting the vanishing property).</p>

    <p class="text-gray-300">Substituting <span class="math">Z=z</span>, we get that <span class="math">Q(x,w_{z}(x),z)=0</span> for each <span class="math">x\\in\\mathcal{D}</span>. This means that the</p>

    <p class="text-gray-300">polynomial <span class="math">Q_{z}(X,Y)\\in\\mathbb{F}_{q}[X,Y]</span> given by <span class="math">Q_{z}(X,Y)=Q(X,Y,z)\\in\\mathbb{F}_{q}[X,Y]</span> is the bivariate polynomial we would have found while running the Guruswami–Sudan algorithm with received word <span class="math">w_{z}:\\mathcal{D}\\to\\mathbb{F}_{q}</span> over the small field <span class="math">\\mathbb{F}_{q}</span>. Since for many <span class="math">z\\in\\mathbb{F}_{q}</span> we have that <span class="math">w_{z}</span> is close to some codeword <span class="math">P_{z}(X)\\in\\mathbb{F}_{q}[X]</span> of the Reed–Solomon code <span class="math">V</span>, we get that <span class="math">Y-P_{z}(X)</span> divides <span class="math">Q(X,Y,z)</span> for many <span class="math">z\\in\\mathbb{F}_{q}</span>. We would like to deduce from this that over the big field <span class="math">\\mathbb{K}</span> there is a low-degree polynomial <span class="math">P(X)\\in\\mathbb{K}[X]</span> such that <span class="math">Y-P(X)</span> divides <span class="math">Q(X,Y)</span> in <span class="math">\\mathbb{K}[X,Y]</span> (and furthermore, this <span class="math">P(X)</span> is close to <span class="math">w</span> and has a simple <span class="math">Z</span> dependence).</p>

    <p class="text-gray-300">This is the most involved (and interesting) part of the analysis. We will factor <span class="math">Q(X,Y,Z)</span> completely into linear factors in <span class="math">Y</span>.</p>

    <p class="text-gray-300"><span class="math">Q(X,Y,Z)=C(X,Z)(Y-\\gamma_{1}(X,Z))(Y-\\gamma_{2}(X,Z))\\cdots(Y-\\gamma_{D}(X,Z)).</span> (2.1)</p>

    <p class="text-gray-300">This is natural to do, because we are searching for factors that are linear in <span class="math">Y</span>. Then we substitute <span class="math">Z=z</span> into this, and we should see <span class="math">P_{z}(X)</span> as one of the factors.</p>

    <p class="text-gray-300">However, getting such a factorization for <span class="math">Q(X,Y,Z)</span> may not be possible with polynomials <span class="math">\\gamma_{i}(X,Z)</span>, and we have to look (far) beyond. What kind of objects should we think of the <span class="math">\\gamma_{i}</span> as? After getting the <span class="math">\\gamma_{i}(X,Z)</span>, we would like to (a) argue about when <span class="math">\\gamma_{i}(X,Z)</span> is a polynomial in <span class="math">X</span>, and (b) substitute <span class="math">Z=z</span> into it and inspect the resulting object. To enable these, we will express <span class="math">\\gamma_{i}(X,Z)</span> in the ring <span class="math">R=\\overline{\\mathbb{K}}[[X]]</span>, the ring of power series in <span class="math">X</span>, whose coefficients are in the algebraic closure of <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span>. The power series in <span class="math">X</span> representation allows us to see when <span class="math">\\gamma_{i}</span> is a polynomial in <span class="math">X</span>, and the coefficients being simply algebraic functions in <span class="math">Z</span> (such as <span class="math">\\sqrt{Z^{3}+Z+1}</span>) allows us to reason about substitutions <span class="math">Z=z</span>. Having decided on <span class="math">R</span>, it is a simple application of Hensel lifting (after possibly a random shift) to show that a factorization as in (2.1) is possible with the <span class="math">\\gamma_{i}\\in R</span>.</p>

    <p class="text-gray-300">Rather than describe what happens in full generality, we just sketch what would happen in a special case with most of the action. Suppose <span class="math">\\mathbb{F}_{q}</span> is not of characteristic <span class="math">2</span>, and we have:</p>

    <p class="text-gray-300"><span class="math">Q(X,Y,Z)=Y^{2}-(Z^{3}+Z+1)(1-ZX).</span></p>

    <p class="text-gray-300">Going to the ring <span class="math">R</span>, and letting <span class="math">\\alpha=\\sqrt{Z^{3}+Z+1}\\in\\overline{\\mathbb{K}}</span>, it turns out that <span class="math">Q(X,Y,Z)</span> factors as:</p>

    <p class="text-gray-300"><span class="math">Q(X,Y,Z)</span> <span class="math">=\\left(Y-\\sqrt{Z^{3}+Z+1}\\sqrt{1-ZX}\\right)\\cdot\\left(Y+\\sqrt{Z^{3}+Z+1}\\sqrt{1-ZX}\\right)</span> <span class="math">=\\left(Y-\\left(\\alpha-\\frac{\\alpha\\cdot Z}{2}X-\\frac{\\alpha\\cdot Z^{2}}{16}X^{2}+\\dots\\right)\\right)\\left(Y+\\left(\\alpha-\\frac{\\alpha\\cdot Z}{2}X-\\frac{\\alpha\\cdot Z^{2}}{16}X^{2}+\\dots\\right)\\right)</span></p>

    <p class="text-gray-300">where we used the Taylor series expansion for <span class="math">\\sqrt{1-ZX}</span>. Now substitute <span class="math">Z=z</span> for <span class="math">z\\in\\mathbb{F}_{q}</span>. Substituting values into algebraic functions like <span class="math">\\alpha</span> is a slightly delicate operation (which square root do you choose? how do you make these choices consistent for different algebraic functions?), but it can be done using basic concepts from the theory of algebraic function fields. Another tool that we need from the theory of algebraic function fields is an analogue of the degree of a polynomial, to measure complexity of algebraic functions and bound the number of their zeroes. In this sketch we avoid going into any such details.</p>

    <p class="text-gray-300">Doing the substitution gives us:</p>

    <p class="text-gray-300"><span class="math">Q_{z}(X,Y)</span> <span class="math">=Q(X,Y,z)</span> <span class="math">=\\left(Y-\\left(\\alpha(z)-\\frac{\\alpha(z)\\cdot z}{2}X+\\cdots+c_{i}\\alpha(z)z^{i}X^{i}+\\cdots\\right)\\right)\\times</span> <span class="math">\\left(Y+\\left(\\alpha(z)-\\frac{\\alpha(z)\\cdot z}{2}X+\\cdots+c_{i}\\alpha(z)z^{i}X^{i}+\\cdots\\right)\\right).</span></p>

    <p class="text-gray-300">By properties of the Guruswami–Sudan decoding algorithm, we know for all “good” <span class="math">z\\in\\mathbb{F}_{q}</span> where <span class="math">w_{z}</span> is close to some low degree polynomial <span class="math">P_{z}</span>, we must have that <span class="math">Y-P_{z}(X)</span> divides <span class="math">Q_{z}(X,Y)</span>. Given the factorization above, one of the following must occur:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{z}(X)=\\Big{(}\\alpha(z)-\\frac{\\alpha(z)\\cdot z}{2}X-\\frac{\\alpha(z)\\cdot z^{2}}{16}X^{2}+\\cdots+c_{i}\\alpha(z)z^{i}X^{i}+\\cdots\\Big{)}</span>,</li>

      <li><span class="math">P_{z}(X)=-\\Big{(}\\alpha(z)-\\frac{\\alpha(z)\\cdot z}{2}X-\\frac{\\alpha(z)\\cdot z^{2}}{16}X^{2}+\\cdots+c_{i}\\alpha(z)z^{i}X^{i}+\\cdots\\Big{)}</span>.</li>

    </ol>

    <p class="text-gray-300">Whichever power series ends up equaling <span class="math">P_{z}(X)</span>, the coefficient of <span class="math">X^{k+1}</span> in that power series must equal <span class="math">0</span>. In our particular example, we deduce that <span class="math">c_{k+1}\\alpha(z)z^{k+1}=0</span> for some constant <span class="math">c_{k+1}</span>. Assuming <span class="math">c_{k+1}</span> is nonzero in <span class="math">\\mathbb{F}_{q}</span>, we get that <span class="math">\\alpha(z)z^{k+1}=0</span> for every good <span class="math">z</span>. Finally we use the fact that a nonzero algebraic functions of low “degree” like <span class="math">\\alpha(Z)Z^{k+1}=\\sqrt{Z^{3}+Z+1}\\cdot Z^{k+1}</span> cannot vanish at too many points <span class="math">z</span>. This means that there cannot be too many good <span class="math">z</span>, contradicting our hypothesis. We conclude that <span class="math">Q(X,Y,Z)</span> cannot equal <span class="math">Y^{2}-(Z^{3}+Z+1)(1-ZX)</span>!</p>

    <p class="text-gray-300">A very similar argument derives a contradiction unless <span class="math">Q(X,Y,Z)</span> has a factor of the form <span class="math">Y-P(X)</span> for some <span class="math">P(X)\\in\\overline{\\mathbb{K}}[X]</span> of degree at most <span class="math">k</span>. The only twist is that we may have to focus on the coefficient of some different power <span class="math">X^{k+c}</span> in the power series than the coefficient of <span class="math">X^{k+1}</span> (in case the coefficient of <span class="math">X^{k+1}</span> in the power series is identically <span class="math">0</span>). To make this argument work, we need to estimate the “degree” of the algebraic functions that appear as coefficients in these power series. This involves a careful study of the Hensel lifting process, especially its effect on the complexity of its coefficients.</p>

    <p class="text-gray-300">The final part of the argument, showing that some <span class="math">Y-P(X)</span> factor of <span class="math">Q(X,Y,Z)</span> is such that <span class="math">P(X)</span> has high agreement with <span class="math">w</span> and all the coefficients of <span class="math">P(X)</span> are linear polynomials in <span class="math">Z</span>, is similar to what happened in the unique decoding case. Instead of using the fact that a low degree rational function and a linear function cannot have high agreement unless they are equal, we use the fact that a low degree algebraic function and a linear function cannot have high agreement unless they are equal. This completes our sketch of the proof.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">Technical issues</h5>

    <p class="text-gray-300">When we actually implement the argument, there are some technical changes we make (both for simplicity and for optimizing parameters). First, we do not do the proof by contradiction, but instead show how to find the factor of the form <span class="math">Y-P(X)</span>. Next, instead of directly doing Hensel lifting with <span class="math">Q</span>, we factor <span class="math">Q</span> into irreducible factors over <span class="math">\\mathbb{F}_{q}[X,Y,Z]</span> and focus on a single irreducible factor that is “responsible” for many of the <span class="math">P_{z}</span>. This helps in that we do not need to factor arbitrarily messy <span class="math">Q</span>’s completely into linear factors, but only those which have the property that <span class="math">Q(X,Y,z)</span> has a linear factor of the form <span class="math">Y-P_{z}(X)</span>. Finally, instead of arguing over the algebraic closure <span class="math">\\overline{\\mathbb{K}}</span>, we go to a small algebraic extension <span class="math">\\mathbb{L}</span> of <span class="math">\\mathbb{K}</span> which is rich enough to express all the coefficients of the relevant power series. These changes lead to some simplifications and quantitative improvements in our proofs.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Relationship with the Arora-Sudan low degree test <em>[x1]</em></h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A beautiful and fundamental paper of Arora and Sudan <em>[x1]</em>, analyzed the “line vs. line” low degree test for multivariate polynomials in the high error regime. The heart of their paper is a theorem that says that if a function <span class="math">f:\\mathbb{F}_{q}^{2}\\to\\mathbb{F}_{q}</span> is such that for most lines <span class="math">L</span> given by <span class="math">Y=aX+b</span> in <span class="math">\\mathbb{F}_{q}^{2}</span> the univariate function obtained from restricting <span class="math">f</span> to <span class="math">L</span> (denoted $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{L}<span class="math">) is close to a low degree univariate polynomial, then </span>f<span class="math"> is itself close to a low degree bivariate polynomial. This is closely related to our theorem which deduces a similar conclusion about a received word </span>w:\\mathcal{D}\\times\\mathbb{F}_{q}\\to\\mathbb{F}_{q}$, also based on restrictions to lines. Our proof is heavily influenced by the proof in <em>[x1]</em> (which in turn builds on fundamental results on</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">polynomial factorization and the Hilbert irreducibility theorem by Kaltofen <em>[x10, x11]</em>). There is one crucial difference in our proof. Our approach is spearheaded by the idea of running all arguments over the big field <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> (as opposed to treating <span class="math">Z</span> as another variable over <span class="math">\\mathbb{F}_{q}</span> just like <span class="math">X</span> and <span class="math">Y</span>, as is done in <em>[x2]</em>). This difference affects our proofs in a tangible sense: our proofs are based on bivariate interpolation over the big field <span class="math">\\mathbb{K}</span> rather than trivariate interpolation over the small field <span class="math">\\mathbb{F}_{q}</span>. Inside the analysis, our proofs use power series in one variable over function fields rather than power series in two variables over finite extensions of <span class="math">\\mathbb{F}_{q}</span>. This leads to more involved algebraic tools being needed for our proof (most seriously the use of algebraic function fields), but also yields three improvements. First, our result is about axis parallel restrictions <span class="math">Z=z</span> (for <span class="math">z\\in\\mathbb{F}_{q}</span>) instead of more general linear restrictions <span class="math">Z=aX+b</span> (for <span class="math">a,b\\in\\mathbb{F}_{q}</span>). This simpler form of restriction is important for our applications. Second, our result deduces structure all the way up to the Johnson radius, while the result in Arora-Sudan is to a smaller radius (polynomially worse in terms of agreement parameter). Third, our result works over fields that are quadratic in the degree of the polynomials involved whereas the Arora-Sudan result requires fields that are quartic (at least) in the degree.</p>

    <h2 id="sec-20" class="text-2xl font-bold">3 Applications</h2>

    <p class="text-gray-300">Our proximity gap results are motivated by the following general setting. There are several purported codewords <span class="math">\\mathbf{u}=\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{n}</span> of an RS code <span class="math">V</span>. A verifier would like to be assured that they are all close to <span class="math">V</span>. This is done by taking a random linear combination of the <span class="math">u_{i}</span> and checking its proximity to <span class="math">V</span>. The analysis of this simple test, which is useful in a variety of application scenarios, turns out to be surprisingly challenging. Indeed, it is closely related to the proximity gap problem we study in this work.</p>

    <p class="text-gray-300">This batch verification problem arises in two kinds of settings: a distributed setting, where entries of <span class="math">\\mathbf{u}</span> are split between multiple parties (“servers”) and may not be known to any single entity, and a centralized setting, where <span class="math">\\mathbf{u}</span> is entirely known to a prover and can be queried by a verifier. We briefly explain the role of proximity gaps in these two types of applications.</p>

    <p class="text-gray-300">In the distributed setting, the coefficients of the random linear combination is either generated by a single verifier or jointly via a distributed coin tossing protocol. Each server then responds with its own share of the output. Verification succeeds if the joint output is a codeword, or alternatively it is close to the code. Examples for applications in the distributed setting include verifiable secret sharing (see Section 8.1) and secure multiparty computation protocols, such as those from <em>[x13, x14]</em>. These applications typically rely on unique decoding and can thus benefit from our near-optimal analysis for this regime. In this type of applications, the main challenge is protecting against an adaptive adversary who may choose which servers to corrupt after seeing the coefficients of the random linear combination. To defeat such an adversary, we need to ensure that if at least one of the <span class="math">u_{i}</span> is far from the code, then (with high probability) so is their random linear combination. If this were not the case, an adaptive adversary could eliminate all inconsistencies by corrupting a small set of servers whose identity is determined by the linear combination. Proximity gaps rule out this kind of attack.</p>

    <p class="text-gray-300">In the centralized setting, <span class="math">\\mathbf{u}</span> is known to a prover and can be queried by the verifier. A typical realization is using a tree-based succinct cryptographic commitment that binds the prover to a uniquely defined <span class="math">\\mathbf{u}</span> and yet enables efficient local opening of symbols queried by the verifier. In this case, the verifier challenges the prover by choosing the coefficients <span class="math">r_{i}</span> of the random linear combination. The prover, who claims that all <span class="math">u_{i}</span> are codewords in <span class="math">V</span>, must respond with a valid codeword <span class="math">u\\in V</span>. The verifier checks that <span class="math">u</span> agrees with <span class="math">u^{\\prime}=r_{1}u_{1}+\\ldots+r_{l}u_{l}</span> by querying a random</p>

    <p class="text-gray-300">entry of <span class="math">u</span> and the corresponding entries of <span class="math">\\mathbf{u}</span> and checking their consistency. (To amplify soundness, the verifier can query several random entries of <span class="math">u</span>.) Here too, proximity gaps guarantee that if one of the <span class="math">u_{i}</span> is far from <span class="math">V</span>, then (with high probability) so is <span class="math">u^{\\prime}</span>. This ensures that the verifier detects an inconsistency with high probability. Examples for applications in the centralized setting include communication-efficient proof systems <em>[x21, x1, x3, x11]</em>, homomorphic commitment schemes <em>[CDD^{+}16]</em>, and secure two-party computation protocols <em>[x15, x16]</em>. See more in Section 3.2 below.</p>

    <p class="text-gray-300">An appealing feature of the simple “random linear combination” test is that it can be implemented with low communication and computation costs. In particular, in the distributed setting it suffices for each server to send a single field element to the verifier. In both settings, communicating the <span class="math">l</span> random coefficients <span class="math">r_{i}</span> is typically not a bottleneck. This random challenge can be made shorter either by using a cryptographic pseudorandom generator or unconditionally by using simple derandomization techniques. In particular, one can generate all coefficients as distinct powers of a single random field elements and appeal to the parameterized curves variant of the proximity gap theorem (Theorem 1.5).</p>

    <p class="text-gray-300">Our new proximity gaps imply a tighter analysis of applications that test proximity to RS codes. Generally speaking, in the distributed setting the improved proximity gap bounds imply a constant-factor improvement in the resilience threshold, namely the number of corrupted parties that can be tolerated. In the centralized setting, one typically gets constant-factor savings in the overall communication and computation costs. While often ignored in theory-oriented research, the latter kind of improvements can be very significant in the context of practical succinct proof systems.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Why RS codes?</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reed–Solomon codes are commonly used in distributed storage, efficient proof systems, and cryptographic protocols. They are useful because of their MDS property, near-linear encoding, and efficient (list)-decoding algorithms. A more qualitative feature of RS codes, which is commonly used in proof systems and cryptography, is the following multiplication-friendliness property: when $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2k<span class="math">, the pointwise products of codewords in </span>V=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]<span class="math"> span a linear code that has nontrivial minimal distance, namely the code </span>\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},2k]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now give more concrete examples of applying proximity gaps to analyze batch-verification tasks that arise in different application scenarios.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.1 Distributed storage and cryptography</h3>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Distributed storage.</h5>

    <p class="text-gray-300">Consider a scenario in which <span class="math">l</span> users encode their inputs using a length-<span class="math">n</span> RS code <span class="math">V=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span>, where server <span class="math">i</span> stores the <span class="math">i</span>-th symbol of each of the <span class="math">l</span> codewords. Suppose that some of the <span class="math">nl</span> symbols were corrupted, say by a transient malware that overwrites a subset of the symbols before being discovered and eliminated. A verifier would like to get a quick estimate of the amount of damage caused by the malware. A natural idea is to have the servers communicate a random linear combination <span class="math">u^{\\prime}</span> of the potentially corrupted codewords <span class="math">u_{j}</span>. Using the basic proximity gap result (Theorem 1.2), if at least one of <span class="math">u_{j}</span> is <span class="math">\\delta</span>-far from the code (for <span class="math">\\delta\\leq\\frac{1-\\rho}{2}</span> or <span class="math">\\delta&lt;1-\\sqrt{\\rho}</span>), then <span class="math">u^{\\prime}</span> is <span class="math">\\delta</span>-far from the code except with small failure probability (at most <span class="math">n/q</span> for <span class="math">\\delta\\leq\\frac{1-\\rho}{2}</span>). Thus, for sufficiently large <span class="math">\\mathbb{F}_{q}</span>, the distance of <span class="math">u^{\\prime}</span> from <span class="math">V</span> provides a reliable upper bound on the maximal relative distance of a vector <span class="math">u_{i}</span> from <span class="math">V</span> within the proximity bounds of Theorem 1.2. This estimate is not too pessimistic in the sense that if only a <span class="math">\\mu</span>-fraction of the servers were affected, the upper bound obtained by the test is no bigger than <span class="math">\\mu</span>.</p>

    <p class="text-gray-300">#####</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Distributed proximity test for Interleaved RS codes.</h4>

    <p class="text-gray-300">The above analysis leaves something to be desired: if <span class="math">u^{\\prime}</span> is within (sufficiently small) distance <span class="math">\\delta</span> from <span class="math">V</span>, the verifier is only assured that each <span class="math">u_{j}</span> is individually within distance <span class="math">\\delta</span> from <span class="math">V</span>. In some applications, we would like to get the stronger guarantee that in such an event there is a <span class="math">\\delta</span>-fraction of the coordinates whose removal makes all <span class="math">u_{j}</span> consistent with <span class="math">V</span>. Moreover, we would like to identify this set of coordinates, which is uniquely defined in the unique decoding regime. This is useful even in the above distributed storage scenario, but will be even more useful for the applications we discuss next. The stronger feature can be conveniently captured using the notion of an Interleaved Reed–Solomon (IRS) code. In an IRS<span class="math">(V,l)</span> code, the codewords are <span class="math">l\\times n</span> matrices in which each row is a codeword in <span class="math">V</span>. The symbols of such a codeword are the matrix columns. Namely, a codeword consists of <span class="math">n</span> symbols in <span class="math">\\mathbb{F}_{q}^{\\ell}</span>. The following theorem, which follows easily from Theorem 1.6, phrases the stronger guarantee provided by the refined analysis in terms of proximity testing for IRS codes. We state it for the unique decoding regime, which suffices (and is sometimes required) for the applications we discuss next. For <span class="math">u</span> within the unique decoding radius of <span class="math">V</span>, we denote by <span class="math">\\Gamma(u,V)</span> the set of coordinates on which <span class="math">u</span> disagrees with the closest codeword from <span class="math">V</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 3.1 (Distributed proximity test for Interleaved RS codes).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math"> and </span>\\mathbf{V}=\\mathrm{IRS}(V,l)<span class="math">. We view codewords in </span>V<span class="math"> and </span>\\mathbf{V}<span class="math"> as vectors in </span>\\mathbb{F}_{q}^{n}<span class="math"> and matrices in </span>\\mathbb{F}_{q}^{l\\times n}<span class="math"> respectively. Let </span>\\rho=\\frac{k+1}{n}<span class="math"> and </span>\\delta\\leq\\frac{1-\\rho}{2}<span class="math">. Let </span>\\mathbf{u}\\in\\mathbb{F}_{q}^{l\\times n}<span class="math"> and let </span>u^{\\prime}=r^{T}\\mathbf{u}<span class="math"> where </span>r\\in_{R}\\mathbb{F}_{q}^{l}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: If <span class="math">\\Delta(\\mathbf{u},\\mathbf{V})\\leq\\delta</span> then <span class="math">\\Pr[\\Delta(u^{\\prime},V)\\leq\\delta]=1</span> and moreover <span class="math">\\Pr[\\Gamma(u^{\\prime},V)\\neq\\Gamma(\\mathbf{u},\\mathbf{V})]\\leq n/q</span>.</li>

      <li>Soundness: If <span class="math">\\Delta(\\mathbf{u},\\mathbf{V})&gt;\\delta</span> then <span class="math">\\Pr[\\Delta(u^{\\prime},V)\\leq\\delta]\\leq n/q</span>.</li>

    </ul>

    <p class="text-gray-300">We refer to the above test as distributed because it can be implemented with low communication complexity in the distributed setting, where each server holds a different column of <span class="math">\\mathbf{u}</span>. One can similarly obtain an affine version with the same guarantee, where <span class="math">\\mathbf{u}</span> has an additional row <span class="math">u_{0}</span> that is always added to <span class="math">u^{\\prime}</span> (i.e., with coefficient <span class="math">r_{0}=1</span>), and the code <span class="math">\\mathbf{V}</span> is extended to IRS<span class="math">(V,l+1)</span>. This affine version is useful for zero-knowledge variants of the test, where a single random <span class="math">u_{0}\\in V</span> is used for blinding <span class="math">u_{1},\\ldots,u_{l}</span>. This is used in the cryptographic applications we discuss next.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">General cryptographic protocols.</h4>

    <p class="text-gray-300">Theorem 3.1 serves as a useful tool for analyzing cryptographic protocols in the presence of an adaptive adversary who can dynamically choose the set of corrupted parties. For instance, it shows that secure multiparty computation protocols from <em>[x13, x21]</em> are adaptively secure when the adversary can corrupt roughly <span class="math">1/3</span> of the parties. The best previous proximity gaps from <em>[x33, x1, x5]</em> could only get up to <span class="math">1/4</span> corruption threshold in the same setting. Adaptive security, in turn, is crucial for the general transformation from <em>[x22, x23]</em> of these honest-majority protocols to two-party protocols and protocols for dishonest majority. Indeed, this is the context that gave rise to proximity gap in the analysis of the Ligero zero-knowledge proof system <em>[x1]</em>, which applies a variant of the transformation from <em>[x22]</em> to a variant of the protocol from <em>[x13]</em>. We give a detailed exposition of the application of proximity gaps to verifiable secret sharing, which serves as a basis for the above results on secure multiparty computation, in Section 8.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.2 Soundness of the Fast RS IOPP (FRI) protocol</h3>

    <p class="text-gray-300">FRI is an Interactive Oracle Proof of Proximity (IOP of Proximity, or IOPP) as defined in <em>[x34, x6]</em>. An IOP is an interactive protocol in which the verifier has oracle access to messages sent</p>

    <p class="text-gray-300">by the prover, so she need not read and store those messages but may query random entries of them. FRI is one of a family of protocols for testing proximity to the RS code (an “RS proximity testing” (RPT) protocol). Its purpose is to check whether a received word <span class="math">f:\\mathcal{D}\\to\\mathbb{F}_{q}</span> belongs to a pre-specified RS code <span class="math">V:=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]</span> and to reject words that are <span class="math">\\delta</span>-far from the code with high probability and low query complexity. Due to its efficiency it is used as a building block in several recent succinct zero knowledge protocols including scalable and transparent (public coins) arguments of knowledge (STARKs) <em>[x1, x2]</em>, Aurora <em>[BCR^{+}18]</em> and its succinct version <em>[BCG^{+}19]</em>, and Fractal <em>[x10]</em>, to name a few. These systems have been shown by Chiesa et al. to be sound in the quantum random oracle model (hence are “plausibly post-quantum secure”) <em>[x9]</em>. Therefore, understanding the concrete soundness error of FRI, denoted <span class="math">\\epsilon_{\\mathsf{FRI}}</span>, is of significant practical value, in addition to being a theoretically interesting question.</p>

    <p class="text-gray-300">Consider the case of <span class="math">f</span> that is maximally far from <span class="math">V</span>, i.e., <span class="math">\\Delta(f,V)\\approx 1-\\rho</span> (this holds, e.g., for random <span class="math">f</span>, with high probability). Fix a target soundness error bound <span class="math">2^{-\\lambda}</span> (in concrete settings, <span class="math">\\lambda</span> is the “security parameter”, often fixed to <span class="math">\\lambda=128</span>). The communication complexity of FRI is dominated by the number <span class="math">t</span> of iterations of the QUERY phase, so the question at hand is:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><em>How many iterations <span class="math">t</span> of the QUERY phase are needed to obtain <span class="math">\\epsilon_{\\mathsf{FRI}}\\leq 2^{-\\lambda}</span>?</em></p>
    </blockquote>

    <p class="text-gray-300">The initial analysis of <em>[x1]</em> required a number <span class="math">t</span> that is quite large, and does not tend to <span class="math">0</span> even for tiny rates <span class="math">\\rho</span>. This was improved by <em>[x5]</em> to <span class="math">t\\approx 4\\lambda/\\log\\frac{1}{\\rho}</span>, and then by <em>[x4]</em> to <span class="math">t\\approx 3\\lambda/\\log\\frac{1}{\\rho}</span>. Sadly, that paper also showed that this bound is tight, at least when the field size <span class="math">q</span> equals the code’s blocklength <span class="math">n</span>. Our main result regarding FRI (Theorem 8.3) shows that for <span class="math">q\\gg n^{2}</span> we can reduce the number <span class="math">t</span> of iterations by <span class="math">33\\%</span> to <span class="math">t\\approx 2\\lambda/\\log\\frac{1}{\\rho}</span>, which leads to communication complexity that is at least <span class="math">33\\%</span> shorter, for provable soundness settings. The actual savings in the provable soundness case are likely larger, due to smaller field size and the ability of the improved analysis to operate with any sequence of oracle sizes in the FRI COMMIT phase (as discussed after the statement of Theorem 8.3).</p>

    <h2 id="sec-28" class="text-2xl font-bold">4 Correlated Agreement over Lines — Unique Decoding Radius</h2>

    <p class="text-gray-300">In this section we prove the correlated agreement result for proximity parameters that are below the unique decoding radius, corresponding to the <span class="math">\\epsilon=\\epsilon_{\\mathsf{U}}</span> part of Theorem 1.4. In this case, where <span class="math">\\delta\\in\\left(0,\\frac{1-\\rho}{2}\\right]</span>, our result holds even with fields that are merely <em>linear</em> in the blocklength of the code. More importantly, the proof will present several ideas, in simplified form, that will appear again in the proof of harder, list decoding regime, result (Theorem 5.1).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As usual, let <span class="math">\\mathbb{F}_{q}</span> be the finite field of size <span class="math">q</span>, let <span class="math">\\mathcal{D}\\subseteq\\mathbb{F}_{q}</span> be an evaluation domain of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, let </span>k\\leq n<span class="math">, and let </span>V=\\mathsf{RS}[\\mathbb{F}_{q},\\mathcal{D},k]<span class="math"> be the Reed–Solomon code of rate </span>\\rho=\\frac{k+1}{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 4.1.</h6>

    <p class="text-gray-300">Suppose <span class="math">\\delta\\leq(1-\\rho)/2</span>. Let <span class="math">u_{0},u_{1}:\\mathcal{D}\\to\\mathbb{F}_{q}</span> be functions. Let</p>

    <p class="text-gray-300"><span class="math">S=\\{z\\in\\mathbb{F}_{q}:\\Delta(u_{0}+zu_{1},V)\\leq\\delta\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>n<span class="math">. Then </span>S=\\mathbb{F}_{q}<span class="math">. Furthermore there are </span>v_{0},v_{1}\\in V<span class="math"> such that for all </span>z\\in\\mathbb{F}_{q}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Delta(u_{0}+zu_{1},v_{0}+zv_{1})\\leq\\delta</span></p>

    <p class="text-gray-300">and in fact</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathcal{D}:(u_{0}(x),u_{1}(x))\\neq(v_{0}(x),v_{1}(x))\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-30" class="text-base font-medium mt-4">Remark 4.1.</h6>

    <p class="text-gray-300">Since <span class="math">\\delta\\leq\\frac{1-\\rho}{2}</span> is within the unique decoding regime, the above <span class="math">v_{0},v_{1}</span>, which are simultaneously and separately <span class="math">\\delta</span>-close to <span class="math">u_{0},u_{1}</span>, are also unique.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">4.1 The Berlekamp–Welch decoder</p>

    <p class="text-gray-300">Our proof will be based on the Berlekamp–Welch decoding algorithm. Let <span class="math">\\mathbb{F}</span> be a (general) field and <span class="math">\\mathcal{D}\\subseteq\\mathbb{F}</span>. For an integer <span class="math">k</span>, consider the Reed–Solomon code <span class="math">V=\\mathsf{RS}[\\mathbb{F},\\mathcal{D},k]</span>. We will be instantiating the Berlekamp–Welch decoder for RS codes over two different fields: the “standard” field <span class="math">\\mathbb{F}_{q}</span> and the field of rational functions <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> in the formal variable <span class="math">Z</span>. We now give a quick description of the Berlekamp–Welch decoding algorithm and some useful aspects of it.</p>

    <p class="text-gray-300">Given a received word <span class="math">w:\\mathcal{D}\\to\\mathbb{F}</span>, where <span class="math">\\mathcal{D}\\subseteq\\mathbb{F}</span>, and an error parameter <span class="math">e=\\lfloor\\delta n\\rfloor\\leq\\frac{n-k-1}{2}</span>, the Berlekamp–Welch decoder finds the unique (if any) polynomial <span class="math">P(X)\\in\\mathbb{F}[X]</span> such that <span class="math">\\Delta(w,P)\\leq e</span>.</p>

    <p class="text-gray-300">The first step of the Berlekamp–Welch decoder is to set up a a homogeneous system of linear equations to find polynomials <span class="math">A(X),B(X)\\in\\mathbb{F}[X]</span> with <span class="math">\\deg(A)\\leq e</span>, <span class="math">\\deg(B)\\leq k+e</span> such that:</p>

    <p class="text-gray-300"><span class="math">A(x)w(x)=B(x)</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\mathcal{D}</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 4.2.</h6>

    <p class="text-gray-300">The homogeneous system of linear equations above has the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\Delta(w,V)\\leq\\delta</span>. Then the system of equations has a nonzero solution.</li>

      <li>Suppose <span class="math">\\Delta(w,V)\\leq\\delta</span>. Then for any nonzero solution <span class="math">A(X)</span>, <span class="math">B(X)</span> to the system of equations, we have that <span class="math">A(X)</span> divides <span class="math">B(X)</span> (in <span class="math">\\mathbb{F}[X]</span>), and furthermore the element of <span class="math">V</span> which realizes the distance is <span class="math">B(X)/A(X)</span>.</li>

      <li>If <span class="math">A(X),B(X)</span> is a nonzero solution to the system of equations such that <span class="math">A(X)</span> divides <span class="math">B(X)</span> (in <span class="math">\\mathbb{F}[X]</span>), then the polynomial <span class="math">P(X)=B(X)/A(X)</span> has the property that <span class="math">\\Delta(w,P)\\leq\\delta</span>.</li>

    </ol>

    <p class="text-gray-300">These properties above are well known and we omit the proof.</p>

    <p class="text-gray-300">Note that in our setting we have <span class="math">k+2e&lt;n</span>. This may seem to be off if one is used to seeing the condition <span class="math">k+2e\\leq n</span>. The difference is that we use <span class="math">k</span> here to denote the degree of the polynomials rather than the dimension of the code, and they are indeed off by <span class="math">1</span> from each other.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.2 The Polishchuk–Spielman lemma</h3>

    <p class="text-gray-300">Another ingredient that will appear in our proof is a version of the Polishchuk–Spielman lemma <em>[x20]</em>. The version we state below is a variation of <em>[x22, Lemma 4.2.18]</em>, with some differences in the precise conditions, and we include a derivation in Appendix D.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Lemma 4.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a field, and let <span class="math">a_{X},a_{Z},b_{X},b_{Z},d_{X},d_{Z},n_{X},n_{Z}</span> be non-negative integers satisfying <span class="math">d_{X}=b_{X}-a_{X}</span>, <span class="math">d_{Z}=b_{Z}-a_{Z}</span>. Let <span class="math">A(X,Z),B(X,Z)\\in\\mathbb{F}[X,Z]</span> be polynomials with degrees bounded by</p>

    <p class="text-gray-300"><span class="math">\\deg_{X}(A)\\leq a_{X},\\quad\\deg_{X}(B)\\leq b_{X},\\quad\\deg_{Z}(A)\\leq a_{Z},\\quad\\deg_{Z}(B)\\leq b_{Z}.</span></p>

    <p class="text-gray-300">Suppose that for at least <span class="math">n_{X}</span> values of <span class="math">x\\in\\mathbb{F}</span>, there exist polynomials <span class="math">P_{Z,x}(Z)\\in\\mathbb{F}[Z]</span> with <span class="math">\\deg_{Z}(P_{Z,x})\\leq d_{Z}</span> such that <span class="math">B(x,Z)=P_{Z,x}(Z)A(x,Z)</span>, and similarly suppose that for at least <span class="math">n_{Z}</span> values of <span class="math">z\\in\\mathbb{F}</span>, there exist polynomials <span class="math">P_{X,z}(X)\\in\\mathbb{F}[X]</span> with <span class="math">\\deg_{X}(P_{X,z})\\leq d_{X}</span> such that <span class="math">B(X,z)=P_{X,z}(X)A(X,z)</span>.</p>

    <p class="text-gray-300">Finally, suppose</p>

    <p class="text-gray-300"><span class="math">\\frac{b_{X}}{n_{X}}+\\frac{b_{Z}}{n_{Z}}&lt;1.</span> (<span class="math">\\star</span>)</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">If all conditions hold, then <span class="math">A(X,Z)\\mid B(X,Z)</span> as polynomials in <span class="math">\\mathbb{F}_{q}[X,Z]</span>. Furthermore, the quotient <span class="math">P(X,Z)=\\frac{B(X,Z)}{A(X,Z)}</span> satisfies <span class="math">\\deg_{X}(P)\\leq d_{X},\\deg_{Z}(P)\\leq d_{Z}</span>, as well as <span class="math">P(X,z)=P_{X,z}(X)</span> for at least <span class="math">n_{Z}-a_{Z}</span> values of <span class="math">z</span>, and <span class="math">P(x,Z)=P_{Z,x}(Z)</span> for at least <span class="math">n_{X}-a_{X}</span> values of <span class="math">x</span>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">4.3 Proof of Theorem 4.1</h3>

    <p class="text-gray-300">By definition of <span class="math">S</span>, for each <span class="math">z\\in S</span>, we have a polynomial <span class="math">P_{z}(X)\\in\\mathbb{F}_{q}[X]</span> with <span class="math">\\deg(P_{z})\\leq k</span> such that <span class="math">\\Delta(u_{0}+zu_{1},P_{z})\\leq\\delta</span>.</p>

    <p class="text-gray-300">Our strategy is to run the Berlekamp–Welch decoder over the field <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> of rational functions in the formal variable <span class="math">Z</span>.</p>

    <p class="text-gray-300">First define a received word</p>

    <p class="text-gray-300"><span class="math">w:\\mathcal{D}\\to\\mathbb{K}</span></p>

    <p class="text-gray-300">given by:</p>

    <p class="text-gray-300"><span class="math">w(x)=u_{0}(x)+Zu_{1}(x).</span></p>

    <p class="text-gray-300">We sometimes also use the notation <span class="math">w(x,Z)</span> to denote <span class="math">u_{0}(x)+Zu_{1}(x)</span>.</p>

    <p class="text-gray-300">We will try to find a polynomial <span class="math">P(X,Z)\\in\\mathbb{F}_{q}[X,Z]</span> of the form <span class="math">P(X,Z)=v_{0}(X)+Zv_{1}(X)</span>, where <span class="math">\\deg_{X}(P)\\leq k</span>, such that</p>

    <p class="text-gray-300"><span class="math">P(x,Z)=w(x)</span></p>

    <p class="text-gray-300">for at least <span class="math">n-e</span> choices of <span class="math">x\\in\\mathcal{D}</span>.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">4.3.1 Step 1: Finding <span class="math">A(X,Z),B(X,Z)</span></h4>

    <p class="text-gray-300">The first step of the Berlekamp–Welch algorithm is to find nonzero <span class="math">A(X,Z),B(X,Z)\\in\\mathbb{K}[X]</span> of degrees <span class="math">\\leq e</span> and <span class="math">\\leq k+e</span> (in the variable <span class="math">X</span>) respectively such that</p>

    <p class="text-gray-300"><span class="math">A(x,Z)w(x)=B(x,Z)</span> (4.1)</p>

    <p class="text-gray-300">for all <span class="math">x\\in\\mathcal{D}</span>, where <span class="math">e=\\lfloor\\delta n\\rfloor</span> as before. Setting this up as a homogeneous linear system over <span class="math">\\mathbb{K}</span>, we get an <span class="math">n\\times(k+2e+2)</span> matrix <span class="math">M(Z)</span> with entries being polynomials in <span class="math">Z</span>, of degree <span class="math">\\leq 1</span> for the <span class="math">e+1</span> columns of the <span class="math">A</span>-variables, and degree <span class="math">0</span> for the <span class="math">k+e+1</span> columns of the <span class="math">B</span> variables. Explicitly, in the row corresponding to <span class="math">x\\in\\mathcal{D}</span>, the entry of <span class="math">M(Z)</span> corresponding to the coefficient of <span class="math">A_{i}(Z)</span> is <span class="math">u_{0}(x)x^{i}+u_{1}(x)x^{i}Z</span>, and the entry corresponding to the coefficient of <span class="math">B_{i}(Z)</span> is simply <span class="math">x^{i}</span>.</p>

    <p class="text-gray-300">We now show that <span class="math">M(Z)</span> has rank <span class="math">&lt;k+2e+2</span> over <span class="math">\\mathbb{K}</span>. Fix any <span class="math">(k+2e+2)\\times(k+2e+2)</span> minor of <span class="math">M(Z)</span>, and consider its determinant <span class="math">R(Z)\\in\\mathbb{F}_{q}[Z]</span>. We will show that <span class="math">R(Z)=0</span>. This then implies that <span class="math">M(Z)</span> has rank <span class="math">&lt;k+2e+2</span> over <span class="math">\\mathbb{K}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">z\\in S</span>, consider <span class="math">M(z)</span>. This is the homogeneous linear system that arises when we run the Berlekamp–Welch decoder with received word <span class="math">u_{0}+zu_{1}\\in\\mathbb{F}_{q}^{n}</span> over the field <span class="math">\\mathbb{F}_{q}</span>. By definition of <span class="math">S</span> we know that <span class="math">\\Delta(u_{0}+zu_{1},V)\\leq\\delta</span>, and so Item 1 of Lemma 4.2 tells us that this linear system has a nonzero solution. Therefore <span class="math">M(z)</span> has rank <span class="math">&lt;k+2e+2</span>. Thus for each <span class="math">z\\in S</span>, <span class="math">R(z)=0</span>. Now notice that <span class="math">\\deg(R)\\leq e+1</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>e+1<span class="math">, we conclude that </span>R(Z)=0$ formally, as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now know that the system of equations <span class="math">M(Z)</span> has a non-trivial solution, with <span class="math">A_{i}(Z),B_{i}(Z)\\in\\mathbb{F}_{q}(Z)</span>. We wish to show that in particular there is a solution in which <span class="math">A_{i}(Z),B_{i}(Z)</span> are not just rational functions, but polynomials of bounded <span class="math">Z</span>-degree. To do so, focus on some <span class="math">r\\times r</span> non-singular submatrix, where <span class="math">r</span> is the matrix’s rank. As we have show <span class="math">r&lt;k+2e+2</span>, we can also choose another <span class="math">r+1</span>-th column to be a “free variable”. Then we can find a unique solution to the <span class="math">r\\times r</span> system, where the free variable is set to <span class="math">1</span>, and all variables outside the chosen <span class="math">r+1</span> vanish. This solution will the necessarily satisfy the entire system of equations, since <span class="math">r</span> was the full rank (and so every other relation is a linear combination of the <span class="math">r</span> rows we chose). Cramer’s rule shows this solution is given</p>

    <p class="text-gray-300">up to signs) by ratios of <span class="math">r\\times r</span> determinants, with the denominator always being the determinant of our chosen <span class="math">r\\times r</span> matrix, and the numerators being the determinants of this matrix with one of its columns replaced by the “free variable” column. We clear out the common denominator by simply assigning it to the free variable instead of the previous assignment of <span class="math">1</span>, and replacing each ratio with only its numerator. This gives us a homogenous form of Cramer’s rule. Note that by the non-singularity assumption, the determinant assigned to the “free” variable must have been non-zero, so this is a non-zero solution.</p>

    <p class="text-gray-300">To summarize, we find that there exists a non-zero solution to the matrix where each variable is either <span class="math">0</span>, or given by some determinant of a square <span class="math">r\\times r</span> submatrix—notably, one from which the column corresponding to that particular variable is excluded. Such determinants will all be polynomials in <span class="math">Z</span>, and their degree is bounded by how many of its columns are attached to <span class="math">A</span> variables. It follows that <span class="math">\\deg B_{i}(Z)\\leq e+1</span>, <span class="math">\\deg A_{i}(Z)\\leq e</span>, as there are only <span class="math">e+1</span> degree <span class="math">1</span> columns, and for the <span class="math">A</span> variables at least one is excluded.</p>

    <p class="text-gray-300">Writing now <span class="math">A(X,Z)=\\sum_{i=0}^{e}A_{i}(Z)X^{i}</span>, <span class="math">B(X,Z)=\\sum_{i=0}^{k+e}B_{i}(Z)X^{i}</span>, we find that <span class="math">A(X,Z),B(X,Z)\\in\\mathbb{F}_{q}[X,Z]</span> are polynomials with <span class="math">\\deg_{Z}(A)\\leq e</span>, <span class="math">\\deg_{Z}(B)\\leq e+1</span>, <span class="math">\\deg_{X}(A)\\leq e</span>, <span class="math">\\deg_{X}(B)\\leq k+e</span> and:</p>

    <p class="text-gray-300"><span class="math">A(x,Z)w(x)=B(x,Z)</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\mathcal{D}</span>. Using our alternate notation for <span class="math">w</span>, we get:</p>

    <p class="text-gray-300"><span class="math">A(x,Z)w(x,Z)=B(x,Z)</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\mathcal{D}</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">4.3.2 Step 2: Dividing <span class="math">B(X,Z)</span> by <span class="math">A(X,Z)</span> in <span class="math">\\mathbb{F}_{q}[X,Z]</span></h4>

    <p class="text-gray-300">Now if <span class="math">z\\in S</span>, we know that the function <span class="math">w(\\cdot,z):\\mathcal{D}\\to\\mathbb{F}_{q}</span> has distance <span class="math">\\leq e</span> from <span class="math">V</span>. Consider the Berlekamp–Welch system of linear equations associated with this received word: namely, we consider the space of all pairs of polynomials <span class="math">E(X),F(X)</span> of degrees <span class="math">\\leq e,\\leq k+e</span> respectively, such that</p>

    <p class="text-gray-300"><span class="math">E(x)w(x,z)=F(x)</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\mathcal{D}</span>. We see that any solution <span class="math">E(X),F(X)</span> of this system falls into one of two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">E(X)=0</span>, in which case <span class="math">F(x)=0</span> for all <span class="math">x\\in\\mathcal{D}</span>, and so <span class="math">F(X)=0</span> too.</li>

      <li><span class="math">E(X)</span> is nonzero, in which case Item 2 of Lemma 4.2 tells us that <span class="math">E(X)</span> divides <span class="math">F(X)</span>, and <span class="math">\\frac{F(X)}{E(X)}=P_{z}(X)</span>.</li>

    </ul>

    <p class="text-gray-300">In both these cases, <span class="math">E(X)</span> divides <span class="math">F(X)</span>, and <span class="math">F(X)=P_{z}(X)E(X)</span>. For any <span class="math">z\\in S</span>, <span class="math">A(X,z),B(X,z)</span> are polynomials that satisfy the properties of <span class="math">E,F</span> above, thus <span class="math">B(X,z)=P_{z}(X)A(X,z)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">a_{X}=a_{Z}=e</span>, <span class="math">b_{X}=k+e</span>, <span class="math">b_{Z}=e+1</span>, <span class="math">d_{X}=k</span>, <span class="math">d_{Z}=1</span>, <span class="math">n_{X}=n</span> and $n_{Z}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>1<span class="math">. We’ve seen that </span>B(x,Z)=w(x,Z)A(x,Z)<span class="math"> with </span>w(x,Z)<span class="math"> of degree at most </span>d_{Z}=1<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n_{X}<span class="math"> values of </span>x<span class="math">, and </span>B(X,z)=P_{z}(X)A(X,z)<span class="math"> with </span>P_{z}(X)<span class="math"> of degree at most </span>d_{X}=k<span class="math"> for </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n_{Z}<span class="math"> values of </span>z<span class="math">. The </span>X<span class="math"> and </span>Z<span class="math"> degrees of </span>A<span class="math"> and </span>B<span class="math"> are bounded by </span>a_{X},a_{Z},b_{X},b_{Z}$, and finally</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{b_{X}}{n_{X}}+\\frac{b_{Z}}{n_{Z}}=\\frac{k+e}{n}+\\frac{e+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{k+2e+1}{n}\\leq 1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">we may therefore apply the Polishchuk–Spielman lemma 4.3. We find that <span class="math">A(X,Z)</span> divides <span class="math">B(X,Z)</span> in <span class="math">\\mathbb{F}_{q}[X,Z]</span>, and the quotient <span class="math">P(X,Z)=B(X,Z)/A(X,Z)</span> is of degree at most <span class="math">d_{Z}=1</span> in <span class="math">Z</span> and</p>

    <p class="text-gray-300"><span class="math">d_{X}=k</span> in <span class="math">X</span>, and so can be written as <span class="math">v_{0}(X)+Zv_{1}(X)</span>, where <span class="math">v_{0},v_{1}</span> are of degree at most <span class="math">k</span>. Furthermore the lemma implies that</p>

    <p class="text-gray-300"><span class="math">v_{0}(x)+Zv_{1}(x)=P(x,Z)=w(x,Z)=u_{0}(x)+Zu_{1}(x)</span></p>

    <p class="text-gray-300">for at least <span class="math">n_{X}-a_{X}=n-e=\\lceil n(1-\\delta)\\rceil</span> values of <span class="math">x\\in\\mathcal{D}</span>. Thus</p>

    <p class="text-gray-300"><span class="math">\\Delta(u_{0}+Zu_{1},v_{0}+Zv_{1})\\leq\\delta</span></p>

    <p class="text-gray-300">as claimed. This completes the proof of Theorem 4.1. ∎</p>

    <h2 id="sec-37" class="text-2xl font-bold">5 Correlated Agreement over Lines — List Decoding Radius</h2>

    <p class="text-gray-300">In this section we prove the large distance part of the correlated agreement theorem (Theorem 1.4), corresponding to larger proximity parameters <span class="math">\\delta\\in\\left(\\frac{1-\\rho}{2},1-\\sqrt{\\rho}\\right)</span>. First, we state the theorem in a slightly different form that will be easier to work with.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">u_{0},u_{1}:\\mathcal{D}\\to\\mathbb{F}_{q}</span>, let <span class="math">m\\geq 3</span>, define</p>

    <p class="text-gray-300"><span class="math">\\delta_{0}(\\rho,m)\\coloneqq 1-\\sqrt{\\rho}-\\frac{\\sqrt{\\rho}}{2m},</span> (5.1)</p>

    <p class="text-gray-300">and let <span class="math">\\delta\\leq\\delta_{0}(\\rho,m)</span>. Define</p>

    <p class="text-gray-300"><span class="math">S=\\{z\\in\\mathbb{F}_{q}:\\Delta(u_{0}+zu_{1},V)\\leq\\delta\\}</span> (5.2)</p>

    <p class="text-gray-300">and suppose</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{(1+\\frac{1}{2m})^{7}m^{7}}{3\\rho^{3/2}}\\,n^{2}.$ (5.3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then <span class="math">u_{0},u_{1}</span> are simultaneously <span class="math">\\delta</span>-close to <span class="math">V</span>, i.e. <span class="math">\\exists v_{0},v_{1}\\in V</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathcal{D}:(u_{0}(x),u_{1}(x))=(v_{0}(x),v_{1}(x))\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above version easily implies the large distance part of Theorem 1.4 with the coarser</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\mathsf{J}}=O\\left(\\frac{1}{(\\eta\\rho)^{O(1)}}\\cdot\\frac{n^{2}}{q}\\right)</span></p>

    <p class="text-gray-300">bound by setting <span class="math">m=O\\left(\\frac{\\sqrt{\\rho}}{\\eta}\\right)</span>. For the more precise bound on <span class="math">\\epsilon_{\\mathsf{J}}</span>, we need to be a little careful, and we do this in the following theorem.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 5.2 (Correlated agreement over lines — alternative formulation).</h6>

    <p class="text-gray-300">Let <span class="math">u_{0},u_{1}:\\mathcal{D}\\to\\mathbb{F}_{q}</span>. Let <span class="math">\\delta,\\eta&gt;0</span> satisfy <span class="math">\\eta\\leq\\frac{\\sqrt{\\rho}}{20}</span> and <span class="math">\\delta\\leq\\delta_{0}(\\rho,\\eta)\\coloneqq 1-\\sqrt{\\rho}-\\eta</span>, and suppose</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}_{z\\in\\mathbb{F}_{q}}(\\Delta(u_{0}+zu_{1},V)\\leq\\delta)&gt;\\frac{\\rho^{2}n^{2}}{(2\\eta)^{7}q}=:\\epsilon_{\\mathsf{J}}.</span> (5.4)</p>

    <p class="text-gray-300">Then <span class="math">u_{0},u_{1}</span> are simultaneously <span class="math">\\delta</span>-close to <span class="math">V</span>, i.e. <span class="math">\\exists v_{0},v_{1}\\in V</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathcal{D}:(u_{0}(x),u_{1}(x))=(v_{0}(x),v_{1}(x))\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof of Theorem 5.2 from Theorem 5.1.</h6>

    <p class="text-gray-300">Set <span class="math">m=\\left\\lceil\\frac{\\sqrt{\\rho}}{2\\eta}\\right\\rceil\\geq 10</span>, and note that <span class="math">\\delta\\leq\\delta_{0}(\\rho,\\eta)&lt;\\delta_{0}(\\rho,m)</span>. Define <span class="math">S</span> as in Theorem 5.1, and observe that (5.3) is satisfied:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\epsilon_{\\mathsf{J}}q=(2\\eta)^{-7}\\rho^{2}n^{2}>\\left(\\frac{m-1}{\\sqrt{\\rho}}\\right)^{7}\\rho^{2}n^{2}=\\left(1-\\tfrac{1}{m}\\right)^{7}\\frac{m^{7}}{\\rho^{3/2}}\\,n^{2}>\\frac{(1+\\tfrac{1}{2m})^{7}m^{7}}{3\\rho^{3/2}}n^{2},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where in the last step we use <span class="math">3\\big{(}1-\\tfrac{1}{m}\\big{)}^{7}&gt;\\big{(}1+\\tfrac{1}{2m}\\big{)}^{7}</span>, which holds for <span class="math">m\\geq 10</span>. Thus we may apply Theorem 5.1, and conclude <span class="math">(u_{0},u_{1})</span> is <span class="math">\\delta</span>-close to <span class="math">(v_{0},v_{1})</span>, as claimed. ∎</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.1 The Guruswami–Sudan decoder</h3>

    <p class="text-gray-300">Our proof will be based on the Guruswami–Sudan decoding algorithm. Let <span class="math">\\mathbb{F}</span> be a (general) field and <span class="math">\\mathcal{D}\\subseteq\\mathbb{F}</span>. Let <span class="math">V</span> be the Reed–Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{D},k]</span>. Let <span class="math">\\rho=\\frac{k+1}{n}</span> denote its rate. We will be instantiating the Guruswami–Sudan decoder for RS codes over two different fields: the “standard” field <span class="math">\\mathbb{F}_{q}</span> and the field of rational functions <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> in the formal variable <span class="math">Z</span>. We now give a quick description of the Guruswami–Sudan decoding algorithm and some useful aspects of it.</p>

    <p class="text-gray-300">First, some definitions related to bivariate polynomials: The <span class="math">(a,b)</span>-weighted degree of a monomial <span class="math">X^{i}Y^{j}</span> is <span class="math">ai+bj</span>. The <span class="math">(a,b)</span>-weighted degree of a polynomial <span class="math">Q(X,Y)\\in\\mathbb{F}[X,Y]</span> is the maximal <span class="math">(a,b)</span>-weighted degree of all its non-zero monomials. The vanishing multiplicity of a polynomial <span class="math">Q(X,Y)\\in\\mathbb{F}[X,Y]</span> at a point <span class="math">(x,y)\\in\\mathbb{F}^{2}</span> is the smallest <span class="math">m</span> such that the shifted polynomial <span class="math">Q(x+X,y+Y)</span>, written as:</p>

    <p class="text-gray-300"><span class="math">Q(x+X,y+Y)=\\sum_{i,j}a_{ij}X^{i}Y^{j}</span></p>

    <p class="text-gray-300">has <span class="math">a_{ij}=0</span> for all <span class="math">(i,j)</span> with <span class="math">i+j&lt;m</span>. We denote the vanishing multiplicity of <span class="math">Q</span> at <span class="math">(x,y)</span> by <span class="math">\\mathsf{mult}(Q,(x,y))</span>.</p>

    <p class="text-gray-300">Given a received word <span class="math">w:\\mathcal{D}\\to\\mathbb{F}</span> and a multiplicity parameter <span class="math">m</span>, the Guruswami–Sudan decoder first solves a homogeneous system of linear equations to find a nonzero polynomial <span class="math">Q(X,Y)\\in\\mathbb{F}[X,Y]</span> with <span class="math">(1,k)</span>-weighted degree less than <span class="math">D_{X}(m)</span> (for a certain function <span class="math">D_{X}(m)</span>, specified later), such that:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{mult}(Q,(x,w(x))\\geq m</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\mathcal{D}</span>.</p>

    <p class="text-gray-300">The key properties of this system of linear equations that enable decoding are given by the following lemma.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 5.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\delta_{0}(\\rho,m)=1-\\sqrt{\\rho}-\\frac{\\sqrt{\\rho}}{2m}</span>. With <span class="math">D_{X}(m)=(m+\\frac{1}{2})\\sqrt{\\rho}n</span>, the system of linear equations set up above has the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The system has a nonzero solution <span class="math">Q(X,Y)</span>.</li>

      <li>For any nonzero solution <span class="math">Q(X,Y)</span> of the above system, and for any polynomial <span class="math">P(X)\\in V</span> such that <span class="math">\\Delta(w,P)\\leq\\delta_{0}(\\rho,m)</span>, we have that <span class="math">Y-P(X)</span> divides <span class="math">Q(X,Y)</span> in the polynomial ring <span class="math">\\mathbb{F}[X,Y]</span>.</li>

    </ol>

    <p class="text-gray-300">Note that these choices of <span class="math">\\delta_{0}</span> and <span class="math">D_{X}</span> are not quite optimal. The optimal values are only slightly better, but their formulas are longer and messier, and we opt for simplicity in favor of optimization.</p>

    <p class="text-gray-300">5.2 Proof of Theorem 5.1</p>

    <p class="text-gray-300">By definition of <span class="math">S</span>, for each <span class="math">z\\in S</span>, we have a polynomial <span class="math">P_{z}(X)\\in\\mathbb{F}_{q}[X]</span> with <span class="math">\\deg(P_{z})\\leq k</span> such that <span class="math">\\Delta(u_{0}+zu_{1},P_{z})\\leq\\delta</span>.</p>

    <p class="text-gray-300">Our strategy is to run the Guruswami–Sudan decoder over the field <span class="math">\\mathbb{K}=\\mathbb{F}_{q}(Z)</span> of rational functions in the formal variable <span class="math">Z</span>.</p>

    <p class="text-gray-300">First define a received word</p>

    <p class="text-gray-300"><span class="math">w:\\mathcal{D}\\to\\mathbb{K}</span></p>

    <p class="text-gray-300">given by:</p>

    <p class="text-gray-300"><span class="math">w(x)=u_{0}(x)+Zu_{1}(x).</span></p>

    <p class="text-gray-300">We sometimes also use the notation <span class="math">w(x,Z)</span> to denote <span class="math">u_{0}(x)+Zu_{1}(x)</span>.</p>

    <p class="text-gray-300">We will try to find a polynomial <span class="math">P(X,Z)\\in\\mathbb{F}_{q}[X,Z]</span> of the form <span class="math">P(X,Z)=v_{0}(X)+Zv_{1}(X)</span>, where <span class="math">\\deg_{X}(P)\\leq k</span>, such that</p>

    <p class="text-gray-300"><span class="math">P(x,Z)=w(x)</span></p>

    <p class="text-gray-300">for at least than <span class="math">n-e</span> choices of <span class="math">x\\in\\mathcal{D}</span>, where <span class="math">e=\\lfloor n\\delta\\rfloor</span> is the decoder’s error parameter.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">5.2.1 Step 1: Interpolating <span class="math">Q(X,Y,Z)</span></h4>

    <p class="text-gray-300">Let <span class="math">D_{X}=D_{X}(m)=(m+\\frac{1}{2})\\sqrt{\\rho}n</span>. The first step of the Guruswami–Sudan decoding algorithm is to find a nonzero polynomial <span class="math">Q(X,Y)\\in\\mathbb{K}[X,Y]</span>:</p>

    <p class="text-gray-300"><span class="math">Q(X,Y)=\\sum_{i+k\\cdot j&lt;D_{X}}Q_{ji}(Z)X^{i}Y^{j},</span></p>

    <p class="text-gray-300">where each <span class="math">Q_{ji}(Z)</span> lies in the big field <span class="math">\\mathbb{K}</span>, such that <span class="math">Q(X,Y)</span> has a zero of multiplicity <span class="math">m</span> at <span class="math">(x,w(x))</span> for each <span class="math">x\\in\\mathcal{D}</span>.</p>

    <p class="text-gray-300">This is possible when the number of available monomials, which is at least <span class="math">\\frac{k}{2}\\bigg{(}\\bigg{(}\\frac{D_{X}}{k}+\\frac{1}{2}\\bigg{)}^{2}-\\frac{1}{4}\\bigg{)}</span> (see Claim B.1 in Appendix B.2), exceeds the number of homogeneous linear equations <span class="math">\\binom{m+1}{2}n</span>. Indeed, this happens for our choice of <span class="math">D_{X}</span>.</p>

    <p class="text-gray-300">Solving this system of equations for a nonzero solution using Cramer’s rule, and clearing <span class="math">Z</span> denominators, we get such a <span class="math">Q(X,Y)\\in\\mathbb{K}[X,Y]</span> where each coefficient <span class="math">Q_{ji}(Z)</span> is in fact an element of <span class="math">\\mathbb{F}_{q}[Z]</span> (i.e., a polynomial instead of just a rational function) with controlled degree.</p>

    <p class="text-gray-300">Explicitly, we get:</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Claim 5.4.</h6>

    <p class="text-gray-300">There is a nonzero polynomial <span class="math">Q(X,Y)\\in\\mathbb{K}[X,Y]</span> with <span class="math">(1,k)</span>-weighted degree less than <span class="math">D_{X}</span> such that for each <span class="math">x\\in\\mathcal{D}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{mult}(Q,(x,w(x)))\\geq m,</span></p>

    <p class="text-gray-300">and furthermore:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg_{X}(Q)&lt;D_{X}=(m+\\frac{1}{2})\\sqrt{\\rho}n.</span> (5.5)</li>

      <li><span class="math">D_{Y}\\coloneqq\\deg_{Y}(Q)</span> satisfies:</li>

    </ul>

    <p class="text-gray-300"><span class="math">D_{Y}&lt;\\frac{D_{X}}{k}=\\frac{m+\\frac{1}{2}}{\\sqrt{\\rho}}.</span> (5.6)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each coefficient <span class="math">Q_{ji}(Z)</span> of <span class="math">Q(X,Y)</span> is in <span class="math">\\mathbb{F}_{q}[Z]</span>.</li>

    </ul>

    <p class="text-gray-300">######</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_{YZ}\\coloneqq\\deg_{Y,Z}(Q)</span> (which is the total <span class="math">Y,Z</span> degree of <span class="math">Q</span>) satisfies:</li>

    </ul>

    <p class="text-gray-300"><span class="math">D_{YZ}\\leq\\frac{(m+\\frac{1}{2})^{3}}{6\\sqrt{\\rho}}n.</span> (5.7)</p>

    <p class="text-gray-300">Only the bound on <span class="math">D_{YZ}</span> needs to be discussed, and it is explained and proven in detail in Appendix B.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 5.4 allows us to express the lower bound on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> from (5.3) in terms of </span>D_{X},D_{Y},D_{YZ}$, as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{(1+\\frac{1}{2m})^{7}m^{7}}{3\\rho^{3/2}}\\,n^{2}=2\\Bigg{(}\\frac{(m+\\frac{1}{2})}{\\sqrt{\\rho}}\\Bigg{)}^{3}\\big{(}(m+\\frac{1}{2})\\sqrt{\\rho}\\,n\\big{)}\\Bigg{(}\\frac{(m+\\frac{1}{2})^{3}}{6\\sqrt{\\rho}}\\,n\\Bigg{)}\\geq 2D_{Y}^{3}D_{X}D_{YZ}.$ (5.8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Over the next subsections, we will prove the following proposition, which is the core of our proof:</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proposition 5.5.</h6>

    <p class="text-gray-300">There exist a subset <span class="math">S^{\\prime}\\subset S</span> and a polynomial <span class="math">P(X,Z)\\in\\mathbb{F}_{q}[X,Z]</span> with the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2D_{Y}},$ (5.9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall z\\in S^{\\prime},\\ P_{z}(X)=P(X,z),</span> (5.10) <span class="math">\\deg_{X}(P)\\leq k,\\ \\deg_{Z}(P)\\leq 1.</span> (5.11)</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">5.2.2 Step 2: <span class="math">Q(X,Y,z)</span> is divisible by <span class="math">Y-P_{z}(X)</span> for many <span class="math">z</span></h4>

    <p class="text-gray-300">Recall that for every <span class="math">z\\in S</span> there exists a polynomial <span class="math">P_{z}(X)\\in\\mathbb{F}_{q}[X]</span> of degree at most <span class="math">k</span> with distance at most <span class="math">\\delta</span> from <span class="math">u_{0}+zu_{1}</span>, i.e. <span class="math">(x,P_{z}(x))</span> equals <span class="math">(x,w_{z}(x))</span> for at least <span class="math">n(1-\\delta)</span> values of <span class="math">x\\in\\mathcal{D}</span>. In each such point of agreement, the univariate polynomial <span class="math">Q(X,P_{z}(X),z)\\in\\mathbb{F}_{q}[X]</span> must then have a zero of order <span class="math">m</span>, thus it has at least <span class="math">mn(1-\\delta)</span> roots counted with multiplicity. On the other hand, Since <span class="math">Q</span> is chosen to have <span class="math">(1,k)</span>-weighted degree less than <span class="math">D_{X}</span>, and <span class="math">\\deg P_{z}(X)\\leq k</span>, we have <span class="math">\\deg_{X}(Q(X,P_{z}(X),z))&lt;D_{X}</span>. Thus the polynomial must be identically zero if <span class="math">D_{X}\\leq mn(1-\\delta)</span>. Indeed this holds, because</p>

    <p class="text-gray-300"><span class="math">1-\\delta\\geq 1-\\delta_{0}=\\left(1+\\frac{1}{2m}\\right)\\sqrt{\\rho}=\\frac{D_{X}}{mn}.</span></p>

    <p class="text-gray-300">Thus <span class="math">Q(X,Y,z)</span> is divisible by <span class="math">Y-P_{z}(X)</span> for each <span class="math">z\\in S</span>.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">5.2.3 Step 3: Finding a good <span class="math">x_{0}</span> to start Hensel lifting</h4>

    <p class="text-gray-300">We now begin the process of finding a power series solution <span class="math">Y=\\gamma(X)\\in\\overline{\\mathbb{K}}[[X]]</span> to <span class="math">Q(X,Y,Z)=0</span> (thought of as a bivariate equation <span class="math">Q(X,Y)=0</span> with coefficients in <span class="math">\\mathbb{K}</span>). To find the power series solution, we will start at a suitable solution <span class="math">(x_{0},\\alpha_{0})</span> of <span class="math">Q(X,Y)=0</span>, and then use Hensel lifting. In this section, our goal is to find such a “suitable” <span class="math">(x_{0},\\alpha_{0})</span>.</p>

    <p class="text-gray-300">Considering <span class="math">Q(X,Y,Z)</span> as a polynomial in <span class="math">Y</span> over <span class="math">\\mathbb{F}_{q}[X,Z]</span>, it can be uniquely factored as</p>

    <p class="text-gray-300"><span class="math">Q(X,Y,Z)=C(X,Z)\\prod_{i}R_{i}(X,Y^{p^{f_{i}}},Z)^{e_{i}},</span> (5.12)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">where <span class="math">p</span> is the characteristic of <span class="math">\\mathbb{F}_q</span>, <span class="math">f_i \\geq 0</span>, <span class="math">e_i \\geq 1</span>, and each <span class="math">R_i(X, Y, Z)</span> is irreducible and separable⁴. In this section we prove the following claim:</p>

    <p class="text-gray-300"><strong>Claim 5.6.</strong> There exists <span class="math">x_0 \\in \\mathbb{F}_q</span> such that for all <span class="math">i</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{disc}_Y(R_i(X, Y, Z))(x_0) \\neq 0 \\in \\mathbb{F}_q[Z].</span></div>

    <p class="text-gray-300">Before we prove the claim, let us explain its use and motivation. The Hensel lift (described in more detail in Appendix A.4) shows that any simple root <span class="math">Y = \\alpha_0 \\in \\overline{\\mathbb{K}}</span> of <span class="math">Q(x_0, Y, Z)</span> can be uniquely lifted to a power series solution <span class="math">\\gamma(X) \\in \\overline{\\mathbb{K}}[[X - x_0]]</span> with free coefficient <span class="math">\\alpha_0</span>, by iteratively finding solutions to <span class="math">Q(X, Y, Z) \\equiv 0 \\pmod{(X - x_0)^s}</span> with increasing <span class="math">s</span>.</p>

    <p class="text-gray-300">However, it may be that <span class="math">Q(X,Y)</span> has no simple roots. This could happen, for example, if the factors of <span class="math">Q(X,Y)</span> appear with multiplicity. To resolve this, we instead focus on an irreducible factor <span class="math">R_i</span> of <span class="math">Q</span>. Even after focusing on <span class="math">R_i</span>, it might still be the case that the particular root <span class="math">\\alpha_0</span> of <span class="math">R_i(x_0,Y,Z)</span> which we would wish to lift non-simple. We avoid this issue by requiring that that <span class="math">R_i(x_0,Y,Z)</span> is separable in <span class="math">Y</span> (i.e., all of its roots in <span class="math">Y</span> are simple). This happens if <span class="math">\\operatorname{disc}_Y R_i(x_0,Y,Z) \\neq 0</span>. Claim 5.6 exactly guarantees the existence of an element <span class="math">x_0</span> such that this occurs for all possible <span class="math">R_i</span>. For all future sections, we will fix any such <span class="math">x_0</span> arbitrarily.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Henceforth, we will assume for simplicity that <span class="math">Q</span> does not have inseparable irreducible factors, i.e. that <span class="math">f_i = 0</span> for all <span class="math">i</span>. Note that since any inseparable factor has <span class="math">Y</span>-degree at least <span class="math">p</span>, this is necessarily the case if the characteristic is larger than <span class="math">D_Y</span>, for example in the case where <span class="math">\\mathbb{F}_q</span> is a prime field with <span class="math">p = q</span>: (5.8) together with the trivial bound $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q<span class="math"> immediately yield </span>D_Y &lt; q^{1/3}$. The general case, including the possibility of inseparable factors, is very similar, but has more technicalities, which are discussed in detail in Appendix C.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof of Claim 5.6.</strong> Since all of the polynomials <span class="math">R_i(X, Y, Z)</span> are separable in <span class="math">Y</span>, the discriminants <span class="math">\\mathrm{disc}_Y(R_i(X, Y, Z)) \\in \\mathbb{F}_q[X, Z]</span> are non-zero polynomials. We need to find an <span class="math">x_0 \\in \\mathbb{F}_q</span> which makes all these discriminants evaluate to non-zero polynomials in <span class="math">\\mathbb{F}_q[Z]</span>. This will simply follow from a bound on the sum of degrees of all the <span class="math">R_i</span>, which we would like to show is less than <span class="math">q</span>. A crude bound on the sum of degrees (which would require a stronger bound on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$) is easy to give. The rest of the proof is just a more careful bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{disc}_Y^*(Q) := \\prod_i \\operatorname{disc}_Y(R_i(X, Y, Z)) \\in \\mathbb{F}_q[Z][X].</span></div>

    <p class="text-gray-300">It suffices to show that <span class="math">\\deg_X \\operatorname{disc}_Y^*(Q) &amp;lt; q</span>.</p>

    <p class="text-gray-300">In order to bound the <span class="math">X</span>-degree of <span class="math">\\mathrm{disc}_Y^*(Q)</span>, we will instead bound the <span class="math">X</span>-degree of <span class="math">\\mathrm{disc}_Y(Q)</span>, and see that it serves as an upper bound. There is a subtle issue here, as <span class="math">\\mathrm{disc}_Y(Q)</span> may very well be the zero polynomial, for example if any <span class="math">e_i &amp;gt; 1</span>. However, note that by expressing <span class="math">Q</span> as polynomial in <span class="math">Y</span>, i.e. <span class="math">Q = \\sum_{j \\leq D_Y} Q_j(X, Z)Y^j</span> with <span class="math">Q_j(X, Z) = \\sum_{i &amp;lt; D_X - k \\cdot j} Q_{ji}(Z)X^i</span>, there is a generic formula for the discriminant <span class="math">\\mathrm{disc}_Y(Q)</span>, which is a polynomial in the <span class="math">Q_j(X, Z)</span> coefficients, given (up to sign) by the determinant of the Sylvester matrix of <span class="math">Q</span> and <span class="math">\\frac{\\partial Q}{\\partial Y}</span>, divided by the leading coefficient <span class="math">Q_{D_Y}</span>. The generic polynomial is non-zero, and though it might vanish for the particular substitution of <span class="math">Q_j</span>, we can still compute its formal <span class="math">X</span>-degree as the maximal degree that would appear when expanding all algebraic expressions in the <span class="math">Q_j(X, Z)</span>, before cancellations. Furthermore, this polynomial will</p>

    <p class="text-gray-300">⁴<span class="math">R(X, Y, Z)</span> being separable in <span class="math">Y</span> means it does not have repeated roots in the variable <span class="math">Y</span>, in any extension field. This is equivalent to <span class="math">\\mathrm{disc}_Y(R(X, Y, Z)) \\neq 0</span>. For an irreducible polynomial in <span class="math">Y</span>, it is also equivalent to the <span class="math">Y</span>-derivative being not identically 0, or to the polynomial not being representable as a polynomial in <span class="math">Y^p</span>.</p>

    <p class="text-gray-300">⁵A root is simple when it has multiplicity 1.</p>

    <p class="text-gray-300">formally divisible by <span class="math">\\mathrm{disc}_{Y}^{*}(Q)</span>, in the sense that the quotient can be expressed as a generic polynomial in <span class="math">X,Z</span> (which again might vanish for the particular substitution). This is due to the <span class="math">R_{i}</span> dividing <span class="math">Q</span>, so that we may write <span class="math">Q(X,Y,Z)=U(X,Y,Z)\\cdot\\prod_{i}R_{i}(X,Y,Z)</span> where <span class="math">U</span> is the quotient. We then use the fact that the discriminant of a product of polynomials is given by a product of their discriminants and resultants, in this case yielding</p>

    <p class="text-gray-300"><span class="math">\\mathrm{disc}_{Y}(Q)=\\mathrm{disc}_{Y}(U)\\cdot\\prod_{i}\\mathrm{disc}_{Y}(R_{i})\\cdot\\prod_{i}\\mathrm{res}_{Y}(R_{i},U)^{2}\\prod_{i&lt;i^{\\prime}}\\mathrm{res}_{Y}(R_{i},R_{i^{\\prime}})^{2}</span></p>

    <p class="text-gray-300">where the right hand side contains <span class="math">\\mathrm{disc}_{Y}^{<em>}(Q)=\\prod_{i}\\mathrm{disc}_{Y}\\,R_{i}</span> as well as other terms, and all discriminants and resultants can be expressed as polynomials in the <span class="math">Y</span>-coefficients of <span class="math">Q,U</span> and the <span class="math">R_{i}</span>. Thus we deduce <span class="math">\\mathrm{deg}_{X}(\\mathrm{disc}_{Y}^{</em>}(Q))\\leq\\mathrm{deg}_{X}(\\mathrm{disc}_{Y}(Q))</span>.</p>

    <p class="text-gray-300">Finally, we wish to evaluate the formal <span class="math">X</span>-degree of <span class="math">\\mathrm{disc}_{Y}(Q)</span> from the Sylvester matrix and the bounds <span class="math">\\mathrm{deg}_{X}\\,Q_{j}&lt;D_{X}-k\\cdot j</span>. Since for each row in this matrix, the non-zero coefficients are simply <span class="math">Q_{D_{Y}},\\ldots Q_{0}</span> (or multiplied by constants, for rows of <span class="math">\\frac{\\partial Q}{\\partial Y}</span>), we see that shifting a column to the right always increases the degree bound by the same constant <span class="math">k</span>, so that in general the entry degree bound is given by the sum of a function of the row index and a linear function of the column index. Since the determinant always uses products with one item from each row and from each column, every non-zero product in the expression will have the exact same degree bound; thus, we may compute this bound “by example”, considering any one such expansion. It is particularly pleasant to take the leading coefficient <span class="math">Q_{D_{Y}}</span> from each of the <span class="math">D_{Y}</span> copies of <span class="math">\\frac{\\partial Q}{\\partial Y}</span>, and the free coefficient of <span class="math">Q_{0}</span> from the <span class="math">D_{Y}-1</span> copies of <span class="math">Q</span>, and of course dividing once by <span class="math">Q_{D_{Y}}</span>, as is part of the discriminant formula, giving the term <span class="math">Q_{D_{Y}}^{D_{Y}-1}Q_{0}^{D_{Y}-1}</span>. We thus get</p>

    <p class="text-gray-300"><span class="math">\\mathrm{deg}_{X}(\\mathrm{disc}_{Y}^{*}(Q))</span> <span class="math">\\leq\\mathrm{deg}_{X}(\\mathrm{disc}_{Y}(Q))=(D_{Y}-1)(\\mathrm{deg}_{X}(Q_{D_{Y}})+\\mathrm{deg}_{X}(Q_{0}))</span> <span class="math">&lt;(D_{Y}-1)(2D_{X}-kD_{Y})&lt;\\frac{(kD_{Y})(2D_{X}-kD_{Y})}{k}</span> <span class="math">&lt;\\frac{D_{X}^{2}}{k}=\\frac{(m+\\frac{1}{2})^{2}\\rho\\,n^{2}}{\\rho\\,n}=(m+\\frac{1}{2})^{2}n.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that from (5.3), we in particular have $q\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{\\left(1+\\frac{1}{2m}\\right)^{7}m^{7}}{3\\rho^{3/2}}n^{2}>(m+\\frac{1}{2})^{2}n$, and we have our desired inequality. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">5.2.4 Step 4: Focusing on a useful factor <span class="math">R_{i}(X,Y,Z)</span></h4>

    <p class="text-gray-300">Our main goal in the following sections is to show that at least one of the factors <span class="math">R_{i}(X,Y,Z)</span> is of the form <span class="math">Y-P(X,Z)</span>, with <span class="math">P\\in\\mathbb{F}_{q}[X,Z]</span> a polynomial of <span class="math">X</span>-degree at most <span class="math">k</span> and <span class="math">Z</span>-degree at most <span class="math">1</span>. Note that for such a factor, we will have in particular that for any <span class="math">z\\in\\mathbb{F}_{q}</span>, <span class="math">Y-P(X,z)</span> is a factor of <span class="math">R_{i}(X,Y,z)</span>, and <span class="math">P(x_{0},z)</span> is a rational root of <span class="math">R_{i}(x_{0},Y,z)</span>. We will see that a converse is also true: if such factors and roots of <span class="math">R_{i}</span> exist for sufficiently many <span class="math">z</span>’s, then <span class="math">R_{i}</span> must be divisible by (and thus of the form) <span class="math">Y-P(X,Z)</span>. In this section we will make use of this fact in order to focus on a useful <span class="math">R_{i}</span>. More precisely, we prove the following claim:</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Claim 5.7.</h6>

    <p class="text-gray-300">There exists a factor <span class="math">R=R_{i}</span> of <span class="math">Q</span>, and an irreducible factor <span class="math">H(Y,Z)</span> of <span class="math">R(x_{0},Y,Z)</span>, such that the set <span class="math">S_{x_{0},R,H}</span> of <span class="math">z</span> values for which both <span class="math">R</span> and <span class="math">H</span> vanish at <span class="math">P_{z}</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">S_{x_{0},R,H}=\\{z\\in S:R(X,P_{z}(X),z)\\equiv 0\\text{ and }H(P_{z}(x_{0}),z)=0\\},</span></p>

    <p class="text-gray-300">is sufficiently large; more precisely, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{x_{0},R,H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{D_{Y}}>2D_{Y}^{2}D_{X}D_{YZ}.$ (5.13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">After substituting <span class="math">X\\mapsto x_{0}</span>, each of the irreducible <span class="math">R_{i}(X,Y,Z)</span> can be factored as</p>

    <p class="text-gray-300"><span class="math">R_{i}(x_{0},Y,Z)=C_{i}(Z)\\prod_{j}H_{ij}(Y,Z),</span></p>

    <p class="text-gray-300">where <span class="math">H_{ij}\\in\\mathbb{F}_{q}[Z][Y]</span> are irreducible, separable in <span class="math">Y</span>, and with positive <span class="math">Y</span>-degree. For <span class="math">Q</span>, this yields the factorization</p>

    <p class="text-gray-300"><span class="math">Q(x_{0},Y,Z)=\\left(C(x_{0},Z)\\prod_{i}C_{i}(Z)\\right)\\prod_{i,j}H_{ij}(Y,Z).</span></p>

    <p class="text-gray-300">In particular, the number of <span class="math">H_{ij}</span> is at most <span class="math">D_{Y}</span>.</p>

    <p class="text-gray-300">For any <span class="math">z\\in S</span>, the polynomial <span class="math">P_{z}(X)</span> satisfies <span class="math">Q(X,P_{z}(X),z)=0</span>, i.e. <span class="math">Y-P_{z}(X)\\mid Q(X,Y,z)</span>, thus there is some <span class="math">i</span> such that <span class="math">Y-P_{z}(X)\\mid R_{i}(X,Y,z)</span>, or equivalently <span class="math">R_{i}(X,P_{z}(X),z)=0</span>. Substituting <span class="math">X\\mapsto x_{0}</span> yields also <span class="math">Y-P_{z}(x_{0})\\mid R_{i}(x_{0},Y,z)</span>, thus there is some <span class="math">j</span> such that <span class="math">Y-P_{z}(x_{0})\\mid H_{ij}(Y,z)</span> and equivalently <span class="math">H_{ij}(P_{z}(x_{0}),z)=0</span>. Therefore we have <span class="math">z\\in S_{x_{0},R_{i},H_{ij}}</span>, by definition. Let <span class="math">(i,j)</span> be the most common pair appearing in this process and set <span class="math">R=R_{i},H=H_{ij}</span>. Since the total number of pairs <span class="math">(i,j)</span> is at most <span class="math">D_{Y}</span>, and using (5.8), by the pigeonhole principle we find that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{x_{0},R,H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{D_{Y}}>2D_{Y}^{2}D_{X}D_{YZ},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as claimed. ∎</p>

    <p class="text-gray-300">As mentioned above, our proof will eventually show that both <span class="math">R</span> and <span class="math">H</span> must in fact be linear in <span class="math">Y</span>, with <span class="math">R(X,Y,Z)=Y-P(X,Z)</span>, where <span class="math">P</span> is linear in <span class="math">Z</span> and of degree <span class="math">k</span> in <span class="math">X</span> and <span class="math">H=R(x_{0},Y,Z)=Y-P(x_{0},Z)</span>. We will also see that <span class="math">P(x_{0},z)=P_{z}(x_{0})</span> for almost all <span class="math">z\\in S_{x_{0},R,H}</span>. We will reach this point only later — for now we assume <span class="math">R,H</span> have <span class="math">Y</span>-degrees <span class="math">d,d_{H}\\leq D_{Y}</span> correspondingly, that their total <span class="math">Y,Z</span> degrees at most <span class="math">D=D_{YZ}</span>, and are not necessarily monic.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">5.2.5 Step 5: Interlude — the algebraic function field <span class="math">\\mathbb{L}</span> and the power series <span class="math">\\gamma(X)</span></h4>

    <p class="text-gray-300">Our next step is to find a root of <span class="math">H</span> (if needed, by artificially adding it to the field <span class="math">\\mathbb{F}_{q}(Z)</span>), and then to lift it to a power series solution <span class="math">Y=\\gamma(X)</span> to <span class="math">R(X,Y,Z)=0</span>. This process is carried out in Appendix A, which also provides the required setup and definitions from the theory of algebraic extensions of function fields.</p>

    <p class="text-gray-300">We strongly encourage reading Appendix A at this point, as the analysis of the aforementioned <span class="math">\\gamma</span> in the next sections will use the following objects introduced and discussed there: the function field <span class="math">\\mathbb{L}</span>, the ring of regular functions <span class="math">\\mathcal{O}</span>, the special polynomials/algebraic functions <span class="math">\\zeta,\\xi,W,\\widetilde{H}</span>, and the power series <span class="math">\\gamma</span> itself, with its coefficients <span class="math">\\alpha_{t}</span> and their numerators <span class="math">\\beta_{t}</span>. We will also use the definition of the rational substitution maps <span class="math">\\pi_{z}</span> (that allow us to substitute <span class="math">z</span> into the regular algebraic functions in <span class="math">\\mathcal{O}</span>) and the weight function <span class="math">\\Lambda(\\cdot)</span> (that bounds the number of zeroes of a regular algebraic function) from that appendix, as well as Lemma A.1.</p>

    <p class="text-gray-300">At the end of the day, the power series <span class="math">\\gamma(X)</span> will be shown to be of the form <span class="math">P(X,Z)\\in\\mathbb{F}_{q}[X,Z]</span> with <span class="math">X</span>- and <span class="math">Z</span>-degrees at most <span class="math">k</span> and <span class="math">1</span>, respectively. However, to reach that point, we will analyze <span class="math">\\gamma(X)</span> as having coefficients in an algebraic extension of <span class="math">\\mathbb{F}_{q}(Z)</span>, and unbounded <span class="math">X</span>-degree.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">5.2.6 Step 6: Bounding the <span class="math">X</span>-degree of <span class="math">\\gamma</span></p>

    <p class="text-gray-300">In this section we show that the power series solution <span class="math">\\gamma=\\sum_{t=0}^{\\infty}\\alpha_{t}(X-x_{0})^{t}</span> to <span class="math">R(X,Y,Z)=0</span> is in fact a finite polynomial in <span class="math">X</span> of degree <span class="math">k</span>. In other words, we prove:</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Claim 5.8.</h6>

    <p class="text-gray-300">For all <span class="math">t&gt;k</span>, <span class="math">\\alpha_{t}=0</span>. Equivalently,</p>

    <p class="text-gray-300"><span class="math">\\gamma=\\gamma_{k}=\\sum_{t=0}^{k}\\alpha_{t}(X-x_{0})^{t}.</span></p>

    <p class="text-gray-300">The claim is proved in two steps: first for all <span class="math">k&lt;t&lt;D_{X}</span>, by showing that <span class="math">\\pi_{z}(\\alpha_{t})</span> is well defined and vanishes for sufficiently many substitutions; then for all <span class="math">t\\geq D_{X}</span> as well, by observing that <span class="math">\\gamma_{k}</span> is already a root of <span class="math">R(X,Y,Z)</span>.</p>

    <p class="text-gray-300">In the course of the proof we will also define the set <span class="math">S^{\\prime}</span> appearing in Proposition 5.5, and show that it satisfies (5.9).</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For each <span class="math">z\\in S_{x_{0},R,H}</span>, from <span class="math">H(P_{z}(x_{0}),z)=0</span> we also get <span class="math">\\widetilde{H}(W(z)P_{z}(x_{0}),z)=0</span>, and thus we have a substitution map <span class="math">\\pi_{z}:\\mathcal{O}\\to\\mathbb{F}_{q}</span> with <span class="math">t_{z}=W(z)P_{z}(x_{0})</span>. The denominators appearing in the <span class="math">\\alpha_{t}</span> are all powers of <span class="math">W</span> and <span class="math">\\xi</span>, so we can evaluate <span class="math">\\alpha_{t}</span> at any <span class="math">z</span> which is not a root of <span class="math">W</span> or <span class="math">\\xi</span>, i.e. in the set</p>

    <p class="text-gray-300"><span class="math">S^{\\prime}=S_{x_{0},R,H}\\setminus\\{z:W(z)=0\\text{ or }\\pi_{z}(\\xi)=0\\}.</span></p>

    <p class="text-gray-300">Using lemma A.1 and the bounds on <span class="math">\\deg W,\\Lambda(\\xi)</span> from claim A.2, as well as (5.13), we find</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{x_{0},R,H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(\\deg W+d_{H}\\Lambda(\\xi))$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$></td>

            <td class="px-3 py-2 border-b border-gray-700">S_{x_{0},R,H}</td>

            <td class="px-3 py-2 border-b border-gray-700">-d_{H}dD\\geq\\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}{D_{Y}}-D_{Y}^{2}D_{YZ}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">&gt;2D_{Y}^{2}D_{X}D_{YZ}-D_{Y}^{2}D_{YZ}=D_{Y}^{2}D_{YZ}(2D_{X}-1).</span> (5.14)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that to apply the lemma we also used <span class="math">\\xi\\neq 0</span> in <span class="math">\\mathbb{L}</span>. Since furthermore $D_{Y}^{2}D_{YZ}<\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2D_{Y}}$, we also get the bound</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{D_{Y}}-D_{Y}^{2}D_{YZ}>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2D_{Y}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as we claimed in (5.9).</p>

    <p class="text-gray-300">Now for each <span class="math">z\\in S^{\\prime}</span>, we may apply <span class="math">\\pi_{z}</span> to <span class="math">\\gamma</span>, since we removed all poles of <span class="math">\\gamma</span> from <span class="math">S^{\\prime}</span>. We wish to show that <span class="math">\\pi_{z}(\\gamma)=P_{z}(X)</span>. Note that <span class="math">\\pi_{z}(\\gamma)\\in\\mathbb{F}_{q}[[X-x_{0}]]</span>, and the polynomial <span class="math">P_{z}(X)</span> can also be considered as a (finite) power series in <span class="math">\\mathbb{F}_{q}[[X-x_{0}]]</span>. We have that <span class="math">Y=P_{z}(X),\\pi_{z}(\\gamma)</span> both are roots of <span class="math">R(X,Y,z)=0</span>: For <span class="math">P_{z}(X)</span> this follows by definition from <span class="math">z\\in S_{x_{0},R,H}</span>, and for <span class="math">\\pi_{z}(X)</span> we have <span class="math">R(X,\\pi_{z}(\\gamma),z)=\\pi_{z}(R(X,\\gamma,Z))=\\pi_{z}(0)=0</span>. Additionally, modulo <span class="math">X-x_{0}</span> we have <span class="math">\\pi_{z}(\\alpha_{0})=\\pi_{z}(T/W)=t_{z}/W(z)=P_{z}(x_{0})</span>. Furthermore, <span class="math">\\pi_{z}(\\zeta)</span> is well defined and non-zero (since <span class="math">\\pi_{z}(\\xi)\\neq 0</span>), and equal to</p>

    <p class="text-gray-300"><span class="math">\\pi_{z}(\\zeta)=\\pi_{z}\\bigg{(}\\frac{\\partial R}{\\partial Y}\\bigg{(}x_{0},\\frac{T}{W},Z\\bigg{)}\\bigg{)}=\\frac{\\partial R}{\\partial Y}\\bigg{(}x_{0},\\frac{t_{z}}{W(z)},z\\bigg{)}=\\frac{\\partial R}{\\partial Y}(x_{0},P_{z}(x_{0}),z).</span></p>

    <p class="text-gray-300">In particular, <span class="math">\\frac{\\partial R}{\\partial Y}(x_{0},P_{z}(x_{0}),z),\\neq 0</span>, i.e. <span class="math">P_{z}(x_{0})=\\pi_{z}(\\alpha_{0})</span> is a simple root of <span class="math">R(x_{0},Y,z)</span>.</p>

    <p class="text-gray-300">Putting all of the above together, we see that both <span class="math">\\pi_{z}(\\gamma),P_{z}(X)\\in\\mathbb{F}_{q}[[X-x_{0}]]</span> are power series solutions to <span class="math">R(X,Y,z)=0</span>, with the same free coefficient <span class="math">\\pi_{z}(\\alpha_{0})=P_{z}(x_{0})</span> modulo <span class="math">X-x_{0}</span>, which is</p>

    <p class="text-gray-300">a simple root of <span class="math">R(x_{0},Y,z)</span>. Thus, they must be identically equal, by the uniqueness of the Hensel lift with a given starting simple root. In other words, we have</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{q}[[X-x_{0}]]\\ni\\sum_{t=0}^{\\infty}\\pi_{z}(\\alpha_{t})(X-x_{0})^{t}=\\pi_{z}(\\gamma)=P_{z}(X)\\in\\mathbb{F}_{q}[X-x_{0}]</span></p>

    <p class="text-gray-300">and in particular, <span class="math">\\pi_{z}(\\alpha_{t})=0</span> for all <span class="math">z\\in S^{\\prime}</span> and all <span class="math">t&gt;k</span>, since <span class="math">\\deg(P_{z})\\leq k</span>. Thus we also find <span class="math">\\pi_{z}(\\beta_{t})=0</span> for all <span class="math">t&gt;k</span>. Restricting to <span class="math">k&lt;t&lt;D_{X}</span>, we additionally have by claim A.2</p>

    <p class="text-gray-300"><span class="math">\\Lambda(\\beta_{t})&lt;(2t+1)dD\\leq dD(2D_{X}-1),</span></p>

    <p class="text-gray-300">and from (5.14) it follows that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>D_{Y}^{2}D_{YZ}(2D_{X}-1)\\geq d_{H}dD(2D_{X}-1)>d_{H}\\Lambda(\\beta_{t}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can therefore apply lemma A.1 to find that indeed <span class="math">\\beta_{t}=0</span> and <span class="math">\\alpha_{t}=0</span> in <span class="math">\\mathbb{L}</span>.</p>

    <p class="text-gray-300">We thus have that the degree <span class="math">k</span> polynomial</p>

    <p class="text-gray-300"><span class="math">\\gamma_{k}=\\sum_{t=0}^{k}\\alpha_{t}(X-x_{0})^{t}=\\sum_{t=0}^{D_{X}-1}\\alpha_{t}(X-x_{0})^{t}=\\gamma_{D_{X}-1}\\in\\mathbb{L}[X]</span></p>

    <p class="text-gray-300">satisfies <span class="math">\\gamma\\equiv\\gamma_{k}\\pmod{(X-x_{0})^{D_{X}}}</span>, and therefore</p>

    <p class="text-gray-300"><span class="math">R(X,\\gamma_{k},Z)\\equiv 0\\pmod{(X-x_{0})^{D_{X}}};</span></p>

    <p class="text-gray-300">but, <span class="math">R(X,\\gamma_{k},Z)\\in\\mathbb{L}[X]</span> is a polynomial of degree <span class="math">&lt;D_{X}</span>, since by construction <span class="math">Q</span> has <span class="math">(1,k)</span>-weighted degree less than <span class="math">D_{X}</span> and so do its factors, and therefore <span class="math">R(X,\\gamma_{k},Z)=0</span> identically. By the uniqueness of the lifting, we thus find <span class="math">\\gamma=\\gamma_{k}\\in\\mathbb{L}[X]</span>, as claimed. ∎</p>

    <h4 id="sec-54" class="text-lg font-semibold mt-6">5.2.7 Step 7: Bounding the <span class="math">Z</span>-degree of <span class="math">\\gamma</span></h4>

    <p class="text-gray-300">In the previous section we’ve seen that <span class="math">\\gamma=\\gamma_{k}\\in\\mathbb{L}[X]</span> is a polynomial of degree at most <span class="math">k</span> in <span class="math">X</span>, whose coefficients lie in <span class="math">\\mathbb{L}</span>, an extension field of <span class="math">\\mathbb{F}_{q}(Z)</span>. We’ve also seen that <span class="math">\\pi_{z}(\\gamma)=P_{z}(X)</span> for all <span class="math">z\\in S^{\\prime}</span>. In this section we will show that the coefficients of <span class="math">\\gamma</span> are all in fact simply linear polynomials in <span class="math">Z</span>, and thus obtain that <span class="math">\\gamma=P(X,Z)\\in\\mathbb{F}_{q}[X,Z]</span> with <span class="math">X</span>-degree at most <span class="math">k</span> and <span class="math">Z</span>-degree at most <span class="math">1</span>:</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Claim 5.9.</h6>

    <p class="text-gray-300">The exists degree <span class="math">\\leq k</span> polynomials <span class="math">v_{0},v_{1}\\in\\mathbb{F}_{q}[X]</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\gamma=v_{0}(X)+Z\\cdot v_{1}(X)=:P(X,Z).</span></p>

    <p class="text-gray-300">Proving Claim 5.9 will also complete the proof of Proposition 5.5, as <span class="math">\\gamma=P</span> satsifies (5.11), the set <span class="math">S^{\\prime}</span> satisfies (5.9), and together they satisfy (5.10), since for each <span class="math">z\\in S^{\\prime}</span>,</p>

    <p class="text-gray-300"><span class="math">P(X,z)=\\pi_{z}(P(X,Z))=\\pi_{z}(\\gamma)=P_{z}(X).</span></p>

    <p class="text-gray-300">We prove Claim 5.9 by showing that <span class="math">\\gamma(x)</span> agrees with the linear function <span class="math">w(x,Z)</span> on at least <span class="math">k+1</span> values of <span class="math">x</span>, using sufficiently many <span class="math">Z</span>-substitutions at each <span class="math">x</span>, and then use the fact <span class="math">\\gamma</span> can be interpolated from such values of <span class="math">\\gamma(x)</span>, and this interpolation is also linear in <span class="math">Z</span>. Details follow.</p>

    <p class="text-gray-300">We consider good pairs of <span class="math">x\\in\\mathcal{D},z\\in S^{\\prime}</span> satisfying <span class="math">w(x,z)=P_{z}(x)</span>. We define the sets of <span class="math">x</span>’s which are good for each <span class="math">z\\in S^{\\prime}</span> and vice versa, that is,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_{z}=\\{x\\in\\mathcal{D}:w(x,z)=P_{z}(x)\\},</span> <span class="math">S^{\\prime}_{x}=\\{z\\in S^{\\prime}:w(x,z)=P_{z}(x)\\}=\\{z\\in S^{\\prime}:x\\in\\mathcal{D}_{z}\\}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the definitions of <span class="math">S</span> and <span class="math">P_{z}</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq n-e<span class="math"> for each </span>z\\in S^{\\prime}<span class="math">, where </span>e=\\lfloor\\delta n\\rfloor<span class="math">. We make the following claims regarding the sizes of the sets </span>S^{\\prime}_{x}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-56" class="text-base font-medium mt-4">Claim 5.10.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(2k+1)d_{H}dD<span class="math">. Then </span>\\gamma(x)=w(x,Z)<span class="math">, and in particular, </span>\\gamma(x)<span class="math"> is a linear polynomial in </span>\\mathbb{F}_{q}[Z]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-57" class="text-base font-medium mt-4">Claim 5.11.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a set <span class="math">\\mathcal{D}_{\\mathrm{top}}=\\{x_{1},\\ldots,x_{k+1}\\}\\subset\\mathcal{D}</span> of <span class="math">k+1</span> points of <span class="math">\\mathcal{D}</span>, satisfying $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(2k+1)d_{H}dD<span class="math"> for all </span>1\\leq j\\leq k+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Before proving the two claims, let us first deduce Claim 5.9 from them:</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof Claim 5.9.</h6>

    <p class="text-gray-300">Observe that from Claim 5.10 and Claim 5.11 it follows that <span class="math">\\gamma(x)=w(x,Z)=u_{0}(x)+Z\\cdot u_{1}(Z)</span> is linear in <span class="math">Z</span> for every <span class="math">x=x_{j}\\in\\mathcal{D}_{\\mathrm{top}}</span>. But, since <span class="math">\\gamma(X)</span> is a polynomial of degree at most <span class="math">k</span>, it can be interpolated from its values in any <span class="math">k+1</span> points, and this interpolation only involves operations over <span class="math">\\mathbb{F}_{q}</span>. Thus the interpolated polynomial will also have coefficients which are linear in <span class="math">Z</span>.</p>

    <p class="text-gray-300">More concretely, let <span class="math">v_{0}(X),v_{1}(X)\\in\\mathbb{F}_{q}[X]</span> be the unique polynomials of degree at most <span class="math">k</span> interpolating <span class="math">u_{0}(x),u_{1}(x)</span> at the points of <span class="math">\\mathcal{D}_{\\mathrm{top}}</span>. Then <span class="math">\\gamma(X)</span> and <span class="math">v_{0}(X)+Z\\cdot v_{1}(X)</span> are two polynomials in <span class="math">\\mathbb{L}[X]</span> of degree at most <span class="math">k</span> which agree on at least <span class="math">k+1</span> evaluations, since</p>

    <p class="text-gray-300"><span class="math">\\gamma(x_{j})=w(x_{j},Z)=u_{0}(x_{j})+Z\\cdot u_{1}(x_{j})=(v_{0}(X)+Z\\cdot v_{1}(X))(x_{j})</span></p>

    <p class="text-gray-300">for each <span class="math">x_{j}\\in\\mathcal{D}_{\\mathrm{top}}</span>. It follows that <span class="math">\\gamma</span> and <span class="math">v_{0}+Z\\cdot v_{1}</span> are identically equal as polynomials in <span class="math">\\mathbb{L}[X]</span>, as claimed. ∎</p>

    <p class="text-gray-300">We now proceed to prove the claims:</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof of Claim 5.10.</h6>

    <p class="text-gray-300">Since <span class="math">\\pi_{z}(\\gamma)=P_{z}(X)</span> for each <span class="math">z\\in S^{\\prime}</span>, by definition of <span class="math">S^{\\prime}_{x}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\pi_{z}(\\gamma(x))=P_{z}(x)=w(x,z)=u_{0}(x)+z\\cdot u_{1}(x)</span></p>

    <p class="text-gray-300">for each <span class="math">z\\in S^{\\prime}_{x}</span>, or equivalently</p>

    <p class="text-gray-300"><span class="math">\\pi_{z}\\big{(}\\gamma(x)-(u_{0}(x)+Z\\cdot u_{1}(x))\\big{)}=0.</span> (5.15)</p>

    <p class="text-gray-300">On the other hand, we can write</p>

    <p class="text-gray-300"><span class="math">\\gamma(x)-(u_{0}(x)+Z\\cdot u_{1}(x))</span> <span class="math">=\\left(\\frac{1}{W^{k+1}\\xi^{e_{k}}}\\sum_{t=0}^{k}\\beta_{t}(x-x_{0})^{t}W^{k-t}\\xi^{e_{k}-e_{t}}\\right)-(u_{0}(x)+Z\\cdot u_{1}(x))</span> <span class="math">=\\frac{1}{W^{k+1}\\xi^{e_{k}}}\\Big{(}\\beta(x)-(u_{0}(x)+u_{1}(x)\\cdot Z)\\;W^{k+1}\\xi^{e_{k}}\\Big{)},</span> (5.16)</p>

    <p class="text-gray-300">where <span class="math">\\beta(x)\\coloneqq\\sum_{t=0}^{k}\\beta_{t}(x-x_{0})^{t}W^{k-t}\\xi^{e_{k}-e_{t}}\\in\\mathcal{O}</span>, which by Claim A.2 has weight</p>

    <p class="text-gray-300"><span class="math">\\Lambda(\\beta(x))</span> <span class="math">\\leq\\max_{t=0,\\ldots,k}(\\Lambda(\\beta_{t})+(k-t)\\Lambda(W)+(e_{k}-e_{t})\\Lambda(\\xi))</span> <span class="math">\\leq\\max_{t=0,\\ldots,k}((1+(t+1)\\Lambda(W)+e_{t}\\Lambda(\\xi))+(k-t)\\Lambda(W)+(e_{k}-e_{t})\\Lambda(\\xi))</span> <span class="math">=1+(k+1)\\Lambda(W)+e_{k}\\Lambda(\\xi)\\leq(2k+1)dD,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and so does <span class="math">\\widetilde{\\beta}(x)\\coloneqq\\beta(x)-(u_{0}(x)+u_{1}(x)\\cdot Z)\\;W^{k+1}\\xi^{e_{k}}</span>. From (5.15) and (5.16) we have <span class="math">\\pi_{z}(\\widetilde{\\beta}(x))=0</span> for all <span class="math">z\\in S^{\\prime}_{x}</span>, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(2k+1)d_{H}dD\\geq d_{H}\\Lambda(\\widetilde{\\beta}(x))<span class="math">, by assumption. By Lemma A.1 it follows that </span>\\widetilde{\\beta}(x)=0<span class="math">, and thus </span>\\gamma(x)=u_{0}(x)+Z\\cdot u_{1}(x)=w(x,Z)<span class="math"> identically in </span>\\mathbb{L}$, as claimed. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof of Claim 5.11.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{D}_{\\mathrm{top}}=\\{x_{1},\\ldots,x_{k+1}\\}\\subset\\mathcal{D}</span> be the set of the <span class="math">x_{j}\\in\\mathcal{D}</span> with the <span class="math">k+1</span> largest sizes of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, breaking ties arbitrarily. We first claim that for each </span>1\\leq j\\leq k+1$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{n-k-1-e}{n-k-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1-\\rho-\\delta}{1-\\rho}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This follows by way of contradiction, which we get by double counting the set of bad pairs <span class="math">(x,z)\\in\\mathcal{D}\\times S^{\\prime}</span> with <span class="math">w(x,z)\\neq P_{z}(x)</span>. The contrary assumption implies that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{n-k-1-e}{n-k-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all </span>x\\notin\\mathcal{D}_{\\mathrm{top}}<span class="math">, giving many bad </span>z<span class="math">-s for each such </span>x<span class="math">, but on the other hand each </span>z<span class="math"> is only paired with a few bad </span>x$-s. More precisely, we get the following contradiction:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\sum_{z\\in S^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}\\setminus\\mathcal{D}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\sum_{x\\in\\mathcal{D}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}\\setminus S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\sum_{x\\in\\mathcal{D}\\setminus\\mathcal{D}_{\\mathrm{top}}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ (5.17)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From (5.14) we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1-\\rho-\\delta}{1-\\rho}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{1-\\rho-\\delta}{1-\\rho}D_{Y}^{2}D_{YZ}(2D_{X}-1)\\geq\\frac{1-\\rho-\\delta}{1-\\rho}(2D_{X}-1)d_{H}dD,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">so to conclude $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x_{j}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(2k+1)d_{H}dD<span class="math"> it suffices to show that </span>2D_{X}-1>\\frac{1-\\rho}{1-\\rho-\\delta}(2k+1)<span class="math">. And indeed for </span>m\\geq 3$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">2D_{X}-1</span> <span class="math">=(2m+1)\\sqrt{\\rho}\\,n-1&gt;2\\cdot 3\\sqrt{\\rho}\\,n-1&gt;\\frac{1+\\sqrt{\\rho}}{\\sqrt{\\rho}}(3\\rho\\,n)-1</span> <span class="math">&gt;\\frac{1-\\rho}{\\sqrt{\\rho}(1-\\sqrt{\\rho})}(2k+1)&gt;\\frac{1-\\rho}{\\sqrt{\\rho}+\\frac{\\sqrt{\\rho}}{2m}-\\rho}(2k+1)</span> <span class="math">=\\frac{1-\\rho}{1-\\delta_{0}(\\rho,m)-\\rho}(2k+1)\\geq\\frac{1-\\rho}{1-\\rho-\\delta}(2k+1)</span></p>

    <p class="text-gray-300">as needed. ∎</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">5.2.8 Step 8: Proving the correlated agreement between <span class="math">u_{i}</span> and <span class="math">v_{i}</span></h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We’ve found a polynomial <span class="math">\\gamma=v_{0}(X)+Z\\cdot v_{1}(X)</span> of the required degrees satisfying <span class="math">Q(X,\\gamma,Z)=0</span>. To finish the proof of Theorem 5.1, it now remains only to be seen that <span class="math">\\gamma(x,Z)</span> and <span class="math">w(x,Z)</span> agree identically on all but $\\delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> values of </span>x\\in\\mathcal{D}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define $\\mathcal{D}^{\\prime}=\\{x\\in\\mathcal{D}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2\\}<span class="math">. Note that for each </span>x\\in\\mathcal{D}^{\\prime}<span class="math">, we must have </span>v_{0}(x)=u_{0}(x)<span class="math">, </span>v_{1}(x)=u_{1}(x)<span class="math"> (and thus </span>\\gamma(x,Z)=w(x,Z)$), since</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">v_{0}(x)+z\\cdot v_{1}(x)</span> <span class="math">=\\pi_{z}(\\gamma(x))=\\pi_{z}(\\gamma)(x)=P_{z}(x)=w(x,z)</span> <span class="math">=u_{0}(x)+z\\cdot u_{1}(x)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for at least <span class="math">2</span> different values of <span class="math">z\\in S^{\\prime}_{x}</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math"> for every </span>x\\in\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}<span class="math">, double counting the number of bad pairs </span>(x,z)\\in\\mathcal{D}\\times S^{\\prime}<span class="math"> with </span>w(x,z)\\neq P_{z}(x)$, as in (5.17), gives</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\sum_{z\\in S^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}\\setminus\\mathcal{D}_{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\sum_{x\\in\\mathcal{D}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}\\setminus S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\sum_{x\\in\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)=(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and therefore $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math">. On the other hand, from (5.3), (5.6), (5.9), as well as </span>m\\geq 2<span class="math"> and </span>\\rho<1$ we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2D_{Y}}>\\frac{(m+\\frac{1}{2})^{6}}{6\\rho}n^{2}>2n^{2},$ (5.18)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">thus</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<\\left(1+\\frac{2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)e<\\left(1+\\frac{1}{n^{2}}\\right)e<e+\\frac{1}{n}<e+1,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i.e. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq e\\leq\\delta n$, which we finally rewrite as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathcal{D}:(u_{0}(x),u_{1}(x))=(v_{0}(x),v_{1}(x))\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as we wanted to show. ∎</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Remark 5.1.</h6>

    <p class="text-gray-300">Note that from <span class="math">\\gamma=v_{0}(X)+Z\\cdot v_{1}(X)=P(X,Z)</span> solving <span class="math">R(X,\\gamma,Z)=0</span> we find that <span class="math">Y-P(X,Z)\\mid R(X,Y,Z)</span>. But since <span class="math">R</span> is irreducible, it indeed follows that <span class="math">R=Y-P(X,Z)</span> is monic and linear in <span class="math">Y</span>, and so is <span class="math">H</span>, as was mentioned earlier; and, as mentioned, we only reach this conclusion near the end of the proof. It is an interesting open problem whether this conclusion can be reached without passing through the various extension fields as our proof required.</p>

    <h2 id="sec-63" class="text-2xl font-bold">6 Correlated Agreement in Generalized Settings</h2>

    <p class="text-gray-300">Both Theorems 4.1 and 5.1 considered two functions <span class="math">u_{0},u_{1}:\\mathcal{D}\\to\\mathbb{F}</span> and the corresponding affine line <span class="math">\\{u_{0}+zu_{1}:z\\in\\mathbb{F}_{q}\\}</span> inside the linear plane <span class="math">\\text{span}\\{u_{0},u_{1}\\}</span>. A generalization of these theorems that is particularly important to the soundness analysis of the FRI protocol in Theorem 8.3 is obtained by considering <span class="math">l+1</span> functions <span class="math">u_{0},\\ldots,u_{l}:\\mathcal{D}\\to\\mathbb{F}</span>, and the <span class="math">1</span>-dimensional, degree <span class="math">l</span> parameterized curve</p>

    <p class="text-gray-300"><span class="math">\\{u_{0}+zu_{1}+z^{2}u_{2}+\\cdots+z^{l}u_{l}:z\\in\\mathbb{F}_{q}\\}</span></p>

    <p class="text-gray-300">inside the linear space <span class="math">\\text{span}\\{u_{0},\\ldots,u_{l}\\}</span>. This curve can also be viewed as a function <span class="math">w(\\cdot,Z):\\mathcal{D}\\to\\mathbb{K}</span> given by</p>

    <p class="text-gray-300"><span class="math">w(x,Z)=u_{0}(x)+u_{1}(x)Z+u_{2}(x)Z^{2}+\\cdots+u_{l}(x)Z^{l}.</span></p>

    <p class="text-gray-300">The two theorems can then be generalized as follows:</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 6.1.</h6>

    <p class="text-gray-300">Suppose <span class="math">\\delta\\leq(1-\\rho)/2</span>. Let <span class="math">u_{0},u_{1},\\ldots,u_{l}:\\mathcal{D}\\to\\mathbb{F}_{q}</span> be functions. Let</p>

    <p class="text-gray-300"><span class="math">S=\\{z\\in\\mathbb{F}_{q}:\\Delta(u_{0}+zu_{1}+\\cdots+z^{l}u_{l},V)\\leq\\delta\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l\\cdot n<span class="math">. Then for all </span>z\\in\\mathbb{F}_{q}$ we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Delta(u_{0}+zu_{1}+\\cdots+z^{l}u_{l},V)\\leq\\delta,</span></p>

    <p class="text-gray-300">and furthermore there are <span class="math">v_{0},\\ldots,v_{l}\\in V</span> such that for all <span class="math">z\\in\\mathbb{F}_{q}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Delta(u_{0}+zu_{1}+\\cdots+z^{l}u_{l},v_{0}+zv_{1}+\\cdots+z^{l}v_{l})\\leq\\delta</span></p>

    <p class="text-gray-300">and in fact</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathcal{D}:(u_{0}(x),\\ldots,u_{l}(x))\\neq(v_{0}(x),\\ldots,v_{l}(x))\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-65" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">Let <span class="math">u_{0},u_{1},\\ldots,u_{l}:\\mathcal{D}\\to\\mathbb{F}_{q}</span>, let <span class="math">m\\geq 3</span>, define <span class="math">\\delta_{0}(\\rho,m)\\coloneqq 1-\\sqrt{\\rho}-\\frac{\\sqrt{\\rho}}{2m}</span>, and let <span class="math">\\delta\\leq\\delta_{0}(\\rho,m)</span>. Define</p>

    <p class="text-gray-300"><span class="math">S=\\{z\\in\\mathbb{F}_{q}:\\Delta(u_{0}+zu_{1}+\\cdots+z^{l}u_{l},V)\\leq\\delta\\}</span></p>

    <p class="text-gray-300">and suppose</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{(1+\\frac{1}{2m})^{7}m^{7}}{3\\rho^{3/2}}\\,n^{2}\\,l.$ (6.1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then <span class="math">u_{0},\\ldots,u_{l}</span> are simultaneously <span class="math">\\delta</span>-close to <span class="math">V</span>, i.e. <span class="math">\\exists v_{0},\\ldots,v_{l}\\in V</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathcal{D}:\\forall 0\\leq i\\leq l,u_{i}(x)=v_{i}(x)\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These generalizations do not greatly affect the proofs, which were presented in the previous sections in the special case <span class="math">l=1</span> only for the purposes of simplicity. We will thus not repeat the arguments in full, but only detail the required changes in subsections 6.1 and 6.2.</p>

    <p class="text-gray-300">Another generalization of interest is to correlated agreement in the entire affine space, stated as Theorem 1.6, restated here for completeness:</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Theorem 1.6 (Correlated agreement over affine spaces).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. For <span class="math">u_{0},u_{1},\\ldots u_{l}\\in\\mathbb{F}_{q}^{\\mathcal{D}}</span> let <span class="math">U=u_{0}+\\mathrm{span}\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> be an affine subspace. If <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span> and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\left[\\Delta(u,V)\\leq\\delta\\right]&gt;\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2, then there exist <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> and <span class="math">v_{0},\\ldots,v_{l}\\in V</span> satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Density: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\delta$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Agreement: for all <span class="math">i\\in\\{0,\\ldots,l\\}</span>, the functions <span class="math">u_{i}</span> and <span class="math">v_{i}</span> agree on all of <span class="math">\\mathcal{D}^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">Furthermore, in the unique decoding regime <span class="math">\\delta\\in\\left(0,\\frac{1-\\rho}{2}\\right]</span>, there exists a unique <em>maximal <span class="math">\\mathcal{D}^{\\prime}</span></em> satisfying the above, with unique <span class="math">v_{i}</span>.</p>

    <p class="text-gray-300">To prove this theorem we will make use of the following lemma:</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 6.3.</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. For <span class="math">u_{0},u_{1},\\ldots u_{l}\\in\\mathbb{F}_{q}^{\\mathcal{D}}</span> let <span class="math">U=u_{0}+\\mathrm{span}\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> be an affine subspace, and let <span class="math">U^{\\prime}=\\mathrm{span}\\{u_{1},\\ldots,u_{l}\\}</span> be the corresponding linear subspace (so that <span class="math">U=u_{0}+U^{\\prime}</span> and <span class="math">U^{\\prime}=U-U</span>). If <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span> and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\left[\\Delta(u,V)\\leq\\delta\\right]&gt;\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2, then we have <span class="math">\\Delta(u^{\\prime},V)\\leq\\delta</span> for every <span class="math">u^{\\prime}\\in U^{\\prime}</span>.</p>

    <p class="text-gray-300">Note that Lemma 6.3 is very similar to Theorem 1.2, the difference being only that the consequent <span class="math">\\Delta(u^{\\prime},V)\\leq\\delta</span> is stated for elements of the linear space <span class="math">U^{\\prime}</span> instead of elements of the affine space <span class="math">U</span>. In particular, when <span class="math">U</span> itself is linear and <span class="math">U^{\\prime}=U</span>, they are equivalent. Moreover, Theorem 1.2 can be proven from Lemma 6.3, and in fact we will pass through such a proof in the course of proving Theorem 1.6. Both Lemma 6.3 and Theorem 1.6 are proven in Section 6.3.</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">6.1 Proof of Theorem 6.1</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Following the proof in Section 4, the first change is in the analysis of the matrix <span class="math">M</span>, where the entries in the columns corresponding to the coefficients of <span class="math">A</span> are of degree <span class="math">\\leq l</span> in <span class="math">Z</span> instead of <span class="math">1</span> (and the columns corresponding to the coefficients of <span class="math">B</span> remain of degree <span class="math">0</span>). The determinants of minors <span class="math">R(Z)</span> are then of degree at most <span class="math">l(e+1)</span>, which is less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so are still identically </span>0<span class="math">, and the matrix has rank </span><k+2e+2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, the solution <span class="math">A,B</span> of the equation system will have <span class="math">Z</span>-degrees <span class="math">\\deg_{Z}(A)\\leq le</span>, <span class="math">\\deg_{Z}(B)\\leq l(e+1)</span>, so <span class="math">a_{Z},b_{Z}</span> grow by a factor of <span class="math">l</span>, as does <span class="math">d_{Z}=l</span> (which remains the degree of the <span class="math">w(x,Z)</span>), and similarly $n_{Z}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l\\cdot n$. We again have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{b_{X}}{n_{X}}+\\frac{b_{Z}}{n_{Z}}&lt;\\frac{k+e}{n}+\\frac{l(e+1)}{l\\cdot n}&lt;\\frac{k+2e+1}{n}\\leq 1</span></p>

    <p class="text-gray-300">and the Polishchuk–Spielman lemma remains applicable, and the rest of the conclusions are derived as before with no further changes, save that <span class="math">P(X,Z)</span> is now of degree <span class="math">l</span> in <span class="math">Z</span>, and thus written as <span class="math">v_{0}(X)+Zv_{1}(X)+\\cdots Z^{l}v_{l}</span>.</p>

    <h3 id="sec-69" class="text-xl font-semibold mt-8">6.2 Proof of Theorem 6.2</h3>

    <p class="text-gray-300">As in the <span class="math">l=1</span> case, we apply the Guruswami–Sudan decoder to the <span class="math">\\mathbb{K}^{\\mathcal{D}}</span> word <span class="math">w(x,Z)=\\sum_{i=0}^{l}u_{i}(x)Z^{i}</span>. We use exactly the same parameters, and the degrees <span class="math">D_{X},D_{Y}</span> are unaffected. In the entries of the equation system, every appearance of (a power of) the previously linear <span class="math">w(x,Z)</span> is replaced by (a power of) a polynomial of degree <span class="math">l</span>, thus the bounds on <span class="math">D_{C},D_{R},D,D_{YZ}</span> are all multiplied by <span class="math">l</span>, and specifically <span class="math">D_{YZ}&lt;\\frac{(m+1/2)^{3}}{6\\sqrt{\\rho}}n\\,l</span>.</p>

    <p class="text-gray-300">Also note that instead of the <span class="math">Y,Z</span> degrees being graded in <span class="math">Q</span> such that the coefficient <span class="math">Q_{ji}(Z)</span> of <span class="math">X^{i}Y^{j}</span> is of degree at most <span class="math">D-j</span> in <span class="math">Z</span>, it is of degree at most <span class="math">D-l\\cdot j</span>, i.e. when <span class="math">Y</span> and <span class="math">Z</span> are assigned weights <span class="math">l</span> and <span class="math">1</span> (instead of <span class="math">1</span> and <span class="math">1</span>), the total weight of <span class="math">Q</span>, and thus also of <span class="math">R</span> and <span class="math">H</span>, is at most <span class="math">D</span>. Thus all bounds on <span class="math">Z</span>-degrees and weights are henceforth simply multiplied by <span class="math">l</span>. The leading coefficient <span class="math">W</span> of <span class="math">H</span> has degree at most <span class="math">D-l\\cdot d</span>, and the variable <span class="math">T=W(Z)Y</span> is assigned the <span class="math">l</span> times larger weight <span class="math">D-l(d-1)</span>, which makes the weight of the monic polynomial <span class="math">\\widetilde{H}</span> dominated by its leading monomial <span class="math">T^{d}</span>, thus the weight never increases on reductions modulo <span class="math">\\widetilde{H}</span>. The bounds on weights of <span class="math">\\xi,\\beta_{t}</span> are multiplied by <span class="math">l</span>. Since for <span class="math">\\mathbb{F}_{q}[Z]</span> polynomials the weight corresponds to degree, lemma A.1 remains valid; in all its applications, the upper bounds on weights of the regular elements are multiplied by <span class="math">l</span>; and so are the lower bounds on the sizes of the sets of vanishing substitutions, i.e. the sets <span class="math">S</span>, <span class="math">S_{x_{0},R,H}</span>, <span class="math">S^{\\prime}</span>, <span class="math">S^{\\prime}_{x_{j}}</span>. Thus we can still deduce that <span class="math">\\gamma</span> is of degree <span class="math">k</span>, and then by interpolating <span class="math">u_{0},\\ldots,u_{l}</span> by polynomials <span class="math">v_{0},\\ldots,v_{l}</span> at <span class="math">k+1</span> appropriately chosen points, to deduce that <span class="math">\\gamma=\\sum_{i=0}^{l}v_{i}(X)Z^{i}</span> identically.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the final argument we again note that <span class="math">\\sum_{i=0}^{l}u_{i}(x)z^{i}=\\sum_{i=0}^{l}v_{i}(x)z^{i}</span> for all <span class="math">x\\in\\mathcal{D}</span> and <span class="math">z\\in S^{\\prime}_{x}</span>. Since for a fixed <span class="math">x</span> both sides of the equation are degree <span class="math">l</span> polynomials in <span class="math">z</span>, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l<span class="math"> then we must have </span>u_{i}(x)=v_{i}(x)<span class="math"> for all </span>0\\leq i\\leq l<span class="math">. We have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2l\\cdot n^{2}<span class="math">, or equivalently </span>\\frac{l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{2}{n^{2}}<span class="math">, and thus the number of </span>x\\in\\mathcal{D}<span class="math"> for which </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq l<span class="math"> is at most </span>\\frac{e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}<e+1<span class="math">, and again we find that </span>u_{i}<span class="math"> and </span>v_{i}<span class="math"> all agree on the set </span>\\mathcal{D}^{\\prime}=\\{x\\in\\mathcal{D}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l\\}<span class="math"> which is of size at least </span>(1-\\delta)n$, as claimed. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">6.3 Proofs of Lemma 6.3 and Theorem 1.6</h3>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof of Lemma 6.3.</h6>

    <p class="text-gray-300">Let <span class="math">u^{\\prime}\\in U^{\\prime}</span> be an arbitrary element. If <span class="math">u^{\\prime}=0</span>, then clearly <span class="math">\\Delta(u^{\\prime},V)=0\\leq\\delta</span>. Otherwise, consider the partition of <span class="math">U</span> into affine lines parallel to <span class="math">u^{\\prime}</span>; formally, write <span class="math">U=\\widetilde{U}\\oplus\\text{span}\\{u^{\\prime}\\}</span>, where <span class="math">\\widetilde{U}\\subset U</span> is some direct complement of <span class="math">u^{\\prime}</span> in <span class="math">U^{\\prime}</span> shifted by <span class="math">u_{0}</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}_{\\tilde{u}\\in\\widetilde{U}}\\Pr_{z\\in\\mathbb{F}_{q}}\\big{[}\\Delta\\big{(}\\tilde{u}+z\\cdot u^{\\prime},V\\big{)}\\leq\\delta\\big{]}=\\Pr_{u\\in U}\\big{[}\\Delta(u,V)\\leq\\delta\\big{]}&gt;\\epsilon,</span></p>

    <p class="text-gray-300">and in particular there exists some <span class="math">\\tilde{u}\\in\\widetilde{U}</span> for which <span class="math">\\Pr_{z\\in\\mathbb{F}_{q}}\\big{[}\\Delta(\\tilde{u}+z\\cdot u^{\\prime},V)\\leq\\delta\\big{]}&gt;\\epsilon</span>. We can thus apply Theorem 1.4 to the line <span class="math">\\{\\tilde{u}+z\\cdot u^{\\prime}:z\\in\\mathbb{F}_{q}\\}</span>, which in particular implies <span class="math">\\Delta(u^{\\prime},V)\\leq\\delta</span>, as claimed. ∎</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof of Theorem 1.6.</h6>

    <p class="text-gray-300">Let <span class="math">\\delta^{<em>}=\\mathsf{D}(U,V)</span>, where <span class="math">\\mathsf{D}</span> is the divergence as defined in subsection 1.2, and let <span class="math">u^{</em>}\\in U</span> be an element with <span class="math">\\Delta(u^{<em>},V)=\\delta^{</em>}</span>.</p>

    <p class="text-gray-300">We first show that <span class="math">\\delta^{*}\\leq\\delta</span>. Let <span class="math">\\overline{U}=\\mathrm{span}(U)</span> be the linear space spanned by <span class="math">U</span>, which either equals <span class="math">U</span> when <span class="math">0\\in U</span>, or otherwise is the disjoint union of <span class="math">U^{\\prime}=U-U</span> and <span class="math">\\{z\\cdot U:z\\in\\mathbb{F}_{q}\\setminus\\{0\\}\\}</span>. By Lemma 6.3 we have <span class="math">\\Delta(u^{\\prime},V)\\leq\\delta</span> for all <span class="math">u^{\\prime}\\in U^{\\prime}</span>, and we also have <span class="math">\\Delta(z\\cdot u,V)=\\Delta(u,V)</span> for all <span class="math">z\\neq 0</span> and <span class="math">u\\in U</span>. Thus in both cases, whether <span class="math">\\overline{U}=U</span> or <span class="math">\\overline{U}=U^{\\prime}\\cup\\bigcup_{z\\neq 0}(z\\cdot U)</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\bar{u}\\in\\overline{U}}[\\Delta(\\bar{u},V)\\leq\\delta]\\geq\\Pr_{u\\in U}[\\Delta(u,V)\\leq\\delta]&gt;\\epsilon.</span></p>

    <p class="text-gray-300">We can therefore apply Lemma 6.3 to <span class="math">\\overline{U}</span>, and in particular for <span class="math">u^{<em>}\\in U\\subset\\overline{U}</span> we get <span class="math">\\delta^{</em>}=\\Delta(u^{*},V)\\leq\\delta</span>, as claimed. As previously noted, this is in fact the content of Theorem 1.2, which is now proved.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\{v_{1}^{<em>},\\ldots,v_{L}^{</em>}\\}\\subset V</span> be all possible codewords at distance at most <span class="math">\\delta^{<em>}</span> from <span class="math">u^{</em>}</span>. Note that they are all in fact at distance <em>exactly</em> <span class="math">\\delta^{<em>}</span>, not less, since otherwise we would have <span class="math">\\Delta(u^{</em>},V)&lt;\\delta^{<em>}</span>. For each <span class="math">1\\leq i\\leq L</span> define the agreement set <span class="math">\\mathcal{D}_{i}^{\\prime}=\\{x\\in\\mathcal{D}:u^{</em>}(x)=v_{i}^{<em>}(x)\\}</span> which has size exactly $(1-\\delta^{</em>})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Note that in the unique decoding regime </span>\\delta^{<em>}\\leq\\frac{1-\\rho}{2}<span class="math"> we must have </span>L=1<span class="math">, and in the general Johnson/Guruswami–Sudan regime </span>\\delta^{</em>}<1-\\sqrt{\\rho}-\\eta<span class="math"> we have </span>L<q<span class="math">: indeed, from </span>\\epsilon=\\epsilon_{\\mathsf{J}}<1<span class="math"> and </span>\\eta<\\frac{\\sqrt{\\rho}}{16}<span class="math"> we must have </span>q>(2\\eta)^{-7}>\\frac{2^{17}}{\\eta},\\frac{2^{21}}{\\sqrt{\\rho}}<span class="math">, and from the analysis of the Guruswami–Sudan algorithm, using (5.6) and </span>m=\\left\\lceil\\frac{\\sqrt{\\rho}}{2\\eta}\\right\\rceil<\\frac{\\sqrt{\\rho}}{2\\eta}+1$ we find</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">L\\leq D_{Y}&lt;\\frac{2m+1}{2\\sqrt{\\rho}}&lt;\\frac{1}{2\\eta}+\\frac{3}{2\\sqrt{\\rho}}&lt;2^{-17}q&lt;q.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each <span class="math">i\\leq L</span>, let $U_{i}=\\{u\\in U:\\,u</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}_{i}^{\\prime}}\\in\\,V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}_{i}^{\\prime}}\\}<span class="math"> be the set of all functions in </span>U<span class="math"> which agree with some codeword in </span>V<span class="math"> on all of </span>\\mathcal{D}_{i}^{\\prime}<span class="math">. Note that this condition is linear, therefore each </span>U_{i}<span class="math"> is an affine subspace of </span>U<span class="math">. We claim that </span>U\\subset\\bigcup_{i=0}^{L}U_{i}<span class="math">, i.e. every element of </span>U<span class="math"> belongs to at least one </span>U_{i}<span class="math">. This is obvious for </span>u^{<em>}<span class="math">, which belongs to all </span>U_{i}<span class="math">. Consider any </span>u\\in U\\setminus\\{u^{</em>}\\}<span class="math">, and the affine line </span>\\{u^{<em>}+z\\cdot(u-u^{</em>}):z\\in\\mathbb{F}_{q}\\}\\subset U<span class="math"> containing </span>u^{<em>}<span class="math"> and </span>u<span class="math">. By definition of </span>\\delta^{</em>}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{z\\in\\mathbb{F}_{q}}[\\Delta(u^{<em>}+z\\cdot(u-u^{</em>}),V)\\leq\\delta^{*}]=1&gt;\\epsilon.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\delta^{<em>}\\leq\\delta</span>, by Theorem 1.4 we have </em>correlated* agreement in the line, i.e. there exists <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta^{*})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and codewords </span>v^{<em>},v\\in V<span class="math"> which respectively agree with </span>u^{</em>},u<span class="math"> on </span>\\mathcal{D}^{\\prime}<span class="math">. In particular </span>\\Delta(u^{<em>},v^{</em>})\\leq\\delta^{<em>}<span class="math">, thus </span>v^{</em>}<span class="math"> must be one of the </span>L<span class="math"> decodings </span>\\{v_{1}^{<em>},\\ldots,v_{L}^{</em>}\\}<span class="math">, as the list was exhaustive, and </span>\\mathcal{D}^{\\prime}=\\mathcal{D}_{i}^{\\prime}<span class="math">. This exactly implies </span>u\\in U_{i}\\subset\\bigcup_{i=0}^{L}U_{i}$, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comparing sizes, we find that the largest <span class="math">U_{i}</span> must then satisfy $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{L}>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{q}<span class="math">. But </span>U_{i}<span class="math"> is a subspace of </span>U<span class="math">, and it thus follows that </span>U_{i}=U<span class="math">. Now setting </span>\\mathcal{D}^{\\prime}=\\mathcal{D}_{i}^{\\prime}<span class="math">, we have in particular that the restrictions of </span>u_{0},u_{1},\\ldots,u_{l}<span class="math"> to </span>\\mathcal{D}^{\\prime}<span class="math"> are codewords, since they are elements or differences of elements in </span>U_{i}<span class="math">. Then setting </span>v_{0},v_{1},\\ldots,v_{l}\\in V<span class="math"> to be the unique extensions of these codewords from </span>\\mathcal{D}^{\\prime}<span class="math"> to </span>\\mathcal{D}<span class="math">, we find that </span>\\mathcal{D}^{\\prime},v_{0},\\ldots,v_{l}<span class="math"> satisfy both conditions. Again note that in the unique decoding regime, </span>L=1<span class="math"> and this </span>\\mathcal{D}^{\\prime}$ is therefore uniquely defined. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-73" class="text-2xl font-bold">7 Correlated Weighted Agreement</h2>

    <p class="text-gray-300">For certain applications, like analyzing the soundness of the FRI protocol (Section 8.2), a <em>weighted</em> version of Theorem 1.5 is necessary, and we provide it in this section.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">For a given weight vector <span class="math">\\mu:\\mathcal{D}\\to[0,1]</span>, the (relative) <span class="math">\\mu</span>-agreement between words <span class="math">u,v</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname{agree}_{\\mu}(u,v)\\coloneqq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\sum_{x:u(x)=v(x)}\\mu(x).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that for <span class="math">\\mu\\equiv 1</span> the notion of <span class="math">\\mu</span>-agreement is equivalent to the standard notion of relative agreement, which is defined as <span class="math">\\operatorname{agree}(u,v)=1-\\Delta(u,v)</span>. The agreement between a word <span class="math">u</span> and a linear code <span class="math">V</span> is the maximal agreement between <span class="math">u</span> and a codeword of <span class="math">V</span>,</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}_{\\mu}(u,V)\\coloneqq\\max_{v\\in V}\\operatorname{agree}_{\\mu}(u,v).</span></p>

    <p class="text-gray-300">We also define the weighted size of a subdomain <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mu(\\mathcal{D}^{\\prime})\\coloneqq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\sum_{x\\in\\mathcal{D}^{\\prime}}\\mu(x).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus the agreement satisfies <span class="math">\\operatorname{agree}_{\\mu}(u,v)=\\mu(\\{x\\in\\mathcal{D}:u(x)=v(x)\\})</span>. Finally, for <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\},u_{i}\\in\\mathbb{F}^{\\mathcal{D}}</span> a set of words, the <span class="math">\\mu</span>-weighted correlated agreement of <span class="math">\\mathbf{u}</span> and <span class="math">V</span> is the maximal <span class="math">\\mu</span>-weighted size of a subdomain <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> such that the restriction of <span class="math">\\mathbf{u}</span> to <span class="math">\\mathcal{D}^{\\prime}</span> belongs to $V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}^{\\prime}}<span class="math">, i.e., for each </span>i=0,\\ldots,l<span class="math"> there exist </span>v_{i}\\in V<span class="math"> such that </span>u_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}^{\\prime}}=v_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{D}^{\\prime}}<span class="math">. When </span>\\mu<span class="math"> is unspecified, it is set to the constant weight function </span>1$, which recovers the notion of correlated agreement measure discussed in Section 1.3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In what follows we shall assume the weight function <span class="math">\\mu</span> has some structure, specifically, all weights <span class="math">\\mu(x)</span> are the form <span class="math">\\mu(x)=\\frac{a_{x}}{M}</span> for varying integers <span class="math">a_{x}</span> and common denominator <span class="math">M</span>. This assumption indeed holds for the special case of FRI soundness (where <span class="math">M</span> equals the blocklength of the RS code to which the FRI protocol is applied). The following is the weighted generalization of Theorem 1.5.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Theorem 7.1 (Weighted correlated agreement over curves – Version I).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span>. Let <span class="math">\\alpha\\in(\\sqrt{\\rho},1)</span> and let <span class="math">\\mu:\\mathcal{D}\\to[0,1]</span> be a vector of weights, whose values all have denominator <span class="math">M</span>. Suppose</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in\\mathsf{curve}(\\mathbf{u})}\\big{[}\\operatorname{agree}_{\\mu}(u,V)\\geq\\alpha\\big{]}&gt;l\\cdot\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2 (with <span class="math">\\eta=\\min(\\alpha-\\sqrt{\\rho},\\frac{\\sqrt{\\rho}}{20})</span>), and additionally suppose</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{u\\in\\mathsf{curve}(\\mathbf{u})}\\big{[}\\operatorname{agree}_{\\mu}(u,V)\\geq\\alpha\\big{]}\\geq\\frac{l(M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1)}{q}\\bigg{(}\\frac{1}{\\eta}+\\frac{3}{\\sqrt{\\rho}}\\bigg{)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then there exist <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> and <span class="math">v_{0},\\ldots,v_{l}\\in V</span> satisfying</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mu</span>-Density: <span class="math">\\mu(\\mathcal{D}^{\\prime})\\geq\\alpha</span>, and</li>

      <li>Agreement: for all <span class="math">i\\in\\{0,\\ldots,l\\}</span>, the functions <span class="math">u_{i}</span> and <span class="math">v_{i}</span> agree on all of <span class="math">\\mathcal{D}^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">A slightly more precise form, only for the Johnson bound regime, is the following:</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Theorem 7.2 (Weighted correlated agreement over curves – Version II).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span>. Let <span class="math">\\mu:\\mathcal{D}\\to[0,1]</span> be a vector of weights, whose values all have denominator <span class="math">M</span>. Let <span class="math">m\\geq 3</span> and let</p>

    <p class="text-gray-300"><span class="math">\\alpha\\geq\\alpha_{0}(\\rho,m)\\coloneqq\\sqrt{\\rho}+\\frac{\\sqrt{\\rho}}{2m}.</span></p>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">S=\\{z\\in\\mathbb{F}_{q}:\\operatorname{agree}_{\\mu}(u_{0}+zu_{1}+\\cdots+z^{l}u_{l},V)\\geq\\alpha\\}</span></p>

    <p class="text-gray-300">and suppose</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\max\\Bigg{(}\\frac{(1+\\frac{1}{2m})^{7}m^{7}}{3\\rho^{3/2}}\\,n^{2}l,\\;\\frac{2m+1}{\\sqrt{\\rho}}(M\\cdot n+1)l\\Bigg{)}.$ (7.1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then <span class="math">u_{0},\\ldots,u_{l}</span> have at least <span class="math">\\alpha</span> correlated <span class="math">\\mu</span>-agreement with <span class="math">V</span>, i.e. <span class="math">\\exists v_{0},\\ldots,v_{l}\\in V</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mu(\\{x\\in\\mathcal{D}:\\forall 0\\leq i\\leq l,u_{i}(x)=v_{i}(x)\\})\\geq\\alpha.</span></p>

    <p class="text-gray-300">Similarly, we can also prove a weighted version of the theorem for affine spaces. As was the case in the unweighted version, here the lower bounds on the probability or size of <span class="math">S</span> are the same as they are for affine lines, which can be considered as curves with degree <span class="math">l=1</span>. Again we give two versions, with <span class="math">\\eta</span> and with <span class="math">m</span>:</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Theorem 7.3 (Weighted correlated agreement over affine spaces).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> and let <span class="math">U=u_{0}+\\mathrm{span}\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> be an affine subspace. Let <span class="math">\\alpha\\in(\\sqrt{\\rho},1)</span> and let <span class="math">\\mu:\\mathcal{D}\\to[0,1]</span> be a vector of weights, whose values all have denominator <span class="math">M</span>. Suppose</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\big{[}\\mathrm{agree}_{\\mu}(u,V)\\geq\\alpha\\big{]}&gt;\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\epsilon</span> is as defined in Theorem 1.2 (with <span class="math">\\eta=\\min(\\alpha-\\sqrt{\\rho},\\frac{\\sqrt{\\rho}}{20})</span>), and additionally suppose</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{u\\in U}\\big{[}\\mathrm{agree}_{\\mu}(u,V)\\geq\\alpha\\big{]}\\geq\\frac{M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1}{q}\\bigg{(}\\frac{1}{\\eta}+\\frac{3}{\\sqrt{\\rho}}\\bigg{)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then there exist <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}</span> and <span class="math">v_{0},\\ldots,v_{l}\\in V</span> satisfying</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mu</span>-Density: <span class="math">\\mu(\\mathcal{D}^{\\prime})\\geq\\alpha</span>, and</li>

      <li>Agreement: for all <span class="math">i\\in\\{0,\\ldots,l\\}</span>, the functions <span class="math">u_{i}</span> and <span class="math">v_{i}</span> agree on all of <span class="math">\\mathcal{D}^{\\prime}</span>.</li>

    </ul>

    <h6 id="sec-77" class="text-base font-medium mt-4">Theorem 7.4 (Weighted correlated agreement over affine spaces – Version II).</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">\\mathbf{u}=\\{u_{0},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> and let <span class="math">U=u_{0}+\\mathrm{span}\\{u_{1},\\ldots,u_{l}\\}\\subset\\mathbb{F}_{q}^{\\mathcal{D}}</span> be an affine subspace.. Let <span class="math">\\mu:\\mathcal{D}\\to[0,1]</span> be a vector of weights, whose values all have denominator <span class="math">M</span>. Let <span class="math">m\\geq 3</span> and let</p>

    <p class="text-gray-300"><span class="math">\\alpha\\geq\\alpha_{0}(\\rho,m)\\coloneqq\\sqrt{\\rho}+\\frac{\\sqrt{\\rho}}{2m}.</span></p>

    <p class="text-gray-300">Suppose</p>

    <p class="text-gray-300"><span class="math">\\Pr_{u\\in U}\\big{[}\\mathrm{agree}_{\\mu}(u,V)\\geq\\alpha\\big{]}&gt;\\max\\Bigg{(}\\frac{(1+\\frac{1}{2m})^{7}m^{7}}{3\\rho^{3/2}}\\cdot\\frac{n^{2}}{q},\\;\\frac{2m+1}{\\sqrt{\\rho}}\\cdot\\frac{M\\cdot n+1}{q}\\Bigg{)}.</span> (7.2)</p>

    <p class="text-gray-300">Then <span class="math">u_{0},\\ldots,u_{l}</span> have at least <span class="math">\\alpha</span> correlated <span class="math">\\mu</span>-agreement with <span class="math">V</span>, i.e. <span class="math">\\exists v_{0},\\ldots,v_{l}\\in V</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mu(\\{x\\in\\mathcal{D}:\\forall 0\\leq i\\leq l,u_{i}(x)=v_{i}(x)\\})\\geq\\alpha.</span></p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">7.1 Proof of Theorems 7.1 and 7.2</h3>

    <p class="text-gray-300">The proofs of the theorems rely on the proofs of Theorems 6.1 and 6.2, which in turn were generalizations of the proofs of Theorems 4.1 and 5.1. Let <span class="math">S</span> be as in Theorem 7.2, so that for each <span class="math">z\\in S</span> there is <span class="math">P_{z}\\in V</span> with <span class="math">\\mathrm{agree}_{\\mu}(\\sum_{j=0}^{l}z^{j}u_{j},P_{z})\\geq\\alpha</span>. By definition, the unweighted agreement is at least the weighted agreement, thus <span class="math">\\Delta(\\sum_{j=0}^{l}z^{j}u_{j},P_{z})\\leq 1-\\alpha</span>. It follows that we can immediately apply Theorems 6.1 and 6.2 to the set <span class="math">S</span>, as all other assumptions hold, and deduce that <span class="math">u_{0},\\ldots,u_{l}</span></p>

    <p class="text-gray-300">ve at least <span class="math">\\alpha</span> correlated agreement with codewords <span class="math">v_{0},\\ldots,v_{l}</span>. This is not sufficient, however, as our goal is to show <span class="math">\\mu</span>-agreement, which is stronger.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To continue, we observe that in the course of our proofs, the codewords <span class="math">v_{0},\\ldots,v_{l}</span> that we found had the property that the identity <span class="math">v_{0}+zv_{1}+\\cdots+z^{l}v_{l}=P_{z}</span> was satisfied for every <span class="math">z\\in S^{\\prime}</span>, where <span class="math">S^{\\prime}\\subset S</span> was a fairly large set. In the unique decoding regime this is even true for <span class="math">S^{\\prime}=S</span>, because <span class="math">P_{z}</span> and <span class="math">\\sum_{j=0}^{l}z^{j}v_{j}</span> are both decodings of <span class="math">\\sum_{j=0}^{l}z^{j}u_{j}</span>, and the decoding is unique. In the Johnson bound regime, this is exactly the content of Proposition 5.5, with <span class="math">P(X,Z)</span> (of degree <span class="math">l</span> in <span class="math">Z</span>) written explicitly as <span class="math">P(X,Z)=\\sum_{j=0}^{l}Z^{j}v_{j}</span>, and a set <span class="math">S^{\\prime}</span> of size greater than $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2D_{Y}}<span class="math"> by (5.9). By (5.6) we have </span>2D_{Y}\\leq\\frac{2m+1}{\\sqrt{\\rho}}<span class="math">, and in the setting of Theorem 7.1 we use the definition </span>m=\\left\\lceil\\frac{\\sqrt{\\rho}}{2\\eta}\\right\\rceil$ to get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">2D_{Y}&lt;\\frac{2m+1}{\\sqrt{\\rho}}&lt;\\frac{\\frac{\\sqrt{\\rho}}{\\eta}+3}{\\sqrt{\\rho}}=\\frac{1}{\\eta}+\\frac{3}{\\sqrt{\\rho}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus find that in all cases the additional assumptions give us $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(M\\cdot n+1)l<span class="math">. The crucial aspect here is that these </span>P_{z}<span class="math"> which for </span>z\\in S^{\\prime}<span class="math"> are linear combinations of the </span>v_{j}<span class="math">, are the same </span>P_{z}<span class="math">-s with which we started—which in this setting were assumed to also have high </span>\\mu<span class="math">-agreement with linear combinations of the words </span>u_{j}<span class="math">, and not just regular agreement. In other words, we know that </span>\\sum_{j=0}^{l}z^{j}u_{j}(x)<span class="math"> and </span>\\sum_{j=0}^{l}z^{j}v_{j}(x)<span class="math"> have high </span>\\mu<span class="math">-agreement for every </span>z\\in S^{\\prime}<span class="math">. We can now use this fact to deduce that the </span>v_{j}<span class="math"> also must have correlated </span>\\mu<span class="math">-agreement with </span>u_{j}<span class="math">. The necessary argument is very similar to that of Section 5.2.8, but in higher generality. We apply it through the following two lemmas, first getting the correlated agreement with a small loss, then showing this loss must be </span>0<span class="math">, if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is large enough in comparison to the denominator </span>M$ of the weights – as we had assumed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-79" class="text-base font-medium mt-4">Lemma 7.5.</h6>

    <p class="text-gray-300">Let <span class="math">V,q,n,k</span> and <span class="math">\\rho</span> be as defined in Theorem 1.2. Let <span class="math">u_{0},\\ldots,u_{l}\\in\\mathbb{F}_{q}^{\\mathcal{D}}</span>, <span class="math">v_{0},\\ldots,v_{l}\\in V</span>, let <span class="math">\\mu</span> be a weight vector, and let <span class="math">\\alpha\\geq 0</span>. Denote</p>

    <p class="text-gray-300"><span class="math">w(x,z)=\\sum_{j=0}^{l}z^{j}u_{j}(x),\\quad\\widetilde{w}(x,z)=\\sum_{j=0}^{l}z^{j}v_{j}(x)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for all <span class="math">x\\in\\mathcal{D}</span>, <span class="math">z\\in\\mathbb{F}_{q}</span>, and suppose that there exists a set <span class="math">S^{\\prime}\\subset\\mathbb{F}_{q}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l$ and such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall z\\in S^{\\prime},\\ \\operatorname{agree}_{\\mu}(w(\\cdot,z),\\widetilde{w}(\\cdot,z))\\geq\\alpha.</span> (7.3)</p>

    <p class="text-gray-300">Then the correlated agreement domain of the <span class="math">(u_{j})</span> and <span class="math">(v_{j})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}^{\\prime}=\\{x\\in\\mathcal{D}:(u_{0}(x),\\ldots,u_{l}(x))=(v_{0}(x),\\ldots,v_{l}(x))\\}</span></p>

    <p class="text-gray-300">satisfies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mu(\\mathcal{D}^{\\prime})>\\alpha-\\frac{l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 7.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V,q,n,k,\\rho,\\alpha,\\mu,u_{j},v_{j},S^{\\prime},\\mathcal{D}^{\\prime}</span> be as in Lemma 7.5 and with the same assumptions. Assume additionally that <span class="math">\\mu</span> only takes rational values with denominator (dividing) <span class="math">M</span>, and that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l+l$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mu(\\mathcal{D}^{\\prime})\\geq\\alpha.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As we have seen that <span class="math">S^{\\prime}</span> satisfies the assumptions of Lemma 7.5 and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(M\\cdot n+1)l=M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l+l<span class="math"> holds, our claimed correlated </span>\\mu$-agreement follows immediately from Lemma 7.6. It remains to prove the lemmas, which we do in the next subsection.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.2 Proofs of Lemmas 7.5 and 7.6</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof of Lemma 7.5.</h6>

    <p class="text-gray-300">Denote</p>

    <p class="text-gray-300"><span class="math">S^{\\prime}_{x}</span> <span class="math">=\\{z\\in S^{\\prime}:w(x,z)=\\widetilde{w}(x,z)\\},\\quad\\forall x\\in\\mathcal{D},</span> <span class="math">\\mathcal{D}_{z}</span> <span class="math">=\\{x\\in\\mathcal{D}:w(x,z)=\\widetilde{w}(x,z)\\},\\quad\\forall z\\in S^{\\prime}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that for any given <span class="math">x\\in\\mathcal{D}</span>, <span class="math">w(x,z),\\widetilde{w}(x,z)</span> are both polynomials in <span class="math">z</span> of degree at most <span class="math">l</span>. It follows that if they agree on more than <span class="math">l</span> values of <span class="math">z</span>, then they must be identical as polynomials and agree for <em>every</em> <span class="math">z</span>. Thus, either $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq l<span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Moreover, since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>l<span class="math">, the set </span>\\mathcal{D}^{\\prime}<span class="math"> is precisely the set of </span>x\\in\\mathcal{D}<span class="math"> for which </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\mathcal{D}\\setminus\\mathcal{D}^{\\prime}<span class="math"> is the set on which </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq l<span class="math">. On the other hand, for each </span>z\\in S^{\\prime}<span class="math">, </span>\\mathcal{D}_{z}<span class="math"> is the agreement set of </span>w(\\cdot,z),\\widetilde{w}(\\cdot,z)<span class="math">, so by (7.3), it has </span>\\mu<span class="math">-weighted size at least </span>\\alpha$. Thus by double counting we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sum_{z\\in S^{\\prime}}\\text{agree}_{\\mu}(w(\\cdot,z),\\widetilde{w}(\\cdot,z))=\\sum_{z\\in S^{\\prime}}\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\sum_{x\\in\\mathcal{D}_{z}}\\mu(x)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here, the first inequality is from the lower bound on the <span class="math">\\mu</span>-agreement of <span class="math">w(\\cdot,z),\\widetilde{w}(\\cdot,z)</span>, the next equality is by definition of <span class="math">\\mu</span>-agreement, the next equality is double counting (changing the order of summation), and the final inequality is from bounding the size of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> inside and outside </span>\\mathcal{D}^{\\prime}$. Rearranging, we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mu(\\mathcal{D}^{\\prime})\\geq\\frac{\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\mu(\\mathcal{D})\\cdot l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}=\\alpha-\\frac{(\\mu(\\mathcal{D})-\\alpha)\\cdot l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}>\\alpha-\\frac{l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as claimed. Here the final step uses the simple bound <span class="math">\\mu(\\mathcal{D})-\\alpha&lt;1</span>. ∎</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof of Lemma 7.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the assumption on the values of <span class="math">\\mu</span>, it follows that <span class="math">\\text{agree}_{\\mu}</span> only takes rational values with denominator $M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and similarly so does </span>\\mu(\\mathcal{D}^{\\prime})<span class="math">. We may therefore round </span>\\alpha<span class="math"> up to the nearest multiple of </span>\\frac{1}{M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> without affecting the validity of the assumption (7.3), nor of the wanted consequent </span>\\mu(D^{\\prime})\\geq\\alpha<span class="math">. The assumption </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l+l<span class="math"> is equivalent to </span>\\frac{l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}\\leq\\frac{1}{M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, and thus from Lemma 7.5 we get</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mu(\\mathcal{D}^{\\prime})>\\alpha-\\frac{l}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-l}\\geq\\alpha-\\frac{1}{M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">But, since both <span class="math">\\alpha</span> and <span class="math">\\mu(\\mathcal{D}^{\\prime})</span> are integer multiples of $\\frac{1}{M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, it follows that </span>\\mu(\\mathcal{D}^{\\prime})\\geq\\alpha$, as claimed. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">7.3 Proof of Theorems 7.3 and 7.4</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As was the case in the unweighted version, these theorems are obtained by reduction to the respective theorems on affine lines (which are special cases of Theorems 7.1 and 7.2 with <span class="math">l=1</span>). The reduction is exactly as done in Section 6.3, with the distance <span class="math">\\Delta</span> replaced by the weighted agreement <span class="math">\\text{agree}_{\\mu}</span>; the parameters <span class="math">\\delta,\\delta^{<em>}</span> replaced by <span class="math">\\alpha,\\alpha^{</em>}</span>; all inequalities on agreement being in the opposite direction to those on distances, thus <span class="math">\\alpha^{<em>}\\geq\\alpha</span> is the </em>smallest<em> <span class="math">\\mu</span>-agreement with the code of any <span class="math">u\\in U</span>; and the sizes of the agreement sets <span class="math">\\mathcal{D}_{i},\\mathcal{D}^{\\prime}</span> are replaced by their <span class="math">\\mu</span>-sizes, which are now equal to <span class="math">\\alpha^{</em>}</span> instead of $(1-\\delta^{*})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For this reduction, there are no new nuances introduced by the move to <span class="math">\\mu</span>-weights, and the proof can be reapplied verbatim, with the above mentioned replacements. We thus omit duplicating it here.</p>

    <p class="text-gray-300">8 Applications to Verifiable Secret Sharing and FRI soundness</p>

    <p class="text-gray-300">In this section we give some more details on applications that were briefly described in Section 3.</p>

    <h3 id="sec-84" class="text-xl font-semibold mt-8">8.1 Verifiable Secret Sharing</h3>

    <p class="text-gray-300">We start with an application of distributed proximity testing of Interleaved Reed–Solomon Codes (Theorem 3.1) to verifiable secret sharing (VSS) <em>[x10]</em>. VSS serves as a building block both for useful special tasks, such as simultaneous broadcast and fair coin-flipping, and for general protocols for secure multiparty computation with an honest majority <em>[x5, x11, x12]</em>.</p>

    <p class="text-gray-300">A VSS protocol with security threshold <span class="math">t</span> is a two-phase protocol involving a dealer, <span class="math">n</span> servers, and an honest output client. The sharing phase starts with the dealer distributing the secret <span class="math">s</span> among the servers by sending a share <span class="math">s^{i}</span> to server <span class="math">i</span> and is followed by a verification protocol. In the reconstruction phase, each server sends its share <span class="math">s^{i}</span> to the output client, who reconstructs <span class="math">s</span> from the shares. Both phases of the protocol are attacked by a malicious adversary who may corrupt at most <span class="math">t</span> servers and possibly also the dealer. Communication proceeds in synchronous rounds and may use secure point-to-point channels. We also assume the availability of a common broadcast medium and a source of unpredictable public coins. These assumptions, which can be eliminated at a small amortized cost, make the protocol simpler. Finally, while the communication is synchronous, the adversary has a rushing capability, in the sense that it can wait to receive messages from uncorrupted parties before sending its own messages.</p>

    <p class="text-gray-300">Here we consider a simplified variant of VSS that allows a denial-of-service attack only in the sharing phase, but not in the reconstruction phase. The latter “guaranteed output delivery” requirement makes the protocol suitable for applications that rely on independence, such as simultaneous broadcast and fair coin-tossing, as they prevent the adversary from making the protocol selectively fail based on information obtained in the final round via rushing.</p>

    <p class="text-gray-300">A VSS protocol as above should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: if the dealer is honest and the sharing phase succeeds, the output client outputs <span class="math">s</span>. Moreover, the sharing phase succeeds if the adversary does not attack it.</li>

      <li>Secrecy: if the dealer is honest, the adversary learns nothing about <span class="math">s</span>.</li>

      <li>Unique reconstruction: even if the dealer is dishonest, if the sharing phase succeeds then the messages sent in the sharing phase define a unique <span class="math">s^{<em>}</span> such that (except with small failure probability) the output client will output <span class="math">s^{</em>}</span> in the end of the reconstruction phase.</li>

    </ul>

    <p class="text-gray-300">Implementing VSS efficiently is a challenging task. Here we consider the following simple approach for simultaneously sharing <span class="math">l</span> secrets <span class="math">s_{1},\\ldots,s_{l}</span>. This approach underlies the efficient MPC protocols from <em>[x14, x13, x15]</em>. A centralized variant of this protocol (in a relaxed setting that allows reconstruction to fail) is a building block in efficient two-party protocols for zero knowledge <em>[x16, x2]</em> and secure computation <em>[x15, x16]</em>.</p>

    <p class="text-gray-300">We will assume here that each secret <span class="math">s_{j}</span> is a single field element and all secrets originate from the same dealer. However, the protocol is even more attractive when the secrets originate from different dealers and when each secret <span class="math">s_{j}</span> is a vector of <span class="math">\\ell&lt;n</span> field elements that are simultaneously shared via so-called “packed secret sharing” <em>[x17]</em>. Moreover, while the communication complexity of the protocol beats all competing approaches we are aware of in the amortized case when <span class="math">l</span> is large, it is potentially useful (and nontrivial to analyze) even with <span class="math">l=1</span>. In fact, if we count public coins and</p>

    <p class="text-gray-300">broadcast as normal communication, the communication complexity of the protocol is nontrivial to match even in this case.</p>

    <p class="text-gray-300">The two phases of the protocol proceed as follows.</p>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">Sharing.</h4>

    <p class="text-gray-300">In the sharing phase, the dealer uses Shamir’s secret sharing scheme <em>[x20]</em> for sharing each secret, with secrecy threshold <span class="math">t</span>. Viewed abstractly, each <span class="math">s_{j}</span> is randomly mapped to a codeword <span class="math">u_{j}</span> of an <span class="math">[n,t+1,d]</span> RS code <span class="math">V</span> over <span class="math">\\mathbb{F}_{q}</span>, with <span class="math">d=n-t</span>. The dealer distributes <span class="math">u_{j}</span> between the servers, together with an additional random codeword <span class="math">u_{0}\\in_{R}V</span> that is used for blinding. Following a public random challenge <span class="math">r\\in\\mathbb{F}_{q}^{l}</span>, each server <span class="math">i</span> broadcasts its view of <span class="math">u^{\\prime}=r^{T}\\mathbf{u}</span>, namely <span class="math">u^{\\prime}(i)=u_{0}(i)+\\sum_{j=1}^{l}r(i)u_{j}(i)</span>. Let <span class="math">u^{\\prime}\\in\\mathbb{F}_{q}^{n}</span> be the resulting vector. (As discussed in Section 3, this challenge can be compressed using either cryptography or simple derandomization techniques.) The sharing phase succeeds if <span class="math">u^{\\prime}\\in V</span>.</p>

    <h4 id="sec-86" class="text-lg font-semibold mt-6">Reconstruction.</h4>

    <p class="text-gray-300">In the reconstruction phase, each server sends its shares to an output client, who recovers the secrets <span class="math">s_{j}</span> by error-correcting the (potentially) corrupted codewords <span class="math">u_{j}^{*}</span>.</p>

    <p class="text-gray-300">We assume in the following that <span class="math">n&gt;3t</span>, implying that the minimal distance of the underlying RS code satisfies <span class="math">d=n-t&gt;2t</span>. We start by considering the case of a static adversary, who decides in advance which <span class="math">t</span> servers to corrupt. Completeness follows from the fact that <span class="math">t&lt;d/2</span> and each <span class="math">u_{j}^{<em>}</span> is <span class="math">t</span>-close to <span class="math">V</span>. Secrecy follows from the secrecy property of Shamir’s scheme and from the fact that <span class="math">u_{0}</span> blinds the information exchanged during the verification process. For the unique reconstruction property, consider the shares of the <span class="math">n-t&gt;2t</span> uncorrupted servers. If they are not consistent with <span class="math">V</span>, then (by a simple analysis) the sharing phase will fail except with <span class="math">1/q</span> probability. If they are consistent with <span class="math">V</span>, then (as before) <span class="math">u_{j}^{</em>}</span> is within the unique decoding radius and the outputs will be correct.</p>

    <p class="text-gray-300">What goes wrong when the adversary can be adaptive? In this case, the dealer could potentially distribute badly formed vectors <span class="math">\\mathbf{u}</span> that have the following devious property: there is <span class="math">u_{j}</span> which is very far from the code, and yet <span class="math">u^{\\prime}</span> is with high probability (say, <span class="math">1/2</span>) <span class="math">t</span>-close to the code. Now, the adaptive adversary can corrupt only those servers in <span class="math">T=\\Gamma(u^{\\prime},V)</span> and send on their behalf field elements that make <span class="math">u^{\\prime}</span> consistent with <span class="math">V</span>. This in turn makes the sharing phase succeed. But since <span class="math">u_{j}</span> is not within the unique decoding distance from <span class="math">V</span>, we lose the unique decoding guarantee. Theorem 1.2 rules out the existence of such a devious <span class="math">\\mathbf{u}</span>. But this is not enough. We actually need to ensure that <span class="math">\\mathbf{u}</span> is consistent with <span class="math">V</span> when restricted to the <span class="math">n-t</span> servers that are not corrupted during reconstruction phase.</p>

    <p class="text-gray-300">This is ensured by the stronger guarantee of Theorem 3.1. The analysis proceeds as follows. If <span class="math">\\mathbf{u}</span> is <span class="math">t</span>-far from the interleaved code <span class="math">\\mathbf{V}</span>, then <span class="math">u^{\\prime}</span> will be <span class="math">t</span>-far from <span class="math">V</span> except with <span class="math">\\leq n/q</span> probability. In this event, even an adaptive corruption cannot make <span class="math">u^{\\prime}</span> look consistent with <span class="math">V</span>, and the sharing phase fails. If <span class="math">\\mathbf{u}</span> is within distance <span class="math">t^{\\prime}\\leq t</span> from <span class="math">\\mathbf{V}</span>, then except with <span class="math">\\leq n/q</span> probability we have that <span class="math">\\Gamma(u^{\\prime},V)=\\Gamma(\\mathbf{u},\\mathbf{V})</span>. Denoting this set by <span class="math">T^{\\prime}</span>, the adversary must corrupt the entire set <span class="math">T^{\\prime}</span> for the sharing phase to succeed, and may additional corrupt <span class="math">t-t^{\\prime}</span> more servers. In this case, <span class="math">\\mathbf{u}</span> restricted to the <span class="math">n-t</span> uncorrupted servers is fully consistent with <span class="math">V</span>, guaranteeing unique reconstruction.</p>

    <p class="text-gray-300">We finally note that security against an adaptive adversary can be reduced to security against a static adversary via a generic union bound argument, taking the union over all <span class="math">\\binom{n}{t}</span> sets of servers that can be eventually be corrupted <em>[CDD^{+}04]</em>. (Alternatively, this follows from the simple derivation of proximity gaps over exponentially large fields discussed in the Introduction.) However, this would require the field size <span class="math">q</span> to satisfy <span class="math">q=2^{\\Omega(n)}</span>, which would make communication grow quadratically (rather than linearly) with the number of servers <span class="math">n</span>. In this parameter regime the proximity gap</p>

    <p class="text-gray-300">approach does not seem useful, as there are VSS protocols that meet the quadratic communication bound with perfect (rather than statistical) security against an adaptive adversary [BGW88].</p>

    <h2 id="sec-87" class="text-2xl font-bold">8.2 Soundness of the Fast RS IOP of Proximity (FRI) protocol for batched instances</h2>

    <p class="text-gray-300">In this section we use Theorems 7.2 and 7.4, the weighted and sharper versions of Theorems 1.5 and 1.6, to improve the soundness of the FRI protocol [BBHR18b], when applied to a batch of functions. We start by briefly recalling the essential components of the protocol needed to state our theorem, assuming familiarity with the protocol (see [BBHR18b] for a more thorough explanation of it). We also explain below the meaning of "batching" of FRI instances.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>The FRI protocol</strong> As explained in Section 3.2, the purpose of FRI is to verify, in the IOP model, the proximity of a received word <span class="math">f^{(0)}: \\mathcal{D}^{(0)} \\to \\mathbb{F}</span> to an RS code <span class="math">V^{(0)} := \\mathsf{RS}[\\mathbb{F}, \\mathcal{D}^{(0)}, k^{(0)}]</span>. FRI works for any evaluation domain <span class="math">\\mathcal{D}^{(0)}</span> that is a coset of 2-smooth group, i.e., for any <span class="math">\\mathcal{D}^{(0)}</span> that is a coset of a group (additive or multiplicative) of size <span class="math">2^s</span>, for integer <span class="math">s</span>. Henceforth we assume the group <span class="math">\\mathcal{D}^{(0)}</span> is multiplicative<span class="math">^6</span>. The FRI protocol has two phases, called COMMIT and QUERY. During the COMMIT phase, a sequence of functions <span class="math">f^{(1)}: \\mathcal{D}^{(1)} \\to \\mathbb{F}, f^{(2)}: \\mathcal{D}^{(2)} \\to \\mathbb{F}, \\ldots, f^{(\\mathfrak{r})}: \\mathcal{D}^{(\\mathfrak{r})} \\to \\mathbb{F}</span> is generated over a finite number <span class="math">\\mathfrak{r}</span> of interactive rounds. With each iteration the domain size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> shrinks. Assuming an honest prover and </span>f^{(0)}<span class="math"> being low-degree, the low-degreeeness property is maintained for each </span>f^{(i)}<span class="math"> (see Claim 8.1). At the beginning of the </span>i<span class="math">-th round, the prover message </span>f^{(i)}: \\mathcal{D}^{(i)} \\to \\mathbb{F}<span class="math"> has already been created (and the verifier has oracle access to it). The verifier now sends a uniformly random </span>z^{(i)} \\in \\mathbb{F}<span class="math"> and the prover replies with a new function </span>f^{(i+1)}: \\mathcal{D}^{(i+1)} \\to \\mathbb{F}<span class="math"> where </span>\\mathcal{D}^{(i+1)}<span class="math"> is a (2-smooth) strict subgroup of </span>\\mathcal{D}^{(i)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{D}^{(i + 1)}</span> partitions <span class="math">\\mathcal{D}^{(i)}</span> into cosets of size $l^{(i)}\\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i + 1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>C_g^{(i)}<span class="math"> denote the coset corresponding to </span>g\\in D^{(i + 1)}$, namely</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">C _ {g} ^ {(i)} := \\left\\{g ^ {\\prime} \\in \\mathcal {D} ^ {(i)} \\mid \\left(g ^ {\\prime}\\right) ^ {l ^ {(i)}} = g \\right\\}. \\tag {8.1}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each coset <span class="math">C_g^{(i)}</span>, the interpolation map <span class="math">M_g^{(i)}</span> is the invertible linear map <span class="math">M_g^{(i)}: \\mathbb{F}^{C_g^{(i)}} \\to \\mathbb{F}^{l^{(i)}}</span> over <span class="math">\\mathbb{F}</span> that maps $f^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C_g^{(i)}}: C_g^{(i)} \\to \\mathbb{F}<span class="math"> — the restriction of </span>f^{(i)}<span class="math"> to domain </span>C_g^{(i)} \\subset \\mathcal{D}^{(i)}<span class="math"> — to the vector </span>\\mathbf{u}^{(i)}(g) = (u_0^{(i)}(g), \\ldots, u_{l^{(i)} - 1}^{(i)}(g))<span class="math"> of coefficients of the polynomial </span>P_{\\mathbf{u}^{(i)}(g)}(Z) = \\sum_{j &lt; l^{(i)}} Z^j \\cdot (u_j^{(i)}(g))<span class="math"> that interpolates </span>f^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C_g^{(i)}}<span class="math">. In other words, </span>M_g^{(i)}<span class="math"> is the inverse of the Vandermonde matrix generated by </span>C_g^{(i)}<span class="math">, which implies that </span>\\left(M_g^{(i)}\\right)^{-1} \\cdot (u_0, \\ldots, u_{l^{(i)} - 1})<span class="math"> is the evaluation of the polynomial </span>P_{\\mathbf{u}}(X) = \\sum_{i &lt; (i)} u_i X^i<span class="math"> on the coset </span>C_g^{(i)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following claim is a restatement of [BBHR18b, Section 4.1], using our notation (and working over a multiplicative rather than additive group). For the sake of completeness a proof appears in Appendix E.</p>

    <p class="text-gray-300"><strong>Claim 8.1.</strong> Suppose that <span class="math">f^{(i)} \\in \\mathsf{RS}[\\mathbb{F}, \\mathcal{D}^{(i)}, k^{(i)}]</span> where <span class="math">k^{(i)} + 1</span> is an integral power of 2. Then, for any <span class="math">z^{(i)} \\in \\mathbb{F}</span>, letting <span class="math">\\mathbf{z}^{(i)} = \\left(\\left(z^{(i)}\\right)^0, \\left(z^{(i)}\\right)^1, \\ldots, \\left(z^{(i)}\\right)^{l^{(i)} - 1}\\right)</span>, the function <span class="math">f_{f^{(i)}, z^{(i)}}^{(i + 1)}: \\mathcal{D}^{(i + 1)} \\to \\mathbb{F}</span></p>

    <p class="text-gray-300">6The FRI protocol in [BBHR18b] is stated for cosets of additive 2-smooth groups; Remark 3.1 in the online version of [BBHR18b] translates the results to multiplicative groups (cf. Remark 1.4 and Section 2.1 there). Generalizing the results here to (i) additive groups, (ii) <span class="math">t</span>-smooth groups for larger constant <span class="math">t</span> and (iii) cosets of groups, is straightforward, using [BBHR18b]; we omit these generalizations to simplify the exposition.</p>

    <p class="text-gray-300">defined on <span class="math">g\\in\\mathcal{D}^{(i+1)}</span> by</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f^{(i+1)}_{f^{(i)},z^{(i)}}(g):=\\left(\\mathbf{z}^{(i)}\\right)^{\\top}\\cdot\\mathbf{u}^{(i)}(g)=\\left(\\mathbf{z}^{(i)}\\right)^{\\top}\\cdot M_{g}^{(i)}\\cdot\\left.f^{(i)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C_{g}^{(i)}}$ (8.2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">is a valid codeword of <span class="math">V^{(i+1)}:=\\mathsf{RS}[\\mathbb{F},\\mathcal{D}^{(i+1)},k^{(i+1)}]</span> where <span class="math">k^{(i+1)}:=\\frac{k^{(i)}+1}{l^{(i)}}-1</span>.</p>

    <h4 id="sec-88" class="text-lg font-semibold mt-6">Batching</h4>

    <p class="text-gray-300">In certain cases the first prover oracle <span class="math">f^{(0)}</span> is sampled from an affine space <span class="math">F\\subset\\mathbb{F}^{\\mathcal{D}^{(0)}}</span> of functions, which serves as our input,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$F=\\left\\{f^{(0)}_{0}+\\sum_{i=1}^{t}x_{i}\\cdot f^{(0)}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}\\in\\mathbb{F},f^{(0)}_{i}:\\mathcal{D}^{(0)}\\to\\mathbb{F}\\right\\}.$ (8.3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This is the case when the FRI protocol is used to “batch” several different instances of the low degree testing problem, combining them all using a random linear combination. In this batching setting we assume the prover has committed to <span class="math">f^{(0)}_{1},\\ldots,f^{(0)}_{t}</span> (notice we set <span class="math">f^{(0)}_{0}=0</span> in this case), and the batched FRI verifier samples uniformly random <span class="math">x_{1},\\ldots,x_{t}\\in\\mathbb{F}</span>, the prover replies with <span class="math">f^{(0)}</span> which supposedly equals <span class="math">f^{(0)}_{0}+\\sum_{i}x_{i}\\cdot f^{(0)}_{i}</span>, and the FRI protocol is now applied to <span class="math">f^{(0)}</span>. Accordingly, the batched FRI QUERY phase is extended so that each time a query to <span class="math">f^{(0)}(g)</span> is requested, the verifier also queries <span class="math">f^{(0)}_{0}(g),\\ldots,f^{(0)}_{t}(g)</span> and verifies that indeed <span class="math">f^{(0)}(g)=f^{(0)}_{0}(g)+\\sum_{i}f^{(0)}_{i}(g)</span>.</p>

    <h4 id="sec-89" class="text-lg font-semibold mt-6">The (batched) FRI QUERY phase</h4>

    <p class="text-gray-300">Claim 8.1 implies that an honest prover may construct from a codeword <span class="math">f^{(i)}\\in V^{(i)}</span> a new codeword <span class="math">f^{(i+1)}\\in V^{(i+1)}</span> (for any value <span class="math">z^{(i)}</span> picked by the verifier), doing so by computing Eq. (8.2) for each <span class="math">g\\in\\mathcal{D}^{(i+1)}</span>. Henceforth we shall always assume <span class="math">f^{(\\mathsf{r})}\\in V^{(\\mathsf{r})}</span>, say, by assuming the verifier always queries the first <span class="math">k^{(\\mathsf{r})}</span> elements of <span class="math">f^{(\\mathsf{r})}</span> (according to some canonical order) and identifies <span class="math">f^{(\\mathsf{r})}</span> with the interpolating polynomial of this function.</p>

    <p class="text-gray-300">Claim 8.1 suggests a natural test for consistency between <span class="math">f^{(i)}</span> and <span class="math">f^{(i+1)}</span>, and the QUERY phase of FRI follows this natural test by applying it iteratively from “top” (<span class="math">f^{(\\mathsf{r})}</span>) to “bottom” (<span class="math">f^{(0)}</span>), according to the following process</p>

    <h4 id="sec-90" class="text-lg font-semibold mt-6">A single invocation of the batched QUERY phase:</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick uniformly random <span class="math">g^{(\\mathsf{r})}\\in\\mathcal{D}^{(\\mathsf{r})}</span>. For <span class="math">i=\\mathsf{r},\\ldots,1</span>, sample <span class="math">g^{(i-1)}</span> uniformly at random from the coset <span class="math">C_{g^{(i)}}^{(i-1)}</span>.</li>

      <li>If <span class="math">f^{(0)}(g^{(0)})\\neq\\ f^{(0)}_{0}(g^{(0)})+\\sum_{i=1}^{t}x_{i}\\cdot f^{(0)}_{i}(g^{(0)})</span>, then reject.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. If, for any <span class="math">i\\in\\{0,\\ldots,\\mathsf{r}-1\\}</span>, we have $f^{(i+1)}(g^{(i+1)})\\neq\\left(\\mathbf{z}^{(i)}\\right)^{\\top}\\cdot M_{g^{(i+1)}}^{(i)}\\cdot\\left.f^{(i)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C_{g^{(i+1)}}^{(i)}}$, then reject.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise — when equality holds in all cases mentioned in the bullets above, then accept.</li>

    </ol>

    <h4 id="sec-91" class="text-lg font-semibold mt-6">Summary of the batched FRI protocol:</h4>

    <p class="text-gray-300">Let us summarize the essential properties recounted thus far, as they will be used in our soundness analysis below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of the protocol’s COMMIT phase the verifier has oracle access to a sequence of functions <span class="math">f^{(0)}:\\mathcal{D}^{(0)}\\to\\mathbb{F},\\ldots,f^{(\\mathsf{r})}:\\mathcal{D}^{(\\mathsf{r})}\\to\\mathbb{F}</span> where <span class="math">\\mathcal{D}^{(0)}\\supsetneq\\ldots,\\supsetneq\\mathcal{D}^{(\\mathsf{r})}</span> is a sequence of 2-smooth groups and <span class="math">f^{(i)}</span> depends arbitrarily on <span class="math">z^{(0)},\\ldots,z^{(i)}</span> (and <span class="math">f^{(0)},\\ldots,f^{(i-1)}</span>). We assume that <span class="math">f^{(\\mathsf{r})}\\in V^{(\\mathsf{r})}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. There exists a set of <span class="math">l^{(i)}\\times l^{(i)}</span> invertible matrices <span class="math">\\{M^{(i)}_{g^{(i+1)}}:g^{(i+1)}\\in\\mathcal{D}^{(i+1)}\\}</span>, so that applying <span class="math">M^{(i)}_{g^{(i+1)}}</span> to $f^{(i)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{C^{(i)}_{g^{(i+1)}}}<span class="math"> maps </span>f^{(i)}<span class="math"> to a sequence of vectors </span>\\mathbf{u}=\\mathbf{u}^{(i)}=\\{u^{(i)}_{0},\\ldots,u^{(i)}_{l^{(i)}}\\}\\subset\\mathbb{F}^{\\mathcal{D}^{(i+1)}}$, where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{u}^{(i)}\\left(g^{(i+1)}\\right)=\\left(u^{(i)}_{0}\\left(g^{(i+1)}\\right),\\ldots,u^{(i)}_{l^{(i)}-1}\\left(g^{(i+1)}\\right)\\right)=M^{(i)}_{g^{(i+1)}}\\cdot f^{(i)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{C^{(i)}_{g^{(i+1)}}}.$ (8.4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, if <span class="math">f^{(i)}</span> is a valid RS codeword over <span class="math">\\mathcal{D}^{(i)}</span> of rate <span class="math">\\rho</span>, then each vector on the parameterized curve passing through <span class="math">\\mathbf{u}^{(i)}</span> is a valid RS codeword over <span class="math">\\mathcal{D}^{(i+1)}</span> of the same rate <span class="math">\\rho</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each iteration of the QUERY phase checks whether <span class="math">f^{(i+1)}</span> was constructed from <span class="math">f^{(i)}</span> via Eq. (8.2) and (in the batched case) whether <span class="math">f^{(0)}</span> was computed correctly via Eq. (8.3).</li>

    </ol>

    <h5 id="sec-92" class="text-base font-semibold mt-4">Soundness</h5>

    <p class="text-gray-300">We now bound the soundness error of the batched FRI protocol, using Theorems 7.1 and 7.2. Recall the notion of correlated agreement from Section 1.3 and its generalization to <span class="math">\\mu</span>-weighted correlated agreement defined at the beginning of Section 7.</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Lemma 8.2 (batched FRI error bound).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V^{(0)}=\\mathsf{RS}[\\mathbb{F},\\mathcal{D}^{(0)},k^{(0)}]</span> where <span class="math">\\mathcal{D}^{(0)}</span> is a coset of a <span class="math">2</span>-smooth multiplicative group, and <span class="math">k^{(0)}+1</span> is a power of <span class="math">2</span>; set $\\rho=(k^{(0)}+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">F\\subseteq\\mathbb{F}^{\\mathcal{D}^{(0)}}</span> be a space of functions as defined in Eq. (8.3) whose correlated agreement density with <span class="math">V^{(0)}</span> is at most <span class="math">\\alpha</span>. For integer <span class="math">m\\geq 3</span>, let</p>

    <p class="text-gray-300"><span class="math">\\alpha^{(0)}(\\rho,m)=\\max\\{\\alpha,\\sqrt{\\rho}(1+1/2m)\\}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume the FRI protocol is used with <span class="math">\\mathsf{r}</span> rounds, and let $l^{(i)}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote the ratio between prover messages (oracles) </span>i<span class="math"> and </span>i+1<span class="math">. Let </span>\\epsilon_{\\mathsf{Q}}$ denote the probability that the verifier accepts a single FRI QUERY invocation. Then,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{x_{1},\\ldots,x_{t},z^{(0)},\\ldots,z^{(r-1)}}\\left[\\epsilon_{\\mathsf{Q}}&gt;\\alpha^{(0)}(\\rho,m)\\right]\\leq\\epsilon_{\\mathsf{C}},</span> (8.5)</p>

    <p class="text-gray-300">where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\mathsf{C}}=\\frac{\\left(m+\\frac{1}{2}\\right)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{2\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{(2m+1)\\cdot(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1)}{\\sqrt{\\rho}}\\cdot\\frac{\\sum_{i=0}^{r-1}l^{(i)}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In words: For any interactive FRI prover <span class="math">P^{<em>}</span>, the probability that the oracles <span class="math">f^{(0)},\\ldots,f^{(\\mathsf{r})}</span> sent by <span class="math">P^{</em>}</span> will pass a single invocation of the batched FRI QUERY test with probability greater than <span class="math">\\alpha^{(0)}(\\rho,m)</span>, is smaller than <span class="math">\\epsilon_{\\mathsf{C}}</span>. The probability is over the random variables <span class="math">x_{1},\\ldots,x_{t}</span> used to sample <span class="math">f^{(0)}</span> from <span class="math">F</span> and over the random messages <span class="math">z^{(0)},\\ldots,z^{(\\mathsf{r}-1)}</span> sent by the verifier during the COMMIT phase.</p>

    <p class="text-gray-300">The previous lemma gives us the following result.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Theorem 8.3 (Batched FRI Soundness).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">f^{(0)}_{0},\\ldots,f^{(0)}_{t}:\\mathcal{D}^{(0)}\\to\\mathbb{F}</span> be a sequence of functions and let <span class="math">V^{(0)}=\\mathsf{RS}[\\mathbb{F},\\mathcal{D}^{(0)},k^{(0)}]</span> where <span class="math">\\mathcal{D}^{(0)}</span> is a coset of a <span class="math">2</span>-smooth group of size $n^{(0)}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\rho=\\frac{k^{(0)}+1}{n^{(0)}}<span class="math"> satisfies </span>\\rho=2^{-\\mathsf{R}}<span class="math"> for positive integer </span>\\mathsf{R}<span class="math">. Let </span>\\alpha=\\sqrt{\\rho}(1+1/2m)<span class="math"> for integer </span>m\\geq 3<span class="math"> and </span>\\epsilon_{\\mathsf{C}}$ be as defined in Lemma 8.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume the FRI protocol is used with <span class="math">\\mathsf{r}</span> rounds. Let $l^{(i)}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote the ratio between prover messages (oracles) </span>i<span class="math"> and </span>i+1<span class="math">. Assume furthermore that </span>s$ is the number of invocations of the FRI QUERY step.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Suppose there exists a batched FRI prover <span class="math">P^{*}</span> that interacts with the batched FRI verifier and causes it to output “accept” with probability greater than</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\sf FRI}:=\\epsilon_{\\sf C}+\\alpha^{s}=\\frac{\\left(m+\\frac{1}{2}\\right)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{2\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{(2m+1)\\cdot(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1)}{\\sqrt{\\rho}}\\cdot\\frac{\\sum_{i=0}^{r-1}l^{(i)}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\left(\\sqrt{\\rho}\\cdot\\left(1+\\frac{1}{2m}\\right)\\right)^{s}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then <span class="math">f^{(0)}_{0},\\ldots,f^{(0)}_{t}</span> have correlated agreement with <span class="math">V^{(0)}</span> on a domain <span class="math">\\mathcal{D}^{\\prime}\\subset\\mathcal{D}^{(0)}</span> of density at least <span class="math">\\alpha</span>.</p>

    <h5 id="sec-95" class="text-base font-semibold mt-4">Numerical Example:</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">q\\geq 2^{256}</span>, $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{20}<span class="math">, </span>\\rho=2^{-4}<span class="math">, so </span>k+1=2^{16}<span class="math">, an entirely reasonable choice for practical applications (In STARKs, </span>k<span class="math"> corresponds to the length of a computation for which a STARK proof is being generated). Set </span>m=2^{11}-1<span class="math"> and notice </span>\\sum(l^{(i)}-1)\\leq n$, so</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\sf C}&lt;\\frac{(2^{11})^{7}\\cdot 2^{40}}{2\\cdot 2^{-6}\\cdot 2^{256}}+\\frac{2^{11}\\cdot 2^{21}}{2^{-2}}\\cdot\\frac{2^{20}}{2^{256}}&lt;2^{-133}.</span></p>

    <p class="text-gray-300">Assume the maximal correlated agreement density of <span class="math">f^{(0)}_{0},\\ldots,f^{(0)}_{t}</span> with <span class="math">\\mathsf{RS}[\\mathbb{F},\\mathcal{D}^{(0)},k+1]</span> is at most</p>

    <p class="text-gray-300"><span class="math">\\alpha=\\sqrt{\\rho}(1+1/2m)\\approx 0.25006\\ldots\\ldots\\approx\\frac{1}{4}.</span></p>

    <p class="text-gray-300">Invoking the QUERY protocol for <span class="math">s=65</span> invocations gives</p>

    <p class="text-gray-300"><span class="math">\\alpha^{s}\\approx 0.25006^{65}&lt;2^{-129.97}</span></p>

    <p class="text-gray-300">So the total FRI error is bounded by</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\sf FRI}\\leq\\epsilon_{\\sf C}+\\alpha^{s}&lt;2^{-128}.</span></p>

    <p class="text-gray-300">In words, if the FRI protocol accepts with probability greater than <span class="math">2^{-128}</span> then <span class="math">f^{(0)}_{0},\\ldots,f^{(0)}_{t}</span> have correlated agreement with <span class="math">V^{(0)}</span> of density greater than <span class="math">\\alpha</span>. Thus we get 128-bits of provable soundness for the FRI protocol for this setting of parameters and 65 invocations of the QUERY phase.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Proof of Theorem 8.3.</h6>

    <p class="text-gray-300">The proof follows directly from Lemma 8.2 by way of contradiction. Suppose the maximal correlated agreement of <span class="math">f^{(0)}_{0},\\ldots,f^{(0)}_{t}</span> with <span class="math">V^{(0)}</span> is less than <span class="math">\\alpha^{(0)}(\\rho,m)=\\sqrt{\\rho}(1+1/2m)</span>, yet the probability of acceptance is greater than <span class="math">\\epsilon_{\\sf C}+(\\alpha^{(0)}(\\rho,m))^{s}</span>.</p>

    <p class="text-gray-300">Let <span class="math">E</span> be the event that each FRI QUERY accepts with probability greater than <span class="math">\\alpha^{(0)}(\\rho,m)</span>. This event depends on <span class="math">x_{1},\\ldots,x_{t},f^{(0)},z^{(0)},f^{(1)},\\ldots,z^{(r-1)},f^{(r)}</span>, where each <span class="math">f^{(i)}</span> is generated by <span class="math">P^{<em>}</span> in response to prior verifier messages. By Lemma 8.2, for any prover <span class="math">P^{</em>}</span>, the probability of the event <span class="math">E</span> is bounded by <span class="math">\\epsilon_{\\sf C}</span>. When <span class="math">E</span> does not hold, then the probability of the event that <span class="math">s</span> independent invocations of the FRI QUERY all return “accept”, is bounded by <span class="math">(\\alpha_{0}(\\rho,m))^{s}</span>.</p>

    <p class="text-gray-300">We conclude the probability of acceptance of the FRI verifier is bounded by <span class="math">\\epsilon_{\\sf C}+(\\alpha^{(0)}(\\rho,m))^{s}</span>, contradicting our assumption. ∎</p>

    <h5 id="sec-97" class="text-base font-semibold mt-4">Discussion and Two Open Questions</h5>

    <p class="text-gray-300">Theorem 8.3 improves on the previous state of the art, due to <em>[x10, x11]</em>, in several ways. First, as explained in Section 3.2, the prior state of the art required a proximity parameter that is smaller than the “one-and-a-half Johnson bound”: <span class="math">\\delta&lt;1-\\sqrt[3]{\\rho}</span>; the current result pushes the proximity parameter (for large fields) up to the Johnson/Guruswami–Sudan bound. Second, the error parameter during the COMMIT phase was worse, and the analysis incurred an additional loss in the proximity parameter during the QUERY phase, which led to worse concrete soundness bounds across all proximity parameter settings. Last, but not least, the prior bounds on <span class="math">\\delta</span> (above the unique decoding radius) were only valid for the case where the “folding</p>

    <p class="text-gray-300">parameters” <span class="math">l^{(0)},\\ldots,l^{(r-1)}</span> were all equal to the fixed value <span class="math">l^{\\star}=2</span>, and deteriorated swiftly for larger <span class="math">l^{(i)}</span> (they only work up to radius <span class="math">1-\\;^{(l^{(i)}+1)}\\sqrt[n]{\\rho}</span>). The current bounds deteriorate much more slowly with <span class="math">l^{(i)}</span>, and this is important because large values of <span class="math">l^{(i)}</span> are often preferable in practice.</p>

    <p class="text-gray-300">Ben-Sasson et al. showed in <em>[x1]</em> that for the FRI protocol to achieve security parameter <span class="math">\\lambda</span> (i.e., <span class="math">\\epsilon_{\\textsf{FRI}}\\leq 2^{-\\lambda}</span>), we need to use at least <span class="math">s\\geq\\lambda/\\log\\frac{1}{\\rho}</span> invocations of the QUERY phase, and conjectured that this lower bound on <span class="math">s</span> is also sufficient (for sufficiently large fields). As noted earlier in Section 3.2 our results imply that taking <span class="math">s\\approx 2\\lambda/\\log\\frac{1}{\\rho}</span> suffices to get security parameter <span class="math">\\lambda</span> for quadratically large fields. Closing the gap between the provable upper and lower bounds on <span class="math">s</span> is left as an interesting open problem. Concretely, the following conjectured improvement to our main correlated agreement theorem (Theorem 1.4) will imply the conjecture of <em>[x1]</em>. To the best of our knowledge, nothing contradicts setting <span class="math">c_{1}=c_{2}=2</span> in the conjecture below. When limiting the scope to fields of characteristic greater than <span class="math">k</span> (degree of the RS code), we are not aware of anything contradicting <span class="math">c_{1}=c_{2}=1</span>; note that <em>[x3, Appendix B]</em> shows these smaller exponents cannot hold for fields of characteristic two.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Conjecture 8.4.</h6>

    <p class="text-gray-300">There exist constants <span class="math">c_{1},c_{2}</span> such that the following statements hold for all <span class="math">\\eta&gt;0</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Theorems 1.2, 1.4 and 1.6 hold for proximity parameter <span class="math">\\delta\\leq 1-\\rho-\\eta</span> with error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon\\leq\\frac{1}{(\\eta\\rho)^{c_{1}}}\\cdot\\frac{n^{c_{2}}}{q}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Theorem 1.5 holds for proximity parameter <span class="math">\\delta\\leq 1-\\rho-\\eta</span> and parameterized curves of degree <span class="math">l</span> with error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\epsilon\\leq\\frac{1}{(\\eta\\rho)^{c_{1}}}\\cdot\\frac{(l\\cdot n)^{c_{2}}}{q}.</span></p>

    <p class="text-gray-300">DEEP FRI is another Reed-Solomon Proximity Testing (RPT) protocol that is closely related to FRI (as its name suggests). Introduced in <em>[x3]</em>, it is slightly less efficient (in terms of prover and verifier complexity) than FRI because it requires more from the prover, making it harder for a malicious prover to cheat. Prior to this work, the extra complexity of DEEP FRI led to improved soundness, which reaches the Johnson/Guruswami–Sudan bound. But Theorem 8.3 shows that FRI has soundness which also reaches the same bound. Moreover, when approaching the Johnson bound, DEEP FRI requires cubic size fields for the arguments to work, whereas FRI is shown here to require only quadratic size fields. Thus, according to our new understanding, in terms of both complexity and field size, FRI dominates DEEP FRI, even though DEEP FRI demands strictly more from the prover side. This raises an interesting second question: understanding how the techniques developed here may be combined with the techniques of the DEEP FRI protocol to derive better soundness bounds for DEEP FRI and new, improved RPT protocols.</p>

    <h4 id="sec-99" class="text-lg font-semibold mt-6">8.2.1 Proof of Lemma 8.2</h4>

    <p class="text-gray-300">Recall that the prover sends a function <span class="math">f^{(i+1)}</span> in response to the random choice of <span class="math">z^{(i)}</span>. In the FRI QUERY phase, the function <span class="math">f^{(i+1)}</span> will be checked for consistency with <span class="math">f^{(i)}</span>. We now introduce a way to keep track of the consistencies and inconsistencies.</p>

    <p class="text-gray-300">Define a sequence of weight functions <span class="math">\\mu^{(i)}:\\mathcal{D}^{(i)}\\to[0,1]</span> and <span class="math">\\nu^{(i)}:\\mathcal{D}^{(i)}\\to[0,1]</span> inductively for <span class="math">i=0,\\ldots,\\mathsf{r}</span>. For <span class="math">i=0</span>, we assign <span class="math">\\{0,1\\}</span> weights indicating whether <span class="math">f^{(0)}(g)</span> is computed correctly:</p>

    <p class="text-gray-300">\\[ \\mu^{(0)}(g)=\\left\\{\\begin{array}[]{ll}1&f^{(0)}(g)=f^{(0)}_{0}(g)+\\sum_{i=1}^{t}x_{i}f^{(0)}_{i}(g)\\\\ 0&\\text{otherwise}\\end{array}\\right. \\]</p>

    <p class="text-gray-300">Now, we inductively define an auxiliary weight <span class="math">\\nu^{(i+1)}:\\mathcal{D}^{(i+1)}\\to[0,1]</span>. Recall the coset <span class="math">C^{(i)}_{g}\\subset\\mathcal{D}^{(i)}</span> from Eq. (8.1). Then</p>

    <p class="text-gray-300"><span class="math">\\nu^{(i+1)}(g)=\\mathbb{E}_{g^{\\prime}\\in C^{(i)}_{g}}[\\mu^{(i)}(g^{\\prime})].</span> (8.6)</p>

    <p class="text-gray-300">In words, <span class="math">\\nu^{(i+1)}(g)</span> is the expected <span class="math">\\mu^{(i)}</span> weight of a member of the coset <span class="math">C^{(i)}_{g}</span>. Finally, we define the weight function <span class="math">\\mu^{(i+1)}</span> thus for each <span class="math">g\\in\\mathcal{D}^{(i+1)}</span>:</p>

    <p class="text-gray-300">\\[ \\mu^{(i+1)}(g)=\\left\\{\\begin{array}[]{ll}\\nu^{(i+1)}(g)&f^{(i+1)}(g)=f^{(i+1)}_{f^{(i)},z^{(i)}}(g)\\\\ 0&\\text{otherwise}\\end{array}\\right. \\]</p>

    <p class="text-gray-300">The key property of the above definition of the <span class="math">\\mu^{(i)}</span> is that <span class="math">\\mu^{(i)}(g)</span> is a measure of the success probability of the FRI QUERY phase conditioned on <span class="math">g</span> being queried from <span class="math">f^{(i)}</span>. This is the underlying reason behind the following claim.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Claim 8.5.</h6>

    <p class="text-gray-300">The probability <span class="math">\\epsilon_{\\mathsf{Q}}</span> that a single invocation of the batched FRI QUERY accepts <span class="math">f^{(0)},\\ldots,f^{(\\mathsf{r})}</span>, where <span class="math">f^{(\\mathsf{r})}\\in\\mathsf{RS}[\\mathbb{F},\\mathcal{D}^{(\\mathsf{r})},k^{(\\mathsf{r})}]</span>, satisfies</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\mathsf{Q}}=\\mathbb{E}_{g^{(\\mathsf{r})}\\in\\mathcal{D}^{(\\mathsf{r})}}\\left[\\mu^{(\\mathsf{r})}\\left(g^{(\\mathsf{r})}\\right)\\right].</span></p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that the FRI QUERY invocation picks a random sequence <span class="math">g^{(\\mathsf{r})},\\ldots,g^{(0)}</span> as described above, where <span class="math">g^{(i-1)}</span> is sampled uniformly at random from <span class="math">C^{(i-1)}_{g^{(i)}}</span>. We prove by induction on <span class="math">i=0,\\ldots,\\mathsf{r}</span> that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}_{g^{(i)}\\in\\mathcal{D}^{(i)}}\\left[\\mu^{(i)}\\left(g^{(i)}\\right)\\right]</span></p>

    <p class="text-gray-300">equals the probability that, when sampling a uniformly random <span class="math">g^{(i)}</span> and generating from it the random sequence <span class="math">g^{(i-1)}\\in C^{(i-1)}_{g^{(i)}},\\ldots,g^{(0)}\\in C^{(0)}_{g^{(1)}}</span>, all tests associated with <span class="math">g^{(i)}</span> and its induced sequence accept.</p>

    <p class="text-gray-300">The base case follows from the definition of <span class="math">\\mu^{(0)}</span>. For the inductive case, notice <span class="math">\\mu^{(i)}(g^{(i)})</span> equals <span class="math">0</span> when <span class="math">f^{(i)}(g^{(i)})</span> is not computed correctly as per Eq. (8.2), and otherwise it is the average of the values of <span class="math">\\mu^{(i-1)}</span> on the coset <span class="math">C^{(i-1)}_{g^{(i)}}\\subseteq\\mathcal{D}^{(i-1)}</span>, which, by the inductive assumption, is the expectation that the tests associated with <span class="math">g^{(i-1)},\\ldots,g^{(0)}</span> are all accepted. ∎</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Proof of Lemma 8.2.</h6>

    <p class="text-gray-300">In light of Claim 8.5 it suffices to prove that with probability <span class="math">1-\\epsilon_{\\mathsf{C}}</span> over the random choices of the verifier,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}_{g\\in\\mathcal{D}^{(\\mathsf{r})}}\\left[\\mu^{(\\mathsf{r})}(g)\\right]\\leq\\alpha^{(0)}(\\rho,m).</span> (8.7)</p>

    <p class="text-gray-300">We define a sequence of bad events <span class="math">E^{(0)},\\ldots,E^{(\\mathsf{r})}</span> and bound the sum of their probabilities by <span class="math">\\epsilon_{\\mathsf{C}}</span>. Assuming none of the bad events occurred, we shall show that Eq. (8.7) holds.</p>

    <p class="text-gray-300">Let <span class="math">E^{(0)}</span> be the event</p>

    <p class="text-gray-300"><span class="math">\\text{agree}_{\\mu^{(0)}}\\left(f^{(0)},V^{(0)}\\right)&gt;\\alpha^{(0)}(\\rho,m).</span></p>

    <p class="text-gray-300">The definition of <span class="math">\\mu^{(0)}</span> implies that the event <span class="math">E^{(0)}</span> is</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}\\left(f_{0}^{(0)}+\\sum_{i=1}^{t}x_{i}f_{i}^{(0)},V^{(0)}\\right)&gt;\\alpha^{(0)}(\\rho,m)=\\max(\\alpha,\\sqrt{\\rho}(1+1/2m)).</span></p>

    <p class="text-gray-300">This event depends on <span class="math">x_{1},\\ldots,x_{t}</span>. By assumption the maximal correlated agreement density of <span class="math">(f_{0}^{(0)},\\ldots f_{t}^{(0)})</span> with <span class="math">V^{(0)}</span> is at most <span class="math">\\alpha</span>. So Theorem 7.4 (with <span class="math">\\alpha=\\alpha^{(0)}(\\rho,m)</span> and <span class="math">\\mu\\equiv 1</span>, <span class="math">M=1</span>) implies:</p>

    <p class="text-gray-300"><span class="math">\\Pr_{x_{1},\\ldots,x_{t}}[E^{(0)}]\\leq\\epsilon,\\text{ where }\\epsilon=\\frac{\\left(m+\\frac{1}{2}\\right)^{7}}{3\\rho^{3/2}}\\cdot\\frac{n^{2}}{q}.</span> (8.8)</p>

    <p class="text-gray-300">Now fix <span class="math">i\\in\\{0,\\ldots,r-1\\}</span>. We define <span class="math">E^{(i+1)}</span> to be the event that:</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}_{\\nu^{(i+1)}}\\left(f_{f^{(i)},z^{(i)}}^{(i+1)},V^{(i+1)}\\right)&gt;\\max\\left(\\operatorname{agree}_{\\mu^{(i)}}\\left(f^{(i)},V^{(i)}\\right),\\sqrt{\\rho}(1+1/2m)\\right).</span> (8.9)</p>

    <p class="text-gray-300">Having fixed <span class="math">f^{(i)}</span> and <span class="math">\\mu^{(i)}</span>, the event <span class="math">E^{(i+1)}</span> depends on <span class="math">z^{(i)}</span>. By definition, we have</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}_{\\mu^{(i+1)}}\\left(f^{(i+1)},V^{(i+1)}\\right)\\leq\\operatorname{agree}_{\\nu^{(i+1)}}\\left(f_{f^{(i)},z^{(i)}}^{(i+1)},V^{(i+1)}\\right)</span></p>

    <p class="text-gray-300">so when <span class="math">E^{(i+1)}</span> does not hold we conclude from Eq. (8.9) that</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}_{\\mu^{(i+1)}}\\left(f^{(i+1)},V^{(i+1)}\\right)\\leq\\max\\left(\\operatorname{agree}_{\\mu^{(i)}}\\left(f^{(i)},V^{(i)}\\right),\\sqrt{\\rho}(1+1/2m)\\right).</span> (8.10)</p>

    <p class="text-gray-300">Let <span class="math">\\alpha=\\max\\left(\\operatorname{agree}_{\\mu^{(i)}}\\left(f^{(i)},V^{(i)}\\right),\\sqrt{\\rho}(1+1/2m)\\right)</span>. Opening up the definition of <span class="math">f_{f^{(i)},z^{(i)}}^{(i+1)}</span>, we get that <span class="math">E^{(i+1)}</span> is the event that:</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}_{\\nu^{(i+1)}}\\left(u_{0}+z^{(i)}u_{1}+\\ldots+(z^{(i)})^{l^{(i)}-1}u_{l^{(i)}-1},V^{(i+1)}\\right)&gt;\\alpha,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">u_{0},\\ldots,u_{l^{(i)}-1}:D^{(i+1)}\\to\\mathbb{F}</span> are the functions obtained from <span class="math">f^{(i)}</span> in the definition of the FRI protocol (cf. Claim 8.1). This is precisely the situation addressed by Theorem 7.2. Moreover, <span class="math">\\nu^{(i+1)}</span> has a common denominator $M=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so, using the notation there </span>M\\cdot n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. So Theorem 7.2 tells us that <em>if</em></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{z^{(i)}}\\left[E^{(i+1)}\\right]\\geq(l^{(i)}-1)\\cdot\\left(\\epsilon^{(i)}+\\frac{2m+1}{\\sqrt{\\rho}}\\cdot\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>then</em> there is an <span class="math">S\\subseteq\\mathcal{D}^{(i+1)}</span> and codewords <span class="math">v_{0},\\ldots,v_{l^{(i)}-1}\\in V^{(i+1)}</span> such that the <span class="math">u_{i}</span> and <span class="math">v_{i}</span> agree on <span class="math">S</span>, and <span class="math">\\nu^{(i+1)}(S)&gt;\\alpha</span>. Here $\\epsilon^{(i)}=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}\\epsilon=\\frac{\\epsilon}{(l^{(0)}\\ldots l^{(i)})^{2}}<span class="math"> where </span>\\epsilon<span class="math"> is given in Eq. (8.8), since the required probability is quadratic in the size of the target domain </span>\\mathcal{D}^{(i+1)}<span class="math">. Recall from Eq. (8.4) that the mapping of </span>f^{(i)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{C_{g^{(i+1)}}^{(i)}}<span class="math"> to </span>\\mathbf{u}^{(i)}(g^{(i+1)})<span class="math"> is the invertible interpolation map. Apply the inverse map, i.e., the evaluation map, to </span>v_{0}(g^{(i+1)}),\\ldots,v_{l^{(i)}-1}(g^{(i+1)})<span class="math"> for each </span>g^{(i+1)}\\in\\mathcal{D}^{(i+1)}<span class="math">, to get a function </span>h^{(i)}:\\mathcal{D}^{(i)}\\to\\mathbb{F}<span class="math"> that, on </span>g^{(i)}\\in C_{g^{(i+1)}}$, satisfies:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h^{(i)}(g^{(i)})=\\sum_{j=0}^{l^{(i)}-1}\\left(g^{(i)}\\right)^{j}\\cdot v_{j}\\left(g^{(i+1)}\\right)=\\sum_{j=0}^{l^{(i)}-1}\\left(g^{(i)}\\right)^{j}\\cdot v_{j}\\left(\\left(g^{(i)}\\right)^{l^{(i)}}\\right).</span></p>

    <p class="text-gray-300">Therefore, since <span class="math">v_{j}\\in V^{(i+1)}</span>, we conclude that <span class="math">h^{(i)}\\in V^{(i)}</span>. Moreover, by definition we have</p>

    <p class="text-gray-300"><span class="math">\\operatorname{agree}_{\\mu^{(i)}}\\left(f^{(i)},V^{(i)}\\right)\\geq\\operatorname{agree}_{\\mu^{(i)}}\\left(f^{(i)},h^{(i)}\\right)=\\nu^{(i+1)}(S)&gt;\\alpha,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">contradicting our definition of <span class="math">\\alpha</span>. The equality above arises from the definition of <span class="math">\\mu^{(i)}, \\nu^{(i+1)}</span> and <span class="math">h^{(i)}</span>, noticing <span class="math">\\nu^{(i+1)}(g^{(i+1)}) \\neq 0</span> implies that $h^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{C}_{g^{(i+1)}}^{(i)}} = f^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{C}_{g^{(i+1)}}^{(i)}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, if none of the events <span class="math">E^{(i + 1)}</span> happen, we deduce via Eq. (8.10) that for all <span class="math">i\\in 0,1,\\ldots ,r - 1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {a g r e e} _ {\\mu^ {(i + 1)}} \\left(f ^ {(i + 1)}, V ^ {(i + 1)}\\right) \\leq \\max  \\left(\\operatorname {a g r e e} _ {\\mu^ {(i)}} \\left(f ^ {(i)}, V ^ {(i)}\\right), \\sqrt {\\rho} (1 + 1 / 2 m)\\right).</span></div>

    <p class="text-gray-300">Recalling the definition of <span class="math">\\epsilon</span> from Eq. (8.8), the probability that <span class="math">E^{(0)}</span> or some <span class="math">E^{(i + 1)}</span> happens is bounded by</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr_ {x _ {1}, \\dots , x _ {t}} \\left[ E ^ {(0)} \\right] + \\sum_ {i = 0} ^ {r - 1} \\Pr_ {z ^ {(i)}} \\left[ E ^ {(i + 1)} \\right] \\leq \\epsilon + \\sum_ {i = 0} ^ {r - 1} (l ^ {(i)} - 1) \\left(\\epsilon^ {(i)} + \\frac {2 m + 1}{\\sqrt {\\rho}} \\cdot \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {D} ^ {(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\ = \\left(1 + \\sum_ {i = 0} ^ {r - 1} \\frac {l ^ {(i)} - 1}{(l ^ {(0)} \\cdots l ^ {(i)}) ^ {2}}\\right) \\epsilon + \\frac {2 m + 1}{\\sqrt {\\rho}} \\cdot \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {D} ^ {(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\sum_ {i = 0} ^ {r - 1} (l ^ {(i)} - 1) \\\\ &lt;   \\frac {3 \\epsilon}{2} + \\frac {2 m + 1}{\\sqrt {\\rho}} \\cdot \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {D} ^ {(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\sum_ {i = 0} ^ {r - 1} l ^ {(i)}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Here we bounded</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {r - 1} \\frac {l ^ {(i)} - 1}{(l ^ {(0)} \\dots l ^ {(i)}) ^ {2}} = \\sum_ {i = 0} ^ {r - 1} \\left(\\frac {1}{(l ^ {(0)} \\dots l ^ {(i - 1)}) ^ {2} l ^ {(i)}} - \\frac {1}{(l ^ {(0)} \\dots l ^ {(i)}) ^ {2}}\\right) &amp;lt;   \\frac {1}{2},</span></div>

    <p class="text-gray-300">which is immediate from <span class="math">l^{(i)}\\geq 2</span></p>

    <p class="text-gray-300">Putting everything together, we get that except on a set with probability strictly less than</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {3 \\epsilon}{2} + \\frac {2 m + 1}{\\sqrt {\\rho}} \\cdot \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {D} ^ {(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\sum_ {i = 0} ^ {r - 1} l ^ {(i)} = \\epsilon_ {\\mathbb {C}},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {a g r e e} _ {\\mu^ {(r)}} (f ^ {(r)}, V ^ {(r)}) = \\mathbb {E} _ {g ^ {(r)} \\in \\mathcal {D} ^ {(r)}} \\left[ \\mu^ {(r)} (g ^ {(r)}) \\right] \\leq \\max (\\alpha , \\sqrt {\\rho} (1 + 1 / 2 m)) = \\alpha^ {(0)} (\\rho , m).</span></div>

    <p class="text-gray-300">The first equality above holds by the assumption that <span class="math">f^{(r)} \\in V^{(r)}</span>. This completes our proof.</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Proceedings of the 24th ACM Conference on Computer and Communications Security, October 2017.</li>

      <li>[AS03] Sanjeev Arora and Madhu Sudan. Improved low-degree testing and its applications. Combinatorica, 23(3):365–426, 2003. Preliminary version appeared in STOC ’97.</li>

      <li>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptology ePrint Archive, 2018:46, 2018.</li>

      <li>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Ynon Horesh, and Michael Riabzev. Fast Reed-Solomon Interactive Oracle Proofs of Proximity. In Proceedings of the 45th International Colloquium on Automata, Languages, and Programming (ICALP), 2018. Available online as Report 134-17 on Electronic Colloquium on Computational Complexity.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part III, volume 11694 of Lecture Notes in Computer Science, pages 701–732. Springer, 2019.</li>

      <li>[BCG^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Lior Goldberg, Tom Gur, Michael Riabzev, and Nicholas Spooner. Linear-size constant-query iops for delegating computation. In Dennis Hofheinz and Alon Rosen, editors, Theory of Cryptography - 17th International Conference, TCC 2019, Nuremberg, Germany, December 1-5, 2019, Proceedings, Part II, volume 11892 of Lecture Notes in Computer Science, pages 494–521. Springer, 2019.</li>

      <li>[BCR^{+}18] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. IACR Cryptology ePrint Archive, 2018:828, 2018.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Theory of Cryptography - 14th International Conference, TCC 2016-B, Beijing, China, October 31 - November 3, 2016, Proceedings, Part II, pages 31–60, 2016.</li>

      <li>[Bég19] Olivier Bégassat. Bivariate polynomial divisibility test of spielman, Dec 2019. https://mathoverflow.net/questions/348657/bivariate-polynomial-divisibility-test-of-spielman.</li>

      <li>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: sampling outside the box improves soundness. In Thomas Vidick, editor, 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA, volume 151 of LIPIcs, pages 5:1–5:32. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020.</li>

    </ul>

    <p class="text-gray-300">[BGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation (extended abstract). In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, STOC ’88, pages 1–10, 1988.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In 33rd Computational Complexity Conference, CCC 2018, June 22-24, 2018, San Diego, CA, USA, pages 24:1–24:23, 2018.</li>

      <li>[CCD88] David Chaum, Claude Crépeau, and Ivan Damgård. Multiparty unconditionally secure protocols (extended abstract). In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, May 2-4, 1988, Chicago, Illinois, USA, pages 11–19, 1988.</li>

      <li>[CDD^{+}04] Ran Canetti, Ivan Damgård, Stefan Dziembowski, Yuval Ishai, and Tal Malkin. Adaptive versus non-adaptive security of multi-party protocols. J. Cryptology, 17(3):153–207, 2004.</li>

      <li>[CDD^{+}16] Ignacio Cascudo, Ivan Damgård, Bernardo David, Nico Döttling, and Jesper Buus Nielsen. Rate-1, linear time and additively homomorphic UC commitments. In Advances in Cryptology - CRYPTO 2016 - 36th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part III, pages 179–207, 2016.</li>

      <li>[CGMA85] Benny Chor, Shafi Goldwasser, Silvio Micali, and Baruch Awerbuch. Verifiable secret sharing and achieving simultaneity in the presence of faults (extended abstract). In 26th Annual Symposium on Foundations of Computer Science, Portland, Oregon, USA, 21-23 October 1985, pages 383–395, 1985.</li>

      <li>[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. Succinct arguments in the quantum random oracle model. In Dennis Hofheinz and Alon Rosen, editors, Theory of Cryptography, pages 1–29, Cham, 2019. Springer International Publishing.</li>

      <li>[COS19] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. IACR Cryptology ePrint Archive, 2019:1076, 2019. To appear in Eurocrypt 2020.</li>

      <li>[DI06] Ivan Damgård and Yuval Ishai. Scalable secure multiparty computation. In Cynthia Dwork, editor, Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings, volume 4117 of Lecture Notes in Computer Science, pages 501–520. Springer, 2006.</li>

      <li>[FY92] Matthew K. Franklin and Moti Yung. Communication complexity of secure computation (extended abstract). In S. Rao Kosaraju, Mike Fellows, Avi Wigderson, and John A. Ellis, editors, Proceedings of the 24th Annual ACM Symposium on Theory of Computing, May 4-6, 1992, Victoria, British Columbia, Canada, pages 699–710. ACM, 1992.</li>

      <li>[GS99] Venkatesan Guruswami and Madhu Sudan. Improved decoding of reed-solomon and algebraic-geometry codes. IEEE Trans. Information Theory, 45(6):1757–1767, 1999.</li>

    </ul>

    <p class="text-gray-300">[HIMV19] Carmit Hazay, Yuval Ishai, Antonio Marcedone, and Muthuramakrishnan Venkitasubramaniam. Leviosa: Lightweight secure arithmetic computation. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, CCS 2019, London, UK, November 11-15, 2019, pages 327–344. ACM, 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[HM01] Martin Hirt and Ueli M. Maurer. Robustness for free in unconditional multi-party computation. In Joe Kilian, editor, CRYPTO 2001, pages 101–118, 2001.</li>

      <li>[IKOS09] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge proofs from secure multiparty computation. SIAM J. Comput., 39(3):1121–1152, 2009.</li>

      <li>[IPS08] Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. Founding cryptography on oblivious transfer - efficiently. In David A. Wagner, editor, Advances in Cryptology - CRYPTO 2008, 28th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2008. Proceedings, volume 5157 of Lecture Notes in Computer Science, pages 572–591. Springer, 2008.</li>

      <li>[IPS09] Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. Secure arithmetic computation with no honest majority. In Omer Reingold, editor, Theory of Cryptography, 6th Theory of Cryptography Conference, TCC 2009, San Francisco, CA, USA, March 15-17, 2009. Proceedings, volume 5444 of Lecture Notes in Computer Science, pages 294–314. Springer, 2009.</li>

      <li>[Kal85] Erich Kaltofen. Polynomial-time reductions from multivariate to bi- and univariate integral polynomial factorization. SIAM Journal on Computing, 14(2):469–489, May 1985.</li>

      <li>[Kal95] Erich Kaltofen. Effective noether irreducibility forms and applications. J. Comput. Syst. Sci, 50(2):274–295, 1995.</li>

      <li>[PS94] Alexander Polishchuk and Daniel A. Spielman. Nearly-linear size holographic proofs. In Proceedings of the 26th Annual ACM Symposium on Theory of Computing, STOC ’94, pages 194–203, 1994.</li>

      <li>[RB89] Tal Rabin and Michael Ben-Or. Verifiable secret sharing and multiparty protocols with honest majority (extended abstract). In Proceedings of the 21st Annual ACM Symposium on Theory of Computing, May 14-17, 1989, Seattle, Washigton, USA, pages 73–85, 1989.</li>

      <li>[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In Proceedings of the 48th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2016, Cambridge, MA, USA, June 18-21, 2016, pages 49–62, 2016.</li>

      <li>[RVW13] Guy N. Rothblum, Salil Vadhan, and Avi Wigderson. Interactive proofs of proximity: delegating computation in sublinear time. In Proceedings of the forty-fifth annual ACM symposium on Theory of computing, pages 793–802. ACM, 2013.</li>

      <li>[RZ18] Ron M. Roth and Gilles Zémor. Personal communication, 2018.</li>

    </ul>

    <p class="text-gray-300">[Sha79] Adi Shamir. How to share a secret. Commun. ACM, 22(11):612–613, 1979.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Spi95] Daniel A. Spielman. Computationally Efficient Error-Correcting Codes and Holographic Proofs. PhD thesis, MIT, 1995.</li>

    </ul>

    <p class="text-gray-300">A Algebraic Extensions of <span class="math">\\mathbb{F}_{q}(Z)</span></p>

    <p class="text-gray-300">In this section we develop preliminaries that will be necessary for the proof of Theorem 5.1. In the proof, we will have a trivariate polynomial <span class="math">Q(X,Y,Z)</span>, with an irreducible factor <span class="math">R(X,Y,Z)</span>. When evaluated at a certain <span class="math">X=x_{0}\\in\\mathbb{F}_{q}</span>, <span class="math">R(x_{0},Y,Z)</span> will have an irreducible factor <span class="math">H(Y,Z)</span>. For both <span class="math">R</span> and <span class="math">H</span>, irreducible means irreducible in the respective ring of polynomials over <span class="math">\\mathbb{F}_{q}</span>. Our goal will be to show that <span class="math">Q</span> has a factor of the form <span class="math">Y-P(X,Z)</span>, where <span class="math">P</span> has low <span class="math">X</span> and <span class="math">Z</span> degree, and in fact <span class="math">R</span> is this factor. Considering <span class="math">Q</span> and <span class="math">R</span> as polynomials in <span class="math">Y</span> over <span class="math">\\mathbb{F}_{q}[X,Z]</span>, this is equivalent to finding a rational root <span class="math">P(X,Z)</span> of <span class="math">Q</span>, which is also a root of <span class="math">R</span>, and <span class="math">P(x_{0},Z)</span> is thus a root of <span class="math">H</span>. To do so, we will instead start by understanding roots of <span class="math">H</span>, not necessarily of the required form or even lying in <span class="math">\\mathbb{F}_{q}(Z)</span>, lifting them to roots of <span class="math">R</span> (and <span class="math">Q</span>), and then investigating these lifts to prove that they are indeed of the required form <span class="math">P(X,Z)</span>.</p>

    <p class="text-gray-300">We will therefore need to understand the roots of <span class="math">H(Y,Z)</span>. Such roots can be realized in <span class="math">\\mathbb{F}_{q}(Z)[T]/(H(T,Z))</span>, which is a finite algebraic extension of <span class="math">\\mathbb{F}_{q}(Z)</span>. The field will perhaps contain only one root of <span class="math">H</span>, which is sufficient, since <span class="math">H</span>’s irreducibility implies all of its roots are equivalent. We will construct this field, in a slightly different way, and also introduce its ring of <em>regular</em> elements, in Appendix A.1. In this field, we will need a concept of <em>weight</em>, which is an extension of the concept of “degree” from <span class="math">\\mathbb{F}_{q}(Z)</span>, and is introduced in Appendix A.2. A major tool that we will use in several ways is of substitution maps from this field to <span class="math">\\mathbb{F}_{q}</span>, extending the concept of substituting <span class="math">Z=z</span> in a rational function in <span class="math">\\mathbb{F}_{q}(Z)</span>. These substitutions and a useful lemma regarding them are introduced in Appendix A.3. The final tool we need is the lifting of roots of <span class="math">H(Y,Z)</span> to roots of <span class="math">R(X,Y,Z)</span>, which is known as Hensel lifting. We describe this process and state an important lemma on the weights of the field elements appearing in this lift in Appendix A.4.</p>

    <h3 id="sec-103" class="text-xl font-semibold mt-8">A.1 The algebraic extension and its regular elements</h3>

    <p class="text-gray-300">Let <span class="math">d\\geq 1</span> be an integer, and let</p>

    <p class="text-gray-300"><span class="math">H(Y,Z)=h_{0}(Z)Y^{d}+h_{1}(Z)Y^{d-1}+\\cdots+h_{d}(Z)\\in\\mathbb{F}_{q}[Y,Z]</span></p>

    <p class="text-gray-300">be an irreducible bivariate polynomial, expressed as a polynomial in <span class="math">Y</span> over <span class="math">\\mathbb{F}_{q}[Z]</span>. Denote the leading coefficient of <span class="math">H</span> also as <span class="math">W=h_{0}</span>.</p>

    <p class="text-gray-300">We wish to understand the field <span class="math">\\mathbb{F}_{q}(Z)[T]/(H(T,Z))</span>, of polynomials in <span class="math">T</span> over <span class="math">\\mathbb{F}_{q}(Z)</span> modulo <span class="math">H</span>. The presence of the leading coefficient <span class="math">W</span> means that <span class="math">T</span> is not an integer in this field, and makes the arithmetic modulo <span class="math">H</span> unpleasant to keep track of, with possible emergence of high powers of <span class="math">W</span> in denominators whenever a reduction modulo <span class="math">H</span> is performed. To avoid this, we first define a “monicized” version of <span class="math">H</span>, denoted <span class="math">\\widetilde{H}</span>, which is a monic, irreducible polynomial in <span class="math">\\mathbb{F}_{q}[Z][T]</span> generating the same field as <span class="math">H</span>:</p>

    <p class="text-gray-300"><span class="math">\\widetilde{H}(T,Z)</span> <span class="math">=W(Z)^{d-1}H(T/W(Z),Z)</span> <span class="math">=T^{d}+h_{1}(Z)T^{d-1}+h_{2}(Z)W(Z)T^{d-2}+\\cdots+h_{d}(Z)W(Z)^{d-1}.</span></p>

    <p class="text-gray-300">We now denote <span class="math">\\mathbb{L}=\\mathbb{F}_{q}(Z)[T]/(\\widetilde{H}(T,Z))</span>, and observe that <span class="math">Y=\\frac{T}{W(Z)}</span> is a root of <span class="math">H(Y,Z)</span> in <span class="math">\\mathbb{L}</span>; this also establishes that <span class="math">T\\mapsto W(Z)\\cdot Y</span> and <span class="math">Y\\mapsto\\frac{T}{W(Z)}</span> are isomorphisms between <span class="math">\\mathbb{L}</span> and <span class="math">\\mathbb{F}_{q}(Z)[Y]/(H(Y,Z))</span>. We say that an element of <span class="math">\\mathbb{L}</span> is <em>regular</em> if it can be expressed as a polynomial in <span class="math">T</span> with coefficients only in the ring <span class="math">\\mathbb{F}_{q}[Z]</span> instead of the field <span class="math">\\mathbb{F}_{q}(Z)</span>; equivalently, if this is true for its canonical form as a polynomial in <span class="math">T</span> of degree less than <span class="math">d</span>. We denote the set of regular elements by <span class="math">\\mathcal{O}=\\mathbb{F}_{q}[Z][T]/(\\widetilde{H}(T,Z))</span>. The regular elements are in fact a ring, and a subring of the ring of integers of <span class="math">\\mathbb{L}</span> (we will not be interested in non-regular integers, for our purposes).</p>

    <p class="text-gray-300">A.2 Algebraic weights</p>

    <p class="text-gray-300">Let <span class="math">D\\geq d</span> be an upper bound on the total <span class="math">Y,Z</span> degree of <span class="math">H</span>, so that <span class="math">\\deg_{Z}h_{k}\\leq D+k-d</span> for all <span class="math">k</span>. We define a <em>weight</em> function <span class="math">\\Lambda</span> on <span class="math">\\mathbb{F}_{q}[T,Z]</span> by assigning <span class="math">\\Lambda(Z)=1</span> and <span class="math">\\Lambda(T)=D+1-d</span>, extended additively to monomials, i.e. <span class="math">\\Lambda(T^{a}Z^{b})=a\\Lambda(T)+b\\Lambda(Z)</span>, and the weight of a polynomial is the maximal weight of all monomials appearing in it with non-zero coefficients (with the weight of the <span class="math">0</span> polynomial being <span class="math">-\\infty</span>). Note that <span class="math">\\Lambda</span> is fully additive on <span class="math">\\mathbb{F}_{q}[T,Z]</span>, i.e. for any <span class="math">A,B\\in\\mathbb{F}_{q}[T,Z]</span>, <span class="math">\\Lambda(AB)=\\Lambda(A)+\\Lambda(B)</span>. Also note that when restricted to <span class="math">\\mathbb{F}_{q}[Z]</span>, <span class="math">\\Lambda=\\deg_{Z}</span>.</p>

    <p class="text-gray-300">Observe that <span class="math">\\widetilde{H}(T,Z)</span> has weight <span class="math">\\Lambda(\\widetilde{H})=d(D+1-d)=dD-d(d-1)</span>, with the leading monomial being of this exact weight and every other monomial bounded by it. It follows that any simple modulo <span class="math">\\Lambda(\\widetilde{H})</span> operation of the form</p>

    <p class="text-gray-300"><span class="math">T^{d+k}\\to-\\sum_{i=1}^{d}h_{i}(Z)W(Z)^{i-1}T^{d+k-i}</span></p>

    <p class="text-gray-300">never increases the weight <span class="math">\\Lambda</span>, and so does complete reduction modulo <span class="math">\\widetilde{H}</span>.</p>

    <p class="text-gray-300">We now define the weight <span class="math">\\Lambda(\\alpha)</span> of a regular element <span class="math">\\alpha\\in\\mathcal{O}</span> as the weight of the canonical representative of <span class="math">\\alpha</span> with degree less than <span class="math">d</span>, which by the above is also the minimal value of <span class="math">\\Lambda</span> over all representatives of <span class="math">\\alpha</span>. It also follows that for any <span class="math">\\alpha,\\beta\\in\\mathcal{O}</span>, if <span class="math">A(T,Z),B(T,Z)</span> are their canonical representatives, and <span class="math">C(T,Z)=A(T,Z)B(T,Z)</span> mod <span class="math">\\widetilde{H}(T,Z)</span> is the canonical representative of <span class="math">\\gamma=\\alpha\\beta</span>, then</p>

    <p class="text-gray-300"><span class="math">\\Lambda(\\gamma)=\\Lambda(C)\\leq\\Lambda(AB)=\\Lambda(A)+\\Lambda(B)=\\Lambda(\\alpha)+\\Lambda(\\beta).</span></p>

    <p class="text-gray-300">In other words, <span class="math">\\Lambda</span> is sub-additive in <span class="math">\\mathcal{O}</span>.</p>

    <h3 id="sec-104" class="text-xl font-semibold mt-8">A.3 Rational substitutions</h3>

    <p class="text-gray-300">Let <span class="math">z\\in\\mathbb{F}_{q}</span> be such that <span class="math">\\widetilde{H}(T,z)</span> has a rational root <span class="math">T=t_{z}</span>. In other words, <span class="math">(t_{z},z)\\in\\mathbb{F}_{q}^{2}</span> is a root of <span class="math">\\widetilde{H}</span>, with <span class="math">t_{z}</span> considered as depending on <span class="math">z</span> (in our applications, it will in fact be given as a function of <span class="math">z</span>). For any such root-pair, we define the <em>substitution</em> <span class="math">\\pi_{z}</span>, which is the homomorphism <span class="math">\\pi_{z}:\\mathcal{O}\\to\\mathbb{F}_{q}</span> given by <span class="math">\\pi_{z}(Z)=z,\\pi_{z}(T)=t_{z}</span>. The homomorphism is well defined since <span class="math">\\mathcal{O}=\\mathbb{F}_{q}[T,Z]/(\\widetilde{H}(T,Z))</span> and <span class="math">\\pi_{z}(\\widetilde{H}(T,Z))=\\widetilde{H}(t_{z},z)=0</span>. The substitution <span class="math">\\pi_{z}</span> can be extended naturally to any element of <span class="math">\\mathbb{L}</span> for which <span class="math">z</span> is not a pole, i.e. elements of the form <span class="math">\\frac{\\beta}{C(Z)}</span> with <span class="math">\\beta\\in\\mathcal{O}</span> and <span class="math">z</span> not a root of <span class="math">C</span>, by <span class="math">\\pi_{z}\\Big{(}\\frac{\\beta}{C(Z)}\\Big{)}=\\frac{\\pi_{z}(\\beta)}{C(z)}</span>.</p>

    <p class="text-gray-300">The following lemma gives an upper bound on the number of substitutions in which an element <span class="math">\\beta\\in\\mathcal{O}</span> can vanish in terms of its weight. It is analogous to the statement that a polynomial of degree at most <span class="math">d</span> which vanishes for more than <span class="math">d</span> evaluations must be the <span class="math">0</span> polynomial.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Lemma A.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\beta\\in\\mathcal{O}</span> be regular with weight <span class="math">\\Lambda(\\beta)</span>. Let</p>

    <p class="text-gray-300"><span class="math">S_{\\beta}=\\{z\\in\\mathbb{F}_{q}:\\exists t_{z}\\in\\mathbb{F}_{q},\\widetilde{H}(t_{z},z)=0\\text{ and }\\pi_{z}(\\beta)=0\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>d\\cdot\\Lambda(\\beta)<span class="math">. Then </span>\\beta=0\\in\\mathbb{L}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-106" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\beta=\\sum_{i=0}^{d-1}\\beta_{i}(Z)T^{i}\\in\\mathbb{F}_{q}[Z][T]</span> be the canonical representative, with</p>

    <p class="text-gray-300"><span class="math">\\deg_{Z}(\\beta_{i})=\\Lambda_{Z}(\\beta_{i})\\leq\\Lambda(\\beta)-i\\Lambda(T)=\\Lambda(\\beta)-i(D+1-d).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the resultant <span class="math">R(Z)=\\operatorname{res}_{T}(\\beta,\\widetilde{H})</span>. From the Sylvester matrix, or considering weights of roots, we find $\\deg_{Z}R\\leq d\\cdot\\Lambda(\\beta)<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. On the other hand, every </span>z\\in S_{\\beta}<span class="math"> is a root of </span>R$, since</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\widetilde{H}(T,z)</span> and <span class="math">\\beta(T,z)</span> have a common root <span class="math">t_{z}</span>. It follows that <span class="math">R</span> is identically <span class="math">0</span>, i.e. <span class="math">\\beta</span> and <span class="math">\\widetilde{H}</span> are not coprime, but since <span class="math">\\widetilde{H}</span> is irreducible and <span class="math">\\deg_{T}(\\beta)&lt;\\deg_{T}(\\widetilde{H})</span>, we have <span class="math">\\beta=0</span>, as claimed. ∎</p>

    <h3 id="sec-107" class="text-xl font-semibold mt-8">A.4 Hensel lifts</h3>

    <p class="text-gray-300">Suppose <span class="math">H(Y,Z)</span> as above is a factor of <span class="math">R_{x_{0}}(Y,Z)=R(x_{0},Y,Z)</span>, where <span class="math">x_{0}\\in\\mathbb{F}_{q}</span>, and <span class="math">R(X,Y,Z)</span> is irreducible in <span class="math">\\mathbb{F}_{q}[X,Y,Z]</span>. Additionally assume that <span class="math">R</span> and <span class="math">R_{x_{0}}</span> are both separable in <span class="math">Y</span>, which means that they do not have double roots when considered as polynomials in <span class="math">Y</span>, or equivalently, that they are coprime to their <span class="math">Y</span>-derivatives. Note that this applies not only to roots in the fields over which they are defined, but over any extension field as well. Denoting <span class="math">\\alpha_{0}=\\frac{T}{W}\\in\\mathbb{L}</span>, we find <span class="math">R(x_{0},\\alpha_{0},Z)=0\\in\\mathbb{L}</span>, or equivalently in <span class="math">\\mathbb{L}[X]</span>,</p>

    <p class="text-gray-300"><span class="math">R(X,\\alpha_{0},Z)\\equiv 0\\ \\ (\\mathrm{mod}\\ X-x_{0}).</span></p>

    <p class="text-gray-300">Since <span class="math">\\alpha_{0}</span> is a root of the separable polynomial <span class="math">R_{x_{0}}</span>, it must be a simple root, or equivalently must satisfy <span class="math">\\zeta=\\frac{\\partial R}{\\partial Y}(x_{0},\\alpha_{0},Z)\\neq 0</span>. In other words <span class="math">\\zeta\\in\\mathbb{L}</span> is invertible. This fact allows us to iteratively lift the root <span class="math">\\alpha_{0}</span> of <span class="math">R(X,Y,Z)\\ (\\mathrm{mod}\\ X-x_{0})</span> to a root</p>

    <p class="text-gray-300"><span class="math">\\alpha_{0}+\\alpha_{1}(X-x_{0})\\quad\\text{of}\\quad R(X,Y,Z)\\ (\\mathrm{mod}\\ (X-x_{0})^{2})</span></p>

    <p class="text-gray-300">by solving the equation <span class="math">R(X,\\alpha_{0}+\\alpha_{1}(X-x_{0}),Z)\\equiv 0\\ (\\mathrm{mod}\\ (X-x_{0})^{2})</span>, in which <span class="math">\\alpha_{1}</span> appears with coefficient <span class="math">\\zeta</span>, after expansion. We then lift again to a root</p>

    <p class="text-gray-300"><span class="math">\\alpha_{0}+\\alpha_{1}(X-x_{0})+\\alpha_{2}(X-x_{0})^{2}\\quad\\text{of}\\quad R(X,Y,Z)\\ (\\mathrm{mod}\\ (X-x_{0})^{3}),</span></p>

    <p class="text-gray-300">and so on. At each step the lifting is unique, and determined by an algebraic equation in which the new <span class="math">\\alpha_{t}</span> appears linearly with the same coefficient <span class="math">\\zeta</span>.</p>

    <p class="text-gray-300">We obtain an infinite sequence <span class="math">(\\alpha_{t})_{t=0}^{\\infty}</span>, such that at each step <span class="math">s</span> the truncated series <span class="math">\\gamma_{s}=\\sum_{t=0}^{s}\\alpha_{t}(X-x_{0})^{t}\\in\\mathbb{L}[X]</span> satisfies</p>

    <p class="text-gray-300"><span class="math">R(X,\\gamma_{s},Z)\\equiv 0\\ \\ \\ (\\mathrm{mod}\\ (X-x_{0})^{s+1}).</span></p>

    <p class="text-gray-300">Equivalently, for the infinite formal power series <span class="math">\\gamma=\\sum_{t=0}^{\\infty}\\alpha_{t}(X-x_{0})^{t}\\in\\mathbb{L}[[X-x_{0}]]</span>, we have <span class="math">R(X,\\gamma,Z)=0\\in\\mathbb{L}[[X-x_{0}]]</span>. Here <span class="math">\\mathbb{L}[[X-x_{0}]]</span> is the ring of formal power series in <span class="math">X-x_{0}</span> with coefficients in <span class="math">\\mathbb{L}</span>. This power series <span class="math">\\gamma</span> is the Hensel lift of <span class="math">\\alpha_{0}</span>, and the process by which it is computed is the Hensel lifting. Its existence and uniqueness both follow solely from <span class="math">\\alpha_{0}</span> being a simple root modulo <span class="math">X-x_{0}</span>.</p>

    <p class="text-gray-300">We make a slight change to the notation, and henceforth <span class="math">d</span> will be the <span class="math">Y</span>-degree of <span class="math">R</span>, and <span class="math">d_{H}\\leq d</span> will denote the <span class="math">Y</span>-degree of <span class="math">H</span> (previously denoted by <span class="math">d</span>). We will also assume that <span class="math">D</span> is an upper bound not only on the total degree of <span class="math">H</span> but also of <span class="math">R</span>. Note that <span class="math">W</span>, the leading coefficient of <span class="math">H</span>, divides the leading coefficient of <span class="math">R_{x_{0}}</span>, and has weight <span class="math">\\Lambda(W)\\leq D-d_{H}</span>.</p>

    <p class="text-gray-300">The following claim describes the coefficients <span class="math">\\alpha_{t}</span> appearing in the Hensel lift, and bounds their denominators and the weights of their numerators:</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Claim A.2.</h6>

    <p class="text-gray-300"><span class="math">\\alpha_{t}</span> is of the form <span class="math">\\frac{\\beta_{t}}{W^{t+1}\\xi^{e_{t}}}</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\xi=W(Z)^{d-2}\\zeta\\in\\mathcal{O}</span> with <span class="math">\\zeta=\\frac{\\partial R}{\\partial Y}(x_{0},\\frac{T}{W},Z)\\in\\mathbb{L}</span>, and</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Lambda(\\xi)\\leq(D-1)+(d-2)\\Lambda(W)\\leq(d-1)(D-d_{H}+1),</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e_{t}=\\max(0,2t-1)</span>, i.e. <span class="math">e_{0}=0</span> and <span class="math">e_{t}=2t-1</span> for <span class="math">t\\geq 1</span>,</li>

    </ul>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta_{t} \\in \\mathcal{O}</span> with</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Lambda (\\beta_{t}) \\leq 1 + (t + 1) \\Lambda (W) + e_{t} \\Lambda (\\xi) \\\\ \\leq 1 + (t + 1) (D - d_{H}) + e_{t} (d - 1) (D - d_{H} + 1) \\\\ = ((d - 1) \\cdot e_{t} + t + 1) (D - d_{H} + 1) - t \\\\ \\leq ((2 t (d - 1) + t + 1) (D - d_{H} + 1) - t &amp;lt; (2 t + 1) d D. \\end{array}</span></div>

    <p class="text-gray-300">The claim is proven by straight-forwardly expanding <span class="math">R(X, \\gamma, Z)</span> as a series in <span class="math">X - x_0</span>, comparing each coefficient to 0, and using induction on <span class="math">t</span>. The existence and uniqueness of the Hensel lift <span class="math">\\gamma</span>, and how each new coefficient <span class="math">\\alpha_t</span> is computed from the previous ones, will also follow from the proof.</p>

    <p class="text-gray-300">Proof. We prove the statement by induction on <span class="math">t</span>. For <span class="math">t = 0</span>, we have simply <span class="math">\\alpha_0 = \\frac{T}{W} \\bmod \\widetilde{H}</span>, i.e. <span class="math">\\beta_0 = T \\bmod \\widetilde{H}</span> and indeed <span class="math">\\Lambda(T) = \\Lambda(W) + 1</span>.</p>

    <p class="text-gray-300">Let <span class="math">R_{ji}(Z)</span> be the coefficient of <span class="math">X^i Y^j</span> in <span class="math">R(X, Y, Z)</span>, i.e. <span class="math">R(X, Y, Z) = \\sum_{i,j} R_{ji}(Z) X^i Y^j</span>. We wish to write <span class="math">R(X, \\gamma, Z)</span> as a power series in <span class="math">X - x_0</span>. A partition of <span class="math">t</span> is a sequence of non-negative integers <span class="math">\\lambda = (\\lambda_l)_{l \\geq 1}</span> with <span class="math">\\sum_{l} l \\cdot \\lambda_l = t</span>. Such sequences are non-zero only finitely many times, and we trim any trailing 0s in writing, e.g. <span class="math">(1) = (1, 0, 0, 0, \\ldots)</span>. We also denote <span class="math">\\Sigma \\lambda = \\sum_{l \\geq 1} \\lambda_l</span>. Let <span class="math">\\mathcal{P}(t)</span> be the set of partitions of <span class="math">t</span>. For any <span class="math">t, i_1 \\leq t</span>, and <span class="math">\\lambda \\in \\mathcal{P}(t - i_1)</span>, denote</p>

    <p class="text-gray-300">$$ \\begin{array}{l} A_{i_{1},\\lambda} = \\sum_{\\substack{j_{0}\\\\ j = j_{0} + \\Sigma \\lambda}}\\binom {j}{j_{0},\\lambda_{1},\\ldots ,\\lambda_{l},\\ldots}\\alpha_{0}^{j_{0}}\\sum_{\\substack{i_{0}\\\\ i = i_{0} + i_{1}}}\\binom {i}{i_{0},i_{1}}R_{ji}(Z)x_{0}^{i_{0}} \\\\ = \\sum_{\\substack{i_{0},j_{0}\\\\ i = i_{0} + i_{1}\\\\ j = j_{0} + \\Sigma \\lambda}}\\binom {i}{i_{0},i_{1}}\\binom {j}{j_{0},\\lambda_{1},\\ldots ,\\lambda_{l},\\ldots}R_{ji}(Z)x_{0}^{i_{0}}\\alpha_{0}^{j_{0}} \\\\ = \\left(\\frac{\\Sigma \\lambda}{\\lambda_{1}, \\dots, \\lambda_{l}, \\dots}\\right) \\sum_{i, j} \\binom{i}{i_{1}} \\binom{j}{\\Sigma \\lambda} R_{ji}(Z) x_{0}^{i - i_{1}} \\alpha_{0}^{j - \\Sigma \\lambda} \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left(\\frac{\\Sigma \\lambda}{\\lambda_{1}, \\dots, \\lambda_{l}, \\dots}\\right) \\left. \\left(\\Delta_{X}^{i_{1}} \\Delta_{Y}^{\\Sigma \\lambda} R (X, Y, Z)\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(x_{0}, \\alpha_{0}, Z)}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where the sums are taken only over non-zero terms, i.e. with <span class="math">i + kj &amp;lt; D_X</span>, and <span class="math">\\Delta_V^k</span> is the <span class="math">k</span>-th Hasse derivative with respect to the variable <span class="math">V</span>. In particular, whenever <span class="math">\\lambda</span> is such that <span class="math">\\Sigma \\lambda = 1</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">A_{0,\\lambda} = (\\Delta_{Y} R)(x_{0}, \\alpha_{0}, Z) = \\frac{\\partial R}{\\partial Y}(x_{0}, \\alpha_{0}, Z) = \\zeta.</span></div>

    <p class="text-gray-300">Since the maximal degree of <span class="math">\\alpha_0 = \\frac{T}{W}</span> appearing in <span class="math">A_{i_1,\\lambda}</span> is <span class="math">d - \\Sigma \\lambda</span>, we can generally write <span class="math">A_{i_1,\\lambda} = \\frac{B_{i_1,\\lambda}}{W^{d - \\Sigma\\lambda}}</span>, where <span class="math">B_{i_1,\\lambda} \\in \\mathcal{O}</span> has weight <span class="math">\\Lambda(B_{i_1,\\lambda}) = (D - \\Sigma \\lambda) + (d - \\Sigma \\lambda)\\Lambda(W)</span>. In the special case <span class="math">i_1 = 0</span>, the coefficient of <span class="math">\\alpha_0^{d - \\Sigma \\lambda}</span> is a multiple of <span class="math">\\sum_{i} R_{di}(Z)x_0^i</span>, which is the leading coefficient of <span class="math">R_{x_0}</span>, hence divisible by <span class="math">W</span>, and thus we can save a little and write <span class="math">A_{0,\\lambda} = \\frac{B_{0,\\lambda}}{W^{d - 1 - \\Sigma \\lambda}}</span>, where <span class="math">B_{0,\\lambda} \\in \\mathcal{O}</span> has weight <span class="math">(D - \\Sigma \\lambda) + (d - 1 - \\Sigma \\lambda)\\Lambda(W)</span>. When <span class="math">\\Sigma \\lambda = 1</span> we then get <span class="math">\\zeta = A_{0,\\lambda} = \\frac{B_{0,\\lambda}}{W^{d - 2}} = \\frac{\\xi}{W^{d - 2}}</span> where <span class="math">\\xi \\in \\mathcal{O}</span> has weight <span class="math">(D - 1) + (d - 2)\\Lambda(W)</span> as stated. To generalize the two cases, we may write <span class="math">A_{i_1,\\lambda} = \\frac{B_{i_1,\\lambda}}{W^{d - \\delta_{i_1,0} - \\Sigma \\lambda}}</span>, where <span class="math">\\delta_{i_1,0} = 1</span> if <span class="math">i_1 = 0</span> and <span class="math">\\delta_{i_1,0} = 0</span> otherwise.</p>

    <p class="text-gray-300">Now, expanding <span class="math">R(X, \\gamma, Z)</span>, we get</p>

    <div class="my-4 text-center"><span class="math-block">0 = R (X, \\gamma , Z) = R \\left(x _ {0} + (X - x _ {0}), \\sum_ {l} \\alpha_ {l} (X - x _ {0}) ^ {l}, Z\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\sum_{ij} R_{ji}(Z) (x_0 + (X - x_0))^i \\left( \\sum_{l} \\alpha_l (X - x_0)^l \\right)^j \\\\ = \\sum_{ij} R_{ji}(Z) \\left( \\sum_{i_0 + i_1 = i} \\binom{i}{i_0, i_1} x_0^{i_0} (X - x_0)^{i_1} \\right. \\\\ \\quad \\times \\sum_{j_0 + \\Sigma \\lambda = j} \\binom{j}{j_0, \\lambda} \\left( \\alpha_0^{j_0} \\prod_l \\alpha_l^{\\lambda_l} \\right) (X - x_0)^{\\sum_l l \\cdot \\lambda_l} \\\\ = \\sum_{t=0}^{\\infty} (X - x_0)^t \\sum_{\\substack{i_1 \\\\ \\lambda \\in \\mathcal{P}(t - i_1)}} A_{i_1, \\lambda} \\prod_{l \\geq 1} \\alpha_l^{\\lambda_l} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that <span class="math">\\alpha_{t}</span> appears for the first time in the term corresponding to <span class="math">(X - x_0)^t</span>, and only with <span class="math">i_1 = 0</span> and <span class="math">\\lambda = \\lambda^{(t)}</span> defined by <span class="math">\\lambda_t^{(t)} = 1</span>, <span class="math">\\lambda_l^{(t)} = 0</span> for <span class="math">l \\neq t</span>, with the coefficient <span class="math">A_{0,\\lambda^{(t)}} = \\zeta</span>. All other summands in the coefficient of <span class="math">(X - x_0)^t</span> involve only <span class="math">\\alpha_{l}</span> with <span class="math">l &amp;lt; t</span>, so we may apply the induction. Comparing the coefficient to 0, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\alpha_t = -\\frac{1}{\\zeta} \\sum_{\\substack{i_1; \\lambda \\in \\mathcal{P}(t - i_1) \\\\ \\lambda \\neq \\lambda^{(t)}}} A_{i_1, \\lambda} \\prod_{l \\geq 1} \\alpha_l^{\\lambda_l} \\\\ = -\\frac{W^{d-2}}{\\xi} \\sum_{\\substack{i_1; \\lambda \\in \\mathcal{P}(t - i_1) \\\\ \\lambda \\neq \\lambda^{(t)}}} \\frac{B_{i_1, \\lambda}}{W^{d - \\delta_{i_1,0} - \\Sigma \\lambda}} \\prod_{l \\geq 1} \\left( \\frac{\\beta_l}{W^{l+1} \\xi^{e_l}} \\right)^{\\lambda_l} \\\\ = \\sum_{\\substack{i_1; \\lambda \\in \\mathcal{P}(t - i_1) \\\\ \\lambda \\neq \\lambda^{(t)}}} \\frac{B_{i_1, \\lambda} \\prod_l \\beta_l^{\\lambda_l}}{W^{2 - \\delta_{i_1,0} - \\Sigma \\lambda + \\sum_l (l+1) \\lambda_l} \\xi^{1 + \\sum_l (2l-1) \\lambda_l}} \\\\ = \\sum_{\\substack{i_1; \\lambda \\in \\mathcal{P}(t - i_1) \\\\ \\lambda \\neq \\lambda^{(t)}}} \\frac{B_{i_1, \\lambda} \\prod_l \\beta_l^{\\lambda_l}}{W^{t - i_1 - \\delta_{i_1,0} + 2} \\xi^{2t - 2i_1 - \\Sigma \\lambda + 1}}, \\\\ = \\frac{1}{W^{t+1} \\xi^{2t-1}} \\sum_{\\substack{i_1; \\lambda \\in \\mathcal{P}(t - i_1) \\\\ \\lambda \\neq \\lambda^{(t)}}} W^{i_1 + \\delta_{i_1,0} - 1} \\xi^{2i_1 + \\Sigma \\lambda - 2} B_{i_1, \\lambda} \\prod_l \\beta_l^{\\lambda_l}, \\end{array}</span></div>

    <p class="text-gray-300">thus we have</p>

    <div class="my-4 text-center"><span class="math-block">\\beta_t = \\sum_{\\substack{i_1; \\lambda \\in \\mathcal{P}(t - i_1) \\\\ \\lambda \\neq \\lambda^{(t)}}} W^{i_1 + \\delta_{i_1,0} - 1} \\xi^{2i_1 + \\Sigma \\lambda - 2} B_{i_1, \\lambda} \\prod_l \\beta_l^{\\lambda_l} \\tag{A.1}</span></div>

    <p class="text-gray-300">which is indeed regular, as the <span class="math">W</span>, <span class="math">\\xi</span>, the <span class="math">B</span>'s and the <span class="math">\\beta</span>'s are all regular and the exponents are non-negative: for the exponent of <span class="math">W</span>, it is always the case that <span class="math">i_1 + \\delta_{i_1,0} \\geq 1</span>. For the exponent of <span class="math">\\xi</span>, for <span class="math">i_1 = 0</span>, every <span class="math">\\lambda \\in \\mathcal{P}(t)</span> with <span class="math">\\lambda \\neq \\lambda^{(t)}</span> indeed has <span class="math">\\Sigma \\lambda \\geq 2</span>, and for <span class="math">i_1 \\geq 1</span> we even have <span class="math">2i_1 + \\Sigma \\lambda - 2 \\geq 1</span>, since <span class="math">\\Sigma \\lambda \\geq 1</span>.</p>

    <p class="text-gray-300">The upper bound on the weight of <span class="math">\\beta</span> can be shown by induction using the recursion (A.1), but an easier way to understand it is by considering the weight of <span class="math">\\alpha_{t}</span>: Since <span class="math">\\gamma = \\sum_{t=0}^{\\infty} \\alpha_{t} (X - x_{0})^{t}</span> is a</p>

    <p class="text-gray-300">54</p>

    <p class="text-gray-300">solution to <span class="math">R(X,Y,Z) = 0</span>, <span class="math">\\gamma</span> has the same weight as <span class="math">Y</span>; since <span class="math">X, x_0</span> have weight 0, each <span class="math">\\alpha_t</span> also has weight <span class="math">\\Lambda(\\alpha_t) = \\Lambda(Y) = 1</span>. Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda (\\beta_ {t}) = \\Lambda (\\alpha_ {t} W ^ {t + 1} \\xi^ {e _ {t}}) \\leq 1 + (t + 1) \\Lambda (W) + e _ {t} \\Lambda (\\xi)</span></div>

    <p class="text-gray-300">as claimed.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <h2 id="sec-110" class="text-2xl font-bold">B.1 The <span class="math">Y, Z</span>-degree of <span class="math">Q</span></h2>

    <p class="text-gray-300">In this section we prove inequality (5.7) of Claim 5.4, which claims that the total <span class="math">Y, Z</span>-degree of <span class="math">Q(X, Y, Z)</span> is bounded by <span class="math">\\frac{(m + 1/2)^3}{6\\sqrt{\\rho}} n</span>.</p>

    <p class="text-gray-300">The bound on <span class="math">D_{YZ} = \\deg_{Y,Z}(Q)</span> comes from minors of the matrix <span class="math">M</span> representing the system of equations defining <span class="math">Q</span>. These equations are all of the form "the <span class="math">(m_X, m_Y)</span>-th derivative of <span class="math">Q</span> vanishes at <span class="math">(x, w(x))</span>", for <span class="math">x \\in \\mathcal{D}</span> and non-negative integers <span class="math">m_X, m_Y</span> with <span class="math">m_X + m_Y &amp;lt; m</span>. Computing the derivative and substituting <span class="math">(x, w(x))</span>, we see that the <span class="math">(x, m_X, m_Y)</span>-th equation is</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_ {X} ^ {m _ {X}} \\Delta_ {Y} ^ {m _ {Y}} Q (x, w (x, Z), Z) = \\sum_ {i + k \\cdot j &amp;lt; D _ {X}} Q _ {j i} (Z) {\\binom {i} {m _ {X}}} {\\binom {j} {m _ {Y}}} x ^ {i - m _ {X}} (u _ {0} (x) + Z u _ {1} (x)) ^ {j - m _ {Y}} = 0.</span></div>

    <p class="text-gray-300">The coefficient of <span class="math">Q_{ji}(Z)</span> in this equation is therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\binom {i} {m _ {X}} \\binom {j} {m _ {Y}} x ^ {i - m _ {X}} (u _ {0} (x) + Z u _ {1} (x)) ^ {j - m _ {Y}},</span></div>

    <p class="text-gray-300">and this coefficient appears in the matrix <span class="math">M</span> at row <span class="math">(x, m_X, m_Y)</span> and column <span class="math">j i</span>. Note that as a polynomial in <span class="math">Z</span>, it has degree at most <span class="math">j - m_{Y}</span>, which is the sum of <span class="math">j</span>, which is determined by the column, and <span class="math">-m_{Y}</span>, determined by the row. We thus call <span class="math">j</span> and <span class="math">-m_{Y}</span> the contributions of the column and the row, respectively, to the <span class="math">Z</span>-degree of the matrix's entry.</p>

    <p class="text-gray-300">Let <span class="math">r</span> be the rank of <span class="math">M</span>, which is bounded from above by the number of rows <span class="math">\\binom{m+1}{2}n</span>. To find a non-zero solution of the system, first find an <span class="math">r \\times r</span> non-singular submatrix, and add an arbitrary single column. As in Section 4.3.1, the homogenous form of Cramer's rule then tells us that a solution to the <span class="math">r \\times (r+1)</span> subsystem is given by assigning each <span class="math">Q_{ji}</span> to be the <span class="math">r \\times r</span> minor obtained by removing the <span class="math">ji</span>-th column from the submatrix and taking the determinant, with alternating signs. These <span class="math">Q_{ji}</span> will then be a solution to the original system, since these <span class="math">r</span> rows span the entire row-space of the original matrix, and the solution is non-zero since at least one of these minors was chosen to be non-singular. The determinant corresponding to <span class="math">Q_{ji}</span> is a sum over products corresponding to permutations, each containing a single entry from each row and each column of the <span class="math">r \\times r</span> submatrix. The degree of each such product is thus bounded by the sum of the degree contributions from all columns and rows of the <span class="math">r \\times r</span> submatrix, regardless of the permutation, or of all columns and rows of the <span class="math">r \\times (r+1)</span> matrix, minus that of the <span class="math">ji</span>-th column. In other words, it is at most <span class="math">D - j</span>, where <span class="math">D = D_C - D_R</span> is the sum of the contributions of all columns and (negative) contributions of all rows from the <span class="math">r \\times (r+1)</span> matrix. Thus the total <span class="math">Y, Z</span> degree of the monomial <span class="math">Q_{ji}X^i Y^j</span> is at most <span class="math">(D - j) + j \\leq D</span>, and hence the total <span class="math">Y, Z</span> degree of <span class="math">Q</span> is at most <span class="math">D</span>, i.e. <span class="math">D_{YZ} \\leq D</span>.</p>

    <p class="text-gray-300">It remains to bound <span class="math">D = D_{C} - D_{R}</span> from above. We do this by simply using <span class="math">D_{R} \\geq 0</span> and bounding <span class="math">D_{C}</span> by the sum of column contributions of the entire matrix. It is possible to improve</p>

    <p class="text-gray-300">8We use the Hasse derivatives <span class="math">\\Delta_X^m (X^i)\\coloneqq \\binom {i}{m}X^{i - m}</span> instead of the regular derivatives to avoid complications due to the characteristic of the field.</p>

    <p class="text-gray-300">55</p>

    <p class="text-gray-300">this bound by finding the worst <span class="math">r</span> for which the sum of the largest <span class="math">r+1</span> column contributions minus the sum of the smallest <span class="math">r</span> row contributions is maximal, and computing these sums. We opt for the simpler bound, since the optimal bound requires a more technical and involved computation, and only ends up improving on the simple bound by a small constant factor, with an unpleasant dependence on <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">Write <span class="math">s=\\left\\lfloor\\frac{D_{X}}{k}\\right\\rfloor</span>, <span class="math">t=\\left\\{\\frac{D_{X}}{k}\\right\\}\\in[0,1)</span> with <span class="math">D_{X}=k(s+t)</span>. Then</p>

    <p class="text-gray-300"><span class="math">D_{YZ}</span> <span class="math">=\\deg_{Y,Z}(Q)\\leq D=D_{C}-D_{R}\\leq D_{C}\\leq\\sum_{i+kj&lt;D_{X}}j</span> <span class="math">=\\sum_{j&lt;\\frac{D_{X}}{k}}j(D_{X}-j\\cdot k)=D_{X}\\sum_{j=0}^{s}j-k\\sum_{j=0}^{s}j^{2}=k(s+t)\\frac{s(s+1)}{2}-k\\frac{s(s+1)(2s+1)}{6}</span> <span class="math">=\\frac{ks(s+1)(s+3t-1)}{6}=\\frac{k}{6}(s^{3}+3ts^{2}+(3t-1)s)=\\frac{k}{6}((s+t)^{3}-(1-3t+3t^{2})s-t^{3})</span> <span class="math">=\\frac{k}{6}((s+t)^{3}-(1-t)^{3}s-(s+1)t^{3})&lt;\\frac{k}{6}(s+t)^{3}=\\frac{D_{X}^{3}}{6k^{2}}\\leq\\frac{(m+\\frac{1}{2})^{3}}{6\\sqrt{\\rho}}\\,n,</span></p>

    <p class="text-gray-300">as claimed in (5.7). ∎</p>

    <h3 id="sec-111" class="text-xl font-semibold mt-8">B.2 The number of variables in the Guruswami–Sudan decoder</h3>

    <p class="text-gray-300">Recall that the Guruswami–Sudan decoder searched for a polynomial <span class="math">Q(X,Y)=\\sum_{i,j}Q_{ji}X^{i}Y^{j}</span>, with variable coefficients <span class="math">Q_{ji}</span> coming from the set <span class="math">\\{(i,j):i,j\\geq 0,i+k\\cdot j&lt;D_{X}\\}</span>.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Claim B.1.</h6>

    <p class="text-gray-300">The number of variables in the Guruswami–Sudan decoder above is at least</p>

    <p class="text-gray-300"><span class="math">\\frac{k}{2}\\Bigg{(}\\left(\\frac{D_{X}}{k}+\\frac{1}{2}\\right)^{2}-\\frac{1}{4}\\Bigg{)}=\\frac{D_{X}(D_{X}+k)}{2k}.</span></p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For this computation, we may assume <span class="math">D_{X}</span> is an integer: if is not, then replacing it by <span class="math">\\lceil D_{X}\\rceil</span> does not change the definition of the set of indices (since the inequality is strict), and only increases the lower bound we wish to prove. Dividing <span class="math">D_{X}</span> by <span class="math">k</span> with remainder, we write <span class="math">D_{X}=k\\cdot a+r</span>, with <span class="math">a=\\left\\lfloor\\frac{D_{X}}{k}\\right\\rfloor</span>, <span class="math">0\\leq r&lt;k</span>. The size of the index set is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\sum_{i+k\\cdot j&lt;D_{X}}1</span> $=\\sum_{j=0}^{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{0\\leq i<D_{X}-kj\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\sum_{j=0}^{a}(D_{X}-kj)=(a+1)D_{X}-k\\frac{a(a+1)}{2}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=(a+1)\\bigg{(}ka+r-\\frac{ka}{2}\\bigg{)}=\\frac{(ka+k)(ka+2r)}{2k}\\geq\\frac{(ka+r)(ka+r+k)}{2k}</span> <span class="math">=\\frac{D_{X}(D_{X}+k)}{2k},</span></p>

    <p class="text-gray-300">where the inequality <span class="math">(ka+k)(ka+2r)&gt;(ka+r)(ka+r+k)</span>, is equivalent after expansion to <span class="math">2rk&gt;r(r+k)\\geq r^{2}+rk</span>, or simply <span class="math">r(k-r)\\geq 0</span>, which follows from <span class="math">0\\leq r&lt;k</span>.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-114" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">C The Inseparable Factor Case in the List Decoding Regime</p>

    <p class="text-gray-300">Recall that in Section 5.2.3, we had assumed that in the decomposition</p>

    <p class="text-gray-300"><span class="math">Q(X,Y,Z)=C(X,Z)\\prod_{i}R_{i}(X,Y^{p^{f_{i}}},Z)^{e_{i}},</span></p>

    <p class="text-gray-300">the factors <span class="math">R_{i}(X,Y^{p^{f_{i}}},Z)</span> were all separable, i.e. <span class="math">f_{i}=0</span>. This assumption was in fact necessary only for the factor <span class="math">R</span> on which we focused in Section 5.2.4. We now consider the case where <span class="math">f=f_{i}&gt;0</span>, and our relevant factor is of the form <span class="math">R(X,Y^{\\mathfrak{p}},Z)</span>, where <span class="math">\\mathfrak{p}=p^{f}</span> and <span class="math">R(X,\\widetilde{Y},Z)</span> is separable and irreducible in <span class="math">\\widetilde{Y}</span>. Note that we still have that <span class="math">R(x_{0},\\widetilde{Y},Z)</span> is separable. The elements of <span class="math">S_{x_{0},R,H}</span> now satisfy <span class="math">Y-P_{z}(X)\\mid R(X,Y^{\\mathfrak{p}},Z)</span>, and equivalently <span class="math">\\widetilde{Y}=P_{z}(X)^{\\mathfrak{p}}</span> is a root of <span class="math">R(X,\\widetilde{Y},Z)</span> and <span class="math">Y^{\\mathfrak{p}}-P_{z}(X)^{\\mathfrak{p}}\\mid R(X,Y^{\\mathfrak{p}},Z)</span>. Similarly, <span class="math">\\widetilde{Y}=P_{z}(x_{0})^{\\mathfrak{p}}</span> is a root of the irreducible factor <span class="math">H(\\widetilde{Y},Z)</span> of <span class="math">R(x_{0},\\widetilde{Y},Z)</span> — and a simple root of both, since they are separable.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathfrak{p}\\leq\\deg_{Y}(R(X,Y^{\\mathfrak{p}},Z))\\leq\\deg_{Y}(Q(X,Y,Z))=D_{Y}</span> and therefore</p>

    <p class="text-gray-300"><span class="math">\\deg_{X}(P_{z}(X)^{\\mathfrak{p}})\\leq p^{f}k\\leq kD_{Y}&lt;D_{X}.</span></p>

    <p class="text-gray-300">We construct the field <span class="math">\\mathbb{L}</span> for the polynomial <span class="math">H(\\widetilde{Y},Z)</span> exactly as before, but noting that <span class="math">\\widetilde{Y}=Y^{\\mathfrak{p}}</span> will have weight <span class="math">\\mathfrak{p}</span>, which correspondingly affects the weight of <span class="math">T=W(Z)\\widetilde{Y}=W(Z)Y^{\\mathfrak{p}}</span>, now defined as <span class="math">D-(d_{H}-1)\\mathfrak{p}</span>. Note that the upper bound on <span class="math">d_{H},d</span> (the <span class="math">\\widetilde{Y}</span> degrees of <span class="math">R,H</span>) is also changed, and is now <span class="math">\\frac{D_{Y}}{\\mathfrak{p}}</span> instead of simply <span class="math">D_{Y}</span>. With these adaptations in mind, we perform the Hensel lift, lifting the root <span class="math">\\alpha_{0}=\\frac{T}{W}\\in\\mathbb{L}</span> of <span class="math">R(x_{0},\\widetilde{Y},Z)</span> to the power series root <span class="math">\\gamma\\in\\mathbb{L}[[X-x_{0}]]</span> of <span class="math">R(X,\\widetilde{Y},Z)</span>. Claim A.2 still holds and gives us</p>

    <p class="text-gray-300"><span class="math">\\Lambda(\\xi)</span> <span class="math">\\leq(D-\\mathfrak{p})+(d-2)\\Lambda(W)\\leq(d-1)(D-(d_{H}-1)\\mathfrak{p}),</span> <span class="math">\\Lambda(\\beta_{t})</span> <span class="math">\\leq\\mathfrak{p}+(t+1)\\Lambda(W)+e_{t}\\Lambda(\\xi)</span> <span class="math">\\leq((d-1)\\cdot e_{t}+t+1)(D-(d_{H}-1)\\mathfrak{p})-\\mathfrak{p}t&lt;(2t+1)dD.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in Section 5.2.6, the substitution <span class="math">\\pi_{z}(\\gamma)</span> for <span class="math">z\\in S^{\\prime}</span> is a root of <span class="math">R(X,\\widetilde{Y},z)</span> which is the lift of the simple root <span class="math">\\widetilde{Y}=P_{z}(x_{0})^{\\mathfrak{p}}</span> of <span class="math">R(x_{0},\\widetilde{Y},Z)</span>. Since <span class="math">P_{z}(X)^{\\mathfrak{p}}</span> is also of this form, by the uniqueness of the lifting we get <span class="math">\\pi_{z}(\\gamma)=P_{z}(X)^{\\mathfrak{p}}</span>, and in particular <span class="math">\\pi_{z}(\\alpha_{t})=0</span> and <span class="math">\\pi_{z}(\\beta_{t})=0</span> for all <span class="math">t</span> except for <span class="math">0\\leq t\\leq\\mathfrak{p}k&lt;D_{X}</span> which are divisible by <span class="math">\\mathfrak{p}</span>. As before, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d_{H}\\Lambda(\\beta_{t})<span class="math"> for all </span>t<D_{X}<span class="math">: the right hand side is bounded from above by </span>\\frac{D_{Y}^{2}D_{YZ}(2D_{X}-1)}{\\mathfrak{p}^{2}}<span class="math">, which only decreases as </span>\\mathfrak{p}<span class="math"> increases. It thus follows that </span>\\beta_{t}=0<span class="math"> and </span>\\alpha_{t}=0<span class="math"> for all </span>t<D_{X}<span class="math"> except for those which are at most </span>\\mathfrak{p}k<span class="math"> and divisible by </span>\\mathfrak{p}$. In other words we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\gamma_{D_{X}-1}=\\sum_{t=0}^{k}\\alpha_{\\mathfrak{p}t}(X-x_{0})^{\\mathfrak{p}t}.</span></p>

    <p class="text-gray-300">Out next goal is to show that <span class="math">\\gamma_{D_{X}-1}</span> is a <span class="math">\\mathfrak{p}</span>-th power of a polynomial of degree <span class="math">k</span> (and later that <span class="math">\\gamma=\\gamma_{D_{X}-1}</span>, and that this polynomial is in fact in <span class="math">\\mathbb{F}_{q}[Z][X-x_{0}]</span>, with coefficients linear in <span class="math">Z</span>). This part did not appear in Section 5, as it is trivial for <span class="math">\\mathfrak{p}=1</span>. This polynomial should naturally be the <span class="math">\\mathfrak{p}</span>-th root of <span class="math">\\gamma_{D_{X}-1}</span> — but in order to construct such roots, we will need some more preliminaries about the field in which they live.</p>

    <p class="text-gray-300">Let <span class="math">\\sigma:\\mathbb{F}_{q}\\to\\mathbb{F}_{q}</span> be the automorphism mapping each element <span class="math">a</span> to its unique <span class="math">\\mathfrak{p}</span>-th root <span class="math">\\sigma(a)=a^{1/\\mathfrak{p}}</span>. Let <span class="math">\\widehat{\\mathbb{L}}</span> be the inseparable algebraic field extension of <span class="math">\\mathbb{L}</span> with elements <span class="math">\\widehat{T},\\widehat{Z}</span> satisfying <span class="math">\\widehat{T}^{\\mathfrak{p}}-T=\\widehat{Z}^{\\mathfrak{p}}-Z=0</span>; equivalently, <span class="math">\\widehat{T}=T^{1/\\mathfrak{p}}</span> and <span class="math">\\widehat{Z}=Z^{1/\\mathfrak{p}}</span>. Note that <span class="math">\\widehat{\\mathbb{L}}</span> can also be directly defined directly</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{q}\\big{(}\\widehat{Z}\\big{)}\\big{[}\\widehat{T}\\big{]}/\\big{(}\\widehat{H}\\big{(}\\widehat{T},\\widehat{Z}\\big{)}\\big{)}</span>, where <span class="math">\\widehat{H}=\\sigma(\\widetilde{H})</span> is the (irreducible) polynomial obtained by applying <span class="math">\\sigma</span> to the coefficients of <span class="math">\\widehat{H}</span>, which satisfies</p>

    <p class="text-gray-300"><span class="math">\\widehat{H}\\big{(}\\widehat{T},\\widehat{Z}\\big{)}^{\\mathfrak{p}}=\\widetilde{H}\\Big{(}\\widehat{T}^{\\mathfrak{p}},\\widehat{Z}^{\\mathfrak{p}}\\Big{)}=\\widetilde{H}(T,Z).</span></p>

    <p class="text-gray-300">Since the monomials of <span class="math">\\widehat{H}</span> have the same <span class="math">\\widehat{T}</span>- and <span class="math">\\widehat{Z}</span>-degrees as the <span class="math">T</span>- and <span class="math">Z</span>-degrees of <span class="math">\\widetilde{H}</span>, a weight <span class="math">\\widehat{\\Lambda}</span> can be defined for regular elements in <span class="math">\\widehat{\\mathbb{L}}</span> in exactly the same way as in <span class="math">\\mathbb{L}</span>. Additionally, <span class="math">\\sigma</span> can be extended to a map <span class="math">\\widehat{\\sigma}:\\mathbb{L}\\to\\widehat{\\mathbb{L}}</span> satisfying <span class="math">\\widehat{\\sigma}(\\alpha)^{\\mathfrak{p}}=\\alpha</span> for all <span class="math">\\alpha\\in\\mathbb{L}</span> by defining <span class="math">\\widehat{\\sigma}(T)=\\widehat{T}</span> and <span class="math">\\widehat{\\sigma}(Z)=\\widehat{Z}</span>. Note that <span class="math">\\Lambda(\\beta)=\\widehat{\\Lambda}(\\widehat{\\sigma}(\\beta))</span> for any <span class="math">\\beta\\in\\mathcal{O}</span>, since <span class="math">\\widehat{\\sigma}</span> preserves degrees. The substitution maps <span class="math">\\pi_{z}</span> for <span class="math">z\\in S^{\\prime}</span> can also be extended to <span class="math">\\widehat{\\mathbb{L}}</span> by setting <span class="math">\\pi_{z}(\\widehat{Z})=\\sigma(z)=z^{1/\\mathfrak{p}}</span> and <span class="math">\\pi_{z}(\\widehat{T})=\\sigma(t_{z})=t_{z}^{1/\\mathfrak{p}}=\\widehat{W}\\big{(}z^{1/\\mathfrak{p}}\\big{)}P_{z}(x_{0})</span>, where <span class="math">\\widehat{W}=\\sigma(W)</span>.</p>

    <p class="text-gray-300">Define</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\gamma}=\\sum_{t=0}^{k}\\widehat{\\sigma}(\\alpha_{\\mathfrak{p}t})(X-x_{0})^{t}\\in\\widehat{\\mathbb{L}}[X-x_{0}]</span></p>

    <p class="text-gray-300">which indeed satisfies <span class="math">\\gamma_{D_{X}-1}=\\widehat{\\gamma}^{\\mathfrak{p}}</span>, and therefore <span class="math">R(X,\\widehat{\\gamma}^{\\mathfrak{p}},Z)\\equiv 0\\ (\\mathrm{mod}\\ (X-x_{0})^{D_{X}})</span>. Since <span class="math">R(X,Y^{\\mathfrak{p}},Z)</span> is a divisor of <span class="math">Q(X,Y,Z)</span>, it follows as before that <span class="math">\\deg_{X}R(X,\\widehat{\\gamma}^{\\mathfrak{p}},Z)&lt;D_{X}</span>, and therefore <span class="math">R(X,\\widehat{\\gamma}^{\\mathfrak{p}},Z)=0</span> identically, and <span class="math">\\gamma=\\gamma_{D_{X}-1}=\\widehat{\\gamma}^{\\mathfrak{p}}</span> by the uniqueness of the lifting. Furthermore, for every <span class="math">z\\in S^{\\prime}</span>, since <span class="math">\\pi_{z}(\\widehat{\\gamma})^{\\mathfrak{p}}=\\pi_{z}(\\widehat{\\gamma}^{\\mathfrak{p}})=\\pi_{z}(\\gamma)=P_{z}(X)^{\\mathfrak{p}}</span>, we also have <span class="math">\\pi_{z}(\\widehat{\\gamma})=P_{z}(X)</span>.</p>

    <p class="text-gray-300">As in Section 5.2.7, our next goal is now to show that the coefficients <span class="math">\\widehat{\\alpha}_{t}=\\widehat{\\sigma}(\\alpha_{\\mathfrak{p}t})</span> of <span class="math">\\widehat{\\gamma}</span> are linear polynomials in <span class="math">\\mathbb{F}_{q}[Z]</span>, rather than general elements of <span class="math">\\widehat{\\mathbb{L}}</span>. This is done in exactly the same way, by comparing the values of <span class="math">\\pi_{z}(\\widehat{\\gamma}(x))</span> and <span class="math">w(x,z)</span> at every <span class="math">x=x_{j}\\in\\mathcal{D}_{\\mathrm{top}}</span> and <span class="math">z\\in S^{\\prime}_{x}</span>, deducing that <span class="math">\\widehat{\\gamma}(x)</span> and <span class="math">w(x,Z)</span> must be equal in <span class="math">\\widehat{\\mathbb{L}}</span> since</p>

    <p class="text-gray-300"><span class="math">d_{H}\\widehat{\\Lambda}(\\widehat{\\beta}_{k})</span> <span class="math">=d_{H}\\widehat{\\Lambda}(\\widehat{\\sigma}(\\beta_{\\mathfrak{p}k}))=d_{H}\\Lambda(\\beta_{\\mathfrak{p}k})\\leq d_{H}(2\\mathfrak{p}k+1)dD&lt;\\frac{(2k+1)D_{Y}^{2}D_{YZ}}{\\mathfrak{p}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$<(2k+1)D_{Y}^{2}D_{YZ}<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, having shown that <span class="math">\\widehat{\\gamma}\\in\\mathbb{F}_{q}[X,Z]</span>, the arguments of Section 5.2.8 can be applied without any further changes, only with <span class="math">\\widehat{\\gamma}</span> in the role <span class="math">\\gamma</span>, concluding the proof.</p>

    <h2 id="sec-115" class="text-2xl font-bold">Appendix D Proof of Lemma 4.3</h2>

    <p class="text-gray-300">It has been recently discovered that there is a subtle flaw in the proof of <em>[x20, Lemma 4.2.18]</em>, and indeed, there are counter examples to the Lemma as originally stated (cf. <em>[x1]</em>). We thank Ronald Cramer and Jade Nardi for pointing out the precise flaw and suggesting possible fixes; the fix chosen and described in this paper was independently discovered by Ronald Cramer.</p>

    <p class="text-gray-300">The main difference between the version of the lemma used in this paper and the original version is the condition that the quotients <span class="math">P_{Z,x}</span> and <span class="math">P_{X,z}</span> have bounded degrees, with the bound matching the difference in the degrees of <span class="math">A</span> and <span class="math">B</span>. This extra assumption suffices to make the original proof valid, and is fortunately satisfied in our application.</p>

    <p class="text-gray-300">For completeness, we provide here a proof of the lemma, essentially following <em>[x20, Lemma 4.2.18]</em>. During the proof, we will make several reductions to smaller and simpler cases by changing the <span class="math">a,b,n</span> variables and the polynomials <span class="math">A,B</span>, but note that none of the reductions will change <span class="math">d_{X},d_{Z}</span> or <span class="math">\\frac{B(X,Z)}{A(X,Z)}</span>.</p>

    <p class="text-gray-300">Clearly, we may assume <span class="math">B</span> is not the zero polynomial (otherwise, the results are trivial). It then follows that <span class="math">A</span> is also not the zero polynomial (otherwise, <span class="math">B(x,Z)=0</span> for <span class="math">n_{X}&gt;b_{X}\\geq\\deg_{X}(B)</span> values of <span class="math">x</span>, so <span class="math">B</span> is identically <span class="math">0</span>). We may also assume that either <span class="math">\\deg_{X}(A)=a_{X}</span> or <span class="math">\\deg_{X}(B)=b_{X}</span>.</p>

    <p class="text-gray-300">If not, then we may decrease  <span class="math">a_{X}</span>  and  <span class="math">b_{X}</span>  by 1 without changing  <span class="math">d_{X} = b_{X} - a_{X}</span>  or any other assumption (in particular, the LHS of  <span class="math">(\\star)</span>  strictly decreases), and repeat until at least one equality holds.</p>

    <p class="text-gray-300">In fact, once we are done subtracting, we will necessarily have  <span class="math">\\deg_X(A) = a_X</span> . This fact follows from the bound on  <span class="math">\\deg_X(P_{X,z})</span>  as well as the inequality  <span class="math">b_{Z} &amp;lt; n_{Z}</span>  (which follows from  <span class="math">(\\star)</span> ). We omit the full details, as this fact will not be used in the proof.</p>

    <p class="text-gray-300">Similarly, by reducing  <span class="math">a_Z</span>  and  <span class="math">b_Z</span>  if necessary, we may assume  <span class="math">\\deg_Z(A) = a_Z</span>  (or  <span class="math">\\deg_Z(B) = b_Z</span> ).</p>

    <p class="text-gray-300">Next, let  <span class="math">G(X,Z) \\in \\mathbb{F}[X,Z]</span>  be the greatest common divisor of  <span class="math">A</span>  and  <span class="math">B</span> ; we aim to prove that  <span class="math">G = A</span> . Let  <span class="math">g_{X} = \\deg_{X}(G)</span> ,  <span class="math">g_{Z} = \\deg_{Z}(G)</span> , and replace both  <span class="math">A</span>  and  <span class="math">B</span>  with the quotients  <span class="math">A / G</span>  and  <span class="math">B / G</span> . The degrees  <span class="math">\\deg_{X}(A)</span> ,  <span class="math">\\deg_{X}(B)</span>  and their bounds  <span class="math">a_{X}, b_{X}</span>  decrease by exactly  <span class="math">g_{X}</span> , and  <span class="math">\\deg_{Z}(A)</span> ,  <span class="math">\\deg_{Z}(B)</span> ,  <span class="math">a_{Z}</span> ,  <span class="math">b_{Z}</span>  decrease by  <span class="math">g_{Z}</span> ; it follows that  <span class="math">d_{X}, d_{Z}</span>  are unchanged, and neither is the quotient  <span class="math">\\frac{B}{A} = \\frac{B / G}{A / G}</span> . The number of good substitutions  <span class="math">n_{X}</span>  also decreases by (at most)  <span class="math">g_{X}</span> , and similarly  <span class="math">n_{Z}</span>  decreases by at most  <span class="math">g_{Z}</span> : indeed, at most  <span class="math">g_{X}</span>  of the  <span class="math">x \\in \\mathbb{F}</span>  can satisfy  <span class="math">G(x,Z) = 0</span> , and in any of at least  <span class="math">n_{X} - g_{X}</span>  good substitution with  <span class="math">G(x,Z) \\neq 0</span> , we can divide both sides of  <span class="math">B(x,Z) = P_{Z,x}(Z)A(x,Z)</span>  by  <span class="math">G(x,Z)</span>  to obtain  <span class="math">\\frac{B}{G}(x,Z) = P_{Z,x}(Z)\\frac{A}{G}(x,Z)</span> , and the assumption  <span class="math">\\deg_{Z}(P_{Z,x}) \\leq d_{Z}</span>  isn't affected. Since  <span class="math">\\frac{b_{X}}{n_{X}} &amp;lt; 1</span>  and  <span class="math">g_{X} \\geq 0</span> , we will have  <span class="math">\\frac{b_{X} - g_{X}}{n_{X} - g_{X}} \\leq \\frac{b_{X}}{n_{X}}</span>  (with equality only if  <span class="math">g_{X} = 0</span> ), and thus</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {b _ {X} - g _ {X}}{n _ {X} - g _ {X}} + \\frac {b _ {Z} - g _ {Z}}{n _ {Z} - g _ {Z}} \\leq \\frac {b _ {X}}{n _ {X}} + \\frac {b _ {Z}}{n _ {Z}} &amp;lt;   1,</span></div>

    <p class="text-gray-300">and it follows that assumption  <span class="math">(\\star)</span>  still holds.</p>

    <p class="text-gray-300">We have seen that after dividing by the GCD, the polynomials still satisfy all of the Lemma's assumptions. Additionally, they are now coprime. We will prove that in this case we must have  <span class="math">a_{X} = a_{Z} = 0</span> , i.e.  <span class="math">A</span>  is a constant function.</p>

    <p class="text-gray-300">Write  <span class="math">A(X,Z) = A_0(Z) + A_1(Z)X + \\dots + A_{a_X}(Z)X^{a_X}</span> , and similarly  <span class="math">B(X,Z) = B_0(Z) + B_1(Z)X + \\dots + B_{b_X}(Z)X^{b_X}</span> . Note that at least one of  <span class="math">A_{a_X}</span> ,  <span class="math">B_{b_X}</span>  is non-zero by the early assumption on equality of degrees. Let</p>

    <div class="my-4 text-center"><span class="math-block">M _ {X} (Z) = \\operatorname {S y l} _ {X} (A, B) = \\left( \\begin{array}{c c c c c c c} B _ {b _ {X}} (Z) &amp;amp; \\dots &amp;amp; \\dots &amp;amp; B _ {1} (Z) &amp;amp; B _ {0} (Z) &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\dots &amp;amp; \\dots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; B _ {b _ {X}} (Z) &amp;amp; \\dots &amp;amp; \\dots &amp;amp; B _ {1} (Z) &amp;amp; B _ {0} (Z) \\\\ A _ {a _ {X}} (Z) &amp;amp; \\dots &amp;amp; A _ {1} (Z) &amp;amp; A _ {0} (Z) &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; A _ {a _ {X}} (Z) &amp;amp; \\dots &amp;amp; A _ {1} (Z) &amp;amp; A _ {0} (Z) &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; \\dots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; A _ {a _ {X}} (Z) &amp;amp; \\dots &amp;amp; A _ {1} (Z) &amp;amp; A _ {0} (Z) \\end{array} \\right)</span></div>

    <p class="text-gray-300">be the Sylvester matrix of  <span class="math">A</span>  and  <span class="math">B</span> , considered as polynomials of degrees  <span class="math">a_{X}</span>  and  <span class="math">b_{X}</span>  in  <span class="math">X</span>  over  <span class="math">\\mathbb{F}[Z]</span> . It is a square matrix of order  <span class="math">a_{X} + b_{X}</span> , with the first  <span class="math">a_{X}</span>  rows being shifts of the coefficient vector of  <span class="math">B</span> , and the last  <span class="math">b_{X}</span>  rows being shifts of the coefficients of  <span class="math">A</span> .</p>

    <p class="text-gray-300">Let  <span class="math">R_{X}(Z) = \\operatorname{det} M_{X}(Z)</span>  be the determinant of the Sylvester matrix, which is not identically 0, since the polynomials are coprime. By the bounds on the  <span class="math">Z</span> -degrees of  <span class="math">A_{i}, B_{j}</span> , it is immediate to see that  <span class="math">\\deg_Z(R_X) \\leq a_X b_Z + a_Z b_X</span> . We will denote  <span class="math">D \\coloneqq a_X b_Z + a_Z b_X</span> , and note that the expression is symmetric in  <span class="math">X</span>  and  <span class="math">Z</span> .</p>

    <p class="text-gray-300">For any of the <span class="math">n_{Z}</span> good values of <span class="math">z\\in\\mathbb{F}</span>, the fact that <span class="math">B(X,z)=P_{X,z}(X)A(X,z)</span> with <span class="math">\\deg_{X}(P)\\leq d_{X}=b_{X}-a_{X}</span> implies that each of the first <span class="math">a_{X}</span> rows of <span class="math">M_{X}(z)</span>, corresponding to the coefficients of <span class="math">B(X,z)</span>, is a linear combination of (at most) <span class="math">d_{X}+1</span> of the <span class="math">b_{X}</span> rows corresponding to coefficients of <span class="math">A(X,z)</span>. It follows that the last <span class="math">b_{X}</span> rows span the whole row space, i.e. <span class="math">\\operatorname{rk}M_{X}(z)\\leq b_{X}</span>, from which it follows that <span class="math">R_{X},R_{X}^{\\prime},\\ldots,R_{X}^{(a_{X}-1)}</span> all vanish at <span class="math">Z=z</span>, i.e. <span class="math">R_{X}</span> has a zero of multiplicity at least <span class="math">a_{X}</span> at every such <span class="math">z</span> (see also <em>[x20, Proposition 4.2.17]</em>). Note that the assumption <span class="math">\\deg_{X}(P_{X,z})\\leq d_{X}</span> is critical: if the degree were larger, than the first <span class="math">\\deg_{X}(P_{X,z})-d_{X}</span> of the <span class="math">B</span> rows would not have been spanned by the <span class="math">A</span> rows.</p>

    <p class="text-gray-300">We have obtained that <span class="math">R_{X}</span> is a non-vanishing polynomial of degree at most <span class="math">D</span>, with at least <span class="math">n_{Z}</span> roots of multiplicity <span class="math">a_{X}</span> each, thus <span class="math">a_{X}n_{Z}\\leq D</span>. Repeating the argument with the roles of <span class="math">X</span> and <span class="math">Z</span> switched, we find <span class="math">a_{Z}n_{X}\\leq D</span> as well. Thus</p>

    <p class="text-gray-300"><span class="math">D=a_{X}b_{Z}+a_{Z}b_{X}=\\frac{b_{Z}}{n_{Z}}a_{X}n_{Z}+\\frac{b_{X}}{n_{X}}a_{Z}n_{X}\\leq\\frac{b_{X}}{n_{X}}D+\\frac{b_{Z}}{n_{Z}}D=\\left(\\frac{b_{X}}{n_{X}}+\\frac{b_{Z}}{n_{Z}}\\right)D.</span></p>

    <p class="text-gray-300">However, <span class="math">(\\star)</span> yields <span class="math">\\frac{b_{X}}{n_{X}}+\\frac{b_{Z}}{n_{Z}}&lt;1</span>, and thus the obtained inequality is only possible for <span class="math">D=0</span>. Since <span class="math">n_{X},n_{Z}&gt;0</span>, and <span class="math">a_{X}n_{Z},a_{Z}n_{X}\\leq D=0</span>, we must have <span class="math">a_{X}=a_{Z}=0</span>, as claimed.</p>

    <p class="text-gray-300">From here the rest of the claim is immediate: <span class="math">a_{X}=a_{Z}=0</span> imply that <span class="math">A</span> is a constant polynomial, so clearly <span class="math">A\\mid B</span>, and furthermore the quotient <span class="math">P=B/A</span> is proportional to <span class="math">B</span>, thus <span class="math">\\deg_{X}(P)=\\deg_{X}(B)\\leq b_{X}=b_{X}-a_{X}=d_{X}</span>, and similarly <span class="math">\\deg_{Z}(P)\\leq d_{Z}</span>. Since <span class="math">d_{X},d_{Z}</span> and <span class="math">P=B/A</span> did not change during our reduction steps, the same results hold for the original polynomials and quotient.</p>

    <p class="text-gray-300">For all <span class="math">n_{Z}</span> substitutions <span class="math">z\\in\\mathbb{F}</span>, we have <span class="math">P(X,z)A(X,z)=B(X,z)=P_{X,z}(X)A(X,z)</span>, and if <span class="math">A(X,z)\\neq 0</span> then we can cancel it to obtain <span class="math">P(X,z)=P_{X,z}(X)</span>. At most <span class="math">\\deg_{Z}(A)\\leq a_{Z}</span> values of <span class="math">z</span> satisfy <span class="math">A(X,z)=0</span>, hence for at least <span class="math">n_{Z}-a_{Z}</span> values we have <span class="math">P(X,z)=P_{X,z}(X)</span>, and similarly for values of <span class="math">x</span>, as claimed.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-116" class="text-2xl font-bold">Appendix E Proof of Claim 8.1</h2>

    <h6 id="sec-117" class="text-base font-medium mt-4">Proof of Claim 8.1.</h6>

    <p class="text-gray-300">By assumption <span class="math">f^{(i)}</span> is the evaluation of a polynomial <span class="math">P(X)</span> of degree strictly less than <span class="math">k^{(i)}</span> and <span class="math">k^{(i)}</span> is an integral power of <span class="math">2</span>. Recall <span class="math">k^{(i+1)}=\\frac{k^{(i)}+1}{2}-1</span> noticing <span class="math">k^{(i+1)}+1</span> is an integral power of <span class="math">2</span>. Let</p>

    <p class="text-gray-300"><span class="math">Q(X,Y)=P(X)\\bmod Y-X^{l^{(i)}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition <span class="math">\\deg_{X}(Q)&lt;l^{(i)}</span> and <span class="math">\\deg_{Y}(Q)&lt;k^{(i+1)}</span>. We claim <span class="math">f^{(i+1)}_{f^{(i)},z^{(i)}}</span> is the evaluation of the polynomial <span class="math">Q(z^{(i)},Y)\\in\\mathbb{F}[Y]</span> on <span class="math">\\mathcal{D}^{(i+1)}</span>. To see this recall that <span class="math">M^{(i)}_{g}</span> is the interpolation map over $f^{(i)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{C^{(i)}_{g}}$ and so</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$M^{(i)}_{g}\\cdot f^{(i)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{C^{(i)}_{g}}=Q(X,g).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, using Eq. (8.2), we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$f^{(i+1)}_{f^{(i)},z^{(i)}}(g)=\\left(\\mathbf{z}^{(i)}\\right)^{\\top}\\cdot M^{(i)}_{g}\\cdot\\left.f^{(i)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C^{(i)}_{g}}=Q(z^{(i)},g).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So <span class="math">f^{(i+1)}_{f^{(i)},z^{(i)}}</span> is the evaluation of the polynomial <span class="math">Q(z^{(i)},Y)</span>, which has degree less than <span class="math">k^{(i+1)}</span>, on the domain <span class="math">\\mathcal{D}^{(i+1)}</span>. This completes the proof. ∎</p>

    <h2 id="sec-118" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Proximity Gaps for Reed-Solomon Codes (2020/654)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/654
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
