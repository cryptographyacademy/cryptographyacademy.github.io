---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/113';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Stream ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression';
const AUTHORS_HTML = 'Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancrède Lepoint, María Naya-Plasencia, Pascal Paillier, Renaud Sirdey';

const CONTENT = `    <p class="text-gray-300">Stream ciphers: A Practical Solution for Efficient Homomorphic-Ciphertext Compression</p>

    <p class="text-gray-300">Anne Canteaut<span class="math">^{1}</span>, Sergiu Carpov<span class="math">^{2}</span>, Caroline Fontaine<span class="math">^{3*}</span>, Tancrède Lepoint<span class="math">^{4**}</span>,</p>

    <p class="text-gray-300">María Naya-Plasencia<span class="math">^{1}</span>, Pascal Paillier<span class="math">^{4**}</span>, and Renaud Sirdey<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Inria, France, {anne.canteaut,maria.naya_plasencia}@inria.fr <span class="math">^{2}</span> CEA LIST, France, {sergiu.carpov,renaud.sirdey}@cea.fr <span class="math">^{3}</span> CNRS/Lab-STICC and Telecom Bretagne and UEB, caroline.fontaine@telecom-bretagne.eu <span class="math">^{4}</span> CryptoExperts, France, {tancrede.lepoint,pascal.paillier}@cryptoexperts.com</p>

    <p class="text-gray-300">Abstract. In typical applications of homomorphic encryption, the first step consists for Alice to encrypt some plaintext <span class="math">m</span> under Bob's public key <span class="math">\\mathsf{pk}</span> and to send the ciphertext <span class="math">c = \\mathsf{HE}_{\\mathsf{pk}}(m)</span> to some third-party evaluator Charlie. This paper specifically considers that first step, i.e. the problem of transmitting <span class="math">c</span> as efficiently as possible from Alice to Charlie. As previously noted, a form of compression is achieved using hybrid encryption. Given a symmetric encryption scheme <span class="math">\\mathsf{E}</span>, Alice picks a random key <span class="math">k</span> and sends a much smaller ciphertext <span class="math">c&#x27; = (\\mathsf{HE}_{\\mathsf{pk}}(k), \\mathsf{E}_k(m))</span> that Charlie decompresses homomorphically into the original <span class="math">c</span> using a decryption circuit <span class="math">\\mathcal{C}_{\\mathsf{E}^{-1}}</span>.</p>

    <p class="text-gray-300">In this paper, we revisit that paradigm in light of its concrete implementation constraints; in particular <span class="math">\\mathsf{E}</span> is chosen to be an additive IV-based stream cipher. We investigate the performances offered in this context by Trivium, which belongs to the eSTREAM portfolio, and we also propose a variant with 128-bit security: Kreyvium. We show that Trivium, whose security has been firmly established for over a decade, and the new variant Kreyvium have an excellent performance.</p>

    <p class="text-gray-300">Keywords. Stream Ciphers, Homomorphic cryptography, Ciphertext compression, Trivium</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Since the breakthrough result of Gentry [Gen09] achieving fully homomorphic encryption (FHE), many works have been published on simpler and more efficient schemes based on homomorphic encryption. Because they allow arbitrary computations on encrypted data, FHE schemes suddenly opened the way to exciting new applications, in particular cloud-based services in several areas (see e.g. [NLV11,GLN12,LLN14]).</p>

    <p class="text-gray-300">Compressed encryption. In these cloud applications, it is often assumed that some data is sent encrypted under a homomorphic encryption (HE) scheme to the cloud to be processed in a way or another. It is thus typical to consider, in the first step of these applications, that a user (Alice) encrypts some data <span class="math">m</span> under some other user's public key <span class="math">\\mathsf{pk}</span> (Bob) and sends some homomorphic ciphertext <span class="math">c = \\mathsf{HE}_{\\mathsf{pk}}(m)</span> to a third-party evaluator in the Cloud (Charlie). The roles of Alice and Bob are clearly distinct, even though they might be played by the same entity in some applications.</p>

    <p class="text-gray-300">However, all HE schemes proposed so far suffer from a very large ciphertext expansion; the transmission of <span class="math">c</span> between Alice and Charlie is therefore a very significant bottleneck in practice. The problem of reducing the size of <span class="math">c</span> as efficiently as possible has first been considered in [NLV11] wherein <span class="math">m</span> is encrypted with a symmetric encryption scheme <span class="math">\\mathsf{E}</span> under some key <span class="math">k</span> randomly chosen by Alice, who then sends a much smaller ciphertext <span class="math">c&#x27; = (\\mathsf{HE}_{\\mathsf{pk}}(k), \\mathsf{E}_k(m))</span> to Charlie. Given <span class="math">c&#x27;</span>, Charlie then exploits the homomorphic property of <span class="math">\\mathsf{HE}</span> and recovers the original</p>

    <div class="my-4 text-center"><span class="math-block">c = \\mathsf{HE}_{\\mathsf{pk}}(m) = \\mathcal{C}_{\\mathsf{E}^{-1}} \\left(\\mathsf{HE}_{\\mathsf{pk}}(k), \\mathsf{E}_k(m)\\right)</span></div>

    <p class="text-gray-300">by homomorphically evaluating the decryption circuit <span class="math">\\mathcal{C}_{\\mathsf{E}^{-1}}</span>. This can be assimilated to a compression method for homomorphic ciphertexts, <span class="math">c&#x27;</span> being the result of applying a compressed encryption scheme to</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This work has received a French governmental support granted to the COMIN Labs excellence laboratory and managed by the National Research Agency in the “Investing for the Future” program under reference ANR-10-LABX-07-01.</li>

    </ul>

    <p class="text-gray-300">** This work has been supported in part by the European Union’s H2020 Programme under grant agreement number ICT-644209 and the French FUI project CRYPTOCOMP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the plaintext <span class="math">m</span> and <span class="math">c</span> being recovered from <span class="math">c^{\\prime}</span> using a ciphertext decompression procedure. In that approach obviously, the new encryption rate $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ becomes asymptotically close to 1 for long messages, which leaves no significant margin for improvement. However, the paradigm of ciphertext compression leaves totally open the question of how to choose E in a way that minimizes the decompression overhead, while preserving the same security level as originally intended.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Prior art. The cost of a homomorphic evaluation of several symmetric primitives has been investigated, including several optimized implementations of AES <em>[x12, x10, x14]</em>, and of the lightweight block ciphers Simon <em>[x20]</em> and Prince <em>[x13]</em>. Usually very simple, lightweight block ciphers seem natural candidates for efficient evaluations in the encrypted domain. However, they may also lead to much worse performances than a homomorphic evaluation of, say, AES. Indeed, contemporary HE schemes use noisy ciphertexts, where a fresh ciphertext includes a noise component which grows along with homomorphic operations. Usually a homomorphic multiplication increases the noise by much larger proportions than a homomorphic addition. The maximum allowable level of noise (determined by the system parameters) then depends mostly on the multiplicative depth of the circuit. Many lightweight block ciphers balance out their simplicity by a large number of rounds, e.g. KATAN and KTANTAN <em>[x9]</em>, with the effect of considerably increasing their multiplicative depth. This type of design is therefore prohibitive in a HE context. Still Prince appears to be a much more suitable block cipher for homomorphic evaluation than AES (and than Simon), because it specifically targets applications that require a low latency; it is designed to minimize the cost of an unrolled implementation <em>[BCG^{+}12]</em> rather than being designed to optimize e.g. silicon area.</p>

    <p class="text-gray-300">At Eurocrypt 2015, Albrecht, Rechberger, Schneider, Tiessen and Zohner observed that the usual criteria that rule the design of lightweight block ciphers are not appropriate when designing a symmetric encryption scheme with a low-cost homomorphic evaluation <em>[ARS^{+}15]</em>. Indeed, both the number of rounds and the number of binary multiplications required to evaluate an Sbox have to be taken into account. Minimizing the number of rounds is a crucial issue for low-latency ciphers like Prince, while minimizing the number of multiplications is a requirement when designing a block cipher for efficient masked implementations (see e.g. <em>[x12]</em>).</p>

    <p class="text-gray-300">These two criteria have been considered together for the first time by Albrecht et al. in the recent design of a family of block ciphers called LowMC <em>[ARS^{+}15]</em> with very small multiplicative size and depth. However, the proposed instances of LowMC, namely LowMC-80 and LowMC-128, have recently had some security issues <em>[x10]</em>. They actually present some weaknesses inherent in their low multiplicative complexity. Indeed, the algebraic normal forms (i.e., the multivariate polynomials) describing the encryption and decryption functions are sparse and have a low degree. This type of features is usually exploited in algebraic attacks, cube attacks and their variants, e.g. <em>[x7, x8, x11, x1]</em>. While these attacks are rather general, the improved variant used for breaking LowMC <em>[x10]</em>, named interpolation attack <em>[x16]</em>, specifically applies to block ciphers. Indeed it exploits the sparse algebraic normal form of some intermediate bit within the cipher using that this bit can be evaluated both from the plaintext in the forward direction and from the ciphertext in the backward direction. This technique leads to several attacks including a key-recovery attack against LowMC-128 with time complexity <span class="math">2^{118}</span> and data complexity <span class="math">2^{73}</span>, implying that the cipher does not provide the expected 128-bit security level.</p>

    <p class="text-gray-300">Our contributions. We emphasize that beyond the task of designing a HE-friendly block cipher, revisiting the whole compressed encryption scheme (in particular its internal mode of operation) is what is really needed in order to take these concrete HE-related implementation constraints into account.</p>

    <p class="text-gray-300">First, we identify that homomorphic decompression is subject to an offline phase and an online phase. The offline phase is plaintext-independent and therefore can be performed in advance, whereas the online phase completes decompression upon reception of the plaintext-dependent part of the compressed ciphertext. Making the online phase as quick as technically doable leads us to choose an additive IV-based stream cipher to implement E. However, we note that the use of a lightweight block cipher as the building-block of that stream cipher usually provides a security level limited to <span class="math">2^{n/2}</span> where <span class="math">n</span> is the block size <em>[x21]</em>, thus limiting the number of encrypted blocks to (typically) less than <span class="math">2^{32}</span> (i.e. 32GB for 64-bit blocks).</p>

    <p class="text-gray-300">As a result, we propose our own candidate for E: the keystream generator Trivium <em>[x10]</em>, which belongs to the eSTREAM portfolio of recommended stream ciphers, and a new proposal called <em>Kreyvium</em>, which shares the same internal structure but allows for bigger keys of 128 bits. The main advantage of Kreyvium over Trivium is that it provides 128-bit security (instead of 80-bit) with the same multiplicative depth, and inherits the same security arguments. It is worth noticing that the design of a variant of Trivium which guarantees a 128-bit security level has been raised as an open problem for the last ten years, see e.g. <em>[x11, p. 30]</em>. Beside a higher security level, it also accommodates longer IVs, so that it can encrypt up to <span class="math">46\\cdot 2^{128}</span> plaintext bits under the same key, with multiplicative depth only 12. Moreover, both Trivium and Kreyvium are resistant against the interpolation attacks used for breaking LowMC since these ciphers do not rely on a permutation which would enable the attacker to compute backwards.</p>

    <p class="text-gray-300">We implemented our construction and instantiated it with Trivium, Kreyvium and LowMC in CTR-mode. Our results show that the promising performances attained by the HE-dedicated block cipher LowMC can be achieved with well-known primitives whose security has been firmly established for over a decade.</p>

    <p class="text-gray-300">Organization of the paper. We introduce a general model and a generic construction to compress homomorphic ciphertexts in Sec. 2. Our construction using Trivium and Kreyvium is described in Sec. 3. Subsequent experimental results are presented in Sec. 4.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 A Generic Design for Efficient Decompression</h2>

    <p class="text-gray-300">In this section, we describe our model and generic construction to transmit compressed homomorphic ciphertexts between Alice and Charlie. We use the same notation as in the introduction: Alice wants to send some plaintext <span class="math">m</span>, encrypted under Bob’s public key <span class="math">\\mathsf{pk}</span> (of an homomorphic encryption scheme HE) to a third party evaluator Charlie.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Offline/Online Phases in Ciphertext Decompression</h3>

    <p class="text-gray-300">Most practical scenarios would likely find it important to distinguish between three distinct phases within the homomorphic evaluation of <span class="math">\\mathcal{C}_{\\mathsf{E}^{-1}}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an <em>offline key-setup</em> phase which only depends on Bob’s public key and can be performed once and for all before Charlie starts receiving compressed ciphertexts encrypted under Bob’s key;</li>

      <li>an <em>offline decompression</em> phase which can be performed only based on some plaintext-independent material found in the compressed ciphertext;</li>

      <li>an <em>online decompression</em> phase which aggregates the result of the offline phase with the plaintext-dependent part of the compressed ciphertext and (possibly very quickly) recovers the decompressed ciphertext <span class="math">c</span>.</li>

    </ol>

    <p class="text-gray-300">As such, our general-purpose formulation <span class="math">c^{\\prime}=(\\mathsf{HE}_{\\mathsf{pk}}(k),\\mathsf{E}_{k}(m))</span> does not allow to make a clear distinction between these three phases. In our context, it is much more relevant to reformulate the encryption scheme as an IV-based encryption scheme where the encryption and decryption process are both deterministic but depend on an IV:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{E}_{k}(m)\\stackrel{{\\scriptstyle\\text{\\tiny def}}}{{=}}\\left(IV,\\mathsf{E}^{\\prime}_{k,IV}(m)\\right)\\;.</span></p>

    <p class="text-gray-300">Since the IV has a limited length, it can be either transmitted during an offline preprocessing phase, or may alternately correspond to a state which is maintained by the server. Now, to minimize the latency</p>

    <p class="text-gray-300">of homomorphic decompression for Charlie, the online phase should be reduced to a minimum. The most appropriate choice in this respect consists in using an additive IV-based stream cipher  <span class="math">Z</span>  so that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {E} _ {k, I V} ^ {\\prime} (m) = Z (k, I V) \\oplus m.</span></div>

    <p class="text-gray-300">In this reformulation, the decompression process is clearly divided into a offline precomputation stage which only depends on  <span class="math">\\mathsf{pk}, k</span>  and  <span class="math">IV</span> , and an online phase which is plaintext-dependent. The online phase is thus reduced to a mere XOR between the plaintext-dependent part of the ciphertext  <span class="math">\\mathsf{E}_{k,IV}&#x27;(m)</span>  and the HE-encrypted keystream  <span class="math">\\mathsf{HE}(Z(k,IV))</span> , which comes essentially for free in terms of noise growth in HE ciphertexts. All expensive operations (i.e. homomorphic multiplications) are performed during the offline decompression phase where  <span class="math">\\mathsf{HE}(Z(k,IV))</span>  is computed from  <span class="math">\\mathsf{HE}(k)</span>  and  <span class="math">IV</span> .</p>

    <h2 id="sec-3" class="text-2xl font-bold">2.2 Our Generic Construction</h2>

    <p class="text-gray-300">We devise a generic construction based on a homomorphic encryption scheme  <span class="math">\\mathsf{HE}</span>  with plaintext space  <span class="math">\\{0,1\\}</span> , an expansion function  <span class="math">G</span>  mapping  <span class="math">\\ell_{IV}</span> -bit strings to strings of arbitrary size, and a fixed-size parametrized function  <span class="math">F</span>  with input size  <span class="math">\\ell_x</span> , parameter size  <span class="math">\\ell_k</span>  and output size  <span class="math">N</span> . The construction is depicted on Fig. 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Our generic construction. The multiplicative depth of the circuit is equal to the depth of  <span class="math">\\mathcal{C}_F</span> . This will be the bottleneck in our protocol and we want the multiplicative depth of  <span class="math">F</span>  to be as small as possible. With current HE schemes, the circuit  <span class="math">\\mathcal{C}_{\\oplus}</span>  is usually very fast (addition of ciphertexts) and has a negligible impact on the noise in the ciphertext.</p>

    <p class="text-gray-300">Compressed encryption. Given an  <span class="math">\\ell_{m}</span> -bit plaintext  <span class="math">m</span> , Bob's public key  <span class="math">\\mathsf{pk}</span>  and  <span class="math">IV \\in \\{0,1\\}^{\\ell_{IV}}</span> , the compressed ciphertext  <span class="math">c&#x27;</span>  is computed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">t = \\lceil \\ell_m / N \\rceil</span></li>

      <li>Set  <span class="math">(x_{1},\\ldots ,x_{t}) = G(IV;t\\ell_{x})</span></li>

      <li>Randomly pick  <span class="math">k\\gets \\{0,1\\}^{\\ell_k}</span></li>

      <li>For  <span class="math">1 \\leq i \\leq t</span> , compute  <span class="math">z_{i} = F_{k}(x_{i})</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Set keystream to the  <span class="math">\\ell_{m}</span>  leftmost bits of  $z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{t}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">c&#x27; = (\\mathsf{HE}_{\\mathsf{pk}}(k), m \\oplus \\mathsf{keystream})</span> .</li>

    </ol>

    <p class="text-gray-300">Ciphertext decompression. Given <span class="math">c^{\\prime}</span> as above, Bob’s public key <span class="math">\\mathsf{pk}</span> and <span class="math">IV\\in\\{0,1\\}^{\\ell_{IV}}</span>, the ciphertext decompression is performed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">t=\\lceil\\ell_{m}/N\\rceil</span>,</li>

      <li>Set <span class="math">(x_{1},\\ldots,x_{t})=G(IV;t\\ell_{x})</span>,</li>

      <li>For <span class="math">1\\leq i\\leq t</span>, compute <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(z_{i})=\\mathcal{C}_{F}\\left(\\mathsf{HE}_{\\mathsf{pk}}(k),x_{i}\\right)</span> with some circuit <span class="math">\\mathcal{C}_{F}</span>,</li>

      <li>Deduce <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(\\mathsf{keystream})</span> from <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(z_{1}),\\ldots,\\mathsf{HE}_{\\mathsf{pk}}(z_{t})</span>,</li>

      <li>Compute <span class="math">c=\\mathsf{HE}_{\\mathsf{pk}}(m)=\\mathcal{C}_{\\oplus}\\left(\\mathsf{HE}_{\\mathsf{pk}}(\\mathsf{keystream}),m\\oplus\\mathsf{keystream}\\right)</span>.</li>

    </ol>

    <p class="text-gray-300">The circuit <span class="math">\\mathcal{C}_{\\oplus}</span> computes <span class="math">\\mathsf{HE}(a\\oplus b)</span> given <span class="math">\\mathsf{HE}(a)</span> and <span class="math">b</span> where <span class="math">a</span> and <span class="math">b</span> are bit-strings of the same size. In our construction, the cost of decompression per plaintext block is <em>fixed</em> and roughly equals one single evaluation of the circuit <span class="math">\\mathcal{C}_{F}</span>; most importantly, the multiplicative depth of the decompression circuit is also fixed, and set to the depth of <span class="math">\\mathcal{C}_{F}</span>.</p>

    <p class="text-gray-300">How secure are compressed ciphertexts? From a high-level perspective, compressed homomorphic encryption is just hybrid encryption and relates to the generic KEM-DEM construct. However it just cannot inherit from the general security results attached to the KEM-DEM framework <em>[x1, x10]</em> since taking some HE scheme to implement the KEM part does not even fulfill the basic requirements that the KEM be IND-CCA or even IND-CCCA. It is usual that HE schemes succeed in achieving CPA security but often grossly fail to realize any form of CCA1 security, to the point of admitting simple key recovery attacks <em>[x12]</em>. Therefore common KEM-DEM results just do not apply here.</p>

    <p class="text-gray-300">On the other hand, CPA security is arguably strong enough for compressed homomorphic encryption, given that in practice Alice may always provide a signature <span class="math">\\sigma(c^{\\prime})</span> together with <span class="math">c^{\\prime}</span> to Charlie to ensure origin and data authenticity. Thus, the right level of security requirement on the compressed encryption scheme itself seems to be just IND-CPA for concrete use. However, it is not known what minimal security assumptions to require from a homomorphic KEM and a general-purpose DEM to yield a KEM-DEM scheme that is provably IND-CPA. As a result of that, evidence that CPA security is reached may only be provided on a case-by-case basis given a specific embodiment.</p>

    <p class="text-gray-300">Instantiating the paradigm. The rest of the paper focuses on how to choose the expansion function <span class="math">G</span> and function <span class="math">F</span> so that the homomorphic evaluation of <span class="math">\\mathcal{C}_{F}</span> is as fast (and its multiplicative depth as low) as possible. In our approach, the value of <span class="math">IV</span> is assumed to be shared between Alice and Charlie and needs not be transmitted along with the compressed ciphertext. For instance, <span class="math">IV</span> is chosen to be an absolute constant such as <span class="math">IV=0^{\\ell}</span> where <span class="math">\\ell=\\ell_{IV}=\\ell_{x}</span>. Another example is to take for <span class="math">IV\\in\\{0,1\\}^{\\ell}</span> a synchronized state that is updated between transmissions. Also, the expansion function <span class="math">G</span> is chosen to implement a counter in the sense of the NIST description of the CTR mode <em>[x20]</em>, for instance</p>

    <p class="text-gray-300"><span class="math">G(IV;t\\ell)=(IV,IV\\boxplus 1,\\ldots,IV\\boxplus(t-1))\\quad\\text{where}\\quad a\\boxplus b=(a+b)\\bmod 2^{\\ell}\\;.</span></p>

    <p class="text-gray-300">Finally, <span class="math">F</span> is chosen to follow a specific design to ensure both an appropriate security level and a low multiplicative depth. We focus in Section 3 on the keystream generator corresponding to Trivium, and on a new variant, called <em>Kreyvium</em>.</p>

    <p class="text-gray-300">Interestingly, the output of an iterated PRF used in counter mode is computationally indistinguishable from random <em>[x3, Th. 13]</em>. Hence, under the assumption that Trivium or Kreyvium is a PRF, the keystream <span class="math">z_{1}\\mid\\mid\\ldots\\mid\\mid z_{t}</span> produced by our construction is also indistinguishable. However, this is insufficient to prove that the compressed encryption scheme is semantically secure (IND-CPA), because the adversary also sees <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(k)</span> during the IND-CPA game, which cannot be proven not to make the keystream distinguishable. Although the security of this approach is empiric, Section 3 provides a strong rationale for the Kreyvium design and makes it the solution with the smallest homomorphic evaluation latency known so far.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Why not using a block cipher for <span class="math">F</span>?</h4>

    <p class="text-gray-300">Although not specifically in these terms, the use of lightweight block ciphers like Prince and Simon has been proposed in the context of compressed homomorphic ciphertexts <em>e.g.</em> <em>[x21, x11]</em>. However a complete encryption scheme based on the ciphers has not been defined. This is a major issue since the security provided by all classical modes of operation (including all variants</p>

    <p class="text-gray-300">of CBC, CTR, CFB, OFB, OCB...) is inherently limited to  <span class="math">2^{n/2}</span>  where  <span class="math">n</span>  is the block size [Rog11] (this is also emphasized in e.g. [KL14, p. 95]). Only a very few modes providing beyond-birthday security have been proposed [Iwa06, Yas11, LST12] but they induce a higher implementation cost and their security is usually upper-bounded by  <span class="math">2^{2n/3}</span> .</p>

    <p class="text-gray-300">In other words, the use of a block cipher operating on 64-bit blocks like PRINCE or SIMON-32/64 implies that the number of blocks encrypted under the same key should be significantly less than  <span class="math">2^{32}</span>  (i.e. 32GB for 64-bit blocks). Therefore, only block ciphers with a large enough block size, like the LowMC instantiation with a 256-bit block proposed in  <span class="math">\\mathrm{[ARS^{+}15]}</span> , are suitable in applications which may require the encryption of more than  <span class="math">2^{32}</span>  bits under the same key.</p>

    <p class="text-gray-300">Since an additive stream cipher is the optimal choice, we now focus on keystream generation, and on its homomorphic evaluation. An IV-based keystream generator is decomposed into:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a resynchronization function, Sync, which takes as input the IV and the key (possibly expanded by some precomputation phase), and outputs some  <span class="math">n</span> -bit initial state;</li>

      <li>a transition function  <span class="math">\\varPhi</span>  which computes the next state of the generator;</li>

      <li>a filtering function  <span class="math">f</span>  which computes a keystream segment from the current internal state.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">Since generating  <span class="math">N</span>  keystream bits may require a circuit of depth up to</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\operatorname {d e p t h} \\left(\\operatorname {S y n c}\\right) + N \\operatorname {d e p t h} (\\Phi) + \\operatorname {d e p t h} (f)\\right),</span></div>

    <p class="text-gray-300">the best design strategy for minimizing this value consists in choosing a transition function with a small depth. The extreme option is to choose for  <span class="math">\\varPhi</span>  a linear function as in the CTR mode where the counter is implemented by an LFSR. An alternative strategy that we will investigate consists in choosing a nonlinear transition whose depth does not increase too fast when it is iterated. In App. B, the reader may find a discussion on the influence of Sync on the multiplicative depth of the circuit depending on which quantity should be encrypted under the HE scheme.</p>

    <p class="text-gray-300">Size of the internal state. A major specificity of our context is that a large internal state can be easily handled. Indeed, in most classical stream ciphers, the internal-state size usually appears as a bottleneck because the overall size of the quantities to be stored highly influences the number of gates in the implementation. This is not the case in our context. It might seem, a priori, that increasing the size of the internal state automatically increases the number of nonlinear operations (because the number of inputs of  <span class="math">\\varPhi</span>  increases). But, this is not the case if a part of this larger internal state is used, for instance, for storing the secret key. This strategy can be used for increasing the security at no implementation cost. Indeed, the complexity of all generic attacks aiming at recovering the internal state of the generator is  <span class="math">\\mathcal{O}(2^{n / 2})</span>  where  <span class="math">n</span>  is the size of the secret part of the internal state even if some part is not updated during the keystream generation. For instance, the time-memory-data-tradeoff attacks in [Bab95, Gol97, BS00] aim at inverting the function which maps the internal state of the generator to the first keystream bits. But precomputing some values of this function must be feasible by the attacker, which is not the case if the filtering or transition function depends on some secret material. On the other hand, the size  <span class="math">n^{\\prime}</span>  of the non-constant secret part of the internal state determines the data complexity for finding a collision on the internal state: the length of the keystream produced from the same key is limited to  <span class="math">2^{n^{\\prime} / 2}</span> . But, if the transition function or the filtering function depends on the IV, this limitation corresponds to the maximal keystream length produced from the same key/IV pair. It is worth noticing that many attacks require a very long keystream generated from the same key/IV pair and do not apply in our context since the keystream length is strictly limited by the multiplicative depth of the circuit.</p>

    <p class="text-gray-300">3.1 Trivium in the HE setting</p>

    <p class="text-gray-300">Trivium <em>[x10]</em> is one of the seven stream ciphers recommended by the eSTREAM project after a 5-year international competition <em>[x13]</em>. Due to the small number of nonlinear operations in its transition function, it appears as a natural candidate in our context.</p>

    <p class="text-gray-300">Description. Trivium is a synchronous stream cipher with a key and an IV of 80 bits each. Its internal state is composed of three registers of sizes 93, 84 and 111 bits, having an internal state size of 288 bits in total. Here, we use for the internal state the notation introduced by the designers: the leftmost bit of the 93-bit register is <span class="math">s_{1}</span>, and its rightmost one is <span class="math">s_{93}</span>; the leftmost bit of the register of size 84 is <span class="math">s_{94}</span> and the rightmost <span class="math">s_{177}</span>; the leftmost bit of register of size 111 is <span class="math">s_{178}</span> and the rightmost <span class="math">s_{288}</span>. The initialization and the generation of an <span class="math">N</span>-bit Keystream are described below.</p>

    <p class="text-gray-300"><span class="math">(s_{1},s_{2},\\ldots,s_{93})\\leftarrow(K_{0},\\ldots,K_{79},0,\\ldots,0)</span> <span class="math">(s_{94},s_{95},\\ldots,s_{177})\\leftarrow(IV_{0},\\ldots,IV_{79},0,\\ldots,0)</span> <span class="math">(s_{178},s_{179},\\ldots,s_{288})\\leftarrow(0,\\ldots,0,1,1,1)</span> for <em><span class="math">i=1</span> to <span class="math">1152+N</span></em> do <span class="math">t_{1}\\leftarrow s_{66}+s_{93}</span> <span class="math">t_{2}\\leftarrow s_{162}+s_{177}</span> <span class="math">t_{3}\\leftarrow s_{243}+s_{288}</span> if <em><span class="math">i&gt;1152</span></em> do output <span class="math">z_{i-1152}\\leftarrow t_{1}+t_{2}+t_{3}</span> end if <span class="math">t_{1}\\leftarrow t_{1}+s_{91}\\cdot s_{92}+s_{171}</span> <span class="math">t_{2}\\leftarrow t_{2}+s_{175}\\cdot s_{176}+s_{264}</span> <span class="math">t_{3}\\leftarrow t_{3}+s_{286}\\cdot s_{287}+s_{69}</span> <span class="math">(s_{1},s_{2},\\ldots,s_{93})\\leftarrow(t_{3},s_{1},\\ldots,s_{92})</span> <span class="math">(s_{94},s_{95},\\ldots,s_{177})\\leftarrow(t_{1},s_{94},\\ldots,s_{176})</span> <span class="math">(s_{178},s_{179},\\ldots,s_{288})\\leftarrow(t_{2},s_{178},\\ldots,s_{287})</span> end for</p>

    <p class="text-gray-300">No attack better than an exhaustive key search is known so far on the full Trivium. It can therefore be considered as a secure cipher. The family of attacks that seems to provide the best result on round-reduced versions is the cube attack and its variants <em>[x14, x1, x11]</em>. They recover some key bits (resp. provide a distinguisher on the keystream) if the number of initialization rounds is reduced to 799 (resp. 885) rounds out of 1152. The highest number of initialization rounds that can be attacked is 961: in this case, a distinguisher exists for a class of weak keys <em>[x19]</em>.</p>

    <p class="text-gray-300">Multiplicative depth. It is easy to see that the multiplicative depth grows quite slowly with the number of iterations. An important observation is that, in the internal state, only the first 80 bits in Register 1 (the keybits) are initially encrypted under the HE and that, as a consequence, performing hybrid clear and encrypted data calculations is possible (this is done by means of the following simple rules: <span class="math">0\\cdot[x]=0</span>, <span class="math">1\\cdot[x]=[x]</span>, <span class="math">0+[x]=[x]</span> and <span class="math">1+[x]=[1]+[x]</span>, where the square brackets denote encrypted bits and where in all but the latter case, a homomorphic operation is avoided which is specially desirable for multiplications). This optimization allows for instance to increase the number of bits which can be generated (after the 1152 blank rounds) at depth 12 from 42 to 57 (<em>i.e.</em>, a 35% increase). Then, the relevant quantity in our context is the multiplicative depth of the circuit which computes <span class="math">N</span> keystream bits from the 80-bit key. The proof of the following proposition is given in the App. C.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">In Trivium, the keystream length <span class="math">N(d)</span> which can be produced from the <span class="math">80</span>-bit key with a circuit of multiplicative depth <span class="math">d</span>, <span class="math">d\\geq 4</span>, is given by</p>

    <p class="text-gray-300">\\[ N(d)=282\\times\\left\\lfloor\\frac{d}{3}\\right\\rfloor+\\left\\{\\begin{array}[]{ll}81&if\\,d\\equiv 0\\bmod 3\\\\ 160&if\\,d\\equiv 1\\bmod 3\\\\ 269&if\\,d\\equiv 2\\bmod 3\\end{array}\\right.. \\]</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">3.2 Kreyvium</p>

    <p class="text-gray-300">Our first aim is to offer a variant of Trivium with 128-bit key and IV, without increasing the multiplicative depth of the corresponding circuit. Besides a higher security level, another advantage of this variant is that the number of possible IVs, and then the maximal length of data which can be encrypted under the same key, increases from <span class="math">2^{80}N_{\\text{trivium}}(d)</span> to <span class="math">2^{128}N_{\\text{kreyvium}}(d)</span>. Increasing the key and IV-size in Trivium is a challenging task, mentioned as an open problem in <em>[x10, p. 30]</em> for instance. In particular, Maximov and Biryukov <em>[x22]</em> pointed out that increasing the key-size in Trivium without any additional modification cannot be secure due to some attack with complexity less than <span class="math">2^{128}</span>. A first attempt in this direction has been made in <em>[x22]</em> but the resulting cipher accommodates 80-bit IV only, and its multiplicative complexity is higher than in Trivium since the number of AND gates is multiplied by 2.</p>

    <p class="text-gray-300">Description. Our proposal, Kreyvium, accommodates a key and an IV of 128 bits each. The only difference with the original Trivium is that we have added to the 288-bit internal state a 256-bit part corresponding to the secret key and the IV. This part of the state aims at making both the filtering and transition functions key- and IV-dependent. More precisely, these two functions <span class="math">f</span> and <span class="math">\\Phi</span> depend on the key bits and IV bits, through the successive outputs of two shift-registers <span class="math">K^{<em>}</span> and <span class="math">IV^{</em>}</span> initialized by the key and by the IV respectively. The internal state is then composed of five registers of sizes 93, 84, 111, 128 and 128 bits, having an internal state size of 544 bits in total, among which 416 become unknown to the attacker after initialization.</p>

    <p class="text-gray-300">We will use the same notation as the description of Trivium, and for the additional registers we use the usual shift-register notation: the leftmost bit is denoted by <span class="math">K^{<em>}_{127}</span> (or <span class="math">IV^{</em>}_{127}</span>), and the rightmost bit (i.e., the output) is denoted by <span class="math">K^{<em>}_{0}</span> (or <span class="math">IV^{</em>}_{0}</span>). Each one of these two registers are rotated independently from the rest of the cipher. The generator is described below, and depicted on Fig. 2.</p>

    <p class="text-gray-300"><span class="math">(s_{1},s_{2},\\ldots,s_{93})\\leftarrow(K_{0},\\ldots,K_{92})</span> <span class="math">(s_{94},s_{95},\\ldots,s_{177})\\leftarrow(IV_{0},\\ldots,IV_{83})</span> <span class="math">(s_{178},s_{179},\\ldots,s_{288})\\leftarrow(IV_{84},\\ldots,IV_{127},1,\\ldots,1,0)</span> <span class="math">(K^{<em>}_{127},K^{</em>}_{126},\\ldots,K^{<em>}_{0})\\leftarrow(K_{0},\\ldots,K_{127})</span> <span class="math">(IV^{</em>}_{127},IV^{<em>}_{126},\\ldots,IV^{</em>}_{0})\\leftarrow(IV_{0},\\ldots,IV_{127})</span> for <em><span class="math">i=1</span> to <span class="math">1152+N</span></em> do <span class="math">t_{1}\\leftarrow s_{66}+s_{93}</span> <span class="math">t_{2}\\leftarrow s_{162}+s_{177}</span> <span class="math">t_{3}\\leftarrow s_{243}+s_{288}+\\bm{K}^{<em>}_{0}</span> if </em><span class="math">i&gt;1152</span><em> do output <span class="math">z_{i-1152}\\leftarrow t_{1}+t_{2}+t_{3}</span> end if <span class="math">t_{1}\\leftarrow t_{1}+s_{91}\\cdot s_{92}+s_{171}+\\bm{IV}^{</em>}_{0}</span> <span class="math">t_{2}\\leftarrow t_{2}+s_{175}\\cdot s_{176}+s_{264}</span> <span class="math">t_{3}\\leftarrow t_{3}+s_{286}\\cdot s_{287}+s_{69}</span> <span class="math">t_{4}\\leftarrow K^{<em>}_{0}</span> <span class="math">t_{5}\\leftarrow IV^{</em>}_{0}</span> <span class="math">(s_{1},s_{2},\\ldots,s_{93})\\leftarrow(t_{3},s_{1},\\ldots,s_{92})</span> <span class="math">(s_{94},s_{95},\\ldots,s_{177})\\leftarrow(t_{1},s_{94},\\ldots,s_{176})</span> <span class="math">(s_{178},s_{179},\\ldots,s_{288})\\leftarrow(t_{2},s_{178},\\ldots,s_{287})</span> <span class="math">(K^{<em>}_{127},K^{</em>}_{126},\\ldots,K^{<em>}_{0})\\leftarrow(t_{4},K^{</em>}_{127},\\ldots,K^{<em>}_{1})</span> <span class="math">(IV^{</em>}_{127},IV^{<em>}_{126},\\ldots,IV^{</em>}_{0})\\leftarrow(t_{5},IV^{<em>}_{127},\\ldots,IV^{</em>}_{1})</span> end for</p>

    <p class="text-gray-300">Related ciphers. KATAN <em>[x12]</em> is a lightweight block cipher with a lot in common with Trivium. It is composed of two registers, whose feedback functions are very sparse, and have a single nonlinear term. The key, instead of being used for initializing the state, is introduced by XORing two key information-bits per round to each feedback bit. The recently proposed stream cipher Sprout <em>[x3]</em>, inspired by Grain but with much smaller registers, also inserts the key in a similar way: instead of using the key for initializing the state, one key information-bit is XORed at each clock to the feedback function. We can see the parallelism between these two ciphers and our newly proposed variant. In particular, the previous security analysis on KATAN shows that this type of design does not introduce any clear</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. Kreyvium. The three registers in the middle correspond to the original Trivium. The modifications defining Kreyvium correspond to the two registers in blue.</p>

    <p class="text-gray-300">weakness. Indeed, the best attacks on round-reduced versions of KATAN so far [FM14] are meet-in-the-middle attacks, that exploit the knowledge of the values of the first and the last internal states (due to the block-cipher setting). As this is not the case here, such attacks, as well as the recent interpolation attacks against LowMC [DLMW15], do not apply. The best attacks against KATAN, when excluding MitM techniques, are conditional differential attacks [KMN10,KMN11].</p>

    <p class="text-gray-300">Design rationale. In Kreyvium, we have decided to XOR the keybit  <span class="math">K_0^<em></span>  to the feedback function of the register that interacts with the content of  <span class="math">(s_1, \\ldots, s_{63})</span>  the later, since  <span class="math">(s_1, \\ldots, s_{63})</span>  is initialized with some key bits. The same goes for the  <span class="math">IV^</em></span>  register. Moreover, as the keybits that start entering the state are the ones that were not in the initial state, all the keybits affect the state at the earliest.</p>

    <p class="text-gray-300">We also decided to initialize the state with some keybits and with all the IV bits, and not with a constant value, as this way the mixing will be performed quicker. Then we can expect that the internal-state bits after initialization are expressed as more complex and less sparse functions in the key and IV bits.</p>

    <p class="text-gray-300">Our change of constant is motivated by the conditional differential attacks from [KMN11]: the conditions needed for a successful attack are that 106 bits from the IV or the key are equal to '0' and a single one needs to be '1'. This suggests that values set to zero "encourage" non-random behaviors, leading to our new constant. In other words, in Trivium, an all-zero internal state is always updated in an all-zero state, while an all-one state will change through time. The 0 at the end of the constant is added for preventing slide attacks.</p>

    <p class="text-gray-300">Multiplicative depth. Exactly as for Trivium, we can compute the number of keystream bits which can be generated from the key at a given depth. The only difference with Trivium is that the first register now contains 93 key bits instead of 80. For this reason, the optimization using hybrid plaintext/ciphertext calculations is a bit less interesting: for any fixed depth  <span class="math">d \\geq 4</span> , we can generate 11 bits less than with Trivium.</p>

    <p class="text-gray-300">Proposition 2. In Kreyvium, the keystream length  <span class="math">N(d)</span>  which can be produced from the 128-bit key with a circuit of multiplicative depth  <span class="math">d</span> ,  <span class="math">d \\geq 4</span> , is given by</p>

    <div class="my-4 text-center"><span class="math-block">N (d) = 2 8 2 \\times \\left\\lfloor \\frac {d}{3} \\right\\rfloor + \\left\\{ \\begin{array}{l l} 7 0 &amp;amp; i f d \\equiv 0 \\bmod 3 \\\\ 1 4 9 &amp;amp; i f d \\equiv 1 \\bmod 3 \\\\ 2 5 8 &amp;amp; i f d \\equiv 2 \\bmod 3 \\end{array} \\right..</span></div>

    <p class="text-gray-300">Security analysis. We investigate in more detail how all the known attacks on Trivium, and some other techniques, can apply to Kreyvium.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">TMDTO</h4>

    <p class="text-gray-300">TMDTO attacks aiming at recovering the initial state of the cipher do not apply since the size of the secret part of the internal state (416 bits) is much larger than twice the key-size. As discussed at the beginning of Section 3, the size of the whole secret internal state has to be taken into account, even if the additional 128-bit part corresponding to <span class="math">K^{<em>}</span> is independent from the rest of the state. On the other hand, TMDTO aiming at recovering the key have complexity larger than exhaustive key search (even without any restriction on the precomputation time) since the key and the IV have the same size </em>[x10, x11]*.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Internal-state collision</h4>

    <p class="text-gray-300">As discussed in Section 3, a distinguisher may be built if the attacker is able to find two colliding internal states, since the two keystream sequences produced from colliding states are identical. Finding such a collision requires around <span class="math">2^{144}</span> keystream bits generated from the same key/IV pair, which is much longer than the maximal keystream length allowed by the multiplicative depth of the circuit. But, for a given key, two internal states colliding on all bits except on <span class="math">IV^{<em>}</span> lead to two keystreams which have the same first 69 bits since <span class="math">IV^{</em>}</span> affects the keystream only 69 clocks later. Moreover, if the difference between the two values of <span class="math">IV^{*}</span> when the rest of the state collides lies in the leftmost bit, then this difference will affect the keystream bits <span class="math">(69+128)=197</span> clocks later. This implies that, within around <span class="math">2^{144}</span> keystream bits generated from the same key, we can find two identical runs of 197 consecutive bits which are equal. However, this property does not provide a valid distinguisher because a random sequence of length <span class="math">2^{144}</span> blocks is expected to contain much more collisions on 197-bit runs. Therefore, the birthday-bound of <span class="math">2^{144}</span> bits provides a limit on the number of bits produced from the same key/IV pair, not on the bits produced from the same IV.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Cube attacks <em>[x12]</em> and cube testers <em>[x2]</em></h4>

    <p class="text-gray-300">As previously pointed out, they provide the best attacks for round-reduced Trivium. In our case, as we keep the same main function, but we have two additional XORs per round, thus a better mixing of the variables, we can expect the relations to get more involved and hamper the application of previously defined round-reduced distinguishers. One might wonder if the fact that more variables are involved could ease the attacker’s task, but we point out here that the limitation in the previous attacks was not the IV size, but the size of the cubes themselves. Therefore, having more variables available is of no help with respect to this point. We can conclude that the resistance of Kreyvium to these types of attacks is at least the resistance of Trivium, and even better.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Conditional differential cryptanalysis</h4>

    <p class="text-gray-300">Because of its applicability to both Trivium and KATAN, the attack from <em>[x14]</em> is definitely of interest in our case. In particular, the highest number of blank rounds is reached if some conditions on two registers are satisfied at the same time (and not only conditions on the register controlled by the IV bits in the original Trivium). In our case, as we have IV bits in two registers, it is important to elucidate whether an attacker can take advantage of introducing differences in two registers simultaneously. First, let us recall that we have changed the constant to one containing mostly 1. We previously saw that the conditions that favor the attacks are values set to zero in the initial state. In Trivium, per design, we have <span class="math">(108+4+13)=125</span> bits already fixed to zero in the initial state, 3 are fixed to one and the others can be controlled by the attacker in the weak-key setting (and the attacker will force them to be zero most of the time). Now, instead, we have 64 bits forced to be 1, 1 equal to zero, and <span class="math">(128+93)=221</span> bits of the initial state controlled by the attacker in the weak-key setting, plus potentially 21 additional bits from the key still not used, that will be inserted during the first rounds. We can conclude that, while in Trivium is possible in the weak-key setting, to introduce zeros in the whole initial state but in 3 bits, in Kreyvium, we will never be able to set to zero 64 bits, implying that applying the techniques from <em>[x14]</em> becomes much harder. Additionally, as in the discussion on cube attacks, we can also hope here that we get more involved relations that will provide a better resistance against these attacks.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Algebraic attacks</h4>

    <p class="text-gray-300">Several algebraic attacks have been proposed against Trivium, aiming at recovering the 288-bit internal state at the beginning of the keystream generation (i.e., at time <span class="math">t=1153</span>) from the knowledge of the keystream bits. The most efficient attack of this type is due to Maximov and Biryukov <em>[x15]</em>. It exploits the fact that the 22 keystream bits at time <span class="math">3t^{\\prime}</span>, <span class="math">0\\leq t^{\\prime}&lt;22</span>, are determined</p>

    <p class="text-gray-300">by all bits of the initial state at indexes divisible by 3 (starting from the leftmost bit in each register). Moreover, once all bits at positions <span class="math">3i</span> are known, then guessing that the outputs of the three AND gates at time <span class="math">3t^{\\prime}</span> are zero provides 3 linear relations between the bits of the internal state and the keystream bits. The attack then consists of an exhaustive search for some bits at indexes divisible by 3. The other bits in such positions are then deduced by solving the linear system derived from the keystream bits at positions <span class="math">3t^{\\prime}</span>. Once all these bits have been determined, the other 192 bits of the initial state are deduced from the other keystream equations. This process must be iterated until the guess for the outputs of the AND gates is correct. In the case of Trivium, the outputs of at least 125 AND gates must be guessed in order to get 192 linear relations involving the 192 bits at indexes <span class="math">3i+1</span> and <span class="math">3i+2</span>. This implies that the attack has to be repeated <span class="math">(4/3)^{125}=2^{52}</span> times. From these guesses, we get many linear relations involving the bits at positions <span class="math">3i</span> only, implying that only an exhaustive search with complexity <span class="math">2^{32}</span> for the other bits at positions <span class="math">3i</span> is needed. Therefore, the overall complexity of the attack is around <span class="math">2^{32}\\times 2^{52}=2^{84}</span>. A similar algorithm can be applied to Kreyvium, but the main difference is that every linear equation corresponding to a keystream bit also involves one key bit. Moreover, the key bits involved in the generation of any 128 consecutive output bits are independent. It follows that each of the first 128 linear equations introduces a new unknown in the system to solve. For this reason, it is not possible to determine all bits at positions <span class="math">3i</span> by an exhaustive search on less than 96 bits like for Trivium. Moreover, the outputs of more than 135 AND gates must be guessed for obtaining enough equations on the remaining bits of the initial state. Therefore the overall complexity of the attack exceeds <span class="math">2^{96}\\times 2^{52}=2^{148}</span> and is much higher that the cost of the exhaustive key search. It is worth noticing that the attack would have been more efficient if only the feedback bits, and not the keystream bits, would have been dependent on the key. In this case, 22 linear relations independent from the key would have been available to the attacker.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4 Experimental Results</h2>

    <p class="text-gray-300">In this section, we discuss and compare the practicality of our generic construction when instantiated with Trivium, Kreyvium and the HE-dedicated cipher LowMC. The expansion function <span class="math">G</span> implements a mere counter, and the aforementioned algorithms are used to instantiate the function <span class="math">F</span> that produces <span class="math">N</span> bits of keystream per iteration—<em>cf.</em> Prop. 1 and 2.</p>

    <p class="text-gray-300">HE framework. In our experiments, we considered two HE schemes: the BGV scheme <em>[x1]</em> and the FV scheme <em>[x12]</em> (a scale-invariant version of BGV). The BGV scheme is implemented in the library HElib <em>[x15]</em> and has become <em>de facto</em> a standard benchmarking library for HE applications. Similarly, the FV scheme was previously used in several HE benchmarkings <em>[FSF^{+}13, x14, x10]</em>, is conceptually simpler than the BGV scheme, and is one of the most efficient HE schemes. Additionally, batching was used <em>[x21]</em>, <em>i.e.</em> the HE schemes were set up to encrypt vectors in an SIMD fashion (component-wise operations, and rotations via the Frobenius endomorphism). The number of elements that can be encrypted depends on the number of terms in the factorization modulo 2 of the cyclotomic polynomial used in the implementation. This batching allowed us to perform several Trivium/Kreyvium/LowMC in parallel in order to increase the throughput.</p>

    <p class="text-gray-300">Parameter selection for subsequent homomorphic processing. In all the previous works on the homomorphic evaluation of symmetric encryption schemes, the parameters of the underlying HE scheme were selected for the exact multiplicative depth required and not beyond <em>[x13, x14, x15, x1,ARS^{+}15]</em>. This means that once the ciphertext is decompressed, no further homomorphic computation can actually be performed by Charlie – this makes the claimed timings considerably less meaningful in a real-world context.</p>

    <p class="text-gray-300">In this work, we benchmarked both parameters for the exact multiplicative depth and parameters able to handle circuits of the minimal multiplicative depth plus 7 to allow further homomorphic processing</p>

    <p class="text-gray-300">Table 1. Latency and throughput for the algorithms using HElib on a single core of a mid-end 48-core server (4 x AMD Opteron 6172 processors with 64GB of RAM).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security level κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">used × depth</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#slots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">latency sec.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">throughput</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |   |   |   |   |  bits/min  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Trivium-12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">45</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">600</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1417.4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1143.0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">3650.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1341.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">11379.7</td>

            <td class="px-3 py-2 border-b border-gray-700">516.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">504</td>

            <td class="px-3 py-2 border-b border-gray-700">1715.0</td>

            <td class="px-3 py-2 border-b border-gray-700">740.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">756</td>

            <td class="px-3 py-2 border-b border-gray-700">4956.0</td>

            <td class="px-3 py-2 border-b border-gray-700">384.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">682</td>

            <td class="px-3 py-2 border-b border-gray-700">3987.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1272.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">12450.8</td>

            <td class="px-3 py-2 border-b border-gray-700">286.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMC-128</td>

            <td class="px-3 py-2 border-b border-gray-700">? ≤ 118</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">682</td>

            <td class="px-3 py-2 border-b border-gray-700">3608.4</td>

            <td class="px-3 py-2 border-b border-gray-700">2903.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">10619.6</td>

            <td class="px-3 py-2 border-b border-gray-700">694.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMC-128 [ARS+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">? ≤ 118</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">682</td>

            <td class="px-3 py-2 border-b border-gray-700">3368.8</td>

            <td class="px-3 py-2 border-b border-gray-700">3109.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">9977.1</td>

            <td class="px-3 py-2 border-b border-gray-700">739.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">by Charlie (which is obviously what is expected in applications of homomorphic encryption). We chose 7 because, in practice, numerous applications use algorithms of multiplicative depth smaller than 7 (see e.g. [GLN12,LLN14]). In what follows we compare the results we obtain using Trivium, Kreyvium and also the LowMC cipher. For LowMC, we benchmarked not only our own implementation but also the LowMC implementation of  <span class="math">\\mathrm{[ARS^{+}15]}</span>  available at https://bitbucket.org/malb/lowmc-helib. Minor changes to this implementation were made in order to obtain an equivalent parametrization of HElib. The main difference between the latter implementations is that the implementation from  <span class="math">\\mathrm{[ARS^{+}15]}</span>  uses an optimized method for multiplying a Boolean vector and a Boolean matrix, namely the "Method of Four Russians". This explains why our implementation is approximately  <span class="math">6\\%</span>  slower, as it performs 2-3 times more ciphertext additions.</p>

    <p class="text-gray-300">Experimental results using HElib. For sake of comparison with  <span class="math">\\left[\\mathrm{ARS}^{+}15\\right]</span> , we ran our implementations and their implementation of LowMC on a single core using HElib. The results are provided in Tab. 1. We recall that the latency refers to the time required to perform the entire homomorphic evaluation whereas the throughput is the number of blocks processed per time unit.</p>

    <p class="text-gray-300">Experimental results using FV. On Tab. 2, we present the benchmarks when using the FV scheme. The experiments were performed using either a single core (in order to compare with BGV) or on all the cores of the machine the tests were performed on. The execution time acceleration factor between 48-core parallel and sequential executions is given in the column "Speed gain". While good accelerations (at least 25 times) were obtained for Trivium and Kreyvium algorithms, the acceleration when using LowMC is significantly smaller ( <span class="math">\\sim</span>  10 times). This is due to the huge number of operations in LowMC that created memory contention and huge slowdown in memory allocation.</p>

    <p class="text-gray-300">Interpretation. First, we would like to recall that LowMC-128 must be considered in a different category because of the existence of a key-recovery attack with time complexity  <span class="math">2^{118}</span>  and data complexity  <span class="math">2^{73}</span>  [DLMW15]. However, it has been included in the table in order to show that the performances achieved by Trivium and Kreyvium are of the same order of magnitude. An increase in the number of rounds of LowMC-128 (typically by 4 rounds) is needed in order to achieve 128-bit security, but this would have a non-negligible impact on its homomorphic evaluation performance, as it would require to increase the depth of the cryptosystem supporting the execution. For instance, a back-of-the-envelope estimation for four additional rounds leads to a degradation of its homomorphic execution performances by a factor of about 2 to 3 (more computations with larger parameters), making the approach in this paper much more competitive.</p>

    <p class="text-gray-300">Table 2. Latency of our construction when using the FV scheme on a mid-end 48-core server (4 x AMD Opteron 6172 processors with 64GB of RAM).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security level κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">used × depth</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">latency (sec.)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Speed gain</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1 core</td>

            <td class="px-3 py-2 border-b border-gray-700">48 cores</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">681.5</td>

            <td class="px-3 py-2 border-b border-gray-700">26.8</td>

            <td class="px-3 py-2 border-b border-gray-700">× 25.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">2097.1</td>

            <td class="px-3 py-2 border-b border-gray-700">67.6</td>

            <td class="px-3 py-2 border-b border-gray-700">× 31.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">888.2</td>

            <td class="px-3 py-2 border-b border-gray-700">33.9</td>

            <td class="px-3 py-2 border-b border-gray-700">× 26.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">2395.0</td>

            <td class="px-3 py-2 border-b border-gray-700">77.2</td>

            <td class="px-3 py-2 border-b border-gray-700">× 31.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">904.4</td>

            <td class="px-3 py-2 border-b border-gray-700">35.3</td>

            <td class="px-3 py-2 border-b border-gray-700">× 25.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">2806.3</td>

            <td class="px-3 py-2 border-b border-gray-700">82.4</td>

            <td class="px-3 py-2 border-b border-gray-700">× 34.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">1318.6</td>

            <td class="px-3 py-2 border-b border-gray-700">49.7</td>

            <td class="px-3 py-2 border-b border-gray-700">× 26.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">3331.4</td>

            <td class="px-3 py-2 border-b border-gray-700">97.9</td>

            <td class="px-3 py-2 border-b border-gray-700">× 34.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMC-128</td>

            <td class="px-3 py-2 border-b border-gray-700">? ≤ 118</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">1531.1</td>

            <td class="px-3 py-2 border-b border-gray-700">171.0</td>

            <td class="px-3 py-2 border-b border-gray-700">× 9.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">3347.8</td>

            <td class="px-3 py-2 border-b border-gray-700">329.0</td>

            <td class="px-3 py-2 border-b border-gray-700">× 10.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is worth noticing that the minimal multiplicative depth for which valid LowMC output ciphertexts were obtained was 14 for the FV scheme and 13 for the BGV scheme (the theoretical multiplicative depth is 12 but the high number of additions in LowMC explains this difference <span class="math">^{11}</span> ).</p>

    <p class="text-gray-300">Our results show that Trivium and Kreyvium have a smaller latency than LowMC, but have a slightly smaller throughput. As already emphasized in [LN14], real-world applications of homomorphic encryption (which are often cloud-based applications) should be implemented in a transparent and user-friendly way. In the context of our approach, the latency of the offline phase is still an important parameter aiming at an acceptable experience for the end-user even when a sufficient amount of homomorphic keystream could not be precomputed early enough because of overall system dimensioning issues.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Also Trivium and Kreyvium are more parallelizable than LowMC is. Therefore, our work shows that the promising performances obtained by the recently proposed HE-dedicated cipher LowMC can also be achieved with Trivium, a well-analyzed stream cipher, and a variant aiming at achieving 128 bits of security. Last but not least, we recall that our construction was aiming at compressing the size of transmissions between Alice and Charlie. We support an encryption rate  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  that becomes asymptotically close to 1 for long messages, e.g. for  </span>\\ell_{m} = 1\\mathrm{GB}$  message length, our construction instantiated with Trivium (resp. Kreyvium), yields an expansion rate of 1.08 (resp. 1.16).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our work shows that the promising performances obtained by the recently proposed HE-dedicated cipher LowMC can also be achieved with Trivium, a well-known primitive whose security has been thoroughly analyzed, e.g. [MB07,DS09], and [ADMS09,FV13,KMN11]. The 10-year analysis effort from the whole community, initiated by the eSTREAM competition, enables us to gain confidence in its security. Also our variant Kreyvium, with a 128-bit security, benefits from the same analysis since the core of the cipher is essentially the same.</p>

    <p class="text-gray-300">From a more fundamental perspective, one may wonder how many multiplicative levels are strictly necessary to achieve a secure compressed encryption scheme, irrespective of any performance metric such as the number of homomorphic bit multiplications to perform in the decompression circuit. We already know that a multiplicative depth of  <span class="math">\\lceil \\log \\kappa \\rceil + 1</span>  is achievable for  <span class="math">\\kappa</span> -bit security (cf. App. D). Can one do better or prove that this is a lower bound?</p>

    <p class="text-gray-300">However, the provable security of a KEM-DEM construct where the KEM is homomorphic remains an open question. In particular, assuming the KEM part is just IND-CPA, what would be the minimum security requirements expected from the DEM part to yield an IND-CPA construction?</p>

    <h2 id="sec-14" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ADMS09] Jean-Philippe Aumasson, Itai Dinur, Willi Meier, and Adi Shamir. Cube Testers and Key Recovery Attacks on Reduced-Round MD6 and Trivium. In FSE, volume 5665 of LNCS, pages 1–22. Springer, 2009.</li>

      <li>[AGKS05] Masayuki Abe, Rosario Gennaro, Kaoru Kurosawa, and Victor Shoup. Tag-KEM/DEM: A New Framework for Hybrid Encryption and A New Analysis of Kurosawa-Desmedt KEM. In EUROCRYPT, volume 3494 of LNCS, pages 128–146. Springer, 2005.</li>

      <li>[AM15] Frederik Armknecht and Vasily Mikhalev. On Lightweight Stream Ciphers with Shorter Internal States. In FSE, volume 9054 of LNCS, pages 451–470. Springer, 2015.</li>

      <li>[AMOR14] Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodríguez-Henríquez. Computing Discrete Logarithms in <span class="math">\\mathbb{F}.3^{6*137}</span> using Magma. IACR Cryptology ePrint Archive, 2014:57, 2014.</li>

      <li>[ARS^{+}15] Martin Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In EUROCRYPT, volume 9056 of LNCS, pages 430–454. Springer, 2015.</li>

      <li>[Bab95] Steve Babbage. A space/time trade-off in exhaustive search attacks on stream ciphers. In European Convention on Security and Detection, number 408. IEEE Conference Publication, 1995.</li>

      <li>[BCG^{+}12] Julia Borghoff, Anne Canteaut, Tim Güneysu, Elif Bilge Kavun, Miroslav Knezevic, Lars R. Knudsen, Gregor Leander, Ventzislav Nikov, Christof Paar, Christian Rechberger, Peter Rombouts, Søren S. Thomsen, and Tolga Yalçin. PRINCE - A Low-Latency Block Cipher for Pervasive Computing Applications. In ASIACRYPT, volume 7658 of LNCS, pages 208–225. Springer, 2012.</li>

      <li>[BDJR97] Mihir Bellare, Anand Desai, E. Jokipii, and Phillip Rogaway. A Concrete Security Treatment of Symmetric Encryption. In FOCS, pages 394–403. IEEE Computer Society, 1997.</li>

      <li>[BG07] Côme Berbain and Henri Gilbert. On the Security of IV Dependent Stream Ciphers. In FSE, volume 4593 of LNCS, pages 254–273. Springer, 2007.</li>

      <li>[BGJT14] Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé. A Heuristic Quasi-Polynomial Algorithm for Discrete Logarithm in Finite Fields of Small Characteristic. In EUROCRYPT, volume 8441 of LNCS, pages 1–16. Springer, 2014.</li>

      <li>[BGV14] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (Leveled) Fully Homomorphic Encryption without Bootstrapping. TOCT, 6(3):13, 2014.</li>

      <li>[Bod07] Marco Bodrato. Towards Optimal Toom-Cook Multiplication for Univariate and Multivariate Polynomials in Characteristic 2 and 0. In WAIFI, volume 4547 of LNCS, pages 116–133. Springer, 2007.</li>

      <li>[BS00] Alex Biryukov and Adi Shamir. Cryptanalytic Time/Memory/Data Tradeoffs for Stream Ciphers. In ASIACRYPT, volume 1976 of LNCS, pages 1–13. Springer, 2000.</li>

      <li>[CCHN15] Avik Chakraborti, Anupam Chattopadhyay, Muhammad Hassan, and Mridul Nandi. TriviA: A fast and secure authenticated encryption scheme. In CHES, volume 9293 of Lecture Notes in Computer Science, pages 330–353. Springer, 2015.</li>

      <li>[CCK^{+}13] Jung Hee Cheon, Jean-Sébastien Coron, Jinsu Kim, Moon Sung Lee, Tancrède Lepoint, Mehdi Tibouchi, and Aaram Yun. Batch Fully Homomorphic Encryption over the Integers. In EUROCRYPT, volume 7881 of LNCS, pages 315–335. Springer, 2013.</li>

      <li>[CDK09] Christophe De Cannière, Orr Dunkelman, and Miroslav Knezevic. KATAN and KTANTAN - A Family of Small and Efficient Hardware-Oriented Block Ciphers. In CHES, volume 5747 of LNCS, pages 272–288. Springer, 2009.</li>

      <li>[CDS15] Sergiu Carpov, Paul Dubrulle, and Renaud Sirdey. Armadillo: a compilation chain for privacy preserving applications. In ACM CCSW, 2015.</li>

      <li>[CLP05] Christophe De Cannière, Joseph Lano, and Bart Preneel. Comments on the rediscovery of time memory data tradeoffs. Technical report, eSTREAM - ECRYPT Stream Cipher Project, 2005.</li>

      <li>[CLT14] Jean-Sébastien Coron, Tancrède Lepoint, and Mehdi Tibouchi. Scale-Invariant Fully Homomorphic Encryption over the Integers. In PKC, volume 8383 of LNCS, pages 311–328. Springer, 2014.</li>

      <li>[CM03] Nicolas Courtois and Willi Meier. Algebraic attacks on stream ciphers with linear feedback. In EUROCRYPT, volume 2656 of LNCS, pages 345–359. Springer, 2003.</li>

      <li>[CP02] Nicolas Courtois and Josef Pieprzyk. Cryptanalysis of block ciphers with overdefined systems of equations. In ASIACRYPT, volume 2501 of LNCS, pages 267–287. Springer, 2002.</li>

      <li>[CP08] Christophe De Cannière and Bart Preneel. Trivium. In New Stream Cipher Designs - The eSTREAM Finalists, volume 4986 of LNCS, pages 244–266. Springer, 2008.</li>

      <li>[CT15] Massimo Chenal and Qiang Tang. On Key Recovery Attacks Against Existing Somewhat Homomorphic Encryption Schemes. In LATINCRYPT, volume 8895 of LNCS, pages 239–258. Springer, 2015.</li>

    </ul>

    <p class="text-gray-300">DHS14. Yarkin Doröz, Yin Hu, and Berk Sunar. Homomorphic AES Evaluation using NTRU. IACR Cryptology ePrint Archive, 2014:39, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DLMW15. Itai Dinur, Yunwen Liu, Willi Meier, and Qingju Wang. Optimized Interpolation Attacks on LowMC. IACR Cryptology ePrint Archive, 2015:418, 2015.</li>

      <li>DS09. Itai Dinur and Adi Shamir. Cube Attacks on Tweakable Black Box Polynomials. In EUROCRYPT, volume 5479 of LNCS, pages 278–299. Springer, 2009.</li>

      <li>DSES14. Yarkin Doröz, Aria Shahverdi, Thomas Eisenbarth, and Berk Sunar. Toward Practical Homomorphic Evaluation of Block Ciphers Using Prince. In WAHC, volume 8438 of LNCS, pages 208–220. Springer, 2014.</li>

      <li>ECR05. ECRYPT - European Network of Excellence in Cryptology. The eSTREAM Stream Cipher Project. http://www.ecrypt.eu.org/stream/, 2005.</li>

      <li>Eni14. Algorithms, key size and parameters report 2014. Technical report, ENISA - European Union Agency for Network and Information Security, 2014.</li>

      <li>FM14. Thomas Fuhr and Brice Minaud. Match Box Meet-in-the-Middle Attack against KATAN. In FSE, volume 8540 of LNCS, pages 61–81. Springer, 2014.</li>

      <li>FSF^{+}13. Simon Fau, Renaud Sirdey, Caroline Fontaine, Carlos Aguilar, and Guy Gogniat. Towards practical program execution over fully homomorphic encryption schemes. In IEEE International Conference on P2P, Parallel, Grid, Cloud and Internet Computing, pages 284–290, 2013.</li>

      <li>FV12. Junfeng Fan and Frederik Vercauteren. Somewhat Practical Fully Homomorphic Encryption. IACR Cryptology ePrint Archive, 2012:144, 2012.</li>

      <li>FV13. Pierre-Alain Fouque and Thomas Vannet. Improving Key Recovery to 784 and 799 Rounds of Trivium Using Optimized Cube Attacks. In FSE, volume 8424 of LNCS, pages 502–517. Springer, 2013.</li>

      <li>Gen09. Craig Gentry. Fully homomorphic encryption using ideal lattices. In STOC, pages 169–178. ACM, 2009.</li>

      <li>GHS12. Craig Gentry, Shai Halevi, and Nigel P. Smart. Homomorphic Evaluation of the AES Circuit. In CRYPTO, volume 7417 of LNCS, pages 850–867. Springer, 2012.</li>

      <li>GKZ14. Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel. Breaking ’128-bit Secure’ Supersingular Binary Curves - (Or How to Solve Discrete Logarithms in <span class="math">\\mathbb{F}.2^{4\\cdot 1223}</span> and <span class="math">\\mathbb{F}.2^{12\\cdot 367}</span>). In CRYPTO, Part II, volume 8617 of LNCS, pages 126–145. Springer, 2014.</li>

      <li>GLN12. Thore Graepel, Kristin E. Lauter, and Michael Naehrig. ML Confidential: Machine Learning on Encrypted Data. In ICISC, volume 7839 of LNCS, pages 1–21. Springer, 2012.</li>

      <li>GLSV14. Vincent Grosso, Gaëtan Leurent, François-Xavier Standaert, and Kerem Varici. LS-Designs: Bitslice Encryption for Efficient Masked Software Implementations. In FSE, volume 8540 of LNCS, pages 18–37. Springer, 2014.</li>

      <li>Gol97. Jovan Dj. Golic. Cryptanalysis of alleged A5 stream cipher. In EUROCRYPT’97, volume 1233 of LNCS, pages 239–255. Springer-Verlag, 1997.</li>

      <li>HK07. Dennis Hofheinz and Eike Kiltz. Secure Hybrid Encryption from Weakened Key Encapsulation. In CRYPTO, volume 4622 of LNCS, pages 553–571. Springer, 2007.</li>

      <li>HS05. Jin Hong and Palash Sarkar. New Applications of Time Memory Data Tradeoffs. In ASIACRYPT, volume 3788 of LNCS, pages 353–372. Springer, 2005.</li>

      <li>HS14. Shai Halevi and Victor Shoup. Algorithms in HElib. In CRYPTO, Part I, volume 8616 of Lecture Notes in Computer Science, pages 554–571, 2014.</li>

      <li>Iwa06. Tetsu Iwata. New Blockcipher Modes of Operation with Beyond the Birthday Bound Security. In FSE, volume 4047 of LNCS, pages 310–327. Springer, 2006.</li>

      <li>JK97. Thomas Jakobsen and Lars R. Knudsen. The interpolation attack on block ciphers. In FSE, volume 1267 of LNCS, pages 28–40. Springer, 1997.</li>

      <li>JP14. Antoine Joux and Cécile Pierrot. Improving the Polynomial time Precomputation of Frobenius Representation Discrete Logarithm Algorithms - Simplified Setting for Small Characteristic Finite Fields. In ASIACRYPT, Part I, volume 8873 of LNCS, pages 378–397. Springer, 2014.</li>

      <li>KL14. Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography, Second Edition. Chapman and Hall/CRC Press, 2014.</li>

      <li>KMN10. Simon Knellwolf, Willi Meier, and María Naya-Plasencia. Conditional Differential Cryptanalysis of NLFSR-Based Cryptosystems. In ASIACRYPT, volume 6477 of LNCS, pages 130–145. Springer, 2010.</li>

      <li>KMN11. Simon Knellwolf, Willi Meier, and María Naya-Plasencia. Conditional Differential Cryptanalysis of Trivium and KATAN. In SAC, volume 7118 of LNCS, pages 200–212. Springer, 2011.</li>

      <li>LLN14. Kristin Lauter, Adriana López-Alt, and Michael Naehrig. Private Computation on Encrypted Genomic Data. In LATINCRYPT, LNCS, 2014.</li>

      <li>LN14. Tancrède Lepoint and Michael Naehrig. A Comparison of the Homomorphic Encryption Schemes FV and YASHE. In AFRICACRYPT, volume 8469 of LNCS, pages 318–335. Springer, 2014.</li>

      <li>LP13. Tancrède Lepoint and Pascal Paillier. On the Minimal Number of Bootstrappings in Homomorphic Circuits. In WAHC, volume 7862 of LNCS, pages 189–200. Springer, 2013.</li>

    </ul>

    <p class="text-gray-300">LST12. Will Landecker, Thomas Shrimpton, and R. Seth Terashima. Tweakable Blockciphers with Beyond Birthday-Bound Security. In CRYPTO, volume 7417 of LNCS, pages 14-30. Springer, 2012. MB07. Alexander Maximov and Alex Biryukov. Two Trivial Attacks on Trivium. In SAC, volume 4876, pages 36-55. Springer, 2007. Nat01. National Institute of Standards and Technology. NIST Special Publication 800-38A — Recommendation for Block Cipher Modes of Operation. NIST Special Publication 800-38A, 2001. NLV11. Michael Naehrig, Kristin E. Lauter, and Vinod Vaikuntanathan. Can homomorphic encryption be practical? In ACM CCSW, pages 113-124. ACM, 2011. Pin89. Antonio Pincin. A new algorithm for multiplication in finite fields. IEEE Transactions on Computers, 38(7):1045-1049, 1989. Rog11. Phillip Rogaway. Evaluation of some blockcipher modes of operation. Cryptrec, 2011. SV14. Nigel P. Smart and Frederik Vercauteren. Fully homomorphic SIMD operations. Des. Codes Cryptography, 71(1):57-81, 2014. Yas11. Kan Yasuda. A New Variant of PMAC: Beyond the Birthday Bound. In CRYPTO, volume 6841 of LNCS, pages 596-609. Springer, 2011.</p>

    <p class="text-gray-300">A more thorough analysis of the number of AND and XOR gates in the different circuits is provided in Table 3. The keystream length is the maximum possible for a given multiplicative depth. It is lower for the BGV scheme (batched) because the IV is no more a boolean string so less circuit optimization are possible. For the FV scheme (non-batched) the table gives the number of executed gates in the worst case. The actual number of executed gates can be lower as it depends on the employed IV.</p>

    <p class="text-gray-300">Table 3. Number of AND and XOR gates to homomorphically evaluate in Trivium and Kreyvium for FV and BGV schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BGV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">#ANDs</td>

            <td class="px-3 py-2 border-b border-gray-700">#XORs</td>

            <td class="px-3 py-2 border-b border-gray-700">keystream</td>

            <td class="px-3 py-2 border-b border-gray-700">#ANDs</td>

            <td class="px-3 py-2 border-b border-gray-700">#XORs</td>

            <td class="px-3 py-2 border-b border-gray-700">keystream</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">3237</td>

            <td class="px-3 py-2 border-b border-gray-700">15019</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">3183</td>

            <td class="px-3 py-2 border-b border-gray-700">14728</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">3474</td>

            <td class="px-3 py-2 border-b border-gray-700">16537</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

            <td class="px-3 py-2 border-b border-gray-700">3474</td>

            <td class="px-3 py-2 border-b border-gray-700">16537</td>

            <td class="px-3 py-2 border-b border-gray-700">136</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3311</td>

            <td class="px-3 py-2 border-b border-gray-700">18081</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">3288</td>

            <td class="px-3 py-2 border-b border-gray-700">17934</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3564</td>

            <td class="px-3 py-2 border-b border-gray-700">19878</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">3561</td>

            <td class="px-3 py-2 border-b border-gray-700">19866</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to limit the multiplicative depth of the decryption circuit, we may prefer to transmit a longer secret  <span class="math">\\tilde{k}</span> , from which more calculations can be done at a small multiplicative depth. Typically, for a block cipher, the sequence formed by all round-keys can be transmitted to the server. In this case, the key scheduling does not have to be taken into account in the homomorphic evaluation of the decryption function. Similarly, stream ciphers offer several such trade-offs between the encryption rate and the encryption throughput. The encryption rate, i.e., the ratio between the size of  <span class="math">c&#x27; = (\\mathsf{HE}_{\\mathsf{pk}}(k),\\mathsf{E}_k(m))</span>  and the plaintext size  <span class="math">\\ell_{m}</span> , is defined as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho = \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c ^ {\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\ell_ {m}} = \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E _ {k} (m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\ell_ {m}} + \\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde {k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times (\\mathrm {H E e x p a n s i o n r a t e})}{\\ell_ {m}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The extremal situation obviously corresponds to the case where the message encrypted under the homomorphic scheme is sent directly, i.e.,  <span class="math">c&#x27; = \\mathsf{HE}_{\\mathsf{pk}}(m)</span> . The multiplicative depth here is 0, as no decryption needs to be performed. In this case,  <span class="math">\\rho</span>  corresponds to the HE expansion rate.</p>

    <p class="text-gray-300">The following alternative scenarios can then be compared.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Only the secret key is encrypted under the homomorphic scheme, i.e., <span class="math">\\tilde{k}=k</span>. Then, since we focus on symmetric encryption schemes with rate 1, we get</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\rho=1+\\frac{\\ell_{k}\\times(\\text{HE expansion rate})}{\\ell_{m}}</span></p>

    <p class="text-gray-300">which is the smallest encryption rate we can achieve for an <span class="math">\\ell_{k}</span>-bit security. In a nonce-based stream cipher, <span class="math">\\ell_{m}</span> is limited by the IV size <span class="math">\\ell_{IV}</span> and by the maximal keystream length <span class="math">N(d)</span> which can be produced for a fixed multiplicative depth <span class="math">d\\geq\\text{depth}(\\text{\\sf Sync})+\\text{depth}(f)</span>. Then, the minimal encryption rate is achieved for messages of any length <span class="math">\\ell_{m}\\leq 2^{\\ell_{IV}}N(d)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An intermediate case consists in transmitting the initial state of the generator, i.e., the output of Sync. Then, the number of bits to be encrypted by the HE increases to the size <span class="math">n</span> of the internal state, while the number of keystream bits which can be generated from a given initial state with a circuit of depth <span class="math">d</span> corresponds to <span class="math">N(d+\\text{depth}(\\text{\\sf Sync}))</span>. Then, we get</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\rho=1+\\frac{n\\times(\\text{HE expansion rate})}{N(d+\\text{depth}(\\text{\\sf Sync}))}\\ ,</span></p>

    <p class="text-gray-300">for any message length. The size of the internal state is at least twice the size of the key. Therefore, this scenario is not interesting, unless the number of plaintext bits <span class="math">\\ell_{m}</span> to be encrypted under the same key is smaller than twice <span class="math">N(d+\\text{depth}(\\text{\\sf Sync}))</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">Appendix C Proofs of Propositions 1 and 2</h2>

    <p class="text-gray-300">We first observe that, within any register in Trivium, the degree of the leftmost bit is greater than or equal to the degrees of the other bits in the register. It is then sufficient to study the evolution of the leftmost bits in the three registers. Let <span class="math">t_{i}(d)</span> denotes the first time instant (starting from <span class="math">t=1</span>) where the leftmost bit in Register <span class="math">i</span> is computed by a circuit of depth <span class="math">d</span>. The depth of the feedback bit in Register <span class="math">i</span> can increase from <span class="math">d</span> to <span class="math">(d+1)</span> if either a bit of depth <span class="math">(d+1)</span> reaches a XOR gate in the feedback function, or a bit of depth <span class="math">d</span> reaches one of the inputs of the AND gate. From the distance between the leftmost bit and the first bit involved in the feedback (resp. and the first entry of the AND gate) in each register, we derive that</p>

    <p class="text-gray-300"><span class="math">t_{1}(d+1)</span> <span class="math">=\\text{min}(t_{3}(d+1)+66,t_{3}(d)+109)</span> <span class="math">t_{2}(d+1)</span> <span class="math">=\\text{min}(t_{1}(d+1)+66,t_{1}(d)+91)</span> <span class="math">t_{3}(d+1)</span> <span class="math">=\\text{min}(t_{2}(d+1)+69,t_{2}(d)+82)</span></p>

    <p class="text-gray-300">In Trivium, the first key bits <span class="math">K_{78}</span> and <span class="math">K_{79}</span> enter the AND gate in Register 1 at time <span class="math">t=13</span> (starting from <span class="math">t=1</span>), implying <span class="math">t_{2}(1)=14</span>. Then, <span class="math">t_{3}(1)=83</span> and <span class="math">t_{1}(1)=149</span>. This leads to</p>

    <p class="text-gray-300"><span class="math">t_{1}(4)=401,t_{2}(4)=296\\text{ and }t_{3}(4)=335\\;.</span></p>

    <p class="text-gray-300">From <span class="math">d=3</span>, the differences <span class="math">t_{i}[d+1]-t_{i}[d]</span> are large enough so that the minimum in the three recurrence relation corresponds to the right-hand term. We then deduce that, for <span class="math">d\\geq 4</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">d\\equiv 1</span> mod 3,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t_{1}(d)=282\\times\\frac{(d-1)}{3}+119,\\;t_{2}(d)=282\\times\\frac{(d-1)}{3}+14,\\;t_{3}(d)=282\\times\\frac{(d-1)}{3}+53.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">d\\equiv 2</span> mod 3,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t_{1}(d)=282\\times\\frac{(d-2)}{3}+162,\\;t_{2}(d)=282\\times\\frac{(d-2)}{3}+210,\\;t_{3}(d)=282\\times\\frac{(d-2)}{3}+96.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">d\\equiv 0</span> mod 3,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t_{1}(d)=282\\times\\frac{(d-3)}{3}+205,\\;t_{2}(d)=282\\times\\frac{(d-3)}{3}+253,\\;t_{3}(d)=282\\times\\frac{(d-3)}{3}+292.</span></p>

    <p class="text-gray-300">The degree of the keystream produced at time <span class="math">t</span> corresponds to the minimum between the degrees of the bit at position 66 in Register 1, the bit at position 69 in Register 2 and the bit at position 66 in Register 3. Then, for <span class="math">d&gt;3</span>,</p>

    <p class="text-gray-300"><span class="math">N(d)=\\min(t_{1}(d+1)+64,t_{2}(d+1)+67,t_{3}(d+1)+64)\\;.</span></p>

    <p class="text-gray-300">This leads to, for any <span class="math">d\\geq 4</span>,</p>

    <p class="text-gray-300">\\[ N(d)=282\\times\\left\\lfloor\\frac{d}{3}\\right\\rfloor+\\left\\{\\begin{array}[]{ll}81&\\text{if }d\\equiv 0\\text{ mod }3\\\\ 160&\\text{if }d\\equiv 1\\text{ mod }3\\\\ 269&\\text{if }d\\equiv 2\\text{ mod }3\\end{array}\\right.\\;. \\]</p>

    <p class="text-gray-300">In Kreyvium, the recurrence relations defining the <span class="math">t_{i}(d)</span> are the same. The only difference is that the first key bits now enter the AND gate in Register 1 at time <span class="math">t=1</span>, implying <span class="math">t_{2}(1)=2</span>. Then, <span class="math">t_{3}(1)=71</span>, <span class="math">t_{1}(1)=137</span> and <span class="math">t_{3}[2]=85</span>. The situation is then similar to Trivium, except that we start from</p>

    <p class="text-gray-300"><span class="math">t_{1}(4)=390,t_{2}(4)=285\\text{ and }t_{3}(4)=324\\;.</span></p>

    <p class="text-gray-300">These three values are equal to the values obtained with Trivium minus 11. This fixed difference then propagated, leading to, for any <span class="math">d\\geq 4</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">d\\equiv 1\\text{ mod }3</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t_{1}(d)=282\\times\\frac{(d-1)}{3}+108,\\;t_{2}(d)=282\\times\\frac{(d-1)}{3}+3,\\;t_{3}(d)=282\\times\\frac{(d-1)}{3}+42.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">d\\equiv 2\\text{ mod }3</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t_{1}(d)=282\\times\\frac{(d-2)}{3}+151,\\;t_{2}(d)=282\\times\\frac{(d-2)}{3}+199,\\;t_{3}(d)=282\\times\\frac{(d-2)}{3}+85.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">d\\equiv 0\\text{ mod }3</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">t_{1}(d)=282\\times\\frac{(d-3)}{3}+194,\\;t_{2}(d)=282\\times\\frac{(d-3)}{3}+242,\\;t_{3}(d)=282\\times\\frac{(d-3)}{3}+281.</span></p>

    <p class="text-gray-300">We eventually derive that, for Kreyvium, for any <span class="math">d\\geq 4</span>,</p>

    <p class="text-gray-300">\\[ N(d)=282\\times\\left\\lfloor\\frac{d}{3}\\right\\rfloor+\\left\\{\\begin{array}[]{ll}70&\\text{if }d\\equiv 0\\text{ mod }3\\\\ 149&\\text{if }d\\equiv 1\\text{ mod }3\\\\ 258&\\text{if }d\\equiv 2\\text{ mod }3\\end{array}\\right.\\;. \\]</p>

    <h2 id="sec-18" class="text-2xl font-bold">Appendix D Another Approach: Using Discrete Logs on Binary Fields</h2>

    <p class="text-gray-300">We now introduce a second, discrete-log based embodiment of the generic compressed encryption scheme of Section 2.2. We recall that the homomorphic encryption scheme <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(\\cdot)</span> is assumed to encrypt separately each plaintext bit. For <span class="math">h\\in\\mathbb{F}_{2^{n}}</span>, we identify <span class="math">h</span> with the vector of its coefficients and therefore by <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(h)</span>, we mean the vector composed of the encrypted coefficients of <span class="math">h</span>.</p>

    <p class="text-gray-300">This approach attempts to achieve provable security while ensuring a low-depth circuit <span class="math">\\mathcal{C}_{F}</span>. For this, we require <span class="math">G</span> to be a PRNG and <span class="math">IV</span> to be chosen at random at encryption time and transmitted within <span class="math">c^{\\prime}</span>. This allows us to prove that <span class="math">c^{\\prime}</span> is semantically secure under a well-defined complexity assumption. Simultaneously, we use exponentiation in a binary field to instantiate <span class="math">F</span>, which yields a circuit <span class="math">\\mathcal{C}_{F}</span> of depth <span class="math">\\lceil\\log\\ell_{k}\\rceil</span>. Performance estimations, however, show that Approach 2 is rather impractical.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">D.1 Description</h3>

    <p class="text-gray-300">In this approach, the operating mode picks a fresh <span class="math">IV\\leftarrow\\{0,1\\}^{\\ell_{IV}}</span> for each compressed ciphertext. The expansion function <span class="math">G</span> is instantiated by some PRNG that we will view as a random oracle in the security proof. Also, we set</p>

    <p class="text-gray-300"><span class="math">\\ell_{x}=N=n\\;,</span></p>

    <p class="text-gray-300">and therefore <span class="math">F</span> maps <span class="math">n</span>-bit inputs to <span class="math">n</span>-bit outputs under <span class="math">\\ell_{k}</span>-bit parameters. Given <span class="math">k\\in\\{0,1\\}^{\\ell_{k}}</span> and <span class="math">x\\in\\{0,1\\}^{n}</span>, <span class="math">F_{k}(x)</span> views <span class="math">x</span> as a field element in <span class="math">\\mathbb{F}_{2^{n}}</span> and <span class="math">k</span> as an <span class="math">\\ell_{k}</span>-bit integer, computes <span class="math">z=x^{k}</span> over <span class="math">\\mathbb{F}_{2^{n}}</span>, views <span class="math">z</span> as an <span class="math">n</span>-bit string and outputs <span class="math">z</span>. This completes the description of the compressed encryption scheme.</p>

    <p class="text-gray-300">D.2 A log-log-depth exponentiation circuit over <span class="math">\\mathbb{F}_{2^n}</span></p>

    <p class="text-gray-300">We describe a circuit <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> which, given a field element <span class="math">h\\in\\mathbb{F}_{2^n}</span> and an encrypted exponent <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(k)</span> with <span class="math">k\\in\\{0,1\\}^{\\ell_{k}}</span>, computes <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(h^{k})</span> and has multiplicative depth at most <span class="math">\\lceil\\log\\ell_{k}\\rceil</span>.</p>

    <p class="text-gray-300">Stricto sensu, <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> is not just a Boolean circuit evaluated homomorphically, as it combines computations in the clear, homomorphic <span class="math">\\mathbb{F}_{2}</span>-arithmetic on encrypted bits, and <span class="math">\\mathbb{F}_{2}</span>-arithmetic on mixed cleartext/encrypted bits.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> uses implicitly some irreducible polynomial <span class="math">p</span> to represent <span class="math">\\mathbb{F}_{2^n}</span> and we denote by <span class="math">\\oplus</span> and <span class="math">\\otimes_{p}</span> the field operators. The basic idea here is that for any <span class="math">a,b\\in\\mathbb{F}_{2^n}</span>, computing <span class="math">\\mathsf{HE}(a\\otimes_{p}b)</span> from <span class="math">\\mathsf{HE}(a),\\mathsf{HE}(b)</span> requires <em>only <span class="math">1</span> multiplicative level</em>, simply because <span class="math">\\otimes_{p}</span> is <span class="math">\\mathbb{F}_{2}</span>-bilinear. Therefore, knowing <span class="math">p</span> and the characteristics of <span class="math">\\mathsf{HE}</span>, we can efficiently implement a bilinear operator on encrypted binary vectors to compute</p>

    <p class="text-gray-300"><span class="math">\\mathsf{HE}(a\\otimes_{p}b)=\\mathsf{HE}(a)\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\mathsf{HE}(b)\\;.</span></p>

    <p class="text-gray-300">A second useful observation is that for any <span class="math">a\\in\\mathbb{F}_{2^n}</span> and <span class="math">\\beta\\in\\{0,1\\}</span>, there is a multiplication-free way to deduce <span class="math">\\mathsf{HE}(a^{\\beta})</span> from <span class="math">a</span> and <span class="math">\\mathsf{HE}(\\beta)</span>. When <span class="math">\\beta=1</span>, <span class="math">a^{\\beta}</span> is just <span class="math">a</span> and <span class="math">a^{\\beta}=1_{\\mathbb{F}_{2^{n}}}=(1,0,\\ldots,0)</span> otherwise. Therefore to construct a vector <span class="math">v=(v_{0},\\ldots,v_{n-1})=\\mathsf{HE}(a^{\\beta})</span>, it is enough to set</p>

    <p class="text-gray-300">\\[ v_{i}:=\\left\\{\\begin{array}[]{ll}\\mathsf{HE}(0)&\\text{if }a_{i}=0\\\\ \\mathsf{HE}(\\beta)&\\text{if }a_{i}=1\\end{array}\\right. \\]</p>

    <p class="text-gray-300">for <span class="math">i=1,\\ldots,n-1</span> and</p>

    <p class="text-gray-300">\\[ v_{0}:=\\left\\{\\begin{array}[]{ll}\\mathsf{HE}(\\beta\\oplus 1)&\\text{if }a_{0}=0\\\\ \\mathsf{HE}(1)&\\text{if }a_{i}=1\\end{array}\\right. \\]</p>

    <p class="text-gray-300">where it does not matter that the same encryption of <span class="math">0</span> be used multiple times. Let us denote this procedure as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{HE}(a^{\\beta})=\\mathsf{L}_{a}\\left(\\mathsf{HE}(\\beta)\\right)\\;.</span></p>

    <p class="text-gray-300">Now, given as input <span class="math">h\\in\\mathbb{F}_{2^{n}}</span>, <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> first computes in the clear <span class="math">h_{i}=h^{2^{i}}</span> for <span class="math">i=0,\\ldots,\\ell_{k}-1</span>. Since</p>

    <p class="text-gray-300"><span class="math">h^{k}=h_{0}^{k_{0}}\\otimes_{p}h_{1}^{k_{1}}\\otimes_{p}\\cdots\\otimes_{p}h_{\\ell_{k}-1}^{k_{\\ell_{k}-1}}\\;,</span></p>

    <p class="text-gray-300">one gets</p>

    <p class="text-gray-300"><span class="math">\\mathsf{HE}(h^{k})</span> <span class="math">=\\mathsf{HE}\\left(h_{0}^{k_{0}}\\right)\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\mathsf{HE}\\left(h_{1}^{k_{1}}\\right)\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\cdots\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\mathsf{HE}\\left(h_{\\ell_{k}-1}^{k_{\\ell_{k}-1}}\\right)</span> <span class="math">=\\mathsf{L}_{h_{0}}\\left(\\mathsf{HE}\\left(k_{0}\\right)\\right)\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\mathsf{L}_{h_{1}}\\left(\\mathsf{HE}\\left(k_{1}\\right)\\right)\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\cdots\\ \\otimes_{p}^{\\mathsf{HE}}\\ \\mathsf{L}_{h_{\\ell_{k}-1}}\\left(\\mathsf{HE}\\left(k_{\\ell_{k}-1}\\right)\\right)\\;.</span></p>

    <p class="text-gray-300">Viewing the <span class="math">\\ell_{k}</span> variables as the leaves of a binary tree, <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> therefore requires at most <span class="math">\\lceil\\log\\ell_{k}\\rceil</span> levels of homomorphic multiplications to compute and return <span class="math">\\mathsf{HE}_{\\mathsf{pk}}(h^{k})</span>.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">D.3 Security Results</h3>

    <p class="text-gray-300">Given some homomorphic encryption scheme <span class="math">\\mathsf{HE}</span> and security parameters <span class="math">\\kappa,n,\\ell_{k}</span>, we define a family of decision problems <span class="math">\\{\\mathsf{DP}_{t}\\}_{t&gt;0}</span> as follows.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 1 (Decision Problem <span class="math">\\mathsf{DP}_{t}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{pk}\\leftarrow\\mathsf{HE}.\\mathsf{KeyGen}(1^{\\kappa})</span> be a random public key, <span class="math">k\\leftarrow\\{0,1\\}^{\\ell_{k}}</span> a random <span class="math">\\ell_{k}</span>-bit integer and <span class="math">g_{1},\\ldots,g_{t},g_{1}^{\\prime},\\ldots,g_{t}^{\\prime}\\leftarrow\\mathbb{F}_{2^{n}}</span>, <span class="math">2t</span> random field elements. Distinguish the distributions</p>

    <p class="text-gray-300"><span class="math">D_{t,1}</span> <span class="math">=\\left(\\mathsf{pk},\\mathsf{HE}_{\\mathsf{pk}}(k),g_{1},\\ldots,g_{t},g_{1}^{k},\\ldots,g_{t}^{k}\\right)\\quad\\text{and}</span> <span class="math">D_{t,0}</span> <span class="math">=\\left(\\mathsf{pk},\\mathsf{HE}_{\\mathsf{pk}}(k),g_{1},\\ldots,g_{t},g_{1}^{\\prime},\\ldots,g_{t}^{\\prime}\\right)\\;.</span></p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Viewing <span class="math">G</span> as a random oracle, the compressed encryption scheme described above is semantically secure (IND-CPA), unless breaking <span class="math">\\mathsf{DP}_{t}</span> is efficient, for messages of bit-size <span class="math">\\ell_{m}</span> with <span class="math">(t-1)n&lt;\\ell_{m}\\leq tn</span>.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">A random-oracle version of the PRNG function <span class="math">G</span> is an oracle that takes as input a pair <span class="math">(IV,\\ell)</span> where <span class="math">IV\\in\\{0,1\\}^{\\ell_{IV}}</span> and <span class="math">\\ell\\in\\mathbb{N}^{*}</span>, and returns an <span class="math">\\ell</span>-bit random string. It is also imposed to the oracle that <span class="math">G(IV;\\ell_{1})</span> be a prefix of <span class="math">G(IV;\\ell_{2})</span> for any <span class="math">IV</span> and <span class="math">\\ell_{1}\\leq\\ell_{2}</span>.</p>

    <p class="text-gray-300">We rely on the real-or-random flavor of the IND-CPA security game and build a reduction algorithm <span class="math">\\mathcal{R}</span> that uses an adversary <span class="math">\\mathcal{A}^{G}</span> against the scheme to break <span class="math">\\mathsf{DP}_{t}</span> as follows. <span class="math">\\mathcal{R}</span> is given as input some <span class="math">(\\mathsf{pk},\\mathsf{HE}_{\\mathsf{pk}}(k),g_{1},\\ldots,g_{t},\\tilde{g}_{1},\\ldots,\\tilde{g}_{t})</span> sampled from <span class="math">D_{t,b}</span> and has to guess the bit <span class="math">b</span>. <span class="math">\\mathcal{R}</span> runs <span class="math">\\mathcal{A}^{G}(\\mathsf{pk})</span> and receives some challenge plaintext <span class="math">m^{\\star}\\in\\{0,1\\}^{\\ell_{m}}</span> where <span class="math">(t-1)n&lt;\\ell_{m}\\leq tn</span>. <span class="math">\\mathcal{R}</span> makes use of its input to build a compressed ciphertext <span class="math">c^{\\prime}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">\\mathsf{keystream}</span> to the <span class="math">\\ell_{m}</span> leftmost bits of <span class="math">\\tilde{g}_{1}\\mid\\mid\\ldots\\mid\\mid\\tilde{g}_{t}</span>,</li>

      <li>Pick a random <span class="math">IV^{\\star}\\leftarrow\\{0,1\\}^{\\ell_{IV}}</span>,</li>

      <li>Abort if <span class="math">G(IV^{\\star};\\ell^{\\prime})</span> is already defined for some <span class="math">\\ell^{\\prime}</span>,</li>

      <li>Set <span class="math">G(IV^{\\star};tn)</span> to <span class="math">g_{1}\\mid\\mid\\ldots\\mid\\mid g_{t}</span>.</li>

      <li>Set <span class="math">c^{\\prime}=(\\mathsf{HE}_{\\mathsf{pk}}(k),IV^{\\star},m^{\\star}\\oplus\\mathsf{keystream})</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{R}</span> then returns <span class="math">c^{\\prime}</span> to <span class="math">\\mathcal{A}</span> and forwards <span class="math">\\mathcal{A}</span>’s guess <span class="math">\\tilde{b}</span> to its own challenger. At any moment, <span class="math">\\mathcal{R}</span> responds to <span class="math">\\mathcal{A}</span>’s queries to <span class="math">G</span> using fresh random strings for each new query or to extend a past query to a larger size. Obviously, all the statistical distributions comply with their specifications. Consequently <span class="math">c^{\\prime}</span> is an encryption of <span class="math">m^{\\star}</span> if the input instance comes from <span class="math">D_{t,1}</span> and is an encryption of some perfectly uniform plaintext if the instance follows <span class="math">D_{t,0}</span>. The reduction is tight as long as the abortion probability <span class="math">q2^{-\\ell_{IV}}</span> remains negligible, <span class="math">q</span> being the number of oracle queries made by <span class="math">\\mathcal{A}</span>. ∎</p>

    <p class="text-gray-300">Interestingly, we note the following fact about our family of decision problems.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">For any <span class="math">t\\geq 2</span>, <span class="math">\\mathsf{DP}_{t}</span> is equivalent to <span class="math">\\mathsf{DP}_{2}</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Obviously, a problem instance <span class="math">(\\mathsf{pk},\\mathsf{HE}_{\\mathsf{pk}}(k),g_{1},\\ldots,g_{t},\\tilde{g}_{1},\\ldots,\\tilde{g}_{t})</span> sampled from <span class="math">D_{t,b}</span> can be converted into an instance of <span class="math">D_{2,b}</span> for the same <span class="math">b</span>, by just removing <span class="math">g_{3},\\ldots,g_{t}</span> and <span class="math">\\tilde{g}_{3},\\ldots,\\tilde{g}_{t}</span>. This operation preserves the distributions of all inner variables. Therefore <span class="math">\\mathsf{DP}_{t}</span> can be reduced to <span class="math">\\mathsf{DP}_{2}</span>. Now, we describe a reduction <span class="math">\\mathcal{R}</span> which, given an instance <span class="math">(\\mathsf{pk},\\mathsf{HE}_{\\mathsf{pk}}(k),g_{1},g_{2},\\tilde{g}_{1},\\tilde{g}_{2})</span> sampled from <span class="math">D_{2,b}</span>, makes use of an adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\mathsf{DP}_{t}</span> to successfully guess <span class="math">b</span>. <span class="math">\\mathcal{R}</span> converts its instance of <span class="math">D_{2,b}</span> into an instance of <span class="math">D_{t,b}</span> as follows. For <span class="math">i=3,\\ldots,t</span>, <span class="math">\\mathcal{R}</span> randomly selects <span class="math">\\alpha_{i}\\leftarrow\\mathbb{Z}/(2^{n}-1)\\mathbb{Z}</span> and sets</p>

    <p class="text-gray-300"><span class="math">g_{i}=g_{1}^{\\alpha_{i}}g_{2}^{1-\\alpha_{i}}\\ ,\\quad\\tilde{g}_{i}=\\tilde{g}_{1}^{\\alpha_{i}}\\tilde{g}_{2}^{1-\\alpha_{i}}\\ .</span></p>

    <p class="text-gray-300">It is easily seen that, if <span class="math">\\tilde{g}_{1}=g_{1}^{k}</span> and <span class="math">\\tilde{g}_{2}=g_{2}^{k}</span> then <span class="math">\\tilde{g}_{i}=g_{i}^{k}</span> for every <span class="math">i</span>. If however <span class="math">\\tilde{g}_{1},\\tilde{g}_{2}</span> are uniformly and independently distributed over <span class="math">\\mathbb{F}_{2^{n}}</span> then so are <span class="math">\\tilde{g}_{3},\\ldots,\\tilde{g}_{t}</span>. Our reduction runs <span class="math">\\mathcal{A}</span> over that instance and outputs the guess <span class="math">\\tilde{b}</span> returned by <span class="math">\\mathcal{A}</span>. Obviously <span class="math">\\mathcal{R}</span> is tight. ∎</p>

    <p class="text-gray-300">Overall, the security of our compressed encryption scheme relies on breaking <span class="math">\\mathsf{DP}_{1}</span> for messages of bit-size at most <span class="math">n</span> and on breaking <span class="math">\\mathsf{DP}_{2}</span> for larger messages. Beyond the fact that <span class="math">\\mathsf{DP}_{2}</span> reduces to <span class="math">\\mathsf{DP}_{1}</span>, we note that these two problems are unlikely to be equivalent since <span class="math">\\mathsf{DP}_{2}</span> is easily broken using a DDH oracle over <span class="math">\\mathbb{F}_{2^{n}}</span> while <span class="math">\\mathsf{DP}_{1}</span> seems to remain unaffected by it.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">D.4 Performance Issues</h3>

    <p class="text-gray-300">Concrete security parameters. Note that our decisional security assumptions <span class="math">\\mathsf{DP}_{t}^{\\exp}</span> for all <span class="math">t\\geq 1</span> reduce to the discrete logarithm computation in the finite field <span class="math">\\mathbb{F}_{2^{n}}</span>. Solving discrete logarithm in finite fields of small characteristics is currently a very active research area, marked notably by the quasi-polynomial algorithm of Barbulescu, Gaudry, Joux and Thomé <em>[x1]</em>. In particular, the expected security one can hope for has been recently completely redefined <em>[x10, x11]</em>. In our setting, we will select a prime <span class="math">n</span> so that computing discrete logarithms in <span class="math">\\mathbb{F}_{2^{n}}</span> has complexity <span class="math">2^{n}</span> for <span class="math">\\kappa</span>-bit security. The first step of Barbulescu et al. algorithm runs in polynomial time. This step has been extensively studied and its complexity has been brought down to <span class="math">\\mathcal{O}((2^{\\log_{2}n})^{6})</span> using a very complex and tight analysis by Joux and Pierrot <em>[x16]</em>. As for the quasi-polynomial step of the algorithm, its complexity can be upper-bounded, but in practice numerous trade-off can be used and it is difficult to give to lower bound it <em>[x10, x11]</em>. To remains conservative in our choice of parameters, we will base our security on the first step. To ensure a 80-bit (resp. 128-bit) security level, one should therefore choose a prime <span class="math">n</span> of <span class="math">\\log_{2}n\\approx 14</span> bits (resp. 23 bits), i.e. work in a finite field of about <span class="math">16,000</span> elements (resp. 4 million elements).</p>

    <p class="text-gray-300">How impractical is this approach? We now briefly see why our discrete-log based construction on binary fields is impractical. We focus more specifically on the exponentiation circuit <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> whose most critical subroutine is a general-purpose field multiplication in the encrypted domain. Taking homomorphic bit multiplication as the complexity unit and neglecting everything else, how fast can we expect to multiply encrypted field elements in <span class="math">\\mathbb{F}_{2^{n}}</span>?</p>

    <p class="text-gray-300">When working in the cleartext domain, several families of techniques exist with attractive asymptotic complexities for large <span class="math">n</span>, such as algorithms derived from Toom-Cook <em>[x1]</em> or Schönhage-Strassen <em>[x22]</em>. It is unclear how these different strategies can be adapted to our case and with what complexities. However, let us optimistically assume that they <em>could be adapted somehow</em> and that one of these adaptations would just take <span class="math">n</span> homomorphic bit multiplications.</p>

    <p class="text-gray-300">A straightforward implementation of <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span> consists in viewing all circuit inputs <span class="math">\\mathsf{L}_{h_{i}}(\\mathsf{HE}(k_{i}))</span> as generic encrypted field elements and in performing generic field multiplications along the binary tree, which would require <span class="math">\\ell_{k}\\cdot n</span> homomorphic bit multiplications. Taking <span class="math">\\ell_{k}=160</span>, <span class="math">n=16000</span> and <span class="math">0.5</span> seconds for each bit multiplication (as a rough estimate of the timings of Section 4), this accounts for more than <span class="math">14</span> days of computation.</p>

    <p class="text-gray-300">This can be improved because the circuit inputs are precisely not generic encrypted field elements; each one of the <span class="math">n</span> ciphertexts in <span class="math">\\mathsf{L}_{h_{i}}(\\mathsf{HE}(k_{i}))</span> is known to equal either <span class="math">\\mathsf{HE}(k_{i})</span>, <span class="math">\\mathsf{HE}(k_{i}\\oplus 1)</span>, <span class="math">\\mathsf{HE}(0)</span> or <span class="math">\\mathsf{HE}(1)</span>. Similarly, a circuit variable of depth <span class="math">1</span> <em>i.e.</em></p>

    <p class="text-gray-300"><span class="math">\\mathsf{L}_{h_{i}}(\\mathsf{HE}(k_{i}))\\otimes_{p}^{\\mathsf{HE}}\\mathsf{L}_{h_{i+1}}(\\mathsf{HE}(k_{i+1}))\\;,</span></p>

    <p class="text-gray-300">contains <span class="math">n</span> ciphertexts that are all an encryption of one of the <span class="math">16</span> quadratic polynomials <span class="math">ak_{i}k_{i+1}+bk_{i}+ck_{i+1}+d</span> for <span class="math">a,b,c,d\\in\\{0,1\\}</span>. This leads us to a strategy where one <em>simulates</em> the <span class="math">\\tau</span> first levels of field multiplications at once, by computing the <span class="math">2^{\\lceil\\log\\ell_{k}\\rceil-\\tau}</span> dictionaries of the form</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathsf{HE}\\left(k_{i}^{b_{0}}k_{i+1}^{b_{1}}\\cdots k_{i+2^{\\tau}-1}^{b_{2^{\\tau}-1}}\\right)\\right\\}_{b_{0},\\ldots,b_{2^{\\tau}-1}\\in\\{0,1\\}}</span></p>

    <p class="text-gray-300">and computing the binary coefficients (in clear) to be used to reconstruct each bit of the <span class="math">2^{\\lceil\\log\\ell_{k}\\rceil-\\tau}</span> intermediate variables of depth <span class="math">\\tau</span> from the dictionaries through linear (homomorphic) combinations. By assumption, this accounts for nothing in the total computation time. The rest of the binary tree is then performed using generic encrypted field multiplications as before, until the circuit output is fully aggregated. This approach is always more efficient than the straightforward implementation and optimal when the total number</p>

    <p class="text-gray-300"><span class="math">\\left(2^{2^{\\tau}}-2^{\\tau}-1\\right)\\cdot 2^{\\lceil\\log\\ell_{k}\\rceil-\\tau}+\\left(2^{\\lceil\\log\\ell_{k}\\rceil-\\tau-1}-1\\right)\\cdot n</span></p>

    <p class="text-gray-300">of required homomorphic bit multiplications is minimal. With <span class="math">\\ell_{k}=160</span> and <span class="math">n=16000</span> again, the best choice is for <span class="math">\\tau=4</span>. Assuming <span class="math">0.5</span> seconds for each bit multiplication, this still gives a prohibitive <span class="math">6.71</span> days of computation for a single evaluation of <span class="math">\\mathcal{C}_{\\mathrm{exp}}</span>.</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Stream ciphers: A Practical Solution for Efficient Homomorph... (2015/113)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/113
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
