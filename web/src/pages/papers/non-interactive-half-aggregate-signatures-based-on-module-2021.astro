---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/263';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Non-Interactive Half-Aggregate Signatures Based on Module Lattices - A First Attempt';
const AUTHORS_HTML = 'Katharina Boudgoust, Adeline Roux-Langlois';

const CONTENT = `    <p class="text-gray-300">Non-Interactive Half-Aggregate Signatures Based on Module Lattices A First Attempt</p>

    <p class="text-gray-300">Katharina Boudgoust¹ and Adeline Roux-Langlois² katharina.boudgoust@cs.au.dk, adeline.roux-langlois@irisa.fr</p>

    <p class="text-gray-300">¹ Aarhus University ² Univ Rennes, CNRS, IRISA</p>

    <p class="text-gray-300">Abstract. The Fiat-Shamir with Aborts paradigm of Lyubashevsky has given rise to efficient lattice-based signature schemes. One popular implementation is Dilithium which is a finalist in an ongoing standardization process run by the NIST. Informally, it can be seen as a lattice analogue of the well-known discrete-logarithm-based Schnorr signature. An interesting research question is whether it is possible to combine several unrelated signatures, issued from different signing parties on different messages, into one single aggregated signature. Of course, its size should be significantly smaller than the trivial concatenation of all signatures. Ideally, the aggregation can be done offline by a third party, called public aggregation. Previous works have shown that it is possible to half-aggregate Schnorr signatures, but it was left unclear if the underlying techniques can be adapted to the lattice setting.</p>

    <p class="text-gray-300">In this work, we show that, indeed, we can use similar strategies to obtain a signature scheme allowing for public aggregation whose hardness is proven assuming the intractability of two well-studied problems on module lattices: The Module Learning With Errors problem (M-LWE) and the Module Short Integer Solution problem (M-SIS).</p>

    <p class="text-gray-300">Unfortunately, our scheme produces aggregated signatures that are larger than the trivial solution of concatenating. This is due to peculiarities that seem inherent to lattice-based cryptography. Its motivation is thus mainly pedagogical, as we explain the subtleties when designing lattice-based aggregate signatures that are supported by a proper security proof.</p>

    <p class="text-gray-300">Keywords. Lattice-Based Cryptography, Module Lattices, Signature Aggregation</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">For a long time, the main focus of cryptology was on secure encryption. With the invention of public key cryptology in the 1970s and the spread of the internet, the need of secure key exchange and authentication of data became more and more important. This is why nowadays the focus of public key cryptology increasingly shifts towards digital signatures. A digital signature scheme <span class="math">\\Pi_S</span> with message</p>

    <p class="text-gray-300">space <span class="math">\\mathcal{M}</span> is composed of three algorithms <span class="math">\\mathsf{KGen},\\mathsf{Sig}</span> and <span class="math">\\mathsf{Vf}</span>. The algorithm <span class="math">\\mathsf{KGen}</span> generates a key pair <span class="math">(\\mathsf{sk},\\mathsf{vk})</span> for a given user, who can then use their secret key <span class="math">\\mathsf{sk}</span> to generate a signature <span class="math">\\sigma</span> on a given message <span class="math">m\\in \\mathcal{M}</span> by running <span class="math">\\mathsf{Sig}(\\mathsf{sk},m)</span>. Afterwards, this signature can be verified by anyone using the verification key <span class="math">\\mathsf{vk}</span>, which is publicly available, by running <span class="math">\\{0,1\\} \\leftarrow \\mathsf{Vf}(\\mathsf{vk},m,\\sigma)</span>. If the verification procedure outputs 1, the signature passes validation.</p>

    <p class="text-gray-300">An interesting research question is whether it is possible to define an additional algorithm <span class="math">\\sigma_{agg} \\gets \\mathsf{AggSig}(\\mathsf{VK}, M, \\Sigma)</span> which takes as input a vector of <span class="math">N \\in \\mathbb{Z}</span> verification keys <span class="math">\\mathsf{VK} = (\\mathsf{vk}_j)_{j \\in [N]}</span>, a vector of <span class="math">N</span> messages <span class="math">M = (m_j)_{j \\in [N]}</span> and a vector of <span class="math">N</span> signatures <span class="math">\\Sigma = (\\sigma_j)_{j \\in [N]}</span>, that were generated by the <span class="math">N</span> different signing parties with corresponding verification keys <span class="math">\\mathsf{vk}_j</span>, and outputs a single signature <span class="math">\\sigma_{agg}</span>. We further require a way for others to verify that <span class="math">\\sigma_{agg}</span> is indeed an aggregation of valid signatures. Thus, we need to provide a second additional algorithm <span class="math">\\{0,1\\} \\gets \\mathsf{AggVf}(\\mathsf{VK}, M, \\sigma_{agg})</span>, that outputs 1 if <span class="math">\\sigma_{agg}</span> is a valid aggregation of <span class="math">N</span> valid signatures. All five algorithms define a so-called aggregate signature scheme <span class="math">\\Pi_{AS} = (\\mathsf{KGen}, \\mathsf{Sig}, \\mathsf{Vf}, \\mathsf{AggSig}, \\mathsf{AggVf})</span>, where we require that it must satisfy correctness and unforgeability properties. A trivial solution is to set <span class="math">\\sigma_{agg}</span> as the concatenation of all the <span class="math">N</span> different signatures and verify one after the other. In the following we are searching for an aggregate scheme that produces a <span class="math">\\sigma_{agg}</span> which is significantly shorter than this trivial solution. Ideally, the aggregation algorithm <span class="math">\\mathsf{AggSig}</span> can be performed by a third, even untrusted party without needing to communicate with the <span class="math">N</span> signing parties. We call this public aggregation. The concept and a first realization of aggregate signatures with public aggregation were given by Boneh et al. [Bon+03] by using bilinear maps constructed over elliptic curves in the generic group model. Aggregate signatures are a useful tool to save communication costs in settings where different users have to authenticate their communication, for instance in consensus protocols or certificate chains. More recently, they attracted increased interest as they help to reduce the size of blockchains such as the Bitcoin blockchain.</p>

    <p class="text-gray-300">Constructing aggregate signature schemes based on the discrete logarithm problem (without bilinear maps) turned out to be much more harder, and so far, only solutions that partly aggregate the signatures are known. Chalkias et al. [Cha+21] build a half-aggregate scheme for the well-known Schnorr signature [Sch91]. It produces aggregate signatures of half the size compared to the trivial solution of concatenating. Its security is proven in the Random Oracle Model (ROM) assuming the hardness of the discrete logarithm problem. It was left unclear if the underlying techniques can be adapted to the lattice setting.</p>

    <p class="text-gray-300">Contributions. We propose an aggregate signature allowing public aggregation, whose security is proven assuming simultaneously the hardness of Module Learning With Errors (M-LWE) and Module Short Integer Solution (M-SIS) and thus based on worst-case module lattice problems [LS15]. Earlier proposals either only</p>

    <p class="text-gray-300">3 Throughout the paper, the neutral singular pronouns they/their are used in order to keep the language as inclusive as possible. See also https://www.acm.org/diversity-inclusion/words-matter</p>

    <p class="text-gray-300">offered security based on (non-standard) average-case lattice problems, or didn't allow for public aggregation (cf. Related Works). From a high level perspective, we take the practical signature from Güneysu et al. [GLP12] as a starting point. It follows the Fiat-Shamir with Aborts (FSwA) paradigm for lattice-based schemes [Lyu12], which is also used in the signature Dilithium [Duc+18], a finalist in the ongoing NIST standardization process⁴.</p>

    <p class="text-gray-300">Due to peculiarities that seem inherent to lattice-based cryptography, our scheme produces aggregated signatures whose sizes are larger than the size of the trivial solution (that is concatenating all the single signatures together). The motivation of our work thus is pedagogical in order to demonstrate the subtleties when designing lattice-based aggregate signatures that are supported by a proper security proof, in a security model we explain below. We would like to remark that most issues we came across also apply to the MMSA(TK) aggregate signature [Dor+20] (cf. Related Works).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Technical Details. Let us quickly recall the FSwA paradigm for lattice-based signatures in the module setting. In the following, all computations are done over the ring  <span class="math">R_{q} = \\mathbb{Z}_{q}[x] / \\langle x^{n} + 1 \\rangle</span> , where  <span class="math">n</span>  is a power of two and  <span class="math">q</span>  is some prime modulus. A verification key is given as  $\\mathbf{t} = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{s} \\in R_q^k<span class="math"> , where  </span>\\mathbf{s} \\in R_q^{\\ell + k}<span class="math">  is a vector of small norm (defining  </span>\\mathsf{sk}<span class="math"> ),  </span>\\mathbf{A} \\in R_q^{k \\times \\ell}<span class="math">  is a public uniform matrix and  </span>\\mathbf{I}_k<span class="math">  the identity matrix of order  </span>k<span class="math"> . A signature is provided by  </span>\\sigma = (\\mathbf{u},\\mathbf{z}) \\in R_q^k \\times R_q^{\\ell + k}<span class="math"> , where  </span>\\mathbf{u}<span class="math">  is a commitment that via some hash function  </span>H_{c}<span class="math">  defines a challenge  </span>c<span class="math"> , and  </span>\\mathbf{z}<span class="math">  is the answer to this challenge. The challenge  </span>c<span class="math">  is a polynomial with coefficients in  </span>\\{-1,0,1\\}<span class="math"> . For verification, one checks that  </span>\\mathbf{z}<span class="math">  is short and that  </span>[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{z} = \\mathbf{t} \\cdot c + \\mathbf{u}<span class="math"> , where  </span>c = H_{c}(\\mathbf{u},\\mathbf{t},m)<span class="math">  for the verification key  </span>\\mathbf{t}<span class="math">  and a message  </span>m<span class="math"> . Adding  </span>\\mathbf{t}<span class="math">  to the input of  </span>H_{c}$  is a simple countermeasure to prevent so-called rogue-attacks [Bon+03, Sec. 3.2].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An intuitive way to aggregate  <span class="math">N</span>  different signatures  <span class="math">(\\sigma_{j})_{j\\in [N]}</span>  with  <span class="math">\\sigma_{j} = (\\mathbf{u}_{j},\\mathbf{z}_{j})</span>  into one signature  <span class="math">\\sigma_{agg}</span>  would be to compute the sum of all components  <span class="math">(\\sum_{j}\\mathbf{u}_{j},\\sum_{j}\\mathbf{z}_{j})</span> . However, we wouldn't be able to verify this aggregated signature as we can't re-compute the different challenges  <span class="math">c_{j}</span>  as we don't know the inputs  <span class="math">\\mathbf{u}_j</span>  to  <span class="math">H_{c}</span> , originally used by the signing parties. Thus, we can only sum up the  <span class="math">\\mathbf{z}_j</span>  parts and still have to transmit all the  <span class="math">\\mathbf{u}_j</span> , which produces an aggregate signature of the form  <span class="math">\\sigma_{agg} = ((\\mathbf{u}_j)_j,\\sum_j\\mathbf{z}_j)</span> . This is essentially how our (half-)aggregate signature looks like. In order to prevent again rogue-type attacks, we use a linear combination (instead of the simple sum), where the coefficients come from some random oracle (which was queried on all signatures that are aggregated). This technique is also used in the Schnorr-analogue by Chalkias et al. [Cha+21]. We formally present our aggregate signature scheme in Section 3.2 and the rogue-attack for the simple-sum solution in Section 4.3.</p>

    <p class="text-gray-300">The size of a single signature can be significantly reduced by replacing the commitment  <span class="math">\\mathbf{u} \\in R_q^k</span>  by the challenge  <span class="math">c \\in R</span> . This does not only reduce the</p>

    <p class="text-gray-300">⁴ https://csrc.nist.gov/Projects/Post-Quantum-Cryptography/ ⁵ Chalkias et al. [Cha+21, Sec. 6] provide evidence that it is necessary to transmit all the commitments.</p>

    <p class="text-gray-300">dimension of the vector from <span class="math">k</span> to 1, but also the total bit-length from <span class="math">nk\\log_2q</span> to <span class="math">n\\log_23</span>, as <span class="math">\\mathbf{u}</span> can be any vector in <span class="math">R_q^k</span> but <span class="math">c</span> is a polynomial with ternary coefficients. Unfortunately, this can't be done in the aggregate setting, as we only have knowledge of the <em>aggregated</em> value of all <span class="math">\\mathbf{z}_j</span>'s. This is the main reason of our failure in constructing aggregate signatures schemes on lattices that are shorter than the trivial concatenation. Note that in the discrete-logarithm setting of the Schnorr aggregate signature in [Cha+21], the challenge <span class="math">c</span> and the commitment <span class="math">\\mathbf{u}</span> are elements of the same space. This explains why there is a real improvement for Schnorr signatures, but not for FSwA signatures.</p>

    <p class="text-gray-300">In our aggregate signature, we have to transmit all <span class="math">N</span> vectors <span class="math">(\\mathbf{u}_j)_j</span> (and the smallish linear combination of all the <span class="math">\\mathbf{z}_j</span>), whereas in the trivial concatenation we transmit all <span class="math">N</span> challenges <span class="math">(c_j)_j</span> (and the <span class="math">N</span> small vectors <span class="math">\\mathbf{z}_j</span>). The size of the <span class="math">\\mathbf{u}_j</span> is so large that it annihilates the compressing effect of combining all the <span class="math">\\mathbf{z}_j</span>. More concretely, taking the level III parameters of Dilithium [Duc+18] and <span class="math">N = 1000</span> signatures to aggregate, then <span class="math">(\\mathbf{u}_1,\\dots ,\\mathbf{u}_N)\\in (R_q^k)^N</span> is of size ca. 4400 KB. However, simply concatenating <span class="math">N</span> single Dilithium signatures produces an aggregate signature of a smaller size of ca. 3300 KB. Note that both earlier versions of this paper on e-print (3 Mar 2021 and 8 Apr 2021) we further compressed the aggregated signature via some linear function <span class="math">T</span> to obtain a solution that was indeed smaller than the trivial concatenation. As we elaborate in Section 3.3, this allowed for simple lattice attacks.</p>

    <p class="text-gray-300">In Section 4.2, we provide a rigorous security proof (Theorem 1), where the proof idea follows the one of Damgård et al. [Dam+21] for their inter-active multi-signature (cf. Related Works). It is composed of a sequence of indistinguishable games (assuming the hardness of M-LWE), where the starting one is the security game of our aggregate signature. The game is specified by the aggregate chosen key model, as introduced by Boneh et al. [Bon+03]. In the last game, the signing procedure is simulated by some algorithm that doesn't depend on the secret key and the verification key is sampled uniformly at random. By applying (twice) the General Forking Lemma from Bellare and Neven [BN06] we can use four different responses of a successful adversary against the scheme in the last game to solve an instance of M-SIS. This "double forking technique" has been used in the setting of multi-signatures, see Maxwell et al. [Max+19]. As we don't need trapdoor commitment schemes, the proof is less technical than the one in [Dam+21].</p>

    <p class="text-gray-300">Related Works. A first attempt to build lattice-based aggregate signatures with public aggregation was made by Doroz et al. [Dor+20]. Their construction builds upon the signature scheme PASS Sign, introduced by Hoffstein et al. [Hof+14]. As a warm-up, they introduce a simple linear (half-)aggregate signature, which they call MMSA (multi-message, multi-user signature aggregation). However, in this version, the aggregate signature is larger than the trivial concatenation of <span class="math">N</span> different signatures. In order to improve the efficiency, they first compress the sig</p>

    <p class="text-gray-300">6 This calculation does not even take into account the fact that in our aggregate signature <span class="math">\\log_2 q</span> has to be increased by some factor <span class="math">\\log_2 \\sqrt{N}</span>.</p>

    <p class="text-gray-300">nature, leading to MMSAT (the T stands for a linear compression function <span class="math">T</span>), and then compress the verification keys, leading to MMSATK. Unfortunately, their construction has several disadvantages: First, the linear compression used in MMSAT(K) is prone to simple forgery attacks (similar to Section 3.3), making those constructions insecure. Second, they only provide a security proof for the first variant MMSA by showing that it inherits the security of the underlying PASS Sign, and subsequently its security can be based on the hardness of the Partial Fourier Recovery problem (PFR). The PFR asks to recover a polynomial in the ring <span class="math">\\mathbb{Z}[x]/\\langle x^{n}-1\\rangle</span> of small norm having access only to a partial list of its Fourier transform. It can be formulated as a bounded distance decoding problem over some ideal lattice. This may rise security concerns, as problems over ideal lattices have been shown to be in specific parameter settings easier than their counterparts over arbitrary lattices, e.g., <em>[x10]</em>. Furthermore, up to today, there are no connections to worst-case lattice problems, which may be seen as an additional security concern.</p>

    <p class="text-gray-300">In a parallel line of research, aggregate signature schemes that only allow for <em>private aggregation</em> have been proposed. In this setting, the different signing parties interact with each other to generate an aggregated signature on one message, which can be the concatenation of different messages. Those are also known as <em>multi-signature schemes</em> and there have been several recent protocols following the FSwA paradigm providing lattice-based inter-active aggregate signatures, see for instance <em>[x11]</em> and references therein.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Open Problems</h4>

    <p class="text-gray-300">We leave as an open problem the construction of an aggregate signature scheme based on standard lattice-problems which allows public aggregation, produces aggregate signatures that are smaller than the simple concatenation and at the same time is provably secure in the aggregate chosen-key security model.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Change Log</h4>

    <p class="text-gray-300">This is the second revision of the paper originally submitted to e-print in March 2021. The first revision (April 2021) took into account the attack against the simple sum solution in the chosen key model (Section 4.3). As, at the time of writing this version, we weren’t aware of any other way to fix the scheme, we proved its security in a more restricted security model, that we called the <em>aggregate independent-chosen-key model</em>. The latest revision (May 2022) now uses a randomized linear combination of the single signatures (instead of a simple sum), where the scalars come from a large enough space. The security of the scheme can now be proven in the standard security model of aggregate signatures. However, we had to remove the compressing function <span class="math">T</span> that we originally applied to the input to the hash function <span class="math">H_{c}</span> as linear compressing is prone to simple lattice attacks (cf. Section 3.3). To avoid misunderstanding, we accordingly changed the title of the paper.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">k \\in \\mathbb{N}</span>, we represent the set <span class="math">\\{1, \\ldots, k\\}</span> by <span class="math">[k]</span>. Vectors are denoted in bold lowercase and matrices in bold capital letters and the identity matrix of order <span class="math">k</span> is denoted by <span class="math">\\mathbf{I}_k</span>. The concatenation of two matrices <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{B}</span> with the same number of rows is denoted by $[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}]<span class="math">. For any set </span>S<span class="math">, we denote by </span>U(S)<span class="math"> the uniform distribution over </span>S<span class="math">. We write </span>x \\gets D<span class="math"> to denote the process of sampling an element </span>x<span class="math"> following the distribution </span>D<span class="math">. Throughout the paper </span>R = \\mathbb{Z}[x] / \\langle x^n + 1 \\rangle<span class="math"> denotes the ring of integers of the </span>2n<span class="math">-th cyclotomic field, where </span>n<span class="math"> is a power of two. Further, </span>q<span class="math"> is a prime such that </span>q = 1 \\mod 2n<span class="math"> defining the quotient ring </span>R_q = \\mathbb{Z}_q[x] / \\langle x^n + 1 \\rangle<span class="math">. An element </span>a = \\sum_{j=1}^{n} a_j x^{j-1}<span class="math"> of </span>R<span class="math"> is identified with its coefficient vector </span>\\mathbf{a} = (a_j)_{j \\in [n]} \\in \\mathbb{Z}^n<span class="math">. For any ring element </span>a \\in R<span class="math">, we set </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_1<span class="math"> as the infinity, the Euclidean and the </span>\\ell_1<span class="math">-norm of its coefficient vector, respectively. All norms can be generalized to vectors </span>\\mathbf{a} \\in R^k<span class="math"> for </span>k \\in \\mathbb{N}<span class="math">, by considering the coefficient vector of dimension </span>kn<span class="math"> defined by </span>\\mathbf{a}<span class="math">. We rely on the key set </span>S_\\beta = \\{a \\in R : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq \\beta\\}<span class="math"> with </span>\\beta \\in \\mathbb{N}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-4" class="text-2xl font-bold">2.1 Module Lattice Problems</h2>

    <p class="text-gray-300">We also recall two lattice problems and refer to [LS15] for more details. We state them in their discrete, primal and HNF form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 1 (M-LWE).</strong> Let <span class="math">k, \\ell, \\beta \\in \\mathbb{N}</span>. The Module Learning With Errors problem M-LWE<span class="math">_{k,\\ell,\\beta}</span> is defined as follows. Given <span class="math">\\mathbf{A} \\gets U(R_q^{k \\times \\ell})</span> and <span class="math">\\mathbf{t} \\in R_q^k</span>. Decide whether <span class="math">\\mathbf{t} \\gets U(R_q^k)</span> or if $\\mathbf{t} = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{s}<span class="math">, where </span>\\mathbf{s} \\gets U(S_\\beta^{\\ell + k})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The M-LWE assumption states that no PPT distinguisher can distinguish the two distributions with non-negligible advantage. Worst-case to average-case reductions guarantee that M-LWE is quantumly [LS15] and classically [Bou+20] at least as hard as the approximate shortest vector problem over module lattices.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 2 (M-SIS).</strong> Let <span class="math">k, \\ell, b \\in \\mathbb{N}</span>. The Module Short Integer Solution problem M-SIS<span class="math">_{k,\\ell,b}</span> is as follows. Given a uniformly random matrix <span class="math">\\mathbf{A} \\gets U(R_q^{k \\times \\ell})</span>. Find a non-zero vector <span class="math">\\mathbf{s} \\in R_q^{k + \\ell}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq b<span class="math"> and </span>[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{s} = \\mathbf{0} \\in R_q^k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The M-SIS assumption states that no PPT adversary can solve this problem with non-negligible probability. Worst-case to average-case reductions guarantee that M-SIS is classically [LS15] at least as hard as the approximate shortest independent vector problem over module lattices.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2.2 Aggregate Signature Schemes</h2>

    <p class="text-gray-300">We present the formal definition of aggregate signature schemes and their property of correctness.</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> An aggregate signature scheme <span class="math">\\Pi_{AS}</span> for a message space <span class="math">\\mathcal{M}</span> consists of a tuple of PPT algorithms <span class="math">\\Pi_{AS} = (\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf},\\mathsf{AggSig},\\mathsf{AggVf})</span>, proceeding as specified in the following protocol:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KGen}(1^{\\lambda})\\to(\\mathsf{sk},\\mathsf{vk}):</span> On input a security parameter <span class="math">\\lambda</span>, the key generation algorithm returns a secret signing key <span class="math">\\mathsf{sk}</span> and a public verification key <span class="math">\\mathsf{vk}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Sig}(\\mathsf{sk},m)\\to\\sigma:</span> On input a signing key <span class="math">\\mathsf{sk}</span> and a message <span class="math">m\\in\\mathcal{M}</span>, the signing algorithm returns a signature <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Vf}(\\mathsf{vk},m,\\sigma)\\to\\{0,1\\}:</span> On input a verification key <span class="math">\\mathsf{vk}</span>, a message <span class="math">m\\in\\mathcal{M}</span> and a signature <span class="math">\\sigma</span>, the verification algorithm either accepts (i.e. outputs <span class="math">1</span>) or rejects (i.e. outputs <span class="math">0</span>).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AggSig}(\\mathsf{VK},M,\\Sigma)\\to\\sigma_{agg}:</span> Given as input a vector of verification keys <span class="math">\\mathsf{VK}=(\\mathsf{vk}_{j})_{j\\in[N]}</span>, a vector of messages <span class="math">M=(m_{j})_{j\\in[N]}</span> and a vector of signatures <span class="math">\\Sigma=(\\sigma_{j})_{j\\in[N]}</span>, the signature aggregation algorithm returns a aggregated signature <span class="math">\\sigma_{agg}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AggVf}(\\mathsf{VK},M,\\sigma_{agg})\\to\\{0,1\\}:</span> Given as input a vector of verification keys <span class="math">\\mathsf{VK}=(\\mathsf{vk}_{j})_{j\\in[N]}</span>, a vector of messages <span class="math">M=(m_{j})_{j\\in[N]}</span> and an aggregated signature <span class="math">\\sigma_{agg}</span>, the aggregated verification algorithm either accepts (i.e. outputs <span class="math">1</span>) or rejects (i.e. outputs <span class="math">0</span>).</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{\\Pi}_{AS}=(\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf},\\mathsf{AggSig},\\mathsf{AggVf})</span> be an aggregate signature scheme for a message space <span class="math">\\mathcal{M}</span>. It is called <em>correct</em> if for all security parameters <span class="math">\\lambda\\in\\mathbb{N}</span> and number of signers <span class="math">N\\in\\mathbb{N}</span> it yields</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{AggVf}(\\mathsf{VK},M,\\mathsf{AggSig}(\\mathsf{VK},M,\\Sigma))=1]=1,</span></p>

    <p class="text-gray-300">where <span class="math">m_{j}\\in\\mathcal{M}</span>, <span class="math">(\\mathsf{sk}_{j},\\mathsf{vk}_{j})\\leftarrow\\mathsf{KGen}(1^{\\lambda})</span> and <span class="math">\\sigma_{j}\\leftarrow\\mathsf{Sig}(\\mathsf{sk}_{j},m_{j})</span> for <span class="math">j\\in[N]</span> and <span class="math">\\mathsf{VK}=(\\mathsf{vk}_{j})_{j\\in[N]}</span>, <span class="math">M=(m_{j})_{j\\in[N]}</span> and <span class="math">\\Sigma=(\\sigma_{j})_{j\\in[N]}</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 General Forking Lemma</h3>

    <p class="text-gray-300">For the sake of completeness and to fix notations, we restate the General Forking Lemma from Bellare and Neven <em>[x1]</em>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 1 (General Forking Lemma).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">N_{q}\\geq 1</span> be an integer and let <span class="math">C</span> be a set of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2<span class="math">. Let </span>\\mathcal{B}<span class="math"> be a randomized algorithm that on input </span>x,h_{1},\\ldots,h_{N_{q}}<span class="math"> returns a pair </span>(j,\\mathsf{out})<span class="math">, where </span>j\\in\\{0,\\ldots,N_{q}\\}<span class="math"> and a side output </span>\\mathsf{out}<span class="math">. Let </span>\\mathsf{IGen}<span class="math"> be a randomized algorithm called the input generator, parametrized by some security parameter </span>\\lambda<span class="math">. We define the accepting probability of </span>\\mathcal{B}$ as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{acc}=\\Pr[j\\neq 0\\colon x\\leftarrow\\mathsf{IGen}(1^{\\lambda});h_{1},\\ldots,h_{N_{q}}\\leftarrow U(H);(j,\\mathsf{out})\\leftarrow\\mathcal{B}(x,h_{1},\\ldots,h_{N_{q}})].</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}_{\\mathcal{B}}</span> be a forking algorithm that works as in Figure 1, given <span class="math">x</span> as input and black-box access to <span class="math">\\mathcal{B}</span>. We define the forking probability of <span class="math">\\mathcal{F}_{\\mathcal{B}}</span> as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{frk}=\\Pr[(\\mathsf{out},\\widetilde{\\mathsf{out}})\\neq(\\bot,\\bot)\\colon x\\leftarrow\\mathsf{IGen}(1^{\\lambda});(\\mathsf{out},\\widetilde{\\mathsf{out}})\\leftarrow\\mathcal{F}_{\\mathcal{B}}(x)].</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then it yields $\\mathsf{acc}\\leq N_{q}/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\sqrt{N_{q}\\cdot\\mathsf{frk}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. The forking algorithm  <span class="math">\\mathsf{F}_{\\mathcal{B}}</span></p>

    <p class="text-gray-300">In this section we first present the underlying single signature scheme (Section 3.1) before introducing our aggregate signature scheme in Section 3.2. From a high level perspective, we take the practical signature from Güneysu et al. [GLP12] as a starting point. The linear aggregation follows the idea of Doroz et. al [Dor+20], where the main difference is that we moved to the M-LWE/M-SIS framework instead of the Partial Fourier Recovery framework of the original scheme. We think that M-LWE and M-SIS are more standard lattice problems and thus they increase our confidence in the security of the proposed scheme. Lastly, we explain in Section 3.3 why the linear compression idea that we used in an earlier version and that we adapted from MMSA(TK) [Dor+20] leads to efficient lattice attacks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following we describe the underlying single signature scheme, which is essentially the signature scheme from Güneysu et al. [GLP12] with minor modifications. Let  <span class="math">R_{q} = \\mathbb{Z}_{q}[x] / \\langle x^{n} + 1\\rangle</span> , with  <span class="math">n</span>  a power of two and  <span class="math">q</span>  a prime such that  <span class="math">q = 1 \\mod 2n</span> . For  <span class="math">k,\\ell \\in \\mathbb{N}</span> , let  <span class="math">\\mathbf{A}\\in R_q^{k\\times \\ell}</span>  follow the uniform distribution and be a public shared parameter of the system. The number of columns  <span class="math">\\ell</span>  and the number of rows  <span class="math">k</span>  should be adapted to the required security level, but usually they are small constants. Let  $H_{c}\\colon \\{0,1\\}^{*}\\to C = \\{c\\in R\\colon \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{1} = d,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 1\\}<span class="math">  be a random oracle with  </span>d<span class="math">  such that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; 2^{2\\lambda}<span class="math"> , where  </span>\\lambda<span class="math">  denotes the required security level. Let  </span>s,\\beta ,M\\in \\mathbb{Z}<span class="math">  and the message space  </span>\\mathcal{M} = \\{0,1\\}^<em><span class="math"> . Finally, let  </span>\\mathcal{D}<span class="math">  denote a distribution over  </span>R^{\\ell +k}<span class="math">  providing (with overwhelming probability) vectors of norm at most  </span>B<span class="math">  and to which we associate a rejection probability  </span>\\operatorname</em>{Pr}_{rej}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The signature scheme  <span class="math">\\Pi_S = (\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf})</span>  from [GLP12] with minor modifications is illustrated in Figure 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Description. The algorithm KGen samples a secret key vector  <span class="math">\\mathbf{s}</span> , composed of elements of  <span class="math">R</span>  with coefficients of size at most  <span class="math">\\beta</span> , and sets the verification key to  $\\mathbf{t} = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{s} \\in R_q^k$ . At the beginning of the signing procedure, a masking</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. The signature scheme from [GLP12] with minor modifications.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vector  <span class="math">\\mathbf{y}</span>  following the distribution  <span class="math">D</span>  is sampled. The signing party then computes  $\\mathbf{u} = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k]\\cdot \\mathbf{y}\\in R_q^k<span class="math"> , which serves together with the verification key  </span>\\mathbf{t}<span class="math">  and the message  </span>m<span class="math">  as input to the random oracle  </span>H_{c}<span class="math"> . The output  </span>c<span class="math">  of  </span>H_{c}<span class="math">  is a polynomial in  </span>R<span class="math">  with exactly  </span>d<span class="math">  coefficients that are  </span>\\pm 1<span class="math">  and the remaining coefficients are 0. The second part of a potential signature is defined as  </span>\\mathbf{z} = \\mathbf{s}\\cdot c + \\mathbf{y}<span class="math"> . In order to make the distribution of the signature independent of the secret key, the algorithm only outputs the potential signature with probability  </span>\\operatorname*{Pr}_{rej}<span class="math"> . This step is called rejection sampling. In order to verify  </span>\\sigma<span class="math"> , the verifier first re-constructs the hash value  </span>c = H_{c}(\\mathbf{u},\\mathbf{t},m)<span class="math">  and then checks if the norm of  </span>\\mathbf{z}<span class="math">  is smaller than  </span>B<span class="math">  and that  </span>[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k]\\cdot \\mathbf{z} = \\mathbf{t}\\cdot c + \\mathbf{u}<span class="math"> . The parameters  </span>\\beta, d, B<span class="math">  and  </span>\\operatorname*{Pr}_{rej}$  have to be set strategically such that the scheme is correct, efficient and secure, see [Lyu12; Duc+18].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Distribution  <span class="math">\\mathcal{D}</span> . For simplicity, we leave the concrete implementation of the distribution  <span class="math">\\mathcal{D}</span>  open. In the literature, mainly two instantiations have been studied: the discrete Gaussian distribution over  <span class="math">R</span>  and the uniform distribution over the set of elements of small norms [Lyu09; Lyu12]. The literature provides concrete formulas for the rejection probability  <span class="math">\\operatorname{Pr}_{rej}</span>  and the bound  <span class="math">B</span> . For example, for  <span class="math">\\mathcal{D} = D_s^{k + \\ell}</span>  the discrete Gaussian distribution of width  <span class="math">s</span> , the bound  <span class="math">B</span>  comes from the Gaussian tail bound and the rejection probability can be computed as  <span class="math">\\min(1, D_s^{\\ell + k}(\\mathbf{z}) / M \\cdot D_{c \\cdot \\mathbf{s}, s}^{\\ell + k}(\\mathbf{z}))</span> , where  <span class="math">M</span>  is a constant that depends on  <span class="math">\\beta</span>  (the Euclidean norm of the secret  <span class="math">\\mathbf{s}</span> ) and  <span class="math">d</span>  (the  <span class="math">\\ell_1</span> -norm of the challenge  <span class="math">c</span> ).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Modifications. A first difference to the signature scheme in [GLP12] is that instead of transmitting  <span class="math">c</span>  in the signature, we send  <span class="math">\\mathbf{u}</span> . For a single signature, both cases are equivalent, as  <span class="math">\\mathbf{u}</span>  defines  <span class="math">c</span>  via the hash function  <span class="math">H_{c}</span>  (and the verification key  <span class="math">\\mathbf{t}</span>  and the message  <span class="math">m</span> ) and  <span class="math">c</span>  defines  <span class="math">\\mathbf{u}</span>  via the equation  $\\mathbf{u} = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k]\\cdot \\mathbf{z} - \\mathbf{t}\\cdot c$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">over  <span class="math">R_{q}</span> . In Section 3.2 we see that this is not the case for an aggregate signature scheme and we thus need to transmit the information  <span class="math">\\mathbf{u}</span> .</p>

    <p class="text-gray-300">Another modification is that we add the verification key  <span class="math">\\mathbf{t}</span>  to the input of the hash function  <span class="math">H_{c}</span>  to compute the challenge  <span class="math">c</span> . As proposed by Boneh et al. [Bon+03, Sec. 3.2] and implemented for MMSA(TK) in [Dor+20, Sec. 8.2], adding  <span class="math">\\mathbf{t}</span>  to the input of  <span class="math">H_{c}</span>  ties the hash value to the (sk, vk)-pair, which prevents so-called rogue key attacks (also called key swap attacks) on aggregate signatures.</p>

    <p class="text-gray-300">Security. Overall, the security of the scheme  <span class="math">\\Pi_S = (\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf})</span>  as specified in Figure 2 is based on the hardness of M-LWE and M-SIS. For the reason of space limits, we don't go into detail here, but refer the interested reader to the original security proofs in [Lyu12] and [GLP12] in the ROM.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following we describe how to aggregate signatures from the scheme above. Assume that we have  <span class="math">N</span>  different users with corresponding secret keys  <span class="math">\\mathbf{s}_1, \\ldots, \\mathbf{s}_N</span>  and verification keys  <span class="math">\\mathsf{VK} = (\\mathsf{vk}_j)_{j \\in [N]}</span> , where  $\\mathsf{vk}_j = \\mathbf{t}_j = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{s}_j<span class="math">  using the same public matrix  </span>\\mathbf{A}<span class="math"> . The  </span>N<span class="math">  users signed  </span>N<span class="math">  different messages  </span>M = (m_j)_{j \\in [N]}<span class="math"> , producing  </span>N<span class="math">  independent signatures  </span>\\Sigma = (\\sigma_j)_{j \\in [N]} = (\\mathbf{u}_j, \\mathbf{z}_j)_j<span class="math"> . For the aggregation, we need another random oracle  </span>H_e: \\{0, 1\\}^* \\to C<span class="math"> , where  </span>C<span class="math">  is the same challenge space as in the single signature scheme, characterized by some positive integer  </span>d<span class="math"> . Further, we let  </span>B'<span class="math">  denote the bound on the norm of an aggregated signature. It&#x27;s concrete value depends on the distribution  </span>\\mathcal{D}<span class="math">  (and its bound  </span>B<span class="math"> ) used for the single signature. Informally speaking, if  </span>\\mathcal{D}<span class="math">  is a discrete Gaussian, so is  </span>B' = O(\\sqrt{N} B)<span class="math"> . If  </span>\\mathcal{D}<span class="math">  is the uniform distribution over vectors of bounded norm, so is  </span>B' = O(NB)<span class="math"> . For simplicity, we set  </span>B' = N\\sqrt{d} B<span class="math">  in the following. The non-interactive half-aggregation of signatures is illustrated in Figure 3. The aggregate signature scheme is given by  </span>\\Pi_{AS} = (\\mathsf{KGen}, \\mathsf{Sig}, \\mathsf{Vf}, \\mathsf{AggSig}, \\mathsf{AggVf})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. Non-Interactive Half-Aggregation of Signatures.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to aggregate <span class="math">N</span> signatures <span class="math">(\\sigma_j)_{j\\in [N]}</span> the algorithm AggSig first reconstructs the challenges <span class="math">c_{j} = H_{c}(\\mathbf{u}_{j},\\mathbf{t}_{j},m_{j})</span> for every <span class="math">j\\in [N]</span> and queries <span class="math">H_{e}</span> to obtain <span class="math">(e_j = H_e(c_1,\\ldots ,c_N,j)</span> for every index <span class="math">j\\in [N]</span>. It then computes the sum <span class="math">\\mathbf{z} = \\sum_{j}e_{j}\\mathbf{z}_{j}</span> and outputs the aggregated signature <span class="math">\\sigma_{agg} = ((\\mathbf{u}_j)_j,\\mathbf{z})</span>, if the Euclidean norm of <span class="math">\\mathbf{z}</span> is bounded above by <span class="math">B^{\\prime}</span>. Else the algorithm outputs <span class="math">\\perp</span>. Note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_je_j\\mathbf{z}_j\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\sum_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_j\\mathbf{z}_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\sum_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq N\\cdot \\sqrt{d}\\cdot B = B^{\\prime}<span class="math"> (at least with overwhelming probability). Thus, the probability that AggSig outputs </span>\\perp<span class="math"> is negligible. The aggregation can be done by anyone, even by untrusted parties, as long as they have access to the random oracle </span>H_{c}$. Thus, public aggregation is enabled.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To verify an aggregated signature <span class="math">\\sigma_{agg}</span>, AggVf first re-constructs the challenges <span class="math">c_{j}</span> for <span class="math">j\\in [N]</span> by using the commitment <span class="math">\\mathbf{u}_j</span> provided in <span class="math">\\sigma_{agg}</span>, the verification key <span class="math">\\mathbf{t}_j</span> and the message <span class="math">m_j</span>. Then it re-constructs the scalars <span class="math">e_j = H_e(c_1,\\ldots ,c_N,j)</span> for every <span class="math">j</span>. The algorithm then checks if the norm of <span class="math">\\mathbf{z}</span> lies within the correct bound. Finally it verifies the equations <span class="math">[\\mathbf{A},\\mathbf{I}_k]\\cdot \\mathbf{z} = \\sum_j(\\mathbf{t}_j\\cdot c_j + \\mathbf{u}_j)</span>. If all checks go through, it outputs 1, else 0.</p>

    <p class="text-gray-300">Remark 1. It now becomes clear that transmitting <span class="math">c_{j}</span> wouldn't be sufficient to verify the aggregated signature: as the verifier only knows the term <span class="math">\\mathbf{z}</span>, but not all the <span class="math">\\mathbf{z}_{j}</span>, they cannot reconstruct <span class="math">\\mathbf{u}_{j}</span> from <span class="math">c_{j}</span>. Without knowing <span class="math">\\mathbf{u}_{j}</span>, however, the verifier would not be able to verify the aggregated signature. Inter-active multi-signatures circumvent this issue by generating inter-actively one common input <span class="math">\\mathbf{u}</span> to the random oracle that depends on all the <span class="math">\\mathbf{u}_{j}</span>, before sending the multi-signature, see for instance [BS16] or [Dam+21]. As a public aggregation is our main objective, we accept a larger aggregated signature size.</p>

    <p class="text-gray-300">The correctness of our protocol <span class="math">\\Pi_{AS}</span> simply follows from the linearity of matrix-vector multiplication over <span class="math">R_{q}</span>.</p>

    <p class="text-gray-300">Lemma 2 (Correctness). Let <span class="math">\\Pi_{AS} = (\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf},\\mathsf{AggSig},\\mathsf{AggVf})</span> be the aggregate signature scheme for a message space <span class="math">\\mathcal{M}</span> with the algorithms as in Figures 2 and 3. Assuming the correctness of the corresponding single signature scheme <span class="math">\\Pi_S = (\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf})</span>, the aggregate signature is correct, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {A g g V f} (\\mathrm {V K}, M, \\operatorname {A g g S i g} (\\mathrm {V K}, M, \\Sigma)) = 1 \\mid \\operatorname {A g g S i g} (\\mathrm {V K}, M, \\Sigma) \\neq \\bot \\right] = 1,</span></div>

    <p class="text-gray-300">where <span class="math">m_j \\in \\mathcal{M}</span>, <span class="math">(\\mathsf{sk}_j, \\mathsf{vk}_j) \\gets \\mathsf{KGen}(1^\\lambda)</span> and <span class="math">\\sigma_j \\gets \\mathsf{Sig}(\\mathsf{sk}_j, m_j)</span> for <span class="math">j \\in [N]</span> and <span class="math">\\mathsf{VK} = (\\mathsf{vk}_j)_{j \\in [N]}</span>, <span class="math">M = (m_j)_{j \\in [N]}</span> and <span class="math">\\Sigma = (\\sigma_j)_{j \\in [N]}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let <span class="math">\\sigma_{agg} \\neq \\bot</span> be the aggregate signature produced by <span class="math">\\mathsf{AggSig}(\\mathsf{VK}, M, \\Sigma)</span>. The first check if $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq B'<span class="math"> succeeds by the construction of </span>\\mathsf{AggSig}$. For the last check, we compute</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {I} _ {k} ] \\cdot \\mathbf {z} = [ \\mathbf {A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {I} _ {k} ] \\cdot \\left(\\sum_ {j = 1} ^ {N} e _ {j} \\mathbf {z} _ {j}\\right) = \\sum_ {j = 1} ^ {N} e _ {j} [ \\mathbf {A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {I} _ {k} ] \\cdot \\mathbf {z} _ {j} = \\sum_ {j = 1} ^ {N} e _ {j} (\\mathbf {t} _ {j} \\cdot c _ {j} + \\mathbf {u} _ {j}),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where we used the linearity over <span class="math">R_{q}</span> and the correctness of <span class="math">\\Pi_S</span>.</p>

    <p class="text-gray-300">Remark 2. In order to guarantee the correctness of the scheme, it is important that all key pairs  <span class="math">(\\mathsf{sk},\\mathsf{vk})</span>  share the same public matrix  <span class="math">\\mathbf{A}</span> . It can be computed interactively by all, or by a reasonable large subset of all parties together during a setup-phase as in [Dam+21]. In order to gain in efficiency, it can instead also be computed by some compact random seed.</p>

    <p class="text-gray-300">In earlier versions of this work we followed the idea of MMSA(TK) [Dor+20] to further compress the aggregated signature. For the compression we used a linear function  <span class="math">T \\colon R_q^k \\to \\mathbb{Z}_q^{n_0}</span>  and applied it to the commitment  <span class="math">\\mathbf{u}_j</span>  before inputting it to the random oracle  <span class="math">H_c</span> . An aggregate signature was given by  <span class="math">\\sigma_{agg} = (\\sum_j \\mathbf{u}_j, T(\\mathbf{u}_j)_j, \\sum_j \\mathbf{z}_j)</span> . The key idea behind the compression was that  <span class="math">(\\sum_j \\mathbf{u}_j, T(\\mathbf{u}_j)_{j \\in [N]})</span>  is much smaller than the complete vector  <span class="math">(\\mathbf{u}_j)_{j \\in [N]}</span> . At the same time,  <span class="math">n_0</span>  is chosen large enough to guarantee combinatorial security (that is  <span class="math">2^\\lambda \\leq q^{n_0}</span> ) as we set  <span class="math">n_0</span>  such that it is hard to find a collision of  <span class="math">H_c</span>  for fixed verification key  <span class="math">\\mathbf{t}</span>  and message  <span class="math">m</span> .</p>

    <p class="text-gray-300">In order to make aggregation compatible with the single signatures, the signing procedure (for a single signature) has to be modified. Instead of inputting  <span class="math">\\mathbf{u}_j</span>  to  <span class="math">H_{c}</span> , only the compressed vector  <span class="math">T(\\mathbf{u}_j)</span>  serves as input, see Figure 4. As we elaborate in the following, this defines an insecure signature scheme. <span class="math">^8</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. The signature scheme from [GLP12] with linear compression.</p>

    <p class="text-gray-300">More precisely, we define an attacker who is able to forge signatures on arbitrary messages for any given public key  <span class="math">\\mathbf{t}</span>  without knowing the corresponding secret key  <span class="math">\\mathbf{s}</span> . First, the attacker initiates the signing procedure by sampling  <span class="math">\\mathbf{y}&#x27; \\gets D</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and computes $\\mathbf{u}' = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{y}'<span class="math">. They then query </span>c = H_c(T(\\mathbf{u}'), \\mathbf{t}, m)<span class="math"> to obtain the challenge for an arbitrary message </span>m<span class="math">. Now, they exploit the fact that </span>T<span class="math"> reduces the lattice dimension from </span>nk<span class="math"> to </span>n_0<span class="math">. More precisely, they use standard lattice reduction to find a short solution </span>\\mathbf{z}<span class="math"> to the equation </span>T[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k]\\mathbf{z} = T(\\mathbf{u}' + \\mathbf{t} \\cdot c)<span class="math"> and set </span>\\mathbf{u} := [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k]\\mathbf{z} - \\mathbf{t} \\cdot c<span class="math">. That is, they solve inhomogeneous SIS for the integer matrix </span>\\mathbf{A}' = T[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\in \\mathbb{Z}_q^{n_0 \\times (n(\\ell + k))}<span class="math"> (ignoring the structure of </span>\\mathbf{A}'<span class="math">). By the linearity of </span>T<span class="math">, it yields </span>T(\\mathbf{u}) = T(\\mathbf{u}')<span class="math"> and thus </span>\\sigma = (\\mathbf{u}, \\mathbf{z})<span class="math"> defines a valid forgery for the public key </span>\\mathbf{t}<span class="math">. Note that there may not exist a short </span>\\mathbf{y}<span class="math"> such that </span>[\\mathbf{A}, \\mathbf{I}_k] \\cdot \\mathbf{y} = \\mathbf{u}<span class="math">, but assuming the hardness of decisional M-LWE, both </span>\\mathbf{u}<span class="math"> and </span>\\mathbf{u}'$ are computationally close to uniform random vectors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-13" class="text-2xl font-bold">4 Security of Our Aggregate Signature Scheme</h2>

    <p class="text-gray-300">We recall in Sec. 4.1 the security model for aggregate signatures from Boneh et al. [Bon+03], before proving in Sec. 4.2 the security of our scheme from Sec. 3.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4.1 The Aggregate Chosen-Key Security Model</h2>

    <p class="text-gray-300">Informally speaking, the security notion we use within this paper of an aggregate signature scheme captures that there exists no efficient adversary who is able to existentially forge an aggregate signature, within a specified game. We use the aggregate chosen-key security model as introduced by Boneh et al. [Bon+03]. Let <span class="math">\\Pi_{AS} = (\\mathsf{KGen}, \\mathsf{Sig}, \\mathsf{Vf}, \\mathsf{AggSig}, \\mathsf{AggVf})</span> be an aggregate signature scheme with message space <span class="math">\\mathcal{M}</span> as in Definition 3 and let <span class="math">N</span> be the number of aggregated signatures. An adversary <span class="math">\\mathcal{A}</span> attacking <span class="math">\\Pi_{AS}</span> is given a single verification key <span class="math">\\mathsf{vk}_N</span>, the challenge key. Their goal is the existential forgery of an aggregate signature involving <span class="math">N</span> signatures, where we oblige <span class="math">\\mathcal{A}</span> to include a signature that can be verified using the challenge key. The remaining <span class="math">N - 1</span> verification keys can be chosen freely by <span class="math">\\mathcal{A}</span>. The adversary is also given access to a signing oracle on the challenge key <span class="math">\\mathsf{vk}_N</span>. Their advantage, denoted by <span class="math">\\mathsf{Adv} \\mathsf{AggSig}_{\\mathcal{A}}</span>, is defined to be their probability of success in the following game.</p>

    <p class="text-gray-300"><strong>Setup.</strong> The aggregate forger <span class="math">\\mathcal{A}</span> is provided with a challenge verification key <span class="math">\\mathsf{vk}_N</span>.</p>

    <p class="text-gray-300"><strong>Queries.</strong> Proceeding adaptively, <span class="math">\\mathcal{A}</span> queries signatures on messages of their choice that can be verified using the challenge key <span class="math">\\mathsf{vk}_N</span>.</p>

    <p class="text-gray-300"><strong>Response.</strong> Finally, <span class="math">\\mathcal{A}</span> outputs an aggregate signature <span class="math">\\sigma_{agg}</span>, together with a message vector <span class="math">M = (m_j)_{j\\in [N]}</span> and verification key vector <span class="math">\\mathsf{VK} = (\\mathsf{vk}_j)_{j\\in [N]}</span>.</p>

    <p class="text-gray-300"><strong>Result.</strong> The forger <span class="math">\\mathcal{A}</span> wins the game if the aggregate signature <span class="math">\\sigma_{agg}</span> is a valid aggregate on the verification key-message pairs <span class="math">(\\mathsf{vk}_j, m_j)_{j \\in [N]}</span>, i.e., if <span class="math">1 \\gets \\mathsf{AggVf}(\\mathsf{VK}, M, \\sigma_{agg})</span>. In order to avoid trivial solutions, <span class="math">\\mathcal{A}</span> is not allowed to hand in a pair <span class="math">(\\mathsf{vk}_N, m_N)</span>, which was queried on the signing oracle before.</p>

    <p class="text-gray-300">If we show the security in the Random Oracle Model (ROM), we also have to give <span class="math">\\mathcal{A}</span> the possibility to query the used random oracles.</p>

    <p class="text-gray-300">Definition 5. Let <span class="math">H</span> denote hash function that is modeled as a random oracle. An aggregate signature scheme <span class="math">\\Pi_{AS}</span> is called <span class="math">(N_H, N_{\\mathrm{Sig}}, N)</span>-secure against existential forgery in the aggregate chosen-key model in the ROM, if there exists no PPT algorithm <span class="math">\\mathcal{A}</span> that existentially forges an aggregate signature on <span class="math">N</span> verification keys in the aggregate chosen-key model, where <span class="math">\\mathcal{A}</span> has non-negligible advantage, makes at most <span class="math">N_H</span> queries to the random oracle <span class="math">H</span> and at most <span class="math">N_{\\mathrm{Sig}}</span> queries to the signing oracle on the challenge key.</p>

    <h2 id="sec-15" class="text-2xl font-bold">4.2 Proof of Security</h2>

    <p class="text-gray-300">We now prove that our scheme is secure against existential forgery in the independent-chosen-key model. Let <span class="math">\\Pi_{AS} = (\\mathsf{KGen},\\mathsf{Sig},\\mathsf{Vf},\\mathsf{AggSig},\\mathsf{AggVf})</span> be the aggregate signature from Section 3.</p>

    <p class="text-gray-300">Theorem 1. Let <span class="math">H_{c}, H_{e}</span> be two hash function providing the challenges and scalars in our aggregate signature, modeled as random oracles both with image space <span class="math">C</span>. Assume the hardness of <span class="math">\\mathrm{M - LWE}_{k,\\ell,\\beta}</span> and of <span class="math">\\mathrm{M - SIS}_{k,\\ell +1,b}</span>, where <span class="math">b = 16d\\cdot B^{\\prime} + 8d^{3 / 2}</span>. Then, the aggregate signature <span class="math">\\Pi_{AS}</span> with parameters <span class="math">(\\ell ,k,\\beta ,B^{\\prime},d)</span> is secure against existential forgery in the aggregate chosen-key model in the ROM. The advantage of some PPT adversary <span class="math">\\mathcal{A}</span> against <span class="math">\\Pi_{AS}</span> is bounded above by</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {Adv} \\operatorname {AggSig}_{\\mathcal{A}} \\leq \\frac {N _ {q}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\sqrt {N _ {q} \\cdot \\left(\\frac {N _ {q}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\sqrt {N _ {q} \\cdot \\operatorname {AdvM-SIS} _ {k , \\ell + 1 , b}}\\right)} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\operatorname {AdvM-LWE} _ {k, \\ell , \\beta} + \\operatorname {negl} (\\lambda),</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">\\lambda</span> denotes the security parameter and <span class="math">\\mathcal{A}</span> makes at most <span class="math">N_{H_c}</span> queries to <span class="math">H_{c}</span>, <span class="math">N_{H_e}</span> queries to <span class="math">H_{e}</span> and <span class="math">N_{\\mathrm{Sig}}</span> queries to the signing oracle and we set <span class="math">N_{q} = N_{H_{c}} + N_{H_{e}} + N_{\\mathrm{Sig}}</span>.</p>

    <p class="text-gray-300">Proof Sketch. Let us first describe the high level idea of the proof, which follows the "double forking technique" of [Max+19]. To begin, note that, assuming the hardness of M-LWE <span class="math">_{k,\\ell,\\beta}</span>, the honestly generated challenge key <span class="math">\\mathsf{vk}_N = \\mathbf{t} = [\\mathbf{A},\\mathbf{I}_k]\\cdot \\mathbf{s}_N</span> is computationally indistinguishable from a uniformly random vector over <span class="math">R_{q}</span>. Thus, one can replace the input <span class="math">(\\mathbf{A},\\mathbf{t})</span> by a real uniform element, which itself defines an instance of M-SIS <span class="math">_{k,\\ell+1,b}</span>. Now, we construct a so-called wrapper <span class="math">\\mathcal{B}</span> around the adversary <span class="math">\\mathcal{A}</span>, that internally invokes <span class="math">\\mathcal{A}</span> to obtain a signature forgery. The wrapper has the important role to simulate the random oracles <span class="math">H_{c}</span> and <span class="math">H_{e}</span> and the signing queries with respect to the challenge key. They output the received forgery, together with some extra information about the forger execution. We then apply twice the General Forking Lemma (Lemma 1). First, we construct an algorithm <span class="math">\\mathcal{C}</span> that runs the forking algorithm <span class="math">\\mathcal{F}_{\\mathcal{B}}</span> on <span class="math">\\mathcal{B}</span>, where the fork is with respect to the answer of <span class="math">H_{e}</span> to the forgery and the challenge index <span class="math">N</span>. Second, we construct another algorithm <span class="math">\\mathcal{D}</span> that runs now the forking algorithm <span class="math">\\mathcal{F}_{\\mathcal{C}}</span> on <span class="math">\\mathcal{C}</span>, where the fork happens regarding the answer of <span class="math">H_{c}</span> to the</p>

    <p class="text-gray-300">forgery and the challenge index <span class="math">N</span>. At the end, the wrapper <span class="math">\\mathcal{B}</span> has been run a total of 4 times, leading to four forgeries. The way how <span class="math">\\mathcal{D}, \\mathcal{C}</span> and <span class="math">\\mathcal{B}</span> are defined allows to derive a solution to M-SIS.</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\mathcal{A}</span> be an adversary against <span class="math">\\Pi_{AS}</span> with advantage Adv AggSig<span class="math">_A</span>. Our high level goal is to show that their advantage is negligible in the security parameter <span class="math">\\lambda</span> by providing a sequence of games <span class="math">G_0, G_1</span> and <span class="math">G_2</span>, where <span class="math">G_0</span> is the original chosen-key security game as in Section 4.1. Assuming the hardness of M-LWE, the adversary <span class="math">\\mathcal{A}</span> can distinguish between those games only with negligible advantage. In the last game <span class="math">G_2</span> we then apply twice the General Forking Lemma, leading to four different forgeries. Those then allow to construct a solution to M-SIS.</p>

    <p class="text-gray-300"><span class="math">G_0</span>: Set <span class="math">N_q = N_{H_c} + N_{H_e} + N_{\\mathrm{Sig}}</span>, where <span class="math">\\mathcal{A}</span> makes at most <span class="math">N_{H_c}</span> queries to <span class="math">H_c</span>, <span class="math">N_{H_e}</span> queries to <span class="math">H_e</span> and <span class="math">N_{\\mathrm{Sig}}</span> queries to the signing oracle on <span class="math">\\mathsf{vk}_N</span>. Recall that <span class="math">C</span> denotes the challenge space from <span class="math">\\mathsf{Sig}</span> (and the scalar space from <span class="math">\\mathsf{AggSig}</span>). Let <span class="math">\\mathcal{B}</span> be a second algorithm that is provided with some randomly chosen <span class="math">h_j, h&#x27;_j \\gets U(C)</span> for <span class="math">j \\in [N_q]</span>. For the random oracle <span class="math">H_c</span>, the algorithm <span class="math">\\mathcal{B}</span> maintains a table <span class="math">\\mathsf{HT}_c</span> which is empty at the beginning. Similarly, for the random oracle <span class="math">H_e</span>, a table <span class="math">\\mathsf{HT}_e</span> is maintained. Further <span class="math">\\mathcal{B}</span> stores two counters <span class="math">\\mathsf{ctr}_c</span> and <span class="math">\\mathsf{ctr}_e</span>, both initially set to 0.</p>

    <p class="text-gray-300">Setup. <span class="math">\\mathcal{B}</span> generates <span class="math">(\\mathsf{sk}_N, \\mathsf{vk}_N) \\gets \\mathsf{KGen}(1^\\lambda)</span> and sends <span class="math">\\mathsf{vk}_N</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Queries on <span class="math">H_c</span>. On input <span class="math">x = (\\mathbf{u}, \\mathbf{t}, m)</span>, if <span class="math">\\mathsf{HT}_c[x]</span> is already set, <span class="math">\\mathcal{B}</span> returns <span class="math">\\mathsf{HT}_c[x]</span>. Else, if <span class="math">\\mathbf{t} = \\mathbf{t}_N</span>, they increment <span class="math">\\mathsf{ctr}_c</span> and set <span class="math">\\mathsf{HT}_e[x] = h_{\\mathsf{ctr}_c}</span>. Else they sample <span class="math">\\mathsf{HT}_c[x] \\gets U(C)</span>. Finally, they output <span class="math">c = \\mathsf{HT}_e[x]</span>.</p>

    <p class="text-gray-300">Queries on <span class="math">H_e</span>. On input <span class="math">x = (c_1, \\ldots, c_N, j)</span> for some <span class="math">j \\in [N]</span>, if <span class="math">\\mathsf{HT}_e[x]</span> is already set, <span class="math">\\mathcal{B}</span> returns <span class="math">\\mathsf{HT}_e[x]</span>. Else, <span class="math">\\mathcal{B}</span> does the following. First, for all <span class="math">i \\in [N-1]</span>, they sample <span class="math">\\mathsf{HT}_e[x_i] \\gets U(C)</span> for <span class="math">x_i = (c_1, \\ldots, c_N, i)</span> (independently of <span class="math">j</span>). Only then, they increment <span class="math">\\mathsf{ctr}_c</span> and set <span class="math">\\mathsf{HT}_e[x_N] = h_{\\mathsf{ctr}_c}&#x27;</span> for <span class="math">x_N = (c_1, \\ldots, c_N, N)</span>. Finally, they output <span class="math">c = \\mathsf{HT}_c[x]</span> (where <span class="math">x = x_j</span> for some <span class="math">j</span>). The order is important here, as we use later that <span class="math">e_i</span> has been fixed before <span class="math">e_N</span> for all <span class="math">i \\in [N-1]</span> for a fixed tuple <span class="math">(c_1, \\ldots, c_N)</span>.</p>

    <p class="text-gray-300">Signing queries. <span class="math">\\mathcal{B}</span> follows the honest signing procedure <span class="math">\\mathrm{Sig}</span> from <span class="math">\\Pi_{AS}</span> for <span class="math">\\mathsf{sk}_N</span> on input message <span class="math">m</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Forgery. Suppose that <span class="math">\\mathcal{A}</span> outputs a forgery <span class="math">\\sigma_{agg} = ((\\mathbf{u}_j)_j, \\mathbf{z},)</span> on the message vector <span class="math">M = (m_j)_{j \\in [N]}</span> and the verification key vector <span class="math">\\mathsf{VK} = (\\mathsf{vk}_j)_{j \\in [N]}</span>. Without loss of generality we assume that <span class="math">\\mathsf{HT}_c</span> was programmed on <span class="math">x = (\\mathbf{u}_N, \\mathbf{t}_N, m_N)</span> and thus <span class="math">c_N = h_{j_f}</span> for some counter index <span class="math">j_f</span>. If not, <span class="math">\\mathcal{A}</span> would only have a probability of $1 - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to guess the correct </span>c_N<span class="math">. With the same argumentation, we assume that </span>\\mathsf{HT}_e<span class="math"> was programmed on </span>x = (c_1, \\ldots, c_N, N)<span class="math"> and thus </span>e_N = h_{j_f}'<span class="math"> for some counter index </span>j_f'<span class="math">. If </span>\\mathsf{AggVf}(\\mathsf{VK}, M, \\sigma_{agg}) = 1<span class="math">, then </span>\\mathcal{B}<span class="math"> outputs </span>(j_f', j_f, (\\mathsf{VK}, M, \\sigma_{agg}, \\mathbf{C}, \\mathbf{E}))<span class="math">, with </span>\\mathbf{C} = (c_j)_{j \\in [N]}<span class="math"> such that </span>c_j = H_c(\\mathbf{u}_j, \\mathbf{t}_j, m_j)<span class="math"> and </span>\\mathbf{E} = (e_j)_j<span class="math"> such that </span>e_j = H_e(c_1, \\ldots, c_N, j)<span class="math">. Else, </span>\\mathcal{B}<span class="math"> outputs </span>(0, 0, \\bot)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">j = 0,1,2</span>, let <span class="math">\\operatorname<em>{Pr}[G_j]</span> denote the probability that <span class="math">\\mathcal{B}</span> doesn't output <span class="math">(0,0,\\bot)</span> in game <span class="math">G_{j}</span>. It yields <span class="math">\\operatorname</em>{Pr}[G_0] = \\mathsf{Adv} \\mathsf{AggSig}_{\\mathcal{A}}</span>.</p>

    <p class="text-gray-300"><span class="math">G_{1}</span>: The game <span class="math">G_{1}</span> is identical to the previous game <span class="math">G_{0}</span> except that <span class="math">\\mathcal{B}</span> doesn't generate the signature honestly, but instead simulates the transcript without using the secret key <span class="math">\\mathsf{sk}_N</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Signing queries.</strong> On input message <span class="math">m</span>, <span class="math">\\mathcal{B}</span> samples <span class="math">c \\gets U(C)</span> and <span class="math">\\mathbf{z} \\gets D_s^{\\ell + k}</span>. They compute $\\mathbf{u} = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{z} - \\mathbf{t}_N \\cdot c<span class="math"> and program </span>c = \\mathsf{HT}_c[x]<span class="math"> with </span>x = (\\mathbf{u}, \\mathbf{t}_N, m)<span class="math"> afterwards. Finally, </span>\\mathcal{B}<span class="math"> outputs </span>\\sigma = (\\mathbf{u}, \\mathbf{z})<span class="math"> with probability </span>1 / M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Due to the rejection sampling, the distribution of <span class="math">\\mathbf{z}</span> is identical in both signing variants (see [Dam+21, Lem. 4] for more details). The only difference between the actual and the original signing algorithm is that now the output of <span class="math">H_{c}</span> is programmed at the end, without checking whether it has already been set for <span class="math">x</span>. Following the same argument as in [Lyu12, Lem. 5.3] this happens only with negligible probability and thus $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[G_1] - \\operatorname{Pr}[G_0]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">G_{2}</span>: The game <span class="math">G_{2}</span> is identical to the previous game <span class="math">G_{1}</span> except how <span class="math">\\mathcal{B}</span> generates the <span class="math">\\mathsf{vk}_N</span> during the setup phase.</p>

    <p class="text-gray-300"><strong>Setup.</strong> <span class="math">\\mathcal{B}</span> samples <span class="math">\\mathbf{t}_N \\gets U(R_q^k)</span>, sets <span class="math">\\mathsf{vk}_N = \\mathbf{t}_N</span> and outputs <span class="math">\\mathsf{vk}_N</span> to <span class="math">\\mathcal{A}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As the signing queries are answered without using the corresponding secret key <span class="math">\\mathsf{sk}_N</span>, <span class="math">\\mathcal{B}</span> can replace <span class="math">\\mathsf{vk}_N</span> by a random vector without <span class="math">\\mathcal{A}</span> noticing, assuming the hardness of M-LWE<span class="math">_{k,\\ell,\\beta}</span>. Thus $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[G_2] - \\operatorname{Pr}[G_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{Adv}_{\\mathrm{M - LWE}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the above, we obtain <span class="math">\\mathsf{Adv} \\mathsf{AggSig}_{\\mathcal{A}} \\leq \\operatorname{Pr}[G_2] + \\mathsf{Adv}_{\\mathrm{M - LWE}_{k,\\ell,\\beta}} + \\mathsf{negl}(\\lambda)</span>. Our aim for the reminder of the proof is to bound <span class="math">\\operatorname{Pr}[G_2]</span>. To do so, we apply twice the General Forking Lemma. Note that in game <span class="math">G_2</span> the matrix $\\mathbf{A}' = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_N]<span class="math"> follows the uniform distribution over </span>R_q^{k \\times (\\ell + 1)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>First Fork.</strong> We construct an algorithm <span class="math">\\mathcal{C}</span> around <span class="math">\\mathcal{B}</span> who invokes the General Forking Lemma (Lemma 1), where the input generator <span class="math">\\mathsf{IGen}</span> is defined to output <span class="math">\\mathbf{A}&#x27;</span>. Let <span class="math">\\mathsf{acc}_{\\mathcal{B}}</span> denote the accepting probability of <span class="math">\\mathcal{B}</span> and <span class="math">\\mathsf{frk}_{\\mathcal{B}}</span> the forking probability of <span class="math">\\mathsf{F}_{\\mathcal{B}}</span> as defined in Lemma 1. Further, set <span class="math">\\mathsf{out} = (j_f, \\mathsf{VK}, M, \\sigma_{agg}, \\mathbf{C}, \\mathbf{E})</span> and feed <span class="math">\\mathcal{B}</span> with the input coins <span class="math">h_1&#x27;, \\ldots, h_{N_q}&#x27;</span>. The fork happens with respect to the counter index from <span class="math">\\mathsf{ctr}_c</span>. Thus, the forking algorithm <span class="math">\\mathsf{F}_{\\mathcal{B}}</span> outputs with probability <span class="math">\\mathsf{frk}_{\\mathcal{B}}</span> two different outputs <span class="math">\\mathsf{out}, \\widetilde{\\mathsf{out}} \\neq (\\bot, \\bot)</span>, where $\\mathsf{acc}_{\\mathcal{B}} \\leq N_q /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sqrt{N_q \\cdot \\mathsf{frk}_{\\mathcal{B}}}<span class="math">. Let </span>\\mathsf{out} = (j_f, \\mathsf{VK}, M, \\sigma_{agg}, \\mathbf{C}, \\mathbf{E})<span class="math"> and </span>\\widetilde{\\mathsf{out}} = (\\tilde{j}_f, \\widetilde{\\mathsf{VK}}, \\tilde{M}, \\tilde{\\sigma}_{agg}, \\tilde{\\mathbf{C}}, \\tilde{\\mathbf{E}})<span class="math">. During the forking, neither </span>\\mathcal{B}<span class="math"> nor </span>\\mathcal{A}<span class="math"> is aware of being rewound. In particular, before arriving at the fork, they behave exactly the same in both executions. As the random coins of </span>\\mathcal{B}<span class="math"> are the same in both executions and as the simulation of </span>H_c<span class="math"> is for </span>j \\neq N<span class="math"> independent of the input </span>(h_j')_{j \\in [N_q]}<span class="math"> to </span>\\mathcal{B}<span class="math">, we have </span>\\mathbf{t}_j = \\tilde{\\mathbf{t}}_j<span class="math">, </span>\\mathbf{u}_j = \\tilde{\\mathbf{u}}_j<span class="math"> and </span>c_j = \\tilde{c}_j<span class="math"> for all </span>j \\in [N]<span class="math"> and </span>e_j = \\tilde{e}_j<span class="math"> for all </span>j \\in [N-1]<span class="math">. Further it yields </span>M = \\tilde{M}<span class="math">. As in both cases, the forgery passes validation, it yields </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\mathbf{z}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; B'<span class="math">. Additionally, </span>[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{z} = \\sum_{j \\in [N]} e_j (\\mathbf{t}_j \\cdot c_j + \\mathbf{u}_j)<span class="math"> and </span>[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\tilde{\\mathbf{z}} = \\sum_{j \\in [N]} \\tilde{e}_j (\\tilde{\\mathbf{t}}_j \\cdot \\tilde{c}_j + \\tilde{\\mathbf{u}}_j)$. Hence, we can deduce that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot (\\mathbf{z} - \\tilde{\\mathbf{z}}) = (e_N - \\tilde{e}_N)(\\mathbf{t}_N c_N + \\mathbf{u}_N). \\tag{1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that Equation 1 is not yet sufficient to extract a solution to M-SIS and we thus fork a second time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second Fork. We now construct another algorithm <span class="math">\\mathcal{D}</span> around <span class="math">\\mathcal{C}</span> who invokes the General Forking Lemma, where the input generator IGen is again defined to output <span class="math">\\mathbf{A}&#x27;</span>. Let <span class="math">\\mathsf{acc}_{\\mathcal{C}}</span> denote the accepting probability of <span class="math">\\mathcal{C}</span> and <span class="math">\\mathsf{frk}_{\\mathcal{C}}</span> the forking probability of <span class="math">\\mathsf{F}_{\\mathcal{C}}</span> as defined in Lemma 1. We observe that <span class="math">\\mathsf{acc}_{\\mathcal{C}} = \\mathsf{frk}_{\\mathcal{B}}</span>. Further, set <span class="math">\\mathsf{out} = (\\mathsf{VK}, M, \\sigma_{agg}, \\mathbf{C}, \\mathbf{E})</span> and feed <span class="math">\\mathcal{C}</span> with the input coins <span class="math">h_1, \\ldots, h_{N_q}</span>. This time, the fork is on the counter <span class="math">\\mathsf{ctr}_c</span>. Thus, the forking algorithm <span class="math">\\mathsf{F}_{\\mathcal{C}}</span> outputs with probability <span class="math">\\mathsf{frk}_{\\mathcal{C}}</span> two different outputs <span class="math">\\mathsf{out}, \\widetilde{\\mathsf{out}} \\neq (\\bot, \\bot)</span>, where $\\mathsf{acc}_{\\mathcal{C}} \\leq N_q /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sqrt{N_q \\cdot \\mathsf{frk}_{\\mathcal{C}}}<span class="math">. More precisely, let </span>\\mathsf{out} = (\\mathsf{VK}, M, \\sigma_{agg}, \\mathbf{C}, \\mathbf{E})<span class="math"> and </span>\\widetilde{\\mathsf{out}} = (\\widetilde{\\mathsf{VK}}, \\tilde{M}, \\tilde{\\sigma}_{agg}, \\tilde{\\mathbf{C}}, \\tilde{\\mathbf{E}})<span class="math">. With the same argumentation as above, we have </span>m_j = m_j'<span class="math">, </span>\\mathbf{u}_j = \\mathbf{u}_j'<span class="math"> and </span>\\mathbf{t}_j = \\mathbf{t}_j'<span class="math"> for all </span>j \\in [N]<span class="math"> and </span>c_j = c_j'<span class="math"> for all </span>j \\in [N-1]<span class="math">. Furthermore, we have </span>c_N \\neq c_N'$. We hence obtain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot (\\mathbf{z}' - \\tilde{\\mathbf{z}}') = (e_N' - \\tilde{e}_N') (\\mathbf{t}_N c_N' + \\mathbf{u}_N) \\tag{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Multiplying Equation 1 by <span class="math">\\varepsilon&#x27; := (e_N&#x27; - \\tilde{e}_N&#x27;)</span> and Equation 2 by <span class="math">\\varepsilon := (e_N - \\tilde{e}_N)</span> and then combining both, we obtain</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot (\\varepsilon' (\\mathbf{z} - \\tilde{\\mathbf{z}}) - \\varepsilon (\\mathbf{z}' - \\tilde{\\mathbf{z}}')) = \\varepsilon \\varepsilon' (\\mathbf{t}_N (c_N - c_N')). \\tag{3}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, <span class="math">\\mathcal{D}</span> can compute the vector <span class="math">\\mathbf{x} = (\\varepsilon&#x27;(\\mathbf{z} - \\tilde{\\mathbf{z}}) - \\varepsilon(\\mathbf{z}&#x27; - \\tilde{\\mathbf{z}}&#x27;), \\varepsilon \\varepsilon&#x27;(c_N&#x27; - c_N))^T</span> which is a solution to the M-SIS problem for the matrix $\\mathbf{A}' = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_N]<span class="math">. The Euclidean norm of the vector </span>\\mathbf{x}$ is bounded above by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq 4 \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon \\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 + 2 \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon^2 c \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq 4 \\cdot 4d \\cdot B' + 2 \\cdot 4d^{3/2} = b,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">B&#x27;</span> is the bound on <span class="math">\\mathbf{z}</span>. This implies that <span class="math">\\mathsf{frk}_{\\mathcal{C}} \\leq \\mathsf{Adv}_{\\mathrm{M-SIS}}</span>. Overall, we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[G_2] = \\mathsf{acc}_{\\mathcal{B}} \\leq \\frac{N_q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\sqrt{N_q \\cdot \\left(\\frac{N_q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\sqrt{N_q \\cdot \\mathsf{Adv}_{\\mathrm{M-SIS}_{k,\\ell+1,k}}}\\right)},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">completing the proof.</p>

    <p class="text-gray-300">Remark 3. Using twice the General Forking Lemma introduces two disadvantages: On the one hand, it causes an important loss in the reduction. On the other hand, we currently don't know how to extend it to the so-called quantum ROM, where an adversary has quantum access to the random oracle (and classical access to the signing oracle). Abdalla et al. [Abd+16] proposed a much tighter reduction for lattice-based signature schemes following the FSwA paradigm by introducing lossy identification schemes. Kiltz et al. [KLS18] used their techniques to construct a generic framework for tightly secure signatures in the quantum ROM. The key idea behind lossy identification schemes is that verification keys can be replaced by random, so-called lossy, keys. Then, using a lossy key, for a fixed commitment (in our scheme this is the vector <span class="math">\\mathbf{u}</span>) with overwhelming probability there exists at most one transcript that verifies. We leave it as an open problem to further investigate if those techniques can be applied to our aggregate signature scheme.</p>

    <p class="text-gray-300">4.3 Rogue-Attack Against the Simple Sum</p>

    <p class="text-gray-300">We just showed that the aggregate signature scheme <span class="math">\\Pi_{AS}</span> as presented in Section 3 is proven secure in the aggregate chosen-key model as introduced by Boneh et al. [Bon+03]. When aggregating, it is important to use random scalars for the sum. Instead of the simple (deterministic) sum, we hence obtain a (randomized) linear combination of the single signature parts <span class="math">\\mathbf{z}_j</span>.</p>

    <p class="text-gray-300">As we think this is important to understand this motivation, we now describe a simple attack if one uses only the simple sum (or a linear combination where the challenge space is too small, as done in the current version of MMSA(TK)), which was first observed by Zhao [Zha19] in the context of a Schnorr-based aggregate signature scheme on elliptic curves.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{t}_N</span> be the challenge key given to the adversary <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> generates the remaining key pairs <span class="math">(\\mathbf{s}_j, \\mathbf{t}_j) \\gets \\mathsf{KGen}</span> for <span class="math">j \\in [N-1]</span> and selects arbitrary messages <span class="math">m_j</span> for <span class="math">j \\in [N]</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. They sample <span class="math">\\mathbf{y}_N \\gets D</span>, set $\\mathbf{u}_N = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{y}_N<span class="math"> and query the random oracle to obtain </span>c_N = H_c(\\mathbf{u}_N, \\mathbf{t}_N, m_N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>They compute <span class="math">c_{N-1} = H_c(\\mathbf{u}_{N-1}, \\mathbf{t}_{N-1}, m_{N-1})</span>.</li>

      <li>They set <span class="math">\\mathbf{z}_{N-1} = \\mathbf{y}_{N-1} + \\mathbf{s}_{N-1} \\cdot c_{N-1}</span> and apply the rejection sampling in order to make the distribution of <span class="math">\\mathbf{z}_{N-1}</span> independent of <span class="math">\\mathbf{s}_{N-1}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. For the remaining <span class="math">j \\in [N-2]</span>, they follow the honest signature procedure: they sample <span class="math">\\mathbf{y}_j \\gets D</span>, set $\\mathbf{u}_j = [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{y}_j<span class="math">, compute </span>c_j = H_c(\\mathbf{u}_j, \\mathbf{t}_j, m_j)<span class="math"> and set </span>\\mathbf{z}_j = \\mathbf{s}_j \\cdot c_j + \\mathbf{y}_j<span class="math">. Then they apply the rejection sampling in order to make the distribution of </span>\\mathbf{z}_j<span class="math"> independent of </span>\\mathbf{s}_j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, they output the forgery <span class="math">\\sigma_{agg} = (\\hat{\\mathbf{u}}, (\\mathbf{u}_j)_j, \\mathbf{z})</span>, where <span class="math">\\hat{\\mathbf{u}} = \\sum_{j=1}^{N} \\mathbf{u}_j</span> and <span class="math">\\mathbf{z} = \\mathbf{y}_N + \\sum_{j=1}^{N-1} \\mathbf{z}_j</span>.</li>

    </ol>

    <p class="text-gray-300">We claim that the forgery passes verification. As all <span class="math">\\mathbf{z}_j \\sim D</span> and <span class="math">\\mathbf{y} \\sim D</span>, the norm of the sum <span class="math">\\mathbf{z}</span> is (with overwhelming probability) bounded above by <span class="math">N \\cdot B =: B&#x27;</span>. Further, it yields <span class="math">\\hat{\\mathbf{u}} = \\sum_{j} \\mathbf{u}_j</span>, as the <span class="math">\\mathbf{u}_j</span> are computed by honestly compressing</p>

    <p class="text-gray-300">9 For the deterministic sum, one can only show security in a much more restricted security model where the adversary has to commit themselves to the signatures they will use in the aggregate signature scheme before receiving the challenge key. More details can be found in an older version of this e-print (8 Apr 2021).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the corresponding <span class="math">\\mathbf{u}_j</span>. It remains to show that $[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{z} = \\sum_{j=1}^{N} (\\mathbf{t}_j \\cdot c_j) + \\hat{\\mathbf{u}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{z} &amp;= [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{y}_N + \\sum_{j=1}^{N-1} [\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{z}_j \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp;= \\mathbf{u}_N + \\mathbf{u}_{N-1} + \\mathbf{t}_N \\cdot c_N + \\mathbf{t}_{N-1} \\cdot c_{N-1} + \\sum_{j=1}^{N-2} \\mathbf{t}_j \\cdot c_j + \\mathbf{u}_j \\\\ &amp;= \\sum_{j=1}^{N} \\mathbf{t}_j \\cdot c_j + \\hat{\\mathbf{u}}, \\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we used that $[\\mathbf{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}_k] \\cdot \\mathbf{y}_{N-1} = \\mathbf{u}_{N-1} + \\mathbf{t}_N \\cdot c_N<span class="math">. In this attack the adversary exploits the fact that they can define a rogue-commitment with respect to the challenge </span>c_N<span class="math">. In our security model, this is prevented as the adversary has to fix the signatures they are going to use in the forgery before receiving the challenge key </span>\\mathbf{t}_N$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-16" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This work was supported by the European Union PROMETHEUS project (Horizon 2020 Research and Innovation Program, grant 780701). It has also received a French government support managed by the National Research Agency in the "Investing for the Future" program, under the national project RISQ P141580-2660001 / DOS0044216. Katharina Boudgoust was funded by the Direction Générale de l'Armement (Pôle de Recherche CYBER). We warmly thank Akira Takahashi for making us aware of the attacks against Schnorr-based aggregate signatures in the chosen-key model and discussions with him and Claudio Orlandi. We also would like to thank Olivier Sanders for an interesting exchange regarding the security proof. Lastly, we also would like to thank Thomas Prest who explained us his attack on the linear compression function used in an earlier version of this paper.</p>

    <h2 id="sec-17" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">[Abd+16] Michel Abdalla et al. "Tightly Secure Signatures From Lossy Identification Schemes". In: <em>J. Cryptol.</em> 29.3 (2016), pp. 597-631.</p>

    <p class="text-gray-300">[BN06] Mihir Bellare and Gregory Neven. "Multi-signatures in the plain public-Key model and a general forking lemma". In: <em>CCS</em>. ACM, 2006, pp. 390-399.</p>

    <p class="text-gray-300">[Bon+03] Dan Boneh et al. "Aggregate and Verifiably Encrypted Signatures from Bilinear Maps". In: <em>EUROCRYPT</em>. Vol. 2656. Lecture Notes in Computer Science. Springer, 2003, pp. 416-432.</p>

    <p class="text-gray-300">[Bou+20] Katharina Boudgoust et al. "Towards Classical Hardness of Module-LWE: The Linear Rank Case". In: ASIACRyPT (2). Vol. 12492. Lecture Notes in Computer Science. Springer, 2020, pp. 289-317. [BS16] Rachid El Bansarkhani and Jan Sturm. "An Efficient Lattice-Based Multisignature Scheme with Applications to Bitcoins". In: CANS. Vol. 10052. Lecture Notes in Computer Science. 2016, pp. 140-155. [CDW21] Ronald Cramer, Léo Ducas, and Benjamin Wesolowski. "Mildly Short Vectors in Cyclotomic Ideal Lattices in Quantum Polynomial Time". In: J. ACM 68.2 (2021), 8:1-8:26. [Cha+21] Konstantinos Chalkias et al. "Non-interactive Half-Aggregation of EdDSA and Variants of Schnorr Signatures". In: CT-RSA. Vol. 12704. Lecture Notes in Computer Science. Springer, 2021, pp. 577-608. [Dam+21] Ivan Damgård et al. "Two-Round n-out-of-n and Multi-signatures and Trapdoor Commitment from Lattices". In: Public Key Cryptography (1). Vol. 12710. Lecture Notes in Computer Science. Springer, 2021, pp. 99-130. [Dor+20] Yarkin Doroz et al. "MMSAT: A Scheme for Multimessage Multiuser Signature Aggregation". In: IACR Cryptol. ePrint Arch. (2020), p. 520. [Duc+18] Léo Ducas et al. "CRYSTALS-Dilithium: A Lattice-Based Digital Signature Scheme". In: IACR Trans. Cryptogr. Hardw. Embed. Syst. 2018.1 (2018), pp. 238-268. [GLP12] Tim Güneysu, Vadim Lyubashevsky, and Thomas Pöppelmann. "Practical Lattice-Based Cryptography: A Signature Scheme for Embedded Systems". In: CHES. Vol. 7428. Lecture Notes in Computer Science. Springer, 2012, pp. 530-547. [Hof+14] Jeffrey Hoffstein et al. "Practical Signatures from the Partial Fourier Recovery Problem". In: ACNS. Vol. 8479. Lecture Notes in Computer Science. Springer, 2014, pp. 476-493. [KLS18] Eike Kiltz, Vadim Lyubashevsky, and Christian Schaffner. “A Concrete Treatment of Fiat-Shamir Signatures in the Quantum Random-Oracle Model”. In: EUROCRYPT (3). Vol. 10822. Lecture Notes in Computer Science. Springer, 2018, pp. 552–586. [LS15] Adeline Langlois and Damien Stehlé. "Worst-case to average-case reductions for module lattices". In: Des. Codes Cryptogr. 75.3 (2015), pp. 565-599. [Lyu09] Vadim Lyubashevsky. "Fiat-Shamir with Aborts: Applications to Lattice and Factoring-Based Signatures". In: ASIACRyPT. Vol. 5912. Lecture Notes in Computer Science. Springer, 2009, pp. 598-616. [Lyu12] Vadim Lyubashevsky. “Lattice Signatures without Trapdoors”. In: EUROCRYPT. Vol. 7237. Lecture Notes in Computer Science. Springer, 2012, pp. 738-755. [Max+19] Gregory Maxwell et al. "Simple Schnorr multi-signatures with applications to Bitcoin". In: Des. Codes Cryptogr. 87.9 (2019), pp. 2139-2164.</p>

    <p class="text-gray-300">[Sch91] Claus-Peter Schnorr. "Efficient Signature Generation by Smart Cards". In: J. Cryptol. 4.3 (1991), pp. 161–174.</p>

    <p class="text-gray-300">[Zha19] Yunlei Zhao. "Practical Aggregate Signature from General Elliptic Curves, and Applications to Blockchain". In: AsiaCCS. ACM, 2019, pp. 529–538.</p>`;
---

<BaseLayout title="Non-Interactive Half-Aggregate Signatures Based on Module La... (2021/263)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/263
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
