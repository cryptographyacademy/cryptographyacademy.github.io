---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/132';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
---

<BaseLayout title="On Small Characteristic Algebraic Tori in Pairing-Based Cryptography (2004/132)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        On Small Characteristic Algebraic Tori in Pairing-Based Cryptography
      </h1>
      <p class="text-gray-400 mb-2">
        R.  Granger, D.  Page, M.  Stam
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; Full Version &middot; eprint 2004/132
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
        &middot; 269s on modal (Tesla T4)
        &middot; sha256:f5965c55b3e54985...
      </p>
    </header>

    <section class="paper-content">
      <p class="text-gray-300">R. Granger, D. Page and M. Stam</p>
      <p class="text-gray-300">University of Bristol, Department of Computer Science, Merchant Venturers Building, Woodland Road, Bristol, BS8 1UB, UK. &#123;granger,page,stam&#125;@cs.bris.ac.uk</p>
      <p class="text-gray-300"><strong>Abstract.</strong> The output of the Tate pairing on an elliptic curve over a finite field may be viewed as an element of an algebraic torus. Using this simple observation, we transfer techniques recently developed for torus-based cryptography to pairing-based cryptography, resulting in more efficient computations, and lower bandwidth requirements. To illustrate the efficacy of this approach, we apply the method to pairings on supersingular elliptic curves in characteristic three.</p>
      <h2 id="1-introduction" class="text-2xl font-bold mt-10 mb-4">1 Introduction</h2>
      <p class="text-gray-300">The use of pairings in cryptography is now a well-studied area, with resulting applications to identity-based encryption, key-agreement and signature schemes [5, 42], tripartite Diffie-Hellman key-agreement [28], and short signatures [6], to name just a few amongst numerous others (see e.g. [12] for a recent survey).</p>
      <p class="text-gray-300">To support these applications much research activity has focused on developing efficient and easily implementable algorithms for their deployment [2, 17, 13]. Currently the fastest algorithm for pairing computation on elliptic curves is that of Duursma and Lee [13], which applies to the class of supersingular elliptic curves in characteristic three with so-called embedding degree six, and is preferable in pairing implementations for contemporary cryptographic schemes.</p>
      <p class="text-gray-300">One is therefore free to use the trace-based methods found in LUC [47] and XTR [31] for post-pairing arithmetic [52], resulting in the compression of pairing outputs by a factor of two and three respectively. Scott and Barreto [44] also describe the use of traces for the computation of the pairing itself, however closer inspection of their work shows that their claim is misleading. Indeed, their method is essentially a polynomial basis transformation and hence does not offer any advantages during the computation of the pairing. Moreover, for characteristic three, we demonstrate that contrary to the claims of Scott and Barreto [44], the performance of their approach is inferior to a straightforward implementation. Thus besides pairing compression, the method they advocate does not seem to offer any benefits.</p>
      <p class="text-gray-300">Our contribution is to achieve both efficient pairing arithmetic, and also pairing compression. Our methods are based on the simple observation that</p>
      <p class="text-gray-300">the quotient group to which the natural output of the Tate pairing belongs, may be viewed as a special representation of an algebraic torus. These groups were introduced to cryptography by Rubin and Silverberg [40], who showed under certain conditions that one can represent elements of the torus via rational embeddings into affine space, providing smaller bandwidth requirements than the corresponding field-embedded representation.</p>
      <p class="text-gray-300">Using this property and an efficient point multiplication method developed for tori [25], we are able to perform arithmetic with pairing values that is on average 30% faster than previous methods. This is useful, for example, in pairing-based protocols where one typically blinds a point by an ephemeral random value. By bilinearity, this blinding may be performed either on the curve before the pairing evaluation, or in the extension field afterwards. Given that a pairing evaluation is usually several times more costly than either a point multiplication on the curve or an exponentiation in the field, if a pairing value ever needs to be reused, it is beneficial to compute it once and for all and to perform each ephemeral blinding in the extension field.</p>
      <p class="text-gray-300">Examples where this occurs include the Boneh-Franklin identity-based encryption scheme [5], the identity-based signature scheme of Hess [27], and the certificate-based encryption scheme of Gentry [21].</p>
      <p class="text-gray-300">The aforementioned compression methods can also be used during any interactive pairing-based protocol where pairing values are transmitted between parties. Such schemes include the selective-ID identity-based encryption scheme of Boneh and Boyen [3], the interactive proof of knowledge in the short group signature scheme of Boneh <em>et al.</em> [4], and various others [22, 43].</p>
      <p class="text-gray-300">One may regard our methods as a characteristic three version of previous work on tori [40,25] tailored for pairings. However they may also be used for pairings on any abelian variety possessing an even embedding degree, which for efficiency reasons is the case for all contemporary pairing algorithms. As such they may also be applied to supersingular binary elliptic curves, although we do not pursue this application here since pairings based on these curves possess an inferior security/efficiency trade-off [16].</p>
      <p class="text-gray-300">The remainder of the article is organised as follows. We next give some background on the Tate pairing and algebraic tori. In §3 we develop fast arithmetic for pairing values, and in §4 we give algorithms for efficient exponentiation. In §5, we describe the field representation we use, while in §6 we detail our improvements to the Duursma-Lee algorithm. In §7, we present implementation results, and in the final section, we make some concluding remarks and present some open problems.</p>
      <h2 id="2-preliminaries" class="text-2xl font-bold mt-10 mb-4">2 Preliminaries</h2>
      <p class="text-gray-300">In this section we briefly provide some mathematical background, and fix some notation.</p>
      <h4 id="2-1-the-tate-pairing" class="text-lg font-semibold mt-6 mb-2">2.1 The Tate Pairing</h4>
      <p class="text-gray-300">The Tate pairing on an elliptic curve is usually computed using a variant of Miller's algorithm [34]. For the special curves often used in cryptography however, it was shown independently by Barreto et al. [2] and Galbraith et al. [17] that much of the computation of the algorithm is redundant. In terms of performance, the former paper provides the better alternative, and we refer to their algorithm as the reduced Tate pairing, or the BKLS algorithm.</p>
      <p class="text-gray-300">The reduced Tate pairing. Let E be an elliptic curve over a finite field  <span class="math">\mathbb&#123;F&#125;_q</span> , and let  <span class="math">\mathcal&#123;O&#125;_E</span>  denote the identity element of the associated group of rational points on  <span class="math">E(\mathbb&#123;F&#125;_q)</span> . For a positive integer  <span class="math">l \mid \#E(\mathbb&#123;F&#125;_q)</span>  coprime to q, let  <span class="math">\mathbb&#123;F&#125;_&#123;q^k&#125;</span>  be the smallest extension field of  <span class="math">\mathbb&#123;F&#125;_q</span>  which contains the l-th roots of unity in  <span class="math">\overline&#123;\mathbb&#123;F&#125;&#125;_q</span> . Also, let  <span class="math">E(\mathbb&#123;F&#125;_q)[l]</span>  denote the subgroup of  <span class="math">E(\mathbb&#123;F&#125;_q)</span>  of all points of order dividing l, and similarly for the degree k extension of  <span class="math">\mathbb&#123;F&#125;_q</span> . From an efficiency perspective, k is usually chosen to be even [2]. For a thorough treatment of the following, we refer the reader to [2] and also [17], and to [46] for an introduction to divisors. Then assuming that  <span class="math">l^3 \nmid \#E(\mathbb&#123;F&#125;_&#123;q^k&#125;)</span> , the reduced Tate pairing of order l is the map</p>
      <div class="math-block">e_l: E(\mathbb&#123;F&#125;_q)[l] \times E(\mathbb&#123;F&#125;_&#123;q^k&#125;)[l] \to \mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;/(\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;)^l,</div>
      <p class="text-gray-300">given by  <span class="math">e_l(P,Q) = f_&#123;P,l&#125;(\mathcal&#123;D&#125;)</span> . Here  <span class="math">f_&#123;P,l&#125;</span>  is a function on E whose divisor is equivalent to  <span class="math">l(P) - l(\mathcal&#123;O&#125;_E)</span> ,  <span class="math">\mathcal&#123;D&#125;</span>  is a divisor equivalent to  <span class="math">(Q) - (\mathcal&#123;O&#125;_E)</span> , whose support is disjoint from the support of  <span class="math">f_&#123;P,l&#125;</span> , and  <span class="math">f_&#123;P,l&#125;(\mathcal&#123;D&#125;) = \prod_i f_&#123;P,l&#125;(P_i)^&#123;a_i&#125;</span> , where  <span class="math">\mathcal&#123;D&#125; = \sum_i a_i P_i</span> . It satisfies the following properties ([15]):</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>For each  <span class="math">P \neq \mathcal&#123;O&#125;_E</span>  there exists  <span class="math">Q \in E(\mathbb&#123;F&#125;_&#123;q^k&#125;)[l]</span>  such that  <span class="math">e_l(P,Q) \neq 1 \in \mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;/(\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;)^l</span>  (non-degeneracy);</li>
        <li>For any integer n,  <span class="math">e_l([n]P,Q) = e_l(P,[n]Q) = e_l(P,Q)^n</span>  for all  <span class="math">P \in E(\mathbb&#123;F&#125;_q)[l]</span>  and  <span class="math">Q \in E(\mathbb&#123;F&#125;_&#123;q^k&#125;)[l]</span>  (bilinearity);</li>
        <li>Let L = hl. Then  <span class="math">e_l(P,Q)^&#123;(q^k-1)/l&#125; = e_L(P,Q)^&#123;(q^k-1)/L&#125;</span> .</li>
      </ul>
      <p class="text-gray-300">When one computes  <span class="math">f_&#123;P,l&#125;(\mathcal&#123;D&#125;)</span> , the value obtained belongs to the quotient group  <span class="math">\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;/(\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;)^l</span> , and not  <span class="math">\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;</span> . In this quotient, for a and b in  <span class="math">\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;</span> ,  <span class="math">a \sim b</span>  if and only if there exists  <span class="math">c \in \mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;</span>  such that  <span class="math">a = bc^l</span> . Clearly, this is equivalent to</p>
      <div class="math-block">a \sim b</div>
      <p class="text-gray-300">if and only if  <span class="math">a^&#123;(q^k-1)/l&#125; = b^&#123;(q^k-1)/l&#125;</span> ,</p>
      <p class="text-gray-300">and hence one ordinarily uses this value as the canonical representative of each coset. The isomorphism between  <span class="math">\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;/(\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;)^l</span>  and the elements of order l in  <span class="math">\mathbb&#123;F&#125;_&#123;q^k&#125;^&#123;\times&#125;</span>  given by this exponentiation makes it possible to compute  <span class="math">f_&#123;P,l&#125;(Q)</span>  rather than  <span class="math">f_&#123;P,l&#125;(\mathcal&#123;D&#125;)</span>  [2]. It also removes the need to compute the costly denominators in Miller's algorithm.</p>
      <p class="text-gray-300">Fig. 1. Field definitions and Curve equations</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Field</td><td class="border border-gray-700 px-3 py-1">Field Polynomial</td><td class="border border-gray-700 px-3 py-1"><span class="math">\operatorname&#123;Curve&#125;</span></td><td class="border border-gray-700 px-3 py-1">Order</td><td class="border border-gray-700 px-3 py-1">MOV security</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;79&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1">0 10 12</td><td class="border border-gray-700 px-3 py-1"><span class="math">Y^2 = X^3 - X - 1</span></td><td class="border border-gray-700 px-3 py-1">0 10 1-</td><td class="border border-gray-700 px-3 py-1">750</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;97&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">(3^&#123;97&#125; + 3^&#123;49&#125; + 1)/7</span></td><td class="border border-gray-700 px-3 py-1">906</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;163&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">Y^2 = X^3 - X - 1</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">1548</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;193&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">t^&#123;193&#125; + t^&#123;12&#125; + 2</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">Y^2 = X^3 - X - 1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">3^&#123;193&#125; - 3^&#123;97&#125; + 1</span></td><td class="border border-gray-700 px-3 py-1">1830</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;239&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1">0 10 1 =</td><td class="border border-gray-700 px-3 py-1"><span class="math">Y^2 = X^3 - X - 1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">3^&#123;239&#125; - 3^&#123;120&#125; + 1</span></td><td class="border border-gray-700 px-3 py-1">2268</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;353&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">t^&#123;353&#125; + t^&#123;142&#125; + 2</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">Y^2 = X^3 - X - 1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">3^&#123;353&#125; + 3^&#123;177&#125; + 1</span></td><td class="border border-gray-700 px-3 py-1">3354</td></tr>
      </tbody></table></div>
      <p class="text-gray-300">The modified Tate pairing. At Asiacrypt 2003, Duursma and Lee introduced an algorithm for pairing computation on a special family of supersingular hyperelliptic curves [13]. In common with the authors of [44], for the elliptic case, which occurs only in characteristic three, we refer to the algorithm as the <em>modified</em> Tate pairing. In Figure 1, we list a sample of curves from this family, upon which we base our implementation.</p>
      <p class="text-gray-300">The first column gives the field over which each curve is defined, and the second lists the corresponding irreducible polynomials defining the field extensions. The third lists the curve equations and the fourth gives the order of the subgroup used. The final column gives the bit-length of the smallest finite field into which the pairing value embeds, which is a degree six extension for these curves. These parameter values were generated simply by testing which prime extension degrees yielded orders for supersingular curves that are prime, or almost prime, i.e., those possessing a small cofactor.</p>
      <p class="text-gray-300">The modified Tate pairing improves upon the reduced variant in three ways. Firstly, using the third property listed above, instead of computing the Tate pairing of order l, one uses the pairing of order  <span class="math">q^3 + 1</span> , which eliminates the need for any point additions in Miller's algorithm. Secondly, while this apparently increases the trit-length of the exponent by a factor of three, Duursma and Lee show that the divisor computed when processing three trits at a time has a very simple form, and hence no losses are incurred. Lastly, they provide a closed form expression for the pairing, thus simplifying implementations.</p>
      <p class="text-gray-300">We give a full description of the Duursma-Lee algorithm in §6, where we also make some elementary computational improvements.</p>
      <h4 id="2-2-algebraic-tori" class="text-lg font-semibold mt-6 mb-2">2.2 Algebraic Tori</h4>
      <p class="text-gray-300">In 1985 El-Gamal made the suggestion that Diffie-Hellman key exchange, digital signatures and El-Gamal encryption be performed in the multiplicative group of an extension of  <span class="math">\mathbb&#123;F&#125;_p</span>  [14], although without going into details. Recent trends in cryptographic research have shown that by exploiting the algebraic structure not available in prime fields, one can obtain compression of elements and efficient arithmetic.</p>
      <p class="text-gray-300">Due to the observation of Pohlig and Hellman [37], one typically works in a prime order subgroup of sufficient size in the multiplicative group of the extension field. To ensure that a particular subgroup does not embed into any subfield of the extension field, it must belong to the cyclotomic subgroup [30], which conjecturally attains the discrete logarithm security of the extension field. The public key cryptosystem XTR [31] exploits compression of elements in the cyclotomic subgroup of  <span class="math">\mathbb&#123;F&#125;_&#123;p^6&#125;^&#123;\times&#125;</span>  by taking their trace with respect to the quadratic subfield, to obtain a compression factor of three.</p>
      <p class="text-gray-300">Based on similar ideas, Rubin and Silverberg [40] proposed the notion of torus-based cryptography as an alternative way to obtain compression of elements in the cyclotomic subgroup of a suitable field extension, which is isomorphic to an algebraic torus (cf. Lemma 1). The public key system CEILIDH proposed in that paper is based on the torus  <span class="math">T_6</span> . This torus has the property that it is birationally isomorphic to two dimensional affine space, which means that its elements can be parametrised via rational functions by only two elements of the base field, rather than the six elements ordinarily required.</p>
      <p class="text-gray-300">It was also shown in [40] that efforts to find a natural extension of the tracebased method of XTR using symmetric functions [7], can not work. It is an open conjecture whether or not  <span class="math">T_n</span>  is 'rational' for all n, in which case one could efficiently compress elements of  <span class="math">T_n</span>  by a factor of  <span class="math">n/\phi(n)</span>  [53,40]. This conjecture is known to be true when n is either a prime power, or the product of two prime powers. However, for the applications that concern us here, the status of the conjecture is unlikely to have any impact, as we explain in §6.</p>
      <p class="text-gray-300">The torus  <span class="math">T_n(\mathbb&#123;F&#125;_q)</span> . Let  <span class="math">\mathbb&#123;F&#125;_q</span>  be a finite field where q is a power of a prime, and let  <span class="math">\Phi_n</span>  be the n-th cyclotomic polynomial. We write  <span class="math">G_&#123;q,n&#125;</span>  for the subgroup of  <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125;^&#123;\times&#125;</span>  of order  <span class="math">\Phi_n(q)</span> , and let  <span class="math">\mathbb&#123;A&#125;^n(\mathbb&#123;F&#125;_q)</span>  denote the n-dimensional affine space over  <span class="math">\mathbb&#123;F&#125;_q</span> , i.e., the variety whose points lie in  <span class="math">\mathbb&#123;F&#125;_q^n</span> .</p>
      <p class="text-gray-300"><strong>Definition 1.</strong> Let  <span class="math">k = \mathbb&#123;F&#125;_q</span>  and  <span class="math">L = \mathbb&#123;F&#125;_&#123;q^n&#125;</span> . The torus  <span class="math">T_n</span>  is the intersection of the kernels of the norm maps  <span class="math">N_&#123;L/F&#125;</span> , for all subfields  <span class="math">k \subset F \subsetneq L</span> :</p>
      <div class="math-block">T_n(k) := \bigcap_&#123;k \subset F \subsetneq L&#125; \operatorname&#123;Ker&#125;[N_&#123;L/F&#125;].</div>
      <p class="text-gray-300">The following lemma provides some relevant properties of  <span class="math">T_n</span>  [40]:</p>
      <p class="text-gray-300"><strong>Lemma 1.</strong> 1.  <span class="math">T_n(\mathbb&#123;F&#125;_q) \cong G_&#123;q,n&#125;</span> , and thus  <span class="math">\#T_n(\mathbb&#123;F&#125;_q) = \Phi_n(q)</span> ; 2. If  <span class="math">h \in T_n(\mathbb&#123;F&#125;_q)</span>  is an element of prime order not dividing n, then h does not lie in a proper subfield of  <span class="math">\mathbb&#123;F&#125;_&#123;q^n&#125;/\mathbb&#123;F&#125;_q</span> .</p>
      <h2 id="3-the-quotient-group" class="text-2xl font-bold mt-10 mb-4">3 The Quotient Group</h2>
      <p class="text-gray-300">Throughout this section and the remainder of the paper we assume we are working in characteristic three fields with prime extension degree (though the ideas</p>
      <p class="text-gray-300">apply equally well to arbitrary finite fields) and so where relevant, all exponents are written in ternary.</p>
      <p class="text-gray-300">Let  <span class="math">l \mid \#E(\mathbb&#123;F&#125;_q)</span>  and suppose we wish to compute the modified Tate pairing of order l. Then invoking the third property of §2.1, one uses the Duursma-Lee algorithm to first compute  <span class="math">e_&#123;q^3+1&#125;</span> , which is an element in the quotient group</p>
      <div class="math-block">\mathcal&#123;G&#125; = \mathbb&#123;F&#125;_&#123;q^6&#125;^&#123;\times&#125; / (\mathbb&#123;F&#125;_&#123;q^6&#125;^&#123;\times&#125;)^&#123;q^3+1&#125;.</div>
      <p class="text-gray-300">For any  <span class="math">a\in\mathbb&#123;F&#125;_&#123;q^6&#125;^&#123;\times&#125;</span>  we have  <span class="math">a^&#123;q^3+1&#125;\in\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span> , and so  <span class="math">\mathcal G</span>  simplifies to  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;^&#123;\times&#125;/\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span> .</p>
      <p class="text-gray-300">Let  <span class="math">G_l \subset \mathbb&#123;F&#125;_&#123;q^6&#125;^&#123;\times&#125;</span>  denote the subgroup of order l, and let  <span class="math">e \in \mathcal&#123;G&#125;</span> . Then the two properties:</p>
      <div class="math-block">\gcd(l, q^3 - 1) = 1 \text&#123; and &#125; e^&#123;q^3 - 1&#125; \in G_l</div>
      <p class="text-gray-300">imply that e = gh for some  <span class="math">g \in G_l</span> ,  <span class="math">h \in \mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span> . Hence powering e by  <span class="math">q^3 - 1</span>  gives</p>
      <div class="math-block">e^&#123;q^3-1&#125; = (qh)^&#123;q^3-1&#125; = q^&#123;q^3-1&#125;</div>
      <p class="text-gray-300">which can then be used in protocols. If a particular protocol requires an exponentiation of this value by some integer  <span class="math">k \mod l</span> , this is performed in  <span class="math">\mathbb&#123;F&#125;_&#123;g^6&#125;</span> .</p>
      <p class="text-gray-300">In this section we give an alternative way to obtain unique representatives of  <span class="math">\mathcal&#123;G&#125;</span>  easily, that furthermore permits fast multiplication, and provides automatic compression by a factor of two. We then show that the natural embedding of  <span class="math">\mathcal&#123;G&#125;</span>  into the extension field is just a special representation of an algebraic torus, which permits further compression.</p>
      <h4 id="3-1-the-basic-idea" class="text-lg font-semibold mt-6 mb-2">3.1 The Basic Idea</h4>
      <p class="text-gray-300">Let  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125; = \mathbb&#123;F&#125;_&#123;q^3&#125;[\sigma]/(\sigma^2 + 1)</span>  which is the extension we use in the Duursma-Lee algorithm. Writing  <span class="math">e = e_0 + e_1 \sigma</span>  and  <span class="math">g = g_0 + g_1 \sigma</span> , by the above we have</p>
      <div class="math-block">e = gh = g_0h + g_1h\sigma.</div>
      <p class="text-gray-300">Since the represented coset remains invariant under multiplication by elements of  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span> , we can divide by  <span class="math">e_1</span> , giving</p>
      <div class="math-block">e' = ee_1^&#123;-1&#125; = e_0/e_1 + \sigma = g_0/g_1 + \sigma.</div>
      <p class="text-gray-300">This also eliminates h and may equally well be used as a canonical representative of the coset to which e belongs.</p>
      <p class="text-gray-300">This element of the quotient group can be represented simply by the  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span>  element  <span class="math">e_0/e_1</span> , and thus compresses the coset representation by a factor of two Computationally, this involves a division in  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span> .</p>
      <p class="text-gray-300">Comparing this to powering by  <span class="math">q^3 - 1</span> , the saving is not significant, since:</p>
      <div class="math-block">e^&#123;q^3 - 1&#125; = \frac&#123;e_0 - e_1 \sigma&#125;&#123;e_0 + e_1 \sigma&#125;,</div>
      <p class="text-gray-300">and hence requires only a division in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span> .</p>
      <p class="text-gray-300">However if one exponentiates this value by some integer  <span class="math">k \mod l</span> , this operation will be faster than if one had first powered e by  <span class="math">q^3 - 1</span> , since multiplying a generic element of  <span class="math">\mathcal&#123;G&#125;</span>  by this element is cheaper than multiplying two generic elements. To see this let  <span class="math">g = g_0/g_1 = e_0/e_1</span>  and  <span class="math">a_0 + a_1\sigma \in \mathcal&#123;G&#125;</span> . Then</p>
      <div class="math-block">(g+\sigma)(a_0+a_1\sigma)=(ga_0-a_1)+(ga_1+a_0)\sigma,</div>
      <p class="text-gray-300">which costs just two  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span>  multiplications, and not the three required if both elements are generic, in which case the arithmetic is identical to that of  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span> . If one assumes cubings and additions are essentially free, then this method will always be roughly one third faster, for whatever practical method one uses to exponentiate. The defining property of the quotient group  <span class="math">\mathcal&#123;G&#125;</span>  thus reduces the cost of arithmetic performed on pairing values.</p>
      <h4 id="3-2-arithmetic-in-span-class-math-mathcal-123-g-125-span" class="text-lg font-semibold mt-6 mb-2">3.2 Arithmetic in <span class="math">\mathcal&#123;G&#125;</span></h4>
      <p class="text-gray-300">We first introduce some terminology to clarify the operations available in  <span class="math">\mathcal&#123;G&#125;</span> . The property that a given coset is invariant under multiplication by elements of  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span>  is suggestive of the projective line</p>
      <div class="math-block">\mathbb&#123;P&#125;^1(\mathbb&#123;F&#125;_&#123;q^3&#125;)=\&#123;(x,y)/\sim\in(\mathbb&#123;F&#125;_&#123;q^3&#125;)^2\setminus\&#123;(0,0)\&#125;\&#125;</div>
      <p class="text-gray-300">where  <span class="math">(x_1, y_1) \sim (x_2, y_2)</span>  if and only if a  <span class="math">\lambda \in \mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span>  exists such that  <span class="math">(x_1, y_1) = (\lambda x_2, \lambda y_2)</span> . The reduction of e to  <span class="math">e_0/e_1</span>  may also be viewed as a map to the affine line  <span class="math">\mathbb&#123;A&#125;^1(\mathbb&#123;F&#125;_&#123;q^3&#125;)</span> . With this analogy we introduce the following.</p>
      <p class="text-gray-300"><strong>Definition 2.</strong>  <span class="math">\mathcal&#123;G&#125;_P</span>  is the projective line  <span class="math">\mathbb&#123;P&#125;^1(\mathbb&#123;F&#125;_&#123;q^3&#125;)</span>  endowed with the group operation induced by the arithmetic of the quadratic extension  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125; = \mathbb&#123;F&#125;_&#123;q^3&#125;[\sigma]/(\sigma^2 + 1)</span>  via the map  <span class="math">(x,y) \to x + y\sigma</span> . The identity element is represented by the points  <span class="math">(\lambda,0)</span>  for any  <span class="math">\lambda \in \mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span> .</p>
      <p class="text-gray-300"><span class="math">\mathcal&#123;G&#125;_A</span>  is the affine part of the line  <span class="math">\mathcal&#123;G&#125;_P</span> . The affine point corresponding to (x,y) is X = A(x,y) = (x/y). Via this map the identity element is the point at infinity which we denote by  <span class="math">\mathcal&#123;O&#125;_G</span> .</p>
      <p class="text-gray-300">With this terminology it should be clear that we can mimic mixed addition methods for point multiplication on elliptic curves [9]. The use of signed digit representations follows since inverses are cheap as we show below. In §4 we derive an exponentiation algorithm using a split exponent method.</p>
      <p class="text-gray-300">Let  <span class="math">P=(x,y)\in\mathcal&#123;G&#125;_P</span>  with corresponding affine representation  <span class="math">(X)\in\mathcal&#123;G&#125;_A</span> . We refer to the generator of  <span class="math">\mathrm&#123;Gal&#125;(\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_q)</span>  as the q-Frobenius, i.e., the automorphism given by powering by q. As already stated computing the inverse of an element is virtually free. This follows since the order of  <span class="math">\mathcal&#123;G&#125;</span>  is  <span class="math">|\mathbb&#123;F&#125;_&#123;q^6&#125;^&#123;\times&#125;/\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;|=(q^6-1)/(q^3-1)=q^3+1</span> , and so applying the cube of the Frobenius gives the inverse:  <span class="math">P^&#123;-1&#125;=(x,-y)</span>  or (-X) in affine. Cubing is also straightforward since we are working in characteristic three:  <span class="math">P^3=(x^3,-y^3)</span> .</p>
      <p class="text-gray-300">For multiplication of two points  <span class="math">P_1 = (x_1, y_1), P_2 = (x_2, y_2) \in \mathcal&#123;G&#125;_P</span>  with affine representations  <span class="math">(X_1), (X_2) \in \mathcal&#123;G&#125;_A</span> , we use the following easy lemma.</p>
      <p class="text-gray-300"><strong>Lemma 2.</strong> Let M and I represent the cost of a multiplication and inversion respectively in  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span> . Then the group operation for combinations of point representations is computed as follows:</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">P_1</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">P_2</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">P_1 \cdot P_2</span></td><td class="border border-gray-700 px-3 py-1">Formula</td><td class="border border-gray-700 px-3 py-1">Cost</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(X_1X_2-1)/(X_1+X_2)</span></td><td class="border border-gray-700 px-3 py-1">2M + I</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">&#123;\cal G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(X_1X_2-1,X_1+X_2)</span></td><td class="border border-gray-700 px-3 py-1">1M</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(x_1x_2-y_1y_2)/(x_1y_2+x_2y_1)</span></td><td class="border border-gray-700 px-3 py-1">4M + I</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(x_1x_2-y_1y_2,x_1y_2+x_2y_1)</span></td><td class="border border-gray-700 px-3 py-1">3M</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">&#123;\cal G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(X_1x_2-y_2)/(X_1y_2+x_2)</span></td><td class="border border-gray-700 px-3 py-1">3M + I</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_A</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathcal&#123;G&#125;_P</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">(X_1x_2 - y_2, X_1y_2 + x_2)</span></td><td class="border border-gray-700 px-3 py-1">2M</td></tr>
      </tbody></table></div>
      <p class="text-gray-300">Squaring can naturally be performed with slightly fewer  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span>  muliplications than above; the corresponding formulae are easily deduced. Besides the precomputation necessary for the exponentiation algorithms we present in Section 4 however, squarings are not required.</p>
      <p class="text-gray-300">With regard to exponentiations, it is clear that the mixed multiplication shown in the final row is the most efficient. If we want to compute  <span class="math">P^k</span>  for some  <span class="math">k \mod l</span> , we first convert P to affine and for each non-zero trit in the expansion of k perform a mixed multiplication of this point with the projective representation of the intermediate value. A multiplication with both points in projective form is equivalent to an ordinary multiplication in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span> , so the mixed multiplication is essentially what allows the savings over arithmetic in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span> . We exploit these observations in the exponentiation algorithms developed in §4.</p>
      <h2 id="3-3-an-equivalent-representation-of-the-quotient-group" class="text-2xl font-bold mt-10 mb-4">3.3 An Equivalent Representation of the Quotient Group</h2>
      <p class="text-gray-300">The arithmetic just described for the quotient group is essentially identical to that developed for the torus  <span class="math">T_2</span>  [25, 40]. Indeed it is not difficult to see that  <span class="math">\mathcal&#123;G&#125; = T_2(\mathbb&#123;F&#125;_&#123;q^3&#125;)</span> .</p>
      <p class="text-gray-300">Given  <span class="math">e \in \mathcal&#123;G&#125;</span> , it is possible to compute the embedding  <span class="math">e^&#123;q^3&#125;/e</span>  of e into  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  and maintain invariance under multiplication by elements of  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span> . This may seem odd since  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  does not possess this property. However our choice of representation of elements in the subgroup of order  <span class="math">q^3 + 1</span>  makes this possible. Again let  <span class="math">e = e_0 + e_1 \sigma</span> . Then</p>
      <div class="math-block">e^&#123;q^3&#125; = e_0 - e_1 \sigma,</div>
      <p class="text-gray-300">and hence</p>
      <div class="math-block">e^&#123;q^3 - 1&#125; = \frac&#123;e_0 - e_1 \sigma&#125;&#123;e_0 + e_1 \sigma&#125; \in G_l \subset \mathbb&#123;F&#125;_&#123;q^6&#125;. \tag&#123;1&#125;</div>
      <p class="text-gray-300">One can perform this division in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  and use the ordinary polynomial representation. Here we choose to leave this fraction unevaluated. Note that multipliying the numerator and denominator of (1) by any element of  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;^&#123;\times&#125;</span>  leaves the represented element unchanged.</p>
      <p class="text-gray-300">An interesting property of this representation is that when multiplying two fractions of this form, the coefficients of the numerator and the denominator</p>
      <p class="text-gray-300">correspond exactly: let</p>
      <div class="math-block">c = \frac&#123;c_0 - c_1 \sigma&#125;&#123;c_0 + c_1 \sigma&#125;, d = \frac&#123;d_0 - d_1 \sigma&#125;&#123;d_0 + d_1 \sigma&#125;,</div>
      <p class="text-gray-300">with  <span class="math">c_i, d_i \in \mathbb&#123;F&#125;_&#123;q^3&#125;</span> . Then since  <span class="math">\sigma^2 + 1 = 0</span> , we see that</p>
      <div class="math-block">cd = \frac&#123;(c_0d_0 - c_1d_1) - (c_0d_1 + c_1d_0)\sigma&#125;&#123;(c_0d_0 - c_1d_1) + (c_0d_1 + c_1d_0)\sigma&#125;</div>
      <p class="text-gray-300">This also follows trivially from the fact that  <span class="math">(cd)^&#123;q^3-1&#125; = c^&#123;q^3-1&#125; \cdot d^&#123;q^3-1&#125;</span> .</p>
      <p class="text-gray-300">For an implementation this allows one therefore to work with the denominator only, since one knows that the coefficients of the numerator will be identical. Hence one may view our previous operations in  <span class="math">\mathcal&#123;G&#125;</span>  without powering equivalently as operating purely on the denominator of (1) after powering, and so all the arithmetic carries over unchanged.</p>
      <p class="text-gray-300">Remark 1. The representation (1) and its identification with  <span class="math">\mathbb&#123;P&#125;^1</span>  were given explicitly by Rubin and Silverberg [40]. However the arithmetical consequences of embedding this representation into the extension field were only fully considered in [25], where it was also noted that one may also represent  <span class="math">T_2</span>  as a quotient group. Thus while these ideas are not new (the representation (1) is a simple application of Hilbert's Theorem 90), they find a novel application in pairing-based cryptography.</p>
      <h2 id="3-4-further-compression-using-span-class-math-t-6-mathbb-123-f-125-q-span" class="text-2xl font-bold mt-10 mb-4">3.4 Further Compression Using <span class="math">T_6(\mathbb&#123;F&#125;_q)</span></h2>
      <p class="text-gray-300">Since the characteristic three supersingular elliptic curves we consider have embedding degree six, one may ask why we use the arithmetic of  <span class="math">T_2(\mathbb&#123;F&#125;_&#123;q^3&#125;)</span>  when the order l subgroup is in fact in  <span class="math">T_6(\mathbb&#123;F&#125;_q)</span> ? The reason is that there seems no obvious way to utilise the extra structure provided by  <span class="math">T_6(\mathbb&#123;F&#125;_q)</span>  [25], though we do not rule out such a possibility. However we know that  <span class="math">|T_6(\mathbb&#123;F&#125;_q)| = (q^2 - q + 1) |</span>   <span class="math">(q^3 + 1) = |T_2(\mathbb&#123;F&#125;_&#123;q^3&#125;)|</span> , and so  <span class="math">T_6(\mathbb&#123;F&#125;_q) \subset T_2(\mathbb&#123;F&#125;_&#123;q^3&#125;)</span> . Thus one can use the properties of the latter and apply them to the former, utilising the improvements derived over the extension field representation.</p>
      <p class="text-gray-300">While arithmetic improvements do not seem available with  <span class="math">T_6</span> , one can exploit it for better compression. As  <span class="math">T_6</span>  is rational, one can map nearly all its elements to the affine plane and use this representation instead for data transmissions.</p>
      <p class="text-gray-300">Using the method described by Rubin and Silverberg [40], and thanks to some serendipitous equations for characteristic three and the given field representation, one obtains this additional compression for free.</p>
      <p class="text-gray-300">By Definition 1,</p>
      <div class="math-block">T_6(\mathbb&#123;F&#125;_q) = \operatorname&#123;Ker&#125;(N_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^3&#125;&#125;) \cap \operatorname&#123;Ker&#125;(N_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^2&#125;&#125;) = T_2(\mathbb&#123;F&#125;_&#123;q^3&#125;) \cap \operatorname&#123;Ker&#125;(N_&#123;\mathbb&#123;F&#125;_&#123;q^6&#125;/\mathbb&#123;F&#125;_&#123;q^2&#125;&#125;).</div>
      <p class="text-gray-300">To obtain a suitable representation one therefore only needs to parametrise those elements of the form (1) which have norm equal to one in the second factor.</p>
      <p class="text-gray-300">Let  <span class="math">e=(a-\sigma)/(a+\sigma)</span>  be the compressed representation for e, and let  <span class="math">a=a_0+a_1\rho+a_2\rho^2</span>  where  <span class="math">\rho^3-\rho\pm 1=0</span>  defines the cubic extension we later use for the Duursma-Lee algorithm. Then we obtain an equation in  <span class="math">a_0,a_1</span> , and  <span class="math">a_2</span>  by the condition</p>
      <p class="text-gray-300"><span class="math">\left(\frac&#123;a-\sigma&#125;&#123;a+\sigma&#125;\right)^&#123;1+q^2+q^4&#125; = 1.</span></p>
      <p class="text-gray-300">This is equivalent to  <span class="math">1+a_1^2-a_0a_2-a_2^2=0</span> , which one can parametrise easily with just  <span class="math">a_1</span>  and  <span class="math">a_2</span> , since  <span class="math">a_0=(1+a_1^2-a_2^2)/a_2</span> . It is therefore sufficient to specify only  <span class="math">a_1</span>  and  <span class="math">a_2</span> , to describe all points on  <span class="math">T_6(\mathbb&#123;F&#125;_q)</span>  bar the identity, and this is essentially all that we need. We therefore have a map  <span class="math">\psi: \mathbb&#123;A&#125;^2(\mathbb&#123;F&#125;_q) \setminus \&#123;(a_1,0)\&#125; \to T_6(\mathbb&#123;F&#125;_q) \setminus \&#123;1\&#125;</span>  given by</p>
      <p class="text-gray-300"><span class="math">\psi(a_1, a_2) = \frac&#123;((1 + a_1^2 - a_2^2) + a_1 a_2 \rho + a_2^2 \rho^2) - a_2 \sigma&#125;&#123;((1 + a_1^2 - a_2^2) + a_1 a_2 \rho + a_2^2 \rho^2) + a_2 \sigma&#125;.</span></p>
      <p class="text-gray-300">The inverse map  <span class="math">\psi^&#123;-1&#125;: T_6(\mathbb&#123;F&#125;_q) \setminus \&#123;1\&#125; \to \mathbb&#123;A&#125;^2(\mathbb&#123;F&#125;_q) \setminus \&#123;(a_1, 0)\&#125;</span>  is given as above, i.e., we just take the second and third coefficients in the fractional expression for e.</p>
      <p class="text-gray-300">Note that  <span class="math">\mathbb&#123;A&#125;^2(\mathbb&#123;F&#125;_q) \setminus \&#123;(a_1,0)\&#125;</span>  and  <span class="math">T_6(\mathbb&#123;F&#125;_q) \setminus \&#123;1\&#125;</span>  both have cardinality  <span class="math">q^2 - q</span> . In terms of the quotient group  <span class="math">\mathcal&#123;G&#125;</span>  and an actual pairing computation, once  <span class="math">e_0/e_1</span>  is computed one can use the second and third coefficients to parametrise the element, without any further computation.</p>
      <p class="text-gray-300">Remark 2. In the context of compression, Rubin and Silverberg [39,41] have shown how one can compress BLS short-signatures [6] by using the trace-zero subvariety contained in the Weil restriction of scalars of an elliptic curve defined over a composite field extension. This method provides a compression factor of  <span class="math">n/\phi(n)</span>  also, where  <span class="math">\gcd(n,2)=1</span> , and can be applied to any pairing-based protocol where one is required to transmit a point on the curve, such as [28]. However for  <span class="math">n \geq 5</span> , building upon an idea of Semaev [45], Gaudry has shown that such curves are weaker than those defined over prime field [20]. Hence this method should be regarded with some caution. We point out that this form of pre-compression is distinct from the post-compression described here, and thus these attacks do not apply.</p>
      <h2 id="4-exponentiation" class="text-2xl font-bold mt-10 mb-4">4 Exponentiation</h2>
      <p class="text-gray-300">Now that we have set up the basic arithmetic for  <span class="math">\mathcal&#123;G&#125;</span> , we explore how one can optimise the basic operation of exponentiation in practice. For comparison, we also describe fast algorithms for exponentation in  <span class="math">G_l</span>  using techniques from [49], and point multiplication in  <span class="math">E(\mathbb&#123;F&#125;_q)</span> , incorporating a novel technique we develop here.</p>
      <p class="text-gray-300">For ease of notation we write the group operation for all three groups multiplicatively, and for each of the above we compare four exponentiation methods, which we detail in turn. The input to each algorithm is a base e and an integer  <span class="math">k \mod l</span>  in standard ternary format. The output is  <span class="math">e^k</span> . When applicable, precomputed values are stored in affine to facilitate the mixed multiplication. We note</p>
      <p class="text-gray-300">that in all three groups inversions are essentially for free, so we consider signed digit representations.</p>
      <h4 id="method-1-signed-ternary-expansion" class="text-lg font-semibold mt-6 mb-2">Method 1: Signed Ternary Expansion</h4>
      <p class="text-gray-300">Using the generalised non-adjacent form, or G-NAF [8], one can take the ternary expansion of an exponent  <span class="math">k \mod l</span>  and transform it into an equivalent signed ternary representation. Such a representation is easy to compute and reduces the average density of non-zero trits from two thirds to one half. The precomputation involves just a single squaring of the base.</p>
      <h2 id="method-2-signed-nonary-expansion" class="text-2xl font-bold mt-10 mb-4">Method 2: Signed Nonary Expansion</h2>
      <p class="text-gray-300">This is the same as Method 1 except we use a base nine expansion of k. This essentially halves the trit-length of k for the cost of precomputing  <span class="math">e^i</span> , i = 1, ..., 8. Again using the G-NAF, the average density of non-zero 'nits' in this expansion is four fifths.</p>
      <h2 id="method-3-sliding-window-ternary-expansion" class="text-2xl font-bold mt-10 mb-4">Method 3: Sliding Window Ternary Expansion</h2>
      <p class="text-gray-300">We use an unsigned ternary expansion of k with a sliding window of width three [33][Chapter 14, Algorithm 14.85]. To do so one needs to precompute and store  <span class="math">e^i</span>  for 0 &lt; i &lt; 27 and  <span class="math">i \neq 0 \mod 3</span> .</p>
      <h4 id="method-4-frobenius-expansion" class="text-lg font-semibold mt-6 mb-2">Method 4: Frobenius Expansion</h4>
      <p class="text-gray-300">For  <span class="math">e \in \mathcal&#123;G&#125;</span>  the q-Frobenius map is easily computed. Moreover, the q-th power of a compressed element is itself compressed. Since the Frobenius map satisfies  <span class="math">q^2 - q + 1 = 0</span>  (as maps) and the group order divides  <span class="math">q^2 - q + 1</span> , one can split the exponent k in two halves  <span class="math">k_1</span>  and  <span class="math">k_2</span>  where  <span class="math">k_1, k_2</span>  are approximately half the trit-length of l and satisfy  <span class="math">k \equiv k_1 + k_2 q \mod l</span>  [49]. One can find  <span class="math">k_1</span>  and  <span class="math">k_2</span>  very quickly having performed a one-time Gaussian two dimensional lattice basis reduction.</p>
      <p class="text-gray-300">Thus a single exponentiation can be transformed into a double exponentiation for half the trit-length of k, for the cost of performing a double exponentiation instead. To compute  <span class="math">e^k</span>  for a random  <span class="math">k \mod l</span> , we perform the double exponentiation  <span class="math">e^&#123;k_1&#125;(e^q)^&#123;k_2&#125;</span>  using Shamir's trick, originally due to Straus [51]. We detail the required precomputation in the next section.</p>
      <p class="text-gray-300">For each of  <span class="math">k_1, k_2</span>  we invoke the G-NAF. The average density of non-zero trits in each of their ternary expansions is 1/2 and hence the average number of non-zero trits in the paired ternary expansion of  <span class="math">k_1, k_2</span>  is  <span class="math">1 - (1/2)^2 = 3/4</span> . We therefore expect to perform on average  <span class="math">(3/4) \cdot m/2 = (3/8)m</span>  multiplications of mixed type during an exponentiation.</p>
      <p class="text-gray-300">Interestingly enough, this method also works for the elliptic curve. Clearly, one can use the same expansion of k on  <span class="math">E(\mathbb&#123;F&#125;_q)</span> , with powering by q is replaced by scalar multiplication by q. Somewhat surprisingly, on the curve also,</p>
      <p class="text-gray-300">multiplication by q is an efficiently computable automorphism since  <span class="math">[q]P = (x - (m \mod 3)b, -y)</span>  for P = (x, y) on the curve (where the curve equation is  <span class="math">Y^2 = X^3 - X + b</span> ). Thus we arrive at a novel application of the Gallant-Lambert-Vanstone exponent split method using fast automorphisms [18].</p>
      <p class="text-gray-300">We note that for supersingular curves over characteristic three there is also an efficient scalar multiplication algorithm due to Koblitz [29] based on the curve automorphism mapping the point (x, y) to  <span class="math">(x^3, y^3)</span> .</p>
      <h4 id="4-1-precomputation" class="text-lg font-semibold mt-6 mb-2">4.1 Precomputation</h4>
      <p class="text-gray-300">The necessary precomputation for Methods 1, 2 and 3 is straightforward. For Method 4 we can take advantage of the q-Frobenius to reduce the cost. We use the notation of  <span class="math">\mathcal&#123;G&#125;</span> . Let  <span class="math">e = e_0 + e_1 \sigma</span> . In order to use Shamir's trick, we need to know the values</p>
      <div class="math-block">(e_0/e_1 + \sigma)^&#123;i+qj&#125;</div>
      <p class="text-gray-300"><span class="math">i, j \in \&#123;0, \pm 1, \pm 2\&#125;</span>  (2)</p>
      <p class="text-gray-300">in affine. Let (i,j) represent the corresponding term in (2). Then we can use the fact that for any  <span class="math">e \in \mathcal&#123;G&#125;</span> , we have  <span class="math">e^&#123;q^2-q+1&#125; = \mathcal&#123;O&#125;_&#123;\mathcal&#123;G&#125;&#125;</span>  to generate most of the required terms easily. To achieve this, one applies the q-Frobenius iteratively to obtain  <span class="math">(i,j)^q = (-j,i+j)</span> . We list these operations in Algorithm 1. In  <span class="math">G_l</span>  we use the same method, having first powered e by  <span class="math">q^3 - 1</span> , but clearly without needing to obtain affine representatives.</p>
      <h2 id="4-2-comparison-with-trace-based-exponentiation" class="text-2xl font-bold mt-10 mb-4">4.2 Comparison with Trace-Based Exponentiation</h2>
      <p class="text-gray-300">The cost of a mixed multiplication in  <span class="math">\mathcal&#123;G&#125;</span>  is 12M. Since  <span class="math">l \approx 3^m</span> , an exponentiation using Method 4 costs on average about 4.5mM. This improves considerably on the 12mM required by the trace method of [44]. Even without mixed multiplication, this exponentiation still only requires 6.75mM, and with neither the exponent splitting nor the mixed multiplication, this cost is only about 9mM. Hence ordinary field arithmetic outperforms the proposed trace method, which in fact can be reduced further to about 10.3mM using a Euclidean algorithm [50], but is still over twice as slow.</p>
      <h3 id="4-3-application-to-other-pairings" class="text-xl font-semibold mt-8 mb-3">4.3 Application to Other Pairings</h3>
      <p class="text-gray-300">We have focused primarily on small characteristic tori because the Duursma-Lee algorithm is currently the most efficient for pairing computation. In the future, the preferred embedding degree of a curve will increase in order to maintain a good security/efficiency trade-off, and thus it is likely that non-supersingular curves over large characteristic fields will be used.</p>
      <p class="text-gray-300">Since the embedding degree n of a pairing on a given abelian variety is minimal, the output of any pairing may be considered an element of the torus  <span class="math">T_n</span> . Hence all of the techniques developed for torus-based cryptography may be applied, certainly for any embedding degree less than thirty.</p>
      <h2 id="algorithm-1-online-pre-computation-for-double-exponentiation" class="text-2xl font-bold mt-10 mb-4">Algorithm 1: Online Pre-computation for Double Exponentiation</h2>
      <p class="text-gray-300"><strong>input</strong> :  <span class="math">e = e_0 + e_1 \sigma \in \mathcal&#123;G&#125;</span></p>
      <p class="text-gray-300"><strong>output</strong>: Representatives in  <span class="math">\mathcal&#123;G&#125;_A</span>  of</p>
      <div class="math-block">(i,j) := (e_0 + e_1 \sigma)^&#123;i+jq&#125;, \quad i,j \in \&#123;0,\pm 1,\pm 2\&#125;</div>
      <div class="math-block">(1,0) \leftarrow A(e)</div>
      <div class="math-block">(0,1) \leftarrow -(1,0)^q</div>
      <div class="math-block">(-1,1) \leftarrow -(0,1)^q</div>
      <div class="math-block">(-1,0) \leftarrow -(-1,1)^q</div>
      <div class="math-block">(0,-1) \leftarrow -(-1,0)^q</div>
      <p class="text-gray-300"><span class="math">(1,-1) \leftarrow -(0,-1)^q</span></p>
      <div class="math-block">(2,0) \leftarrow \text&#123;mul&#125;((1,0),(1,0))</div>
      <div class="math-block">(2,0) \leftarrow \text&#123;mul&#125;((1,0),(2,0))</div>
      <div class="math-block">(0,2) \leftarrow -(2,0)^q</div>
      <div class="math-block">(-2,2) \leftarrow -(0,2)^q</div>
      <div class="math-block">(-2,0) \leftarrow -(-2,2)^q</div>
      <div class="math-block">(0,-2) \leftarrow -(-2,0)^q</div>
      <div class="math-block">(2,-2) \leftarrow -(0,-2)^q</div>
      <div class="math-block">(1,1) \leftarrow \text&#123;mul&#125;((1,0),(0,1))</div>
      <div class="math-block">(1,1) \leftarrow A((1,1))</div>
      <div class="math-block">(-1,2) \leftarrow -(1,1)^q</div>
      <div class="math-block">(-2,1) \leftarrow -(-1,2)^q</div>
      <div class="math-block">(-1,-1) \leftarrow -(-2,1)^q</div>
      <div class="math-block">(1,-2) \leftarrow -(-1,-1)^q</div>
      <div class="math-block">(2,-1) \leftarrow -(1,-2)^q</div>
      <div class="math-block">(1,2) \leftarrow \text&#123;mul&#125;((1,0),(0,2))</div>
      <div class="math-block">(1,2) \leftarrow A((1,2))</div>
      <div class="math-block">(-1,-2) \leftarrow -(1,2)</div>
      <div class="math-block">(2,1) \leftarrow \text&#123;mul&#125;((2,0),(0,1))</div>
      <div class="math-block">(2,1) \leftarrow A((2,1))</div>
      <div class="math-block">(-2,-1) \leftarrow -(2,1)</div>
      <div class="math-block">(2,2) \leftarrow \text&#123;mul&#125;((2,0),(0,2))</div>
      <div class="math-block">(2,2) \leftarrow A((2,2))</div>
      <div class="math-block">(-2, -2) \leftarrow -(2, 2)</div>
      <p class="text-gray-300">However, earlier work [25] shows that for large characteristic, the trace-based methods such as LUC [47] (for degree two extensions), and XTR [31,50] (for degree six extensions), are slightly faster than the torus approach. For the near future however, our methods are likely to remain near-optimal.</p>
      <h2 id="5-field-representation" class="text-2xl font-bold mt-10 mb-4">5 Field Representation</h2>
      <p class="text-gray-300">We briefly describe efficient arithmetic for  <span class="math">\mathbb&#123;F&#125;_q</span>  and the required extensions.</p>
      <h3 id="field-arithmetic-in-span-class-math-mathbb-123-f-125-q-span" class="text-xl font-semibold mt-8 mb-3">Field Arithmetic in <span class="math">\mathbb&#123;F&#125;_q</span></h3>
      <p class="text-gray-300">Let  <span class="math">\mathbb&#123;F&#125;_q = \mathbb&#123;F&#125;_&#123;3^m&#125;</span> . Let  <span class="math">a = a_&#123;m-1&#125;x^&#123;m-1&#125; + \cdots + a_1x + a_0</span>  be an element of  <span class="math">\mathbb&#123;F&#125;_q</span> , held in a polynomial basis, so that  <span class="math">a_i \in \mathbb&#123;F&#125;_3</span> . We follow other work [17, 26] and represent the element a as two bit-vectors  <span class="math">a_H</span>  and  <span class="math">a_L</span> . If we let  <span class="math">a_H[i]</span>  and  <span class="math">a_L[i]</span>  denote bit i of  <span class="math">a_H</span>  and  <span class="math">a_L</span>  respectively, the vectors  <span class="math">a_H</span>  and  <span class="math">a_L</span>  are constructed from a such that for all i</p>
      <div class="math-block">a_H[i] = a_i \text&#123; div &#125; 2</div>
      <div class="math-block">a_L[i] = a_i \text&#123; mod &#125; 2</div>
      <p class="text-gray-300">That is,  <span class="math">a_H</span>  and  <span class="math">a_L</span>  are a bit-sliced representation of the coefficients of a where  <span class="math">a_H</span>  holds the high bit and  <span class="math">a_L</span>  the low bit of a given coefficient. Given a representation of this type, we can perform a component-wise addition  <span class="math">r_i = a_i + b_i</span>  of two elements a and b using the following word-wise logical operations</p>
      <div class="math-block">r_H[i] = (a_L[i] \lor b_L[i]) \oplus t</div>
      <div class="math-block">r_L[i] = (a_H[i] \lor b_H[i]) \oplus t</div>
      <p class="text-gray-300">where</p>
      <div class="math-block">t = (a_L[i] \vee b_H[i]) \oplus (a_H[i] \vee b_L[i]).</div>
      <p class="text-gray-300">Subtraction, and hence multiplication by two, are equally efficient since the negation of an element a simply swaps the vectors  <span class="math">a_H</span>  and  <span class="math">a_L</span>  over and can therefore be implemented by the same function as addition.</p>
      <p class="text-gray-300">On a given computer with word-size w, we hold the bit-vectors  <span class="math">a_H</span>  and  <span class="math">a_L</span>  that represent a as two word-vectors of length  <span class="math">n = \lceil m/w \rceil</span>  and hence apply logical operations in parallel to w coefficients at a time. However, since our representation remains bit-oriented we can borrow further techniques developed for fields of characteristic two. Specifically, it is possible to construct multiplication using a variation of the often cited comb method [32] and inversion by altering the binary extended Euclidean algorithm. We used a Karatsuba method to aggressively split the multiplication operands into word sized chunks, an option that provided significant performance improvements. Unlike elements in characteristic two, squaring in characteristic three is only marginally less expensive than general multiplication. However, cubing can be performed very quickly using table-lookup in an analogous way to the so called <em>coefficient thinning</em> method in characteristic two.</p>
      <h2 id="field-arithmetic-in-span-class-math-mathbb-123-f-125-123-a-3-125-span" class="text-2xl font-bold mt-10 mb-4">Field Arithmetic in <span class="math">\mathbb&#123;F&#125;_&#123;a^3&#125;</span></h2>
      <p class="text-gray-300">Let  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125; = \mathbb&#123;F&#125;_q[\rho]/(\rho^3 - \rho - b)</span> , with  <span class="math">b = \pm 1</span>  depending on the curve equation. Let  <span class="math">a = a_0 + a_1\rho + a_2\rho^2</span>  and  <span class="math">b = b_0 + b_1\rho + b_2\rho^2</span>  be two generic elements. We require the following operations.</p>
      <p class="text-gray-300"><strong>q-Frobenius:</strong> Since  <span class="math">\rho^3 = \rho + b</span>  we have  <span class="math">\rho^&#123;3^m&#125; = \rho + (m \mod 3)b</span>  and  <span class="math">(\rho^2)^&#123;3^m&#125; = (\rho^&#123;3^m&#125;)^2 = \rho^2 + 2b(m \mod 3)\rho + (m^2 \mod 3)</span> . Hence  <span class="math">a^&#123;3^m&#125; = (a_0 + a_1\rho + a_2\rho^2)^&#123;3^m&#125; = (a_0 + a_1b(m \mod 3) + a_2b) + (a_1 - a_2b(m \mod 3))\rho + a_2\rho^2</span> .</p>
      <p class="text-gray-300"><strong>Multiplication:</strong> Let  <span class="math">t_&#123;00&#125; = a_0 b_0</span> ,  <span class="math">t_&#123;11&#125; = a_1 b_1</span> ,  <span class="math">t_&#123;22&#125; = a_2 b_2</span> ,  <span class="math">t_&#123;01&#125; = (a_0 + a_1)(b_0 + b_1)</span> ,  <span class="math">t_&#123;12&#125; = (a_1 + a_2)(b_1 + b_2)</span> , and  <span class="math">t_&#123;20&#125; = (a_2 + a_0)(b_2 + b_0)</span> . Then  <span class="math">ab = (t_&#123;00&#125; + (t_&#123;12&#125; - t_&#123;11&#125; - t_&#123;22&#125;)b) + (t_&#123;01&#125; - t_&#123;00&#125; + t_&#123;11&#125; + t_&#123;12&#125; + t_&#123;22&#125;(b - 1))\rho + (t_&#123;20&#125; - t_&#123;00&#125; + t_&#123;11&#125;)\rho^2</span> .</p>
      <p class="text-gray-300"><strong>Cubing:</strong> This is straightforward in characteristic three. Since  <span class="math">a^3 = (a_0^3 + a_2^3 + a_1^3 b) + (a_1^3 - a_2^3 b)\rho + a_2^3 \rho^2</span> .</p>
      <p class="text-gray-300"><strong>Inversion:</strong> Since the extension degree is small, we can perform this directly. Let  <span class="math">t_&#123;00&#125;=a_0^2,\ t_&#123;11&#125;=a_1^2,\ t_&#123;22&#125;=a_2^2,\ t_&#123;01&#125;=a_0a_1,\ t_&#123;12&#125;=a_1a_2,\ t_&#123;20&#125;=a_2a_0,</span>  and let  <span class="math">\Delta=a_0^3+a_1^3b+a_2^3+t_&#123;20&#125;(a_2-a_0)-a_1(t_&#123;01&#125;+t_&#123;22&#125;b).</span>  Then  <span class="math">a^&#123;-1&#125;=\Delta^&#123;-1&#125;((t_&#123;00&#125;-t_&#123;20&#125;+t_&#123;22&#125;-t_&#123;11&#125;-t_&#123;12&#125;b)+(t_&#123;22&#125;b-t_&#123;01&#125;)\rho+(t_&#123;11&#125;-t_&#123;20&#125;-t_&#123;22&#125;)\rho^2).</span></p>
      <h2 id="field-arithmetic-in-span-class-math-mathbb-123-f-125-123-q-6-125-span" class="text-2xl font-bold mt-10 mb-4">Field Arithmetic in <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span></h2>
      <p class="text-gray-300">Let  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125; = \mathbb&#123;F&#125;_&#123;q^3&#125;[\sigma]/(\sigma^2 + 1)</span> . Let  <span class="math">c = c_0 + c_1\sigma</span>  and  <span class="math">d = d_0 + d_1\sigma</span>  with  <span class="math">c_i, d_i \in \mathbb&#123;F&#125;_&#123;q^3&#125;</span>  be two generic elements. The arithmetic is as follows.</p>
      <p class="text-gray-300"><strong>q-Frobenius:</strong> Since  <span class="math">\sigma^2 = -1</span> , we have that  <span class="math">\sigma^3 = -\sigma</span>  and as m is odd, we obtain  <span class="math">c^&#123;3^m&#125; = c_0^&#123;3^m&#125; - c_1^&#123;3^m&#125; \sigma</span> .</p>
      <p class="text-gray-300"><strong>Multiplication:</strong> Let  <span class="math">t_&#123;00&#125; = c_0 d_0</span> ,  <span class="math">t_&#123;11&#125; = c_1 d_1</span> , and  <span class="math">t_&#123;01&#125; = (c_0 + c_1)(d_0 + d_1)</span> . Then  <span class="math">cd = (t_&#123;00&#125; - t_&#123;11&#125;) + (t_&#123;01&#125; - t_&#123;00&#125; - t_&#123;11&#125;)\sigma</span> .</p>
      <p class="text-gray-300"><strong>Cubing:</strong>  <span class="math">c^3 = c_0^3 - c_1^3 \sigma</span> .</p>
      <p class="text-gray-300"><strong>Inversion:</strong> Let  <span class="math">\Delta = c_0^2 + c_1^2</span> . Then  <span class="math">c^&#123;-1&#125; = \Delta^&#123;-1&#125;(c_0 - c_1\sigma)</span> .</p>
      <h2 id="6-the-modified-tate-pairing-algorithm" class="text-2xl font-bold mt-10 mb-4">6 The Modified Tate Pairing Algorithm</h2>
      <p class="text-gray-300">In this section we detail how to efficiently implement the Duursma-Lee algorithm for the computation of the modified Tate pairing.</p>
      <p class="text-gray-300">Let  <span class="math">P=(x_1,y_1)</span>  and  <span class="math">Q=(x_2,y_2)</span>  be points of order l. Then the modified Tate pairing on the supersingular curve  <span class="math">E(\mathbb&#123;F&#125;_q): Y^2=X^3-X+b</span>  is the mapping  <span class="math">f_P(\phi(Q))^&#123;q^3-1&#125;</span>  where  <span class="math">\phi: E(\mathbb&#123;F&#125;_q) \to E(\mathbb&#123;F&#125;_&#123;q^6&#125;)</span>  is the distortion map  <span class="math">\phi(x_2,y_2)=(\rho-x_2,\sigma y_2)</span> . However, making use of the techniques of §3 we do not need to perform the final powering, as we presume the output will be stored and transmitted in compressed form (Algorithm 2).</p>
      <h2 id="algorithm-2-the-duursma-lee-algorithm" class="text-2xl font-bold mt-10 mb-4">Algorithm 2: The Duursma-Lee Algorithm</h2>
      <p class="text-gray-300">``` \begin&#123;array&#125;&#123;l&#125; \textbf&#123;input&#125; & : \textbf&#123;point &#125; P = (x_1,y_1), \textbf&#123;point &#125; Q = (x_2,y_2) \\ \textbf&#123;output&#125; & : f_P(\phi(Q)) \in \mathcal&#123;G&#125; \\ f \leftarrow 1 \\ \textbf&#123;for &#125; i = 1 \textbf&#123; to &#125; m \textbf&#123; do&#125; \\ & x_1 \leftarrow x_1^3, y_1 \leftarrow y_1^3 \\ & \mu \leftarrow x_1 + x_2 + b, \lambda \leftarrow -y_1 y_2 \sigma - \mu^2 \\ & g \leftarrow \lambda - \mu \rho - \rho^2, f \leftarrow f \cdot g \\ & x_2 \leftarrow x_2^&#123;1/3&#125;, y_2 \leftarrow y_2^&#123;1/3&#125; \\ \textbf&#123;end&#125; \\ \textbf&#123;return &#125; f \end&#123;array&#125; ```</p>
      <h2 id="6-1-cost-analysis" class="text-2xl font-bold mt-10 mb-4">6.1 Cost Analysis</h2>
      <p class="text-gray-300">Let M denote the cost of an  <span class="math">\mathbb&#123;F&#125;_q</span>  multiplication. Each iteration of the loop requires 2M to compute  <span class="math">\mu^2</span>  and  <span class="math">y_1y_2</span> , and an  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  multiplication to compute  <span class="math">f \cdot g</span> . Since a generic  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  multiplication costs 18M, Scott and Barreto [44] reckon that besides the necessary cubings and cube roots, each loop iteration costs 20M. However, in each iteration g is sparse, i.e., not all of its terms are non-trivial, One can exploit this to reduce the cost of multiplying g and f, which is not sparse in general, to 13M. This total of 15M improves on the trace-based method suggested by Scott and Barreto. In fact one can reduce the cost for each loop iteration in the ordinary Duursma-Lee algorithm to just 14M, by unrolling the main loop and better exploiting the sparsity of g.</p>
      <h3 id="algorithm-3-a-refined-duursma-lee-algorithm" class="text-xl font-semibold mt-8 mb-3">Algorithm 3: A Refined *Duursma-Lee* Algorithm.</h3>
      <p class="text-gray-300">``` input : point P = (x_1, y_1), point Q = (x_2, y_2)</p>
      <p class="text-gray-300">output : f_P(\phi(Q)) \in \mathcal&#123;G&#125;</p>
      <p class="text-gray-300">f \leftarrow 1</p>
      <p class="text-gray-300">for i = 1 to (m - 1)/2 do</p>
      <p class="text-gray-300">x_1 \leftarrow x_1^3, y_1 \leftarrow y_1^3</p>
      <p class="text-gray-300">\mu \leftarrow x_1 + x_2 + b, \lambda \leftarrow -y_1 y_2 \sigma - \mu^2</p>
      <p class="text-gray-300">g_1 \leftarrow \lambda - \mu \rho - \rho^2</p>
      <p class="text-gray-300">x_2 \leftarrow x_2^&#123;1/3&#125;, y_2 \leftarrow y_2^&#123;1/3&#125;</p>
      <p class="text-gray-300">x_1 \leftarrow x_1^3, y_1 \leftarrow y_1^3</p>
      <p class="text-gray-300">\mu \leftarrow x_1 + x_2 + b, \lambda \leftarrow -y_1 y_2 \sigma - \mu^2</p>
      <p class="text-gray-300">g_2 \leftarrow \lambda - \mu \rho - \rho^2</p>
      <p class="text-gray-300">g \leftarrow g_1 g_2, f \leftarrow f \cdot g</p>
      <p class="text-gray-300">x_2 \leftarrow x_2^&#123;1/3&#125;, y_2 \leftarrow y_2^&#123;1/3&#125; \nend</p>
      <p class="text-gray-300">x_1 \leftarrow x_1^3, y_1 \leftarrow y_1^3</p>
      <p class="text-gray-300">\mu \leftarrow x_1 + x_2 + b, \lambda \leftarrow -y_1 y_2 \sigma - \mu^2</p>
      <p class="text-gray-300">g \leftarrow \lambda - \mu \rho - \rho^2, f \leftarrow f \cdot g</p>
      <p class="text-gray-300">return f ```</p>
      <p class="text-gray-300">We demonstrate this technique in Algorithm 3 which provides a saving since in each loop, multiplying  <span class="math">g_1</span>  by  <span class="math">g_2</span>  costs only 6M. Multiplying g by f in each loop costs 18M since they are both generic  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  elements. Both  <span class="math">\mu^2</span>  and  <span class="math">y_1y_2</span>  are computed twice in each loop: once for  <span class="math">g_1</span>  and once for  <span class="math">g_2</span> . In total the cost therefore is (6M+4M)(m-1)/2+18M(m-3)/2+13M=14mM-19M, which is equivalent to about 14M per loop iteration of Algorithm 2.</p>
      <p class="text-gray-300">This cost analysis ignores the cost of computing cubings and cube roots. Because of the large number of times each of these operations are invoked, it has been suggested that one should use normal bases to accommodate them efficiently, since they are then implemented using cyclic shifts. Normal bases are well-studied in even characteristic, but for characteristic three one can not construct optimal, type one normal bases with prime extension degree [19,36], although type two bases are available for some values of m. As a result, the cost of general multiplication in software is relatively large, even when variations of high performance methods in characteristic two are used [38,35]. For example, we found that when m=239 normal basis multiplication is between two and three times slower than a polynomial basis multiplication. However, in hardware implementations on a smart-card for example, normal bases still seem the obvious choice since they can match the multiplication speed of polynomial basis while offering inexpensive cube and cube root operations, although perhaps at the cost of flexibility.</p>
      <p class="text-gray-300">To reduce the cost of computing cube roots using a polynomial basis, we observe that the successive cube roots of  <span class="math">x_2</span>  and  <span class="math">y_2</span>  can be computed more easily in reverse order and stored for the duration of the algorithm. Since for any  <span class="math">x_2 \in \mathbb&#123;F&#125;_q</span> , we have  <span class="math">x_2 = x_2^&#123;3^m&#125;</span> , the required values  <span class="math">x_2^&#123;1/3^i&#125;</span>  can be computed as  <span class="math">x_2^&#123;3^&#123;m-i&#125;&#125;</span> , and thus one does not need to compute any cube roots at all. The memory requirement for this is only about  <span class="math">2^&#123;-11&#125;m^2</span>  Kb and the time taken is just the cost of 2m cubings. If memory is at a premium, one can reduce this to about  <span class="math">2^&#123;-4.5&#125;m^&#123;3/2&#125;</span>  Kb with double the number of cubings using further loop unrolling and pebbling strategies.</p>
      <p class="text-gray-300">Remark 3. As already mentioned, Scott and Barreto's method [44] is effectively a change of basis and not a compressed method of computing a pairing. Hence it is unsurprising that the loop unrolling strategy of Algorithm 3 can be used to reduce the cost of the trace method given there, as kindly pointed out by Barreto [1].</p>
      <p class="text-gray-300">Remark 4. Scott and Barreto [44] suggested an open problem asking if it possible to perform the pairing computation directly in compressed form for some compression factor  <span class="math">\geq 3</span>  on ordinary (non-supersingular) curves in characteristic p &gt; 3. A compression factor larger than 3 is extremely unlikely. For pairing-based applications, the desirable extension degrees in the near future are likely to remain small, and no larger than twenty. By Lemma 1, the maximum compression factor possible for a given extension degree n is  <span class="math">n/\phi(n)</span> , and for n &lt; 20, this maximum is three, which is already achieved for the modified Tate pairing.</p>
      <p class="text-gray-300">Fig. 2. Pairing and Exponentiation Timings.</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;79&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;97&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;163&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;193&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;239&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;353&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Pairing</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">BKLS</td><td class="border border-gray-700 px-3 py-1">13.96ms</td><td class="border border-gray-700 px-3 py-1">23.60ms</td><td class="border border-gray-700 px-3 py-1">79.11 ms</td><td class="border border-gray-700 px-3 py-1">123.21ms</td><td class="border border-gray-700 px-3 py-1">179.30ms</td><td class="border border-gray-700 px-3 py-1">527.56ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Algorithm 3</td><td class="border border-gray-700 px-3 py-1">4.67ms</td><td class="border border-gray-700 px-3 py-1">8.41ms</td><td class="border border-gray-700 px-3 py-1">29.26ms</td><td class="border border-gray-700 px-3 py-1">45.67ms</td><td class="border border-gray-700 px-3 py-1">65.73ms</td><td class="border border-gray-700 px-3 py-1">197.58ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Exponentiation in <span class="math">G_l</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 1</td><td class="border border-gray-700 px-3 py-1">3.65ms</td><td class="border border-gray-700 px-3 py-1">6.14ms</td><td class="border border-gray-700 px-3 py-1">20.98ms</td><td class="border border-gray-700 px-3 py-1">33.21ms</td><td class="border border-gray-700 px-3 py-1">44.72ms</td><td class="border border-gray-700 px-3 py-1">130.27ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 2</td><td class="border border-gray-700 px-3 py-1">4.57ms</td><td class="border border-gray-700 px-3 py-1">7.25ms</td><td class="border border-gray-700 px-3 py-1">21.53ms</td><td class="border border-gray-700 px-3 py-1">31.61ms</td><td class="border border-gray-700 px-3 py-1">43.56ms</td><td class="border border-gray-700 px-3 py-1">119.16ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 3</td><td class="border border-gray-700 px-3 py-1">3.67ms</td><td class="border border-gray-700 px-3 py-1">5.79ms</td><td class="border border-gray-700 px-3 py-1">17.85 ms</td><td class="border border-gray-700 px-3 py-1">26.69ms</td><td class="border border-gray-700 px-3 py-1">36.45ms</td><td class="border border-gray-700 px-3 py-1">101.75ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 4</td><td class="border border-gray-700 px-3 py-1">3.06ms</td><td class="border border-gray-700 px-3 py-1">5.10ms</td><td class="border border-gray-700 px-3 py-1">16.55ms</td><td class="border border-gray-700 px-3 py-1">24.67ms</td><td class="border border-gray-700 px-3 py-1">34.74ms</td><td class="border border-gray-700 px-3 py-1">99.56ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Exponentiati</td><td class="border border-gray-700 px-3 py-1">Exponentiation in <span class="math">\mathcal&#123;G&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 1</td><td class="border border-gray-700 px-3 py-1">2.55ms</td><td class="border border-gray-700 px-3 py-1">4.27ms</td><td class="border border-gray-700 px-3 py-1">14.15ms</td><td class="border border-gray-700 px-3 py-1">21.67ms</td><td class="border border-gray-700 px-3 py-1">30.69ms</td><td class="border border-gray-700 px-3 py-1">88.06ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 2</td><td class="border border-gray-700 px-3 py-1">2.62ms</td><td class="border border-gray-700 px-3 py-1">5.21ms</td><td class="border border-gray-700 px-3 py-1">13.21ms</td><td class="border border-gray-700 px-3 py-1">20.38ms</td><td class="border border-gray-700 px-3 py-1">26.97ms</td><td class="border border-gray-700 px-3 py-1">74.90ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 3</td><td class="border border-gray-700 px-3 py-1">3.69ms</td><td class="border border-gray-700 px-3 py-1">4.72ms</td><td class="border border-gray-700 px-3 py-1">15.78ms</td><td class="border border-gray-700 px-3 py-1">22.96ms</td><td class="border border-gray-700 px-3 py-1">37.96ms</td><td class="border border-gray-700 px-3 py-1">73.29ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 4</td><td class="border border-gray-700 px-3 py-1">2.32ms</td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">11.84ms</td><td class="border border-gray-700 px-3 py-1">17.63ms</td><td class="border border-gray-700 px-3 py-1">24.73ms</td><td class="border border-gray-700 px-3 py-1">69.30ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Point Multiplication in <span class="math">E(\mathbb&#123;F&#125;_q)</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 1</td><td class="border border-gray-700 px-3 py-1">1.83ms</td><td class="border border-gray-700 px-3 py-1">3.11ms</td><td class="border border-gray-700 px-3 py-1">10.62ms</td><td class="border border-gray-700 px-3 py-1">16.94ms</td><td class="border border-gray-700 px-3 py-1">24.11ms</td><td class="border border-gray-700 px-3 py-1">69.78ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 2</td><td class="border border-gray-700 px-3 py-1">1.72ms</td><td class="border border-gray-700 px-3 py-1">2.84ms</td><td class="border border-gray-700 px-3 py-1">9.47ms</td><td class="border border-gray-700 px-3 py-1">14.73ms</td><td class="border border-gray-700 px-3 py-1">21.15ms</td><td class="border border-gray-700 px-3 py-1">60.70ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 3</td><td class="border border-gray-700 px-3 py-1">1.82ms</td><td class="border border-gray-700 px-3 py-1">3.01ms</td><td class="border border-gray-700 px-3 py-1">9.66ms</td><td class="border border-gray-700 px-3 py-1">14.95ms</td><td class="border border-gray-700 px-3 py-1">21.19ms</td><td class="border border-gray-700 px-3 py-1">58.70ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Method 4</td><td class="border border-gray-700 px-3 py-1">1.18ms</td><td class="border border-gray-700 px-3 py-1">1.95ms</td><td class="border border-gray-700 px-3 py-1">8.11ms</td><td class="border border-gray-700 px-3 py-1">12.75ms</td><td class="border border-gray-700 px-3 py-1">19.04ms</td><td class="border border-gray-700 px-3 py-1">55.93ms</td><td class="border border-gray-700 px-3 py-1"></td></tr>
      </tbody></table></div>
      <h2 id="7-implementation-results" class="text-2xl font-bold mt-10 mb-4">7 Implementation Results</h2>
      <p class="text-gray-300">In order to provide some concrete idea of the practical cost of our own and other methods, we implemented the proposed field arithmetic, pairing algorithms and exponentiation methods. We used a GCC 3.3 compiler suite to build our implementation and ran timing experiments on a Linux based PC incorporating a 2.80 GHz Intel Pentium 4 processor. The entire system was constructed in C++. We accept that further performance improvements could be made through aggressive profiling and optimisation but are confident our results are representative of the underlying algorithms and allow a comparison between them.</p>
      <p class="text-gray-300">Figure 2 shows the result of timing this implementation using a variety of different base field sizes. In the pairing section, Algorithm 3 refers to the augmented version of Duursma-Lee presented in this paper, with the cube root precomputation strategy and the loop unrolling. The BKLS method is included as a reference. We do not include timings for the methods of [44] since our operation count clearly shows they will be slower than our alternatives. Figure 3 gives timings for the underlying field operations.</p>
      <p class="text-gray-300">We note first that our implementation of Algorithm 3 is between two to three times faster than the BKLS algorithm. With regard to exponentiation, Method 4 is the most efficient for all field sizes and in all three groups, and in  <span class="math">\mathcal&#123;G&#125;</span>  is nearly twice as fast as Method 1 in  <span class="math">G_l</span> . Contrary to a claim of Koblitz [29] that the ratio of the time required for an exponentation in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span>  to the time required for a point multiplication in  <span class="math">E(\mathbb&#123;F&#125;_q)</span>  is 12, our results demonstrate that for fields</p>
      <p class="text-gray-300">Fig. 3. Timings for Field Operations.</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;79&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;97&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;163&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;193&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;239&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;3^&#123;353&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_q</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Add</td><td class="border border-gray-700 px-3 py-1"><span class="math">0.55 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.53 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.58 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.63 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.61 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.64 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Square</td><td class="border border-gray-700 px-3 py-1"><span class="math">4.42 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">6.07 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">12.99 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">16.48 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">19.48 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">40.97 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Cube</td><td class="border border-gray-700 px-3 py-1"><span class="math">0.85 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.84 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.96 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.26 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.24 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.77 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Invert</td><td class="border border-gray-700 px-3 py-1"><span class="math">23.18 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">33.26 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">70.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">97.20 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">136.86 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">303.27 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Multiply</td><td class="border border-gray-700 px-3 py-1"><span class="math">4.06 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">6.02 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">12.80 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">17.83 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">19.42 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">43.11 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\overline&#123;\mathbb&#123;F&#125;_&#123;q^&#123; 3 &#125;&#125;&#125;</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">\overline&#123;\mathbb&#123;F&#125;&#125;_&#123;a^3&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Add</td><td class="border border-gray-700 px-3 py-1"><span class="math">0.60 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.60 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.80 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.50 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Cube</td><td class="border border-gray-700 px-3 py-1"><span class="math">2.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.30 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.50 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">3.20 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">4.20 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Invert</td><td class="border border-gray-700 px-3 py-1"><span class="math">65.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">94.70 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">204.40 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">275.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">350.60 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">741.80 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Frobenius</td><td class="border border-gray-700 px-3 py-1"><span class="math">1.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.30 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.40 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Multiply</td><td class="border border-gray-700 px-3 py-1"><span class="math">26.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">37.80 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">74.20 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">98.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">115.50 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">249.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1"><span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Add</td><td class="border border-gray-700 px-3 py-1"><span class="math">0.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">0.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Cube</td><td class="border border-gray-700 px-3 py-1"><span class="math">2.80 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">4.60 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">4.40 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">4.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">5.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Invert</td><td class="border border-gray-700 px-3 py-1"><span class="math">165.50 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">237.20 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">497.40 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">670.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">817.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1709.50 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Frobenius</td><td class="border border-gray-700 px-3 py-1"><span class="math">2.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">1.90 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.00 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">2.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">Multiply</td><td class="border border-gray-700 px-3 py-1"><span class="math">75.70 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">106.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">227.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">296.80 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">347.30 \mu s</span></td><td class="border border-gray-700 px-3 py-1"><span class="math">745.10 \mu s</span></td><td class="border border-gray-700 px-3 py-1"></td></tr>
      </tbody></table></div>
      <p class="text-gray-300">of a cryptographic size, this value is in fact closer to 1.3. Thus the techniques from [49], together with the fast multiplication in  <span class="math">\mathcal&#123;G&#125;</span> , improve the efficiency of post-pairing arithmetic considerably.</p>
      <p class="text-gray-300">We conceed that while we have not implemented Koblitz's complex multiplication exponentiation method, due to the estimated large preprocessing time required, we do not think it would affect this comparison significantly.</p>
      <p class="text-gray-300">Furthermore, due to our direct inversion method, the ratio of inversion time to multiplication time in  <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span>  is under three for all field sizes. This means our compression method in  <span class="math">\mathcal&#123;G&#125;</span>  costs roughly 4/3 multiplications in  <span class="math">\mathbb&#123;F&#125;_&#123;q^6&#125;</span> , and is therefore also very efficient.</p>
      <h2 id="8-conclusion-and-open-problems" class="text-2xl font-bold mt-10 mb-4">8 Conclusion and Open Problems</h2>
      <p class="text-gray-300">We have shown how to take advantage of the quotient group to which a pairing value naturally belongs in order to speed up exponentiations, and to obtain fast compression of pairing values. We have also proposed some simple refinements to the Duursma-Lee algorithm to improve efficiency. Our results strongly indicate that there are definite advantages to implementing pairing-based cryptographic protocols in characteristic three: the often quoted value of ten for the ratio of the speed of a pairing evaluation to a point multiplication on the curve is really closer to three or four.</p>
      <p class="text-gray-300">Some issues remain. One could certainly improve the exponentiation times for all three groups if there exists an efficiently computable ternary analogue of the Joint Sparse Form [48]. With regard to side channel attacks, such a method may be undesirable since one can not render cubing and multiplication in charcteristic three fields indistinguishable without a serious detriment to performance. As such, a cube-and-multiply-always method using the exponent splitting of Method 4 will half the cost of a secure full length expansion.</p>
      <p class="text-gray-300">Also the exact security of the discrete logarithm problem in characateristic three using the ternary analogue of Coppersmith's method has yet to be investigated [10, 11]. Preliminary research into this problem using Adleman's Function Field Sieve has been conducted [23, 24] but the problem should still be considered open.</p>
      <p class="text-gray-300">Lastly, do there exist methods for faster pairing evaluation using MNT curves, and how might they compare to those presented here?</p>
      <h2 id="acknowledgements" class="text-2xl font-bold mt-10 mb-4">Acknowledgements</h2>
      <p class="text-gray-300">The authors would like to thank the anonymous referee, Paulo Barreto, Steven Galbraith, Keith Harrison, Karl Rubin, Mike Scott, Alice Silverberg, Nigel Smart and Fré Vercauteren for many helpful comments and fruitful discussions.</p>
      <h2 id="references" class="text-2xl font-bold mt-10 mb-4">References</h2>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>1. P. Barreto. Personal Communication.</li>
        <li>P. Barreto, H. Kim, B. Lynn and M. Scott. Efficient Algorithms for Pairing-Based Cryptosystems. In Advances in Cryptology (CRYPTO 2002), Springer LNCS 2442, 354–368, 2002.</li>
        <li>3. D. Boneh and X. Boyen. Efficient Selective-ID Secure Identity-Based Encryption Without Random Oracles. In *Advances in Cryptology (EUROCRYPT 2004)*, Springer LNCS 3027, 223–238, 2004.</li>
        <li>4. D. Boneh, X. Boyen and H. Shacham. Short Group Signatures. In Advances in Cryptology (CRYPTO 2004), Springer LNCS 3152, 41-55, 2004.</li>
        <li>5. D. Boneh and M. Franklin. Identity-Based Encryption from the Weil Pairing. In SIAM Journal on Computing, Volume 32, no. 3, 586-615, 2003.</li>
        <li>D. Boneh, B. Lynn and H. Shacham. Short signatures from the Weil Pairing. In Advances in Cryptology (ASIACRYPT 2001), Springer LNCS 2248, 514-532, 2001.</li>
        <li>W. Bosma, J. Hutton and E. Verheul. Looking beyond XTR. In Advances in Cryptology (ASIACRYPT 2002), Springer LNCS 2501, 46-63, 2002.</li>
        <li>8. W. Clark and J. Liang. On arithmetic weight for a general radix representation of integers. In *IEEE Trans. Info. Theory*, **19**, 823–826, 1973.</li>
        <li>H. Cohen, A. Miyaji and T. Ono. Efficient elliptic curve exponentiation using mixed coordinates. In Advances in Cryptology (ASIACRYPT 1998). Springer LNCS 1514, 51–65, 1998.</li>
        <li>D. Coppersmith. Evaluating logarithms in GF(2<sup>n</sup>). In 16th ACM Symp. Theory of Computing, 201–107, 1984.</li>
        <li>D. Coppersmith. Fast evaluation of logarithms in fields of characteristic two. IEEE Trans. Info. Theory, 30, 587–594, July 1984.</li>
        <li>12. R. Dutta, R. Barua and P. Sarkar. Pairing-Based Cryptographic Protocols: A Survey. Cryptology ePrint Archive, Report 2004/064. Available from http://eprint.iacr.org/2004/064.</li>
      </ul>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>13. I. Duursma and H. Lee. Tate Pairing Implementation for Hyperelliptic Curves  <span class="math">y^2 = x^p x + d</span> . In Advances in Cryptology (ASIACRYPT 2003), Springer LNCS 2894, 111–123, 2003.</li>
        <li>T. ElGamal. A public key cryptosystem and a signature scheme based on discrete logarithms. In *IEEE Trans. Info. Theory* 31, 469–472, 1985.</li>
        <li>G. Frey and H. Ruck. A Remark Concerning m-Divisibility and the Discrete Logarithm Problem in the Divisor Class Group of Curves. In *Math. Comp.* 62, 865-874, 1994.</li>
        <li>16. S. Galbraith. Supersingular Curves in Cryptography. In Advances in Cryptology (ASIACRYPT 2001), Springer LNCS 2248, 495-513, 2001.</li>
        <li>S. Galbraith, K. Harrison and D. Soldera. Implementing the Tate pairing. In Proc. of ANTS V, Springer LNCS 2369, 324–337, 2002.</li>
        <li>R. Gallant, J. Lambert and S. Vanstone. Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms. In Advances in Cryptology (CRYPTO 2001), Springer LNCS 2139, 190–200, 2001.</li>
        <li>19. S. Gao. Normal Bases over Finite Fields. PhD Thesis, Waterloo University, 1993.</li>
        <li>20. P. Gaudry Index calculus for abelian varieties and the elliptic curve discrete logarithm problem Cryptology ePrint Archive, Report 2004/073. Available from http://eprint.iacr.org/2004/073.</li>
        <li>C. Gentry. Certificate-Based Encryption and the Certificate Revocation Problem. In Advances in Cryptology (EUROCRYPT 2003), Springer LNCS 2656, 272–293, 2003</li>
        <li>22. P Golle and A. Juels. Dining Cryptographers Revisited. In Advances in Cryptology (EUROCRYPT 2004), Springer LNCS 3027, 456–473, 2004.</li>
        <li>R. Granger. Estimates for discrete logarithm computations in finite fields of small characteristic. In Cryptography and Coding, Springer LNCS 2898, 190–206, 2003.</li>
        <li>R. Granger, A. Holt, D. Page, N. Smart and F. Vercauteren. Function Field Sieve in Characteristic Three. In Proc. of ANTS VI, Springer LNCS 3076, 223–234, 2004</li>
        <li>R. Granger, D. Page and M. Stam. A Comparison of CEILIDH and XTR. In Proc. of ANTS VI, Springer LNCS 3076, 235–249, 2004.</li>
        <li>K. Harrison, D. Page and N.P. Smart. Software Implementation of Finite Fields of Characteristic Three, for use in Pairing Based Cryptosystems. In LMS Journal of Computation and Mathematics, 5 (1), 181–193, London Mathematical Society, 2002.</li>
        <li>F. Hess. Efficient Identity based Signature Schemes based on Pairings. In Selected Areas in Cryptography (SAC 2002), Springer LNCS 2595, 310–324, 2003.</li>
        <li>A. Joux. A One Round Protocol for Tripartite Diffie-Hellman. In Proc. of ANTS IV, Springer LNCS 1838, 385–394, 2000.</li>
        <li>N. Koblitz. An elliptic curve implementation of the finite field digital signature algorithm. Advances in Cryptology (CRYPTO 98), Springer LNCS 1462, 327–337, 1998.</li>
        <li>30. A. Lenstra. Using Cyclotomic Polynomials to Construct Efficient Discrete Logarithm Cryptosystems over Finite Fields. In *Proc. of ACISP97*, Springer LNCS 1270, 127–138, 1997.</li>
        <li>A. Lenstra and E. Verheul. The XTR Public Key System. In Advances in Cryptology (CRYPTO 2000), Springer LNCS 1880, 1–19, 2000.</li>
        <li>J. López and R. Dahab. High Speed Software Multiplication in F<sub>2m</sub>. In Progress in Cryptography (INDOCRYPT 2000), Springer-Verlag LNCS 1977, 203-212, 2000.</li>
        <li>A.J. Menezes, P.C. van Oorschot and S.A. Vanstone. Handbook of Applied Cryptography. CRC Press, 1997.</li>
      </ul>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>34. V. Miller. Short programs for functions on curves. Unpuplished manuscript, 1986. Available from http://crypto.stanford.edu/miller/miller.pdf.</li>
        <li>P. Ning and Y.L. Yin. Efficient Software Implementation for Finite Field Multiplication in Normal Basis. In *Information and Communications Security (ICICS)*, Springer-Verlag LNCS 2229, 177–188, 2001.</li>
        <li>M. Nöcker. Data structures for parallel exponentiation in finite fields. PhD Thesis, Universität Paderborn, 2001.</li>
        <li>37. G. Pohlig and M. Hellman. An improved algorithm for computing discrete logarithms over GF(p) and its cryptographic significance. In *IEEE Trans. Info. Theory* **24**, 106–110, 1978.</li>
        <li>38. A. Reyhani-Masoleh and M.A. Hasan: Fast Normal Basis Multiplication Using General Purpose Processors. In *Selected Areas in Cryptography (SAC 2001)*, Springer LNCS 2259, 230–244, 2001.</li>
        <li>K. Rubin and A. Silverberg. Supersingular abelian varieties in cryptology. In Advances in Cryptology (CRYPTO 2002), Springer LNCS 2442, 336-353, 2002.</li>
        <li>K. Rubin and A. Silverberg. Torus-Based Cryptography. In Advances in Cryptology (CRYPTO 2003), Springer LNCS 2729, 349</li>
      </ul>
      <p class="text-gray-300">–365, 2003.</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>41. K. Rubin and A. Silverberg. Using Primitive Subgroups to Do More with Fewer Bits. In Algorithm Number Theory (ANTS-VI), Springer LNCS 3076, 18–41, 2004.</li>
        <li>42. R. Sakai, K. Ohgishi and M. Kasahara. Cryptosystems Based on Pairings. In Symposium on Cryptography and Information Security 2000 (SCIS2000), Okinawa, Japan, Jan 26–28, 2000.</li>
        <li>43. M. Scott. Authenticated ID-based Key Exchange and remote log-in with insecure token and PIN number. Cryptology ePrint Archive, Report 2002/164. Available from http://eprint.iacr.org/2002/164.</li>
        <li>44. M. Scott and P. Barreto. Compressed Pairings. In Advances in Cryptology (CRYPTO 2004), Springer LNCS 3152, 140-156, 2004.</li>
        <li>I. Semaev. Summation polynomials and the discrete logarithm problem on elliptic curves. Cryptology ePrint Archive, Report 2004/031. Available from http://eprint.iacr.org/2004/031.</li>
        <li>46. J. Silverman. The arithmetic of elliptic curves. Springer GTM 106, 1986.</li>
        <li>47. P. Smith and C. Skinner. A public-key cryptosystem and a digital signature system based on the Lucas function analogue to discrete logarithms. In Advances in Cryptology (ASIACRYPT 1995), Springer LNCS 917, 357-364, 1995.</li>
        <li>48. J.A. Solinas. Low-Weight Binary Representations for Pairs of Integers. University of Waterloo, Technical Report CORR 2001-41.</li>
        <li>M. Stam and A. Lenstra. Efficient Subgroup Exponentiation in Quadratic and Sixth Degree Extensions. In Cryptographic Hardware and Embedded Systems (CHES 2002), Springer LNCS 2523, 318-332, 2002.</li>
        <li>M. Stam and A. Lenstra. Speeding Up XTR. In Advances in Cryptology (ASI-ACRYPT 2001), Springer LNCS 2248, 125–143, 2001.</li>
        <li>E.G. Straus. Problems and Solutions: (5125) Addition Chains of Vectors. In American Mathematical Monthly, 71, 806-808, 1964.</li>
        <li>52. E. Verheul. Personal Communication, 2001.</li>
        <li>53. V.E. Voskresenskii. Algebraic Groups and Their Birational Invariants. In *Translations of Mathematical Monographs*, **179**, American Mathematical Society, 1998.</li>
      </ul>
    </section>
    <PaperHistory slug="on-small-characteristic-algebraic-tori-in-pairing-based-2004" />
  </article>
</BaseLayout>
