---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/132';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On Small Characteristic Algebraic Tori in Pairing-Based Cryptography';
const AUTHORS_HTML = 'R.  Granger, D.  Page, M.  Stam';

const CONTENT = `    <p class="text-gray-300">R. Granger, D. Page and M. Stam</p>

    <p class="text-gray-300">University of Bristol, Department of Computer Science, Merchant Venturers Building, Woodland Road, Bristol, BS8 1UB, UK. {granger,page,stam}@cs.bris.ac.uk</p>

    <p class="text-gray-300">Abstract. The output of the Tate pairing on an elliptic curve over a finite field may be viewed as an element of an algebraic torus. Using this simple observation, we transfer techniques recently developed for torus-based cryptography to pairing-based cryptography, resulting in more efficient computations, and lower bandwidth requirements. To illustrate the efficacy of this approach, we apply the method to pairings on supersingular elliptic curves in characteristic three.</p>

    <p class="text-gray-300">The use of pairings in cryptography is now a well-studied area, with resulting applications to identity-based encryption, key-agreement and signature schemes [5, 42], tripartite Diffie-Hellman key-agreement [28], and short signatures [6], to name just a few amongst numerous others (see e.g. [12] for a recent survey).</p>

    <p class="text-gray-300">To support these applications much research activity has focused on developing efficient and easily implementable algorithms for their deployment [2, 17, 13]. Currently the fastest algorithm for pairing computation on elliptic curves is that of Duursma and Lee [13], which applies to the class of supersingular elliptic curves in characteristic three with so-called embedding degree six, and is preferable in pairing implementations for contemporary cryptographic schemes.</p>

    <p class="text-gray-300">One is therefore free to use the trace-based methods found in LUC [47] and XTR [31] for post-pairing arithmetic [52], resulting in the compression of pairing outputs by a factor of two and three respectively. Scott and Barreto [44] also describe the use of traces for the computation of the pairing itself, however closer inspection of their work shows that their claim is misleading. Indeed, their method is essentially a polynomial basis transformation and hence does not offer any advantages during the computation of the pairing. Moreover, for characteristic three, we demonstrate that contrary to the claims of Scott and Barreto [44], the performance of their approach is inferior to a straightforward implementation. Thus besides pairing compression, the method they advocate does not seem to offer any benefits.</p>

    <p class="text-gray-300">Our contribution is to achieve both efficient pairing arithmetic, and also pairing compression. Our methods are based on the simple observation that</p>

    <p class="text-gray-300">the quotient group to which the natural output of the Tate pairing belongs, may be viewed as a special representation of an algebraic torus. These groups were introduced to cryptography by Rubin and Silverberg [40], who showed under certain conditions that one can represent elements of the torus via rational embeddings into affine space, providing smaller bandwidth requirements than the corresponding field-embedded representation.</p>

    <p class="text-gray-300">Using this property and an efficient point multiplication method developed for tori [25], we are able to perform arithmetic with pairing values that is on average 30% faster than previous methods. This is useful, for example, in pairing-based protocols where one typically blinds a point by an ephemeral random value. By bilinearity, this blinding may be performed either on the curve before the pairing evaluation, or in the extension field afterwards. Given that a pairing evaluation is usually several times more costly than either a point multiplication on the curve or an exponentiation in the field, if a pairing value ever needs to be reused, it is beneficial to compute it once and for all and to perform each ephemeral blinding in the extension field.</p>

    <p class="text-gray-300">Examples where this occurs include the the Boneh-Franklin identity-based encryption scheme [5], the identity-based signature scheme of Hess [27], and the certificate-based encryption scheme of Gentry [21].</p>

    <p class="text-gray-300">The aforementioned compression methods can also be used during any interactive pairing-based protocol where pairing values are transmitted between parties. Such schemes include the selective-ID identity-based encryption scheme of Boneh and Boyen [3], the interactive proof of knowledge in the short group signature scheme of Boneh et al. [4], and various others [22, 43].</p>

    <p class="text-gray-300">One may regard our methods as a characteristic three version of previous work on tori [40, 25] tailored for pairings. However they may also be used for pairings on any abelian variety possessing an even embedding degree, which for efficiency reasons is the case for all contemporary pairing algorithms. As such they may also be applied to supersingular binary elliptic curves, although we do not pursue this application here since pairings based on these curves possess an inferior security/efficiency trade-off [16].</p>

    <p class="text-gray-300">The remainder of the article is organised as follows. We next give some background on the Tate pairing and algebraic tori. In §3 we develop fast arithmetic for pairing values, and in §4 we give algorithms for efficient exponentiation. In §5, we describe the field representation we use, while in §6 we detail our improvements to the Duursma-Lee algorithm. In §7, we present implementation results, and in the final section, we make some concluding remarks and present some open problems.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we briefly provide some mathematical background, and fix some notation.</p>

    <p class="text-gray-300">3</p>

    <h2 id="sec-4" class="text-2xl font-bold">2.1 The Tate Pairing</h2>

    <p class="text-gray-300">The Tate pairing on an elliptic curve is usually computed using a variant of Miller's algorithm [34]. For the special curves often used in cryptography however, it was shown independently by Barreto et al. [2] and Galbraith et al. [17] that much of the computation of the algorithm is redundant. In terms of performance, the former paper provides the better alternative, and we refer to their algorithm as the reduced Tate pairing, or the BKLS algorithm.</p>

    <p class="text-gray-300"><strong>The reduced Tate pairing.</strong> Let <span class="math">E</span> be an elliptic curve over a finite field <span class="math">\\mathbb{F}_q</span>, and let <span class="math">\\mathcal{O}_E</span> denote the identity element of the associated group of rational points on <span class="math">E(\\mathbb{F}_q)</span>. For a positive integer <span class="math">l \\mid \\# E(\\mathbb{F}_q)</span> coprime to <span class="math">q</span>, let <span class="math">\\mathbb{F}_{q^k}</span> be the smallest extension field of <span class="math">\\mathbb{F}_q</span> which contains the <span class="math">l</span>-th roots of unity in <span class="math">\\overline{\\mathbb{F}}_q</span>. Also, let <span class="math">E(\\mathbb{F}_q)[l]</span> denote the subgroup of <span class="math">E(\\mathbb{F}_q)</span> of all points of order dividing <span class="math">l</span>, and similarly for the degree <span class="math">k</span> extension of <span class="math">\\mathbb{F}_q</span>. From an efficiency perspective, <span class="math">k</span> is usually chosen to be even [2]. For a thorough treatment of the following, we refer the reader to [2] and also [17], and to [46] for an introduction to divisors. Then assuming that <span class="math">l^3 \\nmid \\# E(\\mathbb{F}_{q^k})</span>, the reduced Tate pairing of order <span class="math">l</span> is the map</p>

    <div class="my-4 text-center"><span class="math-block">e_l: E(\\mathbb{F}_q)[l] \\times E(\\mathbb{F}_{q^k})[l] \\to \\mathbb{F}_{q^k}^\\times / (\\mathbb{F}_{q^k}^\\times)^l,</span></div>

    <p class="text-gray-300">given by <span class="math">e_l(P, Q) = f_{P,l}(\\mathcal{D})</span>. Here <span class="math">f_{P,l}</span> is a function on <span class="math">E</span> whose divisor is equivalent to <span class="math">l(P) - l(\\mathcal{O}_E)</span>, <span class="math">\\mathcal{D}</span> is a divisor equivalent to <span class="math">(Q) - (\\mathcal{O}_E)</span>, whose support is disjoint from the support of <span class="math">f_{P,l}</span>, and <span class="math">f_{P,l}(\\mathcal{D}) = \\prod_i f_{P,l}(P_i)^{a_i}</span>, where <span class="math">\\mathcal{D} = \\sum_i a_i P_i</span>. It satisfies the following properties ([15]):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">P \\neq \\mathcal{O}_E</span> there exists <span class="math">Q \\in E(\\mathbb{F}_{q^k})[l]</span> such that <span class="math">e_l(P, Q) \\neq 1 \\in \\mathbb{F}_{q^k}^\\times / (\\mathbb{F}_{q^k}^\\times)^l</span> (non-degeneracy);</li>

      <li>For any integer <span class="math">n</span>, <span class="math">e_l([n]P, Q) = e_l(P, [n]Q) = e_l(P, Q)^n</span> for all <span class="math">P \\in E(\\mathbb{F}_q)[l]</span> and <span class="math">Q \\in E(\\mathbb{F}_{q^k})[l]</span> (bilinearity);</li>

      <li>Let <span class="math">L = hl</span>. Then <span class="math">e_l(P, Q)^{(q^k - 1)/l} = e_L(P, Q)^{(q^k - 1)/L}</span>.</li>

    </ul>

    <p class="text-gray-300">When one computes <span class="math">f_{P,l}(\\mathcal{D})</span>, the value obtained belongs to the quotient group <span class="math">\\mathbb{F}_{q^k}^\\times / (\\mathbb{F}_{q^k}^\\times)^l</span>, and not <span class="math">\\mathbb{F}_{q^k}^\\times</span>. In this quotient, for <span class="math">a</span> and <span class="math">b</span> in <span class="math">\\mathbb{F}_{q^k}^\\times</span>, <span class="math">a \\sim b</span> if and only if there exists <span class="math">c \\in \\mathbb{F}_{q^k}^\\times</span> such that <span class="math">a = bc^l</span>. Clearly, this is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">a \\sim b \\quad \\text{if and only if} \\quad a^{(q^k - 1)/l} = b^{(q^k - 1)/l},</span></div>

    <p class="text-gray-300">and hence one ordinarily uses this value as the canonical representative of each coset. The isomorphism between <span class="math">\\mathbb{F}_{q^k}^\\times / (\\mathbb{F}_{q^k}^\\times)^l</span> and the elements of order <span class="math">l</span> in <span class="math">\\mathbb{F}_{q^k}^\\times</span> given by this exponentiation makes it possible to compute <span class="math">f_{P,l}(Q)</span> rather than <span class="math">f_{P,l}(\\mathcal{D})</span> [2]. It also removes the need to compute the costly denominators in Miller's algorithm.</p>

    <p class="text-gray-300">Fig. 1. Field definitions and Curve equations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Field Polynomial</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Order</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MOV security</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbb{F}_{3^{79}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t^{79} + t^{26} + 2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">Y^2 = X^3 - X - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3^{79} + 3^{49} + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">750</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbb{F}_{3^{97}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t^{97} + t^{12} + 2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">Y^2 = X^3 - X + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">(3^{97} + 3^{49} + 1)/7</span></td>

            <td class="px-3 py-2 border-b border-gray-700">906</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbb{F}_{3^{163}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t^{163} + t^{80} + 2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">Y^2 = X^3 - X - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3^{163} + 3^{82} + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1548</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbb{F}_{3^{193}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t^{193} + t^{12} + 2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">Y^2 = X^3 - X - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3^{193} - 3^{97} + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1830</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbb{F}_{3^{239}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t^{239} + t^{24} + 2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">Y^2 = X^3 - X - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3^{239} - 3^{120} + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">2268</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathbb{F}_{3^{353}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t^{353} + t^{142} + 2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">Y^2 = X^3 - X - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3^{353} + 3^{177} + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">3354</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The modified Tate pairing. At Asiacrypt 2003, Duursma and Lee introduced an algorithm for pairing computation on a special family of supersingular hyperelliptic curves [13]. In common with the authors of [44], for the elliptic case, which occurs only in characteristic three, we refer to the algorithm as the modified Tate pairing. In Figure 1, we list a sample of curves from this family, upon which we base our implementation.</p>

    <p class="text-gray-300">The first column gives the field over which each curve is defined, and the second lists the corresponding irreducible polynomials defining the field extensions. The third lists the curve equations and the fourth gives the order of the subgroup used. The final column gives the bit-length of the smallest finite field into which the pairing value embeds, which is a degree six extension for these curves. These parameter values were generated simply by testing which prime extension degrees yielded orders for supersingular curves that are prime, or almost prime, i.e., those possessing a small cofactor.</p>

    <p class="text-gray-300">The modified Tate pairing improves upon the reduced variant in three ways. Firstly, using the third property listed above, instead of computing the Tate pairing of order <span class="math">l</span>, one uses the pairing of order <span class="math">q^3 + 1</span>, which eliminates the need for any point additions in Miller's algorithm. Secondly, while this apparently increases the trit-length of the exponent by a factor of three, Duursma and Lee show that the divisor computed when processing three trits at a time has a very simple form, and hence no losses are incurred. Lastly, they provide a closed form expression for the pairing, thus simplifying implementations.</p>

    <p class="text-gray-300">We give a full description of the Duursma-Lee algorithm in §6, where we also make some elementary computational improvements.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2.2 Algebraic Tori</h2>

    <p class="text-gray-300">In 1985 El-Gamal made the suggestion that Diffie-Hellman key exchange, digital signatures and El-Gamal encryption be performed in the multiplicative group of an extension of <span class="math">\\mathbb{F}_p</span> [14], although without going into details. Recent trends in cryptographic research have shown that by exploiting the algebraic structure not available in prime fields, one can obtain compression of elements and efficient arithmetic.</p>

    <p class="text-gray-300">Due to the observation of Pohlig and Hellman [37], one typically works in a prime order subgroup of sufficient size in the multiplicative group of the extension field. To ensure that a particular subgroup does not embed into any subfield of the extension field, it must belong to the cyclotomic subgroup [30], which conjecturally attains the discrete logarithm security of the extension field. The public key cryptosystem XTR [31] exploits compression of elements in the cyclotomic subgroup of <span class="math">\\mathbb{F}_{p^n}^{\\times}</span> by taking their trace with respect to the quadratic subfield, to obtain a compression factor of three.</p>

    <p class="text-gray-300">Based on similar ideas, Rubin and Silverberg [40] proposed the notion of torus-based cryptography as an alternative way to obtain compression of elements in the cyclotomic subgroup of a suitable field extension, which is isomorphic to an algebraic torus (cf. Lemma 1). The public key system CEILIDH proposed in that paper is based on the torus <span class="math">T_6</span>. This torus has the property that it is birationally isomorphic to two dimensional affine space, which means that its elements can be parametrised via rational functions by only two elements of the base field, rather than the six elements ordinarily required.</p>

    <p class="text-gray-300">It was also shown in [40] that efforts to find a natural extension of the trace-based method of XTR using symmetric functions [7], can not work. It is an open conjecture whether or not <span class="math">T_{n}</span> is 'rational' for all <span class="math">n</span>, in which case one could efficiently compress elements of <span class="math">T_{n}</span> by a factor of <span class="math">n / \\phi (n)</span> [53, 40]. This conjecture is known to be true when <span class="math">n</span> is either a prime power, or the product of two prime powers. However, for the applications that concern us here, the status of the conjecture is unlikely to have any impact, as we explain in §6.</p>

    <p class="text-gray-300">The torus <span class="math">T_{n}(\\mathbb{F}_{q})</span>. Let <span class="math">\\mathbb{F}_q</span> be a finite field where <span class="math">q</span> is a power of a prime, and let <span class="math">\\varPhi_{n}</span> be the <span class="math">n</span>-th cyclotomic polynomial. We write <span class="math">G_{q,n}</span> for the subgroup of <span class="math">\\mathbb{F}_{q^n}^{\\times}</span> of order <span class="math">\\varPhi_n(q)</span>, and let <span class="math">\\mathbb{A}^n (\\mathbb{F}_q)</span> denote the <span class="math">n</span>-dimensional affine space over <span class="math">\\mathbb{F}_q</span>, i.e., the variety whose points lie in <span class="math">\\mathbb{F}_q^n</span>.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Let <span class="math">k = \\mathbb{F}_q</span> and <span class="math">L = \\mathbb{F}_{q^n}</span>. The torus <span class="math">T_n</span> is the intersection of the kernels of the norm maps <span class="math">N_{L / F}</span>, for all subfields <span class="math">k \\subset F \\subsetneq L</span>:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {n} (k) := \\bigcap_ {k \\subset F \\subsetneq L} \\operatorname {K e r} [ N _ {L / F} ].</span></div>

    <p class="text-gray-300">The following lemma provides some relevant properties of <span class="math">T_{n}</span> [40]:</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> <span class="math">T_{n}(\\mathbb{F}_{q})\\cong G_{q,n}</span>, and thus <span class="math">\\# T_{n}(\\mathbb{F}_{q}) = \\varPhi_{n}(q)</span>;</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">h \\in T_n(\\mathbb{F}_q)</span> is an element of prime order not dividing <span class="math">n</span>, then <span class="math">h</span> does not lie in a proper subfield of <span class="math">\\mathbb{F}_{q^n} / \\mathbb{F}_q</span>.</li>

    </ol>

    <h2 id="sec-6" class="text-2xl font-bold">3 The Quotient Group</h2>

    <p class="text-gray-300">Throughout this section and the remainder of the paper we assume we are working in characteristic three fields with prime extension degree (though the ideas</p>

    <p class="text-gray-300">apply equally well to arbitrary finite fields) and so where relevant, all exponents are written in ternary.</p>

    <p class="text-gray-300">Let <span class="math">l \\mid \\#E(\\mathbb{F}_q)</span> and suppose we wish to compute the modified Tate pairing of order <span class="math">l</span>. Then invoking the third property of §2.1, one uses the Duursma-Lee algorithm to first compute <span class="math">e_{q^3 + 1}</span>, which is an element in the quotient group</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{G} = \\mathbb{F}_{q^6}^\\times / (\\mathbb{F}_{q^6}^\\times)^{q^3 + 1}.</span></div>

    <p class="text-gray-300">For any <span class="math">a \\in \\mathbb{F}_{q^6}^\\times</span> we have <span class="math">a^{q^3 + 1} \\in \\mathbb{F}_{q^3}^\\times</span>, and so <span class="math">\\mathcal{G}</span> simplifies to <span class="math">\\mathbb{F}_{q^6}^\\times / \\mathbb{F}_{q^3}^\\times</span>.</p>

    <p class="text-gray-300">Let <span class="math">G_{l} \\subset \\mathbb{F}_{q^{6}}^{\\times}</span> denote the subgroup of order <span class="math">l</span>, and let <span class="math">e \\in \\mathcal{G}</span>. Then the two properties:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{gcd}(l, q^3 - 1) = 1 \\text{ and } e^{q^3 - 1} \\in G_l</span></div>

    <p class="text-gray-300">imply that <span class="math">e = gh</span> for some <span class="math">g \\in G_l</span>, <span class="math">h \\in \\mathbb{F}_{q^3}^\\times</span>. Hence powering <span class="math">e</span> by <span class="math">q^3 - 1</span> gives</p>

    <div class="my-4 text-center"><span class="math-block">e^{q^3 - 1} = (gh)^{q^3 - 1} = g^{q^3 - 1},</span></div>

    <p class="text-gray-300">which can then be used in protocols. If a particular protocol requires an exponentiation of this value by some integer <span class="math">k \\mod l</span>, this is performed in <span class="math">\\mathbb{F}_{q^6}</span>.</p>

    <p class="text-gray-300">In this section we give an alternative way to obtain unique representatives of <span class="math">\\mathcal{G}</span> easily, that furthermore permits fast multiplication, and provides automatic compression by a factor of two. We then show that the natural embedding of <span class="math">\\mathcal{G}</span> into the extension field is just a special representation of an algebraic torus, which permits further compression.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3.1 The Basic Idea</h2>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma] / (\\sigma^2 + 1)</span> which is the extension we use in the Duursma-Lee algorithm. Writing <span class="math">e = e_0 + e_1\\sigma</span> and <span class="math">g = g_0 + g_1\\sigma</span>, by the above we have</p>

    <div class="my-4 text-center"><span class="math-block">e = gh = g_0 h + g_1 h \\sigma.</span></div>

    <p class="text-gray-300">Since the represented coset remains invariant under multiplication by elements of <span class="math">\\mathbb{F}_{q^3}^\\times</span>, we can divide by <span class="math">e_1</span>, giving</p>

    <div class="my-4 text-center"><span class="math-block">e&#x27; = e e_1^{-1} = e_0 / e_1 + \\sigma = g_0 / g_1 + \\sigma.</span></div>

    <p class="text-gray-300">This also eliminates <span class="math">h</span> and may equally well be used as a canonical representative of the coset to which <span class="math">e</span> belongs.</p>

    <p class="text-gray-300">This element of the quotient group can be represented simply by the <span class="math">\\mathbb{F}_{q^3}</span> element <span class="math">e_0 / e_1</span>, and thus compresses the coset representation by a factor of two. Computationally, this involves a division in <span class="math">\\mathbb{F}_{q^3}</span>.</p>

    <p class="text-gray-300">Comparing this to powering by <span class="math">q^3 - 1</span>, the saving is not significant, since:</p>

    <div class="my-4 text-center"><span class="math-block">e^{q^3 - 1} = \\frac{e_0 - e_1 \\sigma}{e_0 + e_1 \\sigma},</span></div>

    <p class="text-gray-300">and hence requires only a division in <span class="math">\\mathbb{F}_{q^6}</span>.</p>

    <p class="text-gray-300">6</p>

    <p class="text-gray-300">However if one exponentiates this value by some integer <span class="math">k \\mod l</span>, this operation will be faster than if one had first powered <span class="math">e</span> by <span class="math">q^3 - 1</span>, since multiplying a generic element of <span class="math">\\mathcal{G}</span> by this element is cheaper than multiplying two generic elements. To see this let <span class="math">g = g_0 / g_1 = e_0 / e_1</span> and <span class="math">a_0 + a_1 \\sigma \\in \\mathcal{G}</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">(g + \\sigma) (a _ {0} + a _ {1} \\sigma) = (g a _ {0} - a _ {1}) + (g a _ {1} + a _ {0}) \\sigma ,</span></div>

    <p class="text-gray-300">which costs just two <span class="math">\\mathbb{F}_{q^3}</span> multiplications, and not the three required if both elements are generic, in which case the arithmetic is identical to that of <span class="math">\\mathbb{F}_{q^6}</span>. If one assumes cubings and additions are essentially free, then this method will always be roughly one third faster, for whatever practical method one uses to exponentiate. The defining property of the quotient group <span class="math">\\mathcal{G}</span> thus reduces the cost of arithmetic performed on pairing values.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3.2 Arithmetic in <span class="math">\\mathcal{G}</span></h2>

    <p class="text-gray-300">We first introduce some terminology to clarify the operations available in <span class="math">\\mathcal{G}</span>. The property that a given coset is invariant under multiplication by elements of <span class="math">\\mathbb{F}_{q^3}^\\times</span> is suggestive of the projective line</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} ^ {1} (\\mathbb {F} _ {q ^ {3}}) = \\{(x, y) / \\sim \\in (\\mathbb {F} _ {q ^ {3}}) ^ {2} \\setminus \\{(0, 0) \\} \\}</span></div>

    <p class="text-gray-300">where <span class="math">(x_{1},y_{1})\\sim (x_{2},y_{2})</span> if and only if a <span class="math">\\lambda \\in \\mathbb{F}_{q^3}^\\times</span> exists such that <span class="math">(x_{1},y_{1}) = (\\lambda x_{2},\\lambda y_{2})</span>. The reduction of <span class="math">e</span> to <span class="math">e_0 / e_1</span> may also be viewed as a map to the affine line <span class="math">\\mathbb{A}^1 (\\mathbb{F}_{q^3})</span>. With this analogy we introduce the following.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> <span class="math">\\mathcal{G}_P</span> is the projective line <span class="math">\\mathbb{P}^1 (\\mathbb{F}_{q^3})</span> endowed with the group operation induced by the arithmetic of the quadratic extension <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma ] / (\\sigma^2 +1)</span> via the map <span class="math">(x,y)\\to x + y\\sigma</span>. The identity element is represented by the points <span class="math">(\\lambda ,0)</span> for any <span class="math">\\lambda \\in \\mathbb{F}_{q^3}^\\times</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_A</span> is the affine part of the line <span class="math">\\mathcal{G}_P</span>. The affine point corresponding to <span class="math">(x,y)</span> is <span class="math">X = A(x,y) = (x / y)</span>. Via this map the identity element is the point at infinity which we denote by <span class="math">\\mathcal{O}_{\\mathcal{G}}</span>.</p>

    <p class="text-gray-300">With this terminology it should be clear that we can mimic mixed addition methods for point multiplication on elliptic curves [9]. The use of signed digit representations follows since inverses are cheap as we show below. In §4 we derive an exponentiation algorithm using a split exponent method.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">P = (x, y) \\in \\mathcal{G}_P</span> with corresponding affine representation <span class="math">(X) \\in \\mathcal{G}_A</span>. We refer to the generator of <span class="math">\\operatorname{Gal}(\\mathbb{F}_{q^6} / \\mathbb{F}_q)</span> as the <span class="math">q</span>-Frobenius, i.e., the automorphism given by powering by <span class="math">q</span>. As already stated computing the inverse of an element is virtually free. This follows since the order of <span class="math">\\mathcal{G}</span> is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{q^6}^\\times / \\mathbb{F}_{q^3}^\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= (q^5 - 1) / (q^3 - 1) = q^3 + 1<span class="math">, and so applying the cube of the Frobenius gives the inverse: </span>P^{-1} = (x, -y)<span class="math"> or </span>(-X)<span class="math"> in affine. Cubing is also straightforward since we are working in characteristic three: </span>P^3 = (x^3, -y^3)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For multiplication of two points <span class="math">P_{1} = (x_{1},y_{1}), P_{2} = (x_{2},y_{2}) \\in \\mathcal{G}_{P}</span> with affine representations <span class="math">(X_{1}), (X_{2}) \\in \\mathcal{G}_{A}</span>, we use the following easy lemma.</p>

    <p class="text-gray-300">Lemma 2. Let <span class="math">M</span> and <span class="math">I</span> represent the cost of a multiplication and inversion respectively in <span class="math">\\mathbb{F}_{q^3}</span>. Then the group operation for combinations of point representations is computed as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{1}·P_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Formula</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">(X_{1}X_{2}−1)/(X_{1}+X_{2})</td>

            <td class="px-3 py-2 border-b border-gray-700">2M+I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">(X_{1}X_{2}−1,X_{1}+X_{2})</td>

            <td class="px-3 py-2 border-b border-gray-700">1M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">(x_{1}x_{2}−y_{1}y_{2})/(x_{1}y_{2}+x_{2}y_{1})</td>

            <td class="px-3 py-2 border-b border-gray-700">4M+I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">(x_{1}x_{2}−y_{1}y_{2},x_{1}y_{2}+x_{2}y_{1})</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">(X_{1}x_{2}−y_{2})/(X_{1}y_{2}+x_{2})</td>

            <td class="px-3 py-2 border-b border-gray-700">3M+I</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G_{A}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{P}</td>

            <td class="px-3 py-2 border-b border-gray-700">(X_{1}x_{2}−y_{2},X_{1}y_{2}+x_{2})</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Squaring can naturally be performed with slightly fewer <span class="math">\\mathbb{F}_{q^3}</span> multiplications than above; the corresponding formulae are easily deduced. Besides the precomputation necessary for the exponentiation algorithms we present in Section 4 however, squarings are not required.</p>

    <p class="text-gray-300">With regard to exponentiations, it is clear that the mixed multiplication shown in the final row is the most efficient. If we want to compute <span class="math">P^k</span> for some <span class="math">k \\mod l</span>, we first convert <span class="math">P</span> to affine and for each non-zero trit in the expansion of <span class="math">k</span> perform a mixed multiplication of this point with the projective representation of the intermediate value. A multiplication with both points in projective form is equivalent to an ordinary multiplication in <span class="math">\\mathbb{F}_{q^6}</span>, so the mixed multiplication is essentially what allows the savings over arithmetic in <span class="math">\\mathbb{F}_{q^6}</span>. We exploit these observations in the exponentiation algorithms developed in §4.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3.3 An Equivalent Representation of the Quotient Group</h2>

    <p class="text-gray-300">The arithmetic just described for the quotient group is essentially identical to that developed for the torus <span class="math">T_{2}</span> [25,40]. Indeed it is not difficult to see that <span class="math">\\mathcal{G} = T_2(\\mathbb{F}_{q^3})</span>.</p>

    <p class="text-gray-300">Given <span class="math">e \\in \\mathcal{G}</span>, it is possible to compute the embedding <span class="math">e^{q^3} / e</span> of <span class="math">e</span> into <span class="math">\\mathbb{F}_{q^6}</span> and maintain invariance under multiplication by elements of <span class="math">\\mathbb{F}_{q^3}^e</span>. This may seem odd since <span class="math">\\mathbb{F}_{q^6}</span> does not possess this property. However our choice of representation of elements in the subgroup of order <span class="math">q^3 + 1</span> makes this possible. Again let <span class="math">e = e_0 + e_1\\sigma</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">e^{q^3} = e_0 - e_1\\sigma,</span></div>

    <p class="text-gray-300">and hence</p>

    <div class="my-4 text-center"><span class="math-block">e^{q^3 - 1} = \\frac{e_0 - e_1\\sigma}{e_0 + e_1\\sigma} \\in G_I \\subset \\mathbb{F}_{q^6}. \\tag{1}</span></div>

    <p class="text-gray-300">One can perform this division in <span class="math">\\mathbb{F}_{q^6}</span> and use the ordinary polynomial representation. Here we choose to leave this fraction unevaluated. Note that multiplying the numerator and denominator of (1) by any element of <span class="math">\\mathbb{F}_{q^6}^e</span> leaves the represented element unchanged.</p>

    <p class="text-gray-300">An interesting property of this representation is that when multiplying two fractions of this form, the coefficients of the numerator and the denominator</p>

    <p class="text-gray-300">correspond exactly: let</p>

    <div class="my-4 text-center"><span class="math-block">c = \\frac{c_0 - c_1 \\sigma}{c_0 + c_1 \\sigma}, \\quad d = \\frac{d_0 - d_1 \\sigma}{d_0 + d_1 \\sigma},</span></div>

    <p class="text-gray-300">with <span class="math">c_i, d_i \\in \\mathbb{F}_{q^3}</span>. Then since <span class="math">\\sigma^2 + 1 = 0</span>, we see that</p>

    <div class="my-4 text-center"><span class="math-block">c d = \\frac{(c_0 d_0 - c_1 d_1) - (c_0 d_1 + c_1 d_0) \\sigma}{(c_0 d_0 - c_1 d_1) + (c_0 d_1 + c_1 d_0) \\sigma}.</span></div>

    <p class="text-gray-300">This also follows trivially from the fact that <span class="math">(cd)^{q^3 - 1} = c^{q^3 - 1} \\cdot d^{q^3 - 1}</span>.</p>

    <p class="text-gray-300">For an implementation this allows one therefore to work with the denominator only, since one knows that the coefficients of the numerator will be identical. Hence one may view our previous operations in <span class="math">\\mathcal{G}</span> without powering equivalently as operating purely on the denominator of (1) after powering, and so all the arithmetic carries over unchanged.</p>

    <p class="text-gray-300"><strong>Remark 1.</strong> The representation (1) and its identification with <span class="math">\\mathbb{P}^1</span> were given explicitly by Rubin and Silverberg [40]. However the arithmetical consequences of embedding this representation into the extension field were only fully considered in [25], where it was also noted that one may also represent <span class="math">T_2</span> as a quotient group. Thus while these ideas are not new (the representation (1) is a simple application of Hilbert’s Theorem 90), they find a novel application in pairing-based cryptography.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3.4 Further Compression Using <span class="math">T_6(\\mathbb{F}_q)</span></h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the characteristic three supersingular elliptic curves we consider have embedding degree six, one may ask why we use the arithmetic of <span class="math">T_2(\\mathbb{F}_{q^3})</span> when the order <span class="math">l</span> subgroup is in fact in <span class="math">T_6(\\mathbb{F}_q)</span>? The reason is that there seems no obvious way to utilise the extra structure provided by <span class="math">T_6(\\mathbb{F}_q)</span> [25], though we do not rule out such a possibility. However we know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_6(\\mathbb{F}_q)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= (q^2 - q + 1) \\mid (q^3 + 1) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_2(\\mathbb{F}_{q^3})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and so </span>T_6(\\mathbb{F}_q) \\subset T_2(\\mathbb{F}_{q^3})$. Thus one can use the properties of the latter and apply them to the former, utilising the improvements derived over the extension field representation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">While arithmetic improvements do not seem available with <span class="math">T_6</span>, one can exploit it for better compression. As <span class="math">T_6</span> is rational, one can map nearly all its elements to the affine plane and use this representation instead for data transmissions.</p>

    <p class="text-gray-300">Using the method described by Rubin and Silverberg [40], and thanks to some serendipitous equations for characteristic three and the given field representation, one obtains this additional compression for free.</p>

    <p class="text-gray-300">By Definition 1,</p>

    <div class="my-4 text-center"><span class="math-block">T_6(\\mathbb{F}_q) = \\mathrm{Ker}(N_{\\mathbb{F}_{q^6}/\\mathbb{F}_{q^3}}) \\cap \\mathrm{Ker}(N_{\\mathbb{F}_{q^6}/\\mathbb{F}_{q^2}}) = T_2(\\mathbb{F}_{q^3}) \\cap \\mathrm{Ker}(N_{\\mathbb{F}_{q^6}/\\mathbb{F}_{q^2}}).</span></div>

    <p class="text-gray-300">To obtain a suitable representation one therefore only needs to parametrise those elements of the form (1) which have norm equal to one in the second factor.</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">Let <span class="math">e = (a - \\sigma) / (a + \\sigma)</span> be the compressed representation for <span class="math">e</span>, and let <span class="math">a = a_0 + a_1\\rho +a_2\\rho^2</span> where <span class="math">\\rho^3 -\\rho \\pm 1 = 0</span> defines the cubic extension we later use for the Duursma-Lee algorithm. Then we obtain an equation in <span class="math">a_0,a_1</span>, and <span class="math">a_2</span> by the condition</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {a - \\sigma}{a + \\sigma}\\right) ^ {1 + q ^ {2} + q ^ {4}} = 1.</span></div>

    <p class="text-gray-300">This is equivalent to <span class="math">1 + a_1^2 - a_0a_2 - a_2^2 = 0</span>, which one can parametrise easily with just <span class="math">a_1</span> and <span class="math">a_2</span>, since <span class="math">a_0 = (1 + a_1^2 - a_2^2) / a_2</span>. It is therefore sufficient to specify only <span class="math">a_1</span> and <span class="math">a_2</span>, to describe all points on <span class="math">T_6(\\mathbb{F}_q)</span> bar the identity, and this is essentially all that we need. We therefore have a map <span class="math">\\psi : \\mathbb{A}^2(\\mathbb{F}_q) \\setminus \\{(a_1,0)\\} \\to T_6(\\mathbb{F}_q) \\setminus \\{1\\}</span> given by</p>

    <div class="my-4 text-center"><span class="math-block">\\psi (a _ {1}, a _ {2}) = \\frac {((1 + a _ {1} ^ {2} - a _ {2} ^ {2}) + a _ {1} a _ {2} \\rho + a _ {2} ^ {2} \\rho^ {2}) - a _ {2} \\sigma}{((1 + a _ {1} ^ {2} - a _ {2} ^ {2}) + a _ {1} a _ {2} \\rho + a _ {2} ^ {2} \\rho^ {2}) + a _ {2} \\sigma}.</span></div>

    <p class="text-gray-300">The inverse map <span class="math">\\psi^{-1}: T_6(\\mathbb{F}_q) \\setminus \\{1\\} \\to \\mathbb{A}^2(\\mathbb{F}_q) \\setminus \\{(a_1,0)\\}</span> is given as above, i.e., we just take the second and third coefficients in the fractional expression for <span class="math">e</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathbb{A}^2 (\\mathbb{F}_q)\\setminus \\{(a_1,0)\\}</span> and <span class="math">T_{6}(\\mathbb{F}_{q})\\setminus \\{1\\}</span> both have cardinality <span class="math">q^{2} - q</span>. In terms of the quotient group <span class="math">\\mathcal{G}</span> and an actual pairing computation, once <span class="math">e_0 / e_1</span> is computed one can use the second and third coefficients to parametrise the element, without any further computation.</p>

    <p class="text-gray-300">Remark 2. In the context of compression, Rubin and Silverberg [39,41] have shown how one can compress BLS short-signatures [6] by using the trace-zero subvariety contained in the Weil restriction of scalars of an elliptic curve defined over a composite field extension. This method provides a compression factor of <span class="math">n / \\phi (n)</span> also, where <span class="math">\\gcd (n,2) = 1</span>, and can be applied to any pairing-based protocol where one is required to transmit a point on the curve, such as [28]. However for <span class="math">n\\geq 5</span>, building upon an idea of Semaev [45], Gaudry has shown that such curves are weaker than those defined over prime field [20]. Hence this method should be regarded with some caution. We point out that this form of pre-compression is distinct from the post-compression described here, and thus these attacks do not apply.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 Exponentiation</h2>

    <p class="text-gray-300">Now that we have set up the basic arithmetic for <span class="math">\\mathcal{G}</span>, we explore how one can optimise the basic operation of exponentiation in practice. For comparison, we also describe fast algorithms for exponentation in <span class="math">G_{l}</span> using techniques from [49], and point multiplication in <span class="math">E(\\mathbb{F}_q)</span>, incorporating a novel technique we develop here.</p>

    <p class="text-gray-300">For ease of notation we write the group operation for all three groups multiplicatively, and for each of the above we compare four exponentiation methods, which we detail in turn. The input to each algorithm is a base <span class="math">e</span> and an integer <span class="math">k</span> mod <span class="math">l</span> in standard ternary format. The output is <span class="math">e^k</span>. When applicable, precomputed values are stored in affine to facilitate the mixed multiplication. We note</p>

    <p class="text-gray-300">that in all three groups inversions are essentially for free, so we consider signed digit representations.</p>

    <h2 id="sec-12" class="text-2xl font-bold">Method 1: Signed Ternary Expansion</h2>

    <p class="text-gray-300">Using the generalised non-adjacent form, or G-NAF [8], one can take the ternary expansion of an exponent <span class="math">k \\bmod l</span> and transform it into an equivalent signed ternary representation. Such a representation is easy to compute and reduces the average density of non-zero trits from two thirds to one half. The precomputation involves just a single squaring of the base.</p>

    <h2 id="sec-13" class="text-2xl font-bold">Method 2: Signed Nonary Expansion</h2>

    <p class="text-gray-300">This is the same as Method 1 except we use a base nine expansion of <span class="math">k</span>. This essentially halves the trit-length of <span class="math">k</span> for the cost of precomputing <span class="math">e^i, i = 1, \\dots, 8</span>. Again using the G-NAF, the average density of non-zero 'nits' in this expansion is four fifths.</p>

    <h2 id="sec-14" class="text-2xl font-bold">Method 3: Sliding Window Ternary Expansion</h2>

    <p class="text-gray-300">We use an unsigned ternary expansion of <span class="math">k</span> with a sliding window of width three [33][Chapter 14, Algorithm 14.85]. To do so one needs to precompute and store <span class="math">e^i</span> for <span class="math">0 &amp;lt; i &amp;lt; 27</span> and <span class="math">i \\neq 0 \\mod 3</span>.</p>

    <h2 id="sec-15" class="text-2xl font-bold">Method 4: Frobenius Expansion</h2>

    <p class="text-gray-300">For <span class="math">e \\in \\mathcal{G}</span> the <span class="math">q</span>-Frobenius map is easily computed. Moreover, the <span class="math">q</span>-th power of a compressed element is itself compressed. Since the Frobenius map satisfies <span class="math">q^2 - q + 1 = 0</span> (as maps) and the group order divides <span class="math">q^2 - q + 1</span>, one can split the exponent <span class="math">k</span> in two halves <span class="math">k_1</span> and <span class="math">k_2</span> where <span class="math">k_1, k_2</span> are approximately half the trit-length of <span class="math">l</span> and satisfy <span class="math">k \\equiv k_1 + k_2q \\mod l</span> [49]. One can find <span class="math">k_1</span> and <span class="math">k_2</span> very quickly having performed a one-time Gaussian two-dimensional lattice basis reduction.</p>

    <p class="text-gray-300">Thus a single exponentiation can be transformed into a double exponentiation for half the trit-length of <span class="math">k</span>, for the cost of performing a double exponentiation instead. To compute <span class="math">e^k</span> for a random <span class="math">k \\bmod l</span>, we perform the double exponentiation <span class="math">e^{k_1}(e^q)^{k_2}</span> using Shamir's trick, originally due to Straus [51]. We detail the required precomputation in the next section.</p>

    <p class="text-gray-300">For each of <span class="math">k_1, k_2</span> we invoke the G-NAF. The average density of non-zero trits in each of their ternary expansions is <span class="math">1/2</span> and hence the average number of non-zero trits in the paired ternary expansion of <span class="math">k_1, k_2</span> is <span class="math">1 - (1/2)^2 = 3/4</span>. We therefore expect to perform on average <span class="math">(3/4) \\cdot m/2 = (3/8)m</span> multiplications of mixed type during an exponentiation.</p>

    <p class="text-gray-300">Interestingly enough, this method also works for the elliptic curve. Clearly, one can use the same expansion of <span class="math">k</span> on <span class="math">E(\\mathbb{F}_q)</span>, with powering by <span class="math">q</span> is replaced by scalar multiplication by <span class="math">q</span>. Somewhat surprisingly, on the curve also,</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">multiplication by <span class="math">q</span> is an efficiently computable automorphism since <span class="math">[q]P = (x - (m \\bmod 3)b, -y)</span> for <span class="math">P = (x,y)</span> on the curve (where the curve equation is <span class="math">Y^2 = X^3 - X + b</span>). Thus we arrive at a novel application of the Gallant-Lambert-Vanstone exponent split method using fast automorphisms [18].</p>

    <p class="text-gray-300">We note that for supersingular curves over characteristic three there is also an efficient scalar multiplication algorithm due to Koblitz [29] based on the curve automorphism mapping the point <span class="math">(x,y)</span> to <span class="math">(x^3,y^3)</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4.1 Precomputation</h2>

    <p class="text-gray-300">The necessary precomputation for Methods 1, 2 and 3 is straightforward. For Method 4 we can take advantage of the <span class="math">q</span>-Frobenius to reduce the cost. We use the notation of <span class="math">\\mathcal{G}</span>. Let <span class="math">e = e_0 + e_1\\sigma</span>. In order to use Shamir's trick, we need to know the values</p>

    <div class="my-4 text-center"><span class="math-block">(e_0 / e_1 + \\sigma)^{i+qj} \\quad i, j \\in \\{0, \\pm 1, \\pm 2\\} \\tag{2}</span></div>

    <p class="text-gray-300">in affine. Let <span class="math">(i,j)</span> represent the corresponding term in (2). Then we can use the fact that for any <span class="math">e \\in \\mathcal{G}</span>, we have <span class="math">e^{q^3 - q + 1} = \\mathcal{O}_{\\mathcal{G}}</span> to generate most of the required terms easily. To achieve this, one applies the <span class="math">q</span>-Frobenius iteratively to obtain <span class="math">(i,j)^q = (-j,i + j)</span>. We list these operations in Algorithm 1. In <span class="math">G_l</span> we use the same method, having first powered <span class="math">e</span> by <span class="math">q^3 - 1</span>, but clearly without needing to obtain affine representatives.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4.2 Comparison with Trace-Based Exponentiation</h2>

    <p class="text-gray-300">The cost of a mixed multiplication in <span class="math">\\mathcal{G}</span> is <span class="math">12M</span>. Since <span class="math">l \\approx 3^m</span>, an exponentiation using Method 4 costs on average about <span class="math">4.5mM</span>. This improves considerably on the <span class="math">12mM</span> required by the trace method of [44]. Even without mixed multiplication, this exponentiation still only requires <span class="math">6.75mM</span>, and with neither the exponent splitting nor the mixed multiplication, this cost is only about <span class="math">9mM</span>. Hence ordinary field arithmetic outperforms the proposed trace method, which in fact can be reduced further to about <span class="math">10.3mM</span> using a Euclidean algorithm [50], but is still over twice as slow.</p>

    <h2 id="sec-18" class="text-2xl font-bold">4.3 Application to Other Pairings</h2>

    <p class="text-gray-300">We have focused primarily on small characteristic tori because the Duursma-Lee algorithm is currently the most efficient for pairing computation. In the future, the preferred embedding degree of a curve will increase in order to maintain a good security/efficiency trade-off, and thus it is likely that non-supersingular curves over large characteristic fields will be used.</p>

    <p class="text-gray-300">Since the embedding degree <span class="math">n</span> of a pairing on a given abelian variety is minimal, the output of any pairing may be considered an element of the torus <span class="math">T_n</span>. Hence all of the techniques developed for torus-based cryptography may be applied, certainly for any embedding degree less than thirty.</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">|  Algorithm 1: Online Pre-computation for Double Exponentiation  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  input : e = e0 + e1σ ∈ G  |   |</p>

    <p class="text-gray-300">|  output : Representatives in G_A of (i,j) := (e0 + e1σ)^i+jq, i,j ∈ {0,±1,±2}  |   |</p>

    <p class="text-gray-300">|  (1,0) ← A(e)  |   |</p>

    <p class="text-gray-300">|  (0,1) ← -(1,0)^q  |   |</p>

    <p class="text-gray-300">|  (-1,1) ← -(0,1)^q  |   |</p>

    <p class="text-gray-300">|  (-1,0) ← -(-1,1)^q  |   |</p>

    <p class="text-gray-300">|  (0,-1) ← -(-1,0)^q  |   |</p>

    <p class="text-gray-300">|  (1,-1) ← -(0,-1)^q  |   |</p>

    <p class="text-gray-300">|  (2,0) ← mul((1,0), (1,0))  |   |</p>

    <p class="text-gray-300">|  (2,0) ← A((2,0))  |   |</p>

    <p class="text-gray-300">|  (0,2) ← -(2,0)^q  |   |</p>

    <p class="text-gray-300">|  (-2,2) ← -(0,2)^q  |   |</p>

    <p class="text-gray-300">|  (-2,0) ← -(-2,2)^q  |   |</p>

    <p class="text-gray-300">|  (0,-2) ← -(-2,0)^q  |   |</p>

    <p class="text-gray-300">|  (2,-2) ← -(0,-2)^q  |   |</p>

    <p class="text-gray-300">|  (1,1) ← mul((1,0), (0,1))  |   |</p>

    <p class="text-gray-300">|  (1,1) ← A((1,1))  |   |</p>

    <p class="text-gray-300">|  (-1,2) ← -(1,1)^q  |   |</p>

    <p class="text-gray-300">|  (-2,1) ← -(-1,2)^q  |   |</p>

    <p class="text-gray-300">|  (-1,-1) ← -(-2,1)^q  |   |</p>

    <p class="text-gray-300">|  (1,-2) ← -(-1,-1)^q  |   |</p>

    <p class="text-gray-300">|  (2,-1) ← -(1,-2)^q  |   |</p>

    <p class="text-gray-300">|  (1,2) ← mul((1,0), (0,2))  |   |</p>

    <p class="text-gray-300">|  (1,2) ← A((1,2))  |   |</p>

    <p class="text-gray-300">|  (-1,-2) ← -(1,2)  |   |</p>

    <p class="text-gray-300">|  (2,1) ← mul((2,0), (0,1))  |   |</p>

    <p class="text-gray-300">|  (2,1) ← A((2,1))  |   |</p>

    <p class="text-gray-300">|  (-2,-1) ← -(2,1)  |   |</p>

    <p class="text-gray-300">|  (2,2) ← mul((2,0), (0,2))  |   |</p>

    <p class="text-gray-300">|  (2,2) ← A((2,2))  |   |</p>

    <p class="text-gray-300">|  (-2,-2) ← -(2,2)  |   |</p>

    <p class="text-gray-300">However, earlier work [25] shows that for large characteristic, the trace-based methods such as LUC [47] (for degree two extensions), and XTR [31, 50] (for degree six extensions), are slightly faster than the torus approach. For the near future however, our methods are likely to remain near-optimal.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5 Field Representation</h2>

    <p class="text-gray-300">We briefly describe efficient arithmetic for <span class="math">\\mathbb{F}_q</span> and the required extensions.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">Field Arithmetic in <span class="math">\\mathbb{F}_q</span></h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_q = \\mathbb{F}_{3^m}</span>. Let <span class="math">a = a_{m-1}x^{m-1} + \\dots + a_1x + a_0</span> be an element of <span class="math">\\mathbb{F}_q</span>, held in a polynomial basis, so that <span class="math">a_i \\in \\mathbb{F}_3</span>. We follow other work [17, 26] and represent the element <span class="math">a</span> as two bit-vectors <span class="math">a_H</span> and <span class="math">a_L</span>. If we let <span class="math">a_H[i]</span> and <span class="math">a_L[i]</span> denote bit <span class="math">i</span> of <span class="math">a_H</span> and <span class="math">a_L</span> respectively, the vectors <span class="math">a_H</span> and <span class="math">a_L</span> are constructed from <span class="math">a</span> such that for all <span class="math">i</span></p>

    <div class="my-4 text-center"><span class="math-block">a_H[i] = a_i \\operatorname{div} 2</span></div>

    <div class="my-4 text-center"><span class="math-block">a_L[i] = a_i \\bmod 2.</span></div>

    <p class="text-gray-300">That is, <span class="math">a_H</span> and <span class="math">a_L</span> are a bit-sliced representation of the coefficients of <span class="math">a</span> where <span class="math">a_H</span> holds the high bit and <span class="math">a_L</span> the low bit of a given coefficient. Given a representation of this type, we can perform a component-wise addition <span class="math">r_i = a_i + b_i</span> of two elements <span class="math">a</span> and <span class="math">b</span> using the following word-wise logical operations</p>

    <div class="my-4 text-center"><span class="math-block">r_H[i] = (a_L[i] \\vee b_L[i]) \\oplus t</span></div>

    <div class="my-4 text-center"><span class="math-block">r_L[i] = (a_H[i] \\vee b_H[i]) \\oplus t</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">t = (a_L[i] \\vee b_H[i]) \\oplus (a_H[i] \\vee b_L[i]).</span></div>

    <p class="text-gray-300">Subtraction, and hence multiplication by two, are equally efficient since the negation of an element <span class="math">a</span> simply swaps the vectors <span class="math">a_H</span> and <span class="math">a_L</span> over and can therefore be implemented by the same function as addition.</p>

    <p class="text-gray-300">On a given computer with word-size <span class="math">w</span>, we hold the bit-vectors <span class="math">a_H</span> and <span class="math">a_L</span> that represent <span class="math">a</span> as two word-vectors of length <span class="math">n = \\lceil m / w \\rceil</span> and hence apply logical operations in parallel to <span class="math">w</span> coefficients at a time. However, since our representation remains bit-oriented we can borrow further techniques developed for fields of characteristic two. Specifically, it is possible to construct multiplication using a variation of the often cited comb method [32] and inversion by altering the binary extended Euclidean algorithm. We used a Karatsuba method to aggressively split the multiplication operands into word sized chunks, an option that provided significant performance improvements. Unlike elements in characteristic two, squaring in characteristic three is only marginally less expensive than general multiplication. However, cubing can be performed very quickly using table-lookup in an analogous way to the so called coefficient thinning method in characteristic two.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q^3} = \\mathbb{F}_q[\\rho] / (\\rho^3 - \\rho - b)</span>, with <span class="math">b = \\pm 1</span> depending on the curve equation. Let <span class="math">a = a_0 + a_1\\rho + a_2\\rho^2</span> and <span class="math">b = b_0 + b_1\\rho + b_2\\rho^2</span> be two generic elements. We require the following operations.</p>

    <p class="text-gray-300"><strong>q-Frobenius:</strong> Since <span class="math">\\rho^3 = \\rho + b</span> we have <span class="math">\\rho^{3^m} = \\rho + (m \\bmod 3)b</span> and <span class="math">(\\rho^2)^{3^m} = (\\rho^{3^m})^2 = \\rho^2 + 2b(m \\bmod 3)\\rho + (m^2 \\bmod 3)</span>. Hence <span class="math">a^{3^m} = (a_0 + a_1\\rho + a_2\\rho^2)^{3^m} = (a_0 + a_1b(m \\bmod 3) + a_2b) + (a_1 - a_2b(m \\bmod 3))\\rho + a_2\\rho^2</span>.</p>

    <p class="text-gray-300"><strong>Multiplication:</strong> Let <span class="math">t_{00} = a_0b_0</span>, <span class="math">t_{11} = a_1b_1</span>, <span class="math">t_{22} = a_2b_2</span>, <span class="math">t_{01} = (a_0 + a_1)(b_0 + b_1)</span>, <span class="math">t_{12} = (a_1 + a_2)(b_1 + b_2)</span>, and <span class="math">t_{20} = (a_2 + a_0)(b_2 + b_0)</span>. Then <span class="math">ab = (t_{00} + (t_{12} - t_{11} - t_{22})b) + (t_{01} - t_{00} + t_{11} + t_{12} + t_{22}(b - 1))\\rho + (t_{20} - t_{00} + t_{11})\\rho^2</span>.</p>

    <p class="text-gray-300"><strong>Cubing:</strong> This is straightforward in characteristic three. Since <span class="math">a^3 = (a_0^3 + a_2^3 + a_1^3 b) + (a_1^3 - a_2^3 b)\\rho + a_2^3\\rho^2</span>.</p>

    <p class="text-gray-300"><strong>Inversion:</strong> Since the extension degree is small, we can perform this directly. Let <span class="math">t_{00} = a_0^2</span>, <span class="math">t_{11} = a_1^2</span>, <span class="math">t_{22} = a_2^2</span>, <span class="math">t_{01} = a_0a_1</span>, <span class="math">t_{12} = a_1a_2</span>, <span class="math">t_{20} = a_2a_0</span>, and let <span class="math">\\Delta = a_0^3 + a_1^3b + a_2^3 + t_{20}(a_2 - a_0) - a_1(t_{01} + t_{22}b)</span>. Then <span class="math">a^{-1} = \\Delta^{-1}((t_{00} - t_{20} + t_{22} - t_{11} - t_{12}b) + (t_{22}b - t_{01})\\rho + (t_{11} - t_{20} - t_{22})\\rho^2)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q^6} = \\mathbb{F}_{q^3}[\\sigma] / (\\sigma^2 + 1)</span>. Let <span class="math">c = c_0 + c_1\\sigma</span> and <span class="math">d = d_0 + d_1\\sigma</span> with <span class="math">c_i, d_i \\in \\mathbb{F}_{q^3}</span> be two generic elements. The arithmetic is as follows.</p>

    <p class="text-gray-300"><strong>q-Frobenius:</strong> Since <span class="math">\\sigma^2 = -1</span>, we have that <span class="math">\\sigma^3 = -\\sigma</span> and as <span class="math">m</span> is odd, we obtain <span class="math">c^{3^m} = c_0^{3^m} - c_1^{3^m}\\sigma</span>.</p>

    <p class="text-gray-300"><strong>Multiplication:</strong> Let <span class="math">t_{00} = c_0d_0</span>, <span class="math">t_{11} = c_1d_1</span>, and <span class="math">t_{01} = (c_0 + c_1)(d_0 + d_1)</span>. Then <span class="math">cd = (t_{00} - t_{11}) + (t_{01} - t_{00} - t_{11})\\sigma</span>.</p>

    <p class="text-gray-300"><strong>Cubing:</strong> <span class="math">c^3 = c_0^3 - c_1^3\\sigma</span>.</p>

    <p class="text-gray-300"><strong>Inversion:</strong> Let <span class="math">\\Delta = c_0^2 + c_1^2</span>. Then <span class="math">c^{-1} = \\Delta^{-1}(c_0 - c_1\\sigma)</span>.</p>

    <p class="text-gray-300">In this section we detail how to efficiently implement the Duursma-Lee algorithm for the computation of the modified Tate pairing.</p>

    <p class="text-gray-300">Let <span class="math">P = (x_{1},y_{1})</span> and <span class="math">Q = (x_{2},y_{2})</span> be points of order <span class="math">l</span>. Then the modified Tate pairing on the supersingular curve <span class="math">E(\\mathbb{F}_q):Y^2 = X^3 -X + b</span> is the mapping <span class="math">f_{P}(\\phi (Q))^{q^{3} - 1}</span> where <span class="math">\\phi :E(\\mathbb{F}_q)\\to E(\\mathbb{F}_{q^6})</span> is the distortion map <span class="math">\\phi (x_2,y_2) = (\\rho -x_2,\\sigma y_2)</span>. However, making use of the techniques of §3 we do not need to perform the final powering, as we presume the output will be stored and transmitted in compressed form (Algorithm 2).</p>

    <p class="text-gray-300">|  Algorithm 2: The Duursma-Lee Algorithm  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  input : point P = (x1, y1), point Q = (x2, y2)  |   |</p>

    <p class="text-gray-300">|  output : fP(φ(Q)) ∈ G  |   |</p>

    <p class="text-gray-300">|  f ← 1  |   |</p>

    <p class="text-gray-300">|  for i = 1 to m do  |   |</p>

    <p class="text-gray-300">|  x1 ← x13, y1 ← y13  |   |</p>

    <p class="text-gray-300">|  μ ← x1 + x2 + b, λ ← -y1y2σ - μ2  |   |</p>

    <p class="text-gray-300">|  g ← λ - μρ - ρ2, f ← f · g  |   |</p>

    <p class="text-gray-300">|  x2 ← x21/3, y2 ← y21/3  |   |</p>

    <p class="text-gray-300">|  end  |   |</p>

    <p class="text-gray-300">|  return f  |   |</p>

    <p class="text-gray-300">Let  <span class="math">M</span>  denote the cost of an  <span class="math">\\mathbb{F}_q</span>  multiplication. Each iteration of the loop requires  <span class="math">2M</span>  to compute  <span class="math">\\mu^2</span>  and  <span class="math">y_1y_2</span> , and an  <span class="math">\\mathbb{F}_{q^6}</span>  multiplication to compute  <span class="math">f\\cdot g</span> . Since a generic  <span class="math">\\mathbb{F}_{q^6}</span>  multiplication costs  <span class="math">18M</span> , Scott and Barreto [44] reckon that besides the necessary cubings and cube roots, each loop iteration costs  <span class="math">20M</span> . However, in each iteration  <span class="math">g</span>  is sparse, i.e., not all of its terms are non-trivial. One can exploit this to reduce the cost of multiplying  <span class="math">g</span>  and  <span class="math">f</span> , which is not sparse in general, to  <span class="math">13M</span> . This total of  <span class="math">15M</span>  improves on the trace-based method suggested by Scott and Barreto. In fact one can reduce the cost for each loop iteration in the ordinary Duursma-Lee algorithm to just  <span class="math">14M</span> , by unrolling the main loop and better exploiting the sparsity of  <span class="math">g</span> .</p>

    <p class="text-gray-300">Algorithm 3: A Refined Duursma-Lee Algorithm. input : point  <span class="math">P = (x_{1},y_{1})</span>  , point  <span class="math">Q = (x_{2},y_{2})</span> output :  <span class="math">f_{P}(\\phi (Q))\\in \\mathcal{G}</span> <span class="math">f\\gets 1</span> for  <span class="math">i = 1</span>  to  <span class="math">(m - 1) / 2</span>  do <span class="math">x_{1}\\leftarrow x_{1}^{3},y_{1}\\leftarrow y_{1}^{3}</span> <span class="math">\\mu \\leftarrow x_1 + x_2 + b,\\lambda \\leftarrow -y_1y_2\\sigma -\\mu^2</span> <span class="math">g_{1}\\leftarrow \\lambda -\\mu \\rho -\\rho^{2}</span> <span class="math">x_{2}\\leftarrow x_{2}^{1 / 3},y_{2}\\leftarrow y_{2}^{1 / 3}</span> <span class="math">x_{1}\\leftarrow x_{1}^{3},y_{1}\\leftarrow y_{1}^{3}</span> <span class="math">\\mu \\leftarrow x_1 + x_2 + b,\\lambda \\leftarrow -y_1y_2\\sigma -\\mu^2</span> <span class="math">g_{2}\\leftarrow \\lambda -\\mu \\rho -\\rho^{2}</span> <span class="math">g\\gets g_1g_2,f\\gets f\\cdot g</span> <span class="math">x_{2}\\leftarrow x_{2}^{1 / 3},y_{2}\\leftarrow y_{2}^{1 / 3}</span> end <span class="math">x_{1}\\gets x_{1}^{3},y_{1}\\gets y_{1}^{3}</span> <span class="math">\\mu \\leftarrow x_1 + x_2 + b,\\lambda \\leftarrow -y_1y_2\\sigma -\\mu^2</span> <span class="math">g\\gets \\lambda -\\mu \\rho -\\rho^2,f\\gets f\\cdot g</span> return f</p>

    <p class="text-gray-300">We demonstrate this technique in Algorithm 3 which provides a saving since in each loop, multiplying <span class="math">g_{1}</span> by <span class="math">g_{2}</span> costs only <span class="math">6M</span>. Multiplying <span class="math">g</span> by <span class="math">f</span> in each loop costs <span class="math">18M</span> since they are both generic <span class="math">\\mathbb{F}_{q^6}</span> elements. Both <span class="math">\\mu^2</span> and <span class="math">y_{1}y_{2}</span> are computed twice in each loop: once for <span class="math">g_{1}</span> and once for <span class="math">g_{2}</span>. In total the cost therefore is <span class="math">(6M + 4M)(m - 1)/2 + 18M(m - 3)/2 + 13M = 14mM - 19M</span>, which is equivalent to about <span class="math">14M</span> per loop iteration of Algorithm 2.</p>

    <p class="text-gray-300">This cost analysis ignores the cost of computing cubings and cube roots. Because of the large number of times each of these operations are invoked, it has been suggested that one should use normal bases to accommodate them efficiently, since they are then implemented using cyclic shifts. Normal bases are well-studied in even characteristic, but for characteristic three one can not construct optimal, type one normal bases with prime extension degree [19,36], although type two bases are available for some values of <span class="math">m</span>. As a result, the cost of general multiplication in software is relatively large, even when variations of high performance methods in characteristic two are used [38,35]. For example, we found that when <span class="math">m = 239</span> normal basis multiplication is between two and three times slower than a polynomial basis multiplication. However, in hardware implementations on a smart-card for example, normal bases still seem the obvious choice since they can match the multiplication speed of polynomial basis while offering inexpensive cube and cube root operations, although perhaps at the cost of flexibility.</p>

    <p class="text-gray-300">To reduce the cost of computing cube roots using a polynomial basis, we observe that the successive cube roots of <span class="math">x_{2}</span> and <span class="math">y_{2}</span> can be computed more easily in reverse order and stored for the duration of the algorithm. Since for any <span class="math">x_{2} \\in \\mathbb{F}_{q}</span>, we have <span class="math">x_{2} = x_{2}^{3^{m}}</span>, the required values <span class="math">x_{2}^{1/3^{t}}</span> can be computed as <span class="math">x_{2}^{3^{m-i}}</span>, and thus one does not need to compute any cube roots at all. The memory requirement for this is only about <span class="math">2^{-11}m^{2}</span> Kb and the time taken is just the cost of <span class="math">2m</span> cubings. If memory is at a premium, one can reduce this to about <span class="math">2^{-4.5}m^{3/2}</span> Kb with double the number of cubings using further loop unrolling and pebbling strategies.</p>

    <p class="text-gray-300"><strong>Remark 3.</strong> As already mentioned, Scott and Barreto's method [44] is effectively a change of basis and not a compressed method of computing a pairing. Hence it is unsurprising that the loop unrolling strategy of Algorithm 3 can be used to reduce the cost of the trace method given there, as kindly pointed out by Barreto [1].</p>

    <p class="text-gray-300"><strong>Remark 4.</strong> Scott and Barreto [44] suggested an open problem asking if it possible to perform the pairing computation directly in compressed form for some compression factor <span class="math">\\geq 3</span> on ordinary (non-supersingular) curves in characteristic <span class="math">p &amp;gt; 3</span>. A compression factor larger than 3 is extremely unlikely. For pairing-based applications, the desirable extension degrees in the near future are likely to remain small, and no larger than twenty. By Lemma 1, the maximum compression factor possible for a given extension degree <span class="math">n</span> is <span class="math">n / \\phi(n)</span>, and for <span class="math">n &amp;lt; 20</span>, this maximum is three, which is already achieved for the modified Tate pairing.</p>

    <p class="text-gray-300">17</p>

    <p class="text-gray-300">Fig. 2. Pairing and Exponentiation Timings.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F379</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F397</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F3168</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F3198</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F3239</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F3353</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Pairing  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BKLS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13.96ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">23.60ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">79.11ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">123.21ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">179.30ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">527.56ms</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Exponentiation in G_{l}  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.65ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6.14ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20.98ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33.21ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44.72ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">130.27ms</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Method 3</td>

            <td class="px-3 py-2 border-b border-gray-700">3.67ms</td>

            <td class="px-3 py-2 border-b border-gray-700">5.79ms</td>

            <td class="px-3 py-2 border-b border-gray-700">17.85ms</td>

            <td class="px-3 py-2 border-b border-gray-700">26.69ms</td>

            <td class="px-3 py-2 border-b border-gray-700">36.45ms</td>

            <td class="px-3 py-2 border-b border-gray-700">101.75ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Method 4</td>

            <td class="px-3 py-2 border-b border-gray-700">3.06ms</td>

            <td class="px-3 py-2 border-b border-gray-700">5.10ms</td>

            <td class="px-3 py-2 border-b border-gray-700">16.55ms</td>

            <td class="px-3 py-2 border-b border-gray-700">24.67ms</td>

            <td class="px-3 py-2 border-b border-gray-700">34.74ms</td>

            <td class="px-3 py-2 border-b border-gray-700">99.56ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Exponentiation in G  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.55ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4.27ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14.15ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">21.67ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">30.69ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">88.06ms</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Method 3</td>

            <td class="px-3 py-2 border-b border-gray-700">3.69ms</td>

            <td class="px-3 py-2 border-b border-gray-700">4.72ms</td>

            <td class="px-3 py-2 border-b border-gray-700">15.78ms</td>

            <td class="px-3 py-2 border-b border-gray-700">22.96ms</td>

            <td class="px-3 py-2 border-b border-gray-700">37.96ms</td>

            <td class="px-3 py-2 border-b border-gray-700">73.29ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Method 4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.32ms</td>

            <td class="px-3 py-2 border-b border-gray-700">4.07ms</td>

            <td class="px-3 py-2 border-b border-gray-700">11.84ms</td>

            <td class="px-3 py-2 border-b border-gray-700">17.63ms</td>

            <td class="px-3 py-2 border-b border-gray-700">24.73ms</td>

            <td class="px-3 py-2 border-b border-gray-700">69.30ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Point Multiplication in E(F_{q})  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.83ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.11ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10.62ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16.94ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">24.11ms</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">69.78ms</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Method 3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.82ms</td>

            <td class="px-3 py-2 border-b border-gray-700">3.01ms</td>

            <td class="px-3 py-2 border-b border-gray-700">9.66ms</td>

            <td class="px-3 py-2 border-b border-gray-700">14.95ms</td>

            <td class="px-3 py-2 border-b border-gray-700">21.19ms</td>

            <td class="px-3 py-2 border-b border-gray-700">58.70ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Method 4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.18ms</td>

            <td class="px-3 py-2 border-b border-gray-700">1.95ms</td>

            <td class="px-3 py-2 border-b border-gray-700">8.11ms</td>

            <td class="px-3 py-2 border-b border-gray-700">12.75ms</td>

            <td class="px-3 py-2 border-b border-gray-700">19.04ms</td>

            <td class="px-3 py-2 border-b border-gray-700">55.93ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h2 id="sec-25" class="text-2xl font-bold">7 Implementation Results</h2>

    <p class="text-gray-300">In order to provide some concrete idea of the practical cost of our own and other methods, we implemented the proposed field arithmetic, pairing algorithms and exponentiation methods. We used a GCC 3.3 compiler suite to build our implementation and ran timing experiments on a Linux based PC incorporating a 2.80 GHz Intel Pentium 4 processor. The entire system was constructed in C++. We accept that further performance improvements could be made through aggressive profiling and optimisation but are confident our results are representative of the underlying algorithms and allow a comparison between them.</p>

    <p class="text-gray-300">Figure 2 shows the result of timing this implementation using a variety of different base field sizes. In the pairing section, Algorithm 3 refers to the augmented version of Duursma-Lee presented in this paper, with the cube root precomputation strategy and the loop unrolling. The BKLS method is included as a reference. We do not include timings for the methods of [44] since our operation count clearly shows they will be slower than our alternatives. Figure 3 gives timings for the underlying field operations.</p>

    <p class="text-gray-300">We note first that our implementation of Algorithm 3 is between two to three times faster than the BKLS algorithm. With regard to exponentiation, Method 4 is the most efficient for all field sizes and in all three groups, and in <span class="math">\\mathcal{G}</span> is nearly twice as fast as Method 1 in <span class="math">G_{l}</span>. Contrary to a claim of Koblitz [29] that the ratio of the time required for an exponentation in <span class="math">\\mathbb{F}_{q^6}</span> to the time required for a point multiplication in <span class="math">E(\\mathbb{F}_q)</span> is 12, our results demonstrate that for fields</p>

    <p class="text-gray-300">Fig. 3. Timings for Field Operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F}_{3^{70}}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F}_{3^{97}}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F}_{3^{103}}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F}_{3^{193}}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F}_{3^{239}}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F}_{3^{353}}</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbb{F}_q</span>  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.55<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.53<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.58<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.63<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.61<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.64<span class="math">\\mu</span>s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cube</td>

            <td class="px-3 py-2 border-b border-gray-700">0.85<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.84<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.96<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.26<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.24<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.77<span class="math">\\mu</span>s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Invert</td>

            <td class="px-3 py-2 border-b border-gray-700">23.18<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">33.26<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">70.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">97.20<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">136.86<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">303.27<span class="math">\\mu</span>s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multiply</td>

            <td class="px-3 py-2 border-b border-gray-700">4.06<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">6.02<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">12.80<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">17.83<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">19.42<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">43.11<span class="math">\\mu</span>s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbb{F}_{q^3}</span>  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.60<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.60<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.80<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.90<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.90<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.50<span class="math">\\mu</span>s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Invert</td>

            <td class="px-3 py-2 border-b border-gray-700">65.00<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">94.70<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">204.40<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">275.90<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">350.60<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">741.80<span class="math">\\mu</span>s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Frobenius</td>

            <td class="px-3 py-2 border-b border-gray-700">1.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.90<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.00<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.30<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.40<span class="math">\\mu</span>s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multiply</td>

            <td class="px-3 py-2 border-b border-gray-700">26.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">37.80<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">74.20<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">98.00<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">115.50<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">249.00<span class="math">\\mu</span>s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  <span class="math">\\mathbb{F}_{q^6}</span>  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.90<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.90<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.90<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.10<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.00<span class="math">\\mu</span>s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.10<span class="math">\\mu</span>s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Invert</td>

            <td class="px-3 py-2 border-b border-gray-700">165.50<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">237.20<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">497.40<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">670.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">817.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1709.50<span class="math">\\mu</span>s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Frobenius</td>

            <td class="px-3 py-2 border-b border-gray-700">2.00<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.90<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.00<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.10<span class="math">\\mu</span>s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Multiply</td>

            <td class="px-3 py-2 border-b border-gray-700">75.70<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">106.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">227.10<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">296.80<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">347.30<span class="math">\\mu</span>s</td>

            <td class="px-3 py-2 border-b border-gray-700">745.10<span class="math">\\mu</span>s</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">of a cryptographic size, this value is in fact closer to 1.3. Thus the techniques from [49], together with the fast multiplication in <span class="math">\\mathcal{G}</span>, improve the efficiency of post-pairing arithmetic considerably.</p>

    <p class="text-gray-300">We concede that while we have not implemented Koblitz’s complex multiplication exponentiation method, due to the estimated large preprocessing time required, we do not think it would affect this comparison significantly.</p>

    <p class="text-gray-300">Furthermore, due to our direct inversion method, the ratio of inversion time to multiplication time in <span class="math">\\mathbb{F}_{q^3}</span> is under three for all field sizes. This means our compression method in <span class="math">\\mathcal{G}</span> costs roughly <span class="math">4/3</span> multiplications in <span class="math">\\mathbb{F}_{q^6}</span>, and is therefore also very efficient.</p>

    <h2 id="sec-26" class="text-2xl font-bold">8 Conclusion and Open Problems</h2>

    <p class="text-gray-300">We have shown how to take advantage of the quotient group to which a pairing value naturally belongs in order to speed up exponentiations, and to obtain fast compression of pairing values. We have also proposed some simple refinements to the Duursma-Lee algorithm to improve efficiency. Our results strongly indicate that there are definite advantages to implementing pairing-based cryptographic protocols in characteristic three: the often quoted value of ten for the ratio of the speed of a pairing evaluation to a point multiplication on the curve is really closer to three or four.</p>

    <p class="text-gray-300">Some issues remain. One could certainly improve the exponentiation times for all three groups if there exists an efficiently computable ternary analogue of the</p>

    <p class="text-gray-300">Joint Sparse Form [48]. With regard to side channel attacks, such a method may be undesirable since one can not render cubing and multiplication in characteristic three fields indistinguishable without a serious detriment to performance. As such, a cube-and-multiply-always method using the exponent splitting of Method 4 will half the cost of a secure full length expansion.</p>

    <p class="text-gray-300">Also the exact security of the discrete logarithm problem in characteristic three using the ternary analogue of Coppersmith's method has yet to be investigated [10, 11]. Preliminary research into this problem using Adleman's Function Field Sieve has been conducted [23, 24] but the problem should still be considered open.</p>

    <p class="text-gray-300">Lastly, do there exist methods for faster pairing evaluation using MNT curves, and how might they compare to those presented here?</p>

    <h2 id="sec-27" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors would like to thank the anonymous referee, Paulo Barreto, Steven Galbraith, Keith Harrison, Karl Rubin, Mike Scott, Alice Silverberg, Nigel Smart and Fré Vercauteren for many helpful comments and fruitful discussions.</p>

    <h2 id="sec-28" class="text-2xl font-bold">References</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. Barreto. Personal Communication.</li>

      <li>P. Barreto, H. Kim, B. Lynn and M. Scott. Efficient Algorithms for Pairing-Based Cryptosystems. In Advances in Cryptology (CRYPTO 2002), Springer LNCS 2442, 354-368, 2002.</li>

      <li>D. Boneh and X. Boyen. Efficient Selective-ID Secure Identity-Based Encryption Without Random Oracles. In Advances in Cryptology (EUROCRYPT 2004), Springer LNCS 3027, 223-238, 2004.</li>

      <li>D. Boneh, X. Boyen and H. Shacham. Short Group Signatures. In Advances in Cryptology (CRYPTO 2004), Springer LNCS 3152, 41-55, 2004.</li>

      <li>D. Boneh and M. Franklin. Identity-Based Encryption from the Weil Pairing. In SIAM Journal on Computing, Volume 32, no. 3, 586-615, 2003.</li>

      <li>D. Boneh, B. Lynn and H. Shacham. Short signatures from the Weil Pairing. In Advances in Cryptology (ASIACRYPT 2001), Springer LNCS 2248, 514-532, 2001.</li>

      <li>W. Bosma, J. Hutton and E. Verheul. Looking beyond XTR. In Advances in Cryptology (ASIACRYPT 2002), Springer LNCS 2501, 46-63, 2002.</li>

      <li>W. Clark and J. Liang. On arithmetic weight for a general radix representation of integers. In IEEE Trans. Info. Theory, 19, 823-826, 1973.</li>

      <li>H. Cohen, A. Miyaji and T. Ono. Efficient elliptic curve exponentiation using mixed coordinates. In Advances in Cryptology (ASIACRYPT 1998). Springer LNCS 1514, 51-65, 1998.</li>

      <li>D. Coppersmith. Evaluating logarithms in <span class="math">\\mathrm{GF}(2^n)</span>. In 16th ACM Symp. Theory of Computing, 201-107, 1984.</li>

      <li>D. Coppersmith. Fast evaluation of logarithms in fields of characteristic two. IEEE Trans. Info. Theory, 30, 587-594, July 1984.</li>

      <li>R. Dutta, R. Barua and P. Sarkar. Pairing-Based Cryptographic Protocols: A Survey. Cryptology ePrint Archive, Report 2004/064. Available from http://eprint.iacr.org/2004/064.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I. Duursma and H. Lee. Tate Pairing Implementation for Hyperelliptic Curves <span class="math">y^{2} = x^{p} - x + d</span>. In <em>Advances in Cryptology (ASIACRYPT 2003)</em>, Springer LNCS 2894, 111–123, 2003.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>T. ElGamal. A public key cryptosystem and a signature scheme based on discrete logarithms. In <em>IEEE Trans. Info. Theory</em> <strong>31</strong>, 469–472, 1985.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G. Frey and H. Ruck. A Remark Concerning m-Divisibility and the Discrete Logarithm Problem in the Divisor Class Group of Curves. In <em>Math. Comp.</em> 62, 865–874, 1994.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Galbraith. Supersingular Curves in Cryptography. In <em>Advances in Cryptology (ASIACRYPT 2001)</em>, Springer LNCS 2248, 495–513, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Galbraith, K. Harrison and D. Soldera. Implementing the Tate pairing. In <em>Proc. of ANTS V</em>, Springer LNCS 2369, 324–337, 2002.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Gallant, J. Lambert and S. Vanstone. Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms. In <em>Advances in Cryptology (CRYPTO 2001)</em>, Springer LNCS 2139, 190–200, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Gao. Normal Bases over Finite Fields. PhD Thesis, Waterloo University, 1993.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. Gaudry. Index calculus for abelian varieties and the elliptic curve discrete logarithm problem. <em>Cryptology ePrint Archive</em>, Report 2004/073. Available from http://eprint.iacr.org/2004/073.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>C. Gentry. Certificate-Based Encryption and the Certificate Revocation Problem. In <em>Advances in Cryptology (EUROCRYPT 2003)</em>, Springer LNCS 2656, 272–293, 2003.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. Golle and A. Juels. Dining Cryptographers Revisited. In <em>Advances in Cryptology (EUROCRYPT 2004)</em>, Springer LNCS 3027, 456–473, 2004.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Granger. Estimates for discrete logarithm computations in finite fields of small characteristic. In <em>Cryptography and Coding</em>, Springer LNCS 2898, 190–206, 2003.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Granger, A. Holt, D. Page, N. Smart and F. Vercauteren. Function Field Sieve in Characteristic Three. In <em>Proc. of ANTS VI</em>, Springer LNCS 3076, 223–234, 2004.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Granger, D. Page and M. Stam. A Comparison of CEILIDH and XTR. In <em>Proc. of ANTS VI</em>, Springer LNCS 3076, 235–249, 2004.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>K. Harrison, D. Page and N.P. Smart. Software Implementation of Finite Fields of Characteristic Three, for use in Pairing Based Cryptosystems. In <em>LMS Journal of Computation and Mathematics</em>, <strong>5</strong> (1), 181–193, London Mathematical Society, 2002.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>F. Hess. Efficient Identity based Signature Schemes based on Pairings. In <em>Selected Areas in Cryptography (SAC 2002)</em>, Springer LNCS 2595, 310–324, 2003.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Joux. A One Round Protocol for Tripartite Diffie-Hellman. In <em>Proc. of ANTS IV</em>, Springer LNCS 1838, 385–394, 2000.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>N. Koblitz. An elliptic curve implementation of the finite field digital signature algorithm. <em>Advances in Cryptology (CRYPTO 98)</em>, Springer LNCS 1462, 327–337, 1998.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Lenstra. Using Cyclotomic Polynomials to Construct Efficient Discrete Logarithm Cryptosystems over Finite Fields. In <em>Proc. of ACISP97</em>, Springer LNCS 1270, 127–138, 1997.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Lenstra and E. Verheul. The XTR Public Key System. In <em>Advances in Cryptology (CRYPTO 2000)</em>, Springer LNCS 1880, 1–19, 2000.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>J. López and R. Dahab. High Speed Software Multiplication in <span class="math">\\mathbb{F}_{2^m}</span>. In <em>Progress in Cryptography (INDOCRYPT 2000)</em>, Springer-Verlag LNCS 1977, 203–212, 2000.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A.J. Menezes, P.C. van Oorschot and S.A. Vanstone. Handbook of Applied Cryptography. CRC Press, 1997.</li>

    </ol>

    <p class="text-gray-300">21</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V. Miller. Short programs for functions on curves. Unpublished manuscript, 1986. Available from http://crypto.stanford.edu/miller/miller.pdf.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. Ning and Y.L. Yin. Efficient Software Implementation for Finite Field Multiplication in Normal Basis. In <em>Information and Communications Security (ICICS)</em>, Springer-Verlag LNCS 2229, 177–188, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Nöcker. Data structures for parallel exponentiation in finite fields. PhD Thesis, Universität Paderborn, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G. Pohlig and M. Hellman. An improved algorithm for computing discrete logarithms over <span class="math">GF(p)</span> and its cryptographic significance. In <em>IEEE Trans. Info. Theory</em> <strong>24</strong>, 106–110, 1978.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Reyhani-Masoleh and M.A. Hasan. Fast Normal Basis Multiplication Using General Purpose Processors. In <em>Selected Areas in Cryptography (SAC 2001)</em>, Springer LNCS 2259, 230–244, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>K. Rubin and A. Silverberg. Supersingular abelian varieties in cryptography. In <em>Advances in Cryptology (CRYPTO 2002)</em>, Springer LNCS 2442, 336–353, 2002.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>K. Rubin and A. Silverberg. Torus-Based Cryptography. In <em>Advances in Cryptology (CRYPTO 2003)</em>, Springer LNCS 2729, 349–365, 2003.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>K. Rubin and A. Silverberg. Using Primitive Subgroups to Do More with Fewer Bits. In <em>Algorithm Number Theory (ANTS-VI)</em>, Springer LNCS 3076, 18–41, 2004.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Sakai, K. Ohgishi and M. Kasahara. Cryptosystems Based on Pairings. In <em>Symposium on Cryptography and Information Security 2000 (SCIS2000)</em>, Okinawa, Japan, Jan 26–28, 2000.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Scott. Authenticated ID-based Key Exchange and remote log-in with insecure token and PIN number. Cryptology ePrint Archive, Report 2002/164. Available from http://eprint.iacr.org/2002/164.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Scott and P. Barreto. Compressed Pairings. In <em>Advances in Cryptology (CRYPTO 2004)</em>, Springer LNCS 3152, 140–156, 2004.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I. Semaev. Summation polynomials and the discrete logarithm problem on elliptic curves. Cryptology ePrint Archive, Report 2004/031. Available from http://eprint.iacr.org/2004/031.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>J. Silverman. The arithmetic of elliptic curves. Springer GTM 106, 1986.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P. Smith and C. Skinner. A public-key cryptosystem and a digital signature system based on the Lucas function analogue to discrete logarithms. In <em>Advances in Cryptology (ASIACRYPT 1995)</em>, Springer LNCS 917, 357–364, 1995.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>J.A. Solinas. Low-Weight Binary Representations for Pairs of Integers. University of Waterloo, Technical Report CORR 2001-41.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Stam and A. Lenstra. Efficient Subgroup Exponentiation in Quadratic and Sixth Degree Extensions. In <em>Cryptographic Hardware and Embedded Systems (CHES 2002)</em>, Springer LNCS 2523, 318–332, 2002.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Stam and A. Lenstra. Speeding Up XTR. In <em>Advances in Cryptology (ASIACRYPT 2001)</em>, Springer LNCS 2248, 125–143, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>E.G. Straus. Problems and Solutions: (5125) Addition Chains of Vectors. In <em>American Mathematical Monthly</em>, <strong>71</strong>, 806–808, 1964.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>E. Verheul. Personal Communication, 2001.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V.E. Voskresenskii. Algebraic Groups and Their Birational Invariants. In <em>Translations of Mathematical Monographs</em>, <strong>179</strong>, American Mathematical Society, 1998.</li>

    </ol>

    <p class="text-gray-300">22</p>`;
---

<BaseLayout title="On Small Characteristic Algebraic Tori in Pairing-Based Cryp... (2004/132)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/132
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
