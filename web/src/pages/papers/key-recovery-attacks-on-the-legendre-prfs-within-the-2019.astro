---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/862';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Key recovery attacks on the Legendre PRFs within the birthday bound';
const AUTHORS_HTML = 'Dmitry Khovratovich';

const CONTENT = `    <p class="text-gray-300">Dmitry Khovratovich khovratovich@gmail.com Dusk and Evernym and ABDK Consulting and Sikoba Supported by Ethereum Foundation</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We show that Legendre PRF, recently suggested as an MPC-friendly primitive in a prime field <span class="math">\\mathbb{Z}_{p}</span>, admits key recovery attacks of complexity <span class="math">O(\\sqrt{p})</span> rather than previously assumed <span class="math">O(p)</span>. We also demonstrate new attacks on high-degree versions of this PRF, improving on the previous results by Russell and Shparlinski.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Pseudo-random function (PRF) is an important cryptographic primitive. Typically denoted <span class="math">F_{K}(\\cdot)</span> with <span class="math">K</span> being a secret key, its security is usually defined as inability to distinguish the output from a randomly chosen function <span class="math">f</span> on the same domain by an adversary who does not know neither <span class="math">K</span> nor <span class="math">f</span>. Different PRF candidates have been proposed, with block ciphers like AES being the most secure examples. AES and other blockcipher-based PRF candidates with <span class="math">n</span>-bit keys and inputs are assumed to be secure to distinguishing and key recovery attacks with complexity up to <span class="math">2^{n}</span>. In contrast, PRF candidates whose security is based on discrete logarithm hardness and similar assumptions typically claim security only up to the birthday bound and even less <em>[x10]</em>. In this paper we show that the Legendre PRF candidate falls into the second category as it fails to provide security comparable to AES.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Legendre PRF</h4>

    <p class="text-gray-300">The Legendre PRF has been introduced recently <em>[x14]</em> as a MPC-friendly candidate as its multi-party computation requires only a few multiplications which are the bottleneck in many MPC implementations.</p>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime and <span class="math">a</span> a positive integer, then the Legendre symbol <span class="math">L_{p}(a)</span> is defined as</p>

    <p class="text-gray-300"><span class="math">L_{p}(a)=a^{(p-1)/2}\\bmod p</span></p>

    <p class="text-gray-300">and denoted <span class="math">\\left(\\frac{a}{p}\\right)</span>. If <span class="math">a=b^{2}</span> for some <span class="math">b</span> then <span class="math">L_{p}(a)=1</span>, otherwise <span class="math">L_{p}(a)=-1</span>.</p>

    <p class="text-gray-300">Damgard <em>[x10]</em>, based on tests that demonstrate statistical uniformity of quadratic residues modulo <span class="math">p</span>, suggested a keyed Legendre symbol <span class="math">L^{K}_{p}(a)=L_{p}(K+a)</span> as a pseudo-random generator outputting <span class="math">1</span> or <span class="math">-1</span> by incrementing <span class="math">a</span>. Damgard conjectured that no polynomially bounded adversary can recover <span class="math">K</span> with reasonable probability given access to the oracle that computes <span class="math">L^{K}_{p}(a)</span> for any <span class="math">a</span>, which became known as <em>Legendre hidden shift problem</em> <em>[x14]</em>. A naive deterministic algorithm guesses <span class="math">K</span> and compares the entire keystream of length <span class="math">p</span> with the guessed one, thus spending <span class="math">p^{2}</span> time. Russell and Shparlinski <em>[x20]</em> demonstrated, based on the Weil bound, that a deterministic algorithm may consider keystream segments as short as <span class="math">\\log^{2}p</span>, thus bringing down the complexity to <span class="math">p\\log^{2}p</span>. Note that a naive randomized algorithm, selecting a random <span class="math">a</span> to start with, hopes to check the guess using only <span class="math">\\log p</span> outputs and has total complexity of <span class="math">p\\log p</span>. Together with the Russell-Shparlinski bound, these are the best results on the Legendre keyed generator so far. One can also consider a high-degree generator</p>

    <p class="text-gray-300"><span class="math">L^{K_{0},K_{1},\\ldots,K_{d-1}}_{p}(a)=L_{p}(K_{0}+K_{1}a+K_{2}a^{2}+\\cdots+K_{d-1}a^{d-1}+a^{d})</span></p>

    <p class="text-gray-300">with <span class="math">d</span> keys. The Russell-Shparlinski deterministic algorithm requires <span class="math">d^{2}p^{d}\\log^{2}p</span> operations, whereas a naive randomized algorithm needs <span class="math">p^{d}\\log p</span> operations.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Our contributions</h4>

    <p class="text-gray-300">We demonstrate new algorithms for key recovery in Legendre PRF, both in degree-1 and high-degree versions. Our attacks are based on time-memory tradeoff attacks and memoryless collision search algorithms.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Memoryless attack on the Legendre keyed generator</h2>

    <p class="text-gray-300">Here we consider the Legendre linear PRF</p>

    <p class="text-gray-300"><span class="math">L^{K}(a)=L_{p}(K+a).</span></p>

    <p class="text-gray-300">Let us denote for vector <span class="math">\\mathbf{a}=(a_{1},a_{2},\\ldots,a_{n})</span> the set of PRF evaluations</p>

    <p class="text-gray-300"><span class="math">L^{K}(\\mathbf{a})=\\left(L^{K}(a_{1}),L^{K}(a_{2}),\\ldots,L^{K}(a_{n})\\right).</span></p>

    <p class="text-gray-300">We first formalize the uniformity assumption that we use to filter out key candidates. Concretely, we assume that <em>for any vector <span class="math">\\mathbf{a}=(a_{1},a_{2},\\ldots,a_{\\log p})</span> and any <span class="math">\\log p</span>-bit string <span class="math">\\mathbf{b}</span> the number of keys <span class="math">K</span> such that <span class="math">L^{K}(\\mathbf{a})=\\mathbf{b}</span> is <span class="math">O(1)</span></em>. It is a very natural cryptanalytic assumption and it is also confirmed by statistical tests. A conservative attacker may use the Weil bound <em>[x20]</em> which provably upper bounds the length of such strings by <span class="math">\\log^{2}p</span>.</p>

    <p class="text-gray-300">We then note that the Legendre PRF has a very simple related-key property that holds with probability <span class="math">1</span>. Indeed, for any <span class="math">\\delta\\in\\mathbb{Z}_{p}</span>:</p>

    <p class="text-gray-300"><span class="math">L^{K}(a)=L^{K+\\delta}(a-\\delta).</span></p>

    <p class="text-gray-300">Then we proceed as follows. Let <span class="math">N</span> be an integer and <span class="math">\\mathbf{a}=(a_{1},a_{2},\\ldots,a_{n})</span> be a vector of <span class="math">\\mathbb{Z}_{p}</span> elements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Make <span class="math">N</span> guesses of <span class="math">K:K^{1},K^{2},\\ldots,K^{N}</span> and compute <span class="math">N</span> vectors</li>

    </ol>

    <p class="text-gray-300"><span class="math">V[K^{i}]=L^{K^{i}}(\\mathbf{a})=\\left(L^{K^{i}}(a_{1}),L^{K^{i}}(a_{2}),\\ldots,L^{K^{i}}(a_{n})\\right).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Select randomly <span class="math">N</span> elements of <span class="math">\\mathbb{Z}_{p}</span>: <span class="math">A^{1},A^{2},\\ldots,A^{N}</span> and make <span class="math">N\\cdot n</span> queries to the PRF so that <span class="math">N</span> vectors are stored:</li>

    </ol>

    <p class="text-gray-300"><span class="math">W[A^{i}]=L^{K}(A^{i}+\\mathbf{a})=\\left(L^{K}(A^{i}+a_{1}),L^{K}(A^{i}+a_{2}),\\ldots,L^{K}(A^{i}+a_{n})\\right).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">K^{i}-A^{j}=K</span> for some <span class="math">i,j</span>. Then</li>

    </ol>

    <p class="text-gray-300"><span class="math">W[A^{j}]=L^{K}(A^{j}+\\mathbf{a})=L^{K^{i}-A^{j}}(A^{j}+\\mathbf{a})=L^{K^{i}}(\\mathbf{a})=V[K^{i}].</span></p>

    <p class="text-gray-300">Therefore it suffices to find an intersection between <span class="math">\\{W[A^{j}]\\}_{j}</span> and <span class="math">\\{V[K^{i}]\\}_{i}</span>.</p>

    <p class="text-gray-300">If we denote <span class="math">f(x)=V[x]</span> and <span class="math">g(y)=W[y]</span>, then the key recovery is equivalent to the collision search <span class="math">f</span> and <span class="math">g</span>. Thus <span class="math">N=O(\\sqrt{p})</span> suffices.</p>

    <p class="text-gray-300">A collision search between two functions can be done memoryless by first reducing the search to a single function <span class="math">h</span> <em>[x13]</em> and then making a memoryless collision search. The single function is defined as:</p>

    <p class="text-gray-300">\\[ h(x)=\\begin{cases}f(x),&\\text{ if }\\phi(x)=1;\\\\ g(x),&\\text{ if }\\phi(x)=0.\\end{cases} \\]</p>

    <p class="text-gray-300">where <span class="math">\\phi</span> is some simple predicate like a XOR of all bits.</p>

    <p class="text-gray-300">The overall complexity of the attack is <span class="math">O(\\sqrt{p}\\log p)</span> PRF queries and Legendre evaluations. If only <span class="math">M&lt;\\sqrt{p}</span> queries are available, then the attack costs <span class="math">O(p(\\log p)/M)</span> computations. In the unlikely case we get too many false alarms, we can simply select another <span class="math">\\mathbf{a}</span>.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Quadratic Legendre PRF</h2>

    <p class="text-gray-300">Now we consider the polynomial version of Legendre PRF and start with degree 2:</p>

    <p class="text-gray-300"><span class="math">L^{K_{0},K_{1}}(a)=\\left(\\frac{K_{0}+K_{1}a+a^{2}}{p}\\right).</span></p>

    <p class="text-gray-300">A naive randomized algorithm just guesses <span class="math">K_{0},K_{1}</span>, computes <span class="math">\\log p</span> outputs and compares with PRF queries. It has complexity <span class="math">O(p^{2}\\log p)</span>. We can do better by guessing only <span class="math">K_{1}</span> and applying our attack on the linear case, with a simple replace of <span class="math">a</span> with <span class="math">a^{2}</span>. This algorithm has complexity <span class="math">O(p^{1.5}\\log p)</span>.</p>

    <p class="text-gray-300">We can do better by recalling some attacks on stream ciphers. Babbage <em>[x2]</em> considered a clocked stream cipher with internal state of <span class="math">\\log N</span> bits and showed that if we can make <span class="math">M</span> queries to the cipher so that it changes state <span class="math">M</span> times, then we should run the cipher starting at <span class="math">N/M</span> random states and search a collision between guessed keystreams and the actual keystream.</p>

    <p class="text-gray-300">Unfortunately, this attack does not apply directly since in our quadratic generator we do not have a state that evolves. If we set <span class="math">(K_{0},K_{1},a)</span> then only <span class="math">a</span> would change but neither <span class="math">K_{0}</span> nor <span class="math">K_{1}</span>, so Babbage’s attack does not seem to work.</p>

    <p class="text-gray-300">To make the approach work we introduce another related-key property. Recall now that</p>

    <p class="text-gray-300"><span class="math">L(a)=a^{(p-1)/2}\\implies L(ab)=L(a)L(b).</span></p>

    <p class="text-gray-300">Now let <span class="math">r</span> be some integer, then <span class="math">L(r^{2})=1</span>. We obtain</p>

    <p class="text-gray-300">\\[ L^{K_{0},K_{1}}(a)=L^{K_{0},K_{1}}(a)L(r^{2})=\\left(\\frac{K_{0}+K_{1}a+a^{2}}{p}\\right)\\left(\\frac{r^{2}}{p}\\right)=\\\\ =\\left(\\frac{K_{0}r^{2}+K_{1}ar^{2}+a^{2}r^{2}}{p}\\right)=L^{K_{0}r^{2},K_{1}r}(ar). \\]</p>

    <p class="text-gray-300">Or equivalently</p>

    <p class="text-gray-300"><span class="math">L^{K_{0}r^{2},K_{1}r}(a)=L^{K_{0},K_{1}}(a/r).</span> (1)</p>

    <p class="text-gray-300">Thus we can compute the PRF on <span class="math">p</span> related keys using <span class="math">p</span> different <span class="math">r</span> on the same input. However, we need <span class="math">\\log p</span> inputs for each related key. We could use arbitrary <span class="math">\\log p</span> values, but there is a better choice which allows reusing Legendre computation for another related key.</p>

    <p class="text-gray-300">Concretely, consider <span class="math">\\mathbf{a}=(r,r^{2},\\ldots,r^{n})</span>. Then</p>

    <p class="text-gray-300"><span class="math">L^{K_{0},K_{1}}(\\mathbf{a})=(L^{K_{0},K_{1}}(r),L^{K_{0},K_{1}}(r^{2}),\\ldots,L^{K_{0},K_{1}}(r^{n}))</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">\\[ L^{K_{0}r^{2},K_{1}r}(\\mathbf{a})=(L^{K_{0}r^{2},K_{1}r}(r),L^{K_{0}r^{2},K_{1}r}(r^{2}),\\ldots,L^{K_{0}r^{2},K_{1}r}(r^{n}))=\\\\ =(L^{K_{0},K_{1}}(1),L^{K_{0},K_{1}}(r),\\ldots,L^{K_{0},K_{1}}(r^{n-1})) \\]</p>

    <p class="text-gray-300">Therefore, querying the PRF on <span class="math">r^{i}</span> for many <span class="math">i</span> we obtain <span class="math">L^{K_{0}r^{2ri},K_{1}r^{i}}(\\mathbf{a})</span>.</p>

    <p class="text-gray-300">The full attack works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">N</span> guesses of <span class="math">K:K^{1}=(K_{0}^{1},K_{1}^{1}),K^{2}=(K_{0}^{2},K_{1}^{2}),\\ldots,K^{N}=(K_{0}^{N},K_{1}^{N})</span> and a vector <span class="math">\\mathbf{a}=(r,r^{2},\\ldots,r^{n})</span> compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">V[K^{i}]=L^{K^{i}}(\\mathbf{a})=\\{L^{K^{i}}(r),L^{K^{i}}(r^{2}),\\ldots,L^{K^{i}}(r^{n})\\}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">N</span> values <span class="math">r,r^{2},\\ldots,r^{N}</span> compute:</li>

    </ol>

    <p class="text-gray-300">\\[ W[r^{j}]=L^{(K_{0},K_{1})\\circ(r^{2j},r^{j})}(\\mathbf{a})=\\\\ =\\left(L^{(K_{0},K_{1})\\circ(r^{2j},r^{j})}(r),L^{(K_{0},K_{1})\\circ(r^{2j},r^{j})}(r^{2}),\\ldots,L^{(K_{0},K_{1})\\circ(r^{2j},r^{j})}(r^{n})\\right). \\]</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If for some <span class="math">i,j</span> we have <span class="math">K^{i}=(K_{0},K_{1})\\circ(r^{2j},r^{j})</span> then <span class="math">V[K^{i}]=W[r^{j}]</span>. We need <span class="math">p</span> elements in each set to have a collision.</li>

    </ol>

    <p class="text-gray-300">The attack can be done memoryless using the same approach as in Section 2. The overall complexity is <span class="math">O(p\\log p)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generator</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rus-Shpa</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Randomized</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ours</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Linear L^K()</td>

            <td class="px-3 py-2 border-b border-gray-700">p log^2 p</td>

            <td class="px-3 py-2 border-b border-gray-700">p log p</td>

            <td class="px-3 py-2 border-b border-gray-700">√p log p</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Quadratic L^K0,K1()</td>

            <td class="px-3 py-2 border-b border-gray-700">p^2 log^2 p</td>

            <td class="px-3 py-2 border-b border-gray-700">p^2 log p</td>

            <td class="px-3 py-2 border-b border-gray-700">p log p</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">High-deg L^K0,K1,...,Kd-1()</td>

            <td class="px-3 py-2 border-b border-gray-700">p^d d^2 log^2 p</td>

            <td class="px-3 py-2 border-b border-gray-700">p^d d log p</td>

            <td class="px-3 py-2 border-b border-gray-700">p^d-1 d log p</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Summary of our and previous results on the Legendre PRF</p>

    <p class="text-gray-300">We finally consider a high-degree version:</p>

    <div class="my-4 text-center"><span class="math-block">L ^ {K _ {0}, K _ {1}, \\dots , K _ {d - 1}} (a) = \\left(\\frac {K _ {0} + K _ {1} a + \\dots + K _ {d - 1} a ^ {d - 1} + a ^ {d}}{p}\\right)</span></div>

    <p class="text-gray-300">The attack is a simple reduction to the quadratic case:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess  <span class="math">K_{2}, K_{3}, \\ldots, K_{d - 1}</span> ;</li>

      <li>Apply Section 3 attack to  <span class="math">K_{0}, K_{1}</span>  with the modified property</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">L ^ {K _ {0} r ^ {d}, K _ {1} r ^ {d - 1}} (a) = L ^ {K _ {0}, K _ {1}} \\left(a / r ^ {d}\\right) L \\left(r ^ {d}\\right). \\tag {2}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The attack complexity is  <span class="math">O(p^{d - 1}d\\log p)</span> .</li>

    </ol>

    <p class="text-gray-300">[Bab95] SH Babbage. "Improved exhaustive search attacks on stream ciphers". In: (1995) (cit. on p. 3). [Dam88] Ivan Damgård. “On the Randomness of Legendre and Jacobi Sequences”. In: CRYPTO. Vol. 403. Lecture Notes in Computer Science. Springer, 1988, pp. 163–172 (cit. on p. 2). [DY05] Yevgeniy Dodis and Aleksandr Yampolskiy. “A Verifiable Random Function with Short Proofs and Keys”. In: Public Key Cryptography. Vol. 3386. Lecture Notes in Computer Science. Springer, 2005, pp. 416–431 (cit. on p. 1). [Gra+16] Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, et al. "MPC-Friendly Symmetric Key Primitives". In: IACR Cryptology ePrint Archive 2016 (2016), p. 542 (cit. on pp. 1, 2). [MOM91] Hikaru Morita, Kazuo Ohta, and Shoji Miyaguchi. “A Switching Closure Test to Analyze Cryptosystems”. In: CRYPTO. Vol. 576. Lecture Notes in Computer Science. Springer, 1991, pp. 183–193 (cit. on p. 3). [RS04] Alexander Russell and Igor E. Shparlinski. “Classical and quantum function reconstruction via character evaluation”. In: J. Complexity 20.2-3 (2004), pp. 404–422 (cit. on p. 2).</p>`;
---

<BaseLayout title="Key recovery attacks on the Legendre PRFs within the birthda... (2019/862)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/862
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
