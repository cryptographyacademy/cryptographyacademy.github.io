---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/381';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Nakamoto Consensus under Bounded Processing Capacity';
const AUTHORS_HTML = 'Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, David Tse';

const CONTENT = `    <p class="text-gray-300">Lucianna Kiffer</p>

    <p class="text-gray-300">ETH Zürich</p>

    <p class="text-gray-300">Zurich, Switzerland</p>

    <p class="text-gray-300">lkiffer@ethz.ch</p>

    <p class="text-gray-300">Joachim Neu</p>

    <p class="text-gray-300">Stanford University</p>

    <p class="text-gray-300">Stanford, CA, USA</p>

    <p class="text-gray-300">jneu@stanford.edu</p>

    <p class="text-gray-300">Srivatsan Sridhar</p>

    <p class="text-gray-300">Stanford University</p>

    <p class="text-gray-300">Stanford, CA, USA</p>

    <p class="text-gray-300">svatsan@stanford.edu</p>

    <p class="text-gray-300">Aviv Zohar</p>

    <p class="text-gray-300">The Hebrew University</p>

    <p class="text-gray-300">Jerusalem, Israel</p>

    <p class="text-gray-300">avivz@cs.huji.ac.il</p>

    <p class="text-gray-300">For Nakamoto's longest-chain consensus protocol, whose proof-of-work (PoW) and proof-of-stake (PoS) variants power major blockchains such as Bitcoin and Cardano, we revisit the classic problem of the security-performance tradeoff: Given a network of nodes with finite communication- and computation-resources, against what fraction of adversary power is Nakamoto consensus (NC) secure for a given block production rate? State-of-the-art analyses of NC fail to answer this question, because their bounded-delay model does not capture the rate limits to nodes' processing of blocks, which cause congestion when blocks are released in quick succession. We develop a new analysis technique to prove a refined security-performance tradeoff for PoW NC in a bounded-capacity model. In this model, we show that, in contrast to the classic bounded-delay model, Nakamoto's private attack is no longer the worst attack, and a new attack we call the teasing strategy, that exploits congestion, is strictly worse. In PoS, equivocating blocks can exacerbate congestion, making traditional PoS NC insecure except at very low block production rates. To counter such equivocation spamming, we present a variant of PoS NC we call Blanking NC (BlaNC), which achieves the same resilience as PoW NC.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Security and privacy  <span class="math">\\rightarrow</span>  Distributed systems security.</li>

    </ul>

    <p class="text-gray-300">Nakamoto; consensus; blockchain; capacity; bandwidth; spamming.</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse. 2024. Nakamoto Consensus under Bounded Processing Capacity. In Proceedings of the 2024 ACM SIGSAC Conference on Computer and Communications Security (CCS '24), October 14-18, 2024, Salt Lake City, UT, USA. ACM, New York, NY, USA, 26 pages. https://doi.org/10.1145/3658644.3670347</p>

    <p class="text-gray-300">LK, JN, SS and AZ are listed alphabetically.</p>

    <p class="text-gray-300">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">© 2024 Copyright held by the owner/author(s). Publication rights licensed to ACM.</p>

    <p class="text-gray-300">ACM ISBN 979-8-4007-0636-3/24/10</p>

    <p class="text-gray-300">https://doi.org/10.1145/3658644.3670347</p>

    <p class="text-gray-300">David Tse</p>

    <p class="text-gray-300">Stanford University</p>

    <p class="text-gray-300">Stanford, CA, USA</p>

    <p class="text-gray-300">dntse@stanford.edu</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Regions of fraction  <span class="math">\\beta</span>  of adversary nodes and block production rate  <span class="math">\\lambda</span>  with security proofs ( <span class="math">\\square</span> ) and attacks ( <span class="math">\\square</span> ) for NC under a fixed processing capacity of  <span class="math">C = 1</span>  block per second. Analysis in the bounded-delay model [24, 30] (with  <span class="math">\\Delta = 1</span>  s) proves that the private attack  <span class="math">(- - -)</span>  succeeds ( <span class="math">\\square</span> ) iff  <span class="math">\\beta \\geq \\frac{1 - \\beta}{1 + (1 - \\beta)\\lambda}</span> , and that for all other values of  <span class="math">\\beta, \\lambda</span> , no attack succeeds ( <span class="math">\\square</span> ). Our teasing strategy exploits congested block processing and succeeds at lower adversary  <span class="math">\\beta</span>  than the private attack ( <span class="math">\\square</span> ,  <span class="math">\\square</span> ). Our analysis in a bounded-capacity model yields a security region ( <span class="math">\\square</span> ) for PoW NC.</p>

    <p class="text-gray-300">In order to remain secure against adversaries controlling up to  <span class="math">50\\%</span>  of the network, blockchains that utilize Nakamoto's proof-of-work (PoW) longest-chain consensus protocol [28, 45] have been parameterized to leave a security margin between the throughput under normal operation and each node's capacity limits. For instance, in expectation, Bitcoin produces only one block of transactions every ten minutes, though it usually only takes a few seconds for a node to download and verify a block's contents [23]. On the other hand, Bitcoin Cash forked off to increase the block size for better throughput, a proposal whose security implications were hotly debated [1]. The fundamental question that protocol designers face is: What is the security-performance trade-off between the block production rate (relative to the nodes' capacity limit) and the fraction of adversary power that the protocol tolerates? In this work, we show the inadequacy of the bounded-delay model that most previous works utilized to analyze the security of Nakamoto consensus (NC) [24, 28, 30, 35, 37, 50, 52, 55], and instead provide security analysis in a bounded-capacity model that better captures real-world effects such as congestion due to a backlog of blocks that need to be communicated and validated by nodes.</p>

    <p class="text-gray-300">In PoW NC, collectively starting with a well-known “genesis” block, each node continuously works to solve a computational puzzle to extend the longest chain of blocks it sees with a new block containing pending transactions (“mining a new block”). When successful, the node pushes the new block’s header to the network, and makes its content available for download. In order to extend a chain, nodes must first process, i.e., download and verify, the content of blocks in that chain, to ensure that the content is both available and valid. Downloading blocks may take time, especially if blocks are extremely large <em>(23)</em>, but in systems that contain smart contracts, even smaller blocks may take a while to process—mostly due to the time it takes to execute and validate smart contracts <em>(42)</em>.</p>

    <p class="text-gray-300">In PoW, block production occurs at random times, which makes the processing load of the network bursty. Moreover, the adversary can selectively withold its own mined blocks and release them opportunistically. Both these factors further stress the processing (communication, computation, …) capacities of nodes. With limited processing capacity, during times of high load, blocks will be queued for processing. Since nodes cannot mine new blocks extending chains that they have not yet fully processed, queueing further delays the growth of the honest nodes’ chain. As the security of NC is based on the honest chain outgrowing any adversary chain, the reduced growth of the honest nodes’ chain makes it easier for an adversary to attack the system. To analyze security under such effects, it is important to consider the scheduling policy that nodes use in deciding which blocks to download and verify first, given a set of new block headers. Since a node extends its longest chain to produce new blocks, an obvious policy is to first process blocks along the longest header chain that the node has seen. Indeed, this policy can be found in the Bitcoin implementation <em>(9)</em>.</p>

    <p class="text-gray-300">Limitations of the Bounded-Delay Model. Previous work has focused on the security analysis of Bitcoin in the synchronous setting: All messages are assumed to arrive after a maximum delay of <span class="math">\\Delta</span> <em>(24; 28; 30; 35; 37; 50; 52; 55)</em>. Using this model, <em>(24; 30)</em> calculate a tight bound on the fraction <span class="math">\\beta</span> of adversary nodes, for given block production rate <span class="math">\\lambda</span> and delay bound <span class="math">\\Delta</span>, for which the protocol is secure against all attacks. However, the <span class="math">\\Delta</span>-delay model assumes that the delay is the same irrespective of the total processing load, and specifically, that the adversary cannot manipulate the load to its advantage. Thus, the model fails to capture the security implications of bursty release of blocks by an adversary or due to the stochastic nature of PoW mining even by honest nodes alone.</p>

    <p class="text-gray-300">The bounded-delay analysis <em>(24; 30)</em> concludes that the well-known private attack <em>(45)</em> (along with delaying every message by <span class="math">\\Delta</span>) is the worst-case attack strategy since its attack threshold matches the security threshold, i.e., under parameters where the private attack fails, the analysis concludes that all other attacks must fail, too. If we only consider the private attack and low block production rates, then the bounded-delay analysis, with <span class="math">\\Delta</span> taken as the time to process one block, is a good approximation to calculate the fraction of adversary power with which the attack succeeds (see Fig. 1, validated by simulations in Sec. 2). This is because during the private attack, the adversary does not release any blocks (only “benign” random congestion), and the effect of bursty honest mining is less significant at low block rates.</p>

    <p class="text-gray-300">However, there are other strategies in which the adversary adds to the processing load to increase queuing delays. We simulate one such strategy, the teasing strategy (Sec. 2), that is stronger than the private attack, i.e., it succeeds in regions of <span class="math">(\\lambda,\\beta)</span> where the private attack does not (Fig. 1). In the teasing strategy, the adversary “teases” honest nodes to process a longer chain it announces, but makes this effort “useless” by not releasing the block contents for the entire chain. The adversary effectively doubles the processing load and queuing delays, thus slowing the growth of the honest nodes’ chain, while the adversary builds a longer chain to break security. This halves the maximum secure block rate <span class="math">\\lambda</span> for any given <span class="math">\\beta</span> (Fig. 1). While the concrete quantitative impact of this attack may be considered modest, it highlights conceptual limitations of earlier analyses and emphasizes the need for security analysis under more realistic network models, especially to rule out that unbeknown to us there could be even more serious queuing-based attacks.</p>

    <p class="text-gray-300">Security Bounds under Bounded Processing Capacity. To re-establish the security of NC in a more realistic model, we adopt the bounded-capacity model from <em>(48)</em>. Under this model, we consider the scheduling policy as a part of the protocol description as it affects the security of the protocol. Henceforth, we continue to use the verb “to process” to abstract a variety (or combination) of tasks (communication/download, computation/execution/verification, input-output/storage access, …) that are typically subject to rate constraints in real-world systems, and we refer to the corresponding rate limit abstractly as “(processing) capacity”.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Result 1.</h6>

    <p class="text-gray-300">Using the bounded-capacity model and a novel analysis technique, we characterize a region of block mining rate <span class="math">\\lambda</span> and adversary fraction <span class="math">\\beta</span> for which we prove that PoW NC, with a wide range of suitable scheduling policies, is secure (Thm. 4.10). This region is shown in Fig. 1. Specifically, this analysis expands the set of adversary strategies captured by earlier bounded-delay analyses to include adversary strategies that exploit effects from bounded capacity.</p>

    <p class="text-gray-300">In Fig. 2, we plot the adversary resilience versus bandwidth requirement for PoW NC with cautious (e.g. Bitcoin) and ambitious (e.g. Bitcoin Cash) parameters. It shows the importance of modeling and studying congestion effects on security, in particular, for protocols that aim for maximum performance, and our analysis provides tools to do so. While our work demonstrates that earlier analyses have failed to capture some security-critical phenomena, the quantitative gap between our best-known attack (Fig. 1 ) and our best-known security analysis (Fig. 1 ) points to a need for future work.</p>

    <p class="text-gray-300">Proof-of-Stake (PoS) NC. Nakamoto consensus has been adapted to proof-of-stake in protocols of the Ouroboros <em>(4; 22; 35)</em> and Sleepy Consensus <em>(19; 52)</em> families. In PoS NC, the block production lottery is independent of the block’s content or parent <em>(5)</em>. This, unlike in PoW NC, allows an adversary to reuse a “winning PoS lottery ticket” to create infinitely many valid blocks (called equivocations). As observed in <em>(48)</em>, the adversary can spam nodes with many</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: For cautiously parameterized PoW NC (e.g., Bitcoin's  <span class="math">\\lambda = 1/600</span>  blocks/s, block size 4 MB, recommended min. per-node bandwidth 0.4 Mbps [8, 18]), earlier analyses assuming bounded delay  <span class="math">(- - - )</span>  predicted security against any adversary controlling up to  <span class="math">48\\%</span>  of hash power (0), including Nakamoto's private attack [45], which was concluded to be worst-case. The teasing strategy still requires  <span class="math">46\\%</span>  adversary  <span class="math">(- - - a, *)</span> . In contrast, PoW NC parameterized ambitiously (e.g., Bitcoin Cash's same  <span class="math">\\lambda</span> , but max. block size 32 MB, same bandwidth [54]) withstands only a  <span class="math">37\\%</span>  private attacker (0), while the teasing strategy resilience drops to  <span class="math">27\\%</span>  ( <span class="math">\\bullet</span> ).</p>

    <p class="text-gray-300">equivocating blocks, aggravating the problem of congestion. While slashing [11, 12, 49, 59] may deter rational adversaries to some extent, protocols need to tolerate equivocations to handle plausibly irrational Byzantine adversaries [48].</p>

    <p class="text-gray-300">Analytical work [48] gives a security proof for PoS NC in the bounded-capacity model. However, [48] proves security only when nodes have enough capacity so that for each block, they can process potentially different versions of its  <span class="math">k</span>  predecessors, where  <span class="math">k</span>  is the confirmation depth chosen for the chain. This increases the network load by  <span class="math">k</span>  times, thus reducing the maximum secure block rate  <span class="math">\\lambda</span>  by  <span class="math">k</span>  times (Fig. 3). Decreasing the probability of consensus failure requires increasing  <span class="math">k</span> , which means that for security with overwhelming probability, the throughput must approach zero. This is not merely an artifact of the security analysis of [48]: Augmenting our teasing strategy with equivocations demonstrates this behavior (we discuss this in Sec. 2 and App. B.2). On the other hand, PoW NC does not suffer from such vanishing throughput (Fig. 1).</p>

    <p class="text-gray-300">Result 2. We propose and prove the security of a new PoS protocol we call Blanking NC (BlaNC), a variant of PoS NC, that is secure in the same region of block production rate  <span class="math">\\lambda</span>  and adversary fraction  <span class="math">\\beta</span>  as PoW NC. Thus, similar to PoW NC, security with overwhelming probability requires increasing the confirmation depth, which affects latency, but not decreasing the block production rate, which affects throughput (see Fig. 3).</p>

    <p class="text-gray-300">On a high level, in BlaNC, honest nodes establish consensus on PoS lottery tickets for which they have seen equivocations. The contents of blocks from those equivocating PoS lottery tickets are then blanked, i.e., all blocks from those tickets are treated as empty blocks. This absolves honest nodes from processing more than one block per PoS lottery ticket, restoring the non-equivocation</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: The region of fraction  <span class="math">\\beta</span>  of adversary nodes and block production rate  <span class="math">\\lambda</span>  where PoS NC is secure according to [48] ( <span class="math">\\odot</span> ) shrinks as the NC confirmation depth increases, i.e., the desired consensus failure probability decreases (in order: —— to ——). Thus, for the PoS NC protocol of [48], security requires vanishing throughput. In contrast, our new BlaNC protocol achieves a security region ( <span class="math">\\odot</span> ) that is independent of the desired consensus failure probability. Thus, BlaNC is secure with non-vanishing constant throughput. (For all lines, processing capacity is fixed to  <span class="math">C = 1</span>  block/s.)</p>

    <p class="text-gray-300">behavior of PoW from a capacity point of view. From there, the security proof closely follows that of PoW NC.2</p>

    <p class="text-gray-300">Blanking block contents undermines predictability of transaction validity (cf. Sec. 1.2.3). In particular, it is harder to ensure, at the time of composing a block, whether transactions are able to pay their fees. Many modern consensus protocols share this problem (e.g., [2, 20, 43, 61, 63]). We suggest some solutions in Sec. 5.2.</p>

    <p class="text-gray-300">Earlier works have analyzed the security of PoW [24, 28, 30, 37, 45, 50, 55] and PoS [4, 5, 19, 22, 24, 35, 52] NC in the bounded-delay model. Our analysis builds on tools from several of these works, primarily pivots [52] (Nakamoto blocks [24]) and convergence opportunities [37, 50, 52] (or similar [24, 55]). Markov decision processes were used [31, 60] to computationally find optimal attack strategies, assuming honest nodes do not suffer any delay.</p>

    <p class="text-gray-300">Limitations of the bounded-delay model have been observed in previous work [6, 27, 48]. To use the bounded-delay model to set the protocol's block production rate, one needs to find the value of the bound  <span class="math">\\Delta</span> . This is tricky because unlike the capacity limit, which is a physical limit of the hardware used, delay depends on the network load. One approach is to set the delay to the time taken to process one block, i.e.,  <span class="math">\\Delta = 1 / C</span> . While this may be reasonable at rates much smaller than the capacity (as processing queues are mostly empty), queuing delay breaks this bound otherwise. In [27], a queuing model is used to calculate a delay bound that holds throughout the execution with overwhelming probability. However, such a tail bound is too pessimistic because the queuing delays cannot always be large, due to limited block production. In contrast, our finer-grained analysis captures limited block production. Another work [57] analyzes security in a random (iid) delay model. However, the network load, hence queuing delay, is not purely a random process, but is controlled by the adversary. Network experiments [23, 38, 56]</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">help estimate the delay distribution but cannot show us the impact of all possible adversary manipulations.</p>

    <p class="text-gray-300">In analytical work [48], the bounded-capacity model captures adversarial manipulations. Our paper's bounded-capacity model is that of [48]. Our paper differs from [48] two-fold: (a) Only PoS is studied in [48]. Due to equivocations in PoS, the security bounds of [48] are too pessimistic for PoW NC. We develop new analysis machinery (cf. Sec. 1.2.1) to prove security for PoW. Furthermore, the attack in [48] does not apply to PoW, while our teasing strategy does. (b) PoS NC with the freshest-block policy proposed in [48] is secure only when its throughput approaches zero. In contrast, our new PoS protocol, BlaNC, is secure with non-vanishing throughput.</p>

    <p class="text-gray-300">Concurrently, [62] analyzes specific congestion-based attacks on PoW DAG protocols but does not provide a security proof against all attacks. Propagation delays also exacerbate selfish mining strategies [41], and congestion is another way to increase propagation delays. However, the goal of this work is to analyze security under bounded capacity, and selfish mining does not affect the two security properties of consensus: safety and liveness. It affects incentives and fairness, which are orthogonal.</p>

    <p class="text-gray-300">Capacity limits apply not only to downloads but also to execution of transactions and smart contracts. For instance, earlier works [53] have shown that execution times can vary by orders of magnitude between benign and maliciously crafted transactions (with equal gas consumption). While download and execution are similar in that the time taken increases with the number of transactions, they are different in some aspects. Execution is harder to parallelize due to transactions that depend on each other. Methods to parallelize execution of smart contracts are studied in [25, 58]. Additionally, executing transactions can be delayed until after confirmation, such as in [2, 21], but delaying downloads could lead to data availability attacks (cf. Sec. 5.1).</p>

    <p class="text-gray-300">1.2.1 New Analysis Technique. Our key contribution is a new analysis technique for PoW NC under bounded capacity. Traditional NC security analysis (Fig. 4(a)) is based on the notion of a pivot [52]. Pivots are special honest blocks ( <span class="math">\\Rightarrow</span>  liveness) which by a combinatorial argument remain in the chain forever ( <span class="math">\\Rightarrow</span>  safety), and by a probabilistic argument happen frequently. Safety and liveness of NC with suitable parameters follow swiftly.</p>

    <p class="text-gray-300">Under bounded delay, the qualities required for the probabilistic and combinatorial argument, respectively, are equivalent. As a result, it has not been widely noted that these properties are not identical. Under bounded capacity, these properties are no longer equivalent. Our first conceptual contribution is to decompose pivots' probabilistic/combinatorial qualities into ppivots and cpivots (Fig. 4(b)). Ppivots are honest block production events where in every time interval around them there are more honest than adversary block production opportunities (same as pivots in the bounded-delay analysis). Cpivots are honest block production events where in every time interval around them there are more chain growth events than non-chain-growth events (chain growth occurs only when an honest block is produced and soon processed by honest nodes).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) Sleepy analysis [48, 52]:</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) Our analysis: Figure 4: (a) Sleepy analysis [52] is based on pivots. Pivots are special honest blocks ( <span class="math">\\Rightarrow</span>  liveness) which by a combinatorial argument remain in the chain forever ( <span class="math">\\Rightarrow</span>  safety), and by a probabilistic argument happen frequently. Equivalence of the pivot qualities required for each of both arguments follows from bounded delay [51, Fact 1]. The bounded-capacity analysis of [48] also follows the same procedure by choosing a large enough delay parameter. (b) We (red) decompose pivots' probabilistic vs. combinatorial qualities into ppivots vs. cpivots. These are no longer equivalent under bounded capacity, but of many consecutive ppivots one is a cpivot (new combinatorial argument), and ppivots are abundant (new probabilistic argument).</p>

    <p class="text-gray-300">Some ppivots no longer turn into cpivots under bounded capacity, because adversary block release can delay the processing of honestly produced blocks, and thus some honest block production opportunities might not translate to chain growth. Previous bounded-capacity analysis [48] side-stepped this difference by choosing a specific scheduling policy and such a low block production rate that every ppivot becomes a cpivot. Instead, our second technical contribution is a combinatorial argument to show that if there is a sufficiently high density of ppivots over a long time interval, then at least one of these ppivots is typically a cpivot. This relies on the adversary's limited budget of blocks it can spam with, and holds for a wide range of scheduling policies (including longest-header-chain and freshest-block [48]).</p>

    <p class="text-gray-300">The original probabilistic argument of [52] guarantees only a fairly low density of ppivots. Proving a high density is challenging because the occurrence of ppivots are dependent events, so standard Chernoff-style tail bounds are not enough. Our third technical contribution is to show, by leveraging the weak dependence of ppivot occurrences, that long time intervals typically have a high density of ppivots. This completes the analysis for PoW NC.</p>

    <p class="text-gray-300">1.2.2 Blanking Nakamoto Consensus. In BlaNC, every honest node processes at most one out of several equivocations, and instead considers equivocating blocks to be blank. This makes honest nodes immune to the effects of equivocation spamming. However, we need to ensure that honest nodes can still switch from one chain to another longer chain, both of which might contain different equivocating blocks. For this, note that headers of two equivocating</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">blocks from the same PoS lottery can serve as a succinct equivocation proof to convince other nodes that an equivocation was committed. Therefore, in BlaNC, if an honest node sees an equivocation for a block in its longest chain, it publishes an equivocation proof in the block that it produces, which allows all nodes to consistently treat the equivocating block's content as blank without processing it.</p>

    <p class="text-gray-300">A caveat so far is that an adversary could reveal an equivocation late and cause inconsistent ledgers across honest nodes and/or time. To avoid this, we enforce a deadline for how late an equivocation proof can be included in the chain. Our security proof shows how to parameterize the deadline and the protocol's confirmation depth such that if any honest node has blanked the content of any equivocating block on its longest chain, then an appropriate equivocation proof is timely included on-chain, and all honest nodes blank the block's content before it reaches the output ledger.</p>

    <p class="text-gray-300">1.2.3 Ensuring Fees Get Paid despite Lack of Predictable Validity. Blanking of blocks in BlaNC leads to lack of predictable transaction validity, i.e., honest nodes do not know whether transactions they include in their block will be valid, since the content of blocks in the prefix may later be blanked due to an equivocation. Many modern consensus protocols in which consensus proceeds without executing transactions [2, 20, 43, 61, 63] also lack predictable transaction validity. This risks that the adversary gets to spam the ledger with invalid transactions for free. In one solution to prevent this, we focus on guaranteeing transaction fees are always paid regardless of equivocations, by introducing gas deposit accounts that can only be used to pay transaction fees. Any deposit to such an account takes effect only after the deadline has passed for the inclusion of any equivocation proof that might lead to removal of transactions from the deposit's prefix. This gives honest block producers a lower bound on the account's balance which they can use to reliably determine whether a transaction can pay fees.</p>

    <p class="text-gray-300">We begin by exploring a strategy that the attacker can adopt which forces honest nodes to waste capacity on blocks that do not contribute to chain growth. This strategy demonstrates that the well-studied private attack [24, 45] is not the worst case behavior of the attacker, and that the previously established security bounds of the bounded-delay model do not hold in the bounded-capacity setting. We go on to simulate our teasing strategy and to show how it compares to the private attack (summarized in Fig. 5).</p>

    <p class="text-gray-300">Previous analyses concluded that the private attack (Fig. 5) is worst-case based on the false assumption that delays, and hence the honest chain growth rate, do not depend on whether the adversary releases blocks and causes congestion. We exploit congestion to develop the teasing strategy.</p>

    <p class="text-gray-300">Description of the Teasing Strategy. The key idea in the teasing strategy (summarized in Fig. 6) is that the adversary can strategically time the release of blocks it had mined in order to take up some of the capacity of honest nodes. In a nutshell, while the adversary continues to mine a private chain, every time an honest node announces a block at a new height, the adversary releases the</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 5: Private attack (recap): Based on the tip of the longest chain when the private attack starts, the adversary mines a private adversary chain, while honest nodes jointly grow a public honest chain. The adversary's goal is to deconfirm a transaction tx included on the honest chain just below where the adversary chain forks off. Adversary mining is perfectly coordinated so that the adversary chain grows at the adversary block production rate  <span class="math">\\lambda_{\\mathrm{adv}}</span> . Honest nodes suffer from forking due to network delay so that the honest chain grows at a lower rate  <span class="math">\\lambda_{\\mathrm{grwth}} &amp;lt; \\lambda_{\\mathrm{hon}}</span>  than the total block production rate  <span class="math">\\lambda_{\\mathrm{hon}}</span>  of honest nodes. The attack succeeds if the adversary chain grows faster than the honest chain ( <span class="math">\\lambda_{\\mathrm{adv}} &amp;gt; \\lambda_{\\mathrm{grwth}}</span> ) and thus, irrespective of the confirmation depth  <span class="math">k_{\\mathrm{conf}}</span>  chosen for NC, the adversary chain can eventually displace the honest chain as the longest chain and with that deconfirm tx.</p>

    <p class="text-gray-300">headers of a segment of its longer withheld chain and the contents of only the first block. Due to longest-header-chain scheduling, honest nodes prioritize processing blocks on the chain announced by the adversary. Only after an honest node has processed the first adversary block and realizes that the content for the remaining blocks in the announced adversary chain segment are unavailable, does the longest-header-chain rule switch back to processing the newly created honest block. Therefore, the adversary 'teased' the honest nodes to spend some of their resources processing the adversary chain, but without actually gaining a longer chain of blocks compared to the chain they already possessed. The result of this strategy is delayed processing of honest blocks that extend the longest honest chain. Processing is delayed by a factor of 2 compared to the private attack. This in turn results in more honest blocks forking, thus slowing down the honest chain growth rate (Fig. 7 o) to  <span class="math">\\lambda_{\\mathrm{grwth}}^{\\mathrm{teaser}} &amp;lt; \\lambda_{\\mathrm{grwth}}^{\\mathrm{priv}}</span> .</p>

    <p class="text-gray-300">Conditions for success of the teasing strategy. Formally, in both the private attack and the teasing strategy, the length difference between the adversary chain and the honest chain is a random walk [24] which increases at the rate  <span class="math">\\lambda_{\\mathrm{adv}}</span>  and decreases at the rate  <span class="math">\\lambda_{\\mathrm{grwth}}</span> . If  <span class="math">\\lambda_{\\mathrm{adv}} &amp;gt; \\lambda_{\\mathrm{grwth}}</span> , the random walk has a positive drift, so in the long run, the adversary chain will outgrow the honest chain indefinitely and the attack succeeds. Conversely, if  <span class="math">\\lambda_{\\mathrm{adv}} &amp;lt; \\lambda_{\\mathrm{grwth}}</span> , the random walk has a negative drift and the attack will eventually fail. Thus,  <span class="math">\\lambda_{\\mathrm{grwth}}</span>  determines the fraction  <span class="math">\\beta</span>  of total mining power that the adversary needs for the attack, i.e., the attack succeeds if</p>

    <div class="my-4 text-center"><span class="math-block">\\beta \\triangleq \\frac {\\lambda_ {\\mathrm {a d v}}}{\\lambda_ {\\mathrm {a d v}} + \\lambda_ {\\mathrm {h o n}}} &amp;gt; \\frac {\\lambda_ {\\mathrm {g r w t h}}}{\\lambda_ {\\mathrm {g r w t h}} + \\lambda_ {\\mathrm {h o n}}}. \\tag {1}</span></div>

    <p class="text-gray-300">Note that the teasing strategy requires the adversary to maintain a lead of at least two blocks with respect to the honest chain at all times (to proceed in steps (a), (e) in Fig. 6). If this fails, then the adversary must give up and try the attack again. We show a</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (a)</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (b)</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (c)</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> (d)</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> (e)</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> (f) Figure 6: Teasing strategy: Green/red are honest/adversary blocks, and numbers on blocks indicate height in the blockchain. Semi-transparent blocks have been announced (i.e., headers released) but were not yet processed by honest nodes. Blocks with a dashed outline are mined privately by the adversary but not announced. (a) The adversary begins with a short private lead, while honest nodes attempt to extend the honest block 1. (b) An honest node mines a block at height  <span class="math">h = 2</span> , and announces it. Until this block is processed, all honest nodes (except the one who mined block  <span class="math">h</span> ) continue to mine on top of the block at height  <span class="math">h - 1</span> . (c) The adversary announces its chain with height  <span class="math">h + 1</span> , and the honest nodes prioritize its processing beginning with block 1. (d) Honest nodes keep mining as before while requesting the content of the longest chain (the adversary's chain). When honest nodes request the adversary's block of height  <span class="math">h = 2</span> , they find it to be unavailable ('?'), i.e., the adversary did not release its content. Honest nodes then resume processing the honest block of height  <span class="math">h = 2</span> . (e) Eventually, all honest nodes process some block at height 2. The delay in this processing means new blocks by honest nodes could have been mined at height 2, thereby not growing the chain. Meanwhile, if the adversary mined another block, then they are back to step (a), i.e., the adversary has a 2 block lead and can repeat steps (b)-(e) at the next height  <span class="math">h + 1</span> , as shown in step (f).</p>

    <p class="text-gray-300">sample plot of the adversary's lead for different mining rates in Fig. 8. For a large enough adversary (if  <span class="math">\\lambda_{\\mathrm{adv}} &amp;gt; \\lambda_{\\mathrm{grwth}}^{\\mathrm{priv}}</span> ), it is clear the lead has a positive drift and eventually stays positive. However, the teasing strategy succeeds even when the lead has a negative drift initially (e.g. for  <span class="math">\\lambda_{\\mathrm{grwth}}^{\\mathrm{teaser}} &amp;lt; \\lambda_{\\mathrm{adv}} &amp;lt; \\lambda_{\\mathrm{grwth}}^{\\mathrm{priv}}</span> ), as it only needs a random lucky short burst to kickstart step (a). The resulting congestion then decreases the average growth rate of the honest chain to  <span class="math">\\lambda_{\\mathrm{grwth}}^{\\mathrm{teaser}}</span>  and the adversary with mining power  <span class="math">\\lambda_{\\mathrm{adv}} &amp;gt; \\lambda_{\\mathrm{grwth}}^{\\mathrm{teaser}}</span>  can positively bias the random walk, thus eventually maintaining a positive lead, and succeed. We see this process in Fig. 8 —: the adversary's lead rises and drops to zero a few times, causing the adversary to try again. However, eventually, the adversary manages to maintain a permanent lead. On the other hand, when  <span class="math">\\lambda_{\\mathrm{adv}} &amp;lt; \\lambda_{\\mathrm{grwth}}^{\\mathrm{teaser}}</span> , the adversary's lead has a negative drift even after the congestion</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 7: Results of a simulation showing that attackers can slow the growth of the honest chain using the teasing strategy. Shown, is the rate of chain growth relative to honest block production rate, when nodes prioritize processing towards the longest header chain, for various capacity limits. When the attacker does not release any blocks (no attack or private attack), we already see  <span class="math">\\lambda_{\\mathrm{grwth}} &amp;lt; \\lambda_{\\mathrm{hon}}</span>  due to natural congestion  <span class="math">(\\diamond)</span> . The honest chain growth rate under the private attack is approximately the same for a network with finite processing capacity  <span class="math">C(\\diamond)</span> , or for an idealized network with bounded delay  <span class="math">\\Delta = 1 / C(\\longrightarrow)</span> . With a teasing strategy, processing is slowed roughly by a factor of 2, which lowers the growth rate of the chain further  <span class="math">(\\diamond)</span> . This lowers security compared to a private attack, cf. Fig. 1.</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Figure 8: Adversary lead (difference between adversary and honest chain lengths) under private attack and teasing strategy. The simulation consists of 100 honest nodes with capacity  <span class="math">C = 2</span>  blocks per second, collectively mining  <span class="math">\\lambda_{\\mathrm{hon}} = 1</span>  block per second, and one adversary node with variable mining rate  <span class="math">\\lambda_{\\mathrm{adv}}</span>  blocks per second. With these parameters,  <span class="math">\\lambda_{\\mathrm{grwth}}^{\\mathrm{priv}} = 0.67</span>  and  <span class="math">\\lambda_{\\mathrm{grwth}}^{\\mathrm{teaser}} = 0.50</span>  (from Fig. 7). A weak adversary  <span class="math">(\\lambda_{\\mathrm{adv}} = 0.45, \\longrightarrow)</span>  is unable to mine fast enough to gain a lead on the network. A stronger adversary  <span class="math">(\\lambda_{\\mathrm{adv}} = 0.60)</span>  fails to gain a permanent lead through the private attack  <span class="math">(\\longrightarrow)</span> . But, through the teasing strategy, after repeatedly retrying during the first 200 seconds, eventually manages to maintain a lead  <span class="math">(\\longrightarrow)</span> . An even stronger adversary  <span class="math">(\\lambda_{\\mathrm{adv}} = 0.75)</span>  succeeds almost at once under both strategies  <span class="math">(\\longrightarrow, \\longrightarrow)</span> .</p>

    <p class="text-gray-300">effects kick in (Fig. 8 —), and therefore the teasing strategy is bound to run out of blocks and fail.</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">With the combined mining rate  <span class="math">\\lambda \\triangleq \\lambda_{\\mathrm{hon}} + \\lambda_{\\mathrm{adv}}</span>  of honest nodes and adversary, and the honest chain growth rates from Fig. 7, we use eqn. (1) to calculate the adversary fraction  <span class="math">\\beta</span>  required for each attack and plot it in Fig. 1.</p>

    <p class="text-gray-300">Simulation details. We simulate both the private attack and the teasing strategy on a network of 100 nodes. Honest nodes collectively mine blocks at a rate  <span class="math">\\lambda_{\\mathrm{hon}} = 1</span>  block per second. Each node has a limited processing rate of  <span class="math">C</span>  blocks per second. Blocks consist of content (transactions) and a header (PoW and parent block pointer). Since the header contains all information necessary to verify the PoW, nodes only process validly created blocks. All honest nodes and the adversary can directly send valid block headers to one another. Given a tree of valid block headers, nodes run the longest-header-chain policy, i.e., nodes attempt to process (download and verify) the first unprocessed block along the longest header chain. If the longest chain is already processed, or if the content of any block on that chain is unavailable or invalid, then the rule considers the next longest header chain, and so on. We further elaborate on the setup and other simulation details in App. A.</p>

    <p class="text-gray-300">Practical aspects of the teasing strategy. The teasing strategy may not acutely break specific real-world implementations of PoW NC, mainly because miners have over-provisioned capacity. Although the teasing strategy is specific to the longest-header-chain policy, it is possible to devise attacks that exploit congestion even for other policies (see App. B.1). We also note that in basic PoS NC, the adversary can exacerbate the teasing strategy by equivocating the whole adversary chain every time before it releases a block. As the attack goes on, the length of the new announced chain increases. This increases the time honest nodes spend processing this chain, and decelerates the honest chain growth until it comes to a halt. As a result, the chain growth rate under the equiv-teasing attack is nearly zero (details in App. B.2). The key takeaway from the teasing strategy is that exploiting congestion results in attacks that are more severe than the private attack, even in PoW where the block production is limited, and even when the block production rate is below the capacity of nodes. This invalidates the bounded-delay model's predictions and emphasizes the need for a security analysis under models that capture the effects of congestion, especially for protocols that aim to saturate physical performance limits.</p>

    <p class="text-gray-300">Effect of SPV miners. Rational miners in PoW NC face a verifier's dilemma [15, 21, 42]: there is no incentive to download and verify a block's content before mining to extend it. Some so called SPV miners (named after simple-payment-verification clients who download only block headers) mine empty blocks without verifying the parent block's content first, and thus get more time to mine, increasing their chances of being rewarded for mining the next block. Since SPV miners are immune to congestion (as they do not process block content), how does their presence affect the teasing strategy? Under the teasing strategy, SPV miners would mine on the adversary's longer header chain (red block 3 in Fig. 6(d)) without waiting for its contents. However, the remaining honest miners (who we assume still outnumber the SPV miners) still do not consider this chain valid (due to unavailable content). They continue mining on the honest chain, and would still be slowed down by the teasing strategy just as before. We added SPV miners to our simulation and</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> Figure 9: Teasing strategy in the presence of SPV miners, compared with teasing strategy and private attack without SPV miners (same as in Fig. 7). Total mining rate of SPV miners is  <span class="math">\\lambda_{\\mathrm{spv}}</span>  blocks per second. Total mining rate of honest miners is  <span class="math">\\lambda_{\\mathrm{hon}} = 1</span>  block per second. SPV miners are not counted as honest. Teasing strategy still succeeds with lower adversary power than private attack (Fig. 9).</p>

    <p class="text-gray-300">verified that the teasing strategy still succeeds with lower adversary power than the private attack (Fig. 9). Thus, the qualitative insight from the teasing strategy, that congestion enables worse attacks than the private attack, persists.</p>

    <p class="text-gray-300">We briefly recap Nakamoto consensus (NC) and the bounded-capacity model of [48]. Detailed pseudocode of the protocol is provided in App. C.1. Technical details about the model are provided in App. C.3. For ease of exposition, the execution features a static set of  <span class="math">N</span>  equipotent nodes, each of which runs an independent instance of the protocol. Temporary crash faults ('sleepiness') of nodes, heterogeneous distribution of hash power, or difficulty adjustment are left to be addressed with techniques from [28, 29, 52]. We are interested in the large system regime  <span class="math">N \\to \\infty</span> . Nodes interact with each other and with the adversary  <span class="math">\\mathcal{A}</span>  through an environment  <span class="math">\\mathcal{Z}</span>  that models the network.  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{Z}</span>  are summarized below.</p>

    <p class="text-gray-300">Nakamoto's Longest Chain Consensus Protocol. For ease of analysis, we consider the protocol (pseudocode in Alg. 1) to proceed in discrete slots of duration  <span class="math">\\tau</span> . Consider  <span class="math">\\tau</span>  to be a small quantum of time where  <span class="math">\\tau \\rightarrow 0</span> . At each slot  <span class="math">t</span> , the protocol queries the PoW block production ('mining') oracle (idealized functionality in Alg. 2) in an attempt to extend the longest processed chain  <span class="math">\\mathrm{d}C</span>  in the node's view with a new block of pending transactions txs. Each block production attempt is committed to a parent block and block content, and only a single block is produced when the attempt is successful. Per slot, each node can make one block production attempt that will be successful with probability  <span class="math">\\rho / N</span>  where  <span class="math">\\rho = \\Theta(\\tau)</span> , independently of other nodes and slots. If successful, the node disseminates both the resulting (block) header  <span class="math">C&#x27;</span>  and the associated (block) content txs via the environment  <span class="math">\\mathcal{Z}</span>  to all nodes. Finally, the protocol identifies the  <span class="math">k_{\\mathrm{conf}}</span> -deep prefix  <span class="math">\\mathrm{d}C^{\\lceil k_{\\mathrm{conf}} \\rceil}</span>  containing all but the last  <span class="math">k_{\\mathrm{conf}}</span>  blocks of  <span class="math">\\mathrm{d}C</span> . The transactions along  <span class="math">\\mathrm{d}C^{\\lceil k_{\\mathrm{conf}} \\rceil}</span>  are concatenated to produce the output ledger  <span class="math">\\mathrm{LOG}^t</span> .</p>

    <p class="text-gray-300">When a node  <span class="math">p</span>  receives a new valid block header  <span class="math">C</span>  from  <span class="math">\\mathcal{Z}</span>  (push-based header broadcasting), then  <span class="math">p</span>  adds  <span class="math">C</span>  to its header tree</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300"><span class="math">\\mathsf{h}\\mathcal{T}</span>  and relays  <span class="math">\\mathcal{C}</span>  to all other nodes via  <span class="math">\\mathcal{Z}</span> . Throughout the execution, the protocol requests from  <span class="math">\\mathcal{Z}</span>  (pull-based content downloading) the content for block headers decided by a scheduling policy. As a concrete example, we use the longest-header-chain rule (pseudocode in Alg. 3) in which a node downloads content for the first block header with unknown content on the longest header chain it sees. Once a block's content is received and verified by executing its transactions, the node makes it available to other nodes via  <span class="math">\\mathcal{Z}</span> , and updates its  <span class="math">\\mathrm{d}\\mathcal{C}</span> .</p>

    <p class="text-gray-300">Bounded-Capacity Network. We borrow the bounded-capacity network model of [48] (see Fig. 16 for an illustration). In this model,  <span class="math">\\mathcal{Z}</span>  abstracts push-based flooding of 'small' block headers and pull-based downloading of 'large' block contents from peers. Broadcasted block header chains are delivered by  <span class="math">\\mathcal{Z}</span>  to every node, with a per-node per-header delay determined by  <span class="math">\\mathcal{A}</span> , up to a commonly known delay upper bound  <span class="math">\\Delta_{\\mathrm{h}}</span> . Block content made available for download is kept by  <span class="math">\\mathcal{Z}</span>  in what can be thought of as a 'cloud'. Nodes can request the content associated with a particular header. If content matching the header is available, then it is delivered by  <span class="math">\\mathcal{Z}</span>  to the node. Content download and verification is subject to a per-node capacity constraint of  <span class="math">C</span> . Blocks have a fixed maximum size, hence  <span class="math">C</span>  is measured in blocks per second. See App. C.3 for a more formal description of  <span class="math">\\mathcal{Z}</span> .</p>

    <p class="text-gray-300">The 'cloud' captures key properties of pull-based peer-to-peer downloading. At first, content matching a particular header might not be available (e.g.,  <span class="math">\\mathcal{A}</span>  produced a block and disseminated its header, but withheld its content). Later, such content can become available (e.g.,  <span class="math">\\mathcal{A}</span>  releases the content to one node). Thus, the 'cloud' ensures neither data availability nor strong consistency of query outcomes, unlike stronger primitives such as verifiable information dispersal [13, 33, 46, 63]. However, once content for a header does become available, it is unique and remains available. This captures the header's binding commitment to the content, and the fact that honest nodes share content with peers. Requests for unavailable content do not count towards the processing budget.</p>

    <p class="text-gray-300">Also note that the adversary can push additional headers and contents to nodes at will. This models non-uniform capacity (higher than the lower bound  <span class="math">C</span> ) and non-uniform delay (lower than the upper bound  <span class="math">\\Delta_{\\mathrm{h}}</span> ) across nodes (analogous to adversary delay up to maximum  <span class="math">\\Delta</span>  in the bounded-delay model).</p>

    <p class="text-gray-300">The Adversary. The static adversary  <span class="math">\\mathcal{A}</span>  chooses a set of nodes (up to a fraction  <span class="math">\\beta</span>  of all  <span class="math">N</span>  nodes, where  <span class="math">\\beta</span>  is common knowledge) to corrupt before the randomness of the execution is drawn and the execution commences. Uncorrupted honest nodes follow the protocol at all times. Corrupted adversary nodes have arbitrary computationally-bounded Byzantine behavior, coordinated by  <span class="math">\\mathcal{A}</span>  in an attempt to break consensus. Among other things, the adversary can: withhold block headers and contents, or release them late or selectively to honest nodes; push headers and contents to nodes while bypassing the delay and capacity constraints; break ties in the chain selection and schdeuling policy. Note that all miners that deviate from the honest protocol (including crash faults and SPV miners) are modeled as adversary.</p>

    <p class="text-gray-300">Security. For an execution of PoW NC where every honest node  <span class="math">p</span>  at every slot  <span class="math">t</span>  outputs a ledger  <span class="math">\\mathrm{LOG}_p^t</span> , we recall the security desiderata.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Safety: For all adversary strategies, all slots  <span class="math">t, t&#x27;</span> , and all honest nodes  <span class="math">p, q</span>  (same or different):  <span class="math">\\mathrm{LOG}_p^t \\preceq \\mathrm{LOG}_q^{t&#x27;}</span>  or  <span class="math">\\mathrm{LOG}_q^{t&#x27;} \\preceq \\mathrm{LOG}_p^t</span> .</li>

      <li><span class="math">T_{\\mathrm{live}}</span> -Liveness: For all adversary strategies, if a transaction tx is received by all honest nodes by slot  <span class="math">t</span> , then for every honest node  <span class="math">p</span>  and for all slots  <span class="math">t&#x27; \\geq t + T_{\\mathrm{live}}</span> ,  <span class="math">\\mathrm{tx} \\in \\mathrm{LOG}_p^{t&#x27;}</span> .</li>

    </ul>

    <p class="text-gray-300">Note that since blocks have a fixed maximum size, liveness is expected only if transactions are received at a bounded rate. The following definition captures this.</p>

    <p class="text-gray-300">Definition 3.1. The environment  <span class="math">\\mathcal{Z}</span>  is  <span class="math">(\\theta, T_{\\mathrm{txlim}})</span> -tx-limited, if the cumulative size of all transactions received by honest nodes during any interval of  <span class="math">T_{\\mathrm{txlim}}</span>  slots is at most  <span class="math">\\theta \\cdot T_{\\mathrm{txlim}}</span>  times the maximum block size.</p>

    <p class="text-gray-300">Liveness will be proved under transaction-limited environments. The parameter  <span class="math">\\theta</span>  is thus the worst-case throughput ( <span class="math">\\lambda</span>  being the best-case throughput). The burstiness of transaction arrival is measured by  <span class="math">T_{\\mathrm{txlim}}</span> ; large  <span class="math">T_{\\mathrm{txlim}}</span>  may increase confirmation latency  <span class="math">T_{\\mathrm{live}}</span> .</p>

    <p class="text-gray-300">A consensus protocol is secure over time horizon  <span class="math">T_{\\mathrm{hrzn}}</span>  slots with transaction rate  <span class="math">\\theta</span>  iff for some finite  <span class="math">T_{\\mathrm{txlim}}</span> ,  <span class="math">T_{\\mathrm{live}}</span> , for all  <span class="math">(\\theta, T_{\\mathrm{txlim}})</span> -tx-limited environments, it satisfies safety, and  <span class="math">T_{\\mathrm{live}}</span> -liveness with overwhelming probability over executions of time horizon  <span class="math">T_{\\mathrm{hrzn}}</span>  slots. The properties can also be redefined in terms of real-time units instead of slots.</p>

    <p class="text-gray-300">Due to space constraints, we focus on the intuition for the proof. The security theorem for PoW NC is Thm. 4.10. The detailed full proof is provided in App. D.</p>

    <p class="text-gray-300">For any sequence  <span class="math">\\{X_k\\}</span>  and index set  <span class="math">I</span> , let  <span class="math">X_I \\triangleq \\sum_{k \\in I} X_k</span> .</p>

    <p class="text-gray-300">Probabilistic Model for PoW NC Executions. A block production opportunity (BPO) is a pair  <span class="math">(p, t)</span>  where according to the PoW block production lottery, node  <span class="math">p</span>  is eligible to produce a block in slot  <span class="math">t</span> . A BPO is honest (resp. adversary) if  <span class="math">p</span>  is honest (resp. adversary). Since  <span class="math">N \\to \\infty</span> , and mining power is homogeneous, honest (resp. adversary) BPOs per slot are Poisson distributed with parameter  <span class="math">(1 - \\beta)\\rho</span>  (resp.  <span class="math">\\beta\\rho</span> ). An execution refers to a particular realization of the block production lottery for all slots.</p>

    <p class="text-gray-300">Good, Bad, and Empty Slots. Slots without a BPO are called 'empty'. A slot is 'good' iff it has exactly one honest BPO and no adversary BPOs, and is followed by  <span class="math">\\nu</span>  empty slots (inspired by convergence opportunities [37, 50, 52], loners [24], and laggers [55]). Here,  <span class="math">\\nu</span>  is an analysis parameter. We define another analysis parameter  <span class="math">\\widetilde{C}</span>  which is related to  <span class="math">\\nu</span>  as  <span class="math">(\\nu + 1)\\tau \\triangleq \\Delta_{\\mathrm{h}} + \\widetilde{C} / C</span> . Thus,  <span class="math">\\nu, \\widetilde{C}</span>  are chosen so that for a good slot, every honest node can receive the block header for the honest BPO, and process content for  <span class="math">\\widetilde{C}</span>  blocks, before the next BPO. Any non-empty slot which is not good is called 'bad'.</p>

    <p class="text-gray-300">We denote by  <span class="math">t_k</span>  the  <span class="math">k</span> -th non-empty slot. Then, we can introduce random processes over indices, with index  <span class="math">k</span>  corresponding to the</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300"><span class="math">k</span> -th non-empty slot  <span class="math">t_k</span> . Considering only indices simplifies notation considerably. The process  <span class="math">\\{G_k\\}</span>  (' <span class="math">G&#x27;</span>  for good) counts good slots, with  <span class="math">G_k \\triangleq \\mathbb{1}_{\\{\\mathrm{Good}(t_k)\\}}</span> . Correspondingly, let  <span class="math">\\overline{G}_k \\triangleq 1 - G_k</span> . The following fact shows the distribution of good indices.</p>

    <p class="text-gray-300">PROPOSITION 4.1. The  <span class="math">\\{G_k\\}</span>  are independent and identically distributed (iid) with  <span class="math">\\operatorname*{Pr}[G_k = 1] \\triangleq p_{\\mathrm{G}} = (1 - \\beta)\\frac{\\rho e^{-\\rho(\\nu + 1)}}{1 - e^{-\\rho}}</span> .</p>

    <p class="text-gray-300">Throughout the analysis, we assume  <span class="math">p_{\\mathrm{G}} &amp;gt; \\frac{1}{2}</span>  ('honest majority' assumption).</p>

    <p class="text-gray-300">Some Good Slots Imply Growth. A special role is played by good slots  <span class="math">t_k</span>  with the additional property that the block produced at  <span class="math">t_k</span>  is 'soon' processed by all honest nodes. Intuitively, these lead to chain growth, the cornerstone of NC security [24, 52]. We count these slots with  <span class="math">\\{D_k\\}</span>  ('D' for downloaded). Specifically,  <span class="math">D_k \\triangleq 1</span>  if  <span class="math">t_k</span>  is good and the block produced at  <span class="math">t_k</span>  has been processed by all honest nodes by the end of slot  <span class="math">t_k + \\nu</span> ,  <span class="math">D_k \\triangleq 0</span>  otherwise, and  <span class="math">\\overline{D}_k \\triangleq 1 - D_k</span> . Note that  <span class="math">\\{G_k\\}</span>  are iid, and not affected by adversary action, while  <span class="math">\\{D_k\\}</span>  do depend on the adversary action and are thus in particular not iid.</p>

    <p class="text-gray-300">Definition 4.2. We call an index  <span class="math">k</span>  a ppivot (probabilistic pivot), denoted as PPivot  <span class="math">(k)</span> , iff PPivot  <span class="math">(k) \\triangleq (\\forall (i,j] \\ni k: G_{(i,j]} &amp;gt; \\overline{G}_{(i,j)})</span> .</p>

    <p class="text-gray-300">Definition 4.3. We call an index  <span class="math">k</span>  a cpivot (combinatorial pivot), denoted as CPivot  <span class="math">(k)</span> , iff CPivot  <span class="math">(k) \\triangleq (\\forall (i,j] \\ni k: D_{(i,j]} &amp;gt; \\overline{D}_{(i,j)})</span> .</p>

    <p class="text-gray-300">This definition of ppivots and cpivots decouples [52, Def. 5] into its probabilistic aspects [52, Sec. 5.6.3] and combinatorial aspects [52, Sec. 5.6.2], and casts them as conditions on a random walk, inspired by [24, 40], to simplify the analysis. The decoupling is one of the key differences from the analysis in [52] (see Fig. 4). Note that a cpivot is also a ppivot because  <span class="math">D_{i} = 1</span>  implies  <span class="math">G_{i} = 1</span> .</p>

    <p class="text-gray-300">We follow Fig. 4(b). First, we show (Sec. 4.2.1) that blocks from cpivots stabilize, i.e., they are in the longest processed chain of all nodes forever (Lem. 4.5). This is useful because if we know that cpivots occur frequently, then honest nodes can confirm transactions that must lie in the prefix of a cpivot's block (safety), and cpivots' blocks (being produced by honest nodes) bring any outstanding transactions onto chain (liveness). We then show that cpivots occur frequently: We show with a new probabilistic argument (Sec. 4.2.2) that ppivots are abundant, i.e., in every 'sufficiently long' interval (i.e., of length  <span class="math">\\Omega(\\kappa^2)</span> ), a constant fraction of the slots are ppivots (Lem. 4.6). Due to the decoupling of cpivots and ppivots, the proof up to this point does not depend on the capacity constraint and the scheduling policy. Then, we show with a new combinatorial argument (Sec. 4.2.3) that the adversary cannot prevent all ppivots from becoming cpivots, i.e., in every 'sufficiently long' interval, there is at least one cpivot (Lem. 4.8). As a result, if honest nodes confirm transactions that are still on their longest processed chain after 'sufficiently long' time (i.e., confirmation latency  <span class="math">\\Omega(\\kappa^2)</span> ), then PoW NC is safe and live under bounded capacity (Sec. 4.3).</p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a> Figure 10: An illustration for the proof of abundance of ppivots (Prop. D.11). Given a long interval of size  <span class="math">2K_{1}K_{2}</span> , we partition it into  <span class="math">K_{2}</span>  intervals of size  <span class="math">2K_{1}</span>  each, and we group the indices as indicated by different colors. All indices of the same color are at least  <span class="math">2K_{1}</span>  apart, so that intervals of size at most  <span class="math">K_{1}</span>  surrounding two indices from the same group are disjoint, and hence the corresponding ppivot conditions are independent (conditioned on the fact that the ppivot condition holds for all long intervals).</p>

    <p class="text-gray-300">4.2.1 Combinatorial Pivots Stabilize. We now show that the honest block produced in a slot corresponding to a cpivot persists in the longest processed chain of all honest nodes forever after  <span class="math">\\nu</span>  slots after it was produced. Towards this, we first show:</p>

    <p class="text-gray-300">PROPOSITION 4.4 (FORMAL VERSION: PROP. D.4). At every index  <span class="math">k</span>  with  <span class="math">D_{k} = 1</span> , the length of the "shortest (across honest nodes) longest processed chain" grows.</p>

    <p class="text-gray-300">That is, good slots where all honest nodes process the produced block are chain growth events. Due to this and since, by Def. 4.3, all intervals around a cpivot contain more indices with  <span class="math">D_{k} = 1</span>  than those with  <span class="math">D_{k} = 0</span> , there are not enough blocks for any other chain to outnumber the chain growth events that contributed to the growth of the processed chain containing the cpivot's block. Thus, we show the following (proven analogously to the combinatorial argument of [52]):</p>

    <p class="text-gray-300">LEMMA 4.5 (FORMAL VERSION: LEM. D.5). Let  <span class="math">b^{<em>}</span>  be the block produced in a non-empty slot  <span class="math">t_k</span>  such that CPivot( <span class="math">k</span> ). Then, for all slots  <span class="math">t \\geq t_k + \\nu</span> :  <span class="math">b^{</em>}</span>  is in the longest processed chains of all honest nodes.</p>

    <p class="text-gray-300">4.2.2 Probabilistic Pivots Are Abundant. Previous analyses of NC [24, 52] show that sufficiently long intervals contain at least one ppivot (Fig. 4(a)). This was enough for the bounded-delay analysis because in the bounded-delay setting, every ppivot is also a cpivot [51, Fact 1]. However, in the bounded-capacity setting, not every cpivot is a ppivot, because not every good slot results in growth of the longest processed chain of honest nodes (Fig. 4(b)). Thus, existence of one ppivot in every large interval is not enough to conclude existence of one cpivot in every large interval. Instead, we prove, using a concentration bound on the number of ppivots, that long intervals of indices in fact contain a number of ppivots proportional to the interval length (Lem. 4.6). Then, in Sec. 4.2.3, we prove that out of those many ppivots, at least one must also be a cpivot, which allows us to continue with the safety and liveness proofs from [52].</p>

    <p class="text-gray-300">The key challenge in proving that there are many ppivots is that for two indices  <span class="math">k_{1}, k_{2}</span> , the events that  <span class="math">k_{1}</span>  is a ppivot and that  <span class="math">k_{2}</span>  is a ppivot are dependent, because both events depend on overlapping intervals. But a key observation is that since the ppivot condition (Def. 4.2) already holds for large intervals with high probability (Prop. D.8), we only need to look at the small intervals. Then, for two indices  <span class="math">k_{1}, k_{2}</span>  that are sufficiently far apart, these short intervals are disjoint, and thus the corresponding ppivot conditions are independent. Therefore, we decompose a long interval of indices</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">into several groups of far-apart indices. This is illustrated in Fig. 10, each group indicated by a different color. Within each group, by a concentration bound for iid random variables, there are many ppivots. Further, by a union bound, the concentration holds in all the groups simultaneously with high probability (Prop. D.11). Using this, we show:</p>

    <p class="text-gray-300">LEMMA 4.6 (FORMAL VERSION: LEM. D.12). For  <span class="math">K_{\\mathrm{cp}} = \\Omega(\\kappa^2)</span> , with overwhelming probability, in every interval of size at least  <span class="math">K_{\\mathrm{cp}}</span> , at least  <span class="math">(1 - \\delta)p_{\\mathrm{ppivot}}</span>  fraction of the indices in the interval are ppivots.</p>

    <p class="text-gray-300">4.2.3 Many Probabilistic Pivots Imply One Combinatorial Pivot. The longest-header-chain rule  <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>  (Alg. 3) has a few useful properties. Nodes using this rule</p>

    <p class="text-gray-300">(P1) process a BPO's block's content at most once, (P2) either process the most recent honest block, or fully utilize their capacity to process other blocks (i.e., do not stay idle), and (P3) prioritize blocks that were produced 'recently'.</p>

    <p class="text-gray-300">(P1) holds by construction. (P2) holds because this rule is never idle, and will always process towards an honest block when it has processed all longer chains and there is capacity remaining. Moreover, we expect that in a secure execution, (P3) holds because a node's longest header chain cannot fork off too much from its longest processed chain. More precisely, due to Lem. 4.5, any longest header chain in any honest node's view must extend the block produced in the most recent cpivot, and therefore blocks with the highest process priority must have been produced after the most recent cpivot. Thus, if the adversary wants to prevent honest nodes from processing the block produced at a good index  <span class="math">k</span> , so that  <span class="math">G_{k} = 1</span>  but  <span class="math">D_{k} = 0</span> , then it can only "distract" them by providing  <span class="math">\\widetilde{C}</span>  blocks produced after the most recent cpivot (Prop. 4.7).</p>

    <p class="text-gray-300">While we subsequently use  <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>  as a concrete example, the proofs only use (P1), (P2), (P3), and thus apply to several other simple scheduling policies, including the freshest-block rule of [48].</p>

    <p class="text-gray-300">PROPOSITION 4.7. If  <span class="math">G_{k} = 1</span>  and  <span class="math">D_{k} = 0</span> , then during slots  <span class="math">[t_k, t_k + \\nu]</span> , all honest nodes using the longest-header-chain scheduling policy process content of at least  <span class="math">\\widetilde{C}</span>  blocks that are produced in  <span class="math">(i, k]</span> , where  <span class="math">i &amp;lt; k</span>  is the largest index such that CPivot(i) (if such an  <span class="math">i</span>  does not exist,  <span class="math">i = 0</span> ).</p>

    <p class="text-gray-300">Proof. In slot  <span class="math">t_k</span> , there is exactly one block  <span class="math">b</span>  produced by an honest node, the block header is made public at the beginning of the slot, and is seen by all honest nodes within  <span class="math">\\Delta_{\\mathrm{h}}</span>  time. Thereafter, each node has enough time to process  <span class="math">\\widetilde{C}</span>  blocks during slots  <span class="math">[t_k, t_k + \\nu]</span> .</p>

    <p class="text-gray-300">Under the longest-header-chain scheduling policy, if  <span class="math">D_{k} = 0</span> , i.e. an honest node did not process content for the block  <span class="math">b</span>  before the end of slot  <span class="math">t_{k} + \\nu</span> , then that honest node must process the content for at least  <span class="math">\\widetilde{C}</span>  blocks on chains longer than the height of the block  <span class="math">b</span>  or in the prefix of the block  <span class="math">b</span> . Since honest nodes produce blocks extending their longest chain,  <span class="math">b</span>  extends the longest processed chain of some honest node at slot  <span class="math">t_{k} - 1</span> . Let  <span class="math">b^{<em>}</span>  be the block produced in slot  <span class="math">t_{i}</span>  where  <span class="math">\\mathrm{CPivot}(i)</span>  (suppose  <span class="math">i</span>  exists).  <span class="math">\\mathrm{CPivot}(i) \\Rightarrow Y_{i} = 1</span> , therefore this block is unique, and also  <span class="math">t_{k} &amp;gt; t_{i} + \\nu</span> . Due to Lem. 4.5, any valid header chain longer than  <span class="math">b</span>  (which is some node's longest processed chain) at time slot  <span class="math">t_{k}</span>  must contain  <span class="math">b^{</em>}</span> . Therefore, the only blocks that are processed by an honest node during slots  <span class="math">[t_{k}, t_{k} + \\nu]</span></p>

    <p class="text-gray-300">!<a href="img-16.jpeg">img-16.jpeg</a> Figure 11: (a) Example realization of BPOs in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span> , with good (+) and bad (-) indices, and resulting ppivots (O). (b) To prevent a ppivot from being a cpivot, the adversary needs to prevent timely processing (X) of some blocks produced at good indices, so that around the respective ppivot there is an interval ( <span class="math">\\square</span> ) in which the cpivot condition (cf. Def. 4.3) is violated. Here, the first two ppivots are not cpivots. To prevent timely processing of a block from a good index, the adversary must 'spend'  <span class="math">\\widetilde{C}</span>  blocks. Once the adversary runs out of blocks, a ppivot remains a cpivot (here the third ppivot).</p>

    <p class="text-gray-300">(1) must be produced after  <span class="math">t_i</span>  because they extend  <span class="math">b^*</span> , and (2) must be produced no later than  <span class="math">t_k</span>  because there are no blocks produced in  <span class="math">(t_k, t_k + \\nu]</span> .</p>

    <p class="text-gray-300">In case a cpivot  <span class="math">i &amp;lt; k</span>  does not exist, the claim is trivial.</p>

    <p class="text-gray-300">Given the above properties of the scheduling policy, we now want to show that cpivots occur once in a while. Fig. 11 illustrates the key argument for this. To start, let us show that there is at least one cpivot in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span> . From Lem. 4.6, there are many ppivots in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span> . If there were no cpivots in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span> , then the adversary must prevent each ppivot from turning into a cpivot. We know that in any interval around a ppivot, good indices outnumber bad indices by a margin proportional to the interval size (Prop. D.8, see top row in Fig. 11). Therefore, for a ppivot to not be a cpivot, the adversary must prevent an honest node from processing the most recent honest block in several of these good indices (so that the corresponding  <span class="math">G_k = 1</span>  indices have  <span class="math">D_k = 0</span> ). Fig. 11 shows an example where the adversary prevented processing of the honest block in one good index, and as a result, two of the ppivots fail to become a cpivot. From Prop. 4.7, for each such index, the adversary must 'spend' at least  <span class="math">\\widetilde{C}</span>  blocks that the honest node processes. These blocks come from a 'limited budget'. In Lem. D.13, through a combinatorial argument, we show that this 'budget' falls short of the number of blocks required to overthrow all cpivots. Thus, there must be at least one cpivot in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span> . Next, we would like to show that there is at least one cpivot in  <span class="math">\\{mK_{\\mathrm{cp}}, (m + 1)K_{\\mathrm{cp}}\\}</span>  for all  <span class="math">m \\geq 0</span>  (by induction, where we just saw the base case  <span class="math">m = 0</span> ). Here, one may be concerned that the adversary could save up many blocks from the past and attempt to make honest nodes process these blocks at a particular target slot  <span class="math">t_k</span> . But, given that one cpivot occurred in  <span class="math">\\{(m - 1)K_{\\mathrm{cp}}, mK_{\\mathrm{cp}}\\}</span>  (by induction hypothesis), Prop. 4.7 ensures that honest nodes will only process blocks that are produced after  <span class="math">(m - 1)K_{\\mathrm{cp}}</span> . This allows us to bound the 'budget' of blocks that the adversary can use to prevent ppivots from becoming cpivots, and we can complete the induction and conclude:</p>

    <p class="text-gray-300">LEMMA 4.8 (FORMAL VERSION: LEM. D.17). If honest nodes use the longest-header-chain scheduling policy, and in every interval of size at least  <span class="math">K_{\\mathrm{cp}}</span> , at least a certain fraction of BPOs are ppivots (which holds for  <span class="math">\\rho, \\lambda</span>  chosen as a function of the model and analysis parameters, as per eqn. (3)), then for all  <span class="math">m \\geq 0</span> , the interval  <span class="math">(mK_{\\mathrm{cp}}, (m + 1)K_{\\mathrm{cp}}]</span></p>

    <p class="text-gray-300">has at least one cpivot. It follows that any arbitrary interval of length <span class="math">2K_{\\mathrm{cp}}</span> contains at least one cpivot.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.3. Security of Proof-of-Work Nakamoto Consensus</h3>

    <p class="text-gray-300">From Lems. 4.6 and 4.8, we conclude that for suitable <span class="math">\\lambda</span>, with overwhelming probability, cpivots occur in every <span class="math">2K_{\\mathrm{cp}}</span>-interval. This allows us, together with Lem. 4.5 (cpivots stabilize), to prove safety and liveness of the protocol for a confirmation depth <span class="math">k_{\\mathrm{conf}}=\\Theta(K_{\\mathrm{cp}})</span>. The key arguments are in the proof of the following lemma.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 4.9.</h6>

    <p class="text-gray-300">If for some <span class="math">K_{\\mathrm{cp}}&gt;0</span>,</p>

    <p class="text-gray-300">(2) <span class="math">\\forall k:\\exists k^{<em>}\\in\\left(k,k+2K_{\\mathrm{cp}}\\right]:\\mathrm{CPivot}(k^{</em>}),</span></p>

    <p class="text-gray-300">then the PoW Nakamoto consensus protocol <span class="math">\\Pi^{\\rho,\\tau,k_{\\mathrm{conf}}}</span> with <span class="math">k_{\\mathrm{conf}}=2K_{\\mathrm{cp}}+1</span> satisfies safety. Further, if the environment is <span class="math">((\\frac{1}{2}-\\beta)\\rho,2K_{\\mathrm{cp}}/\\rho)</span>-tx-limited, then <span class="math">\\Pi^{\\rho,\\tau,k_{\\mathrm{conf}}}</span> also satisfies liveness with <span class="math">T_{\\mathrm{live}}=\\Theta(K_{\\mathrm{cp}})</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Safety: Denote the longest processed chain of node <span class="math">p</span> at slot <span class="math">t</span> as <span class="math">\\mathrm{d}C_{p}(t)</span> and its <span class="math">k_{\\mathrm{conf}}</span>-deep prefix as <span class="math">\\mathrm{d}C_{p}(t)^{\\lceil k_{\\mathrm{conf}}\\rceil}</span>. For an arbitrary slot <span class="math">t</span>, let <span class="math">k</span> be the largest index such that <span class="math">t_{k}\\leq t</span>. From Lem. 4.8, every interval of <span class="math">2K_{\\mathrm{cp}}</span> indices contains at least one cpivot. Therefore, there exists <span class="math">k^{<em>}\\in\\left(k-2K_{\\mathrm{cp}}-1,k-1\\right]</span> such that <span class="math">\\mathrm{CPivot}(k^{</em>})</span>. Let <span class="math">b^{<em>}</span> be the block from index <span class="math">k^{</em>}</span>. Due to Lem. 4.5, for all honest nodes <span class="math">p,q</span> and <span class="math">t^{\\prime}\\geq t</span>, <span class="math">b^{<em>}\\in\\mathrm{d}C_{p}(t)</span> and <span class="math">b^{</em>}\\in\\mathrm{d}C_{q}(t^{\\prime})</span>. But <span class="math">k^{<em>}\\geq k-k_{\\mathrm{conf}}</span>, so the block <span class="math">b^{</em>}</span> cannot be <span class="math">k_{\\mathrm{conf}}</span>-deep in any chain at slot <span class="math">t</span>. Therefore, <span class="math">\\mathrm{LOG}_{p}^{t}</span> is a prefix of <span class="math">b^{*}</span> which in turn is a prefix of <span class="math">\\mathrm{d}C_{q}(t^{\\prime})</span>. We can thus conclude that either <span class="math">\\mathrm{LOG}_{p}^{t}\\preceq\\mathrm{LOG}_{q}^{t^{\\prime}}</span> or <span class="math">\\mathrm{LOG}_{q}^{t^{\\prime}}\\preceq\\mathrm{LOG}_{p}^{t}</span>. Therefore, safety holds.</p>

    <p class="text-gray-300">Liveness (proof sketch, details in App. D.4): Recall that since indices count slots with block production, <span class="math">T</span> slots corresponds to roughly <span class="math">\\rho T</span> indices. Again let <span class="math">k</span> be the largest index such that <span class="math">t_{k}\\leq t</span>. We will first prove that all transactions received between indices <span class="math">k-2K_{\\mathrm{cp}}</span> and <span class="math">k</span>, which are of total size at most <span class="math">(1-2\\beta)K_{\\mathrm{cp}}</span> as per the tx-limited environment, will be added to the longest processed chains of all nodes by index <span class="math">k+2K_{\\mathrm{cp}}</span>. We know that there exists <span class="math">k^{<em>}\\in\\left(k,k+2K_{\\mathrm{cp}}\\right]</span> such that <span class="math">\\mathrm{CPivot}(k^{</em>})</span>. Since <span class="math">k^{*}</span> is a cpivot, there are more indices <span class="math">j</span> with <span class="math">D_{j}=1</span> than indices with <span class="math">D_{j}=0</span> in the interval <span class="math">\\left(k,k+2K_{\\mathrm{cp}}\\right]</span> (by Def. 4.3). Since each index with <span class="math">D_{j}=1</span> leads to chain growth, every honest node’s longest processed chain grows by at least <span class="math">K_{\\mathrm{cp}}</span> between indices <span class="math">k</span> and <span class="math">k+2K_{\\mathrm{cp}}</span>. There are at most <span class="math">\\beta\\cdot 2K_{\\mathrm{cp}}</span> adversary block productions in the interval <span class="math">\\left(k,k+2K_{\\mathrm{cp}}\\right]</span>, hence every honest node’s longest processed chain grows by at least <span class="math">K_{\\mathrm{cp}}-2\\beta K_{\\mathrm{cp}}</span> honest blocks. These honest blocks will include pending transactions, whose size is at most <span class="math">(1-2\\beta)K_{\\mathrm{cp}}</span>. Moreover, in the interval <span class="math">\\left(k+2K_{\\mathrm{cp}},k+2K_{\\mathrm{cp}}+2k_{\\mathrm{conf}}\\right]</span>, every honest node’s longest processed chain grows by at least <span class="math">k_{\\mathrm{conf}}</span>. Thus, the newly added transactions are <span class="math">k_{\\mathrm{conf}}</span>-deep, hence confirmed, by all nodes by index <span class="math">k+2K_{\\mathrm{cp}}+2k_{\\mathrm{conf}}</span>, which is a latency of <span class="math">T_{\\mathrm{live}}=\\frac{6K_{\\mathrm{cp}}+2}{\\rho}</span> slots. ∎</p>

    <p class="text-gray-300">Subsequently, we take <span class="math">\\tau\\to 0</span> and <span class="math">\\lambda\\triangleq\\rho/\\tau</span> in order to model PoW accurately. Finally, since <span class="math">\\widetilde{C},\\nu</span> were analysis parameters chosen arbitrarily, we maximize over these parameters to find the best possible security–performance tradeoff (Thm. 4.10). The result is plotted for <span class="math">\\Delta_{\\mathrm{h}}\\approx 0</span> (reasonable approximation for large block content relative to headers) in Fig. 1.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 4.10.</h6>

    <p class="text-gray-300">For all <span class="math">\\beta&lt;1/2</span>, <span class="math">\\lambda&gt;0</span>, such that</p>

    <p class="text-gray-300">(3) <span class="math">\\lambda&lt;\\max_{\\widetilde{C}}\\frac{1}{\\Delta_{\\mathrm{h}}+\\widetilde{C}/C}\\ln\\left(\\frac{2(1-\\beta)\\widetilde{C}}{\\widetilde{C}+4+\\sqrt{8\\widetilde{C}+16}}\\right),</span></p>

    <p class="text-gray-300">the PoW Nakamoto consensus protocol with the longest-header-chain scheduling policy, <span class="math">\\tau\\to 0</span>, <span class="math">\\rho=\\lambda\\tau</span>, and <span class="math">k_{\\mathrm{conf}}=\\Theta(\\kappa^{2})</span> is secure with transaction rate <span class="math">(\\frac{1}{2}-\\beta)\\lambda</span>, confirmation latency <span class="math">\\Theta(\\kappa^{2})</span> over a time horizon of <span class="math">T_{\\mathrm{hrzn}}=\\mathrm{poly}(\\kappa)</span>.</p>

    <p class="text-gray-300">Thm. 4.10 is proved in App. D.4.</p>

    <h2 id="sec-20" class="text-2xl font-bold">5. Proof-of-Stake Nakamoto Consensus</h2>

    <p class="text-gray-300">Nakamoto consensus has been adapted to proof-of-stake in protocols of the Ouroboros <em>(Oroboros, 2015; 2016; 35)</em> and Sleepy Consensus <em>(2016; 35)</em> families. The protocol is identical to what was described in Sec. 3 and formalized in Alg. 1, except for a few key differences. The block production oracle for proof-of-stake (idealized in Alg. 4) behaves differently. As in PoW, each node can make one block production attempt per slot that will be successful with probability <span class="math">\\rho/N</span>, independently of other nodes and slots, modeling uniform stake. In PoS, however, (even past) block production opportunities can be ‘reused’ to produce multiple blocks with different parents and/or content, i.e., to equivocate.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.1. Blanking Nakamoto Consensus (BlaNC)</h3>

    <p class="text-gray-300">In the classic bounded-delay analysis, the tradeoff between <span class="math">\\beta</span> and <span class="math">\\lambda</span> is the same for PoW and PoS NC <em>(2016; 30)</em>, because, conceptually, NC security depends only on a race between the honest chain and adversary chains. Even in PoS, the adversary cannot use equivocations to boost its chain growth rate, because blocks within one chain must be from strictly increasing slots, i.e., different BPOs. Under bounded capacity, however, as observed in <em>(48)</em>, honest nodes may waste their limited capacity processing equivocations rather than staying up-to-date with the longest chain. Thus, blocks they produce may not contribute to honest chain growth. As a result, the honest chain growth rate decreases, and with it PoS NC security <em>(48)</em> (compared to PoW). The key idea in BlaNC is to modify the scheduling policy of PoS NC such that per BPO at most one block is processed. This restores the one assumption of the bounded-capacity PoW NC analysis (Sec. 4.2.3 (P1)) that was previously violated in PoS NC due to equivocations. With the modification of BlaNC, the analysis from Sec. 4 carries over to PoS.</p>

    <p class="text-gray-300">One may consider this alternative: defer content processing until after consensus has been reached on a header chain. This, however, requires ensuring that the contents belonging to headers will be available for download. Sampling-based approaches <em>(3)</em> to check data availability come with various challenges <em>(47)</em> and VID-based approaches <em>(2017; 63)</em> do not scale to the large <span class="math">N</span> found in PoS NC.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">5.1.1. Protocol</h4>

    <p class="text-gray-300">BlaNC is PoS NC (cf. <em>(35; 52)</em>), with the following modifications.</p>

    <p class="text-gray-300">The Scheduling Policy in BlaNC. BlaNC uses any scheduling policy that is secure for PoW NC (such as longest-header-chain), modified as follows: a node does not process content for a header</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">(denoted by the corresponding header chain  <span class="math">C</span> ) if it has seen another equivocating header from the same BPO as  <span class="math">C</span> . Instead, the node pretends that content was "processed" and sets it to be empty. The node can then continue processing content for headers that extend  <span class="math">C</span> , and these blocks will be candidates for the node's longest processed chain. With only the above scheduling policy, one honest node may process the real content for a header while another may set it to be empty (depending on when each node saw an equivocating header). In order to output a consistent transaction ledger, reaching consensus on the header chain is no longer enough. Instead, we ensure that honest nodes also agree on which blocks had an equivocation, through equivocation proofs, so that they can consistently blank their contents.</p>

    <p class="text-gray-300">Equivocation Proofs. An equivocation proof consists of two headers  <span class="math">C, C&#x27;</span>  from the same BPO. Whenever a node produces a new block header extending its longest processed chain, it includes an equivocation proof for any header  <span class="math">C</span>  among the last  <span class="math">k_{\\mathrm{epf}}</span>  headers (on the new block's prefix) for which it has seen an equivocating header  <span class="math">C&#x27;</span>  but no equivocation proof was recorded on chain yet.</p>

    <p class="text-gray-300">Equivocation Proof Deadline. The deadline  <span class="math">k_{\\mathrm{epf}}</span>  for adding equivocation proofs ensures that the adversary cannot use equivocations or equivocation proofs to make honest nodes blank the content of an old block whose transactions they have already confirmed. A header  <span class="math">C</span>  is thus invalid if it contains an equivocation proof against a block that is not within  <span class="math">k_{\\mathrm{epf}}</span>  blocks above  <span class="math">C</span> .</p>

    <p class="text-gray-300">Ledger Construction in BlaNC. At the end of each slot, each node confirms all blocks on its longest processed chain that are  <span class="math">k_{\\mathrm{conf}}</span> -deep, except it blanks the contents of blocks against which there is an equivocation proof on chain.</p>

    <p class="text-gray-300">5.1.2 Security Proof. The scheduling policy of BlaNC ensures that, just like in PoW NC, honest nodes process at most one block per BPO. This eliminates additional block processing delays caused by equivocations, allowing the honest chain growth rate to match that of PoW NC. Given this, the security proof of PoW NC in Sec. 4 can be adapted to BlaNC to show that the  <span class="math">k_{\\mathrm{conf}}</span> -deep header chains of all nodes are consistent.</p>

    <p class="text-gray-300">To ensure that their ledgers are consistent, and complete the security proof, we need two more steps. First, liveness of BlaNC follows easily because the contents of blocks produced by honest nodes will never be blanked. Second, for safety, we show (a) honest nodes have processed the content for all blocks against which there is no equivocation proof on chain (these blocks must not be blanked), and (b) honest nodes blank content in their ledger consistently, that is, any honest node blanks the contents of a block in its ledger iff all honest nodes do so. We prove (a) and (b) in Thm. 5.1 by choosing appropriate values for  <span class="math">k_{\\mathrm{conf}}</span>  and  <span class="math">k_{\\mathrm{epf}}</span> .</p>

    <p class="text-gray-300">Since the analysis of PoW NC from Sec. 4 (details in App. D) applies to BlaNC as well, Lem. 4.5 (cpivots stabilize the longest processed chains of all nodes) and Lem. 4.8 (cpivots recur) hold for BlaNC. Thus, eqn. (3) also determines the parameters under which BlaNC is secure, i.e., the security-throughput tradeoff of BlaNC. <span class="math">^{8}</span>  In Fig. 3, we plot the solutions of eqn. (3) with  <span class="math">C = 1</span>  and  <span class="math">\\Delta_{\\mathrm{h}} \\approx 0</span></p>

    <p class="text-gray-300">!<a href="img-17.jpeg">img-17.jpeg</a> Figure 12: Illustration for the security proof of BlaNC (Thm. 5.1). Consider a block  <span class="math">b</span>  that is  <span class="math">k_{\\mathrm{conf}}</span> -deep in the longest processed chain of a node. Indices  <span class="math">j, k, l</span>  are cpivots. Since cpivots stabilize (Lem. 4.5), the corresponding blocks  <span class="math">b_j, b_k, b_l</span>  are in all honest nodes' processed longest chains. At cpivot  <span class="math">j</span> , we know for sure that all honest nodes either processed  <span class="math">b</span> 's content or saw an equivocation for it, because they have processed  <span class="math">b_j</span> 's content. At cpivot  <span class="math">k</span> , we know for sure that if  <span class="math">b</span>  had an equivocation, preventing processing of its content, then an equivocation proof against  <span class="math">b</span>  must have entered the chain. At cpivot  <span class="math">l</span> , we know for sure that the last block that can add an equivocation proof against  <span class="math">b</span>  has stabilized (as the deadline of  <span class="math">k_{\\mathrm{epf}}</span>  blocks has passed). Thus, a ledger formed from  <span class="math">k_{\\mathrm{conf}}</span> -deep blocks (sufficient to obtain three cpivots) will remain safe.</p>

    <p class="text-gray-300">(approximation for block content much larger than headers). Since eqn. (3) does not depend on  <span class="math">\\kappa</span> , for any given  <span class="math">\\beta</span> , the block rate  <span class="math">\\lambda</span>  is non-vanishing. Only latency scales with  <span class="math">\\kappa</span> , similar to PoW NC.</p>

    <p class="text-gray-300">In both Thm. 5.1 (for BlaNC) and Thm. 4.10 (for PoW NC), we prove an upper bound on the confirmation latency that scales with the security parameter  <span class="math">\\kappa</span>  as  <span class="math">O(\\kappa^2)</span> . Concretely, our bound on BlaNC's latency (Thm. 5.1) is  <span class="math">3\\times</span>  our bound for PoW NC (Lem. D.20).</p>

    <p class="text-gray-300">THEOREM 5.1. For all  <span class="math">\\beta &amp;lt; 1/2</span> ,  <span class="math">C</span> ,  <span class="math">\\Delta_{\\mathrm{h}}</span> ,  <span class="math">\\rho</span> ,  <span class="math">\\tau</span>  satisfying eqn. (3), there exists  <span class="math">k_{\\mathrm{epf}}</span> ,  <span class="math">k_{\\mathrm{conf}} = \\Theta(\\kappa^2)</span>  such that the BlaNC protocol is secure with transaction rate  <span class="math">(1 - 2\\beta)\\lambda</span> , confirmation latency  <span class="math">T_{\\mathrm{live}} = \\Theta(\\kappa^2)</span>  slots over a time horizon of  <span class="math">T_{\\mathrm{hrzn}} = \\mathrm{poly}(\\kappa)</span> .</p>

    <p class="text-gray-300">Proof. Set  <span class="math">k_{\\mathrm{conf}} \\triangleq 6K_{\\mathrm{cp}} + 1</span> ,  <span class="math">k_{\\mathrm{epf}} \\triangleq 4K_{\\mathrm{cp}}</span> . Denote the longest processed chain of node  <span class="math">p</span>  at slot  <span class="math">t</span>  as  <span class="math">\\mathrm{d}C_p(t)</span>  and its  <span class="math">k_{\\mathrm{conf}}</span> -deep prefix as  <span class="math">\\mathrm{d}C_p(t)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span> . Safety holds if the following three properties hold for all slots  <span class="math">t \\leq t&#x27;</span>  and for all honest nodes  <span class="math">p, q</span> : (1)  <span class="math">\\mathrm{d}C_p(t)^{\\lceil k_{\\mathrm{conf}} \\rceil} \\preceq \\mathrm{d}C_q(t&#x27;)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span>  or  <span class="math">\\mathrm{d}C_q(t&#x27;)^{\\lceil k_{\\mathrm{conf}} \\rceil} \\preceq \\mathrm{d}C_p(t)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span> . (2) If  <span class="math">b \\in \\mathrm{d}C_p(t)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span>  and there is no equivocation proof in a block header following it, then node  <span class="math">p</span>  must have processed the content of  <span class="math">b</span>  before slot  <span class="math">t</span> . (3) If  <span class="math">b \\in \\mathrm{d}C_p(t)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span>  and  <span class="math">b \\in \\mathrm{d}C_q(t&#x27;)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span> , then  <span class="math">p</span>  blanks the content of  <span class="math">b</span>  in  <span class="math">\\mathrm{LOG}_p^t</span>  iff  <span class="math">q</span>  blanks it in  <span class="math">\\mathrm{LOG}_q^{t&#x27;}</span> .</p>

    <p class="text-gray-300">Consider an arbitrary block  <span class="math">b_{i}</span>  (produced at some index  <span class="math">i</span> ) that is confirmed by an honest node  <span class="math">p</span>  at slot  <span class="math">t</span> , i.e.,  <span class="math">b_{i} \\in \\mathrm{d}C_{p}(t)^{\\lceil k_{\\mathrm{conf}} \\rceil}</span> . Since  <span class="math">b_{i}</span>  is  <span class="math">k_{\\mathrm{conf}}</span> -deep, there must have been at least  <span class="math">6K_{\\mathrm{cp}} + 1</span>  indices after  <span class="math">i</span> . Due to Lem. 4.8, there must have been at least three cpivots  <span class="math">j, k, l</span>  after index  <span class="math">i</span> . Due to Lem. 4.5, the blocks produced at these indices,  <span class="math">b_{j}, b_{k}, b_{l}</span>  are in  <span class="math">\\mathrm{d}C_{q}(t&#x27;)</span>  for all  <span class="math">t&#x27; \\geq t</span>  and for all  <span class="math">q</span>  (see Fig. 12). Therefore,  <span class="math">\\mathrm{d}C_{p}(t)^{\\lceil k_{\\mathrm{conf}} \\rceil} \\preceq \\mathrm{d}C_{q}(t&#x27;)</span> , and from this, we can prove (1).</p>

    <p class="text-gray-300">To prove (2), suppose that node  <span class="math">p</span>  did not process the content of block  <span class="math">b_{i}</span> . Since block  <span class="math">b_{j}</span> , and hence also  <span class="math">b_{i}</span> , is in every honest node's</p>

    <p class="text-gray-300">longest processed chain at slot <span class="math">t_{k+1}-1</span> (Lem. 4.5), it must have been that <span class="math">p</span> saw an equivocation for <span class="math">b_{i}</span> before slot <span class="math">t_{k+1}-1</span> (otherwise it must have actually processed the content of <span class="math">b_{i}</span>). Due to synchrony, all honest nodes see the headers of <span class="math">b_{i}</span> and its equivocation. Since the block <span class="math">b_{k}</span> is produced by an honest node, and <span class="math">k&lt;i+4K_{\\mathrm{cp}}\\times i+k_{\\mathrm{epf}}</span>, <span class="math">b_{k}</span> must contain an equivocation proof against <span class="math">b_{i}</span> (see Fig. 12).</p>

    <p class="text-gray-300">To prove (3), we show that while confirming the block <span class="math">b_{i}</span>, either all nodes see an equivocation proof against <span class="math">b_{i}</span> or none of them do. The latest that an equivocation proof against <span class="math">b_{i}</span> can be included is <span class="math">k_{\\mathrm{epf}}</span> blocks below <span class="math">b_{i}</span>. Since <span class="math">k_{\\mathrm{conf}}&gt;k_{\\mathrm{epf}}+2K_{\\mathrm{cp}}</span>, due to Lem. 4.8, the cpivot <span class="math">I</span> must have occurred after <span class="math">b_{i}</span> became <span class="math">k_{\\mathrm{epf}}</span>-deep and before it became <span class="math">k_{\\mathrm{conf}}</span>-deep (see Fig. 12). Thus, for all <span class="math">p</span> and <span class="math">t</span>, if <span class="math">b_{i}\\in\\mathrm{d}\\mathcal{C}_{p}(t)^{\\lceil k_{\\mathrm{conf}}\\rceil}</span>, then <span class="math">b_{I}\\in\\mathrm{d}\\mathcal{C}_{p}(t)</span>, hence all nodes agree on whether or not an equivocation proof was included.</p>

    <p class="text-gray-300">Liveness follows similarly to PoW NC: Within <span class="math">2K_{\\mathrm{cp}}</span> indices, there are enough honestly produced blocks to include new transactions, and their contents will never be blanked. In <span class="math">\\Theta(K_{\\mathrm{cp}})</span> slots, these blocks will become <span class="math">k_{\\mathrm{conf}}</span>-deep and will be confirmed. ∎</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.2. Handling Loss of Predictable Validity</h3>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">5.2.1. Predictable Transaction Validity</h4>

    <p class="text-gray-300">In UTXO-based chains like Bitcoin (account-based like Ethereum), a transaction is valid iff its inputs are unspent (its execution succeeds and fees are paid).</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 5.2.</h6>

    <p class="text-gray-300">A transaction has predictable validity iff: validity at the time an honest node adds it to a block implies validity when that block gets executed.</p>

    <p class="text-gray-300">The blanking in BlaNC leads to a loss of predictable transaction validity. An honest block <span class="math">B</span> may include a transaction that depends on the contents of a previous block <span class="math">A</span> whose equivocations were not known at the time. After block <span class="math">B</span> is produced, the adversary could release an equivocation for the block <span class="math">A</span>, forcing honest nodes to blank block <span class="math">A</span>’s contents, which may invalidate the transaction in block <span class="math">B</span>. Such invalidated transactions take up free space in honest blocks and lower the effective throughput (valid confirmed transactions) of the ledger.</p>

    <p class="text-gray-300">We propose a simple solution to recover predictable validity for BlaNC: If nodes limit transactions they include in a block to those that don’t depend on any recently changed state, then they can be sure that all equivocations that could affect the validity of a transaction already have a corresponding equivocation proof included on chain. This is because at the time of creating a block, honest nodes have seen all transactions which will be executed, however, not all transactions nodes have seen will be executed. The following lemma follows easily.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 5.3.</h6>

    <p class="text-gray-300">If a node produces a block whose transactions do not share state with any transaction included in the last <span class="math">k_{\\mathrm{epf}}</span> blocks, then the block satisfies Def. 5.2.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">5.2.2. Predictable Fee Validity</h4>

    <p class="text-gray-300">In practice, in popular DeFi-ecosystems, which consist of very interdependent transactions <em>(16; 32)</em>, it may not always be practical to limit the interaction between transactions. We propose instead preserving the minimum requirement that each transaction pays its fee, regardless of the outcome of its execution. This guarantees that miners are compensated for space used in their blocks, and also makes it costly for the adversary to take up space with invalid transactions.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 5.4.</h6>

    <p class="text-gray-300">A transaction has predictable fees iff: ability to pay fees when an honest node adds it to a block implies ability to pay fees when the block executes.</p>

    <p class="text-gray-300">In systems like Ethereum, transactions have a max gas value set by the sender which limits the computation allowed by the transaction and ultimately its fee. We consider a protocol with this gas mechanism, as well as a base transaction cost that covers the block space taken up by the transaction. We introduce a notion of gas deposit accounts to BlaNC that can only be used for transaction fees (transactions internally do not have access to these accounts). When a miner includes a transaction, it checks that the account funding the transaction has enough funds to cover the maximum gas, even if all transactions in its recent ancestor blocks make it to the blanked ledger and consume their maximum gas. Users thus need to maintain a balance proportional to the complexity and frequency of the transactions they make. We also require that any deposit to the account is not considered in the balance until <span class="math">k_{\\mathrm{epf}}</span> blocks after the deposit transaction. Withdrawals can take place immediately, as direct transactions.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 5.5.</h6>

    <p class="text-gray-300">If a node produces a block whose transactions are funded by gas deposit accounts with sufficient balance (balance before <span class="math">k_{\\mathrm{epf}}</span> blocks minus any fees since), then all transactions in the block satisfy Def. 5.4.</p>

    <p class="text-gray-300">The solutions in Secs. 5.2.1 and 5.2.2 are complementary and could each be adopted as per-validator heuristics (<span class="math">i.e.</span> not a consensus rule), or by the system based on the use-case (e.g., expected inter-dependency of transactions).</p>

    <h2 id="sec-30" class="text-2xl font-bold">6. Discussion</h2>

    <p class="text-gray-300">Tightening the Analysis. Our teasing strategy and security analysis (cf. Fig. 1) serve as the first lower and upper bounds on nodes’ minimum capacity required to ensure security in the bounded-capacity PoW setting. A question remains on how to tighten the gap. One avenue for future work is whether the adversary has better strategies than the teasing strategy, which we believe may be optimal in the bounded-capacity model.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Conjecture 6.1.</h6>

    <p class="text-gray-300">For the PoW NC protocol with the longest-header-chain scheduling policy, for all <span class="math">\\beta&lt;1/2,\\lambda</span> for which the teasing strategy is unsuccessful, the protocol is secure (against all attacks).</p>

    <p class="text-gray-300">Conversely, we expect that the security analysis can be improved in multiple ways. The current analysis uses only a few basic properties (P1), (P2), (P3) of the scheduling policy. As a result, we assume that any valid block can be used by the adversary to spam honest nodes. However, when using the longest-header-chain policy, the adversary can only force honest nodes to process blocks that are on their longest header chain, which is already hard for the adversary given that the honest chain has been growing so far. An improved analysis should account not just for the number of block productions in the adversary’s budget but also their blocktree structure. Further, good slots are sufficient but not necessary for chain growth. Improved analysis of the chain growth rate using techniques such as blocktree partitioning <em>(24)</em> can further tighten the analysis.</p>

    <p class="text-gray-300">Variable Difficulty. In practice, PoW blockchains implement a difficulty adjustment algorithm (DAA) to maintain the target block rate</p>

    <p class="text-gray-300">as players join and leave the system. This introduces new avenues for attack <em>(7)</em>. The variable difficulty protocol has so far been proven secure only in the lock-step synchronous model (<em>i.e.</em>, messages delivered in exactly one round) <em>(29)</em>. Security in the bounded-delay and bounded-capacity models remains an open problem. We note, however, that the DAA seems to apply even more stress to limited capacity nodes, as it would lower the difficulty to compensate for chain growth rate lost due to congestion, leading to an increase in the overall block rate of the system. In turn, this would increase congestion, in particular if honestly produced orphaned blocks are processed by honest parties, leading to a vicious cycle. Under the longest-header-chain scheduling policy that we consider in this work, honest nodes do not prioritize processing orphaned blocks, but this appears to be the case for scheduling policies that allow for processing multiple blocks in parallel. The nuance in this analysis is left for future work.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Acknowledgment</h2>

    <p class="text-gray-300">We thank Lei Yang, Mohammad Alizadeh, Sundararajan Renganathan, David Mazières, Ertem Nusret Tas, Ghassan Karame, Florian Tschorsch, and George Danezis for fruitful discussions. The work of LK, JN, and AZ was conducted in part during Dagstuhl Seminar #22421. LK is supported by the armasuisse Science and Technology CYD Distinguished Postdoctoral Fellowship. JN is supported by the Protocol Labs PhD Fellowship. JN and SS are supported by a gift from the Ethereum Foundation and by a research hub funded by Input Output Global Inc. SS is suported by NSF grant CCF-1563098. AZ is supported by grant #1443/21 from the Israel Science Foundation.</p>

    <h2 id="sec-33" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] [n. d.]. <em>Block size limit controversy</em>. https://en.bitcoin.it/wiki/Block_size_limit_controversy</li>

      <li>[2] Mustafa Al-Bassam. 2019. LazyLedger: A Distributed Data Availability Ledger With Client-Side Smart Contracts. arXiv:1905.09274v4 [cs.CR]</li>

      <li>[3] Mustafa Al-Bassam, Alberto Sonnino, Vitalik Buterin, and Ismail Khoffi. 2021. Fraud and Data Availability Proofs: Detecting Invalid Blocks in Light Clients. In <em>Financial Cryptography (2) (LNCS, Vol. 12675)</em>. Springer, 279–298.</li>

      <li>[4] Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas. 2018. Ouroboros Genesis: Composable Proof-of-Stake Blockchains with Dynamic Availability. In <em>CCS</em>. ACM, 913–930.</li>

      <li>[5] Vivek Bagaria, Amir Dembo, Sreeram Kannan, Sewoong Oh, David Tse, Pramod Viswanath, Xuechao Wang, and Ofer Zeitouni. 2019. Proof-of-Stake Longest Chain Protocols: Security vs Predictability. arXiv:1910.02218v3 [cs.CR]</li>

      <li>[6] Vivek Kumar Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath. 2019. Prism: Deconstructing the Blockchain to Approach Physical Limits. In <em>CCS</em>. ACM, 585–602.</li>

      <li>[7] Lear Bahack. 2013. Theoretical Bitcoin Attacks with less than Half of the Computational Power (draft). arXiv:1312.7013v1 [cs.CR]</li>

      <li>[8] Bitcoin Project. [n. d.]. <em>Running A Full Node — Bitcoin</em>. https://bitcoin.org/en/full-node#minimum-requirements</li>

      <li>[9] Bitcoin Project. 2020. <em>Bitcoin Developer Guide – P2P Network – Initial Block Download – Headers-First</em>. https://web.archive.org/web/20230314181737/https://developer.bitcoin.org/devguide/p2p_network.html#headers-first</li>

      <li>[10] Erica Blum, Aggelos Kiayias, Cristopher Moore, Saad Quader, and Alexander Russell. 2020. The Combinatorics of the Longest-Chain Rule: Linear Consistency for Proof-of-Stake Blockchains. In <em>SODA</em>. SIAM, 1135–1154.</li>

      <li>[11] Vitalik Buterin. [n. d.]. <em>Proof of Stake: How I Learned to Love Weak Subjectivity</em>. https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity</li>

      <li>[12] Vitalik Buterin and Virgil Griffith. 2017. Casper the Friendly Finality Gadget. arXiv:1710.09437v4 [cs.CR]</li>

      <li>[13] Christian Cachin and Stefano Tessaro. 2005. Asynchronous Verifiable Information Dispersal. In <em>DISC (LNCS, Vol. 3724)</em>. Springer, 503–504.</li>

      <li>[14] Clément Canonne. [n. d.]. <em>A short note on Poisson tail bounds</em>. https://github.com/ccanonne/probabilitydistributiontoolbox/blob/master/poissonconcentration.pdf</li>

      <li>[15] Tong Cao, Jérémie Decouchant, and Jiangshan Yu. 2023. Leveraging the Verifier’s Dilemma to Double Spend in Bitcoin. In <em>FC (LNCS, Vol. 13951)</em>. Springer, 149–165.</li>

      <li>[16] Ting Chen, Zihao Li, Yuxiao Zhu, Jiachi Chen, Xiapu Luo, John Chi-Shing Lui, Xiaodong Lin, and Xiaosong Zhang. 2020. Understanding Ethereum via Graph Analysis. <em>ACM Trans. Internet Techn.</em> 20, 2 (2020), 18:1–18:32.</li>

      <li>[17] Shir Cohen, Guy Goren, Lefferis Kokoris-Kiayias, Alberto Sonnino, and Alexander Spiegelman. 2023. Proof of Availability and Retrieval in a Modular Blockchain Architecture. In <em>FC (LNCS, Vol. 13951)</em>. Springer, 36–53.</li>

      <li>[18] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed E. Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gün Sirer, Dawn Song, and Roger Wattenhofer. 2016. On Scaling Decentralized Blockchains - (A Position Paper). In <em>Financial Cryptography Workshops (LNCS, Vol. 9604)</em>. Springer, 106–125.</li>

      <li>[19] Phil Daian, Rafael Pass, and Elaine Shi. 2019. Snow White: Robustly Reconfigurable Consensus and Applications to Provably Secure Proof of Stake. In <em>Financial Cryptography (LNCS, Vol. 11598)</em>. Springer, 23–41.</li>

      <li>[20] George Danezis, Lefferis Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegelman. 2022. Narwhal and Tusk: a DAG-based mempool and efficient BFT consensus. In <em>EuroSys</em>. ACM, 34–50.</li>

      <li>[21] Sourav Das, Nitin Awathare, Ling Ren, Vinay J. Ribeiro, and Umesh Bellur. 2021. Tuxedo: Maximizing Smart Contract Computation in PoW Blockchains. <em>Proc. ACM Meas. Anal. Comput. Syst.</em> 5, 3 (2021), 41:1–41:30.</li>

      <li>[22] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2018. Ouroboros Praos: An Adaptively-Secure, Semi-synchronous Proof-of-Stake Blockchain. In <em>EUROCRYPT (2) (LNCS, Vol. 10821)</em>. Springer, 66–98.</li>

      <li>[23] Christian Decker and Roger Wattenhofer. 2013. Information propagation in the Bitcoin network. In <em>P2P</em>. IEEE, 1–10.</li>

      <li>[24] Amir Dembo, Sreeram Kannan, Ertem Nusret Tas, David Tse, Pramod Viswanath, Xuechao Wang, and Ofer Zeitouni. 2020. Everything is a Race and Nakamoto Always Wins. In <em>CCS</em>. ACM, 859–878.</li>

      <li>[25] Thomas D. Dickerson, Paul Gazzillo, Maurice Herliby, and Eric Koskinen. 2020. Adding concurrency to smart contracts. <em>Distributed Comput.</em> 33, 3-4 (2020), 209–225.</li>

      <li>[26] John Duchi. [n. d.]. <em>Hoeffding’s inequality</em>. http://cs229.stanford.edu/extra-notes/hoeffding.pdf</li>

      <li>[27] Matthias Fitzi, Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2020. Proof-of-Stake Blockchain Protocols with Near-Optimal Throughput. Cryptology ePrint Archive, Paper 2020/037. https://eprint.iacz.org/2020/037</li>

      <li>[28] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The Bitcoin Backbone Protocol: Analysis and Applications. In <em>EUROCRYPT (2) (LNCS, Vol. 9057)</em>. Springer, 281–310.</li>

      <li>[29] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. 2017. The Bitcoin Backbone Protocol with Chains of Variable Difficulty. In <em>CRYPTO (1) (LNCS, Vol. 10401)</em>. Springer, 291–323.</li>

      <li>[30] Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2020. Tight Consistency Bounds for Bitcoin. In <em>CCS</em>. ACM, 819–838.</li>

      <li>[31] Arthur Gervais, Ghassan O. Karame, Karl Wiist, Vasileios Glykantzis, Hubert Ritzdorf, and Srdjan Capkun. 2016. On the Security and Performance of Proof of Work Blockchains. In <em>CCS</em>. ACM, 3–16.</li>

      <li>[32] Dongchao Guo, Jiaqing Dong, and Kai Wang. 2019. Graph structure and statistical properties of Ethereum transaction relationships. <em>Inf. Sci.</em> 492 (2019), 58–71.</li>

      <li>[33] James Hendricks, Gregory R. Ganger, and Michael K. Reiter. 2007. Verifying distributed erasure-coded data. In <em>PODC</em>. ACM, 139–146.</li>

      <li>[34] Wassily Hoeffding. 1963. Probability Inequalities for Sums of Bounded Random Variables. <em>J. Amer. Statist. Assoc.</em> 58, 301 (1963), 13–30. https://doi.org/10.1080/01621459.1963.10500830</li>

      <li>[35] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017. Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol. In <em>CRYPTO (1) (LNCS, Vol. 10401)</em>. Springer, 357–388.</li>

      <li>[36] Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse. 2023. Nakamoto Consensus under Bounded Processing Capacity. Cryptology ePrint Archive, Paper 2023/381. https://eprint.iacz.org/2023/381</li>

      <li>[37] Lucianna Kiffer, Rajmohan Rajaraman, and Abhi Shelat. 2018. A Better Method to Analyze Blockchain Consistency. In <em>CCS</em>. ACM, 729–744.</li>

      <li>[38] Lucianna Kiffer, Asad Salman, Dave Levin, Alan Mislove, and Cristina Nita-Rotaru. 2021. Under the Hood of the Ethereum Gossip Protocol. In <em>Financial Cryptography (2) (LNCS, Vol. 12675)</em>. Springer, 437–456.</li>

      <li>[39] Andreas Lenz. [n. d.]. <em>Random walk with positive drtft</em>. https://math.stackexchange.com/q/4449213</li>

      <li>[40] Jing Li, Dongning Guo, and Ling Ren. 2021. Close latency-security trade-off for the Nakamoto consensus. In <em>AFT</em>. ACM, 100–113.</li>

      <li>[41] Zhichun Lu and Ren Zhang. 2023. When is Slower Block Propagation More Profitable for Large Miners?. In <em>ESORICS (3) (LNCS, Vol. 14346)</em>. Springer, 285–305.</li>

      <li>[42] Loi Luu, Jason Teutsch, Raghav Kulkarni, and Prateek Saxena. 2015. Demystifying Incentives in the Consensus Computer. In <em>CCS</em>. ACM, 706–719.</li>

      <li>[43] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. 2016. The Honey Badger of BFT Protocols. In <em>CCS</em>. ACM, 31–42.</li>

    </ul>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">[44] Michael Mirkin, Yan Ji, Jonathan Pang, Ariah Klages-Mundt, Ittay Eyal, and Ari Juels. 2020. BDoS: Blockchain Denial-of-Service. In CCS. ACM, 601–619. [45] Satoshi Nakamoto. 2008. Bitcoin: A Peer-to-Peer Electronic Cash System. https://bitcoin.org/bitcoin.pdf. [46] Kamilla Nazirkhanova, Joachim Neu, and David Tse. 2022. Information Dispersal with Provable Retrievability for Rollups. In AFT. ACM, 180-197. [47] Joachim Neu. 2022. Data Availability Sampling: From Basics to Open Problems. https://www.paradigm.xyz/2022/08/das [48] Joachim Neu, Srivatsan Sridhar, Lei Yang, David Tse, and Mohammad Alizadeh. 2022. Longest Chain Consensus Under Bandwidth Constraint. In AFT. ACM, 126-147. [49] Joachim Neu, Ertem Nusret Tas, and David Tse. 2022. The Availability-Accountability Dilemma and Its Resolution via Accountability Gadgets. In Financial Cryptography (LNCS, Vol. 13411). Springer, 541-559. [50] Rafael Pass, Lior Seeman, and Abhi Shelat. 2017. Analysis of the Blockchain Protocol in Asynchronous Networks. In EUROCRYPT (2) (LNCS, Vol. 10211). 643-673. [51] Rafael Pass and Elaine Shi. 2016. The Sleepy Model of Consensus. Cryptology ePrint Archive, Paper 2016/918. https://eprint.iacr.org/2016/918 [52] Rafael Pass and Elaine Shi. 2017. The Sleepy Model of Consensus. In ASIACRPT (2) (LNCS, Vol. 10625). Springer, 380-409. [53] Daniel Perez and Benjamin Livshits. 2020. Broken Metre: Attacking Resource Metering in EVM. In NDSS. The Internet Society. [54] Jamie Redman. [n.d.]. Running Bitcoin Cash: An Introduction to Operating a Full Node. https://news.bitcoin.com/running-bitcoin-cash-an-introduction-to-operating-a-full-node/ [55] Ling Ren. 2019. Analysis of Nakamoto Consensus. Cryptology ePrint Archive, Paper 2019/943. https://eprint.iacr.org/2019/943 [56] Muhammad Saad, Afsah Anwar, Srivatsan Ravi, and David Mohaisen. 2024. Revisiting Nakamoto Consensus in Asynchronous Networks: A Comprehensive Analysis of Bitcoin Safety and Chain Quality. IEEE/ACM Trans. Netw. 32, 1 (2024), 844-858. [57] Suryanarayana Sankagiri, Shreyas Gandlur, and Bruce Hajek. 2023. The Longest-Chain Protocol Under Random Delays. Stochastic Systems (2023), 13(4):457-458. [58] Vikram Saraph and Maurice Herlihy. 2019. An Empirical Study of Speculative Concurrency in Ethereum Smart Contracts. In <em>Tokenomics (OASics, Vol. 71)</em>. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 4:1-4:15. [59] Peiyao Sheng, Gerui Wang, Kartik Nayak, Sreeram Kannan, and Pramod Viswanath. 2021. BFT Protocol Forensics. In CCS. ACM, 1722-1743. [60] Yonatan Sompolinsky and Aviv Zohar. 2016. Bitcoin's Security Model Revisited. arXiv:1605.09193v2 [cs.CR] [61] Alexander Spiegelman, Neil Giridharan, Alberto Sonnino, and Lefteris Kokoris-Kogias. 2022. Bullshark: DAG BFT Protocols Made Practical. In CCS. ACM, 2705-2718. [62] Shichen Wu, Puwen Wei, Ren Zhang, and Bowen Jiang. 2023. Security-Performance Tradeoff in DAG-based Proof-of-Work Blockchain Protocols. Cryptology ePrint Archive, Paper 2023/1089. https://eprint.iacr.org/2023/1089 [63] Lei Yang, Seo Jin Park, Mohammad Alizadeh, Sreeram Kannan, and David Tse. 2022. DispersedLedger: High-Throughput Byzantine Consensus on Variable Bandwidth Networks. In NSDI. USENIX Association, 493-512.</p>

    <p class="text-gray-300">Nodes in our simulation generate blocks in a Poisson process with rate proportional to their mining power. We assume the mining difficulty is fixed, and do not include any adjustment by a difficulty adjustment algorithm. In fact, difficulty adjustment algorithms tend to worsen processing problems as they increase the block creation rate if the chain does not grow fast enough—which in turn requires more processing from nodes.</p>

    <p class="text-gray-300">Nodes process blocks one at a time according to the priority dictated by the processing policy, at a rate determined by their capacity. They are allowed to preempt their current task if new information (headers that are published, blocks that they mined) presents them with a higher priority target. Since queues can grow large if nodes do not manage to process all blocks in a timely manner, we maintain priority queues of bounded size (typically 100) and evict low priority tasks from the queue as needed. As preemption of</p>

    <p class="text-gray-300">tasks may cause nodes to alternate between tasks, we allow nodes to retain partial work in an LRU cache of size 10.</p>

    <p class="text-gray-300">Except where we note otherwise, headers are assumed to propagate instantly in the simulations. To simulate an idealized bounded-delay network, where needed, we set the header propagation delay to  <span class="math">\\Delta</span>  and the capacity of each node to be  <span class="math">\\infty</span> . Block headers contain the relevant lottery information which can be easily validated. We therefore assume the adversary never publishes headers it did not actually mine.</p>

    <p class="text-gray-300">To remain close to the theoretical analysis, we model all processing tasks as dependent only on the resources available to the node itself. In reality, things are much more complex: nodes typically propagate blocks in a peer-to-peer network, which means both the overlay network topology and the underlying internet topology both greatly impact block download rates and performance. Our simplified setting allows us to focus more on the congestion effects in isolation from the effects of topology and other peer-to-peer related issues.</p>

    <p class="text-gray-300">The teasing strategy relied on the fact that the adversary could entice nodes with a long header chain that is later discovered to be unavailable for processing. It is natural in this case to consider adjusting the scheduling policy to one that prefers the proverbial 'bird in the hand over two birds in the bush', i.e., to extend the blocks we already processed over the illusive promise of a longer chain that the adversary may withhold from us.</p>

    <p class="text-gray-300">Greedy policy. This policy prioritizes processing blocks that extend the chain a node has already processed. If a header of a block at height  <span class="math">h</span>  is announced, and we already have  <span class="math">h_i</span>  blocks from that chain, we set the priority of the block to be  <span class="math">(h_i, h)</span>  and compare between the two priorities lexicographically.</p>

    <p class="text-gray-300">While the greedy policy performs well at high processing rates, we unfortunately find that it performs poorly in the low processing rate regime. Specifically, if a fork in the chain occurs, and nodes are split evenly between the two alternatives, the fork may never resolve. This is because nodes extend their own chain, and prioritize processing on their side of the split while having insufficient processing power to catch up with the other alternative chain. A fork in the chain can result from a deliberate attack by an adversary that releases blocks selectively to different nodes, by a network split, or worse, by an unlucky timing of honest node mining events. In this case, the blockchain fails even for small adversaries. Importantly, a fork that never resolves is either a safety or a liveness failure, as no transaction on either side of the split can be safely accepted.</p>

    <p class="text-gray-300">To demonstrate this scheduling policy in action, we simulate a network of 100 nodes that are split evenly between two partitions for only 15 seconds, i.e., for an expected time required to produce 15 blocks. Once the network split ends, the simulation continues for another 4000 seconds, allowing nodes the opportunity to converge on a chain. We measure the height of the latest block all nodes agree upon. If nodes do not recover from the partition, this block will be</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">!<a href="img-18.jpeg">img-18.jpeg</a> Figure 13: The rate nodes grow the agreed chain after the network splits into two sets of 50 nodes for 15 secs, when the scheduling policy is "longest-header-chain"  <span class="math">(\\cdot)</span>  or "greedy"  <span class="math">(\\cdots \\rightarrow \\cdots)</span> . Nodes using the greedy policy prioritize processes on their current chain. Under low capacity, they do not recover from the split, resulting in two chains forking at genesis, providing no growth of the agreed chain. Thus, longest chain is insecure without an adversary (cf. Fig. 1(c)).</p>

    <p class="text-gray-300">!<a href="img-19.jpeg">img-19.jpeg</a> Figure 14: Results of a simulation of the Equiv-teasing attack comparing the rate of chain growth relative to honest block production rate, when nodes prioritize processing towards the longest header chain, for various capacity limits. The honest chain growth rate falls to almost zero as the adversary spams honest nodes with longer chains. The teasing strategy is shown for comparison.</p>

    <p class="text-gray-300">the genesis and the liveness of the protocol has failed. Otherwise, nodes quickly agree on the main chain and the height of the latest agreed block is just a little behind the longest tip of the chain.</p>

    <p class="text-gray-300">We simulate the evolution after a brief partition for both the longest-header-chain policy as well as for the greedy policy. Our results (Fig. 13) show that in settings where capacity is greater than  <span class="math">1/2</span> , nodes manage to catch up with the chain and the rate of growth matches for both scheduling policies. In lower capacity settings, however, nodes never catch up. Note that this attack requires no adversary mining, yet the protocol is insecure (cf. Fig. 1(c)). This is in stark contrast to the bounded-delay analysis which suggests that the protocol retains security against a non-mining adversary at any capacity (cf. Fig. 1(a)), and highlights again the need to study the security of blockchains at capacity.</p>

    <p class="text-gray-300">In PoS, the adversary can greatly increase the network's processing load using equivocations. The equiv-teasing attack, described in Fig. 15, uses equivocations to announce a whole new chain at every</p>

    <p class="text-gray-300">!<a href="img-20.jpeg">img-20.jpeg</a> Figure 15: Equiv-teasing attack: Steps (a)-(e) are the same as in the teasing strategy (Fig. 6). Recall that in (c), to delay the processing of the honest block at height  <span class="math">h = 3</span> , the adversary announces a block at height  <span class="math">h + 1</span>  which it was withholding. Since this is the longest announced chain, honest nodes prioritize processing block 2 on this chain. New steps: (f) Once an honest node produces a block at height 4, the adversary announces equivocations  <span class="math">1&#x27;, 2&#x27;, \\ldots</span>  of its withheld chain of length 5 instead of announcing one new block extending the chain 1, 2, ... Therefore, honest nodes have to process blocks  <span class="math">1&#x27;, 2&#x27;</span>  even though they processed 1, 2 earlier. The adversary makes content available for only  <span class="math">1&#x27;, 2&#x27;, 3&#x27;</span> . As the attack goes on, the adversary's announced chain gets longer, and it consumes even more of the honest node's processing capacity.</p>

    <p class="text-gray-300">!<a href="img-21.jpeg">img-21.jpeg</a></p>

    <p class="text-gray-300">instance when the teasing strategy would have announced a single new block. As the attack goes on, the length of the new announced chain increases. This increases the time honest nodes spend processing this chain, and decelerates the honest chain growth until it comes to a halt. As a result, in Fig. 14, the chain growth rate under the equiv-teasing attack is nearly zero.</p>

    <p class="text-gray-300">As in the teasing strategy, the adversary starts by producing a private chain. Assuming the adversary's block production rate  <span class="math">\\lambda_{\\mathrm{adv}}</span>  is less than the honest chain growth rate before the attack ( <span class="math">\\lambda_{\\mathrm{grwth}}^{\\mathrm{priv}}</span> ), the probability that the adversary produces a chain of length  <span class="math">k</span>  before the honest chain reaches length  <span class="math">k</span>  is  <span class="math">e^{-O(k)}</span>  [24, 45]. This means that with probability  <span class="math">\\epsilon</span> , the adversary eventually produces a private chain of length  <span class="math">k = O(\\log(1/\\epsilon))</span> , of which it can announce equivocations during the attack. Since this chain is longer than the honest chain, it has higher scheduling priority. It takes honest nodes  <span class="math">k/C</span>  time to process such a chain, during which time, honest nodes do not process blocks on the honest chain. So, any honest blocks produced within  <span class="math">k/C</span>  time after the first honest block at height  <span class="math">h</span>  do not grow the honest chain (Fig. 6(e)). If  <span class="math">\\lambda_{\\mathrm{hon}} k/C</span>  is large, then there are many honest blocks that do not lead to chain growth, causing the chain growth rate  <span class="math">\\lambda_{\\mathrm{grwth}}</span>  to drop (Fig. 14). As in the teasing strategy, if the adversary's block production rate  <span class="math">\\lambda_{\\mathrm{adv}}</span>  exceeds  <span class="math">\\lambda_{\\mathrm{grwth}}</span> , then the adversary succeeds in maintaining the number of block productions required for the attack to go on forever. This eventually slows honest chain growth to a halt. Thus, if  <span class="math">\\lambda_{\\mathrm{hon}} k/C</span>  is large, i.e.,  <span class="math">\\lambda_{\\mathrm{hon}} = \\Omega(1/k) = \\Omega\\left(\\frac{1}{\\log(1/\\epsilon)}\\right)</span> , then the attack succeeds with probability  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Algorithm 1 Idealized NC protocol  <span class="math">\\Pi^{\\rho, \\tau, k_{cond}}</span>  with scheduling policy (helper functions: App. C.2, environment  <span class="math">\\mathcal{Z}</span> : App. C.3, functionality  <span class="math">\\mathcal{T}_{\\mathrm{bdrtree}}^{\\mathrm{PoW}, \\rho, \\tau}</span> ; Alg. 2) 1:  <span class="math">\\triangleright</span>  Global counter of slots  <span class="math">t \\gets 1, 2, \\ldots</span>  of duration  <span class="math">\\tau</span>  ( <span class="math">\\tau \\to 0</span>  for PoW) 2: on init(geneisC, genesisTxs) 3:  <span class="math">\\triangleright</span>  Initialize header tree  <span class="math">\\mathsf{hT}</span> , longest processed chain dC, and mappings from block header to content blkTxs 4:  <span class="math">\\mathsf{hT}, \\mathsf{dC} \\gets \\{\\text{genesisC}\\}</span> , genesisC 5: blkTxs[genesisC]  <span class="math">\\leftarrow</span>  genesisTxs 6: on RECEIVEDHEADERCHAIN(C) 7: assert  <span class="math">\\mathcal{T}_{\\text{bdrtree}}^{\\text{PoW}, \\rho, \\tau}</span>  _VERSITY(C) 8:  <span class="math">\\mathsf{hT} \\gets \\mathsf{hT} \\cup</span>  prefixChainsOf(C) 9: Z.BROADCASTHEADERCHAIN(C) 10: on RECEIVEDCONTENT(C, txs) 11:  <span class="math">\\triangleright</span>  Define processing the content until all prefixes' contents are processed 12: defer until  <span class="math">\\forall C&#x27; &amp;lt; C: \\text{blkTxs}[C&#x27;] \\neq \\text{UNKNOWN}</span> 13: assert C.txsHash = Hash(txs) 14: RECEIVEDHEADERCHAIN(C) 15: assert AreTxsValid(txs) 16: blkTxs[C]  <span class="math">\\leftarrow</span>  txs 17: Z.UPLOADCONTENT(C, txs) 18: Update the longest processed chain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19:  $\\mathcal{T}' \\gets \\{C' \\in \\mathsf{hT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{blkTxs}[C'] \\neq \\text{UNKNOWN}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">21: at slot  <span class="math">t \\gets 1, 2, \\ldots</span> 22: txs  <span class="math">\\leftarrow</span>  Z.RECEIVEDPRINDINGTXS() 23:  <span class="math">\\triangleright</span>  Produce and disseminate a new block if eligible 24: if  <span class="math">C&#x27; \\neq \\bot</span>  with  <span class="math">C&#x27; \\gets \\mathcal{T}_{\\text{bdrtree}}^{\\text{PoW}, \\rho, \\tau}</span> .EXTEND(dC, txs) 25: Z.BROADCASTHEADERCHAIN(C') 26: Z.UPLOADCONTENT(C', txs) 27:  <span class="math">\\triangleright</span>  Confirm all but the last  <span class="math">k_{cond}</span>  blocks on the longest processed chain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">28:  $\\text{LOG}' \\gets \\text{txsLedger(blkTxs, dC}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{cond}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  Ledger of node  </span>p<span class="math">  at  </span>t: \\text{LOG}'_p$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">29: do throughout 30: Download content for some  <span class="math">C</span>  chosen by scheduling policy (e.g. Alg. 3)</p>

    <p class="text-gray-300">Algorithm 2 Idealized functionality  <span class="math">\\mathcal{T}_{\\mathrm{bdrtree}}^{\\mathrm{PoW},\\rho ,\\tau}</span>  block production lottery and header chain structure for PoW (helper functions: App. C.2) 1: on init (genesisC, numNodes) 2:  <span class="math">N \\gets</span>  numNodes 3:  <span class="math">\\mathcal{T} \\gets \\{\\text{genesisC}\\}</span>  ▷ Global set of valid header chains 4: on EXTEND(C, txs) from node  <span class="math">P</span>  (possibly adversary) at slot  <span class="math">t</span> 5: ▷ Abstraction of proof-of-work lottery: each node can call this once per slot and produces a block with probability  <span class="math">p / N</span>  independently of other nodes and slots 6: if lottery  <span class="math">[P, t] \\neq \\bot</span>  return  <span class="math">\\bot</span>  ▷ Only one ticket per node and slot 7: lottery  <span class="math">[P, t] \\gets (\\text{true with probability } p / N, \\text{ else false})</span> 8: if  <span class="math">C \\in \\mathcal{T} \\land \\text{lottery}[P, t]</span>  ▷ Parent chain  <span class="math">C</span>  is valid and lottery was won? 9: ▷ Produce a new block header extending  <span class="math">C</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10:  $C' \\gets C \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{newBlock}(txsHash: Hash(txs))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">11:  <span class="math">\\mathcal{T} \\gets \\mathcal{T} \\cup \\{C&#x27;\\}</span>  ▷ Register new header chain in header tree 12: return  <span class="math">C&#x27;</span> 13: return  <span class="math">\\bot</span> 14: on VERSITY(C) 15: return  <span class="math">C \\in \\mathcal{T}</span>  ▷ Header chain is valid if previously added to header tree</p>

    <p class="text-gray-300">Algorithm 3 Longest-header-chain rule  <span class="math">\\mathcal{D}_{\\mathrm{long}}</span> 1: function dlLongestHdrChain(hT, blkTxs)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2:  $\\mathcal{T}' \\gets \\{C \\in \\mathcal{T}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{blkTxs}[C] = \\text{UNKNOWN}\\}$  ▷ Ignore processed chains</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4:  $C' \\gets \\arg \\min_{C'' \\ni C: \\text{blkTxs}[C''] = \\text{UNKNOWN}}</td>

            <td class="px-3 py-2 border-b border-gray-700">C''</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">  ▷ First unknown block on that chain (if non-existent:  </span>\\bot$ )</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5: return  <span class="math">C&#x27;</span></p>

    <p class="text-gray-300">Pseudocode of an idealized NC protocol  <span class="math">\\Pi^{\\rho, \\tau, k_{cond}}</span>  is provided in Alg. 1. Details of the PoW-based block production lottery, i.e., of production and verification of blocks, are abstracted through an idealized functionality  <span class="math">\\mathcal{T}_{\\mathrm{bdrtree}}^{\\mathrm{PoW}, \\rho, \\tau}</span>  whose pseudocode is provided in</p>

    <p class="text-gray-300">!<a href="img-22.jpeg">img-22.jpeg</a> Figure 16: Bounded-capacity network model [48, Fig. 4]:  <span class="math">\\mathbf{1}</span>  Honest node produces a block, made of header and content. A hash in the header commits to the content.  <span class="math">\\mathbf{2}</span>  Header is flooded (Z.BROADCASTHEADERCHAIN), and arrives at all nodes  <span class="math">(\\Pi^{\\rho ,\\tau ,k_{cond}}</span>  RECEIVEDHEADERCHAIN) with at most  <span class="math">\\Delta_{\\mathrm{h}}</span>  delay.  <span class="math">\\mathbf{3}</span>  Content is made available for peer-to-peer pull-based download (Z.UPLOADCONTENT).  <span class="math">\\mathbf{4}</span>  Content associated with the header is processed (i.e., downloaded and verified)  <span class="math">(\\Pi^{\\rho ,\\tau ,k_{cond}}</span>  RECEIVEDCONTENT), subject to a maximum rate of C.  <span class="math">\\mathbf{5}</span>  The adversary can push headers and content to nodes, bypassing the delay and capacity constraints.</p>

    <p class="text-gray-300">Alg. 2 (cf. [52, Fig. 2], [48, Alg. 3]). Pseudocode for the longest-header-chain scheduling policy  <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>  is provided in Alg. 3. Helper functions used in the pseudocode are detailed in App. C.2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hash(txs): Cryptographic hash function to produce a binding commitment to txs (modelled as a random oracle)</li>

      <li><span class="math">C&#x27; \\preceq C, C \\succeq C&#x27;</span> : Relation that  <span class="math">C&#x27;</span>  is a prefix of  <span class="math">C</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $C\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C'<span class="math"> : Concatenation of  </span>C<span class="math">  and  </span>C'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(true with probability  <span class="math">x</span> , else false): Bernoulli random variable with success probability  <span class="math">x</span></li>

      <li>prefixChainsOf(C): Set of prefixes of  <span class="math">C</span> , i.e., all  <span class="math">C&#x27;</span>  with  <span class="math">C&#x27; \\preceq C</span></li>

      <li>newBlock(txsHash: Hash(txs)) and newBlock(time: t, node: P, txsHash: Hash(txs)): Produce a new PoW and PoS block header with given parameters, respectively</li>

      <li>txsLedger(blkTxs, C): Concatenates the block contents stored in blkTxs for the blocks along the chain  <span class="math">C</span> , to obtain the corresponding transaction ledger</li>

    </ul>

    <p class="text-gray-300">We study PoW NC (App. C.1) using the following model for a network  <span class="math">\\mathcal{Z}</span>  with finite capacity (Fig. 16), and for the powers and limits of an adversary  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">The environment  <span class="math">\\mathcal{Z}</span>  initializes  <span class="math">N</span>  nodes and lets  <span class="math">\\mathcal{A}</span>  corrupt up to  <span class="math">\\beta N</span>  nodes at the beginning of the execution. Corrupted nodes are controlled by the adversary. Honest nodes run  <span class="math">\\Pi^{\\rho, \\tau, k_{cond}}</span> . The environment maintains a mapping  <span class="math">\\mathcal{Z}</span> . blkTxs from block headers to the block content (transactions). This mapping is referred to as</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">the 'cloud' in Fig. 16.  <span class="math">\\mathcal{Z}</span>  also maintains for each node a queue of pending block headers to be delivered after a delay determined by the adversary. If  <span class="math">\\mathcal{A}</span>  has not instructed  <span class="math">\\mathcal{Z}</span>  to deliver a header  <span class="math">\\Delta_{\\mathrm{h}}</span>  real time after it was added to the queue of pending block headers, then  <span class="math">\\mathcal{Z}</span>  delivers it to the node.</p>

    <p class="text-gray-300">Honest nodes and  <span class="math">\\mathcal{A}</span>  interact with  <span class="math">\\mathcal{Z}</span>  via the following functions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Z}</span> .BROADCASTHEADERCHAIN  <span class="math">(C)</span> :</li>

    </ul>

    <p class="text-gray-300">If called by an honest node,  <span class="math">\\mathcal{Z}</span>  en queues  <span class="math">C</span>  in the queue of pending block headers for each node, and notifies  <span class="math">\\mathcal{A}</span> . Then, for each node  <span class="math">P</span> , on receiving  <span class="math">\\text{DELIVER}(C, P)</span>  from  <span class="math">\\mathcal{A}</span> , or when  <span class="math">\\Delta_{\\mathrm{h}}</span>  time has passed since  <span class="math">C</span>  was added to the queue of pending headers,  <span class="math">\\mathcal{Z}</span>  triggers  <span class="math">P</span> .RECEIVEDHEADERCHAIN  <span class="math">(C)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Z}</span> .UPLOADCONTENT  <span class="math">(C, \\mathrm{txs})</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{Z}</span>  stores a mapping from the header chain  <span class="math">C</span>  to the content txs of its last block by setting  <span class="math">\\mathcal{Z}.\\mathrm{blkTxs}[C] = \\mathrm{txs}</span> .  <span class="math">\\mathcal{Z}</span>  only stores the content txs if  <span class="math">\\mathrm{Hash}(\\mathrm{txs}) = C.\\mathrm{txsHash}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Z}</span> .RECEIVEPENDINGTXs():</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{Z}</span>  generates a set of pending transactions and returns them.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If node  <span class="math">P</span>  at slot  <span class="math">t</span>  requests the content associated with a block header  <span class="math">C</span> ,  <span class="math">\\mathcal{Z}</span>  acts as follows. If  <span class="math">\\mathcal{Z}.\\mathrm{blkTxs}[C]</span>  is set, then let  <span class="math">\\mathrm{txs} = \\mathcal{Z}.\\mathrm{blkTxs}[C]</span>  (if not,  <span class="math">\\mathcal{Z}</span>  ignores the request). If the request was received from an honest node  <span class="math">P</span> , if  <span class="math">\\mathcal{Z}</span>  has recently triggered  <span class="math">P</span> .RECEIVEDCONTENT(.) at a rate below  <span class="math">C</span> , then  <span class="math">\\mathcal{Z}</span>  triggers  <span class="math">P</span> .RECEIVEDCONTENT( <span class="math">C</span> , txs) (else,  <span class="math">\\mathcal{Z}</span>  ignores the request). If the request was received from  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{Z}</span>  sends  <span class="math">(C, \\mathrm{txs})</span>  to  <span class="math">\\mathcal{A}</span> .</li>

    </ul>

    <p class="text-gray-300">At all times,  <span class="math">\\mathcal{A}</span>  can trigger  <span class="math">P</span> . RECEIVEDHEADERCHAIN  <span class="math">(C)</span>  and  <span class="math">P</span> . RECEIVEDCONTENT  <span class="math">(C, \\mathrm{txs})</span>  for honest nodes  <span class="math">P</span>  (bypassing header delay and capacity constraint in an adversarially chosen way).</p>

    <p class="text-gray-300">This section provides a self-contained proof of the argument developed in Sec. 4.</p>

    <p class="text-gray-300">Nodes are identified using  <span class="math">p, q</span> . We distinguish between three notions of 'time': Slots of  <span class="math">\\Pi^{\\rho, \\tau, k_{cont}}</span>  are indicated by  <span class="math">r, s, t</span> . Slots in which one or more blocks are produced form a sub-sequence  <span class="math">\\{t_k\\}</span> , defined in App. D.2. Indices into this sub-sequence are denoted by  <span class="math">i, j, k</span> . The physical parameters of our model, header propagation delay  <span class="math">\\Delta_{\\mathrm{h}}</span>  and capacity  <span class="math">C</span> , as well as the mining rate  <span class="math">\\lambda</span> , are specified in units of real time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by  <span class="math">\\mathrm{d}C_p(t)</span>  the longest fully processed chain of an honest node  <span class="math">p</span>  at the end of slot  <span class="math">t</span> , and let  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denote the height of a block  </span>b<span class="math"> . We use the same notation  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to denote the length of a chain  </span>C<span class="math"> , define  </span>L_{p}(t) = \\left[\\mathrm{d}C_{p}(t)\\right]<span class="math">  and  </span>L_{\\min}(t) = \\min_{p} L_{p}(t)<span class="math">  (where &quot;min  </span>p$  " ranges only over honest nodes).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote intervals of indices (or slots) as  <span class="math">(i,j] \\triangleq \\{i + 1,\\dots,j\\}</span> , with the convention that  <span class="math">(i,j] \\triangleq \\emptyset</span>  for  <span class="math">j \\leq i</span> . We study executions over a finite horizon of  <span class="math">T_{\\mathrm{hrzn}}</span>  slots (or  <span class="math">K_{\\mathrm{hrzn}}</span>  indices), and any interval  <span class="math">(i,j]</span>  with  <span class="math">i &amp;lt; 0</span>  or  <span class="math">j &amp;gt; K_{\\mathrm{hrzn}}</span>  considered truncated accordingly. The notation  <span class="math">(i,j] \\succ K</span>  (resp.  <span class="math">\\geq, \\prec, \\preceq, \\asymp</span> ) is short for  <span class="math">j - i &amp;gt; K</span>  (resp.  <span class="math">\\geq, &amp;lt;, \\leq, \\asymp</span> ). In the analysis, we denote with upper-case Latin letters several random processes over indices (e.g.,  <span class="math">X_k</span> ) or slots (e.g.,  <span class="math">H_t</span> ). For any set  <span class="math">I</span>  of indices (analogously for slots), we define  <span class="math">X_I \\triangleq \\sum_{k \\in I} X_k</span> .</p>

    <p class="text-gray-300">We denote by  <span class="math">\\kappa</span>  the security parameter. An event  <span class="math">\\mathcal{E}_{\\kappa}</span>  occurs with overwhelming probability if  <span class="math">\\operatorname<em>{Pr}[\\mathcal{E}_{\\kappa}] \\geq 1 - \\mathrm{negl}(\\kappa)</span> . Here, a function  <span class="math">f(\\kappa)</span>  is negligible  <span class="math">\\mathrm{negl}(\\kappa)</span> , if for all  <span class="math">n &amp;gt; 0</span> , there exists  <span class="math">\\kappa_{n}^{</em>}</span>  such that for all  <span class="math">\\kappa &amp;gt; \\kappa_{n}^{*}</span> ,  <span class="math">f(\\kappa) &amp;lt; \\frac{1}{\\kappa^{n}}</span> .</p>

    <p class="text-gray-300">Recall that the protocol runs in slots of duration  <span class="math">\\tau</span> . A block production opportunity (BPO) is a pair  <span class="math">(p, t)</span>  where according to the PoW block production lottery, node  <span class="math">p</span>  is eligible to produce a block in slot  <span class="math">t</span> . A BPO is called honest (resp. adversary) if node  <span class="math">p</span>  is honest (resp. adversary). The random variables  <span class="math">H_{t}</span>  and  <span class="math">A_{t}</span>  denote the number of honest and adversary BPOs in slot  <span class="math">t</span> , respectively. When the number of nodes  <span class="math">N \\to \\infty</span>  and each node holds an equal rate of block production, by the Poisson approximation of a binomial random variable, we have  <span class="math">H_{t} \\stackrel{\\mathrm{i.i.d.}}{=} \\mathrm{Poisson}((1 - \\beta)\\rho)</span>  and  <span class="math">A_{t} \\stackrel{\\mathrm{i.i.d.}}{=} \\mathrm{Poisson}(\\beta\\rho)</span> , independent of each other and across slots. The total number of BPOs per slot is  <span class="math">Q_{t} \\triangleq H_{t} + A_{t}</span> . An execution refers to a particular realization of the random process  <span class="math">\\{(H_{t}, A_{t})\\}</span> .</p>

    <p class="text-gray-300">Good, Bad, and Empty Slots. Slots without a BPO are called 'empty'. A slot is 'good' iff it has exactly one honest BPO and no adversary BPOs, and is followed by  <span class="math">\\nu</span>  empty slots. This definition is inspired by convergence opportunities [37, 50, 52], loners [24], and laggers [55]. Here,  <span class="math">\\nu</span>  is an analysis parameter. We define another analysis parameter  <span class="math">\\widetilde{C}</span>  which is related to  <span class="math">\\nu</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">(\\nu + 1) \\tau \\triangleq \\Delta_ {\\mathrm {h}} + \\widetilde {C} / C. \\tag {4}</span></div>

    <p class="text-gray-300">Thus,  <span class="math">\\nu, \\widetilde{C}</span>  are chosen such that for a good slot, every honest node can receive the block header for the honest BPO, and process content for  <span class="math">\\widetilde{C}</span>  blocks, before the next BPO. Any non-empty slot which is not good is called 'bad'.</p>

    <p class="text-gray-300">Definition D.1. We call a slot  <span class="math">t</span>  good, bad, empty, respectively, denoted as  <span class="math">\\operatorname{Good}(t)</span> ,  <span class="math">\\operatorname{Bad}(t)</span> ,  <span class="math">\\operatorname{Empty}(t)</span> , respectively, iff:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {G o o d} (t) \\triangleq (H _ {t} = 1) \\wedge (A _ {t} = 0) \\\\ \\wedge \\left(H _ {\\{t, t + \\nu \\}} + A _ {\\{t, t + \\nu \\}} = 0\\right) \\tag {5} \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {B a d} (t) \\triangleq \\left(H _ {t} + A _ {t} &amp;gt; 0\\right) \\wedge \\neg \\operatorname {G o o d} (t) \\tag {6}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {E m p t y} (t) \\triangleq \\left(H _ {t} + A _ {t} = 0\\right). \\tag {7}</span></div>

    <p class="text-gray-300">Note that  <span class="math">\\operatorname{Empty}(t) = \\neg \\operatorname{Good}(t) \\wedge \\neg \\operatorname{Bad}(t)</span> .</p>

    <p class="text-gray-300">We denote by  <span class="math">t_k</span>  the  <span class="math">k</span> -th non-empty slot. Then, we can introduce random processes over indices, with index  <span class="math">k</span>  corresponding to the  <span class="math">k</span> -th non-empty slot  <span class="math">t_k</span> . Considering only indices simplifies analysis by not having to deal with empty slots. The process  <span class="math">\\{G_k\\}</span>  counts good slots, with  <span class="math">G_k \\triangleq \\mathbb{1}_{\\{\\mathrm{Good}(t_k)\\}}</span> . Correspondingly,  <span class="math">(\\widetilde{G}_k)</span>  counts bad slots,  <span class="math">\\widetilde{G}_k \\triangleq 1 - G_k</span> .</p>

    <p class="text-gray-300">The following fact shows the distribution of good indices.</p>

    <p class="text-gray-300">PROPOSITION 4.1. The  <span class="math">\\{G_k\\}</span>  are independent and identically distributed (iid) with  <span class="math">\\operatorname*{Pr}[G_k = 1] \\triangleq p_{\\mathrm{G}} = (1 - \\beta)\\frac{\\rho e^{-\\rho(\\nu + 1)}}{1 - e^{-\\rho}}</span> .</p>

    <p class="text-gray-300">PROOF. First, for any  <span class="math">k</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ G _ {k} = 1 \\right] = \\Pr \\left[ \\operatorname {G o o d} \\left(t _ {k}\\right) \\mid \\neg \\operatorname {E m p t y} \\left(t _ {k}\\right) \\right] \\tag {8} \\\\ = \\frac {\\Pr [ \\operatorname {G o o d} (t _ {k}) ]}{\\Pr [ \\neg \\operatorname {E m p t y} (t _ {k}) ]} = \\frac {(1 - \\beta) \\rho e ^ {- \\rho (\\nu + 1)}}{1 - e ^ {- \\rho}}. \\tag {9} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let  <span class="math">p_{\\mathrm{E}} \\triangleq \\operatorname<em>{Pr}[H_t + A_t = 0]</span> . Take an iid random process  <span class="math">\\{T_k\\}</span>  with  <span class="math">\\operatorname</em>{Pr}[T_k = t] = (1 - p_{\\mathrm{E}})p_{\\mathrm{E}}^d</span>  for  <span class="math">t \\geq 0</span> . The random variables  <span class="math">\\{T_k\\}</span>  describe the inter-arrival times between non-empty slots. Take another iid random process  <span class="math">\\{G_k&#x27;\\}</span> , independent of  <span class="math">\\{T_k\\}</span> , such that</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300"><span class="math">G_{k}^{\\prime}=1</span> with probability <span class="math">\\Pr\\left[H_{t}=1\\wedge A_{t}=0\\mid H_{t}+A_{t}&amp;gt;0\\right]</span> and <span class="math">G_{k}^{\\prime}=0</span> otherwise. The random process <span class="math">\\{G_{k}\\}</span> can be equivalently defined as <span class="math">G_{k}=1</span> iff <span class="math">G_{k}^{\\prime}=1</span> and <span class="math">T_{k}\\geq\\nu</span>. The independence of the random variables <span class="math">\\{G_{k}\\}</span> then follows from the independence of the random variables <span class="math">\\{(T_{k},G_{k}^{\\prime})\\}</span>. ∎</p>

    <p class="text-gray-300">Throughout the analysis, we assume <span class="math">p_{\\mathrm{G}}&amp;gt;\\frac{1}{2}</span> (’honest majority’ assumption).</p>

    <p class="text-gray-300">Some Good Slots Imply Growth. A special role is played by good slots <span class="math">t_{k}</span> with the additional property that the block produced at <span class="math">t_{k}</span> is ’soon’ processed by all honest nodes. Intuitively, these lead to chain growth, the cornerstone of NC security <em>(24; 52)</em>. We count these slots with <span class="math">\\{D_{k}\\}</span>, and all other non-empty slots with <span class="math">\\{\\overline{D}_{k}\\}</span>. Specifically, <span class="math">D_{k}\\triangleq 1</span> if <span class="math">\\mathrm{Good}(t_{k})</span> and the block produced at <span class="math">t_{k}</span> has been processed by all honest nodes by the end of slot <span class="math">t_{k}+\\nu</span>, <span class="math">D_{k}\\triangleq 0</span> otherwise, and <span class="math">\\overline{D}_{k}\\triangleq 1-D_{k}</span>. Finally, we define two random walks on indices of non-empty slots with increments <span class="math">\\{X_{k}\\}</span> and <span class="math">\\{Y_{k}\\}</span> that are handy for the definition of probabilistic and combinatorial pivots:</p>

    <p class="text-gray-300">(10) <span class="math">X_{k}\\triangleq G_{k}-\\overline{G}_{k}\\qquad\\qquad Y_{k}\\triangleq D_{k}-\\overline{D}_{k}</span></p>

    <p class="text-gray-300">Note that the increments <span class="math">\\{X_{k}\\}</span> are iid, and not affected by adversary action, while the increments <span class="math">\\{Y_{k}\\}</span> do depend on the adversary action and are thus in particular not iid. Also note that <span class="math">\\forall k\\colon Y_{k}\\leq X_{k}</span> since <span class="math">D_{k}=1\\implies G_{k}=1</span>.</p>

    <p class="text-gray-300">Probabilistic and Combinatorial Pivots.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition D.2.</h6>

    <p class="text-gray-300">We call an index <span class="math">k</span> a ppivot (short for probabilistic pivot), denoted as <span class="math">\\mathrm{PPivot}(k)</span>, iff:</p>

    <p class="text-gray-300">(11) <span class="math">\\mathrm{PPivot}(k)\\ \\triangleq\\ (\\forall\\ (i,j]\\ni k\\colon X_{(0,i]}&amp;lt;X_{(0,k]}\\leq X_{(0,j]})</span></p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition D.3.</h6>

    <p class="text-gray-300">We call an index <span class="math">k</span> a cpivot (short for combinatorial pivot), denoted as <span class="math">\\mathrm{CPivot}(k)</span>, iff:</p>

    <p class="text-gray-300">(12) <span class="math">\\mathrm{CPivot}(k)\\ \\triangleq\\ (\\forall\\ (i,j]\\ni k\\colon Y_{(0,i]}&amp;lt;Y_{(0,k]}\\leq Y_{(0,j]})</span></p>

    <p class="text-gray-300">This definition of ppivots and cpivots decouples <em>(52, Def. 5)</em> into its probabilistic aspects <em>(52, Sec. 5.6.3)</em> and combinatorial aspects <em>(52, Sec. 5.6.2)</em>, and casts them as conditions on a random walk, inspired by <em>(24; 40)</em>, to simplify the analysis. The decoupling is one of the key differences from the analysis in <em>(52)</em> (see Fig. 4). Note that a cpivot is also a ppivot because <span class="math">Y_{i}\\leq X_{i}</span>. Also, Def. D.2 is equivalent to Def. 4.2, and Def. D.3 is equivalent to Def. 4.3 (cf. proof of Prop. D.7).</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">D.3. Analysis in the Probabilistic Model</h3>

    <p class="text-gray-300">We now develop the tools needed to prove safety and liveness of PoW NC in the bounded-capacity model, following Fig. 4. First, analogously to the combinatorial argument of <em>(52)</em>, we show (App. D.3.1) that blocks from cpivots stabilize, i.e., they remain in the longest processed chain of all honest nodes forever. This is useful because if we know that cpivots occur frequently, then honest nodes can confirm transactions that must lie in the prefix of a cpivot’s block (safety), and cpivots’ blocks (being produced by honest nodes) bring any outstanding transactions onto chain (liveness). We then show that cpivots do indeed occur frequently: We show with a new probabilistic argument (App. D.3.2) that ppivots are abundant, i.e., in every ’sufficiently long’ interval (i.e., of length <span class="math">\\Omega(\\kappa^{2})</span>), a constant fraction of the slots are ppivots (Lem. D.12). Then, we show with a new combinatorial argument (App. D.3.3) that the adversary cannot prevent all ppivots from becoming cpivots, i.e., in every ’sufficiently long’ interval, there is at least one cpivot (Lem. D.17). As a result, if honest nodes confirm transactions that are still on their longest processed chain after ’sufficiently long’ time (i.e., confirmation latency <span class="math">\\Omega(\\kappa^{2})</span>), then PoW NC <span class="math">\\Pi^{p,r,k_{cond}}</span> is safe and live under bounded capacity.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">D.3.1. Combinatorial Pivots Stabilize</h4>

    <p class="text-gray-300">We now show that the honest block produced in a slot corresponding to a cpivot persists in the longest processed chain of all honest nodes forever after <span class="math">\\nu</span> slots after it was produced. Towards this, we first show that if <span class="math">D_{k}=1</span>, i.e., if all honest nodes process the block produced in the good slot <span class="math">t_{k}</span>, then the length of the longest processed chain of honest nodes increases, i.e., a chain growth event (made precise in Prop. D.4). Due to this, since, by Def. D.3, all intervals around a cpivot contain more indices with <span class="math">D_{k}=1</span> than those with <span class="math">D_{k}=0</span>, there can never be some honest node with a longest processed chain that does not contain the block corresponding to the cpivot (Lem. D.5). This is because there are not enough blocks for any other chain to outnumber the chain growth events that contributed to the growth of the processed chain containing the cpivot’s block. Thus, the block corresponding to the cpivot remains in all honest nodes’ longest processed chains forever. Lem. D.5 is proven analogously to the combinatorial argument of <em>(52)</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that <span class="math">\\mathrm{d}\\mathcal{C}_{p}(t)</span> is the longest processed chain of node <span class="math">p</span> at the end of slot <span class="math">t</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the length of chain </span>\\mathcal{C}<span class="math">, </span>L_{p}(t)=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{d}\\mathcal{C}_{p}(t)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the length of the ”shortest (across honest nodes) longest processed chain” is </span>L_{\\min}(t)=\\min_{p}L_{p}(t)<span class="math"> (where ”</span>\\min_{p}<span class="math">” ranges only over honest nodes). The following proposition says that </span>L_{\\min}(t)<span class="math"> grows for every index </span>k<span class="math"> with </span>D_{k}=1$, i.e., these are “chain growth events”.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proposition D.4.</h6>

    <p class="text-gray-300">If <span class="math">D_{k}=1</span>, then <span class="math">L_{\\min}(t_{k}+\\nu)\\geq L_{\\min}(t_{k}-1)+1</span>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">D_{k}=1</span>, slot <span class="math">t_{k}</span> is a good slot. Let <span class="math">b</span> be the unique honest block produced in slot <span class="math">t_{k}</span>, and let honest node <span class="math">p</span> be its producer. Since honest nodes produce blocks on their longest processed chain, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=L_{p}(t_{k}-1)+1\\geq L_{\\min}(t_{k}-1)+1<span class="math">. Further, </span>D_{k}=1<span class="math"> means that the block </span>b<span class="math"> is processed by all honest nodes by the end of slot </span>t_{k}+\\nu<span class="math">. Therefore, </span>L_{\\min}(t_{k}+\\nu)\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma D.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">b^{*}</span> be the block produced in a non-empty slot <span class="math">t_{k}</span> such that <span class="math">\\mathrm{CPivot}(k)</span>. Then, for all header chains <span class="math">\\mathcal{C}^{\\prime}</span> that are valid at slot <span class="math">t\\geq t_{k}+\\nu</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq L_{\\min}(t)\\colon b^{<em>}\\in\\mathcal{C}^{\\prime}<span class="math">. Also then, for all honest nodes </span>p<span class="math"> and for all slots </span>t\\geq t_{k}+\\nu\\colon b^{</em>}\\in\\mathrm{d}\\mathcal{C}_{p}(t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following proposition is helpful for proving Lem. D.5.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proposition D.6.</h6>

    <p class="text-gray-300">For any <span class="math">i&amp;lt;j</span>,</p>

    <p class="text-gray-300">(13) <span class="math">L_{\\min}(t_{j}+\\nu)\\geq L_{\\min}(t_{i+1}-1)+D_{(i,j]}.</span></p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By noting that if <span class="math">D_{k}=1</span>, then <span class="math">t_{k+1}&amp;gt;t_{k}+\\nu</span>, and adding the result of Prop. D.4 for each index with <span class="math">D_{k}=1</span>. ∎</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof of Lem. D.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">\\mathrm{d}\\mathcal{C}_{p}(t)</span> is a valid chain at slot <span class="math">t</span> and $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{d}\\mathcal{C}_{p}(t)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=L_{p}(t)\\geq L_{\\min}(t)$. Therefore, it suffices to show the first claim of the lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For contradiction, let <span class="math">s\\geq t_{k}+\\nu</span> be the first slot in which there is a valid header chain <span class="math">\\mathcal{C}^{\\prime}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq L_{\\min}(s)<span class="math"> and </span>b^{*}\\notin\\mathcal{C}^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">b&#x27;</span>  be the block with maximum height on the chain  <span class="math">C&#x27;</span> , such that  <span class="math">b&#x27;</span>  was produced in a slot  <span class="math">t_i</span>  with  <span class="math">D_i = 1</span> . For  <span class="math">C&#x27;</span>  to be a valid chain at slot  <span class="math">s</span> , we need  <span class="math">t_i \\leq s</span> . Since the block  <span class="math">b&#x27;</span>  is produced by an honest node,  <span class="math">b&#x27;</span>  extends  <span class="math">\\mathrm{d}C_q(t_i - 1)</span>  for some honest node  <span class="math">q</span> . Therefore,  <span class="math">\\mathrm{d}C_q(t_i - 1)</span>  is a prefix of  <span class="math">C&#x27;</span> . This means that  <span class="math">b^* \\notin \\mathrm{d}C_q(t_i - 1)</span> . Moreover,  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{d}C_q(t_i - 1) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= L_q(t_i - 1) \\geq L_{\\min}(t_i - 1)<span class="math"> . If  </span>i &gt; k<span class="math"> , then  </span>t_i - 1 \\geq t_k + \\nu<span class="math">  (since  </span>D_k = 1<span class="math"> ) and  </span>t_i - 1 &lt; s<span class="math">  (shown above). This is a contradiction because we assumed that  </span>s<span class="math">  is the first slot such that  </span>s \\geq t_k + \\nu<span class="math">  and  </span>b^* \\notin C'<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq L_{\\min}(s)<span class="math">  for some valid chain  </span>C'<span class="math"> . Since  </span>b^*<span class="math">  is the only block produced in slot  </span>t_k<span class="math"> ,  </span>i = k<span class="math">  is also not possible. We conclude that  </span>i &lt; k$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since  <span class="math">D_{i} = 1</span>  and  <span class="math">b^{\\prime}</span>  is produced in slot  <span class="math">t_i</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L _ {\\min } \\left(t _ {i} + v\\right) \\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b ^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\tag {14}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">By assumption,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C ^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq L _ {\\min } (s). \\tag {15}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let  <span class="math">t_j</span>  be the last non-empty slot such that  <span class="math">t_j \\leq s</span> . Note that  <span class="math">j \\geq k &amp;gt; i</span> . We must consider two cases:</p>

    <p class="text-gray-300">(1) Case 1:  <span class="math">s \\geq t_j + \\nu</span>  or  <span class="math">D_j = 0</span> . If  <span class="math">D_j = 0</span> , we don't have to worry about whether the block from slot  <span class="math">t_j</span>  was processed by all honest nodes. If  <span class="math">D_j = 1</span>  but  <span class="math">s \\geq t_j + \\nu</span> , then we know that all honest nodes have processed the block from slot  <span class="math">t_j</span>  before the end of slot  <span class="math">s</span> . That is,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} L _ {\\min } (s) \\geq L _ {\\min } \\left(t _ {j} + v\\right) (16) \\\\ \\geq L _ {\\min } \\left(t _ {i + 1} - 1\\right) + D _ {(i, j ]} \\quad (\\text {from Prop. D.6}) (17) \\\\ \\geq L _ {\\min } \\left(t _ {i} + v\\right) + D _ {(i, j ]}. (18) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By definition of  <span class="math">b&#x27;</span> , all blocks in  <span class="math">C&#x27;</span>  appearing after  <span class="math">b&#x27;</span>  correspond to indices  <span class="math">l</span>  with  <span class="math">D_l = 0</span> . These blocks must be from distinct indices greater than  <span class="math">i</span>  but at most  <span class="math">j</span> . So,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C ^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b ^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\bar {D} _ {(i, j ]}. \\tag {19}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">From eqns. (14), (15), (18) and (19), we derive</p>

    <div class="my-4 text-center"><span class="math-block">D _ {(i, j ]} \\leq \\bar {D} _ {(i, j ]} \\Longrightarrow Y _ {(i, j ]} \\leq 0 \\Longrightarrow Y _ {(0, i ]} &amp;lt;   Y _ {(0, j ]} \\tag {20}</span></div>

    <p class="text-gray-300">where  <span class="math">i &amp;lt;   k\\leq j</span></p>

    <p class="text-gray-300">(2) Case 2:  <span class="math">t_j \\leq s &amp;lt; t_j + \\nu</span>  and  <span class="math">D_j = 1</span> . In this case, the block from slot  <span class="math">t_j</span>  may not have enough time to be processed by all honest nodes before the end of slot  <span class="math">s</span> . However, for any  <span class="math">l &amp;lt; j</span>  such that  <span class="math">D_l = 1</span> ,  <span class="math">t_l + \\nu &amp;lt; t_j \\leq s</span> , so there is enough time to process the block from slot  <span class="math">t_l</span> . Let  <span class="math">l \\in (i,j - 1]</span>  be the greatest index such that  <span class="math">D_l = 1</span> . Then,  <span class="math">t_j &amp;gt; t_l + \\nu</span> , and  <span class="math">D_{(i,l]} = D_{(i,j - 1]}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} L _ {\\min } (s) \\geq L _ {\\min } \\left(t _ {j}\\right) (21) \\\\ \\geq L _ {\\min } \\left(t _ {l} + v\\right) (22) \\\\ \\geq L _ {\\min } \\left(t _ {i + 1} - 1\\right) + D _ {(i, l ]} \\quad (\\text {from Prop. D.6}) (23) \\\\ \\geq L _ {\\min } \\left(t _ {i} + v\\right) + D _ {(i, j - 1 ]}. (24) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that since  <span class="math">D_{j} = 1</span> ,  <span class="math">\\overline{D}_{(i,j]} = \\overline{D}_{(i,j - 1]}</span> . Therefore, as in the previous case,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C ^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b ^ {\\prime} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\bar {D} _ {(i, j - 1 ]}. \\tag {25}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">From eqns. (14), (15), (21) and (25),</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} D _ {(i, j - 1 ]} \\leq \\bar {D} _ {(i, j - 1 ]} \\Longrightarrow Y _ {(i, j - 1 ]} \\leq 0 \\\\ \\Longrightarrow Y _ {(0, i ]} &amp;lt;   Y _ {(0, j - 1 ]}. \\tag {26} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">!<a href="img-23.jpeg">img-23.jpeg</a> Figure 17: Illustration of ppivot (eqn. (29)): A ppivot as an index  <span class="math">k</span>  so that  <span class="math">X_{k} = 1</span>  (■) and  <span class="math">X_{(0,.)}</span>  is strictly below  <span class="math">X_{(0,k]}</span>  left of  <span class="math">k</span>  and weakly above  <span class="math">X_{(0,k]}</span>  right of  <span class="math">k</span>  (■, ■).</p>

    <p class="text-gray-300">Note that since we assumed  <span class="math">s \\geq t_k + \\nu</span>  and  <span class="math">s &amp;lt; t_j + \\nu</span> , we know that  <span class="math">j &amp;gt; k</span> . Therefore,  <span class="math">i &amp;lt; k \\leq j - 1</span> .</p>

    <p class="text-gray-300">In either case, eqn. (20) or eqn. (26) contradict the assumption CPivot  <span class="math">(k)</span>  (Def. D.3).</p>

    <p class="text-gray-300">D.3.2 Probabilistic Pivots Are Abundant. Previous analyses of NC [24, 52] show that sufficiently long intervals contain at least one ppivot (Fig. 4(a)). This was enough for the bounded-delay analysis because in the bounded-delay setting, every ppivot is also a cpivot. However, in the bounded-capacity setting, not every cpivot is a ppivot, because not every good slot results in growth of the longest processed chain of honest nodes (Fig. 4(b)). Thus, existence of one ppivot in every large interval is not enough to conclude existence of one cpivot in every large interval. Instead, we prove, using a concentration bound on the number of ppivots (Prop. D.11), that long intervals of indices in fact contain a number of ppivots proportional to the interval length (Lem. D.12). Then, in App. D.3.3, we prove that out of those many ppivots, at least one must also be a cpivot, which allows us to continue with the safety and liveness proofs from [52].</p>

    <p class="text-gray-300">The key challenge in proving that there are many ppivots is that for two indices  <span class="math">k_{1}, k_{2}</span> , the events that  <span class="math">k_{1}</span>  is a ppivot and that  <span class="math">k_{2}</span>  is a ppivot are dependent, because both events depend on overlapping intervals. But a key observation is that since the ppivot condition (Def. D.2) already holds for large intervals with high probability (Prop. D.8), we only need to look at the small intervals. Then, for two indices  <span class="math">k_{1}, k_{2}</span>  that are sufficiently far apart, these short intervals are disjoint, and thus the corresponding ppivot conditions are independent. Therefore, we decompose a long interval of indices into several groups of far-apart indices. This is illustrated in Fig. 10, each group indicated by a different color. Within each group, by a concentration bound for iid random variables, there are many ppivots. Further, by a union bound, the concentration holds in all the groups simultaneously with high probability. This summarizes the proof of Prop. D.11, which culminates in Lem. D.12 showing that with overwhelming probability, there are many ppivots in every long enough interval.</p>

    <p class="text-gray-300">We first identify insightful alternative characterizations of ppivots, and a few propositions to help prove Prop. D.11. Lem. D.12 follows from there.</p>

    <p class="text-gray-300">PROPOSITION D.7.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {P P i v o t} (k) \\Longleftrightarrow (\\forall (i, j ] \\ni k: X _ {(i, j ]} &amp;gt; 0) \\tag {27} \\\\ \\Longleftrightarrow (\\forall (i, j ] \\ni k: G _ {(i, j ]} &amp;gt; \\bar {G} _ {(i, j ]}) \\tag {28} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Longleftrightarrow \\left(X _ {k} = 1\\right) \\wedge (\\forall j \\geq k: X _ {(k, j)} \\geq 0) \\\\ \\wedge (\\forall i &amp;lt;   (k - 1): X _ {(i, k - 1)} \\geq 0) \\tag {29} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">PROOF. Elementary, using  <span class="math">X_{(i,j]} = X_{(0,j]} - X_{(0,i]}</span> .</p>

    <p class="text-gray-300">In particular, eqn. (29) characterizes a ppivot as an index  <span class="math">k</span>  such that  <span class="math">G_{k} = 1</span>  and the simple random walks  <span class="math">\\ell \\mapsto X_{(k,k + \\ell)}</span>  and  <span class="math">\\ell \\mapsto X_{(k - 1 - \\ell ,k - 1)}</span>  starting at 0 remain non-negative forever (Fig. 17). Due to this, we easily see that the probability that any given index is a ppivot is the probability that the index is good and the two random walks never return to zero (Prop. D.10). In Prop. D.8 by a simple concentration bound over iid random variables, we show that in all large intervals, with high probability, the random walk  <span class="math">X_{k}</span>  advances proportionally to the interval length (due to its positive drift).</p>

    <p class="text-gray-300">Throughout this section, assume that  <span class="math">p_{\\mathrm{G}} = \\frac{1}{2} + \\varepsilon_{\\mathrm{G}}</span>  with  <span class="math">\\varepsilon_{\\mathrm{G}} \\in (0, 1/2]</span> .</p>

    <p class="text-gray-300">PROPOSITION D.8. With  <span class="math">\\alpha_{2} \\triangleq 2\\varepsilon_{\\mathrm{G}}^{2}, \\forall (i,j], \\forall \\delta \\geq 0</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ X _ {(i, j)} \\leq (1 - \\delta) 2 \\varepsilon_ {\\mathrm {G}} (j - i) \\right] \\leq \\exp (- \\alpha_ {2} \\delta^ {2} (j - i)). \\tag {30}</span></div>

    <p class="text-gray-300">PROOF. By Hoeffding's inequality [34] [26, Thm. 4].</p>

    <p class="text-gray-300">PROPOSITION D.9 (HOEFEDING'S INEQUALITY [34] [26, THM. 4]). Let  <span class="math">Z_{1}, \\ldots, Z_{n}</span>  be independent bounded random variables with  <span class="math">\\forall i: Z_{i} \\in [a, b]</span> , where  <span class="math">-\\infty &amp;lt; a \\leq b &amp;lt; \\infty</span> . Then,  <span class="math">\\forall t \\geq 0</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\left(\\sum_ {i = 1} ^ {n} Z _ {i}\\right) \\geq \\mathbb {E} \\left[ \\sum_ {i = 1} ^ {n} Z _ {i} \\right] + t n \\right] \\leq \\exp \\left(\\frac {- 2 n t ^ {2}}{(b - a) ^ {2}}\\right) \\tag {31}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\left(\\sum_ {i = 1} ^ {n} Z _ {i}\\right) \\leq \\mathbb {E} \\left[ \\sum_ {i = 1} ^ {n} Z _ {i} \\right] - t n \\right] \\leq \\exp \\left(\\frac {- 2 n t ^ {2}}{(b - a) ^ {2}}\\right) \\tag {32}</span></div>

    <p class="text-gray-300">PROPOSITION D.10.</p>

    <div class="my-4 text-center"><span class="math-block">\\forall k: \\quad \\Pr [ \\mathrm {P P i v o t} (k) ] \\geq (2 p _ {\\mathrm {G}} - 1) ^ {2} / p _ {\\mathrm {G}} \\triangleq p _ {\\text {p p i v o t}} \\tag {33}</span></div>

    <p class="text-gray-300">Proof. In eqn. (29),  <span class="math">\\mathrm{PPivot}(k)</span>  is characterized as the intersection of three independent events:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {1} \\triangleq \\{X _ {k} = 1 \\} \\tag {34}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {2} \\triangleq \\left\\{\\forall \\ell : X _ {(k, k + \\ell)} \\geq 0 \\right\\} \\tag {35}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {3} \\triangleq \\left\\{\\forall \\ell : X _ {(k - 1 - \\ell , k - 1)} \\geq 0 \\right\\} \\tag {36}</span></div>

    <p class="text-gray-300">Their probabilities are easily calculated [39]:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {E} _ {1} \\right] = p _ {\\mathrm {G}} \\quad \\Pr \\left[ \\mathcal {E} _ {2} \\right] = \\Pr \\left[ \\mathcal {E} _ {3} \\right] = (2 p _ {\\mathrm {G}} - 1) / p _ {\\mathrm {G}} \\tag {37}</span></div>

    <p class="text-gray-300">The process  <span class="math">\\{P_k\\}</span>  counts ppivots, with  <span class="math">P_{k} \\triangleq \\mathbb{1}_{\\{\\mathrm{PPivot}(k)\\}}</span> .</p>

    <p class="text-gray-300">PROPOSITION D.11. With  <span class="math">\\alpha_{3} \\triangleq 2p_{\\mathrm{ppivot}}^{2}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\forall (i, j ] \\asymp 2 K _ {1} K _ {2}: \\quad \\Pr \\left[ P _ {(i, j)} \\leq (1 - \\delta) p _ {\\text {p p i v o t}} 2 K _ {1} K _ {2} \\right] \\\\ \\leq 2 K _ {1} \\exp (- \\alpha_ {3} \\delta^ {2} K _ {2}) + K _ {\\mathrm {h r z n}} ^ {2} \\exp (- \\alpha_ {2} K _ {1}). \\tag {38} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">PROOF. Let  <span class="math">\\mathcal{E} \\triangleq \\{\\forall (i,j] \\succeq K_1 \\colon X_{(i,j]} &amp;gt; 0\\}</span> . From Prop. D.8 with  <span class="math">\\delta = 1</span> , and a union bound over all intervals ( <span class="math">\\leq K_{\\mathrm{hrzn}}^2</span>  many), we get</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\neg \\mathcal {E} \\right] \\leq K _ {\\mathrm {h r z n}} ^ {2} \\exp (- \\alpha_ {2} K _ {1}). \\tag {39}</span></div>

    <p class="text-gray-300">For any given index  <span class="math">k</span> , we can partition the intervals of eqn. (27) into 'long' and 'short' intervals (length at least vs. less than  <span class="math">K_{1}</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {k} \\triangleq \\left\\{\\mathrm {P P i v o t} (k) \\right\\} = \\mathcal {E} _ {k} ^ {\\mathrm {L}} \\wedge \\mathcal {E} _ {k} ^ {\\mathrm {S}} \\tag {40}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {k} ^ {\\mathrm {L}} \\triangleq \\left\\{\\forall (i, j) \\ni k, (i, j ] \\succeq K _ {1}: X _ {(i, j)} &amp;gt; 0 \\right\\} \\tag {41}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {k} ^ {\\mathrm {S}} \\triangleq \\left\\{\\forall (i, j ] \\ni k, (i, j ] \\prec K _ {1}: X _ {(i, j)} &amp;gt; 0 \\right\\}. \\tag {42}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  <span class="math">\\mathcal{E}_k^{\\mathrm{L}}\\supseteq \\mathcal{E}</span> . Also, for any two given indices  <span class="math">k_{1},k_{2}</span>  that are 'far apart', i.e., if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1} - k_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2K_{1}<span class="math"> , then  </span>\\mathcal{E}_{k_1}<span class="math">  and  </span>\\mathcal{E}_{k_2}<span class="math">  are conditionally independent given  </span>\\mathcal{E}<span class="math">  (since  </span>\\mathcal{E}_{k_1}^{\\mathrm{S}}<span class="math">  and  </span>\\mathcal{E}_{k_2}^{\\mathrm{S}}$  are).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We decompose  <span class="math">I^{*} \\triangleq (i,j] = (i,i + 2K_{1}K_{2}] = \\bigcup_{\\ell = 1}^{2K_{1}}I_{\\ell}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\ell \\in \\{1, \\dots , 2 K _ {1} \\}: \\quad I _ {\\ell} \\triangleq \\{i + 0 \\cdot 2 K _ {1} + \\ell , \\dots</span></div>

    <div class="my-4 text-center"><span class="math-block">\\dots , i + \\left(K _ {2} - 1\\right) \\cdot 2 K _ {1} + \\ell \\}. \\tag {43}</span></div>

    <p class="text-gray-300">See Fig. 10 for illustration. We define corresponding events,  <span class="math">\\forall \\ell \\in \\{1,\\dots,2K_1\\}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} ^ {*} \\triangleq \\left\\{P _ {I ^ {*}} \\leq (1 - \\delta) p _ {\\text {p p i v o t}} 2 K _ {1} K _ {2} \\right\\} \\tag {44}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {\\ell} \\triangleq \\left\\{P _ {I _ {\\ell}} \\leq (1 - \\delta) p _ {\\text {p p i v o t}} K _ {2} \\right\\}. \\tag {45}</span></div>

    <p class="text-gray-300">Clearly,  <span class="math">\\mathcal{E}^* \\subseteq \\bigcup_{\\ell=1}^{2K_1} \\mathcal{E}_{\\ell}</span> . Thus, by a union bound,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {E} ^ {*} \\mid \\mathcal {E} \\right] \\leq \\sum_ {\\ell = 1} ^ {2 K _ {1}} \\Pr \\left[ \\mathcal {E} _ {\\ell} \\mid \\mathcal {E} \\right]. \\tag {46}</span></div>

    <p class="text-gray-300">Furthermore,  <span class="math">\\forall \\ell \\in \\{1,\\dots,2K_1\\}</span> , and with  <span class="math">\\mu_{\\ell} \\triangleq \\mathbb{E}\\left[P_{I_{\\ell}} \\mid \\mathcal{E}\\right]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {E} _ {\\ell} \\mid \\mathcal {E} \\right] = \\Pr \\left[ P _ {I _ {\\ell}} \\leq (1 - \\delta) p _ {\\text {p p i v o t}} K _ {2} \\mid \\mathcal {E} \\right] \\tag {47}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {(a)}} {\\leq} \\Pr \\left[ P _ {I _ {\\ell}} \\leq (1 - \\delta) \\mu_ {\\ell} \\mid \\mathcal {E} \\right] \\tag {48}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel {\\text {(b)}} {\\leq} \\exp (- 2 \\delta^ {2} \\mu_ {\\ell} ^ {2} / K _ {2}) \\stackrel {\\text {(c)}} {\\leq} \\exp (- 2 p _ {\\text {p p i v o t}} ^ {2} \\delta^ {2} K _ {2}), \\tag {49}</span></div>

    <p class="text-gray-300">where (a) and (c) use</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mu_ {\\ell} = K _ {2} \\mathbb {E} \\left[ \\mathbb {1} _ {\\{P P i v o t (k) \\}} \\mid \\mathcal {E} \\right] \\geq K _ {2} \\mathbb {E} \\left[ \\mathbb {1} _ {\\{P P i v o t (k) \\}} \\right] \\\\ \\geq K _ {2} p _ {\\text {p p i v o t}} \\tag {50} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">(Prop. D.10), and (b) uses that  <span class="math">\\{\\mathrm{PPivot}(k_1)\\}</span>  and  <span class="math">\\{\\mathrm{PPivot}(k_2)\\}</span>  are conditionally independent given  <span class="math">\\mathcal{E}</span>  for  <span class="math">k_{1},k_{2}\\in I_{\\ell}</span> , and Hoeffding's inequality (Prop. D.9).</p>

    <p class="text-gray-300">To complete the proof, with  <span class="math">\\alpha_{3} = 2p_{\\mathrm{ppivot}}^{2}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\mathcal {E} ^ {*} \\right] = \\Pr \\left[ \\mathcal {E} ^ {*} \\cap \\mathcal {E} \\right] + \\Pr \\left[ \\mathcal {E} ^ {*} \\cap \\neg \\mathcal {E} \\right] \\tag {51} \\\\ \\leq \\Pr \\left[ \\mathcal {E} ^ {*} \\mid \\mathcal {E} \\right] + \\Pr [ \\neg \\mathcal {E} ] \\tag {52} \\\\ \\leq 2 K _ {1} \\exp (- \\alpha_ {3} \\delta^ {2} K _ {2}) + K _ {\\mathrm {h r z n}} ^ {2} \\exp (- \\alpha_ {2} K _ {1}). \\tag {53} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">LEMMA D.12. For  <span class="math">K_{\\mathrm{cp}} = \\Omega(\\kappa^2)</span> , and  <span class="math">K_{\\mathrm{hrzn}} = \\mathrm{poly}(\\kappa)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\forall (i, j) \\succeq K _ {\\mathrm {c p}}: P _ {(i, j)} \\geq (1 - \\delta) p _ {\\text {p p i v o t}} K _ {\\mathrm {c p}} \\right] \\\\ \\geq 1 - \\exp (- \\Omega (\\kappa)) = 1 - \\operatorname {n e g l} (\\kappa). \\tag {54} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Proof. From Prop. D.11 by setting  <span class="math">K_{1}, K_{2} = \\Omega(\\kappa)</span>  and  <span class="math">K_{\\mathrm{cp}} = 2K_{1}K_{2}</span> .</p>

    <p class="text-gray-300">D.3.3 Many Probabilistic Pivots Imply One Combinatorial Pivot. The longest-header-chain rule  <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>  (Alg. 3) has a few useful properties. Intuitively, nodes using this rule</p>

    <p class="text-gray-300">(P1) process a BPO's block's content at most once, (P2) either process the most recent honest block, or fully utilize their capacity to process other blocks (i.e., do not stay idle), and (P3) prioritize blocks that were produced 'recently'.</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">(P1) holds by construction. (P2) holds because the scheduling policy <span class="math">\\mathcal{D}_{\\mathrm{long}}</span> is never idle, and will always process towards an honest block when it has processed all longer chains and there is capacity remaining. Moreover, we expect that in a secure execution, (P3) holds because the longest header chain cannot fork off too much from the longest processed chain of an honest node, otherwise it would imply a safety violation. More precisely, due to Lem. D.5, any longest header chain in any honest node’s view must extend the block produced in the most recent cpivot, and therefore blocks with the highest processing priority must have been produced after the most recent cpivot. If the adversary wants to prevent honest nodes from processing the block produced at a good index <span class="math">k</span>, so that <span class="math">G_{k}=1</span> but <span class="math">D_{k}=0</span>, then it can only “distract” them by providing <span class="math">\\widetilde{C}</span> blocks produced after the most recent cpivot (Prop. 4.7).</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proposition 4.7.</h6>

    <p class="text-gray-300">If <span class="math">G_{k}=1</span> and <span class="math">D_{k}=0</span>, then during slots <span class="math">[t_{k},t_{k}+\\nu]</span>, all honest nodes using the longest-header-chain scheduling policy process content of at least <span class="math">\\widetilde{C}</span> blocks that are produced in <span class="math">(i,k]</span>, where <span class="math">i&amp;lt;k</span> is the largest index such that <span class="math">\\mathrm{CPivot}(i)</span> (if such an <span class="math">i</span> does not exist, <span class="math">i=0</span>).</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In slot <span class="math">t_{k}</span>, there is exactly one block <span class="math">b</span> produced by an honest node, the block header is made public at the beginning of the slot, and is seen by all honest nodes within <span class="math">\\Delta_{\\mathrm{h}}</span> time. Thereafter, each node has enough time to process <span class="math">\\widetilde{C}</span> blocks during slots <span class="math">[t_{k},t_{k}+\\nu]</span>.</p>

    <p class="text-gray-300">Under the scheduling policy <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>, if <span class="math">D_{k}=0</span>, i.e. an honest node did not process content for the block <span class="math">b</span> before the end of slot <span class="math">t_{k}+\\nu</span>, then that honest node must process the content for at least <span class="math">\\widetilde{C}</span> blocks on chains longer than the height of the block <span class="math">b</span> or in the prefix of the block <span class="math">b</span>. Since honest nodes produce blocks extending their longest chain, <span class="math">b</span> extends <span class="math">\\mathrm{d}\\mathcal{C}_{p}(t_{k}-1)</span> for some <span class="math">p</span>. Let <span class="math">b^{<em>}</span> be the block produced in slot <span class="math">t_{i}</span> where <span class="math">\\mathrm{CPivot}(i)</span> (suppose <span class="math">i</span> exists). <span class="math">\\mathrm{CPivot}(i)\\implies Y_{i}=1</span>, therefore this block is unique, and also <span class="math">t_{k}&amp;gt;t_{i}+\\nu</span>. Due to Lem. D.5, any valid header chain longer than <span class="math">b</span> at time slot <span class="math">t_{k}</span> must contain <span class="math">b^{</em>}</span>. Therefore, the only blocks that are processed by an honest node during slots <span class="math">[t_{k},t_{k}+\\nu]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>must be produced after <span class="math">t_{i}</span> because they extend <span class="math">b^{*}</span>, and</li>

      <li>must be produced no later than <span class="math">t_{k}</span> because there are no blocks produced in <span class="math">(t_{k},t_{k}+\\nu]</span>.</li>

    </ol>

    <p class="text-gray-300">In case a cpivot <span class="math">i&amp;lt;k</span> does not exist, the claim is trivial. ∎</p>

    <p class="text-gray-300">Given the above properties of the scheduling policy, we now want to show that cpivots occur once in a while. Fig. 11 illustrates the key argument for this. To start, let us show that there is at least one cpivot in <span class="math">\\left(0,K_{\\mathrm{cp}}\\right]</span>. From Lem. D.12, there are many ppivots in <span class="math">\\left(0,K_{\\mathrm{cp}}\\right]</span>. If there were no cpivots in <span class="math">\\left(0,K_{\\mathrm{cp}}\\right]</span>, then the adversary must prevent each ppivot from turning into a cpivot. We know that in any interval around a ppivot, there are more good indices than bad indices (see top row in Fig. 11). In fact, good indices outnumber bad indices by a margin that increases linearly with the size of the interval (Prop. D.8). Therefore, for a ppivot to not be a cpivot, the adversary must prevent an honest node from processing the most recent honest block in several of these good indices (so that the corresponding <span class="math">G_{k}=1</span> indices have <span class="math">D_{k}=0</span>). Fig. 11 shows an example where the adversary prevented processing of the honest block in one good index, and as a result, two of the ppivots fail to become a cpivot. In Lem. D.13, through a combinatorial argument, we show that to prevent all of <span class="math">n</span> ppivots in <span class="math">\\left(0,K_{\\mathrm{cp}}\\right]</span> from becoming cpivots, the adversary must prevent processing of the honest block in at least <span class="math">n/4</span> good indices in <span class="math">\\left(0,2K_{\\mathrm{cp}}\\right]</span>. From Prop. 4.7, for each such index, the adversary must ‘spend’ at least <span class="math">\\widetilde{C}</span> blocks that the honest node processs. These blocks must come from a ‘budget’ that can contain at most all blocks mined during <span class="math">\\left(0,2K_{\\mathrm{cp}}\\right]</span>. If this ‘budget’ falls short of the number of blocks required to overthrow all cpivots, then there must be at least one cpivot in <span class="math">\\left(0,K_{\\mathrm{cp}}\\right]</span>.</p>

    <p class="text-gray-300">Next, we would like to show that there is at least one cpivot in <span class="math">\\left(mK_{\\mathrm{cp}},(m+1)K_{\\mathrm{cp}}\\right]</span> for all <span class="math">m\\geq 0</span> (where we just saw the base case <span class="math">m=0</span>). Here, one may be concerned that the adversary could save up many blocks from the past and attempt to make honest nodes process these blocks at a particular target slot <span class="math">t_{k}</span>. But given that one cpivot occurred in <span class="math">\\left((m-1)K_{\\mathrm{cp}},mK_{\\mathrm{cp}}\\right]</span>, Prop. 4.7 ensures that honest nodes will only process blocks that are produced after <span class="math">(m-1)K_{\\mathrm{cp}}</span>. This allows us to bound the ‘budget’ of blocks that the adversary can use to overthrow cpivots, and therefore show that there is at least one cpivot in <span class="math">\\left(mK_{\\mathrm{cp}},(m+1)K_{\\mathrm{cp}}\\right]</span>. This argument is formalized in Lem. D.17.</p>

    <p class="text-gray-300">Below, we first show the proof for the base case (i.e. for the interval <span class="math">\\left(0,K_{\\mathrm{cp}}\\right]</span>) to highlight the key techniques. Here, <span class="math">Q_{(\\cdot,\\cdot)}</span> is the total number of blocks mined in an interval (bounds the adversary’s block budget), and the expressions on the left in eqns. (73) and (74) are the minimum number of blocks the adversary needs to produce to ensure that there are no cpivots, in terms of the number of ppivots <span class="math">P_{(\\cdot,\\cdot)}</span> and number of good indices <span class="math">G_{(\\cdot,\\cdot)}</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma D.13.</h6>

    <p class="text-gray-300">If honest nodes use the scheduling policy <span class="math">\\mathcal{D}_{\\mathrm{long}}</span> and</p>

    <p class="text-gray-300"><span class="math">\\forall~{}(i,j]\\succeq K_{\\mathrm{cp}},i&lt;k_{\\mathrm{cp}}:\\quad\\widetilde{\\frac{c}{2}}\\left(G_{(i,j]}-\\overline{G}_{(i,j]}\\right)&gt;Q_{(0,j]},</span> (55) <span class="math">\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad</span> <span class="math">~{}\\text{</span>\\exists k_{1}^{<em>}\\in\\left(0,K_{\\mathrm{cp}}\\right]:<span class="math">~{}\\mathrm{CPivot}(k_{1}^{</em>}).</span></p>

    <p class="text-gray-300">Towards proving Lem. D.13, we show two simple corollaries of the cpivot conditions (Props. D.14 and D.15) and show that in any interval, good indices outnumber bad indices by at least the number of ppivots in that interval.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proposition D.14.</h6>

    <p class="text-gray-300"><span class="math">\\neg\\mathrm{CPivot}(k)\\qquad\\Longrightarrow\\qquad\\exists~{}(i,j]\\ni k:\\quad Y_{(i,j]}\\leq 0.</span> (57)</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From Def. D.3. ∎</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proposition D.15.</h6>

    <p class="text-gray-300">If <span class="math">Y_{(i,j]}\\leq 0</span>, then</p>

    <p class="text-gray-300"><span class="math">\\overline{D}_{(i,j]}\\geq D_{(i,j]},\\qquad G_{(i,j]}-D_{(i,j]}\\geq\\frac{1}{2}\\left(G_{(i,j]}-\\overline{G}_{(i,j]}\\right).</span> (58)</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We obtain eqn. (58) from the definition <span class="math">Y_{i}=D_{i}-\\overline{D}_{i}</span>. Then,</p>

    <p class="text-gray-300"><span class="math">G_{(i,j]}+\\overline{G}_{(i,j]}=D_{(i,j]}+\\overline{D}_{(i,j]}</span> (59) <span class="math">G_{(i,j]}+\\overline{G}_{(i,j]}\\geq 2D_{(i,j]}</span> (60) <span class="math">2G_{(i,j]}-2D_{(i,j]}\\geq G_{(i,j]}-\\overline{G}_{(i,j]}.</span> (61)</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proposition D.16.</h6>

    <p class="text-gray-300">If <span class="math">P_{(i,j]}&amp;gt;0</span>, then <span class="math">G_{(i,j]}-\\overline{G}_{(i,j]}\\geq P_{(i,j]}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">!<a href="img-24.jpeg">img-24.jpeg</a> Figure 18: Blue circles represent ppivots, red crosses represent indices with  <span class="math">G_{k} = 1</span>  and  <span class="math">D_{k} = 0</span> . (a) Given intervals  <span class="math">A, B, C</span>  all containing the 2nd blue circle from left, interval  <span class="math">C</span>  is redundant. (b) Given  <span class="math">n</span>  blue circles, the adversary needs at least  <span class="math">n/4</span>  red crosses to draw a set of intervals satisfying eqns. (62) and (63). Here is a placement of red crosses relative to blue circles that achieves the minimum number of red crosses.</p>

    <p class="text-gray-300">!<a href="img-25.jpeg">img-25.jpeg</a></p>

    <p class="text-gray-300">Proof. Let  <span class="math">n = P_{(i,j]}</span> . First, consider  <span class="math">n = 1</span> . There is exactly one ppivot  <span class="math">k \\in (i,j]</span> . From Def. D.2,  <span class="math">X_{(0,i]} &amp;lt; X_{(0,j]}</span> . Therefore,  <span class="math">X_{(i,j]} &amp;gt; 0</span> , hence  <span class="math">G_{(i,j]} - \\overline{G}_{(i,j]} \\geq 1</span> . For the general case, let  <span class="math">k_1, \\ldots, k_n</span>  be the ppivots in  <span class="math">(i,j]</span> . Then, we apply the  <span class="math">n = 1</span>  case on the disjoint intervals  <span class="math">(i,k_1]</span> ,  <span class="math">(k_1,k_2]</span> , ...,  <span class="math">(k_{n-1},j]</span>  and then sum up.</p>

    <p class="text-gray-300">PROOF OF LEM. D.13. Due to eqn. (56), there is at least one ppivot in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span>  (otherwise  <span class="math">P_{\\{0, K_{\\mathrm{cp}}\\}} = 0</span> ). Suppose for contradiction that there is no cpivot in  <span class="math">\\{0, K_{\\mathrm{cp}}\\}</span> . Since cpivots are also ppivots, it is enough to consider that none of the ppivots is a cpivot. Then around each ppivot, there must be at least one interval which violates the combinatorial pivot condition. Formally, there is a set of intervals  <span class="math">\\mathcal{I}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_ {I \\in \\mathcal {I}} I \\supseteq \\left\\{k \\in \\left(0, K _ {\\mathrm {c p}} \\right]: \\operatorname {P P i v o t} (k) \\right\\} \\tag {62}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall I \\in \\mathcal {I}: \\quad Y _ {I} \\leq 0 \\quad (\\text {b y P r o p . D . 1 4}). \\tag {63}</span></div>

    <p class="text-gray-300">Without loss of generality, each interval  <span class="math">I \\in \\mathcal{I}</span>  contains at least one ppivot (removing all intervals that do not contain a ppivot maintains eqns. (62) and (63)). Then if  <span class="math">(i,j] \\in \\mathcal{I}, i &amp;lt; K_{\\mathrm{cp}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, consider the large intervals with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq K_{\\mathrm{cp}}<span class="math"> . Consider indices  </span>k \\in I<span class="math">  for which  </span>G_{k} = 1<span class="math">  (good) but  </span>D_{k} = 0<span class="math">  (block not processed). From Prop. 4.7, for each such index, all honest nodes process  </span>\\widetilde{C}<span class="math">  blocks that are produced no later than  </span>t_{k}<span class="math"> . The number of indices  </span>k \\in I<span class="math">  with  </span>G_{k} = 1<span class="math">  and  </span>D_{k} = 0<span class="math">  is  </span>G_{I} - D_{I}<span class="math"> . For each such index, there must exist  </span>\\widetilde{C}<span class="math">  distinct blocks produced in or before the interval  </span>I<span class="math"> . Therefore, if  </span>I = (i,j]$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">Q _ {(0, j ]} \\geq \\widetilde {C} \\left(G _ {(i, j ]} - D _ {(i, j ]}\\right) \\tag {64}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\frac {\\widetilde {C}}{2} \\left(G _ {(i, j ]} - \\bar {G} _ {(i, j ]}\\right) \\quad (\\text {b y P r o p . D . 1 5}). \\tag {65}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This contradicts eqn. (55). Therefore, all intervals  <span class="math">I \\in \\mathcal{I}</span>  are small  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; K_{\\mathrm{cp}})<span class="math"> . Then for each  </span>I \\in \\mathcal{I}, I \\subset \\{0, 2K_{\\mathrm{cp}}\\}$ , Also,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">G _ {I} - D _ {I} \\geq \\frac {1}{2} \\left(G _ {I} - \\bar {G} _ {I}\\right) \\geq \\frac {1}{2} P _ {I} \\quad (\\text {b y P r o p s . D . 1 5 a n d D . 1 6}). \\tag {66}</span></div>

    <p class="text-gray-300">Consider the indices  <span class="math">k \\in \\{0, 2K_{\\mathrm{cp}}\\}</span>  with  <span class="math">G_k = 1</span>  and  <span class="math">D_k = 0</span> . Let  <span class="math">\\mathcal{I}_k = \\{I \\in \\mathcal{I} : k \\in I\\}</span>  be the set of intervals that contain  <span class="math">k</span> . Let  <span class="math">I_k^L</span>  be an interval in  <span class="math">\\mathcal{I}_k</span>  that stretches farthest to the left, and let  <span class="math">I_k^R</span>  be an interval that stretches farthest to the right (these may also be the same). Note that all other intervals in  <span class="math">\\mathcal{I}_k</span>  are contained in  <span class="math">I_k^L \\cup I_k^R</span> . Therefore, all intervals in  <span class="math">\\mathcal{I}_k</span>  except  <span class="math">I_k^L</span>  and  <span class="math">I_k^R</span>  can be removed from  <span class="math">\\mathcal{I}</span>  while maintaining eqns. (62) and (63) (see Fig. 18(a)). This process is repeated for all  <span class="math">k \\in \\{0, 2K_{\\mathrm{cp}}\\}</span>  with  <span class="math">G_k = 1</span>  and  <span class="math">D_k = 0</span> , so that in</p>

    <p class="text-gray-300">the resulting set  <span class="math">\\mathcal{I}</span> , each such index  <span class="math">k</span>  is contained in at most two intervals. Then,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {k \\in \\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}: G _ {k} = 1, D _ {k} = 0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {I} _ {k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_ {k \\in \\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}: G _ {k} = 1, D _ {k} = 0} 2 \\tag {67}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">= 2 \\left(G _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}} - D _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}}\\right). \\tag {68}</span></div>

    <p class="text-gray-300">This sum can be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {k \\in \\{0, 2 K _ {\\mathrm {c p}} \\}: G _ {k} = 1, D _ {k} = 0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {I} _ {k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sum_ {I \\in \\mathcal {I}} \\left(G _ {I} - D _ {I}\\right) \\tag {69}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\sum_ {I \\in \\mathcal {I}} \\frac {1}{2} P _ {I} \\geq \\frac {1}{2} P _ {\\left\\{0, K _ {\\mathrm {c p}} \\right\\}} \\quad (\\text {b y e q n . (6 2)}). \\tag {70}</span></div>

    <p class="text-gray-300">From eqns. (68) and (70),</p>

    <div class="my-4 text-center"><span class="math-block">G _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}} - D _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}} \\geq \\frac {1}{4} P _ {\\left\\{0, K _ {\\mathrm {c p}} \\right\\}}. \\tag {71}</span></div>

    <p class="text-gray-300">This can also be seen from Fig. 18(b). Finally, as shown before, for each  <span class="math">k</span>  with  <span class="math">G_{k} = 1</span>  and  <span class="math">D_{k} = 0</span> , all honest nodes process at least  <span class="math">\\widetilde{C}</span>  distinct blocks produced in or before index  <span class="math">k</span>  (Prop. 4.7). This gives</p>

    <div class="my-4 text-center"><span class="math-block">Q _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}} \\geq \\widetilde {C} \\left(G _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}} - D _ {\\left\\{0, 2 K _ {\\mathrm {c p}} \\right\\}}\\right) \\geq \\frac {\\widetilde {C}}{4} P _ {\\left\\{0, K _ {\\mathrm {c p}} \\right\\}} \\tag {72}</span></div>

    <p class="text-gray-300">which is a contradiction to eqn. (56).</p>

    <p class="text-gray-300">Lem. D.17 proves that at least one cpivot exists in successive intervals of  <span class="math">K_{\\mathrm{cp}}</span>  length. Lem. D.17 is proved by induction, where the base case is Lem. D.13.</p>

    <p class="text-gray-300">LEMMA D.17. If honest nodes use the scheduling policy  <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">\\forall (i, j ] \\geq K _ {\\mathrm {c p}}: \\quad \\frac {\\widetilde {C}}{2} \\left(G _ {(i, j ]} - \\bar {G} _ {(i, j ]}\\right) &amp;gt; Q _ {(i - 2 K _ {\\mathrm {c p}}, j ]}, \\tag {73}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall m \\geq 0: \\quad \\frac {\\widetilde {C}}{4} P _ {\\left\\{m K _ {\\mathrm {c p}}, (m + 1) K _ {\\mathrm {c p}} \\right\\}} &amp;gt; Q _ {\\left((m - 2) K _ {\\mathrm {c p}}, (m + 2) K _ {\\mathrm {c p}} \\right\\}}, \\tag {74}</span></div>

    <p class="text-gray-300">then  <span class="math">\\forall m\\geq 0:\\exists k_m^<em>\\in \\{mK_{\\mathrm{cp}},(m + 1)K_{\\mathrm{cp}}\\} :\\mathrm{CPivot}(k_m^</em>)</span></p>

    <p class="text-gray-300">Proof. This will be proved through induction. For the base case  <span class="math">(m = 0)</span> , Lem. D.13 shows that  <span class="math">\\exists k_{m}^{<em>} \\in \\{0, K_{\\mathrm{cp}}\\} : \\mathrm{CPivot}(k_{1}^{</em>})</span> .</p>

    <p class="text-gray-300">For  <span class="math">m \\geq 1</span> , assume that  <span class="math">\\exists k_{m-1}^<em> \\in \\{(m-1)K_{\\mathrm{cp}}, mK_{\\mathrm{cp}}\\}</span>  such that  <span class="math">\\mathrm{CPivot}(k_{m-1}^</em>)</span> . Now we want to show that  <span class="math">\\exists k_m^<em> \\in \\{mK_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}</span>  such that  <span class="math">\\mathrm{CPivot}(k_m^</em>)</span> . Suppose for contradiction that there is no cpivot in  <span class="math">\\{mK_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}</span> . As in the proof of Lem. D.13, there is a set of intervals  <span class="math">\\mathcal{I}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\bigcup_ {I \\in \\mathcal {I}} I \\supseteq \\left\\{k \\in \\left\\{m K _ {\\mathrm {c p}}, (m + 1) K _ {\\mathrm {c p}} \\right\\}: \\operatorname {P P i v o t} (k) \\right\\} \\tag {75}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall I \\in \\mathcal {I}: \\quad Y _ {I} \\leq 0. \\tag {76}</span></div>

    <p class="text-gray-300">Without loss of generality, each interval  <span class="math">I \\in \\mathcal{I}</span>  contains at least one ppivot. Then if  <span class="math">(i,j] \\in \\mathcal{I}, i &amp;lt; (m + 1)K_{\\mathrm{cp}}</span>  and  <span class="math">j &amp;gt; mK_{\\mathrm{cp}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, consider the large intervals with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq K_{\\mathrm{cp}}<span class="math"> . Consider indices  </span>k \\in I<span class="math">  for which  </span>G_k = 1<span class="math">  (good) but  </span>D_k = 0<span class="math">  (block not processed). From Prop. 4.7, for each such index  </span>k<span class="math"> , all honest nodes process  </span>\\widetilde{C}<span class="math">  blocks that are produced in the interval  </span>\\{k_{m-1}^*, k\\}<span class="math"> . The number of indices  </span>k \\in I<span class="math">  with  </span>G_k = 1<span class="math">  and  </span>D_k = 0<span class="math">  is exactly  </span>G_I - D_I<span class="math"> . For each such index, there must exist  </span>\\widetilde{C}<span class="math">  distinct blocks from distinct BPOs that are processed by honest nodes. Therefore if  </span>I = (i,j]$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">Q _ {\\left\\{k _ {m - 1} ^ {*}, j \\right\\}} \\geq \\widetilde {C} \\left(G _ {(i, j ]} - D _ {(i, j ]}\\right) \\tag {77}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\frac {\\widetilde {C}}{2} \\left(G _ {(i, j ]} - \\bar {G} _ {(i, j ]}\\right) \\quad (\\text {f r o m P r o p . D . 1 5}). \\tag {78}</span></div>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">But <span class="math">k_{m-1}^<em> &amp;gt; (m-1)K_{\\mathrm{cp}}</span> and <span class="math">i &amp;lt; (m+1)K_{\\mathrm{cp}}</span>. Therefore <span class="math">Q_{\\left(k_{m-1}^</em>, j\\right]} \\leq Q_{\\left(i-2K_{\\mathrm{cp}}, j\\right]}</span>. Then we have a contradiction to eqn. (73). Therefore all intervals <span class="math">I \\in \\mathcal{I}</span> are small ($</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; K_{\\mathrm{cp}}<span class="math">). Then for each </span>I \\in \\mathcal{I}<span class="math">, </span>I \\subset \\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}$. Also,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">G_I - D_I \\geq \\frac{1}{2} \\left(G_I - \\bar{G}_I\\right) \\geq \\frac{1}{2} P_I \\quad \\text{(Props. D.15 and D.16)} \\tag{79}</span></div>

    <p class="text-gray-300">Consider the indices <span class="math">k \\in \\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}</span> with <span class="math">G_k = 1</span> and <span class="math">D_k = 0</span>. Following the arguments in the proof of Lem. D.13, we can reduce the set <span class="math">\\mathcal{I}</span> so that in the resulting set <span class="math">\\mathcal{I}</span>, each such index <span class="math">k</span> is contained in at most two intervals. Then,</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{k \\in \\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}: G_k = 1, D_k = 0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\leq 2 \\left( G_{\\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} - D_{\\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} \\right). \\end{aligned} \\tag{80} $$</p>

    <p class="text-gray-300">This sum can be rewritten as</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{k \\in \\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}: G_k = 1, D_k = 0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tag{81} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\sum_{I \\in \\mathcal{I}} (G_I - D_I) \\tag{82} \\\\ \\geq \\sum_{I \\in \\mathcal{I}} \\frac{1}{2} P_I \\tag{83} \\\\ \\geq \\frac{1}{2} P_{(mK_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}]}. \\tag{84} \\end{aligned} $$</p>

    <p class="text-gray-300">Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} G_{\\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} - D_{\\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} \\\\ \\geq \\frac{1}{4} P_{(mK_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}]}. \\tag{85} \\end{aligned}</span></div>

    <p class="text-gray-300">Finally, for each <span class="math">k</span> with <span class="math">G_k = 1</span> and <span class="math">D_k = 0</span>, all honest nodes process at least <span class="math">\\widetilde{C}</span> distinct blocks produced in or before the most recent cpivot before <span class="math">(m-1)K_{\\mathrm{cp}}</span>. By induction assumption, we have a cpivot <span class="math">k_{m-2}^* \\in \\{(m-2)K_{\\mathrm{cp}}, (m-1)K_{\\mathrm{cp}}\\}</span>. This gives</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} Q_{\\{(m-2)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} \\\\ \\geq \\widetilde{C} \\left( G_{\\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} - D_{\\{(m-1)K_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}} \\right) \\tag{86} \\\\ \\geq \\frac{\\widetilde{C}}{4} P_{(mK_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}]} \\end{aligned} \\tag{87}</span></div>

    <p class="text-gray-300">which is a contradiction.</p>

    <p class="text-gray-300">Finally, using the fact that, with overwhelming probability, a constant fraction of indices are ppivots, we calculate the condition on the parameters <span class="math">\\rho, \\tau</span> in terms of <span class="math">\\nu, \\widetilde{C}</span> for which the conditions eqns. (73) and (74) in Lem. D.17 hold with overwhelming probability. Precisely, we show that, with overwhelming probability, for any index <span class="math">k</span> throughout the time horizon, there is at least one cpivot in the interval <span class="math">\\{k, k+2K_{\\mathrm{cp}}\\}</span>.</p>

    <p class="text-gray-300"><strong>LEMMA D.18.</strong> If <span class="math">\\frac{\\widetilde{C}}{16} \\frac{(2p_{ci} - 1)^2}{p_0} &amp;gt; 1</span>, then for <span class="math">K_{\\mathrm{cp}} = \\Theta(\\kappa^2)</span>, <span class="math">K_{\\mathrm{hrzn}} = \\mathrm{poly}(\\kappa)</span>, with overwhelming probability, for all <span class="math">k &amp;lt; K_{\\mathrm{hrzn}} - 2K_{\\mathrm{cp}}</span>, <span class="math">\\exists k^<em> \\in \\{k, k + 2K_{\\mathrm{cp}}\\} : \\mathrm{CPivot}(k^</em>)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Define the event <span class="math">\\mathcal{E}_1 = \\{\\forall (i,j] \\succeq K_{\\mathrm{cp}}: P_{(i,j]} &amp;gt; (1 - \\delta)p_{\\mathrm{ppivot}}(j - i)\\}</span>. Suppose that <span class="math">\\mathcal{E}_1</span> occurs, and <span class="math">\\frac{\\widetilde{C}}{16} p_{\\mathrm{ppivot}}(1 - \\delta) &amp;gt; 1</span> for some <span class="math">\\delta \\in (0,1)</span>. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\forall (i, j] \\succeq K_{\\mathrm{cp}}: \\quad \\frac{\\widetilde{C}}{4} P_{(i, j]} &amp;gt; \\frac{\\widetilde{C}}{4} (1 - \\delta) p_{\\mathrm{ppivot}}(j - i) \\tag{88} \\\\ &amp;gt; 4(j - i) \\tag{89} \\\\ \\stackrel{\\text{(a)}}{=} Q_{\\{i - 2K_{\\mathrm{cp}}, j + K_{\\mathrm{cp}}\\}} \\tag{90} \\end{aligned}</span></div>

    <p class="text-gray-300">where (a) is because as <span class="math">\\tau \\to 0</span>, each non-empty slot has exactly one BPO. This satisfies eqn. (74) in Lem. D.17. Further,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\widetilde{C}}{2} \\left( G_{(i, j]} - \\bar{G}_{(i, j]} \\right) \\geq \\frac{\\widetilde{C}}{2} P_{(i, j]} &amp;gt; 3(j - i) &amp;gt; Q_{\\{i - 2K_{\\mathrm{cp}}, j\\}} \\tag{91}</span></div>

    <p class="text-gray-300">which satisfies condition eqn. (73) in Lem. D.17. Therefore there is at least one cpivot in every interval of the form <span class="math">\\{mK_{\\mathrm{cp}}, (m+1)K_{\\mathrm{cp}}\\}</span>. It also follows that for all <span class="math">k</span>, there is at least one cpivot in the interval <span class="math">\\{k, k+2K_{\\mathrm{cp}}\\}</span>. By choosing <span class="math">K_{\\mathrm{cp}} = \\Omega(\\kappa^2)</span>, <span class="math">K_{\\mathrm{hrzn}} = \\mathrm{poly}(\\kappa)</span>, and using Lem. D.12 and a union bound, the probability of failure of <span class="math">\\mathcal{E}_1</span> is <span class="math">\\mathrm{negl}(\\kappa)</span>.</p>

    <p class="text-gray-300">While the analysis above is for the scheduling policy <span class="math">\\mathcal{D}_{\\mathrm{long}}</span>, the proofs only use properties (P1), (P2), (P3) and thus apply to several other simple scheduling policies. Another such scheduling policy is "process only blocks that are consistent with the node's confirmed chain". In this work, we did not adopt this rule because it would fail to recover from a network split, as demonstrated in the forking attack mentioned in App. B.1.</p>

    <h2 id="sec-63" class="text-2xl font-bold">D.4 Security of Proof-of-Work Nakamoto Consensus</h2>

    <p class="text-gray-300">In Lem. D.18, we showed that under the longest-header-chain scheduling policy, cpivots occur in every <span class="math">K_{\\mathrm{cp}}</span>-interval. This allows us, together with Lem. D.5 (cpivots stabilize), to prove safety and liveness of the protocol for a suitable confirmation depth <span class="math">k_{\\mathrm{conf}}</span>. Subsequently, we take <span class="math">\\tau \\to 0</span> and <span class="math">\\lambda \\triangleq \\rho / \\tau</span> in order to model PoW accurately. We then identify the values of <span class="math">\\lambda</span> for which given an adversary fraction <span class="math">\\beta</span>, the conditions required in Lem. D.17 for cpivots to occur hold with overwhelming probability. Finally, since <span class="math">\\widetilde{C}</span> was an analysis parameter chosen arbitrarily, we maximize over this parameter to find the best possible security-performance tradeoff (Thm. 4.10). The result is plotted for <span class="math">\\Delta_{\\mathrm{h}} \\approx 0</span> (reasonable approximation for large block sizes) in Fig. 1.</p>

    <p class="text-gray-300"><strong>THEOREM 4.10.</strong> For all <span class="math">\\beta &amp;lt; 1/2</span>, <span class="math">\\lambda &amp;gt; 0</span>, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda &amp;lt; \\max_{\\widetilde{C}} \\frac{1}{\\Delta_{\\mathrm{h}} + \\widetilde{C}/C} \\ln \\left( \\frac{2(1 - \\beta) \\widetilde{C}}{\\widetilde{C} + 4 + \\sqrt{8\\widetilde{C} + 16}} \\right), \\tag{3}</span></div>

    <p class="text-gray-300">the PoW Nakamoto consensus protocol with the longest-header-chain scheduling policy, <span class="math">\\tau \\to 0</span>, <span class="math">\\rho = \\lambda \\tau</span>, and <span class="math">k_{\\mathrm{conf}} = \\Theta(\\kappa^2)</span> is secure with transaction rate <span class="math">(\\frac{1}{2} - \\beta)\\lambda</span>, confirmation latency <span class="math">\\Theta(\\kappa^2)</span> over a time horizon of <span class="math">T_{\\mathrm{hrzn}} = \\mathrm{poly}(\\kappa)</span>.</p>

    <p class="text-gray-300">For PoW, we take <span class="math">\\tau \\to 0</span>, and we would like to express parameters such as mining rate, confirmation latency, and execution time horizon in terms of real-time rather than the fictitious slots or indices. We use Prop. D.19 to bridge from indices to units of real-time, which uses a Poisson tail bound to show that the inter-arrival time between BPOs cannot be too large or too small.</p>

    <p class="text-gray-300">Nakamoto Consensus under Bounded Processing Capacity</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">PROPOSITION D.19.</p>

    <div class="my-4 text-center"><span class="math-block">\\forall k, K \\in \\mathbb {N} \\colon \\Pr \\left[ \\tau \\left(t _ {k + K} - t _ {k}\\right) \\geq \\frac {K}{\\lambda (1 - \\delta)} \\right] \\leq e ^ {\\frac {- K \\beta^ {2}}{\\lambda (1 + \\delta)}}, \\tag {92}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\tau \\left(t _ {k + K} - t _ {k}\\right) \\leq \\frac {K}{\\lambda (1 + \\delta)} \\right] \\leq e ^ {\\frac {- K \\beta^ {2}}{\\lambda (1 + \\delta)}}. \\tag {93}</span></div>

    <p class="text-gray-300">Proof. This results from a Poisson tail bound [14] for the number of BPOs in real time  <span class="math">K / \\lambda</span> , and noting that non-empty slots have exactly one BPO for  <span class="math">\\tau \\to 0</span> .</p>

    <p class="text-gray-300">To prove Thm. 4.10, we recall that there is at least one cpivot in the interval  <span class="math">\\{k,k + 2K_{\\mathrm{cp}}\\}</span>  (Lem. D.18). Given this, we prove safety and liveness of PoW NC in Lem. D.20. Finally, in Thm. 4.10, we calculate for given  <span class="math">\\beta, C, \\Delta_{\\mathrm{h}}</span> , the protocol parameters  <span class="math">\\rho, \\tau</span>  for which PoW NC is secure. In doing so, since  <span class="math">\\widetilde{C}</span>  is just an analysis parameter, we optimize over  <span class="math">\\widetilde{C}</span>  to find the maximum  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">LEMMA D.20. If for some  <span class="math">K_{\\mathrm{cp}} &amp;gt; 0</span></p>

    <div class="my-4 text-center"><span class="math-block">\\forall k: \\exists k ^ {*} \\in (k, k + 2 K _ {\\mathrm {c p}} ]: \\operatorname {C P i v o t} \\left(k ^ {*}\\right), \\tag {94}</span></div>

    <p class="text-gray-300">then the PoW Nakamoto consensus protocol  <span class="math">\\Pi^{\\rho, \\tau, k_{\\mathrm{conf}}}</span>  with  <span class="math">k_{\\mathrm{conf}} = 2K_{\\mathrm{cp}} + 1</span>  satisfies safety. Further, if the environment is  <span class="math">(\\theta, T_{\\mathrm{txlim}})</span> -tx-limited with  <span class="math">\\theta = (1 + \\delta)\\left(\\frac{1}{2} - \\frac{1 - e^{-\\beta\\rho}}{1 - e^{-\\rho}} (1 + \\delta)\\right)\\lambda \\tau</span>  and  <span class="math">T_{\\mathrm{txlim}} = \\frac{2K_{\\mathrm{cp}}}{\\lambda\\tau(1 + \\delta)}</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in \\mathbb {N}, K \\geq K _ {\\mathrm {c p}}: \\quad \\frac {K}{\\lambda \\tau (1 + \\delta)} &amp;lt;   t _ {k + K} - t _ {k} &amp;lt;   \\frac {K}{\\lambda \\tau (1 - \\delta)}, \\tag {95}</span></div>

    <p class="text-gray-300">then it also satisfies liveness with  <span class="math">T_{\\mathrm{live}} = \\max \\left\\{T_{\\mathrm{txlim}}, \\frac{2K_{\\mathrm{cp}}}{\\lambda\\tau(1 - \\delta)}\\right\\} + \\frac{4K_{\\mathrm{cp}} + 2}{\\lambda\\tau(1 - \\delta)}</span> .</p>

    <p class="text-gray-300">Proof. Safety: For an arbitrary slot  <span class="math">t</span> , let  <span class="math">k</span>  be the largest index such that  <span class="math">t_k \\leq t</span> . From eqn. (94), every interval of  <span class="math">2K_{\\mathrm{cp}}</span>  indices contains at least one cpivot. Therefore, there exists  <span class="math">k^<em> \\in (k - 2K_{\\mathrm{cp}} - 1, k - 1]</span>  such that  <span class="math">\\mathrm{CPivot}(k^</em>)</span> . Let  <span class="math">b^<em></span>  be the block from index  <span class="math">k^</em></span> . Due to Lem. D.5, for all honest nodes  <span class="math">p, q</span>  and  <span class="math">t&#x27; \\geq t</span> ,  <span class="math">b^<em> \\in \\mathrm{d}\\mathcal{C}_p(t)</span>  and  <span class="math">b^</em> \\in \\mathrm{d}\\mathcal{C}_q(t&#x27;)</span> . But  <span class="math">k^<em> \\geq k - k_{\\mathrm{conf}}</span> , so the block  <span class="math">b^</em></span>  cannot be  <span class="math">k_{\\mathrm{conf}}</span> -deep in any chain at slot  <span class="math">t</span> . Therefore,  <span class="math">\\mathrm{LOG}_p^t</span>  is a prefix of  <span class="math">b^*</span>  which in turn is a prefix of  <span class="math">\\mathrm{d}\\mathcal{C}_q(t&#x27;)</span> . We can thus conclude that either  <span class="math">\\mathrm{LOG}_p^t \\preceq \\mathrm{LOG}_q^{t&#x27;}</span>  or  <span class="math">\\mathrm{LOG}_q^{t&#x27;} \\preceq \\mathrm{LOG}_p^t</span> . Therefore, safety holds.</p>

    <p class="text-gray-300">For an arbitrary slot  <span class="math">t</span> , let  <span class="math">k</span>  be the largest index such that  <span class="math">t_k \\leq t</span> . We will first prove that all transactions received in slots  <span class="math">t - T_{\\mathrm{txlim}}</span>  to  <span class="math">t</span> , which are of total size at most  <span class="math">\\theta T_{\\mathrm{txlim}}</span>  as per the tx-limited environment, will be added to the longest processed chains of all nodes by the slot corresponding to index  <span class="math">k + 2K_{\\mathrm{cp}}</span> . Let  <span class="math">K_{\\mathrm{txlim}} = \\max \\{2K_{\\mathrm{cp}}, \\lambda \\tau (1 + \\delta)T_{\\mathrm{txlim}}\\}</span> . We know that there exists  <span class="math">k^<em> \\in (k, k + 2K_{\\mathrm{txlim}}]</span>  such that  <span class="math">\\mathrm{CPivot}(k^</em>)</span> . Since  <span class="math">k^<em></span>  is a cpivot, for all  <span class="math">(i, j] \\ni k^</em></span> ,  <span class="math">D_{\\{i, j\\}} &amp;gt; \\overline{D}_{\\{i, j\\}}</span>  (Def. D.3 and eqn. (10)), and hence  <span class="math">D_{\\{i, j\\}} &amp;gt; \\frac{j - i}{2}</span> . Particularly,</p>

    <div class="my-4 text-center"><span class="math-block">\\Longrightarrow D _ {(k, k + K _ {\\mathrm {t x l i m}} - 1 ]} &amp;gt; \\frac {K _ {\\mathrm {t x l i m}} - 1}{2}. \\tag {96}</span></div>

    <p class="text-gray-300">Then from Prop. D.6,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} L _ {\\min } \\left(t _ {k + K _ {\\mathrm {t x l i m}} - 1} + v\\right) - L _ {\\min } \\left(t _ {k + 1} - 1\\right) \\geq D _ {\\left\\{k, k + K _ {\\mathrm {t x l i m}} - 1 \\right\\}} \\\\ \\geq \\frac {K _ {\\mathrm {t x l i m}}}{2}. \\tag {97} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This means that the  <span class="math">K_{\\mathrm{txlim}} / 2</span>  last blocks in any node's longest processed chain at slot  <span class="math">t_{k + K_{\\mathrm{txlim}} - 1 + \\nu}</span>  are from the indices  <span class="math">(k, k + K_{\\mathrm{txlim}} - 1]</span> . Among these, the number of blocks produced by the adversary can be, by a concentration bound, at most  <span class="math">\\frac{1 - e^{-\\beta\\rho}}{1 - e^{-\\rho}} (1 + \\delta)K_{\\mathrm{txlim}}</span> . Therefore, at least  <span class="math">\\left(\\frac{1}{2} - \\frac{1 - e^{-\\beta\\rho}}{1 - e^{-\\rho}} (1 + \\delta)\\right)K_{\\mathrm{txlim}}</span>  blocks are produced by honest nodes. The cumulative size of pending transactions is at most  <span class="math">\\theta T_{\\mathrm{txlim}}</span> , which fits in these honest blocks. Finally, we use Prop. D.6 again to show:</p>

    <div class="my-4 text-center"><span class="math-block">L _ {\\min } \\left(t _ {k + K _ {\\mathrm {t x l i m}} + 2 k _ {\\mathrm {c o n f}} - 1} + v\\right) - L _ {\\min } \\left(t _ {k + 2 k _ {\\mathrm {c o n f}} + 1} - 1\\right) \\geq k _ {\\mathrm {c o n f}}. \\tag {98}</span></div>

    <p class="text-gray-300">Thus, the newly added transactions are  <span class="math">k_{\\mathrm{conf}}</span> -deep, hence confirmed, by all nodes by index  <span class="math">k + 2K_{\\mathrm{cp}} + 2k_{\\mathrm{conf}}</span> . Finally, with eqn. (95),</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t _ {k + K _ {\\mathrm {t x l i m}} + 2 k _ {\\mathrm {c o n f}} - 1} + v - t \\leq t _ {k + K _ {\\mathrm {t x l i m}} + 4 K _ {\\mathrm {c p}} + 1} + v - t _ {k} \\\\ \\leq t _ {k + 6 K _ {\\mathrm {c p}} + 2} - t _ {k} \\\\ &amp;lt;   \\frac {K _ {\\mathrm {t x l i m}} + 4 K _ {\\mathrm {c p}} + 2}{\\lambda \\tau (1 - \\delta)}. \\tag {99} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore,  <span class="math">\\mathrm{tx} \\in \\mathrm{LOG}_p^{t&#x27;}</span>  for all  <span class="math">t&#x27; \\geq t + T_{\\mathrm{live}}</span> .</p>

    <p class="text-gray-300">PROOF OF THM. 4.10. From Lem. D.18, assuming</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\widetilde {C}}{1 6} \\frac {(2 p _ {\\mathrm {G}} - 1) ^ {2}}{p _ {\\mathrm {G}}} (1 - \\delta) &amp;gt; 1, \\tag {100}</span></div>

    <p class="text-gray-300">and from a union bound over horizon  <span class="math">K_{\\mathrm{hrzn}} = \\mathrm{poly}(\\kappa)</span>  on the result of Prop. D.19, the conditions required for Lem. D.20 are satisfied with overwhelming probability. Then Lem. D.20 guarantees safety and liveness with  <span class="math">k_{\\mathrm{conf}} = 2K_{\\mathrm{cp}} = \\Theta (\\kappa^2)</span>  and  <span class="math">T_{\\mathrm{live}} = \\frac{6K_{\\mathrm{cp}} + 2}{\\lambda\\tau(1 - \\delta)} = \\Theta (\\kappa^2)</span> .</p>

    <p class="text-gray-300">Indices are mapped to real time as  <span class="math">T_{\\mathrm{live}}^{\\mathrm{real}} \\triangleq T_{\\mathrm{live}}\\tau</span> . Further, the event  <span class="math">\\{\\tau t_{K_{\\mathrm{hrzn}}} &amp;gt; \\frac{K_{\\mathrm{hrzn}}}{\\lambda(1 + \\delta)}\\}</span>  also occurs except with negligible probability (Prop. D.19), and therefore the time horizon  <span class="math">K_{\\mathrm{hrzn}}</span>  indices corresponds to at least a time horizon of  <span class="math">T_{\\mathrm{hrzn}} \\triangleq \\frac{K_{\\mathrm{hrzn}}}{\\lambda(1 + \\delta)}</span>  real-time units.</p>

    <p class="text-gray-300">Finally, we take the limit  <span class="math">\\tau \\to 0</span> . With the relations  <span class="math">\\lambda = \\rho / \\tau</span> ,  <span class="math">(\\nu + 1)\\tau \\geq \\Delta_{\\mathrm{h}} + \\widetilde{C} / C</span> , and  <span class="math">p_{\\mathrm{ppivot}} = (2p_{\\mathrm{G}} - 1)^2 / p_{\\mathrm{G}}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">p _ {\\mathrm {G}} = (1 - \\beta) \\frac {\\rho e ^ {- \\rho (\\nu + 1)}}{1 - e ^ {- \\rho}} \\rightarrow (1 - \\beta) e ^ {- \\lambda \\left(\\Delta_ {\\mathrm {h}} + \\widetilde {C} / C\\right)}. \\tag {101}</span></div>

    <p class="text-gray-300">Moreover, the value of  <span class="math">\\theta</span>  from Lem. D.20 converges to  <span class="math">(1 + \\delta)(\\frac{1}{2} - \\beta (1 + \\delta))\\lambda</span>  in real-time units.</p>

    <p class="text-gray-300">Note that  <span class="math">\\widetilde{C}</span>  is an analysis parameter whose value is arbitrary. To find the maximum block production rate  <span class="math">\\lambda</span>  that the protocol can achieve, we optimize over  <span class="math">\\widetilde{C}</span> . To find the maximum achievable  <span class="math">\\lambda</span> , we can take  <span class="math">\\delta \\rightarrow 0</span>  as we can increase the latency through increasing  <span class="math">K_{\\mathrm{cp}}</span>  to still satisfy the error bounds. Maximizing over  <span class="math">\\widetilde{C}</span>  from eqns. (100) and (101) gives the resulting threshold.</p>

    <p class="text-gray-300">Details of the PoS-based block production and verification are abstracted through an idealized functionality  <span class="math">\\mathcal{T}_{\\mathrm{hdtree}}^{\\mathrm{PoS},\\rho ,\\tau}</span>  whose pseudocode is provided in Alg. 2 (cf. Alg. 2, [52, Fig. 2], [48, Alg. 3]).</p>

    <p class="text-gray-300">As in PoW, each node can make one block production attempt per slot that will be successful with probability  <span class="math">\\rho / N</span> , independently</p>

    <p class="text-gray-300">CCS '24, October 14-18, 2024, Salt Lake City, UT, USA</p>

    <p class="text-gray-300">Lucianna Kiffer, Joachim Neu, Srivatsan Sridhar, Aviv Zohar, and David Tse</p>

    <p class="text-gray-300">Algorithm 4 Idealized functionality  <span class="math">\\mathcal{F}_{\\mathrm{bdttree}}^{\\mathrm{PoS},\\rho ,\\tau}</span>  block production lottery and header chain structure for PoS (helper functions: App. C.2) 1:  <span class="math">\\triangleright</span>  out(genesisC, numNodes) and verify(C) same as in Alg. 2 2: on isLeader(P, t) from  <span class="math">\\mathcal{A}</span>  (only for adversarial node P) or  <span class="math">\\mathcal{F}_{\\mathrm{bdttree}}^{\\mathrm{PoS},\\rho ,\\tau}</span> 3:  <span class="math">\\triangleright</span>  Abstraction of proof-of-stake lottery each node is chosen leader in each slot with probability  <span class="math">\\rho /N</span>  independently of other nodes and slots 4: if lottery[P, t] =  <span class="math">\\bot</span> 5: lottery[P, t]  <span class="math">\\triangleright</span>  (true with probability  <span class="math">\\rho /N</span> , else false) 6: return lottery[P, t] 7: on EXTEND(t', C, txs) from  <span class="math">\\mathcal{A}</span>  (only for adversarial node P) or  <span class="math">\\mathcal{F}_{\\mathrm{bdttree}}^{\\mathrm{PoS},\\rho ,\\tau}</span> 8:  <span class="math">\\triangleright</span>  New header chain is valid if parent chain C is valid, P is leader for slot t', and t' is later than the tip of C and is not in the future 9: if (C ∈ T) ∧  <span class="math">\\mathcal{F}_{\\mathrm{bdttree}}^{\\mathrm{PoS},\\rho ,\\tau}</span> , isLeader(P, t') ∧ (C.time &lt; t' ≤ t) 10:  <span class="math">\\triangleright</span>  Produce a new block header extending C 11: C' ← CS newBlock(time: t', node: P, txsHash: Hash(txs)) 12: T ← T ∪ {C' }  <span class="math">\\triangleright</span>  Register new header chain in header tree 13: return C' 14: return  <span class="math">\\bot</span> 15: on EXTEND(C, txs) from node P (possibly adversarial) at slot t 16: return  <span class="math">\\mathcal{F}_{\\mathrm{bdttree}}^{\\mathrm{PoS},\\rho ,\\tau}</span> :EXTEND(t, C, txs)</p>

    <p class="text-gray-300">of other nodes and slots (Alg. 4, l. 5) <span class="math">^{11}</span> , modeling uniform stake. In PoS, however, (even past) block production opportunities can be 'reused' to produce multiple blocks with different parents and/or content, i.e., to equivocate (Alg. 4, ll. 2 and 7).</p>`;
---

<BaseLayout title="Nakamoto Consensus under Bounded Processing Capacity (2023/381)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/381
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
