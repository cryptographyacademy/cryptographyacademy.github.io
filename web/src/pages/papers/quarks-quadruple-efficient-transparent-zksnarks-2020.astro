---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1275';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Quarks: Quadruple-efficient transparent zkSNARKs';
const AUTHORS_HTML = 'Srinath Setty, Jonathan Lee';

const CONTENT = `    <p class="text-gray-300">Srinath Setty <em>Microsoft Research</em> Jonathan Lee <em>Microsoft Research</em></p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We introduce Xiphos and Kopis, new transparent zero-knowledge succinct non-interactive arguments of knowledge (zkSNARKs) for R1CS. They do not require a trusted setup, and their security relies on the standard SXDH problem. They achieve non-interactivity in the random oracle model using the Fiat-Shamir transform. Unlike prior transparent zkSNARKs, which support either a fast prover, short proofs, or quick verification, our work is the first to simultaneously achieve all three properties (both asymptotically and concretely) and in addition an inexpensive setup phase, thereby providing the first <em>quadruple-efficient</em> transparent zkSNARKs (<em>Quarks</em>).</p>

    <p class="text-gray-300">Under both schemes, for an R1CS instance of size <span class="math">n</span> and security parameter <span class="math">\\lambda</span>, the prover incurs <span class="math">O_{\\lambda}(n)</span> costs to produce a proof of size <span class="math">O_{\\lambda}(\\log n)</span>. In Xiphos, verification time is <span class="math">O_{\\lambda}(\\log n)</span>, and in Kopis it is <span class="math">O_{\\lambda}(\\sqrt{n})</span>. In terms of concrete efficiency, compared to prior state-of-the-art transparent zkSNARKs, Xiphos offers the fastest verification; its proof sizes are competitive with those of SuperSonic <em>[EURO-CRYPT 2020]</em>, a prior transparent SNARK with the shortest proofs in the literature. Xiphos’s prover is fast: its prover time is <span class="math">\\approx</span>3.8<span class="math">\\times</span> of Spartan <em>[CRYPTO 2020]</em>, a prior transparent zkSNARK with the fastest prover in the literature, and is 376<span class="math">\\times</span> faster than SuperSonic. Kopis, at the cost of increased verification time (which is still concretely faster than SuperSonic), shortens Xiphos’s proof sizes further, thereby producing proofs shorter than SuperSonic. Xiphos and Kopis incur 10–10,000<span class="math">\\times</span> lower preprocessing costs for the verifier in the setup phase depending on the baseline. Finally, a byproduct of Kopis is Lakonia, a NIZK for R1CS with <span class="math">O_{\\lambda}(\\log n)</span>-sized proofs, which provides an alternative to Bulletproofs <em>[S&P 2018]</em> with over an order of magnitude faster proving and verification times.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero-knowledge SNARKs (zkSNARKs) <em>[24, 43]</em> for NP is a primitive that enables a <em>prover</em> to prove to a <em>verifier</em> the knowledge of a satisfying witness <span class="math">w</span> to an NP statement by producing a proof <span class="math">\\pi</span> such that the proof is both zero-knowledge <em>[45]</em> and succinct. There are two forms of succinctness: the size of a proof and the time to verify a proof are both sub-linear in the size of the NP statement. Because of these properties, zkSNARKs is a core building block for various forms of delegation of computation for privacy and/or scalability <em>[3, 17, 27, 28, 37, 51, 53, 59, 62, 63]</em>. Given significant interest, constructing zkSNARKs is an active area of research, with a flurry of recent work to improve asymptotic and concrete efficiency.</p>

    <p class="text-gray-300">There are many approaches to construct zkSNARKs, starting with the works of Kilian <em>[50]</em> and Micali <em>[58]</em>. These works rely on short PCPs <em>[12, 13, 14, 18, 22, 23]</em>, which remain too expensive to be used in practice. A seminal work in this area is GGPR <em>[42]</em>,</p>

    <p class="text-gray-300">*Current affiliation: Nanotronics Imaging. Work done while at Microsoft Research.</p>

    <p class="text-gray-300">which provides zkSNARKs for R1CS with near-optimal asymptotics and good constants. A major problem with state-of-the-art zkSNARKs <em>[19, 21, 46, 60]</em> is the requirement of a trusted setup, where a trusted entity (or a group of entities with at least one honest entity) must choose a trapdoor to create public parameters. Furthermore, the trapdoor must be kept secret to ensure soundness.</p>

    <p class="text-gray-300">This problem was recently addressed by Spartan <em>[61]</em>, a transparent zkSNARK for R1CS. Unlike its predecessors, Spartan does not give up succinct verification <em>[11, 20, 31]</em> nor sacrifices generality by placing restrictions on the types of NP statements supported <em>[16, 69]</em>. Furthermore, Spartan requires only a transparent setup (e.g., choosing a set of random group elements or a collision-resistant hash function). To achieve succinct verification, the verifier, in a preprocessing step, creates a <em>computation commitment</em>, which is a succinct cryptographic commitment to the structure of an NP statement (e.g., the description of a circuit) without requiring secret trapdoors. The preprocessing step incurs time that is at least linear in the size of the statement, but this cost is amortized over all future verification of proofs for statements with the same structure, an amortization property similar to prior zkSNARKs with trusted setup <em>[42, 46]</em>. Following Spartan, Fractal <em>[35]</em> and SuperSonic <em>[29]</em> also employ computation commitments to achieve succinct verification without a trusted setup. Achieving sub-linear verification costs via computation commitments is also referred to as leveraging holography <em>[34, 35]</em>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Limitations of existing transparent zkSNARKs</h3>

    <p class="text-gray-300">Existing transparent zkSNARKs support either a fast prover, short proofs, or quick verification, but not all three properties simultaneously. Also, existing schemes incur high preprocessing costs to create computation commitments. Note that when we refer to “fast”, “short”, ”quick”, or “high”, we refer to both asymptotic efficiency and concrete efficiency (we make these terms more precise below). Furthermore, our focus here is on zkSNARKs for general computations without assuming uniformity or other structure.</p>

    <p class="text-gray-300">(1) Trade-offs among a fast prover, short proofs, and quick verification.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Spartan <em>[61]</em> offers the best asymptotics for the prover (Figure 1). Concretely, it provides the fastest prover in the literature (Figure 2). Furthermore, Spartan relies only on the well-studied DLOG problem. Unfortunately, the proofs are <span class="math">O(\\sqrt{n})</span> group elements and the verifier must perform <span class="math">O(\\sqrt{n})</span> exponentiations, where <span class="math">n</span> is the size of the NP statement. For R1CS statements with <span class="math">2^{20}</span> constraints, Spartan’s proofs are <span class="math">\\approx</span>142 KB and proof verification takes <span class="math">\\approx</span>135 ms.</li>

      <li>SuperSonic <em>[29]</em> offers the best asymptotics for the verifier and proof sizes (Figure 1), relying on groups where the Strong RSA assumption <em>[15, 41]</em> and the recently introduced Adaptive Root Assumption <em>[26, 70]</em> hold (e.g., ideal class groups of imaginary quadratic fields). Concretely, for a <span class="math">2^{20}</span>-sized R1CS statement, the estimated proof sizes are <span class="math">\\approx</span>48 KB. Unfortunately, the SuperSonic prover must perform <span class="math">O(n\\log n)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assistant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">encoder</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan DL</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">log n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">log n GU</td>

            <td class="px-3 py-2 border-b border-gray-700">sRSA + ARA</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal</td>

            <td class="px-3 py-2 border-b border-gray-700">λ · n log n F</td>

            <td class="px-3 py-2 border-b border-gray-700">λ · log2 n F</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">λ · n log n F</td>

            <td class="px-3 py-2 border-b border-gray-700">λ · log2 n F</td>

            <td class="px-3 py-2 border-b border-gray-700">CRHF</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G2</td>

            <td class="px-3 py-2 border-b border-gray-700">SXDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">SXDH</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 1—Asymptotic efficiency of Kopis and Xiphos.  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_{\\mathrm{T}})</span>  refers to groups in a bilinear group. Spartan only requires a group where DLOG is hard, so  <span class="math">\\mathbb{G}_1</span>  could be ristretto255.  <span class="math">\\mathbb{G}_{\\mathrm{U}}</span>  refers to groups where sRSA and ARA hold. We depict the number of exponentations needed in these groups. For  <span class="math">\\mathbb{F}</span>  we depict the number of field multiplications.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof size (KB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assistant (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">encoder (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier (ms)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan DL</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">142</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic</td>

            <td class="px-3 py-2 border-b border-gray-700">63,700</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">17,900</td>

            <td class="px-3 py-2 border-b border-gray-700">2,570</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal</td>

            <td class="px-3 py-2 border-b border-gray-700">864</td>

            <td class="px-3 py-2 border-b border-gray-700">2,500</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">456</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">97</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">390</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos</td>

            <td class="px-3 py-2 border-b border-gray-700">169</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 2—Concrete efficiency of Kopis and Xiphos for  <span class="math">n = 2^{20}</span> . The costs for all schemes were measured by running their implementations on the same hardware platform (§9), with one exception. For SuperSonic, we estimate its costs using the cost model provided by the authors augmented with our microbenchmarks of class group operations using the ANTIC library [1]. The reported costs for SuperSonic assume the use of a CRS consisting of  <span class="math">n</span>  elements of  <span class="math">\\mathbb{G}_{\\mathrm{U}}</span>  [30]. Using an  <span class="math">O_{\\lambda}(1)</span> -sized CRS, as in the original work [29], the encoder runs in time  <span class="math">n \\log n \\mathbb{G}_{\\mathrm{U}}</span>  asymptotically and both the prover and encoder take  <span class="math">\\approx 600,000</span>  s longer for  <span class="math">n = 2^{20}</span> .</p>

    <p class="text-gray-300">exponentiations in a class group, where each operation is  <span class="math">\\approx 800\\times</span>  more expensive than in a group where DLOG is hard. Thus, SuperSonic's prover is slower than Spartan's prover, both asymptotically and concretely. Concretely, for  <span class="math">n = 2^{20}</span> , SuperSonic is  <span class="math">&amp;gt;1</span> ,  <span class="math">700\\times</span>  slower than Spartan.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fractal [35] does not offer short proofs nor a fast prover. Concretely, for an R1CS instance with  <span class="math">2^{18}</span>  constraints, Fractal's prover is  <span class="math">\\approx 18 \\times</span>  slower than Spartan, and it produces proofs of size  <span class="math">\\approx 2.3\\mathrm{MB}</span>  and takes  <span class="math">\\approx 205\\mathrm{ms}</span>  to verify.</li>

    </ul>

    <p class="text-gray-300">(2) High preprocessing costs. Besides the above limitations, the verifier in all three prior schemes incurs  <span class="math">\\Omega(n)</span>  cryptographic operations (see the "encoder" column in Figure 1) to create a computation commitment. This cost is unavoidable for R1CS instances without structure: the verifier must at least preprocess the structure of the statement before verifying a proof. But, it is desirable to make the preprocessing concretely fast.</p>

    <p class="text-gray-300">Remark 1.1. Unlike other zkSNARKs discussed above, Fractal offers plausible post</p>

    <p class="text-gray-300">quantum security. Unfortunately, it does not offer short proofs. Proving is memory-intensive and is concretely expensive (§9). Designing concretely-efficient post-quantum transparent zkSNARKs remains an open problem.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Remark 1.2.</h6>

    <p class="text-gray-300">In the above exposition (and in the rest of the paper), by “Spartan”, we refer to a specific member of the Spartan family of zkSNARKs, called <span class="math">\\text{Spartan}_{\\text{\\tiny{DK}}}</span>. The family has two additional transparent zkSNARKs that can produce <span class="math">O_{\\lambda}(\\log^{2}n)</span>-sized proofs with <span class="math">O_{\\lambda}(\\log^{2}n)</span> verification times, but they are not experimentally evaluated. From our estimates, one of them, <span class="math">\\text{Spartan}_{\\text{\\tiny{CL}}}</span>, incurs prover times analogous to SuperSonic, and another one, <span class="math">\\text{Spartan}_{\\text{\\tiny{RO}}}</span>, produces proofs as big as Fractal, so they suffer from the limitations listed for SuperSonic and Fractal.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 A new goal: Quadruple-efficient transparent zkSNARKs (Quarks)</h3>

    <p class="text-gray-300">To address the aforementioned problems with existing transparent zkSNARKs, we desire zkSNARKs with the following asymptotic and concrete efficiency characteristics. We refer to zkSNARKs that satisfy all the following four properties as Quarks.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A fast prover: The prover should run in time <span class="math">O_{\\lambda}(n)</span>, with a small constant to achieve concrete performance analogous to Spartan.</li>

      <li>Short proofs: The proof length should be <span class="math">O_{\\lambda}(\\log n)</span>, with a small constant to achieve proof sizes similar to SuperSonic <em>[29]</em>.</li>

      <li>Quick verification: The verifier’s time to verify a proof should be <span class="math">O_{\\lambda}(\\log n)</span>, with a small constant to achieve verification times similar to SuperSonic <em>[29]</em>.</li>

      <li>Low preprocessing costs: The cost to the verifier to create a computation commitment to an NP statement’s structure should be <span class="math">O(n)</span>, with small constants such that the concrete cost is only a small constant factor slower than reading the statement.</li>

    </ol>

    <h2 id="sec-7" class="text-2xl font-bold">2 Overview of our work and a summary of our contributions</h2>

    <p class="text-gray-300">In this work, we construct two transparent zkSNARKs, namely Xiphos and Kopis. Of these, Xiphos is a Quark, and Kopis supports all but the quick verification property (concrete verification costs of Kopis is still faster than SuperSonic’s at R1CS instance sizes we experiment with). Nevertheless, Kopis supports shorter proofs than Xiphos and SuperSonic. Figure 1 depicts the asymptotic efficiency of Xiphos and Kopis, and compares it with prior transparent zkSNARKs. Similarly, Figure 2 depicts their concrete efficiency for <span class="math">n=2^{20}</span> R1CS constraints. The security of both schemes relies on the standard SXDH problem <em>[9]</em>, and both achieve non-interactivity in the random oracle model using the Fiat-Shamir transform <em>[40]</em>. A byproduct of Kopis is Lakonia, which does not employ computation commitments, so it incurs <span class="math">O(n)</span> verification costs. However, it produces <span class="math">O_{\\lambda}(\\log n)</span>-sized proofs analogous to Bulletproofs <em>[31]</em>. Figure 3 depicts the asymptotic and concrete efficiency of Lakonia and compares it with its baselines.</p>

    <p class="text-gray-300">Our starting point is Spartan <em>[61]</em>, which offers a modular framework for constructing transparent zkSNARKs. It employs a seminal interactive proof protocol, called the sum-check protocol <em>[57]</em>, in conjunction with an extractable polynomial commitment scheme <em>[29, 49, 69]</em> for multilinear polynomials. To instantiate computation commitments, Spartan requires a polynomial commitment scheme for sparse multilinear</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">asymptotic efficiency</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">concrete efficiency (n = 220)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover</td>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">verifier</td>

            <td class="px-3 py-2 border-b border-gray-700">prover (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">proof size (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">verifier (ms)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n F</td>

            <td class="px-3 py-2 border-b border-gray-700">√n F</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, √n H</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">20,000</td>

            <td class="px-3 py-2 border-b border-gray-700">31,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, √n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">486</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">7,700</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">804</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

            <td class="px-3 py-2 border-b border-gray-700">30,957</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n F</td>

            <td class="px-3 py-2 border-b border-gray-700">log2 n F</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, log2 n H</td>

            <td class="px-3 py-2 border-b border-gray-700">485</td>

            <td class="px-3 py-2 border-b border-gray-700">1,600</td>

            <td class="px-3 py-2 border-b border-gray-700">108,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">STARK</td>

            <td class="px-3 py-2 border-b border-gray-700">n log2 n F</td>

            <td class="px-3 py-2 border-b border-gray-700">log2 n F</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, log2 n H</td>

            <td class="px-3 py-2 border-b border-gray-700">≥4,850</td>

            <td class="px-3 py-2 border-b border-gray-700">39,384</td>

            <td class="px-3 py-2 border-b border-gray-700">≥432,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SpartanDL</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, √n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">369</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, √n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">347</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lakonia</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log n GT</td>

            <td class="px-3 py-2 border-b border-gray-700">n F, √n G2</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">517</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 3—Asymptotic and concrete efficiency of Lakonia and its baselines. Lakonia produces the shortest proofs with the exception of Bulletproofs, but Bulletproofs incurs higher proving and verification costs. All schemes incur linear time verification for arbitrary non-uniform computation. The costs for all schemes were measured by running their implementations on the same hardware platform (§9), with two exceptions. For Bulletproofs, we provide estimates based on prior performance reports [31]. For STARK, we use prior performance reports on arbitrary computation [20], adjusted to use non-heuristic parameters. Relatedly, ethSTARK [4] applies only to a specific uniform circuit (computing a hash chain), where the reported prover performance is competitive with Spartan. However, it only provides ≈29 bits of provable security. They claim an additional 20 bits by making the prover solve a proof-of-work puzzle, requiring  <span class="math">2^{20}</span>  hash computations. If those hash computations are cheap, then it does not add security; if not, it makes the prover's work exponential in the number bits of security gained [8]. Finally, it does not support zero-knowledge.</p>

    <p class="text-gray-300">polynomials. A key innovation in Spartan is a cryptographic compiler, called SPARK, that transforms an existing extractable polynomial commitment for dense multilinear polynomials to an extractable polynomial commitment scheme for sparse multilinear polynomials—without introducing undesirable asymptotic or concrete overheads to the prover or the verifier.</p>

    <p class="text-gray-300">To realize Xiphos, Kopis, and Lakonia, this work makes the following contributions.</p>

    <p class="text-gray-300">(1) Polynomial commitments with constant-sized commitments to shorten proofs. Spartan employs the polynomial commitment scheme of Wahby et al. [69], which we call Hyrax-PC, where the size of a commitment to a multilinear polynomial is  <span class="math">\\sqrt{m}</span>  elements of a group  <span class="math">\\mathbb{G}_1</span>  in which DLOG is hard, where  <span class="math">m = 2^{\\ell}</span>  and  <span class="math">\\ell</span>  is the number of variables in the committed polynomial. In the context of Spartan,  <span class="math">m = O(n)</span> , where  <span class="math">n</span>  is the size of the NP statement. This constitutes a major reason for large proofs in Spartan.</p>

    <p class="text-gray-300">To address this, we design a new polynomial commitment scheme for multilinear polynomials, called Kopis-PC, in which a commitment is a single element of  <span class="math">\\mathbb{G}_{\\mathrm{T}}</span> , where  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_{\\mathrm{T}})</span>  are groups in a bilinear map in which the SXDH problem is hard, so a polynomial commitment is of size  <span class="math">O_{\\lambda}(1)</span> . A single element of  <span class="math">\\mathbb{G}_{\\mathrm{T}}</span>  is a commitment to a vector of  <span class="math">\\sqrt{m}\\mathbb{G}_1</span>  elements under Hyrax-PC. However, in Hyrax-PC, the verifier locally computes an inner product between a vector of public scalars with a vector of  <span class="math">\\sqrt{m}</span>  elements of  <span class="math">\\mathbb{G}_1</span>  (representing a polynomial commitment under Hyrax-PC). Our polynomial commitment scheme handles this by having the prover compute the desired inner product and produce a proof of correct execution using the generalized inner</p>

    <p class="text-gray-300">product arguments of Bunz et al <em>[30]</em>. Kopis-PC can also be seen as an adaptation of the bivariate polynomial commitment scheme of Bunz et al. <em>[30]</em> to the setting of multilinear polynomials. This observation is however new.</p>

    <p class="text-gray-300">Besides Kopis-PC, we also build on Dory-PC <em>[52]</em>, a recent polynomial commitment scheme that employs the same blueprint as Kopis-PC, but in addition exploits the tensor structure in the public vector of scalars. Like Kopis-PC, Dory-PC also produces <span class="math">O_{\\lambda}(1)</span>-sized commitments and <span class="math">O_{\\lambda}(\\log m)</span>-sized polynomial evaluation proofs. The constant associated with Dory-PC’s evaluation proof sizes is <span class="math">\\approx</span>3<span class="math">\\times</span> larger than in Kopis-PC. In exchange, Dory-PC achieves <span class="math">O_{\\lambda}(\\log m)</span> costs to verify a polynomial evaluation proof instead of <span class="math">O_{\\lambda}(\\sqrt{m})</span> under Kopis-PC.</p>

    <p class="text-gray-300">(2) Sparse polynomial commitments with shorter proofs using Sparkle. Another major component that contributes to proof sizes in Spartan is the spark compiler. Even if we replace Hyrax-PC with one of the polynomial commitment schemes that produce constant-sized commitments (Kopis-PC or Dory-PC) in spark, the proof sizes are still <span class="math">O(\\log^{2}n)</span>. This is a result of using a <span class="math">O(\\log n)</span>-depth layered circuit in conjunction with a layered sum-check protocol <em>[36, 44, 66]</em> to prove grand product relations in spark. We address this by designing a variant of spark, called Sparkle, which reduces proof sizes to <span class="math">O(\\log n)</span>. In particular, using a combination of the sum-check protocol and polynomial commitments with constant-sized commitments, we design a new special-purpose SNARK for proving grand product relations. However, a naive replacement of the layered sum-check protocol with the special-purpose SNARK increases constants associated with the prover, which is undesirable. To achieve smaller constants for the prover, Sparkle hybridizes the new SNARK with the layered sum-check approach in spark, where a constant number of layers of the circuit are proved as before, but the rest of the layers are proved using the special-purpose SNARK, there by achieving <span class="math">O(\\log n)</span>-sized proofs without incurring large constants for the prover.</p>

    <p class="text-gray-300">(3) An untrusted assistant to accelerate the verifier’s preprocessing. Recall that the verifier in Spartan (and other prior transparent zkSNARKs) must run an encoder to preprocess the structure of an NP statement to create a computation commitment, which in turn enables the verifier to achieve sub-linear verification costs. We introduce the notion of an untrusted <em>assistant</em> for the encoder. An assistant is an algorithm that can be executed by anyone including the prover. Specifically, both the assistant and the encoder take as input the structure of an NP statement. Both transform the NP statement’s structure into a set of polynomials, but only the assistant creates the necessary polynomial commitments, so only the assistant incurs the high preprocessing costs. Furthermore, the encoder checks that the polynomial commitments are correctly created by requiring the assistant to produce a proof of correct evaluation of the underlying polynomials at a random point in their domain, which the encoder checks by evaluating the polynomials it holds (the random point is a public coin, so in the non-interactive version, it is obtained using the Fiat-Shamir transform in the random oracle model). For multilinear polynomials, since the cost of evaluating the necessary polynomials incurs <span class="math">O(n)</span> time and the cost of verifying proofs of evaluations is sub-linear in <span class="math">O_{\\lambda}(n)</span>, the encoder incurs <span class="math">O(n)</span> costs with a small constant rather than <span class="math">O_{\\lambda}(n)</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">(4) An optimized implementation. We implement Kopis, Xiphos, and Lakonia in Rust by extending libSpartan <em>[7]</em>, a high-speed Rust implementation of Spartan built atop ristretto255 <em>[5, 6, 48]</em>. This is about 5,000 lines of Rust. Since our polynomial commitment schemes require a pairing-friendly elliptic curve, we use bls12-381 and employ its implementation from blstrs <em>[2]</em>. We implement all of our techniques along with a host of optimizations. For example, instead of producing proofs of correct evaluations of multiple committed polynomials independently, our implementation reduces multiple polynomial evaluation proofs into a single one, which lowers verification costs and proof sizes substantially. Another notable optimization is to the zero-knowledge transformation used by Spartan (§8). Many of these optimizations improve Spartan’s performance and proof sizes (we refer to the improved version of Spartan as Spartan++).</p>

    <p class="text-gray-300">(5) A detailed experimental evaluation. We experimentally evaluate our schemes and compare them with state-of-the-art zkSNARKs. We find that Xiphos offers the fastest verification; its proof sizes are competitive with those of SuperSonic, which offers the shortest proofs in the literature. Our evaluation also demonstrates that Xiphos’s prover is fast: its prover is <span class="math">\\approx</span>376<span class="math">\\times</span> faster than SuperSonic and is within <span class="math">\\approx</span>3.8<span class="math">\\times</span> of Spartan, which offers the fastest prover in the literature. Kopis, at the cost of increased verification time (which is still concretely faster than SuperSonic), shortens Xiphos’s proof sizes further, thereby producing proofs shorter than SuperSonic. Xiphos and Kopis incur 10–10,000<span class="math">\\times</span> lower preprocessing costs for the verifier depending on the baseline. Finally, Lakonia shortens Kopis’s proofs further, thereby providing an alternative to Bulletproofs <em>[31]</em> with at least an order of magnitude faster proving and verification costs.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Roadmap for the rest of the paper</h3>

    <p class="text-gray-300">Section 3 describes the basic building blocks we rely on. Section 4 describes Kopis-PC. Section 5 provides a stand-alone description of the special-purpose SNARK for proving grand product relations. Section 6 improves Spartan’s spark compiler using the special-purpose SNARK. Section 7 describes the use of an untrusted assistant to accelerate the verifier’s preprocessing costs. Section 8 describes our improved zero-knowledge transformation. Finally, Section 9 presents an experimental evaluation of Xiphos, Kopis, and Lakonia, and compares them with their baselines.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">We adopt preliminaries from Spartan <em>[61]</em>, with additional definitions. We use <span class="math">\\mathbb{F}</span> to denote a finite field and <span class="math">\\lambda</span> to denote the security parameter. <span class="math">\\texttt{negl}(\\lambda)</span> denotes a negligible function in <span class="math">\\lambda</span>. “PPT algorithms” refer to probabilistic polynomial time algorithms.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.1 Problem instances in R1CS</h3>

    <p class="text-gray-300">Recall that for any problem instance <span class="math">\\mathtt{x}</span>, if <span class="math">\\mathtt{x}</span> is in an NP language <span class="math">\\mathcal{L}</span>, there exists a witness <span class="math">w</span> and a deterministic algorithm <span class="math">\\mathtt{Sat}</span> such that: <span class="math">\\mathtt{Sat}_{\\mathcal{L}}(\\mathtt{x},w)=1</span> if <span class="math">\\mathtt{x}\\in\\mathcal{L}</span>, and 0 otherwise.</p>

    <p class="text-gray-300">Alternatively, the set of tuples of the form <span class="math">\\langle \\mathbf{x}, w \\rangle</span> form a set of NP relations. The subset of those for which <span class="math">\\mathrm{Sat}_{\\mathcal{L}}(\\mathbf{x}, w) = 1</span> are called <em>satisfiable instances</em>, which we denote as: <span class="math">\\mathcal{R}_{\\mathcal{L}} = \\{\\langle \\mathbf{x}, w \\rangle : \\mathrm{Sat}_{\\mathcal{L}}(\\mathbf{x}, w) = 1\\}</span>.</p>

    <p class="text-gray-300">As an NP-complete language, we focus on the rank-1 constraint satisfiability (R1CS), a popular target for compiler toolchains that accept programs expressed in high-level languages [60, 64, 65, 68]. R1CS is implicit in the QAPs of GGPR [42], but it is used with (and without) QAPs in subsequent works [20, 56, 64].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3.1 (R1CS instance and structure).</strong> An R1CS instance is a tuple <span class="math">(\\mathbb{F}, A, B, C, m, n, io)</span>, where <span class="math">io</span> denotes the public input and output of the instance, <span class="math">A, B, C \\in \\mathbb{F}^{m \\times m}</span>, where $m \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">io</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> and there are at most </span>n<span class="math"> non-zero entries in each matrix. The </span>io$-independent part of the instance constitutes the structure of an R1CS instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that matrices <span class="math">A, B, C</span> are defined to be square matrices for conceptual simplicity. Furthermore, WLOG, we assume that <span class="math">n = O(m)</span> throughout the paper.</p>

    <p class="text-gray-300">Below, we use the notation <span class="math">z = (x,y,z)</span>, where each of <span class="math">x,y,z</span> is a vector over <span class="math">\\mathbb{F}</span>, to mean that <span class="math">z</span> is a vector that concatenates the three vectors in a natural way.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3.2 (R1CS).</strong> An R1CS instance <span class="math">(\\mathbb{F}, A, B, C, io, m, n)</span> is said to be <em>satisfiable</em> if there exists a witness $w \\in \\mathbb{F}^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">io</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math"> such that </span>(A \\cdot z) \\circ (B \\cdot z) = (C \\cdot z)<span class="math">, where </span>z = (io, 1, w)<span class="math">, </span>\\cdot<span class="math"> is the matrix-vector product, and </span>\\circ$ is the Hadamard (entry-wise) product.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3.3.</strong> For an R1CS instance <span class="math">\\mathbf{x} = (\\mathbb{F}, A, B, C, io, m, n)</span> and a purported witness $w \\in \\mathbb{F}^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">io</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}$, we define:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{Sat}_{\\mathrm{R1CS}}(\\mathbf{x}, w) = \\begin{cases} 1 &amp;amp; (A \\cdot (io, 1, w) \\circ (B \\cdot (io, 1, w)) = (C \\cdot (io, 1, w)) \\\\ 0 &amp;amp; \\text{otherwise} \\end{cases}</span></div>

    <p class="text-gray-300">The set of satisfiable R1CS instances can be denoted as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{R1CS}} = \\left\\{ \\langle (\\mathbb{F}, A, B, C, io, m, n), w \\rangle : \\mathrm{Sat}_{\\mathrm{R1CS}} \\left( (\\mathbb{F}, A, B, C, io, m, n), w \\right) = 1 \\right\\}</span></div>

    <p class="text-gray-300"><strong>Definition 3.4.</strong> For a given R1CS instance <span class="math">\\mathbf{x} = (\\mathbb{F}, A, B, C, io, m, n)</span>, the NP statement that <span class="math">\\mathbf{x}</span> is satisfiable (i.e., <span class="math">\\langle \\mathbf{x}, \\cdot \\rangle \\in \\mathcal{R}_{\\mathrm{R1CS}}</span>) is of size <span class="math">O(n)</span>.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.2 Succinct interactive arguments of knowledge</h2>

    <p class="text-gray-300">Let <span class="math">\\langle \\mathcal{P}, \\mathcal{V} \\rangle</span> denote a pair of PPT interactive algorithms and Setup denote an algorithm that outputs public parameters <span class="math">pp</span> given as input the security parameter <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Definition 3.5.</strong> A protocol between a pair of PPT algorithms <span class="math">\\langle \\mathcal{P}, \\mathcal{V} \\rangle</span> is called a public-coin succinct interactive argument of knowledge for a language <span class="math">\\mathcal{L}</span> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For any problem instance <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>, there exists a witness <span class="math">w</span> such that for all <span class="math">r \\in \\{0,1\\}^*</span>, <span class="math">\\operatorname{Pr}\\{\\langle \\mathcal{P}(pp,w), \\mathcal{V}(pp,r) \\rangle(\\mathbf{x}) = 1\\} \\geq 1 - \\mathrm{negl}(\\lambda)</span>.</li>

      <li><strong>Soundness.</strong> For any non-satisfiable problem instance <span class="math">\\mathbf{x}</span>, any PPT prover <span class="math">\\mathcal{P}^<em></span>, and for all <span class="math">w, r \\in \\{0,1\\}^</em></span>, <span class="math">\\operatorname{Pr}\\{\\langle \\mathcal{P}^*(pp,w), \\mathcal{V}(pp,r) \\rangle(\\mathbf{x}) = 1\\} \\leq \\mathrm{negl}(\\lambda)</span>.</li>

      <li><strong>Knowledge soundness.</strong> For any PPT adversary <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that <span class="math">\\forall \\mathbf{x} \\in \\mathcal{L}, \\forall w, r \\in \\{0,1\\}^*</span>, if <span class="math">\\operatorname{Pr}\\{\\langle \\mathcal{A}(pp,w), \\mathcal{V}(pp,r) \\rangle(\\mathbf{x}) = 1\\} \\geq \\mathrm{negl}(\\lambda)</span>, then <span class="math">\\operatorname{Pr}\\{\\mathrm{Sat}_{\\mathcal{L}}(\\mathbf{x}, \\mathcal{E}^{\\mathcal{A}}(pp,\\mathbf{x})) = 1\\} \\geq \\mathrm{negl}(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">8</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness. The total communication between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> is sub-linear in the size of the NP statement <span class="math">\\mathtt{x}\\in\\mathcal{L}</span>.</li>

      <li>Public coin. <span class="math">\\mathcal{V}</span>’s messages are chosen uniformly at random.</li>

    </ul>

    <p class="text-gray-300">We denote the <em>transcript</em> of the interaction of two PPTs <span class="math">\\mathcal{P},\\mathcal{V}</span> with random tapes <span class="math">z_{\\mathcal{P}},z_{\\mathcal{V}}</span> on <span class="math">\\mathtt{x}</span> by <span class="math">tr\\langle\\mathcal{P}(z_{\\mathcal{P}}),\\mathcal{V}(z_{\\mathcal{V}})\\rangle(\\mathtt{x})</span></p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3.6.</h6>

    <p class="text-gray-300">A public-coin succinct interactive argument of knowledge is <em>publicly verifiable</em> if there is a polynomial time algorithm <span class="math">\\mathsf{Accept}</span> of the transcript <span class="math">t</span> such that <span class="math">\\mathsf{Accept}(tr\\langle\\mathcal{P}(z_{\\mathcal{P}}),\\mathcal{V}(z_{\\mathcal{V}})\\rangle(\\mathtt{x}),\\mathtt{x})=\\langle\\mathcal{P}(z_{\\mathcal{P}}),\\mathcal{V}(z_{\\mathcal{V}})\\rangle(\\mathtt{x})</span>.</p>

    <p class="text-gray-300">We adapt the following definitions from <em>[69]</em>:</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3.7 (Witness-extended emulation <em>[47]</em>).</h6>

    <p class="text-gray-300">An interactive argument <span class="math">(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> for <span class="math">\\mathcal{L}</span> has witness-extended emulation if for all deterministic polynomial time programs <span class="math">\\mathcal{P}^{<em>}</span> there exists an expected polynomial time emulator <span class="math">E</span> such that for all non-uniform polynomial time adversaries <span class="math">A</span> and all <span class="math">z_{\\mathcal{V}}\\in\\{0,1\\}^{</em>}</span>, the following probabilities differ by at most <span class="math">\\mathtt{negl}(\\lambda)</span>: <span class="math">\\Pr\\{pp\\leftarrow\\mathsf{Setup}(1^{\\lambda})\\;;\\,(\\mathtt{x},z_{\\mathcal{P}})\\leftarrow A(pp)\\;;\\,t\\leftarrow tr\\langle\\mathcal{P}^{<em>}(z_{\\mathcal{P}}),\\mathcal{V}(z_{\\mathcal{V}})\\rangle(\\mathtt{x}):\\mathcal{A}(t,\\mathtt{x})=1\\}</span> and <span class="math">\\Pr\\{pp\\leftarrow\\mathsf{Setup}(1^{\\lambda})\\;;\\,(\\mathtt{x},z_{\\mathcal{P}})\\leftarrow A(pp)\\;;\\,(t,w)\\leftarrow E^{\\mathcal{P}^{</em>}(z_{\\mathcal{P}})}(\\mathtt{x}):\\mathcal{A}(t,\\mathtt{x})=1\\wedge(\\mathsf{Accept}(t)=1\\Rightarrow\\mathsf{Sat}_{\\mathcal{L}}(\\mathtt{x},w)=1)\\}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 3.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An interactive argument <span class="math">(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> for <span class="math">\\mathcal{L}</span> is computational zero-knowledge if for every PPT interactive machine <span class="math">\\mathcal{V}^{<em>}</span>, there exists a PPT algorithm <span class="math">S</span> called the simulator, running in time polynomial in the length of its first input such that for every problem instance <span class="math">\\mathtt{x}\\in\\mathcal{L}</span>, <span class="math">w\\in\\mathcal{R}_{\\mathtt{x}}</span>, and <span class="math">z\\in\\{0,1\\}^{</em>}</span>, the following holds when the distinguishing gap is considered as a function of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">View(\\langle\\mathcal{P}(w),\\mathcal{V}^{*}(z)\\rangle(\\mathtt{x}))\\approx_{c}S(\\mathtt{x},z),</span></p>

    <p class="text-gray-300">where <span class="math">View(\\langle\\mathcal{P}(w),\\mathcal{V}^{<em>}(z)\\rangle(\\mathtt{x}))</span> denotes the distribution of the transcript of interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}^{</em>}</span>, and <span class="math">\\approx_{c}</span> denotes that the two quantities are computationally indistinguishable. If the statistical distance between the two distributions is negligible then the interactive argument is said to be statistical zero-knowledge. If the simulator is allowed to abort with probability at most 1/2, but the distribution of its output conditioned on not aborting is identically distributed to <span class="math">View(\\langle\\mathcal{P}(w),\\mathcal{V}^{*}(z)\\rangle(\\mathtt{x}))</span>, then the interactive argument is called perfect zero-knowledge.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.3 Polynomials and low-degree extensions</h3>

    <p class="text-gray-300">We recall a few basic facts about polynomials:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A polynomial <span class="math">\\mathcal{G}</span> over <span class="math">\\mathbb{F}</span> is an expression consisting of a sum of <em>monomials</em> where each monomial is the product of a constant (from <span class="math">\\mathbb{F}</span>) and powers of one or more variables (which take values from <span class="math">\\mathbb{F}</span>); all arithmetic is performed over <span class="math">\\mathbb{F}</span>.</li>

      <li>The degree of a monomial is the sum of the exponents of variables in the monomial; the degree of a polynomial <span class="math">\\mathcal{G}</span> is the maximum degree of any monomial in <span class="math">\\mathcal{G}</span>. Furthermore, the degree of a polynomial <span class="math">\\mathcal{G}</span> in a particular variable <span class="math">x_{i}</span> is the maximum exponent that <span class="math">x_{i}</span> takes in any of the monomials in <span class="math">\\mathcal{G}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A multivariate polynomial is a polynomial with more than one variable; otherwise it is called a univariate polynomial.</li>

    </ul>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 3.9 (Multilinear polynomial).</h6>

    <p class="text-gray-300">A multivariate polynomial is called a multilinear polynomial if the degree of the polynomial in each variable is at most one.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 3.10 (Low-degree polynomial).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A multivariate polynomial <span class="math">\\mathcal{G}</span> over a finite field <span class="math">\\mathbb{F}</span> is called low-degree polynomial if the degree of <span class="math">\\mathcal{G}</span> in each variable is exponentially smaller than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Low-degree extensions (LDEs).</h4>

    <p class="text-gray-300">Suppose <span class="math">g:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span> is a function that maps <span class="math">\\ell</span>-bit elements into an element of <span class="math">\\mathbb{F}</span>. A polynomial extension of <span class="math">g</span> is a low-degree <span class="math">\\ell</span>-variate polynomial <span class="math">\\widetilde{g}(\\cdot)</span> such that <span class="math">\\widetilde{g}(x)=g(x)</span> for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">A multilinear polynomial extension (or simply, a multilinear extension, or MLE) is a low-degree polynomial extension where the extension is a multilinear polynomial (i.e., the degree of each variable in <span class="math">\\widetilde{g}(\\cdot)</span> is at most one). Given a function <span class="math">Z:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>, the multilinear extension of <span class="math">Z(\\cdot)</span> is the unique multilinear polynomial <span class="math">\\widetilde{Z}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>. It can be computed as follows.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{Z}(x_{1},\\ldots,x_{\\ell})</span> <span class="math">=\\sum_{e\\in\\{0,1\\}^{\\ell}}Z(e)\\cdot\\widetilde{\\operatorname{eq}}(x,e)</span> <span class="math">=\\langle(Z(0),\\ldots,Z(2^{\\ell}-1)),(\\widetilde{\\operatorname{eq}}(x,0),\\ldots,\\widetilde{\\operatorname{eq}}(x,2^{\\ell}-1)\\rangle</span></p>

    <p class="text-gray-300">Note that <span class="math">\\widetilde{\\operatorname{eq}}(x,e)=\\prod_{i=1}^{\\ell}(e_{i}\\cdot x_{i}+(1-e_{i})\\cdot(1-x_{i}))</span>, which is the MLE of the following function:</p>

    <p class="text-gray-300">\\[ \\operatorname{eq}(x,e)=\\begin{cases}1&\\text{if }x=e\\\\ 0&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">For any <span class="math">r\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\widetilde{Z}(r)</span> can be computed in <span class="math">O(2^{\\ell})</span> operations in <span class="math">\\mathbb{F}</span> <em>[66, 67]</em>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Dense representation for multilinear polynomials.</h4>

    <p class="text-gray-300">Since the MLE of a function is unique, it offers the following method to represent any multilinear polynomial. Given a multilinear polynomial <span class="math">\\mathcal{G}(\\cdot):\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>, it can be represented uniquely by the list of evaluations of <span class="math">\\mathcal{G}(\\cdot)</span> over the Boolean hypercube <span class="math">\\{0,1\\}^{\\ell}</span> (i.e., a function that maps <span class="math">\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>). We denote such a representation of <span class="math">\\mathcal{G}</span> as <span class="math">\\texttt{DenseRepr}(\\mathcal{G})</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 3.1.</h6>

    <p class="text-gray-300">If for any <span class="math">x\\in\\{0,1\\}^{\\ell}</span>, <span class="math">\\mathcal{G}(x)=0</span> then <span class="math">\\texttt{DenseRepr}(\\mathcal{G})</span> does not have to include an entry for <span class="math">x</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall the closed-form expression for evaluating <span class="math">\\mathcal{G}(\\cdot)</span> at <span class="math">(r_{1},\\ldots,r_{\\ell})\\in\\mathbb{F}^{\\ell}</span>: <span class="math">\\mathcal{G}(r_{1},\\ldots,r_{\\ell})=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\mathcal{G}(x)\\cdot\\prod_{i=1}^{\\ell}\\left(r_{i}\\cdot x_{i}+(1-r_{i})\\cdot(1-x_{i})\\right)</span>. Observe that if for any <span class="math">x\\in\\{0,1\\}^{\\ell}</span>, <span class="math">\\mathcal{G}(x)=0</span>, <span class="math">x</span> does not contribute to <span class="math">\\mathcal{G}(r)</span> for any <span class="math">r\\in\\mathbb{F}^{\\ell}</span>. ∎</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 3.11.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A multilinear polynomial <span class="math">\\mathcal{G}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> is a sparse multilinear polynomial if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{DenseRepr}(\\mathcal{G})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is sub-linear in </span>O(2^{\\ell})$. Otherwise, it is a dense multilinear polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As an example, suppose <span class="math">\\mathcal{G}:\\mathbb{F}^{2s}\\to\\mathbb{F}</span>. Suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{DenseRepr}(\\mathcal{G})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{s})<span class="math">, then </span>\\mathcal{G}(\\cdot)<span class="math"> is a sparse multilinear polynomial because </span>O(2^{s})<span class="math"> is sublinear in </span>O(2^{2s})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">We adopt our definitions in this subsection and the next from Bünz et al. [29] where they generalize the definition of Kate et al. [49] to allow interactive evaluation proofs. We also borrow their notation: in a list of arguments or returned tuples, variables before the semicolon are public and the ones after are secret; when there is no secret information, semicolon is omitted.</p>

    <p class="text-gray-300">A commitment scheme for some space of messages  <span class="math">\\mathcal{X}</span>  is a tuple of three protocols (Setup, Commit, Open):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">pp \\gets \\operatorname{Setup}(1^{\\lambda})</span> : produces public parameters  <span class="math">pp</span> .</li>

      <li><span class="math">(\\mathcal{C}; \\mathcal{S}) \\gets \\operatorname{Commit}(pp; x)</span> : takes as input some  <span class="math">x \\in \\mathcal{X}</span> ; produces a public commitment  <span class="math">\\mathcal{C}</span>  and a secret opening hint  <span class="math">\\mathcal{S}</span> .</li>

      <li><span class="math">b \\gets \\operatorname{Open}(pp, \\mathcal{C}, x, \\mathcal{S})</span> : verifies the opening of commitment  <span class="math">\\mathcal{C}</span>  to  <span class="math">x \\in \\mathcal{X}</span>  with the opening hint  <span class="math">\\mathcal{S}</span> ; outputs  <span class="math">b \\in \\{0, 1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 3.12. A tuple of three protocols (Setup, Commit, Open) is a binding commitment scheme for  <span class="math">\\mathcal{X}</span>  if:</p>

    <p class="text-gray-300">Binding. For any PPT adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left\\{ \\begin{array}{c} p p \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}); (\\mathcal {C}, \\mathcal {G} _ {0}, \\mathcal {G} _ {1}, \\mathcal {S} _ {0}, \\mathcal {S} _ {1}) = \\mathcal {A} (p p); \\\\ b _ {0} \\leftarrow \\operatorname {O p e n} (p p, \\mathcal {C}, \\mathcal {G} _ {0}, \\mathcal {S} _ {0}); b _ {1} \\leftarrow \\operatorname {O p e n} (p p, \\mathcal {C}, \\mathcal {G} _ {1}, \\mathcal {S} _ {1}): \\\\ b _ {0} = b _ {1} \\neq 0 \\wedge \\mathcal {G} _ {0} \\neq \\mathcal {G} _ {1} \\end{array} \\right\\} \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Definition 3.13. A commitment scheme (Setup, Commit, Open) provides hiding commitments if for all PPT adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} 1 - 2 \\cdot \\operatorname * {P r} \\left\\{ \\begin{array}{c} b = \\bar {b}: \\\\ p p \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}); \\\\ (\\mathcal {G} _ {0}, \\mathcal {G} _ {1}, s t) = \\mathcal {A} _ {0} (p p); \\\\ b \\leftarrow_ {R} \\{0, 1 \\}; \\\\ (\\mathcal {C}, \\mathcal {S}) \\leftarrow \\operatorname {C o m m i t} (p p; \\mathcal {G} _ {b}); \\\\ \\bar {b} \\leftarrow \\mathcal {A} _ {1} (s t, \\mathcal {C}) \\end{array} \\right\\} \\end{array} \\right\\} \\leq \\operatorname {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If the above holds for all algorithms, then the commitment is statistically hiding.</p>

    <p class="text-gray-300">Suppose that  <span class="math">(\\mathsf{Setup}_{\\mathbb{F}},\\mathsf{Commit}_{\\mathbb{F}},\\mathsf{Open}_{\\mathbb{F}})</span>  is a commitment scheme for  <span class="math">\\mathcal{X} = \\mathbb{F}</span> . WLOG, when algorithms below accept as input a multilinear polynomial, they use the dense representation of multilinear polynomials (§3.3).</p>

    <p class="text-gray-300">Definition 3.14. A tuple of four protocols (Setup, Commit, Open, Eval) is a polynomial commitment scheme for  <span class="math">\\ell</span> -variate multilinear polynomials over  <span class="math">\\mathbb{F}</span>  if (Setup, Commit, Open) is a commitment scheme for  <span class="math">\\ell</span> -variate multilinear polynomials over  <span class="math">\\mathbb{F}</span> , and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">pp \\gets \\operatorname{Setup}(1^{\\lambda}), pp_{\\mathbb{F}} \\gets \\operatorname{Setup}_{\\mathbb{F}}(1^{\\lambda})</span> . Both  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  hold a commitment  <span class="math">\\mathcal{C}_G</span>  to  <span class="math">G</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  selects a public coin  <span class="math">r\\in_{R}\\mathbb{F}^{\\ell}</span> ;  <span class="math">\\mathcal{P}</span>  then supplies a commitment  <span class="math">\\mathcal{C}_{\\nu}</span>  to a scalar  <span class="math">\\nu \\in \\mathbb{F}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\operatorname{Eval}(pp, pp_{\\mathbb{F}}, \\mathcal{C}_{\\mathcal{G}}, r, \\mathcal{C}_{\\nu}; \\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}, \\mathcal{S}_{\\nu})</span> is an interactive public-coin protocol between a PPT prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. <span class="math">\\mathcal{P}</span> additionally knows a <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">\\mathcal{G} \\in \\mathbb{F}[X_1, \\ldots, X_\\ell]</span> and its secret opening hint <span class="math">\\mathcal{S}_{\\mathcal{G}}</span>, and the scalar <span class="math">\\nu \\in \\mathbb{F}</span> and its secret opening hint <span class="math">\\mathcal{S}_{\\nu}</span>. <span class="math">\\mathcal{P}</span> attempts to convince <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{G}(r) = \\nu</span>. At the end of the protocol, <span class="math">\\mathcal{V}</span> outputs <span class="math">b \\in \\{0, 1\\}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 3.15.</strong> A polynomial commitment scheme for <span class="math">\\ell</span>-variable multilinear polynomials over <span class="math">\\mathbb{F}</span> is extractable if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For any <span class="math">\\ell</span>-variate multilinear polynomial <span class="math">\\mathcal{G} \\in \\mathbb{F}[X_1, \\ldots, X_\\ell]</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left\\{ \\begin{array}{c} pp \\leftarrow \\operatorname{Setup}(1^{\\lambda}); pp_{\\mathbb{F}} \\leftarrow \\operatorname{Setup}_{\\mathbb{F}}(1^{\\lambda}) \\\\ (\\mathcal{C}_{\\mathcal{G}}, \\mathcal{S}_{\\mathcal{G}}) \\leftarrow \\operatorname{Commit}(pp; \\mathcal{G}); (\\mathcal{C}_{\\nu}, \\mathcal{S}_{\\nu}) \\leftarrow \\operatorname{Commit}_{\\mathbb{F}}(pp_{\\mathbb{F}}; \\nu): \\\\ \\operatorname{Eval}(pp, pp_{\\mathbb{F}}, \\mathcal{C}_{\\mathcal{G}}, r, \\mathcal{C}_{\\nu}; \\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}, \\mathcal{S}_{\\nu}) = 1 \\wedge \\nu = \\mathcal{G}(r) \\end{array} \\right. \\geq 1 - \\operatorname{negl}(\\lambda)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Knowledge soundness.</strong> Eval is a public-coin succinct interactive argument of knowledge with witness-extended emulation (Definition 3.7) for the following NP relation given <span class="math">pp \\leftarrow \\operatorname{Setup}(1^{\\lambda})</span>, <span class="math">pp_{\\mathbb{F}} \\leftarrow \\operatorname{Setup}_{\\mathbb{F}}(1^{\\lambda})</span>, and <span class="math">r \\in \\mathbb{F}^{\\ell}</span> chosen after <span class="math">\\mathcal{C}_{\\mathcal{G}}</span> is fixed:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\operatorname{Eval}}(pp, pp_{\\mathbb{F}}) = \\left\\{ \\begin{array}{c} \\langle (\\mathcal{C}_{\\mathcal{G}}, \\mathcal{C}_{\\nu}), (\\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}, \\mathcal{S}_{\\nu}) \\rangle : \\\\ \\mathcal{G} \\in \\mathbb{F}[X_1, \\ldots, X_\\ell] \\text{ is multilinear } \\wedge \\nu \\in \\mathbb{F} \\wedge \\mathcal{G}(r) = \\nu \\\\ \\wedge \\operatorname{Open}(pp; \\mathcal{C}_{\\mathcal{G}}, \\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}) = 1 \\wedge \\operatorname{Open}_{\\mathbb{F}}(pp_{\\mathbb{F}}; \\mathcal{C}_{\\nu}, \\nu, \\mathcal{S}_{\\nu}) = 1 \\end{array} \\right.</span></div>

    <p class="text-gray-300"><strong>Definition 3.16.</strong> An extractable polynomial commitment scheme (Setup, Commit, Open, Eval) with hiding commitments (Definition 3.13) is zero-knowledge if Eval is a public-coin succinct interactive argument of knowledge with witness-extended emulation (Definition 3.7) and zero-knowledge (Definition 3.8) for the following NP relation given <span class="math">pp \\leftarrow \\operatorname{Setup}(1^{\\lambda})</span>, <span class="math">pp_{\\mathbb{F}} \\leftarrow \\operatorname{Setup}_{\\mathbb{F}}(1^{\\lambda})</span>, and <span class="math">r \\in \\mathbb{F}^{\\ell}</span> chosen after <span class="math">\\mathcal{C}_{\\mathcal{G}}</span> is fixed:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\operatorname{Eval}}(pp, pp_{\\mathbb{F}}) = \\left\\{ \\begin{array}{c} \\langle (\\mathcal{C}_{\\mathcal{G}}, \\mathcal{C}_{\\nu}), (\\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}, \\nu, \\mathcal{S}_{\\nu}) \\rangle : \\mathcal{G} \\in \\mathbb{F}[X_1, \\ldots, X_\\ell] \\text{ is multilinear } \\wedge \\\\ \\mathcal{G}(r) = \\nu \\wedge \\operatorname{Open}(pp; \\mathcal{C}_{\\mathcal{G}}, \\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}) = 1 \\wedge \\operatorname{Open}_{\\mathbb{F}}(pp_{\\mathbb{F}}; \\mathcal{C}_{\\nu}, \\nu, \\mathcal{S}_{\\nu}) = 1 \\end{array} \\right.</span></div>

    <p class="text-gray-300"><strong>Remark 3.1.</strong> Note that in this definition, <span class="math">r</span> is not chosen by the adversary. This weakening is required for the extractability of prior polynomial commitments [30, 52, 69] and Kopis-PC (§4). In our and prior [61, 69] use of these polynomial commitment schemes, <span class="math">\\mathcal{V}</span> selects points of evaluation at random. However, for a multilinear polynomial <span class="math">\\mathcal{G}</span>, if the evaluation point is not chosen after the commitment is fixed, one can employ a simple reduction to transform the evaluation claim to a claim about an evaluation at a random point <span class="math">r&#x27;</span> where <span class="math">r&#x27;</span> is chosen after the polynomial commitment is fixed.</p>

    <h2 id="sec-25" class="text-2xl font-bold">3.6 Inner product proofs (IPPs)</h2>

    <p class="text-gray-300">Suppose that <span class="math">(\\operatorname{Setup}_{\\mathbb{F}}, \\operatorname{Commit}_{\\mathbb{F}}, \\operatorname{Open}_{\\mathbb{F}})</span> denotes a commitment scheme for <span class="math">\\mathcal{X} = \\mathbb{F}</span>.</p>

    <p class="text-gray-300"><strong>Definition 3.17.</strong> A tuple of four protocols <span class="math">\\mathsf{IPP} = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathsf{Eval})</span> is an inner product proof system for <span class="math">s</span>-length vectors over <span class="math">\\mathbb{F}</span> if (IPP.Setup, IPP.Commit, IPP.Open) is a commitment scheme for <span class="math">s</span>-length vectors over <span class="math">\\mathbb{F}</span>, and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\operatorname{Eval}(pp, pp_{\\mathbb{F}}, \\mathcal{C}_Z, V, \\mathcal{C}_y; Z, S_Z, S_y)</span>  is an interactive public-coin protocol between a PPT prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span> .  <span class="math">pp</span>  refers to an output of IPP.Setup(1 <span class="math">\\lambda</span> ) and  <span class="math">pp_{\\mathbb{F}}</span>  refers to an output of Setup(1 <span class="math">\\lambda</span> ). Both  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  hold a commitment  <span class="math">\\mathcal{C}_Z</span>  to a vector  <span class="math">Z \\in \\mathbb{F}^s</span> , a commitment  <span class="math">\\mathcal{C}_y</span>  to a scalar  <span class="math">y \\in \\mathbb{F}</span> , and  <span class="math">V \\in \\mathbb{F}^s</span> .  <span class="math">\\mathcal{P}</span>  additionally knows a vector  <span class="math">Z \\in \\mathbb{F}^s</span>  and its secret opening hint  <span class="math">S_Z</span> , and the scalar  <span class="math">y \\in \\mathbb{F}</span>  and its secret opening hint  <span class="math">S_y</span> .  <span class="math">\\mathcal{P}</span>  attempts to convince  <span class="math">\\mathcal{V}</span>  that  <span class="math">y = \\langle Z, V \\rangle</span> . At the end of the protocol,  <span class="math">\\mathcal{V}</span>  outputs  <span class="math">b \\in \\{0, 1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 3.18. An inner product proof system for  <span class="math">s</span> -length vectors satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any  <span class="math">s</span> -length vector  <span class="math">Z \\in \\mathbb{F}^s</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left\\{ \\begin{array}{c} p p \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}); p p _ {\\mathbb {F}} \\leftarrow \\operatorname {S e t u p} _ {\\mathbb {F}} (1 ^ {\\lambda}) \\\\ (\\mathcal {C} _ {Z}, \\mathcal {S} _ {Z}) \\leftarrow \\operatorname {C o m m i t} (p p; Z); (\\mathcal {C} _ {y}, \\mathcal {S} _ {y}) \\leftarrow \\operatorname {C o m m i t} _ {\\mathbb {F}} (p p _ {\\mathbb {F}}; y): \\\\ \\operatorname {E v a l} (p p, p p _ {\\mathbb {F}}, \\mathcal {C} _ {Z}, V, \\mathcal {C} _ {y},; Z, \\mathcal {S} _ {Z}, \\mathcal {S} _ {y}) = 1 \\wedge y = \\langle Z, V \\rangle \\end{array} \\right\\} \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. Eval is a public-coin succinct interactive argument of knowledge with witness-extended emulation (Definition 3.7) for the following NP relation given  <span class="math">pp \\gets \\operatorname{Setup}(1^{\\lambda})</span>  and  <span class="math">pp_{\\mathbb{F}} \\gets \\operatorname{Setup}_{\\mathbb{F}}(1^{\\lambda})</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {E v a l}} (p p, p p _ {\\mathbb {F}}) = \\left\\{ \\begin{array}{c} \\langle (\\mathcal {C} _ {Z}, V, \\mathcal {C} _ {y}), (Z, \\mathcal {S} _ {Z}, \\mathcal {S} _ {y}) \\rangle : \\\\ Z \\in \\mathbb {F} ^ {s} \\wedge y \\in \\mathbb {F} \\wedge y = \\langle Z, V \\rangle \\wedge \\\\ \\mathsf {O p e n} (p p; \\mathcal {C} _ {Z}, Z, \\mathcal {S} _ {Z}) = 1 \\wedge \\mathsf {O p e n} _ {\\mathbb {F}} (p p _ {\\mathbb {F}}; \\mathcal {C} _ {y}, y, \\mathcal {S} _ {y}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">Definition 3.19. An inner product proof system for  <span class="math">s</span> -length vectors (Setup, Commit, Open, Eval) with hiding commitments (Definition 3.13) is zero-knowledge if Eval is a public-coin succinct interactive argument of knowledge with witness-extended emulation (Definition 3.7) and zero-knowledge (Definition 3.8) for the following NP relation given  <span class="math">pp \\gets \\operatorname{Setup}(1^{\\lambda})</span>  and  <span class="math">pp_{\\mathbb{F}} \\gets \\operatorname{Setup}_{\\mathbb{F}}(1^{\\lambda})</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {E v a l}} (p p, p p _ {\\mathbb {F}}) = \\left\\{ \\begin{array}{c} \\langle (\\mathcal {C} _ {Z}, V, \\mathcal {C} _ {y}), (Z, \\mathcal {S} _ {Z}, y, \\mathcal {S} _ {y}) \\rangle : Z \\in \\mathbb {F} ^ {s} \\wedge \\langle Z, V \\rangle = y \\wedge \\\\ \\mathsf {O p e n} (p p; \\mathcal {C} _ {Z}, Z, \\mathcal {S} _ {Z}) = 1 \\wedge \\mathsf {O p e n} _ {\\mathbb {F}} (p p _ {\\mathbb {F}}; \\mathcal {C} _ {y}, y, \\mathcal {S} _ {y}) = 1 \\end{array} \\right\\}</span></div>

    <h2 id="sec-26" class="text-2xl font-bold">3.7 Bilinear inner product proofs (BIPPs)</h2>

    <p class="text-gray-300">Definition 3.20. A tuple of four protocols  <span class="math">\\mathsf{BIPP} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span>  is a bilinear inner product proof system for  <span class="math">s</span> -length vectors over  <span class="math">\\mathbb{G}_1</span>  if (BIPP.Setup, BIPP.Commit, BIPP.Open) is a commitment scheme for  <span class="math">s</span> -length vectors over  <span class="math">\\mathbb{G}_1</span> , and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\operatorname{Eval}(pp, \\mathcal{C}_Z, V, y; Z, S_Z)</span>  is an interactive public-coin protocol between a PPT prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span> .  <span class="math">pp</span>  refers to an output of BIPP.Setup(1 <span class="math">\\lambda</span> ). Both  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  hold a commitment  <span class="math">\\mathcal{C}_Z</span>  to a vector  <span class="math">Z \\in \\mathbb{G}_1^s</span> , a  <span class="math">y \\in \\mathbb{G}_1</span> , and  <span class="math">V \\in \\mathbb{F}^s</span> .  <span class="math">\\mathcal{P}</span>  additionally knows a vector  <span class="math">Z \\in \\mathbb{G}_1^s</span>  and its secret opening hint  <span class="math">S_Z</span> .  <span class="math">\\mathcal{P}</span>  attempts to convince  <span class="math">\\mathcal{V}</span>  that  <span class="math">y = \\langle Z, V \\rangle</span> . At the end of the protocol,  <span class="math">\\mathcal{V}</span>  outputs  <span class="math">b \\in \\{0, 1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 3.21. A bilinear inner product proof system for  <span class="math">s</span> -length vectors satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any  <span class="math">s</span> -length vector  <span class="math">Z \\in \\mathbb{G}_1^s</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left\\{ \\begin{array}{c} p p \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}); \\\\ (\\mathcal {C} _ {Z}, \\mathcal {S} _ {Z}) \\leftarrow \\operatorname {C o m m i t} (p p; Z); \\\\ \\operatorname {E v a l} (p p, \\mathcal {C} _ {Z}, V, y; Z, \\mathcal {S} _ {Z}) = 1 \\wedge y = \\langle Z, V \\rangle \\end{array} \\right\\} \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">1: // reduces the claim  <span class="math">\\sum_{x\\in \\{0,1\\}^e}\\mathcal{G}(x)\\stackrel {\\circ}{=}T</span>  to  <span class="math">\\mathcal{G}(r)\\stackrel {\\circ}{=}e</span> 2: function SumCheckReduce  <span class="math">(\\mu, \\ell, T, r)</span> 3:  <span class="math">(r_1, r_2, \\ldots, r_\\mu) \\gets r</span> 4:  <span class="math">e\\gets T</span> 5: for  <span class="math">i = 1,2,\\ldots ,\\mu</span>  do 6:  <span class="math">\\mathcal{G}_i(\\cdot)\\gets</span>  ReceiveFromProver() // an honest  <span class="math">\\mathcal{P}_{SC}</span>  returns  <span class="math">\\{\\mathcal{G}_i(0),\\mathcal{G}_i(1),\\ldots \\mathcal{G}_i(\\ell)\\}</span> 7: if  <span class="math">\\mathcal{G}_i(0) + \\mathcal{G}_i(1)\\neq e</span>  then 8: return 0 9: SendToProver  <span class="math">(r_i)</span> 10:  <span class="math">e\\gets \\mathcal{G}_i(r_i)</span>  // evaluate  <span class="math">\\mathcal{G}_i(r_i)</span>  using its point-value form received from the prover return  <span class="math">e</span></p>

    <p class="text-gray-300">FIGURE 4—The sum-check protocol.  <span class="math">\\mathcal{V}_{SC}</span>  checks if a  <span class="math">\\mu</span> -variate polynomial  <span class="math">\\mathcal{G}(\\cdot)</span>  sums to  <span class="math">T</span>  over the Boolean hypercube  <span class="math">\\{0,1\\}^{\\mu}</span>  with the assistance of a prover  <span class="math">\\mathcal{P}_{SC}</span> . The degree of  <span class="math">\\mathcal{G}(\\cdot)</span>  in each variable is at most  <span class="math">\\ell</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. Eval is a public-coin succinct interactive argument of knowledge with witness-extended emulation (Definition 3.7) for the following NP relation given  <span class="math">pp \\gets \\text{Setup}(1^{\\lambda})</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {E v a l}} (p p) = \\left\\{ \\begin{array}{c} \\langle (\\mathcal {C} _ {Z}, V, y), (Z, \\mathcal {S} _ {Z}) \\rangle : \\\\ Z \\in \\mathsf {G} _ {1} ^ {s} \\wedge y \\in \\mathsf {G} _ {1} \\wedge y = \\langle Z, V \\rangle \\wedge \\\\ \\mathsf {O p e n} (p p; \\mathcal {C} _ {Z}, Z, \\mathcal {S} _ {Z}) = 1 \\end{array} \\right\\}</span></div>

    <h2 id="sec-27" class="text-2xl font-bold">3.8 The sum-check protocol</h2>

    <p class="text-gray-300">The sum-check protocol is a seminal interactive proof protocol (an interactive argument where soundness holds unconditionally), which we now elaborate.</p>

    <p class="text-gray-300">Suppose that there is a  <span class="math">\\ell</span> -variate low-degree polynomial,  <span class="math">\\mathcal{G}:\\mathbb{F}^{\\ell}\\to \\mathbb{F}</span>  where the degree of  <span class="math">\\mathcal{G}</span>  in each variable is  <span class="math">\\leq d</span> . The sum-check protocol enables a prover  <span class="math">\\mathcal{P}_{SC}</span>  to prove to a verifier  <span class="math">\\nu_{SC}</span>  claims of the following form, which we call sum-check instances:</p>

    <div class="my-4 text-center"><span class="math-block">T = \\sum_ {x _ {1} \\in \\{0, 1 \\}} \\sum_ {x _ {2} \\in \\{0, 1 \\}} \\dots \\sum_ {x _ {\\ell} \\in \\{0, 1 \\}} \\mathcal {G} (x _ {1}, x _ {2}, \\dots , x _ {\\ell})</span></div>

    <p class="text-gray-300">Of course, given  <span class="math">\\mathcal{G}</span> ,  <span class="math">\\nu_{SC}</span>  can deterministically evaluate the above sum and verify whether that the sum is  <span class="math">T</span> —without requiring any assistance from  <span class="math">\\mathcal{P}_{SC}</span> . But,  <span class="math">\\nu_{SC}</span>  requires computation exponential in  <span class="math">\\ell</span> . With the sum-check protocol,  <span class="math">\\nu_{SC}</span>  requires far less computation at the cost of a probabilistic soundness guarantee.</p>

    <p class="text-gray-300">In the sum-check protocol,  <span class="math">\\mathcal{V}_{SC}</span>  interacts with  <span class="math">\\mathcal{P}_{SC}</span>  over a sequence of  <span class="math">\\ell</span>  rounds where in each round  <span class="math">\\mathcal{V}_{SC}</span>  sends a random challenge (i.e., a public coin) and  <span class="math">\\mathcal{P}</span>  responds with a message of size  <span class="math">O(d)</span> . At the end of this interaction,  <span class="math">\\mathcal{V}_{SC}</span>  outputs  <span class="math">b \\in \\{0,1\\}</span> . The principal cost to  <span class="math">\\mathcal{V}_{SC}</span>  is to evaluate  <span class="math">\\mathcal{G}</span>  at a random point in its domain  <span class="math">r \\in \\mathbb{F}^{\\ell}</span> . We denote the sum-check protocol as  <span class="math">b \\gets \\langle \\mathcal{P}_{SC}, \\mathcal{V}_{SC}(r) \\rangle(\\mathcal{G}, \\ell, d, T)</span> . For any  <span class="math">\\ell</span> -variate polynomial  <span class="math">\\mathcal{G}</span>  with degree at most  <span class="math">d</span>  in each variable, the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. If  <span class="math">T = \\sum_{x \\in \\{0,1\\}^e} \\mathcal{G}(x)</span> , then for a correct  <span class="math">\\mathcal{P}_{SC}</span>  and for all  <span class="math">r \\in \\{0,1\\}^<em></span> ,  <span class="math">\\operatorname</em>{Pr}\\{\\langle \\mathcal{P}_{SC}(\\mathcal{G}), \\mathcal{V}_{SC}(r) \\rangle(\\ell, d, T) = 1\\} = 1</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Soundness. If  <span class="math">T \\neq \\sum_{x \\in \\{0,1\\}^e} \\mathcal{G}(x)</span> , then for any  <span class="math">\\mathcal{P}_{SC}^<em></span>  and for all  <span class="math">r \\in \\{0,1\\}^</em></span> ,  $\\operatorname<em>{Pr}_r\\{\\langle \\mathcal{P}_{SC}^</em>(\\mathcal{G}), \\mathcal{V}_{SC}(r) \\rangle(\\ell, d, T) = 1\\} \\leq d \\cdot \\ell /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness. The communication between  <span class="math">\\mathcal{P}_{SC}</span>  and  <span class="math">\\nu_{SC}</span>  is  <span class="math">O(d\\cdot \\ell)</span>  elements of  <span class="math">\\mathbb{F}</span> .</li>

    </ul>

    <p class="text-gray-300">An alternate formulation.</p>

    <p class="text-gray-300">The sum-check protocol is a mechanism to reduce a claim of the form <span class="math">\\sum_{x\\in\\{0,1\\}^{m}}\\mathcal{G}(x)\\stackrel{{\\scriptstyle?}}{{=}}T</span> to the claim <span class="math">\\mathcal{G}(r)\\stackrel{{\\scriptstyle?}}{{=}}e</span>. In most cases, <span class="math">\\mathcal{V}_{SC}</span> uses an auxiliary protocol to verify the latter claim, so this formulation makes it easy to describe end-to-end protocols. We denote this reduction protocol with <span class="math">e\\leftarrow\\langle\\mathcal{P}_{SC}(\\mathcal{G}),\\mathcal{V}_{SC}(r)\\rangle(\\ell,d,T)</span>. Figure 4 depicts the sum-check protocol from this perspective.</p>

    <h2 id="sec-28" class="text-2xl font-bold">4 A new commitment scheme for multilinear polynomials</h2>

    <p class="text-gray-300">This section describes Kopis-PC, a new polynomial commitment scheme for multilinear polynomials without requiring a trusted setup.</p>

    <p class="text-gray-300">Our scheme can be seen as an extension and generalization of the polynomial commitment scheme of Wahby et al. for multilinear polynomials <em>[69]</em>. Specifically, instead of only relying on singly-homomorphic commitments of Pedersen, our scheme augments the scheme of Wahby et al. <em>[69]</em> with doubly-homomorphic commitments of Abe et al. <em>[10]</em>. Whereas the scheme of Wahby et al. <em>[69]</em> requires only a group where DLOG is hard, our scheme requires a blinear group where SXDH is hard. In exchange, we obtain a substantial improvement in polynomial commitment sizes: for an <span class="math">\\ell</span>-variate multilinear polynomial, the commitment size drops from <span class="math">O_{\\lambda}(2^{\\ell/2})</span> to <span class="math">O_{\\lambda}(1)</span>. Polynomial evaluation proof sizes increase by a small constant factor (<span class="math">\\approx</span>6): instead of <span class="math">O(\\ell)</span> elements of a group where DLOG is hard, our scheme produces <span class="math">O(\\ell)</span> elements of a target group in a bilinear group where SXDH is hard. Nevertheless, in the context of Spartan, we obtain an exponential improvement since it often involves the following three steps: (1) the prover sends one or more polynomial commitments; (2) the prover uses the sum-check protocol to prove certain sum-check instances; and (3) the prover produces polynomial evaluation proofs. For an <span class="math">n</span>-sized R1CS instance, the proof size contribution from steps (1) and (3) drops from <span class="math">O_{\\lambda}(\\sqrt{n})</span> to <span class="math">O_{\\lambda}(\\log n)</span>.</p>

    <p class="text-gray-300">Our scheme can also be seen as an adaptation of the polynomial commitment scheme for bivariate polynomials in the work of Bunz et al. <em>[30]</em> to the setting of multilinear polynomials. While this may appear straightforward in hindsight, our observation is new. For example, Bunz et al. <em>[30]</em> describe two schemes for bivariate polynomials, but it appears that only one of them can be adapted to multilinear polynomials.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.1 Details of Kopis-PC</h3>

    <p class="text-gray-300">Suppose that <span class="math">\\widetilde{Z}</span> is an <span class="math">\\ell</span>-variate multilinear polynomial over <span class="math">\\mathbb{F}</span>. Recall that <span class="math">\\widetilde{Z}</span> can be represented uniquely using a table of its evaluations over the Boolean hypercube <span class="math">\\{0,1\\}^{\\ell}</span> (§3.3). Conveniently, we denote such a table of evaluations as <span class="math">Z</span>. We will abuse notation and treat <span class="math">Z</span> as a function that maps <span class="math">\\ell</span>-bit strings to elements of <span class="math">\\mathbb{F}</span>: <span class="math">Z:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>. Naturally, <span class="math">\\forall x\\in\\{0,1\\}^{\\ell}</span>, <span class="math">\\widetilde{Z}(x)=Z(x)</span>. Furthermore, recall from Section 3.3 that for <span class="math">r\\in\\mathbb{F}^{\\ell}</span>,</p>

    <p class="text-gray-300"><span class="math">\\widetilde{Z}(r)=\\sum_{i\\in\\{0,1\\}^{\\ell}}\\widetilde{\\operatorname{eq}}(i,r)\\cdot Z(i)</span></p>

    <p class="text-gray-300">WLOG, suppose that <span class="math">\\ell</span> is even. Furthermore, let <span class="math">s=\\ell/2</span> and <span class="math">r=(r_{x},r_{y})</span>, where <span class="math">r_{x},r_{y}\\in\\mathbb{F}^{s}</span> and <span class="math">(r_{x},r_{y})</span> denotes a concatenation of two vectors in an obvious fashion. We</p>

    <p class="text-gray-300">can rewrite the above equation as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widetilde{Z}(r_x, r_y) = \\sum_{(i,j) \\in (\\{0,1\\}^s, \\{0,1\\}^s)} Z(i,j) \\cdot \\widetilde{\\mathrm{eq}}(i, r_x) \\cdot \\widetilde{\\mathrm{eq}}(j, r_y) \\\\ = \\sum_{i \\in \\{0,1\\}^s} \\widetilde{\\mathrm{eq}}(i, r_x) \\cdot \\sum_{j \\in \\{0,1\\}^s} Z(i,j) \\cdot \\widetilde{\\mathrm{eq}}(j, r_y) \\end{array}</span></div>

    <p class="text-gray-300">It is also convenient to treat <span class="math">Z</span> as an <span class="math">s \\times s</span> matrix with <span class="math">L(i) = \\mathrm{eq}(i, r_x)</span> and <span class="math">R(j) = \\mathrm{eq}(j, r_y)</span> as vectors of evaluations for all <span class="math">i, j \\in \\{0,1\\}^s</span>. With such a formulation, the following holds: <span class="math">\\widetilde{Z}(r) = (L \\cdot Z) \\cdot R</span>.</p>

    <p class="text-gray-300"><strong>Scheme.</strong> We assume that there exists an inner product proof system IPP and a bilinear inner product proof system BIPP. Wahby et al. [69] provide an adaptation of Bulletproofs' inner product argument [31] that serves as our IPP. Bunz et al. [30] provide a generalization of Bulletproofs' inner product argument that serves as our BIPP.</p>

    <p class="text-gray-300">Kopis-PC is identical to the polynomial commitment scheme of Wahby et al. [69] except that they do not use BIPP, so the verifier must compute a weighted sum of group elements locally after receiving <span class="math">O(2^{\\ell/2})</span>-sized commitment. In Kopis-PC, the verifier receives an <span class="math">O_{\\lambda}(1)</span>-sized commitment. Furthermore, BIPP enables the verifier in Kopis-PC to verifiably offload the necessary computation of weighted sum to the prover. Using proofs analogous to the ones in prior work [30, 52, 69], it is straightforward to show that the scheme below is a polynomial commitment scheme for multilinear polynomials. The Eval depicted below is not a zero-knowledge interactive argument, but it can be extended via standard techniques [52].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">pp \\gets \\operatorname{Setup}(1^{\\lambda}, \\ell)</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">s \\gets 2^{\\ell/2}</span></li>

      <li><span class="math">pp_{out} \\gets \\operatorname{BIPP.Setup}(1^{\\lambda}, s)</span></li>

      <li><span class="math">pp_{in} \\gets \\operatorname{IPP.Setup}(1^{\\lambda}, s)</span></li>

      <li>Output <span class="math">(pp_{out}, pp_{in})</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{C}_{\\mathcal{G}}; \\mathcal{S}_{\\mathcal{G}}) \\gets \\operatorname{Commit}(pp, \\mathcal{G})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">Z</span> denote a matrix representation of evaluations of <span class="math">\\mathcal{G}</span> over <span class="math">\\{0,1\\}^\\ell</span></li>

      <li><span class="math">(\\mathcal{C}_0, \\ldots, \\mathcal{C}_{s-1}; \\mathcal{S}_0, \\ldots, \\mathcal{S}_{s-1}) \\gets \\forall i \\in \\{0, \\ldots, s-1\\} :: \\operatorname{IPP.Commit}(pp.pp_{in}, Z(i))</span>, where <span class="math">Z(i)</span> is the <span class="math">i</span>th row of <span class="math">Z</span> with <span class="math">s</span> elements.</li>

      <li><span class="math">(\\mathcal{C}_{\\mathcal{G}}; \\mathcal{S}_{out}) \\gets \\operatorname{BIPP.Commit}(pp.pp_{out}, (\\mathcal{C}_0, \\ldots, \\mathcal{C}_{s-1}))</span></li>

      <li><span class="math">\\mathcal{S}_{\\mathcal{G}} \\gets (\\mathcal{C}_0, \\ldots, \\mathcal{C}_{s-1}, \\mathcal{S}_0, \\ldots, \\mathcal{S}_{s-1}, \\mathcal{S}_{out})</span></li>

      <li>Output <span class="math">(\\mathcal{C}_{\\mathcal{G}}, \\mathcal{S}_{\\mathcal{G}})</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\operatorname{Eval}(pp, pp_{\\mathbb{F}}, \\mathcal{C}_{\\mathcal{G}}, r, \\mathcal{C}_{\\nu}; \\mathcal{G}, \\mathcal{S}_{\\mathcal{G}}, \\mathcal{S}_{\\nu})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}, \\mathcal{P} \\colon (r_x, r_y) \\gets r</span>, where <span class="math">r = (r_x, r_y)</span> and <span class="math">r_x, r_y \\in \\mathbb{F}^{\\ell/2}</span></li>

      <li><span class="math">\\mathcal{V}, \\mathcal{P} \\colon L = \\forall i :: \\operatorname{eq}(i, r_x)</span>, so <span class="math">L \\in \\mathbb{F}^s</span> where <span class="math">s = 2^{\\ell/2}</span>.</li>

      <li><span class="math">\\mathcal{P} \\colon y_{out} \\gets \\langle (\\mathcal{S}_{\\mathcal{G}}. \\mathcal{C}_0, \\ldots, \\mathcal{S}_{\\mathcal{G}}. \\mathcal{C}_{s-1}), L \\rangle</span></li>

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V} \\colon y_{out}</span></li>

    </ol>

    <p class="text-gray-300">16</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V},\\mathcal{P}\\colon b_{out}\\gets \\mathrm{BIPP.Eval}(pp.pp_{out},pp_{G_1},\\mathcal{C}_{\\mathcal{G}},L,y_{out};(S_{\\mathcal{G}},\\mathcal{C}_0,\\ldots ,S_{\\mathcal{G}},\\mathcal{C}_{s - 1}))</span></li>

      <li><span class="math">\\mathcal{V}</span> : Abort with  <span class="math">b = 0</span>  if  <span class="math">b_{out} = 0</span></li>

      <li><span class="math">\\mathcal{V},\\mathcal{P}\\colon R = \\forall j::\\mathrm{eq}(j,r_y)</span>  , so  <span class="math">R\\in \\mathbb{F}^s</span>  where  <span class="math">s = 2^{\\ell /2}</span></li>

      <li><span class="math">\\mathcal{V},\\mathcal{P}\\colon b_{in}\\gets \\mathrm{IPP.Eval}(pp.pp_{in},pp_{\\mathbb{F}},y_{out},R,\\mathcal{C}_{\\tau};L\\cdot Z,\\langle L,(S,S_0,\\ldots ,S,S_{s - 1})\\rangle ,S_e)</span></li>

      <li><span class="math">\\mathcal{V}</span> : Abort with  <span class="math">b = 0</span>  if  <span class="math">b_{in} = 0</span></li>

      <li><span class="math">\\mathcal{V}</span> : Output  <span class="math">b = 1</span></li>

    </ol>

    <p class="text-gray-300">Analysis of costs. The following table summarizes costs under Kopis-PC and compares with the scheme of Wahby et al. [69], denoted with Hyrax-PC. We also include costs for Dory-PC [52], which follows the same blueprint as Kopis-PC, except that it leverages the tensor structure in  <span class="math">L</span>  and  <span class="math">R</span>  vectors (which are of size  <span class="math">\\sqrt{n}</span> , where  <span class="math">n = 2^{\\ell}</span>  for an  <span class="math">\\ell</span> -variate multilinear polynomial) to avoid materializing them, thereby enabling it to achieve  <span class="math">O_{\\lambda}(\\log n)</span>  verification costs instead of  <span class="math">O_{\\lambda}(\\sqrt{n})</span>  costs under Kopis-PC and Hyrax-PC.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PEval</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πEval</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VEval</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax-PC [69]</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dory-PC [52]</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">SXDH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis-PC</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">n F</td>

            <td class="px-3 py-2 border-b border-gray-700">log n G1</td>

            <td class="px-3 py-2 border-b border-gray-700">√n G2</td>

            <td class="px-3 py-2 border-b border-gray-700">SXDH</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This section describes a new transparent SNARK, which may be of independent interest, for proving grand product relations:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {G P}} = \\left\\{\\left(P \\in \\mathbb {F}, V \\in \\mathbb {F} ^ {m}\\right): P = \\prod_ {i} V _ {i} \\right\\}</span></div>

    <p class="text-gray-300">Spartan [61] employs a  <span class="math">O(\\log m)</span> -depth layered circuit [66] for computing such grand products. The layered circuit takes as input a vector  <span class="math">V</span>  and outputs  <span class="math">T</span> . In each layer, the circuit computes the Hadamard product between the left and right halves of the vector output by the previous layer. To construct a SNARK for grand product relations, Spartan applies the sum-check protocol in a layered fashion [36, 44, 66] in conjunction with a polynomial commitment scheme [69] to commit to the input represented as multilinear polynomial. A principal downside of this approach is that it requires  <span class="math">O(\\log m)</span>  invocations of the sum-check protocol, and it produces  <span class="math">O_{\\lambda}(\\log^2 m)</span> -sized proofs—ignoring the size of the commitments and proofs for polynomial commitments. In Spartan [61], which employs the polynomial commitment scheme of Wahby et al. [69], the latter incurs  <span class="math">O_{\\lambda}(\\sqrt{m})</span>  costs and dominates proof sizes both asymptotically and concretely.</p>

    <p class="text-gray-300">We improve these proof sizes to  <span class="math">O_{\\lambda}(\\log m)</span>  —including the size of the commitment and polynomial evaluation proofs—by leveraging the constant-sized polynomial commitments and logarithmic polynomial evaluation proofs provided by Kopis-PC and Dory-PC. Specifically, we design a new sum-check instance for grand product relations: a polynomial  <span class="math">\\mathcal{G}</span>  that sums to 0 over a certain Boolean hypercube if and only if a given  <span class="math">(P \\in \\mathbb{F}, V \\in \\mathbb{F}^m) \\in \\mathcal{R}_{GP}</span> . Given such a sum-check instance, our approach to convert it to an interactive argument (and then into a SNARK in the random oracle model) is</p>

    <p class="text-gray-300">the same as in prior work <em>[29, 61]</em>: use the sum-check protocol reduce the sum-check instance into a set of polynomial evaluations, and then use a polynomial commitment scheme to prove the correct evaluations of the polynomials.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Details. Let $m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. WLOG, assume that </span>m<span class="math"> is a power of </span>2<span class="math">, and let </span>s=\\log m<span class="math">. Let </span>V<span class="math"> denote a table of evaluations of a </span>\\log m<span class="math">-variate multilinear polynomial </span>v(x)<span class="math"> over </span>\\{0,1\\}^{\\log m}$ in a natural fashion.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 5.1.</h6>

    <p class="text-gray-300"><span class="math">P=\\prod_{x\\in\\{0,1\\}^{\\log m}}v(x)</span> if and only if there exists a multilinear polynomial <span class="math">f</span> in <span class="math">\\log m+1</span> variables such that <span class="math">f(1,\\ldots,1,0)=P</span>, and <span class="math">\\forall x\\in\\{0,1\\}^{\\log m}</span>, the following hold: <span class="math">f(0,x)=v(x),f(1,x)=f(x,0)\\cdot f(x,1)</span></p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove the forward implication, define <span class="math">f</span> to be the MLE of its evaluations on the Boolean hypercube: <span class="math">f(1,\\ldots,1)=0</span> and for all <span class="math">\\ell\\in{0,\\ldots,\\log m}</span> and <span class="math">x\\in\\{0,1\\}^{\\log m-\\ell}</span>, <span class="math">f(1^{\\ell},0,x)=\\prod_{y\\in\\{0,1\\}^{\\ell}}v(x,y)</span>. Then taking <span class="math">\\ell=0</span> we have <span class="math">\\forall x\\in\\{0,1\\}^{\\log m}:f(0,x)=v(x)</span>, and taking <span class="math">\\ell=\\log m</span> we have <span class="math">f(1,\\ldots,1,0)=\\prod_{x\\in\\{0,1\\}^{\\log m}}a(x)=P</span>. For <span class="math">\\ell&gt;0</span>:</p>

    <p class="text-gray-300"><span class="math">f(1^{\\ell},0,x)=</span> <span class="math">\\prod_{y\\in\\{0,1\\}^{\\ell}}v(x,y)=\\prod_{y\\in\\{0,1\\}^{\\ell-1}}v(x,0,y)\\cdot\\prod_{y\\in\\{0,1\\}^{\\ell-1}}v(x,1,y)</span> <span class="math">=</span> <span class="math">f(1^{\\ell-1},0,x,0)\\cdot f(1^{\\ell-1},0,x,1)</span></p>

    <p class="text-gray-300">so <span class="math">f(1,x)=f(x,0)\\cdot f(x,1)</span> for all <span class="math">x\\in\\{0,1\\}^{\\log m}\\backslash\\{1,\\ldots,1\\}</span>. In this last case, we have: <span class="math">f(1,\\ldots,1)=0=f(1,\\ldots,0)\\cdot f(1,\\ldots,1)</span>. So a suitable <span class="math">f</span> exists.</p>

    <p class="text-gray-300">To prove the reverse implication, for any <span class="math">f</span> satisfying these conditions, we have by induction on <span class="math">0\\leq\\ell\\leq\\log m</span>: <span class="math">\\forall x\\in\\{0,1\\}^{\\log m-\\ell}:f(1^{\\ell},0,x)=\\prod_{y\\in\\{0,1\\}^{\\ell}}f(0,x,y)</span>. Then taking <span class="math">\\ell=\\log m</span> implies that: <span class="math">P=f(1,\\ldots,1,0)=\\prod_{x\\in\\{0,1\\}^{\\log m}}v(x)</span> ∎</p>

    <p class="text-gray-300">A sum-check instance for grand products. To check that <span class="math">\\forall x\\in\\{0,1\\}^{\\log m}f(1,x)=f(x,0)\\cdot f(x,1)</span>, we use a prior idea <em>[25, 32, 61]</em>. Let <span class="math">g</span> be the MLE of the function <span class="math">f(1,x)-f(x,0)f(x,1))</span>. In particular,</p>

    <p class="text-gray-300"><span class="math">g(t)=\\sum_{x\\in\\{0,1\\}^{\\log m}}\\widehat{\\operatorname{eq}}(t,x)\\cdot(f(1,x)-f(x,0)\\cdot f(x,1))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz–Zippel lemma, except for a soundness error of $\\log m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (which is negligible in </span>\\lambda<span class="math"> if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is exponential in </span>\\lambda<span class="math">), </span>g(\\tau)=0<span class="math"> for </span>\\tau<span class="math"> uniformly random in </span>\\mathbb{F}^{\\log m}<span class="math"> if and only if </span>g\\equiv 0<span class="math">, which implies that </span>f(1,x)-f(x,0)\\cdot f(x,1)=0<span class="math"> for all </span>x\\in\\{0,1\\}^{\\log m}<span class="math">. Set </span>\\mathcal{G}(x)=\\widehat{\\operatorname{eq}}(\\tau,x)(f(1,x)-f(x,0)\\cdot f(x,1))<span class="math">, where </span>\\mathcal{V}<span class="math"> picks a random </span>\\tau<span class="math">. Similarly, to prove that </span>v(x)=f(0,x)<span class="math"> for all </span>x\\in\\{0,1\\}^{\\ell}<span class="math"> it suffices to prove that </span>v(\\gamma)=f(0,\\gamma)<span class="math"> for a public coin </span>\\gamma\\in\\mathbb{F}^{\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, to prove the existence of <span class="math">f</span> and hence the grand product relationship, it suffices to prove, for some verifier selected random <span class="math">\\tau,\\gamma\\in_{R}\\mathbb{F}^{\\ell}</span>, that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">0=\\sum_{x\\in\\{0,1\\}^{\\log m}}\\widehat{\\operatorname{eq}}(x,\\tau)\\cdot(f(1,x)-f(x,0)\\cdot f(x,1))</span></li>

      <li><span class="math">f(0,\\gamma)=v(\\gamma)</span></li>

      <li><span class="math">f(1,\\ldots,1,0)=P</span>.</li>

    </ul>

    <p class="text-gray-300">SNARKs from combining the sum-check protocol with polynomial commitments. As in Spartan <em>[61]</em> and the compiler of Bunz et al. <em>[29]</em>, to build an interactive</p>

    <p class="text-gray-300">argument for grand products,  <span class="math">\\mathcal{P}</span>  sends to  <span class="math">\\nu</span>  commitments to polynomials  <span class="math">\\nu, f</span> .  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\nu</span>  run the sum-check reduction to reduce the first claim in the list above to an evaluation of  <span class="math">\\mathcal{G}</span>  at some point  <span class="math">r</span> , and  <span class="math">\\mathcal{P}</span>  uses Eval to convince  <span class="math">\\nu</span>  of the correctness of commitments to  <span class="math">f(0, r), f(1, r), f(r, 0), f(r, 1)</span>  and  <span class="math">f(1, \\ldots, 1, 0)</span> . This interactive argument is compiled to a SNARK by the Fiat-Shamir transform [40] in the random-oracle model.</p>

    <p class="text-gray-300">Spartan provides a compiler, called SPARK, to compile an existing polynomial commitment scheme for dense multilinear polynomials to ones that efficiently handle sparse multilinear polynomials. We now describe a modification of SPARK, which we call Sparkle, that reduces polynomial evaluation proof sizes—without substantially increasing the prover's costs.</p>

    <p class="text-gray-300">To evaluate a sparse multilinear polynomial whose dense representation is of size  <span class="math">m</span>  (§3.3), SPARK employs  <span class="math">O(m)</span> -sized circuit with  <span class="math">O(\\log m)</span>  depth. SPARK-derived polynomial commitment schemes implement Eval using a layered sum-check protocol [36, 44, 66] in conjunction with a polynomial commitment scheme [69]. The layered sum-check protocol alone produces  <span class="math">O(\\log^2 m)</span> -sized proofs for sparse polynomial evaluations. Inspecting [61, §7.2.1], The only portion of SPARK's circuit that requires a non-constant depth, is the evaluation of an element of a universal multiset hash function family, requiring the computation of a grand product over elements in a multiset  <span class="math">\\mathcal{M}</span> , where for each in  <span class="math">e \\in \\mathcal{M}</span> ,  <span class="math">e \\in \\mathbb{F}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {\\gamma} (\\mathcal {M}) = \\prod_ {e \\in \\mathcal {M}} (e - \\gamma)</span></div>

    <p class="text-gray-300">Of course, we can employ our special-purpose SNARK for proving grand product relations (§5) instead of using the layered sum-check protocol with  <span class="math">O(\\log m)</span> -depth circuit, bringing proof sizes from  <span class="math">O_{\\lambda}(\\log^2 m)</span>  to  <span class="math">O_{\\lambda}(\\log m)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dense PC choice</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( \\mathcal{P}_{\\text{Eval}} \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( \\mathcal{V}_{\\text{Eval}} \\)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  With SPARK:  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyrax-PC [69]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">public</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(m) \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(\\sqrt{m}) \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(\\log^2 m) \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(\\sqrt{m}) \\)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Virgo-VPD [72]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(m\\log m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(1) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log^2 m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log^2 m) \\)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis-PC</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(1) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log^2 m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\sqrt{m}) \\)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dory-PC [52]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(1) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log^2 m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log m) \\)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  With Sparkle:  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vSQL-VPD [73]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">private</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(m) \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(1) \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(\\log m) \\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\( O_{\\lambda}(\\log m) \\)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dory-PC [52]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(1) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log m) \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">\\( O_{\\lambda}(\\log m) \\)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 5—Costs of sparse polynomial commitments with different choices for dense PC. Here,  <span class="math">m</span>  is number of entries in the dense representation of the multilinear polynomial. Applying Sparkle to Hyrax-PC or Virgo-VPD does not improve proof sizes given their commitment sizes and proof sizes respectively.</p>

    <p class="text-gray-300">Unfortunately, the special-purpose SNARK requires the prover to compute commitments to polynomials that encode the intermediate state of the grand product computation. Whereas, with layered circuit approach, most of the commitments that are required are</p>

    <p class="text-gray-300">created as part of creating a computation commitment in a preprocessing step. Furthermore, the layered sum-check requires no cryptographic operations since claims about the outputs of each layer <span class="math">i</span> are reduced to claims about outputs of the previous layer of <span class="math">i</span>. Thus, if we naively apply the special-purpose SNARK, the prover’s costs increase by <span class="math">\\geq 10\\times</span> compared to a prover that uses the layered sum-check approach.</p>

    <p class="text-gray-300">To address this problem, we observe that in Spartan, grand products are computed over vectors of size <span class="math">\\approx</span>16<span class="math">n</span>, where <span class="math">n</span> is the size of the R1CS instance. Furthermore, we devise a hybrid scheme where we use a constant-depth layered circuit (in conjunction with a layered sum-check) to reduce the grand product instance size to <span class="math">\\approx$$n</span> (instead of 16<span class="math">n</span>) i.e., we apply a depth-4 layered sum-check before employing the special-purpose SNARK for grand product relations. The result is that the prover’s costs increase by <span class="math">\\approx</span>20%, which is reasonable, while providing asymptotic and concrete proof size improvements. Figure 5 depicts the asymptotic improvements of Sparkle-derived sparse polynomial commitment schemes compared to spark-derived schemes.</p>

    <h2 id="sec-34" class="text-2xl font-bold">7 Accelerating the encoder with an untrusted assistant</h2>

    <p class="text-gray-300">Prior work <em>[29, 35, 61]</em> employs a preprocessing phase where the verifier creates a commitment to the structure of an R1CS instance. For example, in Spartan, given the structure of an R1CS instance, <span class="math">(\\mathbb{F},A,B,C,m,n)</span>, and some public parameters <span class="math">pp</span>, the verifier creates commitments to three sparse multilinear polynomials: <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span>. Using spark (or <em>Sparkle</em>), this requires <span class="math">O(1)</span> commitments to dense multilinear polynomials in <span class="math">O(\\log n)</span> variables. Since <span class="math">\\mathcal{V}</span> relies on the correctness of the commitments, in prior work, <span class="math">\\mathcal{V}</span> computes them directly. For example, in Spartan, <span class="math">\\mathcal{V}</span> incurs <span class="math">O(n)</span> group exponentiations. A similar cost is incurred under both SuperSonic and Fractal to create such commitments. The linear cost is unavoidable, but we introduce a mechanism that enables the verifier to employ an untrusted <em>assistant</em>, which can be run by anyone including the prover. In the context of Spartan, this reduces reduces the cost of creating a computation commitment to be <span class="math">O(n)</span> multiplications over <span class="math">\\mathbb{F}</span> (<span class="math">\\mathcal{V}</span> also incurs exponentiations that are sub-linear in <span class="math">O(n)</span>). The improvement is substantial in practice (§9). This technique is general and applies to other schemes including SuperSonic and Fractal.</p>

    <p class="text-gray-300">Details. Suppose that we have an extractable polynomial commitment scheme for multilinear polynomials <span class="math">\\mathtt{PC}</span>. <span class="math">\\mathcal{V}</span> holds <span class="math">pp,pp_{\\mathbb{F}}</span>, which are public parameters for <span class="math">\\mathtt{PC}</span> and a commitment scheme for <span class="math">\\mathbb{F}</span>. To assist <span class="math">\\mathcal{V}</span> in computing a commitment <span class="math">\\mathcal{C}_{\\mathcal{G}}</span> to a dense multilinear polynomial <span class="math">\\mathcal{G}</span>, we have an untrusted assistant compute a commitment <span class="math">\\mathcal{C}</span> with some opening hint <span class="math">\\mathcal{S}</span>. The assistant <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{V}</span> then engage in an interactive protocol to convince <span class="math">\\mathcal{V}</span> that <span class="math">\\mathcal{C}</span> was computed correctly. Given <span class="math">\\mathcal{C},\\mathcal{G}</span> an <span class="math">\\ell</span>-variate multilinear polynomial shared between <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{V}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}\\to\\mathcal{V}</span>: <span class="math">(\\mathcal{C}_{v}~{};~{}\\mathcal{S}_{v})\\leftarrow\\texttt{Commit}_{\\mathbb{F}}(pp_{\\mathbb{F}}~{};v)</span></li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{A}</span>: <span class="math">r\\leftarrow_{\\mathbb{S}}\\mathbb{F}^{\\ell}</span></li>

      <li><span class="math">\\mathcal{A},\\mathcal{V}</span>: <span class="math">b_{poly}=\\mathtt{PC.Eval}(pp,pp_{\\mathbb{F}},\\mathcal{C},r,\\mathcal{C}_{v}~{};~{}\\mathcal{G},\\mathcal{S},\\mathcal{S}_{v})</span></li>

      <li><span class="math">\\mathcal{V}</span>: <span class="math">v\\leftarrow\\mathcal{G}(r)</span></li>

      <li><span class="math">\\mathcal{A},\\mathcal{V}</span>: <span class="math">b_{eval}=\\mathsf{Open}_{\\mathbb{F}}(pp_{\\mathbb{F}},\\mathcal{C}_{v},v,\\mathcal{S}_{v})</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Output <span class="math">b = b_{poly} \\wedge b_{eval}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 7.1.</strong> The above protocol is a public-coin succinct interactive argument of knowledge for the language: <span class="math">\\{\\langle (\\mathcal{C}_{\\mathcal{G}},\\mathcal{G}),(S_{\\mathcal{G}})\\rangle : \\text{Open}(pp,\\mathcal{C}_{\\mathcal{G}},\\mathcal{G},S_{\\mathcal{G}}) = 1\\}</span>, assuming the $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is exponential in the security parameter </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Completeness, succinctness, and public coin follow from the same properties of PC.Eval and <span class="math">\\text{Open}_{\\mathbb{F}}</span>. Since PC is extractable, there is some multilinear <span class="math">\\mathcal{G}&#x27;</span> underlying <span class="math">\\mathcal{C}</span> such that <span class="math">\\mathcal{C}_v</span> is a commitment to <span class="math">\\mathcal{G}&#x27;(r)</span>. Since the commitment to <span class="math">v \\in \\mathbb{F}</span> is binding, <span class="math">\\mathcal{G}&#x27;(r) = v = \\mathcal{G}(r)</span>. So <span class="math">\\mathcal{G}</span> and <span class="math">\\mathcal{G}&#x27;</span> are equal at a randomly chosen <span class="math">r</span>, and so by the Schwartz-Zippel lemma <span class="math">\\mathcal{G} = \\mathcal{G}&#x27;</span>, except for a soundness error of $O(\\log m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\approx \\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Like Spartan [61], Xiphos, Kopis, and Lakonia require a zero-knowledge sum-check protocol: given a commitment <span class="math">\\mathcal{C}_F</span> to a <span class="math">\\ell</span>-variate polynomial <span class="math">F(x)</span> of degree <span class="math">d</span> in each variable, and a commitment <span class="math">\\mathcal{C}_y</span> to <span class="math">y \\in \\mathbb{F}</span>, we reduce a claim of the form <span class="math">y = \\sum_{x \\in \\{0,1\\}^\\ell} F(x)</span> to another commitment <span class="math">C_{y&#x27;}</span> to <span class="math">y&#x27; \\in \\mathbb{F}</span> and a claim that <span class="math">y&#x27; = F(r)</span>, where <span class="math">r \\in \\mathbb{F}^\\ell</span>.</p>

    <p class="text-gray-300">Recall that the non-hiding sum-check proceeds as follows (§3.8). After <span class="math">i</span> rounds, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> share some <span class="math">r_1, \\ldots, r_i \\in \\mathbb{F}</span>, and some target scalar <span class="math">s \\in \\mathbb{F}</span> which is initialized to <span class="math">y</span>. They then follow the following round of the protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">f_i(X) = \\sum_{x \\in \\{0,1\\}^{\\ell - i - 1}} F(r_1, \\ldots, r_i, X, x)</span></li>

      <li><span class="math">\\mathcal{V}</span>: Check that <span class="math">f_i(0) + f_i(1) = s</span></li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">r_{i+1} \\gets_{\\</span>} \\mathbb{F}$.</li>

      <li><span class="math">\\mathcal{P}, \\mathcal{V}</span>: <span class="math">s = f_i(r_{i+1})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">y&#x27;</span> is the value of <span class="math">s</span> at the last round. Additionally, <span class="math">\\mathcal{P}</span> must prove to <span class="math">\\mathcal{V}</span> that <span class="math">F(r) = s</span>, which is performed with an auxiliary protocol (e.g., polynomial commitments).</p>

    <p class="text-gray-300">In Spartan, the sum-check protocol is made zero-knowledge with techniques from Hyrax [68]. The core observation is that <span class="math">\\mathcal{V}</span> only computes linear functions of the polynomials that <span class="math">\\mathcal{P}</span> sends. So <span class="math">\\mathcal{P}</span> can send linearly homomorphic commitments to the evaluations (or coefficients) of these polynomials, and <span class="math">\\mathcal{V}</span> can manipulate the commitments to obtain <span class="math">C_{y&#x27;}</span> with some known <span class="math">S_{y&#x27;}</span>. Unfortunately, this requires that <span class="math">\\mathcal{P}</span> send <span class="math">\\ell</span> commitments to vectors of <span class="math">O(d)</span> scalars, and later prove knowledge of their openings. For <span class="math">k</span> sum-checks this contributes <span class="math">O(k\\ell + d)</span> group elements to the proof and exponentiations to verification, which is concretely expensive.</p>

    <p class="text-gray-300">We take a different approach, conceptually closer to the zero-knowledge sum-check of from Chiesa et al. [33] and follow-up adaptations [71, 72]. This allows us to replace these <span class="math">O(k\\ell + d)</span> costs with an <span class="math">O(kd + \\ell)</span> costs, which is concretely smaller. The idea in this case is that <span class="math">\\mathcal{P}</span> will choose a suitably random polynomial <span class="math">G</span> and send an extractable commitment <span class="math">\\mathcal{C}_G</span> to it to the verifier, along with a claimed value in <span class="math">z \\in \\mathbb{F}</span> for <span class="math">\\sum_{x \\in \\{0,1\\}^\\ell} F(x) + G(x)</span>. A non-hiding sum-check will then be performed on <span class="math">F + G</span> to obtain a claim <span class="math">z&#x27; = F(r) + G(r)</span>; analysis of the randomness of <span class="math">G</span> will show that the transcript of this sum-check is independent of <span class="math">F</span>. <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> will then use Eval and a</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">standard sigma protocol to prove the consistency of commitments <span class="math">C_y, C_{y&#x27;}</span>, commitments to evaluations of <span class="math">G</span>, and <span class="math">z, z&#x27;</span>.</p>

    <p class="text-gray-300"><strong>Definition 8.1.</strong> We call a multilinear polynomial in <span class="math">\\ell</span> variables of form:</p>

    <div class="my-4 text-center"><span class="math-block">g(X) = b_0 \\prod_{i=1}^{\\ell} (1 - X_i) + \\sum_{i=1}^{\\ell} b_i (2X_i - 1) \\prod_{j=1, j \\neq i}^{\\ell} (1 - X_j)</span></div>

    <p class="text-gray-300">a low-weight polynomial.</p>

    <p class="text-gray-300"><strong>Lemma 8.1.</strong> Low-weight polynomials are exactly <span class="math">\\ell</span>-variable multilinear polynomials whose support on <span class="math">\\{0,1\\}^\\ell</span> is contained in <span class="math">\\{(0,\\ldots,0), e_1, \\ldots, e_\\ell\\}</span></p>

    <p class="text-gray-300"><strong>Proof.</strong> For <span class="math">g</span> a low-weight polynomial as above, <span class="math">g(0, \\ldots, 0) = b_0 - \\sum_{i=1}^{\\ell} b_i</span> and for all <span class="math">i \\in \\{1, \\ldots, \\ell\\}</span> and <span class="math">g(e_i) = b_i</span>; for all other points on the Boolean hypercube at least 2 of the <span class="math">X_i</span> are 1 and so every term vanishes. Conversely, let <span class="math">f</span> be a multilinear polynomial whose support on the Boolean hypercube is contained in <span class="math">\\{(0, \\ldots, 0), e_1, \\ldots, e_\\ell\\}</span>. Then let <span class="math">b_i = f(e_i)</span> and <span class="math">b_0 = f(0, \\ldots, 0) + \\sum_i f(e_i)</span>, and define <span class="math">g</span> as above. Then <span class="math">g</span> and <span class="math">f</span> are now two multilinear polynomials that agree on <span class="math">\\{0, 1\\}^\\ell</span> and so <span class="math">g = f</span>.</p>

    <p class="text-gray-300"><strong>Lemma 8.2.</strong> For a low-weight polynomial <span class="math">g</span>, the polynomial in the first variable obtained by summing over the hypercube: <span class="math">\\sum_{x \\in \\{0,1\\}^{\\ell-1}} g(X,x) = (b_0 - b_1) + (2b_1 - b_0)X</span>, which is independent of <span class="math">b_2, \\ldots, b_i</span>.</p>

    <p class="text-gray-300"><strong>Lemma 8.3.</strong> When a variable of a low-weight polynomial is bound, the resulting polynomial is still low-weight:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} g(r, X) &amp;amp;= \\left[ b_0 (1 - r) + (2r - 1) b_1 \\right] \\prod_{i=1}^{\\ell-1} (1 - X_i) \\\\ &amp;amp;\\quad + \\sum_{i=1}^{\\ell-1} \\left[ b_{i+1} (1 - r) \\right] (2X_i - 1) \\prod_{j=1, j \\neq i}^{\\ell-1} (1 - X_j) \\end{aligned}</span></div>

    <p class="text-gray-300"><strong>Lemma 8.4.</strong> Let <span class="math">g</span> be a uniformly random low-weight polynomial, and for some <span class="math">r \\in \\mathbb{F}^\\ell</span> define for <span class="math">i \\in \\{0, \\ldots, \\ell-1\\}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">g_i(X) = \\sum_{x \\in \\{0,1\\}^{\\ell - i - 1}} g(r_1, \\ldots, r_i, X, x).</span></div>

    <p class="text-gray-300">Then if <span class="math">\\forall i: r_i \\neq 1</span>, the <span class="math">g_i</span> are a sequence of independent, uniformly random linear polynomials, subject to the constraint <span class="math">\\forall i &amp;gt; 0: g_{i-1}(r_i) = g_i(0) + g_i(1)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> That <span class="math">g_{i-1}(r_i) = g_i(0) + g_i(1)</span> is clear from the definition of the <span class="math">g_i</span>.</p>

    <p class="text-gray-300">Since <span class="math">g</span> is uniformly random, we have <span class="math">b \\leftarrow_{\\S} \\mathbb{F}^{\\ell+1}</span>. So <span class="math">g_0</span> is uniformly random as <span class="math">b_0, b_1</span> are uniformly random and independent. Note that <span class="math">g_0, \\ldots, g_{i-1}</span> are independent of <span class="math">b_{i+1}</span>, whilst <span class="math">g_i</span> has a contribution <span class="math">b_{i+1} \\prod_{j \\leq i} (1 - r_j)(2X - 1)</span>. Since <span class="math">g_i(0) + g_i(1)</span> is fixed, <span class="math">g_i</span> has one degree of freedom, and so if <span class="math">\\forall j \\leq i: r_j \\neq 1</span> we have <span class="math">g_i</span> uniformly random and independent of <span class="math">b_j</span> for <span class="math">j \\leq i</span>.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">In particular, the Prover samples <span class="math">d</span> random low-weight polynomials <span class="math">g^{1},\\ldots ,g^{d}</span> uniformly at random, and writing <span class="math">X^{j} = (X_{1}^{j},\\dots ,X_{\\ell}^{j})</span>, sets:</p>

    <div class="my-4 text-center"><span class="math-block">G (X) = \\sum_ {i \\in 1 \\dots d} g ^ {i} (X ^ {j}).</span></div>

    <p class="text-gray-300">The commitment to <span class="math">G</span> will be a vector of hiding, blinding commitments to the multilinear polynomials <span class="math">g^i</span>.</p>

    <p class="text-gray-300">Corollary 8.1. For <span class="math">\\operatorname{ord}_{\\mathbb{F}}(r_i) &amp;gt; d</span>, and <span class="math">g^i</span> sampled uniformly at random, the polynomials <span class="math">G_i(X) = \\sum_{x \\in \\{0,1\\}^{\\ell - i - 1}} G(r[1 \\ldots i], X, x)</span> are independent, uniformly random polynomials of degree <span class="math">d</span> subject to the condition that: <span class="math">\\forall i &amp;gt; 0 : G_{i-1}(r_i) = G_i(0) + G_i(1)</span>.</p>

    <p class="text-gray-300">Proof. Since <span class="math">\\operatorname{ord}_{\\mathbb{F}}(r_i) &amp;gt; d</span>, we have <span class="math">r_i^j \\neq 1</span> for any <span class="math">j \\leq d</span>. So by the previous lemma, <span class="math">g^j(X^j)</span> contributes an independent, uniformly random linear combination of in <span class="math">1, X^j</span> to <span class="math">G_i</span>, subject to the constraint that <span class="math">g_{i-1}^j(r_i^j) = g_i(0) + g_i(1)</span>. Since the <span class="math">g^j</span> are independent, <span class="math">G_i</span> has independent, uniformly random coefficients in <span class="math">X^j</span> for all <span class="math">j &amp;gt; 0</span> and satisfies <span class="math">G_{i-1}(r_i) = G_i(0) + G_i(1)</span>. So the <span class="math">G_i</span> are independent and uniformly random polynomials of degree <span class="math">d</span> subject to this condition.</p>

    <p class="text-gray-300">It remains to relate the claims that <span class="math">z = \\sum_{x \\in \\{0,1\\}} F(x) + G(x)</span>, <span class="math">z&#x27; = F(r) + G(r)</span> to commitments <span class="math">\\mathcal{C}_y, \\mathcal{C}_{y&#x27;}, \\mathcal{C}_F, \\mathcal{C}_G</span>. In this protocol, we make use of <span class="math">2^{-1}</span> and assume that <span class="math">\\mathbb{F}</span> is not of characteristic 2.</p>

    <p class="text-gray-300">Recall that the commitments to elements of <span class="math">\\mathbb{F}</span> are Pedersen commitments with generators <span class="math">pp_{\\mathbb{F}} = (P_G, P_H)</span>, i.e. that <span class="math">\\mathrm{Commit}_{\\mathbb{F}}(x) = (pp_{\\mathbb{F}}; xP_G + rP_H; r)</span> for <span class="math">r \\gets_{\\</span>} \\mathbb{F}$.</p>

    <p class="text-gray-300">ZK-sumcheck-reduce <span class="math">(C_y)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span> witness: <span class="math">y = \\sum_{x\\in \\{0,1\\}^{\\ell}}F(x)</span>, opening hint for <span class="math">C_y</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>: <span class="math">\\forall i\\in 1\\dots \\ell :g^{i}\\gets_{\\</span>}\\{\\text{low - weight polynomials in}\\ell \\text{variables}\\}$</p>

    <div class="my-4 text-center"><span class="math-block">z \\leftarrow y + \\sum_ {i} \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} g ^ {i} (x)</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>: <span class="math">(\\mathcal{C}_{g^i};\\mathcal{S}_{g^i})\\gets \\mathrm{Commit}(pp;g^i)</span> for <span class="math">i\\in 1,\\ldots ,\\ell</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}\\to \\mathcal{V}</span>: <span class="math">\\{C_{g^i}:i\\in [1,\\ldots ,\\ell ]\\} ,z</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P},\\mathcal{V}</span>: <span class="math">(r,z^{\\prime})\\gets</span> Sumcheck-reduce <span class="math">(z)</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>: <span class="math">(\\mathcal{C}_{h^i};\\mathcal{S}_{h^i})\\gets \\mathrm{Commit}_{\\mathbb{F}}(pp_{\\mathbb{F}};g^i (r^i))</span> for <span class="math">i\\in 1,\\ldots ,\\ell</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}\\to \\mathcal{V}</span>: <span class="math">\\{C_{h^i}:i\\in [1,\\ldots ,\\ell ]\\}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P},\\mathcal{V}</span> <span class="math">C_{\\sum g^{i}}=\\sum_{i}C_{g_{i}}</span>,</p>

    <p class="text-gray-300"><span class="math">C_{\\mathbb{E}(\\sum g^{i})}=2^{-\\ell}(zP_{G}-C_{y})</span>,</p>

    <p class="text-gray-300"><span class="math">\\text{Assert}(\\text{Eval}(pp,pp_{\\mathbb{F}};C_{\\sum g^{i}},C_{\\mathbb{E}(\\sum g^{i})}),(2^{-1},\\ldots,2^{-1}))</span></p>

    <p class="text-gray-300"><span class="math">\\forall i:\\text{Assert}(\\text{Eval}(pp,pp_{\\mathbb{F}};C_{g^{i}},C_{h^{i}},r^{i}))</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P},\\mathcal{V}</span> <span class="math">C_{y^{\\prime}}\\leftarrow z^{\\prime}P_{G}-\\sum_{i}C_{h^{i}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> Return <span class="math">(r,C_{y^{\\prime}})</span></p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 8.1.</h6>

    <p class="text-gray-300">The above protocol is complete, computationally sound, and zero-knowledge with respect to <span class="math">F,y</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness is immediate; <span class="math">\\mathcal{P}</span> uses <span class="math">F(X)+\\sum g^{i}(X^{i})</span> in the Sumcheck-reduce, and can open <span class="math">C_{y^{\\prime}}</span> to <span class="math">y^{\\prime}=z^{\\prime}-\\sum_{i}h^{i}=F(r)</span>.</p>

    <p class="text-gray-300">We will show computational soundness assuming that Eval and the Pedersen commitments to elements of <span class="math">\\mathbb{F}</span> are sound. From the soundness of Eval, the second set of checks imply that <span class="math">C_{h^{i}}</span> are commitments to evaluations of <span class="math">g^{i}</span> at <span class="math">r^{i}</span>. Since Pedersen commitments are linearly homomorphic, their sum is a commitment to <span class="math">G(r)</span>. So if <span class="math">C_{y^{\\prime}}</span> is a commitment to <span class="math">F(r)</span> then <span class="math">z^{\\prime}</span> must equal <span class="math">F(r)+G(r)</span>. Sumcheck-reduce ensures that if <span class="math">z^{\\prime}=F(r)+G(r)</span> with non-negligible probability and <span class="math">F,G</span> are of low degree, then <span class="math">z=\\sum_{x\\in\\{0,1\\}}F(x)+G(x)</span> Note that for any multilinear polynomial <span class="math">p</span> in <span class="math">\\ell</span> variables and <span class="math">i&gt;0</span>:</p>

    <p class="text-gray-300"><span class="math">\\sum_{x\\in\\{0,1\\}^{\\ell}}p(x^{i})=\\sum_{x\\in\\{0,1\\}^{\\ell}}p(x)=2^{\\ell}p(2^{-1},\\ldots,2^{-1})).</span></p>

    <p class="text-gray-300">So since Eval is sound, the first check on <span class="math">C_{\\sum g^{i}}</span> proves that <span class="math">C_{\\mathbb{E}(\\sum g^{i})}</span> is a commitment to <span class="math">\\sum_{x\\in\\{0,1\\}}G(x)</span>. Then since Pedersen commitments are linearly homomorphic, <span class="math">C_{y}</span> must be a commitment to <span class="math">\\sum_{x\\in\\{0,1\\}}F(x)</span>.</p>

    <p class="text-gray-300">So this protocol reduces a claim that <span class="math">C_{y}</span> is a commitment to the sum of <span class="math">F</span> on the cube to a claim that <span class="math">C_{y^{\\prime}}</span> is a commitment to <span class="math">F(r)</span>.</p>

    <p class="text-gray-300">To see zero-knowledge with respect to <span class="math">F,y</span>, we will show that <span class="math">\\mathcal{P}</span>’s messages are independent of <span class="math">F</span> and <span class="math">y</span>. Initially, Prover sends</p>

    <p class="text-gray-300"><span class="math">z=y+\\sum_{i=1\\ldots\\ell}\\sum_{x\\in\\{0,1\\}^{\\ell}}g^{i}(x),</span></p>

    <p class="text-gray-300">which is plainly independent of <span class="math">F</span>. The remaining messages from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span> outside of the interior, non-hiding sumcheck are all independent hiding commitments. So it suffices to show that the <span class="math">\\mathcal{P}\\to\\mathcal{V}</span> messages in a non-hiding sumcheck on <span class="math">F+G</span> are independent of <span class="math">F</span> given the randomness of <span class="math">G</span> and conditional on <span class="math">z</span>.</p>

    <p class="text-gray-300">The remaining messages in the sum-check are a series of <span class="math">\\ell-1</span> degree-<span class="math">d</span> polynomials <span class="math">p_{i}(X)</span> such that <span class="math">p_{0}(0)+p_{0}(1)=z</span> and for all <span class="math">i&gt;0,p_{i}(0)+p_{i}(1)=p_{i-1}(r_{i})</span> For a prover following the protocol, we have <span class="math">p_{i}(X)=F_{i}(X)+G_{i}</span>, where by Corollary 8.1 the <span class="math">G_{i}</span> are uniformly random and independent, subject to <span class="math">G_{i-1}(r_{i})=G_{i}(0)+G_{i}(1)</span>. Since the <span class="math">p_{i}</span> must obey this constraint, they are independent of <span class="math">F</span>. ∎</p>

    <p class="text-gray-300">###</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Implementation</h4>

    <p class="text-gray-300">Any extractable polynomial commitment scheme can be used as a black box for the low-weight polynomials. However, as each is a linear function of the <span class="math">\\ell+1</span> values <span class="math">b_{i}</span>, it is concretely efficient to commit to them with Pedersen commitments to their vectors <span class="math">b</span>. These commitments have the necessary linearity properties, and Eval is implemented with a linear-time (i.e. <span class="math">O(\\ell)</span>) naive inner-product proof.</p>

    <h2 id="sec-39" class="text-2xl font-bold">9 Experimental evaluation</h2>

    <p class="text-gray-300">This section experimentally evaluates our implementations of Kopis, Xiphos, and Lakonia, and compares them with a set of baselines.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Metrics and methodology.</h4>

    <p class="text-gray-300">Our evaluation metrics are: (1) the prover’s costs to produce a proof; (2) the verifier’s costs to preprocess the structure of an R1CS instance; (3) the verifier’s costs to verify a proof; and (4) the size of a proof. We measure CPU costs using a real-time clock; we measure proof sizes by serializing proof data structures to byte strings. For our schemes, we employ cargo bench to measure performance, and for baselines, we use the profilers provided with their open source code.</p>

    <p class="text-gray-300">We run our experiments on an Azure Standard F16s_v2 virtual machine (16 vCPUs, 32 GB memory) with Ubuntu 20.10. We report results from a single-threaded configuration since not all our baselines leverage multiple cores. As with prior work <em>[20, 35, 61]</em>, we vary the size of the R1CS instance by varying the number of constraints and variables <span class="math">m</span> and maintain the ratio <span class="math">n/m</span> to approximately 1.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Baselines.</h4>

    <p class="text-gray-300">For Kopis and Xiphos, the baselines are: (1) Spartan <em>[61]</em>, (2) Fractal <em>[35]</em>, and (3) SuperSonic <em>[29]</em>. For Spartan, we use its open-source implementation <em>[7]</em>; we also report its performance with our optimizations such as batched polynomial evaluations, which we refer to as Spartan++. For Fractal, we use its open-source implementations from libiop <em>[55]</em>, configured to provide provable security.</p>

    <p class="text-gray-300">Finally, since there does not exist a prior implementation of SuperSonic, we estimate its performance using the authors’ cost models and microbenchmarks. We microbenchmark the cost of an exponentiation in a class group with random 128-bit size exponents using the ANTIC library <em>[1]</em>, which offers a fast class group implementation. We find that each class group exponentiation costs <span class="math">\\approx</span>38 ms. In our estimates of SuperSonic, we ignore the costs of scalar arithmetic (in their information-theoretic proof system) and count only the costs incurred by their polynomial commitment scheme (this is optimistic for SuperSonic and pessimistic to our schemes). Furthermore, our estimates assume standard optimizations such as the Pippenger’s algorithm for multiexponentiation.</p>

    <p class="text-gray-300">For Lakonia, the baselines are: (1) Ligero <em>[11]</em>, (2) Hyrax <em>[69]</em>, and (3) Aurora <em>[20]</em>. For Ligero and Aurora, we use their open-source implementations from libiop <em>[55]</em>, configured to provide provable security, and for Hyrax, we use its reference implementation <em>[54]</em>. Additional baselines for Lakonia include STARK <em>[16]</em> and Bulletproofs <em>[31]</em>. Given the lack of a standard implementation, we report their performance from prior measurements in Figure 3.</p>

    <p class="text-gray-300">Prover. Figure 6 depicts the prover's costs under Kopis, Xiphos, and their baselines. At  <span class="math">2^{20}</span>  constraints, Xiphos and Kopis are  <span class="math">\\approx 3.8\\times</span>  more expensive than Spartan, which features the fastest prover in the literature. Most of this slowdown can be attributed to the difference in speed between operations on ristretto2555 (used by Spartan) and on  <span class="math">\\mathbb{G}_1</span>  of b1s12-381 (used by our schemes). Furthermore, Spartan's underlying library for curve arithmetic [5] features an advanced implementation that leverages avx2 instructions to achieve up to  <span class="math">2\\times</span>  higher speed. With a faster implementation of curve arithmetic on b1s12-381, we believe this gap can be reduced substantially. Compared to SuperSonic (which offers the shortest proofs in the literature), Kopis and Xiphos are up to  <span class="math">376\\times</span>  faster. Finally, compared to Fractal, Kopis and Xiphos are  <span class="math">\\approx 4.5\\times</span>  faster at  <span class="math">2^{18}</span>  constraints (we could not run Fractal beyond  <span class="math">2^{18}</span>  constraints as it runs out of memory).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">599</td>

            <td class="px-3 py-2 border-b border-gray-700">1160</td>

            <td class="px-3 py-2 border-b border-gray-700">2240</td>

            <td class="px-3 py-2 border-b border-gray-700">4360</td>

            <td class="px-3 py-2 border-b border-gray-700">8500</td>

            <td class="px-3 py-2 border-b border-gray-700">16600</td>

            <td class="px-3 py-2 border-b border-gray-700">32500</td>

            <td class="px-3 py-2 border-b border-gray-700">63800</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">5.9</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">6.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

            <td class="px-3 py-2 border-b border-gray-700">5.7</td>

            <td class="px-3 py-2 border-b border-gray-700">10.2</td>

            <td class="px-3 py-2 border-b border-gray-700">15.4</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">169</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof sizes. Figure 7 depicts the proof sizes under Kopis, Xiphos, and their baselines. It is easy to see that Xiphos offers proof sizes competitive with SuperSonic. <span class="math">^{9}</span>  Furthermore, Kopis offers the shortest proofs, both concretely and asymptotically. Proof sizes under our schemes are orders of magnitude shorter than those produced by Fractal. Although Spartan produces proofs shorter than Xiphos at small instance sizes, Xiphos's superior asymptotics are visible around  <span class="math">2^{13}</span>  constraints. Finally, Spartan++ features modest improvements in proof sizes over Spartan.</p>

    <p class="text-gray-300">FIGURE 6—Prover's performance (in seconds) for varying R1CS instance sizes under different schemes. Fractal's prover runs out of memory at  <span class="math">2^{18}</span>  constraints and beyond.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal</td>

            <td class="px-3 py-2 border-b border-gray-700">1M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8M</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1M</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3M</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">41.7</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">98</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">142</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

            <td class="px-3 py-2 border-b border-gray-700">89</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 7—Proof sizes in KBs. Entries with “M” suffix are in MBs.</p>

    <p class="text-gray-300">Verifier. Figure 8 depicts verifier's costs to verify a proof under Kopis, Xiphos, and their baselines. As we can see, Xiphos offers a verifier that is faster than SuperSonic—despite sharing the same asymptotics. Xiphos overtakes Spartan at roughly  <span class="math">2^{18}</span>  constraints</p>

    <p class="text-gray-300">despite Spartan using an advanced implementation of curve arithmetic—because of Xiphos's better asymptotics. Kopis is slower than Xiphos and Spartan, but is concretely faster than SuperSonic at all instance sizes we measured. Finally, Spartan++ features modest improvements in verification times over Spartan.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9s</td>

            <td class="px-3 py-2 border-b border-gray-700">2s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">141</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">188</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">77</td>

            <td class="px-3 py-2 border-b border-gray-700">99</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">68</td>

            <td class="px-3 py-2 border-b border-gray-700">97</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis</td>

            <td class="px-3 py-2 border-b border-gray-700">68</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">185</td>

            <td class="px-3 py-2 border-b border-gray-700">236</td>

            <td class="px-3 py-2 border-b border-gray-700">278</td>

            <td class="px-3 py-2 border-b border-gray-700">390</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 8—Verifier's performance (in ms) under different schemes. Entries with "s" are in seconds.</p>

    <p class="text-gray-300">Verifier's preprocessing (encoder). Figure 9 depicts the verifier's preprocessing costs to create a computation commitment to the structure of an R1CS instance. For Kopis, Xiphos, and Spartan++, we depict the costs of an untrusted assistant in addition to reporting the cost of an encoder. It is easy to see that the use of an untrusted assistant improves preprocessing costs substantially under Xiphos, Kopis, and Spartan++, with speedups of  <span class="math">10 - 10,000 \\times</span>  depending on the baseline. Furthermore, the assistant under Xiphos (and Kopis) is substantially cheaper than the encoders of SuperSonic and Fractal, and is  <span class="math">\\approx 2.5 \\times</span>  of the encoder under Spartan.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">400</td>

            <td class="px-3 py-2 border-b border-gray-700">747</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4k</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6k</td>

            <td class="px-3 py-2 border-b border-gray-700">4.9k</td>

            <td class="px-3 py-2 border-b border-gray-700">9.4k</td>

            <td class="px-3 py-2 border-b border-gray-700">17.9k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">11.5</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">227</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5</td>

            <td class="px-3 py-2 border-b border-gray-700">9.9</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++ (A)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7</td>

            <td class="px-3 py-2 border-b border-gray-700">7.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++ (E)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.005</td>

            <td class="px-3 py-2 border-b border-gray-700">0.007</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.016</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.23</td>

            <td class="px-3 py-2 border-b border-gray-700">0.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis (A)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3.4</td>

            <td class="px-3 py-2 border-b border-gray-700">6.2</td>

            <td class="px-3 py-2 border-b border-gray-700">8.6</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kopis (E)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">0.11</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos (A)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Xiphos (E)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08</td>

            <td class="px-3 py-2 border-b border-gray-700">0.16</td>

            <td class="px-3 py-2 border-b border-gray-700">0.27</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 9—Encoder's performance (in seconds) for varying R1CS instance sizes under different schemes. Entries with suffix "k" are in thousands. For Kopis, Xiphos, and Spartan++, we depict two rows each. Rows with "A" denote the cost of the untrusted assistant and rows with "E" denote the cost of the encoder with advice from an untrusted assistant.</p>

    <p class="text-gray-300">Lakonia and its baselines do not require the verifier to incur any preprocessing costs, so we focus on reporting the prover's costs, the verifier's costs, and proof sizes.</p>

    <p class="text-gray-300">Prover. Figure 10 depicts the performance of the prover under Lakonia and its baselines. Lakonia is faster than all its baselines except the NIZK variant of Spartan. The slowdown relative to Spartan is analogous to the slowdown of Kopis and Xiphos relative to Spartan. Nevertheless, at  <span class="math">2^{20}</span>  constraints, Lakonia is  <span class="math">\\approx 3.6 \\times</span>  faster than Ligero, and  <span class="math">\\approx 25 \\times</span>  faster than Aurora and Hyrax.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">117</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">486</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5</td>

            <td class="px-3 py-2 border-b border-gray-700">13.3</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">116</td>

            <td class="px-3 py-2 border-b border-gray-700">236</td>

            <td class="px-3 py-2 border-b border-gray-700">485</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.09</td>

            <td class="px-3 py-2 border-b border-gray-700">0.16</td>

            <td class="px-3 py-2 border-b border-gray-700">0.27</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700">0.14</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lakonia</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof sizes. Figure 11 depicts proof sizes under Lakonia and its baselines. Bulletproofs (not depicted) offers the shortest proof sizes:  <span class="math">\\approx 1.7\\mathrm{KB}</span>  for  <span class="math">2^{20}</span>  constraints. As reported earlier (Figure 3), Bulletproofs incurs orders of magnitude higher proving and verification costs than Lakonia. Besides Bulletproofs, Lakonia offers the shortest proof sizes, which are substantially shorter than most baseline proof systems. Thus, we believe Lakonia offers a new point in the design space of concretely-efficient proof systems.</p>

    <p class="text-gray-300">FIGURE 10—Prover's performance (in seconds) for varying R1CS instance sizes under different schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">546</td>

            <td class="px-3 py-2 border-b border-gray-700">628</td>

            <td class="px-3 py-2 border-b border-gray-700">1M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2M</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">5M</td>

            <td class="px-3 py-2 border-b border-gray-700">5M</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">20M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">447</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">610</td>

            <td class="px-3 py-2 border-b border-gray-700">717</td>

            <td class="px-3 py-2 border-b border-gray-700">810</td>

            <td class="px-3 py-2 border-b border-gray-700">931</td>

            <td class="px-3 py-2 border-b border-gray-700">1M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5M</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lakonia</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Verifier. Figure 12 depicts the costs of the verifier under Lakonia and its baselines. Despite sharing the same asymptotics, Lakonia's verifier is orders of magnitude faster than all its baselines. The only exception is Spartan where, at  <span class="math">2^{20}</span>  constraints, Lakonia is  <span class="math">\\approx 40\\%</span>  slower than Spartan.</p>

    <p class="text-gray-300">FIGURE 11—Proof sizes in KBs for Lakonia and its baselines. Entries with "M" are in megabytes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">210</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">211</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">213</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">214</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">357</td>

            <td class="px-3 py-2 border-b border-gray-700">680</td>

            <td class="px-3 py-2 border-b border-gray-700">976</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.3s</td>

            <td class="px-3 py-2 border-b border-gray-700">15s</td>

            <td class="px-3 py-2 border-b border-gray-700">31s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax</td>

            <td class="px-3 py-2 border-b border-gray-700">195</td>

            <td class="px-3 py-2 border-b border-gray-700">229</td>

            <td class="px-3 py-2 border-b border-gray-700">262</td>

            <td class="px-3 py-2 border-b border-gray-700">317</td>

            <td class="px-3 py-2 border-b border-gray-700">388</td>

            <td class="px-3 py-2 border-b border-gray-700">502</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.9s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora</td>

            <td class="px-3 py-2 border-b border-gray-700">186</td>

            <td class="px-3 py-2 border-b border-gray-700">316</td>

            <td class="px-3 py-2 border-b border-gray-700">574</td>

            <td class="px-3 py-2 border-b border-gray-700">933</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">6.7s</td>

            <td class="px-3 py-2 border-b border-gray-700">13s</td>

            <td class="px-3 py-2 border-b border-gray-700">27s</td>

            <td class="px-3 py-2 border-b border-gray-700">54s</td>

            <td class="px-3 py-2 border-b border-gray-700">108s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">98</td>

            <td class="px-3 py-2 border-b border-gray-700">194</td>

            <td class="px-3 py-2 border-b border-gray-700">369</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan++</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

            <td class="px-3 py-2 border-b border-gray-700">347</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lakonia</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">115</td>

            <td class="px-3 py-2 border-b border-gray-700">179</td>

            <td class="px-3 py-2 border-b border-gray-700">281</td>

            <td class="px-3 py-2 border-b border-gray-700">517</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FIGURE 12—Verifier's performance (in ms) under different schemes. Entries with "s" are in seconds.</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Justin Thaler for comments on a prior version of this paper.</p>

    <h2 id="sec-44" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Antic – algebraic number theory in c. https://github.com/wbhart/antic.</li>

      <li>[2] blstrs. https://github.com/filecoin-project/blstrs.</li>

      <li>[3] Ethereum Roadmap. ZK-Rollups. https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/.</li>

      <li>[4] ethSTARK. https://github.com/starkware-libs/ethSTARK.</li>

      <li>[5] A pure-Rust implementation of group operations on Ristretto and Curve25519. https://github.com/dalek-cryptography/curve25519-dalek.</li>

      <li>[6] The Ristretto group. https://ristretto.group/.</li>

      <li>[7] Spartan: High-speed zkSNARKs without trusted setup. https://github.com/Microsoft/Spartan.</li>

      <li>[8] Personal communication with Eli Ben-Sasson, Oct. 2020.</li>

      <li>[9] M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev, and M. Ohkubo. Structure-preserving signatures and commitments to group elements. In CRYPTO, pages 209–236, 2010.</li>

      <li>[10] M. Abe, J. Groth, M. Kohlweiss, M. Ohkubo, and M. Tibouchi. Efficient fully structure-preserving signatures and shrinking commitments. Journal of Cryptology, 32(3):973–1025, July 2019.</li>

      <li>[11] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In CCS, 2017.</li>

      <li>[12] S. Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. Proof verification and the hardness of approximation problems. J. ACM, 45(3), May 1998.</li>

      <li>[13] S. Arora and S. Safra. Probabilistic checking of proofs: A new characterization of NP. J. ACM, 45(1):70–122, Jan. 1998.</li>

      <li>[14] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy. Checking computations in polylogarithmic time. In STOC, 1991.</li>

      <li>[15] N. Barić and B. Pfitzmann. Collision-free accumulators and fail-stop signature schemes without trees. In EUROCRYPT, pages 480–494, 1997.</li>

      <li>[16] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent, and post-quantum secure computational integrity. ePrint Report 2018/046, 2018.</li>

      <li>[17] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In S&P, 2014.</li>

      <li>[18] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. On the concrete efficiency of probabilistically-checkable proofs. In STOC, pages 585–594, 2013.</li>

      <li>[19] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO, Aug. 2013.</li>

      <li>[20] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. In EUROCRYPT, 2019.</li>

      <li>[21] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In USENIX Security, 2014.</li>

      <li>[22] E. Ben-Sasson, O. Goldreich, P. Harsha, M. Sudan, and S. Vadhan. Short PCPs verifiable in polylogarithmic time. In Computational Complexity, 2005.</li>

      <li>[23] E. Ben-Sasson and M. Sudan. Short PCPs with polylog query complexity. SIAM J. Comput., 38(2):551–607, May 2008.</li>

      <li>[24] N. Bitansky, A. Chiesa, Y. Ishai, O. Paneth, and R. Ostrovsky. Succinct non-interactive arguments via linear interactive proofs. In TCC, 2013.</li>

      <li>[25] A. J. Blumberg, J. Thaler, V. Vu, and M. Walfish. Verifiable computation using multiple</li>

    </ul>

    <p class="text-gray-300">provers. ePrint Report 2014/846, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[26] D. Boneh, B. Bünz, and B. Fisch. A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712, 2018.</li>

      <li>[27] S. Bowe, A. Chiesa, M. Green, I. Miers, P. Mishra, and H. Wu. Zexe: Enabling decentralized private computation. ePrint Report 2018/962, 2018.</li>

      <li>[28] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Walfish. Verifying computations with state. In SOSP, 2013.</li>

      <li>[29] B. Bunz, B. Fisch, and A. Szepieniec. Transparent SNARKs from DARK compilers. ePrint Report 2019/1229, 2019.</li>

      <li>[30] B. Bunz, M. Maller, P. Mishra, and N. Vesely. Proofs for inner pairing products and applications. Cryptology ePrint Archive, Report 2019/1177, 2019.</li>

      <li>[31] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In S&P, 2018.</li>

      <li>[32] M. Campanelli, D. Fiore, and A. Querol. LegoSNARK: modular design and composition of succinct zero-knowledge proofs. ePrint Report 2019/142, 2019.</li>

      <li>[33] A. Chiesa, M. A. Forbes, and N. Spooner. A zero knowledge sumcheck and its applications. CoRR, abs/1704.02086, 2017.</li>

      <li>[34] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. ePrint Report 2019/1047, 2019.</li>

      <li>[35] A. Chiesa, D. Ojha, and N. Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. ePrint Report 2019/1076, 2019.</li>

      <li>[36] G. Cormode, M. Mitzenmacher, and J. Thaler. Practical verified computation with streaming interactive proofs. In ITCS, 2012.</li>

      <li>[37] A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, and B. Parno. Cinderella: Turning shabby X.509 certificates into elegant anonymous credentials with the magic of verifiable computation. In S&P, 2016.</li>

      <li>[38] S. Dobson, S. D. Galbraith, and B. Smith. Trustless construction of groups of unknown order with hyperelliptic curves. https://www.math.auckland.ac.nz/~sgal018/ANTS/posters/Dobson-Galbraith-Smith.pdf, 2020.</li>

      <li>[39] S. Dobson, S. D. Galbraith, and B. Smith. Trustless groups of unknown order with hyperelliptic curves. Cryptology ePrint Archive, Report 2020/196, 2020.</li>

      <li>[40] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, pages 186–194, 1986.</li>

      <li>[41] E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In CRYPTO, pages 16–30, 1997.</li>

      <li>[42] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In EUROCRYPT, 2013.</li>

      <li>[43] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC, pages 99–108, 2011.</li>

      <li>[44] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum. Delegating computation: Interactive proofs for muggles. In STOC, 2008.</li>

      <li>[45] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge complexity of interactive proof-systems. In STOC, 1985.</li>

      <li>[46] J. Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT, 2016.</li>

      <li>[47] J. Groth and Y. Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In EUROCRYPT, 2008.</li>

      <li>[48] M. Hamburg. Decaf: Eliminating cofactors through point compression. In CRYPTO, 2015.</li>

      <li>[49] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. In ASIACRYPT, pages 177–194, 2010.</li>

    </ul>

    <p class="text-gray-300">[50] J. Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In STOC, 1992.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[51] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In S&P, 2016.</li>

      <li>[52] J. Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. Cryptology ePrint Archive, Report 2020/xxx, 2020.</li>

      <li>[53] J. Lee, K. Nikitin, and S. Setty. Replicated state machines without replicated execution. In S&P, 2020.</li>

      <li>[54] libfennel. Hyrax reference implementation. https://github.com/hyraxZK/fennel.</li>

      <li>[55] libiop. A C++ library for IOP-based zkSNARK. https://github.com/scipr-lab/libiop.</li>

      <li>[56] libsnark. A C++ library for zkSNARK proofs. https://github.com/scipr-lab/libsnark.</li>

      <li>[57] C. Lund, L. Fortnow, H. Karloff, and N. Nisan. Algebraic methods for interactive proof systems. In FOCS, Oct. 1990.</li>

      <li>[58] S. Micali. CS proofs. In FOCS, 1994.</li>

      <li>[59] A. Ozdemir, R. S. Wahby, and D. Boneh. Scaling verifiable computation using efficient set accumulators. Cryptology ePrint Archive, Report 2019/1494, 2019.</li>

      <li>[60] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In S&P, May 2013.</li>

      <li>[61] S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. ePrint Report 2019/550, 2019.</li>

      <li>[62] S. Setty, S. Angel, T. Gupta, and J. Lee. Proving the correct execution of concurrent services in zero-knowledge. In OSDI, Oct. 2018.</li>

      <li>[63] S. Setty, S. Angel, and J. Lee. Verifiable state machines: Proofs that untrusted services operate correctly. ACM SIGOPS Operating Systems Review, 54(1):40–46, Aug. 2020.</li>

      <li>[64] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. In EuroSys, Apr. 2013.</li>

      <li>[65] S. Setty, V. Vu, N. Panpalia, B. Braun, A. J. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to practicality. In USENIX Security, Aug. 2012.</li>

      <li>[66] J. Thaler. Time-optimal interactive proofs for circuit evaluation. In CRYPTO, 2013.</li>

      <li>[67] V. Vu, S. Setty, A. J. Blumberg, and M. Walfish. A hybrid architecture for verifiable computation. In S&P, 2013.</li>

      <li>[68] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In NDSS, 2015.</li>

      <li>[69] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. Doubly-efficient zkSNARKs without trusted setup. In S&P, 2018.</li>

      <li>[70] B. Wesolowski. Efficient verifiable delay functions. In EUROCRYPT, pages 379–407, 2019.</li>

      <li>[71] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. ePrint Report 2019/317, 2019.</li>

      <li>[72] J. Zhang, T. Xie, Y. Zhang, and D. Song. Transparent polynomial delegation and its applications to zero knowledge proof. In S&P, 2020.</li>

      <li>[73] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In S&P, 2017.</li>

    </ul>`;
---

<BaseLayout title="Quarks: Quadruple-efficient transparent zkSNARKs (2020/1275)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1275
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
