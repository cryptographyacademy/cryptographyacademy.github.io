---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1057';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'MuSig-DN: Schnorr Multi-Signatures with Verifiably Deterministic Nonces';
const AUTHORS_HTML = 'Jonas Nick, Tim Ruffing, Yannick Seurin, Pieter Wuille';

const CONTENT = `    <p class="text-gray-300">Jonas Nick^{1}, Tim Ruffing^{1}, Yannick Seurin^{2}, and Pieter Wuille^{1}</p>

    <p class="text-gray-300">^{1} Blockstream jonas@n-ck.net crypto@timruffing.de pieter@wuille.net ^{2} ANSSI, Paris, France yannick.seurin@m4x.org</p>

    <p class="text-gray-300">Abstract. MuSig is a multi-signature scheme for Schnorr signatures, which supports key aggregation and is secure in the plain public key model. Standard derandomization techniques for discrete logarithm-based signatures such as RFC 6979, which make the signing procedure immune to catastrophic failures in the randomness generation, are not applicable to multi-signatures as an attacker could trick an honest user into producing two different partial signatures with the same randomness, which would reveal the user’s secret key.</p>

    <p class="text-gray-300">In this paper, we propose a variant of MuSig in which signers generate their nonce deterministically as a pseudorandom function of the message and all signers’ public keys and prove that they did so by providing a non-interactive zero-knowledge proof to their cosigners. The resulting scheme, which we call MuSig-DN, is the first Schnorr multi-signature scheme with deterministic signing. Therefore its signing protocol is robust against failures in the randomness generation as well as attacks trying to exploit the statefulness of the signing procedure, e.g., virtual machine rewinding attacks. As an additional benefit, a signing session in MuSig-DN requires only two rounds instead of three as required by all previous Schnorr multi-signatures including MuSig. To instantiate our construction, we identify a suitable algebraic pseudorandom function and provide an efficient implementation of this function as an arithmetic circuit. This makes it possible to realize MuSig-DN efficiently using zero-knowledge proof frameworks for arithmetic circuits which support inputs given in Pedersen commitments, e.g., Bulletproofs. We demonstrate the practicality of our technique by implementing it for the secp256k1 elliptic curve used in Bitcoin.</p>

    <p class="text-gray-300">Keywords: digital signatures, multi-signatures, Schnorr signatures, MuSig, non-interactive zero-knowledge proofs, deterministic nonces</p>

    <p class="text-gray-300">1 Introduction</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Background</h3>

    <p class="text-gray-300">Multi-signatures. A multi-signature scheme <em>[x10]</em> allows a group of signers, each having their own secret/public key pair <span class="math">(\\mathsf{sk}_{i},\\mathsf{pk}_{i})</span>, to collaboratively compute a short signature <span class="math">\\sigma</span> on a common message <span class="math">m</span>, ideally with a size independent of the number of the signers. This single signature can be verified given the message <span class="math">m</span> and the set of public keys <span class="math">\\{\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n}\\}</span>, convincing a verifier that every signer approved message <span class="math">m</span>.</p>

    <p class="text-gray-300">Multi-signature schemes require great caution to prevent <em>rogue-key attacks</em>, where the adversary, who is assumed to be able to choose its public key arbitrarily, computes it as a function of honest users’ public keys, allowing it to produce forgeries easily. Many early multi-signature schemes succumbed to such rogue-key attacks <em>[x15, x14, x11, x12, x13, x17, x18]</em>. As rogue-key attacks typically imply that the adversary does not know the secret key associated to its maliciously computed public key, one method for preventing them is to assume the existence of certification authority (CA) and require users to prove knowledge of their secret keys during public key registration. This is usually formalized as the <em>knowledge of secret key</em> (KOSK) assumption <em>[x3, LOS^{+}06, x22]</em>: the security model captures this registration step by demanding that the adversary provides the secret key for any (adversarially chosen) public key involved in its forgery. However, existing standards for registration protocols do not mandate that CAs require proofs of knowledge, and some settings (typically, decentralized applications such as cryptocurrencies) even exclude CAs and public key infrastructures by design. Hence, it is highly preferable to design multi-signature schemes provably secure in the <em>plain public-key model</em>, meaning that participants can create their public keys locally without the need to register them with a CA or any other central party in order to participate in the protocol.</p>

    <p class="text-gray-300">The very first multi-signature scheme provably secure in the plain public-key model <em>[x17]</em> relies on a dedicated key generation phase run by all potential signers, after which the set of potential signers is necessarily static and known in advance to verifiers. A major step was made by Bellare and Neven <em>[x2]</em> who proposed the first scheme (later referred to as BN in this paper) provably secure in the plain public-key model and without a dedicated key setup protocol.</p>

    <p class="text-gray-300">Key Aggregation. Motivated by the foreseen integration of Schnorr signatures <em>[x17]</em> in Bitcoin <em>[x20]</em>, Maxwell <em>et al.</em> proposed MuSig <em>[x13]</em>, a multi-signature protocol for Schnorr signatures provably secure in the plain public-key model. A prominent feature of this scheme (that BN <em>[x2]</em> was lacking) is <em>key aggregation</em>, meaning that the public keys of all cosigners can be aggregated into a single public key <span class="math">\\widetilde{\\mathsf{pk}}</span>. As a result, verifiers do not need to be given the explicit list of all participants’ public keys anymore, and they can just use the aggregate key instead. In fact, verifiers do not even need to know that <span class="math">\\widetilde{\\mathsf{pk}}</span> is an aggregate key and that signatures for this key are jointly generated by multiple signers. This enhances the privacy of the signers and allows for a clean separation between simple Schnorr signature verification (understood by ordinary Bitcoin nodes as part of the consensus rules) and the more complex interactive multi-signature protocol (only supported by Bitcoin wallets that generate MuSig signatures), which moreover makes it easier to deploy modifications to the multi-signature protocol. While these advantages apply directly to the case that funds are jointly controlled by multiple parties, “Taproot” <em>[x21]</em>, an extension proposed to be integrated in Bitcoin</p>

    <p class="text-gray-300">together with Schnorr signatures, applies the same advantages optimistically also to complex spending policies (colloquially referred to as smart contracts): in the common case that all involved parties are willing to cooperate, they can rely on a multi-signature without even revealing the existence of the smart contract, or even the involvement of more than one party, to the public.</p>

    <p class="text-gray-300">The MuSig Scheme. Let us recall the Schnorr signature scheme. Given an (additively denoted) group <span class="math">\\mathbb{G}</span> of prime order <span class="math">p</span> with generator <span class="math">G</span>, a secret/public key pair is a pair <span class="math">(x,X)\\in\\mathbb{F}_{p}\\times\\mathbb{G}</span> where <span class="math">X=xG</span>. To sign a message <span class="math">m</span>, the signer draws a <em>nonce</em> <span class="math">r</span> uniformly at random in <span class="math">\\mathbb{F}_{p}</span>, computes <span class="math">R=rG</span>, <span class="math">c=\\mathsf{H}_{\\mathrm{sig}}(X,R,m)</span>, and <span class="math">s=r+cx\\bmod p</span>, where <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span> is some hash function, and returns <span class="math">\\sigma=(R,s)</span>. A purported signature <span class="math">(R,s)</span> for message <span class="math">m</span> and public key <span class="math">X</span> is valid <em>iff</em> <span class="math">sG=R+\\mathsf{H}_{\\mathrm{sig}}(X,R,m)X</span>.</p>

    <p class="text-gray-300">In MuSig, the aggregate key associated with a group of <span class="math">n</span> signers, each holding a Schnorr key pair <span class="math">(x_{i},X_{i}=x_{i}G)</span>, is defined as <span class="math">\\widetilde{X}=\\sum_{i=1}^{n}\\mu_{i}X_{i}</span>, where <span class="math">\\mu_{i}</span> is a coefficient computed by hashing all participants’ public keys as <span class="math">\\mu_{i}=\\mathsf{H}_{\\mathrm{agg}}(\\{X_{1},\\ldots,X_{n}\\},X_{i})</span> for some hash function <span class="math">\\mathsf{H}_{\\mathrm{agg}}</span>. In order to jointly sign some message <span class="math">m</span>, each signer generates a partial nonce <span class="math">R_{i}=r_{i}G</span> and sends it to the other signers. Then, each signer computes the aggregate nonce <span class="math">\\widetilde{R}=\\sum_{i=1}^{n}R_{i}</span> and a partial signature <span class="math">s_{i}=r_{i}+c\\mu_{i}x_{i}\\bmod p</span> where <span class="math">c=\\mathsf{H}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> and sends <span class="math">s_{i}</span> to other signers. The multi-signature is <span class="math">(\\widetilde{R},s)</span> where <span class="math">s=\\sum_{i=1}^{n}s_{i}</span>. A multi-signature <span class="math">(\\widetilde{R},s)</span> for message <span class="math">m</span> and aggregate key <span class="math">\\widetilde{X}</span> can be verified exactly as a standard Schnorr signature.</p>

    <p class="text-gray-300">Importantly, signers “commit” to their partial nonce by sending <span class="math">t_{i}:=\\mathsf{H}_{\\mathrm{com}}(R_{i})</span> in the initial communication round, where <span class="math">\\mathsf{H}_{\\mathrm{com}}</span> is a hash function. The first version of <em>[x10]</em> omitted the commitment round (resulting in a 2-round protocol) but it was found by Drijvers <em>et al.</em> <em>[x3]</em> that the corresponding security proof was flawed. Drijvers <em>et al.</em> further showed that omitting this commitment round makes the scheme vulnerable to sub-exponential attacks based on Wagner’s algorithm for the generalized birthday problem <em>[x16]</em>. Maxwell <em>et al.</em> later revised <em>[x10]</em> to provide a security proof for the 3-round version which includes the commitment round. See also <em>[x1]</em> for an independent security proof of 3-round MuSig.</p>

    <p class="text-gray-300">Deterministic Nonces. Discrete logarithm-based signatures are well-known to be vulnerable to non-uniform generation of the nonce <span class="math">r</span> <em>[x12, x13]</em>, and there have been plenty of real-world vulnerabilities and attacks exploiting bad randomness in nonces <em>[x6, BHH^{+}14, x4, x14, x11]</em>. In particular, if the same nonce is used to sign two different messages, the secret key can immediately be computed from the two signatures. This can be prevented by using deterministic nonce generation, meaning the nonce <span class="math">r</span> is computed by applying a pseudorandom function (PRF) keyed with some secret key <span class="math">k</span> to the message <span class="math">m</span> <em>[x2, x14, x11, x12]</em>. This method does not only protect against failures in the randomness generation (e.g., due to a improperly seeded system PRG) but also against rewinding attacks, in which the attacker tries to obtain signatures with the same nonce on two different messages by resetting the signing algorithm, which potentially runs in a virtual machine (VM) and precomputes the nonce before the message is determined. As a side benefit, deterministic nonce generation allows to easily test implementations of the signature algorithm in a black-box manner using test vectors.</p>

    <p class="text-gray-300">However, as already noted by Maxwell et al. <em>[x10]</em>, deterministic nonce generation is not directly possible with existing multi-signature protocols based on Schnorr signatures such as MuSig. In fact, when one tries to apply the aforementioned standard method of generating nonces deterministically in order to improve their robustness against PRG failures and VM rewinding attacks, the security of these protocols breaks down entirely! Say Alice and Bob, holding respective keys <span class="math">(x_{1},X_{1})</span> and <span class="math">(x_{2},X_{2})</span>, want to compute a multi-signature on some message <span class="math">m</span>. Alice computes <span class="math">r_{1}</span> (say, as <span class="math">F_{x_{1}}(m)</span> for some pseudorandom function <span class="math">F</span>) and sends <span class="math">R_{1}=r_{1}G</span> to Bob who responds with <span class="math">R_{2}=r_{2}G</span>. Alice computes <span class="math">\\widetilde{R}=R_{1}+R_{2}</span> and her partial signature <span class="math">s_{1}=r_{1}+c\\mu_{1}x_{1}\\bmod p</span> where <span class="math">c=\\mathsf{H}_{\\text{sig}}(\\widetilde{X},\\widetilde{R},m)</span> and sends <span class="math">s_{1}</span> to Bob. However, Bob chooses not to (or maybe cannot) produce his partial signature and the protocol aborts. Later, a new signing attempt takes place for the same message and Alice again sends <span class="math">R_{1}</span>, but Bob responds with <span class="math">R_{2}^{\\prime}\\neq R_{2}</span>. Alice computes <span class="math">\\widetilde{R}^{\\prime}=R_{1}+R_{2}^{\\prime}</span> and <span class="math">s_{1}^{\\prime}=r_{1}+c^{\\prime}\\mu_{1}x_{1}\\bmod p</span> where <span class="math">c^{\\prime}=\\mathsf{H}_{\\text{sig}}(\\widetilde{X},\\widetilde{R}^{\\prime},m)</span> and sends <span class="math">s_{1}^{\\prime}</span> to Bob. Bob (or any adversary that has eavesdropped the communications between Alice and Bob) can now compute Alice’s secret key <span class="math">x_{1}=(s_{1}-s_{1}^{\\prime})/(\\mu_{1}(c-c^{\\prime}))</span>.</p>

    <p class="text-gray-300">Hence, each signer must ensure that their secret nonce <span class="math">r_{i}</span> changes unpredictably whenever <span class="math">c=\\mathsf{H}_{\\text{sig}}(\\widetilde{X},\\widetilde{R},m)</span> changes. Since <span class="math">\\widetilde{R}</span> is a function of all participants’ nonces, this implies a circular dependency in the choice of values <span class="math">r_{i}</span> as long as <span class="math">F</span> is deterministic. The standard way to solve this problem is to add a counter to the input of the function <span class="math">F</span>. To ensure that the same nonce <span class="math">r_{1}</span> is never reused, this counter must only ever increase, and thus state must be kept not only during a protocol session but also <em>between multiple protocol sessions</em>. Implementing such an increase-only counter securely is notoriously hard and arguably not easier than implementing a secure pseudorandom number generator. Common pitfalls include the synchronization of multiple concurrently running signing sessions (on potentially multiple devices), the possibility to rewind VMs (potentially triggered by an attacker), and users rewinding the state of their system by restoring backups, e.g., by simply copying files, using disk imaging tools, or advanced VM solutions. In particular, cryptographic libraries lacking control over execution environments, which differ widely across operation systems and hardware, are faced with the difficulty of keeping a permanent state of the counter and typically would need to rely on the library user to keep the counter state in a proper way.</p>

    <p class="text-gray-300">The aforementioned attack can easily be adapted to work for other multi-signature protocols based on Schnorr signatures when (ab)used with deterministic nonces, e.g., <span class="math">\\mathsf{BN}</span> as well as the protocols by Boneh et al. <em>[x2]</em>. Moreover, introducing a KOSK assumption will not help to prevent the attack. As a result, there is currently no multi-signature scheme based on Schnorr signatures that can be implemented without access to secure randomness or state at signing time.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Our Contribution</h3>

    <p class="text-gray-300">We propose a variant of the MuSig scheme called MuSig-DN (MuSig with Deterministic Nonces) that allows signers to generate nonces deterministically and without having to maintain state. To this end, signers compute their secret nonce <span class="math">r_{i}</span> by applying a pseudorandom function <span class="math">F</span> keyed with a secret key <span class="math">u_{i}</span> (that we call <em>nonce key</em>) to the message and all participants’ public keys. Then, they send their public nonce <span class="math">R_{i}=r_{i}G</span> together with a non-interactive zero-knowledge (NIZK) proof that <span class="math">r_{i}</span> was computed as specified. This NIZK proof can be checked by cosigners using a public key <span class="math">U_{i}</span> (that we call <em>host key</em>) associated with secret nonce</p>

    <p class="text-gray-300"><span class="math">u_{i}</span>. This ensures that, given a set <span class="math">\\mathbf{K}</span> of participants’ public keys (where a public key now consists of both a standard Schnorr verification key <span class="math">X_{i}=x_{i}G</span> and a host key <span class="math">U_{i}</span>) and a message <span class="math">m</span>, the nonce sent by each participant will be the same for any attempt to run the protocol on input <span class="math">(\\mathbf{K},m)</span>. If any signer tries to cheat by sending two different nonces, other participants will detect it (as by soundness of the NIZK proof, at least one of the two nonces will have an invalid proof) and abort the protocol before sending their partial signature. As opposed to the nonces which influence the challenge hash <span class="math">c</span>, each signer can simply derandomize its NIZK proof securely via a PRF.</p>

    <p class="text-gray-300">While the high-level intuition regarding the security of the scheme is clear, proving it formally for an arbitrary pseudorandom function <span class="math">F</span> appears surprisingly subtle. Indeed, <span class="math">F</span> must remain pseudorandom even when the host key <span class="math">U</span> is known. A natural choice is to define <span class="math">U</span> as a commitment to the nonce key <span class="math">u</span>. Depending on the properties of the commitment scheme <span class="math">\\mathsf{COM}</span>, one runs into the following complications:</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{COM}</span> is perfectly hiding, then <span class="math">F</span> obviously remains pseudorandom given <span class="math">U</span>. However, since <span class="math">\\mathsf{COM}</span> can only be computationally binding, an adversary could potentially send two distinct nonces with a valid proof without breaking soundness of the NIZK proof system. Since commitments are never explicitly opened during the protocol, there would be no way for a reduction to exploit this behavior to break the binding property of <span class="math">\\mathsf{COM}</span>, unless the NIZK proof system is a <em>proof of knowledge</em> (PoK), allowing the reduction to extract two distinct openings <span class="math">u</span> and <span class="math">u^{\\prime}</span> of the same host key <span class="math">U</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{COM}</span> is instead perfectly binding, then for any protocol input <span class="math">(\\mathbf{K},m)</span> and any host key <span class="math">U</span>, there is at most one nonce <span class="math">R</span> for which there exists a valid NIZK proof, as needed. However, then the commitment can only be computationally hiding, which in turn means that there is, in general, no guarantee that <span class="math">F</span> is still pseudorandom given <span class="math">U</span>.</p>

    <p class="text-gray-300">Hence, if one wants to work at this level of abstraction, the price to pay is either the reliance on a stronger type of NIZK proofs (namely, PoKs) or the additional (and likely non-standard) <em>assumption</em> that <span class="math">F</span> remains pseudorandom given a commitment to the secret key. We note that it is unclear if the most obvious and most efficient candidates of NIZK PoK systems, which are constructed using the Fiat-Shamir transform and whose extractability thus relies on rewinding techniques via the forking lemma, are at all usable in our setting. Since the main argument in the security proof of the multi-signature scheme relies on rewinding via the forking lemma as well, and the adversary is allowed to adaptively start a polynomial number of concurrent signing sessions, we expect to run into “exponential blow up” issues in the simulation as first discovered by Shoup and Gennaro <em>[x18]</em>.</p>

    <p class="text-gray-300">It might also be tempting to rely on a verifiable random function (VRF) <em>[x14]</em>, i.e., a PRF whose outputs can be publicly verified: given an output value together with a proof, anyone can check that the function was correctly evaluated on the corresponding input. However, note that the output of <span class="math">F</span> is the secret nonce <span class="math">r</span>, which is a scalar, whereas verifiers (i.e., cosigners) are given the public nonce <span class="math">R=rG</span>. Hence, VRFs do not seem directly fit for our setting. What we need instead and what we will construct could rather be informally described as a “VRF in the scalar”, i.e., <span class="math">r</span> is produced pseudorandomly but only <span class="math">R=rG</span> is exposed. This strong requirement rules out even the VRF by Dodis and Yampolskiy <em>[x6]</em>, which seems suitable at first glance because it outputs a group element <span class="math">\\mathsf{VRF}(\\mathsf{sk},x)=(1/(\\mathsf{sk}+x))G</span> such that only the evaluator of the VRF knows the discrete logarithm <span class="math">r=1/(\\mathsf{sk}+x)</span> of the group element.</p>

    <p class="text-gray-300">However for this VRF, only the outputs <span class="math">(1/(\\mathsf{sk}+x))G</span> are pseudorandom, whereas two scalars <span class="math">r=1/(\\mathsf{sk}+x)</span> and <span class="math">r^{\\prime}=1/(\\mathsf{sk}+x^{\\prime})</span> can be trivially distinguished from randomness.</p>

    <p class="text-gray-300">In light of these observations, we opt to work at a lower level of abstraction and consider a specific way of constructing <span class="math">F</span> that allows us to circumvent the aforementioned difficulties. In particular, we avoid introducing non-standard assumptions and we rely only on the soundness of the NIZK proofs (instead of their extractability).</p>

    <p class="text-gray-300">The specific PRF we consider has a simple algebraic structure in order to allow for an efficient implementation in an arithmetic circuit. Let <span class="math">\\mathbb{E}</span> be a cyclic group (written additively) of order <span class="math">q</span> with generator <span class="math">P</span>, which may be different from the group <span class="math">\\mathbb{G}</span> on which the multi-signature scheme is defined. Let further <span class="math">\\mathsf{H}_{\\text{non}}</span>: <span class="math">\\{0,1\\}^{<em>}\\to\\mathbb{E}</span> be a hash function (where index ‘non’ reflects that it will be used for generating the nonce in the multi-signature scheme), and let <span class="math">f:\\mathbb{E}\\to\\mathbb{F}_{p}</span> be a sufficiently “regular” function (meaning that <span class="math">f(A)</span> is close to uniform when <span class="math">A</span> is uniformly distributed in <span class="math">\\mathbb{E}</span>). Then <span class="math">F</span> has key space <span class="math">\\mathbb{Z}_{q}</span> and message space <span class="math">\\{0,1\\}^{</em>}</span> and for <span class="math">u\\in\\mathbb{Z}_{q}</span> and <span class="math">z\\in\\{0,1\\}^{*}</span> it is defined as</p>

    <p class="text-gray-300"><span class="math">F_{u}(z):=f(u\\mathsf{H}_{\\text{non}}(z)).</span> (1)</p>

    <p class="text-gray-300">It can easily be proved that the “core” construction <span class="math">(u,z)\\mapsto u\\mathsf{H}_{\\text{non}}(z)</span> is pseudorandom under the decisional Diffie-Hellman (DDH) assumption in group <span class="math">\\mathbb{E}</span> (in the random oracle model for <span class="math">\\mathsf{H}_{\\text{non}}</span>), even when <span class="math">U=uP</span> is known. This PRF has been considered before in various contexts <em>[x10, x16, PWH^{+}17]</em>. By regularity of <span class="math">f</span>, <span class="math">F</span> is also pseudorandom, and <span class="math">U</span> can be used as host key “committing” to <span class="math">u</span>.</p>

    <p class="text-gray-300">Given a host key <span class="math">U</span>, an input <span class="math">z\\in\\{0,1\\}^{*}</span> (which in the protocol will consist of an encoding of the list of all participants’ verification and host keys and the message <span class="math">m</span> to be signed), and a nonce <span class="math">R=rG</span>, proving that <span class="math">R</span> has been computed correctly means proving (using witness <span class="math">u</span>) that <span class="math">U=uP</span> and <span class="math">R=f(uV)G</span>, where <span class="math">V=\\mathsf{H}_{\\text{non}}(z)</span>. In particular, note that <span class="math">\\mathsf{H}_{\\text{non}}</span> is “out of scope” of the statement being proved.</p>

    <p class="text-gray-300">Obtaining a 2-Round Protocol. Switching to such an algebraic, ROM-based PRF has an interesting benefit: it allows us to obtain a 2-round protocol. Recall that in the first of the three communication rounds of MuSig, signers “commit” to their public nonce <span class="math">R_{i}</span> by sending <span class="math">t_{i}:=\\mathsf{H}_{\\text{com}}(R_{i})</span>. This step prevents any participant from controlling the aggregate nonce <span class="math">\\widetilde{R}=\\sum R_{i}</span>, and from a provable security point of view, allows the reduction to simulate the signing oracle, as we explain briefly now (see <em>[x12, x2, MPS+19]</em> for details). The reduction algorithm, whose goal is to compute the discrete logarithm of some challenge <span class="math">X_{1}\\in\\mathbb{G}</span>, runs the adversary <span class="math">\\mathcal{A}</span> on input <span class="math">X_{1}</span> as the honest user’s public key, meaning that the goal of <span class="math">\\mathcal{A}</span> is to return a forged multi-signature involving <span class="math">X_{1}</span>. The adversary can execute the signature protocol with the honest user by providing a message <span class="math">m</span> and a multiset <span class="math">\\mathbf{X}=\\{X_{1},X_{2},\\ldots,X_{n}\\}</span> where <span class="math">X_{2},\\ldots,X_{n}</span> are arbitrary public keys of purported cosigners. The reduction must simulate the honest signer without knowing the secret key corresponding to <span class="math">X_{1}</span>. The standard strategy for this, assuming <span class="math">\\mathsf{H}_{\\text{sig}}</span> is modeled as a random oracle, is to draw the partial signature <span class="math">s_{1}</span> and the “challenge” <span class="math">c</span> uniformly at random, to let <span class="math">R_{1}:=s_{1}G-c\\mu_{1}X_{1}</span>, and to program <span class="math">\\mathsf{H}_{\\text{sig}}(\\widetilde{X},\\widetilde{R},m):=c</span>, where <span class="math">\\widetilde{X}</span> and <span class="math">\\widetilde{R}</span> are respectively the aggregate public key and the aggregate nonce for the instance of the protocol at hand. However, the reduction must be able to compute <span class="math">\\widetilde{R}</span> and program <span class="math">\\mathsf{H}_{\\text{sig}}</span> <em>before</em> sending the honest user’s nonce <span class="math">R_{1}</span>. This is where the commitment round comes into play. For BN <em>[x12]</em> and MuSig <em>[x13, MPS+19]</em>, assuming <span class="math">\\mathsf{H}_{\\text{com}}</span> is modeled as a random oracle, the reduction can retrieve the nonces that will be sent by the</p>

    <p class="text-gray-300">adversary in the second communication round immediately after the first round (simply by looking at the queries made by the adversary to <span class="math">\\mathsf{H}_{\\text{com}}</span> that were answered with values <span class="math">t_{i}</span>), hence before sending <span class="math">R_{1}</span>.</p>

    <p class="text-gray-300">When moving to deterministic nonces computed with the function <span class="math">F</span> defined in Eq. (1), we can forgo the commitment round and rely on a different strategy for computing <span class="math">\\widehat{R}</span> “in advance” using a trapdoor property of <span class="math">F</span>. Namely, when the adversary starts the protocol with the honest signer, it must specify the host keys <span class="math">U_{2}=u_{2}P,\\ldots,U_{n}=u_{n}P</span> for the purported cosigners. In the random oracle model for <span class="math">\\mathsf{H}_{\\text{non}}</span>, the reduction can draw <span class="math">v</span> uniformly at random and program <span class="math">\\mathsf{H}_{\\text{non}}(z):=vP</span>, where <span class="math">z</span> consists of the list of all participants’ verification keys and host keys and the message. Since <span class="math">u_{i}\\mathsf{H}_{\\text{non}}(z)=u_{i}vP=vU_{i}</span>, this allows the reduction to compute the nonces <span class="math">R_{2},\\ldots,R_{n}</span> that will be sent by the adversary (and hence <span class="math">\\widehat{R}</span>) without knowing the secret nonce keys associated with <span class="math">U_{2},\\ldots,U_{n}</span> as <span class="math">R_{i}=f(vU_{i})</span>.</p>

    <p class="text-gray-300">Note that the number of rounds of the protocol depends in fact on the initial knowledge of signers regarding public keys of their cosigners. If cosigners’ verification keys <span class="math">X_{i}</span> or host keys <span class="math">U_{i}</span> are not known, then the protocol has three rounds as all <span class="math">X_{i}</span>’s and <span class="math">U_{i}</span>’s must be sent before the nonces can be computed by the signers.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Purify: An Efficient Instantiation.</h4>

    <p class="text-gray-300">It remains to find a suitable group <span class="math">\\mathbb{E}</span> and a NIZK proof system in which the two relations <span class="math">U=uP</span> (in <span class="math">\\mathbb{E}</span>) and <span class="math">R=f(uV)G</span> (in <span class="math">\\mathbb{G}</span>) can be proven efficiently. Our choice for <span class="math">\\mathbb{E}</span> relies on quadratic twists of elliptic curves, which are known to be useful for generating random bits from random curve points <em>[x10]</em>. Given the group order <span class="math">p</span> of <span class="math">\\mathbb{G}</span>, let <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span> be elliptic curves over <span class="math">\\mathbb{F}_{p}</span> and quadratic twists of each other with twisting factor <span class="math">d\\neq 0</span>, where <span class="math">d</span> is a quadratic non-residue in <span class="math">\\mathbb{F}_{p}</span>. Then there is an elliptic curve <span class="math">\\mathbb{E}\\cong\\mathbb{E}_{1}\\times\\mathbb{E}_{2}</span> over the quadratic extension field <span class="math">\\mathbb{F}_{p^{2}}\\cong\\mathbb{F}_{p}(\\sqrt{d})</span> that admits a suitable regular function <span class="math">f</span> given by <span class="math">f(W)=x_{0}</span> for a non-zero point <span class="math">W=(x_{0}+x_{1}\\sqrt{d},y_{0}+y_{1}\\sqrt{d})</span> on <span class="math">\\mathbb{E}</span> <em>[x7, x4]</em>.</p>

    <p class="text-gray-300">Since <span class="math">\\mathbb{E}\\cong\\mathbb{E}_{1}\\times\\mathbb{E}_{2}</span>, we can perform the group arithmetic of <span class="math">\\mathbb{E}</span> in <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span>, which in turn can be efficiently done in an arithmetic circuit over <span class="math">\\mathbb{F}_{p}</span>. By using a NIZK proof framework that natively supports secret input scalars <span class="math">s\\in\\mathbb{F}_{p}</span> given in public “commitments” <span class="math">sG\\in\\mathbb{G}</span> as inputs to the arithmetic circuit, e.g. Bulletproofs <em>[BBB^{+}18]</em>, we can avoid the very costly scalar multiplication <span class="math">f(uV)\\cdot G</span> in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">Since <span class="math">f</span> is easy to compute, our main challenge in the implementation of <span class="math">F</span> is to construct an arithmetic circuit for the two scalar multiplications <span class="math">uP</span> and <span class="math">uV</span> in <span class="math">\\mathbb{E}</span>. As <span class="math">P</span> and <span class="math">V=\\mathsf{H}_{\\text{non}}(z)</span> are public, we can precompute values that only depend on <span class="math">P</span> and <span class="math">V</span> outside the circuit. By performing the scalar multiplications using a wNAF (windowed Non Adjacent Form) algorithm and further exploiting that the scalar is the same for both, we are able to obtain a circuit with just below <span class="math">8\\lceil\\log_{2}(p)\\rceil</span> multiplication gates.</p>

    <p class="text-gray-300">With a concrete circuit of <span class="math">2030</span> gates built for <span class="math">\\mathbb{G}</span> being the secp256k1 elliptic curve as used in Bitcoin, creating a NIZK proof takes <span class="math">943\\text{\\,}\\mathrm{ms}</span> and verifying it takes <span class="math">61\\text{\\,}\\mathrm{ms}</span> using Bulletproofs (see Section 6.2).</p>

    <p class="text-gray-300">We stress that NIZK proofs are only used during the signing protocol of MuSig-DN. In particular, since MuSig-DN outputs a normal Schnorr signature, verification of the signature including its performance is unaffected. In fact, signature verifiers cannot even tell that an interactive protocol was used to produce the signature.</p>

    <p class="text-gray-300">1.3 Purify Compared to Other PRFs</p>

    <p class="text-gray-300">Our construction for <span class="math">F</span> aims to strike a balance between security assumptions and proof efficiency. Since we would like to use NIZK proof frameworks that can natively handle computations in <span class="math">\\mathbb{F}_{p}</span>, the performance of the NIZK proof (for proving, and sometimes for verifying) is typically primarily a function of the number of multiplication gates necessary to represent the statement as an arithmetic circuit over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">If one does not care about the complexity of the statement, traditional symmetric-key constructions such as HMAC <em>[x1]</em> (as used in RFC 6979) or AES may be feasible instead. For example, if we assume that HMAC-SHA256 with key <span class="math">u</span> is indistinguishable from random to an attacker who knows <span class="math">uP</span>, it can be used as <span class="math">F</span> directly. Unfortunately, these constructions are generally expensive to implement in arithmetic circuits. A circuit to verify HMAC-SHA256 requires <span class="math">91\\,559</span> multiplication gates, and even using unpadded SHA256 directly (one compression function invocation) takes <span class="math">22\\,493</span> gates. These numbers are per iteration: if <span class="math">p</span> is close to a power of two, one iteration may be enough, but otherwise the circuit may need multiple iterations to get unbiased results.</p>

    <p class="text-gray-300">Much better complexity can be achieved using symmetric-key PRFs that are specifically designed for efficiency in arithmetic circuits. Possible candidates include LowMC <em>[ARS+15]</em>, MiMC <em>[AGR+16, AGP+19]</em> and the Marvellous family <em>[AAB+19]</em>. The latter includes the Rescue cipher, which would permit an <span class="math">F</span> with a 288-gate verification circuit. However, these PRFs are relatively young and none of them have received a sufficient amount of scrutiny and cryptanalysis. Albrecht et al. <em>[ACG+19]</em> conclude that these “block cipher designs for ‘algebraic platforms’ (…) may be particularly vulnerable to algebraic attacks”, and call for further research from the cryptographic community.</p>

    <p class="text-gray-300">Our approach is less efficient than the constructions from this class, as it needs 2030 gates at the 128-bit security level, but retains provable security under the well-understood DDH assumption in the random oracle model.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We let <span class="math">\\mathbb{F}_{p}</span> denote the field with <span class="math">p</span> elements. The security parameter will be denoted <span class="math">\\lambda</span>. All algorithms are probabilistic unless stated otherwise. Given an algorithm <span class="math">\\mathsf{A}</span>, <span class="math">y:=\\mathsf{A}(x_{1},\\ldots,x_{n};\\rho)</span> means that <span class="math">y</span> is the output of <span class="math">\\mathsf{A}</span> when run on input <span class="math">x_{1},\\ldots,x_{n}</span> and randomness <span class="math">\\rho</span>. We let <span class="math">y\\leftarrow\\mathsf{A}(x_{1},\\ldots,x_{n})</span> denote the operation of sampling a random <span class="math">\\rho</span> and letting <span class="math">y:=\\mathsf{A}(x_{1},\\ldots,x_{n};\\rho)</span> and we let <span class="math">[\\mathsf{A}(x_{1},\\ldots,x_{n})]</span> denote the set of outputs returned with non-zero probability by <span class="math">\\mathsf{A}</span> on inputs <span class="math">x_{1},\\ldots,x_{n}</span>. When <span class="math">\\mathcal{A}</span> has oracle access to some function Oracle, we write <span class="math">y\\leftarrow\\mathcal{A}^{\\textsc{Oracle}}(x_{1},\\ldots,x_{n})</span>.</p>

    <p class="text-gray-300">Probabilities. The statistical distance (or total variation distance) <span class="math">\\Delta(X,Y)</span> between two random variables <span class="math">X</span> and <span class="math">Y</span> with range <span class="math">S</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y):=\\sum_{s\\in S}\\frac{1}{2}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[X=s\\right]-\\Pr\\left[Y=s\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The</p>

    <p class="text-gray-300">It is well-known that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y)=\\max_{\\mathcal{A}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[1\\leftarrow\\mathcal{A}(X)\\right]-\\Pr\\left[1\\leftarrow\\mathcal{A}(Y)\\right]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\thinspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the maximum is taken over all (deterministic or probabilistic) algorithms (even computationally unbounded) taking some input in <span class="math">S</span> and returning a bit <span class="math">b</span>, where the probabilities are taken over the randomness of <span class="math">X</span> or <span class="math">Y</span> and <span class="math">\\mathcal{A}</span>’s randomness.</p>

    <p class="text-gray-300">Given a random variable <span class="math">X</span> and an integer <span class="math">n\\geq 1</span>, let <span class="math">X^{(n)}:=(X_{1},\\ldots,X_{n})</span> denote the product distribution where the <span class="math">X_{i}</span>’s are fully independent and distributed as <span class="math">X</span>. We rely on the following well-known fact.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">X</span> and <span class="math">Y</span> be two random variables with range <span class="math">S</span> and <span class="math">n\\geq 1</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\Delta(X^{(n)},Y^{(n)})\\leq n\\cdot\\Delta(X,Y).</span></p>

    <p class="text-gray-300">We refer the reader to Appendix A for a proof.</p>

    <p class="text-gray-300">Let <span class="math">A</span> and <span class="math">B</span> be two finite non-empty sets. A function <span class="math">f:A\\to B</span> is said to be <em>regular</em> if any <span class="math">b\\in B</span> has the same number of pre-images by <span class="math">f</span>; it is <em><span class="math">\\varepsilon</span>-regular</em> if</p>

    <p class="text-gray-300"><span class="math">\\Delta(f(U_{A}),U_{B})\\leq\\varepsilon,</span></p>

    <p class="text-gray-300">where <span class="math">U_{A}</span>, resp. <span class="math">U_{B}</span> follows the uniform distribution on <span class="math">A</span>, resp. <span class="math">B</span>.</p>

    <p class="text-gray-300">Security Games. A <em>security game</em> <span class="math">\\textsc{GAME}_{\\textsf{par}}(\\lambda)</span> indexed by a set of parameters <span class="math">\\textsf{par}</span> consists of a main procedure and a collection of oracle procedures. The main procedure, on input the security parameter <span class="math">\\lambda</span>, initializes variables and generates input on which an adversary <span class="math">\\mathcal{A}</span> is run. The adversary interacts with the game by calling oracles provided by the game and returns some output, based on which the game computes its own output <span class="math">b</span> (usually a single bit), which we write <span class="math">b\\leftarrow\\textsc{GAME}_{\\textsf{par}}^{\\mathcal{A}}(\\lambda)</span>. When the game outputs the truth value of a predicate, we identify false with <span class="math">0</span> and true with <span class="math">1</span>.</p>

    <p class="text-gray-300">Let <span class="math">S</span> be some set, which may depend on the security parameter <span class="math">\\lambda</span>. The <em>random oracle model</em> (ROM) <em>[x1]</em> replaces a cryptographic hash function <span class="math">\\mathsf{H}\\colon\\{0,1\\}^{*}\\to S</span> by a truly random function. In security games, the adversary is given access to an oracle RO which is implemented by lazy sampling: a lookup table <span class="math">\\mathsf{T}</span> is initialized empty and queries <span class="math">x</span> are answered as follows: if <span class="math">\\mathsf{T}(x)</span> is not yet defined, a random <span class="math">y\\leftarrow\\sharp S</span> is sampled and stored as <span class="math">\\mathsf{T}(x):=y</span>; then the oracle returns <span class="math">\\mathsf{T}(x)</span>.</p>

    <p class="text-gray-300">PRNGs and PRFs. Let <span class="math">G=(G_{\\lambda}:\\{0,1\\}^{\\lambda}\\to Y_{\\lambda})</span> for some set <span class="math">Y_{\\lambda}</span> be a family of functions. <span class="math">G</span> is a secure pseudorandom number generator (PRNG) if for any p.p.t. adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Adv}^{\\text{prng}}_{G,\\mathcal{A}}(\\lambda):=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[x\\leftarrow\\sharp\\{0,1\\}^{\\lambda}:1\\leftarrow\\mathcal{A}(G(x))]-\\Pr[y\\leftarrow\\sharp Y_{\\lambda}:1\\leftarrow\\mathcal{A}(y)]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)\\right.\\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">G=(G_{\\lambda}:\\{0,1\\}^{\\lambda}\\times\\{0,1\\}^{*}\\to Y_{\\lambda})</span> for some set <span class="math">Y_{\\lambda}</span> be a family of functions. <span class="math">G</span> is a secure pseudorandom function (PRF) if for any p.p.t. adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Adv}^{\\text{prf}}_{G,\\mathcal{A}}(\\lambda):=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[k\\leftarrow\\sharp\\{0,1\\}^{\\lambda}:1\\leftarrow\\mathcal{A}^{G(k,\\cdot)}(1^{\\lambda})]-\\Pr[1\\leftarrow\\mathcal{A}^{\\text{RO}}(1^{\\lambda})]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)\\right.,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where RO is defined as in the previous paragraph with <span class="math">S=Y_{\\lambda}</span>.</p>

    <p class="text-gray-300">We note that even though we describe our construction Purify as a PRF, we will not rely on the above PRF definition to formalize its security. While the function <span class="math">F</span> in Purify is indeed a PRF, we will work at a lower level of abstraction in our security proofs. The above PRF definition will instead be necessary to capture the pseudorandomness of a helper function <span class="math">\\mathsf{RandDer}</span>, which we use to derandomize NIZK proofs (see Section 4).</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. The DL and DDH problems.</p>

    <p class="text-gray-300">GROUPS. A group description is a triple  <span class="math">\\Gamma = (p, \\mathbb{G}, G)</span>  where  <span class="math">\\mathbb{G}</span>  is an (additively denoted) cyclic group of order  <span class="math">p</span>  and  <span class="math">G</span>  is a generator of  <span class="math">\\mathbb{G}</span> . A (prime-order) group generation algorithm is an algorithm GrGen which on input  <span class="math">1^{\\lambda}</span>  returns a group description  <span class="math">(p, \\mathbb{G}, G)</span>  where  <span class="math">p</span>  is a  <span class="math">\\lambda</span> -bit prime. Fix  <span class="math">t \\in \\mathrm{poly}(\\lambda)</span>  and  <span class="math">\\varepsilon = \\mathrm{negl}(\\lambda)</span> . A  <span class="math">(t, \\varepsilon)</span> -companion group generation algorithm is an algorithm GrGen' which on input a  <span class="math">\\lambda</span> -bit prime  <span class="math">p</span>  returns  <span class="math">(q, \\mathbb{E}, P, f)</span>  where  <span class="math">(q, \\mathbb{E}, P)</span>  is a group description (with  <span class="math">q</span>  not necessarily prime) and  <span class="math">f: \\mathbb{E} \\to \\mathbb{F}_p</span>  is an  <span class="math">\\varepsilon(\\lambda)</span> -regular function computable in time at most  <span class="math">t(\\lambda)</span> . We will require that the discrete logarithm (DL) problem is hard in  <span class="math">\\mathbb{G}</span>  and the decisional Diffie-Hellman (DDH) problem is hard in  <span class="math">\\mathbb{E}</span> , as formalized below.</p>

    <p class="text-gray-300">Definition 1. Let game DL be as defined in Fig. 1. The discrete logarithm problem is said hard w.r.t. GrGen if for any p.p.t. adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathrm {G r G e n}, \\mathcal {A}} ^ {\\mathrm {d l}} (\\lambda) := \\Pr \\left[ 1 \\leftarrow \\operatorname {D L} _ {\\mathrm {G r G e n}} ^ {\\mathcal {A}} (\\lambda) \\right] = \\operatorname {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Let games DDH-0 and DDH-1 be as defined in Fig. 1. The decisional Diffie-Hellman problem is said hard w.r.t. (GrGen, GrGen') if for any p.p.t. adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\operatorname {A d v} _ {\\mathrm {G r G e n}, \\mathrm {G r G e n} ^ {\\prime}, \\mathcal {A}} ^ {\\mathrm {d d h}} (\\lambda) := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ 1 \\leftarrow \\mathrm {D D H} - 0 _ {\\mathrm {G r G e n}, \\mathrm {G r G e n} ^ {\\prime}} ^ {\\mathcal {A}} (\\lambda) \\right] - \\Pr \\left[ 1 \\leftarrow \\mathrm {D D H} - 1 _ {\\mathrm {G r G e n}, \\mathrm {G r G e n} ^ {\\prime}} ^ {\\mathcal {A}} (\\lambda) \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ = \\operatorname {n e g l} (\\lambda). \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">NIZK PROOF SYSTEMS. Let  <span class="math">\\mathsf{R}</span>  be an NP-relation. For  <span class="math">(s, w) \\in \\mathsf{R}</span>  we call  <span class="math">s</span>  the statement and  <span class="math">w</span>  the witness. Let  <span class="math">L_{\\mathsf{R}}</span>  denote the language associated with  <span class="math">\\mathsf{R}</span> , i.e.,  <span class="math">L_{\\mathsf{R}} := \\{s : \\exists w, (s, w) \\in \\mathsf{R}\\}</span> . A non-interactive zero-knowledge (NIZK) proof system  <span class="math">\\Pi</span>  for  <span class="math">\\mathsf{R}</span>  consists of the following three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{crs} \\leftarrow \\Pi</span> . Setup  <span class="math">(1^{\\lambda})</span> : the setup algorithm takes the security parameter and returns a common reference string (CRS)  <span class="math">\\operatorname{crs}</span> ;</li>

      <li><span class="math">\\pi \\coloneqq \\Pi .\\mathsf{Prv}(\\mathsf{crs},s,w;\\rho)</span> : the prover algorithm takes as input a CRS  <span class="math">\\mathsf{crs}</span> , a pair  <span class="math">(s,w)\\in \\mathsf{R}</span>  and an explicit randomness argument  <span class="math">\\rho</span>  and returns a proof  <span class="math">\\pi</span> ; it returns  <span class="math">\\perp</span>  if  <span class="math">(s,w)\\notin \\mathsf{R}</span></li>

      <li><span class="math">b \\coloneqq \\Pi .\\mathsf{Ver}(\\mathsf{crs},s,\\pi)</span> : the (deterministic) verifier algorithm takes as input a CRS  <span class="math">\\mathsf{crs}</span> , a statement  <span class="math">s</span> , and a proof  <span class="math">\\pi</span>  and returns a bit  <span class="math">b \\in \\{0,1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">Proof system  <span class="math">\\Pi</span>  is complete if for every  <span class="math">\\lambda</span>  and every adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathsf {c r s} \\leftarrow \\Pi . \\mathsf {S e t u p} (1 ^ {\\lambda}); (s, w) \\leftarrow \\mathcal {A} (\\mathsf {c r s}); \\pi \\leftarrow \\Pi . \\mathsf {P r v} (\\mathsf {c r s}, s, w; \\rho): \\\\ (s, w) \\in \\mathsf {R} \\wedge \\Pi . \\mathsf {V e r} (\\mathsf {c r s}, s, \\pi) = 0 \\end{array} \\right] = 0.</span></div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. The zero-knowledge game for a proof system  <span class="math">\\Pi</span> .</p>

    <p class="text-gray-300">A proof system  <span class="math">\\Pi</span>  is zero-knowledge if proofs leak no information about the witness. We define a simulator for a proof system  <span class="math">\\Pi</span>  as a pair of algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{crs}, \\tau) \\gets \\Pi . \\mathsf{SimSetup}(1^{\\lambda})</span> : the simulated setup algorithm takes the security parameter and outputs a CRS together with a trapdoor  <span class="math">\\tau</span> ;</li>

      <li><span class="math">\\pi^{<em>} \\gets \\Pi . \\mathsf{SimPrv}(\\mathsf{crs}, \\tau, s)</span> : the simulated prover algorithm takes as input a CRS, a trapdoor  <span class="math">\\tau</span> , and a statement  <span class="math">s</span>  and outputs a simulated proof  <span class="math">\\pi^{</em>}</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 2 (Zero-knowledge). Let games ZK-0 and ZK-1 be as defined in Fig. 2. A proof system  <span class="math">\\Pi</span>  for relation  <span class="math">\\mathsf{R}</span>  is zero-knowledge if there exists a simulator ( <span class="math">\\Pi</span> .SimSetup,  <span class="math">\\Pi</span> .SimPrv) such that for any  <span class="math">p.p.t.</span>  adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {A d v} _ {\\Pi , \\mathrm {R}, \\mathcal {A}} ^ {\\mathrm {z k}} (\\lambda) := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ 1 \\leftarrow \\mathrm {Z K} - 0 _ {\\Pi , \\mathrm {R}} ^ {\\mathcal {A}} (\\lambda) \\right] - \\Pr \\left[ 1 \\leftarrow \\mathrm {Z K} - 1 _ {\\Pi , \\mathrm {R}} ^ {\\mathcal {A}} (\\lambda) \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Soundness requires that no p.p.t. adversary can produce a valid proof for a false statement except with negligible probability. Simulation-soundness is strictly stronger and requires that this holds even when the adversary has oracle access to the simulated prover.</p>

    <p class="text-gray-300">Definition 3 ((Simulation-)soundness). Let games SND, resp. SS be defined as in Fig. 3. A proof system  <span class="math">\\Pi</span>  for relation R is sound, resp. simulation-sound w.r.t. simulator ( <span class="math">\\Pi</span> .SimSetup,  <span class="math">\\Pi</span> .SimPrv), if for any p.p.t. adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\Pi , \\mathrm {R}, \\mathcal {A}} ^ {\\text {s n d}} (\\lambda) := \\Pr \\left[ 1 \\leftarrow \\operatorname {S N D} _ {\\Pi , \\mathrm {R}} ^ {\\mathcal {A}} (\\lambda) \\right] = \\operatorname {n e g l} (\\lambda),</span></div>

    <p class="text-gray-300">resp.  <span class="math">\\mathsf{Adv}_{\\Pi ,\\mathsf{R},\\mathcal{A}}^{\\mathrm{ss}}(\\lambda)\\coloneqq \\operatorname *{Pr}\\left[1\\leftarrow \\mathrm{SS}_{\\Pi ,\\mathsf{R}}^{\\mathcal{A}}(\\lambda)\\right] = \\mathsf{negl}(\\lambda).</span></p>

    <p class="text-gray-300">A multi-signature scheme MS consists of these algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{par} \\gets \\mathsf{MS.Setup}(1^{\\lambda})</span> : the setup algorithm takes the security parameter and returns public parameters  <span class="math">\\mathsf{par}</span> ;</li>

      <li><span class="math">(\\mathsf{sk},\\mathsf{vk})\\gets \\mathsf{MS.KeyGen}(\\mathsf{par})</span>  : the key generation algorithm takes the public parameters and returns a secret key sk and a verification key vk;</li>

    </ul>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. The soundness and simulation-soundness games for a proof system  <span class="math">\\Pi</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sigma \\gets \\langle \\mathsf{MS.Sign}(\\mathsf{par},\\mathbf{V},m,\\mathsf{sk}_1),\\ldots ,\\mathsf{MS.Sign}(\\mathsf{par},\\mathbf{V},m,\\mathsf{sk}_n)\\rangle</span>  is an interactive protocol run by all the cosigners. Each signer runs the protocol on common inputs the public parameters par, a message  <span class="math">m</span> , and a multiset  <span class="math">\\mathbf{V}</span>  of all participants' verification key  <span class="math">\\{\\mathsf{vk}_i\\}_{i = 1}^n</span>  and on secret input its own secret key  <span class="math">\\mathsf{sk}_i</span> ; each participant obtains a signature  <span class="math">\\sigma</span>  as common output;</li>

      <li><span class="math">b \\gets \\mathsf{MS.Ver}(\\mathsf{par}, \\mathbf{V}, m, \\sigma)</span> : the (deterministic) verification algorithm takes public parameters  <span class="math">\\mathsf{par}</span> , a multiset  <span class="math">\\mathbf{V}</span>  of verification keys, a message  <span class="math">m</span> , and a signature  <span class="math">\\sigma</span>  and returns a bit  <span class="math">b \\in \\{0, 1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">CORRECTNESS. A multi-signature scheme is correct if for every  <span class="math">\\lambda</span> , every message  <span class="math">m</span> , and every integer  <span class="math">n</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} \\mathsf {p a r} \\leftarrow \\mathsf {M S . S e t u p} (1 ^ {\\lambda}) \\\\ (\\mathsf {s k} _ {i}, \\mathsf {v k} _ {i}) \\leftarrow \\mathsf {M S . K e y G e n} (\\mathsf {p a r}), i = 1 \\ldots n; \\mathbf {V} := \\{\\mathsf {v k} _ {i} \\} _ {i = 1} ^ {n} \\\\ \\sigma \\leftarrow \\langle \\mathsf {M S . S i g n} (\\mathsf {p a r}, \\mathbf {V}, m, \\mathsf {s k} _ {1}), \\ldots , \\mathsf {M S . S i g n} (\\mathsf {p a r}, \\mathbf {V}, m, \\mathsf {s k} _ {n}) \\rangle : b = 1 \\\\ b \\leftarrow \\mathsf {M S . V e r} (\\mathsf {p a r}, \\mathbf {V}, m, \\sigma) \\end{array} \\right]</span></div>

    <p class="text-gray-300">is negligibly close to 1.</p>

    <p class="text-gray-300">The security model for a multi-signature scheme in the plain public-key model [BN06] requires, informally, that it be infeasible for an attacker to forge multi-signatures involving the verification key of at least one honest signer. The security game proceeds as follows. The game generates keys  <span class="math">(\\mathsf{sk}_1,\\mathsf{vk}_1)</span>  for the honest signer. The adversary gets  <span class="math">\\mathsf{vk}_1</span>  and can start and engage in (concurrent) instances of the signing protocol with the honest signer for arbitrary messages  <span class="math">m</span>  and arbitrary multisets of verification keys  <span class="math">\\mathbf{V}</span>  such that  <span class="math">\\mathsf{vk}_1\\in \\mathbf{V}</span> . Since we work in the plain public-key model, the adversary can choose other keys in  <span class="math">\\mathbf{V}</span>  arbitrarily, in particular it can copy  <span class="math">\\mathsf{vk}_1</span> . Eventually, it returns a multiset of verification keys  <span class="math">\\mathbf{V}</span> , a message  <span class="math">m</span> , and a signature  <span class="math">\\sigma</span> . The adversary wins if  <span class="math">\\sigma</span>  is a correct signature for  <span class="math">(\\mathbf{V},m)</span> ,  <span class="math">\\mathsf{vk}_1\\in \\mathbf{V}</span> , and the adversary never started an instance of the signing protocol for the pair  <span class="math">(\\mathbf{V},m)</span> . Again, other verification keys in  <span class="math">\\mathbf{V}</span>  can be arbitrary (in particular,  <span class="math">\\mathsf{vk}_1</span>  can appear multiple times).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. The EUF-CMA security game for a multi-signature scheme MS.</p>

    <p class="text-gray-300">Definition 4 (EUF-CMA). Let game EUF-CMA be as defined in Fig. 4. A multi-signature scheme MS is existentially unforgeable under chosen-message attacks (EUF-CMA-secure) if for any p.p.t. adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {A d v} _ {\\mathsf {M S}, \\mathcal {A}} ^ {\\text {e u f - c m a}} (\\lambda) := \\Pr \\left[ 1 \\leftarrow \\operatorname {E U F - C M A} _ {\\mathsf {M S}} ^ {\\mathcal {A}} (\\lambda) \\right] = \\operatorname {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">If the signing protocol MS Sign is fully deterministic in its inputs par,  <span class="math">\\mathbf{V}, m, \\mathbf{sk}_i</span> , then EUF-CMA security implies security against additional attacks of practical relevance.</p>

    <p class="text-gray-300">FAILURES IN RANDOMNESS GENERATION. A deterministic signing protocol is trivially unaffected by failures in external randomness sources, e.g., system PRGs, because it does not access such sources.</p>

    <p class="text-gray-300">REWINDING ATTACKS. A deterministic signing protocol prevents state rewinding attacks. Observe that an EUF-CMA adversary who is given the additional capability of rewinding the honest signer in any chosen signing session to just before some chosen round  <span class="math">j</span>  can be simulated by an ordinary EUF-CMA adversary that simply opens an additional second session with the honest user (on the same inputs) and replays rounds 1 to  <span class="math">j - 1</span>  from the first session in the second session. Since the honest signer is fully deterministic, it will reach the same internal state in the second session just before round  <span class="math">j</span>  as it did previously in the first session.</p>

    <p class="text-gray-300">In this section, we give a detailed description of the MuSig-DN scheme, which is a modification of MuSig to support deterministic nonce generation.</p>

    <p class="text-gray-300">Let GrGen be a group generation algorithm and GrGen' be a  <span class="math">(t,\\varepsilon)</span> -companion group generation algorithm for some  <span class="math">t\\in \\mathsf{poly}(\\lambda)</span>  and  <span class="math">\\varepsilon \\in \\mathsf{negl}(\\lambda)</span> . Given  <span class="math">(p,\\mathbb{G},G)\\in [\\mathsf{GrGen}(1^{\\lambda})]</span>  and  <span class="math">(q,\\mathbb{E},P,f)\\in [\\mathsf{GrGen}&#x27;(p)]</span> , let KeyDer be a PRNG with key space  <span class="math">\\{0,1\\}^{\\lambda}</span>  and range  <span class="math">\\mathbb{F}_p\\times \\mathbb{Z}_q\\times \\{0,1\\}^\\lambda</span> , let KeyDer', KeyDer'', and KeyDer''' be the projections of KeyDer onto respectively its first, second and third output component, let RandDer be a PRF with key</p>

    <p class="text-gray-300">space <span class="math">\\{0,1\\}^{\\lambda}</span>, input space <span class="math">\\{0,1\\}^{<em>}</span>, and range <span class="math">\\{0,1\\}^{\\lambda}</span>, let <span class="math">\\mathsf{H}_{\\mathrm{agg}}</span> and <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span> be hash functions from <span class="math">\\{0,1\\}^{</em>}</span> to <span class="math">\\mathbb{F}_p</span> and <span class="math">\\mathsf{H}_{\\mathrm{non}}</span> be a hash function from <span class="math">\\{0,1\\}^{*}</span> to <span class="math">\\mathbb{E}</span>, and let <span class="math">\\mathsf{\\Pi}</span> be a NIZK proof system whose prover algorithm <span class="math">\\mathsf{\\Pi}.\\mathsf{Prv}</span> needs at most <span class="math">\\lambda</span> bits of randomness and which is zero-knowledge and simulation-sound for the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{R} = \\left\\{ \\left( (p, \\mathbb{G}, G, q, \\mathbb{E}, P, f, \\mathcal{F}, U, V, R), u \\right) : U, V \\in \\mathbb{E} \\setminus \\mathcal{F} \\wedge U = u P \\wedge R = f(uV)G \\right\\}, \\tag{2}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathcal{F}</span> is a set of exceptional group elements negligibly small in <span class="math">\\mathbb{E}</span> on which the prover algorithm is allowed to fail. We will omit <span class="math">p, \\mathbb{G}, G, q, \\mathbb{E}, P, f, \\mathcal{F}</span> when they are clear from the context. Looking ahead, the set <span class="math">\\mathcal{F}</span> will allow us to construct a simpler and more efficient proof system, and the concrete set <span class="math">\\mathcal{F}</span> that we will use in our proof system is efficiently recognizable such that the verifier algorithm can trivially reject any statement with group elements in <span class="math">\\mathcal{F}</span> (see Sections 5 and 6).</p>

    <p class="text-gray-300">We define the scheme <span class="math">\\mathsf{MS} := \\mathsf{MuSig-DN}[\\mathsf{GrGen}, \\mathsf{GrGen}&#x27;, \\mathsf{KeyDer}, \\mathsf{RandDer}, \\mathsf{\\Pi}, \\mathcal{F}]</span> as follows (see also Fig. 5 for a pure pseudocode description).</p>

    <p class="text-gray-300"><strong>Setup.</strong> On input <span class="math">1^{\\lambda}</span>, the setup algorithm MS.Setup runs <span class="math">(p, \\mathbb{G}, G) \\gets \\mathsf{GrGen}(1^{\\lambda})</span>, <span class="math">(q, \\mathbb{E}, P, f) \\gets \\mathsf{GrGen}&#x27;(p)</span>, and <span class="math">\\mathsf{crs} \\gets \\mathsf{\\Pi}.\\mathsf{Setup}(1^{\\lambda})</span> and returns <span class="math">\\mathsf{par} := (p, \\mathbb{G}, G, q, \\mathbb{E}, P, f, \\mathsf{crs})</span>.</p>

    <p class="text-gray-300"><strong>Key generation.</strong> On input <span class="math">\\mathsf{par} = (p, \\mathbb{G}, G, q, \\mathbb{E}, P, f, \\mathsf{crs})</span>, the key generation algorithm MS.KeyGen draws a secret key <span class="math">\\mathsf{sk} \\gets \\{0,1\\}^{\\lambda}</span> and computes <span class="math">x := \\mathsf{KeyDer}&#x27;(\\mathsf{sk})</span> (called <em>signature key</em>) and the verification key <span class="math">X := xG</span>; it returns <span class="math">\\mathsf{sk}</span> and <span class="math">\\mathsf{vk} := X</span>.</p>

    <p class="text-gray-300"><strong>Signing.</strong> Let <span class="math">\\mathsf{sk}_1</span>, <span class="math">x_1 = \\mathsf{KeyDer}&#x27;(\\mathsf{sk}_1)</span>, and <span class="math">X_1 = x_1G</span> be respectively the secret key, the signature key, and the verification key of the local signer, let <span class="math">m</span> be the message to sign, let <span class="math">X_2, \\ldots, X_n</span> be the verification keys of the other cosigners, and let <span class="math">\\mathbf{X} := \\{X_1, \\ldots, X_n\\}</span> be the multiset of all participants' verification keys. The signer first computes the aggregate key <span class="math">\\widetilde{X}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mu_i := \\mathsf{H}_{\\mathrm{agg}}(\\mathbf{X}, X_i), \\quad 1 \\leq i \\leq n \\\\ \\widetilde{X} := \\sum_{i=1}^{n} \\mu_i X_i. \\end{array}</span></div>

    <p class="text-gray-300">It computes its <em>nonce key</em> <span class="math">u_1 := \\mathsf{KeyDer}&#x27;&#x27;(\\mathsf{sk}_1)</span> and the corresponding <em>host key</em> <span class="math">U_1 := u_1P</span> and sends <span class="math">U_1</span> to all other cosigners. Upon reception of other signers host keys <span class="math">U_i</span>, <span class="math">2 \\leq i \\leq n</span>, it computes <span class="math">V := \\mathsf{H}_{\\mathrm{non}}(\\mathbf{K}, m)</span> with multiset <span class="math">\\mathbf{K} := \\{(X_1, U_1), \\ldots, (X_n, U_n)\\}</span>, it computes <span class="math">r_1 := f(u_1V)</span>, <span class="math">R_1 := r_1G</span>, and <span class="math">k := \\mathsf{KeyDer}&#x27;&#x27;&#x27;(\\mathsf{sk}_1)</span>, derives randomness <span class="math">\\rho := \\mathsf{RandDer}(k, (\\mathbf{K}, m))</span>, generates a NIZK proof</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_1 := \\Pi.\\mathsf{Prv}(\\mathsf{crs}, (U_1, V, R_1), u_1; \\rho),</span></div>

    <p class="text-gray-300">and sends <span class="math">(R_1, \\pi_1)</span> to all other cosigners. Upon reception of pairs <span class="math">(R_i, \\pi_i)</span>, <span class="math">2 \\leq i \\leq n</span>, from other cosigners, the signer runs <span class="math">\\Pi.\\mathsf{Ver}(\\mathsf{crs}, (U_i, V, R_i), \\pi_i)</span> and aborts if any verification does not pass. Otherwise, it computes</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widetilde{R} := \\sum_{i=1}^{n} R_i, \\\\ c := \\mathsf{H}_{\\mathrm{sig}}(\\widetilde{X}, \\widetilde{R}, m), \\\\ s_1 := r_1 + c \\mu_1 x_1, \\end{array}</span></div>

    <p class="text-gray-300">7 Indices 1, ..., n are local references to signers, and index 1 is w.l.o.g the index of the local signer.</p>

    <p class="text-gray-300">8 We assume a canonical serialization of multisets, e.g., implemented by sorting and then serializing all elements.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5. The multi-signature scheme MS := MuSig-DN[GrGen, GrGen', KeyDer, RandDer, Π, F].</p>

    <p class="text-gray-300">and sends  <span class="math">s_1</span>  to all other cosigners. Finally, upon reception of  <span class="math">s_2, \\ldots, s_n</span>  from other cosigners, it computes  <span class="math">s = \\sum_{i=1}^{n} s_i</span> . The signature is  <span class="math">(\\widetilde{R}, s)</span> .</p>

    <p class="text-gray-300">Verification. On input a multiset of verification keys  <span class="math">\\mathbf{X} = \\{X_1, \\ldots, X_n\\}</span> , a message  <span class="math">m</span> , and a signature  <span class="math">(\\widetilde{R}, s)</span> , the verification algorithm MS.Ver computes  <span class="math">\\mu_i := \\mathsf{H}_{\\mathrm{agg}}(\\mathbf{X}, X_i)</span>  for  <span class="math">1 \\leq i \\leq n</span> ,  <span class="math">\\widetilde{X} := \\sum_{i=1}^{n} \\mu_i X_i</span> ,  <span class="math">c := \\mathsf{H}_{\\mathrm{sig}}(\\widetilde{X}, \\widetilde{R}, m)</span>  and returns 1 if  <span class="math">sG = \\widetilde{R} + c\\widetilde{X}</span>  and 0 otherwise.</p>

    <p class="text-gray-300">DETERMINISTIC SIGNING. The NIZK proof algorithm  <span class="math">\\Pi .\\mathsf{Prv}</span>  is in general probabilistic. To obtain a fully deterministic signing protocol, which is robust against failures of external randomness sources and secure against rewinding attacks (see Section 3.3), we derandomize not only the generation of the nonce  <span class="math">r_1</span>  but also  <span class="math">\\Pi .\\mathsf{Prv}</span>  by deriving its randomness  <span class="math">\\rho</span>  using the PRF RandDer on the protocol inputs  <span class="math">(\\mathbf{K},m)</span> .</p>

    <p class="text-gray-300">STATELESS SIGNING. Security against rewinding attacks implies that unforgeability is guaranteed even in the case that signers do not have a secure non-resettable storage for keeping state</p>

    <p class="text-gray-300">between the rounds of a single signing session. However, MuSig-DN with its fully deterministic signing algorithm goes one step further: since all state in the signing protocol at a given point in time can be recomputed from the protocol inputs and the messages received thus far, some signers may be stateless, i.e., they do not need to keep state at all between the rounds of signing session, not even for correct functionality. Instead, it suffices that only one of the signers (or an untrusted third party) invokes the stateless signers by providing them with the public inputs and all previously sent messages from the cosigners. For example, if signer 1 is stateless, it is possible to ask it for its third-round message <span class="math">s_{1}</span> by providing it with the public inputs <span class="math">m,\\mathbf{X}</span> and the previously sent messages <span class="math">((U_{i}),R_{i},\\pi_{i}))</span>, <span class="math">2\\leq i\\leq n</span> from the cosigners, and signer 1 can simply replay the first two rounds of the protocol internally to produce <span class="math">s_{1}</span>.</p>

    <p class="text-gray-300">Two-Round Scheme. In practice, the nonce/host key pair <span class="math">(u_{1},U_{1})</span> can be computed at key generation time and <span class="math">U_{1}</span> transmitted only once to other cosigners alongside the verification key <span class="math">X_{1}</span>. The cosigners can then store the pair <span class="math">(X_{1},U_{1})</span> as a long-term key. Then a signing session of our protocol needs effectively only two rounds.</p>

    <p class="text-gray-300">The security of this optimization is justified by our security proof, which in fact considers a security game that passes <span class="math">U_{1}</span> as an additional input to the adversary in the beginning of the game (see Game_{0} in Appendix B).</p>

    <p class="text-gray-300">Public Keys. On the other hand, one cannot let the host key <span class="math">U</span> be formally part of the verification key vk of a signer. This would allow an adversary to run the signing protocol on input <span class="math">({(X_{1},U_{1}),(X_{2},U_{2})},m)</span>, thus getting a valid signature <span class="math">\\sigma</span>, and return as forgery a tuple <span class="math">({(X_{1},U_{1}),(X_{2},U^{\\prime}_{2})},m,\\sigma)</span> where <span class="math">U^{\\prime}_{2}\\neq U_{2}</span>: since <span class="math">\\sigma</span> is valid for <span class="math">({(X_{1},U_{1}),(X_{2},U^{\\prime}_{2})},m)</span> but the protocol was never executed on input <span class="math">({(X_{1},U_{1}),(X_{2},U^{\\prime}_{2})},m)</span>, this would be a win according to Definition 4. This artificial problem could be solved by adapting the syntax and the security definition for multi-signature schemes; however, we preferred to abide by the standard definition.</p>

    <p class="text-gray-300">On the Inputs to the Hash. Signers are supposed to compute their signature/verification key pair and their nonce/host key pair from the same secret key sk, so that when all signers are honest the multiset of verification keys <span class="math">\\mathbf{X}</span> uniquely determines the multiset of verification/host key pairs <span class="math">\\mathbf{K}</span>. Hence, one could wonder whether it is indeed necessary to hash <span class="math">\\mathbf{K}</span> instead of <span class="math">\\mathbf{X}</span> in <span class="math">\\mathsf{H}_{\\text{non}}</span>. However, assuming <span class="math">V</span> is computed as <span class="math">V:=\\mathsf{H}_{\\text{non}}(\\mathbf{X},m)</span>, a dishonest signer could use two different host keys <span class="math">U_{i}</span> and <span class="math">U^{\\prime}_{i}</span> in two executions of the protocol with the same common input <span class="math">(\\mathbf{X},m)</span>. This would result in the honest signer computing two partial signatures with the same nonce <span class="math">r_{1}</span> for different aggregate nonces <span class="math">\\widetilde{R}</span> and <span class="math">\\widetilde{R}^{\\prime}</span>, hence leaking its signature key.</p>

    <p class="text-gray-300">Correctness and Robustness. Correctness of the scheme follows from the completeness of the NIZK proof system and correctness of standard MuSig <em>[x10]</em>. The only cases in which the signing protocol outputs <span class="math">\\bot</span> are that the NIZK prover algorithm outputs <span class="math">\\bot</span> or that some cosigner <span class="math">i</span> sends an invalid NIZK proof <span class="math">\\pi_{i}</span>. Given a complete NIZK proof system, these cases correspond to the exceptional cases <span class="math">V\\in\\mathcal{F}</span> or <span class="math">U_{i}\\in\\mathcal{F}</span>. Since the set <span class="math">\\mathcal{F}</span> is negligibly small in <span class="math">\\mathbb{E}</span>, this happens with negligible probability when signers abide by the protocol.</p>

    <p class="text-gray-300">Moreover, a useful property of the interactive signing protocol is that it is robust in the following sense: if a signing session fails (by returning either <span class="math">\\bot</span> or an invalid signature) due to some of the participants sending messages that do not adhere to the protocol specification, it</p>

    <p class="text-gray-300">can be determined who is responsible for the failure (assuming that the network is reliable). By completeness of the NIZK proof system, a cosigner <span class="math">i</span> sending an invalid NIZK proof <span class="math">\\pi_{i}</span> is disruptive except with negligible probability (in case <span class="math">V</span> or <span class="math">U_{i}</span> falls in <span class="math">\\mathcal{F}</span>). If the signing protocol outputs an invalid signature, the disruptive cosigners can be identified by checking the equalities <span class="math">s_{i}G=R_{i}+cX_{i}</span> individually for every <span class="math">2\\leq i\\leq n</span> as already possible in MuSig.</p>

    <p class="text-gray-300">Reducing the Number of Keys. In practice, it may be desirable to reuse a single nonce key across different signature keys in order to reduce the number of public host keys that signers need to store or retransmit if they are involved in many signing setups. Using a single nonce key for multiple signature keys is particularly natural when the host key and the signature keys are derived using a hierarchical deterministic Bitcoin wallet <em>[x29, x11]</em>. Similarly, it may be desirable to use multiple nonce keys with the same signature key, e.g., if the same signature key is stored on multiple devices. We believe that these usage modes do not affect the security of MuSig-DN, but we leave a formal treatment for future work.</p>

    <p class="text-gray-300">Security. We state the security of MuSig-DN in the following theorem whose proof can be found in Appendix B.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{GrGen}</span> be a group generation algorithm for which the DL problem is hard and <span class="math">\\mathsf{GrGen}^{\\prime}</span> be a <span class="math">(t,\\varepsilon)</span>-companion group generation algorithm for which the DDH problem is hard. Let <span class="math">\\mathsf{KeyDer}</span> be a PRNG, <span class="math">\\mathsf{RandDer}</span> a PRF, and <span class="math">\\mathsf{\\Pi}</span> be a zero-knowledge and simulation-sound NIZK proof system for relation <span class="math">\\mathsf{R}</span> as defined in Eq. (2) for some set <span class="math">\\mathcal{F}</span>. Then the multi-signature scheme <span class="math">\\mathsf{MS}:=\\mathsf{MuSig-DN}[\\mathsf{GrGen},\\mathsf{GrGen}^{\\prime},\\mathsf{KeyDer},\\mathsf{RandDer},\\mathsf{\\Pi},\\mathcal{F}]</span> is EUF-CMA-secure in the random oracle model.</p>

    <p class="text-gray-300">Precisely, for any p.p.t. adversary <span class="math">\\mathcal{A}</span> making at most <span class="math">q_{\\mathrm{h}}</span> random oracle queries and initiating at most <span class="math">q_{\\mathrm{s}}</span> instances of the signature protocol with the honest signer, there exist p.p.t. adversaries <span class="math">\\mathcal{B}_{\\mathrm{prng}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{prf}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{snd}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{zk}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{ss}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span>, and <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> with</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathrm{euf-cma}}(\\lambda)</span> <span class="math">\\leq(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{3/4}\\left(\\mathsf{Adv}_{\\mathsf{GrGen},\\mathcal{B}_{\\mathrm{dl}}}^{\\mathrm{dl}}(\\lambda)\\right)^{1/4}</span> <span class="math">+\\mathsf{Adv}_{\\mathsf{KeyDer},\\mathcal{B}_{\\mathrm{prng}}}^{\\mathrm{prng}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{RandDer},\\mathcal{B}_{\\mathrm{prf}}}^{\\mathrm{prf}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{snd}}}^{\\mathrm{snd}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{zk}}}^{\\mathrm{zk}}(\\lambda)</span> <span class="math">+\\mathsf{Adv}_{\\mathsf{GrGen}^{\\prime},\\mathcal{B}_{\\mathrm{ddh}}}^{\\mathrm{ddh}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{ss}}}^{\\mathrm{ss}}(\\lambda)+q_{\\mathrm{s}}\\varepsilon+\\frac{(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{2}}{2^{\\lambda-2}}+\\frac{2}{2^{\\lambda/4}}.</span></p>

    <h2 id="sec-13" class="text-2xl font-bold">5 Purify: A Pure Elliptic Curve PRF</h2>

    <p class="text-gray-300">In this section, we describe a suitable companion group generation algorithm <span class="math">\\mathsf{GrGen}^{\\prime}</span> (see Section 2) which, given a <span class="math">\\lambda</span>-bit prime <span class="math">p</span>, returns a tuple <span class="math">(q,\\mathbb{E},P,f)</span> where <span class="math">(q,\\mathbb{E},P)</span> is a group description and <span class="math">f:\\mathbb{E}\\to\\mathbb{F}_{p}</span> is an <span class="math">\\varepsilon(\\lambda)</span>-regular function for some <span class="math">\\varepsilon\\in\\mathsf{negl}(\\lambda)</span>. We call our construction <em>Purify</em> because the consonants spell PRF and the secret parts of the computation are purely based on elliptic curves.</p>

    <p class="text-gray-300">The construction makes use of randomness extractors that rely on the DDH problem over elliptic curves <em>[x13, x15]</em>. Let <span class="math">p&gt;3</span> be prime. An elliptic curve in short Weierstrass form is a set of points</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}=\\{(x,y)\\in(\\mathbb{F}_{p})^{2}:y^{2}=x^{3}+ax+b\\}\\cup\\{0_{\\mathbb{E}}\\}</span></p>

    <p class="text-gray-300">where <span class="math">a</span> and <span class="math">b</span> are elements of <span class="math">\\mathbb{F}_p</span> such that <span class="math">4a^3 + 27b^2 \\neq 0</span> and <span class="math">0_{\\mathbb{E}}</span> is the point at infinity. It is well-known that <span class="math">\\mathbb{E}</span> can be equipped with a group law with neutral element <span class="math">0_{\\mathbb{E}}</span>. Given an integer <span class="math">n</span>, we let <span class="math">\\mathbb{E}[n]</span> denote the subgroup of <span class="math">n</span>-torsion points, i.e., <span class="math">\\mathbb{E}[n] := \\{P \\in \\mathbb{E} : nP = 0_{\\mathbb{E}}\\}</span>.</p>

    <p class="text-gray-300">Let <span class="math">d \\neq 0</span> be a quadratic non-residue in <span class="math">\\mathbb{F}_p</span>. The curve</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{\\mathbb{E}} = \\left\\{(x, y) \\in (\\mathbb{F}_p)^2 : y^2 = x^3 + ad^2 x + bd^3 \\right\\} \\cup \\left\\{0_{\\tilde{\\mathbb{E}}}\\right\\}</span></div>

    <p class="text-gray-300">is a quadratic twist of <span class="math">\\mathbb{E}</span>. Curves <span class="math">\\mathbb{E}</span> and <span class="math">\\tilde{\\mathbb{E}}</span> are not isomorphic over <span class="math">\\mathbb{F}_p</span> (unless <span class="math">b = 0</span> and <span class="math">-1</span> is a quadratic non-residue in <span class="math">\\mathbb{F}_p</span>, in which case <span class="math">\\mathbb{E}</span> is supersingular) but they become isomorphic over the quadratic extension field <span class="math">\\mathbb{F}_{p^2} \\cong \\mathbb{F}_p[X] / (X^2 - d) \\cong \\mathbb{F}_p(\\sqrt{d}) = \\{u_0 + u_1\\sqrt{d} : (u_0, u_1) \\in (\\mathbb{F}_p)^2\\}</span>, the isomorphism being <span class="math">(x, y) \\mapsto (dx, d\\sqrt{d}y)</span>.</p>

    <p class="text-gray-300">The basic construction of <span class="math">\\mathsf{GrGen}&#x27;</span> is as follows: given <span class="math">p</span>, select an elliptic curve <span class="math">\\mathbb{E}</span> over <span class="math">\\mathbb{F}_{p^2} \\cong \\mathbb{F}_p(\\sqrt{d})</span> whose group of points is cyclic of order <span class="math">q</span> together with a generator <span class="math">P</span> and such that DDH is assumed to be hard over <span class="math">\\mathbb{E}</span> and define</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f : \\mathbb{E} \\to \\mathbb{F}_p \\\\ Q \\mapsto \\begin{cases} 0 &amp;amp; \\text{if } Q = 0_{\\mathbb{E}} \\\\ x_0 &amp;amp; \\text{if } Q = (x_0 + x_1\\sqrt{d}, y_0 + y_1\\sqrt{d}). \\end{cases} \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">U_p</span> be the uniform distribution on <span class="math">\\mathbb{F}_p</span> and <span class="math">U_{\\mathbb{E}}</span> be the uniform distribution on <span class="math">\\mathbb{E}</span>. Farashahi and Pellikaan [FP07], improving on a result by Gurel [Gur05, Lemma 1], showed that <span class="math">U_p</span> and <span class="math">f(U_{\\mathbb{E}})</span> are statistically close. More precisely, Corollary 3 by Farashahi and Pellikaan [FP07] states for <span class="math">p &amp;gt; 18</span> the bound</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta(U_p, f(U_{\\mathbb{E}})) \\leq \\frac{3}{\\sqrt{p}} \\leq \\frac{3\\sqrt{2}}{2^{\\lambda/2}}.</span></div>

    <p class="text-gray-300">In other words, <span class="math">f</span> is <span class="math">\\varepsilon</span>-regular for <span class="math">\\varepsilon = 3\\sqrt{2}/2^{\\lambda/2}</span>.</p>

    <p class="text-gray-300">Our goal is to construct a PRF onto <span class="math">\\mathbb{F}_p</span> of the form</p>

    <div class="my-4 text-center"><span class="math-block">F_u(z) = f(u \\mathsf{H}_{\\text{non}}(z)), \\tag{3}</span></div>

    <p class="text-gray-300">where <span class="math">u \\in \\mathbb{Z}_q</span> is the key and <span class="math">\\mathsf{H}_{\\mathrm{non}} : \\{0,1\\}^* \\to \\mathbb{E}</span> is a hash function. In order for this function to be both computable and verifiable against a public key <span class="math">U = uP</span> by an arithmetic circuit with low multiplicative complexity, we restrict ourselves to specific curves constructed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix a quadratic non-residue <span class="math">d \\in \\mathbb{F}_p^*</span>.</li>

      <li>Find <span class="math">a, b \\in \\mathbb{F}_p</span> such that:</li>

      <li>the equation <span class="math">y^2 = x^3 + ax + b</span> defines an elliptic curve <span class="math">\\mathbb{E}_1</span> over <span class="math">\\mathbb{F}_p</span> of prime order <span class="math">q_1</span> in which DDH is assumed to be hard;</li>

      <li>the equation <span class="math">y^2 = x^3 + ad^2 x + bd^3</span> defines an elliptic curve <span class="math">\\mathbb{E}_2</span> over <span class="math">\\mathbb{F}_p</span> (a quadratic twist of <span class="math">\\mathbb{E}_1</span>) of prime order <span class="math">q_2 \\neq q_1</span>, in which DDH is assumed to be hard.</li>

    </ul>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Consider the elliptic curve <span class="math">\\mathbb{E} = \\mathbb{E}_1(\\mathbb{F}_{p^2})</span>, defined by equation <span class="math">y^{2} = x^{3} + ax + b</span> over <span class="math">\\mathbb{F}_{p^2}</span>. Then</p>

    <p class="text-gray-300">(i) <span class="math">\\mathbb{E}</span> is isomorphic to the direct product <span class="math">\\mathbb{E}_1 \\times \\mathbb{E}_2</span> of <span class="math">\\mathbb{E}_1</span> and <span class="math">\\mathbb{E}_2</span>; in particular, it is cyclic and has order <span class="math">q = q_1q_2</span>;</p>

    <p class="text-gray-300">9 This means in particular that <span class="math">\\mathbb{E}_1</span> must have a large embedding degree.</p>

    <p class="text-gray-300">(ii) there is an efficiently computable and invertible isomorphism  <span class="math">\\phi \\colon \\mathbb{E} \\to \\mathbb{E}_1 \\times \\mathbb{E}_2</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathbb{E}&#x27;</span>  be the curve defined by  <span class="math">y^{2} = x^{3} + ad^{2}x + bd^{3}</span>  over  <span class="math">\\mathbb{F}_{p^2}</span>  and let  <span class="math">\\tau : \\mathbb{E} \\to \\mathbb{E}&#x27;</span>  be the twisting isomorphism defined by  <span class="math">\\tau(x, y) = (dx, d\\sqrt{d}y)</span> . Let  <span class="math">q_{1} = p + 1 - t</span>  be the number of points of  <span class="math">\\mathbb{E}_1</span> . Then  <span class="math">\\mathbb{E}_2</span>  has  <span class="math">q_{2} = p + 1 + t</span>  points and  <span class="math">\\mathbb{E}</span>  has  <span class="math">p^2 + 1 - (t^2 - 2q) = (p + 1)^2 - t^2 = q_1q_2</span>  points.</p>

    <p class="text-gray-300">Since  <span class="math">q_{1}</span>  and  <span class="math">q_{2}</span>  are coprime, let  <span class="math">m_{1}</span>  and  <span class="math">m_{2}</span>  be such that  <span class="math">m_{1}q_{1} + m_{2}q_{2} = 1</span> . Consider</p>

    <div class="my-4 text-center"><span class="math-block">\\psi \\colon \\mathbb {E} \\to \\mathbb {E} [ q _ {1} ] \\times \\mathbb {E} [ q _ {2} ]</span></div>

    <div class="my-4 text-center"><span class="math-block">Q \\mapsto (m _ {2} q _ {2} Q, m _ {1} q _ {1} Q).</span></div>

    <p class="text-gray-300">Note that  <span class="math">\\mathbb{E}[q_1] = \\mathbb{E}_1</span>  (as  <span class="math">\\mathbb{E}_1</span>  is a subgroup of  <span class="math">\\mathbb{E}[q_1]</span>  and  <span class="math">\\mathbb{E}[q_1]</span>  is a proper subgroup of  <span class="math">\\mathbb{E}</span> ) and  <span class="math">\\mathbb{E}[q_2] = \\tau^{-1}(\\mathbb{E}_2)</span>  (as  <span class="math">\\tau^{-1}(\\mathbb{E}_2)</span>  is a subgroup of  <span class="math">\\mathbb{E}[q_2]</span>  and  <span class="math">\\mathbb{E}[q_2]</span>  is a proper subgroup of  <span class="math">\\mathbb{E}</span> ), which implies in particular that  <span class="math">\\# \\mathbb{E}[q_1] = q_1</span>  and  <span class="math">\\# \\mathbb{E}[q_2] = q_2</span> . Hence,  <span class="math">\\psi</span>  is an efficiently computable isomorphism whose inverse, given by  <span class="math">(R,S) \\mapsto R + S</span> , is also efficiently computable. Hence,  <span class="math">\\phi := \\tau&#x27; \\circ \\psi</span>  where  <span class="math">\\tau&#x27;: \\mathbb{E}[q_1] \\times \\mathbb{E}[q_2] \\to \\mathbb{E}_1 \\times \\mathbb{E}_2</span>  is defined by  <span class="math">\\tau&#x27;(R,S) = (R,\\tau(S))</span>  is an efficiently computable and invertible isomorphism from  <span class="math">\\mathbb{E}</span>  to  <span class="math">\\mathbb{E}_1 \\times \\mathbb{E}_2</span> . This proves (i) and (ii) (the fact that  <span class="math">\\mathbb{E}</span>  is cyclic follows from the Chinese Remainder Theorem).</p>

    <p class="text-gray-300">Moreover, assuming DDH is hard in  <span class="math">\\mathbb{E}_1</span>  and  <span class="math">\\mathbb{E}_2</span> , DDH is also hard in  <span class="math">\\mathbb{E}_1 \\times \\mathbb{E}_2</span>  with a tight reduction [GKR04a, Lemma 4], and since  <span class="math">\\phi</span>  is efficiently invertible, DDH is also hard in  <span class="math">\\mathbb{E}</span> .</p>

    <p class="text-gray-300">As a consequence, instead of working over  <span class="math">\\mathbb{E}</span> , one can project the computation onto  <span class="math">\\mathbb{E}_1</span>  and  <span class="math">\\mathbb{E}_2</span> , where the arithmetic is simpler, and then combine the two to obtain the final result. Let  <span class="math">\\mathsf{H}_1</span>  and  <span class="math">\\mathsf{H}_2</span>  be hash functions onto  <span class="math">\\mathbb{E}_1</span>  and  <span class="math">\\mathbb{E}_2</span>  respectively. Define a hash function  <span class="math">\\mathsf{H}_{\\mathrm{non}}</span>  onto  <span class="math">\\mathbb{E}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {H} _ {\\text {n o n}} (z) := \\phi^ {- 1} \\left(\\mathsf {H} _ {1} (z), \\mathsf {H} _ {2} (z)\\right). \\tag {4}</span></div>

    <p class="text-gray-300">Using the definition of  <span class="math">\\phi</span>  given in the proof of Lemma 2, one can easily see that  <span class="math">\\mathsf{H}_{\\mathrm{non}}(z) = \\mathsf{H}_1(z) + \\tau^{-1}(\\mathsf{H}_2(z))</span> , where  <span class="math">\\tau^{-1}(x,y) = (d^{-1}x,d^{-3 / 2}y)</span> . Using the indifferentiability notion by Maurer et al. [MRH04], one can show that  <span class="math">\\mathsf{H}_{\\mathrm{non}}</span>  "behaves" like a random oracle assuming  <span class="math">\\mathsf{H}_1</span>  and  <span class="math">\\mathsf{H}_2</span>  are random oracles. As the EUF-CMA security notion is a single-stage game [RSS11], this ensures that the proof of Theorem 1 (see Appendix B) carries over to MuSig-DN used with this construction (in the random oracle model for  <span class="math">\\mathsf{H}_1</span>  and  <span class="math">\\mathsf{H}_2</span> ).</p>

    <p class="text-gray-300">Claim.  <span class="math">\\mathsf{H}_{\\mathrm{non}}</span>  as defined in (4) is indifferentiable [MRH04] from a random oracle onto  <span class="math">\\mathbb{E}</span> .</p>

    <p class="text-gray-300">Proof. This follows from the results of Brier et al. [BCI+10, Th. 1] by noting that  <span class="math">z \\mapsto (\\mathsf{H}_1(z), \\mathsf{H}_2(z))</span>  is a random oracle onto  <span class="math">\\mathbb{E}_1 \\times \\mathbb{E}_2</span>  and that an efficiently computable and invertible isomorphism is an admissible encoding [BCI+10, Def. 4].</p>

    <p class="text-gray-300">We can now work out an explicit formula for  <span class="math">F_{u}(z)</span>  in terms of multiplications in  <span class="math">\\mathbb{E}_1</span>  and  <span class="math">\\mathbb{E}_2</span> , with  <span class="math">F</span>  as defined in Eq. (3), and  <span class="math">\\mathsf{H}_{\\mathrm{non}}</span>  as defined in Eq. (4):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {u} (z) = f \\left(u \\mathsf {H} _ {\\mathrm {n o n}} (z)\\right) \\\\ = f \\left(u \\phi^ {- 1} \\left(\\mathrm {H} _ {1} (z), \\mathrm {H} _ {2} (z)\\right)\\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">For example, the functions \\mathsf{H}_1  and \\mathsf{H}_2  can be instantiated with the help of a counter and a hash function from \\{0,1\\}^*  to \\mathbb{F}_p . The counter is concatenated to the hash input and the hash output is interpreted as the x-coordinate of \\mathbb{E}_1  or \\mathbb{E}_2  respectively. If there is no corresponding y-coordinate, the counter is incremented and the process is repeated until a valid point is found. Since \\mathsf{H}_1  and \\mathsf{H}_2  only operate on public data there is no risk of leaking information through timing.</p>

    <p class="text-gray-300">For <span class="math">u\\in\\mathbb{Z}_{q}</span>, let <span class="math">u_{1}=u\\bmod q_{1}</span> and <span class="math">u_{2}=u\\bmod q_{2}</span>. Then</p>

    <p class="text-gray-300"><span class="math">F_{u}(z)</span> <span class="math">=f\\left(\\phi^{-1}(u_{1}\\mathsf{H}_{1}(z),u_{2}\\mathsf{H}_{2}(z))\\right)</span> <span class="math">=f\\left(u_{1}\\mathsf{H}_{1}(z)+\\tau^{-1}(u_{2}\\mathsf{H}_{2}(z))\\right).</span></p>

    <p class="text-gray-300">Letting <span class="math">u_{1}\\mathsf{H}_{1}(z)=(x_{1},y_{1})</span> and <span class="math">u_{2}\\mathsf{H}_{2}(z)=(x_{2},y_{2})</span>,</p>

    <p class="text-gray-300"><span class="math">F_{u}(z)</span> <span class="math">=f\\left((x_{1},y_{1})+\\tau^{-1}\\left((x_{2},y_{2})\\right)\\right)</span> <span class="math">=f\\left((x_{1},y_{1})+(d^{-1}x_{2},d^{-3/2}y_{2})\\right).</span></p>

    <p class="text-gray-300">Using the group law in <span class="math">\\mathbb{E}</span> to write the x-coordinate explicitly (see the final paragraph in Section 6.1 for an explicit formula),</p>

    <p class="text-gray-300"><span class="math">F_{u}(z)</span> <span class="math">=f\\left(\\left(\\left(\\frac{d^{-3/2}y_{2}-y_{1}}{d^{-1}x_{2}-x_{1}}\\right)^{2}-x_{1}-d^{-1}x_{2},\\ldots\\right)\\right)</span> <span class="math">=f\\left(\\left(\\frac{y_{1}^{2}+d^{-3}y_{2}^{2}-2d^{-2}\\sqrt{d}y_{1}y_{2}}{(d^{-1}x_{2}-x_{1})^{2}}-x_{1}-d^{-1}x_{2},\\ldots\\right)\\right).</span></p>

    <p class="text-gray-300">Evaluating <span class="math">f</span>, which corresponds to dropping the y-coordinate and the <span class="math">\\sqrt{d}</span> component in the x-coordinate, we have</p>

    <p class="text-gray-300"><span class="math">F_{u}(z)=\\frac{y_{1}^{2}+d^{-3}y_{2}^{2}}{(x_{1}-d^{-1}x_{2})^{2}}-x_{1}-d^{-1}x_{2},</span></p>

    <p class="text-gray-300">By the <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span> curve equations to substitute <span class="math">y_{1}^{2}</span> and <span class="math">y_{2}^{2}</span>,</p>

    <p class="text-gray-300"><span class="math">F_{u}(z)</span> <span class="math">=\\frac{x_{1}^{3}+ax_{1}+b+d^{-3}(x_{2}^{3}+ad^{2}x_{2}+d^{3}b)}{(x_{1}-d^{-1}x_{2})^{2}}-x_{1}-d^{-1}x_{2}</span> <span class="math">=\\frac{x_{1}^{3}+ax_{1}+b+(d^{-1}x_{2})^{3}+ad^{-1}x_{2}+b}{(x_{1}-d^{-1}x_{2})^{2}}-x_{1}-d^{-1}x_{2}.</span></p>

    <p class="text-gray-300">Finally we obtain</p>

    <p class="text-gray-300"><span class="math">F_{u}(z)=\\frac{(x_{1}+d^{-1}x_{2})(a+x_{1}d^{-1}x_{2})+2b}{(x_{1}-d^{-1}x_{2})^{2}}.</span> (5)</p>

    <p class="text-gray-300">In other words, the PRF evaluation is a simple function of the x-coordinates of <span class="math">u_{1}\\mathsf{H}_{1}(z)</span> and <span class="math">u_{2}\\mathsf{H}_{2}(z)</span>.</p>

    <p class="text-gray-300">This equation does not hold in the exceptional cases that <span class="math">u_{1}\\mathsf{H}_{1}(z)=0_{\\mathbb{E}_{1}}</span> or <span class="math">u_{2}\\mathsf{H}_{2}(z)=0_{\\mathbb{E}_{2}}</span>, which exactly correspond to <span class="math">U=uP</span> or <span class="math">V=\\mathsf{H}_{\\text{non}}(z)</span> having order less than <span class="math">q</span>. To avoid these cases when constructing a concrete NIZK proof system, we define the set <span class="math">\\mathcal{F}\\subseteq\\mathbb{E}</span> (see Section 4) as <span class="math">\\mathcal{F}=\\{P\\in\\mathbb{E}:q_{1}P=0_{\\mathbb{E}}\\vee q_{2}P=0_{\\mathbb{E}}\\}</span>. Clearly <span class="math">\\mathcal{F}</span> is negligibly small in <span class="math">\\mathbb{E}</span>.</p>

    <p class="text-gray-300">The <span class="math">\\mathbb{E}</span> group law used above only applies in case the summands are distinct and not each other’s negation, so we must verify that is the case for <span class="math">(x_{1},y_{1})</span> and <span class="math">\\tau^{-1}\\left((x_{2},y_{2})\\right)</span>. Since they are in distinct subgroups <span class="math">\\mathbb{E}[q_{1}]</span> and <span class="math">\\mathbb{E}[q_{2}]</span> there is only a problem if both lie in the intersection of those subgroups. As <span class="math">q_{1}</span> and <span class="math">q_{2}</span> are coprime, that intersection is exactly <span class="math">\\{0_{\\mathbb{E}}\\}</span>, which is excluded by being a subset of <span class="math">\\mathcal{F}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">6 Efficient NIZK</p>

    <p class="text-gray-300">It remains to construct an efficient NIZK proof for the relation</p>

    <p class="text-gray-300"><span class="math">\\mathsf{R}=\\{((p,\\mathbb{G},G,q,\\mathbb{E},P,f,\\mathcal{F},U,V,R),u):U,V\\in\\mathbb{E}\\setminus\\mathcal{F}\\,\\wedge\\,U=uP\\,\\wedge\\,R=f(uV)G\\}.</span></p>

    <p class="text-gray-300">In this section, we describe an arithmetic circuit over the field <span class="math">\\mathbb{F}_{p}</span> for this statement, where <span class="math">p</span> is the group order of <span class="math">\\mathbb{G}</span>. Recall that the public points <span class="math">R\\in\\mathbb{G}</span> and <span class="math">U\\in\\mathbb{E}</span> are in different groups. By using a NIZK proof framework for arithmetic circuits that natively supports secret input scalars <span class="math">s\\in\\mathbb{F}_{p}</span> given in public “commitments” <span class="math">sG\\in\\mathbb{G}</span> as inputs to the circuit, we avoid the costly scalar multiplication <span class="math">f(uV)\\cdot G</span> in <span class="math">\\mathbb{G}</span>. Note that in the typical case <span class="math">\\mathbb{G}</span> is an elliptic curve group of order <span class="math">p</span> and defined over a field <span class="math">\\mathbb{F}_{p^{\\prime}}</span> with <span class="math">p^{\\prime}\\neq p</span> such that this multiplication would be prohibitively expensive to implement in a circuit over the “wrong” field <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">We optimize for a low number of multiplication gates in the circuit, which makes our technique compatible and efficient when used with NIZK proof frameworks for arithmetic circuit satisfiability meeting the aforementioned requirement of supporting inputs in commitments, e.g., Bulletproofs <em>[BBB+18]</em> and the recent framework by Lai, Malavolta and Ronge <em>[LMR19]</em>.</p>

    <p class="text-gray-300">This section gives a high-level description of our circuit, which has 2030 multiplication gates for a 256-bit curve. A full implementation of the circuit in Python is available <em>[Wui19]</em>.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Elliptic Curve Selection.</h5>

    <p class="text-gray-300">Arithmetic operations over elements in <span class="math">\\mathbb{F}_{p}</span> will be native to our circuit and thus very efficient. To make use of these native operations, we would like to work on elliptic curves <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span> over the field <span class="math">\\mathbb{F}_{p}</span>, i.e., the coordinates of points on <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span> are elements of <span class="math">\\mathbb{F}_{p}</span>. For typical choices of <span class="math">\\mathbb{G}</span> (and hence <span class="math">p</span>) such as the secp256k1 elliptic curve used in Bitcoin, it is feasible to find suitable curves <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span> in few CPU days on a modern laptop using the SageMath computer algebra system <em>[Sag19]</em>. We make our code and curve parameters of <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span> suitable for a few common choices available <em>[Wui19]</em>.</p>

    <p class="text-gray-300">For the sake of concreteness, we assume the secp256k1 curve in the remainder of this section. For this choice of <span class="math">\\mathbb{G}</span>, the group order is <span class="math">p=2^{256}-2^{32}-2^{9}-2^{8}-2^{7}-2^{6}-2^{4}-1</span>, which we treat as negligibly close to <span class="math">2^{256}</span>.</p>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Handling Exceptional Points.</h5>

    <p class="text-gray-300">As our circuit relies on Eq. (5) to evaluate <span class="math">f</span>, it is not prepared to handle the exceptional points in the set <span class="math">\\mathcal{F}</span>. However, since <span class="math">\\mathcal{F}</span> is efficiently recognizable, we can simply modify the prover and verifier algorithm of a given NIZK proof framework to immediately output <span class="math">\\bot</span> or <span class="math">0</span>, respectively, when run on an input with <span class="math">U\\in\\mathcal{F}</span> or <span class="math">V\\in\\mathcal{F}</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">6.1 Construction of Arithmetic Circuit</h3>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Half-range Point Multiplication.</h5>

    <p class="text-gray-300">Given the x-coordinates of <span class="math">uP</span> and <span class="math">uV</span>, the function <span class="math">f</span> can be computed with 4 multiplications using Eq. (5). Thus the main task of the circuit is to perform the two scalar multiplications <span class="math">uP</span> and <span class="math">uV</span>. We use a variant of a wNAF</p>

    <p class="text-gray-300">(windowed Non Adjacent Form) algorithm. In more detail, we represent <span class="math">u</span> by a 255-bit string <span class="math">k=(k_{0},\\cdots,k_{254})\\in\\{0,1\\}^{255}</span> as</p>

    <p class="text-gray-300"><span class="math">u</span> <span class="math">=8^{0}(1+2k_{0}+4k_{1})(-1)^{k_{2}}+8^{1}(1+2k_{3}+4k_{4})(-1)^{k_{5}}+\\cdots</span> <span class="math">\\quad+8^{83}(1+2k_{249}+4k_{250})(-1)^{k_{251}}</span> <span class="math">\\quad+(2^{252}+2^{253}k_{252}+2^{254}k_{253}+k_{254}).</span></p>

    <p class="text-gray-300">It can be verified that <span class="math">u\\in\\{1,\\ldots,2^{255}\\}</span>. Since Eq. (5) does not depend on the y-coordinate of <span class="math">uV</span>, the “sign” of <span class="math">u</span> is irrelevant and <span class="math">p/2</span> is just below <span class="math">2^{255}</span>, this range suffices for <span class="math">u</span>. By multiplying the entire equation with an input point <span class="math">Q\\in\\{P,V\\}</span>, we obtain</p>

    <p class="text-gray-300"><span class="math">uQ</span> <span class="math">=8^{0}(1+2k_{0}+4k_{1})(-1)^{k_{2}}Q+8^{1}(1+2k_{3}+4k_{4})(-1)^{k_{5}}Q+\\cdots</span> <span class="math">\\quad+8^{83}(1+2k_{249}+4k_{250})(-1)^{k_{251}}Q</span> <span class="math">\\quad+(2^{252}+2^{253}k_{252}+2^{254}k_{253}+k_{254})Q,</span></p>

    <p class="text-gray-300">a recipe for computing <span class="math">uQ</span>. Our resulting algorithm evaluates the sum of points on the right-hand side from left to right. The summands in the first and second line can be precomputed multiples of <span class="math">Q</span> of the form <span class="math">[-8^{i}\\cdot 7Q,-8^{i}\\cdot 5Q,-8^{i}\\cdot 3Q,-8^{i}\\cdot Q,8^{i}\\cdot Q,8^{i}\\cdot 3Q,8^{i}\\cdot 5Q,8^{i}\\cdot 7Q]</span>; the lookup of these can be efficiently implemented as 2-bit lookups with an optional negation. The summands in the last line correspond to other precomputed multiples of points; the lookup of these can be implemented as 3-bit lookups.</p>

    <p class="text-gray-300">A crucial property of this algorithm is that a point will never be added to itself or its negation when computing the sum from the left to the right. This follows from the observation that the absolute value of the coefficient of any summand is always greater than the sum of all coefficients in the previous summands. By avoiding these two special cases, we can work with an incomplete group law (see below).</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Lookup Tables.</h4>

    <p class="text-gray-300">We often need a circuit that implements a lookup in a constant table of <span class="math">2^{m}</span> values based on the value of <span class="math">m</span> bits <em>[x10, Section A.3.3.9]</em>.</p>

    <p class="text-gray-300">One bit. To implement the map <span class="math">\\{0\\mapsto v_{0},1\\mapsto v_{1}\\}</span> based on the value of the bit <span class="math">b_{0}</span>, write the expression as <span class="math">v_{0}+(v_{1}-v_{0})x</span>. This is a linear expression in <span class="math">b_{0}</span>, so no multiplications are needed. Two bits. To implement the map <span class="math">\\{00\\mapsto v_{00},10\\mapsto v_{10},01\\mapsto v_{01},11\\mapsto v_{11}\\}</span>, based on the value of the variables <span class="math">b_{0}</span> and <span class="math">b_{1}</span>, precompute <span class="math">A=v_{00}</span>, <span class="math">B=v_{10}-v_{00}</span>, <span class="math">C=v_{01}-v_{00}</span>, <span class="math">D=v_{00}+v_{11}-v_{01}-v_{10}</span>. The lookup can then be written as <span class="math">A+Bx+Cy+Dxy</span>. This requires one multiplication to find <span class="math">b_{0}b_{1}</span>. When multiple lookups based on the same <span class="math">b_{0}</span> and <span class="math">b_{1}</span> are needed, this multiplication can be shared across all of them. Three bits. To implement a map from 3 bits <span class="math">b_{0}</span>, <span class="math">b_{1}</span>, and <span class="math">b_{2}</span> to 8 values, precompute <span class="math">A=v_{000}</span>, <span class="math">B=v_{100}-v_{000}</span>, <span class="math">C=v_{010}-v_{000}</span>, <span class="math">D=v_{001}-v_{000}</span>, <span class="math">E=v_{000}+v_{110}-v_{100}-v_{010}</span>, <span class="math">F=v_{000}+v_{101}-v_{100}-v_{001}</span>, <span class="math">G=v_{000}+v_{011}-v_{010}-v_{001}</span>, <span class="math">H=v_{100}+v_{010}+v_{001}+v_{111}-v_{000}-v_{110}-v_{101}-v_{011}</span>. The lookup can then be written as <span class="math">A+Bb_{0}+Cb_{1}+Db_{2}+Eb_{0}b_{1}+Fb_{0}b_{2}+Gb_{1}b_{2}+Hb_{0}b_{1}b_{2}</span>. This requires 4 multiplications; one for each of <span class="math">b_{0}b_{1}</span>, <span class="math">b_{0}b_{2}</span>, <span class="math">b_{1}b_{2}</span>, and <span class="math">b_{0}b_{1}b_{2}</span>. Again these multiplications are shared across all lookups using the same input bits.</p>

    <p class="text-gray-300">Precomputed Odd Multiples of Points. To construct a circuit that looks up the coordinates of one of <span class="math">[-8^{i}\\cdot 7Q,-8^{i}\\cdot 5Q,-8^{i}\\cdot 3Q,-8^{i}\\cdot Q,8^{i}\\cdot Q,8^{i}\\cdot 3Q,8^{i}\\cdot 5Q,8^{i}\\cdot 7Q]</span> where <span class="math">Q\\in\\{P,V\\}</span>, using 3 input bits <span class="math">b_{0}</span>, <span class="math">b_{1}</span>, <span class="math">b_{2}</span> with just 2 multiplication gates, we start by constructing two instances of the two-bit lookup circuit from the previous paragraph; one for the x-coordinate of <span class="math">[8^{i}\\cdot Q,8^{i}\\cdot 3Q,8^{i}\\cdot 5Q,8^{i}\\cdot 7Q]</span> and one for the y-coordinate of those same points. This consumes <span class="math">b_{0}</span> and <span class="math">b_{1}</span>, and needs one gate (as the product of the two bits only needs to be computed once). The bit <span class="math">b_{2}</span> is then used to optionally negate the y-coordinate. That costs another gate <span class="math">(Y=(2z-1)Y^{\\prime})</span>, and extends the range to all 8 outputs.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Affine Elliptic Curve Point Addition.</h4>

    <p class="text-gray-300">For point additions, it is often preferable to represent curve points in Jacobian coordinates because this largely avoids expensive modular divisions. However, when all we care about is verifying the validity of a given equation, modular division is just as expensive as a multiplication – it is just a multiplication where the role of the output is swapped with one of the inputs.</p>

    <p class="text-gray-300">This makes the simpler, affine coordinates more appealing. If the input points are <span class="math">(x_{1},y_{1}),(x_{2},y_{2})</span> and their sum is <span class="math">(x_{3},y_{3})</span>, then for <span class="math">\\gamma=(y_{2}-y_{1})/(x_{2}-x_{1})</span> we have</p>

    <p class="text-gray-300"><span class="math">\\gamma(x_{2}-x_{1})=(y_{2}-y_{1}),\\qquad x_{3}=\\gamma^{2}-x_{1}-x_{2},\\qquad y_{3}=\\gamma(x_{1}-x_{3})-y_{1}.</span></p>

    <p class="text-gray-300">It requires 3 multiplication gates to verify these equations. Note that even if we ignore the point at infinity, these formulas do not form a complete group law: If the two input points are each other’s negation, no satisfaction can be found. If the two points are equal, <span class="math">\\gamma(x_{2}-x_{1})=y_{2}-y_{1}</span> will be valid for every value of <span class="math">\\gamma</span>. We stress that our circuit works securely with this incomplete group law as discussed above.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">6.2 Implementation and Performance Evaluation</h3>

    <p class="text-gray-300">To evaluate the performance of Purify we generated the arithmetic circuit for <span class="math">\\mathbb{G}=\\texttt{secp256k1}</span>, and benchmarked it on a Bulletproofs implementation written in C. We make our code available <em>[x29, x28]</em>. Besides the fact that it supports inputs given in commitments we choose Bulletproofs as proof system because its security is based only on the DL assumption in <span class="math">\\mathbb{G}</span>, which we already require for the security of MuSig-DN. As a result, we do not introduce computational assumptions beyond the hardness of DDH on the curves <span class="math">\\mathbb{E}_{1}</span> and <span class="math">\\mathbb{E}_{2}</span>.</p>

    <p class="text-gray-300">We ran the experiments on an Intel i7-7820HQ system pinned to 2.90 GHz using a single thread and using no more than 50 MB of memory. The implementation takes advantage of the secp256k1 endomorphism to speed up scalar multiplication, and leverages Bulletproofs’ support for batch verification of multiple proofs (which can be used to verify the proofs of all cosigners in a single batch). For reference, verifying a Schnorr signature takes 58 µs on the same system. The results in Table 1 show that MuSig-DN is practical on commodity hardware.</p>

    <p class="text-gray-300">The proof size is 1124 bytes. Bulletproofs <em>[BBB^{+}18]</em> enables a signer to create a single aggregate proof for multiple concurrent signing sessions, e.g., when signing multiple transactions with the same set of cosigners at the same time. This would further save bandwidth because the resulting aggregate proof is smaller than sending a separate proofs for every signing session. We have not implemented this optimization.</p>

    <p class="text-gray-300">Table 1. Running time of Bulletproofs with Purify arithmetic circuits for secp256k1, averaging over 50 runs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Batch size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover (Π.Prv)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">943 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier (Π.Ver)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">50 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">61 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">143 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">1078 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We believe that our techniques are useful beyond the area of deterministic multi-signatures. In this section we describe further promising applications of Purify. We leave a formal treatment for future work.</p>

    <p class="text-gray-300">VERIFIABLE ENCRYPTION OF DISCRETE LOGARITHMS. A verifiable encryption scheme (VES) is a public-key encryption scheme in which a ciphertext for some encryption key  <span class="math">V</span>  comes with a proof that (i) the ciphertext is indeed decryptable for anybody with the decryption key corresponding to  <span class="math">V</span> , and (ii) the resulting plaintext has some special property. Purify specifically applies to the verifiable encryption of a discrete logarithm, i.e., in our case property (ii) means that the resulting plaintext is a discrete logarithm of some given public group element  <span class="math">R</span> . The only VES we are aware of that supports this use case is by Camenisch and Shoup [CS03] and is specific to discrete logarithms in finite fields and does not generalize to other groups such as elliptic curve groups.</p>

    <p class="text-gray-300">We believe that our techniques imply a VES for discrete logarithms in any prime-order group  <span class="math">\\mathbb{G}</span>  supported by our construction and in particular elliptic curve groups. Say  <span class="math">V = vP\\in \\mathbb{E}</span>  is the public encryption key. To encrypt the discrete logarithm  <span class="math">r</span>  of public group element  <span class="math">R = rG\\in \\mathbb{G}</span>  to  <span class="math">V</span> , generate a random ephemeral scalar  <span class="math">u</span>  of  <span class="math">\\mathbb{E}</span> , and output the ElGamal-style ciphertext  <span class="math">(U,c) = (uP,r + f(uV))</span>  together with a NIZK proof that there is a witness  <span class="math">(u,r)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">U = u P \\wedge R = r G \\wedge r = c - f (u V),</span></div>

    <p class="text-gray-300">ignoring exceptional cases. This statement corresponds to the correct decryption  <span class="math">r = c - f(vU) = c - f(uV)</span> . Observe that this statement is very similar to the proof statement used in MuSig-DN; the only difference is that the discrete logarithm of  <span class="math">R</span>  is offset by an additional public input  <span class="math">c</span> .</p>

    <p class="text-gray-300">A practical usage example in the context of cryptocurrencies is verifiable encryption to an escrow agent trusted by buyer and seller of a good [Zmn19]. In this scenario, the buyer (with verification key  <span class="math">A = aG</span> ) does not trust the seller (with verification key  <span class="math">B = bG</span> ) to ship the goods after receiving a payment in Bitcoin. Therefore, the buyer first sends the coins to some aggregate verification key  <span class="math">\\tilde{X}</span>  jointly controlled by both parties (e.g.,  <span class="math">\\tilde{X}</span>  can be generated from  <span class="math">A</span>  and  <span class="math">B</span>  as in MuSig). Because the seller does not trust the buyer to finalize the payment honestly, the buyer uses VES to encrypt her secret key  <span class="math">a</span>  to the escrow agent, and sends the resulting ciphertext together with the proof of correct encryption to the seller. After having verified the proof of correct encryption with respect to the verification key  <span class="math">A</span> , the seller delivers the good. If the buyer now refuses to cooperate with the seller to unlock the money and send</p>

    <p class="text-gray-300">it to the seller, the seller can instead provide an out-of-band proof of the buyer’s misbehavior to the escrow agent and request the decryption of the buyer’s secret key <span class="math">a</span>. The advantage of this particular protocol is that the escrow agent does not need to be involved (and does not even learn about the existence of the deal) in the common case that buyer and seller cooperate. Nevertheless, the seller can be sure that the escrow agent is indeed able to obtain <span class="math">a</span> due to the use of VES.</p>

    <p class="text-gray-300">Double-Authentication-Preventing Signatures. In a double-authentication-preventing signature (DAPS) scheme <em>[x21, x22]</em>, signatures on messages are created with respect to an additional subject value. Signers are held accountable in the following sense: If a signer signs two different messages for the same subject, then the secret key can be computed from the two signatures.</p>

    <p class="text-gray-300">This property is supposed to disincentivize signers from signing conflicting statements, i.e., certify two different public keys for the same individual (the subject). Even though initially proposed for public-key infrastructures, DAPS have been proposed to be used in the context of cryptocurrencies in non-equivocation contracts <em>[x24]</em> where the secret key is also used as a key to access a cryptocurrency wallet. If the signer signs two conflicting statements, then everybody is able to steal (or burn the funds) of the misbehaving signer.</p>

    <p class="text-gray-300">Recall that discrete logarithm-based signature schemes suffer from the property that reusing the same nonce <span class="math">R</span> for two signatures on two different messages will expose the secret key. With this in mind, an obvious idea to construct DAPS is to turn this weakness into a feature and force the signer to derive the nonce <span class="math">R</span> deterministically from some secret and the subject, such that signing two messages for the same subject will imply the use of the same <span class="math">R</span> and thus exposure of the secret key. However, this seemingly simple approach so far has resisted all attempts to turn it into a concrete realization of DAPS. Derler, Ramacher, and Slamanig <em>[x10]</em> explain the issues that arise when trying to use a VRF such as the one by Dodis and Yampolskiy <em>[x13]</em> and call the aforementioned idea a dead end, and all existing constructions of DAPS in the discrete logarithm setting <em>[x24, x23, x10]</em> rely on different ideas. We conjecture that an approach that relies on Purify to derive <span class="math">R</span> overcomes these difficulties, precisely because it provides a stronger pseudorandomness property than the Dodis-Yampolskiy PRF as discussed in Section 1.2.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">Acknowledgments</h3>

    <p class="text-gray-300">We thank Tomer Ashur, Siemen Dhooghe, and Alan Szepieniec for help with finding parameters for a comparison between Purify and Rescue (see Section 1.3). We further thank Mihir Bellare, Greg Maxwell, Ruben Somsen, and the anonymous reviewers for their helpful comments and suggestions.</p>

    <h2 id="sec-23" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AAB^{+}19] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. Cryptology ePrint Archive, Report 2019/426, 2019. https://eprint.iacr.org/2019/426.</li>

      <li>[ACG^{+}19] Martin R. Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, and Markus Schofnegger. Algebraic cryptanalysis of STARK-friendly designs: Application to MARVELlous and MiMC. In Steven D. Galbraith and Shiho Moriai,</li>

    </ul>

    <p class="text-gray-300">editors, ASIACRYPT 2019, Part III, volume 11923 of LNCS, pages 371–397. Springer, Heidelberg, December 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AGP^{+}19] Martin R. Albrecht, Lorenzo Grassi, Léo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel structures for MPC, and more. In Kazue Sako, Steve Schneider, and Peter Y. A. Ryan, editors, ESORICS 2019, Part II, volume 11736 of LNCS, pages 151–171. Springer, Heidelberg, September 2019.</li>

      <li>[AGR^{+}16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part I, volume 10031 of LNCS, pages 191–219. Springer, Heidelberg, December 2016.</li>

      <li>[ARS^{+}15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In Elisabeth Oswald and Marc Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of LNCS, pages 430–454. Springer, Heidelberg, April 2015.</li>

      <li>[Bar97] George Barwood. Digital signatures using elliptic curves. Message posted to the sci.crypt mailing list, 1997. http://groups.google.com/group/sci.crypt/msg/b28aba37180dd6c6.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>[BCI^{+}10] Eric Brier, Jean-Sébastien Coron, Thomas Icart, David Madore, Hugues Randriam, and Mehdi Tibouchi. Efficient indifferentiable hashing into ordinary elliptic curves. In Tal Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 237–254. Springer, Heidelberg, August 2010.</li>

      <li>[BCK96] Mihir Bellare, Ran Canetti, and Hugo Krawczyk. Keying hash functions for message authentication. In Neal Koblitz, editor, CRYPTO’96, volume 1109 of LNCS, pages 1–15. Springer, Heidelberg, August 1996.</li>

      <li>[BDN18] Dan Boneh, Manu Drijvers, and Gregory Neven. Compact multi-signatures for smaller blockchains. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part II, volume 11273 of LNCS, pages 435–464. Springer, Heidelberg, December 2018.</li>

      <li>[BH19] Joachim Breitner and Nadia Heninger. Biased nonce sense: Lattice attacks against weak ECDSA signatures in cryptocurrencies. In Ian Goldberg and Tyler Moore, editors, FC 2019, volume 11598 of LNCS, pages 3–20. Springer, Heidelberg, February 2019.</li>

      <li>[BHH^{+}14] Joppe W. Bos, J. Alex Halderman, Nadia Heninger, Jonathan Moore, Michael Naehrig, and Eric Wustrow. Elliptic curve cryptography in practice. In Nicolas Christin and Reihaneh Safavi-Naini, editors, FC 2014, volume 8437 of LNCS, pages 157–175. Springer, Heidelberg, March 2014.</li>

      <li>[BN06] Mihir Bellare and Gregory Neven. Multi-signatures in the plain public-key model and a general forking lemma. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors, ACM CCS 2006, pages 390–399. ACM Press, October / November 2006.</li>

      <li>[Bol03] Alexandra Boldyreva. Threshold signatures, multisignatures and blind signatures based on the gap-Diffie-Hellman-group signature scheme. In Yvo Desmedt, editor, PKC 2003, volume 2567 of LNCS, pages 31–46. Springer, Heidelberg, January 2003.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Dorothy E. Denning, Raymond Pyle, Ravi Ganesan, Ravi S. Sandhu, and Victoria Ashby, editors, ACM CCS 93, pages 62–73. ACM Press, November 1993.</li>

      <li>[CEV14] Nicolas T. Courtois, Pinar Emirdag, and Filippo Valsorda. Private key recovery combination attacks: On extreme fragility of popular bitcoin key management, wallet and cold storage solutions in presence of poor RNG events. Cryptology ePrint Archive, Report 2014/848, 2014. http://eprint.iacr.org/2014/848.</li>

      <li>[CS03] Jan Camenisch and Victor Shoup. Practical verifiable encryption and decryption of discrete logarithms. In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 126–144. Springer, Heidelberg, August 2003.</li>

      <li>[DDP06] Ivan Damgård, Kasper Dupont, and Michael Østergaard Pedersen. Unclonable group identification. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 555–572. Springer, Heidelberg, May / June 2006.</li>

      <li>[DEF^{+}19] Manu Drijvers, Kasra Edalatnejad, Bryan Ford, Eike Kiltz, Julian Loss, Gregory Neven, and Igors Stepanovs. On the security of two-round multi-signatures. In 2019 IEEE Symposium on Security and Privacy, pages 1084–1101. IEEE Computer Society Press, May 2019.</li>

      <li>[DFL19] Poulami Das, Sebastian Faust, and Julian Loss. A formal treatment of deterministic wallets. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 651–668. ACM Press, November 2019.</li>

    </ul>

    <p class="text-gray-300">[DRS18] David Derler, Sebastian Ramacher, and Daniel Slamanig. Short double- and n-times-authentication-preventing signatures from ECDSA and more. In European Symposium on Security and Privacy - EuroS&P 2018, pages 273–287. IEEE, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DY05] Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random function with short proofs and keys. In Serge Vaudenay, editor, PKC 2005, volume 3386 of LNCS, pages 416–431. Springer, Heidelberg, January 2005.</li>

      <li>[FP07] Reza Rezaeian Farashahi and Ruud Pellikaan. The quadratic extension extractor for (hyper)elliptic curves in odd characteristic. In Claude Carlet and Berk Sunar, editors, Arithmetic of Finite Fields, First International Workshop, WAIFI 2007, volume 4547 of LNCS, pages 219–236. Springer, 2007.</li>

      <li>[FZ13] Matthew K. Franklin and Haibin Zhang. Unique ring signatures: A practical construction. In Ahmad-Reza Sadeghi, editor, FC 2013, volume 7859 of LNCS, pages 162–170. Springer, Heidelberg, April 2013.</li>

      <li>[GKR04a] Rosario Gennaro, Hugo Krawczyk, and Tal Rabin. Secure hashed Diffie-Hellman over Non-DDH groups. Cryptology ePrint Archive, Report 2004/099. Full version of <em>[GKR04b]</em>, 2004. http://eprint.iacr.org/2004/099.</li>

      <li>[GKR04b] Rosario Gennaro, Hugo Krawczyk, and Tal Rabin. Secure hashed Diffie-Hellman over non-DDH groups. In Christian Cachin and Jan Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 361–381. Springer, Heidelberg, May 2004.</li>

      <li>[Gür05] Nicolas Gürel. Extracting bits from coordinates of a point of an elliptic curve. Cryptology ePrint Archive, Report 2005/324, 2005. http://eprint.iacr.org/2005/324.</li>

      <li>[Har94] Lein Harn. Group-oriented <span class="math">(t,n)</span> threshold digital signature scheme and digital multisignature. IEE Proceedings - Computers and Digital Techniques, 141(5):307–313, 1994.</li>

      <li>[HBHW19] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. Zcash protocol specification, version 2019.0.8, 2019. https://raw.githubusercontent.com/zcash/zips/master/protocol/protocol.pdf.</li>

      <li>[HDWH12] Nadia Heninger, Zakir Durumeric, Eric Wustrow, and J. Alex Halderman. Mining your ps and qs: Detection of widespread weak keys in network devices. In Tadayoshi Kohno, editor, USENIX Security 2012, pages 205–220. USENIX Association, August 2012.</li>

      <li>[HMP95] Patrick Horster, Markus Michels, and Holger Petersen. Meta-multisignature schemes based on the discrete logarithm problem. In IFIP/Sec ’95, IFIP Advances in Information and Communication Technology, pages 128–142. Springer, 1995.</li>

      <li>[IN83] K. Itakura and K. Nakamura. A public-key cryptosystem suitable for digital multisignatures. NEC Research and Development, 71:1–8, 1983.</li>

      <li>[Kal87] Burton S. Kaliski Jr. A pseudo-random bit generator based on elliptic logarithms. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 84–103. Springer, Heidelberg, August 1987.</li>

      <li>[Kos15] Ahmed Kosba. jsnark: A java library for writing circuits/constraint systems for zk-snarks, 2015. https://github.com/akosba/jsnark.</li>

      <li>[Lan96] Susan K. Langford. Weakness in some threshold cryptosystems. In Neal Koblitz, editor, CRYPTO’96, volume 1109 of LNCS, pages 74–82. Springer, Heidelberg, August 1996.</li>

      <li>[LHL95] Chuan-Ming Li, Tzonelih Hwang, and Narn-Yih Lee. Threshold-multisignature schemes where suspected forgery implies traceability of adversarial shareholders. In Alfredo De Santis, editor, EUROCRYPT’94, volume 950 of LNCS, pages 194–204. Springer, Heidelberg, May 1995.</li>

      <li>[LMR19] Russell W. F. Lai, Giulio Malavolta, and Viktoria Ronge. Succinct arguments for bilinear group arithmetic: Practical structure-preserving cryptography. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2057–2074. ACM Press, November 2019.</li>

      <li>[LOS^{+}06] Steve Lu, Rafail Ostrovsky, Amit Sahai, Hovav Shacham, and Brent Waters. Sequential aggregate signatures and multisignatures without random oracles. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 465–485. Springer, Heidelberg, May / June 2006.</li>

      <li>[MH96] Markus Michels and Patrick Horster. On the risk of disruption in several multiparty signature schemes. In Kwangjo Kim and Tsutomu Matsumoto, editors, ASIACRYPT’96, volume 1163 of LNCS, pages 334–345. Springer, Heidelberg, November 1996.</li>

      <li>[MNPV99] David M’Raihi, David Naccache, David Pointcheval, and Serge Vaudenay. Computational alternatives to random number generators. In Stafford E. Tavares and Henk Meijer, editors, SAC 1998, volume 1556 of LNCS, pages 72–80. Springer, Heidelberg, August 1999.</li>

    </ul>

    <p class="text-gray-300">[MOR01] Silvio Micali, Kazuo Ohta, and Leonid Reyzin. Accountable-subgroup multisignatures: Extended abstract. In Michael K. Reiter and Pierangela Samarati, editors, ACM CCS 2001, pages 245–254. ACM Press, November 2001.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[MPSW19] Gregory Maxwell, Andrew Poelstra, Yannick Seurin, and Pieter Wuille. Simple Schnorr multisignatures with applications to Bitcoin. Des. Codes Cryptogr., 87(9):2139–2164, 2019.</li>

      <li>[MRH04] Ueli M. Maurer, Renato Renner, and Clemens Holenstein. Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology. In Moni Naor, editor, TCC 2004, volume 2951 of LNCS, pages 21–39. Springer, Heidelberg, February 2004.</li>

      <li>[MRV99] Silvio Micali, Michael O. Rabin, and Salil P. Vadhan. Verifiable random functions. In 40th FOCS, pages 120–130. IEEE Computer Society Press, October 1999.</li>

      <li>[Nic20] Jonas Nick. Purify benchmarks in the bulletproofs reference code, 2020. https://github.com/jonasnick/secp256k1-zkp/tree/bulletproof-musig-dn-benches.</li>

      <li>[NS02] Phong Q. Nguyen and Igor Shparlinski. The insecurity of the digital signature algorithm with partially known nonces. Journal of Cryptology, 15(3):151–176, June 2002.</li>

      <li>[NS03] Phong Q. Nguyen and Igor Shparlinski. The insecurity of the Elliptic Curve Digital Signature Algorithm with partially known nonces. Des. Codes Cryptogr., 30(2):201–217, 2003.</li>

      <li>[OO93] Kazuo Ohta and Tatsuaki Okamoto. A digital multisignature scheme based on the Fiat-Shamir scheme. In Hideki Imai, Ronald L. Rivest, and Tsutomu Matsumoto, editors, ASIACRYPT’91, volume 739 of LNCS, pages 139–148. Springer, Heidelberg, November 1993.</li>

      <li>[OO99] Kazuo Ohta and Tatsuaki Okamoto. Multi-signature schemes secure against active insider attacks. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Science, E82-A(1):21–31, 1999.</li>

      <li>[Poe18] Bertram Poettering. Shorter double-authentication preventing signatures for small address spaces. In Antoine Joux, Abderrahmane Nitaj, and Tajjeeddine Rachidi, editors, AFRICACRYPT 18, volume 10831 of LNCS, pages 344–361. Springer, Heidelberg, May 2018.</li>

      <li>[Por13] Thomas Pornin. Deterministic usage of the digital signature algorithm (DSA) and elliptic curve digital signature algorithm (ECDSA). RFC 6979, 2013. Available at https://rfc-editor.org/rfc/rfc6979.txt.</li>

      <li>[PS00] David Pointcheval and Jacques Stern. Security arguments for digital signatures and blind signatures. Journal of Cryptology, 13(3):361–396, June 2000.</li>

      <li>[PS14] Bertram Poettering and Douglas Stebila. Double-authentication-preventing signatures. In Miroslaw Kutylowski and Jaideep Vaidya, editors, ESORICS 2014, Part I, volume 8712 of LNCS, pages 436–453. Springer, Heidelberg, September 2014.</li>

      <li>[PS17] Bertram Poettering and Douglas Stebila. Double-authentication-preventing signatures. Int. J. Inf. Sec., 16(1):1–22, 2017.</li>

      <li>[PWH^{+}17] Dimitrios Papadopoulos, Duane Wessels, Shumon Huque, Moni Naor, Jan Včelák, Leonid Reyzin, and Sharon Goldberg. Making NSEC5 practical for DNSSEC. Cryptology ePrint Archive, Report 2017/099, 2017. http://eprint.iacr.org/2017/099.</li>

      <li>[RKS15] Tim Ruffing, Aniket Kate, and Dominique Schröder. Liar, liar, coins on fire!: Penalizing equivocation by loss of bitcoins. In Indrajit Ray, Ninghui Li, and Christopher Kruegel, editors, ACM CCS 2015, pages 219–230. ACM Press, October 2015.</li>

      <li>[RSS11] Thomas Ristenpart, Hovav Shacham, and Thomas Shrimpton. Careful with composition: Limitations of the indifferentiability framework. In Kenneth G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 487–506. Springer, Heidelberg, May 2011.</li>

      <li>[RY07] Thomas Ristenpart and Scott Yilek. The power of proofs-of-possession: Securing multiparty signatures against rogue-key attacks. In Moni Naor, editor, EUROCRYPT 2007, volume 4515 of LNCS, pages 228–245. Springer, Heidelberg, May 2007.</li>

      <li>[Sag19] SageMath, the Sage Mathematics Software System (Version 8.9), 2019. https://www.sagemath.org.</li>

      <li>[Sch91] Claus-Peter Schnorr. Efficient signature generation by smart cards. Journal of Cryptology, 4(3):161–174, January 1991.</li>

      <li>[SG02] Victor Shoup and Rosario Gennaro. Securing threshold cryptosystems against chosen ciphertext attack. Journal of Cryptology, 15(2):75–96, March 2002.</li>

      <li>[Val14] Filippo Valsorda. Exploiting ECDSA failures in the Bitcoin blockchain. HITB Security Conference, 2014. See https://conference.hitb.org/hitbsecconf2014kul/materials/D1T1%20-%20Filippo%20Valsorda%20-%20Exploiting%20ECDSA%20Failures%20in%20the%20Bitcoin%20Blockchain.pdf.</li>

    </ul>

    <p class="text-gray-300">[Wag02] David Wagner. A generalized birthday problem. In Moti Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 288-303. Springer, Heidelberg, August 2002. [Wig97] John Wigley. Removing need for rng in signatures. Message posted to the sci.crypt mailing list, 1997. http://groups.google.com/group/sci.crypt/msg/a6da45bcc8939a89. [WNR20] Pieter Wuille, Jonas Nick, and Tim Ruffing. Schnorr signatures for secp256k1. Bitcoin Improvement Proposal 340, 2020. See https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki. [WNT20] Pieter Wuille, Jonas Nick, and Anthony Towns. Taproot: Segwit version 1 output spending rules. Bitcoin Improvement Proposal 341, 2020. See https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki. [Wui13] Pieter Wuille. Hierarchical deterministic wallets. Bitcoin Improvement Proposal 32, 2013. See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki. [Wui19] Pieter Wuille. Reference implementation of arithmetic circuit and curve selection code, 2019. https://github.com/sipa/purify. [Zmn19] ZmnSCPxj. Escrow over lightning?, 2019. https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002028..</p>

    <p class="text-gray-300">We proceed by induction. The result obviously holds for  <span class="math">n = 1</span> . Assuming that it holds for  <span class="math">n - 1</span> , we prove that it holds for  <span class="math">n</span> . For  <span class="math">s \\in S</span> , let  <span class="math">\\mu(s) \\coloneqq \\operatorname{Pr}[X = s]</span>  and  <span class="math">\\nu(s) \\coloneqq \\operatorname{Pr}[Y = s]</span> . Then, we derive the induction step as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} 2 \\Delta (X ^ {(n)}, Y ^ {(n)}) = \\sum_ {(s _ {1}, \\dots , s _ {n}) \\in S ^ {n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu (s _ {1}) \\dots \\mu (s _ {n}) - \\nu (s _ {1}) \\dots \\nu (s _ {n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ = \\sum_ {(s _ {1}, \\dots , s _ {n}) \\in S ^ {n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu (s _ {1}) \\dots \\mu (s _ {n}) - \\mu (s _ {1}) \\dots \\mu (s _ {n - 1}) \\nu (s _ {n}) \\\\ + \\mu (s _ {1}) \\dots \\mu (s _ {n - 1}) \\nu (s _ {n}) - \\nu (s _ {1}) \\dots \\nu (s _ {n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\leq \\sum_ {(s _ {1}, \\dots , s _ {n}) \\in S ^ {n}} \\mu (s _ {1}) \\dots \\mu (s _ {n - 1}) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu (s _ {n}) - \\nu (s _ {n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ + \\sum_ {(s _ {1}, \\dots , s _ {n}) \\in S ^ {n}} \\nu (s _ {n}) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu (s _ {1}) \\dots \\mu (s _ {n - 1}) - \\nu (s _ {1}) \\dots \\nu (s _ {n - 1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ = \\underbrace {\\sum_ {(s _ {1} , \\ldots , s _ {n - 1}) \\in S ^ {n - 1}} \\mu (s _ {1}) \\cdots \\mu (s _ {n - 1})} _ {= 1} \\cdot \\underbrace {\\sum_ {s _ {n} \\in S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu (s _ {n}) - \\nu (s _ {n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} _ {= 2 \\Delta (X, Y)} \\\\ + \\underbrace {\\sum_ {s _ {n} \\in S} \\nu (s _ {n})} _ {= 1} \\cdot \\underbrace {\\sum_ {(s _ {1} , \\ldots , s _ {n - 1}) \\in S ^ {n - 1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu (s _ {1}) \\cdots \\mu (s _ {n - 1}) - \\nu (s _ {1}) \\cdots \\nu (s _ {n - 1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} _ {\\leq 2 (n - 1) \\Delta (X, Y)} \\\\ \\leq 2 n \\cdot \\Delta (X, Y). \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In this section, we prove the security of MuSig-DN as stated in the following theorem that we recall from Section 4.</p>

    <p class="text-gray-300">Theorem 1. Let GrGen be a group generation algorithm for which the DL problem is hard and GrGen' be a  <span class="math">(t,\\varepsilon)</span> -companion group generation algorithm for which the DDH problem is hard. Let KeyDer be a PRNG, RandDer a PRF, and  <span class="math">\\Pi</span>  be a zero-knowledge and simulation-sound</p>

    <p class="text-gray-300">NIZK proof system for relation <span class="math">\\mathsf{R}</span> as defined in Eq. (2) for some set <span class="math">\\mathcal{F}</span>. Then the multi-signature scheme <span class="math">\\mathsf{MS}:=\\mathsf{MuSig-DN}[\\mathsf{GrGen},\\mathsf{GrGen}^{\\prime},\\mathsf{KeyDer},\\mathsf{RandDer},\\mathsf{\\Pi},\\mathcal{F}]</span> is EUF-CMA-secure in the random oracle model.</p>

    <p class="text-gray-300">Precisely, for any p.p.t. adversary <span class="math">\\mathcal{A}</span> making at most <span class="math">q_{\\mathrm{h}}</span> random oracle queries and initiating at most <span class="math">q_{\\mathrm{s}}</span> instances of the signature protocol with the honest signer, there exist p.p.t. adversaries <span class="math">\\mathcal{B}_{\\mathrm{prng}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{prf}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{snd}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{zk}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{ss}}</span>, <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span>, and <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> with</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathrm{rmf-cma}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)</span> <span class="math">\\leq(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{3/4}\\left(\\mathsf{Adv}^{\\mathrm{dl}}_{\\mathsf{GrGen},\\mathcal{B}_{\\mathrm{dl}}}(\\lambda)\\right)^{1/4}</span> <span class="math">+\\mathsf{Adv}^{\\mathrm{prng}}_{\\mathsf{KeyDer},\\mathcal{B}_{\\mathrm{prng}}}(\\lambda)+\\mathsf{Adv}^{\\mathrm{prf}}_{\\mathsf{RandDer},\\mathcal{B}_{\\mathrm{prf}}}(\\lambda)+\\mathsf{Adv}^{\\mathrm{snd}}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{snd}}}(\\lambda)+\\mathsf{Adv}^{\\mathrm{zk}}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{zk}}}(\\lambda)</span> <span class="math">+\\mathsf{Adv}^{\\mathrm{ddh}}_{\\mathsf{GrGen}^{\\prime},\\mathcal{B}_{\\mathrm{ddh}}}(\\lambda)+\\mathsf{Adv}^{\\mathrm{ss}}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{ss}}}(\\lambda)+q_{\\mathrm{s}}\\varepsilon+\\frac{(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{2}}{2^{\\lambda-2}}+\\frac{2}{2^{\\lambda/4}}.</span></p>

    <p class="text-gray-300">We start with a brief overview of the proof (using the notation of Section 4). The general strategy is similar to the security proof of <span class="math">\\mathsf{MuSig}</span> <em>[x20]</em>: we describe a reduction to the DL problem which simulates the honest prover without knowledge of its secret key <span class="math">x_{1}</span> and then extracts <span class="math">x_{1}</span> from the forgery returned by the attacker. To this end, we use the Forking Lemma <em>[x22]</em> twice: first to extract the discrete logarithm of the aggregate key involved in the forgery, and then to extract the discrete logarithm of the honest user’s public key <span class="math">X_{1}</span>. The main difference to the security proof of <span class="math">\\mathsf{MuSig}</span> lies in how the signature oracle corresponding to the honest user is simulated. As usual with Schnorr signatures, the idea is to draw <span class="math">s_{1},c\\longleftrightarrow\\mathds{F}_{p}</span>, to let <span class="math">R_{1}:=s_{1}G-ca_{1}X_{1}</span>, and to program <span class="math">\\mathsf{H}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m):=c</span>. Then <span class="math">r_{1}:=s_{1}-ca_{1}x_{1}</span> is uniformly random in <span class="math">\\mathds{F}_{p}</span>, which under DDH and by the assumption that <span class="math">f</span> is regular is indistinguishable from <span class="math">f(u_{1}\\mathsf{H}_{\\mathrm{non}}(\\mathbf{K},m))</span>. Moreover, since <span class="math">R_{1}</span> is not generated as specified by the protocol, we switch to simulated NIZK proofs, which by the zero-knowledge property of the proof system are indistinguishable from normal proofs.</p>

    <p class="text-gray-300">In order to be able to program <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span> adequately, the adversary must not have previously queried <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span> on input <span class="math">(\\widetilde{X},\\widetilde{R},m)</span>. This implies that <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span> must be programmed before the reduction sends <span class="math">R_{1}</span> to the adversary. The reduction programs <span class="math">\\mathsf{H}_{\\mathrm{non}}(\\mathbf{K},m):=vP</span> for <span class="math">v\\longleftrightarrow\\mathds{Z}_{q}</span>, which allows to compute the nonces <span class="math">R_{i}</span> (<span class="math">i\\geq 2</span>) that will be sent by the adversary as <span class="math">R_{i}=f(vU_{i})</span> and hence to compute <span class="math">\\widetilde{R}</span> and program <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span> (more precisely, the adversary cannot send a nonce different from <span class="math">R_{i}</span> unless it breaks simulation-soundness of <span class="math">\\mathsf{\\Pi}</span>).</p>

    <p class="text-gray-300">Note that the adversary might copy the honest signer’s host key and set <span class="math">U_{i}=U_{1}</span>. This case must be handled before the switch to simulated proofs since afterwards, there are two possible nonces that the adversary could send and that would not allow to break simulation-soundness of <span class="math">\\mathsf{\\Pi}</span>: the (fake) nonce <span class="math">R_{1}</span> sent by the reduction and the correct nonce <span class="math">f(u_{1}V)P</span>. For host keys <span class="math">U_{i}\\neq U_{1}</span>, checking correctness of the nonce <span class="math">R_{i}</span> sent by the adversary requires knowledge of the discrete logarithm of <span class="math">\\mathsf{H}_{\\mathrm{non}}(\\mathbf{K},m)</span>. However, programming <span class="math">\\mathsf{H}_{\\mathrm{non}}(\\mathbf{K},m):=vP</span> can only be done after the reduction step to DDH, hence after the switch to simulated proofs and random nonces, so that the two cases <span class="math">U_{i}=U_{1}</span> and <span class="math">U_{i}\\neq U_{1}</span> must be handled separately.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{MS}:=\\mathsf{MuSig-DN}[\\mathsf{GrGen},\\mathsf{GrGen}^{\\prime},\\mathsf{KeyDer},\\mathsf{RandDer},\\mathsf{\\Pi},\\mathcal{F}]</span> and <span class="math">\\mathcal{A}</span> be an adversary against the EUF-CMA-security of <span class="math">\\mathsf{MS}</span>. We proceed with a sequence of games whose formal definition can be found in Fig. 6 to Fig. 8. Since we work in the ROM, hash functions <span class="math">\\mathsf{H}_{\\mathrm{agg}}</span>, <span class="math">\\mathsf{H}_{\\mathrm{sig}}</span>, and <span class="math">\\mathsf{H}_{\\mathrm{non}}</span> are replaced with random oracles <span class="math">\\mathrm{RO}_{\\mathrm{agg}}</span>, <span class="math">\\mathrm{RO}_{\\mathrm{sig}}</span>, and <span class="math">\\mathrm{RO}_{\\mathrm{non}}</span> respectively. For brevity we let <span class="math">\\overrightarrow{\\mathrm{RO}}:=(\\mathrm{RO}_{\\mathrm{agg}},\\mathrm{RO}_{\\mathrm{sig}},\\mathrm{RO}_{\\mathrm{non}})</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{0}</span>. This is the original unforgeability experiment of Definition 4 applied to <span class="math">\\mathsf{MS}</span> where we made the following changes. First, the nonce/host key pair <span class="math">(u_{1},U_{1})</span> for the honest user is computed during the initialization of the game and <span class="math">U_{1}</span> is given as input to <span class="math">\\mathcal{A}</span>. Clearly, this is w.l.o.g as the first message sent by the honest user in a signing session is always <span class="math">U_{1}</span>. Second, we omit the first round of the signing protocol where host keys are exchanged: instead, the adversary calls the signing oracle <span class="math">\\mathrm{Sign}</span> on input <span class="math">(\\mathbf{K},m)</span> where <span class="math">\\mathbf{K}</span> is a multiset of verification/host key pairs <span class="math">\\{(X_{1},U_{1}),\\ldots,(X_{n},U_{n})\\}</span>, and the oracle returns <span class="math">\\bot</span> in case <span class="math">(X_{1},U_{1})\\notin\\mathbf{K}</span>. Again, this is w.l.o.g. as this is equivalent to <span class="math">\\mathcal{A}</span> calling the signing oracle on input a multiset of verification keys <span class="math">\\mathbf{X}</span>, the oracle sending <span class="math">U_{1}</span> if <span class="math">X_{1}\\in\\mathbf{X}</span> and <span class="math">\\bot</span> otherwise, and the adversary answering with <span class="math">U_{2},\\ldots,U_{n}</span>. Finally, values <span class="math">W</span>, <span class="math">r_{1}</span>, and <span class="math">\\rho</span> computed by oracle <span class="math">\\mathrm{Sign}</span> are stored in tables <span class="math">\\mathsf{T}_{\\mathrm{ddh}}</span>, <span class="math">\\mathsf{T}_{\\mathrm{rand}}</span>, and <span class="math">\\mathsf{T}_{\\rho}</span> respectively, so that they are not computed again if <span class="math">\\mathrm{Sign}</span> is called twice or more on the same inputs <span class="math">(\\mathbf{K},m)</span>. This is purely syntactical and will simplify game hops later. Hence, one has</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{0}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)=\\mathsf{Adv}^{\\mathsf{ruf-cma}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda).</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{1}</span>. In <span class="math">\\mathsf{Game}_{1}</span>, we draw <span class="math">x_{1}</span>, <span class="math">u_{1}</span>, and <span class="math">k</span> uniformly at random instead of drawing <span class="math">\\mathsf{sk}_{1}</span> and calling <span class="math">\\mathsf{KeyDer}(\\mathsf{sk}_{1})</span>. It is straightforward to construct an adversary <span class="math">\\mathcal{B}_{\\mathrm{prng}}</span> against the PRNG-security of <span class="math">\\mathsf{KeyDer}</span> which on input <span class="math">(x_{1},u_{1},k)</span> simulates <span class="math">\\mathsf{Game}_{0}</span> if <span class="math">(x_{1},u_{1},k)=\\mathsf{KeyDer}(\\mathsf{sk}_{1})</span> and <span class="math">\\mathsf{Game}_{2}</span> if <span class="math">(x_{1},u_{1},k)</span> is uniformly random. Hence,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{1}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{0}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-\\mathsf{Adv}^{\\mathsf{prng}}_{\\mathsf{KeyDer},\\mathcal{B}_{\\mathrm{prng}}}(\\lambda).</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{2}</span>. In <span class="math">\\mathsf{Game}_{2}</span>, we draw <span class="math">\\rho</span> uniformly at random instead of calling <span class="math">\\mathsf{RandDer}(k,(\\mathbf{K},m))</span>, and store it in a table <span class="math">\\mathsf{T}_{\\rho}</span> (this way, the same bitstring <span class="math">\\rho</span> is used if <span class="math">\\mathrm{Sign}(\\mathbf{K},m)</span> is called again). It is straightforward to construct an adversary <span class="math">\\mathcal{B}_{\\mathrm{prf}}</span> against the PRF-security of <span class="math">\\mathsf{RandDer}</span> which simulates <span class="math">\\mathsf{Game}_{1}</span> if <span class="math">\\rho=\\mathsf{RandDer}(k,(\\mathbf{K},m))</span> and <span class="math">\\mathsf{Game}_{2}</span> if <span class="math">\\rho</span> is uniformly random. Hence,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{2}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{1}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-\\mathsf{Adv}^{\\mathsf{prf}}_{\\mathsf{RandDer},\\mathcal{B}_{\\mathrm{prf}}}(\\lambda).</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{3}</span>. In <span class="math">\\mathsf{Game}_{3}</span>, during a call to <span class="math">\\mathrm{Sign}(\\mathbf{K},m)</span>, we check whether the adversary copied the honest user’s host key <span class="math">U_{1}</span> and managed to return a nonce different from <span class="math">R_{1}</span> yet with an accepting proof, and abort the game if this is the case. Since for a nonce <span class="math">R_{i}\\neq R_{1}</span>, the tuple <span class="math">(U_{1},V,R_{i})</span> cannot be in the language, this breaks soundness of <span class="math">\\mathsf{\\Pi}</span>. More precisely, we construct an adversary <span class="math">\\mathcal{B}_{\\mathrm{snd}}</span> for game <span class="math">\\mathrm{SND}_{\\mathsf{\\Pi}}</span>. It receives <span class="math">\\mathsf{crs}\\leftarrow\\mathsf{\\textsc{s}}\\mathsf{\\Pi}.\\mathsf{Setup}(1^{\\lambda})</span> and simulates <span class="math">\\mathsf{Game}_{3}</span>. If the game ends up at line (I), <span class="math">\\mathcal{B}_{\\mathrm{snd}}</span> returns the corresponding tuple <span class="math">(U_{1},V,R_{i})</span>, otherwise it aborts. Since <span class="math">\\mathcal{B}_{\\mathrm{snd}}</span> wins game <span class="math">\\mathrm{SND}_{\\mathsf{\\Pi}}</span> exactly when <span class="math">\\mathsf{Game}_{2}</span> returns <span class="math">\\mathbf{true}</span> but <span class="math">\\mathsf{Game}_{3}</span> does not, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{3}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{2}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-\\mathsf{Adv}^{\\mathsf{snd}}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{snd}}}(\\lambda).</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{4}</span>. We define <span class="math">\\mathsf{Game}_{4}</span> from <span class="math">\\mathsf{Game}_{3}</span> by switching to simulated proofs. In the previous <span class="math">\\mathsf{Game}_{3}</span> we ensure that the same protocol inputs <span class="math">(\\mathbf{K},m)</span> yield the same prover randomness <span class="math">\\rho</span> and in turn the same NIZK proof <span class="math">\\pi_{1}</span> by storing <span class="math">\\rho</span> in table <span class="math">\\mathsf{T}_{\\rho}</span> and passing it as an explicit randomness argument to <span class="math">\\mathsf{\\Pi}.\\mathsf{Prv}</span>. To ensure that the same is true in <span class="math">\\mathsf{Game}_{4}</span>, we store and pass <span class="math">\\rho</span> as an explicit randomness argument to <span class="math">\\mathsf{\\Pi}.\\mathsf{SimPrv}</span> in <span class="math">\\mathsf{Game}_{4}</span> in an analogous manner. <span class="math">\\mathsf{Game}_{4}</span> is easily shown to be indistinguishable from <span class="math">\\mathsf{Game}_{3}</span> by constructing the following adversary <span class="math">\\mathcal{B}_{\\mathrm{sk}}</span> for game <span class="math">\\mathsf{ZK}_{\\mathsf{\\Pi}}</span>: it receives <span class="math">\\mathsf{crs}</span> (which is either generated by <span class="math">\\mathsf{\\Pi}.\\mathsf{Setup}</span> or <span class="math">\\mathsf{\\Pi}.\\mathsf{SimSetup}</span>) and simulates <span class="math">\\mathsf{Game}_{3}/\\mathsf{Game}_{4}</span>, querying its oracle <span class="math">\\mathrm{Prove}((U_{1},V,R_{1}),u_{1})</span> when producing a proof. It returns <span class="math">1</span> if the game</p>

    <p class="text-gray-300">returns true and 0 otherwise. Since <span class="math">\\mathcal{B}_{\\mathrm{zk}}</span> exactly simulates Game_{3} or Game_{4} depending on the random bit of the challenger of the ZK_{Π} game, one has</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{4}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{3}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-\\mathsf{Adv}^{\\mathsf{zk}}_{\\Pi,\\mathcal{B}_{\\mathrm{zk}}}(\\lambda).</span></p>

    <p class="text-gray-300">Game_{5}. We define Game_{5} as Game_{4} except that during a call to Sign<span class="math">(\\mathbf{K},m)</span>, the group element <span class="math">W</span>, which is computed as <span class="math">u_{1}V</span> in Game_{4}, is drawn uniformly at random and stored in a table <span class="math">\\mathsf{T}_{\\mathrm{ddh}}</span> (this way, the same group element <span class="math">W</span> is used if Sign<span class="math">(\\mathbf{K},m)</span> is called again). We construct an adversary <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> solving the DDH problem in <span class="math">\\mathbb{E}</span> as follows. On input a DDH instance <span class="math">(U_{1},\\bar{V},\\bar{W})</span>, <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> simulates Game_{4}/Game_{5} as follows: it draws <span class="math">x_{1}\\longleftrightarrow\\mathbb{F}_{p}</span>, computes <span class="math">X_{1}:=x_{1}G</span>, and runs <span class="math">\\mathcal{A}</span> on input <span class="math">(\\mathsf{par},X_{1},U_{1})</span>. When an assignment to <span class="math">\\mathsf{T}_{\\mathrm{non}}(\\mathbf{K},m)</span> occurs, <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> draws <span class="math">\\alpha,\\beta\\longleftrightarrow\\mathbb{Z}_{q}</span>, lets <span class="math">V:=\\alpha P+\\beta\\bar{V}</span> and <span class="math">W:=\\alpha U_{1}+\\beta\\bar{W}</span>, and stores <span class="math">\\mathsf{T}_{\\mathrm{non}}(\\mathbf{K},m):=V</span> and <span class="math">\\mathsf{T}_{\\mathrm{ddh}}(\\mathbf{K},m):=W</span>. It returns 1 if <span class="math">\\mathcal{A}</span> wins the game and 0 otherwise. (Note that <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> does not need the discrete logarithm of <span class="math">U_{1}</span> for simulating the game.)</p>

    <p class="text-gray-300">We prove in Appendix D that the way <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> re-randomizes <span class="math">\\bar{V}</span> and <span class="math">\\bar{W}</span> ensures that for each pair <span class="math">(\\mathbf{K},m)</span>, (i) <span class="math">\\mathsf{T}_{\\mathrm{non}}(\\mathbf{K},m)</span> is uniformly random and (ii) <span class="math">(U_{1},\\mathsf{T}_{\\mathrm{non}}(\\mathbf{K},m),\\mathsf{T}_{\\mathrm{ddh}}(\\mathbf{K},m))</span> is a DDH tuple if <span class="math">(U_{1},\\bar{V},\\bar{W})</span> is a DDH tuple, whereas <span class="math">\\mathsf{T}_{\\mathrm{ddh}}(\\mathbf{K},m)</span> is uniformly random if <span class="math">(U_{1},\\bar{V},\\bar{W})</span> is a non-DDH tuple. Hence, when <span class="math">(U_{1},\\bar{V},\\bar{W})</span> is a DDH tuple, then <span class="math">\\mathcal{B}_{\\mathrm{ddh}}</span> perfectly simulates Game_{4}, whereas when <span class="math">(U_{1},\\bar{V},\\bar{W})</span> is a non-DDH tuple, it perfectly simulates Game_{5}. Consequently,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{5}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{4}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-\\mathsf{Adv}^{\\mathsf{ddh}}_{\\mathsf{GrGen}^{\\prime},\\mathcal{B}_{\\mathrm{ddh}}}(\\lambda).</span></p>

    <p class="text-gray-300">Game_{6}. In Game_{6}, everything is similar to Game_{5} except that the secret nonce <span class="math">r_{1}</span>, which is computed as <span class="math">f(W)</span> in Game_{5}, is drawn uniformly at random in <span class="math">\\mathbb{F}_{p}</span>. Since <span class="math">W</span> is uniform in Game_{5}, by <span class="math">\\varepsilon</span>-uniformity of <span class="math">f</span> and Lemma 1, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{6}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{5}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-q_{\\mathrm{s}}\\varepsilon.</span></p>

    <p class="text-gray-300">Game_{7}. In Game_{7}, we first change how queries to RO_{non} are answered. Instead of drawing <span class="math">\\mathsf{T}_{\\mathrm{non}}(\\mathbf{K},m)\\longleftrightarrow\\mathbb{E}</span>, we draw <span class="math">v\\longleftrightarrow\\mathbb{Z}_{q}</span> and let <span class="math">\\mathsf{T}_{\\mathrm{non}}(\\mathbf{K},m):=vP</span>. The value <span class="math">v</span> is stored in an additional table <span class="math">\\mathsf{T}^{\\prime}_{\\mathrm{non}}</span>. Clearly, this is a purely syntactic change. Moreover, we check that the nonces <span class="math">R_{2},\\ldots,R_{n}</span> sent by the adversary (for host keys <span class="math">U_{i}\\neq U_{1}</span>) have been computed correctly. The value <span class="math">v:=\\mathsf{T}^{\\prime}_{\\mathrm{non}}(\\mathbf{K},m)</span> is retrieved and the game checks that <span class="math">R_{i}=f(vU_{i})G</span>. If for some <span class="math">i\\in\\{2,\\ldots,n\\}</span> the proof <span class="math">\\pi_{i}</span> was valid yet <span class="math">R_{i}\\neq f(vU_{i})G</span>, the game aborts and returns false. We construct an adversary <span class="math">\\mathcal{B}_{\\mathrm{ss}}</span> against simulation-soundness of <span class="math">\\Pi</span> as follows. It receives <span class="math">\\mathsf{crs}\\longleftrightarrow\\mathsf{\\Pi.SimSetup}(\\lambda)</span> and has access to an oracle SimProve. It simulates Game_{7}, querying SimProve for simulating proofs for nonces <span class="math">R_{1}</span>. If the game stops at line (II), then <span class="math">\\mathcal{B}_{\\mathrm{ss}}</span> returns the corresponding tuple <span class="math">(U_{i},V,R_{i})</span>, otherwise it aborts. Since <span class="math">\\mathcal{B}_{\\mathrm{ss}}</span> wins game SS_{Π} exactly when Game_{6} returns true but Game_{7} does not, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{7}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)\\geq\\mathsf{Adv}^{\\mathsf{game}_{6}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)-\\mathsf{Adv}^{\\mathsf{ss}}_{\\Pi,\\mathcal{B}_{\\mathrm{ss}}}(\\lambda).</span></p>

    <p class="text-gray-300">Game_{8}. In Game_{8}, we compute the values <span class="math">R^{\\prime}_{2},\\ldots,R^{\\prime}_{n}</span> of the nonces that we expect to receive from the adversary. This allows to deduce the aggregate nonce <span class="math">\\widetilde{R}</span>, the value <span class="math">c:=\\mathrm{RO}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> and the partial signature <span class="math">s_{1}</span> before sending <span class="math">(R_{1},\\pi_{1})</span>. Since both Game_{7} and Game_{8} abort in case the adversary sends a nonce <span class="math">R_{i}\\neq R^{\\prime}_{i}</span>, the two games are identical and hence</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathsf{game}_{8}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda)=\\mathsf{Adv}^{\\mathsf{game}_{7}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Game}_{9}</span>. In <span class="math">\\mathsf{Game}_{9}</span>, we compute the partial signature <span class="math">s_{1}</span> without the signing key <span class="math">x_{1}</span> using the standard strategy to simulate Schnorr signatures in the ROM. Namely, we draw <span class="math">c</span> and <span class="math">s_{1}</span> randomly (storing <span class="math">(c,s_{1})</span> in place of <span class="math">r_{1}</span> in <span class="math">\\mathsf{T}_{\\mathrm{rand}}</span>), define <span class="math">R_{1}:=s_{1}G-c\\mu_{1}X_{1}</span>, and program <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m):=c</span>, unless <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> has already been defined. Clearly, <span class="math">\\mathsf{Game}_{8}</span> and <span class="math">\\mathsf{Game}_{9}</span> are identical unless <span class="math">\\mathsf{Game}_{9}</span> returns false at line (III). For each query <span class="math">\\mathrm{Sign}(\\mathbf{K},m)</span>, <span class="math">R_{1}</span> and hence <span class="math">\\widetilde{R}</span> is uniformly random in <span class="math">\\mathbb{G}</span> of size <span class="math">p\\geq 2^{\\lambda-1}</span>, hence this happens with probability at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{T}_{\\mathrm{sig}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{\\lambda-1}<span class="math">. Since the size of </span>\\mathsf{T}_{\\mathrm{sig}}<span class="math"> is upper bounded by </span>q_{\\mathrm{h}}+q_{\\mathrm{s}}<span class="math">, and since there are at most </span>q_{\\mathrm{s}}<span class="math"> calls to </span>\\mathrm{Sign}$, one has</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathsf{game}_{9}}(\\lambda)\\geq\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathsf{game}_{9}}(\\lambda)-\\frac{q_{\\mathrm{s}}(q_{\\mathrm{h}}+q_{\\mathrm{s}})}{2^{\\lambda-1}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Game}_{10}</span>. Our final game is <span class="math">\\mathsf{Game}_{10}</span>, where we exclude a bad event that would prevent the application of the Forking Lemma. Namely, for any multiset of keys <span class="math">\\mathbf{X}</span>, when a call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X},X)</span> first occurs for any <span class="math">X\\in\\mathbf{X}</span>, we randomly assign <span class="math">\\mathsf{T}_{\\mathrm{agg}}(\\mathbf{X},X^{\\prime})</span> for all <span class="math">X^{\\prime}\\in\\mathbf{X}</span> and compute the corresponding aggregate key. If it collides with a previous aggregate key or with the aggregate key of a non-<span class="math">\\bot</span> entry in <span class="math">\\mathsf{T}_{\\mathrm{sig}}</span>, the game abort and returns false. Clearly, <span class="math">\\mathsf{Game}_{9}</span> and <span class="math">\\mathsf{Game}_{10}</span> are identical unless <span class="math">\\mathsf{Game}_{10}</span> returns false at line (IV). Let us upper bound the probability that this happens. First, there are at most <span class="math">q_{\\mathrm{h}}+q_{\\mathrm{s}}+1</span> calls to <span class="math">\\mathrm{RO}_{\\mathrm{agg}}</span> that might cause the game to return false (each query to <span class="math">\\mathrm{Sign}</span> as well as the final call to <span class="math">\\mathsf{MS}</span>.Ver might incur up to <span class="math">N</span> calls to <span class="math">\\mathrm{RO}_{\\mathrm{agg}}</span>, but they are all for the same key set <span class="math">\\mathbf{X}</span>, hence only the first call can make the game return false). For each call, <span class="math">\\widetilde{X}</span> is uniformly random in <span class="math">\\mathbb{G}</span> of size <span class="math">p\\geq 2^{\\lambda-1}</span>, hence the game returns false with probability at most $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{AggKeys}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{T}_{\\mathrm{sig}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/2^{\\lambda-1}<span class="math">. Since the size of </span>\\mathsf{AggKeys}<span class="math"> and </span>\\mathsf{T}_{\\mathrm{sig}}<span class="math"> are both upper bounded by </span>q_{\\mathrm{h}}+q_{\\mathrm{s}}+1$, one obtains</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathsf{game}_{10}}(\\lambda)\\geq\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathsf{game}_{9}}(\\lambda)-\\frac{(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{2}}{2^{\\lambda-1}}.</span></p>

    <p class="text-gray-300">The Reduction to DL. Gathering all equations above yields</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathsf{game}_{10}}(\\lambda)\\geq\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathrm{euf}\\text{-}\\mathrm{cma}}(\\lambda)-\\delta</span> (6)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\delta:=\\mathsf{Adv}_{\\mathsf{KeyDer},\\mathcal{B}_{\\mathrm{prng}}}^{\\mathrm{prng}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{RandDer},\\mathcal{B}_{\\mathrm{prf}}}^{\\mathrm{prf}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{snd}}}^{\\mathrm{snd}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{zk}}}^{\\mathrm{zk}}(\\lambda)</span> <span class="math">+\\mathsf{Adv}_{\\mathsf{GrGen}^{\\prime},\\mathcal{B}_{\\mathrm{ddh}}}^{\\mathrm{ddh}}(\\lambda)+\\mathsf{Adv}_{\\mathsf{\\Pi},\\mathcal{B}_{\\mathrm{ss}}}^{\\mathrm{ss}}(\\lambda)+q_{\\mathrm{s}}\\varepsilon+\\frac{(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{2}}{2^{\\lambda-2}}.</span></p>

    <p class="text-gray-300">At this point, we are ready to construct an algorithm solving the DL problem for <span class="math">\\mathsf{GrGen}</span>. More precisely, we show that there exists an algorithm <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}_{\\mathsf{GrGen},\\mathcal{B}_{\\mathrm{dl}}}^{\\mathrm{dl}}(\\lambda)\\geq\\frac{\\left(\\mathsf{Adv}_{\\mathsf{MS},\\mathcal{A}}^{\\mathsf{game}_{10}}(\\lambda)\\right)^{4}}{(q_{\\mathrm{h}}+q_{\\mathrm{s}}+1)^{3}}-\\frac{3}{2^{\\lambda-1}}.</span> (7)</p>

    <p class="text-gray-300">The proof is very similar to the one for <span class="math">\\mathsf{MuSig}</span> <em>[x10]</em> and relies on a double application of the Forking Lemma <em>[x11]</em>. It is detailed in Appendix C.</p>

    <p class="text-gray-300">It is straightforward to check that all algorithms <span class="math">\\mathcal{B}_{\\mathrm{x}}</span> constructed during the proof are polynomial-time. Combining Eq. (6) and Eq. (7), one obtains the result. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6. Games Game0 to Game7 used in the proof of Theorem 1. Algorithm MS.Ver is as defined in Fig. 5. Changes are incremental (e.g., boxed statements apply to Game2 but also Game3, ..., Game7).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Oracle SIGN(K, m) (Game8)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Oracle SIGN(K, m) (Game9)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if (X1, U1)∉ K then return ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">if (X1, U1)∉ K then return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">{(X1, U1), ..., (Xn, Un)} := K</td>

            <td class="px-3 py-2 border-b border-gray-700">{(X1, U1), ..., (Xn, Un)} := K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">X := {X1, ..., Xn}</td>

            <td class="px-3 py-2 border-b border-gray-700">X := {X1, ..., Xn}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">μ1 := ROagg(X, X1)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ1 := ROagg(X, X1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">X := ∑i=1n ROagg(X, Xi)Xi</td>

            <td class="px-3 py-2 border-b border-gray-700">X := ∑i=1n ROagg(X, Xi)Xi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V := ROnon(K, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">V := ROnon(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">v := T′non(K, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">v := T′non(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Trand(K, m) = ⊥ then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Trand(K, m) = ⊥ then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trand(K, m) ←s Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">Trand(K, m) ←s (Fp)2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r1 := Trand(K, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">(c, s1) := Trand(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R1 := r1G</td>

            <td class="px-3 py-2 border-b border-gray-700">R1 := s1G - cμ1X1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Tρ(K, m) = ⊥ then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Tρ(K, m) = ⊥ then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tρ(K, m) ←s {0, 1}λ</td>

            <td class="px-3 py-2 border-b border-gray-700">Tρ(K, m) ←s {0, 1}λ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ρ := Tρ(K, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ := Tρ(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">π1 := Π.SimPrv(crs, τ, (U1, V, R1); ρ)</td>

            <td class="px-3 py-2 border-b border-gray-700">π1 := Π.SimPrv(crs, τ, (U1, V, R1); ρ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if π1 = ⊥ then return ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">if π1 = ⊥ then return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i = 2...n do</td>

            <td class="px-3 py-2 border-b border-gray-700">for i = 2...n do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Ui = U1 then R′i := R1</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ui = U1 then R′i := R1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">else R′i := f(vUi)G</td>

            <td class="px-3 py-2 border-b border-gray-700">else R′i := f(vUi)G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R := R1 + ∑i=2n R′i</td>

            <td class="px-3 py-2 border-b border-gray-700">R := R1 + ∑i=2n R′i</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  / inlining c := ROsig(X, R, m) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if Tsig(X, R, m) = ⊥ then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if Tsig(X, R, m) = ⊥ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  c ←s Fp |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tsig(X, R, m) := c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tsig(X, R, m) := c</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">send (R1, π1)</td>

            <td class="px-3 py-2 border-b border-gray-700">send (R1, π1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">receive ((R2, π2), ..., (Rn, πn))</td>

            <td class="px-3 py-2 border-b border-gray-700">receive ((R2, π2), ..., (Rn, πn))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for i = 2...n do</td>

            <td class="px-3 py-2 border-b border-gray-700">for i = 2...n do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Π.Ver(crs, (Ui, V, Ri), πi) = 0 then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Π.Ver(crs, (Ui, V, Ri), πi) = 0 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Ui = U1 ∧ Ri ≠ R1 then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ui = U1 ∧ Ri ≠ R1 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">abort game and return false</td>

            <td class="px-3 py-2 border-b border-gray-700">abort game and return false</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Ui ≠ U1 ∧ Ri ≠ f(vUi)G then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ui ≠ U1 ∧ Ri ≠ f(vUi)G then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">abort game and return false</td>

            <td class="px-3 py-2 border-b border-gray-700">abort game and return false</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q := Q</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(X, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">Q := Q</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(X, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return s1</td>

            <td class="px-3 py-2 border-b border-gray-700">return s1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 7. Games  <span class="math">\\mathsf{Game}_8</span>  and  <span class="math">\\mathsf{Game}_9</span>  used in the proof of Theorem 1. The main procedure and oracles  <span class="math">\\mathsf{RO}_{\\mathrm{agg}}</span> ,  <span class="math">\\mathsf{RO}_{\\mathrm{sig}}</span> , and  <span class="math">\\mathsf{RO}_{\\mathrm{non}}</span>  are as in  <span class="math">\\mathsf{Game}_7</span> . Changes from  <span class="math">\\mathsf{Game}_7</span>  to  <span class="math">\\mathsf{Game}_8</span>  and from  <span class="math">\\mathsf{Game}_8</span>  to  <span class="math">\\mathsf{Game}_9</span>  are highlighted.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Oracle SIGN(K,m)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(p, G, G) ← GrGen(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">if (X1, U1)∉K then return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(q, E, P, f) ← GrGen'(p)</td>

            <td class="px-3 py-2 border-b border-gray-700">{(X1, U1), ..., (Xn, Un)} := K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(crs, τ) ← Π.SimSetup(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">X := {X1, ..., Xn}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">par := (p, G, G, q, E, P, f, crs)</td>

            <td class="px-3 py-2 border-b border-gray-700">μ1 := ROagg(X, X1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x1 ←<span class="math"> Fp; u1 ←</span> Zq; k ←$ {0,1}λ</td>

            <td class="px-3 py-2 border-b border-gray-700">X := ∑i=1n ROagg(X, Xi)Xi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">X1 := x1G; U1 := u1P</td>

            <td class="px-3 py-2 border-b border-gray-700">V := ROnon(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Q := (); AggKeys := ()</td>

            <td class="px-3 py-2 border-b border-gray-700">v := T'non(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tagg, Tsig, Tnon := () // tables for simulating ROs</td>

            <td class="px-3 py-2 border-b border-gray-700">if Trand(K, m) = ⊥ then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trand, T'non, Tρ := ()</td>

            <td class="px-3 py-2 border-b border-gray-700">Trand(K, m) ← $ (Fp)2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(X, m, σ) ← A SIGN, RΩ (par, X1, U1)</td>

            <td class="px-3 py-2 border-b border-gray-700">(c, s1) := Trand(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return X1 ∈ X ∧ (X, m)∉Q ∧ MS.Ver(par, X, m, σ) = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">R1 := s1G - cμ1X1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Oracle ROagg(X, X) // X, X1 ∈ X by assumption</td>

            <td class="px-3 py-2 border-b border-gray-700">if Tρ(K, m) = ⊥ then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Tagg(X, X) = ⊥ then</td>

            <td class="px-3 py-2 border-b border-gray-700">Tρ(K, m) ← $ {0,1}λ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">for X' ∈ X \\ {X1} do Tagg(X, X') ←$ Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ := Tρ(K, m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tagg(X, X1) ←$ Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">π1 := Π.SimPrv(crs, τ, (U1, V, R1); ρ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">{X1, ..., Xn} := X</td>

            <td class="px-3 py-2 border-b border-gray-700">if π1 = ⊥ then return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">X := ∑i=1n ROagg(X, Xi)Xi</td>

            <td class="px-3 py-2 border-b border-gray-700">for i = 2...n do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if X ∈ AggKeys ∨ ∃(R, m): Tsig(X, R, m) ≠ ⊥ then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ui = U1 then R' := R1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">abort game and return false (IV)</td>

            <td class="px-3 py-2 border-b border-gray-700">else R' := f(vUi)G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AggKeys := AggKeys</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">R := R1 + ∑i=2n R'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return Tagg(X, X)</td>

            <td class="px-3 py-2 border-b border-gray-700">if Tsig(X, R, m) = ⊥ then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Oracle ROsig(X, R, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">Tsig(X, R, m) := c</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Tsig(X, R, m) = ⊥ then</td>

            <td class="px-3 py-2 border-b border-gray-700">else abort game and return false</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tsig(X, R, m) ←$ Fp</td>

            <td class="px-3 py-2 border-b border-gray-700">send (R1, π1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return Tsig(X, R, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">receive ((R2, π2), ..., (Rn, πn))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Oracle ROnon(K, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">for i = 2...n do</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if Tnon(K, m) = ⊥ then</td>

            <td class="px-3 py-2 border-b border-gray-700">if Π.Ver(crs, (Ui, V, Ri), πi) = 0 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T'non(K, m) ←$ Zq</td>

            <td class="px-3 py-2 border-b border-gray-700">return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tnon(K, m) := T'non(K, m)P</td>

            <td class="px-3 py-2 border-b border-gray-700">if Ui = U1 ∧ Ri ≠ R1 then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return Tnon(K, m)</td>

            <td class="px-3 py-2 border-b border-gray-700">abort game and return false</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | if Ui ≠ U1 ∧ Ri ≠ f(vUi)G then  |</p>

    <p class="text-gray-300">|   | abort game and return false  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q := Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(X, m)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | return s1  |</p>

    <p class="text-gray-300">Fig. 8. Game  <span class="math">\\mathsf{Game}_{10}</span>  used in the proof of Theorem 1. Changes from  <span class="math">\\mathsf{Game}_9</span>  to  <span class="math">\\mathsf{Game}_{10}</span>  are highlighted.</p>

    <p class="text-gray-300">The construction of  <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span>  relies on a generalization of the Forking Lemma [PS00] due to Bellare and Neven [BN06] that we recall below. Here we state a variant which is slightly adapted to our setting: it allows for an arbitrary set  <span class="math">S</span>  as range of the random oracle (instead of a set of fixed-length bitstrings).</p>

    <p class="text-gray-300">Lemma 3 (Generalized Forking Lemma [BN06]). Fix an integer  <span class="math">q</span> . Let  <span class="math">\\mathcal{V}</span>  be a randomized algorithm which takes as input some main input inp and elements  <span class="math">h_1, \\ldots, h_q</span>  in some finite set  <span class="math">S</span>  and returns either a distinguished failure symbol  <span class="math">\\bot</span>  or a pair  <span class="math">(i, \\text{out})</span> , where  <span class="math">i \\in \\{1, \\ldots, q\\}</span>  and out is some side output. The accepting probability of  <span class="math">\\mathcal{V}</span> , denoted  <span class="math">\\text{acc}(\\mathcal{V})</span> , is defined as the probability, over the random draw of inp (according to some well-understood distribution),  <span class="math">h_1, \\ldots, h_q \\gets sS</span> , and the random coins of  <span class="math">\\mathcal{V}</span> , that  <span class="math">\\mathcal{V}</span>  returns a non-  <span class="math">\\bot</span>  output. Consider algorithm  <span class="math">\\text{Fork}^{\\mathcal{V}}</span> , taking as input inp, described on Fig. 9. Let  <span class="math">\\text{frk}</span>  be the probability (over the draw of inp and the random coins of  <span class="math">\\text{Fork}^{\\mathcal{V}}</span> ) that  <span class="math">\\text{Fork}^{\\mathcal{V}}</span>  returns a non-  <span class="math">\\bot</span>  output. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {f r k} \\geq \\operatorname {a c c} (\\mathcal {V}) \\left(\\frac {\\operatorname {a c c} (\\mathcal {V})}{q} - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let  <span class="math">q \\coloneqq q_{\\mathrm{h}} + q_{\\mathrm{s}} + 1</span> . In order to construct  <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span>  we define two wrapper algorithms  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{W}</span>  to which we will successively apply the forking lemma.</p>

    <p class="text-gray-300">ALGORITHM  <span class="math">\\mathcal{V}</span> . The first algorithm  <span class="math">\\mathcal{V}</span>  is defined in Fig. 10. It takes as input a main input  <span class="math">\\mathsf{inp}_{\\mathcal{V}} = (p, \\mathbb{G}, G, X^{<em>}, h_{\\mathrm{agg},1}, \\ldots, h_{\\mathrm{agg},q})</span>  and  <span class="math">h_{\\mathrm{sig},1}, \\ldots, h_{\\mathrm{sig},q}</span> , where  <span class="math">(p, \\mathbb{G}, G)</span>  is a group description,  <span class="math">X^{</em>} \\in \\mathbb{G}</span>  is a uniformly random group element, and  <span class="math">h_{\\mathrm{agg},1}, \\ldots, h_{\\mathrm{agg},q}</span>  as well as  <span class="math">h_{\\mathrm{sig},1}, \\ldots, h_{\\mathrm{sig},q}</span>  are uniformly random elements of  <span class="math">S = \\mathbb{F}_p</span>  and simply runs  <span class="math">\\mathsf{Game}_{10}^{\\mathcal{A}}</span>  (cf. Fig. 8), except it sets  <span class="math">X_1 := X^*</span>  and uses  <span class="math">h_{\\mathrm{agg},j}</span>  for the  <span class="math">j</span> -th assignment in  <span class="math">\\mathsf{T}_{\\mathrm{agg}}</span>  for inputs of the form  <span class="math">(\\mathbf{X}, X_1)</span>  and  <span class="math">h_{\\mathrm{sig},j}</span>  for the  <span class="math">j</span> -th assignment in  <span class="math">\\mathsf{T}_{\\mathrm{sig}}</span> . If the game returns false then  <span class="math">\\mathcal{V}</span>  returns  <span class="math">\\bot</span> . Otherwise, let  <span class="math">(\\mathbf{X}, m, \\widehat{R}, s)</span>  be the output of  <span class="math">\\mathcal{A}</span>  in the game, and let  <span class="math">\\{X_1, \\ldots, X_n\\} := \\mathbf{X}</span> ,  <span class="math">\\mu_i := \\mathsf{T}_{\\mathrm{agg}}(\\mathbf{X}, X_i)</span>  for  <span class="math">1 \\leq i \\leq n</span> ,  <span class="math">\\pmb{\\mu} := (\\mu_1, \\ldots, \\mu_n)</span> , and  <span class="math">\\widehat{X} := \\sum_{i=1}^{n} \\mu_i X_i</span> . Let also  <span class="math">\\hat{\\jmath}_{\\mathrm{a}}</span>  and  <span class="math">\\hat{\\jmath}_{\\mathrm{s}}</span>  be the indexes such that assignments  <span class="math">\\mathsf{T}_{\\mathrm{agg}}(\\mathbf{X}, X_1) := h_{\\mathrm{agg}, \\hat{\\jmath}_{\\mathrm{a}}}</span>  and  <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widehat{X}, \\widehat{R}, m) := h_{\\mathrm{sig}, \\hat{\\jmath}_{\\mathrm{s}}}</span>  occurred. Note that the execution of MS.Ver at the end of the game ensures that  <span class="math">\\pmb{\\mu}</span> ,  <span class="math">\\hat{\\jmath}_{\\mathrm{a}}</span> , and  <span class="math">\\hat{\\jmath}_{\\mathrm{s}}</span>  are well-defined. Then</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 9. The "forking" algorithm  <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span>  built from  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">|  Algorithm V(p, G, G, X*, hagg, 1, ..., hagg, q, hsig, 1, ..., hsig, q)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  (q, E, P, f) ← GrGen'(p, G, G); (crs, τ) ← Π.SimSetup(1λ)  |</p>

    <p class="text-gray-300">|  par := (p, G, G, q, E, P, f, crs)  |</p>

    <p class="text-gray-300">|  X1 := X*; u1 ←$ Zq; U1 := u1P  |</p>

    <p class="text-gray-300">|  Q := (); AggKeys := ()  |</p>

    <p class="text-gray-300">|  Tagg, Tsig, Tnon, Trand, T'non, Tρ := ()  |</p>

    <p class="text-gray-300">|  ja := 0; js := 0 // counters for assignments in Tagg and Tsig  |</p>

    <p class="text-gray-300">|  Indagg := (); Indsig := () // tables for storing indexes  |</p>

    <p class="text-gray-300">|  (X, m, (R, s)) ← A SIGN, R0 (par, X1, U1)  |</p>

    <p class="text-gray-300">|  if X1 ∈ X ∧ (X, m)∉ Q ∧ MS.Ver(par, X, m, (R, s)) = 1 then  |</p>

    <p class="text-gray-300">|  {X1, ..., Xn} := X  |</p>

    <p class="text-gray-300">|  for i = 1...n do μi := Tagg(X, Xi)  |</p>

    <p class="text-gray-300">|  μ := (μ1, ..., μn); X := ∑i=1n μiXi  |</p>

    <p class="text-gray-300">|  ja := Indagg(X, X1); js := Indsig(X, R, m)  |</p>

    <p class="text-gray-300">|  out := (hsig, js, ja, X, μ, R, s)  |</p>

    <p class="text-gray-300">|  return (js, out)  |</p>

    <p class="text-gray-300">|  else return ⊥  |</p>

    <p class="text-gray-300">|  Oracle ROagg(X, X) // X, X1 ∈ X by assumption  |</p>

    <p class="text-gray-300">|  if Tagg(X, X) = ⊥ then  |</p>

    <p class="text-gray-300">|  for X' ∈ X \\ {X1} do Tagg(X, X') ←$ Fp  |</p>

    <p class="text-gray-300">|  ja := ja + 1  |</p>

    <p class="text-gray-300">|  Tagg(X, X1) := hagg, ja  |</p>

    <p class="text-gray-300">|  Indagg(X, X1) := ja  |</p>

    <p class="text-gray-300">|  {X1, ..., Xn} := X  |</p>

    <p class="text-gray-300">|  X := ∑i=1n ROagg(X, Xi)Xi  |</p>

    <p class="text-gray-300">|  if X ∈ AggKeys ∨ ∃(R, m): Tagg(X, R, m) ≠ ⊥ then  |</p>

    <p class="text-gray-300">|  abort algorithm and return ⊥  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AggKeys := AggKeys</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  return Tagg(X, X)  |</p>

    <p class="text-gray-300">|  Oracle ROsig(X, R, m)  |</p>

    <p class="text-gray-300">|  if Tagg(X, R, m) = ⊥ then  |</p>

    <p class="text-gray-300">|  js := js + 1  |</p>

    <p class="text-gray-300">|  Tagg(X, R, m) := hsig, js  |</p>

    <p class="text-gray-300">|  Indsig(X, R, m) := js  |</p>

    <p class="text-gray-300">|  return Tagg(X, R, m)  |</p>

    <p class="text-gray-300">Oracle SIGN(K, m)</p>

    <p class="text-gray-300">if  <span class="math">(X_{1},U_{1})\\notin \\mathbf{K}</span>  then return  <span class="math">\\perp</span></p>

    <p class="text-gray-300"><span class="math">\\{(X_1,U_1),\\ldots ,(X_n,U_n)\\} \\coloneqq \\mathbf{K}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}:= \\{X_1,\\dots ,X_n\\}</span></p>

    <p class="text-gray-300"><span class="math">\\mu_{1}\\coloneqq \\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X},X_{1})</span></p>

    <p class="text-gray-300"><span class="math">\\widetilde{X} \\coloneqq \\sum_{i=1}^{n} \\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X}, X_i) X_i</span></p>

    <p class="text-gray-300"><span class="math">V\\coloneqq \\mathrm{RO}_{\\mathrm{non}}(\\mathbf{K},m)</span></p>

    <p class="text-gray-300"><span class="math">v\\coloneqq \\mathsf{T}_{\\mathrm{non}}^{\\prime}(\\mathbf{K},m)</span></p>

    <p class="text-gray-300">if  <span class="math">\\mathsf{T}_{\\mathrm{rand}}(\\mathbf{K},m) = \\bot</span>  then</p>

    <p class="text-gray-300"><span class="math">j_{\\mathrm{s}}\\coloneqq j_{\\mathrm{s}} + 1</span></p>

    <p class="text-gray-300"><span class="math">c\\coloneqq h_{\\mathrm{sig},j_{\\mathrm{s}}};\\quad s_1\\gets \\mathbb{F}_p</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{T}_{\\mathrm{rand}}(\\mathbf{K},m)\\coloneqq (c,s_1)</span></p>

    <p class="text-gray-300"><span class="math">(c,s_1)\\coloneqq \\mathsf{T}_{\\mathrm{rand}}(\\mathbf{K},m)</span></p>

    <p class="text-gray-300"><span class="math">R_{1}\\coloneqq s_{1}G - c\\mu_{1}X_{1}</span></p>

    <p class="text-gray-300"><span class="math">\\pi_1\\coloneqq \\Pi .\\mathrm{SimPrv}(\\mathrm{crs},\\tau ,(U_1,V,R_1);\\rho)</span></p>

    <p class="text-gray-300">if  <span class="math">\\pi_1 = \\bot</span>  then return  <span class="math">\\bot</span></p>

    <p class="text-gray-300">for  <span class="math">i = 2\\dots n</span>  do</p>

    <p class="text-gray-300">if  <span class="math">U_{i} = U_{1}</span>  then  <span class="math">R_{i}^{\\prime} \\coloneqq R_{1}</span></p>

    <p class="text-gray-300">else  <span class="math">R_{i}^{\\prime}\\coloneqq f(vU_{i})G</span></p>

    <p class="text-gray-300"><span class="math">\\widetilde{R} \\coloneqq R_1 + \\sum_{i=2}^{n} R_i&#x27;</span></p>

    <p class="text-gray-300">if  <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m) = \\bot</span>  then</p>

    <p class="text-gray-300"><span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)\\coloneqq c</span></p>

    <p class="text-gray-300"><span class="math">\\operatorname{Ind}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)\\coloneqq j_{\\mathrm{s}}</span></p>

    <p class="text-gray-300">else abort algorithm and return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">send  <span class="math">(R_{1},\\pi_{1})</span></p>

    <p class="text-gray-300">receive  <span class="math">((R_2,\\pi_2),\\ldots ,(R_n,\\pi_n))</span></p>

    <p class="text-gray-300">for  <span class="math">i = 2\\dots n</span>  do</p>

    <p class="text-gray-300">if  <span class="math">\\Pi .\\mathrm{Ver}(\\mathrm{crs},(U_i,V,R_i),\\pi_i) = 0</span>  then return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">if  <span class="math">U_{i} = U_{1}\\wedge R_{i}\\neq R_{1}</span>  then</p>

    <p class="text-gray-300">abort algorithm and return  <span class="math">\\perp</span></p>

    <p class="text-gray-300">if  <span class="math">U_{i}\\neq U_{1}\\wedge R_{i}\\neq f(vU_{i})G</span>  then</p>

    <p class="text-gray-300">abort algorithm and return  <span class="math">\\perp</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{Q} \\coloneqq \\mathbf{Q} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{X}, m)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">return  <span class="math">s_1</span></p>

    <p class="text-gray-300">Fig. 10. Wrapper algorithm  <span class="math">\\mathcal{V}</span> . Changes to Game <span class="math">_{10}</span>  are highlighted.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> returns <span class="math">(\\mathfrak{j}_{\\mathrm{s}},\\mathsf{out}_{\\mathcal{V}})</span> where <span class="math">\\mathsf{out}_{\\mathcal{V}}=(h_{\\mathrm{sig},\\mathfrak{j}_{\\mathrm{s}}},\\mathfrak{j}_{\\mathrm{a}},\\mathbf{X},\\boldsymbol{\\mu},\\widetilde{R},s)</span>. Clearly, the accepting probability of <span class="math">\\mathcal{V}</span> (as defined in Lemma 3) is</p>

    <p class="text-gray-300"><span class="math">\\mathsf{acc}(\\mathcal{V})=\\mathsf{Adv}^{\\mathsf{game}_{10}}_{\\mathsf{MS},\\mathcal{A}}(\\lambda).</span> (8)</p>

    <p class="text-gray-300">Before defining the second algorithm <span class="math">\\mathcal{W}</span>, we prove a number of properties of <span class="math">\\mathcal{V}</span> and <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Consider a successful (i.e., not returning <span class="math">\\bot</span>) execution</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{j}_{\\mathrm{s}},(h_{\\mathrm{sig}},\\mathfrak{j}_{\\mathrm{a}},\\mathbf{X},\\boldsymbol{\\mu},\\widetilde{R},s))\\leftarrow\\mathcal{V}(p,\\mathbb{G},G,X^{*},h_{\\mathrm{agg},1},\\ldots,h_{\\mathrm{agg},q},h_{\\mathrm{sig},1},\\ldots,h_{\\mathrm{sig},q})</span></p>

    <p class="text-gray-300">and let <span class="math">\\{X_{1},\\ldots,X_{n}\\}:=\\mathbf{X}</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{n}):=\\boldsymbol{\\mu}</span>, and <span class="math">\\widetilde{X}:=\\sum_{i=1}^{n}\\mu_{i}X_{i}</span>. Then the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">X^{*}\\in\\mathbf{X}</span>;</li>

      <li><span class="math">\\mu_{i}=h_{\\mathrm{agg},\\mathfrak{j}_{\\mathrm{a}}}</span> for any <span class="math">i</span> such that <span class="math">X_{i}=X^{*}</span>;</li>

      <li><span class="math">sG=\\widetilde{R}+h_{\\mathrm{sig}}\\widetilde{X}</span>.</li>

    </ol>

    <p class="text-gray-300">Moreover, consider a successful execution</p>

    <p class="text-gray-300"><span class="math">((h_{\\mathrm{sig}},\\mathfrak{j}_{\\mathrm{a}},\\mathbf{X},\\boldsymbol{\\mu},\\widetilde{R},s),(h_{\\mathrm{sig}}^{\\prime},\\mathfrak{j}_{\\mathrm{a}}^{\\prime},\\mathbf{X}^{\\prime},\\boldsymbol{\\mu}^{\\prime},\\widetilde{R}^{\\prime},s^{\\prime}))\\leftarrow\\mathsf{Fork}^{\\mathcal{V}}(p,\\mathbb{G},G,X^{*},h_{\\mathrm{agg},1},\\ldots,h_{\\mathrm{agg},q}).</span></p>

    <p class="text-gray-300">Then one has</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{\\mathrm{sig}}\\neq h_{\\mathrm{sig}}^{\\prime}</span>;</li>

      <li><span class="math">\\mathfrak{j}_{\\mathrm{a}}=\\mathfrak{j}_{\\mathrm{a}}^{\\prime}</span>, <span class="math">\\mathbf{X}=\\mathbf{X}^{\\prime}</span>, <span class="math">\\boldsymbol{\\mu}=\\boldsymbol{\\mu}^{\\prime}</span>, and <span class="math">\\widetilde{R}=\\widetilde{R}^{\\prime}</span>.</li>

    </ol>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Property (i) follows from the fact that <span class="math">\\mathcal{V}</span> returns <span class="math">\\bot</span> in case <span class="math">X_{1}=X^{*}\\notin\\mathbf{X}</span>. Property (ii) follows easily by inspection of the code of Fig. 10. Property (iii) simply expresses the validity of the forgery returned by <span class="math">\\mathcal{A}</span> (as <span class="math">\\mathcal{V}</span> returns <span class="math">\\bot</span> if the forgery is invalid). Property (iv) follows directly from the definition of <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span> as it returns <span class="math">\\bot</span> if <span class="math">h_{\\mathrm{sig},\\mathfrak{j}_{\\mathrm{s}}}=h_{\\mathrm{sig},\\mathfrak{j}_{\\mathrm{s}}}^{\\prime}</span>.</p>

    <p class="text-gray-300">It remains to prove property (v). Consider the first execution of <span class="math">\\mathcal{V}</span> run by <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{j}_{\\mathrm{s}},(h_{\\mathrm{sig}},\\mathfrak{j}_{\\mathrm{a}},\\mathbf{X},\\boldsymbol{\\mu},\\widetilde{R},s))\\leftarrow\\mathcal{V}(p,\\mathbb{G},G,X^{*},h_{\\mathrm{agg},1},\\ldots,h_{\\mathrm{agg},q},h_{\\mathrm{sig},1},\\ldots,h_{\\mathrm{sig},q};\\rho_{\\mathcal{V}})</span></p>

    <p class="text-gray-300">and let <span class="math">\\{X_{1},\\ldots,X_{n}\\}:=\\mathbf{X}</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{n}):=\\boldsymbol{\\mu}</span>, and <span class="math">\\widetilde{X}:=\\sum_{i=1}^{n}\\mu_{i}X_{i}</span>. Let also <span class="math">m</span> be the message for which <span class="math">\\mathcal{A}</span> returned its forgery (i.e., <span class="math">\\mathcal{A}</span>’s output was <span class="math">(\\mathbf{X},m,\\widetilde{R},s)</span>). We first show that <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> was necessarily assigned during a call to <span class="math">\\mathrm{RO}_{\\mathrm{sig}}</span>. Note that <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> can only be assigned during a call to <span class="math">\\mathrm{RO}_{\\mathrm{sig}}</span> or a call to Sign. Assume towards contradiction that it is during a call <span class="math">\\mathrm{Sign}(\\hat{\\mathbf{K}},m)</span>, and let <span class="math">\\hat{\\mathbf{X}}</span> be the multiset of verification keys corresponding to <span class="math">\\hat{\\mathbf{K}}</span>. We distinguish two cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\hat{\\mathbf{X}}=\\mathbf{X}</span>, then <span class="math">(\\mathbf{X},m)</span> would be appended to <span class="math">\\mathsf{Q}</span> at the end of the execution of Sign and consequently <span class="math">\\mathcal{V}</span> would return <span class="math">\\bot</span> after <span class="math">\\mathcal{A}</span> returns its forgery.</li>

      <li>If <span class="math">\\hat{\\mathbf{X}}\\neq\\mathbf{X}</span>, then, since the aggregate keys corresponding to <span class="math">\\mathbf{X}</span> and <span class="math">\\hat{\\mathbf{X}}</span> are both equal to <span class="math">\\widetilde{X}</span> (for <span class="math">\\hat{\\mathbf{X}}</span> this follows from the assumption that <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> was assigned during the call <span class="math">\\mathrm{Sign}(\\hat{\\mathbf{K}},m)</span>), necessarily <span class="math">\\mathcal{V}</span> would abort and return <span class="math">\\bot</span> during either the first call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X},\\cdot)</span> (which occurs at the latest during the final call to <span class="math">\\mathsf{MS.Ver}</span>) or the first call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\hat{\\mathbf{X}},\\cdot)</span> (which occurs at the latest during the call to <span class="math">\\mathrm{Sign}(\\hat{\\mathbf{K}},m)</span>).</li>

    </ol>

    <p class="text-gray-300">In both cases we reach a contradiction, which proves the claim.</p>

    <p class="text-gray-300">Consider now the second execution of <span class="math">\\mathcal{V}</span> run by <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\hat{\\jmath}_{\\mathrm{s}},(h^{\\prime}_{\\mathrm{sig}},\\hat{\\jmath}^{\\prime}_{\\mathrm{a}},\\mathbf{X}^{\\prime},\\bm{\\mu}^{\\prime},\\widetilde{R}^{\\prime},s^{\\prime}))</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\leftarrow\\mathcal{V}(p,\\mathbb{G},G,X^{*},h_{\\mathrm{agg},1},\\dots,h_{\\mathrm{agg},q},h_{\\mathrm{sig},1},\\dots,h_{\\mathrm{sig},\\hat{\\jmath}_{\\mathrm{s}}-1},h^{\\prime}_{\\mathrm{sig},\\hat{\\jmath}_{\\mathrm{s}}},\\dots,h^{\\prime}_{\\mathrm{sig},q};\\rho_{\\mathcal{V}})</span></p>

    <p class="text-gray-300">and let <span class="math">\\{X^{\\prime}_{1},\\dots,X^{\\prime}_{n}\\}:=\\mathbf{X}^{\\prime}</span>, <span class="math">(\\mu^{\\prime}_{1},\\dots,\\mu^{\\prime}_{n}):=\\bm{\\mu}^{\\prime}</span>, and <span class="math">\\widetilde{X}^{\\prime}:=\\sum_{i=1}^{n}\\mu^{\\prime}_{i}X^{\\prime}_{i}</span>. By inspection, the two executions are identical up to the <span class="math">\\hat{\\jmath}_{\\mathrm{s}}</span>-th assignment in <span class="math">\\mathsf{T}_{\\mathrm{sig}}</span>; by definition of <span class="math">\\hat{\\jmath}_{\\mathrm{s}}</span>, it is <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m):=h_{\\mathrm{sig},\\hat{\\jmath}_{\\mathrm{s}}}(=h_{\\mathrm{sig}})</span> in the first execution and <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X}^{\\prime},\\widetilde{R}^{\\prime},m^{\\prime}):=h^{\\prime}_{\\mathrm{sig},\\hat{\\jmath}_{\\mathrm{s}}}(=h^{\\prime}_{\\mathrm{sig}})</span> in the second execution, where <span class="math">m^{\\prime}</span> is the message for which <span class="math">\\mathcal{A}</span> returns its forgery in the second execution. Moreover, by the claim above this assignment occurs during a call <span class="math">\\mathrm{RO}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span> in the first execution, resp. <span class="math">\\mathrm{RO}_{\\mathrm{sig}}(\\widetilde{X}^{\\prime},\\widetilde{R}^{\\prime},m^{\\prime})</span> in the second execution. This implies that the arguments of the two calls are equal, which implies in particular that <span class="math">\\widetilde{R}=\\widetilde{R}^{\\prime}</span> and <span class="math">\\widetilde{X}=\\widetilde{X}^{\\prime}</span>.</p>

    <p class="text-gray-300">Before proving other equalities, we show that in both executions, there is necessarily a call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X},\\cdot)</span> and a call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X}^{\\prime},\\cdot)</span> before the call <span class="math">\\mathrm{RO}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span>. Indeed, if this were not the case, then necessarily <span class="math">\\mathcal{V}</span> would abort and return <span class="math">\\perp</span> in the first (resp., second) execution during the first call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X},\\cdot)</span> (resp., <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X}^{\\prime},\\cdot)</span>) (which occurs at the latest during the final call to MS.Ver) since <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)\\neq\\perp</span> at this moment.</p>

    <p class="text-gray-300">This in turns implies that <span class="math">\\mathbf{X}=\\mathbf{X}^{\\prime}</span>. Indeed, assume that <span class="math">\\mathbf{X}\\neq\\mathbf{X}^{\\prime}</span>. Since the aggregate keys corresponding to <span class="math">\\mathbf{X}</span> and <span class="math">\\mathbf{X}^{\\prime}</span> are both equal to <span class="math">\\widetilde{X}</span>, necessarily <span class="math">\\mathcal{V}</span> would abort and return <span class="math">\\perp</span> in both executions during the first call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X},\\cdot)</span> or the first call <span class="math">\\mathrm{RO}_{\\mathrm{agg}}(\\mathbf{X}^{\\prime},\\cdot)</span>, depending on which occurs first, since <span class="math">\\widetilde{X}\\in\\mathsf{AggKeys}</span>: a contradiction.</p>

    <p class="text-gray-300">Finally, this also implies that <span class="math">\\hat{\\jmath}_{\\mathrm{a}}=\\hat{\\jmath}^{\\prime}_{\\mathrm{a}}</span> and <span class="math">\\bm{\\mu}=\\bm{\\mu}^{\\prime}</span> since both executions are identical until the assignment of <span class="math">\\mathsf{T}_{\\mathrm{sig}}(\\widetilde{X},\\widetilde{R},m)</span>. ∎</p>

    <p class="text-gray-300">Algorithm <span class="math">\\mathcal{W}</span>. From <span class="math">\\mathcal{V}</span>, we define a second algorithm <span class="math">\\mathcal{W}</span> as follows. It takes as main input <span class="math">\\mathsf{inp}_{\\mathcal{W}}=(p,\\mathbb{G},G,X^{<em>})</span> and uniformly random elements <span class="math">h_{\\mathrm{agg},1},\\dots,h_{\\mathrm{agg},q}</span> of <span class="math">S=\\mathbb{F}_{p}</span> and runs <span class="math">\\mathsf{Fork}^{\\mathcal{V}}(p,\\mathbb{G},G,X^{</em>},h_{\\mathrm{agg},1},\\dots,h_{\\mathrm{agg},q})</span>. If <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span> returns <span class="math">\\perp</span> then <span class="math">\\mathcal{W}</span> returns <span class="math">\\perp</span> as well. Otherwise, let the output of <span class="math">\\mathsf{Fork}^{\\mathcal{V}}</span> be <span class="math">((h_{\\mathrm{sig}},\\hat{\\jmath}_{\\mathrm{a}},\\mathbf{X},\\bm{\\mu},\\widetilde{R},s),(h^{\\prime}_{\\mathrm{sig}},\\hat{\\jmath}_{\\mathrm{a}},\\mathbf{X},\\bm{\\mu},\\widetilde{R},s^{\\prime}))</span>, where we used Lemma 4 (v) to equate elements of the two outputs of <span class="math">\\mathcal{V}</span>, and let <span class="math">\\{X_{1},\\dots,X_{n}\\}:=\\mathbf{X}</span>, <span class="math">(\\mu_{1},\\dots,\\mu_{n}):=\\bm{\\mu}</span>, and <span class="math">\\widetilde{X}:=\\sum_{i=1}^{n}\\mu_{i}X_{i}</span>. By Lemma 4 (iii), one has</p>

    <p class="text-gray-300"><span class="math">sG=\\widetilde{R}+h_{\\mathrm{sig}}\\widetilde{X}\\quad\\text{and}\\quad s^{\\prime}G=\\widetilde{R}+h^{\\prime}_{\\mathrm{sig}}\\widetilde{X}</span></p>

    <p class="text-gray-300">with <span class="math">h_{\\mathrm{sig}}\\neq h^{\\prime}_{\\mathrm{sig}}</span> by Lemma 4 (iv). Hence, <span class="math">\\mathcal{W}</span> can compute the discrete logarithm <span class="math">\\tilde{x}</span> of <span class="math">\\widetilde{X}</span> as</p>

    <p class="text-gray-300"><span class="math">\\tilde{x}:=(s-s^{\\prime})(h_{\\mathrm{sig}}-h^{\\prime}_{\\mathrm{sig}})^{-1}\\bmod p.</span></p>

    <p class="text-gray-300">Then <span class="math">\\mathcal{W}</span> returns <span class="math">(\\hat{\\jmath}_{\\mathrm{a}},\\mathsf{out}_{\\mathcal{W}})</span> where <span class="math">\\mathsf{out}_{\\mathcal{W}}=(h_{\\mathrm{agg},\\hat{\\jmath}_{\\mathrm{a}}},\\mathbf{X},\\bm{\\mu},\\tilde{x})</span>.</p>

    <p class="text-gray-300">By Lemma 3 with <span class="math">S=\\mathbb{F}_{p}</span>, the accepting probability of <span class="math">\\mathcal{W}</span> satisfies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{acc}(\\mathcal{W})\\geq\\frac{\\mathsf{acc}(\\mathcal{V})^{2}}{q}-\\frac{\\mathsf{acc}(\\mathcal{V})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\geq\\frac{\\mathsf{acc}(\\mathcal{V})^{2}}{q}-\\frac{1}{2^{\\lambda-1}}.$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for <span class="math">\\mathcal{V}</span>, we prove a number of properties regarding <span class="math">\\mathcal{W}</span> and <span class="math">\\mathsf{Fork}^{\\mathcal{W}}</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Consider a successful execution</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{j}_{\\mathrm{a}},(h_{\\mathrm{agg}},\\mathbf{X},\\bm{\\mu},\\tilde{x}))\\leftarrow\\mathcal{W}(p,\\mathbb{G},G,X^{*},h_{\\mathrm{agg},1},\\ldots,h_{\\mathrm{agg},q})</span></p>

    <p class="text-gray-300">and let <span class="math">\\{X_{1},\\ldots,X_{n}\\}:=\\mathbf{X}</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{n}):=\\bm{\\mu}</span>, and <span class="math">\\widetilde{X}:=\\sum_{i=1}^{n}\\mu_{i}X_{i}</span>. Then the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">X^{*}\\in\\mathbf{X}</span>;</li>

      <li><span class="math">\\mu_{i}=h_{\\mathrm{agg}}</span> for any <span class="math">i</span> such that <span class="math">X_{i}=X^{*}</span>;</li>

      <li><span class="math">\\widetilde{X}=\\tilde{x}G</span>.</li>

    </ol>

    <p class="text-gray-300">Moreover, consider a successful execution</p>

    <p class="text-gray-300"><span class="math">((h_{\\mathrm{agg}},\\mathbf{X},\\bm{\\mu},\\tilde{x}),(h_{\\mathrm{agg}}^{\\prime},\\mathbf{X}^{\\prime},\\bm{\\mu}^{\\prime},\\tilde{x}^{\\prime}))\\leftarrow\\mathsf{For}\\mathsf{k}^{\\mathcal{W}}(p,\\mathbb{G},G,X^{*})</span></p>

    <p class="text-gray-300">and let <span class="math">\\{X_{1},\\ldots,X_{n}\\}:=\\mathbf{X}</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{n}):=\\bm{\\mu}</span>, and <span class="math">(\\mu_{1}^{\\prime},\\ldots,\\mu_{n^{\\prime}}^{\\prime}):=\\bm{\\mu}^{\\prime}</span>. Then one has</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">h_{\\mathrm{agg}}\\neq h_{\\mathrm{agg}}^{\\prime}</span>;</li>

      <li><span class="math">\\mathbf{X}=\\mathbf{X}^{\\prime}</span>, <span class="math">n=n^{\\prime}</span>, and <span class="math">\\mu_{i}=\\mu_{i}^{\\prime}</span> for any <span class="math">i</span> such that <span class="math">X_{i}\\neq X^{*}</span>.</li>

    </ol>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Properties (i) and (ii) follow directly from the corresponding properties in Lemma 4, while property (iii) follows from the discussion above. Property (iv) follows directly from the definition of <span class="math">\\mathsf{For}\\mathsf{k}^{\\mathcal{W}}</span> as it returns <span class="math">\\bot</span> if <span class="math">h_{\\mathrm{agg},\\mathfrak{j}_{\\mathrm{a}}}=h_{\\mathrm{agg},\\mathfrak{j}_{\\mathrm{a}}}^{\\prime}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To prove property (v), consider the two executions of <span class="math">\\mathcal{W}</span> run by <span class="math">\\mathsf{For}\\mathsf{k}^{\\mathcal{W}}</span>, which in turn run <span class="math">\\mathcal{V}</span> twice each. By inspection, the four executions are identical up to the <span class="math">\\mathfrak{j}_{\\mathrm{a}}</span>-th assignment in <span class="math">\\mathsf{T}_{\\mathrm{agg}}</span> of the form <span class="math">\\mathsf{T}_{\\mathrm{agg}}(\\cdot,X^{<em>})</span>: in the first two executions it is <span class="math">\\mathsf{T}_{\\mathrm{agg}}(\\mathbf{X},X^{</em>}):=h_{\\mathrm{agg},\\mathfrak{j}_{\\mathrm{a}}}(=h_{\\mathrm{agg}})</span> and in the last two executions it is <span class="math">\\mathsf{T}_{\\mathrm{agg}}(\\mathbf{X}^{\\prime},X^{*}):=h_{\\mathrm{agg},\\mathfrak{j}_{\\mathrm{a}}}^{\\prime}(=h_{\\mathrm{agg}}^{\\prime})</span>. This <span class="math">\\mathfrak{j}_{\\mathrm{a}}</span>-th assignment might happen either because of a call to <span class="math">\\mathrm{RO}_{\\mathrm{agg}}</span> or to <span class="math">\\mathrm{RO}_{\\mathrm{sig}}</span> made by <span class="math">\\mathcal{A}</span> or during the final call to <span class="math">\\mathsf{MS.Ver}</span>. In all cases, the argument of the call are the same and it can easily be checked that this implies <span class="math">\\mathbf{X}=\\mathbf{X}^{\\prime}</span>. Moreover, since $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>n^{\\prime}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{\\mu}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{X}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> this also implies </span>n=n^{\\prime}<span class="math">. Finally, since all four executions are identical up to this </span>\\mathfrak{j}_{\\mathrm{a}}<span class="math">-th assignment and since all assignments </span>\\mathsf{T}_{\\mathrm{agg}}(\\mathbf{X},X^{\\prime})<span class="math"> for </span>x^{\\prime}\\neq X<span class="math"> happen <em>before</em>, this implies that </span>\\mu_{i}=\\mu_{i}^{\\prime}<span class="math"> for any </span>i<span class="math"> such that </span>X_{i}\\neq X^{*}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Reduction <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span>. Finally, we define <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span>. On input <span class="math">(p,\\mathbb{G},G,X^{<em>})</span>, it runs <span class="math">\\mathsf{For}\\mathsf{k}^{\\mathcal{W}}(p,\\mathbb{G},G,X^{</em>})</span>. If <span class="math">\\mathsf{For}\\mathsf{k}^{\\mathcal{W}}</span> returns <span class="math">\\bot</span> then <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span> returns <span class="math">\\bot</span> as well. Otherwise, let <span class="math">((h_{\\mathrm{agg}},\\mathbf{X},\\bm{\\mu},\\tilde{x}),(h_{\\mathrm{agg}}^{\\prime},\\mathbf{X},\\bm{\\mu}^{\\prime},\\tilde{x}^{\\prime}))</span> be the output of <span class="math">\\mathsf{For}\\mathsf{k}^{\\mathcal{W}}</span> and let <span class="math">\\{X_{1},\\ldots,X_{n}\\}:=\\mathbf{X}</span>, <span class="math">(\\mu_{1},\\ldots,\\mu_{n}):=\\bm{\\mu}</span>, and <span class="math">(\\mu_{1}^{\\prime},\\ldots,\\mu_{n}^{\\prime}):=\\bm{\\mu}^{\\prime}</span> (using Lemma 5 (v) to equate elements of the two outputs of <span class="math">\\mathcal{W}</span>).</p>

    <p class="text-gray-300">Let <span class="math">n^{<em>}</span> be the number of times <span class="math">X^{</em>}</span> appears in <span class="math">\\mathbf{X}</span>. Then, by Lemma 5 (ii), (iii), and (v), one has</p>

    <p class="text-gray-300"><span class="math">\\tilde{x}G</span> <span class="math">=\\sum_{i=1}^{n}\\mu_{i}X_{i}=n^{<em>}h_{\\mathrm{agg}}X^{</em>}+\\sum_{i\\in[n]:X_{i}\\neq X^{<em>}}\\mu_{i}X_{i}</span> <span class="math">\\tilde{x}^{\\prime}G</span> <span class="math">=\\sum_{i=1}^{n}\\mu_{i}^{\\prime}X_{i}=n^{</em>}h_{\\mathrm{agg}}^{\\prime}X^{<em>}+\\sum_{i\\in[n]:X_{i}\\neq X^{</em>}}\\mu_{i}X_{i}.</span></p>

    <p class="text-gray-300">Since <span class="math">n^{<em>}\\neq 0</span> and <span class="math">h_{\\mathrm{agg}}\\neq h_{\\mathrm{agg}}^{\\prime}</span> by Lemma 5 (i) and (iv) respectively, <span class="math">\\mathcal{B}_{\\mathrm{dl}}</span> computes the discrete logarithm of <span class="math">X^{</em>}</span> as</p>

    <p class="text-gray-300"><span class="math">x^{<em>}=(\\tilde{x}-\\tilde{x}^{\\prime})(n^{</em>})^{-1}(h_{\\mathrm{agg}}-h_{\\mathrm{agg}}^{\\prime})^{-1}.</span></p>

    <p class="text-gray-300">By Lemma 3, Eq. (8), and Eq. (9), one has</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {A d v} _ {\\mathsf {G r G e n}, \\mathcal {B} _ {\\mathrm {d l}}} ^ {\\mathrm {d l}} (\\lambda) \\geq \\frac {\\mathsf {a c c} (\\mathcal {W}) ^ {2}}{q} - \\frac {\\mathsf {a c c} (\\mathcal {W})}{2 ^ {\\lambda - 1}} \\geq \\frac {\\mathsf {a c c} (\\mathcal {V}) ^ {4}}{q ^ {3}} - \\frac {3}{2 ^ {\\lambda - 1}} = \\frac {\\left(\\mathsf {A d v} _ {\\mathsf {M S} , \\mathcal {A}} ^ {\\mathsf {g a m e} _ {1 0}} (\\lambda)\\right) ^ {4}}{(q _ {\\mathrm {h}} + q _ {\\mathrm {s}} + 1) ^ {3}} - \\frac {3}{2 ^ {\\lambda - 1}},</span></div>

    <p class="text-gray-300">which concludes the proof.</p>

    <h2 id="sec-32" class="text-2xl font-bold">D Rerandomization of DDH Instances</h2>

    <p class="text-gray-300">We prove the following result.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> Let <span class="math">(q,\\mathbb{E},P)</span> be a group description. Let <span class="math">U = uP</span>, <span class="math">V = vP</span>, and <span class="math">W = wP</span> be three group elements. Consider the three following ways of sampling a pair of group elements <span class="math">(V&#x27;,W&#x27;)</span>:</p>

    <p class="text-gray-300">(i) <span class="math">\\alpha, \\beta \\leftrightarrows \\mathbb{Z}_q</span>; <span class="math">V&#x27; := \\alpha P + \\beta V</span>; <span class="math">W&#x27; := \\alpha U + \\beta W</span>; (ii) <span class="math">v&#x27; \\leftrightarrows \\mathbb{Z}_q</span>; <span class="math">V&#x27; := v&#x27;P</span>; <span class="math">W := uv&#x27;P</span>; (iii) <span class="math">v&#x27;, w&#x27; \\leftrightarrows \\mathbb{Z}_q</span>; <span class="math">V&#x27; := v&#x27;P</span>; <span class="math">W&#x27; := w&#x27;P</span>.</p>

    <p class="text-gray-300">Then (i) and (ii) result in identically distributed pairs if <span class="math">w = uv</span> and (i) and (iii) result in identically distributed pairs if <span class="math">w \\neq uv</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> When <span class="math">(V&#x27;, W&#x27;)</span> is sampled according to (i), one has <span class="math">V&#x27; = (\\alpha + \\beta v)P</span> and <span class="math">W&#x27; = (\\alpha u + \\beta w)P</span>. If <span class="math">w = uv</span>, then <span class="math">W&#x27; = u(\\alpha + \\beta v)P</span> and hence (i) and (ii) are equivalent since <span class="math">(\\alpha + \\beta v)</span> is uniformly distributed. If <span class="math">w \\neq uv</span>, then the system</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\alpha + \\beta v = v ^ {\\prime} \\\\ \\alpha u + \\beta w = w ^ {\\prime} \\end{array} \\right.</span></div>

    <p class="text-gray-300">has a unique solution <span class="math">(\\alpha, \\beta) \\in (\\mathbb{F}_p)^2</span> for any pair <span class="math">(v&#x27;, w&#x27;) \\in (\\mathbb{F}_p)^2</span>, hence (i) and (iii) result in identically distributed pairs.</p>

    <p class="text-gray-300">42</p>`;
---

<BaseLayout title="MuSig-DN: Schnorr Multi-Signatures with Verifiably Determini... (2020/1057)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1057
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
