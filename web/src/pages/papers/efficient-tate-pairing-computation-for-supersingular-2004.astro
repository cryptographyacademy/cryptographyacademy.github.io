---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/303';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Tate Pairing Computation for Supersingular Elliptic Curves over Binary Fields';
const AUTHORS_HTML = 'Soonhak Kwon';

const CONTENT = `    <p class="text-gray-300">Efficient Tate Pairing Computation for Supersingular Elliptic Curves over Binary Fields</p>

    <p class="text-gray-300">Soonhak Kwon</p>

    <p class="text-gray-300">Department of Mathematics, Sungkyunkwan University, Korea</p>

    <p class="text-gray-300">shkwon@skku.edu</p>

    <p class="text-gray-300">Abstract: After Miller’s original algorithm for the Tate pairing computation, many improved algorithms have been suggested, to name just a few, by Galbraith et al. and Barreto et al., especially for the fields with characteristic three. Also Duursma and Lee found a closed formula of the Tate pairing computation for the fields with characteristic three. In this paper, we show that a similar argument is also possible for the finite fields with characteristic two. That is, we present a closed formula for the Tate pairing computation for supersingular elliptic curves defined over the binary field <span class="math">\\mathbb{F}_{2^{m}}</span> of odd dimension. There are exactly three isomorphism classes of supersingular elliptic curves over <span class="math">\\mathbb{F}_{2^{m}}</span> for odd <span class="math">m</span> and our result is applicable to all these curves. Moreover we show that our algorithm and also the Duursma-Lee algorithm can be modified to another algorithm which does not need any inverse Frobenius operation (square root or cube root extractions) without sacrificing any of the computational merits of the original algorithm. Since the computation of the inverse Frobenius map is not at all trivial in a polynomial basis and since a polynomial basis is still a preferred choice for the Tate pairing computation in many situations, this new algorithm avoiding the inverse Frobenius operation has some advantage over the existing algorithms.</p>

    <p class="text-gray-300">Keywords: supersingular elliptic curve, Tate pairing, divisor, automorphism, roots of unity.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Introduction</li>

    </ol>

    <p class="text-gray-300">With increasing use of the Tate pairing in cryptographic areas, a study of efficient computation of the Tate pairing becomes the subject of active research these days. Many cryptographic schemes are based on the bilinear pairings arising from the rank two abelian group structure of the points of prescribed order of the given elliptic curve. Examples of such cryptographic protocols are, to name just a few, identity based encryption scheme by Boneh and Franklin <em>[10]</em>, short signature scheme by Boneh et al. <em>[11]</em>, tripartite Diffie-Hellman key agreement protocol by Joux <em>[12]</em>, identity based authenticated key agreement protocol by Smart <em>[25]</em>, and identity based signature schemes by Hess <em>[7]</em>, Sakai et al. <em>[24]</em>. In most of these applications, the Weil pairing or Tate pairing of supersingular elliptic curves (or curves of small embedding degrees) are essential tools. Therefore efficient computation of the Weil or Tate pairings is a crucial factor for practical applications of the above mentioned cryptographic protocols. The Weil pairing for a given elliptic curve is a symmetric bilinear pairing which can be thought of two applications of the Tate pairing. Thus the Weil pairing is more slow to compute than the Tate pairing, and consequently, it is desirable to replace the Weil pairing as the Tate pairing whenever it is possible in many cryptographic schemes.</p>

    <p class="text-gray-300">Recently many progresses have been made on the computation of the Tate pairing. Galbraith et al. <em>[4, 5]</em> suggested a few refined techniques and ideas to speed up the computation</p>

    <p class="text-gray-300">of the Tate pairing. Eisenträger et al. <em>[13]</em> introduced the notion of the squared Tate pairing. Scott and Barreto <em>[2]</em> and Granger et al. <em>[9]</em> discussed properties of compressed pairings. Barreto et al. <em>[1]</em> showed that the standard algorithm of Miller <em>[19]</em> can be modified to so called the BKLS algorithm where division in a finite field can be omitted since the denominator becomes one after final powering. Also Duursma and Lee <em>[3]</em> presented a closed formula for the computation of the Tate pairing for a finite field with characteristic three, which significantly reduces the cost of computing and is flexible for both of software and hardware applications.</p>

    <p class="text-gray-300">In this paper we show that an efficient closed formula can also be obtained for the computation of the Tate pairing for supersingular elliptic curves over a binary field <span class="math">\\mathbb{F}_{2^{m}}</span> with odd dimension <span class="math">m</span>. There are exactly three isomorphism classes of supersingular elliptic curves over <span class="math">\\mathbb{F}_{2^{m}}</span> with <span class="math">m</span> odd <em>[15]</em> and our method is applicable to all these curves, of which two are the most commonly used curves with embedding degree 4. Also we present a method of avoiding inverse Frobenius operations in our and Duursma-Lee’s algorithms. When one wants to use a polynomial basis, inverse Frobenius operation is not at all trivial unlike the case of a normal basis and this inverse operation deteriorates the performance of the algorithms of Duursma-Lee and ours, which need two inverse Frobenius operations in each step of the algorithms. We propose new modified algorithms which avoid the inverse Frobenius map without affecting the computational merits of the original algorithms.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Elliptic curves and Miller’s algorithm</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve over a finite field <span class="math">\\mathbb{F}_{q}</span> where <span class="math">q</span> is a power of a prime. We may express <span class="math">E</span> as the following standard Weierstrass form</p>

    <p class="text-gray-300"><span class="math">E:Y^{2}+a_{1}XY+a_{3}Y=X^{3}+a_{2}X^{2}+a_{4}X+a_{6},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the coefficients <span class="math">a_{1},a_{2},a_{3},a_{4},a_{6}</span> are in <span class="math">\\mathbb{F}_{q}</span>. Let <span class="math">E(\\mathbb{F}_{q})</span> be the set of all points <span class="math">P=(x,y),\\,x,y\\in\\mathbb{F}_{q},</span> on the curve with the point at infinity <span class="math">O</span> (which is <span class="math">(0,1,0)</span> on the corresponding homogeneous equation of degree 3 over a projective plane). <span class="math">E(\\mathbb{F}_{q})</span> has a structure of an abelian group and the order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is bounded by the following well known relation due to Hasse <em>[14]</em>,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q+1-Tr(\\varphi),\\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tr(\\varphi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\sqrt{q},$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">Tr(\\varphi)\\in\\mathbb{Z}</span> is the trace of the Frobenius map <span class="math">\\varphi:E\\longrightarrow E,\\text{ with }\\varphi(x,y)=(x^{q},y^{q}),</span> and <span class="math">\\varphi</span> is a zero of the characteristic polynomial <span class="math">h(X)=X^{2}-Tr(\\varphi)X+q</span>. Let <span class="math">l</span> be a positive integer and let <span class="math">E[l]</span> (resp. <span class="math">E<a href="\\mathbb{F}_{q}">l</a></span>) be the set of points <span class="math">P\\in E(\\overline{\\mathbb{F}}_{q})</span> (resp. <span class="math">P\\in E(\\mathbb{F}_{q})</span>) satisfying <span class="math">lP=O</span>, where <span class="math">\\overline{\\mathbb{F}}_{q}</span> is an algebraic closure of <span class="math">\\mathbb{F}_{q}</span>. Let <span class="math">k</span> be the minimal degree of the extension satisfying <span class="math">E[l]\\subset E(\\mathbb{F}_{q^{k}})</span>. Such <span class="math">k</span> is called the embedding degree (or the security multiplier) of <span class="math">E[l]</span> <em>[1, 15]</em> and is dependent on <span class="math">E</span> and <span class="math">l</span>. If <span class="math">l</span> is prime to <span class="math">q</span>, then it is well known <em>[14, 15]</em> that <span class="math">E[l]\\cong\\mathbb{Z}/l\\oplus\\mathbb{Z}/l</span>.</p>

    <p class="text-gray-300">A divisor <span class="math">D</span> on <span class="math">E</span> is a formal (finite) sum of the points <span class="math">P</span> on the curve</p>

    <p class="text-gray-300"><span class="math">D=\\sum n_{p}(P),\\quad n_{p}\\in\\mathbb{Z}.</span> (2)</p>

    <p class="text-gray-300">We call <span class="math">D</span> a zero divisor if <span class="math">\\sum n_{p}=0</span>. A principal divisor is a divisor of the form <span class="math">(f)=\\sum n_{p}(P)</span>, where <span class="math">f</span> is a rational function on <span class="math">E</span> and <span class="math">P</span> is a point of <span class="math">E</span> with <span class="math">n_{P}</span> the order of multiplicity of <span class="math">f</span> at <span class="math">P</span>, i.e. <span class="math">n_{P}&gt;0</span> if <span class="math">f</span> has a zero at <span class="math">P</span> and <span class="math">n_{P}&lt;0</span> if <span class="math">f</span> has a pole at <span class="math">P</span>. We say two divisors <span class="math">D</span> and <span class="math">D^{\\prime}</span> are equivalent if <span class="math">D-D^{\\prime}</span> is a principal divisor. It is well known <em>[14, 15]</em> that</p>

    <p class="text-gray-300">a principal divisor <span class="math">(f)</span> is a zero divisor, and a divisor <span class="math">D = \\sum n_p(P)</span> is a principal divisor if <span class="math">D</span> is a zero divisor and <span class="math">\\sum n_p P = O</span> in the abelian group <span class="math">E(\\overline{\\mathbb{F}}_q)</span>. More precisely, there is an isomorphism [15]</p>

    <div class="my-4 text-center"><span class="math-block">Div_0 / Div_{prin} \\longrightarrow E, \\quad \\text{with} \\quad D = \\sum n_p(P) \\longmapsto \\sum n_p P, \\tag{3}</span></div>

    <p class="text-gray-300">where the summation in the right side is the addition of points on the elliptic curve <span class="math">E</span> and <span class="math">Div_0</span> (resp. <span class="math">Div_{prin}</span>) is a free abelian group generated by the zero divisors (resp. principal divisors). Now suppose that <span class="math">P \\in E[l]</span>. Then the divisor <span class="math">l(P) - l(O)</span> is a principal divisor so that there is a rational function <span class="math">f_P</span> such that <span class="math">(f_P) = l(P) - l(O)</span>. For any rational function <span class="math">f</span> and any divisor <span class="math">D = \\sum n_p(P)</span> having disjoint supports, one naturally defines <span class="math">f(D) = \\prod f(P)^{n_p}</span>. The Tate pairing <span class="math">\\tau_l</span> on the set <span class="math">E[l]</span> is defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Let <span class="math">P \\in Ell</span> and <span class="math">Q \\in Ell</span>. The Tate pairing is a map</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_l : Ell \\times Ell \\longrightarrow \\{\\zeta_l\\}, \\quad \\text{with} \\quad \\tau_l(P, Q) = f_P(D_Q)^{\\frac{q^k - 1}{l}},</span></div>

    <p class="text-gray-300">where <span class="math">f_P</span> is a rational function satisfying <span class="math">(f_P) = l(P) - l(O)</span> and <span class="math">D_Q</span> is a zero divisor equivalent to <span class="math">(Q) - (O)</span> such that <span class="math">D_Q</span> and <span class="math">(f_P)</span> have disjoint supports. Also <span class="math">\\{\\zeta_l\\}</span> is the group of <span class="math">l</span>-th roots of unity in <span class="math">\\mathbb{F}_{q^k}^\\times</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is well known that <span class="math">\\tau_l</span> is a non-degenerate bilinear pairing. That is, for any <span class="math">P \\neq O \\in \\mathbb{E}[l]</span> there exists a point <span class="math">Q \\in Ell \\neq 1</span>. Also we have <span class="math">\\tau_l(P_1 + P_2, Q) = \\tau_l(P_1, Q) \\tau_l(P_2, Q)</span> and <span class="math">\\tau_l(P, Q_1 + Q_2) = \\tau_l(P, Q_1) \\tau_l(P, Q_2)</span>. Non-degeneracy is not a trivial result and a proof can be found in [6,17]. It is also easy to verify <span class="math">\\tau_{ld}(P, Q) = \\tau_l(P, Q)</span> for <span class="math">P, Q \\in E[l]</span> and <span class="math">d &amp;gt; 0</span> with <span class="math">ld</span> dividing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_q)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An effective algorithm for finding a rational function <span class="math">f_P</span> satisfying <span class="math">(f_P) = l(P) - l(O)</span> with <span class="math">P \\in E[l]</span> is found by Miller [15,19]. Let us briefly explain the idea of Miller. For any zero divisor <span class="math">D</span> and <span class="math">D&#x27;</span>, the isomorphism in (3) implies that there exist points <span class="math">P</span> and <span class="math">P&#x27;</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">D = (P) - (O) + (f), \\quad D&#x27; = (P&#x27;) - (O) + (f&#x27;),</span></div>

    <p class="text-gray-300">for some rational functions <span class="math">f</span> and <span class="math">f&#x27;</span>. Then one easily checks that</p>

    <div class="my-4 text-center"><span class="math-block">D + D&#x27; = (P + P&#x27;) - (O) + \\left( \\frac{ff&#x27;}{\\ell_{P,P&#x27;}} \\right), \\tag{4}</span></div>

    <p class="text-gray-300">where <span class="math">\\ell_{P,P&#x27;}</span> is an equation of a line intersecting <span class="math">P</span> and <span class="math">P&#x27;</span>, and <span class="math">\\ell_P</span> is an equation of a vertical line intersecting <span class="math">P</span> and <span class="math">-P</span>. This can be verified using the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\left( \\frac{\\ell_{P,P&#x27;}}{\\ell_{P+P&#x27;}} \\right) &amp;amp;= \\left( \\ell_{P,P&#x27;} \\right) - \\left( \\ell_{P+P&#x27;} \\right) \\\\ &amp;amp;= (P) + (P&#x27;) + (-P - P&#x27;) - 3(O) - \\left\\{ (P + P&#x27;) + (-P - P&#x27;) - 2(O) \\right\\} \\tag{5} \\\\ &amp;amp;= (P) + (P&#x27;) - (P + P&#x27;) - (O). \\end{aligned}</span></div>

    <p class="text-gray-300">Thus the right side of (4) is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} (P + P&#x27;) - (O) + \\left( \\frac{ff&#x27;}{\\ell_{P,P&#x27;}} \\right) &amp;amp;= (P + P&#x27;) - (O) + (ff&#x27;) + (P) + (P&#x27;) - (P + P&#x27;) - (O) \\\\ &amp;amp;= (P) + (P&#x27;) - 2(O) + (ff&#x27;) = D + D&#x27;. \\end{aligned}</span></div>

    <p class="text-gray-300">.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An elliptic curve <span class="math">E</span> over <span class="math">\\mathbb{F}_{q}</span> is called supersingular if <span class="math">Tr(\\varphi)\\equiv 0\\pmod{p}</span> where <span class="math">\\varphi</span> is the Frobenius map and <span class="math">p</span> is the characteristic of <span class="math">\\mathbb{F}_{q}</span>. If an elliptic curve <span class="math">E</span> over <span class="math">\\mathbb{F}_{q}</span> is supersingular, then it is well known <em>[15]</em> that for any <span class="math">l</span> dividing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the embedding degree </span>k<span class="math"> is bounded by </span>6<span class="math">. More precisely, we have </span>E[l]\\subset E(\\mathbb{F}_{q^{k}})<span class="math"> with </span>k=2,3,4,6<span class="math">. It is also well known <em>[15]</em> that the embedding degree </span>k=6<span class="math"> is attained when the characteristic of </span>\\mathbb{F}_{q}<span class="math"> is three and the embedding degree </span>k=4<span class="math"> is attained when the characteristic of </span>\\mathbb{F}_{q}$ is two.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BKLS algorithm and the algorithm of Duursma and Lee</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Barreto, Kim, Lynn, and Scott <em>[1]</em> showed that, for some supersingular curves with embedding degree <span class="math">k=2,4,6</span>, one can speed up the computation of the Tate pairing by observing that the denominators <span class="math">\\ell_{Q}</span> appearing in the Miller’s algorithm can be omitted using the idea of the distortion map <span class="math">\\phi</span> introduced in <em>[18]</em>, where <span class="math">\\phi</span> is a suitably chosen nontrivial automorphism of the given supersingular elliptic curve. That is, since the line <span class="math">X-\\alpha</span> intersecting <span class="math">Q=(\\alpha,\\beta)\\in\\mathbb{F}_{q}</span> and <span class="math">-Q</span> has only <span class="math">X</span>-coordinate and since this <span class="math">X</span>-coordinate has the value in <span class="math">\\mathbb{F}_{q^{k/2}}</span> after applying <span class="math">\\phi</span> to <span class="math">Q</span>, it becomes one after taking the final power by <span class="math">\\frac{q^{k}-1}{l}</span> because $l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q^{k/2}+1<span class="math"> and </span>q^{k}-1=(q^{k/2}-1)(q^{k/2}+1)<span class="math">. Therefore omitting </span>\\ell_{Q}<span class="math"> does not affect the final pairing value and this greatly simplifies the Miller’s algorithm since the costly operation of division is not necessary. By the similar reasoning, Barreto et al. <em>[1]</em> also showed that it is not necessary to evaluate the Tate pairing at </span>O<span class="math">, the point at infinity, since the image of </span>O<span class="math"> is already in the field </span>\\mathbb{F}_{q}<span class="math"> before taking the final power by </span>\\frac{q^{k}-1}{l}$. To summarize, the BKLS algorithm can be explained as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-1" class="text-base font-medium mt-4">Theorem 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Barreto et al. <em>[1]</em>) Let <span class="math">E</span> be a supersingular elliptic curve over <span class="math">\\mathbb{F}_{q}</span> with embedding degree <span class="math">k=2,4,6</span> and suppose that there is a suitable distortion map <span class="math">\\phi</span> for <span class="math">E</span>. Let <span class="math">l</span> be a positive integer dividing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with </span>gcd(l,q)=1<span class="math"> and let </span>\\{\\zeta_{l}\\}<span class="math"> be the group of </span>l<span class="math">-th roots of unity in </span>\\mathbb{F}_{q^{k}}^{\\times}$. Then the modified Tate pairing</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\tau_{l}:E<a href="\\mathbb{F}_{q}">l</a>\\times E<a href="\\mathbb{F}_{q}">l</a>\\longrightarrow\\{\\zeta_{l}\\},\\quad\\text{with}\\quad\\tau_{l}(P,Q)=f_{P}(\\phi(Q))^{\\frac{q^{k}-1}{l}},</span></p>

    <p class="text-gray-300">is a non-degenerate bilinear pairing, where <span class="math">f_{P}</span> is a rational function with denominator one, i.e. a polynomial, satisfying <span class="math">(f_{P})=l(P)-l(O)</span>.</p>

    <p class="text-gray-300">The crucial difference between the above pairing with a distortion map <span class="math">\\phi</span> and the conventional Tate pairing is that this new pairing is symmetric as long as <span class="math">E<a href="\\mathbb{F}_{q}">l</a></span> is a cyclic group, while the original Tate pairing is not. The reason is that, in this new pairing, both of the points <span class="math">P</span> and <span class="math">Q</span> are in the same cyclic group <span class="math">E<a href="\\mathbb{F}_{q}">l</a></span> generated by a point <span class="math">R</span> of order <span class="math">l</span>. Thus there are integers <span class="math">a</span> and <span class="math">b</span> satisfying <span class="math">P=aR</span> and <span class="math">Q=bR</span> so that we have</p>

    <p class="text-gray-300"><span class="math">\\tau_{l}(P,Q)=\\tau_{l}(aR,bR)=\\tau_{l}(R,R)^{ab}=\\tau_{l}(bR,aR)=\\tau_{l}(Q,P).</span> (6)</p>

    <p class="text-gray-300">Efficient computation of the Tate pairing is closely related with efficient computation of the scalar multiplication <span class="math">lP</span> of a given point <span class="math">P</span> since one has to find a rational function <span class="math">f_{P}</span> satisfying <span class="math">(f_{P})=l(P)-l(O)</span>. Usually a binary representation of <span class="math">l</span> is used for the field <span class="math">\\mathbb{F}_{2^{m}}</span> or the field <span class="math">\\mathbb{F}_{p}</span> with <span class="math">p</span> a prime. A (balanced) ternary representation of <span class="math">l</span> is an optimal choice for <span class="math">\\mathbb{F}_{3^{m}}</span> and both of the algorithms of BKLS <em>[1]</em> and Duursma-Lee <em>[3]</em> made careful studies for this case.</p>

    <p class="text-gray-300">For a field with characteristic three, <span class="math">\\mathbb{F}_{q}</span> with <span class="math">q=3^{m}</span>, Duursma and Lee <em>[3]</em> noticed that one can obtain a faster Tate pairing computation if one use <span class="math">q^{3}+1=3^{3m}+1</span> instead of using</p>

    <p class="text-gray-300">dividing <span class="math">q^{3}+1</span>, since the ternary expansion of <span class="math">q^{3}+1</span> is trivial. That is, if one write <span class="math">g_{Q}</span> as a rational function satisfying</p>

    <p class="text-gray-300"><span class="math">3(Q)-3(O)=(3Q)-(O)+(g_{Q}),</span></p>

    <p class="text-gray-300">then, by repeated applications of the above equation, one has</p>

    <p class="text-gray-300"><span class="math">3^{3m}(P)-3^{3m}(O)=(3^{3m}P)-(O)+(g_{P}^{3^{3m-1}}g_{3P}^{3^{3m-2}}\\cdots g_{3^{3m-2}P}^{3}g_{3^{3m-1}P}).</span></p>

    <p class="text-gray-300">It is shown <em>[3]</em> that the rational function</p>

    <p class="text-gray-300"><span class="math">f=\\prod_{i=1}^{3m}g_{3^{i-1}P}^{3^{3m-i}}=g_{P}^{3^{3m-1}}g_{3P}^{3^{3m-2}}\\cdots g_{3^{3m-2}P}^{3}g_{3^{3m-1}P}</span> (7)</p>

    <p class="text-gray-300">can be used for a computation of the Tate pairing as</p>

    <p class="text-gray-300"><span class="math">\\tau_{l}(P,Q)=f(\\phi(Q))^{3^{3m}-1}.</span> (8)</p>

    <p class="text-gray-300">Duursma and Lee showed that the value <span class="math">f(\\phi(Q))=\\prod_{i=1}^{3m}\\{g_{3^{i-1}P}(\\phi(Q))\\}^{3^{3m-i}}</span> has certain cyclic property with regard to the polynomials <span class="math">g_{3^{i-1}P}^{3^{3m-i}}</span> so that they found a nice closed formula <em>[3]</em> for <span class="math">f</span> as a product of <span class="math">m</span> (not <span class="math">3m</span>) polynomials.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Tate pairing computation for binary fields with closed formulas</li>

    </ol>

    <p class="text-gray-300">4.1. Supersingular elliptic curves over binary fields</p>

    <p class="text-gray-300">For cryptographic purposes, it is natural to think of elliptic curves defined over <span class="math">\\mathbb{F}_{2^{m}}</span> with <span class="math">m</span> odd or more strongly a prime. There are exactly three isomorphism classes of supersingular elliptic curves over <span class="math">\\mathbb{F}_{2^{m}}</span> when <span class="math">m</span> is odd <em>[15]</em>. Namely they are</p>

    <p class="text-gray-300"><span class="math">Y^{2}+Y=X^{3},\\;\\;Y^{2}+Y=X^{3}+X,\\;\\;Y^{2}+Y=X^{3}+X+1.</span> (9)</p>

    <p class="text-gray-300">Among them, the curves</p>

    <p class="text-gray-300"><span class="math">E_{b}:Y^{2}+Y=X^{3}+X+b,\\quad b=0,1</span> (10)</p>

    <p class="text-gray-300">have the embedding degree (or security multiplier) <span class="math">k=4</span> while the curve <span class="math">Y^{2}+Y=X^{3}</span> has <span class="math">k=2</span>. Thus we are mainly interested in the curves <span class="math">E_{b}</span> though our method is also applicable to the curve <span class="math">Y^{2}+Y=X^{3}</span>. The Frobenius map <span class="math">\\varphi:E_{b}\\longrightarrow E_{b}</span> with <span class="math">\\varphi(x,y)=(x^{2},y^{2})</span> is a root of the characteristic polynomial</p>

    <p class="text-gray-300"><span class="math">h(X)=X^{2}\\pm 2X+2=(X-\\varphi)(X-\\bar{\\varphi}).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We also have the order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{b}(\\mathbb{F}_{2^{m}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the group of rational points </span>E_{b}(\\mathbb{F}_{2^{m}})$ as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{b}(\\mathbb{F}_{2^{m}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{m}+1-Tr(\\varphi^{m}),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">Tr(\\varphi^{m})=\\varphi^{m}+\\bar{\\varphi}^{m}</span> and <span class="math">\\varphi^{m}(x,y)=(x^{2^{m}},y^{2^{m}})</span>. Letting <span class="math">c_{j}=Tr(\\varphi^{j})</span>, one can find the values of <span class="math">c_{j}</span> using the following second order liner recurrence relations (or Lucas type sequences) arising from the characteristic polynomial <span class="math">h(X)</span>,</p>

    <p class="text-gray-300"><span class="math">c_{j}=2(\\mp c_{j-1}-c_{j-2}),\\quad j\\geq 0,</span> (11)</p>

    <p class="text-gray-300"><span class="math">c_{0}=2</span> and <span class="math">c_{1}=\\mp 2</span>. From the above relations, it is straightforward to see <em>[15]</em> that <span class="math">E_{b}(\\mathbb{F}_{2^{m}})</span> is a cyclic group of order</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\begin{split}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E_{b}(\\mathbb{F}_{2^{m}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&=2^{m}+1+(-1)^{b}\\sqrt{2\\cdot 2^{m}},\\quad\\text{if}\\quad m\\equiv 1,7\\pmod{8}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&=2^{m}+1-(-1)^{b}\\sqrt{2\\cdot 2^{m}},\\quad\\text{if}\\quad m\\equiv 3,5\\pmod{8}.\\end{split} \\] (12)</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">4.2. Closed formula of the Tate pairing for <span class="math">\\mathbb{F}_{2^{m}}</span></h3>

    <p class="text-gray-300">As in the characteristic three case of Duursma and Lee <em>[3]</em>, we want to derive a closed formula for the Tate pairing computation using the simple equality for our binary case,</p>

    <p class="text-gray-300"><span class="math">2^{2m}+1=(2^{m}+1+2^{\\frac{m+1}{2}})(2^{m}+1-2^{\\frac{m+1}{2}}).</span></p>

    <p class="text-gray-300">Let <span class="math">P=(\\alpha,\\beta)</span> be a point on the curve <span class="math">E_{b}:Y^{2}+Y=X^{3}+X+b,\\;b=0,1</span>. Then one has <span class="math">-P=(\\alpha,\\beta+1)</span> and <span class="math">2P=(\\alpha^{4}+1,\\alpha^{4}+\\beta^{4})</span>. Thus we get</p>

    <p class="text-gray-300"><span class="math">2^{2}P=(\\alpha^{2^{4}},\\beta^{2^{4}}+1)=-\\varphi^{4}(P),\\;2^{3}P=(\\alpha^{2^{6}}+1,\\alpha^{2^{6}}+\\beta^{2^{6}}+1),\\;2^{4}P=(\\alpha^{2^{8}},\\beta^{2^{8}}),</span></p>

    <p class="text-gray-300">where <span class="math">\\varphi^{4}+4=0</span>, i.e. <span class="math">h(X)=X^{2}\\pm 2X+2</span> divides <span class="math">X^{4}+4</span>. Using this cyclic property, one finds easily</p>

    <p class="text-gray-300">\\[ \\begin{split}2^{i-1}P&=(\\alpha^{2^{2i-2}}+i-1,\\beta^{2^{2i-2}}+(i-1)\\alpha^{2^{2i-2}}+\\epsilon_{i})\\\\ &=(\\alpha^{(2i-2)}+i-1,\\beta^{(2i-2)}+(i-1)\\alpha^{(2i-2)}+\\epsilon_{i}),\\end{split} \\] (13)</p>

    <p class="text-gray-300">where <span class="math">\\alpha^{(j)}</span> (resp. <span class="math">\\beta^{(j)}</span>) is defined as <span class="math">\\alpha^{(j)}=\\alpha^{2^{j}}</span> (resp. <span class="math">\\beta^{(j)}=\\beta^{2^{j}}</span>) and <span class="math">\\epsilon_{i}</span> is defined as</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{i}=0\\quad\\text{if}\\;\\;i\\equiv 1,2\\pmod{4}\\quad\\text{and}\\quad\\epsilon_{i}=1\\quad\\text{if}\\;\\;i\\equiv 3,4\\pmod{4}.</span> (14)</p>

    <p class="text-gray-300">For an effective Tate pairing computation, the following distortion map (nontrivial automorphism) is chosen <em>[1]</em> for <span class="math">E_{b}</span>,</p>

    <p class="text-gray-300"><span class="math">\\phi:E_{b}\\longrightarrow E_{b},\\quad\\text{with}\\quad\\phi(x,y)=(x+s^{2},y+sx+t),</span> (15)</p>

    <p class="text-gray-300">where <span class="math">s^{2}+s+1=0</span> and <span class="math">t^{2}+t+s=0</span>. That is,</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{2}(s)=\\mathbb{F}_{2^{2}},\\quad\\mathbb{F}_{2}(t)=\\mathbb{F}_{2^{4}},\\quad s=t^{5},\\quad t^{4}+t+1=0,</span> (16)</p>

    <p class="text-gray-300">and <span class="math">t</span> is a generator of the cyclic group <span class="math">\\mathbb{F}_{2^{4}}^{\\times}</span> of order 15. Therefore if <span class="math">P</span> is a point of order <span class="math">l</span> in <span class="math">\\mathbb{F}_{2^{m}}</span> with <span class="math">m</span> odd, then <span class="math">\\phi(P)\\in E(\\mathbb{F}_{2^{4m}})</span> but <span class="math">\\phi(P)\\not\\in E(\\mathbb{F}_{2^{2m}})</span>, and the two points <span class="math">P</span> and <span class="math">\\phi(P)</span> generate all points of order <span class="math">l</span> as a <span class="math">\\mathbb{Z}/l</span> module.</p>

    <p class="text-gray-300">For any point <span class="math">Q</span> on the curve <span class="math">E_{b}</span>, let us write <span class="math">g_{Q}</span> as a rational function satisfying</p>

    <p class="text-gray-300"><span class="math">2(Q)-2(O)=(2Q)-(O)+(g_{Q}).</span></p>

    <p class="text-gray-300">By the Miller’s formula in (4), we have <span class="math">g_{Q}=\\ell_{Q,Q}/\\ell_{2Q}</span> and the denominator <span class="math">\\ell_{2Q}</span> can be omitted by the result of Barreto et al. <em>[1]</em>. Now for a given point <span class="math">P\\in E_{b}(\\mathbb{F}_{2^{m}})</span>, one repeatedly has</p>

    <p class="text-gray-300"><span class="math">2(P)-2(O)</span> <span class="math">=(2P)-(O)+(g_{P}),</span> <span class="math">2^{2}(P)-2^{2}(O)</span> <span class="math">=2\\{(2P)-(O)\\}+(g_{P}^{2})=(2^{2}P)-(O)+(g_{P}^{2}g_{2P}),</span> <span class="math">2^{3}(P)-2^{3}(O)</span> <span class="math">=2\\{(2^{2}P)-(O)\\}+(g_{P}^{2^{2}}g_{2P}^{2})=(2^{3}P)-(O)+(g_{P}^{2^{2}}g_{2P}^{2}g_{2^{2}P}),</span> <span class="math">\\cdots</span> <span class="math">2^{2m}(P)-2^{2m}(O)</span> <span class="math">=(2^{2m}P)-(O)+(g_{P}^{2^{2m-1}}g_{2P}^{2^{2m-2}}\\cdots g_{2^{2m-2}P}^{2}g_{2^{2m-1}P}).</span></p>

    <p class="text-gray-300">Letting</p>

    <p class="text-gray-300"><span class="math">f_{P}=\\prod_{i=1}^{2m}g_{2^{i-1}P}^{2^{2m-i}}=g_{P}^{2^{2m-1}}g_{2P}^{2^{2m-2}}\\cdots g_{2^{2m-2}P}^{2}g_{2^{2m-1}P},</span> (17)</p>

    <p class="text-gray-300">we have</p>

    <p class="text-gray-300"><span class="math">2^{2m}(P)-2^{2m}(O)=(2^{2m}P)-(O)+(f_{P})\\quad\\text{and}\\quad(P)-(O)=(P)-(O)+(1).</span></p>

    <p class="text-gray-300">Thus the equation (4) of the Miller’s formula again says</p>

    <p class="text-gray-300"><span class="math">(2^{2m}+1)\\{(P)-(O)\\}=(f_{P}\\ell_{P}),</span> (18)</p>

    <p class="text-gray-300">because <span class="math">2^{2m}P=-P</span>. Note that the line <span class="math">\\ell_{P}</span> can also be omitted in the actual computation by the BKLS algorithm. Therefore after adjusting the irrelevant factors, we can say that</p>

    <p class="text-gray-300"><span class="math">(f_{P})=(2^{2m}+1)\\{(P)-(O)\\}=\\tfrac{2^{2m}+1}{l}\\cdot\\{l(P)-l(O)\\}=\\tfrac{2^{2m}+1}{l}(f_{P}^{\\prime}),</span> (19)</p>

    <p class="text-gray-300">where <span class="math">f_{P}^{\\prime}</span> is a rational function satisfying <span class="math">l(P)-l(O)=(f_{P}^{\\prime})</span>. Thus we have the Tate pairing</p>

    <p class="text-gray-300"><span class="math">\\tau_{l}(P,Q)=f_{P}^{\\prime}(\\phi(Q))^{\\tfrac{2^{4m}-1}{l}}=f_{P}^{\\prime}(\\phi(Q))^{\\tfrac{2^{2m}+1}{l}(2^{2m}-1)}=f_{P}(\\phi(Q))^{2^{2m}-1}.</span> (20)</p>

    <p class="text-gray-300">From the equation (17), the rational function <span class="math">f_{P}</span> is just a product of the functions of the form <span class="math">g_{2^{i-1}P}</span> and, in view of the BKLS algorithm, the rational function <span class="math">g_{2^{i-1}P}</span> can be regarded as the tangent line at the point <span class="math">2^{i-1}P</span>. Thus all we have to do is to find an explicit expression of <span class="math">f_{P}=\\prod_{i=1}^{2m}g_{2^{i-1}P}^{2^{m-i}}</span>.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">P=(\\alpha,\\beta),Q=(x,y)</span> be points in <span class="math">E_{b}(\\mathbb{F}_{2^{m}})</span>. Then one has the value of <span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}=\\{g_{2^{i-1}P}(x+s^{2},y+sx+t)\\}^{2^{2m-i}}</span> as</p>

    <p class="text-gray-300"><span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}=\\alpha^{(i-1)}x^{(-i)}+\\beta^{(i-1)}+y^{(-i)}+s(\\alpha^{(i-1)}+x^{(-i)})+t+b,</span></p>

    <p class="text-gray-300">where <span class="math">g_{R}(X,Y)=\\ell_{R,R}</span> is an equation of the tangent line at <span class="math">R</span>.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The tangent line at <span class="math">P=(\\alpha,\\beta)</span> on the curve <span class="math">E_{b}:Y^{2}+Y=X^{3}+X+b</span> is <span class="math">Y=(\\alpha^{2}+1)X+\\beta^{2}+b</span>. Thus we have <span class="math">2(P)-2(O)=(2P)-(O)+(\\tfrac{g_{P}}{\\ell_{2P}})</span> where</p>

    <p class="text-gray-300"><span class="math">g_{P}(x,y)=(\\alpha^{2}+1)x+\\beta^{2}+b-y,</span> (21)</p>

    <p class="text-gray-300">and <span class="math">\\ell_{2P}</span> is the vertical line intersecting <span class="math">2P</span> and <span class="math">-2P</span>. Since <span class="math">\\ell_{2P}</span> can be removed in view of the BKLS algorithm <em>[1]</em>, we are mainly interested in the computations of the lines <span class="math">g_{2^{i-1}P}</span>. Using the equation (13), one has</p>

    <p class="text-gray-300"><span class="math">g_{2^{i-1}P}(x,y)=(\\alpha^{(2i-1)}+i)x+\\beta^{(2i-1)}+(i-1)\\alpha^{(2i-1)}+\\epsilon_{i}+b-y.</span></p>

    <p class="text-gray-300">Therefore, by applying the distortion map <span class="math">\\phi</span> to the point <span class="math">Q=(x,y)</span>, we get</p>

    <p class="text-gray-300"><span class="math">g_{2^{i-1}P}(x+s^{2},y+sx+t)=(\\alpha^{(2i-1)}+i)(x+s^{2})+\\beta^{(2i-1)}+(i-1)\\alpha^{(2i-1)}+\\epsilon_{i}+b-(y+sx+t).</span> (22)</p>

    <p class="text-gray-300">Taking <span class="math">2^{2m-i}</span>-th power of both sides of the above equality,</p>

    <p class="text-gray-300"><span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}</span> <span class="math">\\qquad\\qquad=(\\alpha^{(i-1)}+i)(x^{(2m-i)}+s^{(2m-i+1)})+\\beta^{(i-1)}+(i-1)\\alpha^{(i-1)}+\\epsilon_{i}+b</span> <span class="math">\\qquad\\qquad\\qquad-(y^{(2m-i)}+s^{(2m-i)}x^{(2m-i)}+t^{(2m-i)})</span> (23) <span class="math">\\qquad=\\alpha^{(i-1)}x^{(2m-i)}+\\{i-s^{(2m-i)}\\}x^{(2m-i)}+\\{s^{(2m-i+1)}+i-1\\}\\alpha^{(i-1)}</span> <span class="math">\\qquad\\qquad\\qquad+\\beta^{(i-1)}+b-y^{(2m-i)}+\\{is^{(2m-i+1)}+\\epsilon_{i}-t^{(2m-i)}\\}.</span></p>

    <p class="text-gray-300">From <span class="math">s^{2}+s+1=0</span>, we have <span class="math">s^{(2)}=s^{4}=s,s^{(3)}=s^{2}=s+1,s^{(4)}=s,\\cdots</span>. That is,</p>

    <p class="text-gray-300"><span class="math">s^{(j)}=s+1\\quad\\mbox{if}\\;\\;j=odd\\quad\\mbox{and}\\quad s^{(j)}=s\\quad\\mbox{if}\\;\\;j=even.</span> (24)</p>

    <p class="text-gray-300">The coefficients <span class="math">i-s^{(2m-i)}</span> (resp. <span class="math">i-1+s^{(2m-i+1)}</span> ) of <span class="math">x^{(2m-i)}</span> (resp. <span class="math">\\alpha^{(i-1)}</span>) in the equation (23) have a unique value equal to <span class="math">s</span> independent of the choices of <span class="math">i</span> because <span class="math">i</span> and <span class="math">2m-i</span> always have the same parity. For example, when <span class="math">i</span> is odd, <span class="math">i-s^{(2m-i)}=1+s+1=s</span> and also when <span class="math">i</span> is even, <span class="math">i-s^{(2m-i)}=0+s=s</span>. That is, for any <span class="math">i</span>, we get</p>

    <p class="text-gray-300"><span class="math">i-s^{(2m-i)}=s=i-1+s^{(2m-i+1)}.</span> (25)</p>

    <p class="text-gray-300">From <span class="math">t^{2}=t+s</span>, we have <span class="math">t^{(2)}=t^{2^{2}}=t+s+s^{2}=t+1,t^{(3)}=t^{2^{3}}=t+s+1,t^{(4)}=t+s+s^{2}+1=t,t^{(5)}=t^{2}=t+s,\\cdots</span>. Therefore, for any <span class="math">j\\geq 0</span>, we have</p>

    <p class="text-gray-300"><span class="math">t^{(4j)}=t,\\quad t^{(4j+1)}=t+s,\\quad t^{(4j+2)}=t+1,\\quad t^{(4j+3)}=t+s+1.</span> (26)</p>

    <p class="text-gray-300">Now using the equations (14),(24),(26), it is trivial to show that the last term of the equation (23) has the value</p>

    <p class="text-gray-300"><span class="math">is^{(2m-i+1)}+\\epsilon_{i}-t^{(2m-i)}=t</span> (27)</p>

    <p class="text-gray-300">independent of the choices of <span class="math">i</span>. This can be proved as follows. Since the extension degree <span class="math">m</span> is odd, we have <span class="math">m\\equiv 1\\pmod{4}</span> or <span class="math">m\\equiv 3\\pmod{4}</span>. In any case, we get <span class="math">2m\\equiv 2\\pmod{4}</span> and letting <span class="math">2m=4j+2</span> for some <span class="math">j</span>,</p>

    <p class="text-gray-300"><span class="math">is^{(2m-i+1)}+\\epsilon_{i}-t^{(2m-i)}=is^{(4j+3-i)}+\\epsilon_{i}-t^{(4j+2-i)}.</span> (28)</p>

    <p class="text-gray-300">By taking <span class="math">i\\pmod{4}</span> and noticing that our field has characteristic two, we easily get the equation (27). Since <span class="math">x,y,\\alpha,\\beta</span> are all in <span class="math">\\mathbb{F}_{2^{m}}</span>, the values <span class="math">x^{(j)},y^{(j)},\\alpha^{(j)},\\beta^{(j)}</span> are determined up to the residue classes of <span class="math">j\\pmod{m}</span> and <span class="math">x^{(j)}</span> with <span class="math">j\\in\\mathbb{Z}</span> (resp. <span class="math">y^{(j)},\\alpha^{(j)},\\beta^{(j)}</span>) is understood as <span class="math">x^{(j)}=x^{2^{j^{\\prime}}}</span> where <span class="math">j^{\\prime},\\;0\\leq j^{\\prime}\\leq m-1</span>, is a unique integer satisfying <span class="math">j^{\\prime}\\equiv j\\pmod{m}</span>. Therefore we get</p>

    <p class="text-gray-300"><span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}</span> <span class="math">=\\alpha^{(i-1)}x^{(-i)}+sx^{(-i)}+s\\alpha^{(i-1)}+\\beta^{(i-1)}+y^{(-i)}+t+b</span> <span class="math">=\\alpha^{(i-1)}x^{(-i)}+\\beta^{(i-1)}+y^{(-i)}+s(\\alpha^{(i-1)}+x^{(-i)})+t+b.</span></p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">One has the Tate pairing <span class="math">\\tau_{l}(P,Q)=f_{P}(\\phi(Q))^{2^{2m}-1}</span> where</p>

    <p class="text-gray-300"><span class="math">f_{P}(\\phi(Q))=\\prod_{i=1}^{m}\\{\\alpha^{(i)}x^{(-i+1)}+\\beta^{(i)}+y^{(-i+1)}+s^{2}(\\alpha^{(i)}+x^{(-i+1)})+t^{2}+b\\}.</span></p>

    <p class="text-gray-300">Proof. By the equation (17) and (20), we have <span class="math">f_{P}(\\phi(Q)) = \\prod_{i=1}^{2m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}</span> and since all <span class="math">x^{(j)}, y^{(j)}, \\alpha^{(j)}, \\beta^{(j)}</span> are determined up to the residue classes of <span class="math">j \\pmod{m}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} f_{P}(\\phi(Q)) &amp;amp;= \\prod_{i=1}^{m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\prod_{i=m+1}^{2m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\\\ &amp;amp;= \\prod_{i=1}^{m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\prod_{i=1}^{m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\\\ &amp;amp;= \\prod_{i=1}^{m} \\{\\alpha^{(i-1)} x^{(-i)} + \\beta^{(i-1)} + y^{(-i)} + s(\\alpha^{(i-1)} + x^{(-i)}) + t + b\\}^2 \\\\ &amp;amp;= \\prod_{i=1}^{m} \\{\\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2(\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b\\}. \\end{aligned}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient field arithmetic for the computation of <span class="math">f_{P}(\\phi(Q))</span></li>

    </ol>

    <p class="text-gray-300">The computation of <span class="math">f_{P}(\\phi(Q))</span> involves multiplications in <span class="math">\\mathbb{F}_{2^{4m}}</span>. A natural way to do this is to use a basis for <span class="math">\\mathbb{F}_{2^{4m}}</span> over <span class="math">\\mathbb{F}_{2^m}</span> and transforms a multiplication in <span class="math">\\mathbb{F}_{2^{4m}}</span> into several multiplications in <span class="math">\\mathbb{F}_{2^m}</span>. Since the extension degree is 4, we may use an optimal normal basis of type I but we will stick to the polynomial basis <span class="math">\\{1, t, t^2, t^3\\}</span> for <span class="math">\\mathbb{F}_{2^{4m}}</span> with the minimal polynomial of <span class="math">t</span> as <span class="math">X^4 + X + 1</span> over <span class="math">\\mathbb{F}_{2^m}</span>. Using <span class="math">s^2 = t^2 + t + 1</span>, we may express the element <span class="math">\\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2 (\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2 (\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b = w + zt + (z+1)t^2,</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">z = \\alpha^{(i)} + x^{(-i+1)}, \\quad w = z + \\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + b. \\tag{29}</span></div>

    <p class="text-gray-300">Letting <span class="math">C = c_0 + c_1 t + c_2 t^2 + c_3 t^3</span>, <span class="math">c_i \\in \\mathbb{F}_{2^m}</span>, be the partial product in the computation of <span class="math">f_P(\\phi(Q))</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} C \\cdot (w + zt + (z+1)t^2) &amp;amp;= (c_0 + c_1 t + c_2 t^2 + c_3 t^3)(w + zt + (z+1)t^2) \\\\ &amp;amp;= c_0&#x27; + c_1&#x27; t + c_2&#x27; t^2 + c_3&#x27; t^3, \\tag{30} \\end{aligned}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c_0&#x27; &amp;amp;= c_0 w + (c_2 + c_3)(z+1) + c_3 \\\\ c_1&#x27; &amp;amp;= c_0 w + (c_1 + c_2 + c_3) w + (c_0 + c_2 + c_3)(w + z + 1) + c_3 (z + 1) + c_0 + c_3 \\\\ c_2&#x27; &amp;amp;= c_0 w + (c_1 + c_2 + c_3) w + (c_0 + c_2 + c_3)(w + z + 1) + (c_1 + c_2)(w + z + 1) + c_1 \\\\ c_3&#x27; &amp;amp;= (c_1 + c_2 + c_3) w + (c_1 + c_2)(w + z + 1) + c_2. \\end{aligned} \\tag{31}</span></div>

    <p class="text-gray-300">Therefore one needs only 6 multiplications for the computation of <span class="math">C \\cdot (w + zt + (z+1)t^2)</span>.</p>

    <p class="text-gray-300">Table 1. An algorithm for computing <span class="math">f_{P}(\\phi(Q))</span></p>

    <p class="text-gray-300">Input: <span class="math">P = (\\alpha, \\beta), Q = (x, y)</span></p>

    <p class="text-gray-300">Output: <span class="math">C = f_{P}(\\phi(Q))</span></p>

    <p class="text-gray-300"><span class="math">C\\leftarrow 1</span> for <span class="math">(i=1</span> to <span class="math">m</span> ; <span class="math">i++</span>) <span class="math">\\alpha\\leftarrow\\alpha^{2},\\quad\\beta\\leftarrow\\beta^{2}</span> <span class="math">z\\leftarrow\\alpha+x,\\quad w\\leftarrow z+\\alpha x+\\beta+y+b</span> <span class="math">C\\leftarrow C\\cdot(w+zt+(z+1)t^{2})</span> <span class="math">x\\leftarrow x^{2^{m-1}},\\quad y\\leftarrow y^{2^{m-1}}</span> end for</p>

    <p class="text-gray-300">Assuming that we are using a normal basis for <span class="math">\\mathbb{F}_{2^{m}}</span> over <span class="math">\\mathbb{F}_{2}</span>, the Frobenius maps in Table 1 contribute a negligible cost. Moreover the map <span class="math">x\\leftarrow x^{2^{m-1}}</span> is just a left cyclic shifting by one position of the vector <span class="math">x</span> with respect to a normal basis while <span class="math">x\\leftarrow x^{2}</span> is a right cyclic shifting by one position. All these Frobenius maps are especially useful if one wants an efficient hardware implementation. If we ignore the costs of Frobenius maps and <span class="math">\\mathbb{F}_{2^{m}}</span>-additions, we find that exactly 7 <span class="math">\\mathbb{F}_{2^{m}}</span>-multiplications are needed in each round of the for-loop, where the computation of <span class="math">w</span> needs one multiplication in <span class="math">\\mathbb{F}_{2^{m}}</span> and the computation of <span class="math">C</span> needs 6 multiplications in <span class="math">\\mathbb{F}_{2^{m}}</span> by the equation (31). Compare our result with the similar result in <span class="math">\\mathbb{F}_{3^{m}}</span> case of Duursma and Lee where each step of the algorithm in <em>[3]</em> requires 17 <span class="math">\\mathbb{F}_{3^{m}}</span>-multiplications with trace computation technique <em>[2]</em> and can be reduced to 14 <span class="math">\\mathbb{F}_{3^{m}}</span>-multiplications <em>[8]</em> with loop unfolding technique.</p>

    <p class="text-gray-300">It should be mentioned that one can also use a normal basis for <span class="math">\\mathbb{F}_{2^{4m}}</span> over <span class="math">\\mathbb{F}_{2^{m}}</span> instead of using <span class="math">\\{1,t,t^{2},t^{3}\\}</span> with <span class="math">t^{4}+t+1=0</span>. Letting <span class="math">t^{3}=\\gamma</span>, one has <span class="math">\\gamma^{5}=1</span> and the minimal polynomial of <span class="math">\\gamma</span> over <span class="math">\\mathbb{F}_{2^{m}}</span> is <span class="math">X^{4}+X^{3}+X^{2}+X+1</span>. Therefore we have a normal basis <span class="math">\\{\\gamma,\\gamma^{2},\\gamma^{2^{2}},\\gamma^{2^{3}}\\}=\\{\\gamma,\\gamma^{2},\\gamma^{3},\\gamma^{4}\\}</span> of type I over <span class="math">\\mathbb{F}_{2^{m}}</span>. Using the relation <span class="math">t=\\frac{1}{t^{3}+1}=\\frac{1}{\\gamma+1}=\\gamma^{3}+\\gamma</span>, one may reformulate the equations (30) and (31) with respect to the basis <span class="math">\\{\\gamma,\\gamma^{2},\\gamma^{3},\\gamma^{4}\\}</span>. In this case, the number of necessary additions in <span class="math">\\mathbb{F}_{2^{m}}</span> slightly increases, however the expressions of the coefficients of <span class="math">C</span> in (31) have more regular patterns which are particularly useful for a hardware implementation.</p>

    <p class="text-gray-300">Computing the final powering by <span class="math">2^{2m}-1</span> is a formidable task. However in some situations like a signature verification, one only needs to determine whether <span class="math">\\tau_{l}(P,Q)=\\tau_{l}(P^{\\prime},Q^{\\prime})</span> without having to know the exact value of <span class="math">\\tau_{l}(P,Q)=f_{P}(\\phi(Q))^{2^{2m}-1}</span>. In this case, it suffices to check whether <span class="math">f_{P}(\\phi(Q))^{2^{2m}}f_{P^{\\prime}}(\\phi(Q^{\\prime}))=f_{P}(\\phi(Q))f_{P^{\\prime}}(\\phi(Q^{\\prime}))^{2^{2m}}</span> and the cost of this operation is much cheaper than the cost of the exponentiation by <span class="math">2^{2m}-1</span>. Replacing <span class="math">2^{2m}</span> by <span class="math">3^{3m}</span>, the same technique is also applicable to the Duursma-Lee algorithm <em>[3]</em>.</p>

    <h2 id="sec-6" class="text-2xl font-bold">6 Algorithms without inverse Frobenius operations for polynomial basis arithmetic in <span class="math">\\mathbb{F}_{2^{m}}</span> and <span class="math">\\mathbb{F}_{3^{m}}</span></h2>

    <p class="text-gray-300">Many computational evidence <em>[8, 20]</em> imply that a more efficient field arithmetic can be obtained for low characteristic finite fields by using a polynomial basis than a normal basis, especially for software purposes. Though a Gaussian normal basis of low complexity <em>[26]</em> is a good choice for a fast arithmetic, such basis does not appear quite frequently when compared with a polynomial basis of low hamming weight (like trinomial or pentanomial). In the case of the Tate pairing computation, the same phenomenon that a polynomial basis wins over a normal basis has been observed by Granger, Page, and Stam <em>[8]</em>. Granger et al. <em>[8]</em> showed that, even though a cube root operation (inverse Frobenius operation for characteristic three) in a polynomial basis is quite costly, an algorithm for the Tate pairing computation with a</p>

    <p class="text-gray-300">polynomial basis outperforms a method with a normal basis since one needs many operations of multiplication while only two cube root operations are needed in each step of the Duursma-Lee algorithm [3,8] and since the cost of a multiplication with a normal basis is quite expensive than that of a polynomial basis in general situations. With a small amount of precomputation, Granger et al. [8] showed that a cube root operation in <span class="math">\\mathbb{F}_{3^m}</span> has roughly the same cost as <span class="math">2/3</span> multiplication in <span class="math">\\mathbb{F}_{3^m}</span>. The same method in [8] can be applied to our characteristic two case so that we can show that the cost of one square root operation is roughly equal to the cost of <span class="math">1/2</span> multiplication with a precomputation. It should be mentioned that a general case without a precomputation is not so simple and one needs at least <span class="math">O(m^2 \\log_2 m)</span> additions in <span class="math">\\mathbb{F}_2</span> to find a square root in <span class="math">\\mathbb{F}_{2^m}</span> as is observed by Barreto et al. [2], though the complexity can be reduced to <span class="math">O(m^2)</span> additions in <span class="math">\\mathbb{F}_2</span> if we use a low weight polynomial like a trinomial or a pentanomial.</p>

    <h2 id="sec-7" class="text-2xl font-bold">6.1. Avoiding square root extraction</h2>

    <p class="text-gray-300">In this section, we briefly remark that a close examination of the algorithm in Table 1 reveals that one may derive a new algorithm for the Tate pairing computation which does not need any inverse Frobenius operation (like square root or cube root extractions). Our method is also applicable to the characteristic three case of Duursma an Lee [3] and will be explained later. Let us first study the binary case here. From Theorem 4, we know that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {P} (\\phi (Q)) = \\prod_ {i = 1} ^ {m} \\left\\{\\alpha^ {(i)} x ^ {(- i + 1)} + \\beta^ {(i)} + y ^ {(- i + 1)} + s ^ {2} \\left(\\alpha^ {(i)} + x ^ {(- i + 1)}\\right) + t ^ {2} + b \\right\\}. \\tag {32}</span></div>

    <p class="text-gray-300">We define <span class="math">A_{i}</span> as the conjugates of the terms in the product of the above formula by</p>

    <div class="my-4 text-center"><span class="math-block">A _ {i} ^ {(m - i)} = A _ {i} ^ {2 ^ {m - i}} = \\alpha^ {(i)} x ^ {(- i + 1)} + \\beta^ {(i)} + y ^ {(- i + 1)} + s ^ {2} (\\alpha^ {(i)} + x ^ {(- i + 1)}) + t ^ {2} + b</span></div>

    <p class="text-gray-300">so that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {P} (\\phi (Q)) = \\prod_ {i = 1} ^ {m} A _ {i} ^ {2 ^ {m - i}} = A _ {1} ^ {2 ^ {m - 1}} A _ {2} ^ {2 ^ {m - 2}} \\dots A _ {m} = (\\dots (((A _ {1}) ^ {2} A _ {2}) ^ {2} A _ {3}) ^ {2} \\dots) ^ {2} A _ {m}. \\tag {33}</span></div>

    <p class="text-gray-300">Since <span class="math">A_{i}</span> is in <span class="math">\\mathbb{F}_{2^{4m}}</span>, we get <span class="math">A_{i}^{(4m)} = A_{i}</span>. Therefore, using the fact <span class="math">\\alpha, \\beta, x, y \\in \\mathbb{F}_{2^m}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} A _ {i} = \\left(A _ {i} ^ {(m - i)}\\right) ^ {2 ^ {3 m + i}} = \\alpha^ {(2 i)} x ^ {(1)} + \\beta^ {(2 i)} + y ^ {(1)} + s ^ {(3 m + 1 + i)} \\left(\\alpha^ {(2 i)} + x ^ {(1)}\\right) + t ^ {(3 m + 1 + i)} + b \\tag {34} \\\\ = \\alpha^ {(2 i)} x ^ {2} + \\beta^ {(2 i)} + y ^ {2} + s ^ {(i)} (\\alpha^ {(2 i)} + x ^ {2}) + t ^ {(m - 1 + i)} + b, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">because <span class="math">s^{(j)}</span> is determined up to <span class="math">j \\pmod{2}</span> with <span class="math">3m + 1 \\equiv 0 \\pmod{2}</span> and <span class="math">t^{(j)}</span> is determined up to <span class="math">j \\pmod{4}</span> with <span class="math">3m + 1 \\equiv m - 1 \\pmod{4}</span> as is clear from the equations (24) and (26). Using the cyclic property of <span class="math">t^{(j)}</span> in the equation (26), it is not difficult to see that, for all indices <span class="math">1 \\leq i \\leq m</span>, <span class="math">A_{i}</span> can be written as <span class="math">A_{i} = A_{i}(t) = w + zt + (z + 1)t^{2}</span> for some <span class="math">z</span> and <span class="math">w</span> in <span class="math">\\mathbb{F}_{2^m}</span>. Thus, similarly as in the equations (30) and (31), one needs 6 <span class="math">\\mathbb{F}_{2^m}</span>-multiplications for computing <span class="math">C \\cdot A_{i}(t)</span> with respect to the basis <span class="math">\\{1, t, t^2, t^3\\}</span> for any <span class="math">C \\in \\mathbb{F}_{2^{4m}}</span>. We now have the following algorithm for computing <span class="math">f_{P}(\\phi(Q))</span> which avoids inverse Frobenius operations.</p>

    <p class="text-gray-300">Table 2. An algorithm for computing <span class="math">f_{P}(\\phi(Q))</span> avoiding inverse Frobenius operation</p>

    <p class="text-gray-300">Input: <span class="math">P=(\\alpha,\\beta),Q=(x,y)</span> Output: <span class="math">C=f_{P}(\\phi(Q))</span> <span class="math">C\\leftarrow 1</span> <span class="math">u\\leftarrow x^{2},\\quad v\\leftarrow x^{2},\\quad y\\leftarrow y^{2}</span> for <span class="math">(i=1</span> to <span class="math">m</span> ; <span class="math">i++)</span> <span class="math">\\alpha\\leftarrow\\alpha^{4},\\quad\\beta\\leftarrow\\beta^{4}</span> <span class="math">A(t)\\leftarrow\\alpha(v+1)+u+\\beta+y+b+\\frac{m-1}{2}+(\\alpha+v)t+(\\alpha+v+1)t^{2}</span> <span class="math">C\\leftarrow C^{2}\\cdot A(t)</span> <span class="math">u\\leftarrow u+v+1,\\quad v\\leftarrow v+1</span> end for</p>

    <p class="text-gray-300">Note that the coefficients of <span class="math">A_{i}(t)</span> depend on the values of <span class="math">s^{(i)}</span> and <span class="math">t^{(m-1+i)}</span> and they are recursively computed by the relation (24) and (26). We have the initial values <span class="math">s^{(1)}=s^{2}=t^{2}+t+1</span> and <span class="math">t^{(m)}=t^{2}+\\frac{m-1}{2}</span> and thus we get</p>

    <p class="text-gray-300"><span class="math">A_{1}(t)</span> <span class="math">=\\alpha x+\\beta+y+(t^{2}+t+1)(\\alpha+x)+t^{2}+\\frac{m-1}{2}+b</span> <span class="math">=\\alpha(x+1)+x+\\beta+y+b+\\frac{m-1}{2}+(\\alpha+x)t+(\\alpha+x+1)t^{2},</span> <span class="math">A_{2}(t)</span> <span class="math">=\\alpha x+\\beta+y+(t^{2}+t)(\\alpha+x)+t+1+\\frac{m-1}{2}+b</span> <span class="math">=\\alpha x+1+\\beta+y+b+\\frac{m-1}{2}+(\\alpha+x+1)t+(\\alpha+x)t^{2},</span> <span class="math">A_{3}(t)</span> <span class="math">=\\alpha(x+1)+(x+1)+\\beta+y+b+\\frac{m-1}{2}+(\\alpha+x)t+(\\alpha+x+1)t^{2},</span> <span class="math">A_{4}(t)</span> <span class="math">=\\alpha x+\\beta+y+b+\\frac{m-1}{2}+(\\alpha+x+1)t+(\\alpha+x)t^{2}.</span></p>

    <p class="text-gray-300">Using the intermediate values <span class="math">u,v</span> with the relations <span class="math">u\\leftarrow u+v+1,\\ v\\leftarrow v+1</span>, the pair covers all the possible values <span class="math">(u,v)=(x,x),(1,x+1),(x+1,x),(0,x+1)</span> and the algorithm in Table 2 is justified. In each step of the above algorithm, one needs 7 <span class="math">\\mathbb{F}_{2^{m}}</span>-multiplications which is same to the algorithm in Table 1. Since the operation <span class="math">C\\leftarrow C^{2}</span> needs 4 squaring operations in <span class="math">\\mathbb{F}_{2^{m}}</span> and since the operations <span class="math">\\alpha\\leftarrow\\alpha^{4}</span>, <span class="math">\\beta\\leftarrow\\beta^{4}</span> need the same 4 squaring operations, the total number of necessary squaring is 8 in this new algorithm. On the other hand, the algorithm in Table 1 needs 2 squaring and 2 square root operations. Therefore our new algorithm in Table 2 is a more optimal choice if one is interested in the implementation with a polynomial basis since this new algorithm uses 6 Frobenius operations instead of using 2 inverse Frobenius operations.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">6.2 Avoiding cube root extraction from the algorithm of Duursma and Lee</h3>

    <p class="text-gray-300">Duursma and Lee <em>[3]</em> found a close formula for the following supersingular elliptic curves defined over <span class="math">\\mathbb{F}_{3^{m}}</span> with <span class="math">m</span> prime to 6,</p>

    <p class="text-gray-300"><span class="math">E_{b}:Y^{2}=X^{3}-X+b,\\quad b=\\pm 1.</span> (35)</p>

    <p class="text-gray-300">For the above mentioned curves, the following distortion map (nontrivial automorphism) is used,</p>

    <p class="text-gray-300"><span class="math">\\phi:E_{b}\\longrightarrow E_{b},\\quad\\text{with}\\quad\\phi(x,y)=(\\rho-x,\\sigma y),</span> (36)</p>

    <p class="text-gray-300">where <span class="math">\\sigma^{2}+1=0</span> and <span class="math">\\rho^{3}-\\rho-b=0</span>. That is, <span class="math">\\mathbb{F}_{3}(\\sigma)=\\mathbb{F}_{3^{2}}</span> and <span class="math">\\mathbb{F}_{3}(\\rho)=\\mathbb{F}_{3^{3}}</span>. A closed formula of Duursma and Lee says that, for <span class="math">P=(\\alpha,\\beta)</span> and <span class="math">Q=(x,y)</span> in <span class="math">E<a href="\\mathbb{F}_{3^{m}}">l</a></span>, the Tate pairing</p>

    <p class="text-gray-300">can be written as <span class="math">\\tau_{l}(P,Q) = f_{P}(\\phi(Q))^{3^{3m} - 1}</span> where</p>

    <div class="my-4 text-center"><span class="math-block">f _ {P} (\\phi (Q)) = \\prod_ {i = 1} ^ {m} \\left\\{- \\sigma \\beta^ {(i)} y ^ {(- i + 1)} - \\left(\\alpha^ {(i)} + x ^ {(- i + 1)} - \\rho + b\\right) ^ {2} \\right\\}, \\tag {37}</span></div>

    <p class="text-gray-300">and <span class="math">f_{P}</span> is a rational function satisfying <span class="math">(f_{P}) = (3^{3m} + 1)\\{(P) - (O)\\}</span>. Now define the intermediate values <span class="math">\\mu</span> and <span class="math">\\lambda</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\mu = \\alpha^ {(i)} + x ^ {(- i + 1)} + b \\in \\mathbb {F} _ {3 ^ {m}} \\quad \\mathrm {a n d} \\quad \\lambda = - \\sigma \\beta^ {(i)} y ^ {(- i + 1)} - \\mu^ {2} \\in \\mathbb {F} _ {3 ^ {2 m}}.</span></div>

    <p class="text-gray-300">Then the formula (37) to compute <span class="math">f_{P}(\\phi(Q))</span> is realized by the following algorithm [2,3,8].</p>

    <p class="text-gray-300">Table 3. Duursma-Lee algorithm for computing <span class="math">f_{P}(\\phi(Q))</span></p>

    <p class="text-gray-300">|  Input: <span class="math">P = (\\alpha, \\beta), Q = (x, y)</span>  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Output: <span class="math">C = f_P(\\phi(Q))</span>  |</p>

    <p class="text-gray-300">|  <span class="math">C \\gets 1</span>  |</p>

    <p class="text-gray-300">|  for <span class="math">(i = 1</span> to <span class="math">m</span>; <span class="math">i + +</span>)  |</p>

    <p class="text-gray-300">|  <span class="math">\\alpha \\gets \\alpha^3</span>, <span class="math">\\beta \\gets \\beta^3</span>  |</p>

    <p class="text-gray-300">|  <span class="math">\\mu = \\alpha + x + b</span>, <span class="math">\\lambda = -\\sigma\\beta y - \\mu^2</span>  |</p>

    <p class="text-gray-300">|  <span class="math">C \\gets C \\cdot (\\lambda - \\mu\\rho - \\rho^2)</span>  |</p>

    <p class="text-gray-300">|  <span class="math">x \\gets x^{1/3}</span>, <span class="math">y \\gets y^{1/3}</span>  |</p>

    <p class="text-gray-300">|  end for  |</p>

    <p class="text-gray-300">One needs 2 cube root operations in each step of the above algorithm. However it is not so difficult, by using the same technique of the previous section, to show that one can have a new algorithm where 2 cube root operations (inverse Frobenius) are replaced by 8 cube operations (Frobenius) without affecting the number of multiplications in <span class="math">\\mathbb{F}_{3^m}</span>, which are quite useful in polynomial basis arithmetic. Let us define <span class="math">A_i \\in \\mathbb{F}_{3^{6m}}</span> as the conjugates of the terms in the product formula (37) by</p>

    <div class="my-4 text-center"><span class="math-block">A _ {i} ^ {(m - i)} = A _ {i} ^ {3 ^ {m - i}} = - \\sigma \\beta^ {(i)} y ^ {(- i + 1)} - \\left(\\alpha^ {(i)} + x ^ {(- i + 1)} - \\rho + b\\right) ^ {2} \\tag {38}</span></div>

    <p class="text-gray-300">so that</p>

    <div class="my-4 text-center"><span class="math-block">f _ {P} (\\phi (Q)) = \\prod_ {i = 1} ^ {m} A _ {i} ^ {3 ^ {m - i}} = A _ {1} ^ {3 ^ {m - 1}} A _ {2} ^ {3 ^ {m - 2}} \\dots A _ {m} = (\\dots ((A _ {1}) ^ {3} A _ {2}) ^ {3} A _ {3}) ^ {3} \\dots) ^ {3} A _ {m}. \\tag {39}</span></div>

    <p class="text-gray-300">Since <span class="math">A_{i}</span> is in <span class="math">\\mathbb{F}_{3^{6m}}</span>, we get <span class="math">A_{i}^{(6m)} = A_{i}</span>. From the equation (38), using the fact <span class="math">\\alpha, \\beta, x, y \\in \\mathbb{F}_{3^m}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} A _ {i} = \\left(A _ {i} ^ {(m - i)}\\right) ^ {3 ^ {5 m + i}} = - \\sigma^ {(5 m + i)} \\beta^ {(2 i)} y ^ {(1)} - \\left(\\alpha^ {(2 i)} + x ^ {(1)} - \\rho^ {(5 m + i)} + b\\right) ^ {2} \\tag {40} \\\\ = (- 1) ^ {i + 1} \\sigma \\beta^ {(2 i)} y ^ {(1)} - (\\alpha^ {(2 i)} + x ^ {(1)} - \\rho + (m + 1 - i) b) ^ {2}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">because the relations <span class="math">\\sigma^2 + 1 = 0</span>, <span class="math">\\rho^3 - \\rho - b = 0</span> imply</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma^ {(j)} = (- 1) ^ {j} \\sigma \\quad \\text {and} \\quad \\rho^ {(j)} = \\rho + j b. \\tag {41}</span></div>

    <p class="text-gray-300"><span class="math">A_{i}=\\lambda-\\mu\\rho-\\rho^{2}.</span> (41)</p>

    <p class="text-gray-300">Therefor the modified algorithm is given as follows.</p>

    <p class="text-gray-300">Table 4. A modified Duursma-Lee algorithm without cube root operations</p>

    <p class="text-gray-300">Input: <span class="math">P=(\\alpha,\\beta),Q=(x,y)</span></p>

    <p class="text-gray-300">Output: <span class="math">C=f_{P}(\\phi(Q))</span></p>

    <p class="text-gray-300"><span class="math">C\\leftarrow 1</span></p>

    <p class="text-gray-300"><span class="math">x\\leftarrow x^{3},\\quad y\\leftarrow y^{3},\\quad d\\leftarrow mb</span></p>

    <p class="text-gray-300">for (<span class="math">i=1</span> to <span class="math">m</span> ; <span class="math">i++</span>)</p>

    <p class="text-gray-300"><span class="math">\\alpha\\leftarrow\\alpha^{9},\\quad\\beta\\leftarrow\\beta^{9}</span></p>

    <p class="text-gray-300"><span class="math">\\mu=\\alpha+x+d,\\quad\\lambda=\\sigma\\beta y-\\mu^{2}</span></p>

    <p class="text-gray-300"><span class="math">C\\leftarrow C^{3}\\cdot(\\lambda-\\mu\\rho-\\rho^{2})</span></p>

    <p class="text-gray-300"><span class="math">y\\leftarrow-y,\\quad d\\leftarrow d-b</span></p>

    <p class="text-gray-300">end for</p>

    <p class="text-gray-300">In each step of the above algorithm, the number of necessary multiplications in <span class="math">\\mathbb{F}_{3^{m}}</span> is same to that of the algorithm in Table 3. Since the cube operation <span class="math">C\\leftarrow C^{3}</span> with respect to the basis <span class="math">\\{1,\\rho,\\rho^{2}\\}</span> over <span class="math">\\mathbb{F}_{3^{2m}}</span> costs 6 cube operations in <span class="math">\\mathbb{F}_{3^{m}}</span> and since the operations <span class="math">\\alpha\\leftarrow\\alpha^{9}</span>, <span class="math">\\beta\\leftarrow\\beta^{9}</span> cost 4 cube operations in <span class="math">\\mathbb{F}_{3^{m}}</span>, the total number of necessary Frobenius operations in each step of the above algorithm is 10. Note that the Duursma-Lee algorithm in Table 3 needs 2 Frobenius operations plus 2 inverse Frobenius operations. Therefore our modified algorithm uses 8 Frobenius operations instead of using 2 inverse Frobenius operations. In a polynomial basis, it is safe to believe <em>[8]</em> that the cost of 4 cube operations is cheaper than the cost of one cube root operation.</p>

    <p class="text-gray-300">It should be mentioned that our technique of avoiding inverse Frobenius operations can also be applied to the refined algorithm of Granger et al. <em>[9]</em>, where the for-loop in Table 3 is unrolled so that it has <span class="math">\\frac{m-1}{2}</span> steps and a multiplication of two <span class="math">\\lambda-\\mu\\rho-\\rho^{2}</span> is executed before being multiplied to the partial product <span class="math">C</span>. The only thing we have to do is to redefine <span class="math">A_{i}</span> in the equation (39) appropriately so that the multiplication <span class="math">A_{i}A_{i+1}</span> is performed before being multiplied to <span class="math">C</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Tate pairing computation for <span class="math">Y^{2}+Y=X^{3}</span></li>

    </ol>

    <p class="text-gray-300">Among the three isomorphism classes of supersingular elliptic curves over a binary field <span class="math">\\mathbb{F}_{2^{m}}</span> with <span class="math">m=odd</span>, <span class="math">E_{b}:Y^{2}+Y=X^{3}+X+b</span>, <span class="math">b=0,1</span> and <span class="math">E:Y^{2}+Y=X^{3}</span>, the curve <span class="math">Y^{2}+Y=X^{3}</span> has the embedding degree <span class="math">k=2</span>. Though the curve <span class="math">Y^{2}+Y=X^{3}</span> is not so interesting in terms of the bandwidth, i.e. the imbedding degree <span class="math">k=2</span>, we will discuss a method of efficient Tate pairing computation with a closed formula. Note that a similar formula (like the cases of characteristic two and three) is not available for a prime field <span class="math">\\mathbb{F}_{p}</span> with <span class="math">p\\neq 2,3</span> and one has the same embedding degree <span class="math">k=2</span> for this prime field case. Although the curve <span class="math">E:Y^{2}+Y=X^{3}</span> is not discussed by Barreto et al. in the BKLS algorithm <em>[1]</em>, we will show that a similar technique about the irrelevant denominators is also applicable for this curve. It seems that this technique is applicable to quite a many class of elliptic curves with nontrivial automorphisms over low characteristic finite fields.</p>

    <p class="text-gray-300">Let <span class="math">P=(\\alpha,\\beta)</span> be a point on the curve <span class="math">E:Y^{2}+Y=X^{3}</span>. Then one has <span class="math">-P=(\\alpha,\\beta+1)</span> and <span class="math">2P=(\\alpha^{4},\\beta^{4}+1)=-\\varphi^{2}(P)</span>. Thus we get</p>

    <p class="text-gray-300"><span class="math">2^{2}P=(\\alpha^{2^{4}},\\beta^{2^{4}})=\\varphi^{4}(P),</span></p>

    <p class="text-gray-300">where <span class="math">\\varphi^{4}-4=0</span>, i.e. <span class="math">h(X)=X^{2}+2</span> divides <span class="math">X^{4}-4</span>. Using this property, it is easy to show inductively</p>

    <p class="text-gray-300"><span class="math">2^{i-1}P=(\\alpha^{2^{2i-2}},\\beta^{2^{2i-2}}+i-1)=(\\alpha^{(2i-2)},\\beta^{(2i-2)}+i-1).</span> (43)</p>

    <p class="text-gray-300">For an effective Tate pairing computation, we will use the following distortion map (nontrivial automorphism) for <span class="math">E</span>,</p>

    <p class="text-gray-300"><span class="math">\\phi:E\\longrightarrow E,\\quad\\text{with}\\quad\\phi(x,y)=(x+1,y+x+t),</span> (44)</p>

    <p class="text-gray-300">where <span class="math">t\\in\\mathbb{F}_{2^{2}}</span> with <span class="math">t^{2}+t+1=0</span>. It is clear that the proposed map <span class="math">\\phi</span> is an automorphism since the following equality can be easily checked,</p>

    <p class="text-gray-300"><span class="math">(y+x+t)^{2}+(y+x+t)=(x+1)^{3}.</span> (45)</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">With the above distortion map, the line <span class="math">X-u</span> intersecting <span class="math">R=(u,v)</span> and <span class="math">-R=(u,v+1)</span> with <span class="math">R\\in E(\\mathbb{F}_{2^{m}})</span> can be omitted without altering the pairing value.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The line <span class="math">X-u</span> evaluated at the point <span class="math">\\phi(Q)</span> with <span class="math">Q=(x,y)\\in E(\\mathbb{F}_{2^{m}})</span> is <span class="math">x+1-u</span>. By applying the final powering by <span class="math">\\frac{2^{2m}-1}{l}=(2^{m}-1)\\frac{(2^{m}+1)}{l}</span>, one has <span class="math">(x+1-u)^{\\frac{2^{2m}-1}{l}}=1</span> because <span class="math">x,u\\in\\mathbb{F}_{2^{m}}</span> and <span class="math">l</span> divides $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{2^{m}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{m}+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Let <span class="math">P=(\\alpha,\\beta),Q=(x,y)</span> be points in <span class="math">E(\\mathbb{F}_{2^{m}})</span> with <span class="math">E:Y^{2}+Y=X^{3}</span>. Then one has the value of <span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{m-i}}=\\{g_{2^{i-1}P}(x+1,y+x+t)\\}^{2^{m-i}}</span> as</p>

    <p class="text-gray-300"><span class="math">\\{g_{2^{i-1}P}(x+1,y+x+t)\\}^{2^{m-i}}=\\alpha^{(i-1)}x^{(-i)}+(\\alpha+\\beta)^{(i-1)}+(x+y)^{(-i)}+t.</span></p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The tangent line at <span class="math">P=(\\alpha,\\beta)</span> on the curve <span class="math">E:Y^{2}+Y=X^{3}</span> is <span class="math">Y=\\alpha^{2}X+\\beta^{2}</span>. Thus we have <span class="math">g_{P}(x,y)=\\alpha^{2}x+\\beta^{2}-y</span> and using the equation (43), we get</p>

    <p class="text-gray-300"><span class="math">g_{2^{i-1}P}(x+1,y+x+t)=\\alpha^{(2i-1)}(x+1)+\\beta^{(2i-1)}+i-1-(y+x+t).</span> (46)</p>

    <p class="text-gray-300">Taking <span class="math">2^{m-i}</span>-th power of the both sides of the above equality,</p>

    <p class="text-gray-300"><span class="math">\\{g_{2^{i-1}P}(x+1,y+x+t)\\}^{2^{m-i}}=\\alpha^{(i-1)}(x^{(-i)}+1)+\\beta^{(i-1)}+i-1-(y^{(-i)}+x^{(-i)}+t^{(m-i)}).</span> (47)</p>

    <p class="text-gray-300">Since <span class="math">t^{(1)}=t^{2}=t+1</span>, one has <span class="math">t^{(2)}=t^{4}=t,t^{(3)}=t+1,t^{(4)}=t,\\cdots.</span> That is,</p>

    <p class="text-gray-300"><span class="math">t^{(j)}=t+j,</span> (48)</p>

    <p class="text-gray-300">for any <span class="math">j</span> because we are in the field with characteristic two. Thus we have <span class="math">t^{(m-i)}=t+m-i</span> in the equation (47) and therefore</p>

    <p class="text-gray-300"><span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{m-i}}</span> <span class="math">=\\alpha^{(i-1)}(x^{(-i)}+1)+\\beta^{(i-1)}+i-1-(y^{(-i)}+x^{(-i)}+t+m-i)</span> <span class="math">=\\alpha^{(i-1)}x^{(-i)}+(\\alpha+\\beta)^{(i-1)}+(x+y)^{(-i)}+t.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">One has the Tate pairing <span class="math">\\tau_{l}(P,Q)=f_{P}(\\phi(Q))^{2^{m}-1}</span> where</p>

    <p class="text-gray-300"><span class="math">f_{P}(\\phi(Q))=\\prod_{i=1}^{m}\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{m-i}}=\\prod_{i=1}^{m}\\{\\alpha^{(i-1)}x^{(-i)}+(\\alpha+\\beta)^{(i-1)}+(x+y)^{(-i)}+t\\},</span></p>

    <p class="text-gray-300">and <span class="math">f_{P}</span> is a rational function satisfying <span class="math">(2^{m}+1)\\{(P)-(O)\\}</span>.</p>

    <p class="text-gray-300">One may derive the same algorithms as in Table 1 and 2 for this case also but we omit them here since the method is pretty straightforward.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Conclusions</li>

    </ol>

    <p class="text-gray-300">In this paper we showed that an efficient closed formula can be derived for the Tate pairing computation for supersingular elliptic curves over a binary field <span class="math">\\mathbb{F}_{2^{m}}</span> of odd dimension. There are exactly three isomorphism classes of supersingular elliptic curves over <span class="math">\\mathbb{F}_{2^{m}}</span> with <span class="math">m</span> odd and our method is applicable to all these curves. Each step of our algorithm requires two inverse Frobenius operations like the characteristic three case of Duursma and Lee. To overcome the computational complexity of the inverse Frobenius operation in a polynomial basis, we modified our algorithm and the algorithm of Duursma and Lee, and presented another closed formula which does not need any inverse Frobenius operation, which is especially useful for polynomial basis arithmetic.</p>

    <p class="text-gray-300">References</p>

    <p class="text-gray-300">[1] P. Barreto, H. Kim, B. Lynn, and M. Scott, “Efficient algorithms for pairing based cryptosystems,” <em>Crypto 2002, Lecture Notes in Computer Science</em>, vol. 2442, pp. 354–368, 2002.</p>

    <p class="text-gray-300">[2] M. Scott and P. Barreto, “Compressed pairings,” <em>Crypto 2004, Lecture Notes in Computer Science</em>, to appear, 2004.</p>

    <p class="text-gray-300">[3] I. Duursma and H. Lee, “Tate pairing implementation for hyperelliptic curves <span class="math">y^{2}=x^{p}-x+d</span>,” <em>Asiacrypt 2003, Lecture Notes in Computer Science</em>, vol. 2894, pp. 111–123, 2003.</p>

    <p class="text-gray-300">[4] S. Galbraith, “Supersingular curves in cryptography,” <em>Asiacrypt 2001, Lecture Notes in Computer Science</em>, vol. 2248, pp. 495–513, 2001.</p>

    <p class="text-gray-300">[5] S. Galbraith, K. Harrison, and D. Soldera, “Implementing the Tate pairing,” <em>ANTS 2002, Lecture Notes in Computer Science</em>, vol. 2369, pp. 324–337, 2002.</p>

    <p class="text-gray-300">[6] F. Hess, “A Note on the Tate pairing of curves over finite fields,” <em>Arch. Math.</em> vol. 82, pp. 28–32, 2004.</p>

    <p class="text-gray-300">[7] F. Hess, “Efficient identity based signature schemes based on pairings,” <em>SAC 2002, Lecture Notes in Computer Science</em>, vol. 2595, 310-324, 2003.</p>

    <p class="text-gray-300">[8] R. Granger, D. Page, and M. Stam, “Hardware and software normal basis arithmetic for pairing based cryptography in characteristic three,” preprint, <em>available at</em> http://eprint.iacr.org/2004/157.pdf, 2004.</p>

    <p class="text-gray-300">[9] R. Granger, D. Page, and M. Stam, “On small characteristic algebraic tori in pairing based cryptography,” preprint <em>available at</em> http://eprint.iacr.org/2004/132.pdf, 2004.</p>

    <p class="text-gray-300">[10] D. Boneh and M. Franklin, “Identity based encryption from the Weil pairing,” <em>Crypto 2001, Lecture Notes in Computer Science</em>, vol. 2139, pp. 213–229, 2001.</p>

    <p class="text-gray-300">[11] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from the Weil pairing,” <em>Asiacrypt 2001, Lecture Notes in Computer Science</em>, vol. 2248, pp. 514–532, 2002.</p>

    <p class="text-gray-300">[12] A. Joux, “A one round protocol for tripartite Diffie-Hellman,” <em>ANTS 2000, Lecture Notes in Computer Science</em>, vol. 1838, pp. 385–394, 2000.</p>

    <p class="text-gray-300">[13] K. Eisenträger, K. Lauter, and P.L. Montgomery, “Improved Weil and Tate pairing for elliptic and hyperelliptic curves,” preprint, 2004.</p>

    <p class="text-gray-300">[14] J.H. Silverman, The Arithmetic of Elliptic Curves, Springer-Verlag, 1985.</p>

    <p class="text-gray-300">[15] A.J. Menezes, Elliptic Curve Public Key Cryptosystems, Kluwer Academic Publisher, 1993.</p>

    <p class="text-gray-300">[16] A.J. Menezes, T. Okamoto, and S.A. Vanstone, “Reducing elliptic curve logarithms to logarithms in a finite field,” IEEE Trans. Information Theory, vol. 39, pp. 1639–1646, 1993.</p>

    <p class="text-gray-300">[17] G. Frey and H. Rück, “A remark concerning <span class="math">m</span>-divisibility and the discrete logarithm in the divisor class groups of curves,” Math. Comp., vol. 62, pp. 865–874, 1994.</p>

    <p class="text-gray-300">[18] E.R. Verheul, “Evidence that XTR is more secure than supersingular elliptic curve cryptosystems,” Eurocrypt 2001, Lecture Notes in Computer Science, vol. 2045, pp. 195–210, 2001.</p>

    <p class="text-gray-300">[19] V. Miller, “Short programs for functions on curves,” unpublished manuscript, 1986.</p>

    <p class="text-gray-300">[20] D. Hankerson, J.L. Hernandez, and A.J. Menezes, “Software implementation of elliptic curve cryptography over binary fields,” CHES 2000, Lecture Notes in Computer Science, vol. 1965, pp. 1–24 , 2000.</p>

    <p class="text-gray-300">[21] N. Koblitz, A. Menezes, and S. Vanstone, “The state of elliptic curve cryptography,” Design, Codes and Cryptography, vol. 19, pp. 173–193, 2000.</p>

    <p class="text-gray-300">[22] P. Gaudry, F. Hess, and N.P. Smart, “Constructive and destructive facets of Weil descent on elliptic curves,” J. of Cryptology, vol. 15, pp. 19–46, 2002.</p>

    <p class="text-gray-300">[23] A. Miyaji, M. Nakabayashi, and S. Takano, “New explicit conditions of elliptic curve trace for FR-reduction,” IEICE Trans. Fundamentals, vol. E84 A, pp. 1–10, 2001.</p>

    <p class="text-gray-300">[24] R. Sakai, K. Ohgishi, and M. Kasahara, “Cryptosystems based on pairing,” SICS 2000, Symposium on Cryptography and Information Security, pp. 26–28, 2000.</p>

    <p class="text-gray-300">[25] N.P. Smart, “An identity based authentication key agreement protocol based on pairing,” Electronics Letters, vol. 38, pp. 630–632, 2002.</p>

    <p class="text-gray-300">[26] S. Gao, J. von zur Gathen, and D. Panario, “Gauss periods and fast exponentiation in finite fields,” Latin 1995, Lecture Notes in Computer Science, vol. 911, pp. 311–322, 1995.</p>

    <p class="text-gray-300">[27] K. Rubin and A. Silverberg “Torus based cryptography,” Crypto 2003, Lecture Notes in Computer Science, vol. 2729, pp. 349–365, 2003.</p>`;
---

<BaseLayout title="Efficient Tate Pairing Computation for Supersingular Ellipti... (2004/303)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/303
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
