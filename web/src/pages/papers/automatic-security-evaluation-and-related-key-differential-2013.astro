---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/676';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Automatic Security Evaluation and (Related-key) Differential Characteristic Search: Application to SIMON, PRESENT, LBlock, DES(L) and Other Bit-oriented Block Ciphers';
const AUTHORS_HTML = 'Siwei Sun, Lei Hu, Peng Wang, Kexin Qiao, Xiaoshuang Ma, Ling Song';

const CONTENT = `    <p class="text-gray-300">Automatic Security Evaluation and (Related-key) Differential Characteristic Search: Application to SIMON, PRESENT, LBlock, DES(L) and Other Bit-oriented Block Ciphers</p>

    <p class="text-gray-300">Siwei Sun^{1,2}, Lei Hu^{1,2}, Peng Wang^{1,2}, Kexin Qiao^{1,2}, Xiaoshuang Ma^{1,2}, Ling Song^{1,2}</p>

    <p class="text-gray-300">^{1}State Key Laboratory of Information Security, Institute of Information Engineering, Chinese Academy of Sciences, Beijing 100093, China ^{2}Data Assurance and Communication Security Research Center, Chinese Academy of Sciences, Beijing 100093, China {sunsiwei,hulei,wpeng,qiaokexin,maxiaoshuang,songling}@iie.ac.cn</p>

    <p class="text-gray-300">Abstract. We propose two systematic methods to describe the differential property of an S-box with linear inequalities based on logical condition modelling and computational geometry respectively. In one method, inequalities are generated according to some conditional differential properties of the S-box; in the other method, inequalities are extracted from the H-representation of the convex hull of all possible differential patterns of the S-box. For the second method, we develop a greedy algorithm for selecting a given number of inequalities from the convex hull. Using these inequalities combined with Mixed-integer Linear Programming (MILP) technique, we propose an automatic method for evaluating the security of bit-oriented block ciphers against the (related-key) differential attack, and several techniques for obtaining tighter security bounds. We successfully prove that the 24-round PRESENT-80 is secure enough to resist against standard related-key differential attacks based on differential characteristic, and the probability of the best related-key differential characteristic of the full LBlock is upper bounded by <span class="math">2^{-60}</span>. These are the tightest security bounds with respect to the related-key differential attack published so far for PRESENT-80 and LBlock.</p>

    <p class="text-gray-300">Moreover, we present a new tool for finding (related-key) differential characteristics automatically for bit-oriented block ciphers. Using this tool, we obtain new single-key or related-key differential characteristics for SIMON48, LBlock, DESL and PRESENT-128, which cover larger number of rounds or have larger probability than all previously known results. The methodology presented in this paper is generic, automatic and applicable to many bit-oriented block ciphers.</p>

    <p class="text-gray-300">Keywords: Automatic cryptanalysis, Related-key differential attack, Mixed-integer Linear Programming, Convex hull</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Differential cryptanalysis is one of the most well-known attacks on modern block ciphers, based on which a whole bunch of cryptanalytic techniques has been developed, such as truncated differential attack <em>[40]</em>, impossible differential attack <em>[10]</em>, and boomerang attack <em>[63]</em>. Providing a security evaluation with respect to the differential attack has become a basic requirement for a newly designed practical block cipher to be accepted by the cryptographic community.</p>

    <p class="text-gray-300">Contrary to the single-key model, where methodologies for constructing block ciphers provably resistant to differential attacks are readily available, the understanding of the security of block ciphers with regard to related-key differential attacks is relatively limited. This situation can be seen from the fact that even internationally standardized block ciphers such as AES and PRESENT enjoy no security proof at all for related-key differential attacks at the time of their publication. This limited understanding of the security concerning related-key differential attacks has been greatly improved in recent years for AES-like byte- or word-oriented SPN block ciphers. Along this line of research, two representative papers <em>[11, 27]</em> were published in Eurocrypt 2010 and Crypto 2013. In the former paper <em>[11]</em>, an efficient search tool for finding differential characteristics both in the state and in the key was presented, and the best differential characteristics were obtained for some byte-oriented block ciphers such as AES, byte-Camellia, and Khazad. In the latter paper <em>[27]</em>, Pierre-Alain Fouque et al. showed that the full-round AES-128 can not be proven secure against differential attacks in the related-key model unless the exact coefficients of the MDS matrix and the S-Box differential properties are taken into account. Moreover, a variant of Dijkstra’s shortest path algorithm for finding the most efficient related-key attacks on SPN ciphers was developed in <em>[27]</em>. In <em>[32]</em>, Ivica Nikolic presented a tweak for the</p>

    <p class="text-gray-300">key schedule of AES and the new cipher called xAES is resistant against the related-key differential attacks found in AES.</p>

    <p class="text-gray-300">For bit-oriented block ciphers such as PRESENT-80 and DES, Sareh Emami et al. proved that no related-key differential characteristic exists with probability higher than <span class="math">2^{-64}</span> for the full-round PRESENT-80, and therefore argue that PRESENT-80 is secure against basic related-key differential attacks <em>[24]</em>. In <em>[58]</em>, Sun et al. obtained tighter security bounds for PRESENT-80 with respect to the related-key differential attacks using the MILP technique. Alex Biryukov and Ivica Nikolić proposed two methods <em>[12]</em> based on Matsui’s tool <em>[49]</em> for finding related-key differential characteristics for DES-like ciphers. For their methods, they stated that</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“… our approaches can be used as well to search for high probability related-key differential characteristics in any bit-oriented ciphers with linear key schedule.”</p>
    </blockquote>

    <p class="text-gray-300">Sareh Emami et al. <em>[24]</em> and Sun et al.’s method <em>[58]</em> can not be used to search for actual (related-key) differential characteristics, and Alex Biryukov et al.’s method <em>[12]</em> is only applicable to ciphers with linear key schedule.</p>

    <p class="text-gray-300">In this paper, we provide a method based on Mixed-Integer Linear Programming which can not only evaluate the security (obtain security bound) of a block cipher with respect to the (related-key) differential attacks, but is also able to search for actual (related-key) differential characteristics even if the key schedule algorithm of the block cipher is nonlinear.</p>

    <p class="text-gray-300">Mixed-Integer Linear Programming (MILP). The problem of Mixed Integer Linear Programming (MILP) is a class of optimization problems derived from Linear Programming in which the aim is to optimize an objective function under certain constraints. The field of MILP has received extensive study and achieved great success in both academic and industrial worlds. A Mixed Integer Linear Programming problem can be formally described as follows.</p>

    <p class="text-gray-300">MILP: Find a vector <span class="math">x\\in\\mathbb{Z}^{k}\\times\\mathbb{R}^{n-k}\\subseteq\\mathbb{R}^{n}</span> with <span class="math">Ax\\leq b</span>, such that the linear function <span class="math">c_{1}x_{1}+c_{2}x_{2}+\\dots+c_{n}x_{n}</span> is minimized (or maximized), where <span class="math">(c_{1},\\dots,c_{n})\\in\\mathbb{R}^{n}</span>, <span class="math">A\\in\\mathbb{R}^{m\\times n}</span>, and <span class="math">b\\in\\mathbb{R}^{m}</span>.</p>

    <p class="text-gray-300">Despite its intimate relationship with discrete optimization problems, such as the set covering problem, 0-1 knapsack problem, and traveling salesman problem, it is only in recent years that MILP has been explicitly applied in cryptographic research <em>[1, 6, 18, 19, 42, 53, 64, 71]</em>.</p>

    <p class="text-gray-300">In this paper, we are mainly concerned with the application of MILP method in the (related-key) differential cryptanalysis. Roughly speaking, differential attack <em>[8]</em> is a cryptanalysis technique used to discover non-random behavior of a cipher by analyzing the input and output difference of the cipher. A practical approach to evaluate the security of a cipher against differential attack is to determine the lower bound of the number of active S-boxes throughout the cipher. This strategy has been employed in many designs <em>[4, 9, 16, 17, 21]</em>. MILP was applied in automatically determining the lower bounds of the numbers of active S-boxes for some word-oriented symmetric-key ciphers, and therefore used to prove their security against differential cryptanalysis <em>[15, 51, 68]</em> . Laura Winnen <em>[67]</em> and Sun et al. <em>[58]</em> extended this method by making it applicable to ciphers involving bit-oriented operations. We notice that such MILP tools <em>[15, 51, 58, 68]</em> for counting the minimum number of active S-boxes are also applied or mentioned in the design and analysis of some authenticated encryption schemes <em>[9, 22, 23, 35, 36, 37, 69, 72]</em>.</p>

    <p class="text-gray-300">Our Contributions. We find that the constraints presented in <em>[58]</em> are too coarse (and some of these constraints are redundant in some specific case) to accurately describe the differential properties of a specific cipher, since there are a large number of invalid differential patterns of the cipher satisfying all these constraints, which yields a feasible region of the MILP problem much larger than the set of all valid differential characteristics.</p>

    <p class="text-gray-300">In this paper, we propose two methods to tighten the feasible region by cutting off some impossible differential patterns of a specific S-box with linear inequalities: one method is based on logical condition modeling, and the other is a more general approach based on convex hull computation — a fundamental algorithmic problem in computational geometry. In the first method, typically less than 15 inequalities are generated according to some conditional differential properties of the S-box; while in the second method, several hundreds of inequalities are extracted from the H-representation of the convex hull of all possible differential patterns of the S-box.</p>

    <p class="text-gray-300">However, the second approach produces too many inequalities so that adding all of them to an MILP problem will make the solving process impractical. Therefore, we develop a greedy algorithm for selecting a given number of linear inequalities from the convex hull.</p>

    <p class="text-gray-300">By adding all or a part of the constraints generated by these methods, we provide MILP based methods for evaluating the security of a block cipher with respect to the (related-key) differential attack, and searching for actual (related-key) differential characteristics. Using these methods, we obtain the following results.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The probability of the best related-key differential characteristic of the 24-round PRESENT-80, a bit-oriented SPN block cipher, is upper bounded by <span class="math">2^{-64}</span>, which is the tightest security bound obtained so far for PRESENT-80.</li>

      <li>The probability of the best related-key differential characteristic for the full-round LBlock is at most <span class="math">2^{-60}</span>. This is the first theoretic result concerning the full LBlock’s security against differential attack in the related-key model.</li>

      <li>We obtain a single-key differential characteristic and a single-key differential for the 15-round SIMON48 (a lightweight block cipher designed by the U.S. National Security Agency) with probability <span class="math">2^{-46}</span> and <span class="math">2^{-41.96}</span> respectively, which are the best results published so far for SIMON48.</li>

      <li>We obtain a 14-round related-key differential characteristic of LBlock with only 20 active Sboxes and probability <span class="math">2^{-49}</span> in no more than 4 hours on a PC. Note that the probabilities of the best previously published related-key characteristics covering the 13- and 14-round LBlock are <span class="math">2^{-53}</span> and <span class="math">2^{-65}</span> <em>[70]</em>, respectively.</li>

      <li>We obtain an 8-round related-key differential characteristic of DESL with probability <span class="math">2^{-34.78}</span> in 10 minutes on a PC. To the best of our knowledge, no related-key differential characteristic covering more than 7 rounds of DESL has been published before.</li>

      <li>We obtain a 7-round related-key characteristic for PRESENT-128 with probability <span class="math">2^{-11}</span> and 0 active S-box in its key schedule algorithm, based on which an improved related-key boomerang distinguisher for the 14-round PRESENT-128 and a key-recovery attack on the 17-round PRESENT-128 can be constructed by using exactly the same method presented in <em>[54]</em>.</li>

    </ol>

    <p class="text-gray-300">Note that the above specific results are not the focus of this paper. Instead, the focus is the new method presented in the paper, which is generic, automatic, and applicable to other lightweight ciphers with bit-oriented operations such as EPCBC <em>[71]</em>, and MIBS <em>[33]</em>.</p>

    <p class="text-gray-300">Organization of the paper. In Sect. 2, we introduce Mouha et al.’s framework and its extension for counting the number of active S-boxes of bit-oriented ciphers automatically with the MILP technique. In Sect. 3, we introduce the concept of valid cutting-off inequalities for tightening the feasible region of an MILP problem, and explore how to generate and select valid cutting-off inequalities. We present the methods for automatic security evaluation with respect to the (related-key) differential attack, and searching for (related-key) differential characteristics in Sect. 4 and Sect. 5. In Sect. 6 we conclude the paper and propose some research directions for bit-oriented ciphers and the application of the MILP technique in cryptography. The application of the methods to PRESENT80/128, LBlock, SIMON, DES(L) and example source code are presented in Appendices.</p>

    <h2 id="sec-2" class="text-2xl font-bold">2 Mouha et al.’s Framework and Its Extension</h2>

    <p class="text-gray-300">In this section, we present Mouha et al.’s framework and its extension for counting the number of differentially active S-boxes for word-oriented and bit-oriented block ciphers respectively. We refer the reader to <em>[51, 58]</em> for more information.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.1 Mouha et al.’s Framework for Word-oriented Block Ciphers</h3>

    <p class="text-gray-300">Assume a cipher is composed of the following three word-oriented operations, where <span class="math">\\omega</span> is the word size:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>XOR, <span class="math">\\oplus:\\mathbb{F}_{2}^{\\omega}\\times\\mathbb{F}_{2}^{\\omega}\\rightarrow\\mathbb{F}_{2}^{\\omega}</span>;</li>

      <li>Linear transformation <span class="math">L:\\mathbb{F}_{2^{\\omega}}^{m}\\rightarrow\\mathbb{F}_{2^{\\omega}}^{m}</span> with branch number <span class="math">\\mathcal{B}_{L}</span>;</li>

      <li>S-box, <span class="math">\\mathcal{S}:\\mathbb{F}_{2}^{\\omega}\\rightarrow\\mathbb{F}_{2}^{\\omega}</span>.</li>

    </ul>

    <p class="text-gray-300">Mouha et al.’s framework uses 0-1 variables, which are subjected to certain constraints imposed by the above operations, to denote the word level differences propagating through the cipher (1 for nonzero difference and 0 otherwise).</p>

    <p class="text-gray-300">Detailed MILP model building process for determining a lower bound of the number of active S-boxes is described as follows. Firstly, we should include the constraints imposed by the operations of the cipher.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Constraints Imposed by XOR Operations.</h5>

    <p class="text-gray-300">Suppose <span class="math">a\\oplus b=c</span>, where <span class="math">a,\\ b,\\ c\\in\\mathbb{F}_{2}^{\\omega}</span> are the input and output differences of the XOR operation, the following constraints will make sure that when <span class="math">a</span>, <span class="math">b</span>, and <span class="math">c</span> are not all zero, then there are at least two of them are nonzero:</p>

    <p class="text-gray-300">\\[ \\left\\{&a+b+c\\geq 2d_{\\oplus}\\\\ &d_{\\oplus}\\geq a,\\ d_{\\oplus}\\geq b,\\ d_{\\oplus}\\geq c\\right. \\] (1)</p>

    <p class="text-gray-300">where <span class="math">d_{\\oplus}</span> is a dummy variable taking values from <span class="math">\\{0,1\\}</span>. If each one of <span class="math">a</span>, <span class="math">b</span>, and <span class="math">c</span> represents one bit, we should also add the inequality <span class="math">a+b+c\\leq 2</span>.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Constraints Imposed by Linear Transformation.</h5>

    <p class="text-gray-300">Let <span class="math">x_{i_{k}}</span> and <span class="math">y_{j_{k}},k\\in\\{0,1,\\ldots,m-1\\}</span>, be 0-1 variables denoting the word-level input and output differences of the linear transformation <span class="math">L</span> respectively. Since for nonzero input differences, there are totally at least <span class="math">\\mathcal{B}_{L}</span> nonzero <span class="math">\\omega</span>-bit words in the input and output differences, we include the following constraints:</p>

    <p class="text-gray-300">\\[ \\left\\{&\\sum_{k=0}^{m-1}(x_{i_{k}}+y_{j_{k}})\\geq\\mathcal{B}_{L}d_{L}\\\\ &d_{L}\\geq x_{i_{k}},\\ \\ k\\in\\{0,\\ldots,m-1\\}\\\\ &d_{L}\\geq y_{j_{k}},\\ \\ k\\in\\{0,\\ldots,m-1\\}\\right. \\] (2)</p>

    <p class="text-gray-300">where <span class="math">d_{L}</span> is a dummy variable taking values in <span class="math">\\{0,1\\}</span> and <span class="math">\\mathcal{B}_{L}</span> is the branch number of the linear transformation.</p>

    <p class="text-gray-300">Then, we set up the objective function to be the sum of all variables representing the input words of the S-boxes. Obviously, this objective function corresponds to the number of active S-boxes, and can be minimized to determine its lower bound.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Extension of Mouha et al.’s Framework for Bit-oriented Ciphers</h3>

    <p class="text-gray-300">For bit-oriented ciphers, bit-level representations and additional constraints are needed <em>[58]</em>. For every input and output bit-level difference, a new 0-1 variable <span class="math">x_{i}</span> is introduced such that <span class="math">x_{i}=1</span> if and only if the difference at this bit is nonzero.</p>

    <p class="text-gray-300">For every S-box in the schematic diagram, including the encryption process and the key schedule algorithm, we introduce a new 0-1 variable <span class="math">A_{j}</span> such that</p>

    <p class="text-gray-300">\\[ A_{j}=\\left\\{&1,\\ \\text{if the input word of the Sbox is nonzero,}\\\\ &0,\\ \\text{otherwise.}\\right. \\]</p>

    <p class="text-gray-300">At this point, it is natural to choose the objective function <span class="math">f</span>, which will be minimized, as <span class="math">\\sum A_{j}</span> for the goal of determining a lower bound of the number of active S-boxes.</p>

    <p class="text-gray-300">For bit-oriented ciphers, we need to include two sets of constraints. The first one is the set of constraints imposed by XOR operations, and the other is due to the S-box operation. After changing the representations to bit-level, the set of constraints imposed by XOR operations for bit-oriented ciphers are the same as that presented in (1). The S-box operation is more tricky.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Constraints Describing the S-box Operation.</h5>

    <p class="text-gray-300">Suppose <span class="math">(x_{i_{0}},\\ldots,x_{i_{\\omega-1}})</span> and <span class="math">(y_{j_{0}},\\ldots,y_{j_{\\nu-1}})</span> are the input and output bit-level differences of an <span class="math">\\omega\\times\\nu</span> S-box marked by <span class="math">A_{t}</span>. Firstly, to ensure that <span class="math">A_{t}=1</span> holds if and only if <span class="math">x_{i_{0}},\\ldots,x_{i_{\\omega-1}}</span> are not all zero, we require that:</p>

    <p class="text-gray-300">\\[ \\left\\{&A_{t}-x_{i_{k}}\\geq 0,\\ \\ k\\in\\{0,\\ldots,\\omega-1\\}\\\\ &x_{i_{0}}+x_{i_{1}}+\\cdots+x_{i_{\\omega-1}}-A_{t}\\geq 0\\right. \\] (3)</p>

    <p class="text-gray-300">For bijective S-boxes, nonzero input difference must result in nonzero output difference and vice versa:</p>

    <p class="text-gray-300">\\[ \\left\\{&\\omega y_{j_{0}}+\\omega y_{j_{1}}+\\cdots+\\omega y_{j_{\\nu-1}}-(x_{i_{0}}+x_{i_{1}}+\\cdots+x_{i_{\\omega-1}})\\geq 0\\\\ &\\nu x_{i_{0}}+\\nu x_{i_{1}}+\\cdots+\\nu x_{i_{\\omega-1}}-(y_{j_{0}}+y_{j_{1}}+\\cdots+y_{j_{\\nu-1}})\\geq 0\\right. \\] (4)</p>

    <p class="text-gray-300">Note that the above constraints should not be used for non-bijective S-box such as the S-box of DES(L).</p>

    <p class="text-gray-300">Finally, the Hamming weight of the <span class="math">(\\omega+\\nu)</span>-bit word <span class="math">x_{i_{0}}\\cdots x_{i_{\\omega-1}}y_{j_{0}}\\cdots y_{j_{\\nu-1}}</span> is lower bounded by the branch number <span class="math">\\mathcal{B_{S}}</span> of the S-box for nonzero input difference <span class="math">x_{i_{0}}\\cdots x_{i_{\\omega-1}}</span>, where <span class="math">d_{\\mathcal{S}}</span> is a dummy variable:</p>

    <p class="text-gray-300"><span class="math">\\left\\{{\\sum_{k=0}^{\\omega-1}x_{i_{k}}+\\sum_{k=0}^{\\nu-1}y_{j_{k}}\\geq\\mathcal{B}_{\\mathcal{S}}d_{\\mathcal{S}}\\atop{d_{\\mathcal{S}}\\geq x_{i_{k}},\\ \\ k\\in\\{0,\\ldots,\\omega-1\\}}\\atop{d_{\\mathcal{S}}\\geq y_{j_{k}},\\ \\ k\\in\\{0,\\ldots,\\nu-1\\}}\\right.</span> (5)</p>

    <p class="text-gray-300">where the branch number <span class="math">\\mathcal{B}_{\\mathcal{S}}</span> of an S-box <span class="math">\\mathcal{S}</span>, is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{B}_{\\mathcal{S}}=\\min_{a\\neq b}\\{\\text{wt}((a\\oplus b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathcal{S}(a)\\oplus\\mathcal{S}(b)):a,b\\in\\mathbb{F}_{2}^{\\omega}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and <span class="math">\\text{wt}(\\cdot)</span> is the standard Hamming weight of an <span class="math">(\\omega+\\nu)</span>-bit word. We point out that constraint (5) is redundant for an invertible S-box with branch number <span class="math">\\mathcal{B}_{\\mathcal{S}}=2</span>, since in this particular case, all differential patterns not satisfying (5) violate (4).</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">0-1 Variables.</h3>

    <p class="text-gray-300">The MILP model proposed above is indeed a Pure Integer Programming Problem since all variables appearing are 0-1 variables. However, in practice we only need to explicitly restrict a part of all variables to be 0-1, while all other variables can be allowed to be any real numbers, which leads to a Mixed-integer Linear Programming problem. Following this approach, the MILP solving process may be accelerated as suggested in <em>[18]</em>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Tighten the Feasible Region with Valid Cutting-off Inequalities</h2>

    <p class="text-gray-300">The feasible region of an MILP problem is defined as the set of all variable assignments satisfying all constraints in the MILP problem. The modelling process presented in the previous sections indicates that every differential path corresponds to a solution in the feasible region of the MILP problem. However, a feasible solution of the MILP model is not guaranteed to be a valid differential path, since our constraints are far from perfect to rule out all invalid differential patterns. For instance, assume <span class="math">x_{i}</span> and <span class="math">y_{i}</span> (<span class="math">0\\leq i\\leq 3</span>) are the bit-level input and output differences of the PRESENT-80 S-box. According to Sect. 2.2, <span class="math">x_{i}</span>, <span class="math">y_{i}</span> are subjected to the constraints of (3), (4) and (5). Obviously, <span class="math">(x_{0}\\cdots,x_{3},y_{0},\\cdots,y_{3})=(1,0,0,1,1,0,1,1)</span> satisfies the above constraints, whereas <span class="math">0x9=1001\\rightarrow 0xB=1011</span> is not a valid difference propagation pattern for the PRESENT S-box, which can be seen from the differential distribution table of the PRESENT S-box. Hence, we are actually trying to minimize the number of the active S-boxes over a larger region as illustrated in Fig. 1, and the optimum value obtained in this setting must be smaller than or equal to the actual minimum number of active S-boxes. Although the above fact will not invalidate the lower bound we obtained from our MILP model, this prevents the designers or analysts from obtaining tighter security bounds and valid (related-key) differential characteristics from the feasible region.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: The relationship between the set of all differential paths and the feasible region of the MILP problem, and the effect of cutting-off inequality</p>

    <p class="text-gray-300">The situation would be even worse when modelling an invertible S-box with branch number <span class="math">\\mathcal{B}_{\\mathcal{S}}=2</span>, which is the minimal value of the branch number for an invertible S-box. In the case of invertible S-box with</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{\\mathcal{S}}=2</span>, the constraints of (3), (4) are enough, and (5) is redundant. In this situation, all differential patterns with nonzero input and output differences satisfy the constraints presented in the previous sections, which is obviously too coarse to describe a specific S-box. For instance, all 10 S-boxes of LBlock <em>[70]</em> are invertible and their branch numbers are all 2.</p>

    <p class="text-gray-300">Therefore, we are motivated to look for linear inequalities which can cut off some part of the feasible region of the MILP model while leaving the region of valid differential characteristics intact as illustrated in Fig. 1. For the convenience of discussion, we give the following definition.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A valid cutting-off inequality is a linear inequality which is satisfied by all possible valid differential patterns, but is violated by at least one feasible solution corresponding to an impossible differential pattern in the feasible region of the original MILP problem.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 Methods for Generating Valid Cutting-off Inequalities</h3>

    <p class="text-gray-300">In this section, we present two methods for generating valid cutting-off inequalities by analyzing the differential behavior of the underlying S-box.</p>

    <p class="text-gray-300">Modelling Conditional Differential Behaviour with Linear Inequalities</p>

    <p class="text-gray-300">In building integer programming models in practice, sometimes it is possible to model certain logical constraints as linear inequalities. For example, assume <span class="math">x</span> is a continuous variable such that <span class="math">0\\leq x\\leq M</span>, where <span class="math">M</span> is a fixed integer, and we know that <span class="math">\\delta</span> is a 0-1 variable taking value 1 when <span class="math">x&gt;0</span>, that is</p>

    <p class="text-gray-300"><span class="math">x&gt;0\\ \\ \\Rightarrow\\ \\ \\delta=1.</span></p>

    <p class="text-gray-300">It is easy to verify that the above logical condition can be achieved by imposing the following constraint</p>

    <p class="text-gray-300"><span class="math">x-M\\delta\\leq 0.</span></p>

    <p class="text-gray-300">In fact, there is a surprisingly large number of different types of logical conditions can be imposed in a similar way, and we refer the reader to <em>[65, 66]</em> for many other examples. We now give a theorem which will be used in the following.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">If we assume that all variables are 0-1 variables, then the logical condition that <span class="math">(x_{0},\\ldots,x_{m-1})=(\\delta_{0},\\ldots,\\delta_{m-1})\\in\\{0,1\\}^{m}\\subseteq\\mathbb{Z}^{m}</span> implies <span class="math">y=\\delta\\in\\{0,1\\}\\subseteq\\mathbb{Z}</span> can be described by the following linear inequality</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m-1}(-1)^{\\delta_{i}}x_{i}+(-1)^{\\delta+1}y-\\delta+\\sum_{i=0}^{m-1}\\delta_{i}\\geq 0,</span> (6)</p>

    <p class="text-gray-300">where <span class="math">\\delta_{i}</span>, <span class="math">\\delta</span> are fixed constants and <span class="math">\\mathbb{Z}</span> is the set of all integers.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We only prove the Theorem for the case <span class="math">\\delta=0</span>. For <span class="math">\\delta=1</span>, it can be proved in a similar way. We assume</p>

    <p class="text-gray-300"><span class="math">(\\delta_{0},\\ldots,\\delta_{m-1})=(\\delta_{0},\\ldots,\\delta_{s_{1}-1};\\delta_{s_{1}},\\ldots,\\delta_{m-1})=(1,1,\\ldots,1;0,0,\\ldots,0)=\\Delta^{*}.</span></p>

    <p class="text-gray-300">For other 0-1 patterns, it can be permuted into such a form and this will not affect our proof.</p>

    <p class="text-gray-300">Firstly, <span class="math">(\\Delta^{*},0)</span> is satisfied by (6), which can be verified directly.</p>

    <p class="text-gray-300">Secondly, we prove that all vectors <span class="math">(x_{0},\\ldots,x_{m-1},y)\\in\\{0,1\\}^{m+1}</span> such that <span class="math">(x_{0},\\ldots,x_{m-1})\\neq\\Delta^{*}</span> are satisfied by (6). In such cases, we have</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m-1}(-1)^{\\delta_{i}}x_{i}+(-1)^{\\delta+1}y-\\delta+\\sum_{i=0}^{m-1}\\delta_{i}=-\\sum_{i=0}^{s_{1}-1}x_{i}+\\sum_{i=s_{1}}^{m}x_{i}-y-0+s_{1}\\geq-s_{1}+1-y+s_{1}=1-y\\geq 0,</span></p>

    <p class="text-gray-300">for <span class="math">y=0</span> or <span class="math">y=1</span>.</p>

    <p class="text-gray-300">Finally we prove that the vector <span class="math">(x_{0},\\ldots,x_{m-1},y)=(\\Delta^{*},1)</span> is not satisfied by the linear inequality. In such case, we have</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{m-1}(-1)^{\\delta_{i}}x_{i}+(-1)^{\\delta+1}y-\\delta+\\sum_{i=0}^{m-1}\\delta_{i}=-\\sum_{i=0}^{s_{1}-1}x_{i}+\\sum_{i=s_{1}}^{m}x_{i}-1-0+s_{1}=-s_{1}-1+s_{1}=-1&lt;0.</span></p>

    <p class="text-gray-300">The proof is completed.</p>

    <p class="text-gray-300">For example, the PRESENT S-box has the following conditional differential properties, which are referred to as undisturbed bits in *[61]</p>

    <p class="text-gray-300">Fact 1. The S-box of PRESENT-80 has the following properties:</p>

    <p class="text-gray-300">(i)  <span class="math">1001 \\rightarrow^{<strong><em>} 0</span> : If the input difference of the  <span class="math">S</span> -box is  <span class="math">0x9 = 1001</span> , then the least significant bit of the output difference must be 0; (ii)  <span class="math">0001 \\rightarrow^{</strong></em>} 1</span>  and  <span class="math">1000 \\rightarrow^{<strong><em>} 1</span> : If the input difference of the  <span class="math">S</span> -box is  <span class="math">0x1 = 0001</span>  or  <span class="math">0x8 = 1000</span> , then the least significant bit of the output difference must be 1; (iii)  <span class="math">^{</strong></em>}1 \\rightarrow 0001</span>  and  <span class="math">^{<strong><em>}1 \\rightarrow 0100</span> : If the output difference of the  <span class="math">S</span> -box is  <span class="math">0x1 = 0001</span>  or  <span class="math">0x4 = 0100</span> , then the least significant bit of the input difference must be 1; and (iv)  <span class="math">^{</strong></em>}0 \\rightarrow 0101</span> : If the output difference of the  <span class="math">S</span> -box is  <span class="math">0x5 = 0101</span> , then the least significant bit of the input difference must be 0.</p>

    <p class="text-gray-300">From Theorem 1, we have the following fact. Note that similar conditional differential behaviors of other ciphers were also used by other researchers in different context [19, 28, 38, 39, 44].</p>

    <p class="text-gray-300">Fact 2. Let  <span class="math">0-1</span>  variables  <span class="math">(x_0, x_1, x_2, x_3)</span>  and  <span class="math">(y_0, y_1, y_2, y_3)</span>  represent the input and output bit-level differences of the  <span class="math">S</span> -box respectively, where  <span class="math">x_3</span>  and  <span class="math">y_3</span>  are the least significant bits. Then the logical conditions in Theorem 1 can be described by the following linear inequalities:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>x _ {0} + x _ {1} + x _ {2} - x _ {3} - y _ {3} + 2 \\geq 0 \\tag {7}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {0} + x _ {1} + x _ {2} - x _ {3} + y _ {3} \\geq 0 \\\\ - x _ {0} + x _ {1} + x _ {2} + x _ {3} + y _ {3} \\geq 0 \\end{array} \\right. \\tag {8}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} x _ {3} + y _ {0} + y _ {1} + y _ {2} - y _ {3} \\geq 0 \\\\ x _ {3} + y _ {0} - y _ {1} + y _ {2} + y _ {3} \\geq 0 \\end{array} \\right. \\tag {9}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>x _ {3} + y _ {0} - y _ {1} + y _ {2} - y _ {3} + 2 \\geq 0 \\tag {10}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For example, the linear inequality (7) removes all differential patterns of the form  <span class="math">(x_0,\\ldots ,x_3,y_0,\\ldots ,y_3) =</span> <span class="math">(1,0,0,1,<em>,</em>,*,1)</span> , where  <span class="math">(x_0,\\dots,x_3)</span>  and  <span class="math">(y_0,\\dots,y_3)</span>  are the input and output differences of the PRESENT S-box respectively. We call this group of constraints presented in (7), (8), (9), and (10) the constraints of conditional differential propagation (CDP constraints for short). The CDP constraints obtained from Fact 1 and the differential patterns removed by these CDP constraints are given in Table 1.</p>

    <p class="text-gray-300">Table 1: Impossible differential patterns removed by the CDP constraints generated according to the differential properties of the PRESENT S-box. Here, a 9-dimensional vector  <span class="math">(\\lambda_0,\\dots ,\\lambda_3,\\gamma_0,\\dots ,\\gamma_3,\\theta)</span>  in the left column denotes a linear inequality  <span class="math">\\lambda_0x_0 + \\dots +\\lambda_3x_3 + \\gamma_0y_0 + \\dots +\\gamma_3y_3 + \\theta \\geq 0</span>  , and an 8-dimensional vector in the right column denotes a difference propagation pattern, e.g.,  <span class="math">(1,0,0,1,0,1,1,1)</span>  denotes  <span class="math">0x9 = 1001\\to 0x7 = 0111</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraints obtained by log-ical condition modelling</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Impossible differential patterns removed</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-1,1,1,-1,0,0,0,-1,2)</td>

            <td class="px-3 py-2 border-b border-gray-700">(1,0,0,1,0,0,0,1), (1,0,0,1,0,0,1,1), (1,0,0,1,0,1,0,1), (1,0,0,1,0,1,1,1), (1,0,0,1,1,0,0,1), (1,0,0,1,1,0,1,1), (1,0,0,1,1,1,0,1), (1,0,0,1,1,1,1,1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(1,1,1,-1,0,0,0,1,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,1,0,0,0,0), (0,0,0,1,0,0,1,0), (0,0,0,1,0,1,0,0), (0,0,0,1,0,1,1,0), (0,0,0,1,1,0,0,0), (0,0,0,1,1,0,1,0), (0,0,0,1,1,1,0,0), (0,0,0,1,1,1,1,0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-1,1,1,1,0,0,0,1,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(1,0,0,0,0,0,0,0), (1,0,0,0,0,0,1,0), (1,0,0,0,0,1,0,0), (1,0,0,0,0,1,1,0), (1,0,0,0,1,0,0,0), (1,0,0,0,1,0,1,0), (1,0,0,0,1,1,0,0), (1,0,0,0,1,1,1,0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,1,1,1,1,-1,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,0,0,0,0,1), (0,0,1,0,0,0,0,1), (0,1,0,0,0,0,0,1), (0,1,1,0,0,0,0,1), (1,0,0,0,0,0,0,1), (1,0,1,0,0,0,0,1), (1,1,0,0,0,0,0,1), (1,1,1,0,0,0,0,1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,1,1,-1,1,1,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,0,0,1,0,0), (0,0,1,0,0,1,0,0), (0,1,0,0,0,1,0,0), (0,1,1,0,0,1,0,0), (1,0,0,0,0,1,0,0), (1,0,1,0,0,1,0,0), (1,1,0,0,0,1,0,0), (1,1,1,0,0,1,0,0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,-1,1,-1,1,-1,2)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0,0,0,1,0,1,0,1), (0,0,1,1,0,1,0,1), (0,1,0,1,0,1,0,1), (0,1,1,1,0,1,0,1), (1,0,0,1,0,1,0,1), (1,0,1,1,0,1,0,1), (1,1,0,1,0,1,0,1), (1,1,1,1,0,1,0,1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, there are cases where no such conditional differential property exists. For example, two out of the eight S-boxes of Serpent [7] exhibit no such property. Even when the S-box under consideration can be described with this logical condition modelling technique, the inequalities generated may be not enough to produce a satisfied result. The number of valid cutting-off inequalities can be obtained in this way is given in Table 2 for typical  <span class="math">4 \\times 4</span>  S-boxes.</p>

    <p class="text-gray-300">Table 2: The Numbers of valid cutting-off inequalities obtained using different methods. Notations: the “# CDP” columns record the numbers of constraints obtained using logical condition modelling approach, and the “#CH” columns record the numbers of constraints in the H-representation of the convex hulls.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-box</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#CDP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#CH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-box</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#CDP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#CH</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Klein [29]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">312</td>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S6</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Piccolo [57]</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S7</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TWINE [60]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">324</td>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S8</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRINCE [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S9</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MIBS</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">378</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S0</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT/LED [31]</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S0</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S2</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">325</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S1</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">368</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S2</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S3</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S4</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LBlock S5</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">205</td>

            <td class="px-3 py-2 border-b border-gray-700">Serpent S7</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">368</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following, a more general approach for generating valid cutting-off inequalities is proposed.</p>

    <p class="text-gray-300">The convex hull of a set  <span class="math">Q</span>  of discrete points in  <span class="math">\\mathbb{R}^n</span>  is the smallest convex set that contains  <span class="math">Q</span> . A convex hull in  <span class="math">\\mathbb{R}^n</span>  can be described as the common solutions of a set of finitely many linear equations and inequalities as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\lambda_ {0, 0} x _ {0} + \\dots + \\lambda_ {0, n - 1} x _ {n - 1} + \\lambda_ {0, n} \\geq 0 \\\\ \\dots \\\\ \\gamma_ {0, 0} x _ {0} + \\dots + \\gamma_ {0, n - 1} x _ {n - 1} + \\gamma_ {0, n} = 0 \\\\ \\dots \\end{array} \\right. \\tag {11}</span></div>

    <p class="text-gray-300">This is called the H-Representation of a convex hull. Computing the H-representation of the convex hull of a set of finitely many points is a fundamental algorithm in computation geometry with many applications [30, 56].</p>

    <p class="text-gray-300">If we treat a possible differential of an  <span class="math">\\omega \\times \\nu</span>  S-box as a point in  <span class="math">\\mathbb{R}^{\\omega +\\nu}</span> , then we can obtain a set of finitely many discrete points which includes all possible differential patterns of this S-box. For example, one possible differential pattern of PRESENT S-box is  <span class="math">0x9 = 1001\\rightarrow 0xE = 1110</span>  which is identified with  <span class="math">(1,0,0,1,1,1,1,0)</span> , and one possible differential pattern of the DESL S-box is  <span class="math">0x3E = 111110\\rightarrow 0xB = 1011</span>  which is identified with  <span class="math">(1,1,1,1,1,0,1,0,1,1)</span> . The set of all possible differential patterns for the S-boxes of PRESENT and DESL are given at http://paste.ubuntu.com/7123001/ and http://paste.ubuntu.com/7123005/ respectively. These are essentially sets of finitely many discrete points in high dimensional space, hence we can compute their convex hulls by standard method in computational geometry.</p>

    <p class="text-gray-300">We now define the convex hull of a specific  <span class="math">\\omega \\times \\nu</span>  S-box to be the set of all linear inequalities in the H-Representation of the convex hull  <span class="math">\\mathcal{V}_S \\subseteq \\mathbb{R}^{\\omega + \\nu}</span>  of all possible differential patterns of the S-box. The convex hull of a specific S-box can be obtained by using the inequality_generator() function in the sagegeometry.polyhedron class of the SAGE computer algebra system [59]. The convex hull of the PRESENT S-box contains 327 linear inequalities. Any one of these inequalities can be taken as a valid cutting-off inequality. The numbers of linear inequalities in the convex hulls of typical  <span class="math">4 \\times 4</span>  S-boxes are given in Table 2.</p>

    <p class="text-gray-300">The number of equations and inequalities in the H-Representation of a convex hull computed from a set of discrete points in  <span class="math">n</span>  dimensional space is very large in general. For instance, the convex hull  <span class="math">\\mathcal{V}_S \\subseteq \\mathbb{R}^8</span>  of a  <span class="math">4 \\times 4</span>  S-box typically involves several hundreds of linear inequalities. Adding all of them to an MILP problem will quickly make the MILP problem insolvable in practical time. Hence, it is necessary to select a small number, say  <span class="math">n</span> , of "best" inequalities from the convex hull. Here by "best" we mean that, among all possible selections of  <span class="math">n</span>  inequalities, the selected ones maximize the number of removed impossible differentials. Obviously, this is a hard combinatorial optimization problem. Therefore, we design a greedy algorithm, listed in Algorithm 1, to approximate the optimum selection.</p>

    <p class="text-gray-300">Algorithm 1: Selecting  <span class="math">n</span>  inequalities from the convex hull  <span class="math">\\mathcal{H}</span>  of an S-box Input:  <span class="math">\\mathcal{H}</span>  : the set of all inequalities in the H-representation of the convex hull of an S-box;  <span class="math">\\mathcal{X}</span>  : the set of all impossible differential patterns of an S-box;  <span class="math">n</span>  : a positive integer. Output:  <span class="math">\\mathcal{O}</span>  : a set of  <span class="math">n</span>  inequalities selected from  <span class="math">\\mathcal{H}</span> <span class="math">l^{<em>} := \\text{None};</span> <span class="math">2\\mathcal{X}^{</em>} := \\mathcal{X};</span> <span class="math">3\\mathcal{H}^{<em>} := \\mathcal{H};</span> <span class="math">4\\mathcal{O} := \\emptyset;</span> 5 for  <span class="math">i \\in \\{0, \\dots, n-1\\}</span>  do 6  <span class="math">l^{</em>} := \\text{The inequality in } \\mathcal{H}^{<em>}</span>  which maximizes the number of removed impossible differential patterns from  <span class="math">\\mathcal{X}^{</em>}</span> ; 7  <span class="math">\\mathcal{X}^{<em>} := \\mathcal{X}^{</em>} - \\{\\text{removed impossible differential patterns by } l^{<em>}\\}</span> ; 8  <span class="math">\\mathcal{H}^{</em>} := \\mathcal{H}^{<em>} - \\{l^{</em>}\\}</span> ; 9  <span class="math">\\mathcal{O} := \\mathcal{O} \\cup \\{l^{*}\\}</span> ; 10 end 11 return  <span class="math">\\mathcal{O}</span></p>

    <p class="text-gray-300">The algorithm builds up a set of valid cutting-off inequalities by selecting at each step an inequality from the convex hull which maximizes the number of removed impossible differential patterns from the current feasible region.</p>

    <p class="text-gray-300">For instance, We select 6 valid cutting-off inequalities from the convex hull of the PRESENT S-box using Algorithm 1. These inequalities and the impossible differential patterns removed are listed in Table 3. Compared with the 6 valid cutting-off inequalities obtained by Theorem 1 (see Table 1), they cut off  <span class="math">66 - 42 = 24</span>  more impossible differential patterns, which leads to a relatively tighter feasible region.</p>

    <p class="text-gray-300">Table 3: Impossible differential patterns removed by the constraints selected from the convex hull of the PRESENT S-box</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Constraints selected from the convex hull by the greedy algo-rithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Impossible differential patterns removed</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-2,1,1,3,1,-1,1,2,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(1.0.1.0.0.1.0.0)(1.0.0.0.1.1.0.0)(1.0.0.0.1.0.0.0)(1.0.1.0.0.1.1.0)(1.0.0.0.1.1.1.0)(1.1.0.0.0.1.0.0)(1.1.0.0.0.1.1.0)(1.0.0.0.0.1.0.0)(1.0.0.0.0.1.0.1)(1.0.0.0.0.1.0)(1.1.0.0.1.1.0.0)(1.1.1.0.0.1.0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(1,-2,-3,-2,1,-4,3,-3,10)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.1.1.0.1.1.0.1)(1.1.1.0.0.1.0.1)(0.1.1.1.0.1.1.1)(1.0.1.1.0.1.0.1)(0.1.1.0.0.1.0.1)(0.1.1.1.0.1.0.0)(0.1.1.1.0.1.0.1)(1.1.1.1.1.1.0.1)(0.0.1.1.0.1.0.1)(0.1.1.1.1.1.0.1)(1.1.1.1.0.1.0.1)(0.1.0.1.0.1)(0.1.1.1.1.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,-2,3,-4,-1,-4,-4,1,11)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.1.0.1.0.1.1.0)(1.1.0.1.0.1.1.0)(0.0.0.1.1.1.1.0)(0.1.0.1.0.1.1.1)(0.0.0.1.1.1.1.1)(0.1.0.1.1.1.1.1)(0.1.0.1.1.1.1.1)(0.1.0.1.1.1.1.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-1,-2,-2,-1,-1,2,-1,0,6)</td>

            <td class="px-3 py-2 border-b border-gray-700">(1.1.1.0.1.0.1.1)(1.1.1.0.1.0.1.0)(1.1.1.1.1.0.0.1)(1.1.1.1.1.0.0.0)(0.1.1.1.1.0.1.1)(1.1.1.1.1.0.1.0)(0.1.1.1.1.0.1.0)(1.1.1.1.1.0.1.1)(1.1.1.1.1.0.1.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-2,1,-2,-1,1,-1,-2,0,6)</td>

            <td class="px-3 py-2 border-b border-gray-700">(1.1.1.1.0.1.1.0)(1.1.1.1.0.1.1.1)(1.0.1.1.0.0.1.0)(1.0.1.0.0.1.1)(1.0.1.1.0.0.1.1)(1.0.1.1.1.1.1.1)(1.0.1.1.0.1.1)(1.0.1.1.0.1.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,1,1,-3,1,2,1,2,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.0.0.1.1.0.0.0)(0.0.1.1.0.0.1.0)(0.0.0.1.0.0.0.1)(0.1.0.1.1.0.0.0)(0.0.0.1.0.1.0.0)(0.0.0.1.0.0.1.0)(0.0.0.1.1.0.1.0)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To evaluate the security (obtain the security bound) of a block cipher with respect to related-key differential attack, we can build an MILP model according to Sect. 2 with the constraints introduced in Sect. 3.1 and Sect. 3.2 included. Then we solve the MILP model using any MILP optimizer, and the optimized solution, say  <span class="math">N</span> , is the minimum number of the active S-boxes from which we can deduce that the probability of the best</p>

    <p class="text-gray-300">differential characteristic is upper bounded by <span class="math">\\epsilon^{N}</span>, where <span class="math">\\epsilon</span> is the maximum differential probability (MDP) of a single S-box.</p>

    <p class="text-gray-300">However, it is computationally infeasible to solve an MILP model generated by an <span class="math">r</span>-round block cipher with reasonably large <span class="math">r</span>. In such case, we can turn to the so called simple split approach. We split the <span class="math">r</span>-round block cipher into two parts with consecutive <span class="math">r_{1}</span> rounds and <span class="math">r_{2}</span> rounds such that <span class="math">r_{1}+r_{2}=r</span>. Then we apply our method to these two parts. Assuming that there are at least <span class="math">N_{r_{1}}</span> and <span class="math">N_{r_{2}}</span> active S-boxes in the first and second part respectively, we can deduced that the probability of the best differential characteristic for this <span class="math">r</span>-round cipher is upper bounded by <span class="math">\\epsilon^{(N_{r_{1}}+N_{r_{2}})}</span>. If <span class="math">r_{1}</span> and <span class="math">r_{2}</span> are still too large, they can be divided into smaller parts further.</p>

    <p class="text-gray-300">Note that our method is applicable to both the single-key and related-key models. In single-key model, we only include the variables and constraints in the encryption process. While in related-key model, we include the variables and constraints introduced by both the encryption process, key schedule algorithm and key addition operations.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.1 Techniques for Getting Tighter Security Bounds</h3>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Technique 1.</h4>

    <p class="text-gray-300">In the above analysis, we pessimistically (in the sense that we want to prove the security of a cipher) assume that all the active S-boxes take the MDP <span class="math">\\epsilon</span>. However, this is unlikely to happen in practice, especially in the case that the number of active S-boxes is minimized. Therefore, we have the following strategy for obtaining tighter security bound for a <span class="math">t</span>-round characteristic.</p>

    <p class="text-gray-300">Firstly, compute the set <span class="math">\\mathcal{E}</span> of all the differential patterns of an S-box with probabilities greater than or equal to the S-box’s MDP <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Secondly, compute the H-representation <span class="math">H_{\\mathcal{E}}</span> of the convex hull of <span class="math">\\mathcal{E}</span>, and then use the inequalities selected from <span class="math">H_{\\mathcal{E}}</span> by Algorithm 1 to generate a <span class="math">t</span>-round model according to Sect. 2 and Sect. 3. Note that the feasible region of this model is smaller than that of a <span class="math">t</span>-round model generated in standard way, since the differential patterns allowed to take in this model is more restrictive. Hence, we hope to get a larger objective value than <span class="math">N_{t}</span>, which is the result obtained by using the standard <span class="math">t</span>-round model.</p>

    <p class="text-gray-300">Finally, solve the model using a software optimizer. If the objective value is greater than <span class="math">N_{t}</span>, we know that there is no differential characteristic with only <span class="math">N_{t}</span> active S-boxes such that all these S-boxes take differential patterns with probability <span class="math">\\epsilon</span>. And hence, we can conclude that there is at least one active S-box taking a differential pattern with probability less than <span class="math">\\epsilon</span> in a <span class="math">t</span>-round characteristic with only <span class="math">N_{t}</span> active S-boxes.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Technique 2.</h4>

    <p class="text-gray-300">Yet another technique for obtaining tighter security bound is inspired by Alex Biryukov et al. and Sareh Emami et al.’s (extended) split approach <em>[24, 12]</em>. In Sun et al.’s work <em>[58]</em>, the strategy for proving the security of an <span class="math">n</span>-round iterative cipher against the related-key differential attacks is to use the simple split approach. By employing the MILP technique, compute the minimum number <span class="math">N_{t}</span> of differentially active S-boxes for any consecutive <span class="math">t</span>-round (<span class="math">1\\leq t\\leq n</span>) related-key differential characteristic. Then the lower bound of the number of active S-boxes for the full cipher (<span class="math">n</span>-round) can be obtained by computing</p>

    <p class="text-gray-300"><span class="math">\\sum_{j\\in I\\subseteq\\{1,2,\\dots\\}}N_{t_{j}},\\text{ where }\\sum_{j\\in I}t_{j}=n.</span></p>

    <p class="text-gray-300">Note that the computational cost is too high to compute <span class="math">N_{n}</span> directly.</p>

    <p class="text-gray-300">We point out that this simple “split strategy” can be improved to obtain tighter security bound by exploiting more information of a differential characteristic. The main idea is that the characteristic covering round <span class="math">1</span> to round <span class="math">m</span> and the characteristic covering round <span class="math">m+1</span> to round <span class="math">2m</span> should not be treated equal although they have the same number of rounds, since the starting difference of a characteristic of round <span class="math">m+1</span> to <span class="math">2m</span> is not as free as that of a characteristic of round <span class="math">1</span> to round <span class="math">m</span>. Therefore, we have the following strategy.</p>

    <p class="text-gray-300">Firstly, split an <span class="math">r</span>-round into two parts: round <span class="math">1</span> to round <span class="math">r_{1}</span>, and round <span class="math">r_{1}+1</span> to round <span class="math">r=r_{1}+r_{2}</span>.</p>

    <p class="text-gray-300">Secondly, construct an MILP model covering round <span class="math">1</span> to round <span class="math">r</span>. Change the objective function to be the sum of all S-boxes covering round <span class="math">r_{1}+1</span> to round <span class="math">r</span>. Add some additional constraints on the number of active S-boxes covering round <span class="math">1</span> to round <span class="math">r_{1}</span> (One way to obtain such constraints is to solve the model covering round <span class="math">1</span> to round <span class="math">r_{1}</span>).</p>

    <p class="text-gray-300">Finally, solve the model using any software optimizer, and the result is the lower bound of the number of active S-boxes of round <span class="math">r_{1}+1</span> to round <span class="math">r</span> (<span class="math">r_{2}</span> rounds in total) for any characteristic covering round <span class="math">1</span> to round <span class="math">r</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We have applied the methods presented in this section to PRESENT-80 and LBlock, and the results are given in Appendix A. For PRESENT-80, we prove that the probability of any related-key differential characteristic covering round 1 to round 24 is upper bounded by <span class="math">2^{-64}</span>. For LBlock, we prove that the probability of any related-key differential characteristic of full-round LBlock is upper bounded by <span class="math">2^{-60}</span>. These are the tightest security bounds for PRESENT-80 and LBlock with respect to the related-key differential attack published so far.</p>

    <h2 id="sec-20" class="text-2xl font-bold">5 A Heuristic Method for Finding (Related-key) Differential Characteristics Automatically</h2>

    <p class="text-gray-300">To find a (related-key) differential characteristic with relatively high probability covering <span class="math">r</span> rounds of a cipher is the most important step in (related-key) differential cryptanalysis. Most of the tools for searching differential characteristics are essentially based on Matsui’s algorithm <em>[49]</em>. In this section, we propose an MILP based heuristic method for finding (related-key) differential characteristics. Compared to other methods, our method is easier to implement, and more flexible.</p>

    <p class="text-gray-300">Thanks to the valid cutting-off inequalities which can describe the property of an S-box according to its differential distribution table, our method can output a good (related-key) differential characteristic directly by employing the MILP technique. The procedure of our method is outlined as follows.</p>

    <p class="text-gray-300">Step 1. For every S-box <span class="math">\\mathcal{S}</span>, select <span class="math">n</span> inequalities from the convex hull of the set of all possible differential patterns of <span class="math">\\mathcal{S}</span> using Algorithm 1, and generate an <span class="math">r</span>-round MILP model in which we require that all variables involved are 0-1.</p>

    <p class="text-gray-300">Step 2. Extract a feasible solution of the MILP model by using the Gurobi <em>[52]</em> optimizer.</p>

    <p class="text-gray-300">Step 3. Check whether the feasible solution is a valid (related-key) differential characteristic. If it is a valid characteristic, the procedure terminates. Otherwise, go to step 1, increase the number of selected inequalities from the convex hulls, and repeat the whole process.</p>

    <p class="text-gray-300">We have developed a software by employing the python interface provided by the Gurobi optimizer, which automates the whole process of the above method.</p>

    <p class="text-gray-300">To demonstrate the practicability of our method, we have applied the methods presented in this section to SIMON, PRESENT-128, LBlock and DES(L) <em>[43]</em>, and the results are given in Appendix B. For all these ciphers, we obtain better (related-key) differential characteristics than all previous published results.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">On the Quality of the Characteristics.</h4>

    <p class="text-gray-300">The characteristics found by this method are not guaranteed to be the best. However, if you would like to wait until the optimizer outputs optimum solution, the characteristic found by this method is guaranteed to have the minimum number of active S-boxes. Experimental results show that we get reasonably good solutions. Moreover, the differential probabilities the active S-boxes take largely obey the differential distribution table. For example, for the S-box of PRESENT-128, there are 96 possible nonzero differential patterns in total: 24 of them are of probability <span class="math">2^{-2}</span>, and 72 of them are of probability <span class="math">2^{-3}</span>. In the 7-round PRESENT-128 related-key characteristic we found, there are 4 active S-boxes. One of them are of probability <span class="math">2^{-3}</span>, and all other active S-boxes takes the probability of <span class="math">2^{-2}</span>.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">On the Flexibility of the Searching Algorithm.</h4>

    <p class="text-gray-300">By adding a small number of additional constraints, our method can be used to search characteristics with specific properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By setting some given variables marking the activity of some S-boxes to 1, we can search for characteristics with active S-boxes of predefined positions, which may be used in leaked-state forgery attacks <em>[69]</em>.</li>

      <li>By requiring the output and input variables to be the same, we can search for iterative characteristics.</li>

      <li>By setting all the variables marking the activity of all the S-boxes in the key schedule algorithm to be 0, we can search for characteristics with 0 active S-boxes in its key schedule algorithm, which may be preferred in the related-key differential attack.</li>

    </ol>

    <p class="text-gray-300">6 Conclusion and Directions for Future Work</p>

    <p class="text-gray-300">In this paper, we bring new constraints into the MILP model to describe the differential properties of a specific S-box, and obtain a more accurate MILP model for the differential behavior of a block cipher.</p>

    <p class="text-gray-300">Based on these constraints, we propose an automatic method for evaluating the security of bit-oriented block ciphers with respect to (related-key) differential attack. We also present a new tool for finding (related-key) characteristics automatically. By using these methods, we obtain tighter security bounds for some bit-oriented block ciphers, and related-key characteristics which cover larger number of rounds or have larger probabilities than all previously known results.</p>

    <p class="text-gray-300">At this point, several open problems emerge. Firstly, we have observed that the MILP instances derived from such cryptographic problems are very hard to solve compared with general MILP problems with the same scale with respect to the numbers of variables and constraints. Hence, it is interesting to develop specific methods to accelerate the solving process of such problems and therefore increase the number of rounds of the cipher under consideration that can be dealt with. Secondly, the method presented in this paper is very general. Is it possible to develop a compiler which can convert a standard description, say a description using hardware description language <em>[55]</em>, of a cipher into an MILP instance to automate the entire security evaluation cycle with respect to (related-key) differential attack?</p>

    <p class="text-gray-300">Finally, the methodology presented in this paper has some limitations which we would like to make clear, and trying to overcome these limitations is a topic deserving further investigation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>This methodology is only suitable to evaluate the security of constructions with S-boxes, XOR operations and bit permutations, and can not be applied to block cipher like SPECK <em>[5]</em>, which involve modulo addition and no S-boxes at all. For tools which can be applied to ARX constructions, we refer the reader to <em>[13, 45, 46, 47, 50]</em>.</li>

      <li>We do do consider the differential effect and we assume that the expected differential probability (EDP) <span class="math">\\pi</span> of a characteristic over all keys is (almost) the same as the fixed-key differential probability (DP) <span class="math">\\pi_{K}</span> for almost all keys (the common hypothesis of stochastic equivalence presented in Lai et al.’s work on Markov Ciphers <em>[41]</em>), and that if the lower bound of the EDP for any characteristic of a block cipher is less than <span class="math">2^{-s}</span>, where <span class="math">s</span> is bigger than the block size or key size of the cipher, then the block cipher is secure against the (related-key) differential attack, which is a common assumption in almost all works on practical analysis of block ciphers. For more in-depth discussion of the essential gap between EDP <span class="math">\\pi</span> and DP <span class="math">\\pi_{K}</span>, and what the bounds on EDP actually mean for the security of a block cipher once a key is fixed, we refer the reader to <em>[14]</em> for more information.</li>

    </ol>

    <p class="text-gray-300">Acknowledgements: The authors would like to thank the anonymous reviewers for their helpful comments and suggestions. The work of this paper is supported by the National Key Basic Research Program of China (2013CB834203, 2014CB340603), the National Natural Science Foundation of China (Grants 61472417, 61472415, 61402469 and 61272477), the Strategic Priority Research Program of Chinese Academy of Sciences under Grant XDA06010702, and the State Key Laboratory of Information Security, Chinese Academy of Sciences.</p>

    <h2 id="sec-23" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Albrecht, M., Cid, C.: Cold boot key recovery by solving polynomial systems with noise. In: Applied Cryptography and Network Security. pp. 57–72. Springer (2011)</li>

      <li>[2] Alex Biryukov, Arnab Roy, Vesselin Velichkov: Differential analysis of block ciphers SIMON and SPECK. In: Fast Software Encryption – FSE 2014 (2014)</li>

      <li>[3] Alkhzaimi, H.A., Lauridsen, M.M.: Cryptanalysis of the SIMON family of block ciphers. Cryptology ePrint Archive, Report 2013/543 (2013), http://eprint.iacr.org/2013/543</li>

      <li>[4] Aoki, K., Ichikawa, T., Kanda, M., Matsui, M., Moriai, S., Nakajima, J., Tokita, T.: Camellia: A 128-bit block cipher suitable for multiple platformsdesign andanalysis. In: Selected Areas in Cryptography – SAC 2001. pp. 39–56. Springer (2001)</li>

      <li>[5] Beaulieu, R., Shors, D., Smith, J., Treatman-Clark, S., Weeks, B., Wingers, L.: The SIMON and SPECK families of lightweight block ciphers. Cryptology ePrint Archive, Report 2013/404 (2013), http://eprint.iacr.org/2013/404</li>

      <li>[6] Beigel, R.: The polynomial method in circuit complexity. In: Structure in Complexity Theory Conference, 1993., Proceedings of the Eighth Annual. pp. 82–95. IEEE (1993)</li>

      <li>[7] Biham, E., Anderson, R., Knudsen, L.: Serpent: A new block cipher proposal. In: Fast Software Encryption – FSE 1998. pp. 222–238. Springer (1998)</li>

      <li>[</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(8) Biham, E., Shamir, A.: Differential cryptanalysis of DES-like cryptosystems. Journal of Cryptology 4(1), 3–72 (1991)</li>

      <li>(9) Bilgin, B., Bogdanov, A., Knežević, M., Mendel, F., Wang, Q.: FIDES: Lightweight authenticated cipher with side-channel resistance for constrained hardware. In: Cryptographic Hardware and Embedded Systems – CHES 2013, pp. 142–158. Springer (2013)</li>

      <li>(10) Biryukov, A.: Impossible differential attack. In: Encyclopedia of Cryptography and Security, pp. 597–597. Springer (2011)</li>

      <li>(11) Biryukov, A., Nikolić, I.: Automatic search for related-key differential characteristics in byte-oriented block ciphers: Application to AES, Camellia, Khazad and others. In: Advances in Cryptology – EUROCRYPT 2010, pp. 322–344. Springer (2010)</li>

      <li>(12) Biryukov, A., Nikolić, I.: Search for related-key differential characteristics in DES-like ciphers. In: Fast Software Encryption – FSE 2011. pp. 18–34. Springer (2011)</li>

      <li>(13) Biryukov, A., Velichkov, V.: Automatic search for differential trails in ARX ciphers. In: Topics in Cryptology – CT-RSA 2014, pp. 227–250. Springer (2014)</li>

      <li>(14) Blondeau, C., Bogdanov, A., Leander, G.: Bounds in shallows and in miseries. In: Advances in Cryptology – CRYPTO 2013, pp. 204–221. Springer (2013)</li>

      <li>(15) Bogdanov, A.: On unbalanced feistel networks with contracting MDS diffusion. Designs, Codes and Cryptography 59(1-3), 35–58 (2011)</li>

      <li>(16) Bogdanov, A., Knudsen, L.R., Leander, G., Paar, C., Poschmann, A., Robshaw, M.J., Seurin, Y., Vikkelsoe, C.: PRESENT: An ultra-lightweight block cipher. In: Cryptographic Hardware and Embedded Systems – CHES 2007, pp. 450–466. Springer (2007)</li>

      <li>(17) Borghoff, J., Canteaut, A., Güneysu, T., Kavun, E.B., Knezevic, M., Knudsen, L.R., Leander, G., Nikov, V., Paar, C., Rechberger, C., et al.: Prince–a low-latency block cipher for pervasive computing applications. In: Advances in Cryptology – ASIACRYPT 2012, pp. 208–225. Springer (2012)</li>

      <li>(18) Borghoff, J., Knudsen, L.R., Stolpe, M.: Bivium as a mixed-integer linear programming problem. In: Cryptography and Coding, pp. 133–152. Springer (2009)</li>

      <li>(19) Bulygin, S., Walter, M.: Study of the invariant coset attack on PRINTcipher: more weak keys with practical key recovery. Tech. rep., Cryptology ePrint Archive, Report 2012/85 (2012), http://eprint.iacr.org/2012/085.pdf</li>

      <li>(20) CPLEX, IBM ILOG: IBM software group. User-Manual CPLEX 12 (2011)</li>

      <li>(21) Daemen, J., Rijmen, V., Proposal, A.: Rijndael. In: Proceedings from the First Advanced Encryption Standard Candidate Conference, National Institute of Standards and Technology (NIST) (1998)</li>

      <li>(22) Elena Andreeva, Begül Bilgin, Andrey Bogdanov, Atul Luykx, Florian Mendel, Bart Mennink, Nicky Mouha, Qingju Wang, Kan Yasuda: PRIMATEs v1. CAESAR submission (2014), http://competitions.cr.yp.to/round1/primatesv1.pdf</li>

      <li>(23) Elif Bilge Kavun, Martin M. Lauridsen, Gregor Leander, Christian Rechberger, Peter Schwabe, Tolga Yalcin: PrØst v1. CAESAR submission (2014), http://competitions.cr.yp.to/round1/proestv1.pdf</li>

      <li>(24) Emami, S., Ling, S., Nikolic, I., Pieprzyk, J., Wang, H.: The resistance of PRESENT-80 against related-key differential attacks. Cryptology ePrint Archive, Report 2013/522 (2013), http://eprint.iacr.org/</li>

      <li>(25) Farzaneh Abed, Eik List, Jakob Wenzel, Stefan Lucks: Differential cryptanalysis of round-reduced SIMON and SPECK. In: Fast Software Encryption – FSE 2014 (2014)</li>

      <li>(26) Farzaneh Abed, Eik List, Stefan Lucks, Jakob Wenzel: Differential and linear cryptanalysis of reduced-round SIMON. Cryptology ePrint Archive, Report 2013/526 (2013), http://eprint.iacr.org/526/</li>

      <li>(27) Fouque, P.A., Jean, J., Peyrin, T.: Structural evaluation of AES and chosen-key distinguisher of 9-round AES-128. In: Advances in Cryptology – CRYPTO 2013, pp. 183–203. Springer (2013)</li>

      <li>(28) Fuhr, T.: Finding second preimages of short messages for Hamsi-256. In: Advances in Cryptology – ASIACRYPT 2010, pp. 20–37. Springer (2010)</li>

      <li>(29) Gong, Z., Nikova, S., Law, Y.W.: Klein: a new family of lightweight block ciphers. In: RFID. Security and Privacy, pp. 1–18. Springer (2012)</li>

      <li>(30) Goodman, J.E., O’Rourke, J.: Handbook of discrete and computational geometry. CRC press (2010)</li>

      <li>(31) Guo, J., Peyrin, T., Poschmann, A., Robshaw, M.: The LED block cipher. In: Cryptographic Hardware and Embedded Systems – CHES 2011, pp. 326–341. Springer (2011)</li>

      <li>(32) Ivica Nikolic: Tweaking AES. In: Selected Areas in Cryptography–SAC 2010. pp. 198–210. Springer (2010)</li>

      <li>(33) Izadi, M., Sadeghiyan, B., Sadeghian, S.S., Khanooki, H.A.: MIBS: a new lightweight block cipher. In: Cryptology and Network Security, pp. 334–348. Springer (2009)</li>

      <li>(34) Javad Alizadeh, Nasour Bagheri, Praveen Gauravaram, Abhishek Kumar, and Somitra Kumar Sanadhya: Linear cryptanalysis of round reduced SIMON. Cryptology ePrint Archive, Report 2013/663 (2013), http://eprint.iacr.org/2013/663</li>

      <li>(35) Jérémy Jean, Ivica Nikolić, Thomas Peyrin: Deoxys v1. CAESAR submission (2014), http://competitions.cr.yp.to/round1/deoxysv1.pdf</li>

      <li>(36) Jérémy Jean, Ivica Nikolić, Thomas Peyrin: Joltik v1. CAESAR submission (2014), http://competitions.cr.yp.to/round1/joltikv1.pdf</li>

      <li>(37) Jérémy Jean, Ivica Nikolić, Thomas Peyrin: Kiasu v1. CAESAR submission (2014), http://competitions.cr.yp.to/round1/kiasuv1.pdf</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(38) Knellwolf, S., Meier, W., Naya-Plasencia, M.: Conditional differential cryptanalysis of NLFSR-based cryptosystems. In: Advances in Cryptology – ASIACRYPT 2010, pp. 130–145. Springer (2010)</li>

      <li>(39) Knellwolf, S., Meier, W., Naya-Plasencia, M.: Conditional differential cryptanalysis of Trivium and KATAN. In: Selected Areas in Cryptography – SAC 2012. pp. 200–212. Springer (2012)</li>

      <li>(40) Knudsen, L.R.: Truncated and higher order differentials. In: Fast Software Encryption – FSE 1995. pp. 196–211. Springer (1995)</li>

      <li>(41) Lai, X., Massey, J.L., Murphy, S.: Markov ciphers and differential cryptanalysis. In: Advances in Cryptology – EUROCRYPT91. pp. 17–38. Springer (1991)</li>

      <li>(42) Lamberger, M., Nad, T., Rijmen, V.: Numerical solvers and cryptanalysis. Journal of mathematical cryptology 3(3), 249–263 (2009)</li>

      <li>(43) Leander, G., Paar, C., Poschmann, A., Schramm, K.: New lightweight DES variants. In: Fast Software Encryption – FSE 2007. pp. 196–210. Springer (2007)</li>

      <li>(44) Lehmann, M., Meier, W.: Conditional differential cryptanalysis of Grain-128a. In: Cryptology and Network Security, pp. 1–11. Springer (2012)</li>

      <li>(45) Leurent, G.: Construction of differential characteristics in ARX designs application to Skein. In: Advances in Cryptology – CRYPTO 2013, pp. 241–258. Springer (2013)</li>

      <li>(46) Lipmaa, H., Moriai, S.: Efficient algorithms for computing differential properties of addition. In: Fast Software Encryption–FSE 2001. pp. 336–350. Springer (2002)</li>

      <li>(47) Lipmaa, H., Wallén, J., Dumas, P.: On the additive differential probability of exclusive-or. In: Fast Software Encryption – FSE 2004. pp. 317–331. Springer (2004)</li>

      <li>(48) Marr, D.T., Binns, F., Hill, D.L., Hinton, G., Koufaty, D.A., Miller, J.A., Upton, M.: Hyper-threading technology architecture and microarchitecture. Intel Technology Journal 6(1) (2002)</li>

      <li>(49) Matsui, M.: On correlation between the order of S-boxes and the strength of DES. In: Advances in Cryptology – EUROCRYPT’94. pp. 366–375. Springer (1995)</li>

      <li>(50) Mouha, N., Preneel, B.: Towards finding optimal differential characteristics for ARX: Application to Salsa20. Cryptology ePrint Archive, Report 2013/328 (2013), http://eprint.iacr.org/2013/328</li>

      <li>(51) Mouha, N., Wang, Q., Gu, D., Preneel, B.: Differential and linear cryptanalysis using mixed-integer linear programming. In: Information Security and Cryptology. pp. 57–76. Springer (2012)</li>

      <li>(52) Optimization, Gurobi: Gurobi optimizer reference manual. http://www.gurobi.com (2013)</li>

      <li>(53) Oren, Y., Kirschbaum, M., Popp, T., Wool, A.: Algebraic side-channel analysis in the presence of errors. In: Cryptographic Hardware and Embedded Systems – CHES 2010, pp. 428–442. Springer (2010)</li>

      <li>(54) Özen, O., Varıcı, K., Tan, C., Kocair, Ç.: Lightweight block ciphers revisited: Cryptanalysis of reduced round PRESENT and HIGHT. In: Information Security and Privacy. pp. 90–107. Springer (2009)</li>

      <li>(55) Pedroni, V.A.: Circuit design with VHDL. The MIT Press (2004)</li>

      <li>(56) Preparata, F.P., Shamos, M.I.: Computational geometry: An introduction (monographs in computer science). Monographs in Computer Science (Springer-Verlag, New York, 1985), ISBN 3540961313 (1993)</li>

      <li>(57) Shibutani, K., Isobe, T., Hiwatari, H., Mitsuda, A., Akishita, T., Shirai, T.: Piccolo: an ultra-lightweight block-cipher. In: Cryptographic Hardware and Embedded Systems–CHES 2011, pp. 342–357. Springer (2011)</li>

      <li>(58) Siwei Sun, Lei Hu, Ling Song, Yonghong Xie, Peng Wang: Automatic security evaluation of block ciphers with s-bp structures against related-key differential attacks. In: International Conference on Information Security and Cryptology – Inscrypt 2013 (2013)</li>

      <li>(59) Stein, W., et al.: Sage: Open source mathematical software (2008)</li>

      <li>(60) Suzuki, T., Minematsu, K., Morioka, S., Kobayashi, E.: Twine: A lightweight, versatile block cipher. In: ECRYPT Workshop on Lightweight Cryptography. pp. 146–169 (2011)</li>

      <li>(61) Tezcan, C.: Improbable differential attacks on PRESENT using undisturbed bits. Journal of Computional and Applied Mathematics 259, 503–511 (2014)</li>

      <li>(62) Van Rossum, G., et al.: Python programming language. In: USENIX Annual Technical Conference (2007)</li>

      <li>(63) Wagner, D.: The boomerang attack. In: Fast Software Encryption – FSE 1999. pp. 156–170. Springer (1999)</li>

      <li>(64) Walter, M., Bulygin, S., Buchmann, J.: Optimizing guessing strategies for algebraic cryptanalysis with applications to EPCBC. In: International Conference on Information Security and Cryptology–Inscrypt 2012. pp. 175–197. Springer (2012)</li>

      <li>(65) Williams, H.P.: Logical problems and integer programming. Bulletin of the Institute of Mathematics and its Applications 13, 18–20 (1977)</li>

      <li>(66) Williams, H.P.: Model building in mathematical programming. Wiley (1999)</li>

      <li>(67) Winnen, L.: Sage S-box MILP toolkit, http://www.ecrypt.eu.org/tools/sage-s-box-milp-toolkit</li>

      <li>(68) Wu, S., Wang, M.: Security evaluation against differential cryptanalysis for block cipher structures. Tech. rep., Cryptology ePrint Archive, Report 2011/551 (2011), http://eprint.iacr.org/2011/551.pdf</li>

      <li>(69) Wu, S., Wu, H., Huang, T., Wang, M., Wu, W.: Leaked-state-forgery attack against the authenticated encryption algorithm ALE. In: Advances in Cryptology – ASIACRYPT 2013, pp. 377–404. Springer (2013)</li>

      <li>(70) Wu, W., Zhang, L.: LBlock: a lightweight block cipher. In: Applied Cryptography and Network Security. pp. 327–344. Springer (2011)</li>

      <li>(71) Yap, H., Khoo, K., Poschmann, A., Henricksen, M.: EPCBC-a block cipher suitable for electronic product code encryption. In: Cryptology and Network Security, pp. 76–97. Springer (2011)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Yu Sasaki, Yosuke Todo, Kazumaro Aoki, Yusuke Naito, Takeshi Sugawara, Yumiko Murakami, Mitsuru Matsui, Shoichi Hirose: Minalpher v1. CAESAR submission (2014), http://competitions.cr.yp.to/round1/minalpherv1.pdf</li>

    </ol>

    <p class="text-gray-300">In this section, we apply our method to two block ciphers with different structures. One is the bit-oriented SPN block cipher PRESENT-80, and the other is the bit-oriented Feistel block cipher LBlock.</p>

    <p class="text-gray-300">We have applied the logical condition modelling method presented in Sect. 3.1 to the block cipher PRESENT-80 to determine its security bound with respect to the related-key differential attack. A Python module [62] is developed to generate the MILP instances in "lp" format [20]. In each of these MILP models, we include one more constraint to ensure that the difference of the initial key register is nonzero, since the case where the difference of the initial key register is zero can be analyzed in the single-key model. Then we employ the Gurobi 5.5 optimizer [52] to solve the MILP instances.</p>

    <p class="text-gray-300">By default the computations are performed on a PC using 4 threads with Intel(R) Core(TM) Quad CPU (2.83GHz, 3.25GB RAM, Windows XP), and a star “*” is appended on a timing data to mark that the corresponding computation is taken on a workstation equipped with two Intel(R) Xeon(R) E5620 CPU(2.4GHz, 8GB RAM, 8 cores). Despite there are only 2 CPUs and 8 physical cores in total on the workstation, we fire up 16 threads in Gurobi5.5 to solve the corresponding MILP instances to exploit Intel's Hyper-Threading Technology [48], where for each physical core, the operating system simulates two virtual or logical cores, and shares the workload between them.</p>

    <p class="text-gray-300">We have computed the number of active S-boxes for PRESENT-80 in the related-key model up to 14 rounds, and the results and a comparison with previous results without using CDP constraints are summarized in Table 4. For example, according to the 6th row of Table 4, the Gurobi optimizer finds that the minimum number of active S-boxes for 6-round PRESENT-80 is at least 5 in no more than 16 seconds by solving the MILP model with CDP constraints.</p>

    <p class="text-gray-300">Table 4: Results obtained from MILP models for PRESENT-80 with and without CDP constraints</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With CDP Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without CDP Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"># Active S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700"># Time(in seconds)</td>

            <td class="px-3 py-2 border-b border-gray-700"># Active S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700"># Time(in seconds)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">522</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">4158</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1540</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">18124</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">8136</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">50017</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">18102</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">137160*</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">49537*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">1316808*</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">685372*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">>20days</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">>20days</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These results clearly demonstrate that the MILP models with CDP constraints lead to tighter security bounds. In particular, we have proved that there are at least 16 active S-boxes in the best related-key differential characteristic for any consecutive 12-rounds of PRESENT-80. Therefore, the probability of the best related-key differential characteristic of 24-round PRESENT-80 is  <span class="math">(2^{-2})^{16} \\times (2^{-2})^{16} = 2^{-64}</span> , leading</p>

    <p class="text-gray-300">to the result that the 24-round PRESENT-80 is resistant to basic related-key differential attack based on related-key differential characteristic (rather than differential). For round reduced variants of PRESENT-80 with round  <span class="math">r \\geq 15</span> , we are unable to accomplish the computation within 20 days.</p>

    <p class="text-gray-300">It is possible to get tighter security bounds by adding more constraints: experimental result shows that, by adding 6 more valid cutting-off inequalities listed in Table 3 to the MILP problems for each S-box appearing in the schematic representation of PRESENT-80, we are able to prove that the guaranteed number of active S-boxes in related-key model for 7-round PRESENT-80 is at least 8, which is the tightest bound obtained so far (see Table 4 for comparison).</p>

    <p class="text-gray-300">Up to now, there is no concrete result concerning the security of full-round LBlock [70] against differential attack in the related-key model due to a lack of proper tools for bit-oriented designs.</p>

    <p class="text-gray-300">Since the encryption process of LBlock is nibble-oriented, the security of LBlock against single-key differential attack can be evaluated by those word-oriented techniques. However, the “ <span class="math">\\ll 29</span> ” operations in the key schedule algorithm of LBlock destroy its overall nibble-oriented structure, and make those word-oriented approaches infeasible in evaluating the security of LBlock against the related-key differential attack.</p>

    <p class="text-gray-300">In this subsection, we apply the method proposed in this paper to LBlock, and some results concerning its security against related-key differential attacks are obtained. Note that the type of constraints given in (5) are removed in our MILP models for LBlock according to the explanations presented in previous sections.</p>

    <p class="text-gray-300">From Table 5, we can deduce that the probability of the best differential characteristic for full LBlock (totally  <span class="math">32 = 11 + 11 + 10</span>  rounds) is upper bounded by  <span class="math">(2^{-2})^{10} \\times (2^{-2})^{10} \\times (2^{-2})^{8} = 2^{-56}</span>  (This result will be improved in the following), where  <span class="math">2^{-2}</span>  is the MDP for a single S-box of LBlock.</p>

    <p class="text-gray-300">Table 5: Results for related-key differential analysis on LBlock (The #Variables column records the sum of the number of the 0-1 variables and continuous variables in the MILP model).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#Variables</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#Active S-boxes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (in seconds)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">218+104 = 322</td>

            <td class="px-3 py-2 border-b border-gray-700">660</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">292+208 = 500</td>

            <td class="px-3 py-2 border-b border-gray-700">1319</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">366+312 = 678</td>

            <td class="px-3 py-2 border-b border-gray-700">1978</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">440+416 = 856</td>

            <td class="px-3 py-2 border-b border-gray-700">2637</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">514+520 = 1034</td>

            <td class="px-3 py-2 border-b border-gray-700">3296</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">588+624 = 1212</td>

            <td class="px-3 py-2 border-b border-gray-700">3955</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">662+728 = 1390</td>

            <td class="px-3 py-2 border-b border-gray-700">4614</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">736+832 = 1568</td>

            <td class="px-3 py-2 border-b border-gray-700">5273</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">810+936 = 1746</td>

            <td class="px-3 py-2 border-b border-gray-700">5932</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">386</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">884+1040 = 1924</td>

            <td class="px-3 py-2 border-b border-gray-700">6591</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">19932</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">958+1144 = 2102</td>

            <td class="px-3 py-2 border-b border-gray-700">7250</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">43793</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In fact, here we have an implicit trade-off between the number of constraints we use and the number of rounds we analyze. For example, we can use less constraints for every S-box and try to analyze more rounds, or we can use more constraints and focus on less rounds (but stronger bounds). However, it is not a simple task to find the best trade-off due to our limited computational power. We do try to analyze more rounds by using only one inequality selected from the convex hull for every S-box. The largest number of rounds we are able to analyze is 13, and we have proved that there are at least 13 active S-boxes in any related-key characteristic for 13-round LBlock on a PC with Intel(R) Core(TM) i7-3370 CPU (3.40GHz, 8GBRAM, Window7, 8 cores in total) in roughly 49 days.</p>

    <p class="text-gray-300">Then, we try to improve the above result with the two techniques presented in Sect. 4.1. By using the first technique, we are managed to prove the following results.</p>

    <p class="text-gray-300">Fact 3. There are at least 13 active S-boxes in a 13-round related-key differential characteristic of LBlock, and there is at least one active S-box taking a differential pattern with probability  <span class="math">2^{-3}</span>  in any 13-round related-key differential characteristic of LBlock with only 13 active S-boxes. Therefore, the probability of a 13-round related-key differential characteristic of LBlock is upper bounded by  <span class="math">(2^{-2})^{12} \\times (2^{-3}) = 2^{-27}</span> .</p>

    <p class="text-gray-300">We now turn to the second technique presented in Sect. 4.1. By adding the constraint that the number of active S-boxes of any characteristic covering round 22 to round 26 (5 rounds in total) has at least 1 active</p>

    <p class="text-gray-300">S-box (see Table 5), and at most 12 active S-boxes to a 11-round (round 22 to round 32) MILP model (If this is not the case, it will enable us to get better bounds than the result presented here), we can show that there are at least 3 active S-boxes in a characteristic covering round 27 to round 32 (6 rounds in total). Combined with Fact 3, we have that the probability of the best related-key differential characteristic for full LBlock is upper bounded by  <span class="math">2^{-27} \\times 2^{-27} \\times (2^{-2})^3 = 2^{-60}</span> .</p>

    <p class="text-gray-300">SIMON [5] is a family of lightweight block ciphers designed by the U.S National Security Agency (NSA), which offers excellent performance on both hardware and software platforms. The design of SIMON <span class="math">n_b</span> / <span class="math">n_K</span>  is a Feistel scheme with a block size of  <span class="math">n_b</span>  bits and key size of  <span class="math">n_K</span>  bits. The bitwise AND operation is the only nonlinear operation of SIMON <span class="math">n_b</span> / <span class="math">n_K</span> . For a detailed description of SIMON and existing attacks on it, we refer the reader to [2,3,25,26,34].</p>

    <p class="text-gray-300">By treating the AND  <span class="math">(\\mathbb{F}_2\\times \\mathbb{F}_2\\to \\mathbb{F}_2)</span>  operation as a  <span class="math">2\\times 1</span>  S-box, we apply our method to SIMON in the single-key model. We produce similar results as that presented in [2] for SIMON32/nK and SIMON64/nK. For SIMON48 we obtain a 15-round differential characteristic with probability  <span class="math">2^{-46}</span>  (see Table 6), which is the best 15-round differential characteristic for 15-round SIMON48 published so far. If we fix the input and output differences to be the differences suggested by the characteristic we found, we can compute the probability of this differential by searching all characteristics with probability greater than  <span class="math">2^{-54}</span>  in this differential, and the result is  <span class="math">2^{-41.96}</span>  which is also the best result published so far.</p>

    <p class="text-gray-300">We would like to emphasize that in our MILP models we treat the input bits of the AND operation as independent input bits, and the dependencies of the input bits to the AND operation are not considered. Therefore, the characteristic obtained by our method is not guaranteed to be valid. Hence, every time after the Gurobi optimizer outputs a good solution (characteristic), we check its validity and compute its probability by the method presented in [2].</p>

    <p class="text-gray-300">Table 6: Single-key Differential Characteristic of 15-round SIMON48</p>

    <p class="text-gray-300">|  SIMON48  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">000000001000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">000000100010001000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000100000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000010000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000010000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">00000010000010000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000010</td>

            <td class="px-3 py-2 border-b border-gray-700">00000010000010000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">001000001000001000001000</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000010</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000010</td>

            <td class="px-3 py-2 border-b border-gray-700">001000001000001000001000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">00000010000010000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000010</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000010000010000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000010000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000001000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000010001000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000010000000000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By adding a constraint that there is no active S-box in the key schedule algorithm, we obtain a 7-round related-key differential characteristic for PRESENT-128 with probability  <span class="math">2^{-11}</span>  and 0 active S-box in its key schedule algorithm (see Table 7 and Table 8). This characteristic is better than the 7-round characteristic</p>

    <p class="text-gray-300">presented in [54], and based on this characteristic and the characteristic presented in [54], an improved related-key boomerang attack on 17-round PRESENT-128 which is better than that presented in [54] can be constructed.</p>

    <p class="text-gray-300">Table 7: A 7-round Related-key Characteristic for PRESENT-128 (Characteristic in the Encryption Process)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The input and output differences of the S-box layer</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">In</td>

            <td class="px-3 py-2 border-b border-gray-700">Out</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">0101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">0101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">01010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">01010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">0101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8: A 7-round Related-key Characteristic for PRESENT-128 (Characteristic in the Key Schedule Algorithm)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The Differences in the Key Register</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We obtain a 14-round related-key differential characteristic of LBlock with only 20 active Sboxes and probability  <span class="math">2^{-49}</span>  in no more than 4 hours on a PC, and the characteristic is given in Fig. 2 and Fig. 3. Note that the probabilities of the best previously published related-key characteristics covering 13- and 14-round LBlock is  <span class="math">2^{-53}</span>  and  <span class="math">2^{-65}</span>  [70], respectively.</p>

    <p class="text-gray-300">For DES, we do not get better results compared to [12]. For DESL, we obtain an 8-round related-key differential characteristic of DESL with probability  <span class="math">2^{-34.78}</span>  in no more than 10 minutes on a PC, and the characteristic is given in Table 9 and Table 10. To the best of our knowledge, there is no related-key differential characteristic covering more than 7 rounds of DESL have been published before.</p>

    <p class="text-gray-300">Note that, like DES, there are related-key differential characteristics of DESL that hold with probability 1 and activate no S-box at all. In our searching algorithm we do not interest in such characteristics, and we remove such characteristic from the feasible region of our MILP model by dictating that there are at least one active S-box. In fact, if we do not add this constraint, our method can discover such characteristic (with probability 1) automatically in no more than 5 seconds, which surprised us a lot.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: A 14-round Related-key Differential Characteristic of LBlock (Characteristic in the Key Schedule Algorithm); a black square represents 1, and a white square represents 0.</p>

    <p class="text-gray-300">Table 9: An 8-round related-key differential characteristic for DESL (characteristic in the encryption process)</p>

    <p class="text-gray-300">|  DESL  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 10: An 8-round related-key differential characteristic for DESL (Characteristic in the key schedule algorithm)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Differences in the Key Register</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 3: A 14-round Related-key Differential Characteristic of LBlock (Characteristic in the Encryption Process)</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a></p>

    <p class="text-gray-300">Example code for computing the H-representation of the convex hull of a set of points.</p>

    <p class="text-gray-300">myPoints = [\\</p>

    <p class="text-gray-300">[0, 0, 0, 0, 0, 0, 0, 0],\\</p>

    <p class="text-gray-300">[0, 0, 0, 1, 1, 0, 0, 0],\\</p>

    <p class="text-gray-300">[0, 0, 0, 1, 1, 0, 0, 1],\\</p>

    <p class="text-gray-300">[0, 0, 0, 1, 1, 0, 1, 0],\\</p>

    <p class="text-gray-300">[0, 0, 0, 1, 1, 0, 1, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 0, 0, 0, 0, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 0, 0, 0, 1, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 0, 0, 1, 0, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 0, 0, 1, 1, 0],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 0, 0, 0],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 0, 0, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 0, 1, 0],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 1, 0, 0],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[0, 0, 1, 1, 1, 1, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 0, 0, 0, 0, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 0, 0, 1, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 0, 0, 1, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 0, 0, 1, 0, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 0, 0, 1, 1, 0, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 0, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[0, 1, 0, 1, 0, 0, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 1, 0, 1, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 1, 0, 1, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 0, 1, 1, 0, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 1, 1, 1, 0, 0],\\</p>

    <p class="text-gray-300">[0, 1, 0, 1, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 0, 0, 0, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 0, 0, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 0, 1, 0, 0],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 0, 1, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 1, 0, 0, 0],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 1, 0, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 0, 1, 1, 1, 0],\\</p>

    <p class="text-gray-300">[0, 1, 1, 1, 0, 0, 0, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 1, 0, 0, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 1, 0, 1, 0, 0],\\</p>

    <p class="text-gray-300">[0, 1, 1, 1, 0, 1, 1, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 1, 1, 0, 0, 1],\\</p>

    <p class="text-gray-300">[0, 1, 1, 1, 1, 1, 1, 1],\\</p>

    <p class="text-gray-300">[1, 0, 0, 0, 0, 1, 0, 0],\\</p>

    <p class="text-gray-300">[1, 0, 0, 0, 0, 1, 0, 1],\\</p>

    <p class="text-gray-300">[1, 0, 0, 0, 1, 1, 0, 0],\\</p>

    <p class="text-gray-300">[1, 0, 0, 0, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[1, 0, 0, 0, 1, 1, 1, 0],\\</p>

    <p class="text-gray-300">[1, 0, 0, 0, 1, 1, 1, 1],\\</p>

    <p class="text-gray-300">[1, 0, 0, 1, 0, 1, 0, 0],\\</p>

    <p class="text-gray-300">[1, 0, 0, 1, 0, 1, 0, 1],\\</p>

    <p class="text-gray-300">[1, 0, 0, 1, 1, 1, 0, 0],\\</p>

    <p class="text-gray-300">[1, 0, 0, 1, 1, 1, 0, 1],\\</p>

    <p class="text-gray-300">[1, 0, 0, 1, 1, 1, 1, 0],\\</p>

    <p class="text-gray-300">[1, 0, 0, 1, 1, 1, 1, 1],\\ [1, 0, 1, 0, 0, 1, 0, 1],\\ [1, 0, 1, 0, 0, 1, 1, 0],\\ [1, 0, 1, 0, 1, 0, 0, 0],\\ [1, 0, 1, 0, 1, 0, 0, 1],\\ [1, 0, 1, 0, 1, 0, 1, 0],\\ [1, 0, 1, 0, 1, 0, 1, 1],\\ [1, 0, 1, 1, 0, 0, 0, 1],\\ [1, 0, 1, 1, 0, 0, 1, 1],\\ [1, 0, 1, 1, 1, 1, 0, 0],\\ [1, 0, 1, 1, 1, 1, 0, 1],\\ [1, 0, 1, 1, 1, 1, 1, 0],\\ [1, 0, 1, 1, 1, 1, 1, 1],\\ [1, 1, 0, 0, 0, 0, 1, 0],\\ [1, 1, 0, 0, 0, 1, 1, 0],\\ [1, 1, 0, 0, 0, 1, 1, 1],\\ [1, 1, 0, 0, 1, 0, 0, 0],\\ [1, 1, 0, 0, 1, 1, 1, 0],\\ [1, 1, 0, 0, 1, 1, 1, 1],\\ [1, 1, 0, 1, 0, 0, 1, 0],\\ [1, 1, 0, 1, 0, 1, 1, 0],\\ [1, 1, 0, 1, 0, 1, 1, 1],\\ [1, 1, 0, 1, 1, 0, 0, 1],\\ [1, 1, 0, 1, 1, 1, 1, 0],\\ [1, 1, 0, 1, 1, 1, 1, 1],\\ [1, 1, 1, 0, 0, 0, 0, 1],\\ [1, 1, 1, 0, 0, 0, 1, 1],\\ [1, 1, 1, 0, 0, 1, 0, 0],\\ [1, 1, 1, 0, 0, 1, 1, 1],\\ [1, 1, 1, 0, 1, 0, 0, 1],\\ [1, 1, 1, 0, 1, 0, 1, 1],\\ [1, 1, 1, 0, 1, 1, 0, 1],\\ [1, 1, 1, 1, 0, 0, 0, 1],\\ [1, 1, 1, 1, 0, 0, 1, 1],\\ [1, 1, 1, 1, 0, 1, 0, 0],\\ [1, 1, 1, 1, 1, 0, 1, 1, 1],\\ [1, 1, 1, 1, 1, 1, 0, 0, 0],\\ [1, 1, 1, 1, 1, 1, 0, 1, 0],\\ [1, 1, 1, 1, 1, 1, 1, 1, 1],</p>

    <p class="text-gray-300">D Example Source Code for Generating the MILP Model for LBlock</p>

    <pre><code class="language-text"># Example code for generating the MILP model for LBlock
# Run on Python 3

KEY_SIZE = 80
SUBKEY_SIZE = 32
WORD_SIZE = 4
marker = 0
add_counter = 0

S0_T = [(2, 1, 1, 1, -3, 0, 1, 2, 0),\\
(-1, 2, -2, -1, 0, 0, -2, -1, 5),\\
(0, 1, 0, 0, 1, -1, 1, 0, 0),\\
(-1, -1, 1, -3, 3, -1, -2, 2, 5),\\
(3, -1, -1, -1, 0, 3, 2, 1, 0),\\
(-1, 1, 2, 0, -1, -1, 2, -2, 3),\\
(0, -1, 0, 1, -1, 0, -1, 1, 2),\\
(0, -1, 0, 0, 1, 1, 1, 0, 0),\\
(-1, -1, -1, 0, -1, -1, 0, -1, 5),\\
(1, 2, -2, 1, 0, 0, 1, 2, 0),\\
(1, 2, 3, -2, 1, 0, -1, 3, 0),\\
(-1, 0, 0, 0, 1, 0, 1, 1, 0),\\
(1, 1, -2, -2, 0, -1, -1, -2, 6),\\
(-1, -1, 1, 0, -1, 1, -1, -1, 4),\\
(0, -1, -1, 1, 1, 1, 0, -1, 2),\\
(-1, 0, 1, 0, 1, 1, 1, 0, 0),\\
(1, 0, 1, 1, 0, -1, -1, -1, 2),\\
(1, -2, 1, -1, 2, 3, 1, 1, 0),\\
(-1, 1, 0, 0, -1, 1, 1, -1, 2),\\
(2, -1, -1, 0, -1, 1, 1, 1, 1),\\
(2, 3, 1, 1, 0, -3, 1, 1, 0),\\
(1, -1, -1, 0, 1, -1, -1, 1, 3),\\
(3, 1, 2, 1, -3, -1, 1, 3, 0),\\
(2, -1, -1, 1, -2, 1, 0, 1, 2),\\
(1, -1, 1, -1, 0, 1, 0, -1, 2),\\
(1, 1, 2, 2, 0, 1, 1, -2, 0),\\
(-1, -1, -1, -2, 2, 1, 0, 1, 3),\\
(0, -1, 1, 1, 1, -1, -1, -1, 3)]

S1_T = [(2, 1, 1, 1, -3, 0, 2, 1, 0),\\
(-1, 2, -2, -1, 0, 0, -1, -2, 5),\\
(0, 1, 0, 0, 1, -1, 0, 1, 0),\\
(-1, -1, 1, -3, 3, -1, 2, -2, 5),\\
(3, -1, -1, -1, 0, 3, 1, 2, 0),\\
(-1, 4, 5, 3, -1, -1, -2, 5, 0),\\
(0, -1, 0, 1, -1, 0, 1, -1, 2),\\
(0, -1, 0, 0, 1, 1, 0, 1, 0),\\
(1, 2, -2, 1, 0, 0, 2, 1, 0),\\
(-1, -1, -1, 0, -1, -1, -1, 0, 5),\\
(0, 1, 2, -2, 1, 0, 2, -1, 1),\\
(-1, 0, 0, 0, 1, 0, 1, 1, 0),\\
(1, 1, -2, -2, 0, -1, -2, -1, 6),\\
(2, 0, 1, 1, -2, -1, 1, -1, 2),\\
(-1, -1, 1, 0, -1, 1, -1, -1, 4),\\
(-1, 1, -1, 0, -1, 1, -1, 0, 3),\\
(1, -1, 1, -1, 0, 1, -1, 0, 2),\\
(-1, -1, -1, 0, 1, 1, -1, 0, 3),\\
(0, -1, 1, 1, 1, -1, -1, -1, 3),\\
(1, -1, -1, 1, 0, 1, -1, 0, 2),\\
(2, 3, 1, 1, 0, -3, 1, 1, 0),\\
(2, -1, 2, 3, -1, 2, 3, -1, 0),\\

24
</code></pre>

    <p class="text-gray-300">(-1, 1, 1, -1, 2, 0, 1, 1, 0),\\ (-1, -1, 0, 0, -1, -1, -1, 1, 4),\\ (1, -1, 0, 0, 0, 1, 0, 1, 0),\\ (3, -1, -1, 0, -1, 2, 2, 2, 0),\\ (1, 0, -1, 1, 0, -1, 1, -1, 2)]</p>

    <pre><code class="language-text"></code></pre>

    <p class="text-gray-300">S2_T = [(2, 1, 1, 1, 1, -3, 2, 0, 0),\\ (-1, 2, -2, -1, -2, 0, -1, 0, 5),\\ (0, 1, 0, 0, 1, 1, 0, -1, 0),\\ (-1, -1, 1, -3, -2, 3, 2, -1, 5),\\ (3, -1, -1, -1, 2, 0, 1, 3, 0),\\ (-1, 4, 5, 3, 5, -1, -2, -1, 0),\\ (0, -1, 0, 1, -1, -1, 1, 0, 2),\\ (0, -1, 0, 0, 1, 1, 0, 1, 0),\\ (-1, -1, -1, 0, 0, -1, -1, -1, 5),\\ (1, 2, -2, 1, 1, 0, 2, 0, 0),\\ (1, -2, 1, -2, 1, 3, 2, 4, 0),\\ (1, 1, -2, -2, -1, 0, -2, -1, 6),\\ (-1, 0, 0, 0, 1, 1, 1, 0, 0),\\ (2, 0, 1, 1, -1, -2, 1, -1, 2),\\ (0, -1, 1, 1, -1, 1, -1, -1, 3),\\ (0, 1, 1, -1, -1, 0, 1, 0, 1),\\ (-1, -1, -1, 0, 0, 1, -1, 1, 3),\\ (0, -1, 1, -1, -1, -1, -1, 1, 4),\\ (1, -1, -1, 1, 0, 0, -1, 1, 2),\\ (-1, 1, 0, 0, 1, -1, -1, 1, 2),\\ (3, 2, -1, 3, -1, 0, 3, -1, 0),\\ (1, 2, 1, 1, 1, 0, 0, -2, 0),\\ (-1, 2, 1, -2, 1, 3, 2, 0, 0),\\ (-1, 1, 2, 0, 2, -1, -2, -1, 3),\\ (3, 1, 2, 2, 1, -4, 2, 1, 0),\\ (-1, -1, 1, 1, -1, -1, 0, 1, 3),\\ (3, -1, -1, 0, 2, -1, 2, 2, 0)]</p>

    <pre><code class="language-text"></code></pre>

    <p class="text-gray-300">S3_T = [(2, 1, 1, 1, 0, 1, -3, 2, 0),\\ (-1, 2, -2, -1, 0, -2, 0, -1, 5),\\ (0, 1, 0, 0, -1, 1, 1, 0, 0),\\ (-1, -1, 1, -3, -1, -2, 3, 2, 5),\\ (3, -1, -1, -1, 3, 2, 0, 1, 0),\\ (-1, 1, 2, 0, -1, 2, -1, -2, 3),\\ (0, -1, 0, 1, 0, -1, -1, 1, 2),\\ (0, -1, 0, 0, 1, 1, 1, 0, 0),\\ (-1, -1, -1, 0, -1, 0, -1, -1, 5),\\ (1, 2, -2, 1, 0, 1, 0, 2, 0),\\ (1, 2, 2, -1, 0, -1, 0, 2, 0),\\ (1, 1, -2, -2, -1, -1, 0, -2, 6),\\ (-1, 0, 0, 0, 0, 1, 1, 1, 0),\\ (1, 0, 1, 1, -1, -1, 0, -1, 2),\\ (1, -1, -1, 1, 1, 0, 0, -1, 2),\\ (1, -1, 1, -1, 2, 0, 2, 1, 0),\\ (-1, 0, 1, 0, 1, 1, 1, 0, 0),\\ (-1, 0, -1, 0, 1, -1, 1, -1, 3),\\ (-1, 1, -1, 0, 1, 0, -1, -1, 3),\\ (0, -1, 1, -1, 1, -1, -1, -1, 4),\\ (3, 2, -1, 3, -1, -1, 0, 3, 0),\\ (1, 2, -1, 1, -1, 1, 0, 1, 0),\\ (3, 1, 2, 0, -1, 1, -2, 2, 0),\\ (-1, -1, 1, 1, 1, -1, -1, 0, 3),\\ (1, 1, 2, 2, 1, 1, 0, -2, 0),\\ (2, -1, -1, 0, 1, 1, -1, 1, 1),\\ (0, -1, 1, 1, -1, -1, 1, -1, 3)]</p>

    <pre><code class="language-text"></code></pre>

    <p class="text-gray-300">S4_T = [(2, 1, 1, 1, 1, -3, 0, 2, 0),\\</p>

    <p class="text-gray-300">25</p>

    <pre><code class="language-txt">(-1, 2, -2, -1, -2, 0, 0, -1, 5),\\
(0, 1, 0, 0, 1, 1, -1, 0, 0),\\
(-1, -1, 1, -3, -2, 3, -1, 2, 5),\\
(3, -1, -1, -1, 2, 0, 3, 1, 0),\\
(-1, 4, 5, 3, 5, -1, -1, -2, 0),\\
(0, -1, 0, 1, -1, -1, 0, 1, 2),\\
(0, -1, 0, 0, 1, 1, 1, 0, 0),\\
(-1, -1, -1, 0, 0, -1, -1, -1, 5),\\
(1, 2, -2, 1, 1, 0, 0, 2, 0),\\
(1, -1, 1, -1, -1, 2, 1, 1, 1),\\
(1, 1, -2, -2, -1, 0, -1, -2, 6),\\
(-1, 0, 0, 0, 1, 1, 0, 1, 0),\\
(-1, -1, -1, 0, 0, 1, 1, -1, 3),\\
(1, 0, 1, 1, -1, 0, -1, -1, 2),\\
(1, -1, -1, 1, 0, 0, 1, -1, 2),\\
(-1, 1, 0, 0, 1, -1, 1, -1, 2),\\
(2, 2, 3, -1, -1, 0, -1, 3, 0),\\
(0, -1, 1, -1, -1, -1, 1, -1, 4),\\
(3, -1, -1, 0, 2, -1, 2, 2, 0),\\
(-1, 1, 1, -1, 1, 2, 0, 1, 0),\\
(1, -1, 0, 0, 1, 0, 1, 0, 0),\\
(-1, -1, 1, 0, -1, 1, -1, -1, 4),\\
(2, 3, 1, 1, 1, 0, -3, 1, 0),\\
(1, 0, -1, 1, -1, 0, -1, 1, 2),\\
(0, 1, 2, -2, -1, 1, 0, 2, 1),\\
(-1, -1, 1, 1, -1, -1, 1, 0, 3),\\
(-1, 0, 1, 0, 1, -1, -1, -1, 3)]</code></pre>

    <pre><code class="language-txt">S5_T = [(2, 1, 1, 1, -3, 1, 0, 2, 0),\\
(-1, 2, -2, -1, 0, -2, 0, -1, 5),\\
(0, 1, 0, 0, 1, 1, -1, 0, 0),\\
(-1, -1, 1, -3, 3, -2, -1, 2, 5),\\
(3, -1, -1, -1, 0, 2, 3, 1, 0),\\
(-1, 1, 2, 0, -1, 2, -1, -2, 3),\\
(0, -1, 0, 1, -1, -1, 0, 1, 2),\\
(0, -1, 0, 0, 1, 1, 1, 0, 0),\\
(-1, -1, -1, 0, -1, 0, -1, -1, 5),\\
(1, 2, -2, 1, 0, 1, 0, 2, 0),\\
(1, -1, 1, -1, 2, -1, 1, 1, 1),\\
(-1, 0, 0, 0, 1, 1, 0, 1, 0),\\
(1, 1, -2, -2, 0, -1, -1, -2, 6),\\
(0, 1, 1, -1, 0, -1, 0, 1, 1),\\
(-1, 0, 1, 0, 1, 1, 1, 0, 0),\\
(1, 0, 1, 1, 0, -1, -1, -1, 2),\\
(1, -1, -1, 1, 0, 0, 1, -1, 2),\\
(-1, 1, -1, 0, -1, 0, 1, -1, 3),\\
(0, -1, 1, -1, -1, -1, 1, -1, 4),\\
(-1, -1, -1, 0, 1, 0, 1, -1, 3),\\
(2, -1, -1, 0, -1, 1, 1, 1, 1),\\
(1, -1, -1, 0, 1, -1, -1, 1, 3),\\
(1, 1, 0, 0, 0, 1, -1, 0, 0),\\
(5, 2, 4, 1, -4, 1, -2, 4, 0),\\
(1, 1, 2, 2, 0, 1, 1, -2, 0),\\
(-1, -1, 1, 1, -1, -1, 1, 0, 3),\\
(0, -1, 1, 1, 1, -1, -1, -1, 3)]</code></pre>

    <pre><code class="language-txt">S6_T = [(2, 1, 1, 1, -3, 0, 2, 1, 0),\\
(-1, 2, -2, -1, 0, 0, -1, -2, 5),\\
(0, 1, 0, 0, 1, -1, 0, 1, 0),\\
(-1, -1, 1, -3, 3, -1, 2, -2, 5),\\
(3, -1, -1, -1, 0, 3, 1, 2, 0),\\
(-1, 4, 5, 3, -1, -1, -2, 5, 0),\\
(0, -1, 0, 1, -1, 0, 1, -1, 2),

26

(0, -1, 0, 0, 1, 1, 0, 1, 0),\\
(1, 2, -2, 1, 0, 0, 2, 1, 0),\\
(-1, -1, -1, 0, -1, -1, -1, 0, 5),\\
(0, 1, 2, -2, 1, 0, 2, -1, 1),\\
(-1, 0, 0, 0, 1, 0, 1, 1, 0),\\
(1, 1, -2, -2, 0, -1, -2, -1, 6),\\
(2, 0, 1, 1, -2, -1, 1, -1, 2),\\
(-1, -1, 1, 0, -1, 1, -1, -1, 4),\\
(-1, 1, -1, 0, -1, 1, -1, 0, 3),\\
(1, -1, 1, -1, 0, 1, -1, 0, 2),\\
(-1, -1, -1, 0, 1, 1, -1, 0, 3),\\
(0, -1, 1, 1, 1, -1, -1, -1, 3),\\
(1, -1, -1, 1, 0, 1, -1, 0, 2),\\
(2, 3, 1, 1, 0, -3, 1, 1, 0),\\
(2, -1, 2, 3, -1, 2, 3, -1, 0),\\
(-1, 1, 1, -1, 2, 0, 1, 1, 0),\\
(-1, -1, 0, 0, -1, -1, -1, 1, 4),\\
(1, -1, 0, 0, 0, 1, 0, 1, 0),\\
(3, -1, -1, 0, -1, 2, 2, 2, 0),\\
(1, 0, -1, 1, 0, -1, 1, -1, 2)]

S7_T = [(2, 1, 1, 1, -3, 0, 2, 1, 0),\\
(-1, 2, -2, -1, 0, 0, -1, -2, 5),\\
(0, 1, 0, 0, 1, -1, 0, 1, 0),\\
(-1, -1, 1, -3, 3, -1, 2, -2, 5),\\
(3, -1, -1, -1, 0, 3, 1, 2, 0),\\
(-1, 4, 5, 3, -1, -1, -2, 5, 0),\\
(0, -1, 0, 1, -1, 0, 1, -1, 2),\\
(0, -1, 0, 0, 1, 1, 0, 1, 0),\\
(1, 2, -2, 1, 0, 0, 2, 1, 0),\\
(-1, -1, -1, 0, -1, -1, -1, 0, 5),\\
(0, 1, 2, -2, 1, 0, 2, -1, 1),\\
(-1, 0, 0, 0, 1, 0, 1, 1, 0),\\
(1, 1, -2, -2, 0, -1, -2, -1, 6),\\
(2, 0, 1, 1, -2, -1, 1, -1, 2),\\
(-1, -1, 1, 0, -1, 1, -1, -1, 4),\\
(-1, 1, -1, 0, -1, 1, -1, 0, 3),\\
(1, -1, 1, -1, 0, 1, -1, 0, 2),\\
(-1, -1, -1, 0, 1, 1, -1, 0, 3),\\
(0, -1, 1, 1, 1, -1, -1, -1, 3),\\
(1, -1, -1, 1, 0, 1, -1, 0, 2),\\
(2, 3, 1, 1, 0, -3, 1, 1, 0),\\
(2, -1, 2, 3, -1, 2, 3, -1, 0),\\
(-1, 1, 1, -1, 2, 0, 1, 1, 0),\\
(-1, -1, 0, 0, -1, -1, -1, 1, 4),\\
(1, -1, 0, 0, 0, 1, 0, 1, 0),\\
(3, -1, -1, 0, -1, 2, 2, 2, 0),\\
(1, 0, -1, 1, 0, -1, 1, -1, 2)]

S8_T = [(2, 1, 1, 1, 0, -3, 2, 1, 0),\\
(-1, 2, -2, -1, 0, 0, -1, -2, 5),\\
(0, 1, 0, 0, -1, 1, 0, 1, 0),\\
(-1, -1, 1, -3, -1, 3, 2, -2, 5),\\
(3, -1, -1, -1, 3, 0, 1, 2, 0),\\
(-1, 4, 5, 3, -1, -1, -2, 5, 0),\\
(0, -1, 0, 1, 0, -1, 1, -1, 2),\\
(0, -1, 0, 0, 1, 1, 0, 1, 0),\\
(1, 2, -2, 1, 0, 0, 2, 1, 0),\\
(-1, -1, -1, 0, -1, -1, -1, 0, 5),\\
(1, 1, 2, -1, -1, 0, 2, -1, 1),\\
(1, 1, -2, -2, -1, 0, -2, -1, 6),\\
(-1, 0, 0, 0, 0, 1, 1, 1, 0),\\
(3, 2, 3, 3, -1, 0, -1, -1, 0),\\

27

(1, -1, -1, 1, 1, 0, -1, 0, 2),\\
(1, -1, 1, -1, 1, 2, 1, -1, 1),\\
(-1, -1, -1, 0, 1, 1, -1, 0, 3),\\
(-1, 1, 0, 0, 1, -1, -1, 1, 2),\\
(0, -1, 1, -1, 1, -1, -1, -1, 4),\\
(-1, 2, 1, -2, 0, 3, 2, 1, 0),\\
(3, 2, -1, 3, -1, 0, 3, -1, 0),\\
(-1, -1, 0, 0, -1, -1, -1, 1, 4),\\
(-1, -1, 1, 0, -1, 1, -1, -1, 4),\\
(2, 3, 1, 1, -3, 0, 1, 1, 0),\\
(3, 1, 2, 2, 1, -4, 2, 1, 0),\\
(-1, -1, 1, 1, 1, -1, 0, -1, 3),\\
(-1, 1, 0, -1, 0, 0, 1, -1, 2),\\
(3, -1, -1, 0, 2, -1, 2, 2, 0)]

S9_T = [(2, 1, 1, 1, 1, 2, 0, -3, 0),\\
(-1, 2, -2, -1, -2, -1, 0, 0, 5),\\
(0, 1, 0, 0, 1, 0, -1, 1, 0),\\
(-1, -1, 1, -3, -2, 2, -1, 3, 5),\\
(3, -1, -1, -1, 2, 1, 3, 0, 0),\\
(-1, 4, 5, 3, 5, -2, -1, -1, 0),\\
(0, -1, 0, 1, -1, 1, 0, -1, 2),\\
(0, -1, 0, 0, 1, 0, 1, 1, 0),\\
(-1, -1, -1, 0, 0, -1, -1, -1, 5),\\
(1, 2, -2, 1, 1, 2, 0, 0, 0),\\
(1, -1, 1, -1, -1, 1, 1, 2, 1),\\
(1, 1, -2, -2, -1, -2, -1, 0, 6),\\
(-1, 0, 0, 0, 1, 1, 0, 1, 0),\\
(-1, -1, -1, 0, 0, -1, 1, 1, 3),\\
(-1, 1, 0, 0, 1, -1, 1, -1, 2),\\
(1, -1, -1, 1, 0, -1, 1, 0, 2),\\
(-1, 1, 0, -1, -1, 1, 0, 0, 2),\\
(6, 2, 3, 3, -1, 3, -1, -4, 0),\\
(0, -1, 1, 1, -1, -1, -1, 1, 3),\\
(0, -1, 1, -1, -1, -1, 1, -1, 4),\\
(1, -1, 0, 0, 1, 0, 1, 0, 0),\\
(2, 3, 1, 1, 1, 1, -3, 0, 0),\\
(1, 0, -1, 1, -1, 1, -1, 0, 2),\\
(3, -1, -1, -1, 2, 1, 2, -1, 1),\\
(-1, 0, 1, -1, 1, 1, 1, 2, 0),\\
(-1, 1, 2, 0, 2, -2, -1, -1, 3),\\
(-1, -1, 1, 1, -1, 0, 1, -1, 3)]

def sboxSpecificSubjection(inX, outY, inequs):
assert(len(inX) == len(outY) and len(inX) == 4)

global marker
eqn = []

eqn.append(&#x27; + &#x27;.join([inX[t] for t in range(0, WORD_SIZE)]) + &#x27; - y&#x27;\\
+ str(marker) + &#x27; &amp;gt;= 0&#x27;)
for t in range(0, WORD_SIZE):
eqn.append(inX[t] + &#x27; - &#x27; + &#x27;y&#x27; + str(marker) + &#x27; &amp;lt;= 0&#x27;)
marker = marker + 1

temp1 = &#x27; + &#x27;.join([&#x27;4 &#x27; + inX[i] for i in range(0,4)])
temp2 = &#x27; - &#x27;.join([outY[i] for i in range(0,4)])
eqn.append(temp1 + &#x27; - &#x27; + temp2 + &#x27; &amp;gt;= 0&#x27;)

temp1 = ’ + ’.join([&#x27;4 ’ + outY[i] for i in range(0,4)])
temp2 = ’ - ’.join([inX[i] for i in range(0,4)])
eqn.append(temp1 + ’ - ’ + temp2 + ’ &gt;= 0’)

T = inequ

for t in T :eqn.append((str(t[0]) + ’ ’ + inX[0] + ’ + ’ +\\
str(t[1]) + ’ ’ + inX[1] + ’ + ’ +\\
str(t[2]) + ’ ’ + inX[2] + ’ + ’ +\\
str(t[3]) + ’ ’ + inX[3] + ’ + ’ +\\
str(t[4]) + ’ ’ + outY[0] + ’ + ’ +\\
str(t[5]) + ’ ’ + outY[1] + ’ + ’ +\\
str(t[6]) + ’ ’ + outY[2] + ’ + ’ +\\
str(t[7]) + ’ ’ + outY[3] + ’ &gt;= ’+\\
str(-t[8]) ).replace(’+ -’,’- ’))
return eqn

def getKeyStateAtRound(r):
keycounter = 0
if r==1:
return [’k’+str(i) for i in range(0,KEY_SIZE)]
else:
tempState = getKeyStateAtRound(r-1)
newState = [’’ for i in range(0, KEY_SIZE)]
for i in range(0, KEY_SIZE):
newState[ i ] = tempState[(i+29) % KEY_SIZE]

assert(len(newState)==KEY_SIZE)
if r &gt;= 2:
newState[0] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 0)
newState[1] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 1)
newState[2] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 2)
newState[3] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 3)

newState[4] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 4)
newState[5] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 5)
newState[6] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 6)
newState[7] = ’vInSbox’ + str((r-2)*WORD_SIZE*2 + 7)

return newState

def keySelfSubjectionAtRound(r):
global marker
upKey = getKeyStateAtRound(r)
downKey = getKeyStateAtRound(r+1)

eqn = []

InBits = [upKey[i] for i in range(29, 37)]
OutBits = [downKey[i] for i in range(0, 8)]

in_S9 = InBits[0:4]
in_S8 = InBits[4:8]
out_S9 = OutBits[0:4]
out_S8 = OutBits[4:8]

eqn = eqn + sboxSpecificSubjection(in_S8, out_S8, S8_T)
eqn = eqn + sboxSpecificSubjection(in_S9, out_S9, S9_T)

return eqn

def keyScheduleSubjection(totalRound):

29
</code></pre>

    <p class="text-gray-300">eqn = [] for i in range(1, totalRound + 1): eqn = eqn + keySelfSubjectionAtRound(i) return eqn</p>

    <p class="text-gray-300">def extractSubKeyAtRound(r): tempState = getKeyStateAtRound(r) newState = [tempState[i] for i in range(0, 32)] assert (len(newState) == SUBKEY_SIZE) return newState</p>

    <p class="text-gray-300">SubKeys = [None for i in range(0, 33)] for j in range(1, 33): SubKeys[j] = extractSubKeyAtRound(j)</p>

    <p class="text-gray-300">def xorAdditionSubjection(A, B, C): assert (len(A) == SUBKEY_SIZE and len(B) == SUBKEY_SIZE and len(C) == SUBKEY_SIZE) global add_counter eqn = [] for j in range(0, len(A)): eqn.append(' + '.join([A[j],B[j],C[j]]) + ' - 2 a' + str(add_counter) + \\ ' &gt;= 0') eqn.append('a' + str(add_counter) + ' - ' + A[j] + ' &gt;= 0') eqn.append('a' + str(add_counter) + ' - ' + B[j] + ' &gt;= 0') eqn.append('a' + str(add_counter) + ' - ' + C[j] + ' &gt;= 0') eqn.append(' + '.join([A[j],B[j],C[j]]) + ' &lt;= 2') add_counter = add_counter + 1 return eqn</p>

    <p class="text-gray-300">def F_Subjection(inV, sK, middV, outV): assert(len(inV) == SUBKEY_SIZE and len(sK) == SUBKEY_SIZE and len(middV) == SUBKEY_SIZE and len(outV) == SUBKEY_SIZE) eqn = [] eqn = eqn + xorAdditionSubjection(inV, sK, middV) eqn = eqn + sboxSpecificSubjection(middV[0 : 4], outV[8 :12], S7_T) eqn = eqn + sboxSpecificSubjection(middV[4 : 8], outV[0 : 4], S6_T) eqn = eqn + sboxSpecificSubjection(middV[8 :12], outV[12:16], S5_T) eqn = eqn + sboxSpecificSubjection(middV[12:16], outV[4 : 8], S4_T) eqn = eqn + sboxSpecificSubjection(middV[16:20], outV[24:28], S3_T) eqn = eqn + sboxSpecificSubjection(middV[20:24], outV[16:20], S2_T) eqn = eqn + sboxSpecificSubjection(middV[24:28], outV[28:32], S1_T) eqn = eqn + sboxSpecificSubjection(middV[28:32], outV[20:24], S0_T) return eqn</p>

    <p class="text-gray-300">def rotationXorSubjection(A, B, C): assert(len(A) == SUBKEY_SIZE and len(B) == SUBKEY_SIZE and len(C) == SUBKEY_SIZE) rotA = A[8:16] + A[16:24] + A[24:32] + A[0:8] eqn = [] eqn = eqn + xorAdditionSubjection(rotA, B, C)</p>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">return eqn</p>

    <p class="text-gray-300">def middVars_At_Round(r): assert (r &gt;= 1) return ['midd_r'+str(r)+'_+str(i) for i in range(0, SUBKEY_SIZE)]</p>

    <p class="text-gray-300">def F_Out_At_Round(r): assert(r &gt;= 1) return ['fout_r'+str(r)+'_+str(i) for i in range(0, SUBKEY_SIZE)]</p>

    <p class="text-gray-300">def L_At_Round(r): assert (r &gt;= 1) return ['L_r'+str(r)+'_+str(i) for i in range(0, SUBKEY_SIZE)]</p>

    <p class="text-gray-300">def R_At_Round(r): assert (r &gt;= 1) if (r == 1): return ['R_r'+str(r)+'_+str(i) for i in range(0, SUBKEY_SIZE)] else: return L_At_Round(r-1)</p>

    <p class="text-gray-300">def rotXorOut_At_Round(r): assert (r &gt;= 1) return L_At_Round(r+1)</p>

    <p class="text-gray-300">def genEncryptSubjectionAtRound(r): eqn = []</p>

    <p class="text-gray-300">inF_bits = L_At_Round(r) subK_bits = extractSubKeyAtRound(r) midd_bits = middVars_At_Round(r) fout_bits = F_Out_At_Round(r) right_bits = R_At_Round(r) rotout_bits = rotXorOut_At_Round(r)</p>

    <p class="text-gray-300">eqn = eqn + F_Subjection(inF_bits, subK_bits, midd_bits, fout_bits) eqn = eqn + rotationXorSubjection(right_bits, fout_bits, rotout_bits)</p>

    <p class="text-gray-300">return eqn</p>

    <p class="text-gray-300">def genEncryptSubjection(totalRound): eqn = []</p>

    <p class="text-gray-300">for i in range(1, totalRound + 1): eqn = eqn + genEncryptSubjectionAtRound(i)</p>

    <p class="text-gray-300">return eqn</p>

    <p class="text-gray-300">def getVariables(C): V = set([]) for s in C: temp = s.strip() temp = temp.replace('+', ' ') temp = temp.replace('-', ' ') temp = temp.replace('&gt;=', ' ') temp = temp.replace('&lt;=', ' ') temp = temp.split() for v in temp: if not v.isdecimal(): V.add(v)</p>

    <p class="text-gray-300">31</p>

    <pre><code class="language-python">return V

if __name__ == &quot;__main__&quot;:
ROUND_TO_COUNT = 12

print(&quot;Minimize&quot;)
print(&#x27; + &#x27;.join( [&#x27;y&#x27; + str(i) for i in range(0, ROUND_TO_COUNT*10)] ))

print(&#x27;Subject To&#x27;)
beginBits = R_At_Round(1) + L_At_Round(1)
masterKey = [&#x27;k&#x27; + str(i) for i in range(0, KEY_SIZE)]

print(&#x27; + &#x27;.join(masterKey) + &#x27; &amp;gt;= 1&#x27;)

AA = keyScheduleSubjection(ROUND_TO_COUNT)
BB = genEncryptSubjection(ROUND_TO_COUNT)
for x in AA:
print(x)
for x in BB:
print(x)

print(&#x27;Binary&#x27;)
for v in getVariables(AA + BB):
print(v)
for v in range(0, 80):
print(&#x27;k&#x27;+str(v))
print(&#x27;End&#x27;)</code></pre>`;
---

<BaseLayout title="Automatic Security Evaluation and (Related-key) Differential... (2013/676)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/676
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
