---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2009/516';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Lightweight Cryptography - Cryptographic Engineering for a Pervasive World';
const AUTHORS_HTML = 'Axel Poschmann';

const CONTENT = `    <p class="text-gray-300">Cryptographic Engineering for a Pervasive World</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <h2 id="sec-2" class="text-2xl font-bold">DISSERTATION</h2>

    <p class="text-gray-300">for the degree Doktor-Ingenieur Faculty of Electrical Engineering and Information Technology Ruhr-University Bochum, Germany</p>

    <p class="text-gray-300">Axel York Poschmann Bochum, February 2009</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">To my parents and Katja.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">Author's contact information: axel.poschmann@gmail.com</p>

    <p class="text-gray-300">Thesis Advisor: Prof. Dr.-Ing. Christof Paar Secondary Referee: Dr. Matthew J.B. Robshaw Thesis submitted: February 4, 2009 Thesis defense: April 30, 2009</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">vii</p>

    <p class="text-gray-300">"As light as a feather, and as hard as dragon-scales"</p>

    <p class="text-gray-300">Bilbo Baggins in "The Lord of the Rings: The Fellowship of the Ring".</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">Increasingly, everyday items are enhanced to pervasive devices by embedding computing power and their interconnection leads to Mark Weiser’s famous vision of <em>ubiquitous computing</em> (ubicomp), which is widely believed to be the next paradigm in information technology. The mass deployment of pervasive devices promises on the one hand many benefits (e.g. optimized supply-chains), but on the other hand, many foreseen applications are security sensitive (military, financial or automotive applications), not to mention possible privacy issues. Even worse, pervasive devices are deployed in a hostile environment, <em>i.e</em>. an adversary has physical access to or control over the devices, which enables the whole field of physical attacks. Not only the adversary model is different for ubicomp, but also its optimisation goals are significantly different from that of traditional application scenarios: high throughput is usually not an issue but power, energy and area are sparse resources. Due to the harsh cost constraints for ubicomp applications only the least required amount of computing power will be realized. If computing power is fixed and cost are variable, Moore’s Law leads to the paradox of an increasing demand for lightweight solutions.</p>

    <p class="text-gray-300">In this Thesis different approaches are followed to investigate new lightweight cryptographic designs for block ciphers, hash functions and asymmetric identification schemes. A strong focus is put on lightweight hardware implementations that require as few area (measured in <em>Gate Equivalents (GE)</em>) as possible. We start by scrutinizing the Data Encryption Standard (DES)—a standardized and well-investigated algorithm—and subsequently slightly modify it (yielding DESL) to decrease the area requirements. Then we start from scratch and design a complete new algorithm, called present, where we could build upon the results of the first step. A variety of implementation results of present—both in software and hardware—using different design strategies and different platforms is presented. Our serialized ASIC implementation (<span class="math">1,000</span> GE) is the smallest published and enabled present to be considered as a suitable candidate for the upcoming ISO/IEC standard on lightweight cryptography (ISO/IEC JTC1 SC27 WG2). Inspired by these implementation results, we propose several lightweight hash functions that are based on present in <em>Davies-Meyer</em>-mode (dm-present-80, dm-present-128) and in <em>Hirose</em>-mode (h-present-128). For their security level of <span class="math">64</span> (dm-present-80, dm-present-128) and <span class="math">128</span> bits (h-present-128) the implementation results are the smallest published. Finally, we use present in output feedback mode (OFB) as a pseudo-random number generator within the asymmetric identification scheme crypto-GPS. Its design trade-offs are discussed and the implementation results of different architectures (starting from <span class="math">2,181</span> GE) are backed with figures from a manufactured prototype ASIC.</p>

    <p class="text-gray-300">We conclude that block ciphers drew level with stream-ciphers with regard to low area requirements. Consequently, hash functions that are based on block ciphers can be implemented efficiently in hardware as well. Though it is not easy to obtain lightweight hash functions with a digest size of greater or equal to <span class="math">160</span> bits. Given the required parameters, it is very unlikely that the NIST SHA-3 hash competition will lead to a lightweight approach. Hence, lightweight hash functions with a digest size of greater or equal to <span class="math">160</span> bits remain an open research problem.</p>

    <p class="text-gray-300">Keywords. Lightweight Cryptography, Design, Embedded Systems, Hardware, ASIC, S-boxes, Block cipher, Hash Function, Pervasive Security, IT Security.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">xi</p>

    <p class="text-gray-300">Alltagsgegenstände werden zunehmend durch das Einbetten von Prozessoren zu pervasiven Geräten erweitert und ihre Vernetzung führt zu Mark Weiser’s berühmter Vision des <em>Ubiquitous Computing</em> (ubicomp), das gemeinhin als neues IT-Paradigma angenommen wird. Der erwartete Nutzen ist einerseits vielversprechend (z.B. optimierte Supply-Chains), jedoch sind andererseits viele der skizzierten Szenarien (z.B. fürs Militär, für Banken oder für die Automobilbranche) sicherheitskritisch. Schlimmer noch, durch den Einsatz in „feindlicher“ Umgebung, hat ein möglicher Angreifer volle physikalische Kontrolle über die Geräte, wodurch die gesamte Klasse der physikalischen Angriffe überhaupt erst ermöglicht wird. Abschließend sei noch auf die Gefahren für die Privatsphäre und anderer Bürgerrechte durch die Allgegenwärtigkeit von eingebetteten Systemen hingewiesen. Sicherheit ist also von zentraler Bedeutung. Nicht nur das Angreifermodell von ubicomp, auch seine Optimierungsziele unterscheiden sich deutlich von denen traditioneller IT-Systeme: einerseits geringer Durchsatz, aber andererseits starke Beschränkungen hinsichtlich des Strom-, Energie-, und Flächenverbrauchs. Bedingt durch die scharfen Kostenvorgaben wird stets nur das Minimum der benötigten Rechen- bzw. Speicherkapazität realisiert, wodurch Moore’s Law konträr interpretiert werden muss: da die Rechenkapazität fix und die Kosten variabel sind führt Moore’s Law zu dem Paradoxon einer konstanten oder sogar steigenden Nachfrage nach hocheffizienten Implementierungen.</p>

    <p class="text-gray-300">In dieser Dissertation werden verschiedene Ansätze verfolgt um hocheffiziente Implementierungen von kryptographischen Primitiven wie Blockchiffren, Hashfunktionen und asymmetrischen Identifikationssystemen zu untersuchen. Der Fokus liegt dabei auf hocheffizienten Hardwarerealisierungen, die so wenig Fläche wie möglich—gemessen in Gatter Äquivalenten (GE)—verbrauchen. Zuerst wird der Data Encryption Standard (DES)—ein standardisierter und gut-untersuchter Algorithmus—effizient implementiert und um den Flächenverbrauch weiter zu verringern wird er anschließend geringfügig verändert (DESL). Im nächsten Schritt wird ein komplett neuer Algorithmus (PRESENT) entworfen. Hierbei konnte auf Ergebnisse der vorherigen Untersuchungen aufgebaut werden. Verschiedenste Hard- und Softwarerealisierungen von PRESENT für unterschiedliche Plattformen werden vorgestellt, wobei unser Hardwarerealisierung (1,000 GE) die kleinste bekannte Hardwarerealisierung einer kryptographischen Primitive mit angemessener Sicherheit darstellt. Diese Ergebnisse führten dazu, dass PRESENT als geeigneter Kandidat für den zukünftigen ISO/IEC Standard für Lightweight Cryptography (ISO/IEC JTC1 SC27 WG2) gehandelt wird. Auf diesen Ergebnissen aufbauend, werden neue hocheffiziente Hashfunktionen, die auf PRESENT im Davies-Meyer-Modus (DM-PRESENT-80, DM-PRESENT-128) und im Hirose-Modus (H-PRESENT-128) basieren, vorgestellt. Für die jeweiligen Sicherheitslevel von 64 (DM-PRESENT-80, DM-PRESENT-128)) bzw. 128 Bit (H-PRESENT-128) sind usere Implementierungen diejenigen mit dem geringsten Flächenverbrauch. Schließlich kommt PRESENT im Output-Feedback-Modus als Pseudozufallszahlengerator innerhalb des asymmetrischen Identifikationssystems crypto-GPS zum Einsatz. Verschiedene Architekturen werden vorgestellt und die Implementierungsergebnisse werden durch die Zahlen eines speziell gefertigten ASIC-Prototypen von crypto-GPS ergänzt.</p>

    <p class="text-gray-300">Die Ergebnisse dieser Dissertation lassen den Schluss zu, dass im Hinblick auf effiziente Hardwarerealisierungen Blockchiffren mit Stromchiffren gleichgezogen sind. Dadurch lassen sich Hashfunktionen, die auf Blockchiffren basieren, ebenfalls hocheffizient implementieren. Dieses trifft jedoch nicht auf Hashfunktionen mit Ausgabelängen von 160 oder mehr Bits zu. Berücksichtigt man die Parameter des NIST SHA-3 Hashfunktions-Wettbewerbs, ist es sehr</p>

    <p class="text-gray-300">unwahrscheinlich, dass hieraus eine hocheffiziente Hashfunktion resultiert und folglich bleibt diese Forschungsfrage weiterhin offen.</p>

    <p class="text-gray-300"><strong>Schlüsselworte.</strong> Hocheffiziente Kryptographie, Entwurf, Eingebette Systeme, Hardware, ASIC, S-Box, Blockchiffre, Hashfunktion, Pervasive Sicherheit, IT-Sicherheit.</p>

    <p class="text-gray-300">xii</p>

    <p class="text-gray-300">Acknowledgement</p>

    <p class="text-gray-300">This Thesis is the outcome of three years of research at the Embedded Security group at the Horst Görtz Institute for IT Security at the Ruhr University Bochum. During this time I got the chance to work with friends and therefore could combine many times work and spare time. It offered me a smooth transition from a students life to the working world. The results would not have been possible without collaboration with many researchers and colleagues. Therefore I would like to briefly acknowledge a subset of all the interesting people I met in the past years.</p>

    <p class="text-gray-300">First of all I would like to say <em>Danke!</em> to my supervisor Christof Paar for his great work in supervising, guiding and mentoring me in a very friendly and cooperative way. Secondly, I would like to say <em>Danke!</em> to Irmgard Kühn for coping with all the administrative stuff and all the nice coffee chats that we had. <em>Thank you!</em> Matt Robshaw for being my Thesis reader, and for all the exciting research projects we had. <em>Danke!</em> Gregor Leander for all the funny hours that we spent in your office on joint research projects and on conferences. <em>Merci!</em> Yannick Seurin, <em>Spasibo!</em> Andrey Bogdanov and <em>Tak!</em> Lars Knudsen and Charlotte Vikkelsoe for the joint work on present.</p>

    <p class="text-gray-300"><em>Danke!</em> André Weimerskirch for showing me how to stay calm and relaxed even in the most stressful situations. <em>Danke!</em>, <em>Kiitos!</em>, <em>Merci!</em>, <em>Obrigado!</em>, <em>Spasibo! and Terima kasih!</em> to Dirk Westhoff, Uwe Herzog, Evgeny Osipov and the whole UbiSec&Sens Team.</p>

    <p class="text-gray-300">I would also like to say <em>Danke!</em> and <em>Dhanyavad!</em> to my predecessors Sandeep Kumar, Kerstin Lemke, Jan Pelzl and Kai Schramm for showing me a lifestyle that I wanted to live too! <em>Danke!</em> to my former colleagues Thomas Eisenbarth, Tim Güneysu, Timo Kasper, Markus Kasper for the very friendly and cooperative atmosphere that we had at the COSY/EMSEC group. Several guests have visited our group during the last three years and I would like to say <em>Grazie!</em> Francesco Regazzoni, <em>Daste schoma dart nakone!</em> Amir Moradi and <em>Dėkuj!</em> Martin Novotny for all the fun we had beside the work. I would also like to say <em>Danke!</em> to all the students I have supervised. Finally, <em>Danke!</em> to the whole EMSEC group and all other folks that I forgot.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Motivation 1 1.2 Summary of research contributions and outline 3 1.2.1 Lightweight block ciphers 3 1.2.2 Lightweight hash functions 4 1.2.3 Lightweight public key cryptography 4</p>

    <p class="text-gray-300">2 Fundamentals 7 2.1 Design strategies for lightweight cryptography 7 2.2 Notations 8 2.3 Introduction to ASIC design 9 2.3.1 Semi-custom standard cell design flow 9 2.3.2 Power consumption 10 2.3.3 Metrics 10 2.3.4 Architecture strategies 11 2.4 Hardware properties of cryptographic building blocks 12 2.4.1 Internal state storage 12 2.4.2 Combinatorial elements 13 2.4.3 Confusion and diffusion 14</p>

    <p class="text-gray-300">3 New Lightweight DES Variants 17 3.1 DESL and DESXL: design ideas and security consideration 17 3.2 Related work 18 3.3 Design criteria of DESL 19 3.3.1 Improved resistance against differential cryptanalysis and Davies Murphy attack 20 3.3.2 Improved resistance against linear cryptanalysis 21 3.3.3 4R iterative linear approximation 23 3.3.4 5R iterative linear approximation 24 3.3.5 nR iterative linear approximation 26 3.3.6 Resistance against algebraic attacks 26 3.3.7 Improved S-box 26 3.4 Implementation results 27 3.4.1 Lightweight hardware implementation of DES and DESX 27 3.4.2 Lightweight hardware implementation of DESL and DESXL 29 3.4.3 Lightweight software implementation results 29 3.5 Conclusions 31</p>

    <p class="text-gray-300">4 PRESENT - An Ultra-Lightweight Block Cipher 33 4.1 Related work 33</p>

    <p class="text-gray-300">Table of Contents</p>

    <p class="text-gray-300">4.2 Design decisions 34 4.3 Algorithmic description of the PRESENT encryption routine 35 4.3.1 addRoundKey 36 4.3.2 sBoxlayer 36 4.3.3 pLayer 37 4.4 Algorithmic description of the PRESENT decryption routine 39 4.4.1 addRoundKey 39 4.4.2 invSBoxlayer 39 4.4.3 invPlayer 40 4.5 The key schedule 40 4.5.1 The key schedule for PRESENT-80 40 4.5.2 The key schedule for PRESENT-128 40 4.6 Cryptanalytic Aspects 42 4.6.1 Differential and linear cryptanalysis 42 4.6.2 Structural attacks 46 4.6.3 Algebraic attacks 46 4.6.4 Key schedule attacks 47 4.6.5 Statistical saturation attacks 47 4.6.6 Algebraic differential attacks 48 4.7 Further observations 48</p>

    <p class="text-gray-300">5 Implementation Results of PRESENT 51 5.1 ASIC Implementations 51 5.1.1 Serialized ASIC implementation 51 5.1.2 Round-based ASIC implementation 53 5.1.3 Parallelized ASIC implementation 54 5.1.4 Discussion of the implementation results 55 5.2 FPGA implementation results 57 5.2.1 Target platform and designflow 57 5.2.2 Architecture of the round-based FPGA implementation 57 5.2.3 Implementation results 59 5.3 Hardware/Software co-design implementation results 60 5.3.1 ASIC based co-processor implementation results 60 5.3.2 FPGA-based co-processor implementation results 61 5.3.3 Instruction set extensions for bit-sliced implementation 63 5.4 Software Implementations 64 5.4.1 Implemented variants 64 5.4.2 Software implementation on a 4 bit microcontroller 65 5.4.3 Software implementations on an 8-Bit microcontroller 71 5.4.4 Software implementations on a 16-Bit microcontroller 75 5.4.5 Software implementations on a 32-Bit CPU 78 5.4.6 Other software implementations of PRESENT 80 5.5 Conclusions 82</p>

    <p class="text-gray-300">6 Lightweight Hash Functions 83 6.1 Motivation 83 6.2 Related Work 84 6.3 Design decisions 85</p>

    <p class="text-gray-300">Table of Contents</p>

    <p class="text-gray-300">6.4 Background on hash function constructions 86 6.4.1 Dedicated hash function constructions 86 6.4.2 Block cipher constructions 86 6.5 Compact hash functions with a digest size of 64 bits 87 6.5.1 Description of DM-PRESENT-80 and DM-PRESENT-128 87 6.5.2 Implementation results of DM-PRESENT-80 88 6.5.3 Implementation results of DM-PRESENT-128 92 6.6 Compact hash functions with a digest size of 128 bits 95 6.6.1 Description of H-PRESENT-128 96 6.6.2 Implementation results of H-PRESENT-128 96 6.7 Compact hash functions with a digest size of <span class="math">\\geq 160</span> bits 100 6.7.1 Description of C-PRESENT-192 100 6.7.2 Implementation results and estimations of C-PRESENT-192 102 6.7.3 Dedicated design elements inspired by PRESENT 103 6.7.4 Estimations of PROP-1 and PROP-2 105 6.8 Conclusion 106</p>

    <p class="text-gray-300">7 Lightweight Public-Key Cryptography 109 7.1 Motivation 109 7.2 Related Work 109 7.3 The GPS identification scheme 110 7.3.1 History 110 7.3.2 Parameters and optimizations 110 7.3.3 Design decisions 113 7.4 The crypto-GPS proof-of-concept prototype board 114 7.4.1 The input and output pins of the ASIC 114 7.4.2 The handshake protocol for communication between microcontroller and crypto-GPS ASIC 115 7.4.3 Different architectures of the ASIC 116 7.5 Hardware implementations of round-based crypto-GPS 117 7.5.1 Implementation of the Controller component 119 7.5.2 Implementation of the Addwc component 119 7.5.3 Implementation of the S_Storage component with a fixed secret <span class="math">s</span> 119 7.5.4 Implementation of the S_Storage component with a variable secret <span class="math">s</span> 120 7.6 Hardware implementation of serialized crypto-GPS 120 7.6.1 Implementation of the Controller component 120 7.6.2 Implementation of the S_Storage component with a fixed secret <span class="math">s</span> 122 7.7 Discussion of implementation results 122</p>

    <p class="text-gray-300">8 Physical Security Aspects 125 8.1 Motivation 125 8.2 A pervasive attacker model 125 8.2.1 Classification of attackers 125 8.2.2 Classification of attacks 126 8.2.3 Classification of attack costs 127 8.3 Classification of pervasive devices 127 8.3.1 Unprotected pervasive devices 128 8.3.2 Partly protected pervasive devices 128</p>

    <p class="text-gray-300">Table of Contents</p>

    <p class="text-gray-300">8.3.3 Tamper resistant pervasive devices 130</p>

    <p class="text-gray-300">8.4 Evaluation of pervasive devices with respect to physical security aspects 131</p>

    <p class="text-gray-300">8.4.1 Evaluation of unprotected pervasive devices 131 8.4.2 Evaluation of partly protected pervasive devices 131 8.4.3 Evaluation of tamper resistant pervasive devices 132</p>

    <p class="text-gray-300">8.5 Introduction to side channel attacks and their countermeasures 132</p>

    <p class="text-gray-300">8.5.1 Countermeasures at the algorithmic level 133 8.5.2 Countermeasures at the cell level 135</p>

    <p class="text-gray-300">8.6 Cost overhead estimations of side channel countermeasures 137</p>

    <p class="text-gray-300">8.6.1 Cost overhead estimations for a masked serialized hardware implementations of PRESENT 137 8.6.2 Cost overhead estimations for a masked 4 bit software implementations of PRESENT 140</p>

    <p class="text-gray-300">8.7 Conclusions 140</p>

    <p class="text-gray-300">9 Conclusion 143</p>

    <p class="text-gray-300">Bibliography 147</p>

    <p class="text-gray-300">List of Figures 165</p>

    <p class="text-gray-300">List of Tables 167</p>

    <p class="text-gray-300">Appendix 169</p>

    <p class="text-gray-300">Curriculum Vitae 175</p>

    <p class="text-gray-300">1 Introduction</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“As light as a feather, and as hard as dragon-scales.”</p>
    </blockquote>

    <p class="text-gray-300">was Bilbo Baggins description for Mithril, a legendary material in J.R.R. Tolkiens famous novel “The Lord of the Rings” <em>[228]</em>. It is however also an appropriate description for the topic of this Thesis: Lightweight Cryptography. On the one hand lightweight cryptography aims to yield very lightweight implementations that are virtually “light as a feather”, but on the other hand without conceding the security level too much. In fact, one major aspect of lightweight cryptography is to exploit the security-efficiency trade-offs inherent in implementations of cryptographic algorithms. “Hard as dragon scales” is a good paraphrase for this aspect, because it emphasizes that there are sufficient security levels (e.g. <span class="math">80</span> bit key size) beside a theoretical optimal one.</p>

    <p class="text-gray-300">In the remainder of this chapter, firstly this Thesis is motivated in Section 1.1. Subsequently, in Section 1.2 a summary of our research contributions and the outline of the Thesis is given.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 Motivation</h3>

    <p class="text-gray-300">Increasingly, everyday items are enhanced to pervasive devices by embedding computing power. The interconnection of these pervasive devices leads to Mark Weiser’s famous vision of ubiquitous computing (ubicomp) <em>[238]</em>. A widely shared view is that ubiquitous computing is the next paradigm in information technology. It fits that currently 98.8% of all manufactured microprocessors are employed in embedded applications and only 1.2% in traditional computers. Also Stajano foresees a paradigm shift towards ubiquitous computing when he states that computers “will evolve from a few large, multipurpose, unreliable techno-monoliths to a multitude of small, dedicated, simple and non-threatening appliances" <em>[210, p. XIV]</em>. In 2002 Ross Anderson predicted that by 2012 “your fridge, your heart monitor, your bathroom scales and your shoes might work together to monitor (and nag you about) your cardiovascular health" <em>[210, p. XII]</em>. Nowadays (2009) it seems that it may need another 10 years to let this particular vision come true, but generally the trend is clearly visible.</p>

    <p class="text-gray-300">The mass deployment of pervasive devices promises many benefits such as lower logistic costs, higher process granularity, optimized supply-chains, or location based services among others. For instance the RFID technology is believed to be the enabling technology for the internet of things. Basically, RFID tags consist of a transponder and an antenna and are able to remotely receive data from an RFID host or reader device. In general, RFID tags can be divided into passive and active devices: active tags provide their own power supply (i.e. in form of a battery), whereas passive tags solely rely on the energy of the carrier signal transmitted by the reader device. As a result, passive RFID devices are not only much less expensive, but also require less chip size and have a longer life cycle <em>[74]</em>.</p>

    <p class="text-gray-300">Pervasiveness implies mass deployment which in turn implies harsh cost constraints on the used technology. Software implementations typically face ROM, RAM and energy constraints. The latter can be addressed by the designer by avoiding power consuming accesses to EEPROM or Flash memories and by reducing the required clock cycles. Luckily, on the other hand in most cases just a few data, e.g. counter, initialization vector or identifier, are processed. Therefore high throughput is not critical, though reduction of the clock cycle count increases the throughput. The cost constraints imply in particular for ASICs that power, energy, and area requirements must be kept to a minimum. A complete—i.e. including the analog part—low-cost RFID tag might have between <span class="math">1,000</span> and <span class="math">10,000</span> GE and for security components may only be <span class="math">200-2,000</span> GE available <em>[116]</em>.</p>

    <p class="text-gray-300">One counter-argument might be that Moore’s Law will provide abundant computing power in the near future. However, Moore’s Law needs to be interpreted contrary here: rather than doubling of performance, the price for constant computing power halves each 18 months. This interpretation leads to interesting conclusions, because many foreseen applications require a minimum amount of computing power, but at the same time have extremely tight cost constraints (e.g. RFID in tetra packs). As a consequence these applications are not realized yet, simply because they do not pay off. Moore’s law however halves the price for a constant amount of computing power every <span class="math">18</span> months, and consequently enables such applications after a certain period of time. Therefore, we foresee a constant or even increasing demand for the cheapest (read lightweight) solutions.</p>

    <p class="text-gray-300">Besides the aforementioned benefits, there are also many risks inherent in pervasive computing: many foreseen applications are security sensitive, such as wireless sensor networks for military, financial or automotive applications. With the widespread presence of embedded computers in such scenarios, security is a striving issue, because the potential damage of malicious attacks also increases. Stajano sees these three major problems that determine whether ubicomp will be successful or not <em>[210]</em>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>insufficient security</li>

      <li>solving the wrong problems (e.g. global public-key infrastructure)</li>

      <li>prevent ubicomp to become ubiquitous surveillance.</li>

    </ol>

    <p class="text-gray-300">An aggravating factor is that pervasive devices are usually not deployed in a controlled but rather in a hostile environment, i.e. an adversary has physical access to or control over the devices. This adds the whole field of physical attacks to the potential attack scenarios. Most notably are here so-called side-channel attacks, such as Differential Power Analysis/Correlation Power Analysis <em>[131]</em> or EM attacks <em>[8]</em>. It has been shown that security solutions which use a cryptographically secure algorithm but are implemented without any side-channel countermeasures can easily be broken by such attacks <em>[171]</em>.</p>

    <p class="text-gray-300">Another active research area is to prevent counterfeiting of goods. According to the U.S. Chamber of Commerce “counterfeiting and product piracy cost the U.S. economy between <span class="math">200 billion and </span>250 billion per year and a total of <span class="math">750.000</span> American Jobs” <em>[66, p.26]</em>. Combined with other sources, <em>[172]</em> estimates the global market size of counterfeited goods with US-<span class="math">527</span> billion. For this purpose (beside others, such as access control) it is desired to use RFID tags as cryptographic tokens, e.g. in a challenge response protocol. In this case the tag must be able</p>

    <p class="text-gray-300">to execute a secure cryptographic primitive. Contactless microprocessor cards <em>[192]</em>, which are capable to execute cryptographic algorithms, are not only expensive and, hence, not necessarily suited for mass production, but also draw a lot of current. The high, non-optimal power consumption of a microprocessor can usually only be provided by close coupling systems, a short distance between reader and RFID device has to be ensured <em>[74]</em>. A better approach is to use a custom made RFID chip, which consists of a receiver circuit, a control unit, a finite state machine, some kind of volatile and/or non-volatile memory and a cryptographic primitive. These cryptographic primitives have to be optimized to the harsh power and area constraints that low-cost passive RFID tags face.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Summary of research contributions and outline</h3>

    <p class="text-gray-300">In this Thesis we focus on the technical aspects of security for ubiquitous computing, but also take economic considerations into account (see Section 2). Especially the attacker model, countermeasures for DPA/CPA and the design goals for lightweight cryptography are influenced by cost sensitivity (see Section 8). We will follow different approaches to investigate new lightweight cryptographic designs and their implementations for block ciphers, hash functions and public key identification schemes. A strong focus is put on lightweight hardware implementations that require as few area (measured in <em>Gate Equivalents (GE)</em>) as possible, though also software figures are provided. The contributions can be classified into lightweight block ciphers (Section 1.2.1), lightweight hash functions (Section 1.2.2) and lightweight public key cryptography (Section 1.2.3).</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.2.1 Lightweight block ciphers</h4>

    <p class="text-gray-300">In Chapter 3 we start with a serialized implementation of DES that requires <span class="math">2,310</span> GEs and encrypts a plaintext within <span class="math">144</span> clock cycles. To our knowledge, this is the smallest reported DES implementation, trading area for throughput. In our serialized DES implementation S-boxes take up approximately <span class="math">32\\%</span> of the area. Further we decrease the gate complexity of DES by replacing the eight original S-boxes by a single new one, eliminating seven S-boxes as well as the multiplexer. This lightweight variant of DES is named DESL and results in approximately 20% less chip size than our DES (<span class="math">1,850</span> GEs vs. <span class="math">2,310</span> GEs). The S-box has been carefully selected and highly optimized in such a way that DESL resists common attacks, linear and differential cryptanalysis, and the Davies-Murphy-attack. However, the security provided by DES and DESL is limited by the <span class="math">56</span> bit key, which might be adequate for a range of low-cost applications though. In situations where a higher security level is needed key whitening can be applied yielding the cipher DESXL, with a security level of approx. <span class="math">118</span> bits. DESXL requires <span class="math">2,170</span> GEs and encrypts a plaintext within <span class="math">144</span> clock cycles.</p>

    <p class="text-gray-300">Another alternative for lightweight cryptography, rather than efficiently implement or slightly modify an established cipher, is to design a new hardware optimized cipher from scratch. This approach will be followed in Chapter 4, where we propose present, a <em>substitution permutation network</em> (SPN) based block cipher with <span class="math">31</span> rounds, a block size of <span class="math">64</span> bits, and a key size</p>

    <p class="text-gray-300">of <span class="math">80</span> or <span class="math">128</span> bits. The main design philosophy during the design of present was simplicity: no part of the cipher was added without a good reason for it, like thwarting an attack. The substitution-layer comprises of <span class="math">16</span> S-boxes with <span class="math">4</span>-bit input and <span class="math">4</span>-bit output (<span class="math">4\\times 4</span>). We decided to use similar S-boxes both in the data path and in the key-scheduling, because we learned from DESL that this can result in significant area savings when a serialized implementation is desired. The choice for <span class="math">4\\times 4</span> S-boxes rather than <span class="math">8\\times 8</span> was also hardware driven, because <span class="math">4</span>-bit S-boxes require less than a quarter of the area of <span class="math">8</span>-bit S-boxes (25 GEs vs. 120 GEs). However, <span class="math">4</span>-bit S-boxes have to be selected very carefully because they are cryptographically weaker than <span class="math">8</span>-bit S-boxes. Nevertheless, if they are selected carefully, it is possible to achieve an appropriate security level. The permutation-layer is a very regular and simple bit transposition, which comes virtually for free in hardware since it is realized by simple wiring and, hence, no transistors are required. The permutation-layer ensures that the four output bits of an S-box will be distributed to four distinct S-boxes in the following round, which ensures the avalanche effect. This is required to thwart linear and differential cryptanalyses. The design and security assessment of present is treated more detailed in Chapter 4.</p>

    <p class="text-gray-300">The implementation efficiency of present is intensively scrutinized in Chapter 5. We give details about different implementations for ASICs (serialized, round-based, parallelized and co-processor), FPGAs, and a variety of software platforms (<span class="math">4</span>-, <span class="math">8</span>-, <span class="math">16</span>- and <span class="math">32</span>-bit). Especially noteworthy are the implementation results for the <span class="math">4</span>-bit microcontroller and the serialized ASIC. The first one is the first published implementation of a cryptographic algorithm on such an ultra constrained device and the latter one requires only <span class="math">1,000</span> GE and constitutes the smallest published implementation of a cryptographic algorithm with a reasonable security level.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.2.2 Lightweight hash functions</h4>

    <p class="text-gray-300">Inspired by the implementation results of present, we scrutinize lightweight hash functions that are based on present or that have similar design elements in Chapter 6. Two proposals based on present in Davies-Meyer-mode (dm-present-80 and dm-present-128) that offer a hash digest of <span class="math">64</span> bits are presented using literature-based design strategies. For hash functions with a digest size of <span class="math">128</span> bits, present in Hirose-mode (h-present-128) is proposed. To obtain digests of <span class="math">160</span> bits or more it is required to use at least a triple-block length construction, since present has a block size of <span class="math">64</span> bits. For this purpose c-present-192 is proposed using current best practice, but its implementation results (<span class="math">8,048</span> GE) and estimates (<span class="math">&gt;4,600</span> GE) indicate that this is not the way to go. Instead two proposals—PROP-1 and PROP-2—that use similar design elements to present are investigated. Their implementation estimates are more promising (<span class="math">&gt;2,520</span> GE and <span class="math">&gt;3,010</span> GE).</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">1.2.3 Lightweight public key cryptography</h4>

    <p class="text-gray-300">In Chapter 7 we utilize presents hardware efficiency for public key cryptography. We use present in output feedback mode (OFB) <em>[153]</em>, thus turning it into a stream cipher. This stream</p>

    <p class="text-gray-300">cipher is used as a Pseudo Random Number Generator (PRNG) for the public key <em>crypto-GPS</em> identification scheme <em>[85]</em>, which exploits a security-efficiency trade-off by using pre-computed coupons. The design trade-offs of crypto-GPS are discussed and four different lightweight hardware architectures are described in detail. We show that crypto-GPS can be implemented as efficiently as <span class="math">2,181</span> GE. We furthermore describe the architecture of a prototype circuit board that contains a manufactured ASIC with our four variants of crypto-GPS.</p>

    <p class="text-gray-300">Physical security aspects are discussed in Chapter 8. We first develop a pervasive attacker model in Section 8.2, before we characterize pervasive devices in Section 8.3. Based on this we classify pervasive devices with respect to physical security aspects in Section 8.4. Then we discuss side channel attacks and their countermeasures in Section 8.5 before we estimate the cost overhead of hardware and software implementations of present that contain SCA countermeasures in Section 8.6.</p>

    <p class="text-gray-300">Finally Chapter 9 concludes this Thesis and provides pointer for future work.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">2 Fundamentals</p>

    <p class="text-gray-300">In this Chapter necessary background information will be provided. First, design strategies for lightweight cryptography are discussed in Section 2.1 before the notation is introduced in Section 2.2. Then an overview over the semi-custom standard cell design flow and the used metrics is given in Section 2.3. Finally, the hardware properties of cryptographic building blocks is treated in Section 2.4.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Design strategies for lightweight cryptography</h3>

    <p class="text-gray-300"><em>Lightweight Cryptography</em> is a relatively young scientific sub-field that is located at the intersection of electrical engineering, cryptography and computer science and focuses on new designs, adaptions or efficient implementations of cryptographic primitives and protocols. Due to the harsh cost constraints and a very strong attacker model—especially noteworthy is the possibility of physical attacks—there is an increasing need for lightweight security solutions that are tailored to the ubiquitous computing paradigm.</p>

    <p class="text-gray-300">Every designer of lightweight cryptography has to cope with the trade-off between <em>security</em>, <em>costs</em>, and <em>performance</em>. For block ciphers the key length provides a security-cost trade-off, while the amount of rounds provides a security-performance trade-off and the hardware architecture a cost-performance trade-off (see Figure 2.1). Usually, any two of the three design goals – security and low costs, security and performance, or low costs and performance – can be easily optimized, whereas it is very difficult to optimize all three design goals at the same time. For example, a secure and high performance hardware implementation can be achieved by a pipelined architecture which also incorporates many countermeasures against side-channel attacks. The resulting design would have a high area requirement, which correlates with high costs. On the other hand it is possible to design a secure and low-cost hardware implementation with the drawback of limited performance.</p>

    <p class="text-gray-300">Generally speaking, there are three approaches for providing cryptographic primitives for extremely lightweight applications such as passive RFID tags:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Optimized low-cost implementations for standardized and trusted algorithms.</li>

      <li>Slightly modify a well investigated and trusted cipher.</li>

      <li>Design new ciphers with the goal of having low hardware implementation costs.</li>

    </ol>

    <p class="text-gray-300">In this Thesis we will scrutinize all three approaches. The problem with the first approach is that most modern block ciphers were primarily designed with good software implementation properties in mind, and not necessarily with hardware-friendly properties. This is the right approach for today’s block ciphers, because on the one hand the vast majority of algorithms run in software on PCs or embedded devices, and on the other hand silicon area has become so inexpensive that very high performance hardware implementations (achieved through large chip area) are not a problem any more. However, if the goal is to provide extremely low-cost</p>

    <p class="text-gray-300">Chapter 2. Fundamentals</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2.1: Design trade-offs for lightweight cryptography.</p>

    <p class="text-gray-300">security on devices where both of those assumptions do not hold, it turns out that many modern block ciphers do not perform well for these scenarios. We will underline this observation when following this approach in Chapter 3 where we start with a serialized DES implementation.</p>

    <p class="text-gray-300">The second approach is to have a well investigated cipher, the design of which was driven by low hardware costs. A very well known cipher to this respect is the Data Encryption Standard, DES [159]. DES was designed in the first half of the 1970s and the targeted implementation platform was hardware. However, by today's standard, digital technology was extremely limited in the early 1970s, i.e. a factor of  <span class="math">2^{20}</span>  or 6 orders of magnitude less powerful following Moore's Law. Hence, virtually all components of DES were heavily driven by low hardware complexity: exclusive bit-wise OR (XOR), bit permutation and small S-boxes. We will follow the second approach by slightly modifying DES in order to gain DESL in Chapter 3. The obvious drawback of DES is that its key length is not adequate for many of today's applications, but by applying key-whitening techniques the security level can be increased. This will also be addressed in Chapter 3.</p>

    <p class="text-gray-300">Though the implementation results of DESL are encouraging, they also show optimization potentials. Therefore, in order to further decrease the hardware area requirements, we will also follow the third approach and design the ultra-lightweight cipher PRESENT anew in Chapter 4.</p>

    <p class="text-gray-300">Throughout this Thesis we use the following notations:</p>

    <p class="text-gray-300"><span class="math">E_K(M) = C</span>  Encryption of a message  <span class="math">M</span>  under the key  <span class="math">K</span>  to obtain the ciphertext  <span class="math">C</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$A\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B<span class="math">  Concatenation of  </span>A<span class="math">  and  </span>B$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  Bit-length of  </span>A<span class="math">  , i.e.  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lceil \\log_2(A)\\rceil$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\overline{x_i}</span>  logical inversion of bit  <span class="math">x_{i}</span></p>

    <p class="text-gray-300">logical AND.</p>

    <p class="text-gray-300">2.3. Introduction to ASIC design</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2.2: Top-down digital semi-custom standard cell design flow, source [231].</p>

    <p class="text-gray-300">In this Section first an overview over the semi-custom standard cell design flow is provided in Section 2.3.1. Subsequently, in Section 2.3.2 a brief introduction to power consumption of ASICs is provided. Then in Section 2.3.3 the metrics are explained and finally architectural strategies for hardware implementations are discussed in Section 2.3.4.</p>

    <p class="text-gray-300">In this Thesis several hardware implementation architectures of lightweight cryptographic algorithms will be described. All architectures were developed and synthesized by using a script based design flow (see Figure 2.2). We used Mentor Graphics Modelsim [92] for VHDL source code construction and functional verification. Then the RTL description was synthesized with Synopsys Design Compiler [219] which was also used to generate the area, timing, and power estimation reports. For different parts of this Thesis different version of these programs have been used. We provide details about the used versions in the appropriate subsection. The main effort of synthesis process was area optimization.</p>

    <p class="text-gray-300">Throughout this Thesis we use three different standard cell libraries with different technology parameters: a 350 <span class="math">nm</span> MTC45000 library from AMIS <em>[4]</em>, a 250 <span class="math">nm</span> SESAME-LP2 library from IHP <em>[64]</em>, and a 180 <span class="math">nm</span> UMCL18G212D3 library from UMC <em>[233]</em>. Each of them contains a different set of standard cells and also the subset of implemented logical functions differ between these libraries. These facts will lead to different area requirements expressed in GE for the very same VHDL source code. We mainly used the UMCL18G212D3 library, which is based on the UMC L180 0.18<span class="math">\\mu</span>m 1P6M logic process and has a typical voltage of <span class="math">1.8</span> Volt <em>[233]</em>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">2 Power consumption</h4>

    <p class="text-gray-300">One particular problem of passive RFID applications is that the tags face strict power constraints. A rule-of-thumb is that the current consumption should be less than <span class="math">15\\mu</span>A <em>[72]</em>.</p>

    <p class="text-gray-300">The following equation summarizes the power dissipation <span class="math">P</span> in CMOS devices <em>[59]</em>:</p>

    <p class="text-gray-300"><span class="math">P=\\left(\\frac{1}{2}\\cdot C\\cdot V_{dd}^{2}+Q_{sc}\\cdot V_{dd}\\right)\\cdot f\\cdot N+I_{leak}\\cdot V_{dd}</span></p>

    <p class="text-gray-300">where <span class="math">C</span> denotes the circuit capacitance, <span class="math">V_{dd}</span> the supply voltage, <span class="math">Q_{sc}</span> the short-circuit charge, <span class="math">f</span> the operating frequency, <span class="math">N</span> the switching activity and <span class="math">I_{leak}</span> the leakage current. The first summand represents the dynamic power consumption and the second the static power consumption. At higher frequencies the dynamic part becomes the dominant factor of the total power consumption. It can be linearly decreased by lowering the operating frequency <span class="math">f</span>, which also lowers the switching activity <span class="math">N</span> and quadratically by decreasing the supply voltage <span class="math">V_{dd}</span>. The remaining terms of the dynamic part, <span class="math">C</span> and <span class="math">Q_{sc}</span>, are technology dependent and can not be influenced by an algorithm designer. The static power consumption can be linearly decreased by applying a lower supply voltage <span class="math">V_{dd}</span>. Moreover, since the leakage current <span class="math">I_{leak}</span> is directly proportional to the number of required GEs, decreasing the gate count directly decreases the power consumption of the circuit.</p>

    <p class="text-gray-300">To lower power consumption, RFID applications are typically clocked at a low frequency, <span class="math">e.g.</span> <span class="math">100</span> KHz or <span class="math">500</span> KHz. In this frequency range the static power consumption is dominant. RFID applications usually have harsh cost constraints and the silicon area of the chip is directly proportional to the cost. Therefore, a good way to minimize both the cost and the power consumption is to minimize the area requirements. It has become common to use the term hardware efficient as a synonym for small area requirements. Besides this it is also used to measure throughput per area, which is the inverse of the time-area product (TA).</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">3 Metrics</h4>

    <p class="text-gray-300">To assess the efficiency of our implementation we used the following metrics:</p>

    <p class="text-gray-300">Area: Area requirements are usually measured in <span class="math">\\mu m^{2}</span>, but this value depends on the fabrication technology and the standard cell library. In order to compare the area requirements independently it is common to state the area as gate equivalents [GE]. One GE is equivalent to the area which is required by the two-input NAND gate with the lowest driving strength of the appropriate technology. The area in GE is derived by dividing the area in <span class="math">\\mu m^{2}</span> by the area of a two-input NAND gate.</p>

    <p class="text-gray-300">Cycles: Number of clock cycles to compute and read out the result.</p>

    <p class="text-gray-300">The required amount of time for a certain operation can be calculated by dividing the amount of cycles by the operating frequency <span class="math">t=\\frac{\\text{cycles}}{\\text{freq.}}</span>. Throughout this Thesis in most cases <span class="math">100</span>KHz is used as the operating frequency. Therefore in most cases the time is given in milli seconds [ms]. The rate at which new output is produced with respect to time. The number of output bits is divided by the time, <em>i.e.</em> by the needed cycles and multiplied by the operating frequency. It is expressed in bits per second [bps]. The power consumption is estimated on the gate level by Synopsys PowerCompiler <em>[220]</em>. It is provided in micro Watt [<span class="math">\\mu</span>W]. Note that power estimations on the transistor level are more accurate, but this would also require further design steps in the design flow, <em>e.g.</em> the <em>place&route</em> step. The energy consumption denotes the power consumption over a certain time period. It can be calculated by multiplying the power consumption with the required time of the operation. For the efficiency of a cryptographic algorithm it might be interesting also to know the energy consumption per output bit. The energy consumption is provided in micro Joule [<span class="math">\\mu</span>J] or micro Joule per bit [<span class="math">\\frac{\\mu\\text{J}}{\\text{bit}}</span>], respectively. The power consumption divided by the typical core voltage of the library. These are <span class="math">3.3</span>V for the <em>AMIS MTC45000</em> library, <span class="math">2.5</span>V for the <em>IHP SESAME-LP2</em> library, and <span class="math">1.8</span>V for the <em>UMC UMCL18G212D3</em> library.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The throughput to area ratio is used as a measure of hardware efficiency. The hardware efficiency is calculated by dividing the area requirements by the throughput, <em>i.e.</em> <span class="math">eff.=\\frac{\\text{area}}{\\text{throughput}}</span>, and is expressed in gate equivalents per bits per second $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\text{GE}}{\\text{bps}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the choice of an appropriate I/O interface is highly application specific, while at the same time it can have a significant influence on the area, power, and timing figures. In order to have a clearer estimation of the cryptographic core’s efficiency we throughout this Thesis did not implement any special input or output interfaces, but rather chose a width that best suits the need of the appropriate implementation.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">2.3.4 Architecture strategies</h4>

    <p class="text-gray-300">An implementation for a low cost passive smart device, such as RFID tags or contactless smart cards requires small area and power consumption, while the throughput is of secondary interest. On the other hand, an RFID reader device that reads out many devices at the same time, requires a higher throughput, but area and power consumption are less important. Active smart devices, such as contact smart cards do not face strict power constraints but timing and sometimes energy constraints. In order to tailor an implementation to the design goals of the application scenario there are three major hardware architecture options: parallel (loop unrolled), round-wise, and serial.</p>

    <p class="text-gray-300">A <em>parallel</em>, or loop unrolled, block cipher implementation performs several round operations of the encryption/decryption process within one clock cycle. Usually parallel implementations are <em>pipelined</em>, <em>i.e.</em> registers are inserted in the critical path so as to increase the maximum clock frequency. While parallel implementations have high throughput rates, this is rarely the focus</p>

    <p class="text-gray-300">for RFID applications. Rather, the high area and power demands mean that parallel implementations of block ciphers and stream ciphers are rarely suited for passive RFID applications.</p>

    <p class="text-gray-300">In a round-wise implementation, one round function of a block or a stream cipher is processed within one clock cycle. The decreased throughput comes at the benefit of decreased area and power consumption. From a low power and low area perspective, round-wise implementations are best suited for stream ciphers and make a reasonable option for block ciphers.</p>

    <p class="text-gray-300">To lower power consumption and area requirements, implementations can be <em>serialized</em>; here only a fraction of one round is processed in a clock cycle. Up to a certain point this strategy can significantly decrease the area and the power consumption and the impressive results by Feldhofer et al. on the aes <em>[161]</em> are achieved by serialization <em>[73]</em>. However, it might not always be a suitable implementation strategy since the savings can sometimes be cancelled by the overheads in additional control logic. Nevertheless, from a low power and low area perspective, serial implementations appear to be best-suited for RFID-like implementations in the case of block ciphers. The natural way of implementing stream ciphers is in a bit serial fashion.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.4 Hardware properties of cryptographic building blocks</h3>

    <p class="text-gray-300">This Section first provides a brief overview over sequential (Section 2.4.1) and combinatorial (Section 2.4.2) logic elements. Then in Section 2.4.3 the basic cryptographic properties of confusion and diffusion are discussed with respect to their hardware properties.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">2.4.1 Internal state storage</h4>

    <p class="text-gray-300">Ciphers have an internal state which we might refer to as <em>cipher state</em> and <em>key state</em>. When a block cipher is used, the cipher state is initialized by the plaintext (or ciphertext) and modified under the action of the <em>key</em> (and therefore the key state). When a stream cipher is used, the cipher state is initialized by the <em>initialization value</em> and the <em>key</em>. Stream ciphers then use the initialized cipher state to output the keystream. Block ciphers have a fixed number of rounds and the final internal state serves as the ciphertext. Note that independent of the implementation strategy (see above) the internal cipher state has to be saved at each round.</p>

    <p class="text-gray-300">In software environments kilobytes of RAM and ROM are available. In low-cost tag applications this is not the case. Although most RFID tags have a memory module, for cryptographic algorithms there is only the barest minimum of storage capacity available. Furthermore, read and write access to the memory module (usually EEPROM) is very power consuming. As a consequence it is preferable to store all intermediate values and variables in registers rather than in external memory.</p>

    <p class="text-gray-300">Registers typically consist of <em>flip-flops</em>. Compared to other standard cells, flip-flops have a rather high area and power demand. For example, when using the <em>Virtual Silicon (VST)</em> standard cell library based on the <em>UMC L180 <span class="math">0.18\\mu</span> 1P6M Logic process</em> (UMCL18G212T3, <em>[233]</em>), flip-flops require between <span class="math">5.33</span> GE and <span class="math">12.33</span> GE to store a single bit (see Table 2.1). The gate count differs so significantly for different cells because the first cell (HDDFFPB1) consists only of a simple D flip-flop itself, while the latter one (HDSDERSPB1) comprises of a multiplexer to select one of two possible inputs for storage and a D flip-flop with active-low enable, asynchronous clear and set. There exists a wide variety of flip-flops of different complexity between</p>

    <p class="text-gray-300">2.4. Hardware properties of cryptographic building blocks</p>

    <p class="text-gray-300">Table 2.1: Area requirements and corresponding gate count of selected standard cells of the UMCL18G212T3 library.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Standard cell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Process</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Library</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cell name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area in μm2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GE</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NOT</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDINVBD1</td>

            <td class="px-3 py-2 border-b border-gray-700">6.451</td>

            <td class="px-3 py-2 border-b border-gray-700">0.67</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NAND</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDNAN2D1</td>

            <td class="px-3 py-2 border-b border-gray-700">9.677</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NOR</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDNOR2D1</td>

            <td class="px-3 py-2 border-b border-gray-700">9.677</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AND</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDAND2D1</td>

            <td class="px-3 py-2 border-b border-gray-700">12.902</td>

            <td class="px-3 py-2 border-b border-gray-700">1.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OR</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDOR2D1</td>

            <td class="px-3 py-2 border-b border-gray-700">12.902</td>

            <td class="px-3 py-2 border-b border-gray-700">1.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MUX</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDMUX2D1</td>

            <td class="px-3 py-2 border-b border-gray-700">22.579</td>

            <td class="px-3 py-2 border-b border-gray-700">2.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">XOR (2)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDEXOR2D1</td>

            <td class="px-3 py-2 border-b border-gray-700">25.805</td>

            <td class="px-3 py-2 border-b border-gray-700">2.67</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">XOR (3)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDEXOR3D1</td>

            <td class="px-3 py-2 border-b border-gray-700">45.158</td>

            <td class="px-3 py-2 border-b border-gray-700">4.67</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D Flip flop</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDDFFPB1</td>

            <td class="px-3 py-2 border-b border-gray-700">51.61</td>

            <td class="px-3 py-2 border-b border-gray-700">5.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Scan D flip-flop /w enable</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDSDFPQ1</td>

            <td class="px-3 py-2 border-b border-gray-700">58.061</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Scan flip-flop</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDSDEPQ1</td>

            <td class="px-3 py-2 border-b border-gray-700">83.866</td>

            <td class="px-3 py-2 border-b border-gray-700">8.67</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">complex Scan flip-flop</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">UMCL18G212T3</td>

            <td class="px-3 py-2 border-b border-gray-700">HDSDERSPB1</td>

            <td class="px-3 py-2 border-b border-gray-700">119.347</td>

            <td class="px-3 py-2 border-b border-gray-700">12.33</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">these two extremes. A good trade-off between efficiency and useful supporting logic provide the two flip-flop cells HDSDEPQ1 and HDSDFPQ1. Both are scan flip-flops, which means that beside the flip-flop they also provide a multiplexer. The latter one is also capable of being gate clocked, which is an important feature to lower power consumption.</p>

    <p class="text-gray-300">Storage of the internal state typically accounts for at least  <span class="math">50\\%</span>  of the total area and power consumption. Therefore implementations of cryptographic algorithms for low-cost tag applications should aim to minimize the storage required.</p>

    <p class="text-gray-300">The term combinatorial elements includes all the basic Boolean operations such as NOT, NAND, NOR, AND, OR, and XOR. It also includes some basic logic functions such as multiplexers (MUX). It is widely assumed that the gate count for these basic operations is typically independent of the library used. However, in [199] we showed that ASIC implementation results of a serialized PRESENT in different technologies range from 1,000 GE to 1,169 GE. This indicates that also the gate count for basic logic gates differs depending on the used standard-cell library.</p>

    <p class="text-gray-300">For the Virtual Silicon (VST) standard cell library based on the UMC L180 0.18μ 1P6M Logic process (UMCL18G212T3, [233]) the figures for selected two-input gates with the lowest driving strength is given in Table 2.1. Note that in hardware XOR and MUX are rather expensive when compared to the other basic Boolean operations.</p>

    <p class="text-gray-300">2.4.3 Confusion and diffusion</p>

    <p class="text-gray-300"><em>Shannon (2008)</em> was the first to formalize the ideas of confusion and diffusion as two attractive properties in the design of a secure cipher. In practice, almost all block ciphers are product ciphers, i.e. they are based on subsequent operations of confusion and diffusion. In a block cipher, confusion is often identified with a substitution layer (see below) while diffusion is usually identified with a permutation or “mixing” layer. In reality is not always easy to separate and identify the components that contribute to confusion or diffusion.</p>

    <p class="text-gray-300">Some ciphers use arithmetic operations as a diffusion and confusion technique, but this can significantly increase the area and power consumption. Arguably the most common confusion method is based on S-boxes (see below). A small change in the input to an S-box leads to a complex change in the output. In order to spread these output changes over the entire state quickly, a dedicated diffusion layer has to be applied. The classical way of doing this is to use bit permutation. In hardware, bit permutations can be realized with wires and no transistors are involved. They are therefore a very efficient component. Note that more complex diffusion techniques, such as the mix-column layer used in the AES, are also possible. Even though they have cryptographic advantages, they come at a higher hardware cost.</p>

    <p class="text-gray-300">Many block ciphers, and some stream ciphers, use S-boxes to introduce non-linearity. In software S-boxes are often implemented as look-up tables (LUT). In hardware these look-up tables can have a large area footprint or they pose technological problems since a mix of combinatorial logic and ROM cannot always be easily achieved with a standard hardware design flow. Hence a purely combinatorial realization is often more efficient.</p>

    <p class="text-gray-300">If combinatorial implementations do not exploit any internal structure in the S-box, then the area requirements will grow rapidly with a the number of input and output bits. The more output bits an S-box has, the more Boolean equations will be required. And the more input bits an S-box has, the more complex these equations are likely to be. An interesting interaction between cryptography and hardware implementation can be observed here: in order to withstand differential and linear cryptanalysis <em>(26; 149)</em>, high non-linearity of S-boxes is required, which directly translates into a high gate count. A close look on the hardware efficiency of the S-boxes in AES <em>(161)</em>, DES <em>(159)</em>, and present <em>(33)</em> illustrates this.</p>

    <p class="text-gray-300">AES uses a bijective <span class="math">8</span>-bit S-box, i.e. eight input bits are mapped to eight output bits. In <em>(223)</em> the hardware properties of several implementations of AES S-boxes, each illustrating different design goals, are compared. It turns out that the AES S-box realised as Boolean logic requires about <span class="math">1,000</span> GE while there is no implementation that requires less than <span class="math">300</span> GE. These figures also include the inverse S-box.</p>

    <p class="text-gray-300">DES uses eight different S-boxes that map six input bits to four output bits. In Chapter 3 we will show that in our DES ASIC design the S-boxes require in total <span class="math">742</span> GE. However, taking into account that Boolean terms can be shared between the eight different S-boxes, it is not surprising that the area requirements for a single <span class="math">6</span>-bit to <span class="math">4</span>-bit S-box typically is around <span class="math">120</span> GE. This can also be observed in implementations of DESXL and DESL, which will be introduced also in Chapter 3. Both algorithms use <span class="math">6</span>-bit to <span class="math">4</span>-bit S-boxes but, in contrast to DES, a single S-box is repeated eight times. Therefore only one instance of the S-box has to be implemented in a serialized design, which requires <span class="math">128</span> GE.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">In <em>[140]</em> the area requirements of so-called SERPENT-type S-boxes are described. These are a special subset of <span class="math">4</span>-bit to <span class="math">4</span>-bit S-boxes fulfilling certain criteria and we found that the area requirements for this type of S-box varies between <span class="math">21</span> GE and <span class="math">39</span> GE. As an example, present uses a single, bijective <span class="math">4</span>-bit to <span class="math">4</span>-bit S-box which can be implemented with <span class="math">21</span> GE. However, in Chapter 5 we will see that a single S-box requires <span class="math">28</span> GE when implemented with the UMCL18G212D3 library. This deviation is caused by the fact that synthesis results depend heavily on the technology of the standard cells that are used (see discussion above).</p>

    <p class="text-gray-300">After having introduced the basic knowledge about semi-custom ASIC design, we now can proceed with the first design approach to lightweight cryptography in the next chapter.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <h2 id="sec-21" class="text-2xl font-bold">3 New Lightweight DES Variants</h2>

    <p class="text-gray-300">In this Chapter we first give an overview of our approach in Section 3.1 and treat related work in Section 3.2. Subsequently we present and discuss design criteria for the new algorithm DESL in Section 3.3. There we will describe how we strengthened the original DES S-box design criteria in order to achieve a cryptographically stronger S-box compared to the original DES S-boxes. We will show, that our S-box resists linear and differential cryptanalyses and the Davies-Murphy-attack. The design and security analysis of DESL is joined work with Gregor Leander and hence contains contributions from him. Subsequently we present a lightweight hardware implementation architecture for DES, DESX, DESL and DESXL in Section 3.4. There we also will present the performance results of the described hardware implementations as well as software implementation results. Finally, in Section 3.5 we draw conclusions.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.1 DESL and DESXL: design ideas and security consideration</h3>

    <p class="text-gray-300">The main design ideas of the new cipher family of this Chapter, which are either original DES efficiently implemented or a variant of DES, are:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use of a serial hardware architecture which reduces the gate complexity.</li>

      <li>Optionally apply key-whitening in order to render brute-force attacks impossible.</li>

      <li>Optionally replace the 8 original S-boxes by a single one which further reduces the gate complexity.</li>

    </ol>

    <p class="text-gray-300">If we make use of the first idea, we obtain a lightweight implementation of the original DES algorithm which consumes about 35% less gates than the best known AES implementation <em>[71]</em>.</p>

    <p class="text-gray-300">To our knowledge, this is the smallest reported DES implementation, trading area for throughput. The implementation requires also about 86% fewer clock cycles for encrypting of one block than the serialized AES implementation in <em>[71]</em> (1032 cycles vs. 144) which makes it easier to use in standardized RFID protocols. However, the security provided is limited by the 56-bit key. Brute forcing this key space takes a few months and hundreds of PCs in software, and only a few days with a special-purpose machine such as COPACOBANA <em>[135]</em>. Hence, this implementation is only relevant for application where short-term security is needed, or where the values protected are relatively low. However, we can imagine that in certain low cost applications such a security level is adequate.</p>

    <p class="text-gray-300">In situation where a higher security level is needed key whitening, which we define here as follows:</p>

    <p class="text-gray-300"><span class="math">DESX_{k.k_{1}.k_{2}}(x)=k_{2}\\oplus DES_{k}(k_{1}\\oplus x)</span></p>

    <p class="text-gray-300">can be added to standard DES, yielding DESX. The additional XOR gates increase the gate count by about 14%. The best known key search attack uses a time-memory trade-off and requires <span class="math">2^{120}</span> time steps and <span class="math">2^{64}</span> memory locations, which renders this attack entirely out of reach. The best known mathematical attack is linear cryptanalysis <em>[149]</em>. Linear cryptanalysis requires about <span class="math">2^{43}</span> known ciphertext blocks together with the corresponding plaintexts. At a clock speed of 500 kHz, our DESX implementation will take more than 80 years, so that analytical attacks do not pose a realistic threat. Please note that parallelization is only an option if devices with identical keys are available.</p>

    <p class="text-gray-300">In situations where extremely lightweight cryptography is needed, we can further decrease the gate complexity of DES by replacing the eight original S-Boxes by a single new one. This lightweight variant of DES is named DESL and has a brute-force resistance of <span class="math">2^{56}</span>. In order to strengthen the cipher, key whitening can be applied yielding the cipher DESXL. The crucial question is what the strength of DESL and DESXL is with respect to analytical attacks. We are fully aware that any changes to a cipher might open the door to new attacks, even if the changes have been done very carefully and checked against known attacks. Hence, we believe that DESL (or DESXL) should primarily not be viewed as competitors to AES, but should be used in applications where established algorithms are too costly. In such applications which have to trade security (really: trust in an algorithm) for cost, we argue that it is a cryptographically sound approach to modestly modify a well studied cipher (in fact, the world’s best studied crypto algorithm).</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.2 Related work</h3>

    <p class="text-gray-300">In <em>[73]</em>, Feldhofer et al. propose a very small hardware implementation of the Advanced Encryption Standard (AES) <em>[161]</em> (<span class="math">3,400</span> GE), which was then by far the smallest available implementation of the AES. Their AES design is based on a byte-per-byte serialization, which only requires the implementation of a single S-box <em>[54]</em> and achieves an encryption within <span class="math">1,032</span> clock cycles (<span class="math">=10.32</span> ms @ <span class="math">100kHz</span>). Unfortunately, the ISO/IEC 18000 standard requires that the latency of a response of an RFID tag does not exceed <span class="math">320\\mu s</span>, which is why Feldhofer et al. propose a slightly modified challenge-response protocol based on interleaving. In 2006 Hämäläinen et al. propose a low area implementation of the AES that requires <span class="math">3,100</span> GE and only <span class="math">160</span> clock cycles <em>[96]</em>. However, these figures are still significantly higher than the assumed <span class="math">2,000</span> GE and it seems that it is not very likely to further decrease the area requirements for the AES. This might be due to the fact that the AES—besides the majority of block ciphers—has been developed with good software properties in mind, which in turn means that the gate count for a hardware implementation is rather high.</p>

    <p class="text-gray-300">The only well established cipher that was designed with a strong focus on low hardware costs is the Data Encryption Standard (DES) <em>[159]</em>. The smallest published implementation of DES consists of <span class="math">12,000</span> transistors, which roughly translates to <span class="math">3,000</span> GE, and requires <span class="math">28</span> clock cycles for one encryption <em>[232]</em>. It was published by Verbauwhede et al. back in 1988 and is not based on a modern semi-custom standard cell design flow. Instead it uses customized floor-planning and routing for which the whole implementation was optimized. If we compare this implementation of DES with a standard, one-round implementation of AES, the former</p>

    <p class="text-gray-300">3.3. Design criteria of DESL</p>

    <p class="text-gray-300">consumes about 6% (!) of the logic resources of AES, while having a shorter critical path <em>[232, 201]</em>.</p>

    <p class="text-gray-300">As will become clear in Section 3.4, S-boxes require a large share of the area. Hence, a native approach is to alter the substitution layer of DES by replacing the eight original S-boxes by one S-box, which is repeated eight times. While it does not seem to be possible to find better logic minimizations of the original DES S-boxes, there have been other approaches to alter the S-box, e.g. key-dependent S-boxes <em>[22]</em>, <em>[26]</em> or the so-called <span class="math">s^{i}DES</span> <em>[122, 123, 124]</em>. All these approaches—despite the fact that some of them have worse cryptographic properties than DES <em>[128]</em>—just change the content and not the number of S-boxes. To the best of our knowledge, no DES variant has been proposed in the past which uses a single S-box, repeated eight times. In Section 3.3 we describe how a variant of DES with a single S-box can be made resistant against the differential, linear, and Davies-Murphy attack. The work is based on the original design criteria for DES as published by Coppersmith <em>[48]</em> and the work of Kim et al. <em>[122, 123, 124]</em> where several criteria for DES type S-boxes are presented to strengthen the resistance against the above mentioned attacks.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">3.3 Design criteria of DESL</h3>

    <p class="text-gray-300">Coppersmith states the following eight criteria as the “only cryptographically relevant” ones for the DES S-boxes (see <em>[48]</em>):</p>

    <p class="text-gray-300">Each S-box has six bits of input and four bits of output. No output bit of an S-box should be too close to a linear function of the input bits. If we fix the leftmost and rightmost input bits of the S-box and vary the four middle bits, each possible 4-bit output is attained exactly once as the middle input bits range over their 16 possibilities. If two inputs to an S-box differ in exactly one bit, the outputs must differ in at least two bits. If two inputs to an S-box differ in the two middle bits exactly, the outputs must differ in at least two bits. If two inputs to an S-box differ in their first two bits and are identical in their last two bits, the two outputs must not be the same. For any nonzero 6-bit-difference between inputs, <span class="math">\\Delta I</span>, no more than eight of the 32 pairs of inputs exhibiting <span class="math">\\Delta I</span> may result in the same output difference <span class="math">\\Delta O</span>. Minimize the probability that a non zero input difference to three adjacent S-boxes yield a zero output difference.</p>

    <p class="text-gray-300">In the following sections we will develop eight criterions (C1-C8) which ensure that DESL is resistant against differential, linear, and the Davies-Murphy attack. Figure 3.1 shows our approach for setting up the eight conditions and provides an overview over their purpose.</p>

    <p class="text-gray-300">2Please note that between the DES implementation of Verbauwhede et al. [232] in 1988 and the AES implementation of Satoh et al. [201] in 2001 more than a decade has passed and synthesis algorithms have been greatly improved since.</p>

    <p class="text-gray-300">Chapter 3. New Lightweight DES Variants</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3.1: Eight conditions to be fulfilled by the S-box of DESL in order to thwart differential, linear, and the Davies-Murphy attack.</p>

    <p class="text-gray-300">The criteria (S-1) to (S-7) refer to one single S-box. The only criterion which deals with the combination of S-boxes is criterion (S-8). The designers' goal was to minimize the probability of collisions at the output of the S-boxes and thus at the output of the  <span class="math">f</span> -function. As a matter of fact, it is only possible to cause a collision, i.e. two different inputs are mapped to the same output, in three adjacent S-boxes, but not in a single S-box or a pair of S-boxes due to the diffusion caused by the expansion permutation. The possibility to have a collision in three adjacent S-boxes leads to the most successful differential attack based on a 2-round iterative characteristic with probability  <span class="math">\\frac{1}{234}</span> .</p>

    <p class="text-gray-300">Clearly better than minimizing the probability for collisions in three or more adjacent S-boxes, is to eliminate them. This was the approach used in [122, 123, 124] and can easily be reached by improving one of the design criteria.</p>

    <p class="text-gray-300">We replace (S-6) and (S-8) by an improved design criterion similar to the one given in [124].</p>

    <p class="text-gray-300">Condition 1. If two inputs to an  <span class="math">S</span> -box differ in their first bit and are identical in their last two bits, the two outputs must not be the same.</p>

    <p class="text-gray-300">This criterion ensures that differential attacks using 2-round iterative characteristics, as the one presented by Biham and Shamir in [26], will have all eight S-boxes active and therefore will not be more efficient than exhaustive search anymore.</p>

    <p class="text-gray-300">Moreover, the only criterion that refers to more than one S-box, i.e. (S-8), is now replaced by a condition that refers to one S-box, only. Thus, most of the security analysis remains unchanged when we replace the eight different S-boxes by one S-box repeated eight times.</p>

    <p class="text-gray-300">Note that as described by Biham in <em>[23]</em> and by Kim et al. in <em>[123]</em> this condition also ensures resistance against the Davies Murphy attack <em>[56]</em>.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">3.3.2 Improved resistance against linear cryptanalysis</h4>

    <p class="text-gray-300">To improve the resistance of our variant of DES with only one S-Box against linear cryptanalysis (LC) is more complex than the protection against the differential cryptanalysis. Kim et al. presented a number of conditions that, when fulfilled by a set of S-boxes, ensure the resistance of DES variants against LC. However, several of these conditions focus on different S-boxes and this implies that if one wants to replace all eight S-boxes by just one S-box, there are very tight restrictions to the choice of the S-box. This one S-box has to fulfill all conditions given in <em>[123]</em> referring to any S-box.</p>

    <p class="text-gray-300">Let <span class="math">S_{b}=\\langle b,S\\left(x\\right)\\rangle</span> denote a combination of output bits that is determined by <span class="math">b\\in\\mathrm{GF}(2)^{4}</span>. Then, the Walsh-coefficient <span class="math">S_{b}^{\\mathcal{W}}\\left(a\\right)</span> for an element <span class="math">a\\in\\mathrm{GF}(2)^{6}</span> is defined by</p>

    <p class="text-gray-300"><span class="math">S_{b}^{\\mathcal{W}}(a)=\\sum_{x\\in\\mathrm{GF}(2)^{6}}(-1)^{\\langle b,S(x)\\rangle+\\langle a,x\\rangle}.</span> (3.1)</p>

    <p class="text-gray-300">Since</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\#\\left\\{x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{b}\\left(x\\right)=\\langle a,x\\rangle\\right\\}+\\#\\left\\{x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{b}\\left(x\\right)\\neq\\langle a,x\\rangle\\right\\}=2^{6}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">it follows that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S_{b}^{\\mathcal{W}}(a)=2\\#\\left\\{x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{b}\\left(x\\right)=\\langle a,x\\rangle\\right\\}-2^{6}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The probability of a linear approximation of a combination of output bits <span class="math">S_{b}</span> by a linear combination <span class="math">a</span> of input bits can be written as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p=\\frac{\\#\\left\\{x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{b}\\left(x\\right)=\\langle a,x\\rangle\\right\\}}{2^{6}}.$ (3.2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining equations 3.1 and 3.2 leads to</p>

    <p class="text-gray-300"><span class="math">p=\\frac{S_{b}^{\\mathcal{W}}\\left(a\\right)}{2^{7}}+\\frac{1}{2}.</span></p>

    <p class="text-gray-300">The linear probability bias <span class="math">\\varepsilon</span> is a correlation measure for this deviation from probability <span class="math">\\frac{1}{2}</span> for which it is entirely uncorrelated. We have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p-\\frac{1}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{S_{b}^{\\mathcal{W}}\\left(a\\right)}{2^{7}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us denote the maximum absolute value of the Walsh-Transformation by <span class="math">S_{max}^{\\mathcal{W}}</span>. Then clearly</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon\\leq\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{S_{max}^{\\mathcal{W}}\\left(a\\right)}{2^{7}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The smaller the linear probability bias <span class="math">\\varepsilon</span> is, the more secure the S-box is against linear cryptanalysis. We defined our criterion (S-2”) by setting the threshold for <span class="math">S_{max}^{\\mathcal{W}}</span></p>

    <p class="text-gray-300">Chapter 3. New Lightweight DES Variants</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Condition 2. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{b}^{W}(a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 28<span class="math"> for all </span>a\\in\\mathrm{GF}(2)^{6},\\ b\\in\\mathrm{GF}(2)^{4}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that this is a tightened version of Condition 2 given in <em>[123]</em> where the threshold was set to <span class="math">32</span>. In the original DES the best linear approximation has a maximum absolute Walsh coefficient of <span class="math">40</span> for S-box S5.</p>

    <p class="text-gray-300">If an LC attack is based on an approximation that involves <span class="math">n</span> S-boxes, under the standard assumption that the round keys are statistically independent, the overall bias <span class="math">\\varepsilon</span> is (see <em>[149]</em>)</p>

    <p class="text-gray-300"><span class="math">\\varepsilon=2^{n-1}\\prod_{i=1}^{n}\\varepsilon_{i}</span></p>

    <p class="text-gray-300">where the values <span class="math">\\varepsilon_{i}</span> are the biases for each of the involved S-box.</p>

    <p class="text-gray-300">A rough approximation of the effort of a linear attack based on a linear approximation with bias <span class="math">\\varepsilon</span> is <span class="math">\\varepsilon^{-2}</span>, thus if we require that such an attack is no more efficient than exhaustive search we need <span class="math">\\varepsilon&amp;lt;2^{-28}</span>.</p>

    <p class="text-gray-300">It can easily be seen that any linear approximation for <span class="math">15</span> round DES involves at least <span class="math">7</span> approximations for S-boxes. But as</p>

    <p class="text-gray-300"><span class="math">2^{6}\\prod_{i=1}^{7}\\varepsilon_{i}\\leq 2^{6}\\prod_{i=1}^{7}\\frac{7}{32}\\approx 2^{-9.35}</span></p>

    <p class="text-gray-300">this bound is clearly insufficient.</p>

    <p class="text-gray-300">Thus in order to prove the resistance against linear attack, we have to make sure that either enough S-boxes are active, i.e. enough S-Boxes are involved in the linear approximation, or, if fewer S-boxes are active, the bound on the probabilities can be tightened. In the first case we need more than <span class="math">23</span> active S-boxes as</p>

    <p class="text-gray-300"><span class="math">2^{21}\\left(\\frac{S_{max}^{W}}{128}\\right)^{22}&amp;gt;2^{-28}&amp;gt;2^{22}\\left(\\frac{S_{max}^{W}}{128}\\right)^{23}.</span> (3.3)</p>

    <p class="text-gray-300">For the second case several conditions have been developed in <em>[122, 123]</em>. Due to our special constraints we have to slightly modify these conditions. Following <em>[123]</em> we discuss several cases of iterative linear approximations. We denote a linear approximation of the <span class="math">F</span> function of DES by</p>

    <p class="text-gray-300"><span class="math">\\langle I,Z_{1}\\rangle+\\langle K,Z_{3}\\rangle=\\langle O,Z_{2}\\rangle</span></p>

    <p class="text-gray-300">where <span class="math">Z_{1},Z_{2},Z_{3}\\in\\mathrm{GF}(2)^{32}</span> specify the input, output and key bits used in the linear approximation.</p>

    <p class="text-gray-300">An <span class="math">n</span> round iterative linear approximation is of the form</p>

    <p class="text-gray-300"><span class="math">\\langle I_{1},\\cdot\\rangle+\\langle I_{n},\\cdot\\rangle=\\langle K_{2},\\cdot\\rangle+\\cdots+\\langle K_{n-1},\\cdot\\rangle</span></p>

    <p class="text-gray-300">and consists of linear approximations for the rounds <span class="math">2</span> until <span class="math">n-1</span>.</p>

    <p class="text-gray-300">Similar as it was done in <em>[122]</em> it can be shown that a three round (3R) iterative linear approximation is not possible with a non zero bias, due to condition 1.</p>

    <p class="text-gray-300">We therefore focus on the case of a <span class="math">4</span> and <span class="math">5</span> round iterative approximation only.</p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300">3.3.3 4R iterative linear approximation</p>

    <p class="text-gray-300">A four round iterative linear approximation consists of two linear approximations for the <span class="math">F</span> function of the second and third round. We denote these approximations as</p>

    <p class="text-gray-300"><span class="math">A:\\langle I_{2},Z_{1}\\rangle+\\langle K_{2},Z_{3}\\rangle</span> <span class="math">=</span> <span class="math">\\langle O_{2},Z_{2}\\rangle</span> <span class="math">B:\\langle I_{3},Y_{1}\\rangle+\\langle K_{3},Y_{3}\\rangle</span> <span class="math">=</span> <span class="math">\\langle O_{3},Y_{2}\\rangle.</span></p>

    <p class="text-gray-300">In order to get a linear approximation of the form</p>

    <p class="text-gray-300"><span class="math">\\langle I_{1},\\cdot\\rangle+\\langle I_{4},\\cdot\\rangle=\\langle K_{2},\\cdot\\rangle+\\langle K_{3},\\cdot\\rangle</span></p>

    <p class="text-gray-300">Using <span class="math">O_{2}=I_{1}+I_{3}</span> and <span class="math">O_{3}=I_{2}+I_{4}</span> it must hold that</p>

    <p class="text-gray-300"><span class="math">Z_{2}=Y_{1}\\text{ and }Z_{1}=Y_{2}.</span></p>

    <p class="text-gray-300">The <span class="math">15</span> round approximation is</p>

    <p class="text-gray-300"><span class="math">-AB-BA-AB-BA-AB.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the number of S-boxes involved in the approximation of <span class="math">A</span> is <span class="math">a</span> and for <span class="math">B</span> is <span class="math">b</span> we denote by <span class="math">\\mathcal{A}=(a,b)</span>. First assume that <span class="math">\\mathcal{A}=(1,1)</span>. Due to <span class="math">Z_{2}=Y_{1}</span> and the property of the P-permutation, which distributes the output bits of one S-box to <span class="math">6</span> different S-Boxes in the next round, it must hold that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">. For the same reason we get </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$. To minimize the probability of such an approximation we stipulate the following condition</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-27" class="text-base font-medium mt-4">Condition 3.</h6>

    <p class="text-gray-300">The S-box has to fulfill <span class="math">S_{b}^{\\mathcal{W}}(a)\\leq 4</span> for all <span class="math">a\\in\\mathrm{GF}(2)^{6},b\\in\\mathrm{GF}(2)^{4}</span> with <span class="math">\\mathrm{wt}(a)=\\mathrm{wt}(b)=1</span>.</p>

    <p class="text-gray-300">This condition is comparable to Condition 4 in <em>[123]</em>, however, as we only have a single S-box, we could not find a single S-box fulfilling all the restrictions from Condition 4 in <em>[123]</em>. If the S-box fulfills condition 3 the overall bias for the linear approximation described above is bounded by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq 2^{9}\\left(\\frac{4}{128}\\right)^{10}&lt;2^{-40}.</span></p>

    <p class="text-gray-300">As this is (much) smaller than <span class="math">2^{-28}</span> this does not yield to a useful approximation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume now that <span class="math">\\mathcal{A}=(1,2)</span> (the case <span class="math">\\mathcal{A}=(2,1)</span> is very similar). If <span class="math">B</span> involves two S-boxes we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math"> and thus </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math">. In particular for both S-boxes involved in </span>B$ Condition 3 applies which results in a threshold</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq 2^{14}\\left(\\frac{4}{128}\\right)^{10}\\left(\\frac{28}{128}\\right)^{5}&lt;2^{-46}</span></p>

    <p class="text-gray-300">for the overall linear bias.</p>

    <p class="text-gray-300">Next we assume that <span class="math">\\mathcal{A}=(2,2)</span> . In this case we get (through the properties of the <span class="math">P</span> function) that each S-box involved in <span class="math">A</span> and <span class="math">B</span> has at most two input and output bits involved in the linear approximation. In order to avoid this kind of approximation we add another condition.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Condition 4.</h6>

    <p class="text-gray-300">The S-box has to fulfill <span class="math">S_{b}^{\\mathcal{W}}(a)\\leq 16</span> for all <span class="math">a\\in\\mathrm{GF}(2)^{6},b\\in\\mathrm{GF}(2)^{4}</span> with <span class="math">\\mathrm{wt}(a),\\mathrm{wt}(b)\\leq 2</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">This condition is a tightened version of Condition 5 in <em>[123]</em> where the threshold was set to <span class="math">20</span>. In this case (remember that we now have <span class="math">20</span> S-boxes involved) we get</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq 2^{19}\\left(\\frac{16}{128}\\right)^{20}&lt;2^{-40}.</span></p>

    <p class="text-gray-300">In all other cases, more than <span class="math">23</span> S-boxes are involved and thus the general upper bound (3.3) can be applied.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">3.3.4 5R iterative linear approximation</h4>

    <p class="text-gray-300">A five round iterative linear approximation consists of three linear approximations for the <span class="math">F</span> function of the second, third and fourth round. We denote these approximations as</p>

    <p class="text-gray-300"><span class="math">A:\\langle I_{2},Z_{1}\\rangle+\\langle K_{2},Z_{3}\\rangle</span> <span class="math">=</span> <span class="math">\\langle O_{2},Z_{2}\\rangle</span> <span class="math">B:\\langle I_{3},Y_{1}\\rangle+\\langle K_{3},Y_{3}\\rangle</span> <span class="math">=</span> <span class="math">\\langle O_{3},Y_{2}\\rangle</span> <span class="math">C:\\langle I_{4},X_{1}\\rangle+\\langle K_{4},X_{3}\\rangle</span> <span class="math">=</span> <span class="math">\\langle O_{4},X_{2}\\rangle.</span></p>

    <p class="text-gray-300">In order to get a linear approximation of the form</p>

    <p class="text-gray-300"><span class="math">\\langle I_{1},\\cdot\\rangle+\\langle I_{5},\\cdot\\rangle=\\langle K_{2},\\cdot\\rangle+\\langle K_{3},\\cdot\\rangle+\\langle K_{4},\\cdot\\rangle</span></p>

    <p class="text-gray-300">it must hold that</p>

    <p class="text-gray-300"><span class="math">Z_{1}=Y_{2}=X_{1}\\text{ and }Y_{1}+Z_{2}+X_{2}=0.</span></p>

    <p class="text-gray-300">The <span class="math">15</span> round approximation is</p>

    <p class="text-gray-300"><span class="math">-ABC-CBA-ABC-DE</span></p>

    <p class="text-gray-300">for some linear approximations <span class="math">D</span> and <span class="math">E</span> each involving at least one S-box. Clearly, as the inputs of <span class="math">A</span> and <span class="math">C</span> are the same we have <span class="math">\\mathcal{A}=(a,b,a)</span>, i.e. the number of involved S-boxes in <span class="math">A</span> and <span class="math">C</span> are the same.</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Case <span class="math">b=1</span>:</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume that <span class="math">b=1</span>, i.e. only one S-box is involved in the linear approximation <span class="math">B</span>. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 3<span class="math"> than we must have </span>a\\geq 3<span class="math"> and so the number of S-boxes involved is at least </span>23<span class="math">, which makes the approximation useless. If </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math"> we have two active S-boxes for </span>A<span class="math"> and </span>B<span class="math">. Moreover as </span>b=1<span class="math"> we must have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{2}+X_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">. Due to properties of the </span>P<span class="math"> function, the S-boxes involved in </span>A<span class="math"> and </span>B$ are never adjacent S-boxes, therefore exactly one input bit is involved in the approximation for each of the two S-boxes. In order to minimize the probability for such an approximation, we stipulate the following condition:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-31" class="text-base font-medium mt-4">Condition 5.</h6>

    <p class="text-gray-300">The S-box has to fulfill</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{b_{1}}^{\\mathcal{W}}(a)S_{b_{2}}^{\\mathcal{W}}(a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 240$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for all <span class="math">a\\in\\mathrm{GF}(2)^{6},b_{1},b_{2}\\in\\mathrm{GF}(2)^{4}</span> with <span class="math">\\mathrm{wt}(a)=1,\\mathrm{wt}(b_{1}+b_{2})=1</span>.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">This is a modified version of Condition 7 in <em>[123]</em>. With an S-box fulfilling this condition we derive an upper bound for the overall bias</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq 2^{16}\\left(\\frac{240}{128^{2}}\\right)^{6}\\left(\\frac{16}{128}\\right)^{3}\\left(\\frac{28}{128}\\right)^{2}&lt;2^{-33}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> then </span>a=1<span class="math"> and we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{2}+X_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$. We stipulate one more condition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-32" class="text-base font-medium mt-4">Condition 6.</h6>

    <p class="text-gray-300">The S-box has to fulfill</p>

    <p class="text-gray-300"><span class="math">S^{\\mathcal{W}}_{b}(a)=0</span></p>

    <p class="text-gray-300">for <span class="math">a\\in\\{(010000),(000010)\\},b\\in\\mathrm{GF}(2)^{4}\\text{ with }\\mathrm{wt}(b)=1</span>.</p>

    <p class="text-gray-300">This implies that the input to <span class="math">B</span> is such that a middle bit is affected. Due to the properties of the <span class="math">P</span> function this implies that in the input of <span class="math">A</span> and <span class="math">C</span> a non-middle bit is affected. As for any DES type S-box it holds that <span class="math">S^{\\mathcal{W}}_{b}(100000)=S^{\\mathcal{W}}_{b}(000001)=0</span> for all <span class="math">b</span> the only possible input values for the S-box involved in <span class="math">A</span> and <span class="math">C</span> are <span class="math">(010000)</span> and <span class="math">(000010)</span>. To avoid the second one we define the next condition.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Condition 7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\mathcal{W}}_{b_{1}}(000010)S^{\\mathcal{W}}_{b_{2}}(000010)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for all <span class="math">b_{1},b_{2}\\in\\mathrm{GF}(2)^{4}\\text{ with }\\mathrm{wt}(b_{1}+b_{2})=1</span>.</p>

    <p class="text-gray-300">The other possible input value, <em>i.e.</em> <span class="math">01000</span> occurs only when S-box <span class="math">1</span> is active in <span class="math">B</span> and S-box <span class="math">5</span> is active in <span class="math">A</span> and <span class="math">C</span>. In this case the input values for the S-box in <span class="math">B</span> is <span class="math">(000100)</span> and the output value is <span class="math">(0100)</span>. The next condition makes this approximation impossible.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Condition 8.</h6>

    <p class="text-gray-300">The S-box has to fulfill</p>

    <p class="text-gray-300"><span class="math">S^{\\mathcal{W}}_{(0100)}(000100)=0.</span></p>

    <h5 id="sec-35" class="text-base font-semibold mt-4">Case <span class="math">b=2</span>:</h5>

    <p class="text-gray-300">Assume that <span class="math">b=2</span>, <em>i.e.</em> exactly two S-boxes are involved for <span class="math">B</span>. If <span class="math">a&gt;2</span> then at least <span class="math">23</span> S-boxes are involved in total. If <span class="math">a=2</span> we have for each S-box involved in <span class="math">B</span> at most <span class="math">2</span> input bits and at most <span class="math">2</span> output bits. Therefore we can apply the bound from condition 4 to the two S-boxes from <span class="math">B</span>. Applying the general bound for all the other S-boxes we get</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq 2^{19}\\left(\\frac{16}{128}\\right)^{6}\\left(\\frac{28}{128}\\right)^{14}&lt;2^{-29}.</span></p>

    <p class="text-gray-300">In the case where <span class="math">a=1</span> the two S-boxes involved in <span class="math">B</span> have one input and one output bit involved each, thus we can apply the strong bound from condition 3 for these S-boxes (6 in total) and the general bound for the other S-boxes to get</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq 2^{13}\\left(\\frac{4}{128}\\right)^{6}\\left(\\frac{28}{128}\\right)^{8}&lt;2^{-34}.</span></p>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Case <span class="math">b&gt;2</span>:</h5>

    <p class="text-gray-300">In this case we must have <span class="math">a,b\\geq 2</span> and thus at least <span class="math">29</span> S-boxes are involved in total.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">Chapter 3. New Lightweight DES Variants</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DES S-box</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DESL</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"># deg 2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"># deg 3</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3.1: Number of Degree two and Degree three Equations</p>

    <p class="text-gray-300">|  S  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3.2: Improved DESL S-box</p>

    <p class="text-gray-300">For an  <span class="math">n</span>  round iterative linear approximation with only one S-box involved in each round (denoted as Type-I by Matsui) our condition 3 ensures that if more than 7 S-boxes are involved in total the approximation will not be useful for an attack as</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon \\leq 2 ^ {6} \\left(\\frac {4}{1 2 8}\\right) ^ {7} = 2 ^ {- 2 9}. \\tag {3.4}</span></div>

    <p class="text-gray-300">There is no structural reason why algebraic attacks should pose a greater threat to DESL than to DES. The DESL S-box has been randomly generated in the set of all S-boxes fulfilling the design criteria described above. Therefore we do not expect any special weakness of the chosen S-box. Indeed we computed the number of low degree equations between the input and output bits of the S-box. There exist one quadratic equation and 88 equations of degree 3. Note that for each 6 to 4 Bit S-box, there exist at least 88 equations of degree 3. Given the comparison with the corresponding results for the original DES S-boxes in Table 3.1 we anticipate that DESL is as secure as DES with respect to algebraic attacks.</p>

    <p class="text-gray-300">We randomly generated S-boxes, which fulfill the original DES criteria (S-1), (S-3), (S-4), (S-5), (S-7), Condition 1 and our modified Conditions 2 to 8. Our goal was to find one single S-box, which is significantly more resistant against differential and linear cryptanalyses than the original eight S-boxes of DES. In our DESL algorithm this S-box is repeated eight times and replaces all eight S-boxes in DES. Table 3.2 depicts the improved DESL S-box.</p>

    <p class="text-gray-300">3.4. Implementation results</p>

    <p class="text-gray-300">In this section we present the hardware implementation architecture for our family of lightweight block ciphers. We implemented DES, DESX, DESL, and DESXL in the hardware description language VHDL, where we sacrificed time for area wherever possible. We used Synopsys Design Vision V-2004.06-SP2 to map our designs to the Artisan UMC 0.18<span class="math">\\mu</span>m L180 Process <span class="math">1.8</span>-Volt Sage-X Standard Cell Library and Cadence Silicon Ensemble 5.4 for the Placement &amp; Routing-step. Synopsys NanoSim was used to simulate the power consumption of the back-annotated verilog netlist of the ASICs.</p>

    <p class="text-gray-300">We first describe the DES and DESX implementations in Section 3.4.1 and subsequently describe the DESL and DESXL implementations in Section 3.4.2. Finally we list the software implementation results of DES, DESL and DESX in Section 3.4.3.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">3.4.1 Lightweight hardware implementation of DES and DESX</h4>

    <p class="text-gray-300">The overall architecture of our size-optimized DES implementation is depicted in Figure 3.2. Our design basically consists of five core modules: controller, keyschedule, mem_left, mem_right, and sbox. Subsequently, we give a brief description of these modules.</p>

    <p class="text-gray-300">Controller: The controller module manages all control signals in the ASIC based on a finite state machine. The FSM is depicted in Figure 3.3. Keyschedule: In this module all DES round keys are generated. It is composed of a 56-bit register, an input multiplexer, and an output multiplexer to select the right fraction of the roundkey. mem_left: This module consists of eight 4-bit wide registers, each composed of D-flip-flops. mem_right: This module is similar to the mem_left module with slight differences. It also consists of eight 4-bit wide registers, but it has different input and output signals: instead of a 4-bit wide output it has a 6-bit wide output, due to the expansion function of DES. sbox: This module consists of eight S-boxes of the DES algorithm and an output multiplexer. The S-boxes are realized in combinatorial logic, i.e. a sum of products (SOP) <em>[170]</em>.</p>

    <p class="text-gray-300">Figure 3.2 also shows the datapath of our serialized DES design. The 56-bit key is stored in the key flip-flop register after the PC1 and LS1 permutations have been applied. The plaintext is first confused using the Initial Permutation (IP), then, it is split into two 32-bit inputs for the modules mem_left and mem_right, respectively. The input of mem_left is modified by the inverse of the <span class="math">P</span> permutation and stored in the registers of the modules mem_left and mem_right in one cycle. Next, the output of the last register in mem_right is both stored in the first register of mem_right and expanded to six bits. After an XOR operation with the appropriate block of the current round key, this expanded value is processed by the sbox module, which is selected by the count signal, provided by the controller module. Finally, the result is XORed with the</p>

    <p class="text-gray-300">3Note that the memory modules were designed in a shift register manner, such that the output of a 4-bit block is fed as the new input into the following block. At the end of the chain the current 4-bit block is provided and can be processed without an additional output multiplexer, which results in a saving of 48 GE.</p>

    <p class="text-gray-300">4Note that the design in a shift register manner in this module saves even more area (72 GE) than in the mem_left module, because here a 6-bit wide output multiplexer can be saved. Altogether 120 GE can be saved by our memory design compared to a regular design.</p>

    <p class="text-gray-300">Chapter 3. New Lightweight DES Variants</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 3.2: Datapath of the serialized DES ASIC with original S-boxes.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 3.3: Finite State Machine of the ASIC architecture for DES, DESX, DESL, and DESXL.</p>

    <p class="text-gray-300">output of the mem_left module, and stored in the first flip-flop of the mem_left module. This is repeated eight times, until all 32 bits of the right half are processed.</p>

    <p class="text-gray-300">In our design, we applied the <span class="math">P</span> permutation in each ninth clock cycle. Because the <span class="math">P^{-1}</span> permutation is applied before the left 32-bit half <span class="math">L_{i}</span> is stored in the mem_left module, we perform the (P) permutation on the resulting right half <span class="math">R_{i+1}=P\\left(P^{-1}\\left(L_{i}\\right)\\oplus S\\left(E\\left(R_{i}\\right)\\oplus K_{i}\\right)\\right),</span> where <span class="math">L_{i}</span> denotes the left half, <span class="math">R_{i}</span> denotes the right half, and <span class="math">K_{i}</span> denotes the round key.</p>

    <p class="text-gray-300">By reducing the datapath from a 32-bit bus to a 4-bit bus, only <span class="math">6\\cdot 10+4\\cdot 10=100</span> transistors (25 GE) are needed for the XOR operations, compared to <span class="math">48\\cdot 10+32\\cdot 10=800</span> (200 GE) transistors in a not-serialized design. This saving comes with the disadvantage of two additional multiplexers, each one for the round key (72 GE) and for the S-box output (48 GE). As we will see in Section 3.4.2, our DESL algorithm does not need an output multiplexer in the sbox module.</p>

    <p class="text-gray-300">Once all eight 4-bit blocks of both halves have been processed, they are concatenated to two 32-bit wide outputs of the modules mem_left and mem_right. The output of the module mem_left is transformed by the <span class="math">P</span> permutation and stored as the new content of the mem_right module, while the output of the mem_right module is stored as the new content of the mem_left module. This execution flow repeats another 15 rounds. Finally, both outputs of the memory modules mem_left and mem_right are concatenated to a 64-bit wide output. This output is confused by the Inverse Initial Permutation (<span class="math">IP^{-1}</span>), which results in a valid ciphertext of the DES algorithm. It takes 144 clock cycles to encrypt one 64-bit block of plaintext. For one encryption at 100 kHz the average current consumption is <span class="math">1.19</span> <span class="math">\\mu</span>A and the throughput reaches 5.55 KB/s.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">3.4.2 Lightweight hardware implementation of DESL and DESXL</h4>

    <p class="text-gray-300">As we have described in the previous sections, the main difference between DESL and DES lies in the <span class="math">f</span>-function. We substituted the eight original DES S-boxes by a single but cryptographically stronger S-box (see Table 3.2), which is repeated eight times. Furthermore, we omitted the initial permutation (IP) and its inverse (IP^{-1}), because they do not provide additional cryptographic strength, but at the same time require area for wiring. The design of our DESL algorithm is exactly the same as for the DES algorithm, except for the (IP) and (IP^{-1}) wiring and the sbox module. Figure 3.4 depicts the architecture of the serialized DESL implementation.</p>

    <p class="text-gray-300">Our serialized DESL ASIC implementation has an area requirement of <span class="math">1848</span> GE and it takes 144 clock cycles to encrypt one 64-bit block of plaintext. For one encryption at 100 kHz the average current consumption is <span class="math">0.89</span> <span class="math">\\mu</span>A and the throughput reaches 5.55 KBps. For further details on the implementational aspects of our DES and DESL architecture we refer to <em>[184]</em>.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">3.4.3 Lightweight software implementation results</h4>

    <p class="text-gray-300">For the sake of completeness also lightweight software implementation results have been included here. The figures were taken from <em>[68]</em> and have been obtained for the ATMEL ATMega128 8-bit microcontroller, which is a widely used embedded processor for smart cards and WSNs, e.g. in Micaz Motes. Table 3.4 depicts implementation results of DESL and DESXL for an <span class="math">8</span>-bit microcontroller.</p>

    <p class="text-gray-300">A comparison with software implementations for <span class="math">8</span> bit microcontroller of other block and stream ciphers will be done in Section 5.4.</p>

    <p class="text-gray-300">Chapter 3. New Lightweight DES Variants</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 3.4: Datapath of the serialized DESL ASIC with the improved S-box.</p>

    <p class="text-gray-300">Table 3.3: Hardware implementation results of DES, DESX, DESL and DESXL. All figures are obtained at or calculated for a frequency of  <span class="math">100\\mathrm{kHz}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">key size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">block size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">datapath width</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cycles / block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put [Kbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tech. [μm]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area [GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eff. [bps/GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cur. [μA]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Serialized Architecture  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DES</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">56</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">144</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44.44</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,309</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19.25</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.19</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESX</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">44.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">2,629</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESXL</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">44.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">2,168</td>

            <td class="px-3 py-2 border-b border-gray-700">20.5</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3.5. Conclusions</p>

    <p class="text-gray-300">Table 3.4: Software implementation results of DESL and DESXL.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key size [bits]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Block size [bits]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">code size [bytes]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Encryption [cycles / block]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put at 4 MHZ [Kbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decryption [cycles / block]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put at 4 MHZ [Kbps]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESL [195]</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">3,098</td>

            <td class="px-3 py-2 border-b border-gray-700">8,365</td>

            <td class="px-3 py-2 border-b border-gray-700">30.6</td>

            <td class="px-3 py-2 border-b border-gray-700">7,885</td>

            <td class="px-3 py-2 border-b border-gray-700">32.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESXL [68]</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">3,192</td>

            <td class="px-3 py-2 border-b border-gray-700">8,531</td>

            <td class="px-3 py-2 border-b border-gray-700">30.4</td>

            <td class="px-3 py-2 border-b border-gray-700">7,961</td>

            <td class="px-3 py-2 border-b border-gray-700">32.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We started with the approach of implementing a standardized algorithm with the optimization goal of minimal hardware requirements. We chose DES, because it is one of the very few algorithms that was designed with a strong focus on hardware efficiency and is probably the best investigated algorithm. As a result we presented the smallest known hardware implementation of DES in Section 3.4.</p>

    <p class="text-gray-300">The next step was to have a closer look on the hardware requirements of the single components and it turned out that the substitution layer of DES is very demanding in terms of area requirements. Consequently we thought about further optimizations and we decided to slightly and very carefully change the substitution layer of DES. The literature study revealed that there was no DES variant published that uses a single S-box repeated eight times. Therefore we studied the design criteria of DES S-boxes and the various publications that deal with cryptographic properties of S-boxes.</p>

    <p class="text-gray-300">In Section 3.3 we stated eight conditions that have to be fulfilled by a single S-box in order to be resistant against certain types of linear and differential cryptanalyses, and the Davies-Murphy attack. We presented a strengthened S-box, which is used in the single S-box DES variants DESL and DESXL. Furthermore, we showed, that a differential cryptanalysis with characteristics similar to the characteristics used by Biham and Shamir in [25] is not feasible anymore. We also showed, that DESL is more resistant against the most promising types of linear cryptanalysis than DES due to the improved non-linearity of the S-box.</p>

    <p class="text-gray-300">In order to expand the keyspace we also proposed DESXL, which is a DESX variant based on DESL rather than on DES. DESL and DESXL are two examples for the approach where a well trusted algorithm is slightly and very carefully modified. In order to gain an even more hardware efficient implementation of a cryptographic algorithm, it is required to design a new lightweight algorithm from scratch. This is what we will do in the next chapter.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <h2 id="sec-45" class="text-2xl font-bold">4 present - An Ultra-Lightweight Block Cipher</h2>

    <p class="text-gray-300">In this Chapter we will follow the third approach and design a new cipher from scratch. First we will review related work in Section 4.1 before we present our design decisions in Section 4.2. Then we will present algorithmic descriptions of the encryption (Section 4.3) and the decryption (Section 4.4) routine of present. The key schedule is presented in Section 4.5 and its cryptanalytic aspects are treated subsequently in Section 4.6. Finally we close this Chapter with further observations on the structure of present in Section 4.7. Please note that this chapter is based on joint work with Andrey Bogdanov, Lars Knudsen, Gregor Leander, Christof Paar, Matt Robshaw, Yannick Seurin and Charlotte Vikkelsoe. It is hard to clearly separate individual contributions, but especially the cryptographic aspects, such as the security assessment in Section 4.6, contain significant contributions from co-designers. Implementation results of present will be presented in the following Chapter 5.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">4.1 Related work</h3>

    <p class="text-gray-300">The RFID technology is widely discussed as a promising solution for the counterfeiting issues in the literature <em>[209, 229, 115, 143]</em>. Many of the proposed authentication protocols use a Pseudo Random Number Generator (PRNG), a hash function, or symmetric key encryption <em>[156, 62, 71, 70, 15, 65, 141, 193, 78]</em>. Cheap tags pose severe implementation challenges and it is far from clear that a suitable hash function even exists. Block ciphers however can be used as basic building blocks for a secure identification system, for example in a challenge-response protocol.</p>

    <p class="text-gray-300">Quite a few lightweight cryptographic algorithms have been published that are especially optimized for ultra-constrained devices. HIGHT <em>[107]</em> was recently published by Hong et al. in 2006. It has a <span class="math">64</span>-bit state, a <span class="math">128</span>-bit key, consists of <span class="math">32</span> rounds and was specifically designed for constrained devices such as wireless sensor networks and RFID-tags. HIGHT has a generalized Feistel-like structure and every operation is <span class="math">8</span>-bit oriented. The authors state a hardware requirement of <span class="math">3,048</span> GE for a round-based implementation of HIGHT, but unfortunately do not provide further details.</p>

    <p class="text-gray-300">mCrypton was designed by Lim and Korkishko in 2006 <em>[38]</em> with both lightweight software and lightweight hardware implementations for constrained devices in mind. It has a <span class="math">64</span>-bit state, consists of <span class="math">13</span> rounds and is specified for three different key lengths: <span class="math">64</span>-, <span class="math">96</span>- and <span class="math">128</span>-bit. An encryption-only hardware implementation requires <span class="math">2,420</span> GE with a <span class="math">64</span>-bit key, <span class="math">2,681</span> GE with a <span class="math">96</span>-bit key and <span class="math">2,949</span> GE with a <span class="math">128</span>-bit key.</p>

    <p class="text-gray-300">SEA (Scalable Encryption Algorithm) <em>[213]</em> was proposed by Standaert et al. in 2006 and was targeted for constrained (software) devices. As the name suggests, SEA is designed for a broad-range of application and special emphasis was put on scalability. Consequently, the data state</p>

    <p class="text-gray-300">size <span class="math">n</span>, the key length <span class="math">k</span> and the processor word size <span class="math">b</span> are parameters that can be adjusted to the target application. This flexibility comes at a price of higher area requirements and an implementation of SEA with a block and key size of <span class="math">n=96</span> bits, a word size of <span class="math">b=8</span> bits and <span class="math">n_{r}=93</span> rounds requires <span class="math">3,758</span> GE <em>[144]</em>.</p>

    <p class="text-gray-300">TEA (Tiny Encryption Algorithm) was proposed by Wheeler and Needham <em>[239]</em> and was designed with great emphasis on simplicity. It operates on a <span class="math">64</span>-bit data state, has a <span class="math">128</span>-bit key and consists of <span class="math">64</span> rounds. Kelsey et al. have mounted a related key attack on TEA <em>[119]</em>, which lead to the development of a tweaked version called XTEA <em>[240]</em>. Despite the simplicity of the basic round functions, a hardware implementation of TEA still requires <span class="math">2,355</span> GE <em>[243]</em>.</p>

    <p class="text-gray-300">ICEBERG was published by Standaert et al. in 2004 and was specifically designed for reconfigurable devices <em>[212]</em>. It has a <span class="math">64</span>-bit state, a <span class="math">128</span>-bit key and consists of <span class="math">16</span> rounds. All components of ICEBERG are involutional and hence are well suited for combination of encryption and decryption functionality. However, the smallest published hardware implementation requires <span class="math">7,732</span> GE <em>[144]</em>, which is far from being lightweight.</p>

    <p class="text-gray-300">The eSTREAM project <em>[175]</em> aimed at designing new lightweight stream ciphers and its hardware profile specifically targeted lightweight hardware implementations. Grain <em>[99]</em> and Trivium <em>[57]</em> are among the finalists and have the lowest hardware footprint. Grain can be implemented with only <span class="math">2,599</span> GE and Trivium with only <span class="math">1,294</span> GE <em>[89]</em>. However, a major drawback of stream ciphers is the lengthy initialization phase (e.g. <span class="math">321</span> clock cycles for GRAIN and <span class="math">1,333</span> for TRIVIUM) prior to first usage. The authors of Trivium state that Trivium “was designed as an exercise in exploring how far a stream cipher can be simplified without sacrificing its security, speed or flexibility” and they “strongly discourage the use of Trivium at this stage” (April 2005) <em>[57]</em>. Up to now (February 2009) no cryptanalytic attack has been published that is better than brute force but some attacks come close <em>[63, 150, 191]</em>.</p>

    <p class="text-gray-300">Keeloq <em>[171]</em> and Mifare <em>[173]</em> are two examples for cryptographic algorithms that have been kept secret by the designers in order to gain also security by obscurity, thus violating the Kerckhoff principle <em>[120]</em>. However, Keeloq and Mifare both were broken shortly after their algorithm was reverse-engineered <em>[32, 173]</em>. Though Tea and mCrypton come close to the <span class="math">2,000</span> GE barrier, HIGHT, SEA and TEA are already significantly larger than what is wanted.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">4.2 Design decisions</h3>

    <p class="text-gray-300">Besides security and efficient implementation, the main goal when designing present was simplicity. It is therefore not surprising that similar designs have been considered in other contexts <em>[102]</em> and can even be used as a tutorial for students <em>[101]</em>. In this section we justify the decisions we took during the design of present. First, however, we describe the anticipated application requirements.</p>

    <p class="text-gray-300">In designing a block cipher suitable for extremely constrained environments, it is important to recognize that we are not building a block cipher that is necessarily suitable for wide-spread use; we already have the AES <em>[161]</em> for this. Instead, we are targeting some very specific applications for which the AES is unsuitable. These will generally conform to the following characteristics.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The cipher is to be implemented in hardware.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Applications will only require moderate security levels. Consequently, 80-bit security will be adequate. Note that this is also the position taken for hardware profile stream ciphers submitted to eSTREAM <em>[175]</em>.</li>

      <li>Applications are unlikely to require the encryption of large amounts of data. Implementations might therefore be optimised for performance or for space without too much practical impact.</li>

      <li>In some applications it is possible that the key will be fixed at the time of device manufacture. In such cases there would be no need to re-key a device (which would incidentally rule out a range of key manipulation attacks).</li>

      <li>After security, the physical space required for an implementation will be the primary consideration. This is closely followed by peak and average power consumption, with the timing requirements being a third important metric.</li>

      <li>In applications that demand the most efficient use of space, the block cipher will often only be implemented as <em>encryption-only</em>. In this way it can be used within challenge-response authentication protocols and, with some careful state management, it could be used for both encryption and decryption of communications to and from the device by using the counter mode <em>[162]</em>.</li>

    </ul>

    <p class="text-gray-300">Taking such considerations into account we decided to make present a 64-bit block cipher with an 80-bit key. Optionally we also give specifications for a version with a <span class="math">128</span>-bit key. Encryption and decryption with present have roughly the same physical requirements. Opting to support both encryption and decryption will result in a lightweight block cipher implementation that is still smaller than an encryption-only AES. Opting to implement an encryption-only present will give an ultra-lightweight solution. The encryption subkeys can be computed <em>on-the-fly</em>.</p>

    <p class="text-gray-300">The literature contains a range of attacks that manipulate time-memory-data trade-offs <em>[28]</em> or the birthday paradox when encrypting large amounts of data. However such attacks depend solely on the parameters of the block cipher and exploit no inner structure. Our goal is that these attacks be the best available to an adversary. Side-channel and invasive hardware attacks are likely to be a threat to present, as they are to all cryptographic primitives. For the likely applications, however, the moderate security requirements reflect the very limited gain any attacker would make in practice. In a risk assessment, such attacks are unlikely to be a significant factor.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.3 Algorithmic description of the present encryption routine</h3>

    <p class="text-gray-300">present is an example of an SP-network <em>[153]</em> and consists of <span class="math">31</span> rounds. The block length is <span class="math">64</span> bits and two key lengths of <span class="math">80</span> and <span class="math">128</span> bits are supported. Given the applications we have in mind, we recommend the version with <span class="math">80</span>-bit keys. This is more than adequate security for the low-security applications typically required in tag-based deployments, but just as importantly, this matches the design goals of hardware-oriented stream ciphers in the eSTREAM project and allows us to make a fairer comparison.</p>

    <p class="text-gray-300">Each of the <span class="math">31</span> rounds consists of an xor operation to introduce a round key <span class="math">K_{i}</span> for <span class="math">1\\leq i\\leq 32</span>, where <span class="math">K_{32}</span> is used for post-whitening, a linear bitwise permutation and a non-linear substitution layer. The non-linear layer uses a single <span class="math">4</span>-bit S-box <span class="math">S</span> which is applied <span class="math">16</span> times in parallel</p>

    <p class="text-gray-300">Chapter 4. PRESENT - An Ultra-Lightweight Block Cipher</p>

    <pre><code class="language-txt">generateRoundKeys()
for  $i = 1$  to 31 do
addRoundKey(STATE,  $K_{i}$  sBoxLayer(STATE) pLayer(STATE) end for addRoundKey(STATE,  $K_{32}$</code></pre>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 4.1: A top-level algorithmic description of the encryption routine of PRESENT.</p>

    <p class="text-gray-300">in each round. The encryption routine of the cipher is described in pseudo-code in Figure 4.1, and each stage is now specified in turn. The design rationale are given in Section 4.2 and throughout this Thesis we number bits from zero with bit zero on the right of a block or word.</p>

    <p class="text-gray-300">Given round key  <span class="math">K_{i} = \\kappa_{03}^{i}\\ldots \\kappa_{0}^{i}</span>  for  <span class="math">1\\leq i\\leq 32</span>  and current STATE  <span class="math">b_{63}\\dots b_0</span> , addRoundKey consists of the operation for  <span class="math">0\\leq j\\leq 63</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">b _ {j} \\rightarrow b _ {j} \\oplus \\kappa_ {j} ^ {i}.</span></div>

    <p class="text-gray-300">We use a single 4-bit to 4-bit S-box  <span class="math">S: \\mathbb{F}_2^4 \\to \\mathbb{F}_2^4</span>  in PRESENT. This is a direct consequence of our pursuit of hardware efficiency, with the implementation of such an S-box typically being much more compact than that of an 8-bit S-box. Since we use a bit permutation for the linear diffusion layer, AES-like diffusion techniques [54] are not an option for PRESENT. Therefore we place some additional conditions on the S-boxes to improve the so-called avalanche of change. More precisely, the S-box for PRESENT fulfills the following conditions, where we denote the Fourier coefficient of  <span class="math">S</span>  by</p>

    <div class="my-4 text-center"><span class="math-block">S _ {b} ^ {W} (a) = \\sum_ {x \\in \\mathbb {F} _ {2} ^ {4}} (- 1) ^ {\\langle b, S (x) \\rangle + \\langle a, x \\rangle}.</span></div>

    <p class="text-gray-300">(1) For any fixed non-zero input difference  <span class="math">\\Delta_I \\in \\mathbb{F}_2^4</span>  and any fixed non-zero output difference  <span class="math">\\Delta_O \\in \\mathbb{F}_2^4</span>  we require</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\# \\{x \\in \\mathbb {F} _ {2} ^ {4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S (x) + S (x + \\Delta_ {I}) = \\Delta_ {O} \\} \\leq 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(2) For any fixed non-zero input difference  <span class="math">\\Delta_I \\in \\mathbb{F}_2^4</span>  and any fixed output difference  <span class="math">\\Delta_O \\in \\mathbb{F}_2^4</span>  such that  <span class="math">\\mathrm{wt}(\\Delta_I) = \\mathrm{wt}(\\Delta_O) = 1</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb {F} _ {2} ^ {4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S (x) + S (x + \\Delta_ {I}) = \\Delta_ {O} \\} = \\emptyset .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">4.3. Algorithmic description of the PRESENT encryption routine</p>

    <p class="text-gray-300">Table 4.1: The PRESENT S-box.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S[x]</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">E</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(3) For all non-zero  <span class="math">a \\in \\mathbb{F}_2^4</span>  and all non-zero  <span class="math">b \\in \\mathbb{F}_2^4</span>  it holds that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_b^W(a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 8$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As will become clear in Section 4.6, these conditions will ensure that PRESENT is resistant to differential and linear attacks. Using a classification of all 4-bit S-boxes that fulfill the above conditions [140] we chose an S-box that is particular well-suited to efficient hardware implementation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The S-box used in PRESENT is a 4-bit to 4-bit S-box  <span class="math">S: \\mathbb{F}_2^4 \\to \\mathbb{F}_2^4</span> . Let  $x = (x_3 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_0)<span class="math">  denote the 4-bit input to the S-box and let  </span>S(x) = (S_3(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0(x))$  denote its 4-bit output. By using the Boolean minimization tool espresso [170] we obtained the following four Boolean output functions for the PRESENT S-box:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">S _ {0} (x) = x _ {3} \\cdot x _ {2} \\cdot \\overline {{x _ {1}}} \\cdot x _ {0} + \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot \\overline {{x _ {1}}} \\cdot \\overline {{x _ {0}}} + \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot x _ {0} + x _ {3} \\cdot x _ {1} \\cdot \\overline {{x _ {0}}} + \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot x _ {1} \\cdot x _ {0} + \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot x _ {1} \\cdot x _ {0} + x _ {3} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {0}}}</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {1} (x) = \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot x _ {1} \\cdot \\overline {{x _ {0}}} + x _ {3} \\cdot x _ {2} \\cdot x _ {0} + \\overline {{x _ {2}}} \\cdot x _ {1} \\cdot \\overline {{x _ {0}}} + x _ {3} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot x _ {0} + \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot x _ {1} \\cdot x _ {0} + x _ {3} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {0}}}</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {2} (x) = \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot \\overline {{x _ {0}}} + \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot x _ {0} + x _ {3} \\cdot x _ {2} \\cdot \\overline {{x _ {1}}} + \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot x _ {1} \\cdot x _ {0} + \\overline {{x _ {2}}} \\cdot x _ {1} \\cdot \\overline {{x _ {0}}} + x _ {3} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot x _ {0}</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {3} (x) = \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot x _ {1} \\cdot \\overline {{x _ {0}}} + \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot \\overline {{x _ {0}}} + \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot \\overline {{x _ {1}}} \\cdot \\overline {{x _ {0}}} + x _ {3} \\cdot \\overline {{x _ {2}}} \\cdot x _ {1} + \\overline {{x _ {3}}} \\cdot x _ {2} \\cdot x _ {1} \\cdot x _ {0} + x _ {3} \\cdot \\overline {{x _ {2}}} \\cdot \\overline {{x _ {1}}} \\cdot x _ {0} + \\overline {{x _ {3}}} \\cdot \\overline {{x _ {2}}} \\cdot x _ {1} \\cdot x _ {0}</span></div>

    <p class="text-gray-300">where  <span class="math">\\overline{x}_i</span>  denotes the inversion of bit  <span class="math">x_{i}</span> , denotes a logical AND and  <span class="math">+</span>  denotes a logical OR. The action of this S-box in hexadecimal notation is given by Table 4.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For sBoxLayer the current STATE  <span class="math">b_{63} \\ldots b_0</span>  is considered as sixteen 4-bit words  <span class="math">w_{15} \\ldots w_0</span>  where  $w_i = b_{4*i+3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{4*i+2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{4*i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{4*i}<span class="math">  for  </span>0 \\leq i \\leq 15<span class="math">  and the output nibble  </span>S[w_i]$  provides the updated state values in the obvious way.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The XOR distribution table of the PRESENT S-box is given in Table 4.2. As one can see the maximum probability of any output differential  <span class="math">\\Delta_O</span>  is limited by  <span class="math">P_{\\Delta_O} = \\frac{4}{16} = 2^{-2}</span> .</p>

    <p class="text-gray-300">When choosing the mixing layer, our focus on hardware efficiency demands a linear layer that can be implemented with a minimum number of processing elements, i.e. transistors. This leads us directly to bit permutations. Given our focus on simplicity, we have chosen a regular bit-permutation and this helps to make a clear security analysis (see Section 4.6). The bit permutation used in PRESENT is given by Table 4.3. Bit  <span class="math">i</span>  of STATE is moved to bit position  <span class="math">P(i)</span> .</p>

    <p class="text-gray-300">It is also possible to write the P-layer in the following way:</p>

    <div class="my-4 text-center"><span class="math-block">P (i) = \\left\\{ \\begin{array}{l l} i \\cdot 1 6 \\mod 6 3, &amp;amp; i \\in \\{0, \\ldots , 6 2 \\} \\\\ 6 3, &amp;amp; i = 6 3. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Chapter 4. PRESENT - An Ultra-Lightweight Block Cipher</p>

    <p class="text-gray-300">Table 4.2: Differential distribution table of the PRESENT S-box.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ΔI ΔO</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4.3: The permutation layer of PRESENT.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4.4. Algorithmic description of the PRESENT decryption routine</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 4.2: A top-level algorithmic description of the decryption routine of PRESENT.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">Table 4.4: The inverse PRESENT S-box.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S[x]</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">E</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4.2 depicts a top-level algorithmic overview of the decryption routine of PRESENT. As one can see it consists of the inverse operations applied in the reverse order of the encryption routine of PRESENT. These inverse operations will be detailed in this Section.</p>

    <p class="text-gray-300">The addRoundKey operation is the same as in the encryption routine. However, for the sake of clarity we describe it again in this section. Given round key  <span class="math">K_{i} = \\kappa_{63}^{i}\\ldots \\kappa_{0}^{i}</span>  for  <span class="math">1\\leq i\\leq 32</span>  and current STATE  <span class="math">b_{63}\\dots b_0</span> , addRoundKey consists of the operation for  <span class="math">0\\leq j\\leq 63</span></p>

    <div class="my-4 text-center"><span class="math-block">b _ {j} \\rightarrow b _ {j} \\oplus \\kappa_ {j} ^ {i}.</span></div>

    <p class="text-gray-300">The S-box used in the decryption routine of PRESENT is the inverse of the 4-bit to 4-bit S-box  <span class="math">S:\\mathbb{F}_2^4\\to \\mathbb{F}_2^4</span>  that was described in Section 4.3.2. The action of the inverse S-box in hexadecimal notation is given by Table 4.4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For invSBoxLayer the current STATE  <span class="math">b_{63} \\ldots b_0</span>  is considered as sixteen 4-bit words  <span class="math">w_{15} \\ldots w_0</span>  where  $w_i = b_{4*i+3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{4*i+2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{4*i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{4*i}<span class="math">  for  </span>0 \\leq i \\leq 15<span class="math">  and the output nibble  </span>S[w_i]$  provides the updated state values in the obvious way.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Chapter 4. PRESENT - An Ultra-Lightweight Block Cipher</p>

    <p class="text-gray-300">Table 4.5: The inverse permutation layer of PRESENT.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P(i)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The bit permutation used in the decryption routine of PRESENT is given by Table 4.5. Bit  <span class="math">i</span>  of STATE is moved to bit position  <span class="math">P(i)</span> .</p>

    <p class="text-gray-300">PRESENT can take keys of either 80 or 128 bits. In Section 4.5.1 we describe the version with an 80-bit key and in the following Section 4.5.2 the 128-bit version is described.</p>

    <p class="text-gray-300">The user-supplied key is stored in a key register  <span class="math">K</span>  and represented as  <span class="math">k_{79}k_{78}\\ldots k_0</span> . At round  <span class="math">i</span>  the 64-bit round key  <span class="math">K_{i} = \\kappa_{63}\\kappa_{62}\\ldots \\kappa_{0}</span>  consists of the 64 leftmost bits of the current contents of register  <span class="math">K</span> . Thus at round  <span class="math">i</span>  we have that:</p>

    <div class="my-4 text-center"><span class="math-block">K _ {i} = \\kappa_ {6 3} \\kappa_ {6 2} \\dots \\kappa_ {0} = k _ {7 9} k _ {7 8} \\dots k _ {1 6}.</span></div>

    <p class="text-gray-300">After extracting the round key  <span class="math">K_{i}</span> , the key register  <span class="math">K = k_{79}k_{78}\\ldots k_{0}</span>  is updated as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left[\\mathrm{k}_{79}\\mathrm{k}_{78}\\dots \\mathrm{k}_1\\mathrm{k}_0\\right] = \\left[\\mathrm{k}_{18}\\mathrm{k}_{17}\\dots \\mathrm{k}_{20}\\mathrm{k}_{19}\\right]</span></li>

      <li><span class="math">\\left[\\mathrm{k}_{79}\\mathrm{k}_{78}\\mathrm{k}_{77}\\mathrm{k}_{76}\\right] = S\\left[\\mathrm{k}_{79}\\mathrm{k}_{78}\\mathrm{k}_{77}\\mathrm{k}_{76}\\right]</span></li>

      <li><span class="math">\\left[\\mathrm{k}_{19}\\mathrm{k}_{18}\\mathrm{k}_{17}\\mathrm{k}_{16}\\mathrm{k}_{15}\\right] = \\left[\\mathrm{k}_{19}\\mathrm{k}_{18}\\mathrm{k}_{17}\\mathrm{k}_{16}\\mathrm{k}_{15}\\right] \\oplus</span>  round counter</li>

    </ol>

    <p class="text-gray-300">Thus, the key register is rotated by 61 bit positions to the left, the left-most four bits are passed through the PRESENT S-box, and the round counter value  <span class="math">i</span>  is exclusive-ored with bits  <span class="math">\\mathrm{k}_{19}\\mathrm{k}_{18}\\mathrm{k}_{17}\\mathrm{k}_{16}\\mathrm{k}_{15}</span>  of  <span class="math">K</span>  with the least significant bit of round counter on the right. Figure 4.3 depicts the key schedule for PRESENT-80 graphically.</p>

    <p class="text-gray-300">In this Section the key schedule for 128-bit keys is presented. Similar to the 80-bit variant at the beginning the user-supplied key is stored in a key register  <span class="math">K</span>  and is represented as</p>

    <p class="text-gray-300">4.6. Cryptanalytic Aspects</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 4.3: The key schedule of PRESENT-80.</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 4.4: The key schedule of PRESENT-128.</p>

    <p class="text-gray-300"><span class="math">k_{127}k_{126}\\ldots k_0</span> . At round  <span class="math">i</span>  the 64-bit round key  <span class="math">K_{i} = \\kappa_{63}\\kappa_{62}\\ldots \\kappa_{0}</span>  consists of the 64 leftmost bits of the current contents of register  <span class="math">K</span> . Thus at round  <span class="math">i</span>  we have that:</p>

    <div class="my-4 text-center"><span class="math-block">K _ {i} = \\kappa_ {6 3} \\kappa_ {6 2} \\dots \\kappa_ {0} = k _ {1 2 7} k _ {1 2 6} \\dots k _ {6 4}.</span></div>

    <p class="text-gray-300">After extracting the round key  <span class="math">K_{i}</span> , the key register  <span class="math">K = k_{127}k_{126}\\ldots k_{0}</span>  is updated as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left[\\mathrm{k}_{127}\\mathrm{k}_{126}\\dots \\mathrm{k}_1\\mathrm{k}_0\\right] = \\left[\\mathrm{k}_{66}\\mathrm{k}_{65}\\dots \\mathrm{k}_{68}\\mathrm{k}_{67}\\right]</span></li>

      <li><span class="math">\\left[\\mathrm{k}_{127}\\mathrm{k}_{126}\\mathrm{k}_{125}\\mathrm{k}_{124}\\right] = S\\left[\\mathrm{k}_{127}\\mathrm{k}_{126}\\mathrm{k}_{125}\\mathrm{k}_{124}\\right]</span></li>

      <li><span class="math">\\left[\\mathrm{k}_{123}\\mathrm{k}_{122}\\mathrm{k}_{121}\\mathrm{k}_{120}\\right] = S\\left[\\mathrm{k}_{123}\\mathrm{k}_{122}\\mathrm{k}_{121}\\mathrm{k}_{120}\\right]</span></li>

      <li><span class="math">\\left[\\mathrm{k}_{66}\\mathrm{k}_{65}\\mathrm{k}_{64}\\mathrm{k}_{63}\\mathrm{k}_{62}\\right] = \\left[\\mathrm{k}_{66}\\mathrm{k}_{65}\\mathrm{k}_{64}\\mathrm{k}_{63}\\mathrm{k}_{62}\\right] \\oplus</span>  round counter</li>

    </ol>

    <p class="text-gray-300">Thus, the key register is rotated by 61 bit positions to the left, the left-most eight bits are passed through two PRESENT S-boxes, and the round counter value  <span class="math">i</span>  is exclusive-ored with bits  <span class="math">\\mathrm{k}_{66}\\mathrm{k}_{65}\\mathrm{k}_{64}\\mathrm{k}_{63}\\mathrm{k}_{62}</span>  of  <span class="math">K</span>  with the least significant bit of round counter on the right. Figure 4.4 depicts the key schedule for PRESENT-128 graphically.</p>

    <p class="text-gray-300">Chapter 4. PRESENT - An Ultra-Lightweight Block Cipher</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 4.5: The grouping of S-boxes in PRESENT for the purposes of cryptanalysis. The input numbers indicate the S-box origin from the preceding round and the output numbers indicate the destination S-box in the following round.</p>

    <p class="text-gray-300">In [33] we presented the results of a security analysis of PRESENT. In the following our findings are recalled. First differential and linear cryptanalysis are treated in Section 4.6.1. Subsequently structural attacks (Section 4.6.2), algebraic attacks (Section 4.6.3), key schedule attacks (Section 4.6.4), statistical saturation attacks (Section 4.6.5) and combined algebraic and differential attacks (Section 4.6.6) are treated.</p>

    <p class="text-gray-300">Differential [26] and linear [149] cryptanalysis are among the most powerful techniques available to the cryptanalyst. In order to gauge the resistance of PRESENT to differential and linear cryptanalysis we provide a lower bound to the number of so-called active S-boxes involved in a differential (or linear) characteristic.</p>

    <p class="text-gray-300">We divide the 16 S-boxes into four groups (see Figure 4.5) and by examining the permutation layer one can then establish the following.</p>

    <p class="text-gray-300">(1) The input bits to an S-box come from four distinct S-boxes of the same group. (2) The input bits to a group of four S-boxes come from 16 different S-boxes. (3) The four output bits from a particular S-box enter four distinct S-boxes, each of which belongs to a distinct group of S-boxes in the subsequent round. (4) The output bits of S-boxes in distinct groups go to distinct S-boxes.</p>

    <p class="text-gray-300">We use these observations in the following to proof Theorem 4.1.</p>

    <p class="text-gray-300">The case of differential cryptanalysis is captured by the following theorem.</p>

    <p class="text-gray-300">Theorem 4.1. Any five-round differential characteristic of PRESENT has a minimum of ten active S-boxes.</p>

    <p class="text-gray-300">Proof. Recalling that the rounds are indexed from 1 to 31, consider five consecutive rounds of PRESENT ranging from  <span class="math">i - 2</span>  to  <span class="math">i + 2</span>  for  <span class="math">i \\in [3 \\ldots 29]</span> . Let  <span class="math">D_{j}</span>  be the number of active S-boxes in</p>

    <p class="text-gray-300">round <span class="math">j</span>. If <span class="math">D_{j}\\geq 2</span>, for <span class="math">i-2\\leq j\\leq i+2</span>, then the theorem trivially holds. So let us suppose that one of the <span class="math">D_{j}</span> is equal to one. We can distinguish several cases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The S-box of present is such that a difference in a single input bit causes a difference in at least two output bits (cf. the second design criterion). Thus <span class="math">D_{i-1}+D_{i+1}\\geq 3</span>. Using observation 1 above, all active S-boxes of round <span class="math">i-1</span> belong to the same group, and each of these active S-boxes have only a single bit difference in their output. So according to observation 2 we have that <span class="math">D_{i-2}\\geq 2D_{i-1}</span>. Conversely, according to observation 3, all active S-boxes in round <span class="math">i+1</span> belong to distinct groups and have only a single bit difference in their input. So according to observation 4 we have that <span class="math">D_{i+2}\\geq 2D_{i+1}</span>. Together this gives <span class="math">\\sum_{j=i-2}^{i+2}D_{j}\\geq 1+3+2\\times 3=10</span>.</li>

      <li>If <span class="math">D_{i}=1</span> we can refer to the first case, so let us suppose that <span class="math">D_{i}\\geq 2</span>. According to observation 3 above, all active S-boxes of round <span class="math">i</span> belong to distinct groups and have only a single bit difference in their input. Thus, according to observation 4, <span class="math">D_{i+1}\\geq 2D_{i}\\geq 4</span>. Further, all active S-boxes in round <span class="math">i+1</span> have only a single bit difference in their input and they are distributed so that at least two groups of S-boxes contain at least one active S-box. This means that <span class="math">D_{i+2}\\geq 4</span> and we can conclude that <span class="math">\\sum_{j=i-2}^{i+2}D_{j}\\geq 1+1+2+4+4=12</span>.</li>

      <li>If <span class="math">D_{i}=1</span> we can refer to the first case. So let us suppose that <span class="math">D_{i}\\geq 2</span>. According to observation 1 above, all active S-boxes of round <span class="math">i</span> belong to the same group and each of these active S-boxes has only a single bit difference in their output. Thus, according to observation 2, <span class="math">D_{i-1}\\geq 2D_{i}\\geq 4</span>. Further, all active S-boxes of round <span class="math">i-1</span> have only a single bit difference in their output, and they are distributed so that at least two groups contain at least two active S-boxes. Thus, we have that <span class="math">D_{i-2}\\geq 4</span> and therefore that <span class="math">\\sum_{j=i-2}^{i+2}D_{j}\\geq 4+4+2+1+1=12</span>.</li>

      <li>The reasoning for these cases is similar to those for the second and third cases.</li>

    </ol>

    <p class="text-gray-300">The theorem follows. ∎</p>

    <p class="text-gray-300">By using Theorem 4.1 any differential characteristic over 25 rounds of present must have at least <span class="math">5\\times 10=50</span> active S-boxes. The maximum differential probability of a present S-box is <span class="math">2^{-2}</span> and so the probability of a single 25-round differential characteristic is bounded by <span class="math">2^{-100}</span>. Advanced techniques allow the cryptanalyst to remove the outer rounds from a cipher to exploit a shorter characteristic. However, even if we allow an attacker to remove six rounds from the cipher, a situation without precedent, then the data required to exploit the remaining 25-round differential characteristic exceeds the amount available. Thus, the security bounds are more than we require. However, we have practically confirmed that the bound on the number of active S-boxes in Theorem 4.1 is tight.</p>

    <h5 id="sec-62" class="text-base font-semibold mt-4">Practical confirmation.</h5>

    <p class="text-gray-300">We can identify characteristics that involve ten S-boxes over five rounds. The following two-round iterative characteristic involves two S-boxes per round and holds with probability <span class="math">2^{-25}</span> over five rounds.</p>

    <p class="text-gray-300"><span class="math">\\Delta</span> <span class="math">=</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 1</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 3\\ 0\\ 0\\ 0\\ 3</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 1=\\Delta.</span></p>

    <p class="text-gray-300">A more complicated characteristic holds with probability <span class="math">2^{-21}</span> over five rounds.</p>

    <p class="text-gray-300"><span class="math">\\Delta</span> <span class="math">=</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 7\\ 0\\ 7\\ 0</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ A</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 1\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 0\\ 0\\ 0\\ 1\\ 0\\ 0\\ 0</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 8\\ 8\\ 0\\ 0\\ 8\\ 8</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 3\\ 3\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 3\\ 3\\ 0\\ 0\\ 3\\ 3.</span></p>

    <p class="text-gray-300">While the probability of this second characteristic is very close to the bound of <span class="math">2^{-20}</span>, it is non-iterative and of little practical value. Instead we have experimentally confirmed the probability of the two-round iterative differential. In experiments over 100 independent sub-keys using <span class="math">2^{23}</span> chosen plaintext pairs, the observed probability was as predicted. This seems to suggest that for this particular characteristic there is no accompanying significant differential. However, determining the extent of any differential effect is a complex and time-consuming task even though our preliminary analysis has been encouraging.</p>

    <h5 id="sec-63" class="text-base font-semibold mt-4">Linear cryptanalysis.</h5>

    <p class="text-gray-300">The case of the linear cryptanalysis of present is handled by the following theorem where we analyse the best linear approximation to four rounds of present.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 4.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\epsilon_{\\mathrm{4R}}</span> be the maximal bias of a linear approximation of four rounds of present. Then <span class="math">\\epsilon_{\\mathrm{4R}}\\leq\\frac{1}{2^{7}}</span>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that Matsui’s piling-up lemma <em>[149]</em> estimates the bias of a linear approximation involving <span class="math">n</span> S-boxes to be</p>

    <p class="text-gray-300"><span class="math">2^{n-1}\\prod_{i=1}^{n}\\epsilon_{i},</span></p>

    <p class="text-gray-300">where the values <span class="math">\\epsilon_{i}</span> are the individual bias of each (independent) S-box. According to the design principles of present, the bias of all linear approximations is less than <span class="math">2^{-2}</span> while the bias of any single-bit approximation is less than <span class="math">2^{-3}</span>. Let <span class="math">\\epsilon_{\\mathrm{4R}}^{(j)}</span> denote the bias of a linear approximation over 4 rounds involving <span class="math">j</span> active S-boxes. Now consider the following three cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that each round of a four-round linear approximation has exactly one active S-box. Then the bias of each of the two S-boxes in the middle rounds is at most <span class="math">1/8</span> and the overall bias for a four round approximation can be bounded as follows:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\mathrm{4R}}^{(4)}\\leq 2^{3}\\times(2^{-3})^{2}\\times(2^{-2})^{2}=2^{-7}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose, instead, that there are exactly five active S-boxes over four rounds. Then by the grouping of S-boxes in Figure 4.5, the active S-boxes over three consecutive rounds cannot form the pattern 1-2-1. For this to happen, the two active S-boxes in the middle round are activated by the same S-box and must therefore belong to two different groups of S-boxes. But if this is the case they couldn’t activate only one S-box in the following round. Consequently the number of active S-boxes is either 2-1-1-1 or 1-1-1-2, so that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\epsilon^{(5)}_{4\\mathrm{R}}\\leq 2^{4}\\times(2^{-3})\\times(2^{-2})^{4}=2^{-7}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, suppose that there are more than five active S-boxes. Thus</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\epsilon^{(j)}_{4\\mathrm{R}}\\leq 2^{j-1}\\times(2^{-2})^{j}=2^{-j-1}\\leq 2^{-7}\\text{ for }j&gt;5.</span></p>

    <p class="text-gray-300">The equality is theoretically attainable for <span class="math">j=6</span>. This is a strict inequality for all other <span class="math">j</span>’s.</p>

    <p class="text-gray-300">The theorem follows. ∎</p>

    <p class="text-gray-300">We can use Theorem 4.2 directly to bound the maximal bias of a 28-round linear approximation by</p>

    <p class="text-gray-300"><span class="math">2^{6}\\times\\epsilon^{7}_{4\\mathrm{R}}=2^{6}\\times(2^{-7})^{7}=2^{-43}.</span></p>

    <p class="text-gray-300">Therefore under the assumption that a cryptanalyst need only approximate 28 of the 31 rounds in present to mount a key recovery attack, linear cryptanalysis of the cipher would require of the order of <span class="math">2^{84}</span> known plaintext/ciphertexts. Such data requirements exceed the available text.</p>

    <h5 id="sec-66" class="text-base font-semibold mt-4">Some advanced differential/linear attacks.</h5>

    <p class="text-gray-300">The structure of present allows us to consider some dedicated forms of attacks. However, none have yielded an attack that requires less text than the lower bound on text requirements for linear cryptanalysis. Among the dedicated attacks we considered was one using palindromic differences, since symmetrical differences are preserved with probability one over the diffusion layer, and some advanced variants of differential-linear attacks <em>[138]</em>. While the attacks seemed promising over a few rounds, they very quickly lost their practical value and are unlikely to be useful in the cryptanalysis of present. We also established that <em>truncated differential cryptanalysis</em> <em>[126, 127]</em> was likely to have limited value, though the following two-round truncated extension holds with probability one.</p>

    <p class="text-gray-300"><span class="math">\\Delta</span> <span class="math">=</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 1</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 3\\ 0\\ 0\\ 0\\ 3\\ [\\ \\text{iterate the two-round characteristic}\\ ]</span> <span class="math">\\rightarrow</span> <span class="math">\\vdots</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ 1\\ 1</span> <span class="math">\\rightarrow</span> <span class="math">0\\ 0\\ 0\\ ?\\ 0\\ 0\\ 0\\ ?\\ 0\\ 0\\ 0\\ ?\\ 0\\ 0\\ 0\\ 3</span> <span class="math">\\rightarrow</span> <span class="math">\\delta_{0}\\ \\delta_{1}\\ \\delta_{2}\\ \\delta_{3}\\ \\delta_{4}\\ \\delta_{5}\\ \\delta_{6}\\ \\delta_{7}\\ \\delta_{8}\\ \\delta_{9}\\ \\delta_{10}\\ \\delta_{11}\\ \\delta_{12}\\ \\delta_{13}\\ \\delta_{14}\\ \\delta_{15}\\ \\ \\ \\ \\text{where all }\\delta_{i}\\in\\{0,1\\}.</span></p>

    <p class="text-gray-300">Even when used to reduce the length of the differential characteristics already identified, the data requirements still remain excessive.</p>

    <p class="text-gray-300">Differential attack on reduced-round versions of present</p>

    <p class="text-gray-300">Shortly after the publication of present Wang published her findings about the differential properties of present in <em>[235]</em>. Wang showed that a 16-round version of present is susceptible to differential cryptanalysis. In particular <span class="math">2^{64}</span> chosen plaintexts are required and the time complexity is about <span class="math">2^{65}</span> memory accesses to obtain the right key with a probability of <span class="math">0.999999939</span>. Furthermore <span class="math">2^{32}</span> 6-bit counters and <span class="math">2^{24}</span> hash cells are the memory requirements. One drawback of the attack is that it requires a complete codebook, i.e. all available <span class="math">2^{64}</span> plaintexts and their corresponding ciphertexts are required. If all plaintexts and their corresponding ciphertexts are known to the attacker, the key is not required anymore, because he can simply look up the plaintext to a given ciphertext. Furthermore, the attack can only cryptananlyze 16 out of 31 rounds, hence there is still a large security margin. However, these findings provide an interesting starting point for further studies of the differential properties of present.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">4.6.2 Structural attacks</h4>

    <p class="text-gray-300">Structural attacks such as integral attacks <em>[125]</em> and bottleneck attacks <em>[80]</em> are well-suited to the analysis of AES-like ciphers, such as the AES itself <em>[54]</em>, SQUARE <em>[53]</em> or SHARK <em>[194]</em>. Such ciphers have strong word-like structures, where the words are typically bytes. However, the design of present is almost exclusively bitwise, and while the permutation operation is somewhat regular, the development and propagation of word-wise structures are disrupted by the bitwise operations used in the cipher.</p>

    <p class="text-gray-300">In <em>[244]</em> a bit-pattern based integral attack is proposed and the authors analyze reduced round variants of present with <span class="math">5,6</span> and <span class="math">7</span> rounds. The authors highlight that a <span class="math">5</span> round attack only requires <span class="math">80</span> chosen plaintexts, but the <span class="math">7</span> round attack already requires <span class="math">2^{24.3}</span> chosen plaintexts and has a time complexity of <span class="math">2^{100.1}</span> and a data complexity of <span class="math">2^{77}</span> bytes. Furthermore the authors state that integral attacks “can not be extended beyond a certain point” due to increasing time complexity with increasing number of rounds. Hence, integral attacks do not seem to be a threat for present.</p>

    <h4 id="sec-68" class="text-lg font-semibold mt-6">4.6.3 Algebraic attacks</h4>

    <p class="text-gray-300">Algebraic attacks have had better success when applied to stream ciphers than block ciphers. Nevertheless, the simple structure of present means that they merit serious study. The present S-box is described by <span class="math">21</span> quadratic equations in the eight input/output-bit variables over <span class="math">GF(2)</span>. This is not surprising since it is well-known that any four bit S-box can be described by at least <span class="math">21</span> such equations. The entire cipher can then be described by <span class="math">e=n\\times 21</span> quadratic equations in <span class="math">v=n\\times 8</span> variables, where <span class="math">n</span> is the number of S-boxes in the encryption algorithm and the key schedule. For present we have <span class="math">n=(31\\times 16)+31</span> thus the entire system consists of <span class="math">11,067</span> quadratic equations in <span class="math">4,216</span> variables.</p>

    <p class="text-gray-300">The general problem of solving a system of multivariate quadratic equations is NP-hard. However the systems derived for block ciphers are very sparse since they are composed of <span class="math">n</span> small systems connected by simple linear layers. Nevertheless, it is unclear whether this fact can be exploited in a so-called algebraic attack. Some specialised techniques such as XL <em>[50]</em> and XSL <em>[51]</em> have been proposed, though flaws in both techniques have been discovered <em>[44, 60]</em>.</p>

    <p class="text-gray-300">Instead the only practical results on the algebraic cryptanalysis of block ciphers have been obtained by applying the Buchberger <em>[29]</em> and F4 <em>[69]</em> algorithms within Magma <em>[146]</em>. Simulations on small-scale versions of the AES showed that for all but the very smallest SP-networks one quickly encounters difficulties in both time and memory complexity <em>[45]</em>. The same applies to present as we will show in the next section.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Practical confirmation.</h6>

    <p class="text-gray-300">We ran simulations on small-scale versions using the <span class="math">F_{4}</span> algorithm in Magma. When there is a single S-box, a very small block size of four bits, then Magma can solve the resulting system of equations over many rounds. However, by increasing the block size and adding S-boxes, along with an appropriate version of the linear diffusion layer, the system of equations soon becomes too large. Even when considering a system consisting of seven S-boxes, a block size of 28 bits, we were unable to get a solution in a reasonable time to a two-round version of the reduced cipher. Our analysis suggests that algebraic attacks are unlikely to pose a threat to present.</p>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">4.6.4 Key schedule attacks</h4>

    <p class="text-gray-300">Since there are no established guidelines to the design of key schedules, there is both a wide variety of designs and a wide variety of schedule-specific attacks. The most effective attacks come under the general heading of related-key attacks <em>[20]</em> and slide attacks <em>[29]</em>, and both rely on the build-up of identifiable relationships between different sets of subkeys. To counter this threat, we use a round-dependent counter so that subkey sets cannot easily be “slid”, and we use a non-linear operation to mix the contents of the key register <span class="math">K</span>. In particular,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>all bits in the key register are a non-linear function of the 80-bit user-supplied key by round 21,</li>

      <li>that each bit in the key register after round 21 depends on at least four of the user-supplied key bits, and</li>

      <li>by the time we arrive at deriving <span class="math">K_{32}</span>, six bits are degree two expressions of the 80 user-supplied key bits, 24 bits are of degree three, while the remaining bits are degree six or degree nine function of the user-supplied key bits.</li>

    </ul>

    <p class="text-gray-300">We believe these properties to be sufficient to resist key schedule-based attacks.</p>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">4.6.5 Statistical saturation attacks</h4>

    <p class="text-gray-300">Recently, a new class of statistical saturation attacks has been proposed by Collard and Standaerd <em>[47]</em> and present has been chosen to demonstrate the attack. It exploits properties of the permutation layer, in particular the fact that only <span class="math">8</span> out of <span class="math">16</span> bits of the output of S-boxes 5, 6, 9 and 10 are directed to other S-boxes. However, the authors can only break <span class="math">14</span> rounds out of the 31 rounds of present and it requires <span class="math">2^{34}</span> plaintext-ciphertext pairs. Since this attack has been applied to a reduced version of present with less than half of its rounds, the remaining security margin is still large. Nevertheless, this is an interesting new type of attack and it will be interesting to see it applied to other block ciphers too.</p>

    <p class="text-gray-300">Chapter 4. PRESENT - An Ultra-Lightweight Block Cipher</p>

    <p class="text-gray-300">Table 4.6: The reduced permutation layer  <span class="math">P_{16}(x)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i P16(i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In [2] three attacks are proposed that combine algebraic and differential techniques. The authors performed experimental results for two of three proposed attacks on reduced round variants of PRESENT-80 with 16 (PRESENT-80-16) rounds and on PRESENT-128 with 17 (PRESENT-128-17), 18 (PRESENT-128-18) and 19 (PRESENT-128-19) rounds. However, they also state that such an attack on PRESENT-128-19 would require  <span class="math">2^{113}</span>  CPU cycles and hence is impractical.</p>

    <p class="text-gray-300">Gregor Leander made an observation that promises great optimization potential for software implementations [139]. Figure 4.6(a) depicts two rounds of PRESENT and it can be seen that the 16 bit output of one set of four adjacent S-boxes is exactly mapped to the 16 bit input of four S-boxes in the next round. Leander proposed to re-arrange the S-boxes as it is depicted in Figure 4.6(b). As it becomes clear now, the modified permutation layer  <span class="math">P&#x27;(x)</span>  can be seen as a concatenation of four instances of a permutation layer  <span class="math">P_{16}(x)</span>  that each permutes a 16 bit chunk of the state, i.e.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P ^ {\\prime} (x _ {3}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {0}) = P _ {1 6} (x _ {3})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P _ {1 6} (x _ {2})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P _ {1 6} (x _ {1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P _ {1 6} (x _ {0})</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $x_{i} = b_{16\\cdot i + 15}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{16\\cdot i + 14}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{16\\cdot i}<span class="math">  for  </span>0\\leq i\\leq 3<span class="math"> . The updated state is not in the same order as the original permutation layer  </span>P(x)<span class="math">  would have transformed it, so the roundkey has to be re-ordered nibble-wise. If we apply  </span>P^{\\prime}(x)<span class="math">  again to the state we need another 64 bit permutation  </span>P''(x)<span class="math">  in order to guarantee that  </span>P(P(x)) = P''(P'(P'(x)))<span class="math"> . Interestingly it holds that  </span>P'' = P^{-1}$ , hence</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">P (P (x)) = P ^ {- 1} \\left(P ^ {\\prime} \\left(P ^ {\\prime} (x)\\right)\\right).</span></div>

    <p class="text-gray-300">It is also possible to write the reduced P-layer in the following way:</p>

    <div class="my-4 text-center"><span class="math-block">P _ {1 6} (i) = \\left\\{ \\begin{array}{l l} i \\cdot 4 \\mod 1 5, &amp;amp; i \\in \\{0, \\ldots , 1 4 \\} \\\\ 1 5, &amp;amp; i = 1 5. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Please note that  <span class="math">P_{16}(x)</span>  is an involution, i.e.  <span class="math">P_{16}(x) = P_{16}^{-1}(x)</span> . As we will see in Section 5.4.5 exploitation of this observation will lead to an optimized software implementation of the decryption routine.</p>

    <p class="text-gray-300">4.7. Further observations</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> (a) with regular bit-ordering.</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> (b) with re-arranged S-boxes and a split permutation layer. Figure 4.6: Two rounds of PRESENT</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">5 Implementation Results of present</p>

    <p class="text-gray-300">In Chapter 4 the block cipher present was introduced. For different application scenarios there exist different demands on the implementation and the optimization goals. In this chapter we consider a wide variety of different target platforms ranging from highly-optimized ASICs, over more flexible but still efficient low-cost FPGAs to hardware-software co-design approaches and flexible software implementations for <span class="math">4</span>-, <span class="math">8</span>-, <span class="math">16</span>- and <span class="math">32</span>-bit processors. We start with three ASIC implementations of present in Section 5.1, each of them is highly optimized for a specific scenario. FPGA implementations provide more flexible solutions than ASICs while exploiting the hardware efficiency of present. We present implementation figures of present for low-cost FPGAs in Section 5.2. Then we discuss implementation results that use hardware-software co-design approaches in Section 5.3. Software implementations for a wide range of different target platforms are presented in Section 5.4. Finally, this chapter is concluded in Section 5.5.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">5.1 ASIC Implementations</h3>

    <p class="text-gray-300">In this Section we first describe a serialized architecture that is minimized in terms of area and power consumption in Section 5.1.1. Subsequently, we present a round-based architecture that is optimized in terms of area, speed, and energy in Section 5.1.2. For the sake of completeness, also a parallelized architecture that uses pipelining technique and generates a high throughput is presented in Section 5.1.3. In order to decrease the area requirements even further, all architectures can perform encryption only. This is sufficient for encryption and decryption of data when the block cipher is operated for example in counter mode.</p>

    <p class="text-gray-300">Finally, we evaluate our implementation results with respect to the three scenarios low cost passive smart devices, low cost active smart devices, and high end smart devices in Section 5.1.4. We considered the following optimization goals for the three scenarios: low cost and passive smart devices should be optimized for area and power constraints and low cost and active smart devices for area, energy, and time constraints. Note that in our methodology high end devices are always contact smart cards and hence should be optimized for time and energy constraints. Therefore we do not distinguish between passive and active high end smart devices.</p>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">5.1.1 Serialized ASIC implementation</h4>

    <p class="text-gray-300">As was already pointed out in Section 4.3.3 the permutation layer of present can be written as:</p>

    <p class="text-gray-300">\\[ P(i)=\\left\\{\\begin{array}[]{ll}i\\cdot 16\\mod 63,&i\\in\\{0,\\ldots,62\\}\\\\ 63,&i=63.\\end{array}\\right. \\]</p>

    <p class="text-gray-300">An interesting property of <span class="math">P</span> is the fact that three consecutive application of <span class="math">P(i)</span> lead to the original bit position <span class="math">i</span>, i.e. <span class="math">P(P(P(i)))=i</span>. For bits <span class="math">0</span> and <span class="math">63</span> this is an obvious observation</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a> (a) before application of the pLayer.</p>

    <p class="text-gray-300">!<a href="img-16.jpeg">img-16.jpeg</a> (b) after application of the pLayer.</p>

    <p class="text-gray-300">!<a href="img-17.jpeg">img-17.jpeg</a> Figure 5.1: Bit positions of the PRESENT state arranged in a  <span class="math">4 \\times 4 \\times 4</span>  bit cube. (a) before the rotation. Figure 5.2: Exemplary  <span class="math">4 \\times 4 \\times 4</span>  bit state cube.</p>

    <p class="text-gray-300">!<a href="img-18.jpeg">img-18.jpeg</a> (b) during the rotation.</p>

    <p class="text-gray-300">!<a href="img-19.jpeg">img-19.jpeg</a> (c) after the rotation.</p>

    <p class="text-gray-300">and for the remaining bits this follows from the fact that  <span class="math">P(P(P(i))) = (((i \\cdot 16) \\cdot 16) \\cdot 16) \\mod 63 = i \\cdot 4096 \\mod 63 = i \\cdot 1 \\mod 63</span> .</p>

    <p class="text-gray-300">Consider that we arrange the state of PRESENT in a cube with 4 bits in each dimension, i.e. a  <span class="math">4 \\times 4 \\times 4</span> -bits cube, and that we number the bits according to Figure 5.1(a). After applying the pLayer permutation to the state cube the bit positions change (see Figure 5.1(b)). If one looks carefully it can be seen that the pLayer acts as a rotation of the cube around an axis that runs from the upper right corner at the front to the bottom left corner in the back. This virtual axis would touch bits 0, 21, 42 and 63 (before rotation). An exemplary state cube is depicted in Figure 5.2 before (Figure 5.2(a)), during (Figure 5.2(b)) and after (Figure 5.2(c)) a rotation.</p>

    <p class="text-gray-300">However, it is not an easy task to implement such an architecture efficiently in hardware. The problem of rotating a  <span class="math">4 \\times 4 \\times 4</span> -bits cube has been treated by Pfister/Kaufman [180] in the context of real-time volume rendering. Unfortunately, the selection of single bits in hardware requires a MUX (2.33 GE per bit) and is hence rather expensive in terms of area. Therefore we dropped this idea and used the following architecture instead.</p>

    <p class="text-gray-300">5.1. ASIC Implementations</p>

    <p class="text-gray-300">A serialized architecture of PRESENT-80 is depicted in Figure 5.3. As one can see it has a 4-bit width datapath, i.e. only 4 bits are processed in one clock cycle. Consequently it takes 16 clock cycles to XOR all 16 chunks of the state with the according chunk of the round key and subsequently process the result by the S-box. Another clock cycle is required to perform the pLayer on the whole state. This is due to the fact that the pLayer was designed to provide a good avalanche effect, which in turn prohibits efficient serialization. Since the S-box is not occupied by the datapath in this clock cycle, the key schedule can share the same hardware resources and hence uses the same S-box. This saves 28 GE for a separate S-box at the cost of a new MUX (10 GE). Also the remaining operations of the key schedule are performed in this clock cycle, while in the previous 16 clock cycles only the key state was shifted. Since the key state consists of 20 4-bit chunks, but was only shifted 16 times, the 61 bit left rotation has to be adapted. Contrary to the round-based implementation, now an FSM is required to control the control signals. Furthermore, additionally to the 5-bit round counter another 4-bit counter is required to keep track of the chunks within one round.</p>

    <p class="text-gray-300">The serialized architecture requires 17 clock cycles to process one round and since it has a 4-bit width I/O interface 20 clock cycles are required to initialize the circuit. Since the final round does not include the pLayer it requires only 16 clock cycles during which the result is also output and new data and key can be read in. The done signal indicates if the output is valid. In total a complete PRESENT-80 encryption of a 64-bit message requires  <span class="math">31 \\cdot 17 + 16 + 4 = 547</span>  clock cycles. An encryption with a serialized PRESENT-128 implementation requires  <span class="math">31 \\cdot 17 + 16 + 16 = 559</span>  clock cycles.</p>

    <p class="text-gray-300">!<a href="img-20.jpeg">img-20.jpeg</a> Figure 5.3: Datapath of the serialized PRESENT architecture.</p>

    <p class="text-gray-300">This architecture represents the direct implementation of the PRESENT top-level algorithm description in Figure 4.1, i.e. one round of PRESENT is performed in one clock cycle. The focus lies on a compact solution, but at the same time with an eye on the time-area product. To save</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">power and area a loop based approach is chosen. The balance between the 64-bit datapath and the used operations per clock cycle leads to a good time-area product. Due to the reuse of several building blocks and the round structure, the design has a high energy efficiency as well. The architecture uses only one substitution and permutation layer. So the datapath consists of one 64-bit XOR, 16 S-boxes in parallel, and one P-Layer. To store the internal state and the key, a 64-bit state register and an 80-bit key register are required. The key scheduling consists of a key register, a 5-bit XOR, one S-box and a 61-bit left rotation, which is only wiring. Figure 5.4 depicts the architecture of the round based approach for PRESENT. At first the key and the plaintext are stored into the respective register. After each round the internal state is stored into the state register and the updated key state in the key register. After 31 rounds the state is finally processed via XOR with the last round key, hence a 5-bit counter is required. This architecture does not require an FSM.</p>

    <p class="text-gray-300">!<a href="img-21.jpeg">img-21.jpeg</a> Figure 5.4: Datapath of the round-based PRESENT-80 architecture.</p>

    <p class="text-gray-300">For the sake of completeness we also briefly describe a parallelized pipelined architecture of PRESENT-80 as described in [199], though it is not lightweight. As introduced in Section 2.1 for a parallel design the algorithm is "unrolled", i.e. each of the 31 rounds has its own datapath in order to achieve a higher throughput. The required round key is generated by taking the right bits from the 80-bit key and if necessary pass them through an S-box or add a roundcounter value. All subkeys are available in parallel and no register is needed to store the key. Figure 5.5 shows the datapath of the pipelined architecture. It consists of 32 XORs, 496 S-boxes, and 31 P-Layer for the datapath. The key scheduling consists of 31 S-boxes and the round counter XOR is hard wired, i.e. the XOR addition is realized by inverters. First the given 64-bit plaintext and the first round key are XORed. The result is split up into 16 4-bit blocks. Each block is processed by a 4-bit S-box in parallel. The 64-bit P-Layer transposes the bits at the end of each of the 31 rounds. Note that the 32th round consists only of the XOR operation.</p>

    <p class="text-gray-300">This straight forward approach does not achieve a high maximum operating frequency, because the input signal has to propagate through all XOR and S-box gates and hence the critical path is obviously too long. The more gates belong to the path the higher is the resulting capacitance to be switched. So the time period for a switching event is stretched. To shorten the</p>

    <p class="text-gray-300">5.1. ASIC Implementations</p>

    <p class="text-gray-300">!<a href="img-22.jpeg">img-22.jpeg</a> Figure 5.5: Datapath of the pipelined parallelized PRESENT-80 architecture, source [199].</p>

    <p class="text-gray-300">critical path, flip-flops as pipeline stages were installed after each round, i.e. after each P-Layer (see Figure 5.5). On the one hand this increases the chip area and power consumption further, but on the other hand the maximum frequency can be raised significantly (recall that for this architecture the main design goal is high throughput and not low area requirements).</p>

    <p class="text-gray-300">The pipelined parallelized implementation of PRESENT-80 requires 27,028 GE and once the pipeline is completely filled (after 31 clock cycles) it can encrypt a message block of 64 bits within one clock cycle. This translates to a delay of 31 cycles and a throughput of 6.4 Mbps at a frequency of  <span class="math">100\\mathrm{kHz}</span> . More details about this architecture can be found in [199].</p>

    <p class="text-gray-300">Table 5.1 summarizes the implementation results and compares them to other block and stream cipher implementations after synthesis. <span class="math">^{2}</span>  The upper part shows implementation results of serialized architectures with round-based architectures in its middle part. For the sake of completeness, also figures of a parallelized PRESENT-80 implementation have been included in the lower part. As one can see a serialized implementation of PRESENT-80 requires 1,075 GE. To the best of our knowledge this is the smallest implementation of a cryptographic algorithm with a moderate security level, i.e. 80 bit. The figures for a serialized PRESENT-128 implementation are extrapolated by adding the area for storing 48 additional key bits (288 GE) and a second S-box (28 GE). Due to the serialization it takes 547 clock cycles to encrypt one message block, which leads to a rather small throughput and, consequently, a small hardware efficiency. The implementation figures of DES, DESL, DESX and DESXL have been copied from Section 3.4. Compared to the implementation figures of PRESENT all DES variants are inferior. For comparison reason also figures for two implementations of the AES [73, 96] and the stream ciphers TRIVIUM and GRAIN [89] are included. The AES implementation of Feldhofer et al. [73] is considered to be the benchmark of all lightweight implementations though the implementation of Hämäläinen et al. is around  <span class="math">10\\%</span>  smaller and more than 6 times faster than the first one. However, compared to our serialized PRESENT-80 and PRESENT-128 implementation, it is still  <span class="math">2 - 3</span>  times larger.</p>

    <p class="text-gray-300">It is noteworthy that also the implementation results of both eSTREAM hardware profile finalists TRIVIUM and GRAIN require more area than both serialized PRESENT implementations.</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">Table 5.1: Hardware implementation results of PRESENT-80 and PRESENT-128 with an encryption only datapath for the UMCL18G212T3 standard-cell library. All figures are obtained at or calculated for a frequency of  <span class="math">100\\mathrm{kHz}</span> . Please be aware that power figures can not be compared adequately between different technologies.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">key size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">block size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">datapath width</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cycles / block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put [Kbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tech. [μm]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area [GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eff. [bps/GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cur. [μA]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Serialized Architecture  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRESENT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">547</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11.7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,075</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10.89</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.4</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DES</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">44.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">2,309</td>

            <td class="px-3 py-2 border-b border-gray-700">19.25</td>

            <td class="px-3 py-2 border-b border-gray-700">1.19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESL</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">44.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">1,848</td>

            <td class="px-3 py-2 border-b border-gray-700">24.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.89</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESX</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">44.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">2,629</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DESXL</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">44.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">2,168</td>

            <td class="px-3 py-2 border-b border-gray-700">20.5</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [73]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1,032</td>

            <td class="px-3 py-2 border-b border-gray-700">12.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

            <td class="px-3 py-2 border-b border-gray-700">3400</td>

            <td class="px-3 py-2 border-b border-gray-700">3.65</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [96]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">3,100</td>

            <td class="px-3 py-2 border-b border-gray-700">25.81</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium [89]</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">SC</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">2,599</td>

            <td class="px-3 py-2 border-b border-gray-700">38.48</td>

            <td class="px-3 py-2 border-b border-gray-700">4.67</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Grain [89]</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">SC</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">1,294</td>

            <td class="px-3 py-2 border-b border-gray-700">77.28</td>

            <td class="px-3 py-2 border-b border-gray-700">2.75</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Round-based Architecture  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRESENT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">200</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,570</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">127.4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.78</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SEA [144]</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">103.23</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">3,758</td>

            <td class="px-3 py-2 border-b border-gray-700">27.47</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ICEBERG [144]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">400</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13</td>

            <td class="px-3 py-2 border-b border-gray-700">7,732</td>

            <td class="px-3 py-2 border-b border-gray-700">51.73</td>

            <td class="px-3 py-2 border-b border-gray-700">3.19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HIGHT [107]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">188.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">3,048</td>

            <td class="px-3 py-2 border-b border-gray-700">61.75</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Parallelized Architecture  |   |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRESENT [199]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6,400</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27,028</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">236.79</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">38.3</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Due to the high throughput achievable by both stream ciphers also the hardware efficiency is better than for a serialized present implementation. However, for a minimal area footprint this assumption does not hold anymore. Furthermore, if attention is turned to the round-based implementation results of present-80, it becomes visible that for <span class="math">1,570</span> GE a hardware efficiency of <span class="math">127.4</span> bits per second per GE is achievable, which is the highest among all ciphers in this table. Please note furthermore that stream ciphers require a significant amount of time for initialization (e.g. <span class="math">321</span> clock cycles for GRAIN and <span class="math">1,333</span> for TRIVIUM) prior to first usage. For comparison reasons, figures for round-based implementations of SEA, ICEBERG <em>[144]</em> and HIGHT <em>[107]</em> have been included. All three block ciphers require between <span class="math">3,048</span> GE and <span class="math">7,732</span> GE and also the hardware efficiency is worse than for both present-80 and present-128 implementations. ICEBERG’s high throughput (<span class="math">400</span> Kbps) is nullified by its large area requirements of <span class="math">7,732</span> GE.</p>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">5.2 FPGA implementation results</h3>

    <p class="text-gray-300">In this section we describe an FPGA implementation of a stand-alone present component. We implemented an encryption and a decryption only core and for each we investigated two different design strategies (boolean representation and look-up tables) for the S-box component. First we describe our target platform and the tool-chain in Section 5.2.1. Then we describe our architectures in Section 5.2.2 and finally present our results in Section 5.2.3.</p>

    <h4 id="sec-81" class="text-lg font-semibold mt-6">5.2.1 Target platform and designflow</h4>

    <p class="text-gray-300">We implemented both encryption and decryption functions in <em>VHDL</em> for the <em>Spartan-III XC3S400</em> (Package FG456 with speed grade -5) FPGA core from <em>Xilinx</em> <em>[242]</em>. We used <em>Mentor Graphics ModelSimXE 6.2g</em> for simulation purposes and <em>Xilinx ISE v10.1.03 WebPACK</em> for design synthesis.</p>

    <h4 id="sec-82" class="text-lg font-semibold mt-6">5.2.2 Architecture of the round-based FPGA implementation</h4>

    <p class="text-gray-300">As can be seen from Fig. 5.6(a) our present-80 and present-128 entities have 212 and 270 I/O pins, respectively. We did not implement any I/O logic such as a UART interface in order to achieve implementation figures for the plain present core. The interface usually strongly depends on the target application, hence we deliberately use additional I/O pins for a parallel key input. There are two reasons why we abandon the options of hard-coding the key inside the cipher module or implementing serial interface to supply the key to the algorithm. First, we want to reduce the control logic overhead to a minimum in order to present performing results of the plain encryption core. Secondly, we anticipate that the majority of applications most likely would use present as an independent cipher module within a larger top entity, so that the key can be supplied externally. From that perspective our implementation choice offers the best flexibility.</p>

    <p class="text-gray-300">Unfortunately, the low-cost <em>Spartan-III XC3S200</em> FPGA has no package with more than 173 I/O pins <em>[242]</em>. Therefore we decided to move to the more advanced <em>Spartan-III XC3S400</em> which features a package (FG456) with 264 I/O pins. Larger Spartan FPGAs such as the <em>Spartan-III XC3S1000</em> feature even more I/O pins but also contain more logic resources. Since in this Thesis we focus on lightweight and low-cost implementations of present we chose the smallest</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">!<a href="img-23.jpeg">img-23.jpeg</a> (a) I/O interfaces</p>

    <p class="text-gray-300">!<a href="img-24.jpeg">img-24.jpeg</a> (b) Finite State Machine. Figure 5.6: I/O interfaces and FSM of the PRESENT-80 FPGA implementation.</p>

    <p class="text-gray-300">possible device Spartan-III XC3S400 which is only slightly larger (and hence more expensive) than the Spartan-III XC3S200.</p>

    <p class="text-gray-300">The entire cipher control logic was implemented as a 3-state finite-state machine (see Fig.5.6(b)). After reset the first round begins and the two inputs of the algorithm, plaintext and user-supplied key are read from the corresponding registers. The 64- and 80-bit multiplexers select the appropriate input depending on the value of the round counter, i.e. initial values for plaintext and key are valid only in round 1. Both 64- and 80-bit D-flip-flops are used for round synchronization between the round function output and the output of the key schedule. Part of the round key is then XOR-ed with the plaintext. Key schedule and round function run in parallel for each round  <span class="math">1 \\leq i \\leq 32</span> .</p>

    <p class="text-gray-300">Implementation of both permutation and bit-rotation is very straightforward in hardware, which is a simple bit-wiring. The highly non-linear PRESENT S-box function is the core of the cryptographic strength of the cipher, and is the only design component that takes a lion's share of both computational power and area. Two implementation options for the PRESENT S-box were taken in consideration in order to optimize the efficiency of the cipher. Using Look-Up Tables (LUTs) for bit substitution is the most obvious one and was implemented first. An alternative considered next was determining a minimal non-linear Boolean function</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} S _ {i}: \\quad \\mathbb {F} _ {2} ^ {4} \\quad \\mapsto \\mathbb {F} _ {2} \\\\ \\left(x _ {3} x _ {2} x _ {1} x _ {0}\\right) \\mapsto y _ {i}, \\quad 0 \\leq i \\leq 3 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">for each bit output of the PRESENT S-box using only standard gates, i.e. AND, OR and NOT. The tool espresso [170] was used to produce such minimal Boolean functions for the PRESENT S-box.</p>

    <p class="text-gray-300">Interestingly, in some cases this modification yielded a performance boost in terms of max. frequency/throughput and area requirements measured in occupied slices. E.g., for PRESENT-80 with espresso-optimized S-box ISE showed significant decrease in critical path delay due to routing as compared to the S-box implementation with LUTs. From our results we conclude that espresso and its minimal Boolean functions can yield better resources utilization and may in some cases outpace ISE's internal synthesis mechanisms.</p>

    <p class="text-gray-300">The decryption unit of PRESENT is very similar to the encryption. The first round of decryption requires the last round key of the encryption routine. For optimal performance we assume that this last round key is pre-computed and available at the beginning of the decryption routine. The assumption is fair since we have to perform this step only once for multiple cipher texts.</p>

    <p class="text-gray-300">5.2. FPGA implementation results</p>

    <p class="text-gray-300">Table 5.2: Performance results for encryption and decryption of one data block with PRESENT for different key sizes and S-box implementation techniques on a Spartan-III XC3S400 FPGA.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">enc/dec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S-box (espresso/LUT)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LUTs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FFs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total equiv. Slices</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Max. freq (MHz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CLK cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput (Mbps)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eff. (Mbps/Slices)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">espresso</td>

            <td class="px-3 py-2 border-b border-gray-700">253</td>

            <td class="px-3 py-2 border-b border-gray-700">152</td>

            <td class="px-3 py-2 border-b border-gray-700">176</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">516</td>

            <td class="px-3 py-2 border-b border-gray-700">2.93</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LUT</td>

            <td class="px-3 py-2 border-b border-gray-700">350</td>

            <td class="px-3 py-2 border-b border-gray-700">154</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">2.38</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">espresso</td>

            <td class="px-3 py-2 border-b border-gray-700">328</td>

            <td class="px-3 py-2 border-b border-gray-700">154</td>

            <td class="px-3 py-2 border-b border-gray-700">197</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">2.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LUT</td>

            <td class="px-3 py-2 border-b border-gray-700">328</td>

            <td class="px-3 py-2 border-b border-gray-700">154</td>

            <td class="px-3 py-2 border-b border-gray-700">197</td>

            <td class="px-3 py-2 border-b border-gray-700">238</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">476</td>

            <td class="px-3 py-2 border-b border-gray-700">2.42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">espresso</td>

            <td class="px-3 py-2 border-b border-gray-700">299</td>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">250</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">2.48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LUT</td>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">200</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">508</td>

            <td class="px-3 py-2 border-b border-gray-700">2.51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">espresso</td>

            <td class="px-3 py-2 border-b border-gray-700">366</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">239</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">478</td>

            <td class="px-3 py-2 border-b border-gray-700">2.16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LUT</td>

            <td class="px-3 py-2 border-b border-gray-700">366</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">239</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">478</td>

            <td class="px-3 py-2 border-b border-gray-700">2.16</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5.2 summarizes the performance figures for our implementations. All figures presented are from Post Place &amp; Route Timing Report. To achieve optimal results both Synthesis and Place &amp; Route Effort properties were set to High and Place &amp; Route Extra Effort was set to Continue on Impossible.</p>

    <p class="text-gray-300">Numerous FPGA implementations of AES block cipher exist. Some of them are tuned to maximize data throughput, whereas others were designed for optimization of area requirements and power consumption. There are also block ciphers that were designed specifically for hardware (SEA [145]) or even FPGA (ICEBERG [211]) applications. We compare our PRESENT implementation with different existent FPGA implementations of those ciphers. Given the wide range of different features and logic slices provided by different FPGAs it is hard to make a fair comparison, so additional information on implementation platform and boundary conditions is provided.</p>

    <p class="text-gray-300">Table 5.3 shows that in the field of cryptographic implementations for low-cost FPGA cores, PRESENT offers both the smallest area requirement and highest hardware efficiency compared to AES as well as ICEBERG and SEA implementations. Note, that our implementation does not require any Block RAM units while most AES implementations do. For this matter we show the total equivalent slice count for each implementation to highlight the real area requirements.</p>

    <p class="text-gray-300">The speed grade of the Spartan devices has significant impact on the max. frequency of the cipher. Switching from speed grade 4 to speed grade 5 gave us up to  <span class="math">20\\%</span>  max. frequency increase. There are also different packages for each device platform with varying pinout count. Those facts make a fair inter-platform comparison even harder. Hence, for comparison's sake we picked only AES implementations on Spartan devices with speed grade 5 and above. For ICEBERG and SEA there are only Virtex-II implementations available. We also chose PRESENT version with 128-bit key size for the same reason even though the implementation figures for PRESENT-80 are more encouraging.</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">Table 5.3: Performance comparison of FPGA implementations of cryptographic algorithms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Block Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FPGA device</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Max. freq. (MHz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put (Mbps)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total equiv. Slices</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eff. (Mbps/ Slice)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-III XCS400-5</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">508</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">2.51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-80, [94]</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-III XCS3500</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">271</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ICEBERG, [211]</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">Virtex-II</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1016</td>

            <td class="px-3 py-2 border-b border-gray-700">631</td>

            <td class="px-3 py-2 border-b border-gray-700">1.61</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SEA126,7, [145]</td>

            <td class="px-3 py-2 border-b border-gray-700">126</td>

            <td class="px-3 py-2 border-b border-gray-700">Virtex-II XC2V4000</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">424</td>

            <td class="px-3 py-2 border-b border-gray-700">0.368</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES, [43]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-II XC2S30-6</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

            <td class="px-3 py-2 border-b border-gray-700">522</td>

            <td class="px-3 py-2 border-b border-gray-700">0.32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES, [88]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-III XC3S2000-5</td>

            <td class="px-3 py-2 border-b border-gray-700">196.1</td>

            <td class="px-3 py-2 border-b border-gray-700">25,107</td>

            <td class="px-3 py-2 border-b border-gray-700">17,425</td>

            <td class="px-3 py-2 border-b border-gray-700">1.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES, [88]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-II XC2S15-6</td>

            <td class="px-3 py-2 border-b border-gray-700">67</td>

            <td class="px-3 py-2 border-b border-gray-700">2.2</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES, [200]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-II XC2V40-6</td>

            <td class="px-3 py-2 border-b border-gray-700">123</td>

            <td class="px-3 py-2 border-b border-gray-700">358</td>

            <td class="px-3 py-2 border-b border-gray-700">1214</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES, [37]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan-III</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">1700</td>

            <td class="px-3 py-2 border-b border-gray-700">1800</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Embedded systems offer a wide range of different implementation opportunities. On the extremes there are plain hardware and plain software implementations. In practice however often hardware software co-design strategies are applied, which we will address in this section. We start with a co-processor ASIC implementation in Section 5.3.1 that was published by Rolfes et al. in [199]. Subsequently, in Section 5.3.2 we discuss a co-processor FPGA implementation of Guo et al. [94] and finally we treat Instruction Set Extensions for bit-sliced software implementations that have been published by Grabher et al. [91] in Section 5.3.3.</p>

    <p class="text-gray-300">To equip a smart device with cryptographic functions there are different ways for implementation: software or hardware. The first solution requires RAM to store the program and inhibits the microcontroller while performing cryptographic algorithms. The second possibility is to implement the crypto part straight into the microcontroller core. A more flexible way is to construct a cryptographic co-processor that is controlled by the main core. It uses a memory-like interface for communication. Using the round based architecture of PRESENT-128, we present in this section a cryptographic co-processor with encryption and decryption capabilities.</p>

    <p class="text-gray-300">To get a compact and also fast solution we use the round based architecture presented in Section 5.1.2 with a modified finite state machine and added further multiplexers. Now the plaintext is loaded in 32-bit blocks. As far as we know this is the maximum bit width of microcontrollers for smart devices. The co-processor is controlled by write and read enable signals. The address signal selects the different bit blocks and encryption or decryption mode. Figure 5.7 illustrates the interfaces and the units.</p>

    <p class="text-gray-300">5.3. Hardware/Software co-design implementation results</p>

    <p class="text-gray-300">!<a href="img-25.jpeg">img-25.jpeg</a> Figure 5.7: Block diagram of PRESENT-128 co-processor with 32-bit interface.</p>

    <p class="text-gray-300">The best choice is to implement a round based architecture with a 32-bit I/O interface. In the literature several AES implementations can be found that are up to the mark. We compare the PRESENT implementations to Pramstaller et al. [186] and Satoh et al. [201]. Also a commercial solution by Cast Inc. [39] is listed. Table 5.4 shows the results for the different implementations. As there are many smart cards equipped with 8-bit microcontrollers we list the results for an 8-bit interface, too. The PRESENT co-processor is much more compact than the other implementations and also needs less clock cycles to compute the ciphertext.</p>

    <p class="text-gray-300">Table 5.4: Implementation results of the co-processor architectures of a PRESENT-80 ASIC [199].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Datapath [Bit]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tech. [μm]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">max Freq. [MHz]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area [GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put [Mbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-128</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">2,587</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

            <td class="px-3 py-2 border-b border-gray-700">2,851</td>

            <td class="px-3 py-2 border-b border-gray-700">123</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">353</td>

            <td class="px-3 py-2 border-b border-gray-700">2,900</td>

            <td class="px-3 py-2 border-b border-gray-700">359</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

            <td class="px-3 py-2 border-b border-gray-700">143</td>

            <td class="px-3 py-2 border-b border-gray-700">2,681</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">141</td>

            <td class="px-3 py-2 border-b border-gray-700">2,917</td>

            <td class="px-3 py-2 border-b border-gray-700">231</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">323</td>

            <td class="px-3 py-2 border-b border-gray-700">2,989</td>

            <td class="px-3 py-2 border-b border-gray-700">529</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [39]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">124,000</td>

            <td class="px-3 py-2 border-b border-gray-700">872</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [201]</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.11</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">54,000</td>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES [186]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">85,000</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">92</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Guo et al. investigated the energy and performance efficiency of an FPGA-based System-on-Chip (SoC) platform with AES and PRESENT co-processors in [94]. They used the GEZEL [203]</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">cosimulation environment that creates a platform simulator by combining instruction-set simulators with a hardware kernel. The GEZEL description can be transformed into synthesizable VHDL code and Guo et al. used the resulting VHDL code to add an AES and a PRESENT coprocessor in the Xilinx Platform Studio 9.1.02. Table 5.5 summarizes their result.</p>

    <p class="text-gray-300">Table 5.5: Co-processor implementation results of AES and PRESENT within a System-on-Chip platform based on a low-cost FPGA [94].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AES-128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PRESENT-80</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Area  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Crypto core</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[slices]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,877</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">271</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Timing for encryption of 100 blocks  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SW</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[cycles]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">432,756</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,295,863</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HW/SW</td>

            <td class="px-3 py-2 border-b border-gray-700">[cycles]</td>

            <td class="px-3 py-2 border-b border-gray-700">77,428</td>

            <td class="px-3 py-2 border-b border-gray-700">51,427</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HW speedup</td>

            <td class="px-3 py-2 border-b border-gray-700">[factor]</td>

            <td class="px-3 py-2 border-b border-gray-700">360.6</td>

            <td class="px-3 py-2 border-b border-gray-700">695.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HW/SW speedup</td>

            <td class="px-3 py-2 border-b border-gray-700">[factor]</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6</td>

            <td class="px-3 py-2 border-b border-gray-700">44.6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Power/Energy of crypto core for 10 encryptions 20 MHZ  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Quiescent Power</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[mW]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">51.51</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">44.06</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">[ms]</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">16.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Energy</td>

            <td class="px-3 py-2 border-b border-gray-700">[mJ]</td>

            <td class="px-3 py-2 border-b border-gray-700">0.55</td>

            <td class="px-3 py-2 border-b border-gray-700">0.78</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Energy/byte</td>

            <td class="px-3 py-2 border-b border-gray-700">[μJ/byte]</td>

            <td class="px-3 py-2 border-b border-gray-700">3.46</td>

            <td class="px-3 py-2 border-b border-gray-700">9.81</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Power/Energy of FPGA system for 4 encryptions 50 MHZ  |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Quiescent Power</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[mW]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">31.25</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">31.25</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">[ms]</td>

            <td class="px-3 py-2 border-b border-gray-700">62.08</td>

            <td class="px-3 py-2 border-b border-gray-700">41.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Energy</td>

            <td class="px-3 py-2 border-b border-gray-700">[mJ]</td>

            <td class="px-3 py-2 border-b border-gray-700">3.18</td>

            <td class="px-3 py-2 border-b border-gray-700">2.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Energy/byte</td>

            <td class="px-3 py-2 border-b border-gray-700">[μJ/byte]</td>

            <td class="px-3 py-2 border-b border-gray-700">49.68</td>

            <td class="px-3 py-2 border-b border-gray-700">65.48</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As one can see the area requirements of AES are about 7 times higher compared to PRESENT if we consider the crypto core and it is still 4.5 times higher if we also take the wrapper into account. On the other hand the timing for both plain software (SW) and plain hardware (HW) implementations are 2.75 times better for the AES. However, if also the I/O communication overhead between processor and co-processor is considered the AES requires 1.5 times more cycles compared to PRESENT. The possible speedup of a plain hardware and a combined HW/SW co-design implementation compared to a plain software implementation is provided by the following two rows of the table. Though AES requires 360 times less cycles in hardware compared to software implementations, if also the I/O communication overhead is considered the speedup is reduced to a factor of 5.6. A plain hardware implementation of PRESENT requires nearly 700 times fewer clock cycles and a combined HW/SW co-design implementation still requires 44.6 times fewer clock cycles compared to a plain software implementation. These figures impressively underline PRESENT's suitability for hardware implementations.</p>

    <p class="text-gray-300">The power figures of present are less or equal to those of AES for both the crypto core component and the complete FPGA system. However, the total energy consumption and the energy per byte consumption are worse for present compared to AES for the crypto core component. For the complete FPGA system the total energy consumption of present is less than for AES, while the energy per byte ratio is better for AES. Concluding it can be observed that present is better suited for low-area and low-power implementations that do not have to encrypt large amounts of data, such as passive low-cost devices. Note that this was exactly one of the design goals of present.</p>

    <h4 id="sec-89" class="text-lg font-semibold mt-6">5.3.3 Instruction set extensions for bit-sliced implementation</h4>

    <p class="text-gray-300">Bit-slicing was introduced by Biham in <em>[21]</em> and is a technique which considers a processor with a word size of <span class="math">w</span> bits to be <span class="math">w</span> <span class="math">1</span>-bit processors that operate in a SIMD-style parallelism. Instead of encrypting data blocks subsequently, <span class="math">w</span> blocks are processed at in a bit-serial way at the same time.</p>

    <p class="text-gray-300">In a standard software implementation each data block has the following bit arrangement</p>

    <p class="text-gray-300"><span class="math">B_{i}=b_{i,w-1}b_{i,w-2}\\ldots b_{i,0},0\\leq i\\leq m-1,</span></p>

    <p class="text-gray-300">where <span class="math">m</span> denotes the amount of data blocks to be processed, <span class="math">B_{i}</span> denotes the <span class="math">i</span>-th data block and <span class="math">b_{i,j}</span> denotes the <span class="math">j</span>-th bit of the <span class="math">i</span>-th data block. The order of processing would be <span class="math">B_{0},B_{1},\\ldots,B_{m-1}</span>. In a bit-sliced implementation data blocks have the following bit arrangement</p>

    <p class="text-gray-300"><span class="math">B_{i}=b_{w-1,i}b_{w-2,i}\\ldots b_{0,i},0\\leq i\\leq m-1.</span></p>

    <p class="text-gray-300">Let us consider a CPU with a word size of <span class="math">w=64</span> bits and a block cipher such as present or DES with a block size of <span class="math">n=64</span> bits. Then in standard implementation we would process blocks with the following bit arrangements:</p>

    <p class="text-gray-300"><span class="math">B_{0}=b_{0,63}b_{0,62}\\ldots b_{0,0},B_{1}=b_{1,63}b_{1,62}\\ldots b_{1,0},\\ldots,B_{63}=b_{63,63}b_{63,62}\\ldots b_{63,0}.</span></p>

    <p class="text-gray-300">In a bit-sliced implementation however the bit arrangement looks like the following:</p>

    <p class="text-gray-300"><span class="math">B_{0}=b_{63,0}b_{62,0}\\ldots b_{0,0},B_{1}=b_{63,1}b_{62,1}\\ldots b_{0,1},\\ldots,B_{63}=b_{63,63}b_{62,63}\\ldots b_{0,63}.</span></p>

    <p class="text-gray-300">In other words, the <span class="math">i</span>-th data block that is processed by the CPU consists of the <span class="math">i</span>-th bit of all data blocks. Therefore, prior to processing, the data words have to be re-arranged bit by bit, which poses a significant overhead. In total however bit-slicing was shown to significantly speed-up software implementations of block ciphers. Interestingly, it is especially suited to speed-up operations that are efficient in hardware and rather inefficient in software, such as bit permutations.</p>

    <p class="text-gray-300">Grabher et al. describe Instruction Set Extensions (ISE) for bit-sliced implementations in <em>[91]</em>. They used the Processor Designer tool-chain from CoWare, which is based on LISA (Language for Instruction Set Architectures), to describe a CRISP 5-stage pipeline along with each <span class="math">4</span> KB data and instruction RAM in a Harvard-architecture. Then they used Xilinx ISE</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">7.3 to synthesize it to an ADM-XRC-II PCI card, which includes a Xilinx Virtex-II XC2V6000-4FF1152 FPGA device with 33,000 slices. <span class="math">^{5}</span></p>

    <p class="text-gray-300">Table 5.6 summarizes their results of a comparison between AES, serpent and PRESENT. As one can see PRESENT is by far the smallest but also the slowest implementation of all algorithms. On the one hand it is no wonder that PRESENT has the smallest code footprint in bit-sliced implementations, because it is strongly optimized for a low hardware complexity. On the other hand it would be interesting to see why it takes so many clock cycles for one encryption of PRESENT.</p>

    <p class="text-gray-300">Table 5.6: Performance of ISE for bit-sliced implementations of AES, serpent and PRESENT.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Implementation strategy</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Source</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Code size [bytes]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES-128</td>

            <td class="px-3 py-2 border-b border-gray-700">32 bit</td>

            <td class="px-3 py-2 border-b border-gray-700">[19]</td>

            <td class="px-3 py-2 border-b border-gray-700">1,662</td>

            <td class="px-3 py-2 border-b border-gray-700">1,160</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced</td>

            <td class="px-3 py-2 border-b border-gray-700">[132]</td>

            <td class="px-3 py-2 border-b border-gray-700">2,699</td>

            <td class="px-3 py-2 border-b border-gray-700">2,080</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced /w LUTs</td>

            <td class="px-3 py-2 border-b border-gray-700">[91]</td>

            <td class="px-3 py-2 border-b border-gray-700">2,203</td>

            <td class="px-3 py-2 border-b border-gray-700">1,328</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced /w LUTs and perm.</td>

            <td class="px-3 py-2 border-b border-gray-700">[91]</td>

            <td class="px-3 py-2 border-b border-gray-700">1,222</td>

            <td class="px-3 py-2 border-b border-gray-700">858</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">serpent-128</td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced</td>

            <td class="px-3 py-2 border-b border-gray-700">[91]</td>

            <td class="px-3 py-2 border-b border-gray-700">2,031</td>

            <td class="px-3 py-2 border-b border-gray-700">2,112</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced /w LUTs</td>

            <td class="px-3 py-2 border-b border-gray-700">[91]</td>

            <td class="px-3 py-2 border-b border-gray-700">922</td>

            <td class="px-3 py-2 border-b border-gray-700">984</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-80</td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced</td>

            <td class="px-3 py-2 border-b border-gray-700">[91]</td>

            <td class="px-3 py-2 border-b border-gray-700">39,986</td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Bit-sliced /w LUTs</td>

            <td class="px-3 py-2 border-b border-gray-700">[91]</td>

            <td class="px-3 py-2 border-b border-gray-700">28,082</td>

            <td class="px-3 py-2 border-b border-gray-700">408</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This section presents software implementation results of PRESENT on a wide range of different platforms. First we provide an overview of different implementation profiles in Section 5.4.1. Subsequently we present implementation results for 4-bit microcontrollers, which are up to now the first implementation results for a cryptographic algorithm on a 4-bit microcontroller. Hence, they may serve as a proof-of-concept for the feasibility of cryptography on such constrained devices. Then we provide implementation figures of PRESENT for 8-, 16- and 32-bit microcontrollers/CPUs.</p>

    <p class="text-gray-300">PRESENT-80 has been implemented with three different functionalities, i.e. each one variant is capable of encryption or decryption only, and one variant can perform both encryption and decryption. Furthermore we optimized all three variants either for speed or code size. We numbered the profiles as follows (see also Table 5.7):</p>

    <p class="text-gray-300">Profile I is optimized for speed and can perform the encryption routine only.</p>

    <p class="text-gray-300">5.4. Software Implementations</p>

    <p class="text-gray-300">Table 5.7: The different profiles for the software implementations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">encryption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decryption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc + Dec</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Speed</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">III</td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Code</td>

            <td class="px-3 py-2 border-b border-gray-700">II</td>

            <td class="px-3 py-2 border-b border-gray-700">IV</td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Profile II is optimized for code size and can perform the encryption routine only.</p>

    <p class="text-gray-300">Profile III is optimized for speed and can perform the decryption routine only.</p>

    <p class="text-gray-300">Profile IV is optimized for code size and can perform the decryption routine only.</p>

    <p class="text-gray-300">Profile V is optimized for speed and can perform both the encryption and decryption routine.</p>

    <p class="text-gray-300">Profile VI is optimized for code size and can perform both the encryption and decryption routine.</p>

    <p class="text-gray-300">4-Bit microcontroller are deployed in a very broad range of everyday life items, ranging from watches and washing machines to security critical applications such as car tire sensors or one-time PIN generators. To the best of our knowledge so far no implementation of a cryptographic algorithm on such a constrained platform has been published.</p>

    <p class="text-gray-300">The ATAM893-D, member of Atmel's MARC4 family of 4-bit single-chip microcontrollers inherits a RISC <span class="math">^6</span>  core and contains EEPROM, RAM, parallel input/output ports, two 8-bit programmable multifunction counters/timer and an on-chip clock generation with integrated RC-, 32-kHz and 4-MHz crystal oscillators. It is widely used in wireless applications such as remote keyless entry, immobilizer systems and wireless sensors. Atmel's MARC4 microcontroller family is based on a low-power 4-bit CPU core. The modular MARC4 architecture is high-level language oriented, consuming still below 1 mA in active mode [13]. Programming of MARC4 microcontrollers is supported by a personal computer based software development system with a high-level language qForth compiler and a real-time core simulator (see Fig. 5.8(a)).</p>

    <p class="text-gray-300">The CPU is based on the Harvard architecture with physically separate program memory and data memory. For the communication between ROM, RAM and peripherals three independent buses (instruction-, memory- and I/O-bus) are used. The core contains 4 KByte program memory (ROM), 256x4-bit data memory (RAM), arithmetic-logic-unit (ALU) (see Fig. 5.9(b)), Program Counter (PC), RAM address register, instruction decoder and interrupt controller. The RAM is used for the Expression Stack, the Return Stack and as data memory for variables and arrays. It can be addressed by any of the four 8-bit wide RAM Address Registers SP, RP, X and Y (see below). These registers allow access to any of the 256 RAM nibbles.</p>

    <p class="text-gray-300">All arithmetic, I/O and memory reference operations take their operands from, and return their result to the Expression Stack (EXP) which is addressed by SP. The MARC4 performs</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">!<a href="img-26.jpeg">img-26.jpeg</a> (a) Screenshot of the MARC4 Simple Core Simulator.</p>

    <p class="text-gray-300">!<a href="img-27.jpeg">img-27.jpeg</a> (b) Atmel MARC4 Starter Kit.</p>

    <p class="text-gray-300">!<a href="img-28.jpeg">img-28.jpeg</a> Figure 5.8: Development environment for the MARC4 4 bit microcontroller. (a) MARC4 microcontroller size comparison with 1 cent coins. Figure 5.9: Blockdiagram of the ALU and size comparison of MARC4.</p>

    <p class="text-gray-300">!<a href="img-29.jpeg">img-29.jpeg</a> (b) Blockdiagram of the ALU of MARC4, source: [13].</p>

    <p class="text-gray-300">the operations with the top of stack items (TOS and TOS-1). The TOS register contains the top element of EXP and works in the same way as an accumulator. This stack is also used for passing parameters between subroutines, and as a scratchpad area for temporary storage of data (see Figure 5.9(b)). The 12-bit wide Return Stack (RET) is addressed by the Return Stack Pointer (RP). It is used for storing return addresses of subroutines, interrupt routines and for keeping loop-index counters. It can also be used as a temporary storage area.</p>

    <p class="text-gray-300">The instruction set supports the exchange of data between the top elements of the Expression Stack and the Return Stack. The two stacks within the RAM have a user-definable maximum depth. The MARC4 controller has six programmable registers and one condition code register. The Program Counter (PC) is a 12-bit register that contains the address of the next instruction to be fetched from the ROM. Instructions currently being executed are decoded in the instruction decoder to determine the internal micro-operations. For linear code (no calls or branches), the program counter is incremented with every instruction cycle. If a branch, call, return instruction or an interrupt is executed, the program counter is loaded with a new address. The PC is also used with the table instruction to fetch 8-bit wide ROM constants.</p>

    <p class="text-gray-300">5.4. Software Implementations</p>

    <p class="text-gray-300">We used the MARC4 Starter Kit which contains five samples of the Atmel ATAM893  <span class="math">\\mu C</span>  (see Fig. 5.9(a)), the target application board T4xCx92, an E-Lab ICP V24 Portable programmer and corresponding MARC4 programming board (see Figure 5.8(b)), as well as the software development software (see Figure 5.8(a)).</p>

    <p class="text-gray-300">Since the MARC4 inherits a stack-based architecture (which is similar to a zero-address machine) and its instructions contain only the operation to be performed without any source or destination, please note that it was arduous to implement the PRESENT block cipher on the target platform. In fact it turned out to be similar to the Tower of Hanoi mathematical game.</p>

    <p class="text-gray-300">All variables have to be initialized with a specific value for the MARC4 hardware to function correctly, since no variables are automatically assigned to zero. The 64-bit plaintext (or ciphertext, respectively) input to be encrypted (decrypted) is stored in the nibbles TextF to Text0, where TextF represents the 4 most-significant-bits (MSB) of the input. Hence, we refer to their order from '0' to '9' followed by alphabetical means until the letter 'F'. Naming congruates with the 80 bits of the key variables KeyJ to Key0. In order to implement the PRESENT round counter the 2VARIABLE construct is used. It allocates RAM space for storage of one double length (8-bit) value. The 5 most significant bits of the 8-bit variable Round represent the current number of rounds performed. This design decision was made to efficiently implement the exclusive-or operation (XOR) in the key scheduling function.</p>

    <p class="text-gray-300">PRESENT consists of an initial key addition followed by 31 iterations of :PBOX, :KEYSCHED and :KEYXOR. Also the 8-bit counter Round has to be increased in every iteration.</p>

    <pre><code class="language-txt">:ENCRYPT \\ This is a COMMENT KEYSCHED Round 2@ 8 Me Round 2! \\ increase Round by 8 SBOX PBOX KEYXOR</code></pre>

    <p class="text-gray-300">The required 31 iterations of :ENCRYPT are performed in a  <span class="math">10 \\cdot 3 + 1</span>  fashion. The word :EN-CLOOP applies 10 iterations of :ENCRYPT and is executed 3 times, resulting in 30 iterations of one round of PRESENT. Completing the encryption :ENCRYPT is once again executed, applying the last iteration of the PRESENT encryption.</p>

    <pre><code class="language-txt">ENCLOOP 11 BEGIN DO 10 times ENCRYPT 1- DUP 0 &amp;gt; WHILE . . . WHILE TOS &amp;gt; 0 ENCRYPT REPEAT DROP drop loop-counter=0
ENCRYPTION
INT1 = encryption
KEYXOR Initial KeyXOR
4 BEGIN DO 3 times ENCLoOP
1- DUP
0 &amp;gt; WHILE
ENCLOOP DO-END
REPEAT DROP
ENCRYPT 31st Round of PRESENT</code></pre>

    <p class="text-gray-300">Due to the harsh memory constraints of the MARC4 microcontroller (4 KB ROM, 128 B RAM) our main optimization goal was to reduce the code size, but with an eye on the execution time. Unfortunately the harsh memory constraints did not allow to fit an implementation that is capable of encryption and decryption. Therefore, we first discuss the encryption only implementation (profile II) and subsequently the decryption only implementation (profile IV) before we turn to the implementation results.</p>

    <p class="text-gray-300">Encrypting one block of 64 bits with a given 80-bit key can be divided into 4 procedures coinciding with the blocks found in Fig. 4.1. These procedures are Adding the Key (addRound-</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">Key,:KeyXOR), Substitution Table (sBoxLayer, :SBOX), Permutation Layer (pLayer, :PBOX) and Deriving the Key (update, :KeySched).</p>

    <p class="text-gray-300">The :KeyXOR sub-routine starts with a rather trivial function, the Key XOR. TextF places the 8-bit RAM-address of the variable TextF as two 4-bit values on to the stack (low nibble is top element).  <span class="math">\\theta</span>  copies the 4-bit value at a specified memory location via the two topmost nibbles onto the top of the stack (TOS). ! stores a 4-bit value at a specified memory location. The two topmost nibbles represent the 8-bit RAM-address where the value being the 3rd element on the stack, is to be stored.</p>

    <pre><code class="language-txt">: KEYXOR
TextF @ \\ load value of TextF onto stack
Key[ @ \\ load value of Key] onto stack
XOR TextF ! \\ XOR and save back to TextF
[...] \\ all this can also be written in ...
Text0 @ Key4 @ XOR Text0 ! \\ ...one line</code></pre>

    <p class="text-gray-300">The substitution table consisting of 16 values featured as nibbles stored in the ROM of the MARC4 microcontroller, beginning at ROM-address  <span class="math">0 \\times 360 \\mathrm{~h}</span>  and ending at  <span class="math">0 \\times 36 \\mathrm{~Fh}</span> . This is done with ROMCONST which saves 4-bit values in an array at consecutive ROM addresses. Though the MARC4 instruction set contains the function DTABLE@ which fetches an 8-bit constant from a ROMCONST array referring a 12-bit ROM address, a performance gain about  <span class="math">20\\%</span>  is achieved using ROMBYTE@ instead. Since no carry can occur, the first address (12 bits) of the array sTable can be placed onto the Expression Stack, only the lowest 4 bits of the address need to be added up to generate the substitution table lookup-address.</p>

    <pre><code class="language-txt">ROMCONST sTable 12, 5, 6, 11, 9, 0, 10, 13, 3, 14, 15, 8, 4, 7, 1, 2, AT 360h</code></pre>

    <pre><code class="language-txt">sTable \\ lookup table base address
Text0 @ + \\ lookup table index by adding..
\\ .value of Text0
ROMBYTE@ \\ sTable substitute
Text0 ! \\ save sTable[Text0] to Text0
DROP \\ drop high nibble
[...]</code></pre>

    <p class="text-gray-300">Given the permutation layer's characteristics, it can be implemented using only 16 bits as temporary memory, which are stored in the variables Temp3 to Temp0. The way most efficient approach of implementing the permutation layer was to shift each single bit out of the actual variable, and into its new location. This way of 'filling' the variables equates filo-queueing and it is therefore necessary to insert the subsequent MSB into the LSB position.</p>

    <p class="text-gray-300">Commands used to shift into and rotating out of the carry-bit are SHL, SHR, ROL, ROR (cf. [221]).</p>

    <pre><code class="language-txt">Text0 @ SHR Temp0 @ ROR Temp0 !
SHR Temp1 @ ROR Temp1 !
SHR Temp2 @ ROR Temp2 !
SHR Temp3 @ ROR Temp3 ! \\ Text0 &quot;emptied&quot;
DROP \\ Drop &#x27;empty&#x27; Text0 from stack</code></pre>

    <p class="text-gray-300">This way all 16x4 bits of TextF to Text0 are consecutively processed to assign the bits to their new position. Each of these 16 iterations clears one 4-bit variable which is subsequently used as the next temporary variable maintaining memory-efficiency.</p>

    <p class="text-gray-300">Efficient rotation of all 80 key-bits by 61 positions to the left in the Key Schedule (:KeySched) is performed by moving 20 bits to the right and then rotate one position to the left. Since 20 is a multiple of the 4-bit architecture, the first operation would actually be only re-addressing memory pointers. As mentioned before the MARC4 hardware is a zero-address machine, therefore re-addressing can only be accomplished by copying the respective values into their new positions.</p>

    <p class="text-gray-300">5.4. Software Implementations</p>

    <pre><code class="language-txt">: KEYSCHED
Key4@ Key3@ Key2@ Key1@ Key0@ KeyJ@ KeyH@ KeyG@
KeyF@ KeyE@ KeyD@ KeyC@ KeyB@ KeyA@ Key9@ Key8@ Key7@
Key6 @ Key5@ \\ Pushed Keys onto stack &amp;gt;&amp;gt;20..
SHL Key0 ! \\ Rotate through Carry BEGIN
ROL Key1 ! \\ .. &amp;lt;&amp;lt;1 matches &amp;gt;&amp;gt;19 ergo &amp;lt;&amp;lt;69
[...]
ROL Key1 !
0111b CCR @ &amp;lt; \\ if Carry, insert 0001b into Key0
IF Key0 @ 1 XOR Key0 !
ELSE Key0 @ 0 XOR \\ non-varying RunTime
Key0 ! NOP NOP NOP \\ --&amp;gt; timing-attack resistance
THEN \\ Rotate through Carry END</code></pre>

    <p class="text-gray-300">The single bits 79 to 76 oblige one SBOX lookup as shown above and the 8 bits of the counter Round are added to the bits 19 to 15 of the key resulting in the new actual key.</p>

    <p class="text-gray-300">Round 2@ Key3@ XOR Key3! Key4@ XOR Key4! \\ Add Counter</p>

    <p class="text-gray-300">Due to MARC4's constrained hardware specifications in terms of available memory, no precomputing and storing of the round-keys for decryption can be achieved. Therefor before decrypting, the 31st key is pre-computed, and an inverse key scheduling routine is implemented. Though performance takes a slight hit from the extra amount of pre-computing the 31st key, this was the most efficient way to implement the decryption routine without the need for additional external memory.</p>

    <p class="text-gray-300">The differences in decrypting data, instead of encrypting, are that instead of the regular S-box and permutation layer their respective inverses are used in the reverse order of appearance. Furthermore the first decryption key (i.e. the last encryption key) has to be pre-computed, i.e., the complete encryption key-schedule has to be finished, first.</p>

    <p class="text-gray-300">The word LASTKEY computes the first decryption key and is therefore iterated  <span class="math">30 + 1</span>  times. Now that the first decryption key is stored in KeyJ to Key0 the decryption can be started by setting interrupt number seven (INT7). The decryption code again coincides with encryption, except for the counter Round being decreased and changing order of the inverse substitution table with the inverse permutation layer as described in the following subsections. Adding the key during decryption is similar to the addition during encryption. The inverse Substitution table (:ISBOX) of the decryption is stored at ROM-addresses 0x370h and ending at 0x37Fh. The same characteristics of the :SBOX (see above) also apply here, except for the inverted substitution table IsTable.</p>

    <p class="text-gray-300">ROMCONST IsTable 5, 14, 15, 8, 12, 1, 2, 13, 11, 4, 6, 3, 0, 7, 9, 10, AT 370h</p>

    <p class="text-gray-300">The code of the inverse substitution layer (:iPBOX) logically equals the code of the :PBOX (see above) with only minor changes of sorting.</p>

    <p class="text-gray-300">Presumable the last key is already stored in the variables KeyJ to Key0, the inverse key scheduling shares most of its code with the key scheduling routine of the encryption, just in reverse order. It starts with the exclusive-or with Round and the inverse substitution table lookup of the bits 79 to 76. The way of shifting all key-bits 61 positions to the right is again done the same way as explained before, only changed in its order to achieve the inverse shifting direction.</p>

    <p class="text-gray-300">The results refer to the optimized and most efficient implemented version. Since this is the first state-of-the-art block cipher on a 4-bit microcontroller there are no figures for comparison</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">enc/dec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ROM [lines of code]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Stack [EXP]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[RET]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Init. [cycles]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles / block [cycles]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">841</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">55,734</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">945</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">65,574</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5.8: Code size and cycle count of PRESENT-80 on the ATAM893-D 4-Bit microcontroller.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">enc / dec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Freq. [KHz]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CLK int. / ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time for enc/dec [ms]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put [bits/sec]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Current cons. [μA]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Energy per block [μJ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">per bit [μJ/bit]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">2,000</td>

            <td class="px-3 py-2 border-b border-gray-700">int.</td>

            <td class="px-3 py-2 border-b border-gray-700">27.9</td>

            <td class="px-3 py-2 border-b border-gray-700">2,297</td>

            <td class="px-3 py-2 border-b border-gray-700">79.3</td>

            <td class="px-3 py-2 border-b border-gray-700">3.98</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">ext.</td>

            <td class="px-3 py-2 border-b border-gray-700">111.5</td>

            <td class="px-3 py-2 border-b border-gray-700">574</td>

            <td class="px-3 py-2 border-b border-gray-700">6.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">ext.</td>

            <td class="px-3 py-2 border-b border-gray-700">3,483</td>

            <td class="px-3 py-2 border-b border-gray-700">18.4</td>

            <td class="px-3 py-2 border-b border-gray-700">9.2</td>

            <td class="px-3 py-2 border-b border-gray-700">57.7</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">2,000</td>

            <td class="px-3 py-2 border-b border-gray-700">int.</td>

            <td class="px-3 py-2 border-b border-gray-700">32.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1,952</td>

            <td class="px-3 py-2 border-b border-gray-700">79.3</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

            <td class="px-3 py-2 border-b border-gray-700">ext.</td>

            <td class="px-3 py-2 border-b border-gray-700">131.1</td>

            <td class="px-3 py-2 border-b border-gray-700">488</td>

            <td class="px-3 py-2 border-b border-gray-700">6.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.58</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">ext.</td>

            <td class="px-3 py-2 border-b border-gray-700">4,098</td>

            <td class="px-3 py-2 border-b border-gray-700">15.6</td>

            <td class="px-3 py-2 border-b border-gray-700">9.2</td>

            <td class="px-3 py-2 border-b border-gray-700">67.87</td>

            <td class="px-3 py-2 border-b border-gray-700">1.06</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5.9: Throughput and energy results of PRESENT-80 on the ATAM893-D 4-Bit microcontroller.</p>

    <p class="text-gray-300">available. The pursued target of implementing PRESENT-80 on a 4-bit microcontroller was to achieve the shortest possible execution time while requiring as less resources as possible. Therefore the code size and maximum growth of both stacks (EXP &amp; RET) are listed. As one can see from Table 5.8 the decryption routine requires 100 lines of code more compared to the encryption routine which is due to the additional key-scheduling and the additional inverse S-box. The stack growths and also the time for initialization were similar for both encryption and decryption.</p>

    <p class="text-gray-300">The encryption of 64 bit plaintext requires 55,734 cycles which is equivalent to  <span class="math">27.9\\mathrm{ms}</span>  at  <span class="math">2\\mathrm{MHz}</span>  (see Table 5.9). In the theoretical lowest possible cycle rate of  <span class="math">2\\mathrm{kHz}</span>  this would be equivalent to 27.9 seconds. The decryption of one data block of 64 bits requires 65,574 cycles which is equivalent to  <span class="math">32.8\\mathrm{ms}</span>  at  <span class="math">2\\mathrm{MHz}</span>  or 32.8 seconds at  <span class="math">2\\mathrm{kHz}</span> , respectively. These figures translate to about 2.3 and 1.9 Kbits per second for encryption and decryption at  <span class="math">2\\mathrm{MHz}</span>  or 18.4 and 15.6 bits per second at  <span class="math">16\\mathrm{kHz}</span> , respectively. Please note that RFID applications typically do not require the processing of large amounts of data.</p>

    <p class="text-gray-300">1.8V was applied as the supply voltage for measurements to obtain the current consumption of the microcontroller. A Keithley 2001 digital multi-meter [117] was used for measuring while encrypting data on the  <span class="math">\\mu C</span> . Table 5.9 shows the power consumption for different frequencies. Please note that these numbers also resemble the power consumption of the decryption respectively. Furthermore, measurements have also been conducted for a supply voltage of  <span class="math">5\\mathrm{V}</span> , but the measured current consumption was reciprocal proportional to the operating frequency. Since we could not find an explanation for this phenomenon, we decided to remove these figures from Table 5.9.</p>

    <p class="text-gray-300">The microcontroller was either clocked by an external crystal (XTAL) oscillator or using the internal RC-oscillator. The following clock-speeds were generated using a  <span class="math">32\\mathrm{kHz}</span>  XTAL: 16</p>

    <p class="text-gray-300">kHz, 2 kHz and also the SLEEP mode. The 2 MHz frequency was generated using the internal RC-oscillator. Finally, in order to reduce power-consumption, an external 4 MHz XTAL was used generating the <span class="math">500</span> kHz. We selected the different frequencies in order to show the time-power/energy trade-off that is possible with our present implementation. While 2 MHz and 2 KHz are the maximum and minimum frequencies of the ATAM893-D we also wanted to provide figures for an implementation that requires less then <span class="math">200</span> ms for encryption/decryption of one block. It turned out that <span class="math">500</span> KHz is the lowest possible frequency to reach this goal.</p>

    <p class="text-gray-300">As one can see from Table 5.9 at a supply voltage of <span class="math">1.8</span>V the current consumption of the microcontroller is below 10 <span class="math">\\mu</span>A when clocked at <span class="math">16</span> KHz and <span class="math">500</span> KHz. This is an interesting result, because it indicates that this implementation can also be used for passively powered low-cost RFID tags, which typically require such harsh power constraints. At <span class="math">500</span> KHZ is the best energy per bit ratio, which is interesting for active devices in order to maximize the lifespan of the battery.</p>

    <h4 id="sec-97" class="text-lg font-semibold mt-6">5.4.3 Software implementations on an 8-Bit microcontroller</h4>

    <p class="text-gray-300">These implementations can be downloaded free of charge from the website http://www.lightweightcrypto.org/present.</p>

    <h5 id="sec-98" class="text-base font-semibold mt-4">8 bit target platform and development environment</h5>

    <p class="text-gray-300">The ATMEL AVR RISC microcontroller family uses a Harvard architecture concept, i.e. it uses separate memories and buses for program and data. Its two stage pipeline allows to execute in every clock cycle one instruction and most of its <span class="math">130</span> instructions are single cycle instructions <em>[9]</em>. Out of this family we chose the ATmega163 microcontroller <em>[11]</em> as the target platform. Besides other features such as timers and counters, the ATmega163 provides <span class="math">16</span> K bytes Flash, <span class="math">512</span> bytes EEPROM, <span class="math">1024</span> bytes SRAM and <span class="math">32</span> general purpose working register. Figure 5.10 depicts the architecture of the ATmega163. Access to the SRAM costs <span class="math">2</span> clcock cycles and access to the Flash memory costs <span class="math">3</span> clock cycles. The ATmega163 can operate with up to <span class="math">8</span> MHz. At a frequency of <span class="math">4</span> MHZ and a voltage supply of <span class="math">3</span> Volt the ATmega163 draws <span class="math">5</span> mA of current when active, <span class="math">1.9</span> mA in Idle Mode and less than <span class="math">1\\mu</span>A in Power-down Mode. The interested reader is referred to the data sheet <em>[11]</em> and the instruction set manual <em>[9]</em> for further details about the ATmega163 microcontroller.</p>

    <p class="text-gray-300">We used the integrated development environment AVR Studio 4.13 from ATMEL <em>[10]</em>. It is provided free of charge by ATMEL and supports a wide range of ATMEL’s microcontrollers, such as the ATmega series. The AVR Studio features an in-build chip simulator and a source file editor as well as decent project management capabilities. Furthermore it uses the open-source WinAVR tool kit <em>[241]</em> that contains a GNU GCC compiler for C/C++ source, the avr-gdb debugger and the avrdude programmer.</p>

    <h5 id="sec-99" class="text-base font-semibold mt-4">Speed optimized implementation</h5>

    <p class="text-gray-300">For speed optimization it is wise to pre-compute and store all round keys in an array, because it has to be done only once in the beginning. Since present requires <span class="math">32</span> round keys of each</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">!<a href="img-30.jpeg">img-30.jpeg</a> Figure 5.10: Architecture of the ATmega163 8 bit microcontroller, source: [11].</p>

    <p class="text-gray-300">64 bits, in total <span class="math">256</span> Bytes of data memory are required. The <span class="math">61</span> bit rotation to the left in the key schedule is equivalent to a <span class="math">19</span> bit rotation to the right. For the speed optimized variants this rotation was decomposed into a <span class="math">16</span> bit and a <span class="math">3</span> bit shift to the right. This is advantageous on an <span class="math">8</span> bit platform, such as the ATmega163, because a <span class="math">16</span> bit shift can be implemented by re-addressing the <span class="math">8</span> bit registers in the following way:</p>

    <p class="text-gray-300"><span class="math">key[i]=key[i+2\\,MOD\\,10],\\,0\\leq i\\leq 9.</span></p>

    <p class="text-gray-300">Finally the <span class="math">61</span> bit rotation of all <span class="math">80</span> bits can be implemented by ten register address swaps and <span class="math">10\\cdot 3=30</span> shifting operations. The S-box for the key schedule is stored as <span class="math">16</span> <span class="math">8</span>-bit values where the high nibble is the S-box output value and the low nibble is padded with zeros. This allows to immediately OR the S-box output value with the four LSB of the highest key state byte.</p>

    <p class="text-gray-300">The S-Layer of present consists of <span class="math">16</span> <span class="math">4\\times 4</span> S-boxes (see Chapter 4). A naïve approach would be to select a <span class="math">4</span> bit chunk of the current state byte <span class="math">s</span>, substitute it with the <span class="math">4</span> bit S-box output value and store the result at the right position of the state. However, this would require to apply an AND operation to the state with a selection mask (0xF0 or 0x0F) and a table look-up. In case that the processed nibble is the higher significant one, additionally a shifting by <span class="math">4</span> positions to the left before and after the S-box look-up is required. A more efficient—and well-known—technique is to combine two (or more) smaller S-boxes to a larger S-box. By joining two present S-boxes we get the new <span class="math">8\\times 8</span> S-box:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S_{8\\times 8}(x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2})=S(x_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x_{2}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">S_{8\\times 8}</span> has <span class="math">256</span> entries of each <span class="math">8</span> bits. Using <span class="math">S_{8\\times 8}</span> significantly decreases the cycle count while also significantly increases the memory requirements.</p>

    <p class="text-gray-300">The permutation layer of present is probably the most difficult part to implement in software, because it processes each of the <span class="math">64</span> state bits individually. While in hardware this can be done virtually free of cost, in software this poses severe difficulties. A naïve approach would select <span class="math">64</span> times a single bit, look-up the shifting offset in a table and shift it to its new position. Since table look-ups require <span class="math">2</span> clock cycles this approach would require at least <span class="math">64\\cdot(1+2+1)=256</span> operations in total. A well-known implementation trick is to use look-up tables instead of permutations. Figure 5.11 depicts the general time-memory trade-off for look-up tables. The left side shows the classic look-up table approach for an <span class="math">n</span> bit permutation, which requires only one look-up to get the result. However, the memory requirements are <span class="math">2^{n}\\cdot n</span> bits. In the case of present <span class="math">n=64</span> and hence the memory requirement would be <span class="math">2^{64}\\cdot 64=2^{67}</span> Bytes, which is by far too much.</p>

    <p class="text-gray-300">Therefore a divide-and-conquer approach with the following steps seems to be better suited:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Split the <span class="math">n</span> bit word in <span class="math">k</span> parts, each <span class="math">\\frac{n}{k}</span> bits wide.</li>

      <li>Create <span class="math">k</span> different tables, each with <span class="math">2^{\\frac{n}{k}}</span> entries of <span class="math">n</span> bits.</li>

      <li>Join the <span class="math">k</span> look-up results from the different tables to one final result.</li>

    </ol>

    <p class="text-gray-300">Depending on the joining operation in step 3 (OR, XOR or AND) it is either required to pad the table entries with <span class="math">{}^{\\prime}0^{\\prime}</span> bits (OR, XOR) or with <span class="math">{}^{\\prime}1^{\\prime}</span> bits (AND) in step 2. The advantage of this divide-and-conquer approach is that it trades memory for additional time. Since we have <span class="math">k</span> tables each with <span class="math">2^{\\frac{n}{k}}</span> entries of <span class="math">n</span> bits, the memory requirement is <span class="math">k\\cdot 2^{\\frac{n}{k}}\\cdot n</span> bits. On the other hand now <span class="math">k</span> table look-ups are required and an additional joining operation.</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">!<a href="img-31.jpeg">img-31.jpeg</a> Figure 5.11: Time-memory trade-off for look-up tables.</p>

    <p class="text-gray-300">!<a href="img-32.jpeg">img-32.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-33.jpeg">img-33.jpeg</a></p>

    <p class="text-gray-300">A natural next step for optimizing a software implementation for an 8 bit microcontroller would be to set  <span class="math">k = 8</span> . While the timing then would be  <span class="math">8 + 1 = 9</span>  steps, the memory requirements would be  <span class="math">8 \\cdot 2^{\\frac{64}{8}} \\cdot 64</span>  bits  <span class="math">= 2^{14}</span>  bytes  <span class="math">= 16</span>  KB. Unfortunately this is the exact amount of Flash memory that our target platform ATmega163 provides and hence this approach does not allow a single additional line of code. Therefore we set  <span class="math">k = 16</span>  and now it takes 17 steps to process the permutation while the memory requirements are reduced to  <span class="math">16 \\cdot 2^{\\frac{64}{16}} \\cdot 64</span>  bits  <span class="math">= 2^{11}</span>  bytes  <span class="math">= 2</span>  KB. However, one Flash memory access requires 3 clock cycles, therefore the 8 look-up operations require at least 24 cycles and our timing complexity is about 25 steps. Even worse, one step refers to processing a 64-bit word, which on an 8-bit architecture costs at least 8 cycles each. Therefore the time complexity is around  <span class="math">25 \\cdot 8 = 200</span>  clock cycles. In the end this was the main reason to implement the P-layer in assembly, which results in 176 clock cycles.</p>

    <p class="text-gray-300">Finally, we advised GCC to compile with the -03 option, which aggressively optimizes the code for speed, e.g. by loop-unrolling.</p>

    <p class="text-gray-300">For a size optimized implementation it is wise to compute the round keys on-the-fly, i.e. no key is pre-computed. On the one hand this significantly increases the execution time, but on the other hand also significantly decreases storage requirements. For profile I (encryption only) we chose this option, but for profile II (decryption only) things are different. For decryption first the last round key has to be computed with the regular key schedule using the regular S-box  <span class="math">S</span> . The last round key then can be used to calculate the round keys backwards for which the  <span class="math">S^{-1}</span>  S-box is required. Hence, for decryption an on-the-fly key schedule would require to implement the regular key schedule and its inverse. Furthermore both S-boxes  <span class="math">S</span>  and  <span class="math">S^{-1}</span>  have to be stored. Our implementation results of both variants revealed that the pre-computation approach yields smaller program code (948 B) compared to the on-the-fly variant (1022 B). Therefore we implemented profile II with key pre-computation.</p>

    <p class="text-gray-300">The 61 bit left rotation of the key schedule now is implemented in a FOR loop, while the counter XOR and the S-box look-up are identical to the speed optimized version. The XOR between a round key byte and the appropriate state byte is implemented in a loop.</p>

    <p class="text-gray-300">For size optimization we chose to implement the S-box as a byte array of <span class="math">16</span> entries. The output of this <span class="math">S_{4\\times 8}</span> called S-box is given by the output value of the present S-box (lower nibble) with the higher nibble padded with 0x0:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S_{4\\times 8}(x)=0x0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The S-box look-up of all eight state bytes is realized in a loop for both the encryption and the decryption routine.</p>

    <p class="text-gray-300">For the size optimized version we resigned to use assembly code. Instead we used the arithmetic representation of the permutation layer <span class="math">P(i)</span> and its inverse <span class="math">P^{-1}(i)</span> as it was described in Section 4.3.3:</p>

    <p class="text-gray-300">\\[ P(i)=\\left\\{\\begin{array}[]{ll}i\\cdot 16\\mod 63,&i\\in\\{0,\\ldots,62\\}\\\\ 63,&i=63.\\end{array}\\right. \\] (5.1) \\[ P^{-1}(i)=\\left\\{\\begin{array}[]{ll}i\\cdot 4\\mod 63,&i\\in\\{0,\\ldots,62\\}\\\\ 63,&i=63.\\end{array}\\right. \\] (5.2)</p>

    <p class="text-gray-300">We used a loop to permute all bits of the state according to Equations 5.1 and 5.2. Finally, we advised GCC to compile with the -Os option, which aggressively optimizes the code for minimal size, e.g. by not unrolling any loop.</p>

    <h5 id="sec-101" class="text-base font-semibold mt-4">Performance results</h5>

    <p class="text-gray-300">Table 5.10 summarizes our implementation results and provides details about all implemented profiles. We compare the implementation results of profile V (speed optimized implementation of encryption and decryption) to other software implementations in Table 5.11. As one can see, our present-80 implementation is about <span class="math">11</span>% faster than the one published in <em>[68]</em> but still significantly slower than the AES or IDEA implementation from the same publication. Also the code size of our implementation is larger than the code size of present and IDEA but smaller than AES.</p>

    <h4 id="sec-102" class="text-lg font-semibold mt-6">5.4.4 Software implementations on a 16-Bit microcontroller</h4>

    <p class="text-gray-300">These implementations can be downloaded free of charge from the website http://www.lightweightcrypto.org/present.</p>

    <h5 id="sec-103" class="text-base font-semibold mt-4">16 bit target platform and development environment</h5>

    <p class="text-gray-300">We chose the Infineon C167CR microcontroller as the target <span class="math">16</span>-bit platform <em>[111]</em> due to its widespread usage in the embedded systems community. Figure 5.12(a) depicts a top-level view of the complete architecture (on the left) as well as a more detailed view to the CPU architecture (on the right). The C167 architecture combines design elements of RISC as well CISC features and consists of <span class="math">32</span> KB to <span class="math">128</span> KB mask-programmable ROM, <span class="math">2</span> KB of internal RAM (IRAM) and <span class="math">2</span> KB extension RAM (XRAM). All memories (as well as the I/O ports) share the same address space, therefore the C167 microcontroller has a Von Neumann memory architecture. Beside the <span class="math">16</span>-bit arithmetic and logic unit (ALU), the C167CR features dedicated</p>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">Table 5.10: Performance results of PRESENT-80 on the 8 bit ATmega163 microcontroller.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">enc/dec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">opt. goal</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Profile</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ROM [bytes]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RAM [bytes]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles/bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput @4MHz [Kbps]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">speed</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">1,494</td>

            <td class="px-3 py-2 border-b border-gray-700">272</td>

            <td class="px-3 py-2 border-b border-gray-700">10,089</td>

            <td class="px-3 py-2 border-b border-gray-700">157.64</td>

            <td class="px-3 py-2 border-b border-gray-700">25.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">2,398</td>

            <td class="px-3 py-2 border-b border-gray-700">528</td>

            <td class="px-3 py-2 border-b border-gray-700">9,595</td>

            <td class="px-3 py-2 border-b border-gray-700">149.92</td>

            <td class="px-3 py-2 border-b border-gray-700">26.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">II</td>

            <td class="px-3 py-2 border-b border-gray-700">854</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">646,272</td>

            <td class="px-3 py-2 border-b border-gray-700">10,098</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

            <td class="px-3 py-2 border-b border-gray-700">1,474</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">646,166</td>

            <td class="px-3 py-2 border-b border-gray-700">10,096</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">speed</td>

            <td class="px-3 py-2 border-b border-gray-700">III</td>

            <td class="px-3 py-2 border-b border-gray-700">1,532</td>

            <td class="px-3 py-2 border-b border-gray-700">280</td>

            <td class="px-3 py-2 border-b border-gray-700">10,310</td>

            <td class="px-3 py-2 border-b border-gray-700">161.1</td>

            <td class="px-3 py-2 border-b border-gray-700">24.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">2,398</td>

            <td class="px-3 py-2 border-b border-gray-700">528</td>

            <td class="px-3 py-2 border-b border-gray-700">9,820</td>

            <td class="px-3 py-2 border-b border-gray-700">153.44</td>

            <td class="px-3 py-2 border-b border-gray-700">26.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">IV</td>

            <td class="px-3 py-2 border-b border-gray-700">948</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">634,823</td>

            <td class="px-3 py-2 border-b border-gray-700">9,919</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

            <td class="px-3 py-2 border-b border-gray-700">1,474</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">634,614</td>

            <td class="px-3 py-2 border-b border-gray-700">9,916</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">better is:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">more</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5.11: Comparison of software implementations of ciphers on different 8-bit micro controllers.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key Size [bit]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Block Size [bit]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc. [Cycles/ Block]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T'put at 4MHz [Kbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dec. [Cycles/ Block]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Code Size [byte]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SRAM Size [byte]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  PRESENT  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">profile V [68]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9,595</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">26.7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9,820</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,398</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">528</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Hardware Oriented Block Ciphers  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DES [68]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">56</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8,633</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">29.6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8,154</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4,314</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HIGHT [68]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">2,964</td>

            <td class="px-3 py-2 border-b border-gray-700">80.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2,964</td>

            <td class="px-3 py-2 border-b border-gray-700">5,672</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Software Oriented Block Ciphers  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AES [68]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6,637</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">77.1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7,429</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,606</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">224</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TEA [68]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">6,271</td>

            <td class="px-3 py-2 border-b border-gray-700">40.8</td>

            <td class="px-3 py-2 border-b border-gray-700">6,299</td>

            <td class="px-3 py-2 border-b border-gray-700">1,140</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SEA [68]</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">9,654</td>

            <td class="px-3 py-2 border-b border-gray-700">39.7</td>

            <td class="px-3 py-2 border-b border-gray-700">9,654</td>

            <td class="px-3 py-2 border-b border-gray-700">2,132</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Software Oriented Stream Ciphers  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Salsa20 [68]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">512</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">18,400</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">111.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N/A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,452</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">280</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5.4. Software Implementations</p>

    <p class="text-gray-300">!<a href="img-34.jpeg">img-34.jpeg</a> (a) The C166 16 bit microcontroller.</p>

    <p class="text-gray-300">!<a href="img-35.jpeg">img-35.jpeg</a> (b) The C166 CPU core. Figure 5.12: Architecture of the C166 microcontroller, source: [111].</p>

    <p class="text-gray-300">special function registers (SFR), a separate multiply and dive unit and a barrel shifter. In conjunction with its four stage instruction pipeline this allows to execute most of the instructions within one clock cycle. It is noteworthy that—independent of the shifting amount—all shift and rotate instructions can be executed in one machine cycle. The C167CR requires a voltage supply between  <span class="math">4.5\\mathrm{V}</span>  and  <span class="math">5.5\\mathrm{V}</span>  and its maximum operating frequency is between  <span class="math">25\\mathrm{MHz}</span>  and  <span class="math">33\\mathrm{MHz}</span> . Its current consumption depends on the operating frequency and can be calculated for active  <span class="math">(I_{DD})</span>  and for idle  <span class="math">(I_{ID})</span>  mode by the following equations:</p>

    <div class="my-4 text-center"><span class="math-block">I _ {D D} = 1 5 + 2. 5 \\cdot f</span></div>

    <div class="my-4 text-center"><span class="math-block">I _ {I D} = 1 0 + f</span></div>

    <p class="text-gray-300">where  <span class="math">f</span>  denotes the frequency in MHz. In power down mode the current consumption is  <span class="math">I_{PD} = 50\\mu \\mathrm{A}</span> . The interested reader is referred to the data sheet [111] and the instruction set manual [108] for further details about the C167 microcontroller.</p>

    <p class="text-gray-300">We used Altiums Tasking VX-Toolset v2.2r3 [3], which is integrated into the Eclipse framework [222]. It features a debugger (Crossview Pro) and a high speed simulator for C/C++, assembly and mixed code. There are four optimization levels available:</p>

    <p class="text-gray-300">Level 0 no optimization,</p>

    <p class="text-gray-300">Level 1 optimize without affecting debug-ability,</p>

    <p class="text-gray-300">Level 2 optimize, this is the default level and</p>

    <p class="text-gray-300">Level 3 maximum optimization.</p>

    <p class="text-gray-300">There are different memory models: near, far, (segmented) huge and huge. Out of these alternatives the near memory model results in the fastest code, because it does not access Flash memory, while the far memory model yields the smallest code.</p>

    <p class="text-gray-300">The state is stored as a long long variable that has 64 bits. Since the key has 80 bits, it has to be stored as two long long variable keyhigh and keylow. Though it would have been possible to use a variable type with just 16 bits, we decided to use the long long variable, because this is advantageous for the 61 bit rotation of the key schedule. The S-box of the key</p>

    <p class="text-gray-300">schedule <span class="math">S_{4\\times 64}</span> is realized as a look-up table with <span class="math">16</span> entries, each of which is <span class="math">64</span> bits wide. The S-box output is the most significant nibble, while the remainder of the output is padded with zeros, i.e.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S_{4\\times 64}(x)=S(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0x00000000000000.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For speed optimization we have implemented present-80 with key pre-computation. For profiles I (encryption only) and V (encryption and decryption) we merged the S-layer and the P-layer into a single look-up. For this purpose the divide-and-conquer approach (see Section 5.4.3) has been applied and <span class="math">8</span> new look-up tables have been computed. Since each table outputs <span class="math">64</span> bits the memory requirement for the merged S/P-layer is <span class="math">8\\cdot 2^{8}\\cdot 64=16</span>K bytes. The look-up values are concatenated by an OR operation. For profile III (decryption only) however it is not possible to merge the inverse S-layer and the inverse P-layer, due to the reverse execution order.</p>

    <h5 id="sec-105" class="text-base font-semibold mt-4">Size optimized implementation</h5>

    <p class="text-gray-300">For size optimization it is wise to use on-the-fly key scheduling in order to save memory of the round keys. We use on-the-fly key scheduling for profiles II and VI, while for profile IV we use pre-computation (see Section 5.4.3). Since we operate on <span class="math">64</span> bit variables (long long) the <span class="math">61</span> bit left rotation can be performed within one instruction. Another difference compared to the speed optimized version is the usage of a <span class="math">4\\times 16</span> S-box <span class="math">S_{4\\times 16}</span> which in this case gives the following output:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S_{4\\times 16}(x)=0x000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">S_{4\\times 16}</span> is used both for the key schedule as well a for the data path of the size optimized version, hence the P-layer has to be implemented separately. Similar to the code size optimized <span class="math">8</span>-bit implementations (see Section 5.4.3), we use the arithmetic representation of the P-layer for profiles II, IV and VI.</p>

    <h5 id="sec-106" class="text-base font-semibold mt-4">Performance results</h5>

    <p class="text-gray-300">Table 5.12 shows the implementation results for the Infineon C166 <span class="math">16</span>-bit microcontroller. Interestingly implementation figures of all profiles are significantly worse on a <span class="math">16</span>-bit platform compared to an <span class="math">8</span>-bit platform.</p>

    <h4 id="sec-107" class="text-lg font-semibold mt-6">5.4.5 Software implementations on a 32-Bit CPU</h4>

    <p class="text-gray-300">These implementations can be downloaded free of charge from the website http://www.lightweightcrypto.org/present.</p>

    <p class="text-gray-300">5.4. Software Implementations</p>

    <p class="text-gray-300">Table 5.12: Performance results of PRESENT-80 on the 16 bit C166 microcontroller.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">enc/dec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">opt. goal</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Profile</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HEX code [Kbytes]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles/bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput @4MHz [Kbps]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">speed</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">45.9</td>

            <td class="px-3 py-2 border-b border-gray-700">19,460</td>

            <td class="px-3 py-2 border-b border-gray-700">304.06</td>

            <td class="px-3 py-2 border-b border-gray-700">13.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">92.2</td>

            <td class="px-3 py-2 border-b border-gray-700">19,464</td>

            <td class="px-3 py-2 border-b border-gray-700">304.13</td>

            <td class="px-3 py-2 border-b border-gray-700">13.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">II</td>

            <td class="px-3 py-2 border-b border-gray-700">8.17</td>

            <td class="px-3 py-2 border-b border-gray-700">1,439,296</td>

            <td class="px-3 py-2 border-b border-gray-700">22,489</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

            <td class="px-3 py-2 border-b border-gray-700">9.67</td>

            <td class="px-3 py-2 border-b border-gray-700">1,442,556</td>

            <td class="px-3 py-2 border-b border-gray-700">22,540</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">speed</td>

            <td class="px-3 py-2 border-b border-gray-700">III</td>

            <td class="px-3 py-2 border-b border-gray-700">51.9</td>

            <td class="px-3 py-2 border-b border-gray-700">33,354</td>

            <td class="px-3 py-2 border-b border-gray-700">521.16</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">92.2</td>

            <td class="px-3 py-2 border-b border-gray-700">33,352</td>

            <td class="px-3 py-2 border-b border-gray-700">521.13</td>

            <td class="px-3 py-2 border-b border-gray-700">7.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">IV</td>

            <td class="px-3 py-2 border-b border-gray-700">8.44</td>

            <td class="px-3 py-2 border-b border-gray-700">1,328,714</td>

            <td class="px-3 py-2 border-b border-gray-700">20,716</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

            <td class="px-3 py-2 border-b border-gray-700">9.67</td>

            <td class="px-3 py-2 border-b border-gray-700">1,332,062</td>

            <td class="px-3 py-2 border-b border-gray-700">20,813</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">better is:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">more</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We used Microsoft Visual Studio 2008 Professional Edition [155] as the integrated development environment. Visual Studio features a compiler and a debugger as well as outstanding documentation by the MSDN library. The compiler has several optimization goals, which are bundled to two options: 01 for minimal size and 02 for maximum speed. The implementation was done on a laptop PC equipped with 512 MB RAM and an Intel Pentium III M processor, clocked at 1,600 MHz.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similar to the speed optimized 16-bit implementations (profiles I, III, V, see Section 5.4.4) we stored the 80-bit key in two 64-bit variables (int 64) in order to exploit performance benefits in the 61-bit key schedule rotation. Also similar to the 16-bit implementations, the S-box in the key schedule is realized as a  <span class="math">4 \\times 16</span>  S-box with 64-bit output values that consist of the S-box lookup value which is padded with 15 zeros to the right, i.e.  $S_{4 \\times 64}(x) = S(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0x00000000000000<span class="math"> . The S-box and permutation of the datapath have been merged and the divide-and-conquer approach has been applied with  </span>k = 8<span class="math">  (see Section 5.4.3) for profiles I and V. As we have pointed out for the 16-bit implementation (see Section 5.4.4) it is not possible to merge S-box and permutation for the decryption routine. For the 32-bit implementation however it is possible to exploit an interesting property of the permutation layer. As described in Section 4.7 it is possible to re-arrange the S-boxes of the datapath such that the permutation layer actually consists of four instances of a permutation layer  </span>P_{16}(x)<span class="math">  that permutes only 16 bits (see Figure 4.6(b)). Now it is possible to merge 4 adjacent S-boxes and one instance of the reduced permutation layer (see Figure 5.13) into a new look-up table  </span>SP_{16 \\times 16} = P_{16}(S(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(x))<span class="math"> .  </span>SP_{16}<span class="math">  has  </span>2^{16}<span class="math">  64-bit entries. As one can see, the major benefit is that the expensive permutation layer  </span>P<span class="math">  (or better  </span>P'<span class="math"> ) now only every second round has to be processed, which leads to an estimated clock cycle reduction of  </span>25\\%$ . However, since every second round key has to be re-ordered as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Chapter 5. Implementation Results of PRESENT</p>

    <p class="text-gray-300">!<a href="img-36.jpeg">img-36.jpeg</a> Figure 5.13: Re-ordering and merging of S-boxes with the permutation layer.</p>

    <p class="text-gray-300">!<a href="img-37.jpeg">img-37.jpeg</a></p>

    <p class="text-gray-300">well, the saving is less. Figure 5.13 depicts details of the re-ordering and the merging of the S-boxes with the permutation layer.</p>

    <p class="text-gray-300">Finally, we advised the compiler to use the /02 option for the speed optimized profiles I, III and V.</p>

    <p class="text-gray-300">For profiles II, IV and VI we implemented the key schedule similar to the 16-bit size optimized implementation. However, since we operate on 64-bit variables (int64) we use the  <span class="math">4 \\times 64</span>  S-box  <span class="math">S_{4 \\times 64}</span>  which was introduced above. The permutation layer was implemented using the arithmetic description (see Section 4.3.3). Furthermore we advised the compiler to use the /01 option for the code size optimized profiles II, IV and VI.</p>

    <p class="text-gray-300">Table 5.13 summarizes the implementation results of all variants for the 32-bit Pentium III. We derived the memory requirements from the file size of the assembly file which is created by the compiler. For each profile we measured 100,000 times the required clock cycles with the RDTSC command. Out of the 100,000 values we chose the minimum to keep external influences of the PC (such as network card activity etc.) to a minimum.</p>

    <p class="text-gray-300">Korte provides a PRESENT plugin for Microsofts .NET framework [133]. He also implemented a GUI based implementation of PRESENT in Microsoft Silverlight for educational purposes. Figure 5.14 depicts selected screenshots of his implementation. Oosterlynck implemented PRESENT in Python. Both the .NET and the python implementations can be downloaded free of charge from the website www.lightweightcrypto.org/present.</p>

    <p class="text-gray-300">5.4. Software Implementations</p>

    <p class="text-gray-300">Table 5.13: Performance results of PRESENT-80 on the 32 bit Pentium III CPU.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">enc/dec</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">opt. goal</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Profile</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">src code [Kbytes]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles/bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput @1GHz [Mbps]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">enc</td>

            <td class="px-3 py-2 border-b border-gray-700">speed</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">67.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1,037</td>

            <td class="px-3 py-2 border-b border-gray-700">16.2</td>

            <td class="px-3 py-2 border-b border-gray-700">61.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">1,669</td>

            <td class="px-3 py-2 border-b border-gray-700">1,082</td>

            <td class="px-3 py-2 border-b border-gray-700">16.9</td>

            <td class="px-3 py-2 border-b border-gray-700">59.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">II</td>

            <td class="px-3 py-2 border-b border-gray-700">4.1</td>

            <td class="px-3 py-2 border-b border-gray-700">64,012</td>

            <td class="px-3 py-2 border-b border-gray-700">1,000.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">74,593</td>

            <td class="px-3 py-2 border-b border-gray-700">1,166</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">dec</td>

            <td class="px-3 py-2 border-b border-gray-700">speed</td>

            <td class="px-3 py-2 border-b border-gray-700">III</td>

            <td class="px-3 py-2 border-b border-gray-700">1,628</td>

            <td class="px-3 py-2 border-b border-gray-700">1,443</td>

            <td class="px-3 py-2 border-b border-gray-700">22.5</td>

            <td class="px-3 py-2 border-b border-gray-700">44.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">V</td>

            <td class="px-3 py-2 border-b border-gray-700">1,669</td>

            <td class="px-3 py-2 border-b border-gray-700">1,445</td>

            <td class="px-3 py-2 border-b border-gray-700">22.6</td>

            <td class="px-3 py-2 border-b border-gray-700">44.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">size</td>

            <td class="px-3 py-2 border-b border-gray-700">IV</td>

            <td class="px-3 py-2 border-b border-gray-700">4.5</td>

            <td class="px-3 py-2 border-b border-gray-700">63,651</td>

            <td class="px-3 py-2 border-b border-gray-700">994.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">VI</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">75,399</td>

            <td class="px-3 py-2 border-b border-gray-700">1,178</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">better is:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">less</td>

            <td class="px-3 py-2 border-b border-gray-700">more</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5.14: Screenshots of selected implementations of PRESENT. !<a href="img-38.jpeg">img-38.jpeg</a> (a) The educational Silverlight implementation of (b) The .NET plugin of PRESENT within the crypto framework.</p>

    <p class="text-gray-300">!<a href="img-39.jpeg">img-39.jpeg</a></p>

    <p class="text-gray-300">5.5 Conclusions</p>

    <p class="text-gray-300">In this Chapter we have explored implementations of present on a wide variety of different platforms, ranging from ASICs and FPGAs, over hardware-software co-design approaches to plain software implementations. The serialized ASIC implementation constitutes with <span class="math">1,000</span> GE the smallest published ASIC implementation of a cryptographic algorithm with a reasonable security level. Also the FPGA-implementation leads to a very compact result (<span class="math">202</span> slices), while providing a maximum frequency of <span class="math">254</span> MHz. ASIC and FPGA figures highlight that though present was designed with a minimal hardware footprint in mind, <em>i.e.</em> targeted for low-cost devices such as RFIDs, present is also well suited for high-speed and high-throughput applications. Especially its hardware efficiency, <em>i.e.</em> the throughput per slice or GE, respectively, is noteworthy. Furthermore, interestingly the old-fashioned Boolean minimization tool <em>espresso</em> lead to an FPGA implementation that was significantly smaller than a standard LUT based implementation.</p>

    <p class="text-gray-300">If we only consider crypto cores in a HW/SW co-design environment, the energy consumption of present seems to be not so promising compared to the AES. However, if we also take the I/O commuication overhead between the microcontroller and the co-processor into account, present is more energy efficient and also the power and area (<span class="math">7</span> <em>times</em> smaller) requirements of present are very low compared to the AES. Together with the gained speed-up factor of <span class="math">44.6</span> for a HW/SW co-design approach compared to a plain software implementation, these figures underline presents suitability for low-area and low-cost hardware implementations.</p>

    <p class="text-gray-300">On the software side we exploited the lightweight structure of present and especially its <span class="math">4</span>-bit S-boxes by implementing present on a <span class="math">4</span>-bit microcontroller. Due to the low-power nature of the ATAM893-D microcontroller it is also thinkable that <span class="math">4</span>-bit microcontroller will be employed in low-cost RFID tags. To the best of our knowledge up to now there are no implementation results of cryptographic algorithms for <span class="math">4</span>-bit microcontrollers published. In this Chapter we have closed this gap and provided the first implementation results of this kind. We therefore presented a proof-of-concept that state-of-the-art cryptography is feasible on ultra-constrained <span class="math">4</span>-bit microcontrollers. Our implementation draws a current of <span class="math">6.7\\mu</span>A at a supply voltage of <span class="math">1.8</span>V and a frequency of <span class="math">500</span> KHz. Together with the observation that the processing of one data block requires less than <span class="math">200</span> ms we conclude that this implementation is interesting for passively powered RFID tags. In this Chapter we also provided implementation figures for present with different optimization goals (speed or code size) for <span class="math">8</span>-, <span class="math">16</span>- and <span class="math">32</span>-bit processors. We also showed that the regular structure of the permutation layer of present can be exploited to obtain a faster implementation by re-ordering the S-boxes.</p>

    <p class="text-gray-300">6 Lightweight Hash Functions</p>

    <p class="text-gray-300">In this Chapter lightweight hash functions are investigated. First, the work is motivated in Section 6.1 and related work is treated in Section 6.2. Then our design decisions are presented in Section 6.3 and subsequently information about general hash function constructions are given in Section 6.4. Since current hash functions of dedicated design are either too large or broken, we first consider hash functions that are built around block ciphers. In particular we use the compact block cipher present (see Sections 4 and 5) as a building block and we consider the implementation of a range of hash functions offering <span class="math">64</span>-bit (see Section 6.5) and <span class="math">128</span>-bit outputs (Section 6.6) using established techniques. We also consider hash functions that offer larger outputs and we highlight some design directions along with their potential hardware footprint in Section 6.7. Finally, the Chapter is concluded in Section 6.8. Please note that parts of this chapter are based on joint work with Andrey Bogdanov, Gregor Leander, Christof Paar, Matt Robshaw and Yannick Seurin. Especially the design and security assessment of DM-present-80, DM-present-128, H-present-128 and C-present-192 contain significant contributions from Matt Robshaw and Yannick Seurin, whereas Andrey Bogdanov and Gregor Leander significantly contributed to the design of PROP-1 and PROP-2.</p>

    <h3 id="sec-113" class="text-xl font-semibold mt-8">6.1 Motivation</h3>

    <p class="text-gray-300">With RFID tags on consumer items, the potential for wired-homes, and large-scale sensor networks becoming a reality, we are on the threshold of a pervasive computing environment. But along with these new applications come new, and demanding, security challenges. The cryptographic research community has been quick to identify some of the issues, and device authentication and privacy have received considerable attention. As a result a variety of new protocols have been proposed and in many of them, particularly ones intended to preserve user privacy and to anonymize tag interactions, it is assumed that a cryptographic hash function will be used on the tag.</p>

    <p class="text-gray-300">However, which hash function might be used in practice is rarely identified. Looking at dedicated hash functions from the last 20 years, we have become used to their impressive hashing speed (though this is a view that we might have to change in the future). This fast throughput might lead some designers to believe that hash functions are “efficient” in other regards and that they can be routinely used in low-cost environments. This is a mistake, a point that was convincingly made in a paper by Feldhofer and Rechberger <em>[72]</em>. Generally speaking, current hash functions are not at all suitable for constrained environments. They require significant amounts of state and the operations in current dedicated designs are not hardware friendly. This is not surprising since modern hash functions were designed with 32-bit processors in mind, but it means that very few RFID-oriented protocols appealing to a hash function could ever be used on a modestly-capable tag.</p>

    <p class="text-gray-300">In this Chapter we consider RFID tag-enabled applications and the use of hash functions in RFID protocols. We then turn our attention to the design of hash functions and we explore</p>

    <p class="text-gray-300">whether a block cipher makes an appropriate starting point for a compact hash function instead of a dedicated design.</p>

    <p class="text-gray-300">In Sections 6.5 and 6.6 we instantiate lightweight hash functions using literature-based constructions and the compact block cipher present <em>[33]</em>. This allows us to implement a range of representative constructions that, for their given parameter sets, are the most compact hash functions available today. In Section 6.7 we then look at some challenging problems in designing hash functions with greater hash output lengths. While the paper reveals positive results, our work also serves to highlight the difficult issue of compact hash functions; we therefore close the paper with problems for future research.</p>

    <p class="text-gray-300">To consider the efficiency of our proposals, we implemented two different architectures, i.e. round-based and serialized, for each proposal in VHDL. We describe these architectures and the implementation results in the corresponding subsection in detail. For functional and post-synthesis simulation we used Mentor Graphics Modelsim SE PLUS 6.3a <em>[92]</em> and Synopsys DesignCompiler version Z-2007.03-SP5 <em>[219]</em> was used to synthesize the designs to the Virtual Silicon (VST) standard cell library UMCL18G212T3, which is based on the UMC L180 0.18<span class="math">\\mu</span>m 1P6M logic process and has a typical voltage of <span class="math">1.8</span> Volt <em>[233]</em>. We used Synopsys Power Compiler version Z-2007.03-SP5 <em>[220]</em> to estimate the power consumption of our implementations. For synthesis and for power estimation we advised the compiler to use a clock frequency of <span class="math">100</span> KHz, which is a widely used operating frequency for RFID applications. For the power simulation an appropriate wire-load model was chosen that fits to the size of the actual design. We give details about this in the corresponding subsection.</p>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">6.2 Related Work</h3>

    <p class="text-gray-300">For RFID tag-based applications, the protocols in question are often focused on authentication or on providing some form of anonymity and/or privacy <em>[5, 14, 61, 77, 100, 142, 176]</em>. These protocols use a cryptographic hash function and it is assumed that these can be efficiently implemented in hardware. However, Feldhofer and Rechberger have pointed out that current hash functions are not all suited for use in hardware constrained environments, because the area and power requirements of standard hash functions, e.g. MD4 <em>[197]</em>, MD5 <em>[196]</em>, SHA-1 <em>[166]</em> and SHA-256 <em>[166]</em> are too large <em>[72]</em>. In particular, their implementations require <span class="math">7,350</span> GE and <span class="math">456</span> cycles for MD4, <span class="math">8,400</span> GE and <span class="math">612</span> cycles for MD5, <span class="math">8,120</span> and <span class="math">1,274</span> cycles for SHA-1 and <span class="math">10,868</span> GE and <span class="math">1,128</span> cycles for SHA-256. This is far away from the <span class="math">2,000</span> GE barrier and so they identified the design of new lightweight hash functions as future work.</p>

    <p class="text-gray-300">A new lightweight compression function named MAME was proposed by Yoshida et al. at CHES 2007 <em>[95]</em>. Though their hardware implementation requires only <span class="math">96</span> clock cycles, the area requirement remains still too large with <span class="math">8,100</span> GE. At FSE 2008 Shamir proposed a new MAC named SQUASH that is tailored for RFID tags <em>[207]</em>. There have been no ASIC implementations published so far, but Gosset et al. have assessed the hardware efficiency of SQUASH on a Xilinx Virtex-4 FPGA device <em>[90]</em>. Their area optimized implementation of SQUASH with an output size of <span class="math">32</span> bits requires <span class="math">63,250</span> clock cycles and <span class="math">377</span> slices and <span class="math">104,114</span> clock cycles and <span class="math">378</span> slices for a <span class="math">64</span>-bit output variant. These figures are translated into <span class="math">6,303</span> GE and <span class="math">6,328</span> GE, respectively, by the synthesis tool Xilinx ISE. Please note that the amount of GE derived from a number of slices is typically significantly larger than a plain ASIC implementation would</p>

    <p class="text-gray-300">require and also depends on the target device. Consequently Gosset <em>et al.</em> proposed to see their results as an upper bound.</p>

    <p class="text-gray-300">Recent attacks on standard hash functions <em>[236, 237]</em> have triggered a public competition for a new hash algorithm by NIST <em>[165]</em>. However, since the aim is to design a general purpose hash algorithm, it is no wonder that the requirements do not fit well for constrained environments such as passive RFID tags. Especially the digest sizes of <span class="math">224</span>- to <span class="math">512</span>-bit will most probably lead to high area requirements for any candidates.</p>

    <h3 id="sec-115" class="text-xl font-semibold mt-8">6.3 Design decisions</h3>

    <p class="text-gray-300">Informally, a cryptographic hash function <span class="math">H</span> takes an input of variable size and returns a hash value of fixed length while satisfying the properties of preimage resistance, second preimage resistance, and collision resistance <em>[153]</em>. For a hash function with <span class="math">n</span>-bit output, compromising these should require <span class="math">2^{n}</span>, <span class="math">2^{n}</span>, and <span class="math">2^{n/2}</span> operations respectively. These properties make hash functions very appealing in a range of protocols. For tag-based applications, the protocols in question are often focused on authentication or on providing some form of anonymity and/or privacy <em>[5, 14, 61, 77, 100, 142, 176]</em>. However, some estimates suggest that no more than <span class="math">2,000</span> GE are available for security in low-cost RFID tags <em>[116]</em> but implementation results show that the hash functions available are unsuitable in practice <em>[72]</em>. When we consider what we need from a hash function in an RFID tag-based application the following issues can be identified:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In tag-based applications we are unlikely to hash large amounts of data. Most tag protocols require that the hash function processes a challenge, an identifier, and/or perhaps a counter. The typical input is usually much less than 256 bits.</li>

      <li>In many tag-based applications we do not need the property of <em>collision resistance</em>. Most often the security of the protocol depends on the <em>one-way</em> property. In certain situations, therefore, it is safe to use hash functions with smaller hash outputs.</li>

      <li>Applications will (typically) only require moderate security levels. Consequently 80-bit security, or even less, may be adequate. This is also the position taken in the eSTREAM project <em>[175]</em>. An algorithm should be chosen according to the relevant security level and in deployment, where success depends on every dollar and cent spent, there is no point using extra space to get a 256-bit security level if 64-bit security is all that is required.</li>

      <li>While the physical space for an implementation is often the primary consideration, the peak and average power consumption are also important. The time for a computation will matter if we consider how a tag interacts with higher-level communication and anti-collision protocols.</li>

      <li>Some protocols use a hash function to build a <em>message authentication code</em> (MAC), often by appealing to the HMAC construction <em>[164]</em>. When used as a MAC a number of interesting issues arise such as choosing an appropriate key length and understanding whether keys will be changed, something that will almost certainly be impossible in most tag-enabled applications. There might also be the possibility of side-channel analysis on the MAC. However, such attacks will rarely be worthwhile for cheap tag-enabled applications and we do not consider this issue further.</li>

    </ol>

    <p class="text-gray-300">Taking account of these considerations allows us to make some pragmatic choices. There will be applications that just require one-wayness and the application may only require 80-bit or</p>

    <p class="text-gray-300">64-bit security. Note that this is the view adopted by Shamir in the proposal squash for use in RFID tags <em>[207]</em>. For other applications we might like to see 80-bit security against collision attacks.</p>

    <h3 id="sec-116" class="text-xl font-semibold mt-8">6.4 Background on hash function constructions</h3>

    <p class="text-gray-300">Hash functions in use today are built around the use of a compression function and appeal to the theoretical foundations laid down by Merkle and Damgård <em>[55, 154]</em>. The compression function <span class="math">h</span> has a fixed-length input, consisting of a chaining variable and a message extract, and gives a fixed-length output. A variety of results <em>[58, 114, 118]</em> have helped provide a greater understanding of this construction and while there are some limitations there are some countermeasures <em>[24]</em>. Since our goal is to obtain representative performance estimates, we will not go into the details of hash function designs. Instead we will assume that our hash function uses a compression function in an appropriate way and that the compression function takes as input some words of chaining variable, represented by <span class="math">H_{i}</span>, and some words of (formatted) message extract, represented by <span class="math">M_{i}</span>. We then restrict our focus to the cost of implementing the compression function.</p>

    <p class="text-gray-300">In the hash function literature it is common to distinguish between two popular ways of building a compression function. The first is to use a compression function of a dedicated design and the second is to use an established, and trusted, block cipher.</p>

    <h4 id="sec-117" class="text-lg font-semibold mt-6">6.4.1 Dedicated hash function constructions</h4>

    <p class="text-gray-300">The separation of dedicated constructions from block cipher-based constructions tends to disguise the fact that even dedicated hash functions like SHA-1 <em>[163]</em> and MD5 <em>[196]</em> are themselves built around a block cipher. Remove the feed-forward from compression functions in the MD-family and we are left with a reversible component that can be used as a block cipher (such as SHACAL <em>[98]</em> in the case of SHA-1). However, the underlying block cipher we are left with is rather strange and has a much larger-than-normal block and key size combination. The problem with dedicated hash functions is that recent attacks <em>[236, 237]</em> have shown that there is much to learn in designing block ciphers with such strange parameter sizes. There is therefore some value in considering approaches that use a more “classical” block cipher as the basis for a compression function.</p>

    <h4 id="sec-118" class="text-lg font-semibold mt-6">6.4.2 Block cipher constructions</h4>

    <p class="text-gray-300">The use of a block cipher as a building block in hash function design <em>[49]</em> is as old as DES <em>[159]</em>. The topic has been recently revisited and Black et al. <em>[30]</em> have built on the work of Preneel <em>[187]</em> to present a range of secure <span class="math">2n</span>- to <span class="math">n</span>-bit compression functions built around an <span class="math">n</span>-bit block cipher that takes an <span class="math">n</span>-bit key. Among these are the well-known Davies-Meyer, Matyas-Meyer-Oseas, and Miyaguchi-Preneel constructions.</p>

    <p class="text-gray-300">A hash function with an output of <span class="math">n</span> bits can only offer a security level of <span class="math">2^{n}</span> operations for pre-image and second pre-image attacks and <span class="math">2^{n/2}</span> operations against finding collisions. While a security level of 128-bit is typical for mainstream applications, 80-bit security is often a reasonable target for RFID tag-based applications. Either way, there is a problem since the</p>

    <p class="text-gray-300">hash functions we need cannot always be immediately constructed out of the block ciphers we have to hand. This is not a new problem. But it is not an easy one to solve either, and there has been mixed success in constructing <span class="math">2n</span>-bit hash functions from an <span class="math">n</span>-bit block cipher <em>[36, 49, 129, 136, 137, 188, 189]</em>. While limitations have been identified in many constructions, work by Hirose <em>[103, 105]</em> has identified a family of double-block-length hash functions that possess a proof of security. These use block ciphers with a key length that is twice the block length. Such a property is shared by aes-256 <em>[161]</em> and present-128 <em>[33]</em> and so in Section 6.6 we consider the performance of an Hirose-style construction instantiated using present-128.</p>

    <p class="text-gray-300">When it comes to providing a replacement for SHA-1, the parameter sizes involved provide a difficult challenge. If we are to use a 64-bit block cipher like present-128, then in arriving at a hash function with an output of at least 160 bits we need a construction that delivers an output three times the block size (thereby achieving a 192-bit hash function). There are no “classical” constructions for this and so Sections 6.7.1 and 6.7.3 illustrate two possible design directions. These give representative constructions and we use them to gauge the hardware requirements of different design approaches. We hope that this will be of interest to future hash function designers.</p>

    <h3 id="sec-119" class="text-xl font-semibold mt-8">6.5 Compact hash functions with a digest size of 64 bits</h3>

    <p class="text-gray-300">In this section we will consider two approaches to compact hashing with a digest size of <span class="math">64</span> bits when we use the block cipher present <em>[33]</em> as a building block. We start with the description and security analysis of dm-present-80 and dm-present-128 in Section 6.5.1. Subsequently, we describe different implementation results of both proposals in Section 6.5.2 (dm-present-80) and Section 6.5.3 (dm-present-128).</p>

    <h4 id="sec-120" class="text-lg font-semibold mt-6">6.5.1 Description of dm-present-80 and dm-present-128</h4>

    <p class="text-gray-300">There are a variety of choices for building a 64-bit hash function from a 64-bit block cipher. We will illustrate these with the Davies-Meyer mode where a single 64-bit chaining variable <span class="math">H_{i}</span> is updated using a message extract <span class="math">M_{i}</span> according to the computation <span class="math">H_{i}^{\\prime}=E(H_{i},M)\\oplus H_{i}</span>.</p>

    <p class="text-gray-300">In our case <span class="math">E</span> denotes encryption with either present-80 or present-128, see Figure 6.1. Such hash functions will only be of use in applications that require the one-way property and 64-bit security. At each iteration of the compression function 64 bits of chaining variable and 80 bits (resp. 128 bits) of message-related input are compressed. Therefore the two proposals dm-present-80 and dm-present-128 provide a simple trade-off between space and throughput. We also provide figures for a serial and parallel implementation of present, see Table 6.5.</p>

    <p class="text-gray-300">While we have focused on using Davies-Meyer, it is important to note that these figures are a good indication of the cost for any single block-length hash function construction. If one prefers to implement Matyas-Meyer-Oseas or Miyaguchi-Preneel based on present (instead of Davies-Meyer) then the cost of dm-present-80 will be a reasonable guide. Moving away from present to a different block cipher will almost certainly cause an increase to the space required for an implementation.</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <p class="text-gray-300">!<a href="img-40.jpeg">img-40.jpeg</a> Figure 6.1: Compression function for the 64-bit hash functions DM-PRESENT-80 and DM-PRESENT-128.</p>

    <p class="text-gray-300">We first describe the round-based implementation DM-PRESENT-80/64 with a 64-bit datapath and then subsequently the serialized implementation DM-PRESENT-80/4 with a 4-bit datapath.</p>

    <p class="text-gray-300">Figure 6.3 depicts the architecture of the DM-PRESENT-80 module with a datapath of 64 bits and its input and output signals are depicted in Figure 6.2(a). As one can see this architecture consists of the 64-bit gated register Temp, a finite state machine (FSM), a 64-bit XOR and a round-based PRESENT-80 implementation. The latter one contains a 64-bit and an 80-bit register, a 64-bit XOR, 17 S-boxes (16 in the datapath and one in the key schedule), the P-Layer and a 61-bit rotation and the 5-bit counter XOR in the key schedule.</p>

    <p class="text-gray-300">We used the finite state machine (FSM) depicted in Figure 6.2(b) to control our implementation of DM-PRESENT-80 with a datapath of 64 bits. As can be seen the FSM consists of the six states S_IDLE, S_INIT_TEMP, S_INIT_DATA, S_PRESENT, S_H_UPDATE, and S_DONE. Upon resetting the ASIC the FSM starts in the S_IDLE state. The following two states S_INIT_TEMP and S_INIT_DATA both last for one clock cycle and do not have a condition for transition, i.e. after one clock cycle the FSM transitions to the following state. During the S_INIT_TEMP state the initial chaining variable  <span class="math">H</span>  is loaded into the Temp register and during the S_INIT_DATA state it is forwarded to the State register. The S_PRESENT state lasts for 31 cycles, during which a complete PRESENT encryption is performed. After the encryption the FSM transitions to the S_H_UPDATE state, where the result of the PRESENT encryption is XORed with the chainig variable  <span class="math">H</span>  and the result is stored in the Temp register. This takes one clock cycle and if all message chunks are processed the FSM transitions to the S_DONE state, otherwise to the S_INIT_DATA state. During the S_DONE state the done signal is active indicating that the correct result is ready.</p>

    <p class="text-gray-300">It takes 33 clock cycles to process one message chunk of 80 bits. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  this is equivalent to a throughput of 242.42 Kbps. After synthesis our implementation requires</p>

    <p class="text-gray-300">6.5. Compact hash functions with a digest size of 64 bits</p>

    <p class="text-gray-300">!<a href="img-41.jpeg">img-41.jpeg</a> (a) Input and output signals.</p>

    <p class="text-gray-300">!<a href="img-42.jpeg">img-42.jpeg</a> (b) Finite state machine.</p>

    <p class="text-gray-300">!<a href="img-43.jpeg">img-43.jpeg</a> Figure 6.2: I/O and FSM of the DM-PRESENT-80 module with a datapath of 64 bits. Figure 6.3: Architecture of the DM-PRESENT-80 module with a datapath of 64 bits.</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">module</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">area (GE)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">%</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-80</td>

            <td class="px-3 py-2 border-b border-gray-700">data state</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">17.35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

            <td class="px-3 py-2 border-b border-gray-700">20.24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">P-layer</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">7.73</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key state</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">21.69</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">61 bit rotation</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-box</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">1.27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">counter XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.59</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">overhead</td>

            <td class="px-3 py-2 border-b border-gray-700">temp state</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">17.35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">7.73</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">other (e.g. FSM)</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">6.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sum</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2,213</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6.1: Area requirements of components of DM-PRESENT-80/64.</p>

    <p class="text-gray-300">2, 213 GE and a breakdown of its components is given in Table 6.1. As one can see more than half of the area is required for storage of the state (56.4%). The hardware efficiency is 109.5 bps/GE. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  and with the suggested wire-load model of 10,000 GE the estimated power consumption is  <span class="math">6.28\\mu \\mathrm{W}</span> , which is equivalent to  <span class="math">3.49\\mu \\mathrm{A}</span> .</p>

    <p class="text-gray-300">The architecture of a serialized implementation with a datapath of 4 bits is depicted in Figure 6.4 and its input and output signals are shown in Figure 6.5(a). This architecture comprises of a gated register Temp with 4- and 64-bit inputs and outputs, a 4-bit XOR, a 4-bit MUX, and a serialized PRESENT-80 implementation. The latter one consists of a gated register with 4- and 64-bit input and output, one gated register with 4- and 80-bit input and output, two 4-bit MUXes, a 4-bit XOR, two S-boxes (each one for the datapath and the key schedule), the P-Layer, a 61-bit rotation, the 5-bit counter XOR in the key schedule and a finite state machine (FSM). Please note that this serialized PRESENT-80 implementation is similar to the one described in Section 5.1.1.</p>

    <p class="text-gray-300">We used the finite state machine (FSM) depicted in Figure 6.5(b) to control our implementation of DM-PRESENT-80/4. As can be seen the FSM consists of the seven states S_IDLE, S_INIT_DATA, S_INIT_KS, S_SBOX, S_PLAYER_KS, S_FINISHED, and S_DONE. Upon resetting the ASIC the FSM starts in the S_IDLE state and transitions after one clock cycle into the next state S_INIT_DATA. During each of the next 16 cycles a 4-bit chunk of the 64-bit chaining variable  <span class="math">H</span>  is loaded into both the Temp and the State register. At the same time also the 64 MSB of the 80-bit message  <span class="math">M</span>  are loaded into the Key register. Then the FSM transitions to the S_INIT_KS state, which loads the remaining 16 bits of the message  <span class="math">M</span>  into the Key register. Thus it takes another 4 clock cycles before the FSM transitions to the next state S_SBOX. During each of the 16 cycles of this state, a 4-bit chunk of the state is XORed with a 4-bit chunk of the roundkey, and then subsequently processed by the S-box. Once all 64 bits are processed, the FSM transitions to the S_PLAYER_KS state. During this state the whole State is permuted by the P-layer, and the Key register is updated with the new roundkey within one clock cycle. Since PRESENT features 31 complete rounds (i.e. a round consisting of key XOR, S-box lookup and permutation), the FSM returns back to the S_SBOX state 31 times. At the</p>

    <p class="text-gray-300">6.5. Compact hash functions with a digest size of 64 bits</p>

    <p class="text-gray-300">!<a href="img-44.jpeg">img-44.jpeg</a> Figure 6.4: Architecture of the DM-PRESENT-80 module with a datapath of 4 bits.</p>

    <p class="text-gray-300">!<a href="img-45.jpeg">img-45.jpeg</a> (a) Input and output signals.</p>

    <p class="text-gray-300">!<a href="img-46.jpeg">img-46.jpeg</a> (b) Finite state machine. Figure 6.5: I/O and FSM of the DM-PRESENT-80 top module with a datapath of 4 bits.</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <p class="text-gray-300">!<a href="img-47.jpeg">img-47.jpeg</a> Figure 6.6: Input and output signals of the DM-PRESENT-128 top module with a datapath of 64 bits.</p>

    <p class="text-gray-300"><span class="math">32^{nd}</span>  time the FSM transitions to the S_FINISHED state. Within each of its 16 clock cycles it computes both the final round of PRESENT and then the XOR addition of the chaining variable  <span class="math">H</span>  and the output of PRESENT, 4 bits at a time. Also the done signal is set to 1 to indicate that the result is output. Finally, the FSM transitions to the S_DONE state in order to set the done signal to 0.</p>

    <p class="text-gray-300">It takes 547 clock cycles to process one message chunk of 80 bits. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  this is equivalent to a throughput of 14.63 Kbps. After synthesis our implementation requires 1,600 GE. Unfortunately a detailed breakdown of its components is not possible in this case, because the synthesis result does not provide the required information. However, our serialized architecture of DM-PRESENT-80 consists of a serialized PRESENT-80 (1,075 GE), as described in Section 5.1.1), the Temp register (384 GE), a 4-bit MUX (9 GE), and a 4-bit XOR (11 GE), which sums up to 1,479 GE. The missing 121 GE may be required by the more complex FSM. The hardware efficiency is 9.1 bps/GE. At a clock frequency of  <span class="math">100\\mathrm{kHz}</span>  and with the suggested wire-load model of 10,000 GE DM-PRESENT-80/4 consumes  <span class="math">1.83\\mu \\mathrm{W}</span>  which is equivalent to  <span class="math">1.02\\mu \\mathrm{A}</span> .</p>

    <p class="text-gray-300">First we describe the round-based implementation DM-PRESENT-128/64 with a 64-bit datapath and then subsequently the serialized implementation DM-PRESENT-128/4 with a 4-bit datapath.</p>

    <p class="text-gray-300">Figure 6.7 depicts the architecture of the DM-PRESENT-128 module with a datapath of 64 bits and its input and output signals are depicted in Figure 6.6. Similar to the DM-PRESENT-80 implementation with a 64 bits datapath it contains a 64-bit gated register Temp, a finite state machine (FSM) and a 64 bit XOR. The main difference lies in the round-based PRESENTimplementation, which in this case is PRESENT-128 and not PRESENT-80. It consists of a 64-bit and a 128-bit register, a 64-bit XOR, 18 S-boxes (16 in the datapath and two in the key schedule), the P-Layer and a 61-bit rotation and the 5-bit counter XOR in the key schedule.</p>

    <p class="text-gray-300">We used the same finite state machine (FSM) as for DM-PRESENT-80/64 (see Figure 6.2(b)) and refer to the description above for further details. Similar to the DM-PRESENT-80/64 implementation it also takes 33 clock cycles to process one message chunk. Contrary to the DM-PRESENT-80/64 implementation one message chunk now has 128 bits instead of 80 bits. Therefore the throughput at a frequency of  <span class="math">100\\mathrm{kHz}</span>  is a factor of  <span class="math">\\frac{128}{80} = 1.6</span>  higher and now achieves 387.88</p>

    <p class="text-gray-300">6.5. Compact hash functions with a digest size of 64 bits</p>

    <p class="text-gray-300">!<a href="img-48.jpeg">img-48.jpeg</a> Figure 6.7: Architecture of the DM-PRESENT-128 module with a datapath of 64 bits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">module</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">area (GE)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">%</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-128</td>

            <td class="px-3 py-2 border-b border-gray-700">data state</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">15.18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

            <td class="px-3 py-2 border-b border-gray-700">17.71</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">P-layer</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">6.76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key state</td>

            <td class="px-3 py-2 border-b border-gray-700">768</td>

            <td class="px-3 py-2 border-b border-gray-700">30.36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">61 bit rotation</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">2.21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">counter XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">overhead</td>

            <td class="px-3 py-2 border-b border-gray-700">temp state</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">15.18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">6.76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">other (e.g. FSM)</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sum</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2,530</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6.2: Area requirements of components of DM-PRESENT-128/64.</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <p class="text-gray-300">!<a href="img-49.jpeg">img-49.jpeg</a> Figure 6.8: Input and output signals of the DM-PRESENT-128 top module with a datapath of 4 bits.</p>

    <p class="text-gray-300">!<a href="img-50.jpeg">img-50.jpeg</a> Figure 6.9: Architecture of the DM-PRESENT-128 module with a datapath of 4 bits.</p>

    <p class="text-gray-300">Kbps. After synthesis our implementation requires 2,530 GE and a breakdown of its components is given in Table 6.2. As one can see more than  <span class="math">60\\%</span>  of the area is required for storage of the state. Compared to the plain PRESENT-128 core the implementation of DM-PRESENT-128/64 requires 689 additional GE. The hardware efficiency is 153.3 bps/GE. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  and with the suggested wire-load model of 10,000 GE DM-PRESENT-128/64 has an average power consumption of  <span class="math">7.49\\mu \\mathrm{W}</span> , which relates to an average current consumption of  <span class="math">4.16\\mu \\mathrm{A}</span> .</p>

    <p class="text-gray-300">The architecture of a serialized implementation with a datapath of 4 bits is depicted in Figure 6.9 and its input and output signals are shown in Figure 6.8. Similar to the DM-PRESENT-80/4 implementation this architecture comprises of a gated register Temp with 4- and 64-bit inputs ad outputs, a 4-bit XOR and one 4-bit MUX. The main difference lies in the serialized PRESENT implementation, which in this case is PRESENT-128 and not PRESENT-80. It consists of a gated register with 4- and 64-bit input and output, one gated register with 4- and 128-bit input and output, three 4-bit MUXes, a 4-bit XOR, two S-boxes, the P-Layer, a 61-bit rotation, the 5-bit counter XOR in the key schedule and a finite state machine (FSM).</p>

    <p class="text-gray-300">6.6. Compact hash functions with a digest size of 128 bits</p>

    <p class="text-gray-300">!<a href="img-51.jpeg">img-51.jpeg</a> Figure 6.10: Finite state machine of the DM-PRESENT-128 module with a datapath of 4 bits.</p>

    <p class="text-gray-300">We used a slightly modified version of the finite state machine (FSM) for DM-PRESENT-80/4 to control our implementation of DM-PRESENT-128/4, see Figure 6.10. As can be seen, the FSM consists of the same seven states, i.e. S_IDLE, S_INIT_DATA, S_INIT_KS, S_SBOX, S_PLAYER_KS, S_FINISHED, and S_DONE. The only difference occurs during the S_INIT_KS state. Since now PRESENT with a 128-bit key is used, it requires 12 more cycles to load the whole key into the Key register. Therefore the FSM transitions after 16 clock cycles to the next state and not after just four clock cycles. The remainder of the FSM is identical and we refer to the description above for more details.</p>

    <p class="text-gray-300">It takes 559 clock cycles to process one message chunk of 128 bits. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  this is equivalent to a throughput of 22.9 Kbps. After synthesis our implementation requires 1,886 GE. Unfortunately a detailed breakdown of its components is not possible in this case, because the synthesis result does not provide the required information. However, our serialized architecture of DM-PRESENT-128 consists of a serialized PRESENT-128, the Temp register (384 GE), a 4-bit MUX (9 GE), and a 4-bit XOR (11 GE), which sums up to 1,886 GE. The hardware efficiency is 12.1 bps/GE. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  and with the suggested wireload model of 10,000 GE DM-PRESENT-128/4 has an average power consumption of  <span class="math">2.94\\mu \\mathrm{W}</span> , which relates to an average current consumption of  <span class="math">1.63\\mu \\mathrm{A}</span> .</p>

    <p class="text-gray-300">When designing a 128-bit hash function from the 64-bit output block cipher PRESENT, we have to appeal to so-called double-block-length hash function constructions. Natural candidates are MDC-2 [49] and Hirose's constructions [103, 105]. These schemes possess security proofs in the ideal cipher model, where the underlying block cipher is modeled as a family of random permutations, one permutation being chosen independently for each key. However, MDC-2 is not an ideal construction [214] and so we base our 128-bit hash function H-PRESENT-128 on the construction studied in [105]. We start with a description and security analysis of our proposal H-PRESENT-128 in Section 6.6.1. Subsequently, we present different implementation results for the proposal in Section 6.6.2.</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <p class="text-gray-300">!<a href="img-52.jpeg">img-52.jpeg</a> Figure 6.11: Compression function for the 128-bit hash function H-PRESENT-128.</p>

    <p class="text-gray-300">The scheme H-PRESENT-128 is illustrated in Figure 6.11. The compression function takes as input two 64-bit chaining variables and a 64-bit message extract, denoted by the triple  <span class="math">(H_{1},H_{2},M)</span> , and outputs the pair of updated chaining variables  <span class="math">(H_1&#x27;,H_2&#x27;)</span>  according to the computation</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H _ {1} ^ {\\prime} = E _ {H _ {2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M} (H _ {1}) \\oplus H _ {1} \\quad \\text {and} \\quad H _ {2} ^ {\\prime} = E _ {H _ {2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M} (H _ {1} \\oplus c) \\oplus H _ {1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">E</span>  denotes PRESENT-128 and  <span class="math">c</span>  is a non-zero constant that needs to be fixed [40]. Thus the chaining variable  $H_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{2}$  is 128 bits long and 64 bits of message-related input are hashed per iteration.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hirose showed that, in the ideal cipher model, an adversary has to make at least  <span class="math">2^{n}</span>  queries to the cipher in order to find a collision with non-negligible advantage, where  <span class="math">n</span>  is the block size of the cipher. It is possible to make the same kind of analysis for preimage resistance (see proof of Theorem 4 in [104]) and to show that any adversary has to make at least  <span class="math">2^{2n}</span>  queries to the cipher to find a preimage. As for Section 6.5 our implementation results are presented for both a parallel and serial implementation of PRESENT-128, see Table 6.5. These results should be viewed as indicative of the cost of a double-block-length construction using PRESENT. Since only one key schedule needs to be computed per iteration of the compression function, the Hirose construction is probably one of the most efficient constructions of this type, e.g. in the case of PRESENT around 1,000 GE can be saved in this way.</p>

    <p class="text-gray-300">First we describe the architecture and the implementation results of a round-based H-PRESENT-128 with a 128-bit datapath and subsequently the architecture of a serialized H-PRESENT-128 with an 8-bit datapath.</p>

    <p class="text-gray-300">6.6. Compact hash functions with a digest size of 128 bits</p>

    <p class="text-gray-300">!<a href="img-53.jpeg">img-53.jpeg</a> (a) Input and output signals.</p>

    <p class="text-gray-300">!<a href="img-54.jpeg">img-54.jpeg</a> (b) Finite state machine.</p>

    <p class="text-gray-300">!<a href="img-55.jpeg">img-55.jpeg</a> Figure 6.12: I/O and FSM of the H-PRESENT-128 module with a datapath of 128 bits. Figure 6.13: Architecture of the H-PRESENT-128 module with a datapath of 128 bits.</p>

    <p class="text-gray-300">Figure 6.13 depicts the architecture of the round-based H-PRESENT-128 implementation with a datapath of 128 bits. The H-PRESENT-128/128 implementation consists of a gated register with 64-bit input and output for the chaining variable (384 GE), two 64-bit MUXes (298 GE), two 64-bit XOR gates (342 GE), a finite state machine, a modified PRESENT-128 core and an additional PRESENT data path (1,000 GE). Note that since the constant  <span class="math">c</span>  was chosen as 0x00000000 00000001, the XOR with the constant is actually only a NOT gate, which requires 0.5 GE.</p>

    <p class="text-gray-300">We used the finite state machine (FSM) depicted in Figure 6.12(b) to control our implementation of H-PRESENT-128/128. As can be seen, the FSM consists of the three states S_IDLE, S_INIT and S_PRESENT. Upon resetting the ASIC the FSM starts in the S_IDLE state. During the following state S_INIT the chaining variable  <span class="math">h_1</span>  is stored in the Temp register. In the same clock cycle also the second chaining variable  <span class="math">h_2</span>  and the first message chunk  <span class="math">M</span>  are concatenated and loaded into the Key register. The FSM directly transitions without any condition</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">module</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">area (GE)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">%</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-128</td>

            <td class="px-3 py-2 border-b border-gray-700">2× data state</td>

            <td class="px-3 py-2 border-b border-gray-700">853</td>

            <td class="px-3 py-2 border-b border-gray-700">20.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2× S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">896</td>

            <td class="px-3 py-2 border-b border-gray-700">21.07</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2× P-layer</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2× key XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">8.04</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key state</td>

            <td class="px-3 py-2 border-b border-gray-700">768</td>

            <td class="px-3 py-2 border-b border-gray-700">18.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">61-bit rotation</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">1.32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">counter XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">overhead</td>

            <td class="px-3 py-2 border-b border-gray-700">temp state</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">9.03</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">342</td>

            <td class="px-3 py-2 border-b border-gray-700">8.04</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">MUXes</td>

            <td class="px-3 py-2 border-b border-gray-700">298</td>

            <td class="px-3 py-2 border-b border-gray-700">7.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">other (e.g. FSM)</td>

            <td class="px-3 py-2 border-b border-gray-700">301</td>

            <td class="px-3 py-2 border-b border-gray-700">7.08</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sum</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4,253</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6.3: Area requirements of components of H-PRESENT-128/128.</p>

    <p class="text-gray-300">to the S_PRESENT state. The S_PRESENT state lasts for 32 cycles, during which a complete PRESENT encryption (including the final round) is performed. Both outputs of the two PRESENT datapathes are XORed with the initial chaining variable  <span class="math">h_1</span>  and serve as the new chaining variables  <span class="math">h_1&#x27;</span>  and  <span class="math">h_2&#x27;</span> .  <span class="math">h_1&#x27;</span>  is stored in the Temp register and  <span class="math">h_2&#x27;</span>  is concatenated with the next message chunk and stored in the Key register. Once all message chunks are processed the done signal is set to 1 indicating that the correct result is ready and the FSM transitions to the S_IDLE state.</p>

    <p class="text-gray-300">It takes 32 clock cycles to process one message chunk of 64 bits. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  this is equivalent to a throughput of 200 Kbps. After synthesis our implementation requires 4,256 GE and a breakdown of its components is given in Table 6.3. As one can see more than half of the area is required for storage of the state  <span class="math">(56.4\\%)</span> . The hardware efficiency is 109.5 bps/GE. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  and with the suggested wire-load model of 10,000 GE H-PRESENT-128/128 has an average power consumption of  <span class="math">8.09\\mu \\mathrm{W}</span> , which relates to an average current consumption of  <span class="math">4.49\\mu \\mathrm{A}</span> .</p>

    <p class="text-gray-300">Figure 6.14 depicts the architecture of the serialized H-PRESENT-128 implementation with a datapath of 8 bits. The H-PRESENT-128/8 implementation basically consists of the DM-PRESENT-128/4 implementation (1,886 GE, see above for details) with some additional logic. In particular this is a gated register with 4-bit and 64-bit input and output for the second PRESENT state (384 GE), two 4-bit MUXes (20 GE), two 4-bit XOR gates  <span class="math">(22\\mathrm{GE})^3</span>  and an additional 4-bit MUX for the S-box input (10 GE).</p>

    <p class="text-gray-300">We used the same finite state machine (FSM) as for DM-PRESENT-128/4 (see Figure 6.10) to control our implementation of H-PRESENT-128/8, hence we refer to the description above for</p>

    <p class="text-gray-300">6.6. Compact hash functions with a digest size of 128 bits</p>

    <p class="text-gray-300">!<a href="img-56.jpeg">img-56.jpeg</a> Figure 6.14: Architecture of the H-PRESENT-128 module with a datapath of 8 bits.</p>

    <p class="text-gray-300">!<a href="img-57.jpeg">img-57.jpeg</a> Figure 6.15: Input and output signals of the H-PRESENT-128 top module with a datapath of 8 bits.</p>

    <p class="text-gray-300">more details. It takes <span class="math">559</span> clock cycles to process one data chunk of <span class="math">64</span> bits. Since dm-present-128/4 processes data chunks of <span class="math">128</span> bits while requiring the same amount of clock cycles, h-present-128/8 gains exactly half of its throughput, <em>i.e.</em> <span class="math">11.45</span> Kbps at a frequency of <span class="math">100</span> KHz. After synthesis our implementation requires <span class="math">2,330</span> GE. Again for this architecture a detailed breakdown of its components is not possible. The hardware efficiency is <span class="math">4.9</span> bps/GE. At a frequency of <span class="math">100</span> KHz and with the suggested wire-load model of <span class="math">10,000</span> GE h-present-128/8 has an average power consumption of <span class="math">6.44</span> <span class="math">\\mu</span>W, which relates to an average current consumption of <span class="math">3.58</span> <span class="math">\\mu</span>A.</p>

    <h3 id="sec-132" class="text-xl font-semibold mt-8">6.7 Compact hash functions with a digest size of <span class="math">\\geq</span> 160 bits</h3>

    <p class="text-gray-300">In some cases tag-enabled applications might need collision-resistance at a security level of <span class="math">2^{80}</span> operations. For this we need a hash output of 160 bits or greater. However, this is where the problems really begin and we consider two directions.</p>

    <p class="text-gray-300">For the first, we continue the approach to consider building a hash function with a hash output greater than 160 bits from present <em>as is</em>. So in Section 6.7.1 we try to use present in this way and, using established results in the literature, we make a proposal. However, at the same time, we use the very same results to demonstrate that this approach is unlikely to be successful, a sentiment that is supported by our implementation results in Section 6.7.2. Instead, for the second direction that is described in Section 6.7.3, we move towards a dedicated hash function though we keep elements of present in our constructions. Our dedicated proposals are deliberately simple and obvious, and in this way we aim to provide some first results on the impact different design choices might have in moving towards a new, compact, hash function.</p>

    <h4 id="sec-133" class="text-lg font-semibold mt-6">6.7.1 Description of c-present-192</h4>

    <p class="text-gray-300">We aim to design a hash function that is based on present and has a digest size of at least <span class="math">160</span> bits. Since present has a 64-bit block size, this means that we are forced to consider a triple-block-length construction and we will obtain a 192-bit hash function. Unfortunately very few designs for <span class="math">l</span>-block length hash function with <span class="math">l\\geq 3</span> have been studied so far. However, Peyrin <em>et al.</em> <em>[179]</em> have identified some necessary conditions for securely combining <em>compression functions</em> to obtain a new compression function with a longer output. We can use these results and so, in the case we consider here, our constituent compression functions will be based around present-128, <em>i.e.</em> we will use dm-present-128 as the building block.</p>

    <p class="text-gray-300">More background to the construction framework is given in <em>[179]</em>. However, within this framework, efficiency demands that we keep to a minimum the number of compression functions that we need to use, where each compression function is instantiated by dm-present-128. For reasons of simplicity and greater design flexibility we restrict ourselves to processing only a single 64-bit message extract, and so our inputs to c-present-192, where we use C as shorthand for “constructed”, consist of a quadruplet <span class="math">(H_{1},H_{2},H_{3},M)</span> while the output is a triplet <span class="math">(H_{1}^{\\prime},H_{2}^{\\prime},H_{3}^{\\prime})</span>. The compression function c-present-192 is illustrated in Figure 6.16. The output is computed as:</p>

    <p class="text-gray-300"><span class="math">H_{1}^{\\prime}</span> <span class="math">=</span> <span class="math">f^{(1)}(H_{3},H_{1},H_{2})\\oplus f^{(3)}(H_{3}\\oplus M,H_{1},H_{2})\\oplus f^{(5)}(H_{2},H_{3},M)</span> <span class="math">H_{2}^{\\prime}</span> <span class="math">=</span> <span class="math">f^{(1)}(H_{3},H_{1},H_{2})\\oplus f^{(4)}(H_{1},H_{3},M)\\oplus f^{(6)}(H_{1}\\oplus H_{2},H_{3},M)</span> <span class="math">H_{3}^{\\prime}</span> <span class="math">=</span> <span class="math">f^{(2)}(M,H_{1},H_{2})\\oplus f^{(4)}(H_{1},H_{3},M)\\oplus f^{(5)}(H_{2},H_{3},M)</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">6.7. Compact hash functions with a digest size of \\geq 160 bits</p>

    <p class="text-gray-300">!<a href="img-58.jpeg">img-58.jpeg</a> Figure 6.16: Compression function for the 192-bit hash function C-PRESENT-192.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with  $f^{(i)}(A,B,C) = E(A\\oplus c_{i - 1},B\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C)\\oplus A<span class="math">  for different constants  </span>c_{i}<span class="math">  and  </span>E$  denotes encryption with PRESENT-128.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Each inner compression function  <span class="math">f^{(i)}</span>  is built around PRESENT-128 in Davies-Meyer mode, and five non-zero constants  <span class="math">c_{1},\\ldots ,c_{5}</span>  are used to make them independent. The constants were chosen to be linearly independent and of low Hamming weight.</p>

    <p class="text-gray-300">We chose the constants  <span class="math">c_{0}</span>  to  <span class="math">c_{5}</span>  according to the following equation</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = \\left\\{ \\begin{array}{l} 0, i = 0 \\\\ c _ {i} = 2 ^ {i - 1}, 1 \\leq i \\leq 5. \\end{array} \\right.</span></div>

    <p class="text-gray-300">In other words we used the constants  <span class="math">c_{0} = 0 = 00000_{2}</span> ,  <span class="math">c_{1} = 1 = 00001_{2}</span> ,  <span class="math">c_{2} = 2 = 00010_{2}</span> ,  <span class="math">c_{3} = 4 = 00100_{2}</span> ,  <span class="math">c_{4} = 8 = 01000_{2}</span> ,  <span class="math">c_{5} = 16 = 10000_{2}</span> . In a more computer architecture oriented description the non-zero constants  <span class="math">c_{1},\\ldots ,c_{5}</span>  are given by</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} = (0 x 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1) \\ll (i - 1).</span></div>

    <p class="text-gray-300">This construction might seem too complicated, but this is exactly the point we wish to make. The particular set of parameter values that are forced upon us when trying to build a large-output hash function from a small block cipher means that there will be no simple construction. More precisely, work in [179] shows that for any construction that uses a compression function with parameters equivalent to PRESENT-128 along with linear mixing layers to combine chaining variables and intermediate values, at least six compression functions are needed to resist all currently-known generic attacks. We must therefore use at least six independent calls to DM-PRESENT-128, which is attained by our C-PRESENT-192 construction.</p>

    <p class="text-gray-300">In addition, the output mapping should be a <span class="math">(6,3,3)</span> binary linear error-correcting code, while the input mapping must satisfy the following constraints:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Every external output block must depend on all external input blocks, no matter which invertible transformation of the external inputs and outputs is applied.</li>

      <li>Every pair of external input blocks must appear as an identified pair for every invertible combination of external output blocks, where a pair <span class="math">(A,B)</span> is said to be identified when <span class="math">A</span> and <span class="math">B</span> both appear within the internal inputs to some <span class="math">f^{(i)}</span>, and this no matter which invertible transformation of the external inputs is applied.</li>

    </ol>

    <p class="text-gray-300">The input mapping for our representative was selected from among those that satisfy these conditions and that also minimize the number of key schedules used to hash one block of message. By reducing the number of key schedules we increase the performance of the scheme and, potentially, reduce the space required by an implementation. It can be proved that for the parameter sets of interest to us here, the minimal number of key schedules is two.</p>

    <p class="text-gray-300">For the results of Peyrin et al. <em>[179]</em> to hold, the compression functions <span class="math">f^{(i)}</span> have to be ideal compression functions with respect to collision and preimage resistance (that is, finding a collision or a preimage must require on average <span class="math">\\Theta(2^{n/2})</span> and <span class="math">\\Theta(2^{n})</span> evaluations of the function respectively) and must behave independently. Each inner compression function <span class="math">f^{(i)}</span> is built around present-128 in a way similar to the Davies-Meyer mode. That way, the results of Black et al. <em>[30]</em> ensure that, in the ideal cipher model, finding a collision (resp. a preimage) for the compression functions <span class="math">f^{(i)}</span> requires <span class="math">\\Theta(2^{n/2})</span> (resp. <span class="math">\\Theta(2^{n})</span>) queries to the cipher. Hence, in the ideal cipher model, each inner compression function <span class="math">f^{(i)}</span> is ideal in the sense defined above.</p>

    <p class="text-gray-300">Making the six compression functions <span class="math">f^{(i)}</span> independent is not so easy. The most secure way to do this would be to “tweak” the block cipher with e.g. the XE or XEX construction of Rogaway <em>[198]</em>. However, these constructions are only efficient when one has to compute ciphertexts for the same key and many different tweaks, which is not our case. Using any known provably secure construction of a tweakable block cipher for the c-present-192 scheme would imply one supplementary cipher call for each key, thus increasing the number of block cipher calls per message block to eight. Instead we might consider using the same kind of technique that is used in the Hirose construction and we use five constants <span class="math">c_{1},\\ldots,c_{5}</span> to make the six instances of the compression function independent. In the absence of a structural weakness in present this is sufficient for our purposes. Further, we are trying to estimate the space required for a construction of this type and so this approach will help to yield conservative estimates. The constants were chosen to be linearly independent and of low Hamming weight. They are given by <span class="math">\\texttt{c}_{0}=0</span> and <span class="math">\\texttt{c}_{i}=(0\\texttt{x}0000000000000001)\\ll(i-1)</span> for <span class="math">i\\geq 1</span>. While some limitations of this construction follow from <em>[205]</em>, assuming we can consider the inner compression functions independent, Peyrin et al. show that there is no currently-known attack with computational complexity less than brute-force on the larger compression function.</p>

    <h4 id="sec-134" class="text-lg font-semibold mt-6">6.7.2 Implementation results and estimations of c-present-192</h4>

    <p class="text-gray-300">When implementing c-present-192 in a round-based manner, there is a trade-off between storage of intermediate values and additional present datapaths. A completely parallelized approach would require six datapaths (<span class="math">6\\times 840</span> GE <span class="math">=5,040</span> GE, see Section 5.1) and two key schedules (<span class="math">2\\times 1,000</span> GE <span class="math">=2,000</span> GE, see Section 5.1) of present-128, eight <span class="math">64</span>-bit XORs with two inputs (<span class="math">8\\times 64\\times 2.67GE=1,368</span> GE) and three <span class="math">64</span>-bit XORs with three inputs (<span class="math">3\\times 64\\times 4.67</span> GE <span class="math">=896</span> GE). Note that the XOR addition of the constants can be achieved by inverting</p>

    <p class="text-gray-300">the appropriate bit positions. Since we chose five constants that all have Hamming weight <span class="math">1</span>, the area requirement for the XOR addition of the constants is about <span class="math">3</span> GE. In total the minimal requirement for a round-based implementation of c-present-192 would sum up to more than <span class="math">9,300</span> GE and these figures do not even include the finite state machine of the control logic. This is far away from our ideal goal of around <span class="math">2,000</span> GEs and consequently we do not follow this approach any further.</p>

    <p class="text-gray-300">However, following the above stated trade-off, it is possible to sacrifice throughput for the benefit of area savings. Since a present datapath consists of the storage for <span class="math">64</span> bits, the requirements for the S-boxes and the key XOR, we chose to use as few datapaths as possible. In our proposed c-present-192 the key schedule is shared by three present datapaths. In order to benefit from the shared key schedule, at least three present datapaths are required. Therefore, we base our estimations on three serialized present datapaths.</p>

    <p class="text-gray-300">A serialized presentdatapath basically consists of the storage for the state (<span class="math">384</span> GE), the key XOR (<span class="math">11</span> GE) and the S-box (<span class="math">28</span> GE), which sums up to a total gate count of <span class="math">384+11+28=423</span> GE. Besides three presentdatapathes (<span class="math">3\\times 423</span> GE <span class="math">=1,269</span> GE) and one present-128 key schedule (<span class="math">837</span> GE) c-present-192 requires to store at least five additional <span class="math">64</span>-bit temporary values (<span class="math">5\\times 64</span> GE <span class="math">=1,920</span> GE), <span class="math">13</span> <span class="math">4</span>-bit MUXes (<span class="math">13\\times 4\\times 2.33</span> GE <span class="math">=121</span> GE), which would lead to <span class="math">4,150</span> GE. Additionally, several XOR gates and a finite state machine are required, so in total we estimate the area requirements with <span class="math">4,600</span> GE. Such a serialized implementation would require <span class="math">3,338</span> clock cycles for processing one block of <span class="math">64</span> bits, giving it a throughput of <span class="math">1.9</span> Kbps at <span class="math">100</span> KHZ. In total this would lead to a hardware efficiency of <span class="math">0.41</span> bps. From these estimations it becomes clear that also a serialized implementation of c-present-192 requires too much area, mostly because of the huge intermediate storage requirements.</p>

    <h4 id="sec-135" class="text-lg font-semibold mt-6">6.7.3 Dedicated design elements inspired by present</h4>

    <p class="text-gray-300">Hash function design is notoriously difficult and so an interesting first step is to identify some general approaches and to understand their security and performance trade-offs. In this section we describe the results of some prototyping which tests a range of approaches and provides good background to our ongoing work. Our basic premise is to stay close to the design elements of present and to modify the design so as to give a block cipher with a much larger block size. We then adapt the key schedule in two alternative ways with the first being a natural proposal and the second having strong similarities to Whirlpool <em>[17]</em>. We give implementation results for both approaches.</p>

    <p class="text-gray-300">Our schemes will continue to be based on the Davies-Meyer (DM) scheme <span class="math">H_{i+1}=E(H_{i},M_{i})\\oplus H_{i}</span> though the form of our encryption function <span class="math">E</span> will now change. In general, the encryption function <span class="math">E</span> can be described as:</p>

    <p class="text-gray-300"><span class="math">E:\\mathbb{F}_{2}^{n}\\times\\mathbb{F}_{2}^{k}\\to\\mathbb{F}_{2}^{n}\\enspace,</span> <span class="math">E:\\textsc{plaintext}\\times\\textsc{key}\\mapsto\\textsc{ciphertext}.</span></p>

    <p class="text-gray-300">The detailed description of present can be found in Section 4. At a top-level we can write the <span class="math">r</span>-round encryption of the plaintext state as:</p>

    <p class="text-gray-300">for <span class="math">i=1</span> to <span class="math">r</span> do state <span class="math">\\leftarrow</span> state <span class="math">\\oplus</span> eLayer(key,<span class="math">i</span>) state <span class="math">\\leftarrow</span> sBoxLayer(state) state <span class="math">\\leftarrow</span> pLayer(state) key <span class="math">\\leftarrow</span> genLayer(key,<span class="math">i</span>) end for state <span class="math">\\leftarrow</span> state <span class="math">\\oplus</span> eLayer(key,<span class="math">r+1</span>),</p>

    <p class="text-gray-300">where eLayer describes how a subkey is combined with a cipher state, sBoxLayer and pLayer describe how the state evolves, and genLayer is used to describe the generation of the next subkey.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When used in the DM mode we recast the plaintext and ciphertext as hash function state and use the (formatted) message extract as the key. For ease of design we will choose the parameters <span class="math">k</span> and <span class="math">n</span> so that $k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n<span class="math"> and </span>4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n$, and both our proposals will have the following (unmodified) structure:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for <span class="math">i=1</span> to <span class="math">r</span> do state <span class="math">\\leftarrow</span> state <span class="math">\\oplus</span> eLayer(message,<span class="math">i</span>) state <span class="math">\\leftarrow</span> sBoxLayer(state) state <span class="math">\\leftarrow</span> pLayer(state) message <span class="math">\\leftarrow</span> genLayer(message,<span class="math">i</span>) end for state <span class="math">\\leftarrow</span> state <span class="math">\\oplus</span> eLayer(message,<span class="math">r+1</span>).</p>

    <p class="text-gray-300">The following building blocks are unchanged between the two proposals and are merely generalizations of the present structure to larger 160-bit block sizes.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>sBoxLayer: This denotes use of the present <span class="math">4\\times 4</span>-bit S-box <span class="math">S</span> and it is applied <span class="math">n/4</span> times in parallel.</li>

      <li>pLayer: This is an extension of the present bit-permutation and moves bit <span class="math">i</span> of state to bit position <span class="math">P(i)</span>, where</li>

    </ol>

    <p class="text-gray-300">\\[ P(i)=\\left\\{\\begin{array}[]{ll}i\\cdot n/4\\mod n-1,&\\text{if }i\\in\\{0,\\ldots,n-2\\}\\\\ n-1,&\\text{if }i=n-1.\\end{array}\\right. \\]</p>

    <p class="text-gray-300">It is in the specification of genLayer, which transforms the message of length <span class="math">k</span> from round-to-round, and eLayer : <span class="math">\\mathbb{F}_{2}^{k}\\rightarrow\\mathbb{F}_{2}^{n}</span>, that describes how the message extract is combined with cipher state, that the two proposals differ.</p>

    <p class="text-gray-300">PROP-1. For ease of comparison with present we keep exactly the same 80-bit key input and the same 80-bit key schedule. Thus we modify a <span class="math">160</span>-bit chaining variable using an <span class="math">80</span>-bit message input and, to make an implementation estimate, we use <span class="math">64</span> rounds. This is equivalent to the parameters <span class="math">n=160</span>, <span class="math">k=80</span>, and <span class="math">r=64</span>. The sBoxLayer and pLayer are as above and eLayer and genLayer are described as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. eLayer(message,<span class="math">i</span>)= message$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">genLayer(message,</span>i$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>genLayer(message,<span class="math">i</span>) is defined as the 80-bit key schedule of present. Thus, message is rotated by 61-bit positions to the left, the left-most four bits are passed through the present S-box, and the round counter <span class="math">i</span> is exclusive-ored with some bits of message.</li>

    </ol>

    <p class="text-gray-300">In words, we use the key schedule of present-80 exactly as is and at each round we use what would be two successive 80-bit round keys. At each round the key schedule is updated only</p>

    <p class="text-gray-300">once, so the same subkey is used once on the right-hand side and, in the following round, on the left-hand side.</p>

    <p class="text-gray-300">PROP-2. For the second proposal, we consider a structure that has some similarity to Whirlpool. Our parameter set is <span class="math">n=160</span> and <span class="math">k=160</span> which allows us to use a longer message extract at each iteration of the compression function. For prototyping and implementation estimates we set <span class="math">r=80</span>. The building blocks eLayer and genLayer are specified as:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>eLayer(MESSAGE, <span class="math">i</span>)=MESSAGE</li>

      <li>genLayer(MESSAGE, <span class="math">i</span>)=pLayer(sBoxLayer(MESSAGE <span class="math">\\oplus</span> <span class="math">i</span>)), being just a copy of the data path with round constant addition.</li>

    </ol>

    <p class="text-gray-300">In words, we imagine that our message extract is a 160-bit key and we process the key in a key-schedule that is identical to the encryption process.</p>

    <p class="text-gray-300">Our proposed design elements are not intended to be specifications. Nevertheless, some preliminary analysis follows from the simple structures proposed. In particular, for a fixed message block and two different chaining values we can apply Theorem 1 of <em>[33]</em> directly. This states that at least 10 active S-boxes are involved in any 5-round differential characteristic. However, for the more important case of two different message blocks, the analysis has to be slightly modified. The following two results on the differential behavior of the proposals can be viewed as a first step towards a deeper analysis:</p>

    <h6 id="sec-136" class="text-base font-medium mt-4">Theorem 6.1.</h6>

    <p class="text-gray-300">Let <span class="math">P^{(3)}_{(\\Delta_{1},\\Delta_{2})\\mapsto\\Delta}</span> be the probability of a differential characteristic over 3 rounds of PROP-1 with <span class="math">\\Delta_{2}\\neq 0</span>, i.e. the probability that</p>

    <p class="text-gray-300"><span class="math">\\text{PROP-1}_{3}(H\\oplus\\Delta_{1},M\\oplus\\Delta_{2})=\\text{PROP-1}_{3}(H,M)\\oplus\\Delta,</span></p>

    <p class="text-gray-300">where PROP-1_{3} denotes three rounds of PROP-1. Then each 3-round differential characteristic of this form has at least 4 active S-boxes and therefore <span class="math">P^{(3)}_{(\\Delta_{1},\\Delta_{2})\\mapsto\\Delta}\\leq 2^{-8}</span>.</p>

    <h6 id="sec-137" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">Let <span class="math">P_{(\\Delta_{1},\\Delta_{2})\\mapsto\\Delta}</span> be the probability of a differential characteristic such that</p>

    <p class="text-gray-300"><span class="math">\\text{PROP-2}(H\\oplus\\Delta_{1},M\\oplus\\Delta_{2})=\\text{PROP-2}(H,M)\\oplus\\Delta</span></p>

    <p class="text-gray-300">for <span class="math">\\Delta_{2}\\neq 0</span>. Then <span class="math">P_{(\\Delta_{1},\\Delta_{2})\\mapsto\\Delta}\\leq 2^{-400}</span> for PROP-2.</p>

    <p class="text-gray-300">Theorem 6.1 indicates that the probability of each 64-round differential characteristic can be upper-bounded by <span class="math">(2^{-8})^{\\frac{64}{3}}\\approx 2^{-170}</span>. This observation as well as Theorem 6.2 show that the differential properties may be strong enough to thwart pre-image, second pre-image and collision attacks for both proposals. Furthermore, Theorem 6.2 indicates that one could probably decrease the number of rounds in PROP-2 without unduly compromising the security. The most appropriate trade-off remains an area of research.</p>

    <h4 id="sec-138" class="text-lg font-semibold mt-6">6.7.4 Estimations of PROP-1 and PROP-2</h4>

    <p class="text-gray-300">We estimated the hardware figures for different architectures when implementing PROP-1 and PROP-2. Our implementation estimates range from a 4-bit width data path (highly serialized) up to a 160-bit width data path which offers one round of processing in one cycle. Since PROP-2 uses a very similar key schedule (i.e. message path) and encryption routine, we can give a further two different implementation options: one with a shared sBoxLayer between the data path and the message path and one with an individual sBoxLayer. The results are summarized in Table 6.4 with the efficiency <em>eff.</em> being measured in bps/GE.</p>

    <p class="text-gray-300">Chapter 6. Lightweight Hash Functions</p>

    <p class="text-gray-300">Table 6.4: Hardware estimations of PROP-1 and PROP-1 using datapath widths from 4 bit to 160 bit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">data path width</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROP-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROP-2 (shared)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROP-2 (ind.)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">area (GE)</td>

            <td class="px-3 py-2 border-b border-gray-700">cycles</td>

            <td class="px-3 py-2 border-b border-gray-700">eff. (Kbps/GE)</td>

            <td class="px-3 py-2 border-b border-gray-700">area (GE)</td>

            <td class="px-3 py-2 border-b border-gray-700">cycles</td>

            <td class="px-3 py-2 border-b border-gray-700">eff. (Kbps/GE)</td>

            <td class="px-3 py-2 border-b border-gray-700">area (GE)</td>

            <td class="px-3 py-2 border-b border-gray-700">cycles</td>

            <td class="px-3 py-2 border-b border-gray-700">eff. (Kbps/GE)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2,520</td>

            <td class="px-3 py-2 border-b border-gray-700">5,282</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">3,010</td>

            <td class="px-3 py-2 border-b border-gray-700">6,481</td>

            <td class="px-3 py-2 border-b border-gray-700">0.82</td>

            <td class="px-3 py-2 border-b border-gray-700">3,020</td>

            <td class="px-3 py-2 border-b border-gray-700">3,281</td>

            <td class="px-3 py-2 border-b border-gray-700">1.62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">2,800</td>

            <td class="px-3 py-2 border-b border-gray-700">1,322</td>

            <td class="px-3 py-2 border-b border-gray-700">4.33</td>

            <td class="px-3 py-2 border-b border-gray-700">3,310</td>

            <td class="px-3 py-2 border-b border-gray-700">1,621</td>

            <td class="px-3 py-2 border-b border-gray-700">2.92</td>

            <td class="px-3 py-2 border-b border-gray-700">3,380</td>

            <td class="px-3 py-2 border-b border-gray-700">821</td>

            <td class="px-3 py-2 border-b border-gray-700">5.77</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">3,170</td>

            <td class="px-3 py-2 border-b border-gray-700">662</td>

            <td class="px-3 py-2 border-b border-gray-700">7.64</td>

            <td class="px-3 py-2 border-b border-gray-700">3,730</td>

            <td class="px-3 py-2 border-b border-gray-700">811</td>

            <td class="px-3 py-2 border-b border-gray-700">5.11</td>

            <td class="px-3 py-2 border-b border-gray-700">3,860</td>

            <td class="px-3 py-2 border-b border-gray-700">411</td>

            <td class="px-3 py-2 border-b border-gray-700">10.09</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">4,270</td>

            <td class="px-3 py-2 border-b border-gray-700">266</td>

            <td class="px-3 py-2 border-b border-gray-700">14.09</td>

            <td class="px-3 py-2 border-b border-gray-700">4,960</td>

            <td class="px-3 py-2 border-b border-gray-700">325</td>

            <td class="px-3 py-2 border-b border-gray-700">9.29</td>

            <td class="px-3 py-2 border-b border-gray-700">5,300</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">18.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">4,830</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">24.73</td>

            <td class="px-3 py-2 border-b border-gray-700">5,730</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">15.29</td>

            <td class="px-3 py-2 border-b border-gray-700">6,420</td>

            <td class="px-3 py-2 border-b border-gray-700">83</td>

            <td class="px-3 py-2 border-b border-gray-700">30.03</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6.5 summarizes our results and compares them to other hash functions and AES-based schemes. When the hash output length is 128 bits or lower, a construction based around PRESENT seems to have potential. Certainly they are far more competitive than current hash functions, the primary reason being that there exist efficient block cipher-based constructions for this size of hash output. Even a larger block cipher such as AES makes for a more compact hash function than current dedicated designs at this security level, though the throughput suffers. Also first estimates of an ASIC implementation of SQUASH indicate significantly higher area requirements while at the same time providing a two orders of magnitude lower throughput.</p>

    <p class="text-gray-300">For the area estimates of the AES-based Davies-Meyer and Hirose schemes we used the smallest known (3,400 GE) AES implementation [71]. We estimated the area requirements for storing one bit to be 8 GE as stated in [71]. For the AES-based Davies-Meyer scheme we assumed that at least one additional register would be required to store the 128-bit value  <span class="math">H_{1}</span>  (1,024 additional GE), summing up to at least 4,400 GE in total.</p>

    <p class="text-gray-300">The AES-based Hirose scheme requires an AES implementation with 256-bit key length. However, no such low-cost implementation has been reported so far. Therefore we estimate the area requirements starting from the Feldhofer et al. [71] implementation with a 128-bit key. At least 128 additional key bits (1,024 GE) have to be stored to achieve an AES implementation with 256 bits key length, summing up to at least 4,400 GE. The Hirose scheme requires two instantiations of the block cipher and the storage of one intermediate value  <span class="math">H_{1}</span> , which has the same size as the block size. All together we estimate the AES-based Hirose scheme to require at least 9,800 GE. The serial variant of C-PRESENT-192 was not implemented, because the figures for the round-based variant and the estimations indicate large area requirements with more than 4,600 GE. In fact this large area requirement for both variants of C-PRESENT-192 was the main reason to look for other constructions such as PROP-1 and PROP-2.</p>

    <p class="text-gray-300">Note that it is not easily possible to compare power consumption of designs implemented in different technologies, hence we did not include these figures in Table 6.5. However, the figures for SHA-256 (15.87  <span class="math">\\mu</span> W) and SHA-1 (10.68  <span class="math">\\mu</span> W) provided by Feldhofer and Rechberger [72] are in the same range as ours.</p>

    <p class="text-gray-300">While compact hash functions are often proposed in protocols for RFID tags, there are currently no sufficiently compact candidates to hand. Here we have explored the possibility of building a hash function out of a block cipher such as PRESENT. We have described hash func</p>

    <p class="text-gray-300">6.8. Conclusion</p>

    <p class="text-gray-300">Table 6.5: The performance of different hash functions based on the direct application of PRESENT. For comparison with our hash functions with 128-bit output we include estimates for the AES-based 128-bit hash function in Davies-Meyer mode. For comparison with MAME we include estimates for the 256-bit hash function built from the AES in Hirose's construction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hash output size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data path size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles per block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput at 100KHz [Kbps]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eff. [bps/GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Logic process</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area [GE]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  64 bit output size  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DM-PRESENT-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">64</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">242.42</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">109.5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18μm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,213</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DM-PRESENT-128</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">387.88</td>

            <td class="px-3 py-2 border-b border-gray-700">153.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">2,530</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">559</td>

            <td class="px-3 py-2 border-b border-gray-700">22.9</td>

            <td class="px-3 py-2 border-b border-gray-700">12.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">1,886</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SQUASH [90]</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">104,114</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">ISE</td>

            <td class="px-3 py-2 border-b border-gray-700">6,328</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  128 bit output size  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H-PRESENT-128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">200</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">47</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18μm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4,253</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MD4 [72]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">456</td>

            <td class="px-3 py-2 border-b border-gray-700">112.28</td>

            <td class="px-3 py-2 border-b border-gray-700">15.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13μm</td>

            <td class="px-3 py-2 border-b border-gray-700">7,350</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MD5 [72]</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">612</td>

            <td class="px-3 py-2 border-b border-gray-700">83.66</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13μm</td>

            <td class="px-3 py-2 border-b border-gray-700">8,400</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DM-AES</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">>1,032</td>

            <td class="px-3 py-2 border-b border-gray-700"><12.4</td>

            <td class="px-3 py-2 border-b border-gray-700"><2.8</td>

            <td class="px-3 py-2 border-b border-gray-700">estimate</td>

            <td class="px-3 py-2 border-b border-gray-700">>4,400</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ≥160 bit output size  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C-PRESENT-192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">108</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">59.26</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7.4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.18μm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8,048</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHA-1 [72]</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1,274</td>

            <td class="px-3 py-2 border-b border-gray-700">40.19</td>

            <td class="px-3 py-2 border-b border-gray-700">4.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35μm</td>

            <td class="px-3 py-2 border-b border-gray-700">8,120</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHA-256 [72]</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1,128</td>

            <td class="px-3 py-2 border-b border-gray-700">45.39</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35μm</td>

            <td class="px-3 py-2 border-b border-gray-700">10,868</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MAME [95]</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">266.67</td>

            <td class="px-3 py-2 border-b border-gray-700">32.9</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18μm</td>

            <td class="px-3 py-2 border-b border-gray-700">8,100</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">H-AES</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">>1,032</td>

            <td class="px-3 py-2 border-b border-gray-700"><12.4</td>

            <td class="px-3 py-2 border-b border-gray-700"><1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">estimate</td>

            <td class="px-3 py-2 border-b border-gray-700">>9,800</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">tions that offer 64- and 128-bit outputs based on current design strategies. For their parameter sets these are the most compact hash function candidates available today. In particular, H-PRESENT-128 requires around 4,000 GE, which is similar to the best known AES implementation and about 50% smaller than the best reported MD5 implementation. At the same time, H-PRESENT-128 requires between 20–30 <em>times</em> fewer clock cycles than compact AES and MD5 implementations, giving it a major time-area advantage.</p>

    <p class="text-gray-300">Obviously 128-bit hash functions are relevant for applications where a security-performance trade-off is warranted. To obtain larger hash outputs there are severe complications and we suspect that dedicated designs could be more appropriate.</p>

    <p class="text-gray-300">Understanding the best trade-offs for the different approaches is not easy. As one can see, all three estimations of PROP-1 and PROP-2 scale nicely, though it seems that PROP-2 is more efficient in terms of throughput per area when compared to PROP-1. On the other hand PROP-1 offers a lower minimal achievable gate count, though at the cost of a higher cycle count. Much would also depend on a thorough security analysis of any final proposal and while some initial analysis suggests the possibility of optimizations to an approach like PROP-2, this is something to explore in future work during the design of an explicit proposal.</p>

    <p class="text-gray-300">Clearly there are many areas of open research, not least the design of very compact hash functions. In parallel, it might also be worth revisiting tag-based protocols that use hash functions to see if the same goals can be achieved in a different way.</p>

    <p class="text-gray-300">7 Lightweight Public-Key Cryptography</p>

    <p class="text-gray-300">In this Chapter first the usage of lightweight public-key cryptography is motivated in Section 7.1 and related work is treated in Section 7.2. Subsequently, a brief introduction to the crypto-GPS identification scheme is given in Section 7.3. Then a prototype board that contains a proof-of-concept ASIC implementation of crypto-GPS is decribed in Section 7.4. The component of the ASIC, three different variants of the crypto-GPS scheme, are described subsequently. First two round-based variants are describe in Section 7.5 and a serialized implementation is detailed in Section 7.6.</p>

    <h3 id="sec-140" class="text-xl font-semibold mt-8">7.1 Motivation</h3>

    <p class="text-gray-300">The automotive production process nowadays is very sophisticated with a widely distributed division of tasks. Consequently it is also referred to as a supply chain <em>[97]</em> or even more precise a supply network. On the different steps in the production process different supplier and sub-supplier deliver components or modules just-in-time (JIT). Some modules, such as dashboards or seats are delivered just-in-sequence (JIS). It is of paramount importance to identify components cheaply and reliably in order to guarantee to have the right part at the right place of the assembly line at the right point in time (JIT) in the right order (JIS). Since many different players are here involved, this kind of scenarios for RFID applications is also referred to as open systems. An overview of potentials and risks for automotive supply-chains that use RFID tags from an economic perspective is provided in <em>[183]</em>. One conclusion is that there are great optimization potentials, but also severe security threats if RFID tags are used in open systems.</p>

    <p class="text-gray-300">The former chapters dealt with symmetric cryptographic primitives, which have the drawback of the key-distribution problem. In closed systems RFID tags, readers and the backend system are controlled by a single player. However, this poses no great difficulty, but for open systems it does. Lightweight public-key cryptography may be suitable to address these problems.</p>

    <h3 id="sec-141" class="text-xl font-semibold mt-8">7.2 Related Work</h3>

    <p class="text-gray-300">There exists a rich literature on low-area implementations of public key cryptography based on elliptic curves (ECC). Comparison of different ECC implementations is not always easy, because the choice of the underlying curve determines both efficiency and security of the algorithm. However, no implementation has been published so far that comes close to the goal of <span class="math">2,000</span> GE, but several publications—with a significantly lower security level than <span class="math">80</span>-bit—exist that are in the range of <span class="math">10,000</span> GE or above <em>[18, 68, 75]</em>. Gaubatz et al. <em>[76]</em> have investigated the hardware efficiency of the NTRUencrypt algorithm <em>[174, 106]</em> with the following parameters <span class="math">(N,p,q)=(167,3,128)</span> that offer a security level of only <span class="math">57</span> bits. Though their implementation requires only <span class="math">2,850</span> GE, it takes <span class="math">29,225</span> clock cycles, which translates to <span class="math">292</span> ms, for the response to be computed. However, it is noteworthy that more than <span class="math">80</span>% of the area is occupied</p>

    <p class="text-gray-300">with storage elements and that already a bit serial datapath is used, which implies that the chance of future improvements is very limited. Oren et al. propose a public key identification scheme called <em>WIPR</em> <em>[177]</em> that is based on the randomized variant <em>[87]</em> of the Rabin crypto system <em>[190]</em>. Their ASIC implementation requires <span class="math">5,705</span> GE and <span class="math">66,048</span> clock cycles, which is still significantly larger than <span class="math">2,000</span> GE.</p>

    <h3 id="sec-142" class="text-xl font-semibold mt-8">7.3 The GPS identification scheme</h3>

    <p class="text-gray-300">In this Section first a brief historical overview of GPS is given, before relevant parameters and optimization tricks are presented.</p>

    <h4 id="sec-143" class="text-lg font-semibold mt-6">7.3.1 History</h4>

    <p class="text-gray-300">In 1991 Girault describes self-certified public keys in <em>[81]</em> and 1998 Poupard and Stern analyzed the security of practical “on-the-fly” authentication and signature systems <em>[185]</em>. In 2006 Marc <em>G</em>irault, Guillaume <em>P</em>oupard and Jacques <em>S</em>tern proposed an “On the Fly Authentiction and Signature Scheme Based on Groups of Unknown Order” in <em>[85]</em>. In the remainder we focus on the identification scheme. Nowadays, crypto-GPS is standardized within the international standard ISO/IEC 9798-5 <em>[112]</em>. Furthermore it is listed within the final NESSIE recommendations <em>[113]</em>.</p>

    <h4 id="sec-144" class="text-lg font-semibold mt-6">7.3.2 Parameters and optimizations</h4>

    <p class="text-gray-300">Since crypto-GPS offers a variety of parameters for different security-performance trade-offs, optimizations have been widely discussed in the literature. In the following we will focus on the optimizations that have actually been chosen for our implementation. Starting with the elliptic curve-based variant, we will discuss coupons, low Hamming weight (LHW) challenges, compact encoding of the LHW challenge, and the usage of a PRNG.</p>

    <h5 id="sec-145" class="text-base font-semibold mt-4">Elliptic curve-base</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Though there are variants of the crypto-GPS scheme that are based on RSA-like moduli, we use a variant that uses elliptic curve operations, because it allows smaller keys. Brute-force attacks require a square-root work effort <em>[84]</em>, consequently for a security level of <span class="math">80</span> bits a secret <span class="math">s</span> with $\\sigma=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=160$ bits is required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-146" class="text-base font-semibold mt-4">Coupons</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In <em>[82]</em> Girault described a storage-computation trade-off for the crypto-GPS scheme that uses <span class="math">t</span> coupons, each consisting of a pair <span class="math">(r_{i},x_{i})</span> for <span class="math">1\\leq i\\leq t</span>. These coupons are stored on the tag before deployment. The on-tag computation then can be reduced to <span class="math">y=r_{i}+(s\\times c)</span>, where <span class="math">c</span> is a challenge of $\\delta=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> bits length provided by the reader and </span>s<span class="math"> is a </span>\\sigma<span class="math">-bit secret that is stored on the tag. Figure 7.1 shows a general overview of the elliptic curve-based variant of crypto-GPS that we used. Here </span>h$ denotes the length from an arbitrary hash function HASH.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">7.3. The GPS identification scheme</p>

    <p class="text-gray-300">!<a href="img-59.jpeg">img-59.jpeg</a> Figure 7.1: Overview of the used elliptic curve-based variant of crypto-GPS.</p>

    <p class="text-gray-300">In order to avoid the computationally rather demanding  <span class="math">(\\sigma \\times \\delta)</span> -bit multiplication, it is possible to turn it into a series of simple additions [84]. For this purpose, it is required to turn the challenge  <span class="math">c</span>  into a Low Hammingweight (LHW) challenge [84] such that at least  <span class="math">\\sigma - 1</span>  zero bits are between two subsequent 1 bits. When using binary representations of the multiplicands it is easy to see that multiplications can be performed using the basic Shift-And-Add multiplication algorithm [178]. Always when a bit of the input challenge  <span class="math">c</span>  is 0, the multiplicand  <span class="math">s</span>  is shifted to the left by one position. When the bit of the input challenge  <span class="math">c</span>  is 1 the multiplicand  <span class="math">s</span>  is shifted to the left and the result is added (with carry) to the multiplicand  <span class="math">s</span> . This way a complete multiplication can be reduced to simple shiftings and additions. Since in our case we use a low Hamming weight challenge that has all 1 bits at least  <span class="math">\\sigma - 1</span>  zero bits apart, it is ensured that there is no overlap in subsequent additions of  <span class="math">s</span> . In other words,  <span class="math">s</span>  is never added more than once at the same time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In our implementation we use the following parameters:  $\\sigma =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 160<span class="math">  and a challenge  </span>c<span class="math">  of length  </span>\\delta =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 848<span class="math">  with a Hamming weight of 5. The specifications of GPS state that the parameters are typical set to  </span>\\rho =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\sigma + \\delta + 80<span class="math"> . For the chosen values this leads to  </span>\\rho =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 160 + 848 + 80 = 1,088<span class="math">  bits. According to [84] these parameters enable crypto-GPS to achieve a security level equivalent to a probability of impersonation of  </span>2^{-32}$ . This combination of coupons and LHW leads to the most efficient implementation for constrained devices as has been pointed out in [83, 151, 152].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Also in [151, 83] two encoding schemes have been proposed that allow to use only 40 bits to encode the complete 848-bit challenge  <span class="math">c</span> . In our implementation we will use a modified</p>

    <p class="text-gray-300">Chapter 7. Lightweight Public-Key Cryptography</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">variant of the encoding scheme that was proposed for the 8-bit architecture in [151]. In particular it assumes that the challenge  <span class="math">c</span>  consists of five 8-bit chunks  <span class="math">n_i</span> , or in other words  $c = n_4\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_3\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_0<span class="math"> . Each  </span>n_i<span class="math">  consists of the 5-bit number  </span>c_1<span class="math">  and the 3-bit number  </span>c_2<span class="math">  ( </span>n_i = c_{i,2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i,1}$ ) and encodes the exact position of one of the five non-zero bits of the 848-bit low Hamming weight challenge.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In particular, the positions of the non-zero bits can be calculated by the following recursive equation:</p>

    <div class="my-4 text-center"><span class="math-block">P (i) = 1 6 0 + 8 \\cdot c _ {i, 1} + c _ {i, 2} \\quad 1 \\leq i \\leq 4</span></div>

    <div class="my-4 text-center"><span class="math-block">P (0) = 8 \\cdot c _ {0, 1} + c _ {0, 2} \\quad i = 0.</span></div>

    <p class="text-gray-300">Let us consider two example challenges  <span class="math">C_{comp,1}</span>  and  <span class="math">C_{comp,2}</span> . A compact transmitted challenge</p>

    <div class="my-4 text-center"><span class="math-block">C _ {c o m p, 1} = \\begin{array}{c c c c c} n _ {4} &amp;amp; n _ {3} &amp;amp; n _ {2} &amp;amp; n _ {1} &amp;amp; n _ {0} \\\\ 0 0 &amp;amp; 0 0 &amp;amp; 0 0 &amp;amp; 0 0 &amp;amp; 0 0 \\end{array}</span></div>

    <p class="text-gray-300">in hexadecimal notation gives us the following  <span class="math">c_{i,1}</span>  and  <span class="math">c_{i,2}</span> . Now it is easy to calculate the positions of the non-zero bits  <span class="math">P(i)</span>  according to the above equation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ni</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ci,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ci,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(i)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0x00</td>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0x00</td>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0x00</td>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0x00</td>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0x00</td>

            <td class="px-3 py-2 border-b border-gray-700">000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, it is possible to decode the whole 848-bit challenge  <span class="math">c</span> . For this example the whole challenge is the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ccomp,1 =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">864</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">832</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">800</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">768</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">736</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">704</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">672</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">544</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000001</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000001</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">352</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">288</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000001</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000001</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000001</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the second example we assume the compact challenge</p>

    <div class="my-4 text-center"><span class="math-block">C _ {c o m p, 2} = \\begin{array}{c c c c c} n _ {4} &amp;amp; n _ {3} &amp;amp; n _ {2} &amp;amp; n _ {1} &amp;amp; n _ {0} \\\\ 4 4 &amp;amp; \\mathrm {E} 3 &amp;amp; \\mathrm {A} 2 &amp;amp; \\mathrm {C} 1 &amp;amp; 2 0 \\end{array}</span></div>

    <p class="text-gray-300">which leads to the following table:</p>

    <p class="text-gray-300">7.3. The GPS identification scheme</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ni</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ci,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ci,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0x20</td>

            <td class="px-3 py-2 border-b border-gray-700">001</td>

            <td class="px-3 py-2 border-b border-gray-700">00000</td>

            <td class="px-3 py-2 border-b border-gray-700">8·0+1 = 1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0xC1</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">00001</td>

            <td class="px-3 py-2 border-b border-gray-700">1+160+8·1+6 = 175</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0xA2</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">00010</td>

            <td class="px-3 py-2 border-b border-gray-700">175+160+8·2+5 = 356</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0xE3</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">00011</td>

            <td class="px-3 py-2 border-b border-gray-700">356+160+8·3+7 = 547</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0x44</td>

            <td class="px-3 py-2 border-b border-gray-700">010</td>

            <td class="px-3 py-2 border-b border-gray-700">00100</td>

            <td class="px-3 py-2 border-b border-gray-700">547+160+8·4+2 = 741</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, the challenge in hexadecimal notation is decoded as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ccomp,2 =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">864</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">832</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">800</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">768</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">736</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">704</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">672</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000020</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">608</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">544</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000008</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">352</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">288</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000010</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00008000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000000</td>

            <td class="px-3 py-2 border-b border-gray-700">00000002</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Storing coupons cost memory space and especially in both hardware and software implementation for embedded devices memory is a significant cost factor. Hence, the size of the coupons limits the amount of available coupons for a given amount of memory or increases the cost. One approach considers using shorter hash length [86] to lower memory requirements. The ISO standard 9798 [112] suggests the usage of a PRNG for regenerating  <span class="math">r_i</span>  instead of storing it. This would lower the size of each coupon at the fixed cost of implementing a PRNG. We chose to use PRESENT in output feedback mode (OFB) to serve as the PRNG for our crypto-GPS implementations.</p>

    <p class="text-gray-300">The following optimizations have been considered for this prototype:</p>

    <p class="text-gray-300">(1) Elliptic curves-based variant rather than RSA-based allows shorter keys thus reducing the storage requirements. (2) Coupons/pre-computations avoid hashing and elliptic curve operations on the tag. (3) LHW challenges reduce the on-tag  <span class="math">(\\sigma \\times \\delta)</span> -bit multiplication to simple additions. (4) Compact encoding of LHW challenge allows to reduce the transmission time. (5) Usage of a PRNG reduces storage for the random values.</p>

    <p class="text-gray-300">While all of these optimizations have already been considered and studied in [83, 151, 152] the here described implementations have different features. First of all, the implementations described in [152] assume that the 1,088-bit random number stream  <span class="math">r</span>  and the 160-bit secret  <span class="math">s</span>  are provided in 8-bit chunks on-demand and that the 848-bit challenge  <span class="math">c</span>  is provided bit-serial, 1 bit in each cycle. This however implies that  <span class="math">r</span>  and  <span class="math">s</span>  have to be stored in a separate memory on the tag. Furthermore, this assumption also implies some kind of memory addressing logic that selects the appropriate 8-bit chunk of  <span class="math">r</span>  and  <span class="math">s</span>  on-demand once requested by the GPS core.</p>

    <p class="text-gray-300">The implementations described in <em>[151]</em> also assume that the <span class="math">1,088</span>-bit random number stream <span class="math">r</span> and the <span class="math">160</span>-bit secret <span class="math">s</span> are provided in <span class="math">8</span>-bit or <span class="math">16</span>-bit chunks (depending on the architecture) on-demand. Furthermore it is assumed that the compact challenge <span class="math">c</span> is input into the GPS core in <span class="math">8</span>-bit chunks on-demand. Similar to the implementations described in <em>[152]</em> this implies that <span class="math">r</span>, <span class="math">s</span> and <span class="math">c</span> are stored in an additional memory on the tag and that there is a memory addressing logic. Figures for the additional logic (memory controller, memory) on the tag however are estimated (<span class="math">1,000</span> GE for a PRNG) or not provided.</p>

    <p class="text-gray-300">The implementations described in Sections 7.5 (GPS-64/8-F) and 7.6 (GPS-4/4-F) read in the complete compact challenge <span class="math">c</span> and a <span class="math">64</span>-bit initialization vector <span class="math">IV</span> at the beginning of the computation. Though the secret <span class="math">s</span> will be fixed in practical applications, we have also implemented a variant (GPS-64/8-V) with a variable <span class="math">s</span> in order to scrutinize performance trade-offs for different values of <span class="math">s</span>. Therefore, the (GPS-64/8-V) variant also awaits an <span class="math">s</span> value at the beginning of the computation. The <span class="math">64</span>-bit <span class="math">IV</span> will be used to initialize a present-80 core in Output-Feedback-mode (OFB) that will act as the PRNG. At the end of one run, <em>i.e</em>. after 17 complete iterations of present (<span class="math">17\\cdot 64</span> bit <span class="math">=1,088</span> bit), the ASIC also outputs the internal state of the present core, which will act as the new <span class="math">IV</span> for the next run.</p>

    <p class="text-gray-300">Before we turn to the detailed description of the crypto-GPS implementations in Sections 7.5 and 7.6, we first describe the prototype board in the next section in order to better understand the design constraints.</p>

    <h3 id="sec-151" class="text-xl font-semibold mt-8">7.4 The crypto-GPS proof-of-concept prototype board</h3>

    <p class="text-gray-300">To proof the efficiency of the crypto-GPS scheme and to study different design trade-offs, Orange Labs, Paris, France decided to fabricate a proof-of-concept ASIC that should be able to respond to a challenge in less than <span class="math">200</span> ms. We implemented three different architectures in VHDL. The functional simulated variants were sent to IHP, a german chip foundry. IHP offers so-called multi-design ASICs, were a set of different designs from different customers is bundled on the same wafer. This procedure ensures significant cost savings for the production of the lithographic mask, which in turn allows us to fabricate three different designs for a limited budget. An ATMEL ATmega323 <em>[12]</em> microcontroller (<span class="math">\\mu</span>C) is used to simulate the remaining parts of an RFID tag. As such it provides the ASIC with the challenge <span class="math">c_{in}</span> and the secret <span class="math">s</span> (for some variants) and receives the output of the ASIC. In order to have a proof-of-concept prototype it should be possible to easily demonstrate the functionality of the crypto-GPS variants. Therefore the board contains a serial USB interface for easy communication with a PC. The <span class="math">\\mu</span>C converts the bit serial data stream from the USB interface to the <span class="math">8</span>-bit parallel I/O of the ASIC and vice versa. Figure 7.2 depicts the layout of the prototype board.</p>

    <h4 id="sec-152" class="text-lg font-semibold mt-6">7.4.1 The input and output pins of the ASIC</h4>

    <p class="text-gray-300">One requirement of the shared design ASIC was that all variants have the same I/O pins. In order to have the possibility of using a small packaging we tried to use as few pins as possible. Beside the mandatory pins for power supply we decided to use the following <span class="math">20</span> I/O pins:</p>

    <p class="text-gray-300">one pin is required to clock the ASIC with the right frequency.</p>

    <p class="text-gray-300">7.4. The crypto-GPS proof-of-concept prototype board</p>

    <p class="text-gray-300">!<a href="img-60.jpeg">img-60.jpeg</a> Figure 7.2: Layout diagram of the crypto-GPS prototype board.</p>

    <p class="text-gray-300">n_reset one pin is required to reset the ASIC.</p>

    <p class="text-gray-300">rx this pin is required for the I/O handshake protocol as the input channel to the ASIC.</p>

    <p class="text-gray-300">tx this pin is required for the I/O handshake protocol as the output channel of the ASIC.</p>

    <p class="text-gray-300">data_in these eight pins are used to load values into the ASIC.</p>

    <p class="text-gray-300">data_out these eight pins are used to output the result.</p>

    <p class="text-gray-300">Since the microcontroller  <span class="math">(\\mu C)</span>  is clocked independently from the ASIC, both components have to be synchronized when they are communicating. Therefore a handshake protocol with the following steps was implemented (see Figure 7.3):</p>

    <p class="text-gray-300">(1)  <span class="math">\\mu C</span>  sets input data (2) wait until input data valid (3)  <span class="math">\\mu C</span>  sets tx to '0' indicating that input data are valid (4) wait until ASIC notices that input is valid (IO_READ_WAIT) (5) ASIC sets rx to '0' indicating that input is being read (IO_READ_INPUT)</p>

    <p class="text-gray-300">Chapter 7. Lightweight Public-Key Cryptography</p>

    <p class="text-gray-300">!<a href="img-61.jpeg">img-61.jpeg</a> Figure 7.3: Signal flow of the handshake protocol for communication between board and crypto-GPS ASIC.</p>

    <p class="text-gray-300">(6) ASIC reads input (IO_READ_INPUT) (7) ASIC sets rx to '1' indicating that input was successfully read (IO_READ_ACK) (8) wait until  <span class="math">\\mu C</span>  notices that rx was set to '1' (9)  <span class="math">\\mu C</span>  sets tx to '1' thus finishing the input procedure (10) ASIC computes the response (11) ASIC sets rx to '0' indicating that output data are valid (IO_WRITE_WAIT) (12) wait until  <span class="math">\\mu C</span>  notices that output is valid (IO_WRITE_WAIT) (13)  <span class="math">\\mu C</span>  sets tx to '0' indicating that output is being read (14)  <span class="math">\\mu C</span>  reads output (IO_WROTE_OUTPUT) (15)  <span class="math">\\mu C</span>  sets tx to '1' indicating that the output was successfully read (16) wait until ASIC notices that tx was set to '1' (17) ASIC sets rx to '1' thus finishing the output procedure.</p>

    <p class="text-gray-300">We implemented one crypto-GPS variant with a round-based PRESENT-80 core, an internal datapath of 8 bits and a fixed secret  <span class="math">s</span> . We refer to this variant in the following as GPS-64/8-F and describe the implementation in Section 7.5. Some applications might require that the secret  <span class="math">s</span>  is going to be updated. For this reason and in order to exploit the performance trade-offs for different values of  <span class="math">s</span>  we implemented a GPS variant with a round-based PRESENT-80 core, an internal datapath of 8 bits and a variable secret  <span class="math">s</span>  which is referred to as GPS-64/8-V. We will also provide details about this implementation in Section 7.5. Another design trade-off is to use a serialized PRESENT-80 core instead of a round-based one. For this variant it is advantageous to use an internal datapath of 4 bits. Furthermore we decided to implement this variant with a fixed secret  <span class="math">s</span> . Details for this GPS-4/4-F called variant are provided in Section 7.6. Finally, the ASIC also contains a variant that consists only of a serialized PRESENT-80 encryption core. This implementation is similar to the serialized PRESENT-80 implementation described in Section 5.1.1 but also contains I/O logic. Especially noteworthy is the implementation of the handshake protocol that lead to a significant increase of the area requirements (1,220 GE compared to 1,075 GE). At the time of the submission of this Thesis the ASIC has not yet been</p>

    <p class="text-gray-300">7.5. Hardware implementations of round-based crypto-GPS</p>

    <p class="text-gray-300">!<a href="img-62.jpeg">img-62.jpeg</a> Figure 7.4: Top-level architecture of the GPS-64/8-F and GPS-64/8-V variants.</p>

    <p class="text-gray-300">returned from fabrication such that no further investigations could be performed. Since the architecture of a serialized PRESENT-80 core was detailed already in Section 5.1.1 we do not repeat it at this point.</p>

    <p class="text-gray-300">The architecture of GPS-64/8-F is depicted in Figure 7.4. It uses a round-based PRESENT-80 implementation (PRESENT), a Controller component, a full-adder component (Addwc) and a storage component (S_Storage). In the following these components are described in detail. Since the PRESENT component is similar to the one described in Section 5.1.2 we refer the interested reader there. Starting with the Controller component in Section 7.5.1, the Addwc component is described in Section 7.5.2. Finally two different S_storage components are described in Sections 7.5.3 and 7.5.4.</p>

    <p class="text-gray-300">Chapter 7. Lightweight Public-Key Cryptography</p>

    <p class="text-gray-300">!<a href="img-63.jpeg">img-63.jpeg</a> (a) Central FSM of all crypto-GPS variants.</p>

    <p class="text-gray-300">!<a href="img-64.jpeg">img-64.jpeg</a> (b) I/O FSM of all crypto-GPS variants.</p>

    <p class="text-gray-300">!<a href="img-65.jpeg">img-65.jpeg</a> (c) FSM of the storage component of all crypto-GPS variants.</p>

    <p class="text-gray-300">!<a href="img-66.jpeg">img-66.jpeg</a> (d) FSM of the round-based PRESENT core of GPS-64/8-F and GPS-64/8-V. Figure 7.5: Finite State Machines of the crypto-GPS ASIC.</p>

    <p class="text-gray-300">7.5. Hardware implementations of round-based crypto-GPS</p>

    <p class="text-gray-300">!<a href="img-67.jpeg">img-67.jpeg</a> Figure 7.6: Architecture of the adder component of all crypto-GPS variants.</p>

    <p class="text-gray-300">The controller consists of four separate but interacting FSMs each one for the central control (see Figure 7.5(a)), I/O (Figure 7.5(b)), S_STORAGE (Figure 7.5(c)) and PRESENT (Figure 7.5(d)). It requires 64 clock cycles to initialize the ASIC and load the values  <span class="math">IV</span> ,  <span class="math">c_{in}</span>  and  <span class="math">s</span> . In the round based version it requires 32 cycles to create 64 pseudo random bits by the PRESENT component and to add it with the appropriate chunk of the secret  <span class="math">s</span> . Due to the handshaking protocol, it then requires 64 cycles to output the result in 8-bit chunks. Since we have to compute 1,088 bits we have to repeat this procedure another 16 times. Finally the internal state of the PRESENT component has to be stored outside the ASIC as the new  <span class="math">IV</span>  for the next iteration of crypto-GPS. So in total (including I/O overhead) it takes  <span class="math">17 \\cdot (32 + 64) + 64 = 1</span> , 696 clock cycles for one complete run of crypto-GPS.</p>

    <p class="text-gray-300">Figure 7.6 depicts the ADDWC component. As one can see, it consists of a flip-flop to store the carry bit and a standard full-adder component. For the round-based variants GPS-64/8-F and GPS-64/8-V it has a datapath width of 8 bits, i.e. two 8-bit input values are added.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 7.7(a) depicts the architecture of the S_Storage component for a fixed secret  <span class="math">s</span> . It consists of an 8-bit AND gate (11 GE), an 8-bit OR gate (11 GE), a gated register with 8-bit input (48 GE), an 8-bit 20-to-1 MUX (249 GE), and a shifting component denoted with ("00000000"</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a) «c2. First, the right 8-bit chunk of  <span class="math">s</span>  is chosen by the MUX, which then is ANDed with the 8-bit signal n_zero. n_zero replicates eight times a single bit of the control_vector, hence it can either be set to "00000000" or "11111111". This way the resulting value  <span class="math">a</span>  is either set to the corresponding 8-bit chunk of  <span class="math">s</span>  or "00000000", before it is processed by the shifting component. The shifting component has a second input, namely the shifting offset  <span class="math">c2</span> . Within the shifting component the input value  <span class="math">a</span>  is appended to the string "00000000" in order to yield the intermediate state  <span class="math">b</span> , i.e. in VHDL notation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">b &lt;= "00000000"&amp;a;</p>

    <p class="text-gray-300">Chapter 7. Lightweight Public-Key Cryptography</p>

    <p class="text-gray-300">It then rotates b by c2 positions to the left. Since c2 has three bits, the shifting offset varies between 0 and 7. Finally, it outputs two 8-bit values c and d, which consist of the 8 MSB (c) and the 8 LSB (d) of the internal state b. c is stored in an 8-bit gated register and d is ORed with the output of the gated register.</p>

    <h4 id="sec-159" class="text-lg font-semibold mt-6">7.5.4 Implementation of the S_Storage component with a variable secret <span class="math">s</span></h4>

    <p class="text-gray-300">Figure 7.7(b) depicts the architecture of the S_Storage component that is capable to process variable secrets <span class="math">s</span>. It consists of an 8-bit 4-to-1 input MUX, an 8-bit 3-to-1 output MUX, an 8-bit AND, an 8-bit OR and 22 gated shifting registers that each store 8 bit. 20 of these shifting registers are required to store the complete secret <span class="math">s</span> and the remaining two are required to temporarily store the shifted values for the next addition cycle.</p>

    <h3 id="sec-160" class="text-xl font-semibold mt-8">7.6 Hardware implementation of serialized crypto-GPS</h3>

    <p class="text-gray-300">The architecture of GPS-4/4-F is depicted in Figure 7.8(a). As one can see, the general structure is very close to the architecture of the round-based variants GPS-64/8-F and GPS-64/8-V (see Figure 7.4). It also feeds the 8-bit input value <span class="math">c_{in}</span> into the Controller component, but contrary to the round-based variants it splits this value and feeds the higher nibble into the S_Storage component and the lower nibble into the PRESENT component. Since it uses an internal datapath of 4 bits, also the outputs of the PRESENT, S_Storage and the Addwc components are only 4 bits width. Therefore the 4-bit output signal data_out is padded with "0000" in order to fulfill the requirements of an 8 bit I/O interface. It uses a serialized present-80 implementation (PRESENT), a Controller component, a full-adder component (Addwc) and a storage component for fixed s (S_Storage). Since the PRESENT component is similar to the one described in Section 5.1.1 and the Addwc component was already described in Section 7.5.2, we refer the interested reader there. However, the Controller and the S_Storage components are different and consequently we detail them in the remainder of this section.</p>

    <h4 id="sec-161" class="text-lg font-semibold mt-6">7.6.1 Implementation of the Controller component</h4>

    <p class="text-gray-300">The Controller module consists of the same four FSMs that were already described in Section 7.5.1. Three of them (central FSM, I/O FSM and storage FSM, see Figures 7.5(a) to 7.5(c)) are similar to the ones used for the round-based variants and we refer to Section 7.5.1 for further details. Figure 7.8(b) depicts the FSM of the serialized present-80 component. Due to the serialized approach it is significantly more complex than the FSM for a round-based implementation.</p>

    <p class="text-gray-300">It requires <span class="math">64</span> clock cycles to initialize the ASIC and load the values <span class="math">IV</span>, <span class="math">c_{in}</span> and <span class="math">s</span>. In the serialized version it requires <span class="math">563</span> cycles to create <span class="math">64</span> pseudo random bits by the PRESENT component and to add them to the appropriate chunk of the secret <span class="math">s</span>. Due to the handshaking protocol, it then requires <span class="math">64</span> cycles to output the result in 4-bit chunks. Since we have to compute <span class="math">1,088</span> bits we have to repeat this procedure another <span class="math">16</span> times. Finally the internal state of the PRESENT component has to be stored outside the ASIC as the new <span class="math">IV</span> for the next iteration of crypto-GPS. So in total (including I/O overhead) it takes <span class="math">17\\cdot(563+64)+64=10,723</span> clock cycles for one complete run of crypto-GPS.</p>

    <p class="text-gray-300">7.6. Hardware implementation of serialized crypto-GPS</p>

    <p class="text-gray-300">!<a href="img-68.jpeg">img-68.jpeg</a> (a) Architecture of the storage component of GPS-64/8-F with a fixed secret  <span class="math">s</span> .</p>

    <p class="text-gray-300">!<a href="img-69.jpeg">img-69.jpeg</a> (b) Architecture of the storage component of GPS-64/8-V with a variable secret  <span class="math">s</span> .</p>

    <p class="text-gray-300">!<a href="img-70.jpeg">img-70.jpeg</a> (c) Architecture of the storage component of GPS-4/4-F with a fixed secret  <span class="math">s</span> . Figure 7.7: Three architectures of storage components for different crypto-GPS variants.</p>

    <p class="text-gray-300">Chapter 7. Lightweight Public-Key Cryptography</p>

    <p class="text-gray-300">Table 7.1: Post-Synthesis implementation results of three different architectures of crypto-GPS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security level [bits]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Response size [bits]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data path size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles per block</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time at 100KHz [ms]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Logic process</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area [GE]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GPS-64/8-F</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">1,088</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1,696</td>

            <td class="px-3 py-2 border-b border-gray-700">16.96</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18 UMC</td>

            <td class="px-3 py-2 border-b border-gray-700">2,556</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.25 IHP</td>

            <td class="px-3 py-2 border-b border-gray-700">2,433</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GPS-64/8-V</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">1,088</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1,696</td>

            <td class="px-3 py-2 border-b border-gray-700">16.96</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18 UMC</td>

            <td class="px-3 py-2 border-b border-gray-700">3,976</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.25 IHP</td>

            <td class="px-3 py-2 border-b border-gray-700">3,861</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GPS-4/4-F</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">1,088</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">10,723</td>

            <td class="px-3 py-2 border-b border-gray-700">107.23</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18 UMC</td>

            <td class="px-3 py-2 border-b border-gray-700">2,181</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.25 IHP</td>

            <td class="px-3 py-2 border-b border-gray-700">2,143</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WIPR [177]</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">2,048</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">66,048</td>

            <td class="px-3 py-2 border-b border-gray-700">660.5</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35 AMS</td>

            <td class="px-3 py-2 border-b border-gray-700">5,705</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECC-2·67 [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">67</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">418,250</td>

            <td class="px-3 py-2 border-b border-gray-700">4,183</td>

            <td class="px-3 py-2 border-b border-gray-700">0.25</td>

            <td class="px-3 py-2 border-b border-gray-700">12,944</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECC-112 [75]</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">195,264</td>

            <td class="px-3 py-2 border-b border-gray-700">1,953</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35 AMI</td>

            <td class="px-3 py-2 border-b border-gray-700">10,113</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NTRUencrypt [76]</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">29,225</td>

            <td class="px-3 py-2 border-b border-gray-700">292.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.13 TSMC</td>

            <td class="px-3 py-2 border-b border-gray-700">2,850</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7.7(c) depicts the architecture of the S_Storage component for a fixed secret  <span class="math">s</span>  and an internal 4-bit datapath. As one can see, it is very similar to the S_Storage component of the round-based variant GPS-64/8-F (see Figure 7.7(a)). In fact it just splits the 8-bit input value into two 4-bit chunks. Dependent on a counter value it outputs either the higher or the lower nibble.</p>

    <p class="text-gray-300">For functional and post-synthesis simulation we used Mentor Graphics Modelsim SE PLUS 6.3a [92] and Synopsys DesignCompiler version Z-2007.12-SP1 [218] was used to synthesize the designs to two different standard-cell libraries. Table 7.1 summarizes the implementation results of the three different architectures of crypto-GPS. We provide area figures from post-synthesis for two different libraries. One is the Virtual Silicon (VST) standard cell library UMCL18G212T3, which is based on the UMC L180  <span class="math">0.18\\mu m</span>  1P6M logic process and has a typical voltage of 1.8 Volt [233]. Since throughout this Thesis we used this library for many other designs <span class="math">^4</span> , we also provide area figures for crypto-GPS synthesized to the UMC library in order to enable a fairer comparison with the other designs. On the other hand we provide area figures for crypto-GPS for the IHP standard cell library SESAME-LP2-IHP0.25UM, which is compatible to the IHP  <span class="math">0.25\\mu m</span>  Logic 1P4M Salicide process and has a typical voltage of 2.5 Volt [64]. Since we manufactured an ASIC that uses this process (see Figure 7.9 for a photograph), it is interesting to see how the post-synthesis figures compare to the manufactured ones.</p>

    <p class="text-gray-300">7.7. Discussion of implementation results</p>

    <p class="text-gray-300">!<a href="img-71.jpeg">img-71.jpeg</a> (a) Top-level architecture of the GPS-4/4-F variant.</p>

    <p class="text-gray-300">!<a href="img-72.jpeg">img-72.jpeg</a> (b) FSM of the serialized PRESENT core of the GPS-4/4-F variant. Figure 7.8: Top-level architecture and FSM of the GPS-4/4-F variant.</p>

    <p class="text-gray-300">Chapter 7. Lightweight Public-Key Cryptography</p>

    <p class="text-gray-300">!<a href="img-73.jpeg">img-73.jpeg</a> Figure 7.9: Photograph of the manufactured crypto-GPS ASIC.</p>

    <p class="text-gray-300">As one can see from Table 7.1 the round-based variants GPS-64/8-F and GPS-64/8-V require 1,696 clock cycles and the serialized variant GPS-4/4-F requires 10,723 clock cycles for processing one challenge. At a frequency of  <span class="math">100\\mathrm{kHz}</span>  this translates to 16.96 ms and 107.23 ms, which is well below the required 200 ms. The area requirements (for the UMCL18G212T3 library) range from 3,976 GE for GPS-64/8-V over 2,556 GE for GPS-64/8-F to 2,181 GE for GPS-4/4-F. Given the more than 6 times longer processing time, it seems that a serialized PRESENT implementation only provides a slight benefit compared to a round-based implementation. However, flexibility comes at a high price: while the fixed secret variants can hardwire  <span class="math">s</span>  and select the appropriate chunk with MUXes, the variable variant has to use 160 flip-flops, which results in a significant area overhead.</p>

    <p class="text-gray-300">Oren et al. propose a public key identification scheme called WIPR [177] that is based on the randomized variant [87] of the Rabin crypto system [190]. Their ASIC implementation requires 5,705 GE and 66,048 clock cycles, which is still significantly larger than 2,000 GE. Furthermore it takes more than 6 times longer to process one challenge compared to our serialized implementation and 39 times longer compared to our round-based variants while being significantly larger. While offering a significantly lower security level, even the smallest published ECC implementations require more than 10,000 GE and hence are far away from being lightweight. Gaubatz et al. [76] have investigated the hardware efficiency of the NTRUencrypt algorithm [174, 106] with the following parameters  <span class="math">(N,p,q) = (167,3,128)</span>  that offer a security level of only 57 bits. Though their implementation requires only 2,850 GE, it takes 29,225 clock cycles, which translates to  <span class="math">292\\mathrm{ms}</span> , for the response to be computed. However, it is noteworthy that more than  <span class="math">80\\%</span>  of the area is occupied with storage elements and that already a bit serial datapath is used, which implies that the chance of future improvements is very limited.</p>

    <h2 id="sec-164" class="text-2xl font-bold">8 Physical Security Aspects</h2>

    <p class="text-gray-300">In this Chapter physical security aspects and their relation to lightweight implementations are discussed. Starting with a motivation in Section 8.1, we define a pervasive attacker model in Section 8.2. Subsequently, pervasive devices are classified in Section 8.3 Then we provide an evaluation of pervasive devices with regard to physical security aspects in Section 8.4. Subsequently, in Section 8.5 side channel attacks and their countermeasures are introduced. Then in Section 8.6 the cost overhead of side channel countermeasures are assessed for lightweight hardware and software implementations of present-80. Finally this Chapter is concluded and pointer for future work are provided in Section 8.7.</p>

    <h3 id="sec-165" class="text-xl font-semibold mt-8">8.1 Motivation</h3>

    <p class="text-gray-300">Even though modern ciphers like AES seem to be resistant against cryptographic attacks, such as linear or differential cryptanalysis <em>[149, 26]</em>, it might be possible to attack the <em>implementation</em> of the algorithm. In the last years it became clear that an implementation of a cryptographic algorithm can leak sensitive information about processed key-related data. The term side channel analysis summarizes all possible ways of collecting this information, such as processing time <em>[130]</em>, power consumption <em>[131]</em> or electromagnetic emission <em>[8]</em>. Side channel attacks pose a severe threat for pervasive devices, because of their deployment “in the field”. If a device implements no countermeasures against tampering, an adversary may manipulate the operation environment of the device (voltage, clock frequency) or intrude the device for example by <em>micro probing</em>. An adversary may deduce from side channel information (electromagnetic emission, power consumption) or from the device’s behavior to her manipulations (time delays) critical security parameters like a secret key stored inside the device.</p>

    <h3 id="sec-166" class="text-xl font-semibold mt-8">8.2 A pervasive attacker model</h3>

    <p class="text-gray-300">For a security evaluation of pervasive devices it is important to classify the attackers, which will be carried out in Section 8.2.1. Subsequently in Section 8.2.2 physical attacks will be classified and finally in Section 8.2.3 costs of an attack will be discussed.</p>

    <h4 id="sec-167" class="text-lg font-semibold mt-6">8.2.1 Classification of attackers</h4>

    <p class="text-gray-300">Since the requirements in terms of cost, time, expertise and equipment differ significantly for different attacks, it is important to classify the attackers. We adopted the classes proposed in <em>[1]</em> and <em>[6]</em>, respectively:</p>

    <p class="text-gray-300">Chapter 8. Physical Security Aspects</p>

    <p class="text-gray-300">Class 1, Clever Outsiders: “These attackers are often very intelligent but may have insufficient knowledge of the system. They may have access to only moderately sophisticated equipment. They often try to take advantage of an existing weakness in the system, rather than try to create one.” We believe that clever outsider will typically not spent more than 5,000 EUR for the whole attack including equipment and salary. Class 2, Knowledgeable Insiders: “These attackers have substantial specialized technical education and experience. They have varying degrees of understanding of parts of the system but potential access to most of it. They often have highly sophisticated tools and instruments for analysis.” Knowledgeable insiders may also spend up to 5,000 EUR for an attack, but they can use expensive equipment free of charge. Class 3, Funded Organizations: “These attackers are able to assemble teams of specialists with related and complementary skills backed by great funding resources. They are capable of in-depth analysis of the system, designing sophisticated attacks, and using the most advanced analysis tools. They may use class 2 adversaries as part of the attack team.” Funded organizations may spend several 100,000’s EUR for an attack. Notice that combinations of attacker classes are also possible and bear a great security risk. Imagine a knowledgeable insider who distributes his knowledge via the Internet to many clever outsiders.</p>

    <h4 id="sec-168" class="text-lg font-semibold mt-6">8.2.2 Classification of attacks</h4>

    <p class="text-gray-300">Following Anderson et al. <em>[7]</em>, we categorize the attacks in either active or passive and either local or remote attacks. During an active attack the adversary tries to manipulate the device, its input or its environment to cause abnormal behavior, while during a passive attack, the adversary works with the device as it is operated normally. Local attacks can be further separated into invasive, semi-invasive and non-invasive attacks. Invasive attacks are classified by a direct electrical access to the internal components of the device, for example by micro-probing <em>[134]</em>. Even though, semi-invasive attacks do neither require direct electrical contact nor damage the silicon, they need a de-packaged chip. Thus, an adversary requires access to the device. Anderson et al. <em>[7]</em> give the following example for a semi-invasive attack: “the attacker may use a laser beam to ionize a transistor and thus change the state of the flip-flop that holds the device’s protection state”. Non-invasive attacks include close observation and manipulation of the device’s operation, for example differential power analysis <em>[131]</em>. For this kind of attacks, no extremely sophisticated equipment is necessary. Even class 1 attacker can organize some second-hand equipment (like high-grade oscilloscope) for this attack. Remote attacks include observation of the normal input and output of the device, for example timing analysis, cryptanalysis, protocol analysis, and attacks on the application programming interface. A special kind of remote attacks are Denial of Service (DoS) attacks. In this case an attacker’s aim is to compromise the availability of functions of the device. As an extreme example for a Denial of Service attack consider the following: an attacker could send lots of requests to the device, forcing it to compute answers. After a certain time period the energy resources will be exhausted and the node stops working. That is the reason why active devices are more susceptible to Denial of Service attacks than passive devices. However, since this is not a physical security concern, it was not considered in our evaluation.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">8.2.3 Classification of attack costs</p>

    <p class="text-gray-300">We assume that the cost of an attack consists of two parts: initial costs <span class="math">C_{i}</span> and cost per device <span class="math">C_{d}</span>. The average costs per device <span class="math">C</span> to break <span class="math">x</span> devices are estimated by the following equation:</p>

    <p class="text-gray-300"><span class="math">C=\\frac{C_{i}+x\\cdot C_{d}}{x}</span></p>

    <p class="text-gray-300">As one can see from this equation, with larger <span class="math">x</span>, the initial cost <span class="math">C_{i}</span> become negligible. While high initial costs <span class="math">C_{i}</span> put off class I and class II attackers but not class III attackers, high breaking costs per device <span class="math">C_{d}</span> also scare class III attackers. The optimization goal is therefore to increase the cost per device <span class="math">C_{d}</span> as much as possible.</p>

    <h3 id="sec-169" class="text-xl font-semibold mt-8">8.3 Classification of pervasive devices</h3>

    <p class="text-gray-300">Resistance against tampering is used as the main characteristic to distinguish the classes, because we classify the devices with regard to security issues. The classes are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>unprotected devices</li>

      <li>partly protected devices</li>

      <li>tamper resistant devices.</li>

    </ul>

    <p class="text-gray-300">Another property which we used to classify devices is the power supply. If a device provides not its own power supply, it is called a passive device. If a device has a built-in power supply it is called an active device. Active devices usually have a longer range than passive devices, but, if battery powered, they offer an additional resource, which an attacker might attack. Therefore, we further separated each of the three classes into active and passive devices. In our classification scheme device costs also play an important role. If millions or even billions of devices are deployed, the price of a single device becomes a knock-out criterion. Thus, we classified the devices on their estimated prize as follows:</p>

    <p class="text-gray-300">less than 1 EUR (e.g. passive RFID label) 1 - 10 EUR (e.g. smart card) more than 10 EUR (e.g. high-end smart card)</p>

    <p class="text-gray-300">The NIST standard FIPS 140-02 <em>[160]</em> defines four levels of physical security for cryptographic modules:</p>

    <p class="text-gray-300">devices with no special protection mechanisms devices, that implement tamper evidence mechanisms devices, that implement tamper evidence and tamper response mechanisms devices, that implement tamper evidence, tamper response and environmental protection mechanisms/environmental testing</p>

    <p class="text-gray-300">Tamper evidence mechanisms provide the evidence, that an attack has been attempted (for example a seal). Tamper response mechanisms actively react to the detection of an attack (for example a zeroization circuit that deletes the secure key). Environmental protection mechanisms measure the voltage and temperature of the device. Environmental testing means, that a device undergo a testing procedure with extreme voltages and temperatures before it is deployed. According to</p>

    <p class="text-gray-300">Anderson et al. <em>[7]</em>, there is a clear bifurcation in the smart card market between low-cost smart cards and state of the art secure smart cards. Low-cost smart cards offer rudimentary protection such that we denote them as passive partly protected devices’. We will have a look at highly secure smart cards in Section 8.3.3 as passive tamper resistant devices. Radio Frequency Identification (RFID) devices comprise a wide variety of devices. Because this ranges from single bit transponders to contact-less smart cards, the term RFID is not suitable for our classification scheme. In each case one has to classify an RFID transponder based on the properties of the device. However, we use the term RFID as an equivalent to passive low-cost RFID tags, therefore we will use the term RFID tags synonymous to passive unprotected pervasive devices.</p>

    <h4 id="sec-170" class="text-lg font-semibold mt-6">8.3.1 Unprotected pervasive devices</h4>

    <p class="text-gray-300">Unprotected pervasive devices typically have been developed for mass-market applications. Furthermore, we assume that one of the main designing constraints, probably the most important one, for this kind of devices was low production cost. As a consequence of this sharp cost calculation, unprotected devices were not designed to provide any countermeasures against tampering. A standard passivation layer is the top most layer of every micro-controller. If the secret key is stored in an external memory an adversary can simply read it out and the passivation layer is useless. In this sense it is not really a countermeasure, but it can extend the time needed for an attacker to gain access to the controller chip. Unprotected devices usually comprise embedded processors, which are normally very cheap and hence best suited for mass deployment. The following list summarizes the main characteristics of unprotected devices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>low-cost</li>

      <li>no security driven design</li>

      <li>small/lightweight</li>

      <li>only external memory (e.g. flash memory or EEPROM)</li>

    </ul>

    <p class="text-gray-300">A special subset of unprotected devices are passive unprotected devices. They do not have an own power supply and are extremely low-cost devices. They are supposed to be very small, lightweight and hence very mobile. Examples for this device class are RFIDs tags used as electronic product codes for 0.55 cent. Active unprotected devices are quite similar to passive unprotected devices. They are supposed to be cheap, small, lightweight and also mobile. The main difference is their own power supply. Hence they are additionally susceptible to denial of service attacks. MicaMotes <em>[52]</em> serve as an example for active unprotected devices.</p>

    <h4 id="sec-171" class="text-lg font-semibold mt-6">8.3.2 Partly protected pervasive devices</h4>

    <p class="text-gray-300">With regard to physical security mechanisms partly protected devices in our classification scheme equal Level 3 devices in FIPS 140-2. The aim of this device class is to prevent an intruder to gain access to critical security parameters, like plaintext key, which are stored inside the device. This includes mechanisms that have a high probability of tamper-detection, such as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>top-metal sensor meshes</li>

      <li>light-sensors</li>

    </ul>

    <p class="text-gray-300">Nowadays high-grade smart cards have a sensor mesh implemented in the top metal layer. A sensor mesh consists of sensor, ground and power lines in a serpentine pattern. An adversary, who destroys a sensor line or shortens it to ground or power, causes the device to self-destruct. For micro-probing it is necessary to open a device and remove the standard passivation layer to gain access to the chip’s surface. Light sensors can be used to prevent an opened chip from working. If one of these sensors detects an intrusion attempt, a tamper-response mechanism is triggered. Usually tamper-response mechanisms are zeroization circuits that erase all critical security parameters stored on the device. Beside tamper-detection and tamper-response mechanisms, partly protected devices may have one or more of the following countermeasures implemented:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>glue logic</li>

      <li>noise generators</li>

      <li>internal bus hardware encryption</li>

      <li>password restricted software access to internal memory</li>

    </ul>

    <p class="text-gray-300">Microcontrollers used to be separated in standard building-blocks, like CPU instruction decoder, register file, ALU and I/O circuits. These blocks could be easily identified with an optical microscope. Glue logic describes a randomized ASIC-like logic design where the blocks cannot be identified any more. For an adversary it is virtually impossible to find signals for probing by hand in a glue logic design, hence invasive attacks based on micro-probing are thwarted by this countermeasure <em>[7]</em>. Internal bus hardware encryption makes data analysis more difficult and thus improves the security level. Password restricted software access to internal memory is a countermeasure against simple attacks to read out the whole memory. If the memory content is encrypted an adversary gains no advantage any more. Noise generators aim at thwarting side channel attacks like differential power analysis. They generate noise to obscure the actual signals in the controller. It has become clear that noise generators can not prevent side channel attacks in general, yet they can significantly increase the effort for an adversary to succeed. The following list summarizes the main characteristics of partly protected devices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>medium cost</li>

      <li>security is a design goal</li>

      <li>at least one of the above listed countermeasures is implemented</li>

    </ul>

    <p class="text-gray-300">Passive partly protected devices implement one or more of the above mentioned countermeasures against tampering attacks. Although some of these countermeasures need power to work properly (all kind of sensors) they can be implemented as well on passive devices. An adversary can invade a passive device without any concern as long as the device is not powered on. Once the device is powered on, the sensors detect an intrusion attempt and zeroize all critical security parameters like the plaintext key. Hence the countermeasures work with a delay, giving an adversary a time window where she can try to bypass the countermeasures. In practice, the countermeasures are quite sophisticated and it is a hard and time consuming work to bypass them. Examples for this device class are secure memory modules or basic smart cards. Similar to passive partly protected devices active partly protected devices implement one or more of the above mentioned countermeasures. Additionally, they implement improved tamper-resistance measures compared to passive partly protected devices. Unlike passive devices, active devices can react immediately to a detected intrusion attempt. This is</p>

    <p class="text-gray-300">an advantage over passive devices, hence active partly protected devices are able to provide a higher security level than passive partly protected devices.</p>

    <h4 id="sec-172" class="text-lg font-semibold mt-6">3.3.3 Tamper resistant pervasive devices</h4>

    <p class="text-gray-300">Tamper resistant devices are the most sophisticated devices in our classification scheme. They are comparable to security level 4 devices defined in FIPS 140-2 with regard to physical security issues. In comparison to partly protected devices, which typically implement only a few of the aforementioned countermeasures, tamper resistant devices aim to thwart any known attacks, even attacks from funded organisations (class 3 attackers). Therefore, tamper resistant devices usually implement more of the above mentioned countermeasures than partly protected devices. In addition to the countermeasures mentioned in Section 2, tamper resistant devices possess environmental failure protection mechanism or undergo environmental failure testing. In particular, FIPS 140-2 security level 4 requires the implementation of voltage and temperature sensors. Additionally clock frequency sensors improve the security level. If a device is operated in unusual environmental conditions outside of its standard operation range, this can cause abnormal behaviour, which may result in a security risk <em>[16]</em>. Environmental failure protection mechanisms include:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>internal voltage sensors</li>

      <li>clock frequency sensors</li>

      <li>temperature sensors</li>

    </ul>

    <p class="text-gray-300">Power glitch attacks use under- and over-voltages to cause abnormal behavior of the device. Internal voltage sensors protect the device against these kinds of attacks. Similar to power glitch attacks, clock glitch attacks use a higher frequency to cause abnormal behavior of the device. Furthermore, at a very low clock frequency it is possible to make a static analysis of the device. Clock frequency sensors protect the device from these attacks. Static RAM contents can persist for seconds to minutes after power is removed, when the temperature is below -20^{∘}C. An adversary could use this fact to read out RAM content like secret keys. Furthermore, very high temperatures can cause failures, which may be used for attacks. Temperature sensors aim at this kind of attacks. A high security level is a basic requirement for tamper resistant devices, hence they are the most expensive devices in our classification scheme, assumed that devices of the same processing power are compared. The following list summarizes the main characteristics of partly protected devices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>most sophisticated devices</li>

      <li>high cost</li>

      <li>security is a basic requirement</li>

      <li>many of the aforementioned countermeasures are implemented</li>

      <li>environmental protection mechanisms are implemented or the devices undergo environmental testing before deployment</li>

    </ul>

    <p class="text-gray-300">As already mentioned in Section 2, an adversary can attack a device without any concern as long as it is not switched on, because tamper-detection and environmental failure protection mechanisms can only work, when the device is powered on. Passive tamper resistant devices should therefore have been tested for environmental failure before deployment. The temperature to be tested should range from -100^{∘}C to +200^{∘}C, the voltage “should range from the</p>

    <p class="text-gray-300">smallest negative voltage (with respect to ground) that causes the zeroization of the electronic devices or circuitry, including reversing the polarity of the voltages.” <em>[160]</em>. A wide spread example for passive tamper resistant devices are sophisticated smart cards with controllers like the Infineon SLE88CX720P and SLE66C24PE <em>[109, 110]</em>. In comparison to passive tamper resistant devices, active tamper resistant devices can take full advantage of environmental failure protection mechanisms, because they can continuously monitor the operating voltage and temperature of the device. As soon as the sensors detect unusual environmental conditions of fluctuations, tamper response mechanisms must be triggered. FIPS 140-2 gives two alternatives for tamper-responding mechanisms. Either the device is shut-down or all critical security parameters are zeroized immediately. Examples for active tamper resistant devices are secure hardware modules used for communication between embassies or encryption devices for telecommunication.</p>

    <h3 id="sec-173" class="text-xl font-semibold mt-8">8.4 Evaluation of pervasive devices with respect to physical security aspects</h3>

    <p class="text-gray-300">In this section, we evaluate the proposed device classes with regard to security issues. Starting with unprotected pervasive devices in Section 8.4.1, we evaluate partly protected pervasive devices in Section 8.4.2 and tamper resistant pervasive devices in Section 8.4.3.</p>

    <h4 id="sec-174" class="text-lg font-semibold mt-6">8.4.1 Evaluation of unprotected pervasive devices</h4>

    <p class="text-gray-300">Unprotected devices are developed under tight cost constraints, hence they are not supposed to implement any countermeasures against physical attacks. Once an attacker can achieve unsupervised physical access to an unprotected device, she can try to tamper it with any of the above mentioned local attacks. Neither expensive equipment nor outstanding knowledge about the system is required for an attack of this device class. A clever outsider (class I attacker) may spend up to 5,000 EUR for the required (second hand) equipment. Hence, even class I attacker (clever outsiders) are supposed to be able to break unprotected pervasive devices.</p>

    <h4 id="sec-175" class="text-lg font-semibold mt-6">8.4.2 Evaluation of partly protected pervasive devices</h4>

    <p class="text-gray-300">Partly protected devices implement one or more of the following countermeasures: top-metal sensor meshes, light-sensors, glue logic, noise generators, internal bus hardware encryption, and password restricted software access to internal memory. Anderson et al. state, that “no single low-cost defence technology can protect a device against attacks” <em>[7]</em>. Anyway, if countermeasures are prudent implemented, they can significantly raise the time and effort (red: cost) an attacker has to spend to physically attack a single device. Furthermore, sophisticated and, hence, expensive equipment is required, which will ultimately exclude class I attackers. Beside this, countermeasures aim to make life hard for class II attackers and expensive for class III attackers <em>[6]</em>. Passive devices are in general more vulnerable to physical attacks than active devices, because their countermeasures need to be powered on to work. This delay provides a time window, where the adversary may bypass the countermeasures before she powers the device to read out critical security parameters. Therefore it is more expensive for class II and class III attackers to break an active device rather than a passive device.</p>

    <p class="text-gray-300">8.4.3 Evaluation of tamper resistant pervasive devices</p>

    <p class="text-gray-300">In addition to the countermeasures mentioned in the last section, tamper resistant devices implement environmental failure protection mechanisms or undergo environmental failure detection. Environmental failure protection mechanisms include: internal voltage sensors, clock frequency sensors, and temperature sensors. Anderson and Kuhn refer to a senior agency official and a senior scientist at a leading semiconductor manufacturer stating the following: “chip contents cannot be kept from a capable motivated opponent; at most one can impose cost and delay” <em>[7]</em>. Because passive tamper resistant devices provide a time window where an adversary may bypass the countermeasures and the environmental failure protection mechanisms, we think that these devices can be broken by a class III (funded organisations) opponent. By contrast, active tamper resistant devices can implement more sophisticated tamper-detection mechanisms, which will react immediately to a detected attack. This results in a higher security level and, hence, even for class III attackers it is much more expensive to break an active tamper resistant device. Note that content of static RAM, if stored for a long period, may be burned in and, hence, easily be read out.</p>

    <p class="text-gray-300">As we have pointed out in this Section, the security level of a cryptographic implementation is a matter of costs and it is very expensive to deter class II and class III attackers. Since a large share of the envisioned applications of low-cost RFID tags protects low-price values, also a low-cost security solution is sufficient. In particular for many cases it might be sufficient to deter class I attackers or raise the cost to break a single device above the value of the protected application. Therefore in the following we concentrate on non-invasive passive attacks, i.e. side-channel attacks, because they only require low-cost equipment and can be mounted without insider knowledge.</p>

    <h3 id="sec-176" class="text-xl font-semibold mt-8">8.5 Introduction to side channel attacks and their countermeasures</h3>

    <p class="text-gray-300">Side channel cryptanalysis has emerged as a serious threat for smart cards and other types of pervasive devices performing cryptographic operations. It was demonstrated in a number of publications that side channel attacks are an extremely powerful and practical tool for breaking unprotected (or insufficiently protected) implementations of crypto systems. These attacks exploit the fact that the execution of a cryptographic algorithm on a physical device leaks information about sensitive data (e.g. secret keys) involved in the computations. Though these attacks have been discovered accidently already in 1943 <em>[167]</em>, it took more than 50 years for the first publication of power analysis attacks in 1999 <em>[131]</em>. Many sources of side channel information have been discovered in recent years, including the timing characteristics of a cryptographic algorithm <em>[130]</em>, as well as deliberately introduced computational faults <em>[16, 27]</em>, but most notably are power analysis attacks <em>[131]</em>, which evolved to an own scientific sub-field with an ever increasing amount of publications. Simple Power Analysis (SPA) uses the leaked information from a single computation, while Differential Power Analysis (DPA) utilizes statistical methods to evaluate the information observed from multiple computations <em>[131]</em>. Currently, there exists no perfect protection against DPA attacks. However, by applying appropriate countermeasures, it is possible to make the attacker’s task more difficult and expensive. These countermeasures can be implemented at the architectural, algorithmic, or cell level. In the</p>

    <p class="text-gray-300">remainder we focus on the latter two. Starting with an overview of countermeasures at the algorithmic level, we then discuss countermeasures at the cell level.</p>

    <h4 id="sec-177" class="text-lg font-semibold mt-6">1 Countermeasures at the algorithmic level</h4>

    <p class="text-gray-300">The two most common countermeasure principles against side channel attacks at the algorithmic level are <em>hiding</em> and <em>masking</em> <em>[147]</em>. This Section provides a brief overview over implementation possibilities of these fundamental principals.</p>

    <h5 id="sec-178" class="text-base font-semibold mt-4">Hiding</h5>

    <p class="text-gray-300"><em>Hiding</em> is a general term for countermeasures that aim to break the link between the power consumption of a cryptographic device and the processed data value <em>[147]</em>. There are two hiding approaches: either the device has a random power consumption such that in each clock cycle a random amount of power is consumed or exactly the same amount of power is dissipated in each cycle. The latter approach tries to implement single operations in a way that each operation with all data values consumes the same amount of data. However, both goals are not possible in practice, but there are several proposal to approach this goal. In the following two proposals that use time de-synchronization are shortly presented. Subsequently two proposal that reduce the signal-to-noise ratio (SNR) are presented.</p>

    <h5 id="sec-179" class="text-base font-semibold mt-4">Random insertion of dummy cycles</h5>

    <p class="text-gray-300">This approach tries to de-synchronize different power traces of the cryptographic device. It randomly inserts dummy operations before, during and after the execution of the algorithm. For an attacker it is important to have aligned traces, such that correlating peaks add up. The random insertion of dummy operations de-aligns measured power traces and hence more traces are required for a successful attack. The drawback of this approach is its longer execution time and hence its lower throughput.</p>

    <h5 id="sec-180" class="text-base font-semibold mt-4">Shuffling</h5>

    <p class="text-gray-300">Many cryptographic algorithms use operations that only modify a part of the internal state at once. S-boxes are a good example for these kind of operations. In the case of AES and present 16 similar S-boxes are applied in parallel to the state. Note that AES has an internal data state of <span class="math">128</span> bits and <span class="math">8\\times 8</span> S-boxes while present has an internal state of <span class="math">64</span> bits and <span class="math">4\\times 4</span> S-boxes. In a serialized implementation, where in each clock cycle only one chunk of <span class="math">4</span> bits (in case of present) is processed by the S-box, <span class="math">16</span> cycles are required for the whole state. Usually the <span class="math">4</span>-bit chunks are processed subsequently and—more important—in the same order for each round of the algorithm. Shuffling randomizes the sequence of similar operations with different random number for each execution and round of the algorithm. As a result the power traces of such a protected implementation are similarly randomized as by the insertion of dummy operations, but the throughput does not suffer. Unfortunately only a limited amount of operations are shuffle-able in an algorithm. However, in practice both countermeasures are often combined.</p>

    <h5 id="sec-181" class="text-base font-semibold mt-4">Increasing the noise</h5>

    <p class="text-gray-300">There are two possibilities to reduce the SNR: increasing the noise or reducing the signal. To increase the noise especially for hardware implementations there exist</p>

    <p class="text-gray-300">a variety of different approaches. The most straightforward approach is to perform several independent operations in parallel. A pipelined parallelized implementation of a cryptographic algorithm performs several encryptions of different—and hence independent—plaintexts at the same time. Consequently it is much harder to attack a parallelized implementation compared to a round-based or serialized implementation. Dedicated noise generators are another approach to increase the noise. These circuits are solely implemented to generate random noise thus increasing <span class="math">Var(P_{en})</span> and hence lower the SNR. Disadvantageous on both approaches is the introduction of significant overhead in terms of area and power consumption.</p>

    <h5 id="sec-182" class="text-base font-semibold mt-4">Reducing the signal</h5>

    <p class="text-gray-300">In order to lower the SNR it is also possible to decrease the signal. It turned out that this a challenging task, because even the smallest deviations in the power consumption of different operations can be exploited by DPA. However, dedicated logic styles try to flatten the power consumption at the cell level. The goal is have a constant power consumption for all different cells such that the overall power consumption is constant. Finally some approaches filter the power consumption of the cryptographic device in order to remove all data- and operation-dependent components.</p>

    <h5 id="sec-183" class="text-base font-semibold mt-4">Masking</h5>

    <p class="text-gray-300">Masking is a countermeasure that aims to release the link between the intermediate values of a cryptographic algorithm and its power consumption by randomization. Masking can be applied on the algorithmic level, i.e. there is no need to change the power characteristics of the device. In Boolean masking the intermediate value <span class="math">v_{m}</span> is bit-wise XORed with the mask, such that <span class="math">v_{m}=v\\oplus m</span> and in arithmetic masking an arbitrary arithmetic operator is used despite the bit-wise XOR. In the remainder of this Thesis we focus on Boolean masking and consequently the term masking refers to Boolean masking unless it is denoted otherwise.</p>

    <p class="text-gray-300">The idea behind masking is to blind the input at the very beginning of the cipher with a random value (the mask) and then process the masked instead of the unmasked value. As a result, the side channel leakage of all intermediate, key-dependent values is not correlated to the unmasked values. Hence, side channel attacks can be effectively thwarted <em>[204]</em>. Finally, in the so-called mask correction step, the mask has to be removed in order to output the correct ciphertext. For this purpose the mask has to be processed by similar operations as the data or key state. For linear operations, e.g. the permutation layer in present, this is simple to implement, because <span class="math">P(x\\oplus m)=P(x)\\oplus m</span> holds. However, for non-linear operations such as S-boxes it is not trivial, because <span class="math">S(x\\oplus m)\\neq S(x)\\oplus S(m).</span> Therefore, the masked S-box <span class="math">S_{m_{1}}</span> has to be adapted for each possible value of the mask <span class="math">m_{1}</span>, such that <span class="math">S_{m_{1}}(x\\oplus m_{1})=S(x)\\oplus m_{1}</span> holds. This enables the mask to flow through the S-box, such that it can be unmasked easily by XORing the mask to the output again. Figure 8.1(a) depicts a schematic of such a modified S-box.</p>

    <p class="text-gray-300">However, if the mask has to be updated in every round, the S-box can be further modified, such that <span class="math">S_{m_{2}}(x\\oplus m^{\\prime})=S(x)\\oplus m_{d}</span> holds. Now the input value <span class="math">x\\oplus m^{\\prime}</span> of the S-box is concealed by a different mask (<span class="math">m^{\\prime}</span>) than the output of the S-box (<span class="math">m_{d}</span>). Figure 8.1(b) depicts a schematic of the masked S-box-m2 entity, which takes <span class="math">x\\oplus m^{\\prime}</span>, <span class="math">m^{\\prime}</span> and <span class="math">m_{d}</span> as inputs and outputs <span class="math">S(x)\\oplus m_{d}</span>. We advised the espresso tool to provide four Boolean output functions according to the specifications. Hence S-box-m1 can be seen as an <span class="math">8\\times 4</span> S-box and S-box-m2 as a <span class="math">12\\times 4</span> S-box.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">8.5. Introduction to side channel attacks and their countermeasures</p>

    <p class="text-gray-300">!<a href="img-74.jpeg">img-74.jpeg</a> (a) Single masked S-box. Figure 8.1: Schematics of single and double masked PRESENT S-boxes.</p>

    <p class="text-gray-300">!<a href="img-75.jpeg">img-75.jpeg</a> (b) Double masked S-box.</p>

    <p class="text-gray-300">After synthesis the masked S-boxes  <span class="math">S_{m_1}</span>  and  <span class="math">S_{m_2}</span>  require 52 GE and 57 GE, which is about twice the size of a standard PRESENT S-box (28 GE).</p>

    <p class="text-gray-300">Both modified S-boxes S-box-m1 and S-box-m2 first remove the mask form the input, process the unmasked value, and then mask the output again. This is an effective countermeasures against side channel attacks that exploit the leakage of flip-flops, such as [158, 157]. However, both S-boxes may be susceptible to side channel attacks that exploit the leakage of the combinatorial parts (toggle-count model).</p>

    <p class="text-gray-300">Masking is in fact a (2,2) secret sharing scheme [206, 31], where both shares of the secret are required to proceed. Unfortunately, higher order DPA attacks (HODPA) can break basic masking schemes. However, Chari et al. have shown in [41] that up to  <span class="math">n</span> -th order DPA attacks can be prevented by using  <span class="math">n</span>  masks. Following this direction, Nikova et al. extend the idea of masking with more than two shares in [168]. They show that non-linear functions implemented in such a way, achieve provable security against first-order DPA attacks and also resists higher-order attacks that are based on a comparison of mean power consumption. Estimations of a hardware implementation of these ideas are presented in [169].</p>

    <p class="text-gray-300">Sense Amplifier Based Logic (SABL), which is a Dual-Rail Precharge (DRP) logic, has been proposed by Tiri et al. [224] as the first DPA countermeasure at the cell level. In fact, in theory using a full-custom design tool enables to equalize the load capacitances of each couple of complementary logic signals and hence to make the power consumption independent of the</p>

    <p class="text-gray-300">processed data. Afterwards, Wave Dynamic Differential Logic (WDDL) <em>[226]</em> has been introduced in order to avoid the usage of full-custom design tools especially for the routing process. Since some place and route methods such as <em>[93, 227]</em> were proposed to diminish the load imbalances of complementary signals, the data-dependent time of evaluation and the memory effect of WDDL cells leave it still vulnerable to DPA attacks <em>[216, 147]</em>.</p>

    <p class="text-gray-300">Although it has been shown that masking at the cell level can not prevent the information leakage because of the presence of glitches <em>[148]</em>, its combination with precharge logics led to Random Switching Logic (RSL) <em>[217]</em> in order to equalize the circuit transition probability. However, Tiri and Schaumont <em>[225]</em> showed that the single mask-bit in RSL just add one bit of entropy. On the other hand, in order to use semi-custom design tools without routing constrains, Masked Dual-Rail Precharge Logic (MDPL) <em>[182]</em> was introduced. It works similar to WDDL and employs a single mask-bit to nullify the effect of load imbalances. Moreover, Dual-Rail Random Switching Logic (DRSL) <em>[42]</em> was proposed to be the dual-rail version of RSL and to avoid the need of a central module to control the precharge signals.</p>

    <p class="text-gray-300">Suzuki et al. showed that MDPL is susceptible to the early propagation effect <em>[215]</em>. The practical evaluation of the SCARD prototype chip proved that the early propagation effect which resulted in a vulnerability of CMOS circuits also exists for MDPL cells <em>[181]</em>. In order to cope with the early propagation issues, the designers of MDPL introduced a so called Evaluation-Precharge Detection Unit (EPDU), which consists of three (CMOS) AND gates and two (CMOS) OR gates. The EPDU is applied to all improved MDPL (iMDPL) gates, hence it is not surprising that the area requirements for iMDPL gates increased significantly compared to MDPL gates.</p>

    <p class="text-gray-300">Gierlichs <em>[79]</em> presented an attack on MDPL that exploits a deviation in the mask bit distribution and unbalanced dual-rails in the target cell. In order to mount this attack an adversary requires detailed knowledge on the layout-level of the device under attack. However, in practice this information is not publicly available or requires insider knowledge or expensive equipment and time-consuming efforts, such as reverse-engineering to gain it.</p>

    <p class="text-gray-300">At that time, Schaumont and Tiri <em>[202]</em> showed that already slightly unbalanced complementary wires can be exploited to mount classical DPA attacks after only a simple filtering operation. Contrary to Gierlichs they did not exploit the unbalanced wires of the mask bit signal, but rather use only the unbalanced dual-rail wires of the logical signals.</p>

    <p class="text-gray-300">Note that the attacks of Gierlichs and of Schaumont/Tiri can also be mounted on circuits built in iMDPL, but again require unbalanced wires and detailed knowledge of the device under attack. Therefore both attacks assume a rather strong attacker model. Furthermore, both attacks and also the attacks by Suzuki et al. <em>[215]</em> and Popp et al. <em>[181]</em> exploit leakage of the combinatorial part of a circuit. Contrary to this, Moradi et al. presented an attack on special circuits built in MDPL and DRSL that exploits the leakage of the underlying flip-flops <em>[158]</em>. They gain the Hamming distance of the mask bit with a Simple Power Analysis (SPA) and subsequently attack the circuit with a Correlation Power Analysis (CPA) <em>[35]</em>. Note that the success rate of any SPA strongly depends on the architecture of the attacked device. However, this attack is focused on a special type of flip-flops and a special architecture of the circuit. In a follow-up work <em>[157]</em> Moradi et al. analyzed the information leakage of CMOS flip-flops as well as the flip-flops of some known DPA-resistant logic styles. Using a modified Hamming distance</p>

    <p class="text-gray-300">model to find the leakage of the CMOS flip-flops used in masked flip-flops their attack does not require any knowledge of the layout of the device nor unbalanced wires and hence can be mounted even by class 1 attackers (clever outsiders). Their attack works even if a masked dual-rail ASIC has perfectly balanced wires.</p>

    <p class="text-gray-300">Yet, perfectly balanced loads can never be achieved in practice because electrical effects will always cause different wire capacitances, even when the routing is done manually in a full-custom design process. Therefore, it is questionable whether dual-rail logic approaches can provide enough resistance against side channel attacks in practice. Hence, the design of side channel countermeasures at the cell level remains an open research problem.</p>

    <h3 id="sec-185" class="text-xl font-semibold mt-8">8.6 Cost overhead estimations of side channel countermeasures</h3>

    <p class="text-gray-300">In this Section the costs of side channel countermeasures for lightweight hardware and software implementations of present-80 are assessed. The goal is to provide figures that estimate the additional costs in terms of area and timing when implementing side channel countermeasures. First a masked serialized present-80/4 hardware architecture is discussed in Section 8.6.1 and subsequently a masked software implementation on a 4-bit microcontroller is assessed in Section 8.6.2.</p>

    <h4 id="sec-186" class="text-lg font-semibold mt-6">8.6.1 Cost overhead estimations for a masked serialized hardware implementations of present</h4>

    <p class="text-gray-300">This section estimates the overhead costs of a masked serialized hardware implementation of present compared to a non-masked implementation. In a masked implementation no two values with the same mask should be stored in registers with a similar leakage model in subsequent clock cycles <em>[147]</em>. This is especially important for lightweight hardware implementations, because the register are reduced to a minimum in order to save area. This in particular means that as few registers or flip-flops are used as possible, which implies that updated values replace current values. For round-based implementations it is immediately clear that in each cycle a new mask has to be applied to all data state and key state bits. A serialized present-80/4 implementations requires a new 4-bit mask for every 4-bit chunk of the data and the key state in every round. Hence, regardless of the architecture, a masked present-80 implementation requires in total <span class="math">32\\cdot(64+80)=4,608</span> mask bits, i.e. random bits.</p>

    <p class="text-gray-300">Figure 8.2 depicts a proposal for a double masked serialized present-80 architecture. It consists of a serialized present-80/4 implementation without the S-boxes component (<span class="math">1,038</span> GE), because it was replaced by S-box-m2 in the datapath and by S-box-m1 in the key schedule. The initial data are input as sixteen 4-bit words <span class="math">W=w_{15}\\ldots w_{0}</span>. These words are masked with random 4-bit words <span class="math">m_{d,i}\\in_{R}\\{0,1\\}</span> before they are stored in the state registers, hence the data state consists of the following sixteen 4-bit words <span class="math">w_{m,15}\\ldots w_{m,0}</span> where <span class="math">w_{m,i}=w_{i}\\oplus m_{d,i}</span> for <span class="math">0\\leq i\\leq 15</span>. Similarly, the initial key <span class="math">K=k_{19}\\ldots k_{0}</span> is input in 4-bit words and masked with random 4-bit words <span class="math">m_{k,j}\\in_{R}\\{0,1\\}</span>. Consequently the key state consists of the following twenty 4 bit words <span class="math">k_{m,19}\\ldots k_{m,0}</span> where <span class="math">k_{m,j}=k_{j}\\oplus m_{k,j}</span> for <span class="math">0\\leq j\\leq 19</span>. For this initial masking step two additional 4-bit XORs with two inputs (<span class="math">18.64</span> GE) are required.</p>

    <p class="text-gray-300">Chapter 8. Physical Security Aspects</p>

    <p class="text-gray-300">Please note that in our notation the masks of the current round are denoted with <span class="math">m_{d,i}</span> and <span class="math">m_{k,j}</span> while the values of the masks from the previous round are denoted with <span class="math">m_{d,i}^{\\prime}</span> and <span class="math">m_{k,j}^{\\prime}</span>. Therefore, after each round the following transitions occurs</p>

    <p class="text-gray-300"><span class="math">m_{d,i}^{\\prime}</span> <span class="math">\\leftarrow m_{d,i},\\text{for }0\\leq i\\leq 15</span> <span class="math">m_{k,j}^{\\prime}</span> <span class="math">\\leftarrow m_{k,j},\\text{for }0\\leq j\\leq 19</span></p>

    <p class="text-gray-300">and consequently also</p>

    <p class="text-gray-300"><span class="math">w_{m^{\\prime},15}\\ldots w_{m,0}</span> <span class="math">\\leftarrow w_{m,15}\\ldots w_{m^{\\prime},0}</span> <span class="math">k_{m^{\\prime},19}\\ldots k_{m,0}</span> <span class="math">\\leftarrow k_{m,19}\\ldots k_{m^{\\prime},0}</span></p>

    <p class="text-gray-300">where <span class="math">w_{m^{\\prime},i}=w_{i}\\oplus m_{d,i}^{\\prime}</span> for <span class="math">0\\leq i\\leq 15</span> and <span class="math">k_{m^{\\prime},i}=k_{i}\\oplus m_{k,i}^{\\prime}</span> for <span class="math">0\\leq i\\leq 19</span>. This implies that the mask bits have to be stored for one round, which requires <span class="math">144</span> additional flip-flops (<span class="math">864</span> GE).</p>

    <p class="text-gray-300">After initialization, the first <span class="math">4</span>-bit word of the data state <span class="math">w_{m^{\\prime},0}</span> is XORed with the corresponding key nibble <span class="math">k_{m^{\\prime},0}</span> and subsequently processed by the S-box-m2 before it is stored again in the data state register. As mentioned above the data state has to be concealed with a different mask prior to storing, which is performed by the S-box-m2 component. The S-box input <span class="math">x_{m^{\\prime},i}</span> consists of the XOR sum of the masked data state word <span class="math">w_{m^{\\prime},i}</span> and the corresponding masked key state word <span class="math">k_{m^{\\prime},i}</span>, i.e. <span class="math">x_{m^{\\prime},i}=w_{m^{\\prime},i}\\oplus k_{m^{\\prime},i}=(w_{i}\\oplus m_{d,i}^{\\prime})\\oplus(k_{i}\\oplus m_{k,i}^{\\prime})=x_{i}\\oplus m_{i}^{\\prime}</span>, where <span class="math">x_{i}=w_{i}\\oplus k_{i}</span> and <span class="math">m_{i}^{\\prime}=m_{d,i}^{\\prime}\\oplus m_{k,i}^{\\prime}</span>. Recall that S-box-m2 was designed such that <span class="math">S_{m_{2}}(x\\oplus m^{\\prime})=S(x)\\oplus m_{d}</span>, hence the output of S-box-m2 is <span class="math">S(w_{i}\\oplus k_{i})\\oplus m_{d,i}</span>. In order to provide <span class="math">m_{i}^{\\prime}</span> a <span class="math">4</span>-bit XOR with two inputs is required (<span class="math">9.32</span> GE).</p>

    <p class="text-gray-300">In the same cycle the key state word is fed back into the key state register. In order to update the key mask, one <span class="math">4</span>-bit XOR with three inputs (<span class="math">18.68</span> GE) is required that XORs <span class="math">m_{k,i}</span> and <span class="math">m_{k,i}^{\\prime}</span> to the masked key word <span class="math">k_{m^{\\prime},i}</span>. Therefore the key state is updated with <span class="math">k_{m,i}=k_{m^{\\prime},i}\\oplus m_{k,i}^{\\prime}\\oplus m_{k,i}=(k_{i}\\oplus m_{k,i}^{\\prime})\\oplus m_{k,i}^{\\prime}\\oplus m_{k,i}=k_{i}\\oplus m_{k,i}</span>. After <span class="math">16</span> iterations all data state words have been processed but four key state words have not. Therefore four additional clock cycles, during which the data state sleeps, are required. The permutation layer is processed in a single clock cycle on the complete data state. In total the execution of one round would require <span class="math">16+4+1=21</span> clock cycles. After repetition of <span class="math">31</span> times in the final round the output has to be unmasked. For this purpose a <span class="math">4</span> bit XOR with two inputs is required (<span class="math">9.32</span> GE).</p>

    <p class="text-gray-300">Please note that the S-boxes unit replaces the S-box component of the serialized present-80/4 implementation while all other units from Table 8.1 require additional area. The S-box component of the plain present-80/4 implementation consists of a <span class="math">4</span>-bit MUX (<span class="math">9.32</span> GE) and an S-box (<span class="math">28</span> GE), which sums up to <span class="math">37.2</span> GE. Consequently the contribution of the S-boxes unit to the overhead was reduced by <span class="math">37</span> GE and in the following Table 8.2 only the difference was taken into account. As one can see a masked implementation requires less than double the area of a non-masked one and is slightly above the <span class="math">2,000</span> GE barrier. Similar to the plain implementation, the majority of the area is required for storage, because for every data and key state bit also a mask bit has to be stored. The timing overhead is caused by the fact that the key state is <span class="math">16</span> bits longer than the data state. Since the mask bits are provided in <span class="math">4</span>-bit chunks, <span class="math">4</span> additional clock cycles are required per round in order to update the mask of the key state. Since also the plain implementation requires <span class="math">20</span> clock cycles to read in the key at the beginning of each new message block, this overhead occurs only during <span class="math">31</span> rounds. In total <span class="math">31\\cdot 4=124</span> additional clock cycles would be required for a masked implementation.</p>

    <p class="text-gray-300">As a next step this proposal needs to be implemented and its power consumption has to be simulated to assess the achieved resistance against side channel attacks. Then if the results are</p>

    <p class="text-gray-300">8.6. Cost overhead estimations of side channel countermeasures</p>

    <p class="text-gray-300">!<a href="img-76.jpeg">img-76.jpeg</a> Figure 8.2: Proposal for a serialized double masked PRESENT-80 architecture.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">module</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">area [GE]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">%</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">S-box-m1</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">5.05</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">S-box-m2</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">5.54</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">XORs</td>

            <td class="px-3 py-2 border-b border-gray-700">init data mask</td>

            <td class="px-3 py-2 border-b border-gray-700">9.32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">init key mask</td>

            <td class="px-3 py-2 border-b border-gray-700">9.32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">md ⊕ mk</td>

            <td class="px-3 py-2 border-b border-gray-700">9.32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">data unmask</td>

            <td class="px-3 py-2 border-b border-gray-700">9.32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key mask update</td>

            <td class="px-3 py-2 border-b border-gray-700">18.68</td>

            <td class="px-3 py-2 border-b border-gray-700">1.82</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">flip-flops</td>

            <td class="px-3 py-2 border-b border-gray-700">data mask</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">37.32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">key mask</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">46.65</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sum</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1,029</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8.1: Estimated area requirements of masking components for serialized PRESENT-80/4.</p>

    <p class="text-gray-300">Chapter 8. Physical Security Aspects</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">component</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">unit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">area</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">clock cycles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">[GE]</td>

            <td class="px-3 py-2 border-b border-gray-700">rel.</td>

            <td class="px-3 py-2 border-b border-gray-700">[CLK]</td>

            <td class="px-3 py-2 border-b border-gray-700">rel.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRESENT-80/4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1,075</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">547</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">masking overhead</td>

            <td class="px-3 py-2 border-b border-gray-700">S-boxes</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">XORs</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">0.23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">flip-flops</td>

            <td class="px-3 py-2 border-b border-gray-700">864</td>

            <td class="px-3 py-2 border-b border-gray-700">0.80</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total sum</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2,067</td>

            <td class="px-3 py-2 border-b border-gray-700">1.92</td>

            <td class="px-3 py-2 border-b border-gray-700">671</td>

            <td class="px-3 py-2 border-b border-gray-700">1.23</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8.2: Estimated area and timing overhead of masking components for a serialized PRESENT-80/4 implementation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ROM [lines of code]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rel.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Stack [EXP/RET]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rel.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Init. [cycles]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rel.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycles / block [cycles]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rel.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">umasked</td>

            <td class="px-3 py-2 border-b border-gray-700">841</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">25/4</td>

            <td class="px-3 py-2 border-b border-gray-700">1/1</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">55,734</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">masked</td>

            <td class="px-3 py-2 border-b border-gray-700">2,699</td>

            <td class="px-3 py-2 border-b border-gray-700">3.21</td>

            <td class="px-3 py-2 border-b border-gray-700">25/4</td>

            <td class="px-3 py-2 border-b border-gray-700">1/1</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">2.78</td>

            <td class="px-3 py-2 border-b border-gray-700">92,498</td>

            <td class="px-3 py-2 border-b border-gray-700">1.66</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 8.3: Code size and cycle count overhead of a masked PRESENT-80 implementation on the ATAM893-D 4-bit microcontroller.</p>

    <p class="text-gray-300">promising, a real ASIC should be manufactured and attacked in order to assess the security level more realistically.</p>

    <p class="text-gray-300">In Section 5.4.2 a software implementation of PRESENT-80 on a 4-bit microcontroller was presented. This implementation was strengthened using Boolean masking in a straightforward manner and a coding style that achieves a constant runtime. Further implementation details can be found in [234]. Table 8.3 shows the performance of the masked implementation in comparison with the non-masked implementation. As one can see the masked implementation requires more than three times of ROM while the stack requirements stay the same. This is mainly caused by the masked S-box, which is 16 times larger than the unmasked S-box. At the same time the initialization phase is nearly three time as long and the encryption of one data blocks requires  <span class="math">66\\%</span>  more clock cycles. However, with 92,498 clock cycles the masked implementation can encrypt one message block below  <span class="math">200~\\mathrm{ms}</span>  when clocked at  <span class="math">500\\mathrm{kHz}</span> , where the current consumption is still below  <span class="math">10\\mu \\mathrm{A}</span>  (see Section 5.4.2).</p>

    <p class="text-gray-300">The structural problem of most of todays SCA countermeasures is that they significantly increase the area, timing and power consumption of the implemented algorithm compared to a non-protected implementation. Furthermore, many countermeasures require random num</p>

    <p class="text-gray-300">bers, hence also a TRNG or a PRNG has to be available. Since this will also increase the cost of an implementation of the algorithm, it will delay the break-even point and hence the mass deployment of some applications. For ultra-constrained applications, such as passive RFID tags, some countermeasures pose an impregnable barrier, because the power consumption of the protected implementation is much higher than what is available.</p>

    <p class="text-gray-300">Power optimization techniques are an important tool for lightweight implementations of specific pervasive applications and might ease the aforementioned problem. On the one hand they also strengthen implementations against side channel attacks, because they lower the power consumption (the signal), which decreases the signal to noise ratio (SNR). However, on the other hand power saving techniques also <em>weaken</em> the resistance against side channel attacks. One consequence of the power minimization goal is that in the optimal case only those parts of the data path are active that process the relevant information. Furthermore, the width of the data path, <em>i.e.</em> the amount of bits that are processed at one point in time, is reduced by serialization. This however implies that the algorithmic noise is reduced to a minimum, which reduces the amount of required power traces for a successful side channel attack. Even worse, the serialized architecture allows the adversary a divide-and-conquer approach which further reduces the complexity of a side channel attack. Summarizing, it can be concluded that lightweight implementations greatly enhance the success probability of a side channel attack. The practical side channel attack <em>[67]</em> on <em>KeeLoq</em> applications <em>[171]</em> impressively underline this conclusions.</p>

    <p class="text-gray-300">A different approach that combines power saving and SCA resistance is taken by Khatir and Moradi. They propose to use <em>adiabatic logic</em> styles as a countermeasure against SCA attacks <em>[121]</em>. Adiabatic logic uses a time-varying voltage source and its slopes of transition are slowed down. This reduces the energy dissipation of each transition to:</p>

    <p class="text-gray-300"><span class="math">E_{Adiabatic}=\\xi\\frac{RC}{T}CV_{dd}^{2}</span></p>

    <p class="text-gray-300">where <span class="math">T</span> denotes the charging/discharging time, <span class="math">V_{dd}</span> the voltage swing value <span class="math">\\xi</span> is the shaping factor for the power wave form. Recall that the energy dissipation of a CMOS circuit is given by the following equation:</p>

    <p class="text-gray-300"><span class="math">E_{CMOS}=\\frac{1}{2}CV_{dd}^{2}</span></p>

    <p class="text-gray-300">where <span class="math">C</span> denotes the associated capacitance and <span class="math">V_{dd}</span> the supply voltage. In short the idea of adiabatic logic is to use a trapezoidal power-clock voltage rather than fixed supply voltage. As a consequence the power consumption of a circuit is reduced while at the same time its resistance against side-channel attacks is greatly enhanced. Especially for pervasive devices adiabatic logic styles seem to be a promising SCA countermeasure and future publications on this topic will be worth reading.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">9 Conclusion</p>

    <p class="text-gray-300">As we have pointed out in this Thesis, the attacker model is different for pervasive devices compared to traditional computers. Especially the access to and the control over the pervasive devices opens the whole field of physical attacks for a potential adversary. On the other side, pervasive devices are typically very constrained in terms of computing capabilities, memory capacitance, and available power supply. These requirements lead to the need of specifically tailored security solutions for pervasive devices. Furthermore, due to the cost-constraints inherent in mass-deployment always the cheapest, <em>i.e</em>. most constrained, device that fulfills the requirements will be chosen for deployment. Consequently, there is a constant or even increasing demand for lightweight cryptography.</p>

    <p class="text-gray-300">In Chapter 2 we introduced the notation, metrics and further background information as well as the design approaches and trade-offs for lightweight cryptography. We started with the approach of implementing a standardized algorithm with the optimization goal of minimal hardware requirements in Chapter 3. We chose DES, because it is one of the very few algorithms that was designed with a strong focus on hardware efficiency and is probably the best investigated algorithm. As a result we presented the smallest known hardware implementation of DES in Section 3.4.1. The next step was to have a closer look on the hardware requirements of the single components and it turned out that the substitution layer of DES is very demanding in terms of area requirements. Consequently we thought about further optimizations and we decided to slightly and very carefully change the substitution layer of DES. The literature study revealed that so far there was no DES variant published that uses a single S-box repeated eight times. Therefore we studied the design criteria of DES’ S-boxes and the various publications that deal with cryptographic properties of S-boxes.</p>

    <p class="text-gray-300">In Section 3.3 we stated eight conditions which a single S-box has to fulfill in order to be resistant against certain types of linear and differential cryptanalyses, and the Davies-Murphy attack. We presented a strengthened S-box, which is used in the single S-box DES variants DESL and DESXL. Furthermore, we showed, that a differential cryptanalysis with characteristics similar to the characteristics used by Biham and Shamir in <em>[25]</em> is not feasible anymore. We also showed, that DESL is more resistant against the most promising types of linear cryptanalysis than DES due to the improved non-linearity of the S-box. In order to expand the key space we also proposed DESXL, which is a DESX variant based on DESL rather than on DES. Due to the low current consumption and the small chip size required for our DESL design, it is especially suited for resource limited applications, for example RFID tags and wireless sensor nodes. DESL and DESXL are two examples for the approach where a well trusted algorithm is slightly and very carefully modified. In order to gain an even more hardware efficient implementation of a cryptographic algorithm, it is required to design a new lightweight algorithm from scratch.</p>

    <p class="text-gray-300">This approach was followed in Chapter 4, where the new lightweight block cipher present was proposed. Well-known design principles (substitution-permutation network) were used to optimize its structure and every component for lightweight hardware implementation with</p>

    <p class="text-gray-300">a minimal area footprint, hence so to say present is an <em>engineered</em> cipher. The design philosophy of present was to keep it straight and simple wherever possible, because this eases implementation, while at the same time encourages researchers to scrutinize the security of present. In Section 4.6 we have presented our cryptanalytic results that show that present resists all (at the time of publication) known cryptanalytic attacks. Furthermore we also have discussed recent cryptanalytic results from other researchers that to some extent propose new cryptanalytic techniques. Interestingly all results underline the strength of present against these attacks.</p>

    <p class="text-gray-300">In this Thesis we have also intensively explored implementations of present on a wide variety of different platforms, ranging from ASICs and FPGAs, over hardware-software co-design approaches to plain software implementations. The serialized ASIC implementation constitutes with <span class="math">1,000</span> GE the smallest published ASIC implementation of a cryptographic algorithm with a reasonable security level. Also the FPGA-implementation leads to a very compact result (<span class="math">202</span> slices), while providing a maximum frequency of <span class="math">254</span> MHz. ASIC and FPGA figures highlight that though present was designed with a minimal hardware footprint in mind, <em>i.e.</em> targeted for low-cost devices such as RFIDs, present is well suited for high-speed and high-throughput applications. Especially its hardware efficiency, <em>i.e.</em> the throughput per slice or GE, respectively, is noteworthy. Furthermore, interestingly the old-fashioned Boolean minimization tool <em>espresso</em> lead to an FPGA implementation that was significantly smaller than a standard LUT based implementation. Besides this, we have also discussed recently published HW/SW co-design implementation results from other researchers that all underline presents suitability for low-cost and low-power applications that only process small amounts of data.</p>

    <p class="text-gray-300">On the software side we exploited the lightweight structure of present and especially its <span class="math">4</span>-bit S-boxes by implementing present on a <span class="math">4</span>-bit microcontroller. To the best of our knowledge up to now there are no implementation results of cryptographic algorithms for <span class="math">4</span>-bit microcontrollers published. In Chapter 5 we have closed this gap and provided the first implementation results of this kind. We therefore presented a proof-of-concept that state-of-the-art cryptography is feasible on ultra-constrained <span class="math">4</span>-bit microcontrollers. Our implementation draws a current of <span class="math">6.7</span> <span class="math">\\mu</span>A at a supply voltage of <span class="math">1.8</span>V and a frequency of <span class="math">500</span> KHz. Together with the observation that the processing of one data block requires less than <span class="math">200</span> ms we conclude that this implementation is interesting for passively powered RFID tags.</p>

    <p class="text-gray-300">While compact hash functions are often proposed in protocols for RFID tags, there are currently no sufficiently compact candidates to hand. In Chapter 6 we have explored the possibility of building a hash function out of a block cipher such as present. We have described hash functions that offer 64- and 128-bit outputs based on current design strategies. For their parameter sets these are the most compact hash function candidates available today. In particular, h-present-128 requires around <span class="math">4,000</span> GE, which is similar to the best known AES implementation and about 50% smaller than the best reported MD5 implementation. At the same time, h-present-128 requires between 20–30 <em>times</em> fewer clock cycles than compact AES and MD5 implementations, giving it a major time-area advantage. Obviously 128-bit hash functions are relevant for applications where a security-performance trade-off is warranted. To obtain larger hash outputs there are severe complications and we suspect that dedicated designs could be more appropriate.</p>

    <p class="text-gray-300">Lightweight public-key cryptography was investigated in Chapter 7. There we have described a proof-of-concept prototype board that simulates an RFID tag and contains a crypto-GPS ASIC. Several well-known optimizations of crypto-GPS have been described and three different hardware architectures of the crypto-GPS scheme have been presented. The implemen</p>

    <p class="text-gray-300">tation figures show that public key cryptography with a security level equivalent to <span class="math">80</span> bits can be implemented with as few as <span class="math">2,181</span> GE including also memory and PRNG components. For <span class="math">375</span> additional GE a more than <span class="math">6</span> times faster implementation (<span class="math">1,696</span> vs. <span class="math">10,723</span> clock cycles) can be realized. Both of these variants have a fixed secret <span class="math">s</span> and an implementation with a variable secret <span class="math">s</span> requires <span class="math">3,976</span> GE and takes <span class="math">1,696</span> clock cycles.</p>

    <p class="text-gray-300">The area and power minimization goals of lightweight cryptographic implementations also bear security risks with regard to physical attacks. While on the one hand power saving techniques reduce the signal, which in turn decreases the signal to noise ratio (SNR), on the other hand together with a serialized datapath they decrease the algorithmic noise to a minimum, thus increasing the SNR. This in turn greatly increase the success probability of side channel attacks. Therefore in Chapter 8 we classified pervasive devices with respect to physical security aspects. Furthermore, we have estimated the costs of masking for lightweight hardware and software implementations of present. One observation from previously published countermeasures against side channel attacks is that each countermeasure introduces a significant overhead in area, clock cycles, and/or power consumption. Even more interesting, though the relative overhead stays the same for different algorithms, the total overhead in terms of area and power consumption (and also the costs) decreases with a more efficient algorithm. Especially with regard to the adapted Moore’s law this can be a strong argument for or against a certain algorithm. Under this assumption area and power minimization becomes ever more important and adiabatic logic seems to be a very promising logic style for pervasive devices.</p>

    <p class="text-gray-300">In short, the implementation results that have been described in this Thesis lead to the following conclusions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The widespread assumption that stream-ciphers can be implemented more efficiently in hardware compared to block ciphers does not hold anymore, since the block cipher present requires only <span class="math">1,000</span> GE.</li>

      <li>Consequently, hash functions with a digest size of <span class="math">64</span> or <span class="math">128</span> bits that are based on block ciphers can be implemented efficiently in hardware as well. Though it is not easy to obtain lightweight hash functions with a digest size of greater or equal to <span class="math">160</span> bits. Given the required parameters, it is very unlikely that the NIST SHA-3 hash competition will lead to a lightweight approach. Hence, lightweight hash functions with a digest size of greater or equal to <span class="math">160</span> bits remain an open research problem.</li>

      <li>It is possible to implement the asymmetric cryptographic identification scheme crypto-GPS with only <span class="math">2,181</span> GE including storage and PRNG. However, crypto-GPS has a limited (though configurable) amount of pre-computed coupons. It would be interesting to see lightweight implementations of asymmetric identification schemes that do not have this constraints.</li>

    </ol>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">Bibliography</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] D.G. Abraham, G.M. Dolan, G.P. Double, and J.V. Stevens. Transaction Security System. IBM Systems Journal, 30(2):206–229, 1991.</li>

      <li>[2] M. Albrecht and C. Cid. Algebraic Techniques in Differential Cryptanalysis. In Fast Software Encryption 2009 – FSE 2009, Lecture Notes in Computer Science. Springer-Verlag, to appear., 2009.</li>

      <li>[3] Altium Limited. TASKING VX-Toolset for C166 User Guide. Available via http://tinyurl.com/pwtlra, September 2008.</li>

      <li>[4] AMI Semiconductors. MTC45000 Standard Cell Design Data Book <span class="math">0.35</span> <span class="math">\\mu</span>m CMOS, December 1996.</li>

      <li>[5] Y. An and S. Oh. RFID System for User’s Privacy Protection. In IEEE Asia-Pacific Conference on Communications, pages 16–519. IEEE Computer Society, 2005.</li>

      <li>[6] R. Anderson. Security Engineering: A Guide to Building Dependable Distributed Systems. John Wiley & Sons, Inc. New York, NY, USA, 2001.</li>

      <li>[7] R. Anderson, M. Bond, J. Clulow, and S. Skorobogatov. Cryptographic Processors - a Survey. Proceedings of the IEEE, 94(2):357–369, 2006.</li>

      <li>[8] R. Anderson and M. Kuhn. Tamper Resistance - a Cautionary Note. In Second Usenix Workshop on Electronic Commerce, pages 1–11, November 1996.</li>

      <li>[9] Atmel. 8-bit AVR Instruction Set. Available via http://www.atmel.com/dyn/resources/prod_documents/doc0856.pdf.</li>

      <li>[10] Atmel. AVR Studio 4.13. Available via http://www.atmel.com/dyn/products/tools_card.asp?tool_id=2725.</li>

      <li>[11] Atmel. Datasheet of ATMega163, an 8-bit AVR Microcontroller with 16K Bytes In-System Programmable Flash. Available via http://www.atmel.com/dyn/resources/prod_documents/doc1142.pdf, 2003.</li>

      <li>[12] Atmel. Datasheet of ATMega323, an 8-bit AVR Microcontroller with 32K Bytes In-System Programmable Flash. Available via http://www.atmel.com/dyn/resources/prod_documents/doc1457.pdf, 2003.</li>

      <li>[13] Atmel. Flash Version for ATAR080 ATAR090/890 ATAR092/892 and ATAM893-D . Available via http://www.atmel.com/dyn/resources/prod_documents/doc4680.pdf, 2005.</li>

      <li>[14] G. Avoine and P. Oechslin. A Scalable and Provably Secure Hash-based RFID Protocol. In 3rd IEEE Conference on Pervasive Computing and Communications Workshops — PerCom 2005, pages 110–114. IEEE Computer Society, 2005.</li>

      <li>[15] D. Bailey and A. Juels. Shoehorning Security into the EPC Standard. In R. De Prisco and M. Yung, editors, Security in Communication Networks — SCN 2006, volume 4116 of Lecture Notes in Computer Science, pages 303–320, Maiori, Italy, September 2006. Springer-Verlag.</li>

    </ul>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[16] H. Bar-El, H. Choukri, D. Naccache, M. Tunstall, and C. Whelan. The Sorcerer’s Apprentice Guide to Fault Attacks. Proceedings of the IEEE, 94(2):370–382, 2006.</p>

    <p class="text-gray-300">[17] P. Baretto and V. Rijmen. The Whirlpool Hashing Function. Available via http://www.larc.usp.br/~pbarreto/WhirlpoolPage.html.</p>

    <p class="text-gray-300">[18] L. Batina, J. Guajardo, T. Kerins, N. Mentens, P. Tuyls, and I. Verbauwhede. An Elliptic Curve Processor Suitable For RFID-Tags. Cryptology ePrint Archive, Report 2006/227, available via http://eprint.iacr.org/, 2006.</p>

    <p class="text-gray-300">[19] G. Bertoni, L. Breveglieri, P. Fragneto, M. Macchetti, and S. Marchesin. Efficient Software Implementation of AES on 32-Bit Platforms. In C.D. Walter, C.K. Koç, and C. Paar, editors, Cryptographic Hardware and Embedded Systems — CHES 2003, volume 2779 of Lecture Notes in Computer Science, pages 159–171. Springer-Verlag, 2003.</p>

    <p class="text-gray-300">[20] E. Biham. New Types of Cryptanalytic Attacks Using Related Keys. In T. Helleseth, editor, EUROCRYPT 1993, volume 765 of Lecture Notes in Computer Science, pages 398–409. Springer-Verlag, 1994.</p>

    <p class="text-gray-300">[21] E. Biham. A Fast New DES Implementation in Software. In <em>Fast Software Encryption</em> 1997 – FSE 1997, volume 1267 of Lecture Notes in Computer Science, pages 260–272. Springer-Verlag, 1997.</p>

    <p class="text-gray-300">[22] E. Biham and A. Biryukov. How to Strengthen DES Using Existing Hardware. In Advances in Cryptology — ASIACRYPT 1994. Lecture Notes in Computer Science, Springer-Verlag, 1994. Available via citeseer.ist.psu.edu/biham94how.html.</p>

    <p class="text-gray-300">[23] E. Biham and A. Biryukov. An Improvement of Davies’ Attack on DES. Journal of Cryptology, 10(3):195–205, Summer 1997. Available via citeseer.ist.psu.edu/467934.html.</p>

    <p class="text-gray-300">[24] E. Biham and O. Dunkelman. A Framework for Iterative Hash Functions - HAIFA. Presented at Second NIST Cryptographic Hash Workshop, available via csrc.nist.gov/groups/ST/hash/, August 2006.</p>

    <p class="text-gray-300">[25] E. Biham and A. Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In A.J. Menezes and S.A. Vanstone, editors, Advances in Cryptology — CRYPTO 1990, volume Lecture Notes in Computer Science 537, pages 2–21. Springer-Verlag, 1991.</p>

    <p class="text-gray-300">[26] E. Biham and A. Shamir. Differential Cryptanalysis of the Full 16-Round DES. In Advances in Cryptology — CRYPTO 1992, volume 740 of Lecture Notes in Computer Science, pages 487–496, 1992. Available via citeseer.ist.psu.edu/biham93differential.html.</p>

    <p class="text-gray-300">[27] E. Biham and A. Shamir. Differential Fault Analysis of Secret Key Cryptosystems. In B. S. Kaliski, editor, Advances in Cryptology — CRYPTO 1997, volume 1294 of Lecture Notes in Computer Science, pages 513–525. Springer-Verlag, 1997.</p>

    <p class="text-gray-300">[28] A. Biryukov, S. Mukhopadhyay, and P. Sarkar. Improved time-memory trade-offs with multiple data. In B. Preneel and S. Tavares, editors, Selected Areas in Cryptography — SAC 2005, volume 3897 of Lecture Notes in Computer Science, pages 110–127. Springer-Verlag.</p>

    <p class="text-gray-300">[29] A. Biryukov and D. Wagner. Advanced Slide Attacks. In B. Preneel, editor, Eurocrypt 2000, volume 1807 of Lecture Notes in Computer Science, pages 589–606. Springer-Verlag, 2000.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[30] J. Black, P. Rogaway, and T. Shrimpton. Black-Box Analysis of the Block-Cipher-Based Hash-Function Constructions from PGV. In M. Yung, editor, <em>Advances in Cryptology — CRYPTO 2002</em>, volume 2442 of <em>Lecture Notes in Computer Science</em>, pages 320–335. Springer-Verlag, 2002.</p>

    <p class="text-gray-300">[31] G. R. Blakley. Safeguarding Cryptographic Keys. In <em>National Computer Conference</em>, pages 313–317, 1979.</p>

    <p class="text-gray-300">[32] A. Bogdanov. Attacks on the KeeLoq Block Cipher and Authentication Systems. In <em>RFID Security — RFIDsec 2007, Workshop Record</em>, 2007.</p>

    <p class="text-gray-300">[33] A. Bogdanov, G. Leander, L.R. Knudsen, C. Paar, A. Poschmann, M.J.B. Robshaw, Y. Seurin, and C. Vikkelsoe. PRESENT - An Ultra-Lightweight Block Cipher. In P. Paillier and I. Verbauwhede, editors, <em>Cryptographic Hardware and Embedded Systems — CHES 2007</em>, number 4727 in <em>Lecture Notes in Computer Science</em>, pages 450–466. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[34] A. Bogdanov, G. Leander, C. Paar, A. Poschmann, M. J.B. Robshaw, and Y. Seurin. Hash Functions and RFID Tags: Mind the Gap. In E. Oswald and P. Rohatgi, editors, <em>Cryptographic Hardware and Embedded Systems — CHES 2008</em>, number 5154 in <em>Lecture Notes in Computer Science</em>, pages 283–299. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[35] E. Brier, C. Clavier, and F. Olivier. In M. Joye and J.-J. Quisquater, editors, <em>Cryptographic Hardware and Embedded Systems — CHES 2004</em>.</p>

    <p class="text-gray-300">[36] L. Brown, J. Pieprzyk, and J. Seberry. LOKI - A Cryptographic Primitive for Authentication and Secrecy Applications. In J. Pieprzyk and J. Seberry, editors, <em>Advances in Cryptology — AUSCRYPT 1990</em>, volume 453 of <em>Lecture Notes in Computer Science</em>, pages 229–236. Springer-Verlag, 1990.</p>

    <p class="text-gray-300">[37] P. Bulens, F.-X. Standaert, J.-J. Quisquater, P. Pellegrin, and G. Rouvroy. Implementation of the AES-128 on Virtex-5 FPGAs. In S. Vaudenay, editor, <em>Progress in Cryptology — AFRICACRPT 2008</em>, pages 16–26, 2008.</p>

    <p class="text-gray-300">[38] C. Lim and T. Korkishko. mCrypton - A Lightweight Block Cipher for Security of Low-cost RFID Tags and Sensors. In J. Song, T. Kwon, and M. Yung, editors, <em>Workshop on Information Security Applications — WISA 2005</em>, volume 3786 of <em>Lecture Notes in Computer Science</em>, pages 243–258. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[39] Cast Inc. Cast AES32-C. Available via www.cast-inc.com.</p>

    <p class="text-gray-300">[40] D. Chang. A Practical Limit of Security Proof in the Ideal Cipher Model: Possibility of Using the Constant As a Trapdoor In Several Double Block Length Hash Functions. IACR Cryptology ePrint Archive, Report 2006/481. Available via http://eprint.iacr.org/2006/481, 2006.</p>

    <p class="text-gray-300">[41] S. Chari, C. S. Jutla, J. R. Rao, and P. Rohatgi. Towards Sound Approaches to Counteract Power-Analysis Attacks. In M. Wiener, editor, <em>Advances in Cryptology — CRYPTO 1999</em>, volume 1666 of <em>Lecture Notes in Computer Science</em>, pages 398–412. Springer-Verlag, 1999.</p>

    <p class="text-gray-300">[42] Z. Chen and Y. Zhou. Dual-Rail Random Switching Logic: A Countermeasure to Reduce Side Channel Leakage. In L. Goubin and M. Matsui, editors, <em>Cryptographic Hardware and Embedded Systems — CHES 2006</em>, volume 4249 of <em>Lecture Notes in Computer Science</em>, pages 242–254. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[43] P. Chodowiec and K. Gaj. Very Compact FPGA Implementation of the AES Algorithm. In C.D. Walter, C.K. Koc, and C. Paar, editors, Cryptographic Hardware and Embedded Systems — CHES 2003, number 2779 in Lecture Notes in Computer Science, pages 319–333. Springer-Verlag, 2003.</p>

    <p class="text-gray-300">[44] C. Cid and G. Leurent. An Analysis of the XSL Algorithm. In B. Roy, editor, Advances in Cryptology — ASIACRPT 2005, volume 3788 of Lecture Notes in Computer Science, pages 333–352. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[45] C. Cid, S. Murphy, and M.J.B. Robshaw. Small Scale Variants of the AES. In H. Gilbert and H. Handschuh, editors, FSE 2005, volume 3557 of Lecture Notes in Computer Science, pages 145–162. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[46] B. Collard. http://www.dice.ucl.ac.be/crypto/people/show/217.</p>

    <p class="text-gray-300">[47] B. Collard and F.-X. Standaert. A Statistical Saturation Attack against the Block Cipher PRESENT. In Topics in Cryptology — CT-RSA 2009, to appear.</p>

    <p class="text-gray-300">[48] D. Coppersmith. The Data Encryption Standard (DES) and its Strength Against Attacks. Technical report rc 186131994, IBM Thomas J. Watson Research Center, December 1994.</p>

    <p class="text-gray-300">[49] D. Coppersmith, S. Pilpel, C.H. Meyer, S.M. Matyas, M.M. Hyden, J. Oseas, B. Brachtl, and M. Schilling. Data Authentication Using Modification Detection Codes Based on a Public One Way Encryption Function. U.S. Patent No. 4,908,861, March 13 1990.</p>

    <p class="text-gray-300">[50] N. Courtois, A. Klimov, J. Patarin, and A. Shamir. Efficient Algorithms for Solving Overdefined Systems of Multivariate Polynomial Equations. In B. Preneel, editor, Advances in Cryptology — EUROCRYPT 2000, volume 1807 of Lecture Notes in Computer Science, pages 392–407. Springer-Verlag, 2000.</p>

    <p class="text-gray-300">[51] N. Courtois and J. Pieprzyk. Cryptanalysis of Block Ciphers with Overdefined Systems of Equations. In Y. Zheng, editor, Advances in Cryptology — ASIACRPT 2002, volume 2501 of Lecture Notes in Computer Science, pages 267–287. Springer-Verlag, 2002.</p>

    <p class="text-gray-300">[52] Crossbow Technology Inc. MPR-MIB Users Manual. Available via http://www.xbow.com/Support/Support_pdf_files/MPR-MIB_Series_Users_Manual.pdf, June 2007.</p>

    <p class="text-gray-300">[53] J. Daemen, L. Knudsen, and V. Rijmen. The Block Cipher Square. In E. Biham, editor, Fast Software Encryption — FSE 1997, volume 1267 of Lecture Notes in Computer Science, pages 149–165. Springer-Verlag, 1997.</p>

    <p class="text-gray-300">[54] J. Daemen and V. Rijmen. The Design of Rijndael. Springer-Verlag, Berlin, Germany, 2002.</p>

    <p class="text-gray-300">[55] I. Damgård. A Design Principle for Hash Functions. In G. Brassard, editor, Advances in Cryptology — CRYPTO 1989, volume 435 of Lecture Notes in Computer Science, pages 416–427. Springer-Verlag, 1989.</p>

    <p class="text-gray-300">[56] D. Davies and S. Murphy. Pairs and Triplets of DES S-Boxes. Journal of Cryptology, 8(1):1–25, 1995.</p>

    <p class="text-gray-300">[57] C. de Cannière and B. Preneel. Trivium. Available via www.ecrypt.eu.org/stream.</p>

    <p class="text-gray-300">[58] R.D. Dean. Formal Aspects of Mobile Code Security. PhD thesis, Princeton University, 1999.</p>

    <p class="text-gray-300">[59] S. Devadas and S. Malik. A survey of optimization techniques targeting low power VLSI circuits. In ACM/IEEE Conference on Design Automation, pages 242–247, 1995.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[60] C. Diem. The XL-Algorithm and a Conjecture from Commutative Algebra. In P.J. Lee, editor, <em>Advances in Cryptology — ASIACRPT 2004</em>, volume 3329 of <em>Lecture Notes in Computer Science</em>, pages 323–337. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[61] T. Dimitriou. A lightweight rfid protocol to protect against traceability and cloning attacks. In <em>IEEE International Conference on Security and Privacy of Emerging Areas in Communication Networks (SecureComm 2005)</em>, pages 59–66. IEEE Computer Society, 2005.</p>

    <p class="text-gray-300">[62] T. Dimitriou. A Secure and Efficient RFID Protocol that could make Big Brother (partially) Obsolete. In <em>International Conference on Pervasive Computing and Communications – PerCom 2006</em>, pages 269–275, Pisa, Italy, March 2006. IEEE Computer Society.</p>

    <p class="text-gray-300">[63] I. Dinur and A. Shamir. Cube Attacks on Tweakable Black Box Polynomials. <em>Cryptology ePrint Archive</em>, Report 2008/385, available via http://eprint.iacr.org/2008/385, 2008.</p>

    <p class="text-gray-300">[64] Dolphin Integration. SESAME-LP2 – Description of the Standard Cells for the Process IHP 0.25 μm – ViC Specifications, December 2005.</p>

    <p class="text-gray-300">[65] S. Dominikus, E. Oswald, and M. Feldhofer. Symmetric authentication for RFID systems in practice. RFID and Lightweight Crypto — RFIDsec 2005, Workshop Record, July 2005.</p>

    <p class="text-gray-300">[66] T. J. Donohue. The State of American Business 2007. Technical report, United States Chamber of Commerce, 2007.</p>

    <p class="text-gray-300">[67] T. Eisenbarth, T. Kasper, A. Moradi, C. Paar, M. Salmasizadeh, and M. T. M. Shalmani. On the power of power analysis in the real world: A complete break of the keeloqcode hopping scheme. In <em>CRYPTO</em>, pages 203–220, 2008.</p>

    <p class="text-gray-300">[68] T. Eisenbarth, S. Kumar, C. Paar, A. Poschmann, and L. Uhsadel. A Survey of Lightweight Cryptography Implementations. <em>IEEE Design &amp; Test of Computers – Special Issue on Secure ICs for Secure Embedded Computing</em>, 24(6):522 – 533, November/December 2007.</p>

    <p class="text-gray-300">[69] J. C Faugère. A new efficient algorithm for computing Gröbner bases (<span class="math">F_4</span>). <em>Journal of Pure and Applied Algebra</em>, 139(1):61 – 88, June 1999.</p>

    <p class="text-gray-300">[70] M. Feldhofer. An Authentication Protocol in a Security Layer for RFID Smart Tags. In <em>The 12th IEEE Mediterranean Electrotechnical Conference — MELECON 2004</em>, volume 2, pages 759–762, Dubrovnik, Croatia, May 2004. IEEE.</p>

    <p class="text-gray-300">[71] M. Feldhofer, S. Dominikus, and J. Wolkerstorfer. Strong Authentication for RFID Systems Using the AES algorithm. In M. Joye and J.-J. Quisquater, editor, <em>Cryptographic Hardware and Embedded Systems — CHES 2004</em>, volume 3156 of <em>Lecture Notes in Computer Science</em>, pages 357–370. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[72] M. Feldhofer and C. Rechberger. A Case Against Currently Used Hash Functions in RFID Protocols. In <em>First International Workshop on Information Security — IS 2006</em>, volume 4277 of <em>Lecture Notes in Computer Science</em>, pages 372–381. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[73] M. Feldhofer, J. Wolkerstorfer, and V. Rijmen. AES Implementation on a Grain of Sand. <em>Information Security, IEE Proceedings</em>, 152(1):13–20, 2005.</p>

    <p class="text-gray-300">[74] K. Finkenzeller. <em>RFID Handbook: Fundamentals and Applications in Contactless Smart Cards and Identification</em>. John Wiley and Sons, 2003.</p>

    <p class="text-gray-300">[75] F. Fürbass and J. Wolkerstorfer. ECC Processor with Low Die Size for RFID Applications. In <em>IEEE International Symposium on Circuits and Systems 2007 – ISCAS 2007</em>, pages 1835–1838, 2007.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[76] J.-P. Kaps G. Gaubatz and B. Sunar. Public Key Cryptography in Sensor Networks—Revisited. In C. Castellucia, H. Hartenstein, C. Paar, and d. Westhoff, editors, <em>Proceeding of the 1st European Workshop on Security in Ad-Hoc and Sensor Networks – ESAS 2004</em>, volume 3312 of <em>Lecture Notes in Computer Science</em>, pages 2–18. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[77] X. Gao, Z. Xian, H. Wang, J. Shen, J. Huang, and S. Song. An Approach to Security and Privacy of RFID System for Supply Chain. In <em>IEEE International Conference on E-Commerce Technology for Dynamic E-Business</em>, pages 164–168. IEEE Computer Society, 2004.</p>

    <p class="text-gray-300">[78] X. Gao, Z. Xiang, H. Wang, J. Shen, J. Huang, and S. Song. An Approach to Security and Privacy of RFID System for Supply Chain. In <em>Conference on E-Commerce Technology for Dynamic E-Business — CEC-East2004</em>, pages 164–168, Beijing, China, September 2005. IEEE, IEEE Computer Society.</p>

    <p class="text-gray-300">[79] B. Gierlichs. DPA-Resistance Without Routing Constraints? – A Cautionary Note About MDPL Security. In P. Paillier and I. Verbauwhede, editors, <em>Cryptographic Hardware and Embedded Systems — CHES 2007</em>, volume 4727 of <em>Lecture Notes in Computer Science</em>, pages 107–120. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[80] H. Gilbert and M. Minier. A Collision Attack on 7 Rounds of Rijndael. In <em>3rd AES Candidate Conference</em>, pages 230–241, 2000.</p>

    <p class="text-gray-300">[81] M. Girault. Self-Certified Public Keys. In D. W. Davies, editor, <em>Advances in Cryptology — EUROCRYPT 1991</em>, volume 547 of <em>Lecture Notes in Computer Science</em>, pages 490–497. Springer-Verlag, 1991.</p>

    <p class="text-gray-300">[82] M. Girault. Low-Size Coupons for Low-Cost IC Cards. In J. Domingo-Ferrer, D. Chan, and A. Watson, editors, <em>4th Working Conference on Smart Card Research and Advanced Applications on Smart Card Research and Advanced Applications</em>, pages 39–50, Norwell, MA, USA, 2001. Kluwer Academic Publishers.</p>

    <p class="text-gray-300">[83] M. Girault, L. Juniot, and M.J.B. Robshaw. The Feasibility of On-the-Tag Public Key Cryptography. In <em>RFID Security 2007 — RFIDsec 2007, Workshop Record</em>, 2007.</p>

    <p class="text-gray-300">[84] M. Girault and D. Lefranc. Public Key Authentication with One (Online) Single Addition. In M. Joye and J.-J. Quisquater, editor, <em>Cryptographic Hardware and Embedded Systems - CHES 2004</em>, volume 3156 of <em>Lecture Notes in Computer Science</em>, pages 967–984. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[85] M. Girault, G. Poupard, and J. Stern. On the Fly Authentication and Signature Schemes Based on Groups of Unknown Order. <em>Journal of Cryptology</em>, 19:463–487, 2006.</p>

    <p class="text-gray-300">[86] M. Girault and J. Stern. On the Length of Cryptographic Hash-Values Used in Identification Schemes. In Y. Desmedt, editor, <em>Advances in Cryptology — CRYPTO 1994</em>, volume 893 of <em>Lecture Notes in Computer Science</em>, pages 202–215. Springer-Verlag, 1994.</p>

    <p class="text-gray-300">[87] S. Goldwasser and S. Micali. Probabilistic Encryption &amp; How to Play Mental Poker Keeping Secret All Partial Information. In <em>ACM Symposium on Theory of Computing — STOC 1982</em>, pages 365–377, New York, NY, USA, 1982. ACM.</p>

    <p class="text-gray-300">[88] T. Good and M. Benaissa. AES on FPGA from the Fastest to the Smallest. In J.R. Rao and B. Sunar, editors, <em>Cryptographic Hardware and Embedded Systems — CHES 2005</em>, number 3659 in <em>Lecture Notes in Computer Science</em>, pages 427–440. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[89] T. Good and M. Benaissa. Hardware Results for Selected Stream Cipher Candidates. State of the Art of Stream Ciphers 2007 (SASC 2007), Workshop Record, February 2007. Available via www.ecrypt.eu.org/stream.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[90] F. Gosset, F.-X. Standaert, and J.-J. Quisquater. FPGA Implementation of SQUASH. In Twenty-ninth Symposium on Information Theory in the Benelux, 2008.</p>

    <p class="text-gray-300">[91] P. Grabher, J. Großschädl, and D. Page. Light-Weight Instruction Set Extensions for Bit-Sliced Cryptography. In E. Oswald and P. Rohatgi, editors, Cryptographic Hardware and Embedded Systems — CHES 2008, number 5154 in Lecture Notes in Computer Science, pages 331–345. Springer-Verlag, August 2008.</p>

    <p class="text-gray-300">[92] Mentor Graphics. ModelSim SE User’s Manual. Available via http://www.model.com/resources/resources\\_manuals.asp.</p>

    <p class="text-gray-300">[93] S. Guilley, P. Hoogvorst, Y. Mathieu, and R. Pacalet. The "Backend Duplication" Method. In J.R. Rao and B. Sunar, editors, Cryptographic Hardware and Embedded Systems — CHES 2005, volume 3659 of Lecture Notes in Computer Science, pages 383–397. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[94] X. Guo, Z. Chen, and P. Schaumont. Energy and Performance Evaluation of an FPGA-Based SoC Platform with AES and PRESENT Coprocessors. In Embedded Computer Systems: Architectures, Modeling, and Simulation, volume 5114 of Lecture Notes in Computer Science, pages 106–115. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[95] H. Yoshida, D. Watanabe, K. Okeya, J. Kitahara, J. Wu, O. Kucuk, and B. Preneel. MAME: A Compression Function With Reduced Hardware Requirements. In P. Paillier and I. Verbauwhede, editors, Cryptographic Hardware and Embedded Systems — CHES 2007, volume 4727 of Lecture Notes in Computer Science, pages 148–165. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[96] P. Hämäläinen, T. Alho, M. Hännikainen, and T. D. Hämäläinen. Design and Implementation of Low-Area and Low-Power AES Encryption Hardware Core. In DSD, pages 577–583, 2006.</p>

    <p class="text-gray-300">[97] R. B. Handfield and E. L. Nichols. Introduction to Supply Chain Management. Prentice-Hall, Upper Saddle River, NJ, 1999.</p>

    <p class="text-gray-300">[98] H. Handschuh, L.R. Knudsen, and M.J.B. Robshaw. Analysis of SHA-1 in Encryption Mode. In D. Naccache, editor, Topics in Cryptology — CT-RSA 2001, volume 2020 of Lecture Notes in Computer Science, pages 70–83, 2001.</p>

    <p class="text-gray-300">[99] M. Hell, T. Johansson, A. Maximov, and W. Meier. A Stream Cipher Proposal: Grain-128. In IEEE International Symposium on Information Theory—ISIT 2006, 2006. Also available via www.ecrypt.eu.org/stream.</p>

    <p class="text-gray-300">[100] D. Henrici, J. Götze, and P. Müller. A Hash-based Pseudonymization Infrastructure for RFID Systems. In P. Georgiadis, J. Lopez, S. Gritzalis, and G. Marias, editors, SecPerU 2006, pages 22–27. IEEE Computer Society Press, 2006.</p>

    <p class="text-gray-300">[101] H. Heys. A Tutorial on Differential and Linear Cryptanalysis. Available via www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf.</p>

    <p class="text-gray-300">[102] H. M. Heys and S. E. Tavares. Substitution-Permutation Networks Resistant to Differential and Linear Cryptanalysis. Journal of Cryptology, 9(1):1–19, 1996.</p>

    <p class="text-gray-300">[103] S. Hirose. Provably Secure Double-Block-Length Hash Functions in a Black-Box Model. In C. Park and S. Chee, editors, ICISC 2004, volume 3506, pages 330–342. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[104] S. Hirose. How to Construct Double-Block-Length Hash Functions. In Second Cryptographic Hash Workshop, Santa Barbara, Aug 2006.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[105] S. Hirose. Some Plausible Constructions of Double-Block-Length Hash Functions. In M.J.B. Robshaw, editor, Fast Software Encryption 2006 – FSE 2006, volume 4047 of Lecture Notes in Computer Science, pages 210–225, 2006.</p>

    <p class="text-gray-300">[106] J. Hoffstein, J. Pipher, and J. Silverman. NTRU: A Ring-based Public Key Cryptosystem. In J. Buhler, editor, Algorithmic Number Theory (ANTS III), volume 1423 of Lecture Notes in Computer Science, pages 267–288. Springer-Verlag, 1998.</p>

    <p class="text-gray-300">[107] D. Hong, J. Sung, S. Hong, J. Lim, S. Lee, B. S. Koo, C. Lee, D. Chang, J. Lee, K. Jeong, H. Kim, J. Kim, and S. Chee. HIGHT: A New Block Cipher Suitable for Low-Resource Device. In L. Goubin and M. Matsui, editors, Cryptographic Hardware and Embedded Systems — CHES 2006, number 4249 in Lecture Notes in Computer Science, pages 46–59. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[108] Infineon Technologies. Instruction Set Manual for the C166 Family of Infineon 16-Bit Single-Chip Microcontrollers. Available via http://www.keil.com/dd/docs/datashts/infineon/c166ism.pdf, March 2001.</p>

    <p class="text-gray-300">[109] Infineon Technologies. Security &amp; Chip Card ICs - SLE 88CX720P, 2001. Available via http://www.datasheetarchive.com/pdf-datasheets/Datasheets-14/DSA-262009.pdf.</p>

    <p class="text-gray-300">[110] Infineon Technologies. Security &amp; Chip Card ICs - SLE 66C24PE, 2004. Available via http://www.datasheetarchive.com/pdf-datasheets/Datasheets-14/DSA-262009.pdf.</p>

    <p class="text-gray-300">[111] Infineon Technologies. Data Sheet for C167CR/C167SR 16-Bit Single-Chip Microcontroller. Available via http://tinyurl.com/qvyxqs, February 2005.</p>

    <p class="text-gray-300">[112] ISO/IEC. International Standard ISO/IEC 9798 Information technology – Security techniques – Entity authentication – Part 5: Mechanisms using Zero-Knowledge Techniques. Available via http://tinyurl.com/o24jww.</p>

    <p class="text-gray-300">[113] IST-1999-12324. Final Report of European Project IST-1999-12324: New European Schemes for Signatures, Integrity, and Encryption (NESSIE). Available via https://www.cosic.esat.kuleuven.be/nessie/, April 2004.</p>

    <p class="text-gray-300">[114] A. Joux. Multi-Collisions in Iterated Hash Functions. Application to Cascaded Constructions. In M. Franklin, editor, Advances in Cryptology — CRYPTO 2004, volume 3152 of Lecture Notes in Computer Science, pages 306–316. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[115] A. Juels. RFID Security and Privacy: a Research Survey. Selected Areas in Communications, IEEE Journal on, 24(2):381–394, Feb. 2006.</p>

    <p class="text-gray-300">[116] A. Juels and S. A. Weis. Authenticating pervasive devices with human protocols. In V. Shoup, editor, Advances in Cryptology — CRYPTO 2005, volume 3126 of Lecture Notes in Computer Science, pages 293–198. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[117] Keithley Instruments. 7.5-Digit High Performance Multimeter. Available via http://www.keithley.com/data?asset=361, 2005.</p>

    <p class="text-gray-300">[118] J. Kelsey and B. Schneier. Second Preimages on <span class="math">n</span>-bit Hash Functions for Much Less than <span class="math">2^n</span> Work. In R. Cramer, editor, Advances in Cryptology — EUROCRYPT 2005, volume 3494 of Lecture Notes in Computer Science, pages 474–490. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[119] J. Kelsey, B. Schneier, and D. Wagner. Related-key Cryptanalysis of 3-WAY, Biham-DES, CAST, DES-X, NewDES, RC2, and TEA. In G. Goos, J. Hartmanis, and J. van</p>

    <p class="text-gray-300">154</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">Leeuwen, editors, Information and Communications Security, volume 1334 of Lecture Notes in Computer Science, pages 233–246. Springer-Verlag, 1997.</p>

    <p class="text-gray-300">[120] A. Kerckhoff. La Cryptographie Militaire. Journal des Sciences Militaires, IX:5–38, Feb. 1883. Available via http://tinyurl.com/qgb56g.</p>

    <p class="text-gray-300">[121] M. Khatir and A. Moradi. Secure Adiabatic Logic: a Low-Energy DPA-Resistant Logic Style. Cryptology ePrint Archive, Report 2008/123, available via http://eprint.iacr.org/2008/123, 2008.</p>

    <p class="text-gray-300">[122] K. Kim, S. Lee, S. Park, and D. Lee. DES can be Immune to Linear Cryptanalysis. In Workshop on Selected Areas in Cryptography – SAC 1994, pages 70–81, May 1994. Available via citeseer.csail.mit.edu/kim94des.html.</p>

    <p class="text-gray-300">[123] K. Kim, S. Lee, S. Park, and D. Lee. Securing DES S-boxes Against Three Robust Cryptanalysis. In Workshop on Selected Areas in Cryptography – SAC 1995, pages 145–157, 1995. Available via citeseer.ist.psu.edu/kim95securing.html.</p>

    <p class="text-gray-300">[124] K. Kim, S. Park, and S. Lee. Reconstruction of <span class="math">s^2</span>-DES S-Boxes and their Immunity to Differential Cryptanalysis. In Korea-Japan Joint Workshop on Information Security and Cryptology – JW-ISC 1993, October 1993. Available via citeseer.csail.mit.edu/kim93reconstruction.html.</p>

    <p class="text-gray-300">[125] L. Knudsen and D. Wagner. Integral Cryptanalysis. In Fast Software Encryption — FSE 2002, volume 2365 of Lecture Notes in Computer Science, pages 112–127. Springer-Verlag, 2002.</p>

    <p class="text-gray-300">[126] L. R. Knudsen and T. A. Berson. Truncated Differentials of SAFER. In D. Gollmann, editor, Fast Software Encryption — FSE 1996, volume 1039 of Lecture Notes in Computer Science, pages 15–26. Springer-Verlag, 1996.</p>

    <p class="text-gray-300">[127] L. R. Knudsen, M. J. B. Robshaw, and D. Wagner. Truncated Differentials and Skipjack. In M. Wiener, editor, Advances in Cryptology — CRYPTO 1999, volume 1666 of Lecture Notes in Computer Science, pages 165–180. Springer-Verlag, 1999.</p>

    <p class="text-gray-300">[128] L.R. Knudsen. Iterative Characteristics of DES and <span class="math">s^2</span>-DES. In E. F. Brickell, editor, Advances in Cryptology — CRYPTO 1992, volume 740 of Lecture Notes in Computer Science, pages 497–511. Springer-Verlag, 1992.</p>

    <p class="text-gray-300">[129] L.R. Knudsen and X. Lai. New Attacks on all Double Block Length Hash Functions of Hash Rate 1, Including the Parallel-DM. In A. De Santis, editor, Advances in Cryptology — EUROCRYPT 1994, volume 950 of Lecture Notes in Computer Science, pages 410–418. Springer-Verlag, 1994.</p>

    <p class="text-gray-300">[130] P. C. Kocher. Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems. In N. I. Koblitz, editor, Advances in Cryptology — CRYPTO 1996, volume 1109 of Lecture Notes in Computer Science, pages 104–113. Springer Verlag, 1996.</p>

    <p class="text-gray-300">[131] P. C. Kocher, J. Jaffe, and B. Jun. Differential Power Analysis. In M. Wiener, editor, Advances in Cryptology — CRYPTO 1999, volume 1666 of Lecture Notes in Computer Science, pages 388–397. Springer Verlag, 1999.</p>

    <p class="text-gray-300">[132] R. Könighofer. A Fast and Cache-Timing Resistant Implementation of the AES. In Topics in Cryptology — CT-RSA 2008, volume 4964, pages 187–202. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[133] T. Korte. Silverlight Implementation of PRESENT. M.sc. thesis, Embedded Security Group, Ruhr University Bochum, February 2009.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[134] M. Kuhn and O. Kömmerling. Design Principles for Tamper-resistant Smartcard Processors. In USENIX Workshop on Smartcard Technology, 1999.</p>

    <p class="text-gray-300">[135] S. Kumar, C. Paar, J. Pelzl, G. Pfeiffer, and M. Schimmler. Breaking Ciphers with CO-PACOBANA - A Cost-Optimized Parallel Code Breaker. In L. Goubin and M. Matsui, editors, Cryptographic Hardware and Embedded Systems — CHES 2006, number 4249 in Lecture Notes in Computer Science, pages 101–118. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[136] X. Lai and J.L. Massey. Hash Functions Based on Block Ciphers. In R. A. Rueppel, editor, Advances in Cryptology — EUROCRYPT 1992, volume 658, pages 55–70. Springer-Verlag, 1992.</p>

    <p class="text-gray-300">[137] X. Lai, C. Waldvogel, W. Hohl, and T. Meier. Security of Iterated Hash Functions Based on Block Ciphers. In D.R. Stinson, editor, Advances in Cryptology — CRYPTO 1993, volume 773 of Lecture Notes in Computer Science, pages 379–390. Springer-Verlag, 1993.</p>

    <p class="text-gray-300">[138] S. K. Langford and M. E. Hellman. Differential-Linear Cryptanalysis. In Y. G. Desmedt, editor, Advances in Cryptology — CRYPTO 1994, volume 94 of Lecture Notes in Computer Science, pages 17–25. Springer-Verlag, 1994.</p>

    <p class="text-gray-300">[139] G. Leander. Re-Ordering of PRESENTs S-boxes. Personal Communication., November 2007.</p>

    <p class="text-gray-300">[140] G. Leander and A. Poschmann. On the Classification of 4-Bit S-boxes. In C. Carlet and B. Sunar, editors, Arithmetic of Finite Fields — WAIFI 2007, volume 4547 of Lecture Notes in Computer Science. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[141] S. Lee, T. Asano, and K. Kim. RFID Mutual Authentication Scheme based on Synchronized Secret Information. In Symposium on Cryptography and Information Security, Hiroshima, Japan, January 2006.</p>

    <p class="text-gray-300">[142] S. Lee, Y. Hwang, D. Lee, and J. Lim. Efficient Authentication for Low-Cost RFID Systems. In O. Gervasi, M.L. Gavrilova, V. Kumar, A. Laganà, H.P. Lee, Y. Mun, D. Taniar, and C.J.K. Tan, editors, Computational Science and Its Applications — ICCSA 2005, volume 3480 of Lecture Notes in Computer Science, pages 619–627. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[143] M. Lehtonen, T. Staake, F. Michahelles, and E. Fleisch. From Identification to Authentication - A Review of RFID Product Authentication Techniques. RFID Security — RFIDsec 2006, Workshop Record, July 2006.</p>

    <p class="text-gray-300">[144] F. Mace, F.-X. Standaert, and J.-J. Quisquater. ASIC Implementations of the Block Cipher SEA for Constrained Applications. In RFID Security — RFIDsec 2007, Workshop Record, pages 103 – 114, Malaga, Spain, 2007.</p>

    <p class="text-gray-300">[145] F. Macé, F.-X. Standaert, and J.-J. Quisquater. FPGA implementation(s) of a Scalable Encryption Algorithm. IEEE Transactions on Very Large Scale Integration (VLSI) Systems, 16(2):212–216, 2008.</p>

    <p class="text-gray-300">[146] MAGMA. Magma v2.12. Computational Algebra Group, School of Mathematics and Statistics, University of Sydney, available via http://magma.maths.usyd.edu.au, 2005.</p>

    <p class="text-gray-300">[147] S. Mangard, E. Oswald, and T. Popp. Power Analysis Attacks: Revealing the Secrets of Smart Cards. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[148] S. Mangard, T. Popp, and B. M. Gammel. Side-Channel Leakage of Masked CMOS Gates. In Topics in Cryptology — CT-RSA 2005, volume 3376 of Lecture Notes in Computer Science, pages 351–365. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[149] M. Matsui. Linear Cryptanalysis of DES Cipher. In T. Hellenseth, editor, <em>Advances in Cryptology — EUROCRYPT 1993</em>, volume 0765 of <em>Lecture Notes in Computer Science</em>, pages 286–397, Berlin, Germany, 1994. Springer-Verlag.</p>

    <p class="text-gray-300">[150] A. Maximov and A. Biryukov. Two trivial attacks on trivium. <em>Cryptology ePrint Archive</em>, Report 2007/021, 2007. Available via http://eprint.iacr.org/.</p>

    <p class="text-gray-300">[151] M. McLoone and M. J. B. Robshaw. New Architectures for Low-Cost Public Key Cryptography on RFID Tags. In <em>IEEE International Conference on Security and Privacy of Emerging Areas in Communication Networks — SecureComm 2005</em>, pages 1827–1830. IEEE, 2007.</p>

    <p class="text-gray-300">[152] M. McLoone and M.J.B. Robshaw. Public Key Cryptography and RFID Tags. In M. Abe, editor, <em>Topics in Cryptology — CT-RSA 2007</em>, volume 4377 of <em>Lecture Notes in Computer Science</em>, pages 372–384. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[153] A. J. Menezes, P. C. van Oorschot, and S. A. Vanstone. <em>Handbook of Applied Cryptography</em>. CRC Press, Boca Raton, Florida, USA, first edition, 1996.</p>

    <p class="text-gray-300">[154] R.C. Merkle. One Way Hash Functions and DES. In G. Brassard, editor, <em>Advances in Cryptology — CRYPTO 1989</em>, volume 435 of <em>Lecture Notes in Computer Science</em>, pages 428–446. Springer-Verlag, 1989.</p>

    <p class="text-gray-300">[155] Microsoft. Visual Studio 2008 Product Information. Available via http://tinyurl.com/q9j9po.</p>

    <p class="text-gray-300">[156] D. Molnar, A. Soppera, and D. Wagner. A Scalable, Delegatable, Pseudonym Protocol Enabling Ownership Transfer of RFID Tags. <em>RFID and Lightweight Crypto — RFIDsec 2005</em>, Workshop Record, July 2005.</p>

    <p class="text-gray-300">[157] A. Moradi, T. Eisenbarth, A. Poschmann, C. Rolfes, C. Paar, M. T. M. Shalmani, and M. Salmasizadeh. Information Leakage of Flip-Flops in DPA-Resistant Logic Styles. <em>Cryptology ePrint Archive</em>, Report 2008/188, available via http://eprint.iacr.org/, 2008.</p>

    <p class="text-gray-300">[158] A. Moradi, M. Salmasizadeh, and M. T. M. Shalmani. In K.-H. Nam and G. Rhee, editors, <em>Information Security and Cryptology — ICISC 2007</em>, Lecture Notes in Computer Science, pages 259–272. Springer-Verlag.</p>

    <p class="text-gray-300">[159] National Institute of Standards and Technology. FIPS 46-3: Data Encryption Standard (DES). Available via http://csrc.nist.gov, October 1999.</p>

    <p class="text-gray-300">[160] National Institute of Standards and Technology. FIPS 140-2: Security Requirements for Cryptographic Modules. Available via http://csrc.nist.gov/publications/fips/, 2001.</p>

    <p class="text-gray-300">[161] National Institute of Standards and Technology. FIPS 197: Advanced Encryption Standard. Available via http://csrc.nist.gov/publications/fips/, 26. November 2001.</p>

    <p class="text-gray-300">[162] National Institute of Standards and Technology. SP800-38A: Recommendation for Block Cipher Modes of Operation, December 2001.</p>

    <p class="text-gray-300">[163] National Institute of Standards and Technology. FIPS 180-2: Secure Hash Standard. Available via http://csrc.nist.gov, August 2002.</p>

    <p class="text-gray-300">[164] National Institute of Standards and Technology. FIPS 198: The Keyed-Hash Message Authentication Code. Available via http://csrc.nist.gov, March 2002.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[165] National Institute of Standards and Technology. Announcing Request for Candidate Algorithm Nominations for a New Cryptographic Hash Algorithm (SHA-3) Family. Federal Register, 72(212):62212 – 62220, November 2007.</p>

    <p class="text-gray-300">[166] National Institute of Standards and Technology. FIPS 180-3: Secure Hash Standard. Available via http://csrc.nist.gov, October 2008.</p>

    <p class="text-gray-300">[167] National Security Agency. TEMPEST: A Signal Problem. Cryptologic Spectrum, 2(3), 1972 (declassified 2007).</p>

    <p class="text-gray-300">[168] S. Nikova, C. Rechberger, and V. Rijmen. Threshold Implementations Against Side-Channel Attacks and Glitches. In P. Ning, S. Qing, and N. Li, editors, International Conference in Information and Communications Security — ICICS 2006, volume 4307 of Lecture Notes in Computer Science, pages 529–545. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[169] S. Nikova, V. Rijmen, and M. Schläffer. Secure Hardware Implementations of Non-Linear Functions in the Presence of Glitches. In P.J. Lee and J.H. Cheon, editors, International Conference in Information and Communications Security — ICICS 2008, volume 5461 of Lecture Notes in Computer Science, pages 218–234. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[170] N.N. Espresso. Available via http://tinyurl.com/o7qh6w, November 1994.</p>

    <p class="text-gray-300">[171] N.N. Keeloq Algorithm. Available via http://en.wikipedia.org/wiki/KeeLoq, November 2006.</p>

    <p class="text-gray-300">[172] N.N. Havocscope Illicit Market News. Available via http://www.havocscope.com, January 2008.</p>

    <p class="text-gray-300">[173] K. Nohl and H. Ploetz. Mifare - Little Security, Despite Obscurity. Talk at the 24th Chaos Communication Congress, December 2007.</p>

    <p class="text-gray-300">[174] NTRU Cryptosystems. NTRUencrypt. Available via www.ntru.com.</p>

    <p class="text-gray-300">[175] ECRYPT Network of Excellence. The Stream Cipher Project: eSTREAM. Available via www.ecrypt.eu.org/stream.</p>

    <p class="text-gray-300">[176] M. Ohkubo, K. Suzuki, and S. Kinoshita. Cryptographic Approach to Privacy-Friendly Tags. In RFID Privacy Workshop, 2003.</p>

    <p class="text-gray-300">[177] Y. Oren and M. Feldhofer. WIPR – Public-Key Identification on Two Grains of Sand. In RFID Security — RFIDsec 2008, Workshop Record, July 2008. Available via http://iss.oy.ne.ro/WIPR.</p>

    <p class="text-gray-300">[178] B. Parhami. Computer Arithmetic: Algorithms and Hardware Designs. Oxford University Press, September 1999.</p>

    <p class="text-gray-300">[179] T. Peyrin, H. Gilbert, F. Muller, and M. J. B. Robshaw. Combining Compression Functions and Block Cipher-Based Hash Functions. In X. Lai and K. Chen, editors, Advances in Cryptology — ASIACRPT 2006, volume 4284 of Lecture Notes in Computer Science, pages 315–331. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[180] H. Pfister and A. E. Kaufman. Cube-4 - A Scalable Architecture for Real-Time Volume Rendering. In IEEE Symposium on Volume Visualization — VVS 1996, pages 47–54, 1996.</p>

    <p class="text-gray-300">[181] T. Popp, M. Kirschbaum, T. Zefferer, and S. Mangard. Evaluation of the Masked Logic Style MDPL on a Prototype Chip. In P. Paillier and I. Verbauwhede, editors, Cryptographic Hardware and Embedded Systems — CHES 2007, volume 4727 of Lecture Notes in Computer Science, pages 81–94. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[182] T. Popp and S. Mangard. Masked Dual-Rail Pre-charge Logic: DPA-Resistance without Routing Constraints. In J.R. Rao and B. Sunar, editors, Cryptographic Hardware and Embedded Systems — CHES 2005, volume 3659 of Lecture Notes in Computer Science, pages 172–186. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[183] A. Poschmann. Potenziale der RFID-Technologie zur Steuerung der Produktionsprozesskette in der Automobilindustrie. M.Sc. Thesis in Business Studies, Fernuniversität in Hagen, April 2008.</p>

    <p class="text-gray-300">[184] A. Poschmann, G. Leander, K. Schramm, and C. Paar. New Lightweight Crypto Algorithms for RFID. In IEEE International Symposium on Circuits and Systems 2007 – ISCAS 2007, pages 1843–1846, 2007.</p>

    <p class="text-gray-300">[185] G. Poupard and J. Stern. Security Analysis of a Practical “on the fly” Authentication and Signature Generation. In K. Nyberg, editor, Advances in Cryptology - EUROCRYPT 1998, volume 1403 of Lecture Notes in Computer Science, pages 422–436. Springer-Verlag, 1998.</p>

    <p class="text-gray-300">[186] N. Pramstaller, S. Mangard, S. Dominikus, and J. Wolkerstorfer. Efficient AES Implementations on ASICs and FPGAs. In AES Conference, pages 98–112, 2004.</p>

    <p class="text-gray-300">[187] B. Preneel. Analysis and Design of Cryptographic Hash Functions. PhD thesis, Katholieke Universiteit Leuven, 1993.</p>

    <p class="text-gray-300">[188] B. Preneel, A. Bosselaers, R. Govaerts, and J. Vandewalle. Collision-Free Hash Functions Based on Block Cipher Algorithms. In International Carnahan Conference on Security Technology, pages 203–210. IEEE, 1989.</p>

    <p class="text-gray-300">[189] J.-J. Quisquater and M. Girault. 2n-bit Hash-Functions Using n-bit Symmetric Block Cipher Algorithms. In J.-J. Quisquater and J. Vandewalle, editors, Advances in Cryptology — EUROCRYPT 1989, volume 434 of Lecture Notes in Computer Science, pages 102–109. Springer-Verlag, 1989.</p>

    <p class="text-gray-300">[190] M. Rabin. Digitalized Signatures and Public-key Functions as Intractable as Factorization. Technical report, Massachusetts Institute of Technology, Cambridge, MA, USA, 1979.</p>

    <p class="text-gray-300">[191] H. Raddum. Cryptanalytic Results on Trivium. Available via http://www.ecrypt.eu.org/stream/trivium.html, October 2006.</p>

    <p class="text-gray-300">[192] W. Rankl and W. Effing. Smart Card Handbook. Carl Hanser Verlag, München, Germany, second edition, 2002.</p>

    <p class="text-gray-300">[193] K. Rhee, J. Kwak, S. Kim, and D. Won. Challenge-Response based RFID Authentication Protocol for Distributed Database Environment. In D. Hutter and M. Ullmann, editors, Security in Pervasive Computing — SPC 2005, volume 3450 of Lecture Notes in Computer Science, pages 70–84, Boppard, Germany, April 2005. Springer-Verlag.</p>

    <p class="text-gray-300">[194] V. Rijmen, J. Daemen, B. Preneel, A. Bosselaers, and E. De Win. The Cipher Shark. In D. Gollmann, editor, Fast Software Encryption — FSE 1996, volume 1039 of Lecture Notes in Computer Science, pages 99–111. Springer-Verlag, 1996.</p>

    <p class="text-gray-300">[195] S. Rinne, T. Eisenbarth, and C. Paar. Performance Analysis of Contemporary Light-Weight Block Ciphers on 8-bit Microcontrollers. In Software Performance Enhancement for Encryption and Decryption — SPEED 2007, 2007.</p>

    <p class="text-gray-300">[196] R. L. Rivest. RFC 1321: The MD5 Message-Digest Algorithm. Available via http://www.ietf.org/rfc/rfc1321.txt, April 1992.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[197] R.L. Rivest. The MD4 Message Digest Algorithm. In A.J. Menezes and S.A. Vanstone, editors, Advances in Cryptology — CRYPTO 1990, volume 537 of Lecture Notes in Computer Science, pages 303–311. Springer-Verlag, 1991.</p>

    <p class="text-gray-300">[198] P. Rogaway. Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. In P.J. Lee, editor, Advances in Cryptology — ASIACRPT 2004, volume 3329 of Lecture Notes in Computer Science, pages 16–31. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">[199] C. Rolfes, A. Poschmann, G. Leander, and C. Paar. Ultra-Lightweight Implementations for Smart Devices - Security for 1000 Gate Equivalents. In G. Grimaud and F.-X. Standaert, editors, Smart Card Research and Advanced Application — CARDIS 2008, volume 5189 of Lecture Notes in Computer Science, pages 89–103. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[200] G. Rouvroy, F.-X. Standaert, J.-J. Quisquater, and J.-D. Legat. Compact and Efficient Encryption/Decryption Module for FPGA Implementation of the AES Rijndael Very Well Suited for Small Embedded Applications. In International Conference on Information Technology: Coding and Computing — ITCC 2004, pages 583–587. IEEE Computer Society, 2004.</p>

    <p class="text-gray-300">[201] A. Satoh, S. Morioka, K. Takano, and S. Munetoh. A Compact Rijndael Hardware Architecture with S-Box Optimization. In C. Boyd, editor, Advances in Cryptology — ASIACRPT 2001, volume 2248 of Lecture Notes in Computer Science, pages 239–254. Springer-Verlag, 2001.</p>

    <p class="text-gray-300">[202] P. Schaumont and K. Tiri. Masking and Dual-Rail Logic Don't Add Up. In P. Paillier and I. Verbauwhede, editors, Cryptographic Hardware and Embedded Systems — CHES 2007, volume 4727 of Lecture Notes in Computer Science, pages 95–106. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[203] P. Schaumont and I. Verbauwhede. A Component-Based Design Environment for ESL Design. Design &amp; Test of Computers, IEEE, 23(5):338–347, 2006.</p>

    <p class="text-gray-300">[204] K. Schramm. Advanced Methods in Side Channel Cryptanalysis. PhD thesis, Ruhr University Bochum, 2006.</p>

    <p class="text-gray-300">[205] Y. Seurin and T. Peyrin. Security Analysis of Constructions Combining FIL Random Oracles. In A. Biryukov, editor, Fast Software Encryption 2007 – FSE 2007, volume 4593 of Lecture Notes in Computer Science, pages 119–136. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[206] A. Shamir. How to Share a Secret. Communications of the ACM, 22(11):612–613, 1979.</p>

    <p class="text-gray-300">[207] A. Shamir. SQUASH-A New MAC with Provable Security Properties for Highly Constrained Devices Such as RFID Tags. In K. Nyberg, editor, Fast Software Encryption 2008 – FSE 2008, volume 5086, pages 144–157. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[208] C.E. Shannon. Communication Theory of Secrecy Systems. Bell System Technical Journal, 28-4:656–715, 1949.</p>

    <p class="text-gray-300">[209] T. Staake, F. Thiesse, and E. Fleisch. Extending the EPC Network: the Potential of RFID in Anti-Counterfeiting. ACM Symposium on Applied Computing, pages 1607–1612, 2005.</p>

    <p class="text-gray-300">[210] F. Stajano. Security for Ubiquitous Computing. Wiley, 1st edition, June 2002.</p>

    <p class="text-gray-300">[211] F.-X. Standaert, G. Piret, G. Rouvroy, and J.-J. Quisquater. FPGA Implementations of the ICEBERG Block Cipher. The VLSI Journal, 40(1):20–27, 2007.</p>

    <p class="text-gray-300">[212] F.-X. Standaert, G. Piret, G. Rouvroy, J.-J. Quisquater, and J.-D. Legat. ICEBERG: an Involutional Cipher Efficient for Block Encryption in Reconfigurable Hardware. In B. Roy and W. Meier, editors, Fast Software Encryption — FSE 2004, pages 279–298. Springer-Verlag, 2004.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[213] F.X. Standaert, G. Piret, N. Gershenfeld, and J.-J. Quisquater. SEA: A Scalable Encryption Algorithm for Small Embedded Applications. In J. Domingo-Ferrer, J. Posegga, and D. Schreckling, editors, Smart Card Research and Applications, Proceedings of CARDIS 2006, volume 3928 of Lecture Notes in Computer Science, pages 222–236. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[214] J. P. Steinberger. The Collision Intractability of MDC-2 in the Ideal-Cipher Model. In M. Naor, editor, Advances in Cryptology — EUROCRYPT 2007, volume 4515 of Lecture Notes in Computer Science, pages 34–51. Springer-Verlag, 2007.</p>

    <p class="text-gray-300">[215] D. Suzuki and M. Saeki. Security Evaluation of DPA Countermeasures Using Dual-Rail Pre-charge Logic Style. In L. Goubin and M. Matsui, editors, Cryptographic Hardware and Embedded Systems — CHES 2006, volume 4249 of Lecture Notes in Computer Science, pages 255–269. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[216] D. Suzuki, M. Saeki, and T. Ichikawa. DPA Leakage Models for CMOS Logic Circuits. In J.R. Rao and B. Sunar, editors, Cryptographic Hardware and Embedded Systems — CHES 2005, volume 3659 of Lecture Notes in Computer Science, pages 366–382. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[217] D. Suzuki, M. Saeki, and T. Ichikawa. Random Switching Logic: A New Countermeasure against DPA and Second-Order DPA at the Logic Level. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences, E90-A(1):160–168, 2007. Also available via http://eprint.iacr.org/2004/346.</p>

    <p class="text-gray-300">[218] Synopsys. Design Compiler User Guide - Version A-2007.12. Available via http://tinyurl.com/pon88o, December 2007.</p>

    <p class="text-gray-300">[219] Synopsys. Design Compiler User Guide - Version Z-2007.3. Available via http://tinyurl.com/qnskxf, March 2007.</p>

    <p class="text-gray-300">[220] Synopsys. Power Compiler User Guide - Version Z-2007.03. Available via http://tinyurl.com/pnwhuh, March 2007.</p>

    <p class="text-gray-300">[221] Temic Semiconductors. MARC4 4-Bit Microcontrollers - Programmers Guide. Available via http://www.atmel.com/dyn/resources/prod_documents/doc4747.pdf, 2004.</p>

    <p class="text-gray-300">[222] The Eclipse Foundation. Eclipse IDE for C/C++ Developers. Available via http://www.eclipse.org.</p>

    <p class="text-gray-300">[223] S. Tillich, M. Feldhofer, and J. Großschädl. Area, Delay, and Power Characteristics of Standard-Cell Implementations of the AES S-Box. In S. Vassiliadis, S. Wong, and T.D. Hämäläinen, editors, Embedded Computer Systems: Architectures, Modeling, and Simulation – SAMOS 2006, volume 4917 of Lecture Notes in Computer Science, pages 457–466. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[224] K. Tiri, M. Akmal, and I. Verbauwhede. A Dynamic and Differential CMOS Logic with Signal Independent Power Consumption to Withstand Differential Power Analysis on Smart Cards. In European Solid-State Circuits Conference — ESSCIRC 2002, pages 403–406, 2002.</p>

    <p class="text-gray-300">[225] K. Tiri and P. Schaumont. Changing the Odds Against Masked Logic. In E. Biham and A.M. Youssef, editors, Selected Areas in Cryptography — SAC 2006, volume 4356 of Lecture Notes in Computer Science, pages 134–146. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[226] K. Tiri and I. Verbauwhede. A Logic Level Design Methodology for a Secure DPA Resistant ASIC or FPGA Implementation. In Design, Automation and Test in Europe Conference - DATE 2004, pages 246-251, 2004.</p>

    <p class="text-gray-300">[227] K. Tiri and I. Verbauwhede. Place and Route for Secure Standard Cell Design. In Smart Card Research and Advanced Applications — CARDIS 2004, pages 143-158. Kluwer, 2004.</p>

    <p class="text-gray-300">[228] J.R.R. Tolkien. The Lord of the Rings, The Fellowship of the Ring. George Allen Unwin, 1954.</p>

    <p class="text-gray-300">[229] P. Tuyls and L. Batina. RFID-tags for Anti-Counterfeiting. In D. Pointcheval, editor, Topics in Cryptology — CT-RSA 2006, volume 3860, pages 115–131. Springer-Verlag, 2006.</p>

    <p class="text-gray-300">[230] United Nations Office on Drugs and Crime. World Drug Report 2005, June 2005. Available via http://tinyurl.com/owteuf.</p>

    <p class="text-gray-300">[231] A. Vachoux. Top-down Digital Design Flow. Microelectronic Systems Lab, EPFL, 3.1 edition, November 2006.</p>

    <p class="text-gray-300">[232] I. Verbauwhede, F. Hoornaert, J. Vandewalle, and H. De Man. Security and Performance Optimization of a New DES Data Encryption Chip. IEEE Journal of Solid-State Circuits, 23(3):647-656, 1988.</p>

    <p class="text-gray-300">[233] Virtual Silicon Inc. 0.18 μm VIP Standard Cell Library Tape Out Ready, Part Number: UMCL18G212T3, Process: UMC Logic 0.18 μm Generic II Technology: 0.18μm, July 2004.</p>

    <p class="text-gray-300">[234] M. Vogt. Side Channel Attack Resistant Implementation of Lightweight Cryptography on Ultra-Constrained 4-bit Microcontroller. M.sc. thesis, Embedded Security Group, Ruhr University Bochum, March 2009.</p>

    <p class="text-gray-300">[235] M. Wang. Differential Cryptanalysis of Reduced-Round PRESENT. In S. Vaudenay, editor, Progress in Cryptology — AFRICACRPT 2008, number 5023 in Lecture Notes in Computer Science, pages 40–49. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">[236] X. Wang, Y.L. Yin, and H. Yu. Finding Collisions in the Full SHA-1. In V. Shoup, editor, Advances in Cryptology — CRYPTO 2005, volume 3621 of Lecture Notes in Computer Science, pages 17-36. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[237] X. Wang and H. Yu. How to Break MD5 and Other Hash Functions. In R. Cramer, editor, Advances in Cryptology — EUROCRYPT 2005, volume 3494 of Lecture Notes in Computer Science, pages 19-35. Springer-Verlag, 2005.</p>

    <p class="text-gray-300">[238] M. Weiser. The computer for the 21st century. ACM SIGMOBILE Mobile Computing and Communications Review, 3(3):3-11, 1999.</p>

    <p class="text-gray-300">[239] D. Wheeler and R. Needham. TEA, a Tiny Encryption Algorithm. In B. Preneel, editor, Fast Software Encryption — FSE 1994, volume 1008 of Lecture Notes in Computer Science, pages 363-366. Springer-Verlag, 1994.</p>

    <p class="text-gray-300">[240] D. Wheeler and R. Needham. TEA extensions. October 1997. Available via www.ftp.cl.cam.ac.uk/ftp/users/djw3/. (Also Correction to XTEA. October, 1998.).</p>

    <p class="text-gray-300">[241] WinAVR. Suite of Executable, Open Source Software Development Tools for the Atmel AVR Series of RISC Microprocessors Hosted on the Windows Platform. Available via http://winavr.sourceforge.net.</p>

    <p class="text-gray-300">[242] Xilinx. Spartan-3 FPGA Family Data Sheet. Available via http://www.xilinx.com, June 2008.</p>

    <p class="text-gray-300">[243] Y. Yu, Y. Yang, Y. Fan, and H. Min. Security Scheme for RFID Tag. Technical report, Auto-ID Labs white paper WP-HARDWARE-022.</p>

    <p class="text-gray-300">Bibliography</p>

    <p class="text-gray-300">[244] M.R. Z’Aba, H. Raddum, M. Henricksen, and E. Dawson. Bit-Pattern Based Integral Attack. In K. Nyberg, editor, Fast Software Encryption — FSE 2008, volume 5086 of Lecture Notes in Computer Science, pages 363–381. Springer-Verlag, 2008.</p>

    <p class="text-gray-300">“哈，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，你是个小伙子，</p>

    <p class="text-gray-300">2.1 Design trade-offs for lightweight cryptography. 8 2.2 Top-down digital semi-custom standard cell design flow, source [231]. 9 3.1 Eight conditions to be fulfilled by the S-box of DESL in order to thwart differential, linear, and the Davies-Murphy attack. 20 3.2 Datapath of the serialized DES ASIC with original S-boxes. 28 3.3 Finite State Machine of the ASIC architecture for DES, DESX, DESL, and DESXL. 28 3.4 Datapath of the serialized DESL ASIC with the improved S-box. 30 4.1 A top-level algorithmic description of the encryption routine of PRESENT. 36 4.2 A top-level algorithmic description of the decryption routine of PRESENT. 39 4.3 The key schedule of PRESENT-80. 41 4.4 The key schedule of PRESENT-128. 41 4.5 The grouping of S-boxes in PRESENT for the purposes of cryptanalysis. The input numbers indicate the S-box origin from the preceding round and the output numbers indicate the destination S-box in the following round. 42 4.6 Two rounds of PRESENT 49 5.1 Bit positions of the PRESENT state arranged in a <span class="math">4 \\times 4 \\times 4</span> bit cube. 52 5.2 Exemplary <span class="math">4 \\times 4 \\times 4</span> bit state cube. 52 5.3 Datapath of the serialized PRESENT architecture. 53 5.4 Datapath of the round-based PRESENT-80 architecture. 54 5.5 Datapath of the pipelined parallelized PRESENT-80 architecture, source [199]. 55 5.6 I/O interfaces and FSM of the PRESENT-80 FPGA implementation. 58 5.7 Block diagram of PRESENT-128 co-processor with 32-bit interface. 61 5.8 Development environment for the MARC4 4 bit microcontroller. 66 5.9 Blockdiagram of the ALU and size comparison of MARC4. 66 5.10 Architecture of the ATmega163 8 bit microcontroller, source: [11]. 72 5.11 Time-memory trade-off for look-up tables. 74 5.12 Architecture of the C166 microcontroller, source: [111]. 77 5.13 Re-ordering and merging of S-boxes with the permutation layer. 80 5.14 Screenshots of selected implementations of PRESENT. 81 6.1 Compression function for the 64-bit hash functions DM-PRESENT-80 and DM-PRESENT-128. 88 6.2 I/O and FSM of the DM-PRESENT-80 module with a datapath of 64 bits. 89 6.3 Architecture of the DM-PRESENT-80 module with a datapath of 64 bits. 89 6.4 Architecture of the DM-PRESENT-80 module with a datapath of 4 bits. 91 6.5 I/O and FSM of the DM-PRESENT-80 top module with a datapath of 4 bits. 91 6.6 Input and output signals of the DM-PRESENT-128 top module with a datapath of 64 bits. 92</p>

    <p class="text-gray-300">List of Figures</p>

    <p class="text-gray-300">6.7 Architecture of the DM-PRESENT-128 module with a datapath of 64 bits. 93 6.8 Input and output signals of the DM-PRESENT-128 top module with a datapath of 4 bits. 94 6.9 Architecture of the DM-PRESENT-128 module with a datapath of 4 bits. 94 6.10 Finite state machine of the DM-PRESENT-128 module with a datapath of 4 bits. 95 6.11 Compression function for the 128-bit hash function H-PRESENT-128. 96 6.12 I/O and FSM of the H-PRESENT-128 module with a datapath of 128 bits. 97 6.13 Architecture of the H-PRESENT-128 module with a datapath of 128 bits. 97 6.14 Architecture of the H-PRESENT-128 module with a datapath of 8 bits. 99 6.15 Input and output signals of the H-PRESENT-128 top module with a datapath of 8 bits. 99 6.16 Compression function for the 192-bit hash function C-PRESENT-192. 101 7.1 Overview of the used elliptic curve-based variant of crypto-GPS. 111 7.2 Layout diagram of the crypto-GPS prototype board. 115 7.3 Signal flow of the handshake protocol for communication between board and crypto-GPS ASIC. 116 7.4 Top-level architecture of the GPS-64/8-F and GPS-64/8-V variants. 117 7.5 Finite State Machines of the crypto-GPS ASIC. 118 7.6 Architecture of the adder component of all crypto-GPS variants. 119 7.7 Three architectures of storage components for different crypto-GPS variants. 121 7.8 Top-level architecture and FSM of the GPS-4/4-F variant. 123 7.9 Photograph of the manufactured crypto-GPS ASIC. 124 8.1 Schematics of single and double masked PRESENT S-boxes. 135 8.2 Proposal for a serialized double masked PRESENT-80 architecture. 139</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2.1 Area requirements and corresponding gate count of selected standard cells of the UMCL18G212T3 library. 13</li>

      <li>3.1 Number of Degree two and Degree three Equations 26</li>

      <li>3.2 Improved DESL S-box 26</li>

      <li>3.3 Hardware implementation results of DES, DESX, DESL and DESXL. All figures are obtained at or calculated for a frequency of <span class="math">100\\mathrm{KHz}</span>. 30</li>

      <li>3.4 Software implementation results of DESL and DESXL. 31</li>

      <li>4.1 The present S-box. 37</li>

      <li>4.2 Differential distribution table of the present S-box. 38</li>

      <li>4.3 The permutation layer of present. 38</li>

      <li>4.4 The inverse present S-box. 39</li>

      <li>4.5 The inverse permutation layer of present. 40</li>

      <li>4.6 The reduced permutation layer <span class="math">P_{16}(x)</span>. 48</li>

      <li>5.1 Hardware implementation results of present-80 and present-128 with an encryption only datapath for the umcl18g212t3 standard-cell library. All figures are obtained at or calculated for a frequency of <span class="math">100\\mathrm{KHz}</span>. Please be aware that power figures can not be compared adequately between different technologies. 56</li>

      <li>5.2 Performance results for encryption and decryption of one data block with present for different key sizes and S-box implementation techniques on a Spartan-III XC3S400 FPGA. 59</li>

      <li>5.3 Performance comparison of FPGA implementations of cryptographic algorithms. 60</li>

      <li>5.4 Implementation results of the co-processor architectures of a present-80 ASIC <em>[199]</em>. 61</li>

      <li>5.5 Co-processor implementation results of AES and present within a System-on-Chip platform based on a low-cost FPGA <em>[94]</em>. 62</li>

      <li>5.6 Performance of ISE for bit-sliced implementations of AES, serpent and present. 64</li>

      <li>5.7 The different profiles for the software implementations. 65</li>

      <li>5.8 Code size and cycle count of present-80 on the ATAM893-D 4-Bit microcontroller. 70</li>

      <li>5.9 Throughput and energy results of present-80 on the ATAM893-D 4-Bit microcontroller. 70</li>

      <li>5.10 Performance results of present-80 on the 8 bit ATmega163 microcontroller. 76</li>

      <li>5.11 Comparison of software implementations of ciphers on different 8-bit micro controllers. 76</li>

      <li>5.12 Performance results of present-80 on the 16 bit C166 microcontroller. 79</li>

      <li>5.13 Performance results of present-80 on the 32 bit Pentium III CPU. 81</li>

      <li>6.1 Area requirements of components of dm-present-80/64. 90</li>

      <li>6.2 Area requirements of components of dm-present-128/64. 93</li>

      <li>6.3 Area requirements of components of h-present-128/128. 98</li>

    </ul>

    <p class="text-gray-300">List of Tables</p>

    <p class="text-gray-300">6.4 Hardware estimations of PROP-1 and PROP-1 using datapath widths from 4 bit to 160 bit. 106 6.5 The performance of different hash functions based on the direct application of PRESENT. For comparison with our hash functions with 128-bit output we include estimates for the AES-based 128-bit hash function in Davies-Meyer mode. For comparison with MAME we include estimates for the 256-bit hash function built from the AES in Hirose's construction. 107 7.1 Post-Synthesis implementation results of three different architectures of crypto-GPS. 122 8.1 Estimated area requirements of masking components for serialized PRESENT-80/4.139 8.2 Estimated area and timing overhead of masking components for a serialized PRESENT-80/4 implementation. 140 8.3 Code size and cycle count overhead of a masked PRESENT-80 implementation on the ATAM893-D 4-bit microcontroller. 140</p>

    <p class="text-gray-300">Appendix</p>

    <p class="text-gray-300">A testvector generator for present-80 and present-128 is available free of charge from www.lightweightcrypto.org/present. It creates all intermediate values for both encryption and decryption and also allows to vary the amount of rounds. In the following each one testvector including all intermediate values is provided for encrypting the all “0” message under the all “0” key for present-80 and present-128. Please note that besides also generating testvectors the present cryptool2 plugin provides a nice visualization of present for educational purposes.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Appendix</p>

    <p class="text-gray-300">Plaintext: 0000000000000000 Given Key (80bit): 0000000000000000 0000</p>

    <p class="text-gray-300">Round 1 Subkey: 0000000000000000</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 0000000000000000 ...S-Box: ccccccccccccccc ...P-Box: fffffffff00000000</p>

    <p class="text-gray-300">Round 2 Subkey: c000000000000000</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 3ffffffff00000000 ...S-Box: b222222cccccccc ...P-Box: 80ff00fffff008000</p>

    <p class="text-gray-300">Round 3 Subkey: 5000180000000001</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: d0ff18ffff008001 ...S-Box: 7c22532222cc3cc5 ...P-Box: 4036c837b7c88c09</p>

    <p class="text-gray-300">Round 4 Subkey: 60000a0003000001</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 2036c237b4c88c08 ...S-Box: 6cba46bd894334c3 ...P-Box: 73c2cd26b6192359</p>

    <p class="text-gray-300">Round 5 Subkey: b0000c0001400062</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: c3c2c126b759233b ...S-Box: 4b46456a8d0e6bb8 ...P-Box: 41d7be58531e4446</p>

    <p class="text-gray-300">Round 6 Subkey: 900016000180002a</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: d1d7a858529e446c ...S-Box: 757df30306e199a4 ...P-Box: 182ef861ad62fd1c</p>

    <p class="text-gray-300">Round 7 Subkey: 0001920002c00033</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 182f6a61afa2fd2f ...S-Box: 5362afa5f2f62762 ...P-Box: 0ea0a5b67effc5a4</p>

    <p class="text-gray-300">Round 8 Subkey: a000a0003240005b</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: aea005b64cbfc5ff ...S-Box: f1fcc08a94824022 ...P-Box: bba0b848a113e080</p>

    <p class="text-gray-300">Round 9 Subkey: d000d4001400064c</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 6ba06c48b513e6cc ...S-Box: a8fca493805b1a44 ...P-Box: fa943423a9142338</p>

    <p class="text-gray-300">Round 10 Subkey: 30017a001a800284</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: ca954e23b39421bc ...S-Box: 4fe0916b8be96584 ...P-Box: 69f2e22d63684d54</p>

    <p class="text-gray-300">Round 11 Subkey: e01926002f400355</p>

    <p class="text-gray-300">Text after ...</p>

    <p class="text-gray-300">...Key-Xor: 89ebc42d4c284e01 ...S-Box: 3e184967946391c5 ...P-Box: 548a4b63c330a59d</p>

    <p class="text-gray-300">Round 12 Subkey: f00a1c0324c005ed</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: a4805760e7f0a070 ...S-Box: f93c0dac1d2cfcdc ...P-Box: d75f955fa228e4ca</p>

    <p class="text-gray-300">Round 13 Subkey: 800d5e014380649e</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 5752cb5ee1a88054 ...S-Box: 0d06480115f33c09 ...P-Box: 44255864103841f9</p>

    <p class="text-gray-300">Round 14 Subkey: 4017b001abc02876</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 0432e865bbf8698f ...S-Box: c9b613a08823ae32 ...P-Box: e2cc9004363f6c12</p>

    <p class="text-gray-300">Round 15 Subkey: 71926802f600357f</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 935ef806c03f596d ...S-Box: eb0123ca4cb20ea7 ...P-Box: c36682c5cd375421</p>

    <p class="text-gray-300">Round 16 Subkey: 10a1ce324d005ec7</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: d3c74cf780370ae6 ...S-Box: 7b4d942d3cbdcf1a ...P-Box: 597db55cc2a5d9b6</p>

    <p class="text-gray-300">Round 17 Subkey: 20d5e21439c649a8</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 79a85748fb63901e ...S-Box: def30d9328abec51 ...P-Box: e67ce40e71b8b713</p>

    <p class="text-gray-300">Round 18 Subkey: c17b041abc428730</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 2707e014cdfa3023 ...S-Box: 6dcd1c59472fbc6b ...P-Box: 751df6d6807b5b59</p>

    <p class="text-gray-300">Round 19 Subkey: c926b82f60835781</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: bc3b4ef9e0f80cd8 ...S-Box: 84b8912e1c23c473 ...P-Box: b948414e23332c93</p>

    <p class="text-gray-300">Round 20 Subkey: 6a1cd924d705ec19</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: d354986af436c08a ...S-Box: 7b09e3af29ba4c3f ...P-Box: 5b75890dcfb3d563</p>

    <p class="text-gray-300">Round 21 Subkey: bd5e0d439b249aea</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: e62b844e54974f89 ...S-Box: 1a68399109ed923e ...P-Box: 5679203168278f5a</p>

    <p class="text-gray-300">Round 22 Subkey: 07b077abc1a8736e</p>

    <p class="text-gray-300">Text after ... ...Key-Xor: 51c9579aa98ffc34 ...S-Box: 054e0deffe3224b9 ...P-Box: 17c377c413fa45a3</p>

    <p class="text-gray-300">Round 23 Subkey: 426ba0f60ef5783e Text after... ...Key=Xor: 55a8d7321d0f3d9d ...S=Box: 00f37db657c2b7e7 ...P=Box: 262a2de73b5f3ecd</p>

    <p class="text-gray-300">Round 24 Subkey: 41cda84d741ec1d5 Text after... ...Key=Xor: 67e785aa4f41ff18 ...S=Box: ad1d30ff92952253 ...P=Box: d3a053128b4d7bb3</p>

    <p class="text-gray-300">Round 25 Subkey: f5e0e839b509ae8f Text after... ...Key=Xor: 2640bb2b3e44d53c ...S=Box: 6a9c8868b19970b4 ...P=Box: 7db29209c28a20fa</p>

    <p class="text-gray-300">Round 26 Subkey: 2b075ebc1d0736ad Text after... ...Key=Xor: 56b5ccb5df8d1657 ...S=Box: 0a80448072375a0d ...P=Box: 62050c9940f400b9</p>

    <p class="text-gray-300">Round 27 Subkey: 86ba2560ebd783ad Text after... ...Key=Xor: e4bf29f9ab238314 ...S=Box: 19826e2ef86b3b59 ...P=Box: 65d50da21fbcc09f</p>

    <p class="text-gray-300">Round 28 Subkey: 8cdab0d744ac1d77 Text after... ...Key=Xor: e90fbd755b10dde8 ...S=Box: 1ec287d0085c7713 ...P=Box: 6a50663c540d862f</p>

    <p class="text-gray-300">Round 29 Subkey: 1e0eb19b561ae89b Text after... ...Key=Xor: 745ed7a702176eb4 ...S=Box: d9017dfdc65da189 ...P=Box: c79b8ff00a48df35</p>

    <p class="text-gray-300">Round 30 Subkey: d075c3c1d6336acd Text after... ...Key=Xor: 17ee4c31dc7bb5f8 ...S=Box: 5d1194b574d88023 ...P=Box: 4a38c5e00283fba1</p>

    <p class="text-gray-300">Round 31 Subkey: 8ba27a0eb8783ac9 Text after... ...Key=Xor: c19abfeebafbc168 ...S=Box: 45ef82118f2845a3 ...P=Box: 38d2f04c34635345</p>

    <p class="text-gray-300">Final Round Subkey: 6dab31744f41d700 Text: 5579c1387b228445</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300">PRESENT-80 key schedule Input: 0000000000000000 0000 Subkey Round 1: &gt;&gt;0000000000000000&lt;&lt; ...after Shift: 0000000000000000 0000 ...after S=Box: c000000000000000 0000 Subkey Round 2 (after Salt): &gt;&gt;c000000000000000&lt;&lt; 8000</p>

    <p class="text-gray-300">...after Shift: 1000180000000000 0000 ...after S=Box: 5000180000000000 0000 Subkey Round 3 (after Salt): &gt;&gt;5000180000000001&lt;&lt; 0000</p>

    <p class="text-gray-300">...after Shift: 20000a0003000000 0000 ...after S=Box: 60000a0003000000 0000 Subkey Round 4 (after Salt): &gt;&gt;60000a0003000001&lt;&lt; 8000</p>

    <p class="text-gray-300">...after Shift: 30000c0001400060 0000 ...after S=Box: b0000c0001400060 0000 Subkey Round 5 (after Salt): &gt;&gt;b0000c0001400062&lt;&lt; 0000</p>

    <p class="text-gray-300">...after Shift: 4000160001800028 000c ...after S=Box: 9000160001800028 000c Subkey Round 6 (after Salt): &gt;&gt;900016000180002a&lt;&lt; 800c</p>

    <p class="text-gray-300">...after Shift: 5001920002c00030 0005 ...after S=Box: 0001920002c00030 0005 Subkey Round 7 (after Salt): &gt;&gt;0001920002c00033&lt;&lt; 0005</p>

    <p class="text-gray-300">...after Shift: 6000a00032400058 0006 ...after S=Box: a000a00032400058 0006 Subkey Round 8 (after Salt): &gt;&gt;a000a0003240005b&lt;&lt; 8006</p>

    <p class="text-gray-300">...after Shift: 7000d40014000648 000b ...after S=Box: d000d40014000648 000b Subkey Round 9 (after Salt): &gt;&gt;d000d4001400064c&lt;&lt; 000b</p>

    <p class="text-gray-300">...after Shift: 80017a001a800280 00c9 ...after S=Box: 30017a001a800280 00c9 Subkey Round 10 (after Salt): &gt;&gt;30017a001a800284&lt;&lt; 80c9</p>

    <p class="text-gray-300">...after Shift: 901926002f400350 0050 ...after S=Box: e01926002f400350 0050 Subkey Round 11 (after Salt): &gt;&gt;e01926002f400355&lt;&lt; 0050</p>

    <p class="text-gray-300">...after Shift: a00a1c0324c005e8 006a ...after S=Box: f00a1c0324c005e8 006a Subkey Round 12 (after Salt): &gt;&gt;f00a1c0324c005ed&lt;&lt; 806a</p>

    <p class="text-gray-300">...after Shift: b00d5e0143806498 00bd ...after S=Box: 800d5e0143806498 00bd Subkey Round 13 (after Salt): &gt;&gt;800d5e014380649e&lt;&lt; 00bd</p>

    <p class="text-gray-300">...after Shift: c017b001abc02870 0c93 ...after S=Box: 4017b001abc02870 0c93 Subkey Round 14 (after Salt): &gt;&gt;4017b001abc02876&lt;&lt; 8c93</p>

    <p class="text-gray-300">...after Shift: d1926802f6003578 050e ...after S=Box: 71926802f6003578 050e Subkey Round 15 (after Salt): &gt;&gt;71926802f600357f&lt;&lt; 050e</p>

    <p class="text-gray-300">...after Shift: e0a1ce324d005ec0 06af ...after S=Box: 10a1ce324d005ec0 06af Subkey Round 16 (after Salt): &gt;&gt;10a1ce324d005ec7&lt;&lt; 86af</p>

    <p class="text-gray-300">...after Shift: f0d5e21439c649a0 0bd8 ...after S=Box: 20d5e21439c649a0 0bd8 Subkey Round 17 (after Salt): &gt;&gt;20d5e21439c649a8&lt;&lt; 0bd8</p>

    <p class="text-gray-300">...after Shift: 017b041abc428738 c935 ...after S=Box: c17b041abc428738 c935 Subkey Round 18 (after Salt): &gt;&gt;c17b041abc428730&lt;&lt; 4935</p>

    <p class="text-gray-300">...after Shift: 0926b82f60835788 50e6 ...after S=Box: c926b82f60835788 50e6 Subkey Round 19 (after Salt): &gt;&gt;c926b82f60835781&lt;&lt; 50e6</p>

    <p class="text-gray-300">...after Shift: 2a1cd924d705ec10 6af0 ...after S=Box: 6a1cd924d705ec10 6af0 Subkey Round 20 (after Salt): &gt;&gt;6a1cd924d705ec19&lt;&lt; eaf0</p>

    <p class="text-gray-300">...after Shift: 3d5e0d439b249ae0 bd83 ...after S=Box: bd5e0d439b249ae0 bd83</p>

    <p class="text-gray-300">Appendix</p>

    <pre><code class="language-txt">Subkey Round 21 (after Salt): &amp;gt;&amp;gt;bd5e0d439b249aea&amp;lt;&amp;lt; bd83
...after Shift: 57b077abc1a87364 935d
...after S-Box: 07b077abc1a87364 935d
Subkey Round 22 (after Salt): &amp;gt;&amp;gt;07b077abc1a8736e&amp;lt;&amp;lt; 135d
...after Shift: c26ba0f60ef57835 0e6d
...after S-Box: 426ba0f60ef57835 0e6d
Subkey Round 23 (after Salt): &amp;gt;&amp;gt;426ba0f60ef5783e&amp;lt;&amp;lt; 0e6d
...after Shift: c1cda84d741ec1de af07
...after S-Box: 41cda84d741ec1de af07
Subkey Round 24 (after Salt): &amp;gt;&amp;gt;41cda84d741ec1d5&amp;lt;&amp;lt; 2f07
...after Shift: a5e0e839b509ae83 d83a
...after S-Box: f5e0e839b509ae83 d83a
Subkey Round 25 (after Salt): &amp;gt;&amp;gt;f5e0e839b509ae8f&amp;lt;&amp;lt; d83a
...after Shift: fb075ebc1d0736a1 35d1
...after S-Box: 2b075ebc1d0736a1 35d1
Subkey Round 26 (after Salt): &amp;gt;&amp;gt;2b075ebc1d0736ad&amp;lt;&amp;lt; b5d1
...after Shift: b6ba2560ebd783a0 e6d5
...after S-Box: 86ba2560ebd783a0 e6d5
Subkey Round 27 (after Salt): &amp;gt;&amp;gt;86ba2560ebd783ad&amp;lt;&amp;lt; e6d5
...after Shift: bcdaab0d744ac1d7a f075
...after S-Box: 8cdab0d744ac1d7a f075
Subkey Round 28 (after Salt): &amp;gt;&amp;gt;8cdab0d744ac1d77&amp;lt;&amp;lt; 7075
...after Shift: ee0eb19b561ae895 83ae
...after S-Box: 1e0eb19b561ae895 83ae
Subkey Round 29 (after Salt): &amp;gt;&amp;gt;1e0eb19b561ae89b&amp;lt;&amp;lt; 83ae
...after Shift: 7075c3c1d6336ac3 5d13
...after S-Box: d075c3c1d6336ac3 5d13
Subkey Round 30 (after Salt): &amp;gt;&amp;gt;d075c3c1d6336acd&amp;lt;&amp;lt; dd13
...after Shift: bba27a0eb8783ac6 6d59
...after S-Box: 8ba27a0eb8783ac6 6d59
Subkey Round 31 (after Salt): &amp;gt;&amp;gt;8ba27a0eb8783ac9&amp;lt;&amp;lt; 6d59
...after Shift: 2dab31744f41d70f 0759
...after S-Box: 6dab31744f41d70f 0759
Subkey Round 32 (after Salt): &amp;gt;&amp;gt;6dab31744f41d700&amp;lt;&amp;lt; 8759</code></pre>

    <p class="text-gray-300">Plaintext: 0000000000000000 Given Key (128 bit): 0000000000000000 0000000000000000</p>

    <p class="text-gray-300">Round 1</p>

    <p class="text-gray-300">Subkey: 0000000000000000</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 0000000000000000 ...S-Box: ccccccccccccccc ...P-Box: ffffff0000000</p>

    <p class="text-gray-300">Round 2</p>

    <p class="text-gray-300">Subkey: cc00000000000000</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 33fffff0000000 ...S-Box: bb22222cccccccc ...P-Box: c0ff00fff00c000</p>

    <p class="text-gray-300">Round 3</p>

    <p class="text-gray-300">Subkey: c30000000000000</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 03ff00fff00c000 ...S-Box: cb22cc2222cc4ccc ...P-Box: cc378c3f73c04000</p>

    <p class="text-gray-300">Round 4</p>

    <p class="text-gray-300">Subkey: 5b3000000000000</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 97078c3f73c04000 ...S-Box: edcd34b2db4c9ccc ...P-Box: f2dff4b78b405ac8</p>

    <p class="text-gray-300">Round 5</p>

    <p class="text-gray-300">Subkey: 580c000000000001</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: aad3f4b78b405ac9 ...S-Box: f7b298d389c0f4e ...P-Box: d775e117f885f5a4</p>

    <p class="text-gray-300">Round 6</p>

    <p class="text-gray-300">Subkey: 656cc00000000001</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: b2192117f885f5a5 ...S-Box: 865e655d233020f0 ...P-Box: 91027f0258ea2762</p>

    <p class="text-gray-300">Round 7</p>

    <p class="text-gray-300">Subkey: 6e60300000000001</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: ff624f0258ea2763 ...S-Box: 22a692c6031f6dab ...P-Box: 2a17131cf55b0875</p>

    <p class="text-gray-300">Round 8</p>

    <p class="text-gray-300">Subkey: b595b30000000001</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 9f82a01cf55b0874 ...S-Box: e236fc542008c3d9 ...P-Box: 8c1b9f0af8842a07</p>

    <p class="text-gray-300">Round 9</p>

    <p class="text-gray-300">Subkey: beb980c000000002</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 32a21fcaf8842a05 ...S-Box: b6f6524f23396fc0 ...P-Box: a1167b0ef5eca974</p>

    <p class="text-gray-300">Round 10</p>

    <p class="text-gray-300">Subkey: 96d656cc00000002</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 37c02dc2f5eca976 ...S-Box: bd4c67462014feda ...P-Box: d00f7f1e8d8dc42a</p>

    <p class="text-gray-300">Round 11</p>

    <p class="text-gray-300">Subkey: 9ffae60300000002</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 4ff5991d8d8dc428 ...S-Box: 9220ee5737374963 ...P-Box: 8c040f5a6df383f5</p>

    <p class="text-gray-300">Round 12</p>

    <p class="text-gray-300">Subkey: 065b595b30000002</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 8a5f56015df383f7 ...S-Box: 3f020ac5072b3b2d ...P-Box: 46154341d47ec15d</p>

    <p class="text-gray-300">Round 13</p>

    <p class="text-gray-300">Subkey: 0f7feb980c000003</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 496aa8d9d87ec15e ...S-Box: 9eaff37e73d14501 ...P-Box: f9205bac7fc09ef5</p>

    <p class="text-gray-300">Round 14</p>

    <p class="text-gray-300">Subkey: ac196d656cc00003</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 553936c913009ef6 ...S-Box: 00beba4e5bcce12a ...P-Box: 3d7913b83d4b28c4</p>

    <p class="text-gray-300">Round 15</p>

    <p class="text-gray-300">Subkey: a33dffae60300003</p>

    <p class="text-gray-300">Text after...</p>

    <p class="text-gray-300">...Key-Xor: 9e44ec165d7b28c7 ...S-Box: e199145a07d8634d ...P-Box: b131866b814c7a65</p>

    <p class="text-gray-300">Round 16 Subkey: d6b065b595b30003</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 6781e3de14ff7a66 ...S-Box: ad351b715922dfaa ...P-Box: c44f528ca6377fcc</p>

    <p class="text-gray-300">Round 17 Subkey: df8cf7feb980c004</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 1bc3a5721fb7bfc8 ...S-Box: 584bf0d6528d8243 ...P-Box: 5a38ab9219459a91</p>

    <p class="text-gray-300">Round 18 Subkey: 3b5ac196d656cc04</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 61626a04cf135695 ...S-Box: a5a6afc9425b0ae0 ...P-Box: af1656a2bc564530</p>

    <p class="text-gray-300">Round 19 Subkey: 387e33dffae60304</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 9768657d46b04634 ...S-Box: eda3a0d79a8c9ab9 ...P-Box: eaffc310b946538b</p>

    <p class="text-gray-300">Round 20 Subkey: eced6b065b595b34</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 0612a816e21f08bf ...S-Box: ca56f35a1652c382 ...P-Box: c90aba685d552ea4</p>

    <p class="text-gray-300">Round 21 Subkey: e3e1f8cf7feb9809</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 2aeb42a722beb6ad ...S-Box: 6f1896fd66818af7 ...P-Box: 5b2ec7c3c6c76b13</p>

    <p class="text-gray-300">Round 22 Subkey: 6bb3b5ac196d6569</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 309d726fdfaa0e7a ...S-Box: bce7d6a272ffc1df ...P-Box: ea3b7cbbb7f198b7</p>

    <p class="text-gray-300">Round 23 Subkey: bb8f87e33dffae65</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 51b4fb588a0e36d2 ...S-Box: 058928033fc1ba76 ...P-Box: 346c406309cf51da</p>

    <p class="text-gray-300">Round 24 Subkey: 80aeced6b065b590</p>

    <p class="text-gray-300">Text after... ...Key-Xor: b4c28eb5b9aae44a ...S-Box: 894631808eff199f ...P-Box: c2f7307118714c3f</p>

    <p class="text-gray-300">Round 25 Subkey: c1ee3e1f8cf7febf</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 03190e6e9486b280 ...S-Box: cb5ec1a1e93a863c ...P-Box: dad9b88552b66562</p>

    <p class="text-gray-300">Round 26 Subkey: 2602bb3b5ac196d0</p>

    <p class="text-gray-300">Text after... ...Key-Xor: fcdb03be0877f3b2 ...S-Box: 2478cb81c3dd2b86 ...P-Box: 1eb668b1a44d2574</p>

    <p class="text-gray-300">Round 27 Subkey: cb07b8f87e33dffc</p>

    <p class="text-gray-300">Text after... ...Key-Xor: d5b1d049da7efa88 ...S-Box: 70857c9e7fd12f33 ...P-Box: 27649de489cf9af7</p>

    <p class="text-gray-300">Round 28 Subkey: 34980aeced6b065d</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 13fc970864a49caa ...S-Box: 5b24edc3a9f9e4ff ...P-Box: 4efb9e2f69abc573</p>

    <p class="text-gray-300">Round 29 Subkey: 8b2c1ee3e1f8cf78</p>

    <p class="text-gray-300">Text after... ...Key-Xor: c5d780cc88530a0b ...S-Box: 407d3c44330bcfc8 ...P-Box: 141fb70e28d438d4</p>

    <p class="text-gray-300">Round 30 Subkey: 54d2602bb3b5ac1e</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 40cdd7259b6194ca ...S-Box: 9c477d60e8a5e94f ...P-Box: c4ed7e9b1aa99c15</p>

    <p class="text-gray-300">Round 31 Subkey: 4a2cb07b8f87e33a</p>

    <p class="text-gray-300">Text after... ...Key-Xor: 8ec1cee0952e7f2f ...S-Box: 3145411ce061d262 ...P-Box: 018839aa80a7d618</p>

    <p class="text-gray-300">Final Round Subkey: 97534980aeced6b7 Text: 96db702a2e6900af</p>

    <hr class="my-8 border-gray-700" />

    <h2 id="sec-193" class="text-2xl font-bold">PRESENT-128 key schedule</h2>

    <p class="text-gray-300">Input: 000000000000000 0000000000000000</p>

    <p class="text-gray-300">Subkey Round 1: >>000000000000000<<</p>

    <p class="text-gray-300">...after Shift: 000000000000000 0000000000000000 ...after S-Box: cc00000000000000 0000000000000000 Subkey Round 2 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>cc000000000000000<< 4000000000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 0800000000000000 1980000000000000 ...after S-Box: c300000000000000 1980000000000000 Subkey Round 3 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>c3000000000000000<< 9980000000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 1330000000000000 1860000000000000 ...after S-Box: 5b30000000000000 1860000000000000 Subkey Round 4 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>5b300000000000000<< d860000000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 1b0c000000000000 0b66000000000000 ...after S-Box: 580c00000000000 0b66000000000000 Subkey Round 5 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>580c000000000001<< 0b66000000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 216cc00000000000 0b01800000000000 ...after S-Box: 656cc00000000000 0b01800000000000 Subkey Round 6 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>656cc00000000001<< 4b01800000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 2960300000000000 0cad9800000000000 ...after S-Box: 6e60300000000000 0cad9800000000000 Subkey Round 7 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>6e60300000000001<< 8cad9800000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 3195b30000000000 0dcc060000000000 ...after S-Box: b595b30000000000 0dcc0600000000000 Subkey Round 8 (after Salt):</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>>b595b30000000001<< cdcc060000000000</p>
    </blockquote>

    <p class="text-gray-300">...after Shift: 39b980c000000000 16b2b66000000000 ...after S-Box: beb980c000000000 16b2b66000000000</p>

    <pre><code>
Subkey Round 9 (after Salt):
&gt;&gt;beb980c000000002&lt;&lt; 16b2b66000000000

...after Shift: 42d656cc00000000 17d7301800000000
...after S-Box: 96d656cc00000000 17d7301800000000

Subkey Round 10 (after Salt):
&gt;&gt;96d656cc00000002&lt;&lt; 57d7301800000000

...after Shift: 4afae60300000000 12dacad980000000
...after S-Box: 9ffae60300000000 12dacad980000000

Subkey Round 11 (after Salt):
&gt;&gt;9ffae60300000002&lt;&lt; 92dacad980000000

...after Shift: 525b595b30000000 13ff5cc060000000
...after S-Box: 065b595b30000000 13ff5cc060000000

Subkey Round 12 (after Salt):
&gt;&gt;065b595b30000002&lt;&lt; d3ff5cc060000000

...after Shift: 5a7feb980c000000 00cb6b2b66000000
...after S-Box: 0f7feb980c000000 00cb6b2b66000000

Subkey Round 13 (after Salt):
&gt;&gt;0f7feb980c000003&lt;&lt; 00cb6b2b66000000

...after Shift: 60196d656cc00000 01effd7301800000
...after S-Box: ac196d656cc00000 01effd7301800000

Subkey Round 14 (after Salt):
&gt;&gt;ac196d656cc00003&lt;&lt; 41effd7301800000

...after Shift: 683dffae60300000 15832dacad980000
...after S-Box: a33dffae60300000 15832dacad980000

Subkey Round 15 (after Salt):
&gt;&gt;a33dffae60300003&lt;&lt; 95832dacad980000

...after Shift: 72b065b595b30000 1467bff5cc060000
...after S-Box: d6b065b595b30000 1467bff5cc060000

Subkey Round 16 (after Salt):
&gt;&gt;d6b065b595b30003&lt;&lt; d467bff5cc060000

...after Shift: 7a8cf7feb980c000 1ad60cb6b2b66000
...after S-Box: df8cf7feb980c000 1ad60cb6b2b66000

Subkey Round 17 (after Salt):
&gt;&gt;df8cf7feb980c004&lt;&lt; 1ad60cb6b2b66000

...after Shift: 835ac196d656cc00 1bf19effd7301800
...after S-Box: 3b5ac196d656cc00 1bf19effd7301800

Subkey Round 18 (after Salt):
&gt;&gt;3b5ac196d656cc04&lt;&lt; 5bf19effd7301800

...after Shift: 8b7e33dffae60300 076b5832dacad980
...after S-Box: 387e33dffae60300 076b5832dacad980

Subkey Round 19 (after Salt):
&gt;&gt;387e33dffae60304&lt;&lt; 876b5832dacad980

...after Shift: 90ed6b065b595b30 070fc67bff5cc060
...after S-Box: eced6b065b595b30 070fc67bff5cc060

Subkey Round 20 (after Salt):
&gt;&gt;eced6b065b595b34&lt;&lt; c70fc67bff5cc060

...after Shift: 98e1f8cf7feb980c 1d9dad60cb6b2b66
...after S-Box: e3e1f8cf7feb980c 1d9dad60cb6b2b66

Subkey Round 21 (after Salt):
&gt;&gt;e3e1f8cf7feb9809&lt;&lt; 1d9dad60cb6b2b66

...after Shift: 23b3b5ac196d656c dc7c3f19effd7301
...after S-Box: 6bb3b5ac196d656c dc7c3f19effd7301

Subkey Round 22 (after Salt):
&gt;&gt;6bb3b5ac196d6569&lt;&lt; 9c7c3f19effd7301

...after Shift: 338f87e33dffae60 2d7676b5832dacad
...after S-Box: bb8f87e33dffae60 2d7676b5832dacad

Subkey Round 23 (after Salt):
&gt;&gt;bb8f87e33dffae65&lt;&lt; ad7676b5832dacad

...after Shift: b5aeced6b065b595 b771f0fc67bff5cc
...after S-Box: 80aeced6b065b595 b771f0fc67bff5cc

Subkey Round 24 (after Salt):
&gt;&gt;80aeced6b065b590&lt;&lt; 7771f0fc67bff5cc

...after Shift: 0eee3e1f8cf7feb9 9015d9dad60cb6b2
...after S-Box: c1ee3e1f8cf7feb9 9015d9dad60cb6b2

Subkey Round 25 (after Salt):
&gt;&gt;c1ee3e1f8cf7febf&lt;&lt; 9015d9dad60cb6b2

...after Shift: f202bb3b5ac196d6 583dc7c3f19effd7
...after S-Box: 2602bb3b5ac196d6 583dc7c3f19effd7

Subkey Round 26 (after Salt):
&gt;&gt;2602bb3b5ac196d0&lt;&lt; 183dc7c3f19effd7

...after Shift: 0307b8f87e33dffa e4c057676b5832da
...after S-Box: cb07b8f87e33dffa e4c057676b5832da

Subkey Round 27 (after Salt):
&gt;&gt;cb07b8f87e33dffc&lt;&lt; 64c057676b5832da

...after Shift: 8c980aeced6b065b 5960f71f0fc67bff
...after S-Box: 34980aeced6b065b 5960f71f0fc67bff

Subkey Round 28 (after Salt):
&gt;&gt;34980aeced6b065d&lt;&lt; 9960f71f0fc67bff

...after Shift: b32c1ee3e1f8cf7f e693015d9dad60cb
...after S-Box: 8b2c1ee3e1f8cf7f e693015d9dad60cb

Subkey Round 29 (after Salt):
&gt;&gt;8b2c1ee3e1f8cf78&lt;&lt; e693015d9dad60cb

...after Shift: 1cd2602bb3b5ac19 716583dc7c3f19ef
...after S-Box: 54d2602bb3b5ac19 716583dc7c3f19ef

Subkey Round 30 (after Salt):
&gt;&gt;54d2602bb3b5ac1e&lt;&lt; 316583dc7c3f19ef

...after Shift: c62cb07b8f87e33d ea9a4c057676b583
...after S-Box: 4a2cb07b8f87e33d ea9a4c057676b583

Subkey Round 31 (after Salt):
&gt;&gt;4a2cb07b8f87e33a&lt;&lt; 6a9a4c057676b583

...after Shift: 4d534980aeced6b0 6945960f71f0fc67
...after S-Box: 97534980aeced6b0 6945960f71f0fc67

Subkey Round 32 (after Salt):
&gt;&gt;&gt;97534980aeced6b7&lt;&lt; a945960f71f0fc67

# Curriculum Vitae

## Personal Data

Born on 25 April 1979 in Hamburg, Germany.
Contact Information:
- e-mail: axel.poschmann@gmail.com

## Research Interests
- Lightweight cryptography
- side channel resistant ASIC design
- low-power and area-efficient implementations of cryptographic algorithms
- security for RFIDs and Wireless Sensor Networks

## Education

01/2006 - 04/2009  Ph.D. studies
Title: Lightweight Cryptography - Security Engineering for a Pervasive World
Supervisor: Prof. Dr.-Ing. Christof Paar
Chair for Embedded Security
Horst Görtz Institute for IT Security
Ruhr-University Bochum, Germany

10/2004 - 04/2008  Fernuniversität in Hagen, Germany
degree awarded: Diplom-Kaufmann
equivalent to M.Sc. in Business Studies

10/2000 - 12/2005  Ruhr University of Bochum, Germany
degree awarded: Diplom-Ingenieur IT-Sicherheit (1,3)
equivalent to M.Sc. in IT Security (Excellent)

10/1998 - 09/2000  Friedrich-Alexander-University of Erlangen-Nuremberg, Germany
degree awarded: Vordiplom
equivalent to intermediate Diploma in Business Studies

Curriculum Vitae

# International Studies

07/2008 - 10/2008 research stay at the UC Berkeley, Berkeley, USA
supported by the German Academic Exchange Service (DAAD)

11/2004 - 02/2005 research stay at the Swiss Institute of Technology Lausanne, Switzerland

1996, 1997 Each 3 weeks exchange of students to Shanghai and Beijing, China

# Experience

since 03/2009 Academic Research (Post-Doc)
School of Physical &amp;amp; Mathematical Sciences
Nanyang Technological University, Singapore

01/2006 - 02/2009 Research and teaching assistant
Horst Görtz Institute for IT Security
Chair for Embedded Security
Ruhr University of Bochum, Germany

2007 - 2008 Conducting a market study “New Markets for RFID-based Applications” as an external Consultant at CardFactory AG, Oldenburg, Germany

2006 Professional training course in IT Security for the Advanced Training Center of the Ruhr University Bochum, Germany

2002 - 2004 Student assistant at Communication Security group
Ruhr University Bochum, Germany

2003 IT security Consultant at Atelion GmbH, Hamburg, Germany

2002 8 weeks Internship at the Information Security group of the Federal State Bank Westdeutsche Landesbank, Duesseldorf, Germany

2002 7 weeks internship at the IT security consulting company Thales Communication GmbH (now Atelion GmbH), Hamburg, Germany

# Fellowships and Awards

2008 Doctoral stipend of the German Academic Exchange Service (DAAD)

Curriculum Vitae

01/2007 - 04/2009 Fellow of the Research School of the Ruhr-University Bochum, Germany
2007 Stipend of the Ruth und Gert Massenberg Stiftung for travel cost
2006 Award for a particularly good grade (top 5%) of the Faculty of Electrical Engineering and Information Technology of the Ruhr-University Bochum, Germany
2006 2. place at the CAST-Award IT Security (award for best theses in IT Security in Austria, Germany, and Switzerland, 2,500 EUR)
2006 VDE MS Thesis Award of the German Association for Electrical, Electronic &amp;amp; Information Technologies (VDE, 500 EUR)
2002 1. Place at the 1. Crypto Challenge of the Ruhr University Bochum
1991 - 1998 Participation in special training courses for highly mathematically skilled students at the William-Stern-Gesellschaft, Hamburg, Germany

## List of Publications

This thesis is a monograph which contains unpublished material, but is based on the following publications. All publications are listed in (reverse) chronological order and are sorted in the categories book chapters, peer-reviewed journal papers, peer-reviewed conference papers, and other publications.

## Book Chapters

- C. Paar, A. Poschmann, M.J.B. Robshaw. New Designs in Lightweight Symmetric Encryption. Chapter in P. Kitsos, Y. Zhang (eds.): RFID Security: Techniques, Protocols and System-On-Chip Design, Springer-Verlag.

## Peer-Reviewed Journal Papers

- T. Eisenbarth, S. Kumar, C. Paar, A. Poschmann, L. Uhsadel. Survey of Lightweight Cryptography Implementations. IEEE Design &amp;amp; Test of Computers - Special Issue on Secure ICs for Secure Embedded Computing vol. 24, Nr. 6, pp. 522-533, November 2007.

## Peer-Reviewed Conference Papers

- C. Rolfes, A. Poschmann, G. Leander, C. Paar. Ultra-Lightweight Implementations for Smart Devices - Security for 1000 Gate Equivalents. Proceedings of 8th Smart Card Research and Advanced Application Conference, CARDIS 2008, Egham, United Kingdom. LNCS, Springer-Verlag. 8.-11. September 2008.

Curriculum Vitae

■ A. Bogdanov, G. Leander, C. Paar, A. Poschmann, M.J.B. Robshaw, Y. Seurin. Hash Functions and RFID Tags : Mind The Gap, Proceedings of 10th Workshop on Cryptographic Hardware and Embedded Systems, Washington, D.C. USA. LNCS, Springer-Verlag, 10.-13. August 2008.

■ B. Driessen, A. Poschmann, C. Paar. Comparison of Innovative Signature Algorithms for WSNs. Proceedings of 1. ACM Conference on Wireless Network Security, WiSec 2008, Alexandria, Virginia, USA. ACM Press. 31. March - 2. April 2008.

■ C. Rolfes, A. Poschmann, C. Paar. Security for 1000 Gate Equivalents. Workshop on Secure Component and System Identification, SECSI 2008, Berlin. 17.-18. March, 2008.

■ A. Poschmann, C. Paar. Hardware Optimierte Lightweight Block-Chiffren fÃ¼r RFID- und Sensor-Systeme. INFORMATIK 2007 - Informatik trifft Logistik, Workshop: Kryptologie in Theorie und Praxis, 37. Jahresstagung der Gesellschaft für Informatik e. V. (GI), LNI P-110, Bremen, 27. September, 2007.

■ A. Bogdanov, L.R. Knudsen, G. Leander, C. Paar, A. Poschmann, M.J.B. Robshaw, Y. Seurin, and C. Vikkelsoe. PRESENT: An Ultra-Lightweight Block Cipher. 9. International Workshop on Cryptographic Hardware and Embedded Systems, CHES 2007, Vienna, Austria, LNCS, Springer-Verlag, September 10 - 13, 2007.

■ F. Regazzoni, S. Badel, T. Eisenbarth, J. Großschädl, A. Poschmann, Z. Toprak, M. Macchetti, L. Pozzi, C. Paar, Y. Leblebici, and P. Ienne. A Simulation-Based Methodology for Evaluating the DPA-Resistance of Cryptographic Functional Units with Application to CMOS and MCML Technologies. International Conference on Embedded Computer Systems: Architectures, Modeling, and Simulation (SAMOS IC 07), Samos, Greece. 16.-19. July, 2007.

■ L. Uhsadel, A. Poschmann, C. Paar. Enabling Full-Size Public-Key Algorithms on 8-bit Sensor Nodes. European Workshop on Security and Privacy in Ad hoc and Sensor Networks 2007, ESAS 2007, Cambridge, United Kingdom. LNCS, Springer-Verlag, 2.-3. July, 2007.

■ G. Leander and A. Poschmann. On the Classification of 4-Bit S-boxes. International Workshop on the Arithmetic of Finite Fields (WAIFI), Madrid, Spanien. LNCS, Springer-Verlag, 21.-22. June, 2007.

■ L. Uhsadel, A. Poschmann, and C. Paar. An Efficient General Purpose Elliptic Curve Cryptography Module for Ubiquitous Sensor Networks. Software Performance Enhancement for Encryption and Decryption, SPEED 2007, Amsterdam, Netherlands. 11.-12. June, 2007.

■ G. Leander, C. Paar, A. Poschmann, K. Schramm. New Lightweight Crypto Algorithms for RFID. IEEE International Symposium on Circuits and Systems 2007, ISCAS 2007, New Orleans, Louisiana, USA. IEEE Conference Proceedings ISCAS 2007, pp. 1843 - 1846, 27.-30. May, 2007.

■ G. Leander, C. Paar, A. Poschmann, K. Schramm. New Lightweight DES Variants. Fast Software Encryption 2007, FSE 2007, Luxemburg City, Luxemburg. LNCS, Springer-Verlag, 26.-28. March, 2007.

■ A. Poschmann, D. Westhoff, and A. Weimerskirch. Dynamic Code Update for the Efficient Usage of Security Components in WSNs. Workshop on Mobile Ad-Hoc Networks 2007, WMAN 2007, Bern, Switzerland. VDE-Verlag, 1.-2. March, 2007.

Curriculum Vitae

- A. Poschmann, G. Leander, K. Schramm, C. Paar. A Family of Light-Weight Block Ciphers Based on DES Suited for RFID Applications. Workshop on RFID Security 2006, Graz, Austria, 12.-14. July, 2006.

## Other Publications

- G. Acs, L. Buttyan, A. Casaca, C. Castelluccia, A. Francillon, J. Girao, A. Grilo, P. Langendoerfer, M. Nunes, E. Osipov, K. Piotrowski, A. Poschmann, J. Riihijaervi, P. Schaffer, R. Silva, P. Steffen, A. Weimerskirch, D. Westhoff, UbiSec&amp;amp;Sens Deliverable D0.1 Scenario definition and initial threat analysis, 2006, http://www.ist-ubisecsens.org/deliverables/D0.1_060628.pdf
- C. Castelluccia, B. Driessen, A. Hessler, M. Manulis, A. Poschmann, O. Ugus, A. Weimerskirch, D. Westhoff, UbiSec&amp;amp;Sens Deliverable D2.2 Specification and Implementation of Re-Recognition Schemes, 2007.
- F. Armknecht, L. Buttyan, C. Castelluccia, A. Francillon, M. Manulis, A. Poschmann, O. Ugus, D. Westhoff, UbiSec&amp;amp;Sens Deliverable D2.4 Specification and Simulation of Key Pre-distribution Schemes, 2007, http://www.ist-ubisecsens.org/deliverables/D2.4_026820.pdf
- A. Hessler, P. Langendoerfer, M. Manulis, A. Poschmann, K. Piotrowski, D. Westhoff, UbiSec&amp;amp;Sens Deliverable D3.1 Specification, Implementation and Simulation of Secure Distributed Data Storage, 2007.
- J.-M. Bohli, A. Casaca, C. Jardak, P. Langendoerfer, E. Meshkova, R. Nunes, S. Peter, K. Piotrowski, A. Poschmann, K. Rerkrai, UbiSec&amp;amp;Sens Deliverable D3.3 Interfaces for Management as well as Service and Application Support, 2008,

179</code></pre>`;
---

<BaseLayout title="Lightweight Cryptography - Cryptographic Engineering for a P... (2009/516)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2009 &middot; eprint 2009/516
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
