---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2009/370';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'A study of pairing computation for elliptic curves with embedding degree 15';
const AUTHORS_HTML = 'Nadia El Mrabet, Nicolas Guillermin, Sorina Ionica';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">This paper presents the first study of pairing computation on curves with embedding degree $15$. We compute the Ate and the twisted Ate pairing for a family of curves with parameter $\\rho~1.5$ and embedding degree $15$. We use a twist of degree 3 to perform most of the operations in $\\F_p$ or $\\F_{p^5}$. Furthermore, we present a new arithmetic for extension fields of degree $5$. Our computations show that these curves give very efficient implementations for pairing-based cryptography at high security levels.</p>
    </section>

    <p class="text-gray-300">Pairings on elliptic curves were introduced by Andr&eacute; Weil in 1948 in mathematics [24], but their utilization in cryptography is actually quite recent. They were first used for cryptanalytic purposes, i.e. attacking the discrete logarithm problem on supersingular elliptic curves [2], but nowadays they are also used as building blocks for new cryptographic protocols such as the tripartite Diffie-Hellman protocol [15], identity-based encryption [5], short signatures [6], and others. A pairing is a bilinear map  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_3</span> , where  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\mathbb{G}_3</span>  are groups of large prime order r. Known pairings on elliptic curves, i.e. the Weil, Tate, Eta and Ate pairings map to the multiplicative group of the minimal extension of the ground field  <span class="math">\\mathbb{F}_p</span>  containing the r-th roots of unity. The degree of this extension is called the embedding degree with respect to r. The most efficient known method used for pairing computation is Miller's algorithm, whose performance relies heavily on efficient arithmetic of this extension field. It follows that for efficient pairing computation we need curves with a rather small embedding degree.</p>

    <p class="text-gray-300">On the other hand, latest research in efficient computation of pairings focused on the reduction of the loop length in Miller's algorithm. It was proven [23][13] that on most known families of ordinary curves, the complexity of Miller's algorithm is  <span class="math">\\mathcal{O}(\\frac{1}{\\varphi(k)}\\log_2(r))</span> , where k is the embedding degree and  <span class="math">\\varphi</span>  is Euler's totient function. Consequently, for a fixed level of security and therefore a fixed bit length of r, pairing computation might turn out to be faster on curves with embedding degrees such that the integer  <span class="math">\\varphi(k)</span>  is large. Moreover, in practice we are looking for curves for which the following value  <span class="math">\\rho = \\frac{\\log_2(p)}{\\log_2(r)}</span>  is as small as possible, in order to save bandwidth during the calculation.</p>

    <p class="text-gray-300">In this paper, we give the first efficient pairing computation for curves of embedding degree 15. We show that existing constructions of families of curves of degree 15 and j-invariant 0 present multiple advantages. First of all, we show that pairing computation on these curves has loop length  <span class="math">\\frac{\\log_2(r)}{8}</span>  for the Ate pairing and  <span class="math">\\frac{\\log_2(r)}{2}</span>  for the twisted Ate pairing. Secondly, we show that by using twists of degree 3 we manage to perform most of the operations in  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{p^5}</span> . By making use of an interpolation technique, we also improve the arithmetic of  <span class="math">\\mathbb{F}_{p^5}</span>  in order to get better results.</p>

    <p class="text-gray-300">Moreover, denominator computation and the final inversion can be avoided by making use of the twist. Our results show that by choosing the optimal arithmetic on  <span class="math">\\mathbb{F}_{p^5}</span>  and  <span class="math">\\mathbb{F}_{p^{15}}</span> , pairing computation</p>

    <p class="text-gray-300">on curves of embedding degree 15 and  <span class="math">\\rho=1.5</span>  is faster than on Barreto-Naehrig curves for high security levels, i.e. security levels of 192 and 256 bits. Our computations suggest that these curves might be the best choice one could make among known pairing-friendly families of curves for implementations at high security levels.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows: Section 2 gives the definition and important properties of pairings. In Section 3 we establish the optimal computation of the pairing on curves with embedding degree 15. In Section 4 we describe an interpolation-based algorithm for multiplication over the field  <span class="math">\\mathbb{F}_{p^5}</span> . Finally, we conclude in Section 5 by giving a global evaluation of the number of operations needed to compute the pairing and by comparing our results to performances obtained on Barreto-Naehrig curves, which are considered as standard at the time this paper was written.</p>

    <p class="text-gray-300">In this section we give a brief overview of the definitions of pairings on elliptic curves and of Miller's algorithm [20] used in pairing computation. Let p be a prime, E an elliptic curve defined over  <span class="math">\\mathbb{F}_p</span>  by the Weierstrass equation  <span class="math">y^2 = x^3 + ax + b</span>  and r a prime factor of  <span class="math">\\#(E(\\mathbb{F}_p))</span> . Suppose  <span class="math">r^2</span>  does not divide  <span class="math">\\#(E(\\mathbb{F}_p))</span>  and let k be the embedding degree with respect to r, i.e. the smallest integer such that r divides  <span class="math">p^k - 1</span> . We denote by  <span class="math">P_{\\infty}</span>  the point at infinity of the elliptic curve.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> A pairing is a bilinear and non degenerate function:</p>

    <p class="text-gray-300"><span class="math">$e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_3</span>$</p>

    <p class="text-gray-300"><span class="math">(P,Q) \\to e(P,Q)</span></p>

    <p class="text-gray-300">where  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are subgroups of order r on the elliptic curve and  <span class="math">\\mathbb{G}_3</span>  is generally  <span class="math">\\mu_r</span> , the subgroup of the r-th roots of unity in  <span class="math">\\mathbb{F}_{p^k}</span> . In general, in cryptographic applications, we take  <span class="math">\\mathbb{G}_1 = E(\\mathbb{F}_p)[r]</span>  and  <span class="math">\\mathbb{G}_2 \\subset E(\\mathbb{F}_{p^k})[r]</span> , where we denote by E(K)[r] the subgroup of K-rational points of order r of the elliptic curve E. We also denote E[r] the subgroup of points of order r defined over the algebraic closure of  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">Let  <span class="math">P \\in \\mathbb{G}_1</span> ,  <span class="math">Q \\in \\mathbb{G}_2</span> . The goal of Miller's algorithm is to first construct a rational function  <span class="math">f_{s,P}</span>  associated to the point P and to some integer s and to secondly evaluate this function at the point Q (in fact at a divisor associated to this point). The function  <span class="math">f_{s,P}</span>  is such that the divisor associated to it is:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{div}(f_{s,P}) = s(P) - (sP) - (s-1)(P_{\\infty}).</span>$</p>

    <p class="text-gray-300">Suppose we want to compute the sum of iP and jP. Take  <span class="math">h_1</span>  the line going through iP and jP and  <span class="math">h_2</span>  the vertical line through (i+j)P. Miller's idea was to make use of the following relation</p>

    <p class="text-gray-300"><span class="math">$f_{i+j,P} = f_{i,P} f_{j,P} \\frac{h_1}{h_2},\\tag{1}</span>$</p>

    <p class="text-gray-300">in order to compute  <span class="math">f_{s,P}</span>  iteratively. Moreover, Miller's algorithm uses the double-and-add method to compute  <span class="math">f_{s,P}</span>  in  <span class="math">\\log_2(s)</span>  operations.</p>

    <p class="text-gray-300">The Tate pairing The Tate pairing, denoted  <span class="math">e_{Tate}</span> , is defined by:</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{G}_1 \\times \\mathbb{G}_2 \\mapsto \\mathbb{G}_3</span>$</p>

    <p class="text-gray-300"><span class="math">(P,Q) \\mapsto e_{Tate}(P,Q) = f_{r,P}(Q).</span></p>

    <p class="text-gray-300">Here, the function  <span class="math">f_{r,P}</span>  is normalized, i.e.  <span class="math">(u_0^r f_{r,P})(P_{\\infty}) = 1</span>  for  <span class="math">u_0^r</span>  some  <span class="math">\\mathbb{F}_p</span> -rational uniformizer at  <span class="math">P_{\\infty}</span> . This pairing is only defined up to a representative of  <span class="math">(\\mathbb{F}_{p^k})^r</span> . In order to obtain a unique value we raise it to the power  <span class="math">\\frac{p^k-1}{r}</span> , obtaining an r-th root of unity that we call the reduced Tate pairing</p>

    <p class="text-gray-300"><span class="math">$\\hat{e}_{Tate}(P,Q) = f_{r,P}(Q)^{\\frac{p^k-1}{r}}.</span>$</p>

    <p class="text-gray-300">Ate pairing Let  <span class="math">\\pi_p</span>  be the Frobenius over the elliptic curve:  <span class="math">\\pi_p: E \\to E</span> , such that for  <span class="math">P = (x_P, y_P)</span>   <span class="math">\\pi_p(P) = (x_P^p, y_P^p)</span> . The trace of the Frobenius is denoted by t. Let T = t - 1,  <span class="math">\\mathbb{G}_1 := E[r] \\cap \\text{Ker}(\\pi_q - [1])</span>  and  <span class="math">\\mathbb{G}_2 := E[r] \\cap \\text{Ker}(\\pi_q - [q])</span> . Then for two points  <span class="math">P \\in \\mathbb{G}_1</span>  and  <span class="math">Q \\in \\mathbb{G}_2</span> , the Ate pairing is given by:</p>

    <p class="text-gray-300"><span class="math">$e_{ate}(Q, P) = f_{T,Q}(P)^{(p^k - 1)/r}</span>$</p>

    <p class="text-gray-300">It was shown in [14] that the Ate pairing is actually a power of the reduced Tate pairing.</p>

    <p class="text-gray-300">Twisted Ate pairing We begin with the following definition.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> Let E, E' be elliptic curves over  <span class="math">F_p</span> . Then E' is called a twist of degree d if there exists an isomorphism  <span class="math">\\phi_d: E&#x27; \\to E</span>  defined over  <span class="math">\\mathbb{F}_{p^d}</span>  and d is minimal.</p>

    <p class="text-gray-300">Suppose now that E admits a twist E' defined over  <span class="math">\\mathbb{F}_{p^{k/d}}</span>  of degree d, with  <span class="math">d \\mid k</span> . We set  <span class="math">m = \\gcd(k, d)</span>  and e = k/m. We consider  <span class="math">G_1</span>  and  <span class="math">G_2</span>  as above. Then for  <span class="math">P \\in G_1, Q \\in G_2</span>  we get [14]:</p>

    <p class="text-gray-300"><span class="math">$e_{twisted}(P,Q) = f_{T^e,P}(Q)^{(p^k-1)/r},</span>$</p>

    <p class="text-gray-300">The twisted Ate pairing is also a power of the reduced Tate pairing. For curves with small trace of the Frobenius, it is clear that the Ate and twisted Ate pairings should be preferred to the Tate pairing, as the loop in Miller's algorithm will be shorter. Other variants of twisted Ate pairing were obtained in [19] replacing  <span class="math">T^e</span>  with  <span class="math">T^{ie}</span> , for any  <span class="math">i \\in \\mathbb{Z}</span> . All these variants were given in order to find the smallest possible  <span class="math">\\lambda</span>  determining the length of the loop in Miller's algorithm. Hess and Vercauteren exploit these ideas in [13] and [23], respectively, by making use of lattices.</p>

    <p class="text-gray-300"><strong>Optimal pairing</strong> Consider s an integer and  <span class="math">h = \\sum_{i=0}^d h_i x^i \\in \\mathbb{Z}[x]</span>  with  <span class="math">h(s) \\equiv 0 \\mod r</span> . Let  <span class="math">R \\in E(\\mathbb{F}_{q^k})</span>  and  <span class="math">f_{s,h,R}</span>  the function whose divisor is</p>

    <p class="text-gray-300"><span class="math">$(f_{s,h,R}) = \\sum_{i=0}^{d} h_i((s^i R) - (P_{\\infty}))</span>$</p>

    <p class="text-gray-300">We denote  <span class="math">||h||_1 = \\sum_{i=0}^{d} |h_i|</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let s be any primitive root of unity modulo  <span class="math">r^2</span>  and n an integer dividing #Aut(E). Then</p>

    <p class="text-gray-300"><span class="math">$a_{s,h}^{twist}: G_1 \\times G_2 \\to \\mu_r</span>$</p>

    <p class="text-gray-300"><span class="math">(P,Q) \\to (f_{s,h,P}(Q))^{(q^k-1)/r}.</span></p>

    <p class="text-gray-300">defines a bilinear pairing which is non-degenerate if and only if  <span class="math">h(s) \\not\\equiv 0 \\mod r^2</span> . The relation with the Tate pairing is</p>

    <p class="text-gray-300"><span class="math">$a_{s,h}^{twist}(P,Q) = t(P,Q)^{h(s)/r}</span>$
.</p>

    <p class="text-gray-300">There exists an efficiently computable  <span class="math">h \\in \\mathbb{Z}</span>  with  <span class="math">h(s) \\equiv 0 \\mod r</span> ,  <span class="math">deg(h) \\leq \\varphi(n) - 1</span>  and  <span class="math">||h||_1 = \\mathcal{O}(r^{1/\\varphi(n)})</span>  such that the above pairings are non-degenerate. The  <span class="math">\\mathcal{O}</span> -constant depends only on n.</p>

    <p class="text-gray-300">Security aspect The security of a pairing based cryptosystem relies on two parameters: the bit length of r,  <span class="math">\\log_2 r</span>  and the bit size of the extension field  <span class="math">k\\log_2 p</span> . These parameters have to be chosen large enough to ensure that the discrete logarithm problem will be hard in both the subgroup of points of order r of the curve and the multiplicative group of the finite field  <span class="math">\\mathbb{F}_{p^k}</span> . The fastest known attack on finite field is the index calculus method, whose complexity is  <span class="math">\\mathcal{O}(L_r(\\frac{1}{3}))</span> , where  <span class="math">L_r(\\frac{1}{3}) = \\exp\\left((32/9)^{(1/3)}(\\log r)^{\\frac{1}{3}}\\log(\\log(r))^{\\frac{2}{3}}\\right)</span>  and c is a constant depending on the characteristic of the finite field [12]. Meanwhile the best attack known</p>

    <p class="text-gray-300">Table 1. Level of security in bit</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">AES security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">bit<br>size of <span class="math">r</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">bitsize of <span class="math">p^k</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3072</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7680</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15360</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">on elliptic curves DLP is the Pollard- <span class="math">\\rho</span>  method, whose complexity is  <span class="math">\\mathcal{O}(\\sqrt{r})</span>  [9, Chap. 17]. As a consequence, while the security level will increase, the bound on  <span class="math">k\\log_2(p)</span>  is expected to grow faster than the bound on  <span class="math">\\log_2(r)</span> . Following NIST recommendations [1], Table 1 gives optimal bitsizes of r and  <span class="math">p^k</span>  for different security levels.</p>

    <p class="text-gray-300">On the other hand, in practice we are looking for curves for which the following value</p>

    <p class="text-gray-300"><span class="math">$\\rho = \\frac{\\log p}{\\log r}</span>$</p>

    <p class="text-gray-300">is as small as possible, in order to save bandwith during the calculation. This is due to the fact that for a fixed level of security, efficient implementation of the pairing depends on the size of the ground field, i.e. on the size of p. So taking greater k is a better solution than increasing the bit length of p.</p>

    <p class="text-gray-300">A first method that could be used in order to build curves with k=15 is the Cocks-Pinch method [8]. This method generates curves with arbitrary r and  <span class="math">\\rho \\sim 2</span> . Duan and all. [11] showed that by using the Brezing-Weng method we can actually do better. They generated a family of curves with j-invariant 0, embedding degree 15 and  <span class="math">\\rho \\sim 1.5</span> . This family is given by the following polynomials:</p>

    <p class="text-gray-300"><span class="math">$p = \\frac{1}{3}x^{12} - \\frac{2}{3}x^{11} + \\frac{1}{3}x^{10} + \\frac{1}{3}x^7 - \\frac{2}{3}x^6 + \\frac{1}{3}x^5 + \\frac{1}{3}x^2 + \\frac{1}{3}x + \\frac{1}{3}x + \\frac{1}{3}x + \\frac{1}{3}x + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7 + \\frac{1}{3}x^7</span>$</p>

    <p class="text-gray-300">The remainder of this paper will present efficient computation of pairings on this family of curves. To emphasize the performance of our suggestion, we compare our results to those resulting from efficient implementation of pairings on Barreto-Naehrig curves [4]. We briefly remind that these are curves of embedding degree 12 and j-invariant 0, given by the following parametrization:</p>

    <p class="text-gray-300"><span class="math">$p = 36x^4 + 36x^3 + 24x^2 + 6x + 1</span>$
<span class="math">$r = 36x^4 + 36x^3 + 18x^2 + 6x + 1</span>$
<span class="math">$t = 6x^2 + 1</span>$</p>

    <p class="text-gray-300">These curves are preferred in cryptographic applications because they have the  <span class="math">\\rho \\sim 1</span>  and most operations during the pairing computation are done in  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{p^2}</span> , thanks to the existence of a twist of degree 6.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Twists of degree 3</h3>

    <p class="text-gray-300">Let E be an elliptic curve of j-invariant 0, defined over  <span class="math">\\mathbb{F}_p</span> . Suppose its equation is  <span class="math">y^2 = x^3 + b</span> , with  <span class="math">b \\in \\mathbb{F}_p</span> . Consider E over the extension field  <span class="math">\\mathbb{F}_{p^{k/3}}</span> . Then it admits a cubic twist E' of equation  <span class="math">y^2 = x^3 + \\frac{b}{D}</span> ,</p>

    <p class="text-gray-300">with D not a cubic residue  <span class="math">D \\in \\mathbb{F}_{a^{k/3}}</span> . The morphism</p>

    <p class="text-gray-300"><span class="math">$\\Phi_3: E&#x27; \\to E: \\Phi_3(x,y) = (xD^{1/3}, yD^{1/2})</span>$</p>

    <p class="text-gray-300">maps points in  <span class="math">E&#x27;(\\mathbb{F}_{p^k/3})</span>  to points in  <span class="math">E(\\mathbb{F}_{p^k})</span> . In particular, as  <span class="math">r \\mid \\#E&#x27;</span> , we may choose Q, the generator of  <span class="math">\\mathbb{G}_2</span> , as the image of an r order point under this morphism :  <span class="math">Q = \\Phi_3(Q&#x27;)</span> , with  <span class="math">Q&#x27; \\in E&#x27;(\\mathbb{F}_{p^{k/3}})</span> . So  <span class="math">Q = (D^{1/3}x, D^{1/2}y)</span> , with  <span class="math">x, y \\in \\mathbb{F}_{p^{k/3}}</span> . As we will see later, for k = 15 this will imply that most operations in pairing computation on  <span class="math">\\mathbb{G}_1 \\times \\mathbb{G}_2</span>  (or  <span class="math">\\mathbb{G}_2 \\times \\mathbb{G}_1</span> ) are to be done in  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{p^5}</span> .</p>

    <p class="text-gray-300">We can easily see that for the family of curves with k=15 described above, the length of the Miller's loop for the twisted Ate pairing is  <span class="math">\\frac{5}{8}\\log_2 r</span> . We will show that the complexity of the computation of the optimal pairing for this family is  <span class="math">\\mathcal{O}(\\frac{\\log_2 r}{2})</span> . Indeed, we apply theorem 1 with n=3 and compute the following polynomial using function field LLL ([21]):</p>

    <p class="text-gray-300"><span class="math">$h_{15}(x,t) = (x^3 - x^2 + 1)t - x^4 + x^3 - x + 1</span>$</p>

    <p class="text-gray-300">We compute</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{div}(f_{s,h,P}) = ((x^3 - x^2 + 1)(sP) - ((x^3 - x^2 + 1)sP) - (x^3 - x^2)(P_{\\infty})) + ((-x^4 + x^3 - x + 1)(P) - ((-x^4 + x^3 - x + 1)P) - (-x^4 + x^3 - x)(P_{\\infty})) + ((x^3 - x^2 + 1)tP) + ((-x^4 + x^3 - x + 1)P) - 2(P_{\\infty}) = \\operatorname{div}(f_{x^3 - x^2 + 1, sP}) + \\operatorname{div}(f_{-x^4 + x^3 - x + 1, P}) + \\operatorname{div}(f_{x^3 - x^2 + 1, sP})</span>$</p>

    <p class="text-gray-300">Now it was shown in [14] that  <span class="math">\\mathbb{G}_1 = E[r] \\cap \\operatorname{Ker}(\\zeta_3 \\circ \\pi_p^5 - [p^5])</span>  and  <span class="math">\\mathbb{G}_2 = E[r] \\cap \\operatorname{Ker}(\\zeta_3 \\circ \\pi_{p^5} - [1])</span>  and that  <span class="math">f_{T^5,\\zeta_3 \\circ \\pi_p^5(P)} \\circ \\zeta_3 \\circ \\pi_p^5 = f_{T^5,P}</span> . We conclude that the optimal twisted Ate pairing for this family of curves is given by the formula:</p>

    <p class="text-gray-300"><span class="math">$(f_{x^3-x^2+1,P}^{p^5}(Q)f_{-x^4+x^3-x+1,P}(Q))^{\\frac{p^{15}-1}{r}}.</span>$</p>

    <p class="text-gray-300">Note that the evaluation at Q of the vertical line  <span class="math">v_{(x^3-x^2+1)tP}</span>  can actually be ignored because of the final exponentiation. So we need to compute  <span class="math">f_{x,P}(Q)</span> ,  <span class="math">f_{x^2,P}(Q)</span> ,  <span class="math">f_{x^3,P}(Q)</span>  and  <span class="math">f_{x^4,P}(Q)</span>  as well the evaluation at Q of the lines  <span class="math">l_{x^3P,-x^2P}</span> ,  <span class="math">l_{-x^4,x^3}</span> ,  <span class="math">l_{(-x^4+x^3,-x)}</span> . So we get a complexity of  <span class="math">\\mathcal{O}(\\log r/2)</span>  for the pairing computation. The twisted Ate pairing has loop length  <span class="math">\\frac{\\log r}{2}</span>  for Barreto-Naehrig curves, as a search for the optimal pairing on these curves gives, for example,</p>

    <p class="text-gray-300"><span class="math">$h_{12}(x,t) = (2x+6x^2)*t+1+2x</span>$</p>

    <p class="text-gray-300">So the complexity of Miller's algorithm is  <span class="math">\\frac{\\log_2 r}{2}</span> . The Ate pairing for k=15 is given by  <span class="math">f_{x,Q}(P)</span> , so the loop length is  <span class="math">\\frac{\\log r}{8}</span> , while the optimal Ate pairing computation for Barreto-Naehrig curves has complexity  <span class="math">\\mathcal{O}(\\frac{\\log r}{4})</span> , as shown in [23]. We have also verified with MAGMA that our formulas give bilinear non-degenerated pairings.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Denominator elimination in pairing computation</h3>

    <p class="text-gray-300">We use an idea given in [18]. We observe that the expression of line  <span class="math">h_2</span>  in Equation (1) can be written as:</p>

    <p class="text-gray-300"><span class="math">$x_T - x_Q = \\frac{x_T^3 - x_Q^3}{x_T^2 + x_T x_Q + x_Q^2} = \\frac{y_T^2 - y_Q^2}{x_T^2 + x_T x_Q + x_Q^2}.</span>$</p>

    <p class="text-gray-300">The element  <span class="math">(y_Q^2 - y_T^2)</span>  is in  <span class="math">\\mathbb{F}_{p^5}</span>  and can be forgotten during the computation of the pairing, because of the final exponentiation. Indeed,  <span class="math">p^5 - 1</span>  is a divisor of  <span class="math">\\frac{p^{15} - 1}{r}</span>  so multiplication by this term can be omitted. Consequently at each iteration in Miller's algorithm loop it suffices to multiply by  <span class="math">x_T^2 + x_T x_Q + x_Q^2</span> , instead of dividing by  <span class="math">h_2</span> . This saves operations, as we no longer need to compute denominators at each step and also avoids the final inversion, which is important on restricted devices.</p>

    <p class="text-gray-300">Pairing computation on elliptic curves in Weierstrass form is usually performed in Jacobian coordinates (see [7], [3]), but we find that homogenous coordinates will give better results in our case. Our starting point is a suggestion for pairing computation in homogenous coordinates given in [10]. A point (X, Y, Z) in homogenous coordinates represents the affine point (X/Z, Y/Z) on the elliptic curve of affine equation  <span class="math">y^{-}x^{3} + c</span> . Due to denominator elimination, the doubling step of the Miller loop becomes:</p>

    <p class="text-gray-300"><span class="math">$(2i)P \\leftarrow 2 \\cdot (iP)</span>$
<span class="math">$f_{2i,P} \\leftarrow f_{i,P}^2 h_1(Q) S_T(Q)</span>$</p>

    <p class="text-gray-300">where  <span class="math">h_1(Q) = 2YZy_Q - 3X^2x_Q + Y^2 - 3cZ^2</span>  and  <span class="math">S_T(Q) = Z^2x_Q^2 + XZx_Q + X^2</span> . We compute  <span class="math">(2i)P = (X_3, Y_3, Z_3)</span>  as</p>

    <p class="text-gray-300"><span class="math">$X_3 = 2XY(Y^2 - 9Z^2),</span>$</p>

    <p class="text-gray-300"><span class="math">Y_3 = (Y - Z)(Y + 3Z)^3 - 8Y^3Z,</span>
<span class="math">Z_3 = 2Y^3Z.</span></p>

    <p class="text-gray-300">We perform the operations in the following order:</p>

    <p class="text-gray-300"><span class="math">$A = Y^{2}</span>$
<span class="math">E = X^{2}</span>
<span class="math">B = Z^{2}</span>   <span class="math">F = (X + Y)^{2} - E - A</span>
<span class="math">C = (Y + Z)^{2} - A - B</span>   <span class="math">X_{3} = F \\cdot (A - 9B)</span>
<span class="math">Z_{3} = 4A \\cdot C</span>   <span class="math">Y_{3} = (A - 3B + C) \\cdot (A + 9B + 3C) - Z_{3}</span></p>

    <p class="text-gray-300">We compute  <span class="math">h_1(Q) \\cdot S_T(Q)</span>  as:</p>

    <p class="text-gray-300"><span class="math">$h_1(Q)S_T(Q) = (2YZy_Q - 3X^2x_Q + Y^2 - 3cZ^2)(Z^2x_Q^2 + XZx_Q + X^2) = 2X^2YZy_Q + 2XYZ^2x_Qy_Q + 2YZ^3x_Q^2y_Q - 3X^4x_Q - 3X^3Zx_Q^2 - 3X^2Z^2x_Q^3 + (Y^2 - 3cZ^2)X^2 + (Y^2 - 3cZ^2)XZx_Q + (Y^2 - 3cZ^2)Z^2x_Q^2</span>$</p>

    <p class="text-gray-300">It follows that we need to perform the following operations:</p>

    <p class="text-gray-300"><span class="math">$G = B \\cdot C</span>$</p>

    <p class="text-gray-300"><span class="math">$H = B \\cdot F</span>$</p>

    <p class="text-gray-300"><span class="math">$I = E^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$K = \\frac{(X+Z)^{2} - E - B}{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$L = K^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$M = F^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$N = (A - 3cB) \\cdot K</span>$</p>

    <p class="text-gray-300"><span class="math">$Q = E \\cdot K</span>$</p>

    <p class="text-gray-300"><span class="math">$P = (A - 3cB) \\cdot B</span>$</p>

    <p class="text-gray-300">This gives the following computation for  <span class="math">h_1(Q)S_T(Q)</span> :</p>

    <p class="text-gray-300"><span class="math">$h_1(Q)S_T(Q) = Fy_Q + Hx_Qy_Q + Gx_Q^2y_Q - (3I - N)x_Q - (3O - P)x_Q^2 - 3Lx_Q^3 + M - 3cLx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + Mx_Q^2 + M</span>$</p>

    <p class="text-gray-300">We denote by  <span class="math">S_{p^n}</span>  and  <span class="math">M_{p^n}</span>  the cost of a squaring and a multiplication, respectively, in the extension field of degree n of  <span class="math">\\mathbb{F}_p</span> . We assume that the expressions of  <span class="math">x_Q</span> ,  <span class="math">x_Q^2</span> ,  <span class="math">y_Q</span> ,  <span class="math">x_Qy_Q</span> ,  <span class="math">x_Q^2y_Q</span>  are precomputed. As explained in section 3.1,  <span class="math">x_Q</span>  and  <span class="math">y_Q</span>  can be chosen such as the multiplication of any of these expressions</p>

    <p class="text-gray-300">with an element of  <span class="math">\\mathbb{F}_p</span>  costs  <span class="math">5M_p</span> . A count of the operations for the entire doubling step for the twisted Ate pairing gives  <span class="math">9S_p + 38M_p + S_{p^{15}} + M_{p^{15}}</span> . In the case of the Ate pairing doubling computation, A, B, C, ...L are elements of  <span class="math">\\mathbb{F}_{p^5}</span> , so the operation count gives  <span class="math">30M_p + 9S_{p^5} + 8M_{p^5} + S_{p^{15}} + M_{p^{15}}</span> . For pairing computation on Barretto-Naehrig curves we only need to do the doubling of the point and compute  <span class="math">h_1(Q)</span> . The operation count gives  <span class="math">5S_p + 15M_p + S_{p^{12}} + M_{p^{12}}</span>  for the doubling part of the twisted Ate pairing and  <span class="math">4M_p + 5S_{p^2} + 3M_{p^2} + S_{p^{12}} + M_{p^{12}}</span>  for the Ate pairing.</p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 First comparison</h3>

    <p class="text-gray-300">We compare the complexity of pairing computation for the families of curves presented above, using Karatsuba and Toom Cook multiplication algorithms in the extension fields. The costs of multiplications are given in Table 2. We denote by  <span class="math">A_p</span>  the cost of an addition in  <span class="math">\\mathbb{F}_p</span> . Table 3 gives recommended sizes of r and p for different security levels. Using a classical arithmetic, we count the number of multiplications in  <span class="math">\\mathbb{F}_p</span>  needed for a Miller loop; we do not take into account the cost of the polynomial reduction one has to perform when multiplying two elements of the extension field. Indeed,  <span class="math">\\mathbb{F}_{p^{12}}</span>  is usually constructed as an extension of  <span class="math">\\mathbb{F}_{p^2}</span> , which in turn is constructed as  <span class="math">\\mathbb{F}_p/(X^2+1)</span> . The polynomials used to construct the extension fields of degree 2 and 3 over this field then have constant term  <span class="math">\\delta</span>  in  <span class="math">\\mathbb{F}_{p^2}</span> ; depending on the choice of delta (not a square, nor a cube) the multiplication cost may vary. However in this paper we consider this influence negligeable. The resulting comparison for the Ate and twisted Ate pairings is given in Table 4.</p>

    <p class="text-gray-300"><strong>Table 2.</strong> A performance evaluation: arithmetic of  <span class="math">\\mathbb{F}_{p^{15}}</span>  versus arithmetic of  <span class="math">\\mathbb{F}_{p^{12}}</span></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#314;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^2}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_p</span> &#1079;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^5}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^6}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^{12}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^{15}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3M_p + 4A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5M_p + 20A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">13M_p + 58A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">15M_p + 72A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45M_p + 180A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">65M_p + 390A_p</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3. A security evaluation: curves with embedding degree 15 versus Barreto-Naehrig curves</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">AES security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#305;p sizes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">group</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">o sizes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">bit length of <span class="math">r</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">length of <span class="math">r</span> bit length of <span class="math">p^k</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k = 15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k = 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">r</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3072</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7680</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">576</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15360</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">682</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1280</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1280</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4. Pairing evaluation: curves with embedding degree 15 versus Barreto-Naehrig curves</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Twisted Ate pairing</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Security level in bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k = 15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k = 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k = 15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k = 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7800M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">12480M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">16104M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">17007M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">30432M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">31200M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">28601M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">33486M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">54048M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">62400M_{p}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">It becomes clear that at 80 and 128 bits security levels Barreto-Naehrig curves give most efficient pairing computation. On the other hand, for 192 and 256 security levels, the family of curves with embedding degree 15 and  <span class="math">\\rho</span>  1.5 gives pairing computations faster than on Barreto-Naehrig curves. Moreover, note that Karatsuba is optimal for extensions of degree 2, so it seems quite natural to question these results. We propose in the next Section an improvement of the arithmetic on  <span class="math">\\mathbb{F}_{p^5}</span>  using the Newton interpolation method to compute a multiplication between two elements of  <span class="math">\\mathbb{F}_{p^5}</span> .</p>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Finite field arithmetic</h2>

    <p class="text-gray-300">In cryptography, and more generally in arithmetic, we need an efficient polynomial multiplication. The optimization can be in time or elementary operations. Pairing Based Cryptography (PBC) follows the same rules as PBC involves polynomial computations. Indeed A and  <span class="math">B \\in \\mathbb{F}_{p^k}</span>  are represented as polynomials of degree (k-1) in  <span class="math">\\gamma</span> , with  <span class="math">\\gamma</span>  a root in  <span class="math">\\mathbb{F}_{p^k}</span>  of a polynomial of degree k, irreducible over  <span class="math">\\mathbb{F}_p</span> . If possible, the irreducible polynomial is chosen to be  <span class="math">X^k - \\beta</span> , with  <span class="math">\\beta \\in \\mathbb{F}_p</span> . In the case of k = 5, this condition is true for every prime p such that  <span class="math">p \\equiv 1 \\mod(5)</span>  [17, Theorem 3.75].</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let  <span class="math">\\mathbb{F}_p</span>  be a finite field and  <span class="math">\\beta</span>  be an element of  <span class="math">\\mathbb{F}_p</span>  such that  <span class="math">\\beta</span>  is not a k-th power of an element of  <span class="math">\\mathbb{F}_p</span> . Then the polynomial  <span class="math">X^k - \\beta</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">In extensions of degree 2 or 3 the Karatsuba and Toom Cook multiplications are the most efficient. For higher degree extension, one can use tower field extensions [16] and apply Karatsuba and Toom Cook [25], or multiplication by interpolation [25]. Generally, interpolation methods have an important drawback: they increase the number of additions during a multiplication. We present a multiplication by Newton interpolation which, despite the extra additions, improves the global complexity of a multiplication in  <span class="math">\\mathbb{F}_{p^5}</span>  when compared to the Karatsuba multiplication.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Interpolation</h3>

    <p class="text-gray-300">We denote by  <span class="math">A(X) = a_0 + a_1 X + \\ldots + a_{k-1} X^{k-1}</span> ,  <span class="math">B(X) = b_0 + b_1 X + \\ldots + b_{k-1} X^{k-1}</span>  the polynomials obtained by substituting  <span class="math">\\gamma</span>  by X in the expressions of A and B in  <span class="math">\\mathbb{F}_{p^k}</span> . Multiplications by interpolation follow these steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Find 2k-1 different values in  <span class="math">\\mathbb{F}_p</span>   <span class="math">\\{\\alpha_0, \\alpha_1, \\dots, \\alpha_{2k-2}\\}.</span></li>
      <li>Evaluate the polynomials A(X) and B(X) at these 2k-1 values:  <span class="math">A(\\alpha_0), \\ldots, A(\\alpha_{2k-2}), B(\\alpha_0), \\ldots, B(\\alpha_0)</span></li>
      <li>Compute  <span class="math">C(X) = A(X) \\times B(X)</span>  at these 2k-1 values  <span class="math">C(\\alpha_i) = A(\\alpha_i)B(\\alpha_i)</span> .</li>
      <li>Interpolate C(X) polynomial of degree 2k-2 either with Lagrange or Newton interpolation.</li>
    </ul>

    <p class="text-gray-300">We describe our method of multiplication using the Newton interpolation, which is more efficient for our purpose than Lagrange interpolation [25]. The use of FFT [25] is not interesting in our case. Indeed, during a FFT multiplication, we have to multiply by roots of unity. As we do not have any control on the characteristic p we work with, the roots of unity do not necessarily have a sparse representation, even after recoding. It follows that multiplications by these roots are expensive. Furthermore, the choice of values of interpolation in Section 4.3 is not interesting for the FFT method. Last but not least, FFT is very interesting for extensions of large even degree, which is not the case for the finite field  <span class="math">\\mathbb{F}_{p^5}</span> . Consequently, we focused on the Newton interpolation.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Newton interpolation</h3>

    <p class="text-gray-300">Newton interpolation constructs the polynomial C(X) in the following way:</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} c&#x27;_0 = &amp; C(\\alpha_0) \\\\ c&#x27;_1 = &amp; (C(\\alpha_1) - c&#x27;_0) \\frac{1}{(\\alpha_1 - \\alpha_0)} \\\\ c&#x27;_2 = \\left( (C(\\alpha_2) - c&#x27;_0) \\frac{1}{(\\alpha_2 - \\alpha_0)} - c&#x27;_1 \\right) \\frac{1}{(\\alpha_2 - \\alpha_1)} \\\\ \\vdots = &amp; \\vdots \\end{cases}</span>$</p>

    <p class="text-gray-300">The reconstruction of C(X) is done by</p>

    <p class="text-gray-300"><span class="math">$C(X) = c&#x27;_0 + c&#x27;_1(X - \\alpha_0) + c&#x27;_2(X - \\alpha_0)(X - \\alpha_1) + \\dots + c&#x27;_{2k-2}(X - \\alpha_0)(X - \\alpha_1) \\dots (X - \\alpha_{2k-2}).</span>$</p>

    <p class="text-gray-300">It can be computed using the Horner scheme:</p>

    <p class="text-gray-300"><span class="math">$C(X) = c&#x27;_0 + (X - \\alpha_0) [c&#x27;_1 + (X - \\alpha_1) (c&#x27;_2 + (X - \\alpha_2) \\langle \\dots \\rangle)]</span>$</p>

    <p class="text-gray-300">So, complexity in term of operation of Newton interpolation is the sum of the complexities of these different operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the evaluations in  <span class="math">\\alpha_i</span>  of A(X) et B(X)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the 2k-1 multiplications in  <span class="math">\\mathbb{F}_p</span>  (  <span class="math">A(\\alpha_i) \\times B(\\alpha_i)</span>  )</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>computation of the  <span class="math">c&#x27;_i</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the Horner scheme to find the expression of  <span class="math">C(X) = A(X) \\times B(X)</span>  of degree 2k-1.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We consider that k = 5, the 2k - 1 = 9 chosen values for the interpolation are:</p>

    <p class="text-gray-300"><span class="math">$\\alpha_0 = 0, \\alpha_1 = 1, \\alpha_2 = -1, \\alpha_3 = 2, \\alpha_4 = -2, \\alpha_5 = 4, \\alpha_6 = -4, \\alpha_7 = 3, \\alpha_8 = \\infty.</span>$</p>

    <p class="text-gray-300">We choose those value in order to minimize the number of additions and divisions by the differences of the  <span class="math">\\alpha_i</span>  during the interpolation.</p>

    <p class="text-gray-300">In the following section, we denote  <span class="math">A_p</span>  an addition,  <span class="math">M_p</span>  a multiplication, and  <span class="math">S_p</span>  a square in  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">Complexity of the evaluations in  <span class="math">\\alpha_i</span>  of A and B First of all, we have to evaluate A(X) and B(X) at the  <span class="math">\\alpha_i</span> 's. With the chosen values, evaluations of A(X) and B(X) are done using only additions and shifts in  <span class="math">\\mathbb{F}_p</span> . Indeed, a product by a power of 2 is composed of shifts in binary base, so in order to evaluate A(X) at  <span class="math">2^j</span> , we compute the products  <span class="math">a_i \\times (2^j)^i</span> , and perform the additions  <span class="math">\\sum_{i=0}^{k-1} a_i (2^j)^i</span>  using a FFT scheme</p>

    <p class="text-gray-300">Writing down 3 = 2 + 1, the evaluation in 3 is only composed of shifts and additions too. Indeed, powers of 3 can be decomposed as sum of powers of 2:  <span class="math">3^2 = 2^3 + 1</span> ,  <span class="math">3^3 = 2^5 - 2^2 - 1</span>  et  <span class="math">3^4 = 2^6 + 2^4 + 1</span> . Adding the different costs, evaluations of A(X) and B(X) have a complexity of  <span class="math">50A_n</span> .</p>

    <p class="text-gray-300">Once we have the evaluations, we have to compute the multiplications  <span class="math">A(\\alpha_i) \\times B(\\alpha_i)</span>  which are obtained with  <span class="math">9M_p</span> . The complexity of the steps 1 and 2 altogether is then  <span class="math">50A_p + 9M_p</span> .</p>

    <p class="text-gray-300">Complexity of the computations of  <span class="math">c&#x27;_j</span>  In order to compute the coefficients  <span class="math">c&#x27;_j</span>  during a Newton interpolation, one has to compute exact divisions by the differences of the  <span class="math">\\alpha_i \\in \\mathbb{F}_p</span> . We call an exact division a division where the dividend is a multiple of the divisor. Among all the differences of the  <span class="math">\\alpha_i</span>  we choose, eleven are not a power of 2. They are given in Table 5. In a binary basis, exact divisions by power of 2 are very simple, they are only shift on the right of the bits. We have to analyze the complexity of divisions by 3, 5 and 7. A precise analysis of these divisions shows they can be computed in only one subtraction.</p>

    <p class="text-gray-300">Table 5. The problematic differences</p>

    <p class="text-gray-300"><span class="math">$\\alpha_3 - \\alpha_2 = 3</span>$
<span class="math">\\alpha_4 - \\alpha_1 = -3</span>
<span class="math">\\alpha_5 - \\alpha_1 = 3</span>
<span class="math">\\alpha_5 - \\alpha_2 = 5</span>
<span class="math">\\alpha_5 - \\alpha_4 = 6</span>
<span class="math">\\alpha_6 - \\alpha_1 = -5</span>
<span class="math">\\alpha_6 - \\alpha_2 = -3</span>
<span class="math">\\alpha_6 - \\alpha_3 = -6</span>
<span class="math">\\alpha_7 - \\alpha_0 = 3</span>
<span class="math">\\alpha_7 - \\alpha_4 = 5</span>
<span class="math">\\alpha_7 - \\alpha_6 = 7</span></p>

    <p class="text-gray-300">We describe here the method to execute the exact division. We want to divide  <span class="math">\\delta</span> , a multiple of 3, by 3, i.e.  <span class="math">\\delta</span>  verifies that  <span class="math">\\delta = 3 \\times \\sigma</span>  and we want to find  <span class="math">\\sigma</span> . This equality can be rewritten as  <span class="math">\\sigma = \\delta - 2 \\times \\sigma</span> . If  <span class="math">\\delta = \\sum_i \\delta_i 2^i</span>  and  <span class="math">\\sigma = \\sum_i \\sigma_i 2^i</span>  we can find  <span class="math">\\sigma</span>  bit after bit beginning with the less significant bit. Indeed,  <span class="math">\\sigma = \\delta - 2 \\times \\sigma</span>  gives  <span class="math">\\sigma_0 = \\delta_0</span> . Thus we can find  <span class="math">\\sigma_1</span>  as the result of the subtraction:  <span class="math">\\delta_1 \\delta_0 - \\sigma_0 0 = \\sigma_1 \\sigma_0</span> . By extrapolation we find  <span class="math">\\sigma_1</span> , and then  <span class="math">\\sigma_2</span>  and the following as explained in Figure 1.</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Scheme for the division by 3 in one addition</p>

    <p class="text-gray-300">Consequently, an exact division by 3 is theoretically done with exactly one subtraction in  <span class="math">\\mathbb{F}_p</span> . The same scheme can be applied to an exact division by 5. Indeed, for  <span class="math">\\chi = 5 \\times \\kappa</span>  (i. e. knowing  <span class="math">\\chi</span>  we want to find  <span class="math">\\kappa</span> ), we just have to consider that  <span class="math">\\kappa = \\chi - 4 \\times \\kappa</span> . Then the exact division by 5 has the complexity of a subtraction.</p>

    <p class="text-gray-300">The cost of an exact division by 7 is the same as the one of an addition in  <span class="math">\\mathbb{F}_p</span> , provided that we find first the negative of the result. We know  <span class="math">\\mu = 7 \\times \\nu</span> , and we want to find  <span class="math">\\nu</span> . We transform the equation:  <span class="math">-\\nu = \\mu - 8 \\times \\nu</span> . So first we find  <span class="math">-\\nu</span>  with an addition in  <span class="math">\\mathbb{F}_p</span> , and then it is quite easy to find  <span class="math">\\nu</span> .</p>

    <p class="text-gray-300">We consider that the complexity of a subtraction is equivalent to the complexity of an addition, which is an upper bound for a subtraction. The implementation aspect is considered in Section 4.4. As a consequence, the exact divisions by 3, 5 and 7 can be computed with only an addition. The eleven divisions by these values have a complexity of  <span class="math">11A_p</span> .</p>

    <p class="text-gray-300">In order to have the complexity of the computation of the  <span class="math">c&#x27;_j</span> , we must take into consideration the subtractions. There are 28 subtractions in the formulas of the  <span class="math">c&#x27;_j</span> .</p>

    <p class="text-gray-300">Thus, the complexity of the computation of the  <span class="math">c&#x27;_i</span>  is  <span class="math">39A_p</span> .</p>

    <p class="text-gray-300">Complexity of the polynomial interpolation We use the Horner scheme to find the expression of the product polynomial  <span class="math">C = A \\times B</span> . The Horner scheme consists in writing and computing:</p>

    <p class="text-gray-300"><span class="math">$C(X) = ((((c&#x27;_8(X - \\alpha_7) + c&#x27;_7)(X - \\alpha_6) + c&#x27;_6)(X - \\alpha_5) + c&#x27;_5) \\dots + c&#x27;_1)(X - \\alpha_1) + c&#x27;_0.</span>$</p>

    <p class="text-gray-300">We begin to compute from the inside (the parenthesis  <span class="math">(c&#x27;_8(X - \\alpha_7) + c&#x27;_7))</span>  to the outside, i.e. we compute  <span class="math">((c&#x27;_8(X - \\alpha_7) + c&#x27;_7)(X - \\alpha_6) + c&#x27;_6)</span> , and we continue until we arrive at the coefficient  <span class="math">c&#x27;_0</span> . Thus</p>

    <p class="text-gray-300">the construction of the polynomial using the Horner scheme is composed of multiplications of the <em>i</em>-th parenthesis by  <span class="math">\\alpha_{7-i}</span>  and additions. With the chosen values of  <span class="math">\\alpha&#x27;_i</span> s the Horner scheme is composed only of additions.</p>

    <p class="text-gray-300">So the complexity of the polynomial expression with the Horner scheme is  <span class="math">29A_p</span> .</p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 Results and implementation aspects</h3>

    <p class="text-gray-300">We have described the multiplication by interpolation for an extension of degree 5 of a finite field. Table 6 gives the complexity of multiplications with several methods: the classical Karatsuba and Toom Cook multiplications (KTC), the interpolation multiplication. The third line of Table 6 (Mix) gives the cost of a multiplication in  <span class="math">\\mathbb{F}_{p^{15}}</span>  using a tower of extension fields. We use our Newton multiplication in  <span class="math">\\mathbb{F}_{p^5}</span>  and the Toom Cook method for the extension field of degree 3 over  <span class="math">\\mathbb{F}_{p^5}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Extension<br>Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^2}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^5}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^{12}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">M_{p^{15}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">KTC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">3M_p + 4A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">13M_p + 60A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45M_p + 180A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">65M_p + 390A_p</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Interpolation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9M_p + 107A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">23M_p + 2070A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">29M_p + 2136A_p</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mix</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45M_n + 180A_n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45M_n + 635A_n</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6. Complexity of different method of multiplication</p>

    <p class="text-gray-300">Using these results, it becomes clear that it is better to use a multiplication by interpolation instead of a multiplication using Karatsuba Toom Cook for extension fields of degree 5. We save 4 multiplications in  <span class="math">\\mathbb{F}_p</span>  using interpolation whereas we add 47 additions. The extra cost due to these additions is not as important as the cost to compute 4 multiplications in  <span class="math">\\mathbb{F}_p</span> . Indeed, the complexity of a Karatsuba multiplication in  <span class="math">\\mathbb{F}_p</span>  is</p>

    <p class="text-gray-300"><span class="math">$5N^{\\log_2(3)}A_w + N^{\\log_2(3)}M_w</span>$</p>

    <p class="text-gray-300">where N is the number of bytes of the considered integers, and where  <span class="math">A_w</span>  and  <span class="math">M_w</span>  represent an addition and a multiplication of a word.</p>

    <p class="text-gray-300">We designed the exact division by 3 on a Stratix 2 FPGA (speed grade 3). The result of this implementation is that the division we present can be done in the same time as an addition. We compute the exact division of an integer of size 240 bits in 13.9 ns, which is an acceptable latency to be executed in one clock cycle. In comparaison, on the same FPGA the ripple-carry adder, which takes benefit of carry propagation mechanism, achieves a 14.2 ns latency on an integer addition of the same length. Thus our hyptothesis in Section 4.3 is verified and the complexity we give is true.</p>

    <p class="text-gray-300">On the contrary, for extensions of degree 12 and 15, using an interpolation to compute a multiplication is not so interesting. The additional cost of the additions is huge in comparison to the saved multiplications. The interpolation method is very interesting for an extension of degree 5, because we can choose the value of interpolation such that the number of additions does not increase too much in relation with the saved multiplications. Table 7 gives the comparison of a pairing computation considering the number of multiplications and additions at different security levels.</p>

    <p class="text-gray-300">Table 7 gives our final comparison. We used our improved arithmetic for an extension of degree 5 to compute a multiplication in  <span class="math">\\mathbb{F}_{p^5}</span> . We compare our result to the complexity of the pairing computation on Barreto-Naehrig curves.</p>

    <p class="text-gray-300">Note that we have only counted the number of operations in  <span class="math">\\mathbb{F}_p</span> , but the base field has different bitsizes for each family of curves. This means that Barreto Naehrig curves still give the most efficient pairing computation for 80 and 128-bits security levels. On the other hand, for 192 and 256-bits security</p>

    <p class="text-gray-300"><strong>Table 7.</strong> A performance evaluation of the Ate pairing computation: curves with embedding degree 15 versus Barreto-Naehrig curves</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ate p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">airing</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Twisted Ate pairing</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AES security</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k=15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k=12 k=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k=12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">4830M_p + 53760A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">4300M_p + 13600A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">9880M_p + 88900A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7800M_p + 25200A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">7728M_p + 86064A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">6900M_p + 21760A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">15808M_p + 142240A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">12480M_p + 40320A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">11592M_p + 129096A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">17007M_p + 54400A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">23712M_p + 213360A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">31200M_p + 100800A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">20587M_p + 172128A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">33486M_p + 108800A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">42113M_p + 284480A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">62400M_p + 201600A_p</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">levels, pairing computation is more efficient on curves with embedding degree 15 and  <span class="math">\\rho \\sim 1.5</span>  than on Barreto-Naehrig curves (note that at these security levels the bitlength of p is shorter for k=15). We evaluated the cost of final exponentiation using the techniques proposed in [22] and our computations showed that this operation has approximatively the same cost for curves with k=15 and  <span class="math">\\rho \\sim 1.5</span>  and for Barretto-Naehrig curves at 256-bits security level (about 960  <span class="math">S_{p^{15}}</span>  for k=15 and 940  <span class="math">S_{p^{12}}</span>  for k=12). However, for lower security levels the final exponentiation will be more expensive for the case k=15 because it depends on the value of  <span class="math">\\rho \\sim 1.5</span> . Further work needs to be done to find families of curves of embedding degree 15 with better  <span class="math">\\rho</span>  value if we want to make this case interesting for lower security levels.</p>

    <p class="text-gray-300">In this paper, we give efficient pairing computation for curves of embedding degree 15. We show that existing constructions of families of curves of degree 15 and j-invariant 0 present multiple advantages. First of all, we show that pairing computation on these curves has loop length  <span class="math">\\frac{\\log r}{8}</span>  for the Ate pairing and  <span class="math">\\frac{\\log r}{2}</span>  for the twisted Ate pairing. Secondly, we show that by using twists of degree 3 we manage to perform most of the operations in  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{p^5}</span> . Moreover, denominator computation and the final inversion can be avoided by making use of twists. By using of an interpolation technique, we also improve the arithmetic of  <span class="math">\\mathbb{F}_{p^5}</span>  in order to get better results.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Recommendations for Key Management, 2007. Special Publication 800-57 Part 1.</li>
    </ol></li>
      <li><p class="text-gray-300">S. Vanstone A. Menezes, T. Okamoto. Reducing elliptic curve logarithms in a finite field. IEEE Transactions on Information Theory, 39(5):1639&ndash;1646, 1993.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Arne, T. Lange, M. Naehrig, and C. Ritzenhaler. Faster Pairing Computation, 2009. http://eprint.iacr.org/2009/155.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography SAC 2005, volume 3897 of Lecture Notes in Computer Science, pages 319 &ndash;331. Springer, 2006.</li>
    </ol></li>
      <li><p class="text-gray-300">D. Boneh and M. K. Franklin. Identity-based encryption from the Weil pairing. In Joe Kilian, editor, Advances in Cryptology - CRYPTO 2001, volume 2139 of Lecture Notes in Computer Science, pages 213&ndash;229. Springer Verlag, 2001.</p></li>
      <li><p class="text-gray-300">D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In Colin Boyd, editor, Advances in Cryptology &ndash; ASIACRYPT 2001, volume 2248 of Lecture Notes in Computer Science, pages 514&ndash;532. Springer Verlag, 2001.</p></li>
      <li><p class="text-gray-300">Sanjit Chatterjee, Palash Sarkar, and Rana Barua. Efficient computation of tate pairing in projective coordinate over general characteristic fields, 2004.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Cocks and R.G.E. Pinch. Indentity-based cryptosystems based on the Weil pairing. unplublished manuscript, 2001.</li>
    </ol></li>
      <li><p class="text-gray-300">H. Cohen and G. Frey (editors). Handbook of elliptic and hyperelliptic curve cryptography. Discrete Math. Appl., Chapman Hall/CRC, 2006.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>C. Costello, H. Hisil, J.M.G. Nieto, and K.K.H. Wong. Faster Pairings on Special Weierstrass Curves. Pairing 2009, 2009. to appear.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P. Duan, S. Cui, and C.W. Chan. Special polynomial families for generating more suitable elliptic curves for pairing-based cryptosystems. In The 5th WSEAS International Conference on Electronics, Hardware, Wireless Optimal Communications, 2005.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R. Granger, A.J. Holt, D. Page, N.P. Smart, and F. Vercauteren. Function field sieve in characteristic three. In Applied Cryptography and Network Security) 2004, volume 3076 of Lectures Notes in Computer Science, pages 223&ndash;234. Springer, 2004.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Hess. Pairing Lattices. In Steven Galbraith and Kenny Peterson, editors, Pairing 2008, volume 5209 of Lectures Notes in Computer Science, pages 18&ndash;38, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Hess, N. P. Smart, and F. Vercauteren. The Eta Pairing Revisited. IEEE Transactions on Information Theory, 52:4595&ndash;4602, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. Joux. A one round protocol for tripartite Diffie-Hellman. Journal of Cryptology, 17(4):263&ndash;276, September 2004.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Neal Koblitz and Alfred Menezes. Pairing-based cryptography at high security levels. In Nigel P. Smart, editor, IMA Int. Conf., volume 3796 of Lectures Notes in Computer Science, pages 13&ndash;36, 2005.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>R. Lidl and H. Niederreiter. Finite Fields. 2nd ed., Cambridge University Press, 1997.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>X. Lin, C. Zhao, F. Zhang, and Y. Wang. Computing the Ate Pairing on Elliptic Curves with Embedding Degree k = 9. IEICE Transactions, 91-A(9):2387&ndash;2393, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Seiichi Matsuda, Naoki Kanayama, Florian Hess, and Eiji Okamoto. Optimised versions of the ate and twisted ate pairings. In the Eleventh IMA International Conference on Cryptography and Coding, pages 302&ndash;312. Springer-Verlag, 2007.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Victor S. Miller. The Weil pairing, and its efficient calculation. Journal of Cryptology, 17(4):235&ndash;261, September 2004.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S. Paulus. Lattice basis reduction in function fields. In Joe Buhler, editor, ANTS III, volume 1423 of Lectures Notes in Computer Science, pages 567&ndash;575, 1998.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Scott, N. Benger, M. Charlemagne, L.J.D. Perez, and E.J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. to appear in Pairing 2009, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Frederik Vercauteren. Optimal Pairings, 2008. http://eprint.iacr.org/2008/096.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Andr&acute;e Weil. Courbes alg&acute;ebriques et vari&acute;et&acute;es ab&acute;eliennes (in french. Hermann, 1948.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Von ZurGathen and J. Gerhard. Modern Computer Algebra. Cambridge University Press, New York, NY, USA, 2003.</li>
    </ol></li>
    </ul>

    </section>
`;
---

<BaseLayout title="A study of pairing computation for elliptic curves with embe... (2009/370)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2009 &middot; eprint 2009/370
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-study-of-pairing-computation-for-curves-with-embedding-2009" />
  </article>
</BaseLayout>
