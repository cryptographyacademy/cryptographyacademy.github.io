---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/370';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Nova: Recursive Zero-Knowledge Arguments from Folding Schemes';
const AUTHORS_HTML = 'Abhiram Kothapalli, Srinath Setty, Ioanna Tzialla';

const CONTENT = `    <p class="text-gray-300">Abhiram Kothapalli† Srinath Setty<em> Ioanna Tzialla‡ †Carnegie Mellon University </em>Microsoft Research ‡New York University</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Abstract. We introduce a new approach to realize incrementally verifiable computation (IVC), in which the prover recursively proves the correct execution of incremental computations of the form <span class="math">y = F^{(\\ell)}(x)</span>, where <span class="math">F</span> is a (potentially non-deterministic) computation, <span class="math">x</span> is the input, <span class="math">y</span> is the output, and <span class="math">\\ell &amp;gt; 0</span>. Unlike prior approaches to realize IVC, our approach avoids succinct non-interactive arguments of knowledge (SNARKs) entirely and arguments of knowledge in general. Instead, we introduce and employ <em>folding schemes</em>, a weaker, simpler, and more efficiently-realizable primitive, which reduces the task of checking two instances in some relation to the task of checking a single instance. We construct a folding scheme for a characterization of NP and show that it implies an IVC scheme with improved efficiency characteristics: (1) the "recursion overhead" (i.e., the number of steps that the prover proves in addition to proving the execution of <span class="math">F</span>) is a constant and it is dominated by two group scalar multiplications expressed as a circuit (this is the smallest recursion overhead in the literature), and (2) the prover's work at each step is dominated by two multiexponentiations of size $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, providing the fastest prover in the literature. The size of a proof is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> group elements, but we show that using a variant of an existing zkSNARK, the prover can prove the knowledge of a valid proof succinctly and in zero-knowledge with </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ group elements. Finally, our approach neither requires a trusted setup nor FFTs, so it can be instantiated efficiently with any cycles of elliptic curves where DLOG is hard.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We revisit the problem of realizing <em>incrementally-verifiable computation (IVC)</em> [47]: a cryptographic primitive that enables producing proofs of correct execution of "long running" computations such that a verifier can efficiently verify the correct execution of any prefix of the computation. IVC enables a wide variety of applications including verifiable delay functions [10, 50], succinct blockchains [14, 34], and incrementally-verifiable versions of verifiable state machines [36, 42].</p>

    <p class="text-gray-300">A well-known approach to construct IVC is to use succinct non-interactive arguments of knowledge (SNARKs) for NP [26, 27, 33, 39]: at each incremental step <span class="math">i</span>, the prover produces a SNARK proving that it has applied <span class="math">F</span> correctly to the output of step <span class="math">i - 1</span> and that the SNARK verifier <em>represented as a circuit</em> has accepted the SNARK from step <span class="math">i - 1</span> [7, 9]. However, it is well-known that</p>

    <p class="text-gray-300">this approach is impractical <em>[7, 21]</em>. Alternatively, one can use SNARKs without trusted setup <em>[19, 23, 41, 44]</em> but their verifiers are more expensive than those of SNARKs with trusted setup, both asymptotically and concretely. Recent works <em>[11, 13, 17, 18]</em> aim to address the inefficiency of SNARK-based IVC, with an innovative approach: at each step, the verifier circuit “defers” expensive steps in verifying a SNARK for NP instances (e.g., verifying polynomial evaluation proofs) by accumulating those steps into a single instance that is later checked efficiently. However, these works still require the prover to produce a SNARK at each step and the verifier circuit to partially verify that SNARK.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We introduce a new approach that avoids SNARKs (and more generally arguments of knowledge) entirely and relies purely on deferral to realize IVC. In a nutshell, instead of accumulating expensive steps of verifying a SNARK for NP instances, the verifier circuit in our approach accumulates the NP instances themselves. We formalize this technique as a new and minimal primitive, which we refer to as a <em>folding scheme</em>. A folding scheme is weaker, simpler, and far more efficient compared to arguments of knowledge including SNARKs. Indeed, realizing IVC via folding schemes results in improved efficiency over prior work (Figure 2): (1) the verifier circuit is constant-sized and its size is dominated by two group scalar multiplications; this is the smallest verifier circuit in the literature (in the context of recursive proof composition); and (2) the prover’s work at each step is dominated by two multiexponentiations of size $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, providing the fastest prover in the literature, both asymptotically and concretely. Section 1.4 provides a detailed comparison between our approach and prior work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Folding Schemes</h3>

    <p class="text-gray-300">A folding scheme is defined with respect to an NP relation, and it is a protocol between an untrusted <em>prover</em> and a <em>verifier</em>. Both entities hold two <span class="math">N</span>-sized NP instances, and the prover in addition holds purported witnesses for both instances. The protocol enables the prover and the verifier to output a single <span class="math">N</span>-sized NP instance, which we refer to as a <em>folded instance</em>. Furthermore, the prover privately outputs a purported witness to the folded instance using purported witnesses for the original instances. Informally, a folding scheme guarantees that the folded instance is satisfiable only if the original instances are satisfiable. A folding scheme is said to be <em>non-trivial</em> if the verifier’s costs and the communication are lower in the case where the verifier participates in the folding scheme and then verifies a purported NP witness for the folded instance than the case where the verifier verifies purported NP witnesses for each of the original instances.</p>

    <p class="text-gray-300">Several existing techniques exhibit the two-to-one reduction pattern of folding schemes. Examples include the sumcheck protocol <em>[38]</em> and the split-and-fold techniques in inner product arguments <em>[12]</em>. Appendix A provides further details.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Remark 1 (Folding Schemes vs. SNARKs)</h6>

    <p class="text-gray-300">SNARKs for NP <em>[8, 26, 27, 33, 39]</em> trivially imply a folding scheme for NP: given two NP instances <span class="math">u_{1}</span> and <span class="math">u_{2}</span> and the corresponding witnesses, the prover proves <span class="math">u_{1}</span> by producing a SNARK. The verifier checks that SNARK and then sets <span class="math">u_{2}</span> to be the folded instance. However,</p>

    <p class="text-gray-300">we construct a folding scheme for NP without relying on SNARKs (or more generally arguments of knowledge). Specifically, our folding scheme is weaker than any argument of knowledge (succinct or otherwise) because it merely <em>reduces</em> the satisfiability of two NP instances to the satisfiability of a single NP instance.</p>

    <p class="text-gray-300">To design a folding scheme for NP, we start with a popular NP-complete language that generalizes arithmetic circuit satisfiability: R1CS (Definition 10). As we illustrate later, it is difficult to devise a folding scheme for R1CS. To address this, we introduce a variant of R1CS, called <em>relaxed R1CS</em>, which, like R1CS, not only characterizes NP, but, unlike R1CS, can support a folding scheme. The following theorem captures the cryptographic and efficiency characteristics of our folding scheme for relaxed R1CS.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">There exists a constant-round, public-coin, zero-knowledge folding scheme for relaxed R1CS where for <span class="math">N</span>-sized relaxed R1CS instances over a finite field <span class="math">\\mathbb{F}</span> with the same “structure” (i.e., R1CS coefficient matrices), the prover’s work is <span class="math">O_{\\lambda}(N)</span>, and the verifier’s work and the communication are both <span class="math">O_{\\lambda}(1)</span>, assuming the existence of any additively-homomorphic commitment scheme that provides <span class="math">O_{\\lambda}(1)</span>-sized commitments to <span class="math">N</span>-sized vectors over <span class="math">\\mathbb{F}</span> (e.g., Pedersen’s commitments), where <span class="math">\\lambda</span> is the security parameter.</p>

    <p class="text-gray-300">Because our folding scheme is public coin, it can be made non-interactive in the random oracle model using the Fiat-Shamir transform <em>[25]</em>, and be instantiated (heuristically) in the standard model using a concrete hash function. We rely on such a non-interactive folding scheme to construct IVC.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 IVC from Non-Interactive Folding Schemes</h3>

    <p class="text-gray-300">We show how to realize IVC using a non-interactive version of our folding scheme for relaxed R1CS. We refer to our construction as Nova.</p>

    <p class="text-gray-300">Recall that an IVC is an argument of knowledge <em>[33, 39]</em> for incremental computations of the form <span class="math">y=F^{(\\ell)}(x)</span>, where <span class="math">F</span> is a (possibly non-deterministic) computation, <span class="math">\\ell&gt;0</span>, <span class="math">x</span> is a public input, and <span class="math">y</span> is the public output. At each incremental step, the IVC prover produces a proof that the step was computed correctly <em>and</em> it has verified a proof for the prior step. In other words, at each incremental step, the IVC prover produces a proof of satisfiability for an augmented circuit that augments the circuit for <span class="math">F</span> with a “verifier circuit” that verifies the proof of the prior step. Recursively, the final proof proves the correctness of the entire incremental computation. A key aspect of IVC is that neither the IVC verifier’s work nor the IVC proof size depends on the number of</p>

    <p class="text-gray-300">steps in the incremental computation. In particular, the IVC verifier only verifies the proof produced at the last step of the incremental computation.</p>

    <p class="text-gray-300">In Nova, we consider incremental computations, where each step of the incremental computation is expressed with R1CS (all the steps in the incremental computation share the same R1CS coefficient matrices). At step <span class="math">i</span> of the incremental computation, as in other approaches to IVC, Nova’s prover proves that the step <span class="math">i</span> was computed correctly. Furthermore, at step <span class="math">i</span>, instead of verifying a proof for step <span class="math">i-1</span> (as in traditional approaches to IVC), Nova’s approach treats the computation at step <span class="math">i-1</span> as an R1CS instance and folds that into a running relaxed R1CS instance. Specifically, at each step, Nova’s prover proves that it has performed the step’s computation and has folded its prior step represented as an R1CS instance into a running relaxed R1CS instance. In other words, the circuit satisfiability instance that the prover proves at each incremental step computes a step of the incremental computation and includes a circuit for the computation of the verifier in the non-interactive folding scheme for relaxed R1CS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A distinctive aspect of Nova’s approach to IVC is that it achieves the smallest “verifier circuit” in the literature. Since the verifier’s costs in the non-interactive version of the folding scheme for relaxed R1CS is <span class="math">O_{\\lambda}(1)</span>, the size of the computation that Nova’s prover proves at each incremental step is $\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, assuming </span>N<span class="math">-sized vectors are committed with an </span>O_{\\lambda}(1)<span class="math">-sized commitments (e.g., Pedersen’s commitments). In particular, the verifier circuit in Nova is constant-sized and its size is dominated by two <em>group scalar multiplications</em>. Furthermore, Nova’s prover’s work at each step is dominated by two multiexponentiations of size </span>\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Note that Nova’s prover does not perform any FFTs, so it can be instantiated efficiently using <em>any</em> cycles of elliptic curves where DLOG is hard.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With the description thus far, the size of an IVC proof (which is a purported witness for the running relaxed R1CS instance) is $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Instead of sending such a proof to a verifier, at any point in the incremental computation, Nova’s prover can prove the knowledge of a satisfying witness to the running relaxed R1CS instance in zero-knowledge with an </span>O_{\\lambda}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$-sized succinct proof using a zkSNARK that we design by adapting Spartan <em>[41]</em>. The following theorem summarizes our key result.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">For any incremental function where each step of the incremental function applies a (non-deterministic) function <span class="math">F</span>, there exists an IVC scheme with the following efficiency characteristics, assuming <span class="math">N</span>-sized vectors are committed with an <span class="math">O_{\\lambda}(1)</span>-sized commitments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- IVC proof sizes are $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the verifier’s work to verify them is </span>O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The prover’s work at each incremental step is </span>\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Specifically, the prover’s work at each step is dominated by two multiexponentiations of size </span>\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1.3 Implementation and Performance Evaluation</p>

    <p class="text-gray-300">We implement Nova as a library in about 6,000 lines of Rust <em>[3]</em>. The library is generic over a cycle of elliptic curves and a hash function (used internally as the random oracle). The library provides candidate implementations with the Pasta cycle of elliptic curves <em>[4]</em> and Poseidon <em>[2, 29]</em>. For the former, Nova relies on pasta-msm <em>[5]</em>, a high-performance library for computing multiexpoentiations over the Pasta cycle of curves. Finally, the library accepts <span class="math">F</span> (i.e., a step of the incremental computation) as a bellperson gadget <em>[1]</em>.</p>

    <p class="text-gray-300">Recursion Overheads. We measure the size of Nova’s verifier circuit, as it determines the recursion overhead: the number of additional constraints that the prover must prove at each incremental step besides proving an invocation of <span class="math">F</span>.</p>

    <p class="text-gray-300">We find that Nova’s verifier circuit is <span class="math">\\approx</span>10,000 R1CS constraints. This is the smallest verifier circuit in the literature and hence Nova incurs the lowest recursion overhead. Specifically, Nova’s recursion overhead is <span class="math">&gt;10\\times</span> lower than in SNARK-based IVC <em>[7]</em> with state-of-the-art per-circuit trusted setup SNARK <em>[30]</em>, and over <span class="math">100\\times</span> smaller than with a SNARK without trusted setup <em>[23]</em>. Compared to recent works, Nova’s recursion overhead is over <span class="math">13\\times</span> lower than Halo’s <em>[13]</em>, and over <span class="math">4\\times</span> lower than the scheme of Bünz et al. <em>[17]</em>.</p>

    <p class="text-gray-300">Performance of Nova. We experiment with Nova on an Azure Standard F32s_v2 VM (16 physical CPUs, 2.70 GHz Intel(R) Xeon(R) Platinum 8168, and 64 GB memory). In our experiments, we vary the number of constraints in <span class="math">F</span>. Our performance metrics are: the prover time, the verifier time, and proof sizes. We measure these for Nova’s IVC scheme as well as its Spartan-based zkSNARK to compress IVC proofs. Figure 1 depicts our results, and we find the following.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The prover’s per-step cost to produce an IVC proof and compress it scale sub-linearly with the size of <span class="math">F</span> (since the cost is dominated by two multiexponentiations, which scale sub-linearly due to the Pippenger algorithm and parallelize better at larger sizes). When $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{20}<span class="math"> constraints, the prover’s per-step cost to produce an IVC proof is </span>\\approx<span class="math">1</span>\\mu<span class="math">s/constraint. For the same </span>F<span class="math">, the cost to produce a compressed IVC proof is </span>\\approx<span class="math">24</span>\\mu$s/constraint.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifying a compressed proof is only <span class="math">\\approx</span>2<span class="math">\\times</span> higher costs than verifying a significantly longer IVC proof.</li>

    </ul>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.4 A More Detailed Comparison with Prior Work</h3>

    <p class="text-gray-300">Figure 2 compares Nova with prior approaches. Nova’s approach can be viewed as taking Halo’s approach to the extreme. Specifically:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> IVC Scheme (per step)</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> A zkSNARK of a Valid IVC Proof</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 1: Performance of Nova as a function of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . See the text for details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- At each incremental step, Halo's verifier circuit verifies a "partial" SNARK. This still requires Halo's prover to perform  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> -sized FFTs and  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  exponentiations (i.e., not an  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> -sized multiexponentiation). Whereas, in Nova, the verifier circuit folds an entire NP instance representing computation at the prior step into a running relaxed R1CS instance. This only requires Nova&#x27;s prover to commit to a satisfying assignment of an  </span>\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> -sized circuit (which computes  </span>F<span class="math">  and performs the verifier&#x27;s computation in a folding scheme for relaxed R1CS), so at each step, Nova&#x27;s prover only computes an  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ -sized multiexponentiation and does not compute any FFTs. So, Nova's prover incurs lower costs than Halo's prover, both asymptotically and concretely.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Halo and Nova have the same proof sizes  $O_{\\lambda}(\\log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math">  and verifier time  </span>O_{\\lambda}(</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Bünz et al. [18] apply Halo's approach to other polynomial commitment schemes. Halo Infinite [11] generalizes the approach in Halo [13] to any homomorphic polynomial commitment scheme; they also obtain PCD (and hence IVC) even when polynomial commitment schemes do not satisfy succinctness.</p>

    <p class="text-gray-300">Bünz et al. [17] propose a variant of the approach in Halo, where they realize PCD (and hence IVC) without relying on succinct arguments. Specifically, they first devise a non-interactive argument of knowledge (NARK) for R1CS with  <span class="math">O_{\\lambda}(N)</span> -sized proofs and  <span class="math">O_{\\lambda}(N)</span>  verification times for  <span class="math">N</span> -sized R1CS instances. Then, they show that most of the NARK's verifier's computation can be deferred by performing  <span class="math">O_{\\lambda}(1)</span>  work in the verifier circuit. For zero-knowledge, Nova relies on zero-knowledge arguments with succinct proofs, whereas their approach does not rely on succinct arguments. However, Nova's approach has several conceptual and efficiency advantages over the work of Bünz et al [17]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Nova introduces a new primitive called a folding scheme, which is conceptually simpler and is easier to realize than prior notions such as (split) accumulation schemes used in prior work [17, 18]. Furthermore, a folding scheme for NP directly leads to IVC and is again easier to analyze than with prior notions.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- At each step, their prover performs an  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -sized FFT (which costs  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  operations over  </span>\\mathbb{F}$ ). Whereas, Nova does not perform any FFTs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Their prover's work for multiexponentitions at each step and the size of their verifier circuit are both higher than in Nova by  <span class="math">\\approx 4\\times</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">“Verifier circuit” (dominant ops)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover (each step)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumptions</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BCTV14 [7] with [30]†</td>

            <td class="px-3 py-2 border-b border-gray-700">3 P</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) FFT O(C) MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">q-type</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan [41]-based IVC</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√C) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(√C)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(√C)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG, RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractal [23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log2C) F O(log2C) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) FFT O(C) MHT</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Halo [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log C) G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) FFT O(C) EXP</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG, RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BCLMS [17]*</td>

            <td class="px-3 py-2 border-b border-gray-700">8 G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) FFT O(C) MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG, RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">DLOG, RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G_T</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C) MSM</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">SXDH, RO</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\dagger</span>  Requires per-circuit trusted setup and is undesirable in practice <span class="math">O(C)</span>  FFT: FFT over an  <span class="math">O(C)</span> -sized vector costing  <span class="math">O(C \\log C)</span>  operations over  <span class="math">\\mathbb{F}</span> <span class="math">O(C)</span>  MHT: Merkle tree over an  <span class="math">O(C)</span> -sized vector costing  <span class="math">O(C)</span>  hash computations <span class="math">O(C)</span>  EXP:  <span class="math">O(C)</span>  exponentiations in a cryptographic group <span class="math">O(C)</span>  MSM:  <span class="math">O(C)</span> -sized multi-exponentiation in a cryptographic group</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 2: Asymptotic costs of Nova and its baselines to produce and verify a proof for an incremental computation where each incremental step applies a function  <span class="math">F</span> .  <span class="math">C</span>  denotes the size of the computation at each incremental step, i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{V}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , where  </span>\\mathcal{C}_{\\mathcal{V}}<span class="math">  is the &quot;verifier circuit&quot; in IVC. The &quot;verifier circuit&quot; column depicts the number of dominant operations in  </span>\\mathcal{C}_{\\mathcal{V}}<span class="math"> , where  </span>\\mathbb{P}<span class="math">  denotes a pairing in a pairing-friendly group,  </span>\\mathbb{F}<span class="math">  denotes the number of finite field operations,  </span>\\mathbb{H}<span class="math">  denotes a hash computation, and  </span>\\mathbb{G}<span class="math">  denotes a scalar multiplication in a cryptographic group. The prover column depicts the cost to the prover for each step of the incremental computation, and proof sizes and verifier times refer respectively to the size of the proof of the incremental computation and the associated verification times. For Nova&#x27;s proof sizes and verification times, we depict the compressed proof sizes (otherwise, they are  </span>O_{\\lambda}(C)<span class="math"> ) and the time to verify a compressed proof (otherwise, they are  </span>O_{\\lambda}(C)$ ). Rows with RO require heuristically instantiating the random oracle with a concrete hash function in the standard model.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof sizes are  $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  in their work, whereas in Nova, they are  </span>O_{\\lambda}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ . We believe, in theory, they can also compress their proofs, using a succinct argument, but unlike Nova, they do not specify how to do so in a concretely efficient manner. Furthermore, using succinct arguments is inconsistent with their goal of not employing them.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Concurrent work. In an update concurrent with this work, Bunz et al. [17] provide an improved construction of their NARK for R1CS, which leads to an IVC that, like Nova, avoids FFTs. Furthermore, they improve the size of the verifier circuit by  <span class="math">\\approx 2\\times</span> , which is still larger than Nova's verifier circuit by  <span class="math">\\approx 2\\times</span> . The per-step computation of the prover remains  <span class="math">4\\times</span>  higher than Nova.</p>

    <p class="text-gray-300">Section 2 provides the necessary background. Section 3 formally defines folding schemes and their properties. In Section 4, we introduce a variant of R1CS</p>

    <p class="text-gray-300">called relaxed R1CS for which we provide a folding scheme satisfying Theorem 1. Then, in Section 5, we use a non-interactive version of the folding scheme (§4.2) to construct an IVC scheme and a scheme to compress IVC proofs satisfying Theorem 2 by assuming the existence of a zkSNARK for relaxed R1CS with logarithmic-sized proofs. Finally, in Section 6, we construct such a zkSNARK.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> denote a finite field with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\Theta(\\lambda)}<span class="math">, where </span>\\lambda<span class="math"> is the security parameter. Let </span>\\cong$ denote computational indistinguishability with respect to a PPT adversary. We globally assume that generator algorithms that produce public parameters are additionally provided appropriate size bounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 A Commitment Scheme for Vectors over <span class="math">\\mathbb{F}</span></h3>

    <p class="text-gray-300">We require a commitment scheme for vectors over <span class="math">\\mathbb{F}</span> that is additively homomorphic and succinct. We formally define these two properties and others noted below in Appendix F. Below, we define the syntax for commitment schemes.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1 (A Commitment Scheme for Vectors).</h6>

    <p class="text-gray-300">A commitment scheme for <span class="math">\\mathbb{F}^{m}</span> is a tuple of three protocols with the following interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{\\lambda},m)\\to\\mathsf{pp}</span>: takes length parameter <span class="math">m</span>; produces public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathsf{Com}(\\mathsf{pp},v,r)\\to C</span>: takes vector <span class="math">v\\in\\mathbb{F}^{m}</span> and <span class="math">r\\in\\mathbb{F}</span>; produces commitment <span class="math">C</span>.</li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{pp},C,v,r)\\to\\{0,1\\}</span>: verifies the opening of commitment <span class="math">C</span> to <span class="math">v\\in\\mathbb{F}^{m}</span>.</li>

    </ul>

    <p class="text-gray-300">A commitment scheme satisfies hiding (the commitment reveals no information), binding (a PPT adversary cannot open a commitment to two different values), and succinctness (the commitment size is logarithmic in the opening size).</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.2 Non-Interactive Arguments of Knowledge</h3>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2 (Non-Interactive Argument of Knowledge).</h6>

    <p class="text-gray-300">Consider a relation <span class="math">\\mathcal{R}</span> over public parameters, structure, instance, and witness tuples. A non-interactive argument of knowledge for <span class="math">\\mathcal{R}</span> consists of PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic <span class="math">\\mathcal{K}</span>, denoting the generator, the prover, the verifier and the encoder respectively with the following interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})\\to\\mathsf{pp}</span>: On input security parameter <span class="math">\\lambda</span>, samples public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s})\\to(\\mathsf{pk},\\mathsf{vk})</span>: On input structure <span class="math">\\mathsf{s}</span>, representing common structure among instances, outputs the prover key <span class="math">\\mathsf{pk}</span> and verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},u,w)\\to\\pi</span>: On input instance <span class="math">u</span> and witness <span class="math">w</span>, outputs a proof <span class="math">\\pi</span> proving that <span class="math">(\\mathsf{pp},\\mathsf{s},u,w)\\in\\mathcal{R}</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},u,\\pi)\\to\\{0,1\\}</span>: Checks instance <span class="math">u</span> given proof <span class="math">\\pi</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">An argument of knowledge satisfies completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} (\\mathsf {v k}, u, \\pi) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\pi \\leftarrow \\mathcal {P} (\\mathsf {p k}, u, w) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">An argument of knowledge satisfies knowledge soundness if for all PPT adversaries  <span class="math">\\mathcal{A}</span>  there exists a PPT extractor  <span class="math">\\mathcal{E}</span>  such that for all randomness  <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\mathcal {V} (\\mathsf {v k}, u, \\pi) = 1, \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\notin \\mathcal {R} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, u, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {p p}; \\rho), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ w \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\rho) \\end{array} \\right. \\right] = \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 3 (Zero-Knowledge). An argument of knowledge  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  for relation  <span class="math">\\mathcal{R}</span>  satisfies zero-knowledge if there exists PPT simulator  <span class="math">\\mathcal{S}</span>  such that for all PPT adversaries  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{c} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\pi \\leftarrow \\mathcal {P} (\\mathsf {p k}, u, w) \\end{array} \\right. \\end{array} \\right\\} \\cong \\left\\{ \\begin{array}{c} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {p p}, \\mathsf {s}, u, \\pi) \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf {p p}, \\tau) \\leftarrow \\mathcal {S} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\pi \\leftarrow \\mathcal {S} (\\mathsf {p p}, u, \\tau) \\end{array} \\right. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 4 (Succinctness). A non-interactive argument system is succinct if the size of the proof  <span class="math">\\pi</span>  is polylogarithmic in the size of the witness  <span class="math">w</span> .</p>

    <h2 id="sec-15" class="text-2xl font-bold">2.3 Incrementally Verifiable Computation</h2>

    <p class="text-gray-300">Incrementally verifiable computation (IVC) [47] enables verifiable computation for repeated function application. Intuitively, for a function  <span class="math">F</span> , with initial input  <span class="math">z_0</span> , an IVC scheme allows a prover to produce a proof  <span class="math">\\Pi_i</span>  for the statement  <span class="math">z_i = F^{(i)}(z_0)</span>  (i.e.,  <span class="math">i</span>  applications of  <span class="math">F</span>  on input  <span class="math">z_0</span> ) given a proof  <span class="math">\\Pi_{i-1}</span>  for the statement  <span class="math">z_{i-1} = F^{(i-1)}(z_0)</span> . Formally, IVC schemes additionally permit  <span class="math">F</span>  to take auxiliary input  <span class="math">\\omega</span> . We recall the definition of IVC using notational conventions of modern argument systems.</p>

    <p class="text-gray-300">Definition 5 (IVC). An incrementally verifiable computation (IVC) scheme is defined by PPT algorithms  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  and deterministic  <span class="math">\\kappa</span>  denoting the generator, the prover, the verifier, and the encoder respectively. An IVC scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  satisfies perfect completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} (\\mathsf {v k}, i, z _ {0}, z _ {i}, \\Pi_ {i}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ F, (i, z _ {0}, z _ {i}, z _ {i - 1}, \\omega_ {i - 1}, \\Pi_ {i - 1}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, F), \\\\ z _ {i} = F (z _ {i - 1}, \\omega_ {i - 1}), \\\\ \\mathcal {V} (\\mathsf {v k}, i - 1, z _ {0}, z _ {i - 1}, \\Pi_ {i - 1}) = 1, \\\\ \\Pi_ {i} \\leftarrow \\mathcal {P} (\\mathsf {p k}, i, z _ {0}, z _ {i}; z _ {i - 1}, \\omega_ {i - 1}, \\Pi_ {i - 1}) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">F</span> is a polynomial time computable function. Likewise, an IVC scheme satisfies knowledge soundness if for any constant <span class="math">n \\in \\mathbb{N}</span>, and for all expected polynomial time adversaries <span class="math">\\mathcal{P}^*</span>, there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{\\mathsf{r}} \\left[ \\begin{array}{l} z_n = z \\text{ where} \\\\ z_{i+1} \\leftarrow F(z_i, \\omega_i) \\\\ \\forall i \\in \\{0, \\ldots, n-1\\} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^{\\lambda}), \\\\ (F, (z_0, z), \\Pi) \\leftarrow \\mathcal{P}^*(\\mathsf{pp}, \\mathsf{r}), \\\\ (\\omega_0, \\ldots, \\omega_{n-1}) \\leftarrow \\mathcal{E}(\\mathsf{pp}, \\mathsf{r}) \\end{array} \\right] \\approx</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\mathsf{r}} \\left[ \\mathcal{V}(\\mathsf{vk}, (n, z_0, z), \\Pi) = 1 \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(1^{\\lambda}), \\\\ (F, (z_0, z), \\Pi) \\leftarrow \\mathcal{P}^*(\\mathsf{pp}, \\mathsf{r}), \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, F) \\end{array} \\right]</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{r}</span> denotes an arbitrarily long random tape.</p>

    <p class="text-gray-300">An IVC scheme satisfies succinctness if the size of the IVC proof <span class="math">\\Pi</span> does not grow with the number of applications <span class="math">n</span>.</p>

    <p class="text-gray-300">We note that in the definition above, the number of steps <span class="math">n</span> is treated as a fixed environment variable that characterizes the extractor. This model is required for all known general recursive techniques as they rely on recursive extractors that blowup polynomially for each additional recursive step [11, 14, 17, 23]. Bitansky et al. [9] avoid such a restriction by making non-blackbox assumptions about the extractors runtime with respect to that of the malicious prover. In any case, there are no known attacks on arbitrary depth recursion.</p>

    <p class="text-gray-300">This section formally defines folding schemes. Intuitively, a folding scheme for a relation <span class="math">\\mathcal{R}</span> is a protocol that reduces the task of checking two instances in <span class="math">\\mathcal{R}</span> to the task of checking a single instance in <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300"><strong>Definition 6 (Folding Scheme).</strong> Consider a relation <span class="math">\\mathcal{R}</span> over public parameters, structure, instance, and witness tuples. A folding scheme for <span class="math">\\mathcal{R}</span> consists of a PPT generator algorithm <span class="math">\\mathcal{G}</span>, a deterministic encoder algorithm <span class="math">\\mathcal{K}</span>, and a pair of PPT algorithms <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> denoting the prover and verifier respectively, with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda}) \\to \\mathsf{pp}</span>: On input security parameter <span class="math">\\lambda</span>, samples public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp}, \\mathsf{s}) \\to (\\mathsf{pk}, \\mathsf{vk})</span>: On input <span class="math">\\mathsf{pp}</span>, and a common structure <span class="math">\\mathsf{s}</span> between instances to be folded, outputs a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk}, (u_1, w_1), (u_2, w_2)) \\to (u, w)</span>: On input instance-witness tuples <span class="math">(u_1, w_1)</span> and <span class="math">(u_2, w_2)</span> outputs a new instance-witness tuple <span class="math">(u, w)</span> of the same size.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk}, u_1, u_2) \\to u</span>: On input instances <span class="math">u_1</span> and <span class="math">u_2</span>, outputs a new instance <span class="math">u</span>.</li>

    </ul>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">(u, w) \\leftarrow \\langle \\mathcal{P}(\\mathsf{pk}, w_1, w_2), \\mathcal{V}(\\mathsf{vk}) \\rangle (u_1, u_2)</span></div>

    <p class="text-gray-300">denote the verifier's output instance  <span class="math">u</span>  and the prover's output witness  <span class="math">w</span>  from the interaction of  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  on witnesses  <span class="math">(w_1, w_2)</span> , prover key  <span class="math">\\mathsf{pk}</span> , verifier key  <span class="math">\\mathsf{vk}</span>  and instances  <span class="math">(u_1, u_2)</span> . Likewise, let</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {t r} = \\langle \\mathcal {P} (\\mathrm {p k}, w _ {1}, w _ {2}), \\mathcal {V} (\\mathrm {v k}) \\rangle (u _ {1}, u _ {2})</span></div>

    <p class="text-gray-300">denote the corresponding interaction transcript. A folding scheme satisfies perfect completeness if for all PPT adversaries  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u _ {1}, w _ {1}), (u _ {2}, w _ {2})) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}), (\\mathsf {p p}, \\mathsf {s}, u _ {2}, w _ {2}) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ (u, w) \\leftarrow \\langle \\mathcal {P} (\\mathsf {p k}, w _ {1}, w _ {2}), \\mathcal {V} (\\mathsf {v k}) \\rangle (u _ {1}, u _ {2}) \\end{array} \\right. \\right] = 1. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">A folding scheme satisfies knowledge soundness if for any expected polynomial-time adversary  <span class="math">\\mathcal{P}^*</span>  there is an expected polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R}, \\\\ (\\mathsf {p p}, \\mathsf {s}, u _ {2}, w _ {2}) \\in \\mathcal {R} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u _ {1}, u _ {2})) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {p p}, \\rho), \\\\ (w _ {1}, w _ {2}) \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\rho) \\end{array} \\right. \\right] \\geq \\\\ \\Pr \\left[ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u _ {1}, u _ {2})) \\leftarrow \\mathcal {P} ^ {<em>} (\\mathsf {p p}, \\rho), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ (u, w) \\leftarrow \\langle \\mathcal {P} ^ {</em>} (\\mathsf {p k}, \\rho), \\mathcal {V} (\\mathsf {v k}) \\rangle (u _ {1}, u _ {2}) \\end{array} \\right. \\right] - \\mathsf {n e g l} (\\lambda) \\right. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\rho</span>  denotes arbitrary input randomness for  <span class="math">\\mathcal{P}^*</span> . We call a transcript an accepting transcript if  <span class="math">\\mathcal{P}</span>  outputs a satisfying folded witness  <span class="math">w</span>  for the folded instance  <span class="math">u</span> . We consider a folding scheme non-trivial if the communication costs and  <span class="math">\\mathcal{V}</span> 's computation are lower in the case where  <span class="math">\\mathcal{V}</span>  participates in the folding scheme and then checks a witness sent by  <span class="math">\\mathcal{P}</span>  for the folded instance than the case where  <span class="math">\\mathcal{V}</span>  checks witnesses sent by  <span class="math">\\mathcal{P}</span>  for each of the original instances.</p>

    <p class="text-gray-300">Definition 7 (Non-Interactive). A folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is non-interactive if the interaction between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  consists of a single message from  <span class="math">\\mathcal{P}</span>  to  <span class="math">\\mathcal{V}</span> . This single message is denoted as an output of  <span class="math">\\mathcal{P}</span> , and an input to  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">Definition 8 (Zero-Knowledge). A folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  satisfies zero-knowledge for relation  <span class="math">\\mathcal{R}</span>  if there exists a PPT simulator  <span class="math">\\mathcal{S}</span>  such that for all PPT</p>

    <p class="text-gray-300">adversaries <span class="math">\\mathcal{A}</span>, and <span class="math">\\mathcal{V}^*</span>, and input randomness <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ \\mathsf {t r} \\left(\\mathsf {s}, (u _ {1}, w _ {1}), (u _ {2}, w _ {2})\\right) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}), (\\mathsf {p p}, \\mathsf {s}, u _ {2}, w _ {2}) \\in \\mathcal {R}, \\\\ \\mathsf {t r} = \\langle \\mathcal {P} (\\mathsf {p k}, w _ {1}, w _ {2}), \\mathcal {V} ^ {*} (\\mathsf {v k}, \\rho) \\rangle (u _ {1}, u _ {2}) \\end{array} \\right\\} \\cong \\\\ \\left\\{ \\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ \\mathsf {t r} \\left(\\mathsf {s}, (u _ {1}, w _ {1}), (u _ {2}, w _ {2})\\right) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}), (\\mathsf {p p}, \\mathsf {s}, u _ {2}, w _ {2}) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\mathsf {t r} \\leftarrow \\mathcal {S} ^ {\\mathcal {V} ^ {*} (\\mathsf {v k}, \\rho)} (\\mathsf {p k}, u _ {1}, u _ {2}) \\end{array} \\right. \\end{array} \\right.</span></div>

    <p class="text-gray-300"><strong>Definition 9 (Public Coin).</strong> A folding scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> is called public coin if all the messages sent from <span class="math">\\mathcal{V}</span> to <span class="math">\\mathcal{P}</span> are sampled from a uniform distribution.</p>

    <p class="text-gray-300">Typically, knowledge soundness is difficult to prove directly. To assist these proofs, prior works employ the forking lemma [12], which abstracts away much of the probabilistic reasoning. The original forking lemma shows that to prove knowledge soundness it is sufficient to construct a PPT extractor that takes as input a "tree" of accepting transcripts and outputs a satisfying witness. However, in our setting, this extractor must additionally take as input the prover's output (i.e., the folded instance and witness) for each of these transcripts, which contains information needed to reconstruct the original witness. So, we introduce a small variant of the forking lemma that captures this modification.</p>

    <p class="text-gray-300"><strong>Lemma 1 (Forking Lemma for Folding Schemes).</strong> Consider a <span class="math">(2\\mu + 1)</span>-move folding scheme <span class="math">\\Pi = (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span>. <span class="math">\\Pi</span> satisfies knowledge soundness if there exists a PPT <span class="math">\\mathcal{X}</span> such that for all input instance pairs <span class="math">(u_1, u_2)</span>, outputs satisfying witnesses <span class="math">(w_1, w_2)</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, given public parameters <span class="math">\\mathsf{pp}</span>, a structure <span class="math">\\mathsf{s}</span>, and an <span class="math">(n_1, \\ldots, n_\\mu)</span>-tree of accepting transcripts and the corresponding folded instance-witness pairs <span class="math">(u, w)</span>. This tree comprises of <span class="math">n_1</span> transcripts (and the corresponding instance-witness pairs) with fresh randomness in <span class="math">\\mathcal{V}</span>'s first message; and for each such transcript, <span class="math">n_2</span> transcripts (and the corresponding instance-witness pairs) with fresh randomness in <span class="math">\\mathcal{V}</span>'s second message; etc., for a total of <span class="math">\\prod_{i=1}^{\\mu} n_i</span> leaves bounded by <span class="math">\\mathsf{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof Intuition.</strong> A proof for our variant of the forking lemma is similar to that of Bootle et al. [12]. We present a formal proof in Appendix E.</p>

    <p class="text-gray-300">In this section, we describe a public-coin, zero-knowledge interactive folding scheme for NP. We additionally discuss how to make it non-interactive. We leverage the non-interactivity property to realize IVC in the next section, and the zero-knowledge property to achieve zero-knowledge IVC proof compression.</p>

    <p class="text-gray-300">4.1 A Public-Coin, Zero-Knowledge Folding Scheme</p>

    <p class="text-gray-300">To design a folding scheme for NP, we need an NP-complete language. While theoretically any NP-complete language is a viable candidate, we focus on R1CS, a popular algebraic representation that generalizes arithmetic circuit satisfiability.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 10 (R1CS)</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span>. Let the public parameters consist of size bounds <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where <span class="math">m&gt;\\ell</span>. The R1CS structure consists of sparse matrices <span class="math">A,B,C\\in\\mathbb{F}^{m\\times m}</span> with at most <span class="math">n=\\Omega(m)</span> non-zero entries in each matrix. An instance <span class="math">\\mathsf{x}\\in\\mathbb{F}^{\\ell}</span> consists of public inputs and outputs and is satisfied by a witness <span class="math">W\\in\\mathbb{F}^{m-\\ell-1}</span> if <span class="math">(A\\cdot Z)\\circ(B\\cdot Z)=C\\cdot Z</span>, where <span class="math">Z=(W,\\mathsf{x},1)</span>.</p>

    <p class="text-gray-300">As we show in the next section, to realize IVC, we only need a folding scheme that can fold two R1CS instances with the same R1CS matrices <span class="math">(A,B,C)</span>. Specifically, given R1CS matrices <span class="math">(A,B,C)</span>, and two corresponding instance-witness pairs <span class="math">(\\mathsf{x}_{1},W_{1})</span> and <span class="math">(\\mathsf{x}_{2},W_{2})</span>, we would like to devise a scheme that reduces the task of checking both instances into the task of checking a single new instance-witness pair <span class="math">(\\mathsf{x},W)</span> against the same R1CS matrices <span class="math">(A,B,C)</span>. Unfortunately, as we illustrate now, it is difficult to devise a folding scheme for R1CS such that it satisfies completeness, let alone knowledge soundness.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">First Attempt.</h4>

    <p class="text-gray-300">As R1CS is an algebraic system, the most direct approach would be to take a random linear combination. Ignoring efficiency concerns, suppose that the prover sends witnesses <span class="math">W_{1}</span> and <span class="math">W_{2}</span> in the first step. The verifier responds with a random <span class="math">r\\in\\mathbb{F}</span>; the prover and the verifier both compute</p>

    <p class="text-gray-300"><span class="math">\\mathsf{x}\\leftarrow\\mathsf{x}_{1}+r\\cdot\\mathsf{x}_{2}</span> <span class="math">W\\leftarrow W_{1}+r\\cdot W_{2},</span></p>

    <p class="text-gray-300">and set the new instance-witness pair to be <span class="math">(\\mathsf{x},W)</span>. However, for non-trivial <span class="math">Z_{1}=(W_{1},\\mathsf{x}_{1},1)</span> and <span class="math">Z_{2}=(W_{2},\\mathsf{x}_{2},1)</span>, and <span class="math">Z=(W,\\mathsf{x},1)</span>, we <em>roughly</em> have that</p>

    <p class="text-gray-300"><span class="math">AZ\\circ BZ</span> <span class="math">=A(Z_{1}+r\\cdot Z_{2})\\circ B(Z_{1}+r\\cdot Z_{2})</span> <span class="math">=AZ_{1}\\circ BZ_{1}+r\\cdot(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1})+r^{2}\\cdot(AZ_{2}\\circ BZ_{2})</span> <span class="math">\\neq CZ.</span></p>

    <p class="text-gray-300">The failed attempt exposes three issues. First, we must account for an additional cross-term, <span class="math">r\\cdot(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1})</span>. Second, the terms excluding the cross-term combine to produce a term that does not equal <span class="math">CZ</span>:</p>

    <p class="text-gray-300"><span class="math">AZ_{1}\\circ BZ_{1}+r^{2}\\cdot(AZ_{2}\\circ BZ_{2})=CZ_{1}+r^{2}\\cdot CZ_{2}\\neq CZ_{1}+r\\cdot CZ_{2}=CZ.</span></p>

    <p class="text-gray-300">Third, we do not even have that <span class="math">Z=Z_{1}+r\\cdot Z_{2}</span> because <span class="math">Z_{1}+r\\cdot Z_{2}=(W,\\mathsf{x},1+r\\cdot 1)</span>.</p>

    <p class="text-gray-300">Second Attempt. To handle the first issue, we introduce a “slack” (or error) vector <span class="math">E\\in\\mathds{F}^{m}</span> which absorbs the cross terms generated by folding. To handle the second and third issues, we introduce a scalar <span class="math">u</span>, which absorbs an extra factor of <span class="math">r</span> in <span class="math">CZ_{1}+r^{2}\\cdot CZ_{2}</span> and in <span class="math">Z=(W,\\mathsf{x},1+r\\cdot 1)</span>. We refer to a variant of R1CS with these additional terms as <em>relaxed</em> R1CS.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 11 (Relaxed R1CS).</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathds{F}</span>. Let the public parameters consist of size bounds <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where <span class="math">m&gt;\\ell</span>. The relaxed R1CS structure consists of sparse matrices <span class="math">A,B,C\\in\\mathds{F}^{m\\times m}</span> with at most <span class="math">n=\\Omega(m)</span> non-zero entries in each matrix. A relaxed R1CS instance consists of an error vector <span class="math">E\\in\\mathds{F}^{m}</span>, a scalar <span class="math">u\\in\\mathds{F}</span>, and public inputs and outputs <span class="math">\\mathsf{x}\\in\\mathds{F}^{\\ell}</span>. An instance <span class="math">(E,u,\\mathsf{x})</span> is satisfied by a witness <span class="math">W\\in\\mathds{F}^{m-\\ell-1}</span> if <span class="math">(A\\cdot Z)\\circ(B\\cdot Z)=u\\cdot(C\\cdot Z)+E</span>, where <span class="math">Z=(W,\\mathsf{x},u)</span>.</p>

    <p class="text-gray-300">Note that any R1CS instance can be expressed as a relaxed R1CS instance by augmenting it with <span class="math">u=1</span> and <span class="math">E=0</span>, so relaxed R1CS retains <span class="math">\\mathsf{NP}</span>-completeness.</p>

    <p class="text-gray-300">Building on the first attempt, the prover and verifier can now use <span class="math">E</span> to accumulate the cross-terms. In particular, for <span class="math">Z_{i}=(W_{i},\\mathsf{x}_{i},u_{i})</span>, the prover and verifier additionally compute</p>

    <p class="text-gray-300"><span class="math">u</span> <span class="math">\\leftarrow u_{1}+r\\cdot u_{2}</span> <span class="math">E</span> <span class="math">\\leftarrow E_{1}+r\\cdot(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1}-u_{1}CZ_{2}-u_{2}CZ_{1})+r^{2}\\cdot E_{2},</span></p>

    <p class="text-gray-300">and set the new instance-witness pair to be <span class="math">((E,u,\\mathsf{x}),W)</span>. Conveniently, updating <span class="math">u</span> in this manner also keeps track of how the constant term in <span class="math">Z</span> should be updated, which motivates our choice to use <span class="math">u</span> in <span class="math">Z=(W,\\mathsf{x},u)</span> rather than introducing a new variable. Now, for <span class="math">Z=(W,\\mathsf{x},u)</span>, and for random <span class="math">r\\in\\mathds{F}</span>,</p>

    <p class="text-gray-300"><span class="math">AZ\\circ BZ</span> <span class="math">=AZ_{1}\\circ BZ_{1}+r\\cdot(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1})+r^{2}\\cdot(AZ_{2}\\circ BZ_{2})</span> <span class="math">=(u_{1}CZ_{1}+E_{1})+r\\cdot(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1})+r^{2}\\cdot(u_{2}CZ_{2}+E_{2})</span> <span class="math">=(u_{1}+r\\cdot u_{2})\\cdot C(Z_{1}+rZ_{2})+E</span> <span class="math">=uCZ+E.</span></p>

    <p class="text-gray-300">This implies that, for R1CS matrices <span class="math">(A,B,C)</span>, the folded witness <span class="math">W</span> is a satisfying witness for the folded instance <span class="math">(E,u,\\mathsf{x})</span> as promised. A few issues remain: in the above scheme, the prover sends witnesses <span class="math">(W_{1},W_{2})</span> for the verifier to compute <span class="math">E</span>. As a result, the folding scheme is <em>not</em> non-trivial; it is also not zero-knowledge.</p>

    <p class="text-gray-300">Final Protocol. To circumvent these issues, we use succinct and hiding additively homomorphic commitments to <span class="math">W</span> and <span class="math">E</span> in the instance, and treat both <span class="math">W</span> and <span class="math">E</span> as the witness. We refer to this variant of relaxed R1CS as <em>committed relaxed R1CS</em>. Below, we describe a folding scheme for committed relaxed R1CS, where the prover sends a single commitment to aid the verifier in computing commitments to the folded witness <span class="math">(W,E)</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 12 (Committed Relaxed R1CS).</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathds{F}</span> and a commitment scheme <span class="math">\\mathsf{Com}</span> over <span class="math">\\mathds{F}</span>. Let the public parameters consist of size bounds</p>

    <p class="text-gray-300"><span class="math">m,n,\\ell \\in \\mathbb{N}</span> where <span class="math">m &amp;gt; \\ell</span>, and commitment parameters <span class="math">\\mathsf{pp}_W</span> and <span class="math">\\mathsf{pp}_E</span> for vectors of size <span class="math">m</span> and <span class="math">m - \\ell - 1</span> respectively. The committed relaxed R1CS structure consists of sparse matrices <span class="math">A, B, C \\in \\mathbb{F}^{m \\times m}</span> with at most <span class="math">n = \\Omega(m)</span> non-zero entries in each matrix. A committed relaxed R1CS instance is a tuple <span class="math">(\\overline{E}, u, \\overline{W}, \\mathsf{x})</span>, where <span class="math">\\overline{E}</span> and <span class="math">\\overline{W}</span> are commitments, <span class="math">u \\in \\mathbb{F}</span>, and <span class="math">\\mathsf{x} \\in \\mathbb{F}^{\\ell}</span> are public inputs and outputs. An instance <span class="math">(\\overline{E}, u, \\overline{W}, \\mathsf{x})</span> is satisfied by a witness <span class="math">(E, r_E, W, r_W) \\in (\\mathbb{F}^m, \\mathbb{F}, \\mathbb{F}^{m - \\ell - 1}, \\mathbb{F})</span> if <span class="math">\\overline{E} = \\mathsf{Com}(\\mathsf{pp}_E, E, r_E)</span>, <span class="math">\\overline{W} = \\mathsf{Com}(\\mathsf{pp}_W, W, r_W)</span>, and <span class="math">(A \\cdot Z) \\circ (B \\cdot Z) = u \\cdot (C \\cdot Z) + E</span>, where <span class="math">Z = (W, \\mathsf{x}, u)</span>.</p>

    <p class="text-gray-300"><strong>Construction 1 (A Folding Scheme for Committed Relaxed R1CS).</strong> Consider a finite field <span class="math">\\mathbb{F}</span> and a succinct, hiding, and homomorphic commitment scheme <span class="math">\\mathsf{Com}</span> over <span class="math">\\mathbb{F}</span>. We define the generator and the encoder as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda}) \\to \\mathsf{pp}</span>: output size bounds <span class="math">m, n, \\ell \\in \\mathbb{N}</span>, and commitment parameters <span class="math">\\mathsf{pp}_W</span> and <span class="math">\\mathsf{pp}_E</span> for vectors of size <span class="math">m</span> and <span class="math">m - \\ell - 1</span> respectively.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp}, (A, B, C)) \\to (\\mathsf{pk}, \\mathsf{vk})</span>: output <span class="math">\\mathsf{pk} \\gets (\\mathsf{pp}, (A, B, C))</span> and <span class="math">\\mathsf{vk} \\gets \\bot</span>.</li>

    </ul>

    <p class="text-gray-300">The verifier <span class="math">\\mathcal{V}</span> takes two committed relaxed R1CS instances <span class="math">(\\overline{E}_1, u_1, \\overline{W}_1, \\mathsf{x}_1)</span> and <span class="math">(\\overline{E}_2, u_2, \\overline{W}_2, \\mathsf{x}_2)</span>. The prover <span class="math">\\mathcal{P}</span>, in addition to the two instances, takes witnesses to both instances, <span class="math">(E_1, r_{E_1}, W_1, r_{W_1})</span> and <span class="math">(E_2, r_{E_2}, W_2, r_{W_2})</span>. Let <span class="math">Z_1 = (W_1, \\mathsf{x}_1, u_1)</span> and <span class="math">Z_2 = (W_2, \\mathsf{x}_2, u_2)</span>. The prover and the verifier proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Send <span class="math">\\overline{T} \\coloneqq \\operatorname{Com}(\\mathsf{pp}_E, T, r_T)</span>, where <span class="math">r_T \\gets_R \\mathbb{F}</span> and with cross term</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">T = A Z _ {1} \\circ B Z _ {2} + A Z _ {2} \\circ B Z _ {1} - u _ {1} \\cdot C Z _ {2} - u _ {2} \\cdot C Z _ {1}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Sample and send challenge <span class="math">r \\gets_R \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{V}, \\mathcal{P}</span>: Output the folded instance <span class="math">(\\overline{E}, u, \\overline{W}, \\mathsf{x})</span> where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\overline {{E}} \\leftarrow \\overline {{E}} _ {1} + r \\cdot \\overline {{T}} + r ^ {2} \\cdot \\overline {{E}} _ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">u \\leftarrow u _ {1} + r \\cdot u _ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline {{W}} \\leftarrow \\overline {{W}} _ {1} + r \\cdot \\overline {{W}} _ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">x \\leftarrow x _ {1} + r \\cdot x _ {2}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Output the folded witness <span class="math">(E, r_E, W, r_W)</span>, where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">E \\leftarrow E _ {1} + r \\cdot T + r ^ {2} \\cdot E _ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {E} \\leftarrow r _ {E _ {1}} + r \\cdot r _ {T} + r ^ {2} \\cdot r _ {E _ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">W \\leftarrow W _ {1} + r \\cdot W _ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {W} \\leftarrow r _ {W _ {1}} + r \\cdot r _ {W _ {2}}</span></div>

    <p class="text-gray-300"><strong>Theorem 3 (A Folding Scheme for Committed Relaxed R1CS).</strong> Construction 1 is a public-coin folding scheme for committed relaxed R1CS with perfect completeness, knowledge soundness, and zero-knowledge.</p>

    <p class="text-gray-300">15</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof Intuition.</h6>

    <p class="text-gray-300">With textbook algebra, we can show that if witnesses <span class="math">(E_{1},r_{E_{1}},</span> <span class="math">W_{1},r_{W_{1}})</span> and <span class="math">(E_{2},r_{E_{2}},W_{2},r_{W_{2}})</span> are satisfying witnesses, then the folded witness <span class="math">(E,r_{E},W,r_{W})</span> must be a satisfying witness. We prove knowledge soundness via the forking lemma (Lemma 1) by showing that the extractor can produce the initial witnesses given three accepting transcripts and the corresponding folded witnesses. Specifically, the extractor uses all three transcripts to compute <span class="math">E_{i}</span> and <span class="math">r_{E_{i}}</span>, and any two transcripts to compute <span class="math">W_{i}</span> and <span class="math">r_{W_{i}}</span> for <span class="math">i\\in\\{1,2\\}</span>. The choice of which two transcripts does not matter due to the binding property of the commitment scheme. We present a formal proof in Appendix B. ∎</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.2 Achieving Non-Interactivity via the Fiat-Shamir Transform</h3>

    <p class="text-gray-300">To design Nova’s IVC scheme, we require our folding scheme for committed relaxed R1CS to be non-interactive in the standard model. To do so we first achieve non-interactivity in the random oracle model using the (strong) Fiat-Shamir transform <em>[25]</em>. Next, we heuristically instantiate the random oracle using a cryptographic hash function. As a result, we can only heuristically argue the security of the resulting non-interactive folding scheme. Note that all existing IVC constructions in the standard model require instantiating the random oracle with a cryptographic hash function <em>[13, 17, 23, 47]</em>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Construction 2 (A Non-Interactive Folding Scheme).</h6>

    <p class="text-gray-300">We achieve non-interactivity in the random oracle model using the strong Fiat-Shamir transform <em>[25]</em>. Let <span class="math">\\rho</span> denote a random oracle sampled during parameter generation and provided to all parties. Let <span class="math">(\\mathsf{G},\\mathsf{K},\\mathsf{P},\\mathsf{V})</span> represent our interactive folding scheme (Construction 1). We construct a non-interactive folding scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})</span>: output <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{G}(1^{\\lambda})</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},(A,B,C))</span>: <span class="math">\\mathsf{vk}\\leftarrow\\rho(\\mathsf{pp},\\mathsf{s})</span> and <span class="math">\\mathsf{pk}\\leftarrow(\\mathsf{pp},(A,B,C),\\mathsf{vk})</span>; output <span class="math">(\\mathsf{vk},\\mathsf{pk})</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},(u_{1},w_{1}),(u_{2},w_{2}))</span>: runs <span class="math">\\mathsf{P}((\\mathsf{pk}.\\mathsf{pp},\\mathsf{pk}.(A,B,C))</span> to retrieve its first message <span class="math">\\overline{T}</span>, and sends <span class="math">\\overline{T}</span> to <span class="math">\\mathcal{V}</span>; computes <span class="math">r\\leftarrow\\rho(\\mathsf{vk},u_{1},u_{2},\\overline{T})</span>, forwards this to <span class="math">\\mathsf{P}</span>, and outputs the resulting output.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},u_{1},u_{2},\\overline{T})</span>: runs <span class="math">\\mathsf{V}</span> with <span class="math">\\overline{T}</span> as the message from the prover and with randomness <span class="math">r\\leftarrow\\rho(\\mathsf{vk},u_{1},u_{2},\\overline{T})</span>, and outputs the resulting output.</li>

    </ul>

    <h6 id="sec-25" class="text-base font-medium mt-4">Assumption 1 (RO instantiation).</h6>

    <p class="text-gray-300">Construction 2 is a non-interactive folding scheme that satisfies completeness, knowledge soundness, and zero-knowledge in the standard model when <span class="math">\\rho</span> is instantiated with a cryptographic hash function.</p>

    <h2 id="sec-26" class="text-2xl font-bold">5 Nova: An IVC Scheme with Proof Compression</h2>

    <p class="text-gray-300">This section describes Nova, an IVC scheme designed from a non-interactive folding scheme, which when instantiated with any additively-homomorphic commitment scheme with succinct commitments achieves the claimed efficiency (Lemma 4). In addition, Nova incorporates an efficient zkSNARK to prove the knowledge</p>

    <p class="text-gray-300">of valid IVC proofs succinctly and in zero-knowledge, providing a succinct, zero-knowledge proof of knowledge of a valid IVC proof.</p>

    <p class="text-gray-300">In Nova, at each incremental step, the prover folds a particular step of the incremental computation (represented as a committed relaxed R1CS instance-witness pair) into a running committed relaxed R1CS instance-witness pair. At any step in the incremental computation, a valid “IVC proof”, in a nutshell, is a satisfying witness of the running committed relaxed R1CS instance (which an honest prover can compute by folding witnesses associated with each step of the incremental computation) along with the running committed relaxed R1CS instance. Furthermore, at any incremental step, Nova’s prover can prove in zero-knowledge and with a succinct proof—using a variant of an existing zkSNARK <em>[41]</em> (Section 6)—that it knows a valid IVC proof (i.e., a satisfying witness) to the running committed relaxed R1CS instance (Construction 4).</p>

    <p class="text-gray-300">Note that Nova is <em>not</em> a zero-knowledge IVC scheme, as that would additionally require an IVC proof to be zero-knowledge (in Nova’s case, an IVC proof does <em>not</em> hide witnesses associated with steps of the incremental computation). This difference is immaterial in the context of a single prover since it can use Nova’s auxiliary zkSNARK to provide a zero-knowledge proof of knowledge of a valid IVC proof; we leave it to future work to achieve zero-knowledge IVC.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.1 Constructing IVC from a Folding Scheme for NP</h3>

    <p class="text-gray-300">Recall that an IVC scheme allows a prover to show that <span class="math">z_{n}=F^{(n)}(z_{0})</span> for some count <span class="math">n</span>, initial input <span class="math">z_{0}</span>, and output <span class="math">z_{n}</span>. We now show how to construct an IVC scheme for a non-deterministic, polynomial-time computable function <span class="math">F</span> using our non-interactive folding scheme for committed relaxed R1CS (Construction 2).</p>

    <p class="text-gray-300">In our construction, as in a SNARK-based IVC, the prover uses an augmented function <span class="math">F^{\\prime}</span> (Figure 3), which, in addition to invoking <span class="math">F</span>, performs additional bookkeeping to fold proofs of prior invocations of itself.</p>

    <p class="text-gray-300">We first describe a simplified version of <span class="math">F^{\\prime}</span>, to provide intuition. <span class="math">F^{\\prime}</span> takes as non-deterministic advice two committed relaxed R1CS instances <span class="math">\\mathsf{u}_{i}</span> and <span class="math">\\mathsf{U}_{i}</span>. Suppose that <span class="math">\\mathsf{U}_{i}</span> represents the correct execution of invocations <span class="math">1,\\ldots,i-1</span> of <span class="math">F^{\\prime}</span> so long as <span class="math">\\mathsf{u}_{i}</span> represents the correct execution of invocation <span class="math">i</span> of <span class="math">F^{\\prime}</span>. <span class="math">F^{\\prime}</span> performs two tasks. First, it executes a step of the incremental computation: instance <span class="math">\\mathsf{u}_{i}</span> contains <span class="math">z_{i}</span> which <span class="math">F^{\\prime}</span> uses to output <span class="math">z_{i+1}=F(z_{i})</span>. Second, <span class="math">F^{\\prime}</span> invokes the verifier of the non-interactive folding scheme to fold the task of checking <span class="math">\\mathsf{u}_{i}</span> and <span class="math">\\mathsf{U}_{i}</span> into the task of checking a single instance <span class="math">\\mathsf{U}_{i+1}</span>. The IVC prover then computes a new instance <span class="math">\\mathsf{u}_{i+1}</span> which attests to the correct execution of invocation <span class="math">i+1</span> of <span class="math">F^{\\prime}</span>, thereby attesting that <span class="math">z_{i+1}=F(z_{i})</span> and <span class="math">\\mathsf{U}_{i+1}</span> is the result of folding <span class="math">\\mathsf{u}_{i}</span> and <span class="math">\\mathsf{U}_{i}</span>. Now, we have that <span class="math">\\mathsf{U}_{i+1}</span> represents the correct execution of invocations <span class="math">1,\\ldots,i</span> of <span class="math">F^{\\prime}</span> so long as <span class="math">\\mathsf{u}_{i+1}</span> represents the correct execution of invocation <span class="math">i+1</span> of <span class="math">F^{\\prime}</span>.</p>

    <p class="text-gray-300">The above description glossed over a subtle discrepancy: Because <span class="math">F^{\\prime}</span> must output the running instance <span class="math">\\mathsf{U}_{i+1}</span> for the next invocation to use, it is contained</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 3: A simplified depiction of  <span class="math">F&#x27;</span> .  <span class="math">F&#x27;</span>  represented as a committed relaxed R1CS instance  <span class="math">\\mathsf{u}_{i+1}</span>  encodes the statement that there exists  <span class="math">(i, z_0, z_i, \\mathsf{u}_i, \\mathsf{U}_i, \\mathsf{U}_{i+1}, r_i, r_{i+1}, \\overline{T})</span>  such that  <span class="math">\\mathsf{u}_i \\cdot \\mathsf{x} = \\mathsf{hash}(\\mathsf{vk}, i, z_0, z_i, \\mathsf{U}_i, r_i)</span> ,  <span class="math">h_{i+1} = \\mathsf{hash}(\\mathsf{vk}, i + 1, z_0, F(z_i), \\mathsf{U}_{i+1}, r_{i+1})</span> ,  <span class="math">\\mathsf{U}_{i+1} = \\mathsf{NIFS}.V(\\mathsf{vk}, \\mathsf{U}_i, \\mathsf{u}_i, \\overline{T})</span> , and that  <span class="math">F&#x27;</span>  outputs  <span class="math">h_{i+1}</span> . The diagram omits depicting  <span class="math">\\mathsf{vk}</span> ,  <span class="math">\\omega_i</span> ,  <span class="math">r_i</span> ,  <span class="math">r_{i+1}</span> , and  <span class="math">\\overline{T}</span> .</p>

    <p class="text-gray-300">in  <span class="math">\\mathsf{u}_{i + 1}.\\times</span>  (i.e., the public IO of  <span class="math">\\mathsf{u}_{i + 1}</span> ). But, in the next iteration,  <span class="math">F^{\\prime}</span>  must fold  <span class="math">\\mathsf{u}_{i + 1}.\\times</span>  into  <span class="math">\\mathsf{U}_{i + 1}.\\times</span> , meaning that  <span class="math">F^{\\prime}</span>  is stuck trying to squeeze  <span class="math">\\mathsf{U}_{i + 1}</span>  into  <span class="math">\\mathsf{U}_{i + 1}.\\times</span> . To handle this inconsistency, we modify  <span class="math">F^{\\prime}</span>  to output a collision-resistant hash of its public IO rather than producing it directly (this ensures that the public IO of  <span class="math">F^{\\prime}</span>  is a constant number of finite field elements). The next invocation of  <span class="math">F^{\\prime}</span>  then additionally takes the preimage of this hash as non-deterministic advice. Note that the hash function takes an additional random input. We assume that this provides a commitment scheme with hiding commitments.</p>

    <p class="text-gray-300">Producing IVC Proofs. Let  <span class="math">(\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp})</span>  be the trivially satisfying instance-witness pair, where  <span class="math">E,W,</span>  and  <span class="math">\\times</span>  are appropriately-sized zero vectors,  <span class="math">r_E = 0</span> <span class="math">r_W = 0</span>  , and  <span class="math">\\overline{E}</span>  and  <span class="math">\\overline{W}</span>  are commitments of  <span class="math">E</span>  and  <span class="math">W</span>  respectively.</p>

    <p class="text-gray-300">Now, in iteration  <span class="math">i + 1</span> , the IVC prover runs  <span class="math">F&#x27;</span>  and computes  <span class="math">\\mathsf{u}_{i + 1}</span>  and  <span class="math">\\mathsf{U}_{i + 1}</span>  as well as the corresponding witnesses  <span class="math">\\mathsf{w}_{i + 1}</span>  and  <span class="math">\\mathsf{W}_{i + 1}</span> . Because  <span class="math">\\mathsf{u}_{i + 1}</span>  and  <span class="math">\\mathsf{U}_{i + 1}</span>  together attest to the correctness of  <span class="math">i + 1</span>  invocations of  <span class="math">F&#x27;</span>  (which indirectly attests to  <span class="math">i + 1</span>  invocations of  <span class="math">F</span> ) the IVC proof  <span class="math">\\varPi_{i + 1}</span>  is  <span class="math">((\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1}),(\\mathsf{u}_{i + 1},\\mathsf{w}_{i + 1}))</span> . Moreover, succinctness is maintained by the properties of the underlying folding scheme. We formally describe our construction below.</p>

    <p class="text-gray-300"><strong>Construction 3 (IVC).</strong> Let  <span class="math">\\mathsf{NIFS} = (\\mathsf{G},\\mathsf{K},\\mathsf{P},\\mathsf{V})</span>  be the non-interactive folding scheme for committed relaxed R1CS (Construction 2). Consider a polynomial-time function  <span class="math">F</span>  that takes non-deterministic input, and a cryptographic hash function  <span class="math">\\mathsf{hash}</span> . We define our augmented function  <span class="math">F&#x27;</span>  as follows (all arguments to  <span class="math">F&#x27;</span>  are taken as non-deterministic advice):</p>

    <div class="my-4 text-center"><span class="math-block">F ^ {\\prime} (\\mathsf {v k}, \\mathsf {U} _ {i}, \\mathsf {u} _ {i}, (i, z _ {0}, z _ {i}), \\omega_ {i}, \\overline {{T}}, r _ {i}, r _ {i + 1}) \\rightarrow \\mathsf {x}:</span></div>

    <p class="text-gray-300">If <span class="math">i = 0</span>, output <span class="math">\\mathsf{hash}(\\mathsf{vk}, i + 1, z_0, F(z_0, \\omega_0), \\mathsf{u}_{\\perp}, r_{i+1})</span>,</p>

    <p class="text-gray-300">otherwise,</p>

    <p class="text-gray-300">(1) check that <span class="math">\\mathsf{u}_i.\\mathsf{x} = \\mathsf{hash}(\\mathsf{vk}, i, z_0, z_i, \\mathsf{U}_i, r_i)</span>, where <span class="math">\\mathsf{u}_i.\\mathsf{x}</span> is the public IO of <span class="math">\\mathsf{u}_i</span>, (2) check that <span class="math">(\\mathsf{u}_i.\\overline{E},\\mathsf{u}_i.\\mathsf{u}) = (\\mathsf{u}_{\\perp}.\\overline{E},1)</span>, (3) compute <span class="math">\\mathsf{U}_{i + 1}\\gets \\mathsf{NIFS.V}(\\mathsf{vk},\\mathsf{U}_i,\\mathsf{u}_i,\\overline{T})</span>, and (4) output <span class="math">\\mathsf{hash}(\\mathsf{vk}, i + 1, z_0, F(z_i, \\omega_i), \\mathsf{U}_{i+1}, r_{i+1})</span>.</p>

    <p class="text-gray-300">Because <span class="math">F&#x27;</span> can be computed in polynomial time, it can be represented as a committed relaxed R1CS structure. We assume that there is a deterministic procedure, which we denote with AUGMENT, that takes as input a function <span class="math">F</span> and public parameters <span class="math">\\mathsf{pp}</span> sampled by <span class="math">\\mathcal{G}</span> of the IVC scheme, and outputs the committed relaxed R1CS structure corresponding to <span class="math">F&#x27;</span>, which we denote with <span class="math">\\mathsf{s}_{F&#x27;}</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathrm {u} _ {i + 1}, \\mathrm {w} _ {i + 1}\\right) \\leftarrow \\operatorname {t r a c e} \\left(F ^ {\\prime}, \\left(\\mathrm {v k}, \\mathrm {U} _ {i}, \\mathrm {u} _ {i}, \\left(i, z _ {0}, z _ {i}\\right), \\omega_ {i}, \\bar {T}, r _ {i}, r _ {i + 1}\\right)\\right)</span></div>

    <p class="text-gray-300">denote the satisfying committed relaxed R1CS instance-witness pair <span class="math">(\\mathsf{u}_{i + 1},\\mathsf{w}_{i + 1})</span> for the execution of <span class="math">F^{\\prime}</span>, as a committed Relaxed R1CS with structure <span class="math">\\mathsf{s}_{F&#x27;}</span>, on non-deterministic advice <span class="math">(\\mathsf{vk},\\mathsf{U}_i,\\mathsf{u}_i,(i,z_0,z_i),\\omega_i,\\overline{T},r_i,r_{i + 1})</span>. Note that trace is a randomized algorithm that internally samples randomness to create hiding commitments inside <span class="math">\\mathsf{u}_{i + 1}</span>. Additionally, note that trace sets <span class="math">\\mathsf{u}_{i + 1}.\\overline{E} = \\mathsf{u}_{\\perp}.\\overline{E}</span> and that <span class="math">\\mathsf{u}_{i + 1}.u = 1</span>.</p>

    <p class="text-gray-300">We define the IVC scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda})\\to \\mathsf{pp}</span>: Output NIFS.G(1λ).</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},F)\\to (\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <p class="text-gray-300">(1) compute <span class="math">\\mathsf{s}_{F^{\\prime}}\\gets \\mathsf{AUGMENT}(\\mathsf{pp},F)</span> (2) compute <span class="math">(\\mathsf{pk}_{\\mathsf{fs}},\\mathsf{vk}_{\\mathsf{fs}})\\gets \\mathsf{NIFS.K}(\\mathsf{pp},\\mathsf{s}_{F^{\\prime}})</span> (3) output <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets ((\\mathsf{pp},F,\\mathsf{pk}_{\\mathsf{fs}}),(\\mathsf{pp},\\mathsf{s}_{F^{\\prime}},\\mathsf{vk}_{\\mathsf{fs}}))</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_0,z_i),\\omega_i,\\Pi_i)\\to \\Pi_{i + 1}</span></p>

    <p class="text-gray-300">(1) if <span class="math">i = 0</span>, compute <span class="math">(\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1},\\overline{T})\\gets (\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp},\\mathsf{u}_{\\perp}.\\overline{E})</span> (2) otherwise, parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_i,\\mathsf{W}_i),(\\mathsf{u}_i,\\mathsf{w}_i),r_i)</span> and compute <span class="math">(\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1},\\overline{T})\\gets</span> NIFS.P(pk, <span class="math">(\\mathsf{U}_i,\\mathsf{W}_i),(\\mathsf{u}_i,\\mathsf{w}_i))</span> (3) sample <span class="math">r_{i + 1}\\in \\mathbb{F}</span> randomly; (4) compute <span class="math">(\\mathsf{u}_{i + 1},\\mathsf{w}_{i + 1})\\gets \\mathsf{trace}(F^{\\prime},(\\mathsf{vk},\\mathsf{U}_i,\\mathsf{u}_i,(i,z_0,z_i),\\omega_i,\\overline{T},r_i,r_{i + 1}))</span> and (5) output <span class="math">\\Pi_{i + 1}\\gets ((\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1}),(\\mathsf{u}_{i + 1},\\mathsf{w}_{i + 1}),r_{i + 1})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_0,z_i),\\Pi_i)\\to \\{0,1\\}</span></p>

    <p class="text-gray-300">If <span class="math">i = 0</span>, check that <span class="math">z_{i} = z_{0}</span>; otherwise, (1) parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_i,\\mathsf{W}_i),(\\mathsf{u}_i,\\mathsf{w}_i),r_i)</span>, (2) check that <span class="math">\\mathsf{u}_i.\\mathsf{x} = \\mathsf{hash}(\\mathsf{vk},i,z_0,z_i,\\mathsf{U}_i,r_i)</span>, (3) check that <span class="math">(\\mathsf{u}_i.\\overline{E},\\mathsf{u}.u) = (\\mathsf{u}_{\\perp}.\\overline{E},1)</span>, and (4) check that <span class="math">\\mathsf{W}_i</span> and <span class="math">\\mathsf{w}_i</span> are satisfying witnesses to <span class="math">\\mathsf{U}_i</span> and <span class="math">\\mathsf{u}_i</span> respectively using vk.pp and vk.sF.</p>

    <p class="text-gray-300"><strong>Lemma 2 (Completeness).</strong> Construction 3 is an IVC scheme that satisfies completeness.</p>

    <p class="text-gray-300"><strong>Proof Intuition.</strong> Given a satisfying IVC proof <span class="math">\\Pi_i = ((\\mathsf{U}_i, \\mathsf{W}_i), (\\mathsf{u}_i, \\mathsf{w}_i), r_i)</span> suppose that <span class="math">\\mathcal{P}</span> outputs <span class="math">\\Pi_{i+1} = ((\\mathsf{U}_{i+1}, \\mathsf{W}_{i+1}), (\\mathsf{u}_{i+1}, \\mathsf{w}_{i+1}), r_{i+1})</span>. Because <span class="math">\\Pi_i</span> is a valid IVC proof, <span class="math">(\\mathsf{u}_i, \\mathsf{w}_i)</span> and <span class="math">(\\mathsf{U}_i, \\mathsf{W}_i)</span> are satisfying instance-witness pairs. Because <span class="math">(\\mathsf{U}_{i+1}, \\mathsf{W}_{i+1})</span> is obtained by folding <span class="math">(\\mathsf{u}_i, \\mathsf{w}_i)</span> and <span class="math">(\\mathsf{U}_i, \\mathsf{W}_i)</span>, it must be satisfying by the folding scheme's completeness. By construction, <span class="math">(\\mathsf{u}_{i+1}, \\mathsf{w}_{i+1})</span> is satisfying instance-witness pair that satisfies the IVC verifier's auxiliary checks including the ones that involve <span class="math">r_{i+1}</span>. Thus, <span class="math">\\Pi_{i+1}</span> is satisfying. Appendix C provides a formal proof.</p>

    <p class="text-gray-300"><strong>Lemma 3 (Knowledge Soundness).</strong> Construction 3 is an IVC scheme that satisfies knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof Intuition.</strong> For function <span class="math">F</span>, constant <span class="math">n</span>, <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda})</span>, and <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathcal{K}(\\mathsf{pp}, F)</span>, consider an adversary <span class="math">\\mathcal{P}^<em></span> that outputs <span class="math">(z_0, z, \\Pi)</span> such that <span class="math">\\mathcal{V}(\\mathsf{vk}, (n, z_0, z), \\Pi) = 1</span> with probability <span class="math">\\epsilon</span>. We construct an extractor <span class="math">\\mathcal{E}</span> that with input <span class="math">(\\mathsf{pp}, z_0, z)</span>, outputs <span class="math">(\\omega_0, \\ldots, \\omega_{n-1})</span> such that by computing <span class="math">z_i \\gets F(z_{i-1}, \\omega_{i-1})</span> for all <span class="math">i \\in \\{1, \\ldots, n\\}</span> we have that <span class="math">z_n = z</span> with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>. We show inductively that <span class="math">\\mathcal{E}</span> can construct an extractor <span class="math">\\mathcal{E}_i</span> that outputs <span class="math">(z_i, \\ldots, z_{n-1})</span>, <span class="math">(\\omega_i, \\ldots, \\omega_{n-1})</span>, and <span class="math">\\Pi_i</span> such that for all <span class="math">j \\in \\{i+1, \\ldots, n\\}</span>, <span class="math">z_j = F(z_{j-1}, \\omega_{j-1})</span>, <span class="math">\\mathcal{V}(\\mathsf{vk}, i, z_0, z_i, \\Pi_i) = 1</span>, and <span class="math">z_n = z</span> with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>. Then, because in the base case when <span class="math">i = 0</span>, <span class="math">\\mathcal{V}</span> checks that <span class="math">z_0 = z_i</span>, it is sufficient for <span class="math">\\mathcal{E}</span> to run <span class="math">\\mathcal{E}_0</span> to retrieve values <span class="math">(\\omega_0, \\ldots, \\omega_{n-1})</span>. Initially, <span class="math">\\mathcal{E}_n</span> simply runs the assumed <span class="math">\\mathcal{P}^</em></span> to get a satisfying <span class="math">\\Pi_n</span>. Given extractor <span class="math">\\mathcal{E}_i</span> that satisfies the inductive hypothesis, we can construct extractor <span class="math">\\mathcal{E}_{i-1}</span>. Appendix C provides a formal proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 4 (Efficiency).</strong> When instantiated with the Pedersen commitment scheme (Construction 6), we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ o(2 \\cdot \\mathsf{G} + 2 \\cdot \\mathsf{H} + \\mathsf{R})<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of R1CS constraints to encode a function </span>F<span class="math">, </span>\\mathsf{G}<span class="math"> is the number of constraints required to encode a group scalar multiplication, </span>\\mathsf{H}<span class="math"> is the number of constraints required to encode </span>\\mathsf{hash}<span class="math">, and </span>\\mathsf{R}<span class="math"> is the number of constraints to encode the RO </span>\\rho$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> On input instances <span class="math">\\mathsf{U}</span> and <span class="math">\\mathsf{u}</span>, NIFS.V computes <span class="math">\\overline{E} \\gets \\mathsf{U}.\\overline{E} + r \\cdot \\overline{T} + r^2 \\cdot \\mathsf{u}.\\overline{E}</span> and <span class="math">\\overline{W} \\gets \\mathsf{U}.\\overline{W} + r \\cdot \\mathsf{u}.\\overline{W}</span>. However, by construction, <span class="math">\\mathsf{u}.\\overline{E} = \\mathsf{u}_{\\perp}.\\overline{E} = \\overline{0}</span>. So, NIFS.V computes two group scalar multiplications, as it does not need to compute <span class="math">r^2 \\cdot \\mathsf{u}.\\overline{E}</span>. NIFS.V additionally invokes the RO once to obtain a random scalar. Finally, <span class="math">F&#x27;</span> makes two additional calls to <span class="math">\\mathsf{hash}</span> (details are in the description of <span class="math">F&#x27;</span>).</p>

    <p class="text-gray-300">5.2 Compressing IVC Proofs with zkSNARKs</p>

    <p class="text-gray-300">To prove a statement about an incremental computation, the prover can produce an IVC proof using the construction in the prior section and send the IVC proof to the verifier. However, this does not satisfy zero-knowledge (as the IVC proof described in the prior section does not hide the prover’s non-deterministic inputs) and succinctness (as the IVC proof size is linear in the size <span class="math">F</span>). In theory, one can address this problem with any zkSNARK for <span class="math">\\mathsf{NP}</span>. Specifically, <span class="math">\\overline{\\mathcal{P}}</span> can produce a zkSNARK proving that it knows <span class="math">\\Pi_{i}</span> such that IVC verifier <span class="math">\\mathcal{V}</span> accepts for statement <span class="math">(i,z_{0},z_{i})</span>. Naturally, the proof sent to the verifier is succinct and zero-knowledge due to the corresponding properties of the zkSNARK.</p>

    <p class="text-gray-300">Unfortunately, employing an off-the-shelf zkSNARK makes the overall solution impractical as the zkSNARK prover must prove, among other things, the knowledge of vectors whose commitments equal a particular value; this requires encoding a linear number of group scalar multiplications in the programming model of zkSNARKs (e.g., R1CS or circuits). To address this, we design a zkSNARK tailored for our particular purpose and we describe it in Section 6. Below, we describe how to use a zkSNARK to prove the knowledge of a valid IVC proof. Formally, we design a zkSNARK for the following relation.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 13 (IVC Proof Validity Relation).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IVC}=(G,K,P,V)</span> denote the IVC scheme described in Construction 3. We define the relation <span class="math">\\mathcal{R}_{\\mathsf{VIVC}}</span> over public parameter, structure, instance, and witness tuples as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{VIVC}}=\\left\\{\\left.(\\mathsf{pp},F,(n,z_{0},z_{n}),\\Pi_{n})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}\\mathsf{vk}\\leftarrow\\mathsf{IVC}.K(\\mathsf{pp},F),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{IVC}.V(\\mathsf{vk},(i,z_{0},z_{i}),\\Pi)=1\\end{matrix}\\right\\} \\]</p>

    <p class="text-gray-300">In a nutshell, we leverage the fact that <span class="math">\\Pi</span> contains two committed relaxed R1CS instance-witness pairs. So, <span class="math">\\mathcal{P}</span> first folds the instance-witness pairs <span class="math">(\\mathsf{u},\\mathsf{w})</span> and <span class="math">(\\mathsf{U},\\mathsf{W})</span> in <span class="math">\\Pi</span> to produce a folded instance-witness pair <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span>, using <span class="math">\\mathsf{NIFS.P}</span>. Next, <span class="math">\\mathcal{P}</span> runs <span class="math">\\mathsf{zkSNARK.P}</span> to prove that it knows a valid witness for <span class="math">\\mathsf{U}^{\\prime}</span>. One caveat is that for zero-knowledge to hold, we need that <span class="math">\\Pi</span> is honestly randomized. We capture this qualification formally in Theorem 4.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Construction 4 (A zkSNARK of a Valid IVC Proof).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IVC}=(G,K,P,V)</span> denote the IVC scheme in Construction 3, let <span class="math">\\mathsf{NIFS}</span> denote the non-interactive folding scheme in Construction 2, and let <span class="math">\\mathsf{hash}</span> denote a randomized cryptographic hash function that provides hiding. Assume a zkSNARK (Definition 2), <span class="math">\\mathsf{zkSNARK}</span>, for committed relaxed R1CS that has the same public parameter generator algorithm. We construct a zkSNARK <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for the relation <span class="math">\\mathcal{R}_{\\mathsf{VIVC}}</span> (Definition 13) as follows.</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathcal{G}(1^{\\lambda})}\\rightarrow\\mathsf{pp}</span>:</p>

    <p class="text-gray-300">Output <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkSNARK}.G(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathcal{K}(\\mathsf{pp},F)}\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <p class="text-gray-300">(1) Compute <span class="math">(\\mathsf{pk}_{\\mathsf{IVC}},\\mathsf{vk}_{\\mathsf{IVC}})\\gets \\mathsf{IVC.K}(\\mathsf{pp},F).</span> (2) Compute <span class="math">s_{F&#x27;} \\gets \\text{AUGMENT}(\\mathsf{pp}, F)</span>. (3) Compute <span class="math">(\\mathsf{pk}_{\\mathsf{zkSNARK}}, \\mathsf{vk}_{\\mathsf{zkSNARK}}) \\gets \\mathsf{zkSNARK.K}(\\mathsf{pp}, \\mathsf{s}_{F&#x27;})</span>. (4) Output <span class="math">\\mathsf{pk} \\gets ((\\mathsf{pk}_{\\mathsf{IVC}}, \\mathsf{pk}_{\\mathsf{zkSNARK}})</span> and <span class="math">\\mathsf{vk} \\gets (\\mathsf{vk}_{\\mathsf{IVC}}, \\mathsf{vk}_{\\mathsf{zkSNARK}})</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{P}(\\mathrm{pk}, (n, z_0, z_n), \\Pi_n)) \\rightarrow \\pi:</span></div>

    <p class="text-gray-300">If <span class="math">n = 0</span>, output <span class="math">\\perp</span>; otherwise,</p>

    <p class="text-gray-300">(1) parse <span class="math">\\Pi_n</span> as <span class="math">((\\mathsf{U}_n,\\mathsf{W}_n),(\\mathsf{u}_n,\\mathsf{w}_n),r_n)</span> (2) compute <span class="math">(\\mathsf{U}&#x27;,\\mathsf{W}&#x27;,\\overline{T}_n)\\gets \\mathsf{NIFS.P}(\\mathsf{pk}_{\\mathsf{IVC}},[(\\mathsf{U}_n,\\mathsf{W}_n),(\\mathsf{u}_n,\\mathsf{w}_n)))</span> (3) compute <span class="math">\\pi_{\\mathsf{U}&#x27;} \\gets \\mathsf{zkSNARK.P}(\\mathsf{pk}_{\\mathsf{zkSNARK}}, \\mathsf{U}&#x27;, \\mathsf{W}&#x27;)</span> (4) output <span class="math">(\\mathsf{U}_n,\\mathsf{u}_n,r_n,\\overline{T}_n,\\pi_{\\mathsf{U}&#x27;})</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{V}(\\mathrm{vk}, (n, z_0, z_n), \\pi) \\rightarrow \\{0, 1\\}</span></div>

    <p class="text-gray-300">If <span class="math">n = 0</span>, check that <span class="math">z_0 = z_i</span>; otherwise,</p>

    <p class="text-gray-300">(1) parse <span class="math">\\pi</span> as <span class="math">(\\mathsf{U}_n,\\mathsf{u}_n,r_n,\\overline{T}_n,\\pi_{\\mathsf{U}&#x27;})</span>, (2) check that <span class="math">\\mathsf{u}_n.\\mathsf{x} = \\mathsf{hash}(\\mathsf{vk}_{\\mathsf{IVC}},i,z_0,z_n,\\mathsf{U}_n,r_n)</span>, (3) check that <span class="math">(\\mathsf{u}.\\overline{E},\\mathsf{u}.\\mathsf{u}) = (\\mathsf{u}_{\\perp}.\\overline{E},1)</span>, (4) compute <span class="math">\\mathsf{U}&#x27; \\gets \\mathsf{NIFS.V}(\\mathsf{vk}_{\\mathsf{IVC}}, \\mathsf{U}_n, \\mathsf{u}_n, \\overline{T}_n)</span>, and (5) check that <span class="math">\\mathsf{zkSNARK.V}(\\mathsf{vk}_{\\mathsf{zkSNARK}}, \\mathsf{U}&#x27;, \\pi_{\\mathsf{U}&#x27;}) = 1</span>.</p>

    <p class="text-gray-300">Theorem 4 (A zkSNARK of a Valid IVC Proof). Construction 4 is a SNARK of a valid IVC proof produced by Construction 3. It provides zero-knowledge if the adversary <span class="math">\\mathcal{A}</span> is restricted to sample the instance-witness pair <span class="math">((n, z_0, z_n), \\Pi_n)</span> with the following strategy, where <span class="math">\\mathcal{A}^{\\star}</span> is an arbitrary PPT algorithm:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{A}(\\mathsf{pp}) \\rightarrow (F, (n, z_0, z_i), \\Pi_n):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(F, n, z_0, \\omega_0, \\ldots, \\omega_{n-1}) \\gets \\mathcal{A}^{\\star}(\\mathsf{pp})</span></li>

      <li><span class="math">(\\mathsf{pk}_{\\mathsf{IVC}},\\mathsf{vk}_{\\mathsf{IVC}})\\gets \\mathsf{IVC.K}(\\mathsf{pp},F)</span></li>

      <li><span class="math">\\Pi_0 \\gets \\perp</span></li>

      <li>for <span class="math">i = 1</span> to <span class="math">n</span></li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\Pi_i \\gets \\mathsf{IVC.P}(\\mathsf{pk}_{\\mathsf{IVC}},(i,z_0,z_{i-1}),\\omega_{i-1},\\Pi_{i-1})</span> (b) <span class="math">z_i \\gets F(z_{i-1}, \\omega_{i-1})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(F, (n, z_0, z_n), \\Pi_n)</span></li>

    </ol>

    <p class="text-gray-300">Proof Intuition. Completeness and knowledge soundness hold due to the completeness and knowledge soundness of the underlying zkSNARK and the non-interactive folding scheme. Assuming the non-interactive folding scheme satisfies succinctness (e.g., by using the Pedersen commitment scheme), succinctness holds</p>

    <p class="text-gray-300">due to the fact that <span class="math">\\mathfrak{u}</span>, <span class="math">\\mathsf{U}</span>, and <span class="math">\\overline{T}</span> are succinct, and due to the succinctness of the underling zkSNARK.</p>

    <p class="text-gray-300">To prove zero-knowledge, we leverage the restriction on the adversarily strategy to generate instance-witness pairs for the zkSNARK. In particular, we construct a simulator <span class="math">\\mathcal{S}</span> that first iteratively simulates <span class="math">(\\mathsf{U}_i,\\mathsf{u}_i)</span> for all <span class="math">i\\in \\{1,\\ldots ,n\\}</span>. Specifically, given the simulated values <span class="math">(\\mathsf{U}_i,\\mathsf{u}_i)</span>, <span class="math">\\mathcal{S}</span> first uses the simulator of the non-interactive folding scheme to simulate <span class="math">\\overline{T}_i</span>. <span class="math">\\mathcal{S}</span> then folds <span class="math">\\mathsf{U}_i</span> and <span class="math">\\mathsf{u}_i</span> using <span class="math">\\overline{T}_i</span> to produce <span class="math">\\mathsf{U}_{i + 1}</span>. <span class="math">\\mathcal{S}</span> simulates <span class="math">\\mathsf{u}_i</span> using the observation that all terms are randomized. The only exception is <span class="math">\\mathsf{u}_n.\\mathsf{x}</span>, which is set to <span class="math">\\mathsf{hash}(\\mathsf{vk}_{\\mathsf{NIFS}},n,z_0,z_n,\\mathsf{U}_n,r_n)</span>, where <span class="math">r_n\\in \\mathbb{F}</span> is sampled randomly. In the final round, <span class="math">\\mathcal{S}</span> folds <span class="math">\\mathsf{u}_n</span> and <span class="math">\\mathsf{U}_n</span> (again using a simulated <span class="math">\\overline{T}_n</span>) to produce an instance <span class="math">\\mathsf{U}&#x27;</span>, and then uses the simulator of the zkSNARK to produce <span class="math">\\pi_{\\mathsf{U}&#x27;}</span>. <span class="math">\\mathcal{S}</span> outputs <span class="math">(\\mathsf{U}_n,\\mathsf{u}_n,r_n,\\overline{T}_n,\\pi_{\\mathsf{U}&#x27;})</span>. We provide a formal proof in Appendix D.</p>

    <p class="text-gray-300">As described in Section 5.2, Nova needs a zkSNARK for committed relaxed R1CS to prove the knowledge of a valid IVC proof succinctly and in zero-knowledge. This section presents such a zkSNARK by adapting Spartan [41]. We build on Spartan [41] to avoid FFTs and a trusted setup.</p>

    <h2 id="sec-31" class="text-2xl font-bold">6.1 Background</h2>

    <p class="text-gray-300">We assume familiarity with polynomials. We provide background in Appendix G.</p>

    <p class="text-gray-300"><strong>Definition 14 (Polynomial Extension).</strong> Suppose <span class="math">f:\\{0,1\\}^{\\ell}\\to \\mathbb{F}</span> is a function that maps <span class="math">\\ell</span>-bit strings to an element of <span class="math">\\mathbb{F}</span>. A polynomial extension of <span class="math">f</span> is a low-degree <span class="math">\\ell</span>-variate polynomial <span class="math">\\widetilde{f}:\\mathbb{F}^{\\ell}\\to \\mathbb{F}</span> such that <span class="math">\\widetilde{f}(x) = f(x)</span> for all <span class="math">x\\in \\{0,1\\}^{\\ell}</span>. A multilinear extension (MLE) of a function <span class="math">f:\\{0,1\\}^{\\ell}\\to \\mathbb{F}</span> is a low-degree polynomial extension where the extension is a multilinear polynomial.</p>

    <p class="text-gray-300">Every function <span class="math">f:\\{0,1\\}^{\\ell}\\to \\mathbb{F}</span> has a unique MLE, and conversely every <span class="math">\\ell</span>-variate multilinear polynomial over <span class="math">\\mathbb{F}</span> extends a unique function mapping <span class="math">\\{0,1\\}^{\\ell}\\to \\mathbb{F}</span>. Below, we use <span class="math">\\widetilde{f}</span> to denote the unique MLE of <span class="math">f</span>.</p>

    <p class="text-gray-300"><strong>Lemma 5 (The Sum-Check Protocol [38]).</strong> For <span class="math">\\ell</span>-variate polynomial <span class="math">G</span> over <span class="math">\\mathbb{F}</span> with degree at most <span class="math">\\mu</span> in each variable, there exists a public-coin interactive proof protocol (known as the sum-check protocol) to reduce the task of checking <span class="math">\\sum_{x\\in \\{0,1\\}^{\\ell}}G(x) = T</span> to the task of checking <span class="math">G(r) = e</span> for <span class="math">r\\in \\mathbb{F}^{\\ell}</span>. The interaction consists of a total of <span class="math">\\ell</span> rounds, where in each round the verifier sends a single element of <span class="math">\\mathbb{F}</span> and the prover responds with <span class="math">\\mu +1</span> elements of <span class="math">\\mathbb{F}</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">6.2 A Polynomial IOP for Idealized Relaxed R1CS</h2>

    <p class="text-gray-300">Our exposition below is based on Spartan [41] and its recent recapitulation [37]. The theorem below and its proof is a verbatim adaptation of Spartan's polynomial IOP for R1CS to relaxed R1CS.</p>

    <p class="text-gray-300">Recall that an interactive proof (IP) <em>[28]</em> for a relation <span class="math">\\mathcal{R}</span> is an interactive protocol between a prover and a verifier where the prover proves the knowledge of a witness <span class="math">w</span> for a prescribed instance <span class="math">u</span> such that <span class="math">(u,w)\\in\\mathcal{R}</span>. An interactive oracle proof (IOP) <em>[6, 40]</em> generalizes interactive proofs where in each round the prover may send an oracle (e.g., a string) and the verifier may query a previously-sent oracle during the remainder of the protocol. A polynomial IOP <em>[19]</em> is an IOP in which the oracle sent by the prover is a polynomial and the verifier may query for an evaluation of the polynomial at a point in its domain. We consider a (minor) variant of polynomial IOPs, where the verifier has oracle access to polynomials in the R1CS structure and instance.</p>

    <p class="text-gray-300">We first construct a polynomial IOP for an idealized version of relaxed R1CS (Definition 15) where the instance contains a purported witness. We then compile it into a zkSNARK for committed relaxed R1CS (Definition 12).</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 15 (Idealized Relaxed R1CS)</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span>. Let the public parameters consist of size bounds <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where <span class="math">m&gt;\\ell</span>. An idealized relaxed R1CS structure consists of sparse matrices <span class="math">A,B,C\\in\\mathbb{F}^{m\\times m}</span> with at most <span class="math">n=\\Omega(m)</span> non-zero entries in each matrix. An idealized relaxed R1CS instance consists of an error vector <span class="math">E\\in\\mathbb{F}^{m}</span>, a scalar <span class="math">u\\in\\mathbb{F}</span>, witness vector <span class="math">W\\in\\mathbb{F}^{m}</span>, and public inputs and outputs <span class="math">\\mathsf{x}\\in\\mathbb{F}^{\\ell}</span>. An instance <span class="math">(E,u,W,\\mathsf{x})</span> is satisfying if <span class="math">(A\\cdot Z)\\circ(B\\cdot Z)=u\\cdot(C\\cdot Z)+E</span>, where <span class="math">Z=(W,\\mathsf{x},u)</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Construction 5 (Polynomial IOP for Idealized Relaxed R1CS)</h6>

    <p class="text-gray-300">Consider an idealized relaxed R1CS statement <span class="math">\\varphi</span> consisting of public parameters <span class="math">(m,n,\\ell)</span>, structure <span class="math">(A,B,C)</span>, and instance <span class="math">(E,u,W,\\mathsf{x})</span>, Without loss of generality, we assume that <span class="math">m</span> and <span class="math">n</span> are powers of <span class="math">2</span> and that <span class="math">m=2\\cdot(\\ell+1)</span>.</p>

    <p class="text-gray-300">Let <span class="math">s=\\log m</span>. We interpret the matrices <span class="math">A,B,C</span> as functions with signature <span class="math">\\{0,1\\}^{\\log m}\\times\\{0,1\\}^{\\log m}\\to\\mathbb{F}</span> in a natural manner. In particular, an input in <span class="math">\\{0,1\\}^{\\log m}\\times\\{0,1\\}^{\\log m}</span> is interpreted as the binary representation of an index <span class="math">(i,j)\\in[m]\\times[m]</span>, where <span class="math">[m]\\coloneqq\\{1,\\ldots,m\\}</span> and the function outputs <span class="math">(i,j)</span>th entry of the matrix. As such, let <span class="math">\\widetilde{A}</span>, <span class="math">\\widetilde{B}</span>, and <span class="math">\\widetilde{C}</span> denote multilinear extensions of <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> interpreted as functions, so they are <span class="math">2\\log m</span>-variate sparse multilinear polynomials of size <span class="math">n</span>. Similarly, we interpret <span class="math">E</span> and <span class="math">W</span> as functions with respective signatures <span class="math">\\{0,1\\}^{\\log m}\\to\\mathbb{F}</span> and <span class="math">\\{0,1\\}^{\\log m-1}\\to\\mathbb{F}</span>. Furthermore, let <span class="math">\\widetilde{E}</span> and <span class="math">\\widetilde{W}</span> denote the multilinear extensions of <span class="math">E</span> and <span class="math">W</span> interpreted as functions, so they are multilinear polynomials in <span class="math">\\log m</span> and <span class="math">\\log m-1</span> variables respectively.</p>

    <p class="text-gray-300">As noted earlier, the verifier has an oracle access to the following polynomials: <span class="math">\\widetilde{A}</span>, <span class="math">\\widetilde{B}</span>, <span class="math">\\widetilde{C}</span>, <span class="math">\\widetilde{E}</span>, and <span class="math">\\widetilde{W}</span>. Additionally, the verifier reads <span class="math">u</span> and <span class="math">\\mathsf{x}</span> in entirety.</p>

    <p class="text-gray-300">Let <span class="math">Z=(W,\\mathsf{x},u)</span>. Similar to how we interpret matrices as functions, we interpret <span class="math">Z</span> and <span class="math">(\\mathsf{x},u)</span> as functions with the following respective signatures: <span class="math">\\{0,1\\}^{s}\\to\\mathbb{F}</span> and <span class="math">\\{0,1\\}^{s-1}\\to\\mathbb{F}</span>. Observe that the MLE <span class="math">\\widetilde{Z}</span> of <span class="math">Z</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\widetilde{Z}(X_{1},\\ldots,X_{s})=(1-X_{1})\\cdot\\widetilde{W}(X_{2},\\ldots,X_{s})+X_{1}\\cdot\\widetilde{(\\mathsf{x},u)}(X_{2},\\ldots,X_{s})</span> (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similar to <em>[41, Theorem 4.1]</em>, checking if <span class="math">\\varphi</span> is satisfiable is equivalent, except for a soundness error of $\\log m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>\\tau\\in\\mathbb{F}^{s}$, to checking if the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">following identity holds:</p>

    <div class="my-4 text-center"><span class="math-block">0 \\stackrel {?} {=} \\sum_ {x \\in \\{0, 1 \\} ^ {s}} \\tilde {\\mathbf {e q}} (\\tau , x) \\cdot F (x), \\tag {2}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F (x) = \\left(\\sum_ {y \\in \\{0, 1 \\} ^ {s}} \\widetilde {A} (x, y) \\cdot \\widetilde {Z} (y)\\right) \\cdot \\left(\\sum_ {y \\in \\{0, 1 \\} ^ {s}} \\widetilde {B} (x, y) \\cdot \\widetilde {Z} (y)\\right) - \\\\ \\left(u \\cdot \\sum_ {y \\in \\{0, 1 \\} ^ {s}} \\widetilde {C} (x, y) \\cdot \\widetilde {Z} (y) + \\widetilde {E} (x)\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and  <span class="math">\\widetilde{\\mathbf{eq}}</span>  is the multilinear extension of  <span class="math">\\mathbf{eq}:\\{0,1\\}^s\\times \\{0,1\\}^s\\to \\mathbb{F}</span>  where  <span class="math">\\mathbf{eq}(x,e) = 1</span>  if  <span class="math">x = e</span>  and 0 otherwise.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That is, if  <span class="math">\\varphi</span>  is satisfiable, then Equation (2) holds with probability 1 over the choice of  <span class="math">\\tau</span> , and if not, then Equation (2) holds with probability at most  $O(\\log m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  over the random choice of  </span>\\tau$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To compute the right-hand side in Equation (2), the prover and the verifier apply the sum-check protocol to the following polynomial:  <span class="math">g(x) \\coloneqq \\widetilde{\\mathbf{eq}}(\\tau, x) \\cdot F(x)</span> . From the verifier's perspective, this reduces the task of computing the right-hand side of Equation (2) to the task of evaluating  <span class="math">g</span>  at a random input  <span class="math">r_x \\in \\mathbb{F}^s</span> . Note that the verifier can locally evaluate  <span class="math">\\widetilde{\\mathbf{eq}}(\\tau, r_x)</span>  in  <span class="math">O(\\log m)</span>  field operations via  <span class="math">\\widetilde{\\mathbf{eq}}(\\tau, r_x) = \\prod_{i=1}^{s} (\\tau_i r_{x,i} + (1 - \\tau_i)(1 - r_{x,i}))</span> . With  <span class="math">\\widetilde{\\mathbf{eq}}(\\tau, r_x)</span>  in hand,  <span class="math">g(r_x)</span>  can be computed in  <span class="math">O(1)</span>  time given the four quantities:  <span class="math">\\sum_{y \\in \\{0,1\\}^s} \\widetilde{A}(r_x, y) \\cdot \\widetilde{Z}(y)</span> ,  <span class="math">\\sum_{y \\in \\{0,1\\}^s} \\widetilde{B}(r_x, y) \\cdot \\widetilde{Z}(y)</span> ,  <span class="math">\\sum_{y \\in \\{0,1\\}^s} \\widetilde{C}(r_x, y) \\cdot \\widetilde{Z}(y)</span> , and  <span class="math">\\widetilde{E}(r_x)</span> .</p>

    <p class="text-gray-300">The last quantity can be computed with a single query to polynomial  <span class="math">\\widetilde{E}</span> . Furthermore, the first three quantities can be computed by applying the sum-check protocol three more times in parallel, once to each of the following three polynomials (using the same random vector of field elements,  <span class="math">r_y \\in \\mathbb{F}^s</span> , in each of the three invocations):  <span class="math">\\widetilde{A}(r_x, y) \\cdot \\widetilde{Z}(y)</span> ,  <span class="math">\\widetilde{B}(r_x, y) \\cdot \\widetilde{Z}(y)</span> , and  <span class="math">\\widetilde{C}(r_x, y) \\cdot \\widetilde{Z}(y)</span> .</p>

    <p class="text-gray-300">To perform the verifier's final check in each of these three invocations of the sum-check protocol, it suffices for the verifier to evaluate each of the above three polynomials at the random vector  <span class="math">r_y</span> , which means it suffices for the verifier to evaluate  <span class="math">\\widetilde{A}(r_x, r_y)</span> ,  <span class="math">\\widetilde{B}(r_x, r_y)</span> ,  <span class="math">\\widetilde{C}(r_x, r_y)</span> , and  <span class="math">\\widetilde{Z}(r_y)</span> . The first three evaluations can be obtained via the verifier's assumed query access to  <span class="math">(\\widetilde{A}, \\widetilde{B}, \\widetilde{C})</span> .  <span class="math">\\widetilde{Z}(r_y)</span>  can be computed (via Equation (1)) from a query to  <span class="math">\\widetilde{W}</span>  and from computing  <span class="math">(\\overline{\\mathbf{x}, u})</span> .</p>

    <p class="text-gray-300">In summary, we have the following polynomial IOP.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}</span>  ..  <span class="math">\\tau \\in_{R}\\mathbb{F}^{s}</span></li>

      <li><span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span> : run the sum-check protocol to reduce the check in Equation (2) to checking if the following hold, where  <span class="math">r_x, r_y</span>  are vectors in  <span class="math">\\mathbb{F}^s</span>  chosen at random by the verifier over the course of the sum-check protocol:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widetilde{A}(r_x, r_y) \\stackrel{?}{=} v_A</span> ,  <span class="math">\\widetilde{B}(r_x, r_y) \\stackrel{?}{=} v_B</span> , and  <span class="math">\\widetilde{C}(r_x, r_y) \\stackrel{?}{=} v_C</span> ;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widetilde{E}(r_{x})\\stackrel{{\\scriptstyle?}}{{=}}v_{E}</span>; and</li>

      <li><span class="math">\\widetilde{Z}(r_{y})\\stackrel{{\\scriptstyle?}}{{=}}v_{Z}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>check if <span class="math">\\widetilde{A}(r_{x},r_{y})\\stackrel{{\\scriptstyle?}}{{=}}v_{A}</span>, <span class="math">\\widetilde{B}(r_{x},r_{y})\\stackrel{{\\scriptstyle?}}{{=}}v_{B}</span>, and <span class="math">\\widetilde{C}(r_{x},r_{y})\\stackrel{{\\scriptstyle?}}{{=}}v_{C}</span>, with a query to <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span> at <span class="math">(r_{x},r_{y})</span>;</li>

      <li>check if <span class="math">\\widetilde{E}(r_{x})\\stackrel{{\\scriptstyle?}}{{=}}v_{E}</span> with an oracle query to <span class="math">\\widetilde{E}</span>; and</li>

      <li>check if <span class="math">\\widetilde{Z}(r_{y})\\stackrel{{\\scriptstyle?}}{{=}}v_{Z}</span> by checking if: <span class="math">v_{Z}=(1-r_{y}[1])\\cdot v_{W}+r_{y}[1]\\cdot\\overbrace{(\\overline{\\mathsf{x},u})}(r_{y}[2..])</span>, where <span class="math">r_{y}[2..]</span> refers to a slice of <span class="math">r_{y}</span> without the first element of <span class="math">r_{y}</span>, and <span class="math">v_{W}\\leftarrow\\widetilde{W}(r_{y}[2..])</span> via an oracle query (see Equation (1)).</li>

    </ul>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction 5 is a polynomial IOP for idealized relaxed R1CS defined over a finite field <span class="math">\\mathbb{F}</span>, with the following parameters, where <span class="math">m</span> denotes the dimension of the R1CS matrices, and <span class="math">n</span> denotes the number of non-zero entries in the matrices: Soundness error is $O(\\log m)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; round complexity is </span>O(\\log m)<span class="math">; The verifier has query access to </span>2\\log m<span class="math">-variate multilinear polynomials </span>\\widetilde{A},\\widetilde{B},\\widetilde{C}<span class="math"> in the structure, and </span>(\\log m)<span class="math">-variate multilinear polynomial </span>\\widetilde{E}<span class="math">, and </span>(\\log m-1)<span class="math">-variate multilinear polynomial </span>\\widetilde{W}<span class="math"> in the instance; the verifier issues a single query to polynomials </span>\\widetilde{A}<span class="math">, </span>\\widetilde{B}<span class="math">, </span>\\widetilde{C}<span class="math">, and </span>\\widetilde{W}<span class="math">, </span>\\widetilde{E}<span class="math">, and otherwise performs </span>O(\\log m)<span class="math"> operations over </span>\\mathbb{F}<span class="math">; the prover performs </span>O(n)<span class="math"> operations over </span>\\mathbb{F}<span class="math"> to compute its messages in the polynomial IOP and to respond to the verifier’s queries to </span>(\\widetilde{W},\\widetilde{E},\\widetilde{A},\\widetilde{B},\\widetilde{C})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Perfect completeness follows from perfect completeness of the sum-check protocol and the fact that Equation (2) holds with probability 1 over the choice of <span class="math">\\tau</span> if <span class="math">\\varphi</span> is satisfiable. Applying a standard union bound to the soundness error introduced by probabilistic check in Equation (2) with the soundness error of the sum-check protocol <em>[38]</em>, we conclude that the soundness error for the depicted polynomial IOP as at most $O(\\log m)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The sum-check protocol is applied four times (although three of the invocations occur in parallel and in practice combined into one <em>[41]</em>). In each invocation, the polynomial to which the sum-check protocol is applied has degree at most 3 in each variable, and the number of variables is <span class="math">s=\\log m</span>. Hence, the round complexity of the polynomial IOP is <span class="math">O(\\log m)</span>. Since each polynomial has degree at most 3 in each variable, the total communication cost is <span class="math">O(\\log m)</span> field elements.</p>

    <p class="text-gray-300">The claimed verifier runtime is immediate from the verifier’s runtime in the sum-check protocol, and the fact that <span class="math">\\widehat{\\mathsf{eq}}</span> can be evaluated at any input <span class="math">(\\tau,r_{x})\\in\\mathbb{F}^{2s}</span> in <span class="math">O(\\log m)</span> field operations. As in Spartan <em>[41]</em>, the prover’s work in the polynomial IOP in <span class="math">O(n)</span> operations over <span class="math">\\mathbb{F}</span> using prior techniques <em>[45, 51]</em>. ∎</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">6.3 Compiling Polynomial IOPs to zkSNARKs</h3>

    <p class="text-gray-300">As in prior works <em>[19, 22, 41]</em>, we compile our polynomial IOP into a zkSNARK using a polynomial commitment scheme <em>[32]</em> and the Fiat-Shamir transform <em>[25]</em>.</p>

    <p class="text-gray-300">Interpreting commitments to vectors as polynomial commitments. It is well known that commitments to <span class="math">m</span>-sized vectors over <span class="math">\\mathbb{F}</span> are commitments to <span class="math">\\log m</span>-variate multilinear polynomials represented with evaluations over <span class="math">\\{0,1\\}^{m}</span> <em>[35, 41, 49, 52]</em>. Furthermore, there is a polynomial commitment scheme for <span class="math">\\log m</span>-variate multilinear polynomials if there exists an argument protocol to prove an inner product computation between a committed vector and an <span class="math">m</span>-sized public vector <span class="math">((r_{1},1-r_{1})\\otimes\\ldots\\otimes(r_{\\log m},1-r_{\\log m})),</span> where <span class="math">r\\in\\mathbb{F}^{\\log m}</span> is an evaluation point. There are two candidate constructions in the literature. Note that the primary difference between two schemes is in the verifier’s time.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>. If the commitment scheme for vectors over <span class="math">\\mathbb{F}</span> is Pedersen’s commitments (Construction 6), as in prior work <em>[49]</em>, Bulletproofs <em>[16]</em> provides a suitable inner product argument protocol. The polynomial commitment scheme here achieves the following efficiency characteristics, assuming the hardness of the discrete logarithm problem. For a <span class="math">\\log m</span>-variate multilinear polynomial, committing takes <span class="math">O_{\\lambda}(m)</span> time to produce an <span class="math">O_{\\lambda}(1)</span>-sized commitment; the prover incurs <span class="math">O_{\\lambda}(m)</span> costs to produce an evaluation proof of size <span class="math">O_{\\lambda}(\\log m)</span> that can be verified in <span class="math">O_{\\lambda}(m)</span>. Note that <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span> is a special case of Hyrax’s polynomial commitment scheme <em>[49]</em>.</li>

      <li><span class="math">\\mathsf{PC}_{\\mathsf{Dory}}</span>. If vectors over <span class="math">\\mathbb{F}</span> are committed with a two-tiered “matrix” commitment (see for example, <em>[20, 35]</em>), which provides <span class="math">O_{\\lambda}(1)</span>-sized commitments to <span class="math">m</span>-sized vectors under the SXDH assumption. With this commitment scheme, Dory <em>[35]</em> provides the necessary inner product argument. The polynomial commitment here achieves the following efficiency characteristics, assuming the hardness of SXDH. For a <span class="math">\\log m</span>-variate multilinear polynomial, committing takes <span class="math">O_{\\lambda}(m)</span> time to produce an <span class="math">O_{\\lambda}(1)</span>-sized commitment; the prover incurs <span class="math">O_{\\lambda}(m)</span> costs to produce an evaluation proof of size <span class="math">O_{\\lambda}(\\log m)</span> that can be verified in <span class="math">O_{\\lambda}(\\log m)</span>.</li>

    </ol>

    <p class="text-gray-300">Polynomial commitments for sparse multilinear polynomials. In our constructions below, we require polynomial commitment schemes that can efficiently handle sparse multilinear polynomials. Spartan <em>[41, §7]</em> (and its optimization <em>[44, §6]</em>) provides a generic compiler to transform existing polynomial commitment schemes for multilinear polynomials into those that can efficiently handle sparse multilinear polynomials. Specifically, we apply <em>[37, Theorem 5]</em>) (which captures Spartan’s compiler in a generic manner) to <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span> and <span class="math">\\mathsf{PC}_{\\mathsf{Dory}}</span> to obtain their variants that can efficiently handle sparse multilinear polynomials; we refer to them as “Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>” and “Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{Dory}}</span>” respectively.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 6 (A zkSNARK from <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>).</h6>

    <p class="text-gray-300">Assuming the hardness of the discrete logarithm problem, there exists a zkSNARK in the random oracle model for committed relaxed R1CS with the following efficiency characteristics, where <span class="math">m</span> denotes the dimensions of R1CS matrices and <span class="math">n</span> denotes the number of non-zero entries in the matrices: The encoder runs in time <span class="math">O_{\\lambda}(n)</span>; The prover runs in time <span class="math">O_{\\lambda}(n)</span>; The proof length is <span class="math">O_{\\lambda}(\\log n)</span>; and the verifier runs in time <span class="math">O_{\\lambda}(n)</span>.</p>

    <p class="text-gray-300">roof.</p>

    <p class="text-gray-300">For R1CS structure <span class="math">(A,B,C)</span>, we first have the encoder directly provide <span class="math">(\\widetilde{A},\\widetilde{B},\\widetilde{C})</span> in the prover key, and additionally provide sparse polynomial commitments to <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span> using Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span> in both the prover and verifier keys. Next, we apply the compiler of <em>[19]</em> using <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span> to the polynomial IOP from Construction 5. At a high level, this replaces all of the oracles provided to the verifier with <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span> commitments, which the prover and verifier then use to simulate ideal queries to a committed oracle. By <em>[19, Theorem 6]</em> this provides a public-coin honest-verifier zero-knowledge interactive argument of knowledge. In particular, we can treat the resulting protocol as an argument for committed relaxed R1CS because the verifier is now provided with (polynomial) commitments to <span class="math">E</span> and <span class="math">W</span>. Applying the Fiat-Shamir transform <em>[25]</em> achieves non-interactivity and zero-knowledge in the random oracle model.</p>

    <p class="text-gray-300">The claimed efficiency follows from the efficiency of the polynomial IOP, <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>, and Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>. In more detail, using Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>, the encoder takes <span class="math">O_{\\lambda}(n)</span> time to create commitments <span class="math">2\\log m</span>-variate sparse multilinear polynomials <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span>. The prover’s costs in the polynomial IOP is <span class="math">O(n)</span>. Furthermore, proving the evaluations of two <span class="math">O(\\log m)</span>-variate multilinear polynomials using <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>, it takes <span class="math">O_{\\lambda}(m)</span> time. And, to prove the evaluations of three <span class="math">2\\log m</span>-variate sparse multilinear polynomials of size <span class="math">n</span>, using Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>, it takes <span class="math">O_{\\lambda}(n)</span> time. In total, the prover time is <span class="math">O_{\\lambda}(n)</span>. The proof length in the polynomial IOP is <span class="math">O(\\log m)</span>, and the proof sizes in the polynomial evaluation proofs is <span class="math">O_{\\lambda}(\\log n)</span>, so the proof length is <span class="math">O_{\\lambda}(\\log n)</span>. The verifier’s time in the polynomial IOP is <span class="math">O(\\log m)</span>. In addition, it verifies five polynomial evaluations, which costs <span class="math">O_{\\lambda}(n)</span> time: the two polynomial in the instance take <span class="math">O_{\\lambda}(m)</span> time using <span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>, and the three polynomials in the structure takes <span class="math">O_{\\lambda}(n)</span> time using Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>. So, in total, the verifier time is <span class="math">O_{\\lambda}(n)</span>. ∎</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Corollary 1 (A zkSNARK from <span class="math">\\mathsf{PC}_{\\mathsf{Oory}}</span>).</h6>

    <p class="text-gray-300">Assuming the hardness of the SXDH problem, there exists a zkSNARK in the random oracle model for committed relaxed R1CS with the following efficiency characteristics, where <span class="math">m</span> denotes the dimensions of R1CS matrices and <span class="math">n</span> denotes the number of non-zero entries in the matrices: The encoder runs in time <span class="math">O_{\\lambda}(n)</span>; The prover runs in time <span class="math">O_{\\lambda}(n)</span>; The proof length is <span class="math">O_{\\lambda}(\\log n)</span>; and the verifier runs in time <span class="math">O_{\\lambda}(\\log n)</span>.</p>

    <h2 id="sec-40" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Arasu Arun, Weidong Cui, Justin Drake, Bryan Parno, and Justin Thaler for various conversations and helpful comments on a prior version of this paper. We thank Andy Polyakov and Kelly Olson for help with pasta-msm. We thank Chhi’mèd Künzang for helpful conversations and for PRs to the Nova repository, including an adapter that enables transforming circuits written with bellperson to a format that Nova uses. We thank Wilson Nguyen for pointing out a discrepancy in the zero-knowledge property proven in a prior version of Appendix D. Abhiram Kothapalli (while at Carnegie Mellon University) was supported by a gift from Bosch, NSF Grant No. 1801369, and by the</p>

    <p class="text-gray-300">CONIX Research Center, one of six centers in JUMP, a Semiconductor Research Corporation (SRC) program sponsored by DARPA.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] bellperson. https://crates.io/crates/bellperson</li>

      <li>[2] neptune. https://crates.io/crates/neptune</li>

      <li>[3] Nova: Recursive SNARKs without trusted setup. https://github.com/Microsoft/Nova</li>

      <li>[4] Pasta curves. https://crates.io/crates/pasta_curves</li>

      <li>[5] pasta-msm. https://crates.io/crates/pasta-msm</li>

      <li>[6] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive Oracle Proofs. In: TCC (2016)</li>

      <li>[7] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. In: CRYPTO (2014)</li>

      <li>[8] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In: ITCS (2012)</li>

      <li>[9] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and bootstrapping for SNARKs and proof-carrying data. In: STOC (2013)</li>

      <li>[10] Boneh, D., Bünz, B., Fisch, B.: A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712 (2018)</li>

      <li>[11] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Halo Infinite: Recursive zk-SNARKs from any Additive Polynomial Commitment Scheme. Cryptology ePrint Archive, Report 2020/1536 (2020)</li>

      <li>[12] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: EUROCRYPT (2016)</li>

      <li>[13] Bowe, S., Grigg, J., Hopwood, D.: Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021 (2019)</li>

      <li>[14] Bowe, S., Grigg, J., Hopwood, D.: Halo2 (2020), https://github.com/zcash/halo2</li>

      <li>[15] Brakerski, Z., Holmgren, J., Kalai, Y.T.: Non-interactive delegation and batch np verification from standard computational assumptions. In: STOC. pp. 474–482 (2017)</li>

      <li>[16] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: S&P (2018)</li>

      <li>[17] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. Cryptology ePrint Archive, Report 2020/1618 (2020)</li>

      <li>[18] Bünz, B., Chiesa, A., Mishra, P., Spooner, N.: Proof-carrying data from accumulation schemes. In: TCC (2020)</li>

      <li>[19] Bünz, B., Fisch, B., Szepieniec, A.: Transparent SNARKs from DARK compilers. In: EUROCRYPT (2020)</li>

      <li>[20] Bünz, B., Maller, M., Mishra, P., Vesely, N.: Proofs for inner pairing products and applications. Cryptology ePrint Archive, Report 2019/1177 (2019)</li>

    </ul>

    <p class="text-gray-300">[21] Chen, W., Chiesa, A., Dauterman, E., Ward, N.P.: Reducing participation costs via incremental verification for ledger systems. Cryptology ePrint Archive, Report 2020/1522 (2020)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Pre-processing zkSNARKs with universal and updatable SRS. In: EUROCRYPT (2020)</li>

      <li>[23] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: EUROCRYPT (2020)</li>

      <li>[24] Drucker, A.: New limits to classical and quantum instance compression. SIAM Journal of Computing 44(5), 144–3–1479 (2015)</li>

      <li>[25] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: CRYPTO. pp. 186–194 (1986)</li>

      <li>[26] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EUROCRYPT (2013)</li>

      <li>[27] Gentry, C., Wichs, D.: Separating succinct non-interactive arguments from all falsifiable assumptions. In: STOC. pp. 99–108 (2011)</li>

      <li>[28] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof-systems. In: STOC (1985)</li>

      <li>[29] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. Cryptology ePrint Archive, Paper 2019/458 (2019)</li>

      <li>[30] Groth, J.: On the size of pairing-based non-interactive arguments. In: EUROCRYPT (2016)</li>

      <li>[31] Harnik, D., Naor, M.: On the compressibility of <span class="math">\\mathcal{NP}</span> instances and cryptographic applications. SIAM Journal of Computing 39(5), 1667–1713 (2010)</li>

      <li>[32] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: ASIACRYPT. pp. 177–194 (2010)</li>

      <li>[33] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: STOC (1992)</li>

      <li>[34] Labs, O.: Mina cryptocurrency (2020), https://minaprotocol.com</li>

      <li>[35] Lee, J.: Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. Cryptology ePrint Archive, Report 2020/1274 (2020)</li>

      <li>[36] Lee, J., Nikitin, K., Setty, S.: Replicated state machines without replicated execution. In: S&P (2020)</li>

      <li>[37] Lee, J., Setty, S., Thaler, J., Wahby, R.: Linear-time zero-knowledge SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/030 (2021)</li>

      <li>[38] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. In: FOCS (Oct 1990)</li>

      <li>[39] Micali, S.: CS proofs. In: FOCS (1994)</li>

      <li>[40] Reingold, O., Rothblum, G.N., Rothblum, R.D.: Constant-round interactive proofs for delegating computation. In: STOC. pp. 49–62 (2016)</li>

      <li>[41] Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: CRYPTO (2020)</li>

      <li>[42] Setty, S., Angel, S., Gupta, T., Lee, J.: Proving the correct execution of concurrent services in zero-knowledge. In: OSDI (Oct 2018)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[43] Setty, S., Braun, B., Vu, V., Blumberg, A.J., Parno, B., Walfish, M.: Resolving the conflict between generality and plausibility in verified computation. In: EuroSys (Apr 2013)</li>

      <li>[44] Setty, S., Lee, J.: Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Report 2020/1275 (2020)</li>

      <li>[45] Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: CRYPTO (2013)</li>

      <li>[46] Thaler, J.: Proofs, arguments, and zero-knowledge. http://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.html (2020)</li>

      <li>[47] Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: TCC. pp. 552–576 (2008)</li>

      <li>[48] Wahby, R.S., Ji, Y., Blumberg, A.J., Shelat, A., Thaler, J., Walfish, M., Wies, T.: Full accounting for verifiable outsourcing. In: CCS (2017)</li>

      <li>[49] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: S&P (2018)</li>

      <li>[50] Wesolowski, B.: Efficient verifiable delay functions. In: EUROCRYPT. pp. 379–407 (2019)</li>

      <li>[51] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: CRYPTO (2019)</li>

      <li>[52] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: S&P (2017)</li>

    </ul>

    <p class="text-gray-300">Supplementary Materials</p>

    <h2 id="sec-41" class="text-2xl font-bold">Appendix A Additional Related Work</h2>

    <p class="text-gray-300">A folding scheme is reminiscent of the technique used in protocols such as Bulletproofs <em>[16]</em>, where the prover splits an <span class="math">N</span>-sized inner product instance into two <span class="math">N/2</span>-sized inner product instances, and then the prover and the verifier interactively combine the two <span class="math">N/2</span>-sized instances into a single <span class="math">N/2</span>-sized instance. A folding scheme differs from this technique in that it targets folding NP relations. Furthermore, our folding scheme for relaxed R1CS folds arbitrary NP instances.</p>

    <p class="text-gray-300">A folding scheme is also reminiscent of the sum-check protocol <em>[38]</em> applied to layered circuits <em>[48, 49]</em>, where the prover and the verifier interactively combine <span class="math">\\beta\\geq 2</span> instances of depth-1 circuit satisfiability into a single depth-1 circuit satisfiability instance, and the combined instance is proven using additional invocations of the sum-check protocol. Once the protocol combines <span class="math">\\beta</span> instances of depth-1 circuit satisfiability into a single depth-1 circuit satisfiability instance, it is not entirely clear how to fold additional circuit satisfiability instances into a single running instance. Whereas, with a folding scheme, the prover and the verifier can continually fold NP instances into a single running instance.</p>

    <p class="text-gray-300">Finally, a folding scheme is also related to other prior notions such as “batch verification” <em>[15, 40]</em> and “instance compression” <em>[24, 31]</em>. Given <span class="math">\\beta</span> NP instances, batch verification protocols aim to produce a succinct proof that all <span class="math">\\beta</span> instances are satisfiable. In contrast, a folding scheme’s goal is to transform the satisfiability of two NP instances into a single NP-instance. (AND)-instance compression schemes efficiently compress <span class="math">\\beta</span> SAT instances into a single short string that retains information about whether all instances are satisfiable. A folding scheme differs from this notion in that compression is aided by an (untrusted) prover who knows (purported) witnesses to the original <span class="math">\\beta</span> instances. Furthermore, unlike instance compression, a folding scheme can be interactive.</p>

    <h2 id="sec-42" class="text-2xl font-bold">Appendix B Proof of Theorem 3 (A Folding Scheme for Committed Relaxed R1CS)</h2>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 6 (Completeness)</h6>

    <p class="text-gray-300">Construction 1 is a folding scheme for committed relaxed R1CS with perfect completeness.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathsf{F}</span>, a succinct, hiding, and homomorphic commitment scheme <span class="math">\\mathsf{Com}</span> over <span class="math">\\mathsf{F}</span>, and public parameters consisting of size bounds <span class="math">m,n,\\ell\\in\\mathsf{N}</span> where <span class="math">m&gt;\\ell</span>, and commitment parameters <span class="math">\\mathsf{pp}_{W}</span> and <span class="math">\\mathsf{pp}_{E}</span> for vectors of size <span class="math">m</span> and <span class="math">m-\\ell-1</span> respectively sampled by the generator. Consider an adversarially chosen R1CS structure <span class="math">(A,B,C)\\in\\mathsf{F}^{m\\times m}</span> and two committed relaxed R1CS instances</p>

    <p class="text-gray-300"><span class="math">\\varphi_{1}=(\\overline{E}_{1},u_{1},\\overline{W}_{1},\\mathsf{x}_{1})\\quad\\text{and}\\quad\\varphi_{2}=(\\overline{E}_{2},u_{2},\\overline{W}_{2},\\mathsf{x}_{2}).</span></p>

    <p class="text-gray-300">Suppose that the prover <span class="math">\\mathcal{P}</span>, in addition to the two instances, holds <em>satisfying</em> witnesses to both instances, <span class="math">(E_{1},r_{E_{1}},W_{1},r_{W_{1}})</span> and <span class="math">(E_{2},r_{E_{2}},W_{2},r_{W_{2}})</span>. Let <span class="math">Z_{1}=(W_{1},\\mathsf{x}_{1},u_{1})</span> and <span class="math">Z_{2}=(W_{2},\\mathsf{x}_{2},u_{2})</span>.</p>

    <p class="text-gray-300">Now suppose that <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> compute a folded instance <span class="math">\\varphi=(\\overline{E},u,\\overline{W},\\mathsf{x})</span>, and suppose that <span class="math">\\mathcal{P}</span> computes a folded witness <span class="math">(E,r_{E},W,r_{W})</span>, To prove completeness, we must show that <span class="math">(E,W)</span> is a satisfying witness for instance <span class="math">\\varphi</span>. Let <span class="math">Z=(W,x,u)</span>.</p>

    <p class="text-gray-300">For <span class="math">(E,W)</span> to be a satisfying witness, we must have the following:</p>

    <p class="text-gray-300"><span class="math">AZ\\circ BZ=u\\cdot CZ+E</span> (3)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\overline{E}</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{E},E,r_{E})</span> (4) <span class="math">\\overline{W}</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{W},W,r_{W})</span> (5)</p>

    <p class="text-gray-300">It is easy to see that Equations (4) and (5) hold from the additive homomorphism of the commitment scheme.</p>

    <p class="text-gray-300">Thus, we focus on proving that Equation (3) holds. By construction, for Equation (3) to hold, we must have for <span class="math">r\\in_{R}\\mathbb{F}</span></p>

    <p class="text-gray-300"><span class="math">A(Z_{1}+r\\cdot Z_{2})\\circ B(Z_{1}+r\\cdot Z_{2})=(u_{1}+r\\cdot u_{2})\\cdot C(Z_{1}+r\\cdot Z_{2})+E.</span></p>

    <p class="text-gray-300">Distributing, we must have</p>

    <p class="text-gray-300"><span class="math">AZ_{1}\\circ BZ_{1}+r(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1})+r^{2}(AZ_{2}\\circ BZ_{2})=</span> <span class="math">u_{1}\\cdot CZ_{1}+r(u_{1}\\cdot CZ_{2}+u_{2}CZ_{1})+r^{2}\\cdot u_{2}\\cdot CZ_{2}+E.</span></p>

    <p class="text-gray-300">Aggregating by powers of <span class="math">r</span>, we must have</p>

    <p class="text-gray-300"><span class="math">(AZ_{1}\\circ BZ_{1}-u_{1}\\cdot CZ_{1})+</span> <span class="math">r(AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1}-u_{1}\\cdot CZ_{2}-u_{2}CZ_{1})+</span> (6) <span class="math">r^{2}(AZ_{2}\\circ BZ_{2}-u_{2}\\cdot CZ_{2})</span> <span class="math">=</span> <span class="math">E.</span></p>

    <p class="text-gray-300">However, because <span class="math">W_{1}</span> and <span class="math">W_{2}</span> are satisfying witnesses, we have</p>

    <p class="text-gray-300"><span class="math">AZ_{1}\\circ BZ_{1}-u_{1}\\cdot CZ_{1}</span> <span class="math">=E_{1}</span> <span class="math">AZ_{2}\\circ AZ_{2}-u_{2}\\cdot CZ_{2}</span> <span class="math">=E_{2}.</span></p>

    <p class="text-gray-300">Additionally, by construction we have</p>

    <p class="text-gray-300"><span class="math">AZ_{1}\\circ BZ_{2}+AZ_{2}\\circ BZ_{1}-u_{1}\\cdot CZ_{2}-u_{2}\\cdot CZ_{1}=T.</span></p>

    <p class="text-gray-300">Thus, by substitution, for Equation (6) to hold we must have</p>

    <p class="text-gray-300"><span class="math">E_{1}+r\\cdot T+r^{2}\\cdot E_{2}=E,</span></p>

    <p class="text-gray-300">which holds by construction.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 7 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 1 is a knowledge sound folding scheme for committed relaxed R1CS.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span>, a succinct, hiding, and homomorphic commitment scheme <span class="math">\\mathsf{Com}</span> over <span class="math">\\mathbb{F}</span>, and public parameters consisting of size bounds <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where <span class="math">m&gt;\\ell</span>, and commitment parameters <span class="math">\\mathsf{pp}_{W}</span> and <span class="math">\\mathsf{pp}_{E}</span> for vectors of size <span class="math">m</span> and <span class="math">m-\\ell-1</span> respectively sampled by the generator. Consider an adversarially chosen R1CS structure <span class="math">(A,B,C)\\in\\mathbb{F}^{m\\times m}</span> and two committed relaxed R1CS instances</p>

    <p class="text-gray-300"><span class="math">\\varphi_{1}=(\\overline{E}_{1},u_{1},\\overline{W}_{1},\\mathsf{x}_{1})\\quad\\text{and}\\quad\\varphi_{2}=(\\overline{E}_{2},u_{2},\\overline{W}_{2},\\mathsf{x}_{2}).</span></p>

    <p class="text-gray-300">We prove knowledge soundness via the forking lemma (Lemma 1). That is, we prove that there exists a PPT algorithm <span class="math">\\mathcal{X}</span> such that when given public parameters <span class="math">\\mathsf{pp}</span>, structure <span class="math">(A,B,C)</span>, and a tree of accepting transcripts and the corresponding folded instance-witness pairs outputs a satisfying witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">In more detail, suppose <span class="math">\\mathcal{X}</span> is provided three transcripts <span class="math">(\\tau_{1},\\tau_{2},\\tau_{3})</span> with the same initial commitment <span class="math">\\overline{T}</span> from the prover. Note that a transcript <span class="math">\\tau_{i}</span> for <span class="math">i\\in\\{1,2,3\\}</span> additionally comes attached with an accepting witness <span class="math">\\tau_{i}.(W,E,r_{W},r_{E})</span> and the verifier’s randomness <span class="math">\\tau_{i}.r</span>. Interpolating points <span class="math">(\\tau_{1}.r,\\tau_{1}.W)</span> and <span class="math">(\\tau_{2}.r,\\tau_{2}.W)</span>, <span class="math">\\mathcal{X}</span> retrieves <span class="math">(W_{1},W_{2})</span> such that</p>

    <p class="text-gray-300"><span class="math">W_{1}+\\tau_{i}.r\\cdot W_{2}=\\tau_{i}.W</span> (7)</p>

    <p class="text-gray-300">for <span class="math">i\\in\\{1,2\\}</span>. Similarly interpolating points <span class="math">(\\tau_{1}.r,\\tau_{1}.E)</span>, <span class="math">(\\tau_{2}.r,\\tau_{2}.E)</span>, <span class="math">(\\tau_{3}.r,\\tau_{3}.E)</span>, <span class="math">\\mathcal{X}</span> retrieves <span class="math">(E_{1},E_{2})</span> and a cross-term <span class="math">T</span> such that</p>

    <p class="text-gray-300"><span class="math">E_{1}+\\tau_{i}.r\\cdot T+\\tau_{i}.r^{2}\\cdot E_{2}=\\tau_{i}.E</span> (8)</p>

    <p class="text-gray-300">for <span class="math">i\\in\\{1,2,3\\}</span>. Using the same approach, <span class="math">\\mathcal{X}</span> can interpolate for <span class="math">r_{W_{1}},r_{W_{2}}</span> and <span class="math">r_{E_{1}},r_{T},r_{E_{2}}</span>. We must argue that <span class="math">(W_{1},E_{1},r_{W_{1}},r_{E_{1}})</span> and <span class="math">(W_{2},E_{2},r_{W_{2}},r_{E_{2}})</span> are indeed satisfying witnesses for <span class="math">\\varphi_{1}</span> and <span class="math">\\varphi_{2}</span> respectively.</p>

    <p class="text-gray-300">We first show that the retrieved witness elements are valid openings to the corresponding commitments in the instance. For <span class="math">i\\in\\{1,2\\}</span>, because <span class="math">\\tau_{i}.W,\\tau_{i}.r_{W}</span> is part of a satisfying witness, by construction,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp}_{W},W_{1},r_{W_{1}})+\\tau_{i}.r\\cdot\\mathsf{Com}(\\mathsf{pp}_{W},W_{2},r_{W_{2}})</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{W},W_{1}+\\tau_{i}.r\\cdot W_{2},r_{W_{1}}+\\tau_{i}.r\\cdot r_{W_{2}})</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{W},\\tau_{i}.W,\\tau_{i}.r_{W})</span> <span class="math">=\\overline{W}_{1}+\\tau_{i}.r\\cdot\\overline{W}_{2}.</span></p>

    <p class="text-gray-300">Interpolating, we must have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp}_{W},W_{1},r_{W_{1}})</span> <span class="math">=\\overline{W}_{1}</span> (9) <span class="math">\\mathsf{Com}(\\mathsf{pp}_{W},W_{2},r_{W_{2}})</span> <span class="math">=\\overline{W}_{2}.</span> (10)</p>

    <p class="text-gray-300">Similarly, for <span class="math">i\\in\\{1,2,3\\}</span>, because <span class="math">\\tau_{i}.E,\\tau_{i}.r_{E}</span> is part of a satisfying witness, by construction, we must have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp}_{E},E_{1},r_{E_{1}})+\\tau_{i}.r\\cdot\\mathsf{Com}(\\mathsf{pp}_{E},T,r_{T})+\\tau_{i}.r^{2}\\cdot\\mathsf{Com}(\\mathsf{pp}_{E},E_{2},r_{E_{2}})</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{E},E_{1}+\\tau_{i}.r\\cdot T+\\tau_{i}.r^{2}\\cdot E_{2},r_{E_{1}}+\\tau_{i}.r\\cdot r_{T}+\\tau_{i}.r^{2}\\cdot r_{E_{2}})</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{E},\\tau_{i}.E,\\tau_{i}.r_{E})</span> <span class="math">=\\overline{E}_{1}+\\tau_{i}.r\\cdot\\overline{T}+\\tau_{i}.r^{2}\\cdot\\overline{E}_{2}.</span></p>

    <p class="text-gray-300">Interpolating, we must have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp}_{E},E_{1},r_{E_{1}})</span> <span class="math">=\\overline{E}_{1}</span> <span class="math">\\mathsf{Com}(\\mathsf{pp}_{E},E_{2},r_{E_{2}})</span> <span class="math">=\\overline{E}_{2}</span></p>

    <p class="text-gray-300">Next, we must show that <span class="math">(W_{1},E_{1})</span> and <span class="math">(W_{2},E_{2})</span> satisfy the relaxed R1CS relation. To show this, we must first argue that Equation (7) holds for <span class="math">i=3</span> as well (i.e., <span class="math">W_{1}+\\tau_{3}.r\\cdot W_{2}=\\tau_{3}.W</span>). Indeed, Equations (9) and (10) imply that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp}_{W},W_{1}+\\tau_{3}.r\\cdot W_{2},r_{W_{1}}+\\tau_{3}.r\\cdot r_{W_{2}})</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{W},W_{1},r_{W_{1}})+\\tau_{3}.r\\cdot\\mathsf{Com}(\\mathsf{pp}_{W},W_{2},r_{W_{2}})</span> <span class="math">=\\overline{W}_{1}+\\tau_{3}.r\\cdot\\overline{W}_{2}</span> <span class="math">=\\mathsf{Com}(\\mathsf{pp}_{W},\\tau_{3}.W,\\tau_{3}.W)</span></p>

    <p class="text-gray-300">Thus, by the binding property of <span class="math">\\mathsf{Com}</span>, we must additionally have that</p>

    <p class="text-gray-300"><span class="math">W_{1}+\\tau_{3}.r\\cdot W_{2}=\\tau_{3}.W</span> (11)</p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Because <span class="math">(\\tau_{i}.W,\\tau_{i}.E)</span> is part of a satisfying witness, for <span class="math">i\\in\\{1,2,3\\}</span> we have</p>

    <p class="text-gray-300"><span class="math">A(\\tau_{i}.Z)\\circ B(\\tau_{i}.Z)=u\\cdot C(\\tau_{i}.Z)+\\tau_{i}.E</span></p>

    <p class="text-gray-300">where <span class="math">\\tau_{i}.Z=(\\tau_{i}.W,\\tau_{i}.x,\\tau_{i}.u)</span>. However, by Equations (7), (8), and (11) for <span class="math">i\\in\\{1,2,3\\}</span>, this implies that with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300"><span class="math">A(Z_{1}+\\tau_{i}.r\\cdot Z_{2})\\circ B(Z_{1}+\\tau_{i}.r\\cdot Z_{2})=</span> <span class="math">(u_{1}+\\tau_{i}.r\\cdot u_{2})\\cdot C(Z_{1}+\\tau_{i}.r\\cdot Z_{2})+(E_{1}+\\tau_{i}.r\\cdot T+\\tau_{i}.r^{2}\\cdot E_{2})</span></p>

    <p class="text-gray-300">where <span class="math">Z_{1}=(W_{1},x_{1},u_{1})</span> and <span class="math">Z_{2}=(W_{2},x_{2},u_{2})</span>. Expanding and interpolating, we have that</p>

    <p class="text-gray-300"><span class="math">AZ_{1}\\circ BZ_{1}</span> <span class="math">=u_{1}\\cdot CZ_{1}+E_{1}</span> <span class="math">AZ_{2}\\circ BZ_{2}</span> <span class="math">=u_{2}\\cdot CZ_{2}+E_{2}</span></p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. Thus, <span class="math">(W_{1},E_{1},r_{W_{1}},r_{E_{1}})</span> and <span class="math">(W_{2},E_{2},r_{W_{2}},r_{E_{2}})</span> meet all the requirements to be satisfying witnesses for <span class="math">\\varphi_{1}</span> and <span class="math">\\varphi_{2}</span> respectively with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 8 (Zero-Knowledge).</h6>

    <p class="text-gray-300">Construction 1 is a zero-knowledge folding scheme for committed relaxed R1CS.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Intuitively, zero-knowledge holds because the prover only sends a single hiding commitment. More formally, the simulator <span class="math">\\mathcal{S}</span> samples random <span class="math">T\\in\\mathds{F}^{m}</span> and <span class="math">r\\in\\mathds{F}</span> and computes <span class="math">\\overline{T}=\\mathsf{Com}(\\mathsf{pp}_{E},T,r)</span>. Next, <span class="math">\\mathcal{S}</span> derives the verifier’s challenge, <span class="math">r</span>, using <span class="math">\\rho</span> and outputs <span class="math">\\mathsf{tr}=(\\overline{T},r)</span>. (Perfect) zero-knowledge holds from the (perfect) hiding property of the underlying commitment scheme. ∎</p>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix C Proofs for IVC from Folding Schemes (Construction 3)</h2>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 9 (IVC Completeness).</h6>

    <p class="text-gray-300">Construction 3 is an IVC scheme that satisfies perfect completeness.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider <span class="math">(F,i+1,z_{0},z_{i+1})</span> and the corresponding inputs <span class="math">(z_{i},\\omega_{i})</span> such that</p>

    <p class="text-gray-300"><span class="math">z_{i+1}=F(z_{i},\\omega_{i})</span></p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span>, and let <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},F)</span>. Now consider a proof <span class="math">\\Pi_{i}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1</span></p>

    <p class="text-gray-300">We must show that given</p>

    <p class="text-gray-300"><span class="math">\\Pi_{i+1}\\leftarrow\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\omega_{i},\\Pi_{i})</span></p>

    <p class="text-gray-300">that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i+1,z_{0},z_{i+1},\\Pi_{i+1})=1</span></p>

    <p class="text-gray-300">with probability <span class="math">1</span>. We show this by induction on <span class="math">i</span>.</p>

    <p class="text-gray-300">Base Case <span class="math">(i=0)</span>: Suppose the prover is provided <span class="math">\\Pi_{0}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},0,z_{0},z_{0},\\Pi_{0})=1.</span></p>

    <p class="text-gray-300">By the base case of <span class="math">\\mathcal{P}</span> and <span class="math">F^{\\prime}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pi_{1}=((\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp}),(\\mathsf{u}_{1},\\mathsf{w}_{1}),r_{1})</span></p>

    <p class="text-gray-300">for some <span class="math">(\\mathsf{u}_{1},\\mathsf{w}_{1})</span>. By definition, the instance-witness pair <span class="math">(\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp})</span> satisfies <span class="math">F^{\\prime}</span>. Moreover, by construction, <span class="math">(\\mathsf{u}_{1},\\mathsf{w}_{1})</span> must also be satisfying. Additionally, by the construction of <span class="math">F^{\\prime}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{1}.\\mathsf{x}=\\mathsf{hash}(\\mathsf{vk},1,z_{0},F(z_{0},w_{0}),\\mathsf{u}_{\\perp},r_{1}).</span></p>

    <p class="text-gray-300">And, by the construction of <span class="math">\\mathcal{P}</span>, we have <span class="math">\\mathsf{w}_{1}.E=\\mathbf{0}</span> and <span class="math">\\mathsf{w}_{1}.r_{E}=0</span> (implying that <span class="math">\\mathsf{u}_{1}.\\overline{E}=0</span>), and <span class="math">\\mathsf{u}_{1}.u=1</span>. Therefore, we have</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{pp},1,z_{0},z_{1},\\Pi_{1})=1.</span></p>

    <p class="text-gray-300">Inductive Step (<span class="math">i\\geq 1</span>): Assume that for</p>

    <p class="text-gray-300"><span class="math">\\Pi_{i}=((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),r_{i})</span></p>

    <p class="text-gray-300">we have that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1</span></p>

    <p class="text-gray-300">and suppose that</p>

    <p class="text-gray-300"><span class="math">\\Pi_{i+1}=((\\mathsf{U}_{i+1},\\mathsf{W}_{i+1}),(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1}),r_{i+1})\\leftarrow\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\omega_{i},\\Pi_{i}).</span></p>

    <p class="text-gray-300">By the construction of <span class="math">\\mathcal{P}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{U}_{i+1},\\mathsf{W}_{i+1},\\overline{T})\\leftarrow\\mathsf{NIFS.P}(\\mathsf{pk},(\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i})).</span></p>

    <p class="text-gray-300">Thus, by the completeness of the underlying folding scheme, and the premise that <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> and <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span> are satisfying instance-witness pairs, we have that <span class="math">(\\mathsf{U}_{i+1},\\mathsf{W}_{i+1})</span> is a satisfying instance-witness pair. Additionally, by the premise, we have that <span class="math">\\mathsf{u}_{i}.x=\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},r_{i})</span>, <span class="math">\\mathsf{u}_{i}.\\overline{E}=0</span>, and <span class="math">\\mathsf{u}_{i}.u=1</span>. Therefore, <span class="math">\\mathcal{P}</span> can construct a satisfying instance-witness pair <span class="math">(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1})</span> that represents the correct execution of <span class="math">F^{\\prime}</span> on input <span class="math">(\\mathsf{U},\\mathsf{u},(i,z_{0},z_{i}),\\omega_{i},\\overline{T},r_{i},r_{i+1})</span>, where <span class="math">r_{i+1}\\in_{R}\\mathbb{F}</span>. By construction, this particular input implies that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{i+1}.\\mathsf{x}</span> <span class="math">=\\mathsf{hash}(\\mathsf{vk},\\mathsf{u}_{i}.i+1,\\mathsf{u}_{i}.z_{0},F(z_{i},w_{i}),\\mathsf{NIFS.V}(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u}_{i},\\overline{T}),r_{i+1})</span> (12) <span class="math">=\\mathsf{hash}(\\mathsf{vk},\\mathsf{u}_{i}.i+1,\\mathsf{u}_{i}.z_{0},z_{i+1},\\mathsf{U}_{i+1},r_{i+1})</span></p>

    <p class="text-gray-300">by the correctness of the underlying folding scheme. As in the base case, by the construction of <span class="math">\\mathcal{P}</span>, we have <span class="math">\\mathsf{w}_{i+1}.E=\\mathbf{0}</span>, <span class="math">\\mathsf{w}_{i+1}.r_{E}=0</span> (implying that <span class="math">\\mathsf{u}_{i+1}.\\overline{E}=0</span>) and <span class="math">\\mathsf{u}_{i+1}.u=1</span>. Thus, by Equation (12) we have</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i+1,z_{0},z_{i+1},\\Pi_{i+1})=1.</span></p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 10 (IVC Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 3 is an IVC scheme that satisfies knowledge soundness.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Our approach is inspired by a recursive extraction technique described by Bünz et al <em>[17]</em>. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span>. Consider an expected polynomial-time adversary <span class="math">\\mathcal{P}^{<em>}</span> that outputs a function <span class="math">F</span> on input <span class="math">\\mathsf{pp}</span>, and let <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},F)</span>. Suppose that, for a constant <span class="math">n</span>, <span class="math">\\mathcal{P}^{</em>}</span> additionally outputs <span class="math">(z_{0},z,\\Pi)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},n,z_{0},z,\\Pi)=1</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon</span>. We must construct an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> that with input <span class="math">(\\mathsf{pp},z_{0},z)</span>, outputs <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span> such that by computing</p>

    <p class="text-gray-300"><span class="math">z_{i}\\leftarrow F(z_{i-1},\\omega_{i-1})</span></p>

    <p class="text-gray-300">we have that <span class="math">z_{n}=z</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We show inductively that <span class="math">\\mathcal{E}</span> can construct an expected polynomial-time extractor <span class="math">\\mathcal{E}_{i}(\\mathsf{pp})</span> that outputs <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}),\\varPi_{i})</span> such that for all <span class="math">j\\in\\{i+1,\\ldots,n\\}</span>,</p>

    <p class="text-gray-300"><span class="math">z_{j}=F(z_{j-1},\\omega_{j-1})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\varPi_{i})=1</span> (13)</p>

    <p class="text-gray-300">for <span class="math">z_{n}=z</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Then, because in the base case when <span class="math">i=0</span>, <span class="math">\\mathcal{V}</span> checks that <span class="math">z_{0}=z_{i}</span>, the values <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span> retrieved by <span class="math">\\mathcal{E}_{0}(\\mathsf{pp})</span> are such that computing <span class="math">z_{i+1}=F(z_{i},\\omega_{i})</span> for all <span class="math">i\\geq 1</span> gives <span class="math">z_{n}=z</span>. At a high level, to construct an extractor <span class="math">\\mathcal{E}_{i-1}</span>, we first assume the existence of <span class="math">\\mathcal{E}_{i}</span> that satisfies the inductive hypothesis. We then use <span class="math">\\mathcal{E}_{i}(\\mathsf{pp})</span> to construct an adversary for the non-interactive folding scheme (which we denote as <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span>). This in turn guarantees an extractor for the non-interactive folding scheme, which we denote as <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span>. We then use <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span> to construct <span class="math">\\mathcal{E}_{i-1}</span> that satisfies the inductive hypothesis.</p>

    <p class="text-gray-300">In the base case, for <span class="math">i=n</span>, let <span class="math">\\mathcal{E}_{n}(\\mathsf{pp};\\rho)</span> output <span class="math">(\\bot,\\bot,\\varPi_{n})</span> where <span class="math">\\varPi_{n}</span> is the output of <span class="math">\\mathcal{P}^{*}(\\mathsf{pp};\\rho)</span>. By the premise, <span class="math">\\mathcal{E}_{n}</span> succeeds with probability <span class="math">\\epsilon</span> in expected polynomial-time.</p>

    <p class="text-gray-300">For <span class="math">i\\geq 1</span>, suppose <span class="math">\\mathcal{E}</span> can construct an expected polynomial-time extractor <span class="math">\\mathcal{E}_{i}</span> that outputs <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}))</span>, and <span class="math">\\varPi_{i}</span> that satisfies the inductive hypothesis. To construct an extractor <span class="math">\\mathcal{E}_{i-1}</span>, <span class="math">\\mathcal{E}</span> first constructs an adversary <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span> for the non-interactive folding scheme as follows:</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathcal{P}}_{i-1}(\\mathsf{pp};\\rho)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}),\\varPi_{i})\\leftarrow\\mathcal{E}_{i}(\\mathsf{pp};\\rho)</span>.</li>

      <li>Parse <span class="math">\\varPi_{i}</span> as <span class="math">((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),r_{i})</span>.</li>

      <li>Parse <span class="math">\\mathsf{w}_{i}</span> to retrieve <span class="math">(\\mathsf{U}_{i-1},\\mathsf{u}_{i-1},\\overline{T}_{i-1},r_{i-1})</span>.</li>

      <li>Output <span class="math">(\\mathsf{U}_{i-1},\\mathsf{u}_{i-1})</span> and <span class="math">((\\mathsf{U}_{i},\\mathsf{W}_{i}),\\overline{T}_{i-1})</span>.</li>

    </ol>

    <p class="text-gray-300">By the inductive hypothesis, we have that <span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\varPi_{i})=1</span>, where <span class="math">\\varPi_{i}\\leftarrow\\mathcal{E}_{i}(\\mathsf{pp})</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Therefore, by the the verifier’s checks we have that <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> and <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span> are satisfying instance-witness pairs, and that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{i}.\\mathsf{x}=\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},r_{i}).</span></p>

    <p class="text-gray-300">Because <span class="math">\\mathcal{V}</span> ensures that <span class="math">(\\mathsf{u}_{i}.\\overline{E},\\mathsf{u}_{i}.u)=(\\overline{0},1)</span> we have that <span class="math">\\mathsf{w}_{i}</span> is indeed a satisfying assignment for <span class="math">F^{\\prime}</span> (and not just a trivially satisfying witness). Then, by the construction of <span class="math">F^{\\prime}</span> and the binding property of the hash function, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{U}_{i}=\\mathsf{NIFS}.\\mathsf{V}(\\mathsf{vk},\\mathsf{U}_{i-1},\\mathsf{u}_{i-1},\\overline{T}_{i-1})</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Thus, <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span> succeeds in producing an accepting folded instance-witness pair <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span>, for instances <span class="math">(\\mathsf{U}_{i-1},\\mathsf{u}_{i-1})</span>, with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in expected polynomial-time.</p>

    <p class="text-gray-300">Then, by the knowledge soundness of the underlying non-interactive folding scheme (Assumption 1) there exists an extractor <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span> that outputs <span class="math">(\\mathsf{w}_{i-1},\\mathsf{W}_{i-1})</span> such that <span class="math">(\\mathsf{u}_{i-1},\\mathsf{w}_{i-1})</span> and <span class="math">(\\mathsf{U}_{i-1},\\mathsf{W}_{i-1})</span> satisfy <span class="math">F^{\\prime}</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in expected polynomial-time.</p>

    <p class="text-gray-300">Given an expected polynomial-time <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span> and an expected polynomial-time <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span>, <span class="math">\\mathcal{E}</span> constructs an expected polynomial time <span class="math">\\mathcal{E}_{i-1}</span> as follows</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{i-1}(\\mathsf{pp};\\rho)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((\\mathsf{U}_{i-1},\\mathsf{u}_{i-1}),(\\mathsf{U}_{i},\\mathsf{W}_{i}),\\overline{T}_{i-1})\\leftarrow\\widetilde{\\mathcal{P}}_{i-1}(\\mathsf{pp};\\rho)</span></li>

      <li>Retrieve <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}),\\varPi_{i},r_{i-1})</span> from the internal state of <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span>.</li>

      <li>Parse <span class="math">\\varPi_{i}.\\mathsf{w}_{i}</span> to retrieve <span class="math">z_{i-1}</span> and <span class="math">\\omega_{i-1}</span></li>

      <li>Let <span class="math">(\\mathsf{w}_{i-1},\\mathsf{W}_{i-1})\\leftarrow\\widetilde{\\mathcal{E}}_{i-1}(\\mathsf{pp})</span>.</li>

      <li>Let <span class="math">\\varPi_{i-1}\\leftarrow((\\mathsf{U}_{i-1},\\mathsf{W}_{i-1}),(\\mathsf{u}_{i-1},\\mathsf{w}_{i-1}),r_{i-1})</span>.</li>

      <li>Output <span class="math">((z_{i-1},\\ldots,z_{n-1}),(\\omega_{i-1},\\ldots,\\omega_{n-1}),\\varPi_{i-1})</span>.</li>

    </ol>

    <p class="text-gray-300">We first reason that the output <span class="math">(z_{i-1},\\ldots,z_{n-1})</span>, and <span class="math">(\\omega_{i-1},\\ldots,\\omega_{n-1})</span> are valid. By the inductive hypothesis, we already have that for all <span class="math">j\\in\\{i+1,\\ldots,n\\}</span>,</p>

    <p class="text-gray-300"><span class="math">z_{j}=F(z_{j-1},\\omega_{j-1}),</span></p>

    <p class="text-gray-300">and that <span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),r_{i}))=1</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Because <span class="math">\\mathcal{V}</span> additionally checks that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{i}.\\mathsf{x}=\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},r_{i})</span> (14)</p>

    <p class="text-gray-300">by the construction of <span class="math">F^{\\prime}</span> and the binding property of the hash function, we have</p>

    <p class="text-gray-300"><span class="math">F(z_{i-1},\\omega_{i-1})=z_{i}</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Next, we argue that <span class="math">\\varPi_{i-1}</span> is valid. Because <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> satisfies <span class="math">F^{\\prime}</span>, and <span class="math">(\\mathsf{U}_{i-1},\\mathsf{u}_{i-1})</span> were retrieved from <span class="math">\\mathsf{w}_{i}</span>, by the binding property of the hash function, and by Equation (14), we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{i-1}.\\mathsf{x}</span> <span class="math">=\\mathsf{hash}(\\mathsf{vk},i-1,z_{0},z_{i-1},\\mathsf{U}_{i-1},r_{i-1})</span> <span class="math">(\\mathsf{u}_{i-1}.\\overline{E},\\mathsf{u}_{i-1}.u)</span> <span class="math">=(\\overline{0},1)</span></p>

    <p class="text-gray-300">Additionally, in the case where <span class="math">i=1</span>, by the base case check of <span class="math">F^{\\prime}</span>, we have that <span class="math">z_{i-1}=z_{0}</span>. Because <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span> succeeds with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i-1,z_{0},z_{i-1},\\varPi_{i-1})=1</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">D Proof of Theorem 4 (A zkSNARK of a Valid IVC Proof)</p>

    <p class="text-gray-300">Proof. Completeness and knowledge soundness hold due to the completeness and knowledge soundness of the underlying zero-knowledge succinct non-interactive argument of knowledge (zkSNARK) and the non-interactive folding scheme (NIFS). Succinctness holds due to the succinctness of the commitment scheme underlying the non-interactive folding scheme, the succinctness of the hash function, and the succinctness of the underlying non-interactive argument. To prove zero-knowledge, we first construct a simulator <span class="math">\\mathcal{S}</span> as follows. Let NIFS.S and zkSNARK.S denote the simulators for the underlying non-interactive folding scheme and the zkSNARK respectively. The simulator is given as input the statement proven by an IVC proof <span class="math">(n, z_0, z_n)</span> along with public parameters <span class="math">\\mathsf{pp}</span>. For <span class="math">i \\in \\{1, \\ldots, n-1\\}</span>, let <span class="math">z_i = \\bot</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}(\\mathsf{pp},(n,z_0,z_n),\\tau)\\to \\pi</span></p>

    <p class="text-gray-300">If <span class="math">n = 0</span>,</p>

    <p class="text-gray-300">output <span class="math">\\bot</span>;</p>

    <p class="text-gray-300">otherwise,</p>

    <p class="text-gray-300">(1) for <span class="math">i \\in \\{0, \\dots, n-1\\}</span></p>

    <p class="text-gray-300"><span class="math">(r_{i+1}, r_{i+1}&#x27;) \\gets_R \\mathsf{F}</span></p>

    <p class="text-gray-300">if <span class="math">i = 0</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{U}_1 \\gets \\mathsf{u}_{\\perp}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_1 \\gets (\\mathsf{hash}(\\mathsf{vk}, 1, z_0, z_1, U_1, r_1), (\\mathsf{u}_{\\perp}.\\overline{E}, 1, \\mathsf{Com}(\\mathsf{pp}, 0, r_1&#x27;)))</span></p>

    <p class="text-gray-300">otherwise</p>

    <p class="text-gray-300"><span class="math">\\overline{T}_i \\gets \\mathsf{NIFS.S}(\\mathsf{pp}_{\\mathsf{NIFS}}, \\mathsf{U}_i, \\mathsf{u}_i)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{U}_{i+1} \\gets \\mathsf{NIFS.V}(\\mathsf{vk}_{\\mathsf{NIFS}}, \\mathsf{U}_i, \\mathsf{u}_i, \\overline{T}_i)</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{i+1} \\gets (\\mathsf{hash}(\\mathsf{vk}, i+1, z_0, z_{i+1}, \\mathsf{U}_{i+1}, r_{i+1}), (\\mathsf{u}_{\\perp}.\\overline{E}, 1, \\mathsf{Com}(\\mathsf{pp}, 0, r_{i+1}&#x27;)));</span></p>

    <p class="text-gray-300">(2) <span class="math">\\overline{T}_n \\gets \\mathsf{NIFS.S}(\\mathsf{pp}_{\\mathsf{NIFS}}, \\mathsf{U}_n, \\mathsf{u}_n)</span></p>

    <p class="text-gray-300">(3) <span class="math">\\pi_{\\mathsf{U}&#x27;} \\gets \\mathsf{zkSNARK.S}(\\mathsf{pp}_{\\mathsf{zkSNARK}}, \\mathsf{NIFS.V}(\\mathsf{vk}_{\\mathsf{NIFS}}, \\mathsf{U}_n, \\mathsf{u}_n, \\overline{T}_n), \\tau)</span></p>

    <p class="text-gray-300">(4) output <span class="math">(\\mathsf{U}_n, \\mathsf{u}_n, r_n, \\overline{T}_n, \\pi_{\\mathsf{U}&#x27;})</span>.</p>

    <p class="text-gray-300">If <span class="math">n = 0</span>, both the simulator and the honest prover output <span class="math">\\bot</span>. If <span class="math">n &amp;gt; 0</span>, we reason that the pair <span class="math">(\\mathsf{U}, \\mathsf{u})</span> is indistinguishable from the pair produced by an honest prover. We do so by showing that if <span class="math">(\\mathsf{U}_i, \\mathsf{u}_i)</span> is indistinguishable then <span class="math">(\\mathsf{U}_{i+1}, \\mathsf{u}_{i+1})</span> is indistinguishable.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">i = 1</span>. By the definition of IVC.P, <span class="math">U_1 = \\mathsf{u}_{\\perp}</span> in both the real and simulated settings. Additionally, we have that <span class="math">\\mathsf{u}_1.\\overline{E} = \\mathsf{u}_{\\perp}.\\overline{E}</span> and <span class="math">\\mathsf{u}.u = 1</span> in both the real and simulated setting. Due to the hiding property of the hash function, we have that the simulated hash of the public IO, <span class="math">\\mathsf{hash}(\\mathsf{vk}, i + 1, z_0, z_{i+1}, \\mathsf{U}_{i+1}, r_{i+1})</span>, is indistinguishable from the one generated honestly. Due to the hiding property of the commitment scheme, we additionally have that the simulated commitment to the witness, <span class="math">\\mathsf{Com}(\\mathsf{pp}, 0, r_{i+1}&#x27;)</span>, is indistinguishable from the one generated honestly.</li>

    </ul>

    <p class="text-gray-300">41</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some <span class="math">i \\in \\{1, \\dots, n - 1\\}</span>, suppose now that <span class="math">(\\mathsf{U}_i, \\mathsf{u}_i)</span> is indistinguishable in the real and the simulated settings. Due to the zero-knowledge property of the underlying non-interactive folding scheme, we have that <span class="math">\\overline{T}_i \\gets \\mathsf{NIFS.S}(\\mathsf{pp}_{\\mathsf{NIFS}}, \\mathsf{U}_i, \\mathsf{u}_i)</span> is indistinguishable in the real and the simulated settings. Thus, we have that <span class="math">\\mathsf{U}_{i + 1} \\gets \\mathsf{NIFS.V}(\\mathsf{vk}, \\mathsf{U}_i, \\mathsf{u}_i, \\overline{T}_i)</span> is indistinguishable in the real and the simulated settings. Then, we have that <span class="math">\\mathsf{hash}(\\mathsf{vk}_{\\mathsf{NIFS}}, i + 1, z_0, z_{i + 1}, \\mathsf{U}_{i + 1}, r_{i + 1})</span> is indistinguishable in the real and the simulated setting. The remaining pieces of <span class="math">\\mathsf{u}_{i + 1}</span> are indistinguishable in the real and the simulated setting for the same reasons as the base case. Thus, we have that <span class="math">(\\mathsf{U}_{i + 1}, \\mathsf{u}_{i + 1})</span> is indistinguishable in the real and the simulated settings.</li>

    </ul>

    <p class="text-gray-300">Furthermore, in both the real and simulated settings, <span class="math">\\mathsf{U}_n</span> and <span class="math">\\mathsf{u}_n</span> satisfy the verifier's hash check that <span class="math">\\mathsf{u}_n.\\mathsf{x} = \\mathsf{hash}(\\mathsf{vk}, n, z_0, z_n, \\mathsf{U}_n, r_{n+1})</span>. In the simulated setting, this holds because the simulator uses the provided values of <span class="math">(n, z_0, z_n)</span> when computing <span class="math">\\mathsf{u}_n.\\mathsf{x}</span>.</p>

    <p class="text-gray-300">Now, because <span class="math">(\\mathsf{U}_n,\\mathsf{u}_n)</span> are indistinguishable from that produced by honest IVC.P, we have that <span class="math">\\overline{T}_n</span> produced by NIFS.S(pp, <span class="math">\\mathsf{U}_n,\\mathsf{u}_n</span>) is indistinguishable from that produced by <span class="math">\\overline{\\mathcal{P}}</span> due to the zero-knowledge property of the underlying non-interactive folding scheme. This means that <span class="math">\\mathsf{U}&#x27;</span> generated by NIFS.V(vk, <span class="math">\\mathsf{U}_n,\\mathsf{u}_n,\\overline{T}</span>) is indistinguishable from that produced honestly. This means that <span class="math">\\pi_{\\mathsf{U}&#x27;}</span> is indistinguishable in the real and the simulated setting due to the zero-knowledge property of the underlying zkSNARK. Thus, the simulated zkSNARK <span class="math">(\\mathsf{U}_n,\\mathsf{u}_n,\\overline{T}_n,\\pi_{\\mathsf{U}&#x27;})</span> is indistinguishable from the one generated honestly.</p>

    <h2 id="sec-54" class="text-2xl font-bold">E Proof of Lemma 1 (Forking Lemma for Folding Schemes)</h2>

    <p class="text-gray-300">We provide a proof for our variant of the forking lemma by adapting the proof of the forking lemma from Bootle et al. [12].</p>

    <p class="text-gray-300"><strong>Lemma.</strong> Let <span class="math">\\mathbb{F}</span> denote a finite field. Consider a <span class="math">(2\\mu + 1)</span>-move folding scheme <span class="math">\\Pi = (\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span>. <span class="math">\\Pi</span> satisfies knowledge soundness if there exists a PPT <span class="math">\\mathcal{X}</span> such that for all input instance pairs <span class="math">(u_1, u_2)</span>, outputs satisfying witnesses <span class="math">(w_1, w_2)</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, given public parameters <span class="math">\\mathsf{pp}</span>, a structure <span class="math">\\mathsf{s}</span>, and an <span class="math">(n_1, \\ldots, n_\\mu)</span>-tree of accepting transcripts and the corresponding folded instance-witness pairs <span class="math">(u, w)</span>. This tree comprises of <span class="math">n_1</span> transcripts (and the corresponding instance-witness pairs) with fresh randomness in <span class="math">\\mathcal{V}</span>'s first message; and for each such transcript, <span class="math">n_2</span> transcripts (and the corresponding instance-witness pairs) with fresh randomness in <span class="math">\\mathcal{V}</span>'s second message; etc., for a total of <span class="math">\\prod_{i=1}^{\\mu} n_i</span> leaves bounded by <span class="math">\\mathrm{poly}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Consider a <span class="math">(2\\mu + 1)</span>-move folding scheme <span class="math">(\\mathcal{G}, \\mathcal{K}, \\mathcal{P}, \\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span> with randomness sampled uniformly from <span class="math">\\mathbb{F}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math">. Suppose there exists a PPT </span>\\mathcal{X}<span class="math"> such that for arbitrary input instances </span>(u_1, u_2)<span class="math">, outputs the corresponding satisfying witnesses </span>(w_1, w_2)<span class="math"> with probability </span>1 - \\mathrm{negl}(\\lambda)$, given public parameters</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}</span>, a structure <span class="math">\\mathsf{s}</span>, and an <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree of accepting transcripts and the corresponding folded instance-witness pairs where <span class="math">\\prod_{i=1}^{\\mu}n_{i}</span>. Consider an arbitrary expected polynomial-time adversary <span class="math">\\mathcal{P}^{<em>}</span>, and <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span>. Let <span class="math">\\epsilon</span> be the probability that, given <span class="math">(u_{1},u_{2})\\leftarrow\\mathcal{P}^{</em>}(\\mathsf{pp},\\rho),\\mathcal{P}^{*}(\\mathsf{pp},\\rho)</span> succeeds in producing a valid witness <span class="math">w</span> for the folded instance <span class="math">u</span>. To prove that <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies knowledge-soundness we will show that there exists a corresponding extractor <span class="math">\\mathcal{E}</span> that outputs a valid witness pair <span class="math">(w_{1},w_{2})</span> for instances <span class="math">(u_{1},u_{2})</span> given public parameters <span class="math">\\mathsf{pp}</span> and the prover randomness <span class="math">\\rho</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We first construct an extractor <span class="math">\\mathcal{E}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathsf{pp},\\rho)\\rightarrow(w_{1},w_{2})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{s},(u_{1},u_{2}))\\leftarrow\\mathcal{P}^{*}(\\mathsf{pp},\\rho)</span></li>

      <li>Compute <span class="math">\\mathsf{tree}\\leftarrow\\mathcal{T}(1)</span>, where the function <span class="math">\\mathcal{T}</span> is defined below.</li>

      <li>If <span class="math">\\mathsf{tree}</span> is not a valid <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree (i.e. there are collisions in the verifier’s randomness) return <span class="math">\\bot</span>.</li>

      <li>Output <span class="math">(w_{1},w_{2})\\leftarrow\\mathcal{X}(\\mathsf{pp},\\mathsf{s},u_{1},u_{2},\\mathsf{tree})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{T}(i)\\rightarrow\\mathsf{tree}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample the verifier’s randomness for round <span class="math">i</span>; denote it as <span class="math">r_{i}</span>.</li>

      <li>If <span class="math">i=\\mu+1</span>, compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">(u,w)\\leftarrow\\langle\\mathcal{P}^{*}(\\rho),\\mathcal{V}(u_{1},u_{2})\\rangle</span></p>

    <p class="text-gray-300">and let <span class="math">\\mathsf{tr}</span> be the corresponding transcript. If <span class="math">(u,w)\\in\\mathcal{R}</span>, output <span class="math">\\{(\\mathsf{tr},(u,w))\\}</span>. Otherwise output <span class="math">\\bot</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>With fixed verifier randomness <span class="math">(r_{1},\\ldots,r_{i})</span>, compute <span class="math">\\mathsf{tree}\\leftarrow\\mathcal{T}(i+1)</span> <em>once</em>. If <span class="math">\\mathsf{tree}=\\bot</span> output <span class="math">\\bot</span>.</li>

      <li>With fixed verifier randomness <span class="math">(r_{1},\\ldots,r_{i})</span>, repeatedly run <span class="math">\\mathcal{T}(i+1)</span> until <span class="math">n_{i}-1</span> additional lists of accepting transcripts are acquired. Append all the results to <span class="math">\\mathsf{tree}</span>.</li>

      <li>Output <span class="math">\\mathsf{tree}</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">E_{1}</span> denote the event that <span class="math">\\mathcal{T}(1)</span> outputs <span class="math">\\mathsf{tree}\\neq\\bot</span> in less than <span class="math">T</span> time steps (we specify <span class="math">T</span> later). Given <span class="math">E_{1}</span>, let <span class="math">E_{2}</span> denote the event that the resulting <span class="math">\\mathsf{tree}</span> is a valid <span class="math">(n_{1},\\ldots,n_{\\mu})</span>-tree (i.e. there are no collisions in the verifier’s randomness). Given <span class="math">E_{1}</span> and <span class="math">E_{2}</span>, let <span class="math">E_{3}</span> denote the event that <span class="math">\\mathcal{X}</span> succeeds with <span class="math">\\mathsf{tree}</span> as input. Then, we have that <span class="math">\\mathcal{E}</span> succeeds with probability</p>

    <p class="text-gray-300"><span class="math">P_{\\mathcal{E}}=\\Pr\\left[E_{3}\\right]\\cdot\\Pr\\left[E_{2}\\right]\\cdot\\Pr\\left[E_{1}\\right]</span>.</p>

    <p class="text-gray-300">We now compute each of these probabilities. To compute <span class="math">\\Pr\\left[E_{1}\\right]</span>, we observe that <span class="math">T(1)</span> fails (i.e. returns <span class="math">\\bot</span>) only when its <em>first</em> call to <span class="math">T(2)</span> fails. Likewise, <span class="math">T(2)</span> fails only when its first call to <span class="math">T(3)</span> fails. Chaining these assertions, we have that <span class="math">T(1)</span> fails with probability <span class="math">(1-\\epsilon)</span>, which, by assumption, is the probability that <span class="math">T(\\mu+1)</span> fails. Thus, the expected number of times <span class="math">T(i)</span> calls <span class="math">T(i+1)</span> is</p>

    <p class="text-gray-300"><span class="math">1+\\Pr\\left[\\text{First call to }T(i+1)\\text{ succeeds}\\right]\\cdot\\frac{(n_{i}-1)}{\\Pr\\left[T(i+1)\\text{ returns }\\mathsf{tree}\\neq\\bot\\right]}</span></p>

    <p class="text-gray-300"><span class="math">=1+\\epsilon\\cdot\\frac{(n_{i}-1)}{\\epsilon}</span> <span class="math">=n_{i}.</span></p>

    <p class="text-gray-300">Hence, the total runtime is expected to be <span class="math">t=O(\\prod_{i=1}^{p}n_{i})</span> which is bounded above by <span class="math">\\mathsf{poly}(\\lambda)</span> by assumption. Moreover, by Markov’s inequality, we have that <span class="math">\\mathcal{T}</span> runs for time longer than <span class="math">T&gt;t</span> with probability <span class="math">\\frac{t}{T}</span>. Thus, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[E_{1}]=(1-\\frac{t}{T})\\cdot\\epsilon.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given <span class="math">E_{1}</span> we have that <span class="math">\\mathcal{T}</span> runs in at most <span class="math">T</span> time-steps. This ensures that there are at most <span class="math">T</span> random challenges produced for the verifier, and that the probability of collision is at most $\\frac{T^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. Thus, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[E_{2}]=1-\\frac{T^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, given <span class="math">E_{1}</span> and <span class="math">E_{2}</span>, we have that <span class="math">\\Pr[E_{3}]=1-\\mathsf{negl}(\\lambda)</span> by assumption. Consolidating our calculations we have that <span class="math">\\mathcal{E}</span> succeeds with probability</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P_{\\mathcal{E}}=(1-\\mathsf{negl}(\\lambda))\\cdot\\left(1-\\frac{T^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\cdot\\left(1-\\frac{t}{T}\\right)\\cdot\\epsilon$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setting $T=\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (and assuming that </span>T\\geq t$) we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">P_{\\mathcal{E}}</span> $=(1-\\mathsf{negl}(\\lambda))\\cdot\\left(1-\\frac{1}{\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right)\\cdot\\left(1-\\frac{t}{\\sqrt[3]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right)\\cdot\\epsilon$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=\\epsilon-\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-55" class="text-2xl font-bold">Appendix F A Commitment Scheme for Vectors</h2>

    <p class="text-gray-300">We first recall the syntax for commitment schemes for vectors introduced in Section 2.1 and then define the required binding and hiding properties. Next, we define the additionally required additively homomorphic and succinctness properties. For the sake of concreteness, we reproduce Pedersen’s commitment scheme, which satisfies all of the required properties.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 16 (Commitment Scheme)</h6>

    <p class="text-gray-300">A commitment scheme for <span class="math">\\mathbb{F}^{m}</span> is a tuple of three protocols with the following syntax that satisfy the two properties listed below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},m)</span>: produces public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">C\\leftarrow\\mathsf{Com}(\\mathsf{pp},x,r)</span>: takes as input <span class="math">x\\in\\mathbb{F}^{m}</span> and <span class="math">r\\in\\mathbb{F}</span>; produces a public commitment <span class="math">C</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\operatorname{Open}(\\mathfrak{pp}, C, x, r)</span> : verifies the opening of commitment  <span class="math">C</span>  to  <span class="math">x \\in \\mathbb{F}^m</span>  and  <span class="math">r \\in \\mathbb{F}</span> ; outputs  <span class="math">b \\in \\{0, 1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">(1) Binding. For any PPT adversary  <span class="math">\\mathcal{A}</span> , the following probability is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {G e n} (1 ^ {\\lambda}, m), \\\\ b _ {0} = b _ {1} = 1, &amp;amp; (C, x _ {0} \\in \\mathsf {F} ^ {m}, x _ {1} \\in \\mathsf {F} ^ {m}, r _ {0} \\in \\mathsf {F}, r _ {1} \\in \\mathsf {F}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ x _ {0} \\neq x _ {1} &amp;amp; b _ {0} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p}, C, x _ {0}, r _ {0}), \\\\ &amp;amp; b _ {1} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p}, C, x _ {1}, r _ {1}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">(2) Hiding. For all PPT adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> , the following probability is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{2} - \\Pr \\left[ b = \\bar {b} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (x _ {0}, x _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} _ {0} (\\mathsf {p p}), \\\\ \\bar {b} \\leftarrow_ {R} \\{0, 1 \\}, r \\leftarrow_ {R} \\mathbb {F}, \\\\ C \\leftarrow \\mathsf {C o m} (\\mathsf {p p}, x _ {b}, r), \\\\ \\bar {b} \\leftarrow \\mathcal {A} _ {1} (\\mathsf {s t}, C) \\end{array} \\right. \\right] \\right. \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If hiding holds for all adversaries, then the commitment is statistically hiding.</p>

    <p class="text-gray-300">Definition 17 (Additively Homomorphic). A commitment scheme for vectors over  <span class="math">\\mathbb{F}^m</span> ,  <span class="math">(\\mathrm{Gen},\\mathrm{Com},\\mathrm{Open})</span> , is additively homomorphic if for all public parameters  <span class="math">\\mathfrak{pp}</span>  produced from  <span class="math">\\mathrm{Gen}(1^\\lambda, m)</span> , and for any  <span class="math">x_1, x_2 \\in \\mathbb{F}^m</span>  and for any  <span class="math">r_1, r_2 \\in \\mathbb{F}</span> ,  <span class="math">\\mathrm{Com}(\\mathfrak{pp}, x_1, r_1) + \\mathrm{Com}(\\mathfrak{pp}, x_2, r_2) = \\mathrm{Com}(\\mathfrak{pp}, x_1 + x_2, r_1 + r_2)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 18 (Succinctness). A commitment scheme for vectors over  <span class="math">\\mathbb{F}^m</span> ,  <span class="math">(\\mathrm{Gen}, \\mathrm{Com}, \\mathrm{Open})</span> , provides succinct commitments if for all public parameters  <span class="math">\\mathfrak{pp}</span>  produced from  <span class="math">\\mathrm{Gen}(1^\\lambda, m)</span> , and any  <span class="math">x \\in \\mathbb{F}^m</span>  and  <span class="math">r \\in \\mathbb{F}</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Com}(\\mathfrak{pp}, x, r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O_\\lambda(\\mathrm{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction 6 (Pedersen Commitment). For group  <span class="math">\\mathbb{G}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math">  with scalar field  </span>\\mathbb{F}<span class="math">  and where the discrete logarithm problem is hard, the Pedersen commitment scheme for vectors over  </span>\\mathbb{F}$  is defined as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{Gen}(1^{\\lambda}, m)</span> : Sample  <span class="math">g \\gets_{R} \\mathbb{G}^{m}</span> ,  <span class="math">h \\gets_{R} \\mathbb{G}</span> . Output  <span class="math">(g, h)</span> .</li>

      <li><span class="math">C \\gets \\operatorname{Com}(\\mathfrak{pp}, x \\in \\mathbb{F}^m, r \\in \\mathbb{F})</span> : Output  <span class="math">h^r \\cdot \\prod_{i \\in \\{0, \\dots, m\\}} g_i^{x_i}</span> .</li>

    </ul>

    <p class="text-gray-300">Lemma 11 (Pedersen Commitment). The Pedersen commitment scheme is hiding, binding, additively homomorphic, and succinct.</p>

    <p class="text-gray-300">This section is adapted from prior work [37, 41, 46]. We recall a few basic facts about polynomials.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A polynomial  <span class="math">g</span>  over  <span class="math">\\mathbb{F}</span>  is an expression consisting of a sum of monomials where each monomial is the product of a constant and powers of one or more variables; all arithmetic is performed over  <span class="math">\\mathbb{F}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The degree of a monomial is the sum of the exponents of variables in the monomial; the (total) degree of a polynomial <span class="math">g</span> is the maximum degree of any monomial in <span class="math">g</span>. Furthermore, the degree of a polynomial <span class="math">g</span> in a particular variable <span class="math">x_{i}</span> is the maximum exponent that <span class="math">x_{i}</span> takes in any <span class="math">g</span>’s monomials.</li>

      <li>A <em>multivariate</em> polynomial is a polynomial with more than one variable. A multivariate polynomial is called a <em>multilinear</em> polynomial if the degree of the polynomial in each variable is at most one.</li>

      <li>A multivariate polynomial <span class="math">g</span> over a finite field <span class="math">\\mathsf{F}</span> is called <em>low-degree</em> if the degree of <span class="math">g</span> in each variable is bounded above by a constant.</li>

    </ul>

    <h2 id="sec-58" class="text-2xl font-bold">Appendix H An Optimization to Theorem 6</h2>

    <p class="text-gray-300">In Theorem 6, given that the verifier’s runtime to verify an evaluation is at least linear in the polynomial size, the verifier does not gain by querying commitments to structure polynomials <span class="math">\\widetilde{A},\\widetilde{B},\\widetilde{C}</span>. Rather, the verifier can directly evaluate them, which not only simplifies the protocol (as one does not need Sparse-<span class="math">\\mathsf{PC}_{\\mathsf{BP}}</span>), but also improves costs, both asymptotically and concretely.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">Assuming the hardness of the discrete logarithm problem, there exists a non-interactive zero-knowledge argument of knowledge for committed relaxed R1CS with the following efficiency characteristics, where <span class="math">m</span> denotes the dimensions of the R1CS coefficient matrices and <span class="math">n</span> denotes the number of non-zero entries in the matrices: The encoder runs in time <span class="math">O_{\\lambda}(m)</span>; The prover runs in time <span class="math">O(n)+O_{\\lambda}(m)</span>; The proof length is <span class="math">O_{\\lambda}(\\log m)</span>; and the verifier runs in time <span class="math">n+O_{\\lambda}(m)</span>.</p>

    <h2 id="sec-60" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Nova: Recursive Zero-Knowledge Arguments from Folding Scheme... (2021/370)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/370
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
