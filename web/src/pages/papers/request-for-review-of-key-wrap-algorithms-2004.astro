---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/340';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Request for Review of Key Wrap Algorithms';
const AUTHORS_HTML = 'Morris Dworkin';

const CONTENT = `    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">The following document contains excerpts from draft standard of the Accredited Standards Committee, X9, Inc. (ASC X9) entitled ANS X9.102- Wrapping of Keys and Associated Data. ASC X9 grants permission to the editor of this draft standard, the National Institute of Standards and Technology, to reproduce these excerpts, and they are to be used solely for the purpose of commenting and adding input to the draft standard.</p>

    <p class="text-gray-300">These excerpts will be made available on the Cryptology ePrint Archive of the International Association of Cryptologic Research with permission of ASC X9 for a six month period but may not be made available on any other website, public network, satellite or otherwise without the prior written consent of the ACCREDITED STANDARDS COMMITTEE X9, INC., Contact: Cindy Fuller, Executive Director, ASC X9, Inc., P.O. Box 4035, Annapolis, MD 21403 USA.</p>

    <p class="text-gray-300">© ASC X9, Inc.</p>

    <p class="text-gray-300">P.O. Box 4035 • Annapolis, MD 21403 • 410-267-7707 or 301-879-7988 • www.X9.org</p>

    <p class="text-gray-300">Request for Review of Key Wrap Algorithms November, 2004</p>

    <p class="text-gray-300">American Standards Committee X9, Financial Services, Inc., Subcommittee F, Working Group 1 (X9F1) requests a cryptographic review of the four key wrap algorithms in the draft key wrap standard, ANS X9.102. This request for review outlines the security goals and the specifications of the four algorithms. Comments on the security of the algorithms should be submitted to the editor of ANS X9.102, the National Institute of Standards and Technology (NIST), at dworkin@nist.gov. Comments will be accepted until May 21, 2005.</p>

    <p class="text-gray-300">The four key wrap algorithms are intended to provide privacy and integrity protection for specialized data such as cryptographic keys, called the key data string, without the use of nonces. In addition, for three of the algorithms, integrity protection optionally may be provided for cleartext associated data, called the header, which will typically contain control information about the wrapped key.</p>

    <p class="text-gray-300">The four algorithms that are currently proposed in Draft ANS X9.102 are named AESKW, TDKW, AKW1, and AKW2. The essential specification of AESKW has been available on the NIST key management web page since 2002. The underlying block cipher for AESKW is the Advanced Encryption Standard (AES) algorithm; TDKW is the analogue of AESKW for the Triple Data Encryption Algorithm (TDEA).</p>

    <p class="text-gray-300">TDEA is also the underlying block cipher for the two alternative key wraps, AKW1 and AKW2. AKW1 is essentially the algorithm proposed in the Internet Engineering Task Force (IETF) Request for Comment (RFC) 3217. AKW2 is the algorithm that is implicitly defined in a “key block” specification that has been developed for use in constrained legacy systems in the financial services industry.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2.1 Overview</h2>

    <p class="text-gray-300">The analysis of the privacy or integrity that is provided by an algorithm is typically undertaken in the context of a security model: a specific security property/goal with respect to a specific attack model. In Section 2.2., security models with respect to both privacy and integrity are discussed for AESKW, TDKW, and AKW1. For AKW2, Section 2.3 contains background on the design considerations, and Section 2.4 discusses security models.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2.2 Security Models for AESKW, TDKW, AKW1</h2>

    <p class="text-gray-300">With respect to privacy, for AESKW, TDKW, and AKW1, the X9F1 working group proposes the goal of indistinguishability of ciphertexts under adaptive chosen ciphertext</p>

    <p class="text-gray-300">attacks¹. For this model, the adversary chooses two distinct “target” inputs to the wrapping function that are not distinguishable by their length. The wrapping function is then applied to one of the two targets, chosen uniformly at random, under a secret key protection key, also chosen uniformly at random, and the result is returned to the adversary. The adversary breaches the goal if he can distinguish with probability greater than 0.5 which of the two target strings was wrapped.</p>

    <p class="text-gray-300">In an adaptive chosen ciphertext attack, the adversary has access to oracles for both the wrapping and unwrapping functions of the key wrap, under the same key protection key². The oracles may be queried adaptively, i.e., taking into account the results of previous queries, both before and after the adversary chooses the target strings and receives the target ciphertext. Of course, the adversary may not query 1) the wrapping oracle on either of the target strings or 2) the unwrapping oracle on the target ciphertext. For queries to the wrapping oracle for AKW1, which incorporates random bits into the input, the bits are selected uniformly at random, out of the adversary's control.</p>

    <p class="text-gray-300">The queries to the wrapping oracles are limited to 2⁴⁸ for AESKW and 2³² for TDKW and AKW1, consistent with the data requirements of the specifications. Moreover, the adversary's computing operations/time in the adaptive chosen ciphertext attack model are assumed to be less than what would be required to break the underlying block cipher by a brute force search of the key space, where the key size for TDEA is interpreted as the associated “security level,” i.e., 112 bits for three-key TDEA, and 80 bits for two-key TDEA.</p>

    <p class="text-gray-300">With respect to data integrity, the attack model is the same, and the security goal is unforgeability. In particular, it should not be feasible for an adversary to produce a valid ciphertext that is new, i.e., different than the result of any query to the wrapping oracle³. Feasibility here is assessed in relation to the number of bits of redundancy in the specification of the algorithm: at least 63 in AESKW and TDKW, and at least 64 in AKW1. A forgery is considered feasible if the probability of producing such a ciphertext is greater than could be achieved by random guessing.</p>

    <p class="text-gray-300">The above security models are presented for convenience; however, the X9F1 working group will also consider attacks with a different privacy or integrity goal, or a different attack model, such as, for example, attacks based on related keys or weak keys.</p>

    <p class="text-gray-300">¹ This model is essentially the symmetric key analogue of IND-CCA2 privacy discussed in M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway, Relations among Notions of Security for Public-Key Encryption Schemes Advances in Cryptology—CRYPTO 1998, Lecture Notes in Computer Science, vol. 1462, Hugo Krawczyk, ed., Springer-Verlag, 1998..</p>

    <p class="text-gray-300">² For a well-designed key wrap, however, each output of the unwrapping oracle is likely to be “invalid.”</p>

    <p class="text-gray-300">³ This captures the usual definition of data integrity, because the introduction of bit errors into a valid ciphertext, either unintentionally or intentionally, is equivalent to an adversary flipping the corresponding bits of a corresponding oracle output. If the result is a valid ciphertext with sufficiently high probability, then forgery is feasible, contrary to the definition of unforgeability.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">3</p>

    <h2 id="sec-6" class="text-2xl font-bold">2.3 Background on the Design Considerations for AKW2</h2>

    <p class="text-gray-300">Unlike AESKW and TDKW, the AKW2 method was developed for a specific environment, the ATM/POS network. This network has evolved over 20 years, so it contains a large number of legacy, computationally limited devices. Many of the devices were originally deployed to implement only 56-bit DEA, and are being retrofitted to support TDEA. The original DEA-based network encrypted DEA keys with ECB. This approach was reasonable given that DEA keys fit within a single block. As TDEA was gradually added to the network, these keys continued to be either ECB encrypted, or CBC encrypted with a zero IV (no MAC). The risks of such an approach are obvious to the cryptographic community.</p>

    <p class="text-gray-300">AKW2 was designed to run on computationally limited devices. As a result, the AKW2 method just employs a TDEA crypto-primitive since these devices often lack sufficient memory and computational power to support other algorithms. The design was created with the realization that every additional TDEA block operation in AKW2 increases the probability that these devices will continue to be operated with ECB-based key management. The method is very specific to the threat model for this network. Other systems must examine the security assumptions very carefully if they are considering using AKW2.</p>

    <p class="text-gray-300">A complete description of the ATM/POS threat model is beyond the scope of this document. However, to help the reader understand the environment, the list below groups the major vulnerabilities that affect key management with symmetric keys into four categories. For more information, consult ANS X9.24 part 1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Failures of procedure – This class of vulnerabilities includes most of the security vulnerabilities that have been exploited in actual networks. It includes bad practices such as the use of test keys in production environments, failures in the enforcement of dual control, and even e-mailing keys to vendors for debugging purposes. Protection from this type of vulnerability is largely a matter for auditors to enforce.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bad random number generation – This class of vulnerabilities is not limited to the financial networks and is included here only for completeness. Techniques for generating good random numbers are beyond the scope of the key wrapping standard.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Exhaustive search of 56-bit DEA keys – This class of vulnerabilities is divided into two parts. There are a number of 56-bit DEA keys still in use in the financial networks. The vulnerability of such keys can only be fixed by upgrading the cryptography to TDEA. There is an additional class of attacks that may be performed on TDEA keys wrapped using techniques that do not ensure integrity of the key block that allows an attacker to manipulate encrypted keys to reduce the security of the system to 56-bit keys.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Manipulation of Key Usage – This class of vulnerabilities is primarily exploitable at the server, within a data center or switch. At the server, key wrapping and other cryptographic operations are performed within hardware cryptographic modules. The</li>

    </ol>

    <p class="text-gray-300">modules are designed to prevent exposure of cleartext keys to the calling application or any single user. However, if the usage of the keys is not cryptographically enforced within the module, a single user may be able to manipulate the interface to expose keys. These attacks have been well known for years and every vendor includes protection against such attacks. Unfortunately, different vendors use different methods, and these methods are not interoperable. Thus, part of the process of deploying systems that must work in a multi-vendor environment is often a deliberate re-introduction of these vulnerabilities.</p>

    <p class="text-gray-300">The goal of AKW2 is to reduce the threat of attacks based on the third and fourth types of vulnerability.</p>

    <h2 id="sec-7" class="text-2xl font-bold">Threat Model Characteristics:</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As in the other TDEA-based wrapping schemes, we consider that an oracle attack is impractical if it requires more than <span class="math">2^{32}</span> queries of the hardware.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Financial institutions have controls that make it impractical for an attacker to create a related key by XORing the wrapping key with the constant 0x4545454545454545, 0x4D4D4D4D4D4D4D4D, or 0x0808080808080808.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we consider that leakage about plaintext key information tends to happen in an "all-or-nothing" manner. Procedural failures that leak key information tend to reveal the entire key. This does not mean that power analysis or other side-channel type of attacks are not capable of leaking partial information about a key, merely that in the financial network the most convenient attack does not involve attacking the wrapped key.</li>

    </ol>

    <p class="text-gray-300">Note that one of the significant security features of the method is not included in the specification of AKW2 in this request for review. The X9F6 working group has created a Technical Report, TR-31, to define a set of headers for common types of keys that will allow keys to be labeled consistently for transport between two vendors. This definition will eliminate many of the O(1) attacks that are currently possible for insiders using multi-vendor solutions.⁴</p>

    <p class="text-gray-300">Balancing the constraints of the legacy network and the security goals led to the following choices for AKW2:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key derivation is performed by a simple XOR, rather than a one-way key derivation function. In order to prevent catastrophic failure if a procedural error results in the misuse of a key-wrapping key in both ECB wrapping schemes and AKW2, the key-wrapping key is not used directly for encryption.⁵</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The CBC encryption scheme allows the use of a non-random IV.</li>

    </ol>

    <p class="text-gray-300">a) Using a non-random IV allows an attacker to identify when the first block of two wrapped keys are equal. Note that valid keys on a database or in transit are random values. The X9F6 working group assumes that the system will not wrap <span class="math">2^{32}</span> key values under the same wrapping key.</p>

    <p class="text-gray-300">⁴ Attacks against key usage can be performed independent of the key length.</p>

    <p class="text-gray-300">⁵ Note that the assumption about related keys is vitally important to the security of this approach.</p>

    <p class="text-gray-300">4</p>

    <p class="text-gray-300">b) When the IV is non-random, the IV is derived from the header to separate different types of keys under different IVs. This helps reduce the number of keys under a particular IV.⁶</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The MAC algorithm in AKW2 is based on Algorithm 1 of ISO 9797-1.</li>

    </ol>

    <p class="text-gray-300">a) Algorithms 2 and 3 are clearly inappropriate with keys derived by XOR. b) Algorithm 1 is vulnerable to simple concatenation attacks. The requirements in Section 7.2, Item 5 provide protection against these attacks.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.4 Security Models for AKW2</h2>

    <p class="text-gray-300">With respect to data integrity, the security model for AKW2 is the same as described in Section 2.2 for the other proposed key wraps: unforgeability under adaptive chosen ciphertext attacks. The number of bits of redundancy is a parameter (the MAC length) of AKW2 between 32 and 64.</p>

    <p class="text-gray-300">However, AKW2 cannot satisfy the same privacy goal as the other three key wrap algorithms. In particular, because the encryption mechanism in AKW2 is the cipher block chaining (CBC) mode of TDEA with a predictable initialization vector (IV), it is straightforward for an adversary to distinguish ciphertexts under adaptive chosen ciphertext attacks. The X9F1 working group suggests the following two alternative models for AKW2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Known Plaintext Security.</strong> The privacy model in Section 2.2 is weakened in two ways: 1) the two target plaintexts are generated uniformly at random, i.e., not by the adversary; and 2) the adversary may not query the wrapping oracle after receiving the target plaintexts. The adversary may still adaptively query the oracles prior to receiving the target plaintexts and ciphertext, in order to try to learn about the encryption function. The goal is still to determine which of the target plaintexts was encrypted to produce the target ciphertext.</li>

      <li><strong>Ciphertext Only Security.</strong> The adversary is given the ciphertexts, i.e. the wrapped forms, of a set of target plaintexts that are generated uniformly at random. The adversary breaches the privacy goal if he can guess any bit of any target plaintext with probability greater than 0.5. As in the known plaintext model, the adversary may adaptively query the oracles prior to receiving the target plaintexts and ciphertext, in order to try to learn about the encryption function.</li>

    </ul>

    <p class="text-gray-300">As with the other key wrap algorithms, analysts are free to devise other models, keeping in mind the threat model characteristics in Section 2.3. Note that AKW2 is designed for a system that provides protection against the use of related keys; however, this protection is independent of the important question of whether the simple relationship between the two subkeys introduces vulnerabilities into AKW2.</p>

    <p class="text-gray-300">⁶ In addition, this usage provides some very weak protection against another common procedural vulnerability. There are protocols that require the use of a single key for multiple purposes despite the inherent risk. The header IV hides such deliberate re-use from the casual observer. Note that it does not provide any security against knowledgeable insiders.</p>

    <p class="text-gray-300">6</p>

    <p class="text-gray-300">The following notational conventions apply to the specifications below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Variables are italicized: a single, lower case letter represents an integer; other variables, possibly with subscripts or superscripts, represent strings.</li>

      <li><span class="math">\\mathrm{MSB}_x(\\cdot)</span> and <span class="math">\\mathrm{LSB}_x(\\cdot)</span> are the functions for the most and least significant <span class="math">x</span> bits.</li>

      <li><span class="math">\\mathrm{AES}_K(\\cdot)</span> and <span class="math">\\mathrm{TDEA}_K(\\cdot)</span> are the (forward) AES and TDEA algorithms under the key <span class="math">K</span>; <span class="math">\\mathrm{AES}_K^{-1}(\\cdot)</span> and <span class="math">\\mathrm{TDEA}_K^{-1}(\\cdot)</span> are the inverse algorithms.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The concatenation operation is denoted $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The bit string consisting of <span class="math">x</span> '0' bits is denoted <span class="math">0^x</span>.</li>

      <li>Given a nonnegative integer <span class="math">x</span> and a positive integer <span class="math">y</span> such that <span class="math">x &amp;lt; 2^y</span>, the representation of <span class="math">x</span> as a binary string of <span class="math">y</span> bits is denoted <span class="math">[x]_y</span>.</li>

    </ul>

    <h2 id="sec-11" class="text-2xl font-bold">4.1 Overview</h2>

    <p class="text-gray-300">A link to the original specification of AESKW is available at the NIST key management home page <http: cryptotoolkit="" kms="" csrc.nist.gov=""></http:>. The specification proposed for ANS X9.102 extends the original specification, mainly in the following two ways:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A formatting function including a padding scheme is specified for encoding the key data string into a sequence of blocks, i.e., the plaintext; thus, AESKW applies to key data strings of arbitrary length (up to the specified maximum).</li>

      <li>A cleartext header may be authenticated, essentially by duplicating the header within the formatting of the key data string into the plaintext. The header is verified within the integrity check function that corresponds to the formatting function.</li>

    </ol>

    <p class="text-gray-300">In practice, the header may be a representative, or message digest, of some other, larger string. In this case, of course, the scope of the integrity assurance extends to the message digest, but not necessarily to the larger string.</p>

    <p class="text-gray-300">Below are specifications of the elements of AESKW: the data requirements, the plaintext formatting function, the integrity check function, the wrapping function, and the unwrapping function.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4.2 Data Requirements for AESKW</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The header, <span class="math">H</span>, shall be an octet string whose octet length is less than 256.</li>

      <li>The number of plaintext blocks, <span class="math">n</span>, shall satisfy <span class="math">2 \\leq n \\leq 2^{32}</span>. Consequently, at least one of the two input strings to the formatting function, <span class="math">H</span> and KeyData, shall be nonempty.</li>

      <li>For any given key protection key, no more than <span class="math">2^{48}</span> inputs shall be wrapped in the lifetime of the key.</li>

    </ol>

    <h2 id="sec-13" class="text-2xl font-bold">4.3 AESKW Plaintext Formatting Function</h2>

    <p class="text-gray-300">Prerequisites:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">ICV</span>, integrity check value of 48 bits.</li>

    </ul>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300">—<span class="math">H</span>, header string;</p>

    <p class="text-gray-300">—KeyData, key data string.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">—<span class="math">P_1, P_2, \\ldots, P_n</span>: plaintext, <span class="math">n</span> 64 bit semiblocks.</p>

    <p class="text-gray-300">Steps:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1) Let $s = (64 - (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyData</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)) \\mod 64$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">PadLen = [s]_8</span>, e.g., if <span class="math">s = 13</span> then <span class="math">Padlen = 00001101</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">Hlen</span> be the binary representation of the octet length of <span class="math">H</span> as a string of 8 bits.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">P_1, P_2, \\ldots, P_n</span> be the sequence of semiblocks such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_n = ICV \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PadLen \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hlen \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyData \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^s.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-14" class="text-2xl font-bold">4.4 AESKW Integrity Check Function</h2>

    <p class="text-gray-300">Prerequisites:</p>

    <p class="text-gray-300">—ICV, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300">—<span class="math">H</span>, header string;</p>

    <p class="text-gray-300">—<span class="math">P_1, P_2, \\ldots, P_n</span>: purported plaintext, sequence of 64 bit semiblocks.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">—either “INVALID” or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the header length:</li>

    </ol>

    <p class="text-gray-300">If <span class="math">H</span> is not an octet string of octet length <span class="math">\\mathrm{LSB}_8(P_1)</span>, then return “INVALID.”</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the header:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">H</span> is not a prefix of $P_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_3 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_n$, then return “INVALID.”</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the integrity check value:</li>

    </ol>

    <p class="text-gray-300">If <span class="math">\\mathrm{MSB}_{48}(P_1) \\neq ICV</span>, then return “INVALID.”</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the padding:</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">r</span> be the integer whose binary representation is <span class="math">\\mathrm{LSB}_8(\\mathrm{MSB}_{56}(P_1))</span>.</p>

    <p class="text-gray-300">If <span class="math">r &amp;gt; 63</span> or <span class="math">\\mathrm{LSB}_r(P_n) \\neq 0^r</span>, then return “INVALID”; else, return the unique string KeyData such that <span class="math">H \\parallel \\text{KeyData} \\parallel 0^r = P_2 \\parallel P_3 \\parallel \\ldots \\parallel P_n</span>.</p>

    <h2 id="sec-15" class="text-2xl font-bold">4.5 AESKW Wrapping</h2>

    <p class="text-gray-300">Prerequisites:</p>

    <p class="text-gray-300">—<span class="math">K</span>: key protection key, established among all the parties to the data;</p>

    <p class="text-gray-300">—ICV, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300">—<span class="math">H</span>, header string;</p>

    <p class="text-gray-300">—KeyData, key data string.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">—<span class="math">C_1, C_2, \\ldots, C_n</span>: ciphertext, <span class="math">n</span> 64 bit semiblocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Format the plaintext:</li>

    </ol>

    <p class="text-gray-300">Apply the plaintext formatting function (Section 4.3) to <span class="math">H</span> and KeyData to produce <span class="math">P_1, P_2, \\ldots, P_n</span>, a sequence of <span class="math">n</span> 64 bit semiblocks for some <span class="math">n</span>.</p>

    <p class="text-gray-300">7</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize variables:</li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">A^0 = P_1</span></p>

    <p class="text-gray-300">For  <span class="math">i = 2,\\dots ,n</span></p>

    <p class="text-gray-300"><span class="math">R_{i}^{0} = P_{i}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate intermediate values:</li>

    </ol>

    <p class="text-gray-300">For  <span class="math">t = 1,\\dots ,s</span>  ，where  <span class="math">s = 6(n - 1)</span></p>

    <p class="text-gray-300"><span class="math">A^i = \\mathrm{MSB}_{64}(\\mathrm{AES}_K(A^{i - 1}\\parallel R_2^{t - 1}))\\oplus [t]_{64};</span></p>

    <p class="text-gray-300">For  <span class="math">i = 2,\\dots ,n - 1</span></p>

    <p class="text-gray-300"><span class="math">R_{i}^{t} = R_{i + 1}^{t - 1};</span></p>

    <p class="text-gray-300"><span class="math">R_{n}^{t} = \\mathrm{LSB}_{64}(\\mathrm{AES}_{K}(A^{t - 1}\\parallel R_{2}^{t - 1}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the results:</li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">C_1 = A^s</span></p>

    <p class="text-gray-300">For  <span class="math">i = 2,\\dots ,n</span></p>

    <p class="text-gray-300"><span class="math">C_i = R_i^s</span></p>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">The following diagram illustrates the motion of the AESKW wrapping function. The variable that indexes the iterations,  <span class="math">t</span> , increases from 1 to  <span class="math">6(n - 1)</span> . The plaintext formatting function is not illustrated.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">Prerequisites</p>

    <p class="text-gray-300">— <span class="math">K</span> : key protection key, established among all the parties to the data;</p>

    <p class="text-gray-300">—ICV, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300">—H, header string;</p>

    <p class="text-gray-300"><span class="math">-C_{1}, C_{2}, \\ldots, C_{n}</span> : the ciphertext,  <span class="math">n</span>  64 bit semiblocks.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">—either "INVALID" or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize variables:</li>

    </ol>

    <p class="text-gray-300">Set  <span class="math">A^s = C_1</span> , where  <span class="math">s = 6(n - 1)</span> .</p>

    <p class="text-gray-300">For  <span class="math">i = 2,\\dots ,n</span></p>

    <p class="text-gray-300"><span class="math">R_{i}^{s} = C_{i}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate the intermediate values:</li>

    </ol>

    <p class="text-gray-300">For  <span class="math">t = s, s - 1, \\ldots, 1</span> :</p>

    <p class="text-gray-300"><span class="math">A^{t - 1} = \\mathrm{MSB}_{64}(\\mathrm{AES}^{-1}_K((A^t\\oplus [t]_{64})\\parallel R_n^t));</span></p>

    <p class="text-gray-300"><span class="math">R_{2}^{t - l} = \\mathrm{LSB}_{64}(\\mathrm{AES}^{-1}_{K}((A^{t}\\oplus [t]_{64})\\parallel R_{n}^{t}))</span></p>

    <p class="text-gray-300">For  <span class="math">i = 3,\\dots ,n</span></p>

    <p class="text-gray-300"><span class="math">R_{i}^{t - 1} = R_{i - 1}^{t}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the purported plaintext:</li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">P_{1} = A^{0}</span></p>

    <p class="text-gray-300">For  <span class="math">\\mathrm{i} = 2,\\dots,n</span></p>

    <p class="text-gray-300"><span class="math">P_{i} = \\mathbf{R}_{i}^{0}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the purported plaintext:</li>

    </ol>

    <p class="text-gray-300">Apply the integrity check function (Section 4.4) to  <span class="math">H</span>  and  <span class="math">P_{1}, P_{2}, \\ldots, P_{n}</span>  and return the result.</p>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">The following diagram illustrates the motion of the AESKW unwrapping function. The variable that indexes the iterations,  <span class="math">t</span> , decreases from 6(n-1) to 1. The integrity check function is not illustrated.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">TDKW is the analogue of AESKW with TDEA as the underlying block cipher. Thus, a semiblock now consists of 32 bits, and two semiblocks are essentially devoted to integrity protection.</p>

    <p class="text-gray-300">Below are specifications of the elements of TDKW: the data requirements, the formatting function, the integrity check function, the wrapping function, and the unwrapping function.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5.2 Data Requirements for TDKW</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The header, <span class="math">H</span>, shall be an octet string whose octet length is less than 256.</li>

      <li>The number of plaintext blocks, <span class="math">n</span>, shall satisfy <span class="math">2 \\leq n \\leq 2^{16}</span>.</li>

      <li>For any given key protection key, no more than <span class="math">2^{32}</span> inputs shall be wrapped in the lifetime of the key.</li>

    </ol>

    <h2 id="sec-20" class="text-2xl font-bold">5.3 TDKW Plaintext Formatting Function</h2>

    <p class="text-gray-300"><strong>Prerequisites:</strong> —ICV, integrity check value of 48 bits.</p>

    <p class="text-gray-300"><strong>Inputs:</strong> —H, header string; —KeyData, key data string.</p>

    <p class="text-gray-300"><strong>Outputs:</strong> —<span class="math">P_1, P_2, \\ldots, P_n</span>: plaintext, <span class="math">n</span> 32 bit semiblocks.</p>

    <p class="text-gray-300"><strong>Steps:</strong></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1) Let $s = (32 - (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyData</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)) \\mod 32$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">PadLen = [s]_8</span>, e.g., if <span class="math">s = 13</span> then <span class="math">Padlen = 00001101</span>.</li>

      <li>Let <span class="math">Hlen</span> be the binary representation of the octet length of <span class="math">H</span> as a string of 8 bits.</li>

      <li>Let <span class="math">P_1, P_2, \\ldots, P_n</span> be the sequence of semiblocks such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">P_1 \\parallel P_2 \\parallel \\ldots \\parallel P_n = ICV \\parallel PadLen \\parallel Hlen \\parallel H \\parallel KeyData \\parallel 0^s</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5.4 TDKW Integrity Check Function</h2>

    <p class="text-gray-300"><strong>Prerequisites:</strong> —ICV, integrity check value of 51 bits.</p>

    <p class="text-gray-300"><strong>Inputs:</strong> —H, header string; —<span class="math">P_1, P_2, \\ldots, P_n</span>: purported plaintext, sequence of 32 bit semiblocks.</p>

    <p class="text-gray-300"><strong>Outputs:</strong> —either “INVALID” or KeyData, a key data string.</p>

    <p class="text-gray-300"><strong>Steps:</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the header length:</li>

    </ol>

    <p class="text-gray-300">If <span class="math">H</span> is not an octet string of octet length <span class="math">\\mathrm{LSB}_8(P_2)</span>, then return “INVALID.”</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the header:</li>

    </ol>

    <p class="text-gray-300">If <span class="math">H</span> is not a prefix of <span class="math">P_3 \\parallel P_4 \\parallel \\ldots \\parallel P_n</span>, then return “INVALID.”</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the integrity check value:</li>

    </ol>

    <p class="text-gray-300">If <span class="math">\\mathrm{MSB}_{48}(P_1 \\parallel P_2) \\neq ICV</span>, then return “INVALID.”</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the padding:</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">r</span> be the integer whose binary representation is <span class="math">\\mathrm{LSB}_8(\\mathrm{MSB}_{24}(P_2))</span>. If <span class="math">r &amp;gt; 31</span> or <span class="math">\\mathrm{LSB}_r(P_n) \\neq 0^r</span>, then return “INVALID”; else, return the unique string KeyData such that <span class="math">H \\parallel KeyData \\parallel 0^r = P_3 \\parallel P_4 \\parallel \\ldots \\parallel P_n</span>.</p>

    <p class="text-gray-300">10</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">Prerequisites: —K: key protection key, established among all the parties to the data; —ICV, integrity check value of 48 bits.</p>

    <p class="text-gray-300">Inputs: —H, header string; —KeyData, key data string.</p>

    <p class="text-gray-300">Outputs: —<span class="math">C_1, C_2, \\ldots, C_n</span>: ciphertext, <span class="math">n</span> 32 bit semiblocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Format the key data and header into plaintext:</li>

    </ol>

    <p class="text-gray-300">Apply the plaintext formatting function (Section 5.3) to <span class="math">H</span> and KeyData to produce <span class="math">P_1, P_2, \\ldots, P_n</span>, a sequence of <span class="math">n</span> 32 bit semiblocks for some <span class="math">n</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize variables:</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">A^0 = P_1</span>. For <span class="math">i = 2, \\ldots, n</span>, <span class="math">R_i^0 = P_i</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate intermediate values:</li>

    </ol>

    <p class="text-gray-300">For <span class="math">t = 1, \\ldots, s</span>, where <span class="math">s = 6(n-1)</span>: <span class="math">A^t = \\mathrm{MSB}_{32}(\\mathrm{TDEA}_K(A^{t-1} \\parallel R_2^{t-1})) \\oplus [t]_{32}</span>; For <span class="math">i = 2, \\ldots, n-1</span>, <span class="math">R_i^t = R_{i+1}^{t-1}</span>; <span class="math">R_n^t = \\mathrm{LSB}_{32}(\\mathrm{TDEA}_K(A^{t-1} \\parallel R_2^{t-1}))</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the results:</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">C_1 = A^s</span>. For <span class="math">i = 2, \\ldots, n</span>, <span class="math">C_i = R_i^s</span>.</p>

    <p class="text-gray-300">Diagram: See the analogous diagram for the AESKW wrapping function in Section 4.5.</p>

    <p class="text-gray-300">Prerequisites —K: key protection key, established among all the parties to the data; —ICV, integrity check value of 51 bits.</p>

    <p class="text-gray-300">Inputs: —H, header string; —<span class="math">C_1, C_2, \\ldots, C_n</span>: the ciphertext, <span class="math">n</span> 32 bit semiblocks.</p>

    <p class="text-gray-300">Outputs: —either “INVALID” or KeyData, a key data string.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize variables:</li>

    </ol>

    <p class="text-gray-300">Set <span class="math">A^s = C_1</span>, where <span class="math">s = 6(n-1)</span>. For <span class="math">i = 2, \\ldots, n</span>, <span class="math">R_i^s = C_i</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate the intermediate values:</li>

    </ol>

    <p class="text-gray-300">For <span class="math">t = s, s-1, \\ldots, 1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">A^{t-1} = \\operatorname{MSB}_{32}(\\operatorname{TDEA}^{-1}_K((A^t \\oplus [t]_{32}) \\parallel R_n^t));</span></div>

    <div class="my-4 text-center"><span class="math-block">R_2^{t-1} = \\operatorname{LSB}_{32}(\\operatorname{TDEA}^{-1}_K((A^t \\oplus [t]_{32}) \\parallel R_n^t));</span></div>

    <p class="text-gray-300">For <span class="math">i = 3, \\ldots, n</span>,</p>

    <div class="my-4 text-center"><span class="math-block">R_i^{t-1} = R_{i-1}^t.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the purported plaintext:</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">P_1 = A^0</span>.</p>

    <p class="text-gray-300">For <span class="math">i = 2, \\ldots, n</span>,</p>

    <div class="my-4 text-center"><span class="math-block">P_i = R_i^0.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the purported plaintext:</li>

    </ol>

    <p class="text-gray-300">Apply the integrity check function (Section 5.4) to <span class="math">H</span> and <span class="math">P_1, P_2, \\ldots, P_n</span> and return the result.</p>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">See the analogous diagram for the AESKW unwrapping function in Section 4.6.</p>

    <h2 id="sec-24" class="text-2xl font-bold">6 AKW1</h2>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">6.1 Overview</h3>

    <p class="text-gray-300">AKW2 essentially employs two passes of CBC encryption: the first pass over the plaintext and a hash-based integrity check value, the second pass in reverse order over the results of the first pass. The elements of AKW1 are specified below: the data requirements, the wrapping function, and the unwrapping function. The formatting of key data into plaintext is not explicitly specified.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">6.2 Data Requirements for AKW1</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The number of plaintext blocks, <span class="math">n</span>, shall satisfy <span class="math">1 \\leq n \\leq 2^{16}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any given key protection key, no more than <span class="math">2^{32}</span> inputs shall be wrapped in the lifetime of the key.</li>

    </ol>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">6.3 AKW1 Wrapping</h3>

    <p class="text-gray-300">Prerequisites</p>

    <p class="text-gray-300">— <span class="math">K</span>: key protection key, established among all the parties to the data;</p>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300">— <span class="math">P_1, P_2, \\ldots, P_n</span>: the plaintext, <span class="math">n</span> 64 bit blocks.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">— <span class="math">C_1, C_2, \\ldots, C_{n+1}, C_{n+2}</span>: the ciphertext, <span class="math">n + 2</span> 64 bit blocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use an approved random bit generator to generate a random block of 64 bits. Call the result <span class="math">IV</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">ICV = \\mathrm{MSB}_{64}(\\mathrm{SHA1}(P_1 \\parallel P_2 \\parallel \\ldots \\parallel P_n))</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encrypt <span class="math">P_1 \\parallel P_2 \\parallel \\ldots \\parallel P_n \\parallel ICV</span>, using TDEA in CBC mode under <span class="math">K</span>, with <span class="math">IV</span> as the initialization vector. Call the resulting ciphertext <span class="math">TEMP1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">TEMP2 = IV \\parallel TEMP1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reverse the order of the octets in <span class="math">TEMP2</span>. That is, the most significant (first) octet is swapped with the least significant (last) octet, and so on. Call the result <span class="math">TEMP3</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encrypt <span class="math">TEMP3</span> using TDEA in CBC mode under <span class="math">K</span>, with the hexadecimal string <span class="math">0x4adda22c79e82105</span> as the initialization vector. Return the result as the ciphertext.</li>

    </ol>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">Prerequisites</p>

    <p class="text-gray-300">— <span class="math">K</span> : key protection key, established among all the parties to the data.</p>

    <p class="text-gray-300">Inputs:</p>

    <p class="text-gray-300"><span class="math">C_1, C_2, \\ldots, C_{n+1}, C_{n+2}</span> : the ciphertext,  <span class="math">n+2</span>  64 bit blocks.</p>

    <p class="text-gray-300">Outputs:</p>

    <p class="text-gray-300">—either "INVALID" or  <span class="math">P_{1}, P_{2}, \\ldots, P_{n}</span> : the plaintext sequence of  <span class="math">n</span>  64 bit blocks.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decrypt the ciphertext using TDEA in CBC mode under  <span class="math">K</span> , with the hexadecimal string 0x4adda22c79e82105 as the initialization vector. Call the result TEMP3.</li>

      <li>Reverse the order of the octets in TEMP3. That is, the most significant (first) octet is swapped with the least significant (last) octet, and so on. Call the result TEMP2.</li>

      <li>Let  <span class="math">IV</span>  be the single block and TEMP1 the concatenation of  <span class="math">n + 1</span>  blocks such that  <span class="math">\\mathrm{TEMP2} = IV \\parallel \\mathrm{TEMP1}</span> .</li>

      <li>Decrypt TEMP1 using TDEA in CBC mode under  <span class="math">K</span> , with  <span class="math">IV</span>  as the initialization vector. Call the result TEMP.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5) Let  <span class="math">P_{1}, P_{2}, \\ldots, P_{n}</span> ,  <span class="math">ICV</span>  be the  <span class="math">n + 1</span>  blocks for which  $\\mathrm{TEMP} = P_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{n} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ICV$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">The following is a diagram of the AKW1 unwrapping function; the verification of the integrity check value is not illustrated.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">AKW2 is essentially CBC mode encryption followed by CBC-MAC authentication of the header and ciphertext, where the two keys are related to the key protection key, and hence to each other, by a constant exclusive-OR difference. The data requirements, the wrapping function, and the unwrapping function for AKW2 are specified in Sections 7.2., 7.3, and 7.4, respectively.</p>

    <p class="text-gray-300">The formatting of the key data string into plaintext blocks, although mandated in the data requirements and verified within the unwrapping function, is not explicitly specified.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The number of plaintext blocks,  <span class="math">n</span> , shall satisfy  <span class="math">2 \\leq n \\leq 2^{16}</span> .</li>

      <li>For any given key protection key, no more than  <span class="math">2^{32}</span>  inputs shall be wrapped in the lifetime of the key.</li>

      <li>The parameter  <span class="math">Tlen</span>  shall be chosen between 32 and 64 and fixed for any given key protection key.</li>

      <li>The function for formatting valid key data strings into plaintext shall be one-to-one, i.e., unambiguously parsible.</li>

      <li>One (or more) of the following conditions shall be met:</li>

    </ol>

    <p class="text-gray-300">a) The parameter  <span class="math">Tlen</span>  is 32. b) The formatting of the first block of the header includes an explicit encoding of the length of the string  <span class="math">H_{1} \\parallel H_{2} \\parallel \\ldots \\parallel H_{j} \\parallel C_{1} \\parallel C_{2} \\parallel \\ldots \\parallel C_{n} \\parallel T</span> . c) The length of the plaintext is fixed for any given header.</p>

    <p class="text-gray-300">7.3 AKW2 Wrapping</p>

    <p class="text-gray-300">Prerequisites: — <span class="math">K</span>, key protection key, established among all the parties to the data; — Tlen, an integer parameter; — plaintext formatting function.</p>

    <p class="text-gray-300">Input: — <span class="math">H_1, H_2, \\ldots, H_j</span>: <span class="math">j</span> header blocks; — <span class="math">P_1, P_2, \\ldots, P_n</span>: formatted plaintext, a sequence of 64 bit blocks.</p>

    <p class="text-gray-300">Output: — <span class="math">C_1, C_2, \\ldots, C_n</span>: the ciphertext, a sequence of 64 bit blocks; — <span class="math">T</span>, message authentication code of bit length <span class="math">Tlen</span>.</p>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Derive the TDEA confidentiality subkey, denoted <span class="math">K&#x27;</span>, by exclusive-ORing each octet of <span class="math">K</span>, (including parity bits) with 0x45. Similarly, derive the TDEA authentication subkey, denoted <span class="math">K&#x27;&#x27;</span>, by exclusive-ORing each octet of <span class="math">K</span> with 0x4D.</li>

      <li>Encrypt the plaintext using the CBC mode of TDEA with the confidentiality subkey, <span class="math">K&#x27;</span>, and initialization vector <span class="math">H_1</span> to produce <span class="math">C_1, C_2, \\ldots, C_n</span>, the ciphertext.</li>

      <li>Apply the CBC-MAC mode of TDEA with the authentication subkey, <span class="math">K&#x27;&#x27;</span>, to the header blocks concatenated with the ciphertext blocks to produce the MAC:</li>

    </ol>

    <p class="text-gray-300">a) Let <span class="math">A_0 = 0^{64}</span>. b) For <span class="math">i = 1</span> to <span class="math">j</span>, let <span class="math">A_i = \\mathrm{TDEA}_{K&#x27;&#x27;}(H_i \\oplus A_{i-1})</span>. c) Let <span class="math">B_0 = A_j</span>. d) For <span class="math">i = 1</span> to <span class="math">n</span>, let <span class="math">B_i = \\mathrm{TDEA}_{K&#x27;&#x27;}(C_i \\oplus B_{i-1})</span>. e) Let <span class="math">T = \\mathrm{MSB}_{\\mathrm{Tlen}}(B_n)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">C_1, C_2, \\ldots, C_n, T</span>.</li>

    </ol>

    <p class="text-gray-300">Steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Derive the TDEA confidentiality subkey, denoted <span class="math">K&#x27;</span>, by exclusive-ORing each octet of <span class="math">K</span>, (including parity bits) with 0x45. Similarly, derive the TDEA authentication subkey, denoted <span class="math">K&#x27;&#x27;</span>, by exclusive-ORing each octet of <span class="math">K</span> with 0x4D.</li>

      <li>Encrypt the plaintext using the CBC mode of TDEA with the confidentiality subkey, <span class="math">K&#x27;</span>, and initialization vector <span class="math">H_1</span> to produce <span class="math">C_1, C_2, \\ldots, C_n</span>, the ciphertext.</li>

      <li>Apply the CBC-MAC mode of TDEA with the authentication subkey, <span class="math">K&#x27;&#x27;</span>, to the header blocks concatenated with the ciphertext blocks to produce the MAC:</li>

    </ol>

    <p class="text-gray-300">a) Let <span class="math">A_0 = 0^{64}</span>. b) For <span class="math">i = 1</span> to <span class="math">j</span>, let <span class="math">A_i = \\mathrm{TDEA}_{K&#x27;&#x27;}(H_i \\oplus A_{i-1})</span>. c) Let <span class="math">B_0 = A_j</span>. d) For <span class="math">i = 1</span> to <span class="math">n</span>, let <span class="math">B_i = \\mathrm{TDEA}_{K&#x27;&#x27;}(C_i \\oplus B_{i-1})</span>. e) Let <span class="math">T = \\mathrm{MSB}_{\\mathrm{Tlen}}(B_n)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">C_1, C_2, \\ldots, C_n, T</span>.</li>

    </ol>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Diagram:</p>

    <p class="text-gray-300">— <span class="math">K</span> , key protection key, established among all the parties to the data;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Tlen, an integer parameter;</li>

    </ul>

    <p class="text-gray-300">—a plaintext formatting function.</p>

    <p class="text-gray-300">—H1, H2, ..., Hj: j header blocks; —C1, C2, ... Cn: ciphertext, n 64 bit blocks; —  <span class="math">T^{\\prime}</span>  , the purported message authentication code of bit length Tlen.</p>

    <p class="text-gray-300">—either "INVALID" or KeyData, the key data string.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Derive the TDEA confidentiality subkey, denoted  <span class="math">K&#x27;</span> , by exclusive-ORing each octet of  <span class="math">K</span> , (including parity bits) with 0x45. Similarly, derive the TDEA authentication subkey, denoted  <span class="math">K&#x27;&#x27;</span> , by exclusive-ORing each octet of  <span class="math">K</span>  with 0x4D.</li>

      <li>Apply the CBC-MAC mode of TDEA with the authentication subkey to the header blocks concatenated with the ciphertext blocks to produce the MAC:</li>

    </ol>

    <p class="text-gray-300">a) Let  <span class="math">A_0 = 0^{64}</span> . b) For  <span class="math">i = 1</span>  to  <span class="math">j</span> , let  <span class="math">A_{i} = \\mathrm{TDEA}_{K^{\\prime \\prime}}(H_{\\mathrm{i}}\\oplus A_{i - 1})</span> c) Let  <span class="math">B_0 = A_j</span> d) For  <span class="math">i = 1</span>  to  <span class="math">n</span> , let  <span class="math">B_{i} = \\mathrm{TDEA}_{K^{\\prime \\prime}}(C_{i}\\oplus B_{i - 1})</span> e) Let  <span class="math">T = B_{n}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compare the purported MAC to the MAC that was produced in Step 2: if  <span class="math">T = T&#x27;</span> , then continue to Step 4; else return "INVALID."</li>

      <li>Decrypt  <span class="math">C_1, C_2, \\ldots, C_n</span>  using the CBC mode of TDEA with the confidentiality subkey  <span class="math">K&#x27;</span>  and initialization vector  <span class="math">H_1</span>  to produce  <span class="math">P_1, P_2, \\ldots, P_n</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the formatting of the plaintext with respect to the header, including the applicable element of Data Requirement 5 in Section 7.2. If the plaintext is validly formatted, return  <span class="math">P_{1}, P_{2}, \\ldots, P_{n}</span> ; else return "INVALID."</li>

    </ol>

    <p class="text-gray-300">Diagram:</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>`;
---

<BaseLayout title="Request for Review of Key Wrap Algorithms (2004/340)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/340
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
