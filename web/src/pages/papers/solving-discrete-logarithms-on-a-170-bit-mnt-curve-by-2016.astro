---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/507';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Solving discrete logarithms on a 170-bit MNT curve by pairing reduction';
const AUTHORS_HTML = 'Aurore Guillevic, François Morain, Emmanuel Thomé';

const CONTENT = `    <p class="text-gray-300">Aurore Guillevic^{4,5}, François Morain^{3}, and Emmanuel Thomé^{1,2}</p>

    <p class="text-gray-300">^{1} Institut national de recherche en informatique et en automatique (INRIA), Nancy, France emmanuel.thome@inria.fr ^{2} LORIA, CNRS UMR 7503, Nancy, France ^{3} École Polytechnique/LIX, CNRS UMR 7161, Palaiseau, France morain@lix.polytechnique.fr ^{4} University of Calgary, Alberta, Canada aurore.guillevic@ucalgary.ca ^{5} Pacific Institute for the Mathematical Sciences, CNRS UMI 3069, Canada</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Pairing based cryptography is in a dangerous position following the breakthroughs on discrete logarithms computations in finite fields of small characteristic. Remaining instances are built over finite fields of large characteristic and their security relies on the fact the embedding field of the underlying curve is relatively large. How large is debatable. The aim of our work is to sustain the claim that the combination of degree 3 embedding and too small finite fields obviously does not provide enough security. As a computational example, we solve the DLP on a 170-bit MNT curve, by exploiting the pairing embedding to a 508-bit, degree-3 extension of the base field.</p>

    <p class="text-gray-300">Keywords: Discrete logarithm, finite field, number field sieve, MNT elliptic curve</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Pairing-based cryptography</h3>

    <p class="text-gray-300">Pairings were introduced as a constructive cryptographic tool in 2000 by Joux <em>[29]</em>, who proposed a one-round three participants key-exchange. Numerous protocols also based on pairings have been developed since. Beyond efficient broadcast protocols, prominent applications include Identity-Based Encryption <em>[33, 34, 12]</em>, or short signatures <em>[13]</em>.</p>

    <p class="text-gray-300">The choice of appropriate curves and pairing definitions in the context of pairing-based cryptography has been the topic of many research articles. An important invariant is the degree of the embedding field, which measures the complexity of evaluating pairings, but is also related to the security of systems (see Section 2 for more precisions). The first cryptographic setups proposed used pairings on supersingular curves of embedding degree 2 defined over a prime field <span class="math">\\mathbb{F}_{p}</span>, where <span class="math">p</span> is 512-bit long, so that the pairing embeds into a 1024-bit finite field <span class="math">\\mathbb{F}_{p^{2}}</span>. Another early curve choice is a supersingular elliptic curve in characteristic three, defined over <span class="math">\\mathbb{F}_{3^{97}}</span>, of embedding degree 6 (used e.g. in <em>[13]</em>, as well as various implementation proposals, e.g. <em>[9]</em>). More recent proposals define pairing-friendly ordinary curves over large characteristic fields, where constraining the embedding degree to selected values is a desired property <em>[40, 15, 18, 14, 24, 21, 8, 22]</em>.</p>

    <p class="text-gray-300">Cryptanalysis of pairings can be attempted via two distinct routes. Either attack the discrete logarithm problem on the curve, or in the embedding field of the pairing considered. The former approach is rarely successful, given that it is usually easy to choose curves which are large enough to thwart <span class="math">O(\\sqrt{N})</span> attacks such as parallel collision search or Pollard rho. Note however that derived</p>

    <p class="text-gray-300">problems such as the discrete logarithm <em>with auxiliary inputs</em> are much easier to handle, as shown by <em>[44]</em>.</p>

    <p class="text-gray-300">Attacking pairings via the embedding field is a strategy known as the Menezes–Okamoto–Vanstone <em>[39]</em> or Frey–Rück <em>[23]</em> attack, depending on which pairing is considered. Successful cryptanalyses that follow this strategy have been described in small characteristic. In <em>[28]</em>, for a supersingular curve over <span class="math">\\mathbb{F}_{3^{97}}</span>, the small characteristic allowed the use of the Function Field Sieve algorithm <em>[1]</em>, and the composite extension degree was also a very useful property. More recently, following recent breakthroughs for discrete logarithm computation in small characteristic finite fields <em>[6, 26]</em>, a successful attack has been reported on a supersingular curve over <span class="math">\\mathbb{F}_{2^{1223}}</span>, with degree-4 embedding <em>[26]</em>. The outcome of these more recent works is that curves in small characteristic are now definitively avoided for pairing-based cryptography.</p>

    <p class="text-gray-300">As far as we know, there is no major record computation of discrete logarithms over pairing-friendly curves in large characteristic using a pairing reduction in the finite field. The pairing-friendly curves used in practice have a large embedding field of more than 1024 bits, where computing a discrete logarithm is still very challenging. A few curves in large characteristic have comparatively small embedding fields, and were identified as weak to this regard, although no practical computation to date demonstrated the criticality of this weakness. This includes the so-called MNT curves defined by Miyaji–Nakabayashi–Takano, e.g. <em>[40, Example 1]</em>, an elliptic curve defined over a 170-bit prime <span class="math">p</span>, and of 508-bit embedding field <span class="math">\\mathbb{F}_{p^{3}}</span>.</p>

    <p class="text-gray-300">Despite the academic agreement on the fact that the pairing embedding fields for 170-bit MNT curves in general, and the one just mentioned in particular, are too small for cryptographic use, recent work like <em>[2]</em> has shown how cryptography relying on overly optimistic hardness assumptions can linger almost indefinitely in the wild. Demonstrating a practical break is key to really phasing out such outdated cryptographic choices. As far as we know, an MNT curve of low embedding degree 3 was never used in pairing-based cryptography, but was never attacked by a pairing reduction either. In this article, we present our attack over the weak MNT curve <em>[40, Example 1]</em>, with <span class="math">p</span> of 170 bits and <span class="math">n=3</span>. We report a discrete logarithm computation in the group of points of this curve by a pairing reduction, using only a moderate amount of computing power.</p>

    <p class="text-gray-300">In order to attack the discrete logarithm problem in the embedding field, appropriate variants of the Number Field Sieve must be used. The crucial point is the adequate choice of a polynomial pair defining the Number Field Sieve setup, among the various choices proposed in the literature <em>[30, 38, 31, 5, 7]</em>. It is also important to arrange for the computation to take advantage of Galois automorphisms when available, both within sieving and linear algebra. Last, some care is needed in order to efficiently compute individual logarithms of arbitrary field elements.</p>

    <p class="text-gray-300">This article is organized as follows. Section 2 reviews some background and notations for MNT curves on the one hand, and the Number Field Sieve (NFS) as a general framework on the other hand. Section 3 discusses in more detail the various possible choices of polynomial selection techniques for NFS. Section 4 discusses the details of the discrete logarithm computation with NFS, while Section 4.3 defines and solves an arbitrary challenge on the MNT curve.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We follow e.g. [11, chap. IX]. To fix notations, pairings are defined as follows, the map being bilinear, non-degenerate and computable in polynomial time in the size of the inputs.</p>

    <div class="my-4 text-center"><span class="math-block">e: \\left\\{ \\begin{array}{c} E (\\mathbb {F} _ {p}) [ \\ell ] \\times E (\\mathbb {F} _ {p ^ {n}}) [ \\ell ] \\rightarrow \\mu_ {\\ell} \\subset \\mathbb {F} _ {p ^ {n}} ^ {*} \\\\ (P, Q) \\quad \\mapsto e (P, Q). \\end{array} \\right. \\tag {1}</span></div>

    <p class="text-gray-300">Here,  <span class="math">\\mu_{\\ell}</span>  is the subgroup of  <span class="math">\\ell</span> -th roots of unity, i.e. an element  <span class="math">u \\in \\mu_{\\ell}</span>  satisfies  <span class="math">u^{\\ell} = 1 \\in \\mathbb{F}_{p^n}^*</span> . The integer  <span class="math">n</span>  is the so-called embedding degree, that is the smallest integer  <span class="math">i</span>  for which the  <span class="math">\\ell</span> -torsion is contained in  <span class="math">\\mathbb{F}_{p^i}</span> . It has a major impact on evaluating the difficulty of solving the DLP on the curve.</p>

    <p class="text-gray-300">Let  <span class="math">G_{1}</span>  be a generator of  <span class="math">E(\\mathbb{F}_p)[\\ell]</span>  and  <span class="math">P</span>  in the same group, whose discrete logarithm  <span class="math">u</span>  is sought (so that  <span class="math">P = [u]G_{1}</span> ). We choose a generator  <span class="math">G_{2}</span>  for  <span class="math">E(\\mathbb{F}_{p^n})[\\ell]</span> . We observe that</p>

    <div class="my-4 text-center"><span class="math-block">e (P, G _ {2}) = e (G _ {1}, G _ {2}) ^ {u}</span></div>

    <p class="text-gray-300">so that  <span class="math">u</span>  can be recovered as the logarithm of  <span class="math">U = e(P, G_2)</span>  in base  <span class="math">T = e(G_1, G_2)</span> , where both elements belong to the subgroup of order  <span class="math">\\ell</span>  of  <span class="math">\\mathbb{F}_{p^n}^<em></span> . Note that by construction,  <span class="math">\\ell = O(p)</span> , so that the Number Field Sieve linear algebra phase has to be considered modulo  <span class="math">\\ell</span> , which is a priori much smaller than the largest prime order subgroup of  <span class="math">\\mathbb{F}_{p^n}^</em></span> , which has size  <span class="math">O(p^{\\phi(n)})</span> .</p>

    <p class="text-gray-300">The Miyaji-Nakabayashi-Takano curves were designed in 2000 in [40] as the first example of ordinary curves with low embedding degree  <span class="math">n = 3, 4</span> , or 6. The curves were presented as a weak instance of ordinary elliptic curves that should be avoided in elliptic-curve cryptography because of the Menezes-Okamoto-Vanstone and Frey-Rück attacks [39,23] that embed the computation of a discrete logarithm from the group of points of the curve to the embedding field  <span class="math">\\mathbb{F}_{p^n}</span> . At the 80-bit security level which was used in the 2000's, an elliptic curve of 160-bit prime order was considered safe, and of at least the same security as an 1024-bit RSA modulus. However for MNT curves over prime fields of 160 bits, the MOV and FR reduction attacks embed to finite fields of size 480, 640, or 960 bits, none of which should be considered as having a hard enough DLP. For these three cases and most of all for  <span class="math">n = 3</span> , computing a discrete logarithm in the embedding field is considerably easier than over the elliptic curve. The conclusion of the MNT paper was to advise developers to systematically check that the embedding degree of an elliptic curve is large enough, to avoid pairing reduction attacks. The authors also mentioned as a constructive use of their curves the prequel work of Kasahara, Ohgishi, and Sakai on identity-based encryption using pairings [33,34]. Some implementations using MNT curves exist, for example the Miracl Library proposes software on an MNT curve over a 170-bit prime, with embedding degree  <span class="math">n = 6</span> , providing a 80-bit security level.</p>

    <p class="text-gray-300"><strong>Construction of MNT curves</strong> The parameters  <span class="math">p</span> ,  <span class="math">\\tau</span> ,  <span class="math">\\ell</span>  (base field, trace, and number of points) of the curve are given by polynomials of degree at most two. For  <span class="math">n = 3, 4</span> , or 6, these are</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">embedding degree n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p = P(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">τ = Tr(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#E(Fp) = p + 1 - τ</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">12x2 - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">±6x - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">12x2 + 6x + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">x2 + x + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-x, or x + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">x2 + 2x + 2 or x2 + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4x2 + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">1 ± 2x</td>

            <td class="px-3 py-2 border-b border-gray-700">x2 + 2x + 2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">embedding degree n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2p (#E(Fp))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n log2p (#Fpn)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">80-bit security</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">170</td>

            <td class="px-3 py-2 border-b border-gray-700">510</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">170</td>

            <td class="px-3 py-2 border-b border-gray-700">680</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">170</td>

            <td class="px-3 py-2 border-b border-gray-700">1020</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. MNT curves as pairing-friendly curves in the 2000's</p>

    <p class="text-gray-300">To generate a curve, one needs to find an integer  <span class="math">y</span>  of the appropriate size, such that  <span class="math">p = P(y)</span>  is prime and  <span class="math">\\# E(\\mathbb{F}_p)</span>  is also prime, or equal to a small cofactor times a large prime. To compute the coefficients of the curve equation, a Pell equation need to be solved.</p>

    <p class="text-gray-300">The target curve Our target will be the MNT curve given in [40, Example 1]. We recall that the curve parameters satisfy</p>

    <p class="text-gray-300"><span class="math">y = -0x732c8cf5f983038060466</span></p>

    <p class="text-gray-300"><span class="math">p = 12y^{2} - 1 = 0x26dccacc5041939206cf2b7dec50950e3c9fa4827af</span>  of 170 bits</p>

    <p class="text-gray-300"><span class="math">\\tau = 6y - 1</span>  where  <span class="math">\\tau</span>  is the trace of the curve</p>

    <p class="text-gray-300"><span class="math">\\# E(\\mathbb{F}_p) = p + 1 - \\tau = 7^2 \\cdot 313 \\cdot \\ell</span>  where  <span class="math">\\ell</span>  is a 156-bit prime</p>

    <p class="text-gray-300"><span class="math">\\ell = 0xa60fd646ad409b3312c3b23ba64e082ad7b354d</span></p>

    <p class="text-gray-300">The pairing embeds into the prime order  <span class="math">\\ell</span>  subgroup of the cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^3}</span> , where  <span class="math">\\ell</span>  divides  <span class="math">p^2 + p + 1</span> .</p>

    <p class="text-gray-300">Our target field is  <span class="math">\\mathbb{F}_{p^n}</span> . NFS-DL starts by selecting two irreducible integer polynomials  <span class="math">f</span>  and  <span class="math">g</span>  such that  <span class="math">\\varphi = \\gcd(f \\bmod p, g \\bmod p)</span>  is irreducible of degree  <span class="math">n</span>  (construction of  <span class="math">f</span>  and  <span class="math">g</span>  is discussed in Section 3). We use the representation  <span class="math">\\mathbb{F}_{p^n} = \\mathbb{F}_p[x] / (\\varphi(x))</span> . Let  <span class="math">K_f = \\mathbb{Q}[x] / (f(x)) = \\mathbb{Q}(\\alpha)</span> , and  <span class="math">\\mathcal{O}_f</span>  be its ring of integers. Note that because  <span class="math">f</span>  is not necessarily monic,  <span class="math">\\alpha</span>  might not be an algebraic integer. Let  <span class="math">\\rho_f</span>  be the map from  <span class="math">K_f</span>  to  <span class="math">\\mathbb{F}_{p^n}</span> , sending  <span class="math">\\alpha</span>  to  <span class="math">T \\bmod (p, \\varphi(T))</span> . We define likewise  <span class="math">K_g = \\mathbb{Q}(\\beta)</span> , together with  <span class="math">\\mathcal{O}_g</span>  and  <span class="math">\\rho_g</span> . This installs the (typical) commutative diagram in Figure 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1.NFS-DL diagram for  <span class="math">\\mathbb{F}_{p^n}</span></p>

    <p class="text-gray-300">Given  <span class="math">f</span>  and  <span class="math">g</span> , we choose a smoothness bound  <span class="math">B</span>  and build factor bases  <span class="math">\\mathcal{F}_f</span>  (resp.  <span class="math">\\mathcal{F}_g</span> ) consisting of prime ideals in  <span class="math">\\mathcal{O}_f</span>  (resp.  <span class="math">\\mathcal{O}_g</span> ) of norm less than  <span class="math">B</span> , to which we add prime ideals dividing  <span class="math">\\operatorname{lc}(f)</span>  (resp.  <span class="math">\\operatorname{lc}(g)</span> ) to take into account the fact that  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  are not algebraic integers. Then, we collect relations, that is polynomials  <span class="math">\\phi(x) \\in \\mathbb{Z}[x]</span>  such that both ideals  <span class="math">\\langle \\phi(\\alpha) \\rangle</span>  and  <span class="math">\\langle \\phi(\\beta) \\rangle</span>  are smooth,</p>

    <p class="text-gray-300">namely factor completely over <span class="math">\\mathcal{F}_{f}</span> (resp. <span class="math">\\mathcal{F}_{g}</span>). Smoothness is related to <span class="math">\\mathrm{Norm}(\\phi(\\alpha))</span>, and in turn to <span class="math">\\mathrm{Res}(f,\\phi)</span> since we have</p>

    <p class="text-gray-300"><span class="math">\\pm\\operatorname{lc}(f)^{\\deg(\\phi)}\\mathrm{Norm}(\\phi(\\alpha))=\\mathrm{Res}(f,\\phi).</span></p>

    <p class="text-gray-300">When <span class="math">\\phi</span> is such that the integers <span class="math">\\mathrm{Res}(f,\\phi)</span> and <span class="math">\\mathrm{Res}(g,\\phi)</span> are <span class="math">B</span>-smooth (only prime factors below <span class="math">B</span>), we have a relation:</p>

    <p class="text-gray-300">\\[ \\left\\{&\\phi(\\alpha)\\mathcal{O}_{f}=\\prod_{\\mathfrak{q}\\in\\mathcal{F}_{f}}\\mathfrak{q}^{\\operatorname{val}_{\\mathfrak{q}}(\\phi(\\alpha))},\\\\ &\\phi(\\beta)\\mathcal{O}_{g}=\\prod_{\\mathfrak{r}\\in\\mathcal{F}_{f}}\\mathfrak{r}^{\\operatorname{val}_{\\mathfrak{r}}(\\phi(\\beta))}\\right. \\]</p>

    <p class="text-gray-300">that are transformed as linear relation between virtual logarithms of ideals <em>[47]</em>, to which are added the so-called Schirokauer maps <em>[46]</em>, labelled <span class="math">\\lambda_{f,i}</span> for <span class="math">1\\leq i\\leq r_{f}</span> where <span class="math">r_{f}</span> is the unit rank of <span class="math">K_{f}</span> (and the same for <span class="math">g</span>).</p>

    <p class="text-gray-300">To overcome the problem of dealing with fractional ideals instead of integral ideals, we use the following result from <em>[41]</em> (see also <em>[19]</em>).</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Let <span class="math">f(X)=\\sum_{i=0}^{d}c_{i}X^{i}</span> with coprime integer coefficients and <span class="math">\\alpha</span> a root of <span class="math">f</span>. Let</p>

    <p class="text-gray-300"><span class="math">J_{f}=\\langle c_{d},c_{d}\\alpha+c_{d-1},c_{d}\\alpha^{2}+c_{d-1}\\alpha+c_{d-2},\\ldots,c_{d}\\alpha^{d-1}+c_{d-1}\\alpha^{d-2}+\\cdots+c_{1}\\rangle.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then <span class="math">\\langle 1,\\alpha\\rangle J_{f}=(1)</span>, <span class="math">J_{f}</span> has norm $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>J_{f}\\langle a-b\\alpha\\rangle<span class="math"> is an integral ideal for integers </span>a<span class="math"> and </span>b$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\phi(X)</span> has degree <span class="math">k-1</span>, we have <span class="math">\\mathrm{Norm}(J_{f}^{k-1}\\langle\\phi(\\alpha)\\rangle)=\\pm\\operatorname{Res}(f,\\phi)</span>, so that we can read off the factorization of the integral <span class="math">J_{f}^{k-1}\\langle\\phi(\\alpha)\\rangle</span> directly from the factorization of its norm. A relation can now be written as:</p>

    <p class="text-gray-300"><span class="math">(k-1)\\operatorname{vlog}(J_{f})+\\sum_{\\mathfrak{q}\\in\\mathcal{F}_{f}}\\operatorname{val}_{\\mathfrak{q}}(\\phi(\\alpha))\\operatorname{vlog}(\\mathfrak{q})+\\sum_{i=1}^{r_{f}}\\lambda_{f,i}(\\phi(\\alpha))\\operatorname{vlog}(\\lambda_{f,i})</span> <span class="math">\\equiv(k-1)\\operatorname{vlog}(J_{g})+\\sum_{\\mathfrak{r}\\in\\mathcal{F}_{g}}\\operatorname{val}_{\\mathfrak{r}}(\\phi(\\beta))\\operatorname{vlog}(\\mathfrak{r})+\\sum_{i=1}^{r_{g}}\\lambda_{g,i}(\\phi(\\beta))\\operatorname{vlog}(\\lambda_{g,i})\\bmod\\ell.</span></p>

    <p class="text-gray-300">We select as many <span class="math">\\phi(x)</span> of degree at most <span class="math">k-1</span> (for <span class="math">k\\geq 2</span> and very often <span class="math">k=2</span>) as needed to find <span class="math">\\#\\mathcal{F}_{f}+\\#\\mathcal{F}_{g}+r_{f}+r_{g}+2</span> relations. Note that <span class="math">J_{f}</span> and <span class="math">J_{g}</span> are not always prime ideals. Nevertheless since all their prime divisors have a grouped contribution for each relation, we may count them as single columns. We may even replace the two columns by one, corresponding to <span class="math">\\operatorname{vlog}(J_{f})-\\operatorname{vlog}(J_{g})</span> (e.g. this is done in cado-nfs).</p>

    <p class="text-gray-300">Given sufficiently many equations, the linear system in the virtual logarithms can be solved using sparse linear algebra techniques such as the Block Wiedemann algorithm <em>[17]</em>. When we want to compute the logarithm of a given target, we need to rewrite some power (or some multiple) of the target as a multiplicative combination of the images in <span class="math">\\mathbb{F}_{p^{n}}</span> of the factor base ideals, and use the precomputed data base of computed logarithms. Section 4 will briefly discusses algebraic factorization in practice.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3 Polynomial Selection</h2>

    <p class="text-gray-300">The polynomial selection is the first step of the NFS algorithm. Polynomial selection is rather cheap, but care is needed since the quality of the polynomial pair it outputs conditions the running time</p>

    <p class="text-gray-300">of the three next steps. Sections 3.1 and 3.1 below explain the two phases of polynomial selection. In a nutshell, we first decide from which family the polynomials are chosen, and then we search among possible solutions for "exceptionally good" polynomials. Note that because all degree  <span class="math">n</span>  irreducible polynomials correspond to isomorphic finite fields  <span class="math">\\mathbb{F}_{p^n}</span> , we are not constrained in the choice of  <span class="math">\\operatorname{Res}(f, g)</span> . This degree of freedom allows to select good polynomials.</p>

    <p class="text-gray-300">As of 2016, the available polynomial selection algorithms are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the Conjugation method (Conj) [5, §. 3.3], explained in Algorithm 1;</li>

      <li>the Generalized Joux-Lercier method (GJL) [5, §. 3.2] and [38] that produces polynomials of unbalanced coefficient sizes (see Algorithm 2 in Appendix A);</li>

      <li>the Joux-Lercier-Smart-Vercauteren method (JLSV <span class="math">_1</span> ) [30, §. 2.3], explained in Algorithm 3, that produces two polynomials of degree  <span class="math">n</span>  and coefficient size in  <span class="math">O(\\sqrt{p})</span>  for both polynomials;</li>

      <li>the second proposition (JLSV <span class="math">_2</span> ) of the same paper [30, §. 3.2];</li>

      <li>the Joux-Pierrot (JP) method for pairing-friendly curves [31] which produces polynomials equivalent to the Conjugation method for MNT curves (Algorithm 4);</li>

      <li>the TNFS method of Barbulescu, Gaudry and Kleinjung [7].</li>

    </ul>

    <p class="text-gray-300">Remark 1 (Non-applicable methods.). The Sarkar-Singh and Kim-Barculescu methods [45,35] do not apply to finite fields of prime extension degree  <span class="math">n</span>  such as  <span class="math">\\mathbb{F}_{p^3}</span> . The TNFS method is not better than the best above methods for our practical case study, as shown in the paper [7, §5].</p>

    <p class="text-gray-300">Algorithm 1 presents the Conjugation method, which eventually provided the best yield. Pseudocode describing the other methods can be found in Appendix A.</p>

    <p class="text-gray-300">| Algorithm 1: Polynomial selection with the Conjugation method [5, §3.3] |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">| Input: p prime and n integer Output: f, g, ψ with f, g ∈ Z[x] irreducible and ψ = gcd(f mod p, g mod p) in Fp[x] irreducible of degree n |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 repeat 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Select g1(x), g0(x), two polynomials with small integer coefficients, deg g1 < deg g0 = n</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| 4 until a(y) has a root y in Fp and ψ(x) = g0(x) + yg1(x) is irreducible in Fp[x] |</p>

    <p class="text-gray-300">| 5 f ← Resy(a(y), g0(x) + yg1(x)) |</p>

    <p class="text-gray-300">| 6 (u, v) ← a rational reconstruction of y |</p>

    <p class="text-gray-300">| 7 g ← vg0 + ug1 |</p>

    <p class="text-gray-300">| 8 return (f, g, ψ) |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The various methods above yield polynomial pairs whose characteristics differ significantly. Table 2 gives the expected degrees and coefficient sizes. From this data, we can derive bounds on the resultants on both sides of a relation (either using the coarse bound  $(\\deg f + \\deg \\phi)! \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg \\phi} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg f}$ , or finer bounds such as [10, Th. 7], as used in [7, §. 3.2]). These norms should be minimized in order to obtain the best running-time for the NFS algorithm. We obtain the plot of Figure 2 for the bit-size of the product of norms, similar to [5, Fig. 3].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2 suggests that the GJL method yields the smallest norms for  <span class="math">\\log_2Q = 508</span> . The norms produced with the Conjugation and  <span class="math">\\mathrm{JLSV}_1</span>  methods are not very far however so we compared more</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">D+1≥n+1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log p)</td>

            <td class="px-3 py-2 border-b border-gray-700">D≥n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Q1/(D+1))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JP or Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">2n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log p)</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Q1/(2n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Q1/(2n))</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Q1/(2n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV2</td>

            <td class="px-3 py-2 border-b border-gray-700">D≥n+1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Q1/(D+1))</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Q1/(D+1))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. Norm bound for four polynomial selection methods for  <span class="math">\\mathbb{F}_{p^3}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">precisely these three methods for our 170-bit parameters. This entails finding competitive polynomial pairs for each method, and comparing their merits. Estimated bounds as well as experimental values for the products of norms for  <span class="math">\\log_2Q = 508</span>  are reported in Table 3. Results of sieving on one slide of special-  <span class="math">q</span>  is reported in Table 4. The algorithms and computed polynomials are given in Appendix A. The theoretical bound  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  equals one bit in the Conjugation and GJL methods whereas in practice to improve the smoothness properties of  </span>f<span class="math"> , we have chosen a polynomial with moderately larger coefficients, and with better  </span>\\alpha<span class="math">  and Murphy&#x27;s E values (see [42, §5.2 eq. (5.7)] on Murphy&#x27;s E value). The coefficient size of  </span>g<span class="math">  selected with the GJL, Conj and JLSV </span>_1<span class="math">  methods is a few bits larger than the theoretical bound because we computed linear combinations of two distinct  </span>g<span class="math"> , and of  </span>f<span class="math">  and the initial  </span>g<span class="math">  in the JLSV </span>_1<span class="math">  case (since they are of same degree). The advantage of the hybrid Joux-Pierrot method (Algorithm 5) in the MNT case is that  </span>g$  can be monic, which does not allow for linear combinations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Norm bound w.r.t.  <span class="math">Q</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Norm bound f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Norm bound g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">product</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bound</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">bound</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">bound</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">bound</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">bound</td>

            <td class="px-3 py-2 border-b border-gray-700">exp.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">127</td>

            <td class="px-3 py-2 border-b border-gray-700">130</td>

            <td class="px-3 py-2 border-b border-gray-700">106</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">208</td>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">314</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">157</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">164</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">328</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">hybrid JP</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">157</td>

            <td class="px-3 py-2 border-b border-gray-700">168</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">164</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">331</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">164</td>

            <td class="px-3 py-2 border-b border-gray-700">326</td>

            <td class="px-3 py-2 border-b border-gray-700">327</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV2</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">180</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">386</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Norm bounds in bits for  <span class="math">\\log Q = 508</span>  and  <span class="math">\\log E = 25.25</span> : estimates based on Table 2, compared to experimental values with our selected polynomials.</p>

    <p class="text-gray-300">Galois actions: For small extension degrees <span class="math">n\\in\\{3,4,6\\}</span> there exist families of polynomials producing number fields with cyclic Galois groups, and an easy-to-compute automorphism <em>[20, Prop. 1.2]</em>. Taking polynomials from these families yields a speed-up in the sieving part as well as in the linear algebra part for the JLSV_{1} and Conjugation methods. We take <span class="math">g=x^{3}-y_{0}x^{2}-(y_{0}+3)x-1</span> for the Conjugation method, i.e. <span class="math">g_{0}=x^{3}-3x-1</span> and <span class="math">g_{1}=-x^{2}-x</span> in Algorithm 1. The Galois action is <span class="math">\\sigma(x)=(-x-1)/x</span> which is independent of the parameter <span class="math">y_{0}</span>. In that case, given the factorization for <span class="math">\\langle a-b\\alpha\\rangle</span>, we can deduce that of</p>

    <p class="text-gray-300"><span class="math">\\sigma(\\langle a-b\\alpha\\rangle)=\\langle a-b\\sigma(\\alpha)\\rangle=-\\frac{1}{\\alpha}(b-(-a-b)\\alpha).</span></p>

    <p class="text-gray-300">The same holds on the <span class="math">f</span> side.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Forming a database of good polynomials <span class="math">f</span>.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the Conjugation method (and similarly for the competing methods), the early steps in Algorithm 1 can be tabulated in some way, depending only on the extension degree <span class="math">n</span> (and for JLSV_{1}, also on the size of <span class="math">p</span>, but not its value): we can store a database of <span class="math">f</span>’s with good smoothness properties (low <span class="math">\\alpha</span> and high Murphy’s E values). Actually we searched over <span class="math">a(y)=a_{2}y^{2}+a_{1}y+a_{0}</span>, where <span class="math">0&lt;a_{2}&lt;32</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><32<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><512<span class="math">, and computed </span>f=\\mathrm{Res}_{y}(a(y),x^{3}-yx^{2}-(y+3)x-1)<span class="math">. Later, depending on </span>p<span class="math">, we can continue Algorithm 1 for these precomputed polynomials (test whether </span>a<span class="math"> has a root modulo </span>p$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note also that in Algorithm 1, the rational reconstruction step naturally produces several quotients <span class="math">u/v</span>, which yield several candidate polynomials <span class="math">g</span>. Small linear combinations of these polynomials can be tried, in order to improve on the Murphy’s E value.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2 Probing the sieving yield</h3>

    <p class="text-gray-300">To finalize the comparison between the polynomials, we compared the relation yield for small special-<span class="math">q</span> ranges sampled over the complete special-<span class="math">q</span> space. Because the JLSV_{1} and Conjugation methods feature balanced norms, we used similar large prime bounds (27 bits) on both sides in both cases, and allowed two large prime on each side. In contrast, for the GJL method, we allowed 28-bit large primes on the <span class="math">g</span> side, and chose <span class="math">q</span> to be only on that side. The Conjugation method (polynomial below) appeared as the best option based on the seconds/relation measure, given that the overall yield was sufficient. Results of this test are reported on Table 4.</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{ll}f&=28x^{6}+16x^{5}-261x^{4}-322x^{3}+79x^{2}+152x+28\\\\ \\alpha(f)&=-2.94\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}&=8.33\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">g&=24757815186639197370442122\\ x^{3}+40806897040253680471775183\\ x^{2}\\\\ &&-33466548519663911639551183x-24757815186639197370442122\\\\ \\alpha(g)&=-4.16\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}&=85.08,\\ \\mbox{the optimal being}\\ \\frac{1}{2}\\log_{2}p=85\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathrm{E}(f,g)&=1.31\\cdot 10^{-12}\\end{array} \\] (2)</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Solving DLP over <span class="math">\\mathbb{F}_{p^{3}}</span></h2>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.1 Sieving and linear algebra</h3>

    <p class="text-gray-300">We took a smoothness bound of <span class="math">50\\times 10^{6}</span> on both sides; and all special-<span class="math">q</span> in <span class="math">[50\\times 10^{6},2^{27}]</span>, on both sides. This took roughly 660 core-days, normalized on the most common hardware used, namely</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">seconds/relation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">relations/special-q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">remarks</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Generalized Joux-Lercier</td>

            <td class="px-3 py-2 border-b border-gray-700">3.48</td>

            <td class="px-3 py-2 border-b border-gray-700">4.96</td>

            <td class="px-3 py-2 border-b border-gray-700">0+3 large primes below 228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.31</td>

            <td class="px-3 py-2 border-b border-gray-700">4.24</td>

            <td class="px-3 py-2 border-b border-gray-700">2+2 large primes below 227, orbits of</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjugation</td>

            <td class="px-3 py-2 border-b border-gray-700">0.91</td>

            <td class="px-3 py-2 border-b border-gray-700">5.93</td>

            <td class="px-3 py-2 border-b border-gray-700">three special-q batched together</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Probed yield for special-  <span class="math">q</span>  ranges. Cpu time on Intel Xeon E5520 (2.27GHz).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4-core Intel Xeon E5520 CPUs (2.27GHz). We collected 57070251 relations, out of which 34740801 were non duplicate. Filtering produced a  <span class="math">1982791 \\times 1982784</span>  matrix  <span class="math">M</span>  with weight 396558692. Taking into account the block of 7 Schirokauer maps  <span class="math">S</span> , the matrix  $M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S$  is square.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We computed 8 sequences in the Block Wiedemann algorithm, using the trick mentioned in [17, §8], as programmed in cado-nfs (rediscovered and further analyzed in [32]). All these sequences can be computed independently. Computation time for the 8 Krylov sequence was about 250 core-days (Xeon E5-2650, 2.4GHz, using four 16-core nodes per sequence). Finding the linear (matrix) generator for the matrices took 75 core-hours, parallelized over 64 cores. Building the solution costed some more 170 core-days. We reconstructed virtual logarithms for 15196345 out of the 15206761 factor base elements (99.9%). This was good enough to start looking for individual logarithms.</p>

    <p class="text-gray-300">From the linear algebra step, we know how to compute the logarithm modulo  <span class="math">\\ell</span>  of any element of  <span class="math">\\mathbb{F}_{p^3}</span>  whose lift in either  <span class="math">K_{f}</span>  or  <span class="math">K_{g}</span>  factors completely over the factor base. Lifting in  <span class="math">K_{f}</span>  is often convenient because norms are smaller.</p>

    <p class="text-gray-300">The tiny case. A particular element which lifts conveniently in  <span class="math">K_{f}</span>  is the common root  <span class="math">t</span>  of both polynomials. By construction, its lift  <span class="math">\\alpha \\in K_{f}</span>  generates a principal (fractional) ideal that factors as  <span class="math">J_{f}^{-1}</span>  (see Proposition 1) times prime ideals of norm dividing 28, namely:  <span class="math">(\\alpha) = I_{2,0}^{2}I_{2,\\infty}^{-2}I_{7,0}I_{7,\\infty}^{-1}</span> , where  <span class="math">I_{2,\\infty}^{2}I_{7,\\infty}</span>  corresponds to  <span class="math">J_{f}</span>  and the prime ideals in the right-hand side can be made explicit. Its logarithm therefore writes as</p>

    <p class="text-gray-300"><span class="math">\\log (t) = 2\\mathrm{vlog}I_{2,0} - 2\\mathrm{vlog}I_{2,\\infty} + \\mathrm{vlog}I_{7,0} - \\mathrm{vlog}I_{7,\\infty} + \\sum_{i = 1}^{5}\\lambda_{f,i}(\\alpha)\\mathrm{vlog}(\\lambda_{f,i}).</span></p>

    <p class="text-gray-300"><span class="math">\\lambda_{f,1}(\\alpha) = 0 \\times 3720106a3d368d7f731a0757b905778050ae327, \\lambda_{f,2}(\\alpha) = 0 \\times 1dbeace7d0ec187712ae8afcd6ccdc4db06f781,</span></p>

    <p class="text-gray-300"><span class="math">\\lambda_{f,3}(\\alpha) = 0 \\times 9c3109f7741d625869f135706be03fc09375450, \\lambda_{f,4}(\\alpha) = 0 \\times 1e46653b287d99c502a5c6e12ab17a3dd10988c,</span></p>

    <p class="text-gray-300"><span class="math">\\lambda_{f,5}(\\alpha) = 0 \\times 31628f3e0b491e622946b32f66292c1389a7427.</span></p>

    <p class="text-gray-300">By construction the value  <span class="math">\\log (t)</span>  above is invertible modulo  <span class="math">\\ell</span> , and we can freely normalize our virtual logarithm values so that it is equal to one.</p>

    <p class="text-gray-300">The tame case. Elements whose lifts do not factor completely over any of the factor base but have only moderate-size outstanding factors can be dealt with using a classical descent procedure. This finds recursively new relations involving smaller and smaller primes, until all primes involved belong to the factor base. Software achieving this exists, such as the las_descent program in cado-nfs.</p>

    <p class="text-gray-300">The general case.</p>

    <p class="text-gray-300">For computing individual logarithms of arbitrary elements, we used the boot technique described in <em>[27]</em>. For each target, we compute a preimage in <span class="math">\\mathbb{Z}[x]</span> represented by a polynomial of degree at most <span class="math">5</span> and coefficients bounded by <span class="math">p^{1/3}</span>. The norm in <span class="math">K_{f}</span> of the preimage is <span class="math">O(p^{2})=O(Q^{2/3})</span>, of approximately <span class="math">340</span> bits. The asymptotic complexity of this step is <span class="math">L_{Q}[1/3,1.26]</span>, and would be <span class="math">L_{Q}[1/3,1.132]</span> with one early-abort test (see e.g. <em>[43, §4.3]</em> or <em>[3, Ch. 4]</em>). The optimal size of largest prime factors in the decomposition is given by the formula <span class="math">L_{Q}[2/3,(e^{2}/3)^{1/3}\\approx 0.529]</span>, where <span class="math">e=2/3</span> (see <em>[16, §4]</em>). Applying it for <span class="math">\\log_{2}Q=508</span> gives a bound of <span class="math">68</span> bits and a running-time of approximately <span class="math">2^{42}</span> tests. In practice we found very easily initial splittings where <span class="math">B_{1}</span> is less than <span class="math">64</span> bits, which eased the descent.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.3 Solving the challenge</h3>

    <p class="text-gray-300">Our main use case for individual logarithm computation in <span class="math">\\mathbb{F}_{p^{3}}</span> is to solve a DLP challenge on the curve. The challenge definition procedure described in Appendix B gives:</p>

    <p class="text-gray-300"><span class="math">G_{1}</span> <span class="math">=\\left(0\\text{\\times}106\\text{\\text{b}}415\\text{\\text{d}}7\\text{\\text{b}}4\\text{\\text{a}}2\\text{\\text{d}}71659\\text{\\text{a}}e97440\\text{\\text{c}}b\\text{\\text{b}}20\\text{\\text{a}}6\\text{\\text{d}}e42\\text{\\text{d}}76\\text{\\text{d}}69,0\\text{\\text{\\text{}}}</span> <span class="math">0\\text{\\text{\\text{}}}</span> <span class="math">16\\text{\\text{\\text{d}}}</span> <span class="math">74\\text{\\text{\\text{a}}}</span> <span class="math">2\\text{\\text{a}}88\\text{\\text{e}}817\\text{\\text{f}}1821\\text{\\text{a}}1\\text{\\text{c}}40\\text{\\text{e}}220\\text{\\text{d}}34\\text{\\text{e}}e\\text{\\text{c}}93\\text{\\text{e}}33\\text{\\text{c}}b83\\right),</span> <span class="math">P</span> $=\\left(0\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text{\\text</p>

    <p class="text-gray-300">the largest factor having 54 bits, a very small size indeed (compared to the 68 bits predicted by theory). The descent procedure for other primes took 10.7 hours. We found that</p>

    <p class="text-gray-300"><span class="math">\\log(S) = 0 \\times 48a6bcf57cacca997658c98a0c196c25116a0aa</span>  (normalized to  <span class="math">\\log t = 1</span> ).</p>

    <p class="text-gray-300">We eventually found that</p>

    <p class="text-gray-300"><span class="math">\\log_{G_1}(P) = 0 \\times 711d13ed75e05cc2ab2c9ec2c910a98288ec038 \\bmod \\ell.</span></p>

    <p class="text-gray-300">Our work showed that the choice of embedding degree  <span class="math">n</span>  and finite field size  <span class="math">\\log p^n</span>  should be done carefully. The size of  <span class="math">\\mathbb{F}_{p^n}</span>  should be large enough to provide the desired level of security. We recall these sizes for  <span class="math">\\mathbb{F}_{p^3}</span> . The recent improvement of Kim-Barculescu [36] does not apply to  <span class="math">\\mathbb{F}_{p^n}</span>  where  <span class="math">n</span>  is prime, so  <span class="math">\\mathbb{F}_{p^3}</span>  is not affected. The asymptotic complexity of the NFS algorithm for  <span class="math">\\mathbb{F}_{p^3}</span>  is  <span class="math">\\exp((c + o(1))(\\log p^n)^{1/3}(\\log \\log p^n)^{2/3}) = L_{p^3}[1/3, (64/9)^{1/3}]</span> . Since there is a polynomial factor hidden in the notation  <span class="math">c + o(1)</span> , taking  <span class="math">\\log_2 L_{p^3}[1/3, (64/9)^{1/3}]</span>  does not give the exact security level but only an approximation. We may compare our present record with previous records of same size for prime fields  <span class="math">\\mathbb{F}_p</span>  and quadratic fields  <span class="math">\\mathbb{F}_{p^2}</span> . Kleinjung in 2007 announced a record computation in a prime field  <span class="math">\\mathbb{F}_p</span>  of 530 bits (160 decimal digits) [37]. Barbulescu, Gaudry, Guillevic and Morain in 2014 announced a record computation in  <span class="math">\\mathbb{F}_{p^2}</span>  of 529 bits (160 decimal digits) [4]. We compare the timings in Table 5. The timings of relation collection and linear algebra were not balanced in Kleinjung record: 3.3 years compared to 14 years and moreover, this is a quite old record so it is not really possible to compare our record with this one directly. We can compare our record with the 529-bit  <span class="math">\\mathbb{F}_{p^2}</span>  record computation of 2014 [4]. Our total running-time is 15.5 times longer whereas the finite field is 21 bit smaller.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">record</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">relation collection</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">linear algebra</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">individual log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">total</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kleinjung [37]</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3 CPU-years</td>

            <td class="px-3 py-2 border-b border-gray-700">14 years</td>

            <td class="px-3 py-2 border-b border-gray-700">few hours</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">530-bit field</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2 GHz Xeon64</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2 GHz Xeon64</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2 GHz Xeon64</td>

            <td class="px-3 py-2 border-b border-gray-700">17.3 years</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BGGM [4]</td>

            <td class="px-3 py-2 border-b border-gray-700">68 core-days = 0.19y</td>

            <td class="px-3 py-2 border-b border-gray-700">30.3 hours</td>

            <td class="px-3 py-2 border-b border-gray-700">few hours</td>

            <td class="px-3 py-2 border-b border-gray-700">70 days</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">529-bit field</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0 GHz E5-2650</td>

            <td class="px-3 py-2 border-b border-gray-700">NVidia GTX 680 graphic card</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0 GHz E5-2650</td>

            <td class="px-3 py-2 border-b border-gray-700">= 0.2 year</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700">660 core-days = 1.81y</td>

            <td class="px-3 py-2 border-b border-gray-700">423 days =1.16y</td>

            <td class="px-3 py-2 border-b border-gray-700">2 days</td>

            <td class="px-3 py-2 border-b border-gray-700">1085 days</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">508-bit field</td>

            <td class="px-3 py-2 border-b border-gray-700">2.27GHz 4-core Xeon E5520</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4 GHz Xeon E5-2650</td>

            <td class="px-3 py-2 border-b border-gray-700">2.27GHz 4-core Xeon E5520</td>

            <td class="px-3 py-2 border-b border-gray-700">= 2.97 years</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Comparison of running-time for Discrete Logarithm records in  <span class="math">{\\mathbb{F}}_{p},{\\mathbb{F}}_{p}{}^{2}</span>  and  <span class="math">{\\mathbb{F}}_{p}{}^{3}</span>  of 530,529 and 508 bits.</p>

    <p class="text-gray-300">We have computed a DLP on an MNT curve with embedding degree 3. What are the next candidates? We could continue the series in two directions: increasing the size of  <span class="math">p</span>  to 600 bits, in order to compare this new record to the previous records of the same size, in particular the  <span class="math">\\mathbb{F}_{p^2}</span>  record of 600 bits [5]. We could conjecture, according to the present record and the size of the norms, that a DLP record in  <span class="math">\\mathbb{F}_{p^3}</span>  of 600 bits will be more than 15 times harder than in a 600-bit field  <span class="math">\\mathbb{F}_{p^2}</span> .</p>

    <p class="text-gray-300">The second direction would be to continue the series of MNT curves, with  <span class="math">n = 4</span> . We found an MNT curve of embedding degree 4 in Miracl (file k4mnt.ecs). The curve was generated by Drew Sutherland for Mike Scott a long time ago.</p>

    <p class="text-gray-300"><span class="math">y = 0\\mathrm{xf}19192168\\mathrm{b}16\\mathrm{c}1315\\mathrm{d}33</span></p>

    <p class="text-gray-300"><span class="math">p = y^{2} + y + 1 = 0\\mathrm{xe}3\\mathrm{f}367\\mathrm{d}542\\mathrm{c}82027\\mathrm{f}33\\mathrm{d}\\mathrm{c}5\\mathrm{f}3245769\\mathrm{e}676\\mathrm{a}5755\\mathrm{d}</span></p>

    <p class="text-gray-300"><span class="math">\\ell = 0 \\times 6 \\mathrm{~b} 455 \\mathrm{e} 0 \\mathrm{a} 014 \\mathrm{f} 1 \\mathrm{e} 30 \\mathrm{e} \\mathrm{a} \\mathrm{e} \\mathrm{f} 7300 \\mathrm{b} \\mathrm{d} 4 \\mathrm{b} \\mathrm{b} 4258290 \\mathrm{f} \\mathrm{c} 5</span></p>

    <p class="text-gray-300"><span class="math">\\tau = y + 1 = 0 \\times f 19192168 b 16 c 1315 d 34</span></p>

    <p class="text-gray-300"><span class="math">\\# E(\\mathbb{F}_p) = y^2 + 1 = p + 1 - \\tau = 2 \\cdot 17 \\cdot \\ell</span></p>

    <p class="text-gray-300">Since  <span class="math">n</span>  is a prime power, we have to adapt the Kim-Barculescu technique (dedicated to non-prime power  <span class="math">n</span> ) to prime-power extension degrees. We construct  <span class="math">\\mathbb{F}_{p^4}</span>  as  <span class="math">\\mathbb{F}_{p^2}[x] / (\\varphi(x))</span> , where  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p[s] / (h_1(s))</span>  and both  <span class="math">h_1</span>  and  <span class="math">\\varphi</span>  are of degree 2, and  <span class="math">\\varphi</span>  has coefficients in  <span class="math">\\mathbb{F}_{p^2}</span> . As a consequence, the polynomials  <span class="math">f</span>  and  <span class="math">g</span>  will have coefficients in  <span class="math">\\mathbb{Z}[s] / (h_1(s))</span>  instead of  <span class="math">\\mathbb{Z}</span> . For example, one could take</p>

    <p class="text-gray-300"><span class="math">h_1(s) = s^2 + 2,</span></p>

    <p class="text-gray-300"><span class="math">h_2(x,t_0,s) = x^2 +s + t_0,</span></p>

    <p class="text-gray-300"><span class="math">P(t_0) = t_0^2 +t_0 + 1,</span></p>

    <p class="text-gray-300"><span class="math">f = \\operatorname{Res}_{t_0}(P(t_0), h_2(x, t_0, s)) = x^4 + (2s - 1)x^2 - s - 1,</span></p>

    <p class="text-gray-300"><span class="math">g = h_{2}(x,y,s) = x^{2} + s + 0\\mathrm{xf19192168b16c1315d33}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The major difference is that to be efficient, we have to sieve polynomials of degree 1 with coefficients in  <span class="math">\\mathbb{Z}[s] / (h_1(s))</span> , that is elements of the form  <span class="math">(a_0 + a_1s) + (b_0 + b_1s)x</span>  where the  <span class="math">a_i</span> 's and  <span class="math">b_i</span> 's are small rational integers, say  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq A<span class="math"> . For instance, taking  </span>\\log_2(E) = 1.1(\\log Q)^{1/3}(\\log \\log Q)^{2/3} \\approx 28<span class="math"> , we obtain  </span>A = E^{2/(2\\deg h)}<span class="math">  of 14 bits. The upper bound on the norm would be of 120 bits on  </span>f<span class="math"> -side and 219 bits on  </span>g<span class="math"> -side, the total being roughly of 339 bits. This is 11 bits more than our present record for the 508-bit  </span>n = 3<span class="math">  MNT curve (328 bits, Table 3), but by far much less than with any previous technique applied to that  </span>\\mathbb{F}_{p^4}$ . Norm estimates are provided in Table 6. From a practical point of view, we would need extensions of the work [25].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6. Norm bound estimates for  <span class="math">{\\mathbb{F}}_{p4}</span>  of 640 bits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NBf</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NBg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NBf + NBg</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kim-Barculescu+hybrid JP</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">219</td>

            <td class="px-3 py-2 border-b border-gray-700">339</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GJL</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">243</td>

            <td class="px-3 py-2 border-b border-gray-700">387</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV1</td>

            <td class="px-3 py-2 border-b border-gray-700">320</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">195</td>

            <td class="px-3 py-2 border-b border-gray-700">195</td>

            <td class="px-3 py-2 border-b border-gray-700">390</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sarkar-Singh, r = 2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">394</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JP-Conj</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">159</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">399</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JLSV2, D = 6 (D best choice)</td>

            <td class="px-3 py-2 border-b border-gray-700">91</td>

            <td class="px-3 py-2 border-b border-gray-700">91</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">470</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Acknowledgements. The authors are grateful to Pierrick Gaudry for his help in running the computations.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>L. M. Adleman and M.-D. Huang. Function field sieve methods for discrete logarithms over finite fields. Inform. and Comput., 151(1):5-16, 1999.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry, M. Green, J. A. Halderman, N. Heninger, D. Springall, E. Thomé, L. Valenta, B. VanderSloot, E. Wustrow, S. Z. Béguelin, and P. Zimmermann. Imperfect forward secrecy: How Diffie-Hellman fails in practice. In I. Ray, N. Li, and C. Kruegel:, editors, ACM CCS 15, pages 5–17. ACM Press, Oct. 2015.</li>

      <li>[3] R. Barbulescu. Algorithmes de logarithmes discrets dans les corps finis. PhD thesis, Université de Lorraine, 2013.</li>

      <li>[4] R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Discrete logarithms in GF(<span class="math">p^{2}</span>) — 160 digits. Announcement on the Number Theory List, Jun 2014. https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;2ddabd4c.1406.</li>

      <li>[5] R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part I, volume 9056 of Lecture Notes in Comput. Sci., pages 129–155. Springer, Heidelberg, Apr. 2015.</li>

      <li>[6] R. Barbulescu, P. Gaudry, A. Joux, and E. Thomé. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In P. Q. Nguyen and E. Oswald, editors, EUROCRYPT 2014, volume 8441 of Lecture Notes in Comput. Sci., pages 1–16. Springer, Heidelberg, May 2014.</li>

      <li>[7] R. Barbulescu, P. Gaudry, and T. Kleinjung. The tower number field sieve. In T. Iwata and J. H. Cheon, editors, ASIACRYPT 2015, Part II, volume 9453 of Lecture Notes in Comput. Sci., pages 31–55. Springer, Heidelberg, Dec. 2015.</li>

      <li>[8] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In B. Preneel and S. Tavares, editors, SAC 2005, volume 3897 of Lecture Notes in Comput. Sci., pages 319–331. Springer, Heidelberg, Aug. 2006.</li>

      <li>[9] J. Beuchat, N. Brisebarre, J. Detrey, E. Okamoto, M. Shirase, and T. Takagi. Algorithms and arithmetic operators for computing the <span class="math">\\eta_{T}</span> pairing in characteristic three. IEEE Trans. Computers, 57(11):1454–1468, 2008.</li>

      <li>[10] Y. Bistritz and A. Lifshitz. Bounds for resultants of univariate and bivariate polynomials. Linear Algebra and its Applications, 432(8):1995 – 2005, 2010. Special issue devoted to the 15th ILAS Conference at Cancun, Mexico, June 16-20, 2008.</li>

      <li>[11] I. F. Blake, G. Seroussi, and N. Smart. Advances in Elliptic Curve Cryptography, volume 317 of London Mathematical Society Lecture Note Series. Cambridge University Press, 2005.</li>

      <li>[12] D. Boneh and M. K. Franklin. Identity-based encryption from the Weil pairing. In J. Kilian, editor, CRYPTO 2001, volume 2139 of Lecture Notes in Comput. Sci., pages 213–229. Springer, Heidelberg, Aug. 2001.</li>

      <li>[13] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In C. Boyd, editor, ASIACRYPT 2001, volume 2248 of Lecture Notes in Comput. Sci., pages 514–532. Springer, Heidelberg, Dec. 2001.</li>

      <li>[14] F. Brezing and A. Weng. Elliptic curves suitable for pairing based cryptography. Des. Codes Cryptogr., 37(1):133–141, 2005.</li>

      <li>[15] C. Cocks and R. G. Pinch. ID-based cryptosystems based on the Weil pairing, 2001. Unpublished manuscript.</li>

      <li>[16] A. Commeine and I. Semaev. An algorithm to solve the discrete logarithm problem with the number field sieve. In M. Yung, Y. Dodis, A. Kiayias, and T. Malkin, editors, PKC 2006, volume 3958 of Lecture Notes in Comput. Sci., pages 174–190. Springer, Heidelberg, Apr. 2006.</li>

      <li>[17] D. Coppersmith. Solving homogeneous linear equations over GF(2) via block Wiedemann algorithm. Math. Comp., 62(205):333–350, 1994.</li>

      <li>[18] R. Dupont, A. Enge, and F. Morain. Building curves with arbitrary small MOV degree over finite prime fields. Journal of Cryptology, 18(2):79–89, Apr. 2005.</li>

      <li>[19] R. M. Elkenbracht-Huizing. An implementation of the number field sieve. Experiment. Math., 5(3):231–253, 1996.</li>

      <li>[20] K. Foster. HT90 and “simplest” number fields. Illinois J. Math., 55(4):1621–1655, 2011.</li>

      <li>[21] D. Freeman. Constructing pairing-friendly elliptic curves with embedding degree 10. In F. Hess, S. Pauli, and M. E. Pohst, editors, Algorithmic Number Theory, 7th International Symposium, ANTS-VII, Berlin, Germany, July 23-28, 2006, Proceedings, volume 4076 of Lecture Notes in Comput. Sci., pages 452–465. Springer, 2006.</li>

      <li>[22] D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing-friendly elliptic curves. Journal of Cryptology, 23(2):224–280, Apr. 2010.</li>

      <li>[23] G. Frey and H. G. Rück. A remark concerning m-divisibility and the discrete logarithm in the divisor class group of curves. Math. Comp., 62(206):865–874, 1994.</li>

      <li>[24] S. D. Galbraith, J. F. McKee, and P. C. Valença. Ordinary abelian varieties having small embedding degree. Finite Fields and Their Applications, 13(4):800–814, 2007.</li>

      <li>[25] P. Gaudry, L. Grémy, and M. Videau. Collecting relations for the number field sieve in <span class="math">GF(p^{6})</span>. Cryptology ePrint Archive, Report 2016/124, 2016. https://eprint.iscr.org/2016/124.</li>

      <li>[26] R. Granger, T. Kleinjung, and J. Zumbrägel. Breaking ’128-bit secure’ supersingular binary curves - (or how to solve discrete logarithms in <span class="math">\\mathbb{F}_{2^{4}\\cdot 1223}</span> and <span class="math">\\mathbb{F}_{2^{12}\\cdot 367}</span>). In J. A. Garay and R. Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of Lecture Notes in Comput. Sci., pages 126–145. Springer, Heidelberg, Aug. 2014.</li>

    </ul>

    <p class="text-gray-300">27] A. Guillevic. Computing individual discrete logarithms faster in <span class="math">\\mathrm{GF}(p^{n})</span> with the NFS-DL algorithm. In T. Iwata and J. H. Cheon, editors, ASIACRYPT 2015, Part I, volume 9452 of Lecture Notes in Comput. Sci., pages 149–173. Springer, Heidelberg, Dec. 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[28] T. Hayashi, T. Shimoyama, N. Shinohara, and T. Takagi. Breaking pairing-based cryptosystems using <span class="math">\\eta_{T}</span> pairing over <span class="math">\\mathrm{GF}(3^{97})</span>. In X. Wang and K. Sako, editors, ASIACRYPT 2012, volume 7658 of Lecture Notes in Comput. Sci., pages 43–60. Springer, Heidelberg, Dec. 2012.</li>

      <li>[29] A. Joux. A one round protocol for tripartite Diffie-Hellman. In W. Bosma, editor, ANTS-IV, volume 1838 of Lecture Notes in Comput. Sci., pages 385–394. Springer, 2000.</li>

      <li>[30] A. Joux, R. Lercier, N. Smart, and F. Vercauteren. The number field sieve in the medium prime case. In C. Dwork, editor, CRYPTO 2006, volume 4117 of Lecture Notes in Comput. Sci., pages 326–344. Springer, Heidelberg, Aug. 2006.</li>

      <li>[31] A. Joux and C. Pierrot. The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> - application to pairing-friendly constructions. In Z. Cao and F. Zhang, editors, PAIRING 2013, volume 8365 of Lecture Notes in Comput. Sci., pages 45–61. Springer, Heidelberg, Nov. 2014.</li>

      <li>[32] A. Joux and C. Pierrot. Nearly sparse linear algebra. Cryptology ePrint Archive, Report 2015/930, 2015. http://eprint.iacr.org/2015/930.</li>

      <li>[33] M. Kasahara, K. Ohgishi, and R. Sakai. Notes on ID-based key sharing systems on elliptic curve. Technical report, IEICE, Nov. 1999.</li>

      <li>[34] M. Kasahara, K. Ohgishi, and R. Sakai. Cryptosystems based on pairing. In The 2000 Symposium on Cryptography and Information Security, volume SCIS2000-C20, Jan. 2000.</li>

      <li>[35] T. Kim. Extended tower number field sieve: A new complexity for medium prime case. Cryptology ePrint Archive, Report 2015/1027, 2015. http://eprint.iacr.org/2015/1027.</li>

      <li>[36] T. Kim and R. Barbulescu. Extended Tower Number Field Sieve: A New Complexity for Medium Prime Case. preprint, Mar. 2016.</li>

      <li>[37] T. Kleinjung. Discrete logarithms in <span class="math">\\mathrm{GF}(p)</span> — 160 digits. Announcement on the Number Theory List, Feb 2007. https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;1c737cf8.0702.</li>

      <li>[38] D. Matyukhin. Effective version of the number field sieve for discrete logarithms in the field <span class="math">\\mathrm{GF}(p^{k})</span> (in Russian). Tr. Diskr. Mat., 9:121–151, 2006. http://m.mathnet.ru/php/archive.phtml?vshow=paper&jrnid=tdm&paperid=144&option_lang=eng.</li>

      <li>[39] A. Menezes, T. Okamoto, and S. A. Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. IEEE Transactions on Information Theory, 39(5):1639–1646, 1993.</li>

      <li>[40] A. Miyaji, M. Nakabayashi, and S. Takano. Characterization of elliptic curve traces under FR-reduction. In D. Won, editor, ICISC 00, volume 2015 of Lecture Notes in Comput. Sci., pages 90–108. Springer, Heidelberg, Dec. 2001.</li>

      <li>[41] P. L. Montgomery. Square roots of products of algebraic numbers, 1997. Unpublished draft, dated May 16, 1997.</li>

      <li>[42] B. A. Murphy. Polynomial Selection for the Number Field Sieve Integer Factorisation Algorithm. PhD thesis, Australian National University, 1999.</li>

      <li>[43] C. Pomerance. Analysis and comparison of some integer factoring algorithms. In H. W. J. Lenstra and R. Tijdeman, editors, Computational methods in number theory, part I, volume 154 of Mathematical Centre Tracts, pages 89–139. Mathematisch Centrum, Amsterdam, 1982. available in pdf at http://oai.cwi.nl/oai/asset/19571/19571A.pdf.</li>

      <li>[44] Y. Sakemi, G. Hanaoka, T. Izu, M. Takenaka, and M. Yasuda. Solving a discrete logarithm problem with auxiliary input on a 160-bit elliptic curve. In M. Fischlin, J. Buchmann, and M. Manulis, editors, PKC 2012, volume 7293 of Lecture Notes in Comput. Sci., pages 595–608. Springer, Heidelberg, May 2012.</li>

      <li>[45] P. Sarkar and S. Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In M. Fischlin and J.-S. Coron, editors, EUCROCRYPT 2016, Lecture Notes in Comput. Sci., May 2016. http://eprint.iacr.org/2015/944.</li>

      <li>[46] O. Schirokauer. Discrete logarithms and local units. Philos. Trans. Roy. Soc. London Ser. A, 345(1676):409–423, 1993.</li>

      <li>[47] O. Schirokauer. Virtual logarithms. J. Algorithms, 57(2):140–147, 2005.</li>

    </ul>

    <h2 id="sec-22" class="text-2xl font-bold">Appendix A Polynomial selection methods</h2>

    <p class="text-gray-300">We provide in this section the algorithms of the polynomial selection methods that we compared in Section 3, together with the polynomials computed for our <span class="math">\\mathbb{F}_{p^{3}}</span> record.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Input:  <span class="math">p</span>  prime,  <span class="math">n</span>  integer and  <span class="math">d \\geq n</span>  integer</p>

    <p class="text-gray-300">Output:  <span class="math">f, g, \\psi</span>  with  <span class="math">f, g \\in \\mathbb{Z}[x]</span>  irreducible and  <span class="math">\\psi = \\gcd(f \\bmod p, g \\bmod p)</span>  in  <span class="math">\\mathbb{F}_p[x]</span>  irreducible of degree  <span class="math">n</span></p>

    <p class="text-gray-300">1 Choose a polynomial  <span class="math">f(x)</span>  of degree  <span class="math">d + 1</span>  with small integer coefficients which has a monic irreducible factor  <span class="math">\\psi(x) = \\psi_0 + \\psi_1 x + \\dots + x^n</span>  of degree  <span class="math">n</span>  modulo  <span class="math">p</span> 2 Reduce the following matrix using LLL</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">return  <span class="math">(f,g = g_0 + g_1x + \\dots +g_dx^d,\\psi)</span></p>

    <p class="text-gray-300">Generalized Joux-Lercier method. The first step of Algorithm 2 is to choose a polynomial  <span class="math">f</span>  of degree 4 in our context. We need  <span class="math">f</span>  to factor as a linear polynomial times a degree 3 polynomial modulo  <span class="math">p</span> , hence we cannot allow for a degree two subfield, or any of the Galois groups C4, V4 or D4. We extracted from the Magma number field database the list of irreducible polynomials of degree 4 and Galois group A4 (of order 12), class number one and signature (0,2) (592 polynomials) and (4,0) (3101 polynomials).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In step 2 of Algorithm 2, the LLL algorithm outputs four polynomials  <span class="math">g_{1}</span> ,  <span class="math">g_{2}</span> ,  <span class="math">g_{3}</span>  and  <span class="math">g_{4}</span>  with small coefficients. To obtain the smallest possible coefficients, we set the LLL parameters to  <span class="math">\\delta = 0.99999</span>  and  <span class="math">\\eta = 0.50001</span> . We compute linear combinations  <span class="math">g = \\sum_{i=1}^{4} \\lambda_{i} g_{i}</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 2^{5} \\cdot \\min_{1 \\leq i \\leq 4} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  (roughly speaking,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 32<span class="math"> ) so that the size of the coefficients of  </span>g<span class="math">  do not increase too much, while we can obtain a polynomial  </span>g<span class="math">  with a better Murphy&#x27;s  </span>\\mathbb{E}$  value.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then we run Algorithm 2 with our modified step 2 for each polynomial  <span class="math">f</span>  in our database and we selected the pair with the highest Murphy's  <span class="math">\\mathbb{E}</span>  value. We obtained</p>

    <p class="text-gray-300"><span class="math">f</span> <span class="math">= x^{4} - 2x^{3} + 2x^{2} + 4x + 2</span> <span class="math">\\alpha (f)</span> <span class="math">= 1.2</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\log_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 2$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">g</span> <span class="math">= 133714102332614336563681181193704960555x^3</span> <span class="math">+173818706907699496668994559342802299969x^2</span> <span class="math">+878019651910536420352249995702628405053x</span> <span class="math">-185403948115503498471378323785210605885</span> <span class="math">\\alpha (g)</span> <span class="math">= -2.1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\log_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 129.37<span class="math">  , the optimal being  </span>\\frac{3}{4}\\log_2p = 127.5$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbb{E}(f,g)</span> <span class="math">= 5.08\\cdot 10^{-13}</span></p>

    <p class="text-gray-300">Joux-Lercier-Smart-Vercauteren method. The Joux-Lercier-Smart-Vercauteren method, described in Algorithm 3, is possibly the most straightforward polynomial selection method adapted to non-prime finite fields. It is possible to force this method to pick polynomials  <span class="math">f</span>  within a specific family, in order to force nice Galois properties. For example, we may use the form  <span class="math">\\psi = x^3 - tx^2 - (t + 3)x - 1</span> .</p>

    <p class="text-gray-300">The enumeration was the largest for the  <span class="math">\\mathrm{JLSV}_1</span>  method: we searched over  <span class="math">2^{25}</span>  polynomials  <span class="math">f</span>  in the cyclic family  <span class="math">x^3 - t_0 x^2 - (t_0 + 3)x - 1</span> , with a parameter  <span class="math">t_0</span>  of 84 up to 85 bits. We kept the</p>

    <p class="text-gray-300">|  Algorithm 3: Polynomial selection with the JLSV1 method [30, §2.3]  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: p prime and n integer  |   |</p>

    <p class="text-gray-300">|  Output: f, g ∈ Z[x] irreducible and ψ = gcd(f mod p, g mod p) ∈ Fp[x] irreducible of degree n  |   |</p>

    <p class="text-gray-300">|  1 Select f1(x), f0(x), two polynomials with small integer coefficients, deg f1 < deg f0 = n  |   |</p>

    <p class="text-gray-300">|  2 repeat  |   |</p>

    <p class="text-gray-300">|  3 choose y ≈ [√p]  |   |</p>

    <p class="text-gray-300">|  4 (u, v) ← a rational reconstruction of y modulo p (different from y/1)  |   |</p>

    <p class="text-gray-300">|  5 g ← vf0 + uf1  |   |</p>

    <p class="text-gray-300">|  6 until f = f0 + yf1 and g are irreducible in Fp[x]  |   |</p>

    <p class="text-gray-300">|  7 return (f, g, ψ = f mod p)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">polynomials whose  <span class="math">\\alpha</span>  value was less than  <span class="math">-3.0</span> . We then continued Algorithm 3 selectively for these good precomputed polynomials. The "initial"  <span class="math">g</span>  (say  <span class="math">g_0</span> ) produced by Algorithm 3 can be improved by using instead any linear combination  <span class="math">g = \\lambda f + \\mu g_0</span>  for small  <span class="math">\\lambda</span>  and  <span class="math">\\mu</span> , thereby improving the Murphy's E value. We set  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^5$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">f</span> <span class="math">= x^{3} - 30145663100857939296343446x^{2} - 30145663100857939296343449x - 1</span> <span class="math">\\alpha (f)</span> <span class="math">= -3.0</span> $\\log_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 84.64<span class="math"> </span>g<span class="math"> </span>= 30145663100857939299699540x^3 +46845274144495980578316407x^2<span class="math"> </span>-43591715158077837320782213x - 30145663100857939299699540<span class="math"> </span>\\alpha (g)<span class="math"> </span>= -2.8<span class="math"> </span>\\log_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 85.28<span class="math">  , the optimal being  </span>\\frac{1}{2}\\log_2p = 85<span class="math"> </span>\\operatorname {E}(f,g)<span class="math"> </span>= 1.02\\cdot 10^{-12}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Conjugation and Joux-Pierrot methods. The Joux-Pierrot method produces polynomials with the same degree and coefficient properties as the Conjugation method for MNT curves and that are moreover monic. The polynomials constructed with the Conjugation method allow a factor two speed-up thanks to a Galois automorphism. We propose here a hybrid variant in Algorithm 5 for pairing-friendly curves. The conjugation method, in Algorithm 1, is the one which eventually produced the best polynomial pair.</p>

    <p class="text-gray-300">|  Algorithm 4: Polynomial selection with the Joux-Pierrot method [31]  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: p prime, p = P(x0) where P is a degree d ≥ 2 polynomial, and n integer  |   |</p>

    <p class="text-gray-300">|  Output: f, g, ψ with f, g ∈ Z[x] irreducible and ψ = gcd(f mod p, g mod p) in Fp[x] irreducible of degree n  |   |</p>

    <p class="text-gray-300">|  1 repeat  |   |</p>

    <p class="text-gray-300">|  2 Choose g(x) = x^n + R(x) - x0 with R of small degree and tiny coefficients  |   |</p>

    <p class="text-gray-300">|  3 f(x) ← P(x^n + R(x)) // where P is the polynomial s.t. p = P(x0)  |   |</p>

    <p class="text-gray-300">|  4 until f and g are irreducible  |   |</p>

    <p class="text-gray-300">|  5 return (f, g, ψ = g)  |   |</p>

    <p class="text-gray-300">For the Conjugation method as well as the hybrid method of Algorithm 5, and similarly to the  <span class="math">\\mathrm{JLSV}_1</span>  method, it is possible to choose polynomials  <span class="math">g</span>  of the form  <span class="math">\\psi = x^3 - tx^2 - (t + 3)x - 1</span>  to allow a Galois automorphism of degree 3.</p>

    <p class="text-gray-300">|  Algorithm 5: Polynomial selection, variant of Joux-Pierrot and Conjugation methods  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: p prime, p = P(y) with deg P ≥ 2 and P of tiny coefficients, and n integer  |   |</p>

    <p class="text-gray-300">|  Output: f, g, ψ with f, g ∈ Z[x] irreducible and ψ = gcd(f mod p, g mod p) in Fp[x] irreducible of degree n  |   |</p>

    <p class="text-gray-300">|  1 repeat  |   |</p>

    <p class="text-gray-300">|  2 Select g1(x), g0(x), two polynomials with small integer coefficients, deg g1 < deg g0 = n  |   |</p>

    <p class="text-gray-300">|  3 Select small integers a, b, c, d  |   |</p>

    <p class="text-gray-300">|  4 ψ(x) = g0(x) + (a + by/c + dy mod p) g1(x)  |   |</p>

    <p class="text-gray-300">|  5 f ← ResY(P(Y), (c + dY)g0(x) + (a + bY)g1(x))  |   |</p>

    <p class="text-gray-300">|  6 g ← (c + dy)g0(x) + (a + by)g1(x) // g ≡ (c + dy)ψ(x) mod p  |   |</p>

    <p class="text-gray-300">|  7  |   |</p>

    <p class="text-gray-300">|  8 until ψ(x) is irreducible in Fp[x] and f, g are irreducible in Z[x]  |   |</p>

    <p class="text-gray-300">|  9 return (f, g, ψ)  |   |</p>

    <p class="text-gray-300">In practice, in Algorithm 5 one might prefer to constrain  <span class="math">d = 0</span> , so that  <span class="math">g</span>  has small leading coefficient  <span class="math">c</span> . Going further and requiring  <span class="math">c = 1</span>  so that  <span class="math">g</span>  is monic reduces however too much the possibilities to find a good pair of polynomials.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following example has been obtained with Algorithm 5, searching over all  <span class="math">(a + by) / c</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 256$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">y = -8702303353090049898316902</span>  is the targeted MNT curve parameter</p>

    <p class="text-gray-300"><span class="math">f = 108x^{6} + 1116x^{5} + 3347x^{4} + 2194x^{3} - 613x^{2} - 468x + 108</span></p>

    <p class="text-gray-300"><span class="math">g = 6x^{3} + 34809213412360199593267639x^{2} + 34809213412360199593267621x - 6</span></p>

    <p class="text-gray-300"><span class="math">= 6x^{3} - (4y - 31)x^{2} - (4y - 13)x - 6</span></p>

    <p class="text-gray-300"><span class="math">\\varphi = \\frac{1}{6} g \\bmod p = x^3 + 151460167298404651346258165094598961506004769966481x^2</span></p>

    <p class="text-gray-300">+151460167298404651346258165094598961506004769966478  <span class="math">x - 1</span></p>

    <p class="text-gray-300">We first compute a generator  <span class="math">G_{1}</span>  of  <span class="math">E(\\mathbb{F}_p)[\\ell]</span>  by taking a point  <span class="math">G_{0}</span>  on the curve and multiplying it by the cofactor  <span class="math">\\frac{\\#E(\\mathbb{F}_p)}{\\ell}</span> . For simplicity, we took the smallest possible  <span class="math">x</span> -coordinate such that  <span class="math">(x^{3} + ax + b)</span>  is a square and took the square root  <span class="math">y</span>  of even least significant bit (lsb). This gives:</p>

    <p class="text-gray-300"><span class="math">G_{0} = (2,0\\times 17\\mathrm{b}2192\\mathrm{d}9\\mathrm{f}643\\mathrm{d}079\\mathrm{f}733\\mathrm{d}3\\mathrm{a}6\\mathrm{a}5372\\mathrm{c}469\\mathrm{d}\\mathrm{e}\\mathrm{a}666\\mathrm{c}\\mathrm{e})</span></p>

    <p class="text-gray-300"><span class="math">G_{1} = (0\\times 106\\mathrm{b}415\\mathrm{d}7\\mathrm{b}4\\mathrm{a}2\\mathrm{d}71659\\mathrm{a}\\mathrm{e}97440\\mathrm{c}\\mathrm{b}\\mathrm{b}20\\mathrm{a}6\\mathrm{d}\\mathrm{e}42\\mathrm{d}76\\mathrm{d}69,0\\times 16\\mathrm{d}74\\mathrm{a}2\\mathrm{a}88\\mathrm{e}817\\mathrm{f}1821\\mathrm{a}1\\mathrm{c}40\\mathrm{e}220\\mathrm{d}34\\mathrm{e}\\mathrm{e}\\mathrm{c}93\\mathrm{e}33\\mathrm{c}\\mathrm{b}83).</span></p>

    <p class="text-gray-300">For the challenge, we took a point  <span class="math">P</span>  on the curve whose  <span class="math">x</span> -coordinate is made of the 51 first decimal digits of  <span class="math">\\pi</span> , and such that its  <span class="math">y</span> -coordinate is of even lsb. We then get  <span class="math">P = [\\frac{\\#E(\\mathbb{F}_p)}{\\ell}]P_0</span> .</p>

    <p class="text-gray-300"><span class="math">P_{0} = (0\\times d6f4dcacdbe68004d7666a4d01dfa3321e33e476e6,0\\times 13acf67269153bf52bdaedd8fbd4272989187e77c9a),</span></p>

    <p class="text-gray-300"><span class="math">P = (0\\times 15052\\mathrm{ba}45717710\\mathrm{e}6\\mathrm{b}0\\mathrm{cbf}8\\mathrm{ed}89\\mathrm{c}5\\mathrm{c}1\\mathrm{a}0\\mathrm{a}279480\\mathrm{e}26,0\\times 8050\\mathrm{f}05\\mathrm{a}231\\mathrm{a}\\mathrm{e}1\\mathrm{f}13\\mathrm{e}56\\mathrm{d}\\mathrm{e}1171\\mathrm{c}108294656052339).</span></p>

    <p class="text-gray-300">Applying the FR-reduction. We first construct  <span class="math">\\mathbb{F}_{p^3}</span>  as  <span class="math">\\mathbb{F}_p(z) = \\mathbb{F}_p[x] / (x^3 + x + 1)</span> , for ease of pairing computations. We compute a generator  <span class="math">G_2</span>  of the order  <span class="math">\\ell</span>  subgroup of  <span class="math">E(\\mathbb{F}_{p^3})</span>  which is not  <span class="math">E(\\mathbb{F}_p)</span> . We decided to take a point whose  <span class="math">x</span> -coordinate is  <span class="math">x_Q = z + a</span>  with  <span class="math">a</span>  as small as possible, such that</p>

    <p class="text-gray-300"><span class="math">x_{Q}^{3}+ax_{Q}+b</span> is a square in <span class="math">\\mathbb{F}_{p^{3}}</span>. Again we took the square root of even lsb. We multiplied this point <span class="math">Q</span> by the cofactor to get a generator <span class="math">G_{2}</span> of the right order <span class="math">\\ell</span> subgroup. Given <span class="math">\\#E(\\mathbb{F}_{p})=p+1-\\tau</span>, the order of <span class="math">E(\\mathbb{F}_{p^{3}})</span> is <span class="math">p^{3}+1-\\tau^{3}+3p\\tau</span>, so that <span class="math">G_{2}=[\\frac{\\#E(\\mathbb{F}_{p^{3}})}{\\ell^{2}}]Q</span>. We compute the reduced Tate pairing of the two generators, to get a generator <span class="math">G_{T}=e(G_{1},G_{2})</span> of the order <span class="math">\\ell</span> subgroup of <span class="math">\\mathbb{F}_{p^{3}}</span> (reduced means we perform the final exponentiation to the power <span class="math">(p^{3}-1)/\\ell</span> to get a unique result). We compute the reduced Tate pairing of our challenge and <span class="math">G_{2}</span>, to get a challenge <span class="math">S=e(P,G_{2})</span> in <span class="math">\\mathbb{F}_{p^{3}}</span>. This process leads to</p>

    <p class="text-gray-300"><span class="math">S</span> <span class="math">=0\\text{\\times}21\\text{e}33\\text{c}d9\\text{b}53366343\\text{bcf}0\\text{d}519\\text{f}5\\text{a}80\\text{b}32\\text{e}3\\text{bab}8\\text{c}44\\text{a}\\ z^{2}+0\\text{\\times}ce97\\text{b}3388642\\text{afc}9\\text{d}74\\text{b}42\\text{a}4\\text{e}4\\text{e}1\\text{e}135\\text{a}3375\\text{a}437\\text{e}\\ z</span> <span class="math">\\quad\\quad+0\\text{\\times}166327121\\text{ab}56\\text{b}7\\text{b}22\\text{e}28\\text{e}\\text{a}7\\text{f}0\\text{b}\\text{a}\\text{a}731\\text{a}7\\text{c}\\text{f}92\\text{a}8348</span> <span class="math">G_{T}</span> <span class="math">=0\\text{\\times}14\\text{f}\\text{ab}\\text{f}0\\text{e}76\\text{b}0\\text{d}2\\text{e}77\\text{b}\\text{b}3767494448\\text{b}\\text{d}094184\\text{b}65316\\ z^{2}+0\\text{\\times}d39926\\text{b}9\\text{c}80\\text{b}\\text{b}8\\text{c}6\\text{f}54970\\text{a}5569\\text{e}74813\\text{a}\\text{f}5\\text{a}172\\text{d}6\\ z</span> <span class="math">\\quad\\quad+0\\text{\\times}9\\text{e}\\text{b}16519\\text{c}8\\text{b}\\text{c}9\\text{a}34\\text{b}9460\\text{a}\\text{a}\\text{e}9\\text{f}\\text{b}\\text{c}9\\text{a}2\\text{b}\\text{e}575\\text{f}82548.</span></p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Computing the individual log using NFS-DL</h4>

    <p class="text-gray-300">We change the representation of <span class="math">\\mathbb{F}_{p^{3}}</span> according to the defining polynomial described in Section 3.1. It means that we compute an isomorphism from <span class="math">\\mathbb{F}_{p}(z)=\\mathbb{F}_{p}[x]/(x^{3}+x+1)</span> to <span class="math">\\mathbb{F}_{p}(t)=\\mathbb{F}_{p}[x]/(\\varphi(x))</span>, where <span class="math">\\varphi=\\text{Res}(f,g)</span> with <span class="math">f,g</span> as given in 3.2. This isomorphism can be written as follows, and gives the following values for the challenge <span class="math">S</span> and the generator <span class="math">G_{T}</span>:</p>

    <p class="text-gray-300"><span class="math">z</span> <span class="math">\\mapsto 0\\text{\\times}1963349\\text{af}2\\text{bc}59\\text{b}4\\text{b}166\\text{a}\\text{c}91643384\\text{d}\\text{e}0\\text{e}\\text{f}\\text{d}\\text{b}797\\text{e}\\text{b}\\text{d}</span> <span class="math">\\quad\\quad+0\\text{\\times}2440\\text{f}3\\text{d}5\\text{f}3\\text{e}6\\text{d}\\text{e}8039\\text{b}767\\text{b}132\\text{a}935\\text{e}\\text{b}797\\text{f}\\text{f}\\text{d}24\\text{d}\\text{d}1\\ t+0\\text{\\times}287\\text{c}\\text{d}0\\text{b}842\\text{a}\\text{d}6\\text{a}479\\text{c}0431\\text{f}51\\text{e}52\\text{c}\\text{e}\\text{e}08874\\text{d}\\text{f}3\\text{f}\\text{d}6\\ t^{2}</span> <span class="math">S</span> <span class="math">=0\\text{\\times}11\\text{a}2\\text{f}1\\text{f}13\\text{f}\\text{a}9\\text{b}08703\\text{a}033\\text{e}\\text{e}3\\text{c}4321539156\\text{f}865\\text{e}\\text{e}9</span> <span class="math">\\quad\\quad+0\\text{\\times}1098\\text{c}3\\text{b}7280\\text{e}\\text{f}2\\text{c}\\text{f}8\\text{b}091\\text{d}08197\\text{d}\\text{e}0\\text{a}9\\text{b}\\text{a}935\\text{f}\\text{f}79\\text{c}6\\ t+0\\text{\\times}221205020\\text{e}7729\\text{c}\\text{b}46166\\text{a}9\\text{e}\\text{d}\\text{f}\\text{d}5\\text{a}\\text{c}\\text{b}3\\text{b}\\text{f}59\\text{d}\\text{d}0\\text{a}7\\text{d}4\\ t^{2}</span> <span class="math">G_{T}</span> <span class="math">=0\\text{\\times}d772111\\text{b}150\\text{e}\\text{c}08f0\\text{a}\\text{d}89\\text{d}987\\text{f}1\\text{b}037\\text{c}630155608\\text{c}</span> <span class="math">\\quad\\quad+0\\text{\\times}f956\\text{c}\\text{a}\\text{b}6840\\text{c}7\\text{e}909\\text{a}\\text{b}\\text{c}29584\\text{f}1\\text{a}\\text{e}\\text{e}48\\text{c}\\text{c}\\text{b}\\text{d}39\\text{d}698\\ t+0\\text{\\times}205\\text{e}\\text{b}5\\text{b}1\\text{e}09\\text{f}76\\text{b}\\text{f}0\\text{e}\\text{f}85\\text{e}\\text{f}\\text{e}\\text{a}\\text{a}3\\text{f}\\text{d}\\text{c}\\text{b}3827\\text{d}43441\\text{b}3\\ t^{2}</span></p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">Back to the curve</h3>

    <p class="text-gray-300">We obtained</p>

    <p class="text-gray-300"><span class="math">\\log(S)=0\\text{\\times}48\\text{a}6\\text{b}\\text{c}\\text{f}57\\text{c}\\text{a}\\text{c}\\text{c}\\text{a}997658\\text{c}98\\text{a}0\\text{c}196\\text{c}25116\\text{a}0\\text{a}\\text{a},\\ \\ \\log(G_{T})=0\\text{\\times}8\\text{c}58\\text{b}66\\text{f}0\\text{d}8\\text{b}2\\text{e}99\\text{a}1\\text{c}0530\\text{b}2649\\text{e}\\text{c}0\\text{c}76501\\text{c}3,</span></p>

    <p class="text-gray-300">so that <span class="math">u=\\log(S)/\\log(G_{T})=\\log(P)=0\\text{\\times}711\\text{d}13\\text{e}\\text{d}75\\text{e}05\\text{c}\\text{c}2\\text{a}\\text{b}2\\text{c}9\\text{e}\\text{c}2\\text{c}910\\text{a}98288\\text{e}\\text{c}038</span> mod <span class="math">\\ell</span>.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">B.2 Code</h3>

    <pre><code class="language-text">ZZ := Integers();
x0 := -8702303353090049898316902;
t := 6*x0 - 1;
p := 12*x0^2 - 1; // this is a 170-bit prime
cofactor_E := 7^2*313;
ell := (p+1-t) div cofactor_E; // this is a 156-bit prime
cofactor_E3 := (p^3 + 1 - t^3 + 3*p*t) div ell^2;
cofactor_Fp3:=(p^3-1) div ell;

a := 818416342594888291485044088811640789053085789975506;
b := 666070443323978349780035881803413282865714842057992;

Fp := FiniteField(p,1);

E := EllipticCurve([Fp!a, Fp!b]);

even_sqrt:=func&lt;x| (ZZ!Eltseq(y)[1] mod 2 eq 1 select -y else y) where y is Sqrt(x)&gt;;
SetPrintLevel(&quot;Hex&quot;);

// generator of rational subgroup
G0:=E![x,even_sqrt(x^3+a*x+b)] where x is Fp!2;
G1 := cofactor_E*G0;
printf &quot;G1 = %o\\n&quot;, ChangeUniverse(Eltseq(G1)[1..2],Integers());

// generator of subgroup over extension
// an arbitrary representation of Fp3.
Fp3&lt;z&gt; := ext&lt;Fp | Polynomial([1,1,0,1])&gt;;
Q := E(Fp3)![x,even_sqrt(x^3+a*x+b)] where x is z+2;
G2 := cofactor_E3*Q;

// generator of image subgroup
generator := ReducedTatePairing(E(Fp3) ! G1, G2, ell);

// challenge
x_P := Fp ! 314159265358979323846264338327950288419716939937510;
P0:=E![x,even_sqrt(x^3+a*x+b)]
where x is Fp!314159265358979323846264338327950288419716939937510;
P := cofactor_E*P0;
printf &quot;P = %o\\n&quot;, ChangeUniverse(Eltseq(P)[1..2],Integers());
challenge := ReducedTatePairing(E(Fp3)!P, G2, ell);

// Our chosen representation of Fp3
g0:=Polynomial([-1,-3,0,1]);
g1:=Polynomial([0,-1,-1]);
y0:=66860548332739903465896435955260897778062220455483;
Fpn:=ext&lt;Fp | g0+y0*g1&gt;;
Embed(Fp3,Fpn,Roots(DefiningPolynomial(Fp3),Fpn)[1][1]);

Fpn_challenge := Fpn ! challenge;
Fpn_generator := Fpn ! generator;

log_t:=1; // this is our normalization choice (for t == Fpn.1)
log_generator:=0x8C58B66F0D8B2E99A1C0530B2649EC0C76501C3; // logarithm of generator e(G1,G2)
log_challenge:=0x48A6BCF57CACCA997658C98A0C196C25116A0AA; // logarithm of challenge

printf &quot;// checking log(challenge) w.r.t. log(basis)&quot;;
assert (Fpn_generator^log_challenge/Fpn_challenge^log_generator) ^ cofactor_Fp3 eq 1;
assert (generator^log_challenge/challenge^log_generator)^cofactor_Fp3 eq 1; // of course
assert (Fpn_generator / Fpn.1^log_generator) ^ cofactor_Fp3 eq 1;
print &quot; OK&quot;;

printf &quot;// back to the elliptic curve: &quot;;
log_P := ZZ ! (GF(ell) ! log_challenge / log_generator);

assert log_challenge*G1 eq log_generator*P and log_P * G1 eq P;
print &quot; OK&quot;;</code></pre>`;
---

<BaseLayout title="Solving discrete logarithms on a 170-bit MNT curve by pairin... (2016/507)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/507
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
