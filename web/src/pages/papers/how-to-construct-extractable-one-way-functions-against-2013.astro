---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/468';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'How To Construct Extractable One-Way Functions Against Uniform Adversaries';
const AUTHORS_HTML = 'Nir Bitansky, Ran Canetti, Omer Paneth';

const CONTENT = `    <p class="text-gray-300">Nir Bitansky* Ran Canetti† Omer Paneth‡ Alon Rosen§</p>

    <p class="text-gray-300">June 3, 2014</p>

    <p class="text-gray-300">This is an out of date draft. The paper was merged with How to Construct Extractable Functions against Uniform Adversaries [BCP13] to form On the Existence of Extractable One-Way Functions [BCPR14].</p>

    <p class="text-gray-300">We show that if there exist indistinguishability obfuscators for all circuits then there do not exist auxiliary-input extractable one-way functions. In particular, the knowledge of exponent assumption with respect to adversaries with auxiliary input is false in any group where computing discrete logarithms is intractable. The proof uses the "punctured programs" technique of [Sahai-Waters 2013].</p>

    <p class="text-gray-300">Program obfuscation, namely the task of making code unintelligible while preserving its functionality, has been long considered to be a holy grail of cryptography, with diverse and far reaching applications. The rigorous treatment of obfuscation was initiated by Barak et al.  <span class="math">\\left[\\mathrm{BGI}^{+}01\\right]</span> , who formulated a number of definitions of security for this task. However, until very recently, we only knew how to obfuscate a number of specific and restricted classes of programs under any of these definitions. Furthermore, Barak et al. demonstrated a class of programs that are unobfuscatable according to a natural definition, namely virtual black box (VBB) obfuscation, which guarantees that access to the obfuscated program gives no more power than access to an impenetrable black box with the same input-output functionality. Impossibility results for more natural classes of programs, with respect to stronger variants of VBB obfuscation, subsequently followed [GK05].</p>

    <p class="text-gray-300">All of this changed with the work by Garg et al.  <span class="math">\\mathrm{[GGH^{+}13b]}</span>  who proposed a candidate construction of general-purpose obfuscators. They show that, under algebraic assumptions closely related to multilinear</p>

    <p class="text-gray-300">maps <em>[x10, x11]</em>, their construction satisfies the relaxed notion of <em>indistinguishability obfuscation</em> (<span class="math">i\\mathcal{O}</span>) <em>[BGI^{+}01]</em>, for which no impossibility results are known. The notion of <span class="math">i\\mathcal{O}</span> only requires that it is hard to distinguish an obfuscation of <span class="math">C_{0}</span> from an obfuscation of <span class="math">C_{1}</span>, for any two circuits <span class="math">C_{0}</span> and <span class="math">C_{1}</span> of the same size that compute the exact same function.</p>

    <p class="text-gray-300">The security of the Garg et al. construction is based on a specific family of intractability assumptions (different for any obfuscated function). Being introduced only recently, these assumptions are still not well-understood, though several recent works have verified the validity of the constructions (or variants thereof) in idealized algebraic models <em>[x12, x3, BGTK^{+}13]</em>. In fact, in these models the construction is even shown to obtain the stronger VBB notion.</p>

    <p class="text-gray-300">A priori, it is not clear how strong or meaningful is the <span class="math">i\\mathcal{O}</span> notion of security. However, as observed in <em>[BGI^{+}01, x14]</em>, <span class="math">i\\mathcal{O}</span> is “best possible,” in the sense that <em>if</em> a class of programs is obfuscatable according to some notion of security, then a general <span class="math">i\\mathcal{O}</span> obfuscator, applied to this class of programs, will provide essentially the same security guarantee. Furthermore, several recent works <em>[GGH^{+}13b, x28, x21, x12]</em> showed that general <span class="math">i\\mathcal{O}</span> obfuscation can be combined with more standard cryptographic primitives to construct many powerful primitives such as functional encryption, public-key encryption from one way functions, attribute-based encryption, as well as NIZKs, CCA encryption, 2-message multi-party computation <em>[x12]</em>, deniable encryption, and more. Despite these dramatic advances, many questions are still open and the full range of implications of <span class="math">i\\mathcal{O}</span> for all circuits still seems far from being well understood.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Extractable Functions</h3>

    <p class="text-gray-300">The concept of extractable functions originates with the work of Damgård over 20 years ago <em>[x13]</em>, which first formulated the “knowledge of exponent assumption” (KEA). The KEA notion, with respect to a group <span class="math">G</span>, says that for any adversary <span class="math">\\mathcal{A}</span>, there exists an extractor <span class="math">\\mathcal{E}</span>, such that whenever <span class="math">\\mathcal{A}</span>, given two random generators <span class="math">(g,h)</span> of <span class="math">G</span> outputs two group elements of the form <span class="math">(g^{x},h^{x})</span> for some <span class="math">x</span>, then <span class="math">\\mathcal{E}</span>, given the same <span class="math">(g,h)</span>, outputs <span class="math">x</span>. Variants of this assumption have been used in the context of CCA and plaintext aware encryption, zero knowledge, non-interactive succinct arguments and other primitives, e.g., <em>[x13, x15, x4, x5, x16, x17, x18]</em>.</p>

    <p class="text-gray-300">Abstracting from this assumption, Canetti and Dakdouk <em>[x7, x8]</em> defined the notion of <em>extractable function families</em>. Similarly to KEA, a family of functions <span class="math">\\mathcal{F}</span> is extractable if for any adversary <span class="math">\\mathcal{A}</span> there exists an extractor <span class="math">\\mathcal{E}</span>, such that whenever <span class="math">\\mathcal{A}</span>, given a random key <span class="math">e</span> for a function <span class="math">f_{e}\\in\\mathcal{F}</span>, outputs an element <span class="math">y</span> in the image of <span class="math">f_{e}</span>, then <span class="math">\\mathcal{E}</span>, given the same <span class="math">e</span>, outputs a preimage of <span class="math">y</span>. Intuitively, this means that the “only way” to generate a value in the image of <span class="math">f_{e}</span> is to “honestly” apply <span class="math">f_{e}</span> on some chosen input. When <span class="math">\\mathcal{F}</span> has additional hardness properties (such as one-wayness or collision resistance), this abstraction has proven to be quite powerful <em>[x8, x2, x9, x10]</em>.</p>

    <p class="text-gray-300">Different formulations of assumptions of this kind exhibit widely different properties. While variants differ in several aspects, let us concentrate on a particular aspect: the “advice”, or “auxiliary information” available to the adversary and extractor. One straightforward formulation requires that, for any possible adversary (modeled as a uniform algorithm) there exists an extractor (again, modeled as a uniform algorithm) that successfully extracts as described above, given the adversary’s coin tosses. An alternative is to model both the adversary and the extractor as non-uniform families of polysize circuits.</p>

    <p class="text-gray-300">However, neither formulation suffices when using extractable functions with other components in a larger cryptographic scheme or protocol. Indeed, during the execution of such a protocol or scheme, an adversary <span class="math">\\mathcal{A}</span> may gather information <span class="math">z</span> from other components and use it as <em>additional</em> auxiliary input when evaluating the extractable function. While, in the non-uniform definition, for every <span class="math">z</span>, there exists an extractor for <span class="math">\\mathcal{A}(z,\\cdot)</span>, a reduction/simulator might not be able to efficiently find this extractor. Similar issues are</p>

    <p class="text-gray-300">encountered in various cryptographic contexts that involve composition: a classic example, from the context of zero-knowledge, is in proving that zero-knowledge is closed under sequential composition. There, the solution is to require a stronger notion of auxiliary-input zero-knowledge.</p>

    <p class="text-gray-300">In the context of extractable functions, the solution is to require a single extractor that can handle any auxiliary information <span class="math">z</span> gathered by the adversary. Specifically, we require that for any polytime adversary <span class="math">\\mathcal{A}</span> there should exist a polytime extractor <span class="math">\\mathcal{E}</span> such that extraction succeeds when <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{E}</span> are given the same advice string <span class="math">z</span>. That is, for any polysize <span class="math">z</span>, and for a randomly chosen key <span class="math">e</span>, the probability that <span class="math">\\mathcal{A}</span>, given <span class="math">(z,e)</span> outputs a value <span class="math">y</span> in the image of <span class="math">f_{e}</span> and <span class="math">\\mathcal{E}</span>, given <span class="math">(z,e)</span>, does not output a preimage of <span class="math">y</span>, is negligible. We call this property auxiliary-input extractability.</p>

    <p class="text-gray-300">Indeed, this notion is needed in order to use extractable functions to obtain the standard notion of auxiliary-input zero-knowledge. In certain cases, auxiliary-input extractability can be relaxed to consider only the case where the common auxiliary input is taken from some specific distribution that captures the ‘possible’ auxiliary information in a given system (see e.g. <em>[x1]</em>).</p>

    <p class="text-gray-300">Do auxiliary-input extractable functions exist? With one recent exception, in which the adversary is assumed to have only bounded-length advice <em>[x2]</em>, we do not have any candidate extractable one-way functions with an explicit, constructive extraction algorithm under any of the above formulations. Instead, existence of such an extractor is merely assumed (e.g., <em>[x10, x7, x11, x12, x16, x14]</em>. Such assumptions are arguably not satisfying. In particular, they do not qualify as “efficiently falsifiable” <em>[x20]</em>; namely, unlike standard assumptions where it possible to algorithmically study the best possible “breakers”, here we do not even have an algorithmic way to test whether a given adversary <span class="math">\\mathcal{A}</span> breaks the assumption.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Our Result</h3>

    <p class="text-gray-300">Auxiliary-input extractability is a strong requirement: the auxiliary-input <span class="math">z</span> may potentially encode arbitrary circuits, which may be executed by the adversary, meaning that the extractor needs to extract from arbitrary circuits. Given our current lack of understanding of non-black-box extraction techniques, the latter further decreases our confidence in such assumptions. Furthermore, the need to extract from arbitrary code reveals a clear tension between extractable functions and obfuscation: if <span class="math">z</span> contains obfuscated code, how can we expect the extractor to algorithmically extract useful information out of it?</p>

    <p class="text-gray-300">We show that general <span class="math">i\\mathcal{O}</span> suffices to make this intuition rigorous:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1.1.</h6>

    <p class="text-gray-300">If there exist indistinguishability obfuscators for all circuits, then there do not exist one-way functions that are auxiliary-input extractable.</p>

    <p class="text-gray-300">So, is the knowledge of exponent assumption wrong? Originally <em>[x10]</em>, the knowledge of exponent assumption (KEA) was not stated with auxiliary-input extractability, but rather according to the notion where every adversary <span class="math">\\mathcal{A}</span> has an extractor <span class="math">\\mathcal{E}</span>, and the only joint extra information is the adversary’s coin tosses and key for the function. In particular, given a non-uniform adversary <span class="math">\\mathcal{A}</span> with an obfuscated code as advice <span class="math">z</span>, the extractor is allowed to have a different advice <span class="math">z^{\\prime}</span>, representing the “deobfuscated” code. Indeed, our result does not rule out such a notion of extraction (even assuming <span class="math">i\\mathcal{O}</span> for all circuits). Our result does not disvalidate the intuition that “the only way” to compute <span class="math">(g^{x},h^{x})</span>, given <span class="math">(g,h)</span> is by “knowing” <span class="math">x</span>. As we shall see, our adversary and auxiliary-input will be devised so that <span class="math">x</span> is actually known, but only by an underlying obfuscated computation, and thus cannot be figured out efficiently from it by an external extractor.</p>

    <p class="text-gray-300">We also note that our result does not rule out extractable functions with respect to adversaries with bounded polynomial advice, such as those constructed in <em>[x1]</em>. Neither do they rule out extractable</p>

    <p class="text-gray-300">functions with respect to auxiliary input that is taken from specific distributions, e.g. the uniform distribution, required in <em>[x1]</em>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.4 Proof Idea</h3>

    <p class="text-gray-300">To show that the existence of <span class="math">i\\mathcal{O}</span> rules out auxiliary-input extractable functions, we follow the basic intuition given above. We focus on the ‘hardest scenario’, where the auxiliary input <span class="math">z</span> may represent an arbitrary malicious, and potentially obfuscated code. Specifically, we consider the following folklore case (sketched in <em>[x1, x2, BCI^{+}13, x1]</em>) where <span class="math">z</span> is an obfuscation of a circuit <span class="math">C_{k}</span> that, given key <span class="math">e</span> for an extractable <span class="math">f_{e}</span>, chooses its preimage in an unpredictable way: it applies a pseudo-random function <span class="math">\\mathsf{PRF}_{k}</span> to the key, and outputs the result <span class="math">f_{e}(\\mathsf{PRF}_{k}(e))</span>.</p>

    <p class="text-gray-300">Note that an adversary, given such an obfuscated circuit as auxiliary input <span class="math">z</span>, can run it on the key <span class="math">e</span> for the extractable function and always obtain a proper image. The question is whether the extractor, given the same <span class="math">(e,z)</span>, can output a preimage. Intuitively, had we given the extractor black-box access to the circuit <span class="math">C_{k}</span>, instead of an obfuscation of <span class="math">C_{k}</span>, it would have to invert the one-way function to obtain such a preimage. Note that as an oracle <span class="math">C_{k}</span> only returns <span class="math">f_{e^{\\prime}}(\\mathsf{PRF}_{k}(e^{\\prime}))</span> for any query <span class="math">e^{\\prime}</span>, and thus by pseudo-randomness, finding a preimage of <span class="math">f_{e}(\\mathsf{PRF}_{k}(e))</span> is as hard as finding a preimage for a random image <span class="math">f_{e}(u)</span>.</p>

    <p class="text-gray-300">If <span class="math">z</span> is a VBB obfuscation of <span class="math">C_{k}</span>, the above could be translated to an actual proof; but is that also the case if we use indistinguishability obfuscation? When <span class="math">z=i\\mathcal{O}(C_{k})</span>, it is not as clear what kind of information leaks on the PRF key <span class="math">k</span>. Nevertheless, we show that the above argument can still be salvaged. The idea is to consider an alternative to the the circuit <span class="math">C_{k}</span> that computes the same function, but without actually “knowing” <span class="math">\\mathsf{PRF}_{k}(e)</span>. This is achieved using the puncturing technique of Sahai and Waters <em>[x21]</em>.</p>

    <p class="text-gray-300">Specifically, instead of using any PRF family, we use a puncturable PRF. In such PRFs it is possible to puncture a given key <span class="math">k</span> at an arbitrary point <span class="math">x^{<em>}</span> in the domain of the function. The punctured function <span class="math">\\mathsf{PRF}_{k_{x^{</em>}}}</span>, with punctured key <span class="math">k_{x^{<em>}}</span>, preserves functionality at any other point, but hides any information on the point <span class="math">\\mathsf{PRF}_{k}(x^{</em>})</span>; namely, this value is pseudo-random, even given <span class="math">(x^{<em>},k_{x^{</em>}})</span>. As shown in several recent works <em>[x3, x4, x16]</em>, such puncturable PRFs follow from the <em>[x10]</em> construction.</p>

    <p class="text-gray-300">Using a puncturable PRF in the implementation of <span class="math">C_{k}</span>, we can now show that if the extractor succeeds in finding a preimage of <span class="math">y=f_{e}(\\mathsf{PRF}_{k}(e))</span>, it would also succeed had we provided it with an obfuscation of the alternative circuit <span class="math">C_{k_{e},y}</span>. The circuit <span class="math">C_{k_{e},y}</span> computes the same function as <span class="math">C_{k}</span>, but in a different way: it only has the punctured key <span class="math">k_{e}</span>, and has the value <span class="math">y=f_{e}(\\mathsf{PRF}_{k}(e))</span> directly hardwired into it, so that it does not have to evaluate the PRF in order to compute it. Thus, the fact that the extractor still succeeds follows by the guarantee of indistinguishability obfuscation. However, now by the pseudo-randomness guarantee at the punctured point <span class="math">e</span>, we know that <span class="math">\\mathsf{PRF}_{k}(e)</span> is pseudo random, and thus the extractor can be used to invert the one-way function <span class="math">f_{e}</span> from scratch.</p>

    <p class="text-gray-300">Finally, we note that since puncturable PRFs can be constructed from one-way functions, and any EOWF is in particular a OWF, it follows that the impossibility of EOWFs is implied by indistinguishability obfuscation without any further assumptions.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 Definitions</h2>

    <p class="text-gray-300">We define extractable one-way functions, indistinguishability obfuscation, and puncturable pseudo-random functions.</p>

    <p class="text-gray-300">2.1 Auxiliary-Input Extractable One-Way Functions</p>

    <p class="text-gray-300">In this paper, we focus attention to extractable one-way functions. Our results directly extend to stronger extractable function primitives, such as extractable collision-resistant hashing, and extractable commitments.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2.1 (Auxiliary-input EOWFs <em>[x10]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell,\\ell^{\\prime},m</span> be polynomially bounded length functions. An efficiently computable family of functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{F}=\\left\\{f_{e}:\\{0,1\\}^{\\ell(n)}\\rightarrow\\{0,1\\}^{\\ell^{\\prime}(n)}\\ \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ e\\in\\{0,1\\}^{m(n)},n\\in\\mathbb{N}\\right\\}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler <span class="math">\\mathcal{K}_{\\mathcal{F}}</span>, is an auxiliary-input extractable one-way function if it satisfies:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One-wayness: For PPT <span class="math">\\mathcal{A}</span>, large enough security parameter <span class="math">n\\in\\mathbb{N}</span>, and <span class="math">z\\in\\{0,1\\}^{\\mathrm{poly}(n)}</span>:</li>

    </ol>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}e\\leftarrow\\mathcal{K}_{\\mathcal{F}}(1^{n})\\\\ x\\leftarrow\\{0,1\\}^{\\ell(n)}\\end{subarray}}\\left[\\begin{array}[]{c}x^{\\prime}\\leftarrow\\mathcal{A}(e,f_{e}(x);z)\\\\ f_{e}(x^{\\prime})=f_{e}(x)\\end{array}\\right]\\leq\\mathrm{negl}(n)\\enspace. \\]</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extractability: For any PPT adversary <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that, for any large enough security parameter <span class="math">n\\in\\mathbb{N}</span>, and advice <span class="math">z\\in\\{0,1\\}^{\\mathrm{poly}(n)}</span>:</li>

    </ol>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}e\\leftarrow\\mathcal{K}_{\\mathcal{F}}(1^{n})\\end{subarray}}\\left[\\begin{array}[]{c}y\\leftarrow\\mathcal{A}(e;z)\\\\ \\exists x:f_{e}(x)=y\\end{array}\\right.\\wedge\\begin{array}[]{c}x^{\\prime}\\leftarrow\\mathcal{E}(e;z)\\\\ f_{e}(x^{\\prime})\\neq y\\end{array}\\right]\\leq\\mathrm{negl}(n) \\] (1)</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 2.1 (On the auxiliary input).</h6>

    <p class="text-gray-300">For our results it is critical that the extractor <span class="math">\\mathcal{E}</span> receives the same auxiliary input <span class="math">z</span>, which could be of arbitrary polynomial length, as <span class="math">\\mathcal{A}</span> does, and has to operate efficiently with respect to this auxiliary input. This flavor of definition is standard in defining auxiliary-input security, e.g., auxiliary-input zero-knowledge, and auxiliary-input obfuscation. Additional motivation for this formulation appears in the introduction.</p>

    <p class="text-gray-300">Still, one could consider weaker notions of extractability which may still suffice for some applications, and are not ruled out by our results, even assuming indistinguishability obfuscation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Separate auxiliary inputs: Here we only require that for any <span class="math">\\mathcal{A}</span> with non-uniform advice <span class="math">z_{s}</span>, there exists an extractor with non-uniform advice <span class="math">z_{s^{\\prime}}</span>, which may arbitrarily and inefficiently depend on <span class="math">z_{s}</span>, and could be of an arbitrary polynomial size. This weaker notion may be useful in cases where the adversary’s auxiliary inputs do not depend on computations that may have taken place in the system before the extractable function is used. Examples include CCA and plaintext-aware encryption with non-uniform security reductions <em>[x11, x12]</em>, and weak versions of 3-message zero-knowledge where the where the verifier doe not get auxiliary information and simulator is allowed to be more non-uniform than the verifier <em>[x20, x12]</em>.</li>

      <li>Common but benign auxiliary input: Here <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{S}</span>, in addition to arbitrary separate auxiliary-inputs <span class="math">z_{s}</span> and <span class="math">z_{s^{\\prime}}</span>, respectively, get common auxiliary input <span class="math">z</span> as that id drawn from a specific distribution that is conjectured to be ‘benign’, in the sense that it is unlikely to encode a malicious obfuscation. For instance, the distribution can be uniform or an encryption of a random string. Examples where this is sufficient includes essentially all the works on succinct non-interactive arguments (SNARGs), succinct NIZKs, and targeted malleability that rely on extractable primitives <em>[x13, x24, x18, GLR11, x1, BCCT12, BC12, DFH12, Lip12, BCCT13, BCI^{+}13, x10, x11]</em>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bounded auxiliary input: Here there is a bound on the size of the auxiliary-input that the adversary may get. EOWFs according to this notion are constructed in <em>[x1]</em> from standard assumptions, and shown to suffice for 3-message arguments of knowledge and 2-message arguments that are bounded auxiliary-input zero-knowledge.</li>

    </ul>

    <p class="text-gray-300">Finally, we remark that one may consider adversaries with both separate and common dynamic auxiliary input. That is, for any <span class="math">\\mathcal{A}</span> and auxiliary input <span class="math">z_{s}</span> there should exist <span class="math">\\mathcal{S}</span> and auxiliary input <span class="math">z_{s^{\\prime}}</span> such that (1) holds for any common auxiliary input <span class="math">z</span>. This notion is also ruled out by our techniques.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2 Indistinguishability Obfuscation</h3>

    <p class="text-gray-300">Indistinguishability obfuscation was introduced in <em>[BGI^{+}01]</em> and given a candidate construction in <em>[GGH^{+}13b]</em>, and subsequently in <em>[x1, BGTK^{+}13, x11]</em>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2.2 (Indistinguishability obfuscation <em>[BGI^{+}01]</em>).</h6>

    <p class="text-gray-300">A PPT algorithm <span class="math">i\\mathcal{O}</span> is said to be an <em>indistinguishability obfuscator</em> (INDO) for <span class="math">\\mathcal{C}</span>, if it satisfies:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Functionality: For any <span class="math">C\\in\\mathcal{C}</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr_{i\\mathcal{O}}\\left[\\forall x:i\\mathcal{O}(1^{n},C)(x)=C(x)\\right]=1\\enspace.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Indistinguishability: For any ensemble of circuit pairs <span class="math">\\{(C_{n}^{(1)},C_{n}^{(2)})\\in\\mathcal{C}\\times\\mathcal{C}\\}_{n\\in\\mathbb{N}}</span>, where the two circuits in each pair are of the same size and functionality, it holds that:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\left\\{i\\mathcal{O}(1^{n},C_{n}^{(1)})\\right\\}_{n\\in\\mathbb{N}}\\approx_{c}\\left\\{i\\mathcal{O}(1^{n},C_{n}^{(2)})\\right\\}_{n\\in\\mathbb{N}}\\enspace.</span></p>

    <p class="text-gray-300">For ease of notation, we shall often omit <span class="math">1^{n}</span> from the input to the obfuscator.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.3 Puncturable PRFs</h3>

    <p class="text-gray-300">We next define puncturable PRFs. We consider a simple case of the puncturable PRFs where any PRF might be punctured at a single point. The definition is formulated as in <em>[x23]</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2.3 (Puncturable PRFs).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell,m</span> be polynomially bounded length functions. An efficiently computable family of functions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{PRF}=\\left\\{\\textsf{PRF}_{k}:\\{0,1\\}^{m(n)}\\rightarrow\\{0,1\\}^{\\ell(n)}\\ \\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ k\\in\\{0,1\\}^{n},n\\in\\mathbb{N}\\right\\}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler <span class="math">\\mathcal{K}_{\\mathcal{PRF}}</span>, is a puncturable PRF if there exists a puncturing algorithm <span class="math">\\mathsf{Punc}</span> that takes as input a key <span class="math">k\\in\\{0,1\\}^{n}</span>, and a point <span class="math">x^{<em>}</span>, and outputs a punctured key <span class="math">k_{x^{</em>}}</span>, so that the following conditions are satisfied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Functionality is preserved under puncturing: For every <span class="math">x^{*}\\in\\{0,1\\}^{\\ell(n)}</span>,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{k\\leftarrow\\mathcal{K}_{\\mathcal{PRF}}(1^{n})}\\left[\\forall x\\neq x^{<em>}:\\textsf{PRF}_{k}(x)=\\textsf{PRF}_{k_{x^{</em>}}}(x)\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ k_{x^{<em>}}=\\mathsf{Punc}(k,x^{</em>})\\right]=1\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Indistinguishability at punctured points: The following ensembles are computationally indistinguishable:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{x^{<em>}, k_{x^{</em>}}, \\mathsf{PRF}_{k}(x^{<em>}) \\mid k \\gets \\mathcal{K}_{\\mathcal{PRF}}(1^{n}), k_{x^{</em>}} = \\mathsf{Punc}(k, x^{<em>})\\}_{x^{</em>} \\in \\{0, 1\\}^{m(n)}, n \\in \\mathbb{N}}</span></li>

      <li><span class="math">\\left\\{x^{<em>}, k_{x^{</em>}}, u \\mid k \\gets \\mathcal{K}_{\\mathcal{PRF}}(1^{n}), k_{x^{<em>}} = \\mathsf{Punc}(k, x^{</em>}), u \\gets \\{0, 1\\}^{\\ell(n)}\\right\\}_{x^{*} \\in \\{0, 1\\}^{m(n)}, n \\in \\mathbb{N}}</span> .</li>

    </ul>

    <p class="text-gray-300">To be explicit, we include  <span class="math">x^{<em>}</span>  in the distribution; throughout, we shall assume for simplicity that a punctured key  <span class="math">k_{x^{</em>}}</span>  includes  <span class="math">x^{*}</span>  in the clear. As shown in [BGI13, BW13, KPTZ13], the GGM [GGM86] PRF yield puncturable PRFs as defined above.</p>

    <p class="text-gray-300">We now show that if indistinguishability obfuscators exist, there do not exist EOWFs according to Definition 2.1. For this purpose, assuming the existence of an EOWF family  <span class="math">\\mathcal{F}</span> , we shall describe an adversary  <span class="math">\\mathcal{A}</span>  and a distribution  <span class="math">\\mathcal{Z}</span>  on auxiliary inputs, such that any extractor fails, for auxiliary inputs sampled from  <span class="math">\\mathcal{Z}</span> .</p>

    <p class="text-gray-300">We consider a universal PPT adversary  <span class="math">\\mathcal{A}</span>  that given  <span class="math">(e,z)\\in \\{0,1\\}^{m(n)}\\times \\{0,1\\}^{\\mathrm{poly}(n)}</span> , parses  <span class="math">z</span>  as a circuit and returns  <span class="math">z(e)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{F}</span>  be a family of extractable one-way functions and let  <span class="math">\\mathcal{PRF}</span>  be a puncturable pseudo-random function family. We start by defining two families of circuits</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{C} = \\left\\{C_k:\\{0,1\\}^{m(n)}\\to \\{0,1\\}^{\\ell '(n)}\\biggm{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}k\\in \\{0,1\\}^n,n\\in \\mathbb{N}\\right\\} ,<span class="math"> </span>\\mathcal{C}^<em> = \\left\\{C_{k_{e^</em>},y^*}:\\{0,1\\}^{m(n)}\\to \\{0,1\\}^{\\ell '(n)}\\biggm{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}k\\in \\{0,1\\}^n,n\\in \\mathbb{N}\\right\\} .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The circuit  <span class="math">C_k</span> , given a key  <span class="math">e</span>  for an EOWF, applies  <span class="math">\\mathsf{PRF}_k</span>  to  <span class="math">e</span> , obtains an input  <span class="math">x</span> , and returns the result of applying the EOWF  <span class="math">f_e</span>  to  <span class="math">x</span> .</p>

    <p class="text-gray-300"><span class="math">C_k</span></p>

    <p class="text-gray-300">Hardwired: a PRF key  <span class="math">k \\in \\{0,1\\}^n</span> .</p>

    <p class="text-gray-300">Input: an EOWF key  <span class="math">e \\in \\{0,1\\}^{m(n)}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">x = \\mathsf{PRF}_k(e)</span></li>

      <li>Return  <span class="math">y = f_{e}(x)</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 1: The circuit  <span class="math">C_k</span> .</p>

    <p class="text-gray-300">The circuit  <span class="math">C_{k_{e^<em>},y^</em>}</span> , has a hardwired PRF key  <span class="math">k_{e^<em>}</span>  that was derived from  <span class="math">k</span>  by puncturing it at the point  <span class="math">e^</em></span> . In addition, it has hardwired an output  <span class="math">y^<em></span>  to replace the punctured result. In particular, when  <span class="math">y^</em> = f_{e^<em>}(\\mathsf{PRF}_k(e^</em>))</span>  the circuit  <span class="math">C_{k_{e^<em>},y^</em>}</span>  computes the same function as  <span class="math">C_k</span> .</p>

    <p class="text-gray-300">We are now ready to define our auxiliary input distribution  <span class="math">\\mathcal{Z} = \\{Z_n\\}_{n\\in \\mathbb{N}}</span> . Let  <span class="math">s = s(n)</span>  be the maximal size of circuits in either  <span class="math">\\mathcal{C}</span>  or  <span class="math">\\mathcal{C}^*</span> , corresponding to security parameter  <span class="math">n</span> , and denote by  <span class="math">[C]_s</span>  a</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: The circuit  <span class="math">C_{k_{e^<em>},y^</em>}</span> .</p>

    <p class="text-gray-300">circuit  <span class="math">C</span>  padded with zeros to size  <span class="math">s</span> . Let  <span class="math">i\\mathcal{O}</span>  be an indistinguishability obfuscator. The distribution  <span class="math">Z_{n}</span>  simply consists of an obfuscated (padded) circuit  <span class="math">C_k</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: The auxiliary input distribution  <span class="math">Z_{n}</span> .</p>

    <p class="text-gray-300">We next show that  <span class="math">\\mathcal{A}</span>  cannot have any extractor  <span class="math">\\mathcal{E}</span>  satisfying Definition 2.1. In fact, we show a stronger claim; namely, that for the auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , any extractor fails with overwhelming probability.</p>

    <p class="text-gray-300">Proposition 3.1. Let  <span class="math">\\mathcal{E}</span>  be any PPT candidate extractor for  <span class="math">\\mathcal{A}</span>  then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{e\\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^{n})\\\\ z\\leftarrow Z_{n}}}\\left[ \\begin{array}{cc}y\\leftarrow \\mathcal{A}(e;z) &amp;amp; x^{\\prime}\\leftarrow \\mathcal{E}(e;z)\\\\ \\exists x:f_{e}(x) = y &amp;amp; f_{e}(x^{\\prime})\\neq y \\end{array} \\right]\\geq 1 - \\operatorname {negl}(n)  ..</span></div>

    <p class="text-gray-300">We note that, since the key  <span class="math">e</span>  is sampled above independently of the auxiliary input  <span class="math">z</span> , the above indeed disproves extractability.</p>

    <p class="text-gray-300">Proof of Proposition 3.1. First, we note that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{e\\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^{n})\\\\ z\\leftarrow Z_{n}}}\\left[ \\begin{array}{c}y\\leftarrow \\mathcal{A}(e;z)\\\\ \\exists x:f_{e}(x) = y \\end{array} \\right] = 1  ;</span></div>

    <p class="text-gray-300">indeed, by the definition of  <span class="math">\\mathcal{A}</span>  and  <span class="math">Z_{n}</span> , and the correctness of  <span class="math">i\\mathcal{O}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {A} (e, z) = z (e) = C _ {k} (e) = f _ {e} \\left(\\operatorname {P R F} _ {k} (e)\\right),</span></div>

    <p class="text-gray-300">where <span class="math">C_k \\in \\mathcal{C}</span> is the circuit obfuscated in <span class="math">z</span>, i.e. <span class="math">z = i\\mathcal{O}([C_k]_s)</span>.</p>

    <p class="text-gray-300">Now, assume towards contradiction that, for infinitely many <span class="math">n \\in \\mathbb{N}</span>, the extractor <span class="math">\\mathcal{E}</span> successfully outputs an image with noticeable probability <span class="math">\\epsilon(n)</span>, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}_{\\substack{e \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^{n}) \\\\ z \\leftarrow Z_{n}}} \\left[ \\begin{array}{c} x&#x27; \\leftarrow \\mathcal{E}(e; z) \\\\ f_{e}(x&#x27;) = z(e) = f_{e}(\\mathsf{PRF}_{k}(e)) \\end{array} \\right] \\geq \\epsilon(n),</span></div>

    <p class="text-gray-300">where as before, <span class="math">z = i\\mathcal{O}([C_k]_s)</span>.</p>

    <p class="text-gray-300">Next, for every <span class="math">e^<em></span> we consider an alternative distribution <span class="math">Z_{n}(e^{</em>},y^{<em>})</span> that, instead of sampling a circuit <span class="math">C_k</span>, samples a circuit <span class="math">C_{k_{e^</em>},y^<em>}</span>, by first sampling <span class="math">k</span> as usual, and then computing <span class="math">y^{</em>} = f_{e^{<em>}}(\\mathsf{PRF}_{k}(e^{</em>}))</span>, and the punctured key <span class="math">k_{e^<em>}</span>. (Note that <span class="math">Z_{n}(e^{</em>},y^{<em>})</span> is actually only parameterized by <span class="math">e^</em></span>, we add <span class="math">y^{*}</span> to the notation, to be more explicit.) We claim that the extractor still succeeds in finding a preimage, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}_{\\substack{e^{*} \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^{n})\\\\ z^{*} \\leftarrow Z_{n}(e^{*},y^{*})}}\\left[ \\begin{array}{c}x^{\\prime}\\leftarrow \\mathcal{E}(e^{*};z^{*})\\\\ f_{e^{*}}(x^{\\prime}) = z^{*}(e^{*}) = y^{*} = f_{e^{*}}(\\mathsf{PRF}_{k}(e^{*})) \\end{array} \\right]\\geq \\epsilon (n) - \\operatorname {negl}(n).</span></div>

    <p class="text-gray-300">This follows from the fact that, for any <span class="math">e^<em></span> and <span class="math">k</span>, <span class="math">C_k</span> and <span class="math">C_{k_{e^</em>},y^*}</span> compute the same function, and the <span class="math">i\\mathcal{O}</span> indistinguishability guarantee.</p>

    <p class="text-gray-300">Next, we consider another experiment where <span class="math">Z_{n}(e^{<em>},y^{</em>})</span> is altered to a new distribution <span class="math">Z_{n}(e^{<em>},u)</span> that, instead of sampling <span class="math">y^{</em>} = f_{e^{<em>}}(\\mathsf{PRF}_{k}(e^{</em>}))</span> in <span class="math">C_{k_{e^{<em>}},y^{</em>}}</span>, samples <span class="math">y^{<em>} = f_{e^{</em>}}(u)</span>, for an independent random <span class="math">u \\gets \\{0,1\\}^{\\ell}</span>. We claim that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}_{\\substack{e^{*} \\leftarrow \\mathcal{K}_{\\mathcal{F}}(1^{n})\\\\ z^{*} \\leftarrow Z_{n}(e^{*},u)}}\\left[ \\begin{array}{c}x^{\\prime}\\leftarrow \\mathcal{E}(e^{*};z^{*})\\\\ f_{e^{*}}(x^{\\prime}) = z^{*}(e^{*}) = y^{*} = f_{e^{*}}(u) \\end{array} \\right]\\geq \\epsilon (n) - \\operatorname {negl}(n) ;</span></div>

    <p class="text-gray-300">indeed, this follows from the fact that <span class="math">\\mathsf{PRF}_k(e^<em>)</span> is pseudo-random, even given the punctured key <span class="math">k_{e^</em>}</span>.</p>

    <p class="text-gray-300">This means that <span class="math">\\mathcal{E}</span> can be used to break the one-wayness of <span class="math">\\mathcal{F}</span>. Indeed, given a random key <span class="math">e^<em></span>, and a challenge <span class="math">y^</em> = f_{e^<em>}(u)</span>, an inverter can simply sample a punctured <span class="math">k_{e^</em>}</span> on its own, construct the circuit <span class="math">C_{k_{e^<em>},y^</em>}</span>, with its challenge <span class="math">y^<em></span> hardwired in, and sample an obfuscation <span class="math">z^</em> \\gets i\\mathcal{O}(C_{k_{e^<em>},y^</em>})</span>. Finally, it runs <span class="math">\\mathcal{E}(e^<em>,z^</em>)</span> to invert <span class="math">y^*</span>, with the same probability <span class="math">\\epsilon(n) - \\mathrm{negl}(n)</span>.</p>

    <p class="text-gray-300">Remark 3.1 (Separate vs. common auxiliary input). As mentioned in Remark 2.1, our proof also holds in the case that the extractor <span class="math">\\mathcal{E}</span> is allowed extra (separate) auxiliary input <span class="math">s</span>, which does not depend on the (common) auxiliary input <span class="math">z</span> (provided that the EOWF is one-way against non-uniform adversaries).</p>

    <p class="text-gray-300">Finally, we note that since puncturable PRFs can be constructed from one-way functions, and any EOWF is, in particular, a OWF, the impossibility of auxiliary-input EOWFs is implied by indistinguishability obfuscation without any further assumptions. Thus, Theorem 1.1 follows.</p>

    <p class="text-gray-300">[BC12] Nir Bitansky and Alessandro Chiesa. Succinct arguments from multi-prover interactive proofs and their efficiency benefits. In CRYPTO, pages 255–272, 2012.</p>

    <p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, ITCS '12, pages 326–349, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for snarks and proof-carrying data. In STOC, pages 111–120, 2013.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC, pages 315–333, 2013.</li>

      <li>[BCP13] Nir Bitansky, Ran Canetti, and Omer Paneth. How to construct extractable one-way functions against uniform adversaries. IACR Cryptology ePrint Archive, 2013:468, 2013.</li>

      <li>[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In Proceedings of the 46th Annual ACM Symposium on Theory of Computing, STOC ’14, 2014.</li>

      <li>[BGI^{+}01] Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai, Salil P. Vadhan, and Ke Yang. On the (im)possibility of obfuscating programs. In CRYPTO, pages 1–18, 2001.</li>

      <li>[BGI13] Elette Boyle, Shafi Goldwasser, and Ioana Ivan. Functional signatures and pseudorandom functions. IACR Cryptology ePrint Archive, 2013:401, 2013.</li>

      <li>[BGTK^{+}13] Boaz Barak, Sanjam Garg, Yael Tauman-Kalai, Omer Paneth, and Amit Sahai. Protecting obfuscation against algebraic attacks. IACR Cryptology ePrint Archive, 2013:631, 2013.</li>

      <li>[BP04a] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols. In Proceedings of the 24th Annual International Cryptology Conference, pages 273–289, 2004.</li>

      <li>[BP04b] Mihir Bellare and Adriana Palacio. Towards plaintext-aware public-key encryption without random oracles. In ASIACRYPT, pages 48–62, 2004.</li>

      <li>[BR13] Zvika Brakerski and Guy Rothblum. Virtual black-box obfuscation for all circuits via generic graded encoding. IACR Cryptology ePrint Archive, 2013:563, 2013.</li>

      <li>[BSW12] Dan Boneh, Gil Segev, and Brent Waters. Targeted malleability: homomorphic encryption for restricted computations. In ITCS, pages 350–366, 2012.</li>

      <li>[BW13] Dan Boneh and Brent Waters. Constrained pseudorandom functions and their applications. IACR Cryptology ePrint Archive, 2013:352, 2013.</li>

      <li>[CD08] Ran Canetti and Ronny Ramzi Dakdouk. Extractable perfectly one-way functions. In Proceedings of the 35th International Colloquium on Automata, Languages and Programming, pages 449–460, 2008.</li>

      <li>[CD09] Ran Canetti and Ronny Ramzi Dakdouk. Towards a theory of extractable functions. In TCC, pages 595–613, 2009.</li>

      <li>[CLT13] Jean-Sébastien Coron, Tancrède Lepoint, and Mehdi Tibouchi. Practical multilinear maps over the integers. In CRYPTO (1), pages 476–493, 2013.</li>

      <li>[CV13] Ran Canetti and Vinod Vaikuntanathan. Obfuscating branching programs using black-box pseudo-free groups. IACR Cryptology ePrint Archive, 2013:500, 2013.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Dam92] Ivan Damgård. Towards practical public key systems secure against chosen ciphertext attacks. In Proceedings of CRYPTO91, pages 445–456, 1992.</li>

      <li>[DCL08] Giovanni Di Crescenzo and Helger Lipmaa. Succinct NP proofs from an extractability assumption. In Proceedings of the 4th Conference on Computability in Europe, pages 175–185, 2008.</li>

      <li>[DFH12] Ivan Damgård, Sebastian Faust, and Carmit Hazay. Secure two-party computation with low communication. In TCC, pages 54–74, 2012.</li>

      <li>[GGH13a] Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear maps from ideal lattices. In EUROCRYPT, pages 1–17, 2013.</li>

      <li>[GGH^{+}13b] Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and Brent Waters. Candidate indistinguishability obfuscation and functional encryption for all circuits. In FOCS, 2013.</li>

      <li>[GGHR13] Sanjam Garg, Craig Gentry, Shai Halevi, and Mariana Raykova. Two-round secure mpc from indistinguishability obfuscation. IACR Cryptology ePrint Archive, 2013:601, 2013.</li>

      <li>[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. J. ACM, 33(4):792–807, 1986.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In EUROCRYPT, pages 626–645, 2013.</li>

      <li>[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In FOCS, pages 553–562, 2005.</li>

      <li>[GLR11] Shafi Goldwasser, Huijia Lin, and Aviad Rubinstein. Delegation of computation without rejection problem from designated verifier CS-proofs. Cryptology ePrint Archive, Report 2011/456, 2011.</li>

      <li>[GR07] Shafi Goldwasser and Guy N. Rothblum. On best-possible obfuscation. In TCC, pages 194–213, 2007.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, pages 321–340, 2010.</li>

      <li>[GS12] Divya Gupta and Amit Sahai. On constant-round concurrent zero-knowledge from a knowledge assumption. IACR Cryptology ePrint Archive, 2012:572, 2012.</li>

      <li>[HSW13] Susan Hohenberger, Amit Sahai, and Brent Waters. Replacing a random oracle: Full domain hash from indistinguishability obfuscation. IACR Cryptology ePrint Archive, 2013:509, 2013.</li>

      <li>[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In Proceedings of the 18th Annual International Cryptology Conference, pages 408–423, 1998.</li>

      <li>[KPTZ13] Aggelos Kiayias, Stavros Papadopoulos, Nikos Triandopoulos, and Thomas Zacharias. Delegatable pseudorandom functions and applications. IACR Cryptology ePrint Archive, 2013:379, 2013.</li>

    </ul>

    <p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In TCC, pages 169–189, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Lip13] Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear error-correcting codes. IACR Cryptology ePrint Archive, 2013:121, 2013.</li>

      <li>[Mie08] Thilo Mie. Polylogarithmic two-round argument systems. Journal of Mathematical Cryptology, 2(4):343–363, 2008.</li>

      <li>[Nao03] Moni Naor. On cryptographic assumptions and challenges. In Proceedings of the 23rd Annual International Cryptology Conference, pages 96–109, 2003.</li>

      <li>[SW13] Amit Sahai and Brent Waters. How to use indistinguishability obfuscation: Deniable encryption, and more. IACR Cryptology ePrint Archive, 2013:454, 2013.</li>

    </ul>`;
---

<BaseLayout title="How To Construct Extractable One-Way Functions Against Unifo... (2013/468)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/468
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
