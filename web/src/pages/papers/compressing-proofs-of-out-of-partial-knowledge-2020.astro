---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/753';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Compressing Proofs of $k$-Out-Of-$n$ Partial Knowledge';
const AUTHORS_HTML = 'Thomas Attema, Ronald Cramer, Serge Fehr';

const CONTENT = `    <p class="text-gray-300">Thomas Attema<span class="math">^{1,2,3,<em>}</span>, Ronald Cramer<span class="math">^{1,2,<strong>}</span>, and Serge Fehr<span class="math">^{1,2,</strong> </em>}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> CWI, Cryptology Group, Amsterdam, The Netherlands <span class="math">^{2}</span> Leiden University, Mathematical Institute, Leiden, The Netherlands <span class="math">^{3}</span> TNO, Cyber Security and Robustness, The Hague, The Netherlands</p>

    <p class="text-gray-300">Version 4 - March 9, 2021<span class="math">^{4}</span></p>

    <p class="text-gray-300">Abstract. In an (honest-verifier) zero-knowledge proof of partial knowledge, introduced by Cramer, Damgård and Schoenmakers (CRYPTO 1994), a prover knowing witnesses for some <span class="math">k</span>-subset of <span class="math">n</span> given public statements can convince the verifier of this claim without revealing which <span class="math">k</span>-subset. The accompanying solution combines <span class="math">\\Sigma</span>-protocol theory and linear secret sharing, and achieves linear communication complexity for general <span class="math">k,n</span>. Especially the “one-out-of-<span class="math">n</span>” case <span class="math">k=1</span> has seen myriad applications during the last decades, e.g., in electronic voting, ring signatures, and confidential transaction systems in general.</p>

    <p class="text-gray-300">In this paper we focus on the discrete logarithm (DL) setting, where the prover claims knowledge of DLs of <span class="math">k</span>-out-of-<span class="math">n</span> given elements. Groth and Kohlweiss (EUROCRYPT 2015) have shown how to solve the special case <span class="math">k=1</span> with logarithmic (in <span class="math">n</span>) communication, instead of linear as prior work. However, their method takes explicit advantage of <span class="math">k=1</span> and does not generalize to <span class="math">k&amp;gt;1</span> without losing all advantage over prior work. Alternatively, an indirect approach for solving the considered problem is by translating the <span class="math">k</span>-out-of-<span class="math">n</span> relation into a circuit and then applying recent advances in communication-efficient circuit ZK. Indeed, for the <span class="math">k=1</span> case this approach has been highly optimized, e.g., in ZCash.</p>

    <p class="text-gray-300">Our main contribution is a new, simple honest-verifier zero-knowledge proof protocol for proving knowledge of <span class="math">k</span> out of <span class="math">n</span> DLs with logarithmic communication and for general <span class="math">k</span> and <span class="math">n</span>, without requiring any generic circuit ZK machinery. Our solution puts forward a novel extension of the compressed <span class="math">\\Sigma</span>-protocol theory (CRYPTO 2020), which we then utilize to compress a new <span class="math">\\Sigma</span>-protocol for proving knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> DL’s down to logarithmic size. The latter <span class="math">\\Sigma</span>-protocol is inspired by the CRYPTO 1994 approach, but a careful re-design of the original protocol is necessary for the compression technique to apply. Interestingly, even for <span class="math">k=1</span> and general <span class="math">n</span> our approach improves prior direct approaches as it reduces prover complexity without increasing the communication complexity. Besides the conceptual simplicity, we also identify regimes of practical relevance where our approach achieves asymptotic and concrete improvements, e.g., in proof size and prover complexity, over the generic approach based on circuit-ZK.</p>

    <p class="text-gray-300">Finally, we show various extensions and generalizations of our core result. For instance, we extend our protocol to proofs of partial knowledge of Pedersen (vector) commitment openings, and/or to include a proof that the witness satisfies some additional constraint, and we show how to extend our results to non-threshold access structures.</p>

    <p class="text-gray-300">Keywords: Proofs of Partial Knowledge, One-out-of-Many, Compressed <span class="math">\\Sigma</span>-Protocol Theory, Zero-Knowledge, Secure Algorithmics, Ring-Signatures.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Proofs of Partial Knowledge</h3>

    <p class="text-gray-300">Proofs of partial knowledge [CDS94] allow a prover to convince a verifier that the prover knows <span class="math">k</span> out of <span class="math">n</span> secrets, without revealing which secrets the prover knows. Typically, these secrets are solutions to public</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>thomas.attema@tno.nl</li>

    </ul>

    <p class="text-gray-300"><strong> cramer@cwi.nl, cramer@math.leidenuniv.nl </strong>* serge.fehr@cwi.nl <span class="math">^{4}</span> Change log w.r.t. Version 3 - October 21, 2020: (a) minor editorial changes, and (b) revised introduction of our techniques.</p>

    <p class="text-gray-300">instances of intractable problems, such as the discrete logarithm problem. The work of <em>[x10]</em> gives an elegant solution with linear communication complexity that combines <span class="math">\\Sigma</span>-protocol theory with linear secret sharing. Our goal is to invoke the techniques of Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em> and follow-up work, in particular the compressed <span class="math">\\Sigma</span>-protocol framework of <em>[x1]</em>, to construct proofs of partial knowledge with <em>logarithmic</em> communication complexity.</p>

    <p class="text-gray-300">Compressed <span class="math">\\Sigma</span>-protocol theory <em>[x1]</em> was introduced as a strengthening of <span class="math">\\Sigma</span>-protocol theory. It inherits the flexibility and versatility of <span class="math">\\Sigma</span>-protocols while compressing their communication complexity from linear to logarithmic. The main pivot of this theory is a standard <span class="math">\\Sigma</span>-protocol for opening linear forms on Pedersen vector commitments, i.e., a <span class="math">\\Sigma</span>-protocol for proving that a committed vector <span class="math">\\mathbf{x}</span> satisfies <span class="math">L(\\mathbf{x})=y</span> for a public linear form <span class="math">L</span> and a public scalar <span class="math">y</span>. By an appropriate adaptation of the techniques from <em>[BCC^{+}16, BBB^{+}18]</em> this pivotal <span class="math">\\Sigma</span>-protocol is compressed to achieve communication complexity that is logarithmic in the dimension of <span class="math">\\mathbf{x}</span>; additionally a linearization approach to handle non-linearities is described <em>[x1]</em>. As one of the applications of this theory it was shown how to obtain circuit zero-knowledge (ZK) protocols with logarithmic communication complexity for arbitrary arithmetic circuits.</p>

    <p class="text-gray-300">An obvious approach for constructing proofs of partial knowledge with logarithmic complexity is to apply recent advances in communication efficient circuit ZK to a suitably constructed circuit for capturing the <span class="math">k</span>-out-of-<span class="math">n</span> relation. For instance, this is how the decentralized and confidential transaction system ZCash is designed <em>[x14]</em>.</p>

    <p class="text-gray-300">In this work here, we take a more direct approach that avoids generic circuit techniques. We find such a direct solution scientifically more appealing, but there are also efficiency considerations that may make our solution the preferred choice (we discuss this in detail in Section 1.5). Our solution is inspired by the core idea of <em>[x10]</em> of exploiting properties of linear secret sharing; however, the straightforward approach of compressing the original <em>[x10]</em>-protocol with the techniques of <em>[x1]</em> does not work; the third message in the <em>[x10]</em>-protocol includes a consistent secret sharing of the challenge, which cannot be compressed.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Their Applications</h3>

    <p class="text-gray-300">Proofs of partial knowledge have seen myriad applications during the last decades. For instance, they were shown to be applicable to the construction of <em>group signature schemes</em> <em>[x11]</em>. Group signature schemes <em>[x12]</em> allow a member of a group to sign a message without revealing which member it is, while a designated <em>group manager</em> is capable of revoking the anonymity of the signer.</p>

    <p class="text-gray-300">Another application is to <em>ring signature schemes</em> <em>[x23]</em>, which do not contain such a revocation mechanism. In a ring signature scheme, a group member can select any ad-hoc subset of group members and anonymously sign a message on behalf of this subset. Here, 1-out-of-<span class="math">n</span> proofs together with the Fiat-Shamir <em>[x15]</em> heuristic allow for a straightforward construction of ring-signature schemes. Because of the ad-hoc nature a ring signature must contain a list of the subset’s members and, therefore, its size grows linearly in the size of the ring; however, in many practical scenario’s the costs of specifying a ring can be amortized over many instances.</p>

    <p class="text-gray-300">Proofs of partial knowledge, in particular in the form of ring signature schemes, also play a crucial role in confidential decentralized transactions system such as Zerocoin <em>[x20]</em>. Zerocoin was proposed as an extension of Bitcoin to provide stronger privacy guarantees. A Zerocoin transaction requires a ZKPoK that the transferred coin is an element of a public set of unspent coins. Other decentralized payment systems that rely on 1-out-of-<span class="math">n</span> proofs to provide confidentiality are, e.g., Lelantus <em>[x16]</em>, ZCash <em>[x14]</em>, Zether <em>[x4]</em> and Monero <em>[x28]</em>.</p>

    <p class="text-gray-300">As a generalization of ring signature schemes, threshold ring signatures only allow a large enough subset to compute a valid signature <em>[x13]</em>. These schemes require a generalization of the special proof of partial knowledge case <span class="math">k=1</span>. For instance, Monero is actively working on threshold ring signature schemes <em>[x18]</em>. Moreover, in <em>[x10]</em>, it is shown how their generalization from 1-out-of-<span class="math">n</span> proofs to so-called many-out-of-many proofs improves the communication complexity of the Zether payment system. They show that many practical scenarios require more general proofs of partial knowledge than only 1-out-of-<span class="math">n</span> proofs.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">1.3 Our Contributions</p>

    <p class="text-gray-300">In this work, we start off by introducing and analyzing a novel extension of the core compression protocol from compressed <span class="math">\\Sigma</span>-protocol theory <em>[x1]</em>. Namely, we observe that the compressed <span class="math">\\Sigma</span>-protocol for opening linear forms can be adapted to apply to general homomorphisms, i.e., for proving that a committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> satisfies <span class="math">f(\\mathbf{x})=y</span> for an arbitrary group homomorphism <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}</span> and an element <span class="math">y\\in\\mathbb{G}</span>. The loss of efficiency is at most a constant factor and the adapted protocol still achieves a logarithmic communication complexity. Furthermore, the amortization technique to open multiple linear forms for essentially the price of one <em>[x1]</em> directly carries over to opening multiple homomorphisms. This generalized functionality has not been considered before in the context of logarithmic complexity. As we discuss below, it turns out to be very useful in the design of efficient proofs of partial knowledge, but possibly also beyond.</p>

    <p class="text-gray-300">Indeed, given <span class="math">n</span> group elements <span class="math">P_{1},\\ldots,P_{n}\\in\\mathbb{G}</span>, consider a prover claiming that it knows <span class="math">k</span> out of the <span class="math">n</span> DLs, i.e., it knows a subset <span class="math">S\\subset\\{1,\\ldots,n\\}</span> of cardinality <span class="math">k</span> and exponents <span class="math">x_{i}\\in\\mathbb{Z}_{q}</span> such that <span class="math">g^{x_{i}}=P_{i}</span> for all <span class="math">i\\in S</span>. Inspired by the design principle of <em>[x3]</em>, we reduce this <span class="math">k</span>-out-of-<span class="math">n</span> case to the <span class="math">n</span>-out-of-<span class="math">n</span> case by having the prover “eliminate” the instances that it does not know, and then we apply the amortized version of the new compressed <span class="math">\\Sigma</span>-protocol for opening homomorphisms to prove the <span class="math">n</span> instances in one go, with logarithmic complexity. However, the original solution of <em>[x3]</em> to reduce the <span class="math">k</span>-out-of-<span class="math">n</span> to the <span class="math">n</span>-out-of-<span class="math">n</span> case, achieved by secret sharing the challenge, does not work for us, as the resulting protocol is not in the shape for the (above generalization of the) <em>[x1]</em> compression technique to apply.</p>

    <p class="text-gray-300">Instead, we use the following new solution. The prover first chooses an <span class="math">(n-k+1)</span>-out-of-<span class="math">n</span> Shamir secret sharing <span class="math">(s_{1},\\ldots,s_{n})</span> of the default secret <span class="math">s=1</span>, where it selects the non-constant “random” coefficients <span class="math">a_{1},\\ldots,a_{n-k}</span> of the sharing polynomial <span class="math">p(X)=1+a_{1}X+\\cdots+a_{n-k}X^{n-k}</span> so that <span class="math">s_{i}=0</span> for <span class="math">i\\not\\in S</span>. The prover then commits to the vector <span class="math">(\\mathbf{a},\\mathbf{t})=(a_{1},\\ldots,a_{n-k},t_{1},\\ldots,t_{n})\\in\\mathbb{Z}_{q}^{2n-k}</span> with <span class="math">t_{i}</span> set to <span class="math">t_{i}=s_{i}x_{i}</span> for any <span class="math">i</span>, understood to be equal to <span class="math">0</span> for <span class="math">i\\notin S</span>, i.e., when <span class="math">s_{i}=0</span>. Finally, it proves that</p>

    <p class="text-gray-300"><span class="math">g^{t_{i}}=P_{i}^{s_{i}}</span> (1)</p>

    <p class="text-gray-300">for all <span class="math">i\\in\\{1,\\ldots,n\\}</span>. Proving this linear relation with a standard <span class="math">\\Sigma</span>-protocol gives a novel secret-sharing based realization of <em>[x3]</em>, with linear communication complexity.</p>

    <p class="text-gray-300">This protocol crucially differs from the original proofs-of-partial knowledge, making it amenable to our compression techniques. First, it generates a single compact commitment to the vector of interest <span class="math">(\\mathbf{a},\\mathbf{t})</span>. No compact commitments are used in the original protocol. Second, the <span class="math">(n-k+1,n)</span>-secret sharing of <span class="math">1</span> is implicitly defined by the committed coefficients <span class="math">a_{1},\\ldots,a_{n-k}</span>. By contrast, in the original protocol the prover computes an arbitrary <span class="math">(n-k+1,n)</span>-secret sharing of a challenge <span class="math">c</span> sampled uniformly at random by the verifier. Since the verifier has to check the consistency of this secret sharing this approach has an inherent linear communication complexity.</p>

    <p class="text-gray-300">Let us consider our proofs-of-partial knowledge realization. By the linearity of Shamir’s secret sharing scheme, for any <span class="math">i</span> Equation 1 can be cast as a homomorphism of the committed values <span class="math">a_{1},\\ldots,a_{n-k},t_{1},\\ldots,t_{n}</span>, and thus our novel variation of <em>[x1]</em>, including the amortization over the <span class="math">n</span> homomorphisms, applies, thereby achieving a logarithmic communication complexity.</p>

    <p class="text-gray-300">In total, our <span class="math">k</span>-out-of-<span class="math">n</span> proof protocol requires the prover to send <span class="math">4\\left\\lceil\\log_{2}(2n-k+1)\\right\\rceil-5</span> group elements and <span class="math">4</span> elements in <span class="math">\\mathbb{Z}_{q}</span> to the verifier. We also show how to further reduce this to <span class="math">2\\left\\lceil\\log_{2}(2n-k+1)\\right\\rceil-1</span> group elements and <span class="math">4</span> elements in <span class="math">\\mathbb{Z}_{q}</span> on a pairing-based platform. The protocol is public-coin and can therefore be made non-interactive by the Fiat-Shamir transform <em>[x10]</em>. The public set-up, necessary for the vector commitment, consists of at most <span class="math">2n</span> group elements, and the complexity of the prover scales linearly in <span class="math">n</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.4 Extensions and Variations</h3>

    <p class="text-gray-300">The conceptual simplicity of our design principle makes it easy to extend the protocol in various directions, for instance to proofs of partial knowledge about “multi-generator discrete logarithms” and corresponding</p>

    <p class="text-gray-300">Pedersen vector commitments. Furthermore, by introducing a pairing and considering a pairing based extension of Pedersen’s vector commitment scheme, we can reduce the relevant constant by another factor up to 2. Moreover, we show that our proofs of partial knowledge are compatible with circuit ZK protocols of <em>[x1]</em>, allowing the prover to demonstrate that his secret information satisfies some arbitrary given constraint. Finally, we generalize the results from threshold access structures to arbitrary access structures.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.5 Comparison with Other Approaches</h3>

    <p class="text-gray-300">Achieving partial proofs of knowledge with logarithmic complexity has received quite some attention over the last few years, with different approaches and different (partial) solutions. We discuss here the examples that are most relevant in the context of our new approach, and we compare them with our results.</p>

    <p class="text-gray-300">In <em>[x11]</em>, Groth and Kohlweiss consider the special case <span class="math">k=1</span>, and where the prover claims to be able to open 1 out of <span class="math">n</span> public commitments to zero. Their solution is a <span class="math">\\Sigma</span>-protocol that works for any additively homomorphic commitment scheme over <span class="math">\\mathbb{Z}_{q}</span> and it achieves a logarithmic communication complexity. To describe their approach, let <span class="math">1\\leq\\ell\\leq n</span> be the index of the prover’s secret. The prover commits to each bit of <span class="math">\\ell</span> and runs <span class="math">\\lceil\\log_{2}(n)\\rceil</span> standard <span class="math">\\Sigma</span>-protocols, in parallel and on a common challenge, proving that all these commitments can indeed be opened to a binary value. In addition, the prover shows that the responses of these parallel <span class="math">\\Sigma</span>-protocols satisfy some multiplicative relation, which completes the protocol. This approach does not have an obvious generalization to <span class="math">k</span>-out-of-<span class="math">n</span> proofs.</p>

    <p class="text-gray-300">The 1-out-of-<span class="math">n</span> proof of <em>[x11]</em> requires the prover to send <span class="math">4\\lceil\\log_{2}(n)\\rceil</span> group elements and <span class="math">3\\lceil\\log_{2}(n)\\rceil+1</span> field elements. By using Pedersen vector commitments, instead of ordinary Pedersen commitment, the communication costs can be further reduced to <span class="math">\\lceil\\log_{2}(n)\\rceil+4</span> group elements and <span class="math">\\lceil\\log_{2}(n)\\rceil+3</span> field elements <em>[BCC^{+}15]</em>. Instead of the binary decomposition, the approach of <em>[BCC^{+}15]</em> considers the <span class="math">m</span>-ary decomposition of the secret index <span class="math">\\ell</span>. Here, we have optimized their approach for proving knowledge of 1-out-of-<span class="math">n</span> discrete logarithms by taking <span class="math">m=2</span>. The work of <em>[BCC^{+}15]</em> focuses on a slightly different scenario in which the communication costs are minimized for <span class="math">m=4</span>.</p>

    <p class="text-gray-300">In comparison, in our protocol, which works for any <span class="math">k</span>, the prover sends <span class="math">4\\lceil\\log_{2}(2n-k+1)\\rceil-5</span> group elements and 4 field elements to the verifier, which is reduced to <span class="math">2\\lceil\\log_{2}(2n-k+1)\\rceil-1</span> group elements and 4 field elements on a pairing-based platform. Hence, perhaps surprisingly, our simple protocols are comparable to dedicated solutions for the special case <span class="math">k=1</span>.</p>

    <p class="text-gray-300">Recently, a generalization from 1-out-of-<span class="math">n</span> proofs of <em>[x11]</em> to “many-out-of-many” proofs was given <em>[x10]</em>. This generalization considers a prover that claims to know the opening of all commitments in one of the orbits of a public permutation of <span class="math">n</span> public commitments. However, the protocol only works for permutations with orbits of equal size. Since the permutation is public and of this specific form, this protocol does not constitute a general <span class="math">k</span>-out-of-<span class="math">n</span> proof of partial knowledge.</p>

    <p class="text-gray-300">The prover complexity of the aforementioned 1-out-of-<span class="math">n</span> proofs <em>[x11, BCC^{+}15]</em> is <span class="math">O\\big{(}\\kappa n\\log(n)\\big{)}</span>, and that of the “many-out-of-many” proofs <em>[x10]</em> is <span class="math">O\\big{(}\\kappa n\\log^{2}(n)\\big{)}</span>, where <span class="math">\\kappa</span> is the computational security parameter. By contrast, our protocol has prover complexity <span class="math">O\\big{(}\\kappa n\\big{)}</span>. Here and below, we express the prover complexity in terms of the number of group operations required. Note that, a single exponentiation requires <span class="math">O(\\kappa)=O(\\log(q))</span> group operations. By contrast, some other authors express the prover complexity in the number of exponentiations. Similarly, we specify the communication costs in terms of the number group and field elements.</p>

    <p class="text-gray-300">Aiming to improve the prover complexity of the 1-out-of-<span class="math">n</span> proofs of <em>[x11, BCC^{+}15]</em>, Jivanyan and Mamikonyan <em>[x20]</em> proposed a hierarchical approach. Their protocol assumes that <span class="math">n=NM</span> and applies an appropriate 1-out-of-<span class="math">N</span> proof followed by a 1-out-of-<span class="math">M</span> proof. It reduces the prover complexity from <span class="math">O(\\kappa n\\log(n))</span> down to <span class="math">O\\big{(}\\kappa(n+N\\log(N)+M\\log(M))\\big{)}</span>, which equals <span class="math">O(\\kappa n)</span> if, for example, <span class="math">N=M=\\sqrt{n}</span>. However, this hierarchical approach increases the communication complexity to <span class="math">O\\big{(}N\\log(N)+M\\log(M)+M\\big{)}</span>, hence it is subject to a trade-off between prover and communication complexity.</p>

    <p class="text-gray-300">Alternatively to our and the above approaches, proofs of partial knowledge can be constructed via generic circuit ZK protocols. This indirect approach is, for example, followed by the confidential transaction system ZCash <em>[x14]</em>. A standard construction for the 1-out-of-<span class="math">n</span> case is to incorporate the group elements <span class="math">P_{i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">into a Merkle tree [Mer80], and ask the prover to prove knowledge of an exponent  <span class="math">x_{i}</span>  such that the group element  <span class="math">g^{x_i}</span>  is the leaf of a valid, but secret, Merkle path. In this case, the arithmetic circuit  <span class="math">C</span>  implements a composition of the exponentiation  <span class="math">g^{x_i}</span>  and the  <span class="math">\\log_2(n)</span>  hash function evaluations corresponding to the validation of a Merkle path, and it is therefore of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O\\big(\\kappa \\log (n)\\big)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Even though this is obviously possible, to our knowledge this Merkle-tree approach has not been explicitly generalized to the  <span class="math">k</span> -out-of- <span class="math">n</span>  case before, making it difficult to do a rigorous efficiency comparison. However, such a generalization would require  <span class="math">k</span>  Merkle paths to be validated, resulting in circuits of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O\\big(\\kappa k\\log_2(n)\\big)<span class="math"> . In addition, the circuit has to validate that the  </span>k<span class="math">  Merkle paths are distinct. The obvious way to do this requires a circuit of size  </span>O(k^2)<span class="math"> . In these complexity estimates we neglect the  </span>O(\\kappa n)$  size circuit required to construct the Merkle tree, because these costs can be amortized in some applications.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Table 1, the asymptotic complexities of our direct approach are compared with the indirect approach, instantiated with typical communication efficient circuit ZK protocols for which the size of the public parameters and the prover complexity are linear and the communication complexity is logarithmic in the circuit size. We observe that, if  <span class="math">k = \\Omega(\\sqrt{n})</span> , our approach yields an asymptotic improvement over the indirect approach.</p>

    <p class="text-gray-300">Moreover, the constants of our approach are small. By contrast, taking for instance the case  <span class="math">k = 1</span>  and a highly optimized group, associated to a security parameter  <span class="math">\\kappa \\approx 100</span> , the indirect approach can be instantiated with arithmetic circuits containing approximately  <span class="math">1400\\log_2(n)</span>  multiplication gates [HBHW20]. Hence, even for the 1-out-of-  <span class="math">n</span>  case, where the indirect approach has better asymptotic complexities, we obtain better communication complexity for  <span class="math">n</span>  ranging up to roughly 9000.</p>

    <p class="text-gray-300">Table 1. Comparison of the asymptotic complexities of the indirect approach, using typical communication-efficient circuit ZK protocols, and our direct approach, for  <span class="math">k</span> -out-of-  <span class="math">n</span>  proofs of partial knowledge, with security parameter  <span class="math">\\kappa</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Indirect Circuit ZK Approach</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our Direct Approach</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Size of Public Parameters</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κk log(n) + k2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover Complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κk log(n) + k2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(κn)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication Complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(κk log(n) + k2))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log(n))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above circuit approach can further be adjusted, for instance by invoking ZK protocols with constant communication complexity [Gro10], or by replacing Merkle trees with RSA-accumulators [BdM93], which results in arithmetic circuits with a number of multiplication gates that is constant in  <span class="math">n</span>  [STY00]. However, these approaches are incomparable in that they are based on computational hardness assumptions that are considered less standard, like the strong-RSA assumption or the knowledge-of-exponent assumption. Furthermore, in these protocols, the size of the public parameters and the prover complexity are still linear in the circuit size, and for practical instances still result in sizeable circuits, respectively.</p>

    <p class="text-gray-300">The remainder of paper is organized as follows. In Section 2, we recall the notation and some of the results from compressed  <span class="math">\\Sigma</span> -protocol theory [AC20]. In Section 3, we describe our twist on the pivotal  <span class="math">\\Sigma</span> -protocol from [AC20]. In Section 4, we combine this generalization with an adaptation of the techniques from [CDS94] to construct our proof of partial knowledge. Finally, in Section 5, we discuss a number of extensions and generalizations of our proofs of partial knowledge.</p>

    <p class="text-gray-300">2 Preliminaries</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Interactive Proofs</h3>

    <p class="text-gray-300">We briefly introduce the concept of an interactive proof and some of the basic (security) properties. An interactive proof <span class="math">\\Pi</span> for relation <span class="math">R</span> is a protocol between prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>. It takes as public input the statement <span class="math">x</span> and as prover’s private input the witness <span class="math">w</span>, which is written as <span class="math">\\textsc{Input}(x;w)</span>. As the output of the protocol the verifier either accepts or rejects the prover’s claim of knowing a witness <span class="math">w</span>. <span class="math">\\Pi</span> is called (perfectly) complete if on any input <span class="math">(x;w)\\in R</span> the verifier always accepts. Evaluating <span class="math">\\Pi</span> on input <span class="math">(x;w)</span> is also written as <span class="math">\\Pi(x;w)</span>.</p>

    <p class="text-gray-300">An interactive proof with <span class="math">\\mu</span> communication rounds is also called a <span class="math">\\mu</span>-move protocol. Note that the final message is always sent from the prover to the verifier. The messages communicated in one protocol evaluation are also referred to as a conversation or a transcript. If all the messages from the verifier to the prover consist of random coins chosen by the verifier, one speaks of a public-coin protocol. All our protocols will be public-coin and thereby suitable for the Fiat-Shamir transformation <em>[x10]</em>, which turns public-coin interactive proofs into non-interactive protocols.</p>

    <p class="text-gray-300">An interactive proof <span class="math">\\Pi</span> for relation <span class="math">R</span> is said to have witness extended emulation <em>[x20]</em> if there exists algorithm <span class="math">\\chi</span> (witness extended emulator) that runs in expected polynomial time and does the following. The algorithm <span class="math">\\chi</span>, on input <span class="math">x</span> and given rewindable oracle access to a (possibly dishonest) prover <span class="math">\\mathcal{P}^{<em>}</span>, outputs a transcript and a witness <span class="math">w</span> such that: (1) the emulated transcript is statistically indistinguishable from conversations between <span class="math">\\mathcal{P}^{</em>}</span> and an honest verifier <span class="math">\\mathcal{V}</span>, and (2) the probability that the emulated transcript is accepting and the witness <span class="math">w</span> is not a valid witness for <span class="math">x</span> is negligible. Witness extended emulation gives a notion for proofs of knowledge (PoKs) that is sufficient in practical applications <em>[BCC^{+}16, BBB^{+}18, x1]</em>.</p>

    <p class="text-gray-300">We also consider the computational version of a PoK, where witness extended emulation is required to hold only for computationally bounded dishonest provers under a computational hardness assumption. In those cases, the relation <span class="math">R</span> typically depends on a (possibly implicit) security parameter, as well as on some additional public parameters that are assumed to be chosen according to a specific probability distribution, and the success probability of the prover is then understood to be on average over the choice of these public parameters. These computational variants of proofs of knowledge are also called arguments of knowledge.</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi</span> is called honest verifier zero-knowledge (HVZK) if there exists an efficient simulator that, on input a statement <span class="math">x</span> that admits a witness <span class="math">w</span>, outputs an accepting transcript, such that the simulated transcripts follow exactly the same distribution as transcripts between an honest prover and an honest verifier.</p>

    <p class="text-gray-300">A 3-move public-coin interactive proof is called a <span class="math">\\Sigma</span>-protocol. The 3 messages are then typically denoted <span class="math">(a,c,z)</span> where <span class="math">c</span> is called the challenge. For a HVZK <span class="math">\\Sigma</span>-protocol the simulator often proceeds by first selecting a random challenge <span class="math">c</span> and then preparing the messages <span class="math">a</span> and <span class="math">z</span>; in this case, we speak of special honest verifier zero-knowledge (SHVZK).</p>

    <p class="text-gray-300">A <span class="math">\\Sigma</span>-protocol is called <span class="math">k</span>-special sound if there exists an efficient algorithm that, on input any statement <span class="math">x</span> and <span class="math">k</span> accepting transcripts <span class="math">(a,c_{1},z_{1}),\\ldots,(a,c_{k},z_{k})</span> with common first message <span class="math">a</span> and pairwise distinct challenges <span class="math">c_{i}</span>, outputs a witness <span class="math">w</span> for <span class="math">x</span>.</p>

    <p class="text-gray-300">More generally, we consider <span class="math">(2\\mu+1)</span>-move public-coin protocols, in which all the verifier’s messages are uniformly random challenges. These protocols are called <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound if there exists an efficient algorithm that, on input any statement <span class="math">x</span> and a <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts, outputs a witness <span class="math">w</span> for <span class="math">x</span>. A <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts is a set of <span class="math">\\prod_{i=1}^{\\mu}k_{i}</span> accepting transcripts that are arranged in the following tree structure. The nodes in this tree correspond to the prover’s messages and the edges correspond to the verifier’s challenges. Every node at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. Every transcript corresponds to exactly one path from the root node to a leaf node.</p>

    <p class="text-gray-300">We note that in some public-coin protocols the verifier sends <span class="math">\\mu</span> challenges in less than <span class="math">2\\mu+1</span> rounds, i.e., some of the verifier’s messages contain more than one challenge. For these protocols, we also consider the</p>

    <p class="text-gray-300"><span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness property. In this case, a <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts contains nodes that do not correspond to a message sent from the prover to the verifier.</p>

    <p class="text-gray-300">Let us assume that the challenges are sampled uniformly at random from challenge sets with a cardinality that is exponential in the security parameter. In this work all challenge sets are equal to <span class="math">\\mathbb{Z}_{q}\\cong\\mathbb{Z}/(q\\mathbb{Z})</span> for some prime <span class="math">q</span> that is understood to be exponential in the security parameter. Hence, for the protocols in this work this assumption is satisfied. Then witness extended emulation is known to follow from <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-special soundness <em>[BCC^{+}16]</em>. In this work, we will show that all protocols are <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-special sound for some <span class="math">\\mu</span> and some list of <span class="math">k_{i}</span>’s, from which witness extended emulation therefore follows.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Multi-Exponentiation and The Pedersen Vector Commitment Scheme</h3>

    <p class="text-gray-300">We consider statements over the ring <span class="math">\\mathbb{Z}_{q}\\cong\\mathbb{Z}/(q\\mathbb{Z})</span> with <span class="math">q</span> prime. We let <span class="math">\\mathbb{G}</span> be an Abelian group of prime order <span class="math">q</span> for which we write its group operation multiplicatively. We write vectors in <span class="math">\\mathbb{Z}_{q}^{n}</span> or <span class="math">\\mathbb{G}^{n}</span> in boldface, i.e., <span class="math">\\mathbf{x}=(x_{1},\\ldots,x_{n})\\in\\mathbb{Z}_{q}^{n}</span> and <span class="math">\\mathbf{g}:=(g_{1},\\ldots,g_{n})\\in\\mathbb{G}^{n}</span>, and we write <span class="math">\\mathbf{g}^{\\mathbf{x}}</span> for the multi-exponentiation</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}^{\\mathbf{x}}:=\\prod_{i=1}^{n}g_{i}^{x_{i}}\\in\\mathbb{G}\\,.</span></p>

    <p class="text-gray-300">Furthermore, for vectors <span class="math">\\mathbf{x},\\mathbf{y}\\in\\mathbb{Z}_{q}^{n}</span>, <span class="math">\\mathbf{g},\\mathbf{h}\\in\\mathbb{G}^{n}</span> and scalar <span class="math">c\\in\\mathbb{Z}_{q}</span>, we have the following component-wise operations:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}<em>\\mathbf{h}:=(g_{1}h_{1},g_{2}h_{2},\\ldots,g_{n}h_{n})\\in\\mathbb{G}^{n},\\;\\mathbf{g}^{c}:=(g_{1}^{c},g_{2}^{c},\\ldots,g_{n}^{c})\\in\\mathbb{G}^{n}\\;\\text{ and }\\;\\mathbf{x}</em>\\mathbf{y}:=(x_{1}y_{1},x_{2}y_{2},\\ldots,x_{n}y_{n})\\in\\mathbb{Z}_{q}^{n}.</span></p>

    <p class="text-gray-300">Additionally, assuming <span class="math">n</span> is even, we write <span class="math">\\mathbf{g}_{L}:=(g_{1},\\ldots,g_{n/2})</span>, <span class="math">\\mathbf{g}_{R}:=(g_{n/2+1},\\ldots,g_{n})\\in\\mathbb{G}^{n/2}</span> and <span class="math">\\mathbf{x}_{L}:=(x_{1},\\ldots,x_{n/2})</span>, <span class="math">\\mathbf{x}_{R}:=(x_{n/2+1},\\ldots,x_{n})\\in\\mathbb{Z}_{q}^{n/2}</span>, for the left and right halves of these vectors.</p>

    <p class="text-gray-300">We let <span class="math">\\mathbb{G}_{T}</span> be another Abelian group and denote the set of all group homomorphisms <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span> by <span class="math">\\mathrm{Hom}(\\mathbb{Z}_{q}^{n},\\mathbb{G}_{T})</span>. Typically <span class="math">\\mathbb{G}_{T}=\\mathbb{G}</span> or <span class="math">\\mathbb{G}_{T}=\\mathbb{Z}_{q}</span>, in the latter case <span class="math">\\mathrm{Hom}(\\mathbb{Z}_{q}^{n},\\mathbb{G}_{T})=\\mathrm{Hom}(\\mathbb{Z}_{q}^{n},\\mathbb{Z}_{q})</span> is the set of linear forms on <span class="math">\\mathbb{Z}_{q}^{n}</span>. For any homomorphism <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span> it holds that its image <span class="math">\\mathrm{im}(f)\\subset\\mathbb{G}_{T}</span> is a <span class="math">\\mathbb{Z}_{q}</span>-module. For this reason, and without loss of generality, we assume that <span class="math">\\mathbb{G}_{T}</span> is a <span class="math">\\mathbb{Z}_{q}</span>-module.</p>

    <p class="text-gray-300">Moreover, we define the left and right part of <span class="math">f</span> as follows:</p>

    <p class="text-gray-300"><span class="math">f_{L}:\\mathbb{Z}_{q}^{n/2}\\to\\mathbb{G}_{T},\\quad</span> <span class="math">\\mathbf{x}\\mapsto f(\\mathbf{x},0),</span> (2) <span class="math">f_{R}:\\mathbb{Z}_{q}^{n/2}\\to\\mathbb{G}_{T},\\quad</span> <span class="math">\\mathbf{x}\\mapsto f(0,\\mathbf{x}),</span></p>

    <p class="text-gray-300">where, e.g., <span class="math">(\\mathbf{x},0)\\in\\mathbb{Z}_{q}^{n}</span> is the vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n/2}</span> appended with <span class="math">n/2</span> zeros.</p>

    <p class="text-gray-300">In this work we also consider the Pedersen vector commitment scheme. This commitment scheme allows a prover to (compactly) commit to an <span class="math">n</span>-dimensional vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> in a single group element <span class="math">P\\in\\mathbb{G}</span>. We recall that a Pedersen vector commitment <span class="math">P</span> is simply a multi-exponentiation, i.e.,</p>

    <p class="text-gray-300"><span class="math">P=h^{\\gamma}\\mathbf{g}^{\\mathbf{x}},</span></p>

    <p class="text-gray-300">for public parameters <span class="math">h\\in\\mathbb{G}</span> and <span class="math">\\mathbf{g}\\in\\mathbb{G}^{n}</span> and for a (private) <span class="math">\\gamma\\in\\mathbb{Z}_{q}</span> sampled uniformly at random by the prover.</p>

    <p class="text-gray-300">The Pedersen vector commitment scheme is perfectly hiding and computationally binding under the discrete logarithm assumption. More precisely, the commitment scheme is binding under the assumption that a prover does not know a non-zero vector <span class="math">(\\gamma,x_{1},\\ldots,x_{n})\\in\\mathbb{Z}_{q}^{n+1}</span> such that</p>

    <p class="text-gray-300"><span class="math">h^{\\gamma}\\prod_{i=1}^{n}g_{i}^{x_{i}}=1.</span></p>

    <p class="text-gray-300">Such a non-zero vector <span class="math">(\\gamma,x_{1},\\ldots,x_{n})</span> is also called a non-trivial discrete log relation for group elements <span class="math">h,g_{1},\\ldots,g_{n}</span>. From here on forward, we assume that these group elements have been sampled uniformly at random in a setup phase and that the prover does not know a non-trivial discrete logarithm (DL) relation. These group elements form the set of public parameters for all our protocols. We say a protocol is computationally <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound, under the discrete logarithm assumption, if <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness holds under the assumption that a prover does not know a non-trivial DL relation between the public parameters.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3 Proving Group Homomorphism Openings on Multi-Exponentiations</h2>

    <p class="text-gray-300">In this section, we construct an interactive proof for proving that a secret multi-exponent <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> for a public multi-exponentiation <span class="math">P=\\mathbf{g}^{\\mathbf{x}}\\in\\mathbb{G}</span> is mapped to a given public value <span class="math">y</span> under an arbitrary but given group homomorphism <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span>. Our new protocol has a communication complexity that is logarithmic in the dimension <span class="math">n</span>. By considering one of the coordinates of <span class="math">\\mathbf{x}</span> to be “the randomness”, and considering an <span class="math">f</span> that ignores this coordinate, we immediately get a protocol that applies to Pedersen vector commitments and proves that the committed vector satisfied the relation defined by the considered group homomorphism and the target value <span class="math">y</span>.</p>

    <p class="text-gray-300">Our approach for constructing said protocol is as follows. We start with the canonical <span class="math">\\Sigma</span>-protocol for the considered problem of proving <span class="math">f(\\mathbf{x})=y</span> (Section 3.1), and we then adapt the compression mechanism of <em>[x1]</em> such that it is applicable to our setting. Indeed, our setting is a generalization of <em>[x1]</em>, which applies to the special case where <span class="math">f</span> is a linear form <span class="math">L:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}</span>. This then results in a compressed <span class="math">\\Sigma</span>-protocol that features the claimed logarithmic complexity (Section 3.3).</p>

    <p class="text-gray-300">Later in the section, we also discuss a couple of (standard) amortization techniques applied to our protocol, for instance for proving <span class="math">f_{i}(\\mathbf{x})=y_{i}</span> for several group homomorphisms <span class="math">f_{i}</span> at (essentially) the cost of proving one.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.1 The Standard <span class="math">\\Sigma</span>-protocol for Opening Homomorphisms</h3>

    <p class="text-gray-300">We consider the problem of proving that the multi-exponent <span class="math">\\mathbf{x}</span> of a multi-exponentiation <span class="math">P=\\mathbf{g}^{\\mathbf{x}}</span> is mapped to a certain value <span class="math">y</span> under a given homomorphism <span class="math">f\\in\\mathrm{Hom}(\\mathbb{Z}_{q},\\mathbb{G}_{T})</span>, i.e., that <span class="math">f(\\mathbf{x})=y</span>, without revealing <span class="math">\\mathbf{x}</span>. More concretely, we want to construct PoK protocols for the relation</p>

    <p class="text-gray-300"><span class="math">R_{f}=\\big{\\{}\\big{(}P\\in\\mathbb{G},y\\in\\mathbb{G}_{T};\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}\\big{)}:P=\\mathbf{g}^{\\mathbf{x}},y=f(\\mathbf{x})\\big{\\}}.</span> (3)</p>

    <p class="text-gray-300">Protocol 1, denoted by <span class="math">\\Pi_{0}</span>, is the canonical <span class="math">\\Sigma</span>-protocol for this relation <span class="math">R_{f}</span>, following the generic construction design for <span class="math">q</span>-one-way group homomorphisms <em>[x10, x9]</em>. The properties of <span class="math">\\Pi_{0}</span>, known to hold for this generic construction, are summarized in Theorem 1. Note that the only difference between this protocol and Protocol 2 of <em>[x1]</em> is that here we consider multi-exponentiations and general group homomorphisms instead of Pedersen commitments and linear forms.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1 (Homomorphism Evaluation).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{0}</span> is a <span class="math">\\Sigma</span>-protocol for relation <span class="math">R_{f}</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{G}</span>, 1 element of <span class="math">\\mathbb{G}_{T}</span> and <span class="math">n</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <p class="text-gray-300">Protocol 1  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_0</span>  for relation  <span class="math">R_f</span> Opening a homomorphism on a Pedersen vector commitment.</p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: g ∈ Gn, INPUT(P,y;x)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | P = g^x ∈ G |   |</p>

    <p class="text-gray-300">|   | y = f(x) ∈ GT |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  r ←R Zq^n |  |   |</p>

    <p class="text-gray-300">|  A = gr |  |   |</p>

    <p class="text-gray-300">|  t = f(r) |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A,t→</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c ←R Zq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ←c |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z = cx + r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z→</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | g^z = AP^c  |</p>

    <p class="text-gray-300">|   |  | f(z) = cy + t  |</p>

    <p class="text-gray-300">The  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_0</span>  for opening homomorphisms has a linear communication complexity. We now deploy the techniques from  <span class="math">[\\mathrm{BCC}^{+}16, \\mathrm{BBB}^{+}18, \\mathrm{AC20}]</span>  to compress the communication complexity from linear to logarithmic. A first observation is that the verifier's final check verifies that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(A P ^ {c}, c y + t; \\mathbf {z}\\right) \\in R _ {f},</span></div>

    <p class="text-gray-300">i.e., that the prover's final message  <span class="math">\\mathbf{z}</span>  is a witness with respect to the same relation  <span class="math">R_{f}</span>  for the statement  <span class="math">(AP^{c}, cy + t)</span> ; which is computed by the verifier. This is no coincidence; this holds generically for this standard construction of  <span class="math">\\Sigma</span> -protocols for  <span class="math">q</span> -one-way group homomorphisms. The final message of  <span class="math">\\Pi_0</span>  can therefore be understood as a trivial PoK for relation  <span class="math">R_{f}</span> , and replacing this trivial PoK by a more efficient one will reduce the communication complexity without affecting security (significantly). In particular, the alternative PoK does not have to be zero-knowledge since the trivial one obviously is not.</p>

    <p class="text-gray-300">Our compression mechanism is thus an interactive proof  <span class="math">\\varPi_{1}</span>  for relation  <span class="math">R_{f}</span>  that is not zero-knowledge anymore but has improved efficiency. The compression mechanism is very similar to the one used in [AC20]. The difference is that we consider the more general case of opening arbitrary group homomorphisms, rather than restricting ourselves to linear forms. This generalization requires a minor adaptation. The first step in the compression of [AC20] is namely to incorporate the linear form evaluation into the multi-exponentiation as an additional exponent on a new generator  <span class="math">k\\in \\mathbb{G}</span> . This reduction step does not apply to the general case of opening arbitrary group homomorphisms, and is therefore omitted in our protocols. For this reason we directly apply (a minor adaptation of) the main compression mechanism of [AC20]; ultimately this will increase the communication costs of the compressed  <span class="math">\\Sigma</span> -protocol by roughly a factor two when compared to opening linear forms. However, in contrast to the compressed  <span class="math">\\Sigma</span> -protocol for opening linear forms [AC20], our protocol is unconditionally sound rather than computationally. In Section 5.1, we show how a more general class of homomorphisms can be incorporated into the commitment, thereby avoiding the factor two loss in the communication efficiency.</p>

    <p class="text-gray-300">The compression mechanism, i.e., our protocol  <span class="math">\\varPi_{1}</span>  for relation  <span class="math">R_{f}</span>  that has improved efficiency but is not zero-knowledge, is described in Protocol 2 below. Here,  <span class="math">n</span>  is assumed to be even, which is without loss of generality (if not the witness can be appended with a zero). Also, recall that  <span class="math">\\mathbf{x}_L\\coloneqq (x_1,\\ldots ,x_{n / 2})</span>  equals the left half of the vector  <span class="math">\\mathbf{x}\\in \\mathbb{Z}_q^n</span>  and that  <span class="math">f_{R}(\\mathbf{x}_{L})\\coloneqq f(0,\\dots ,0,\\mathbf{x}_{L})</span> , etc.</p>

    <p class="text-gray-300">Before discussing the security of  <span class="math">\\varPi_1</span>  as a proof of knowledge in Theorem 2, we emphasize the following two important properties of  <span class="math">\\varPi_1</span> . The size of the response has halved compared to the original protocol  <span class="math">\\varPi_0</span> , and thereby the communication costs are reduced by roughly a factor two, and second, verifying the correctness of the response is again by means of checking whether it is a witness for the relation  <span class="math">R_{f&#x27;}</span> , now instantiated with the group homomorphism  <span class="math">f&#x27; := cf_L + f_R \\in \\mathrm{Hom}\\big(\\mathbb{Z}_q^{n/2}, \\mathbb{G}_T\\big)</span> .</p>

    <p class="text-gray-300">Protocol 2 Compression Mechanism  <span class="math">\\varPi_{1}</span>  for relation  <span class="math">R_{f}</span> .</p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: g INPUT(P,y;x)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  P = g^x ∈ G y = f(x) ∈ GT  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  A = gxR, a = fR(xL) |   |</p>

    <p class="text-gray-300">|  B = gxR, b = fL(xR) |   |</p>

    <p class="text-gray-300">|  A,B,a,b  |   |</p>

    <p class="text-gray-300">|  c←R Zq  |   |</p>

    <p class="text-gray-300">|  g' := gLz * gR ∈ Gn/2 Q := APcBc2 f' := cfL + fR  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z = xL + cxR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(g')z ≠ Q f'(z) ≠ a + cy + c2b</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 2 (Compression Mechanism). Let  <span class="math">n \\in \\mathbb{Z}_{&amp;gt;0}</span>  be even. Then  <span class="math">\\Pi_1</span>  is a 3-move protocol for relation  <span class="math">R_f</span> . It is perfectly complete and unconditionally 3-special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> : 2 elements of  <span class="math">\\mathbb{G}</span> , 2 elements of  <span class="math">\\mathbb{G}_T</span>  and  <span class="math">n/2</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> : 1 element of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness follows directly.</p>

    <p class="text-gray-300">Special Soundness: We show that the protocol is 3-special sound, i.e., there exists an efficient algorithm that on input three accepting transcripts computes a witness for relation  <span class="math">R_{f}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">(A,B,a,b,c_1,\\mathbf{z}_1)</span> ,  <span class="math">(A,B,a,b,c_2,\\mathbf{z}_2)</span>  and  <span class="math">(A,B,a,b,c_3,\\mathbf{z}_3)</span>  be three accepting transcripts for distinct challenges  <span class="math">c_{1},c_{2},c_{3}\\in \\mathbb{Z}_{q}</span> . Let  <span class="math">a_1,a_2,a_3\\in \\mathbb{Z}_q</span>  be such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c} 1 &amp;amp; 1 &amp;amp; 1 \\\\ c _ {1} &amp;amp; c _ {2} &amp;amp; c _ {3} \\\\ c _ {1} ^ {2} &amp;amp; c _ {2} ^ {2} &amp;amp; c _ {3} ^ {2} \\end{array} \\right) \\left( \\begin{array}{c} a _ {1} \\\\ a _ {2} \\\\ a _ {3} \\end{array} \\right) = \\left( \\begin{array}{c} 0 \\\\ 1 \\\\ 0 \\end{array} \\right).</span></div>

    <p class="text-gray-300">Note that, since the challenges are distinct, this Vandermonde matrix is invertible and a solution to this equation exists. We define  <span class="math">\\bar{\\mathbf{z}} = \\sum_{i=1}^{3} a_i(c_i \\mathbf{z}_i, \\mathbf{z}_i)</span>  for which it is easily verified that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} ^ {\\bar {\\mathbf {z}}} = P \\qquad \\text {a n d} \\qquad f (\\bar {\\mathbf {z}}) = y.</span></div>

    <p class="text-gray-300">Hence,  <span class="math">\\bar{\\mathbf{z}}</span>  is a witness for relation  <span class="math">R_{f}</span> , which completes the proof.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 Compressed <span class="math">\\Sigma</span>-protocol</h3>

    <p class="text-gray-300">Finally, we compose <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> and its compression mechanism <span class="math">\\Pi_{1}</span> to obtain a compressed <span class="math">\\Sigma</span>-protocol for opening homomorphisms on multi-exponentiations <span class="math">\\mathbf{g}^{\\mathbf{x}}</span> such as Pedersen vector commitments. We follow the notation of <em>[x1]</em> and write <span class="math">\\Pi_{b}\\diamond\\Pi_{a}</span> for the composition of two composable interactive proofs <span class="math">\\Pi_{a}</span> and <span class="math">\\Pi_{b}</span>. Protocols <span class="math">\\Pi_{a}</span> and <span class="math">\\Pi_{b}</span> are composable if protocol <span class="math">\\Pi_{b}</span> is a PoK for the prover’s final message of protocol <span class="math">\\Pi_{a}</span>. Recall that this composition means that the final message of protocol <span class="math">\\Pi_{a}</span> is replaced by an execution of protocol <span class="math">\\Pi_{b}</span>.</p>

    <p class="text-gray-300">We assume that <span class="math">n</span> is a power of two, if it is not the witness can be appended with zeros such that its dimension is a power of 2. For <span class="math">n\\leq 2</span> it is optimal to omit the compression mechanism, for this reason it is assumed that <span class="math">n&gt;2</span>. To minimize the communication complexity we recursively apply the compression protocol <span class="math">\\Pi_{1}</span> until the dimension of the witness is reduced to four, i.e., <span class="math">\\mu=\\lceil\\log_{2}(n)\\rceil-2</span> times. For this composition we write</p>

    <p class="text-gray-300"><span class="math">\\Pi_{c}=\\underbrace{\\Pi_{1}\\diamond\\cdots\\diamond\\Pi_{1}}_{\\mu\\text{ times}}\\diamond\\Pi_{0}.</span> (4)</p>

    <p class="text-gray-300">Theorem 3 captures the security and efficiency properties of Protocol <span class="math">\\Pi_{c}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 3 (Compressed <span class="math">\\Sigma</span>-Protocol for Opening Homomorphisms).</h6>

    <p class="text-gray-300">Let <span class="math">n&gt;2</span>, then <span class="math">\\Pi_{c}</span> is a <span class="math">(2\\mu+3)</span>-move protocol for relation <span class="math">R_{f}</span>, where <span class="math">\\mu=\\lceil\\log_{2}(n)\\rceil-2</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally <span class="math">(2,3,3,\\ldots,3)</span>-special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2\\lceil\\log_{2}(n)\\rceil-3</span> elements of <span class="math">\\mathbb{G}</span>, <span class="math">2\\lceil\\log_{2}(n)\\rceil-3</span> elements of <span class="math">\\mathbb{G}_{T}</span> and <span class="math">4</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\lceil\\log_{2}(n)\\rceil-1</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows in a straightforward manner.</p>

    <p class="text-gray-300">Special Honest Verifier Zero-Knowledge follows since <span class="math">\\Pi_{0}</span> is SHVZK. A simulator for <span class="math">\\Pi_{c}</span> runs the simulator for <span class="math">\\Pi_{0}</span>, and replaces the final messages of the simulated transcripts by honest executions of <span class="math">\\Pi_{1}\\diamond\\cdots\\diamond\\Pi_{1}</span>.</p>

    <p class="text-gray-300">Special Soundness: Since the protocol is the composition of protocols that are 2- or 3-special sound, it is easily seen that <span class="math">\\Pi_{c}</span> is <span class="math">(2,3,\\ldots,3)</span>-special sound, i.e., there exists an efficient algorithm that on input a <span class="math">(2,3,\\ldots,3)</span>-tree (depth <span class="math">\\mu+1</span>) of <span class="math">2\\cdot 3^{\\mu}</span> accepting transcripts computes a witness for relation <span class="math">R_{f}</span>. ∎</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">We explicitly emphasize once more that the above and below results on opening homomorphisms <span class="math">f(\\mathbf{x})</span> on multi-exponentiations <span class="math">\\mathbf{g}^{\\mathbf{x}}</span> immediately carry over to opening homomorphisms <span class="math">f(\\mathbf{x})</span> on Pedersen vector commitments <span class="math">\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}</span>, simply by renaming the involved variables in the obvious way.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.4 Amortization Techniques</h3>

    <p class="text-gray-300">This section describes two standard amortization techniques. First, we consider the scenario where a prover wishes to open one homomorphism <span class="math">f</span> on many multi-exponentiations <span class="math">P_{1},\\ldots,P_{s}</span>, i.e., we consider the relation</p>

    <p class="text-gray-300"><span class="math">R_{\\text{\\tiny AMOREXP}}=\\big{\\{}\\left(P_{1},\\ldots,P_{s},y_{1},\\ldots,y_{s};\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{s}\\right):P_{1}=\\mathbf{g}^{\\mathbf{x}_{1}},y_{1}=f(\\mathbf{x}_{1}),\\ldots,P_{1}=\\mathbf{g}^{\\mathbf{x}_{1}},y_{s}=f(\\mathbf{x}_{s})\\big{\\}}.</span> (5)</p>

    <p class="text-gray-300">The standard (amortized) <span class="math">\\Sigma</span>-protocol for relation <span class="math">R_{\\text{\\tiny AMOREXP}}</span> is similar to <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> for relation <span class="math">R_{f}</span>: it has the same first two moves, but then the prover’s final response is <span class="math">\\mathbf{z}=\\mathbf{r}+\\sum_{i=1}^{s}c^{i}\\mathbf{x}_{i}</span> and the verifier checks that <span class="math">\\mathbf{g}^{\\mathbf{z}}=AP_{1}^{c}\\cdots P_{s}^{c^{s}}</span> and <span class="math">f(\\mathbf{z})=t+cy_{1}+\\cdots+c^{s}y_{s}</span>. The communication costs of the amortized <span class="math">\\Sigma</span>-protocol are exactly equal to the communication costs of protocol <span class="math">\\Pi_{0}</span> and the compression mechanism applies as before. We denote the compressed amortized <span class="math">\\Sigma</span>-protocol for relation <span class="math">R_{\\text{\\tiny AMOREXP}}</span> by <span class="math">\\Pi_{\\text{\\tiny AMOREXP}}</span>. Its main properties are summarized in Theorem 4.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 4 (Amortization over Many Multi-Exponentiations).</h6>

    <p class="text-gray-300">Let <span class="math">n&gt;2</span>, then <span class="math">\\Pi_{\\text{\\tiny AMOREXP}}</span> is a <span class="math">(2\\mu+3)</span>-move protocol for relation <span class="math">R_{\\text{\\tiny AMOREXP}}</span>, where <span class="math">\\mu=\\lceil\\log_{2}(n)\\rceil-2</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally <span class="math">(s+1,3,3,\\ldots,3)</span>-special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">2\\lceil \\log_2(n) \\rceil - 3</span> elements of <span class="math">\\mathbb{G}</span>, <span class="math">2\\lceil \\log_2(n) \\rceil - 3</span> elements of <span class="math">\\mathbb{G}_T</span> and 4 elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\lceil \\log_2(n) \\rceil - 1</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">Second, we consider the amortization scenario where a prover wishes to open many homomorphisms <span class="math">f_{1}, \\ldots, f_{s}</span> on one multi-exponentiation <span class="math">P</span>, i.e., we consider a compressed <span class="math">\\Sigma</span>-protocol for the following relation</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathrm{AMORHOM}} = \\left\\{ (P, y_1, \\dots, y_s; \\mathbf{x}) : P = \\mathbf{g}^{\\mathbf{x}}, y_1 = f_1(\\mathbf{x}), \\dots, y_s = f_s(\\mathbf{x}) \\right\\}. \\tag{6}</span></div>

    <p class="text-gray-300">This scenario is reduced to the original scenario of opening one homomorphism on one commitment by means of a standard polynomial amortization trick. In the first move of the protocol, the verifier sends a random challenge <span class="math">\\rho \\in \\mathbb{Z}_q</span> to the prover, and then <span class="math">\\Pi_c</span> is executed on the instance given by <span class="math">P = \\mathbf{g}^{\\mathbf{x}}</span>, <span class="math">f_\\rho = f_1 + \\rho f_2 + \\dots + \\rho^{s-1} f_s</span> and <span class="math">y_\\rho = y_1 + \\rho y_2 + \\dots + \\rho^{s-1} y_s</span>.</p>

    <p class="text-gray-300">The core idea behind this construction is the observation that if <span class="math">\\mathbf{x}</span> satisfies <span class="math">f_\\rho(\\mathbf{x}) = y_\\rho</span> for <span class="math">s</span> distinct choices of <span class="math">\\rho</span> then <span class="math">f_i(\\mathbf{x}) = y_i</span> for all <span class="math">i \\in \\{1, \\ldots, s\\}</span>. A caveat is that when trying to extract such an <span class="math">\\mathbf{x}</span> by rewinding <span class="math">s - 1</span> times and choosing different <span class="math">\\rho</span>'s, one might potentially extract different choices of <span class="math">\\mathbf{x}</span>'s. However, since <span class="math">\\mathbf{g}^{\\mathbf{x}} = P</span> must still hold, this would lead to a non-trivial DL relation among the <span class="math">g_i</span>'s, and thus cannot happen when the prover is computationally bounded.</p>

    <p class="text-gray-300">The properties of this protocol for relation <span class="math">R_{\\mathrm{AMORHOM}}</span>, denoted by <span class="math">\\Pi_{\\mathrm{AMORHOM}}</span>, are summarized in Theorem 5. Note that the communication from prover to verifier is identical to that of protocol <span class="math">\\Pi_c</span>. However, the polynomial amortization trick degrades the soundness from unconditional to computational because of the above reason.</p>

    <p class="text-gray-300"><strong>Theorem 5 (Amortization over Many Homomorphisms).</strong> Let <span class="math">n &amp;gt; 2</span>, then <span class="math">\\Pi_{\\mathrm{AMORHOM}}</span> is a <span class="math">(2\\mu + 4)</span>-move protocol for relation <span class="math">R_{\\mathrm{AMORHOM}}</span>, where <span class="math">\\mu = \\lceil \\log_2(n) \\rceil - 2</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(s, 2, 3, 3, \\ldots, 3)</span>-special sound, under the discrete logarithm assumption in <span class="math">\\mathbb{G}</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">2\\lceil \\log_2(n) \\rceil - 3</span> elements of <span class="math">\\mathbb{G}</span>, <span class="math">2\\lceil \\log_2(n) \\rceil - 3</span> elements of <span class="math">\\mathbb{G}_T</span> and 4 elements of <span class="math">\\mathbb{Z}_q</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\lceil \\log_2(n) \\rceil</span> elements of <span class="math">\\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">In the above claim on the computational special soundness we take it as understood that <span class="math">g_1, \\ldots, g_n</span> are chosen uniformly at random in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Completeness and SHVZK follow directly from the corresponding properties of Protocol <span class="math">\\Pi_c</span>.</p>

    <p class="text-gray-300"><strong>Special Soundness:</strong> From the proof of Theorem 3 we know that for every <span class="math">\\rho</span> there exists an efficient algorithm that, from any <span class="math">(2,3,\\ldots,3)</span>-tree (depth <span class="math">\\mu + 1</span>) of accepting transcripts, extracts a witness <span class="math">\\mathbf{z}</span> such that <span class="math">\\mathbf{g}^{\\mathbf{z}} = P</span> and <span class="math">f_{\\rho}(\\mathbf{z}) = y_1 + \\rho y_2 + \\dots + \\rho^{s-1} y_s</span>.</p>

    <p class="text-gray-300">We show that there also exists an efficient algorithm that, from <span class="math">s</span> exponents <span class="math">\\mathbf{z}_1, \\ldots, \\mathbf{z}_s \\in \\mathbb{Z}_q^n</span> such that <span class="math">\\mathbf{g}^{\\mathbf{z}_i} = P</span> and <span class="math">f_{\\rho_i}(\\mathbf{z}_i) = y_1 + \\rho_i y_2 + \\dots + \\rho_i^{s-1} y_s</span> for all <span class="math">i</span> and for pairwise distinct challenges <span class="math">\\rho_i \\in \\mathbb{Z}_q</span>, extracts either a non-trivial DL-relation for the public parameters <span class="math">\\mathbf{g}</span> or a witness for relation <span class="math">R_{\\mathrm{AMORHOM}}</span>. Combining these two results shows that Protocol <span class="math">\\Pi_{\\mathrm{AMORHOM}}</span> is <span class="math">(s, 2, 3, \\ldots, 3)</span>-special sound from which knowledge soundness follows from [AC20].</p>

    <p class="text-gray-300">First suppose that there exist <span class="math">1 \\leq i, j \\leq s</span> such that <span class="math">\\mathbf{z}_i \\neq \\mathbf{z}_j</span>. Then <span class="math">\\mathbf{g}^{\\mathbf{z}_i} = P = \\mathbf{g}^{\\mathbf{z}_j}</span> gives a non-trivial DL-relation, which completes the proof for this case.</p>

    <p class="text-gray-300">Now suppose that <span class="math">\\mathbf{z}_i = \\mathbf{z}</span> for all <span class="math">i</span>. Let <span class="math">\\left(a_{i,j}\\right)_{1\\leq i,j\\leq s}</span> be the inverse of the Vandermonde matrix generated by the challenges <span class="math">\\rho_1,\\ldots ,\\rho_s</span>, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{ccc} 1 &amp;amp; \\dots &amp;amp; 1 \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\rho_1^s &amp;amp; \\dots &amp;amp; \\rho_s^s \\end{array} \\right) \\left( \\begin{array}{c} a_{1,1} &amp;amp; \\dots &amp;amp; a_{1,s} \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ a_{s,1} &amp;amp; \\dots &amp;amp; a_{s,s} \\end{array} \\right) = I_s.</span></div>

    <p class="text-gray-300">Note that this Vandermonde matrix is invertible because the challenges are pairwise distinct. Then for all <span class="math">1 \\leq i \\leq s</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">f_i(\\mathbf{z}) = a_{1,i} f_{\\rho_1}(\\mathbf{z}) + \\dots + a_{s,i} f_{\\rho_s}(\\mathbf{z}) = y_i.</span></div>

    <p class="text-gray-300">Hence <span class="math">\\mathbf{z}</span> is a witness for relation <span class="math">R_{\\mathrm{AMORHOM}}</span> which completes the proof.</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">4 Proving Partial Knowledge</p>

    <p class="text-gray-300">Here, we show our new efficient proofs for partial knowledge, i.e., for proving knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> discrete logarithms (Section 4.1), and for proving knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> commitment openings (Section 4.2). As we will see, these new proofs of partial knowledge follow quite easily by exploiting the core idea of the general construction in <em>[x10]</em> and combining it with the techniques and results from the section above. This further demonstrates the strength of combining the compression technique introduced by <em>[BCC^{+}16, BBB^{+}18]</em> with general <span class="math">\\Sigma</span>-protocol theory.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.1 Partial Knowledge of DL’s</h3>

    <p class="text-gray-300">In this section we construct a simple SHVZK proof of knowledge for proving knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> discrete logarithms. Our protocol inherits the logarithmic communication from the compressed <span class="math">\\Sigma</span>-protocol(s) from the previous section. More precisely, we give a SHVZK protocol for the following relation</p>

    <p class="text-gray-300"><span class="math">R_{\\textsc{partial}}=\\big{\\{}\\left(g,P_{1},\\ldots,P_{n}\\in\\mathbb{G},k\\in\\{1,\\ldots,n\\};S\\subset\\{1,\\ldots,n\\},\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}\\right):</span> (7) <span class="math">\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad </span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,P_{i}=g^{x_{i}}\\text{ for all }i\\in S\\big{\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that, for notational convenience, the witness <span class="math">\\mathbf{x}</span> is defined as a vector in <span class="math">\\mathbb{Z}_{q}^{n}</span> while only the <span class="math">k</span> coefficients <span class="math">(x_{i})_{i\\in S}</span> are relevant in this relation.</p>

    <p class="text-gray-300">The protocol goes as follows. First, the prover computes the unique polynomial</p>

    <p class="text-gray-300"><span class="math">p(X)=1+\\sum_{j=1}^{n-k}a_{j}X^{j}\\in\\mathbb{Z}_{q}[X]</span></p>

    <p class="text-gray-300">of degree at most <span class="math">n-k</span> such that <span class="math">p(0)=1</span> and <span class="math">p(i)=0</span> for all <span class="math">i\\notin S</span>.</p>

    <p class="text-gray-300">Second, the prover computes</p>

    <p class="text-gray-300"><span class="math">t_{i}:=p(i)x_{i}</span></p>

    <p class="text-gray-300">for <span class="math">i\\in\\{1,\\ldots,n\\}</span> (recall that <span class="math">p(i)</span> vanishes for those <span class="math">i</span> for which the prover does not know <span class="math">x_{i}</span>), and sends a Pedersen commitment <span class="math">P\\in\\mathbb{G}</span> to the vector</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(a_{1},\\ldots,a_{n-k},t_{1},\\ldots,t_{n})\\in\\mathbb{Z}_{q}^{2n-k}</span></p>

    <p class="text-gray-300">to the verifier. Here, the commitment <span class="math">P</span> is computed as <span class="math">P=\\mathbf{g}^{\\mathbf{y}}h^{\\gamma}</span> with respect to public parameters <span class="math">\\mathbf{g}=(g_{1},\\ldots,g_{2n-k})\\in\\mathbb{G}^{2n-k}</span> and <span class="math">h\\in\\mathbb{G}</span> for which no non-trivial DL-relations are known to the prover, i.e., so that the commitment is indeed binding.</p>

    <p class="text-gray-300">Finally, the prover proves to the verifier that the committed vector <span class="math">\\mathbf{y}</span> satisfies</p>

    <p class="text-gray-300"><span class="math">g^{t_{i}}=P_{i}^{p(i)}</span> (8)</p>

    <p class="text-gray-300">for all <span class="math">i\\in\\{1,\\ldots,n\\}</span>, where the exponent <span class="math">p(i)</span> on the right-hand-side term is understood as the evaluation of the affine function <span class="math">(w_{1},\\ldots,w_{n-k})\\mapsto 1+\\sum_{j=1}^{n-k}w_{j}i^{j}</span> applied to <span class="math">a_{1},\\ldots,a_{n-k}</span>. Thus, rewriting (8) as</p>

    <p class="text-gray-300"><span class="math">g^{t_{i}}P_{i}^{-\\sum_{j}a_{j}i^{j}}=P_{i}</span> (9)</p>

    <p class="text-gray-300">we obtain an expression where the left hand side is a group homomorphism <span class="math">f</span> applied to the committed committed vector <span class="math">\\mathbf{y}</span>, and thus the prover can prove one instance of (8) by means of the compressed protocol from Theorem 3; respectively, for improved efficiency, it can invoke the amortized protocol <span class="math">\\Pi_{\\textsc{amorhom}}</span> from Theorem 5 for proving that (8) holds for all <span class="math">i\\in\\{1,\\ldots,n\\}</span>.</p>

    <p class="text-gray-300">The resulting protocol, denoted <span class="math">\\Pi_{\\textsc{partial}}</span>, is summarized below in Protocol 3. We note that, in line with the amortized protocol it uses as a subroutine, it is computationally special sound, based on the assumption that the prover does not know any non-trivial DL-relations among the public parameters. The security and efficiency properties of <span class="math">\\Pi_{\\textsc{partial}}</span> are formally described in Theorem 6.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Protocol 3 SHVZK Proof of Partial Knowledge  <span class="math">\\Pi_{\\mathrm{PARTIAL}}</span>  for Relation  <span class="math">R_{\\mathrm{PARTIAL}}</span>  Proving knowledge of  <span class="math">k</span> -out-of- <span class="math">n</span>  discrete logarithms.</p>

    <p class="text-gray-300">|  PUBLIC PARAMETERS: g ∈ G2n-k, h ∈ G  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  INPUT (g, P1, ..., Pn, k; S, x)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S ⊂ {1, ..., n},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  gxi = Pi for i ∈ S  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p(X) = 1 + ∑i=1n-k aiXi s.t. |   |</p>

    <p class="text-gray-300">|  p(i) = 0 ∀i∉S |   |</p>

    <p class="text-gray-300">|  y = (a1, ..., an-k, |   |</p>

    <p class="text-gray-300">|  p(1)x1, ..., p(n)xn) |   |</p>

    <p class="text-gray-300">|  γ ←R Zq, P = g^y h^γ |   |</p>

    <p class="text-gray-300">|  Run ΠAMORHOM to prove that y satisfies  |   |</p>

    <p class="text-gray-300">|  g^{yi+n-k}P_i^- ∑j yj^i^j = Pi ∀i ∈ {1, ..., n}  |   |</p>

    <p class="text-gray-300">Theorem 6 ( <span class="math">k</span> -out-of- <span class="math">n</span>  SHVZK Proof of Partial Knowledge). Let  <span class="math">n &amp;gt; 1</span> , then  <span class="math">\\Pi_{\\mathrm{PARTIAL}}</span>  is a  <span class="math">(2\\mu + 5)</span> -move protocol for relation  <span class="math">R_{\\mathrm{PARTIAL}}</span> , where  <span class="math">\\mu = \\lceil \\log_2(2n - k + 1) \\rceil - 2</span> . It is perfectly complete, special honest-verifier zero-knowledge and computationally  <span class="math">(n, 2, 3, 3, \\ldots, 3)</span> -special sound, under the discrete logarithm assumption in  <span class="math">\\mathbb{G}</span> . Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">4\\lceil \\log_2(2n - k + 1)\\rceil -5</span>  elements of  <span class="math">\\mathbb{G}</span>  and 4 elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\lceil \\log_2(2n - k + 1) \\rceil</span>  elements of  <span class="math">\\mathbb{Z}_q</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness follows in a straightforward manner.</p>

    <p class="text-gray-300">Special Honest Verifier Zero-Knowledge follows immediately from the fact that  <span class="math">P</span>  is uniformly random and from the corresponding zero-knowledge property of  <span class="math">\\Pi_{\\mathrm{AMORHOM}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Special Soundness: The computational special soundness of  <span class="math">\\Pi_{\\mathrm{AMORHOM}}</span>  guarantees existence of an extractor that extracts, from any computationally-bounded successful prover, an opening  <span class="math">\\mathbf{y} = (a_1,\\ldots ,a_{n - k},t_1,\\ldots ,t_n)</span>  of the commitment  <span class="math">P</span>  for which (9) holds for all  <span class="math">i\\in \\{1,\\dots ,n\\}</span> , and thus, considering the corresponding polynomial  <span class="math">p(X) = 1 + \\sum_{j = 1}^{n - k}a_jX^j</span> , for which (8) holds for all  <span class="math">i\\in \\{1,\\dots ,n\\}</span> . Given the bounded degree of  <span class="math">p</span>  and the non-zero constant coefficient,  <span class="math">p(i) = 0</span>  for at most  <span class="math">n - k</span>  choices of  <span class="math">i\\in \\{1,\\dots ,n\\}</span> . Thus, setting  <span class="math">S\\coloneqq \\{i:p(i)\\neq 0\\}</span> , we have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k<span class="math"> , and for any  </span>i\\in S<span class="math">  we can set  </span>x_{i}\\coloneqq t_{i} / p(i)<span class="math">  and (8) then implies that  </span>g^{x_i} = P_i$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the previous section we constructed a protocol for proving knowledge of  <span class="math">k</span> -out-of- <span class="math">n</span>  discrete logarithms or, equivalently, a protocol for showing that a prover can open  <span class="math">k</span> -out-of- <span class="math">n</span>  Pedersen commitments to 0. This protocol can easily be adapted to accommodate, for example, the following variation of this zero-knowledge scenario.</p>

    <p class="text-gray-300">In this variation we let  <span class="math">P_{1}, \\ldots, P_{n}</span>  be Pedersen commitments, for which the prover claims to know  <span class="math">k</span> -out-of-  <span class="math">n</span>  openings, not necessarily to 0. More precisely, the prover claims to know a witness for the following relation:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} R _ {\\text {P A R T I A L C O M}} = \\left\\{\\left(g, h, P _ {1}, \\dots , P _ {n} \\in \\mathbb {G}, k \\in \\{1, \\dots , n \\}; S \\subset \\{1, \\dots , n \\}, x _ {1}, \\dots , x _ {n} \\in \\mathbb {Z} _ {q}, \\right. \\right. \\\\ \\left. \\gamma_ {1}, \\dots , \\gamma_ {n} \\in \\mathbb {Z} _ {q}\\right):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= k, P _ {i} = g ^ {x _ {i}} h ^ {\\gamma_ {i}} \\text {f o r a l l} i \\in S \\}. ^ {9} \\tag {10} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">A proof of knowledge for relation <span class="math">R_{\\textsc{partialcom}}</span> is obtained by applying the following adaptations. After defining the polynomial <span class="math">p(X)</span> as before, the prover computes</p>

    <p class="text-gray-300"><span class="math">t_{i}:=p(i)x_{i}\\in\\mathbb{Z}_{q}\\quad\\text{and}\\quad s_{i}:=p(i)\\gamma_{i}\\in\\mathbb{Z}_{q},</span></p>

    <p class="text-gray-300">for <span class="math">i\\in\\{1,\\ldots,n\\}</span> and sends a Pedersen commitment <span class="math">P\\in\\mathbb{G}</span> to the vector</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(a_{1},\\ldots,a_{n-k},t_{1},\\ldots,t_{n},s_{1},\\ldots,s_{n})\\in\\mathbb{Z}_{q}^{3n-k},</span></p>

    <p class="text-gray-300">to the verifier. Finally, by invoking Protocol <span class="math">\\Pi_{\\textsc{amorhom}}</span>, the prover shows that</p>

    <p class="text-gray-300"><span class="math">g^{t_{i}}h^{s_{i}}P_{i}^{-\\sum_{j}a_{j}i^{j}}=P_{i}</span></p>

    <p class="text-gray-300">for all <span class="math">i\\in\\{1,\\ldots,n\\}</span>. Formally, we have the following security and efficiency properties.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 7 (<span class="math">k</span>-out-of-<span class="math">n</span> SHVZK Proof of Partial Knowledge for Commitment Openings).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\textsc{partialcom}}</span> is a <span class="math">(2\\mu+5)</span>-move protocol for relation <span class="math">R_{\\textsc{partialcom}}</span>, where <span class="math">\\mu=\\lceil\\log_{2}{(3n-k+1)}\\rceil-2</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(n,2,3,3,\\ldots,3)</span>-special sound, under the discrete logarithm assumption in <span class="math">\\mathbb{G}</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">4\\lceil\\log_{2}{(3n-k+1)}\\rceil-5</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">4</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\lceil\\log_{2}{(3n-k+1)}\\rceil</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-23" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">We emphasize that <span class="math">\\Pi_{\\textsc{partialcom}}</span> is only special sound under the assumption that the prover does not know a non-trivial DL relation between the public parameters <span class="math">\\mathbf{g}\\in\\mathbb{G}^{3n-k}</span> and <span class="math">h\\in G</span> for the Pedersen commitment <span class="math">P</span> to the vector <span class="math">\\mathbf{y}</span>, i.e., it is crucial that the commitment <span class="math">P</span> is binding. By contrast, the special soundness of <span class="math">\\Pi_{\\textsc{partialcom}}</span> does not depend on a computational assumption regarding the public parameters <span class="math">g,h\\in\\mathbb{G}</span> for the Pedersen commitments <span class="math">P_{i}</span>, i.e., the commitments <span class="math">P_{i}</span> are not required to be binding for Protocol <span class="math">\\Pi_{\\textsc{partialcom}}</span> to be special sound.</p>

    <h2 id="sec-24" class="text-2xl font-bold">5 Extensions and Generalizations</h2>

    <p class="text-gray-300">Our techniques from Section 4 for proofs of partial knowledge can be extended and generalized in various directions. We discuss some examples here.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.1 Pairing Based Commitments to Reduce the Communication Complexity</h3>

    <p class="text-gray-300">We show here that by introducing a pairing and considering a pairing based extension of Pedersen’s vector commitment scheme (see below), we can incorporate a trick from <em>[BBB^{+}18]</em> to reduce the relevant constant by another factor up to <span class="math">2</span>.</p>

    <p class="text-gray-300">Recall that, rather than a general homomorphism <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span>, <em>[x1]</em> considers the special case of a linear form <span class="math">L:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}</span>, with the goal to prove that a secret vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span>, committed to as <span class="math">P=\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}</span>, satisfies <span class="math">L(\\mathbf{x})=y</span> for a publicly known <span class="math">P</span> and <span class="math">y</span>. The trick then is to include <span class="math">y</span> into the commitment by considering <span class="math">P^{\\prime}=\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}k^{y}</span> instead, and proving it to be of the claimed form using a <span class="math">\\Sigma</span>-protocol and then compressing it. The gained advantage is not that <span class="math">y</span> becomes hidden in the commitment — <span class="math">y</span> is still known, and <span class="math">P^{\\prime}</span> would actually be computed by the verifier from <span class="math">P</span> and <span class="math">y</span> — but that the public information is reduced to a single group element. In the language of our general view (Appendix A), Protocol 4 is applied to the homomorphism <span class="math">\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span>, <span class="math">\\mathbf{x}\\mapsto\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}k^{L(\\mathbf{x})}</span>, rather than to <span class="math">\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}\\times\\mathbb{Z}_{q}</span>, <span class="math">\\mathbf{x}\\mapsto(\\mathbf{g}^{\\mathbf{x}}h^{\\gamma},L(\\mathbf{x}))</span>. Thereby, in every recursion of the compression mechanism, each “cross term” consists of just one element in <span class="math">\\mathbb{G}_{T}</span> now, rather than a pair in <span class="math">\\mathbb{G}_{T}\\times\\mathbb{Z}_{q}</span>. Overall this reduces the communication costs by roughly a factor up to <span class="math">2</span>, depending on the choice of the group <span class="math">\\mathbb{G}_{T}</span> and the representation of its elements.</p>

    <p class="text-gray-300">To apply this approach to our scenario, and incorporate <span class="math">f(\\mathbf{x})\\in\\mathbb{G}_{T}</span> into the commitment, we require a compact vector commitment scheme for vectors <span class="math">(\\mathbf{x},y)\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{G}_{T}</span>, which have coefficients in both <span class="math">\\mathbb{Z}_{q}</span> and <span class="math">\\mathbb{G}_{T}</span>. Under bilinear pairing assumptions these commitment schemes exist <em>[AFG^{+}16, x11]</em>. Namely, let us assume that there exists a group <span class="math">\\mathbb{G}_{2}</span> of prime order <span class="math">q</span>, and a bilinear pairing <span class="math">e:\\mathbb{G}_{T}\\times\\mathbb{G}_{2}\\to\\mathbb{G}</span>. For public parameters <span class="math">\\mathbf{g}\\in\\mathbb{G}^{n}</span>, <span class="math">h\\in\\mathbb{G}</span> and <span class="math">R\\in\\mathbb{G}_{2}</span> sampled uniformly at random, we can define the following commitment scheme:</p>

    <p class="text-gray-300"><span class="math">\\textsc{com}^{\\prime}:\\mathbb{Z}_{q}^{n}\\times\\mathbb{G}_{T}\\times\\mathbb{Z}_{q}\\to\\mathbb{G},\\quad(\\mathbf{x},y,\\gamma)\\mapsto\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}e(y,R),</span> (11)</p>

    <p class="text-gray-300">where <span class="math">\\gamma\\in\\mathbb{Z}_{q}</span> is chosen uniformly at random to commit to an element <span class="math">(\\mathbf{x},y)\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{G}_{T}</span>. This commitment scheme is unconditionally hiding and binding under the assumption that the prover does not know a non-zero vector <span class="math">(\\mathbf{x},y,\\gamma)\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{G}_{T}\\times\\mathbb{Z}_{q}</span> such that <span class="math">\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}e(y,R)=1\\in\\mathbb{G}</span>. This assumption is implied by the double pairing (DBP) assumption, which is in turn implied by the decisional Diffie-Hellman assumption over <span class="math">\\mathbb{G}_{T}</span> <em>[AFG^{+}16, x11]</em>.</p>

    <p class="text-gray-300">A more efficient protocol for opening arbitrary homomorphisms <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span> is now obtained by replacing the Pedersen vector commitment scheme by this pairing based commitment scheme that allows the group element <span class="math">f(\\mathbf{x})</span> to be incorporated into the commitment. The resulting compressed <span class="math">\\Sigma</span>-protocol for opening homomorphisms is derived as in Section 3, but with the generic compression Protocol 4 now instantiated with the group homomorphism <span class="math">\\mathbb{Z}_{q}^{n+1}\\to\\mathbb{G}</span>, <span class="math">(\\mathbf{x},\\gamma)\\mapsto\\mathbf{g}^{\\mathbf{x}}h^{\\gamma}e(cf(\\mathbf{x}),R)</span>, for a random challenge <span class="math">c\\in\\mathbb{Z}_{q}</span>, rather than <span class="math">\\mathbb{Z}_{q}^{n+1}\\to\\mathbb{G}\\times\\mathbb{G}_{T}</span>, <span class="math">(\\mathbf{x},\\gamma)\\mapsto(\\mathbf{g}^{\\mathbf{x}}h^{\\gamma},f(\\mathbf{x}))</span>. Applying this modification to the <span class="math">k</span>-out-of-<span class="math">n</span> proof of partial knowledge (Protocol 3) results in communication costs, from prover to verifier, of exactly <span class="math">2\\left\\lceil\\log_{2}(2n-k+1)\\right\\rceil-1</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">4</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.2 Multi-Exponentiations and Vector Commitments</h3>

    <p class="text-gray-300">A straightforward generalization of Protocol <span class="math">\\Pi_{\\textsc{partial}}</span> shows that, instead of the DL problem for standard exponentiations, we can also consider multi-exponentiations. More concretely, this generalization gives a protocol for the following relation</p>

    <p class="text-gray-300"><span class="math">R^{\\prime}=\\big{\\{}\\big{(}\\mathbf{h}\\in\\mathbb{G}^{m},P_{1},\\ldots,P_{n}\\in\\mathbb{G},k\\in\\{1,\\ldots,n\\};S\\subset\\{1,\\ldots,n\\},\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{n}\\in\\mathbb{Z}_{q}^{m}\\big{)}:</span> (12)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,P_{i}=\\mathbf{h}^{\\mathbf{x}_{i}}\\text{ for all }i\\in S\\big{\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The only adaptation of protocol <span class="math">\\Pi_{\\textsc{partial}}</span> that is required is the replacement of the scalars <span class="math">x_{i}\\in\\mathbb{Z}_{q}</span> by vectors <span class="math">\\mathbf{x}_{i}\\in\\mathbb{Z}_{q}^{m}</span>. The communication complexity of the resulting protocol grows logarithmically in the dimension <span class="math">m</span> of the multi-exponentiations. In a completely analogous manner, protocol <span class="math">\\Pi_{\\textsc{partialcom}}</span> from Section 4.2 can be generalized to proving partial knowledge of Pedersen vector commitment openings.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.3 Plug and Play with Circuit Zero-Knowledge</h3>

    <p class="text-gray-300">In many practical scenarios, one wishes to prove not only partial knowledge of commitment openings, but also that the committed values satisfy some additional constraints. Typically these constraints are defined by an arithmetic circuit <span class="math">C:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}</span> and the committed values <span class="math">x_{1},\\ldots,x_{n}\\in\\mathbb{Z}_{q}</span> are claimed to satisfy <span class="math">C(x_{1},\\ldots,x_{n})=0</span>. More concretely, we consider a prover that claims to know a witness for the following relation</p>

    <p class="text-gray-300"><span class="math">R_{\\textsc{partialcirc}}=\\big{\\{}\\big{(}g,h,P_{1},\\ldots,P_{n}\\in\\mathbb{G},k\\in\\{1,\\ldots,n\\};S\\subset\\{1,\\ldots,n\\},x_{1},\\ldots,x_{n}\\in\\mathbb{Z}_{q},</span> (13)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\gamma_{1},\\ldots,\\gamma_{n}\\in\\mathbb{Z}_{q}\\big{)}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,P_{i}=g^{x_{i}}h^{\\gamma_{i}}\\text{ for all }i\\in S,C(x_{1},\\ldots,x_{n})=0\\big{\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that in this relation the prover is only committed to <span class="math">k</span>-out-of-<span class="math">n</span> scalars <span class="math">x_{i}</span>, i.e., it can choose <span class="math">n-k</span> scalars freely.</p>

    <p class="text-gray-300">To handle this extension of the partial knowledge scenario we deploy the circuit ZK techniques from <em>[x1]</em>. For these techniques to be applicable all we need to show is that we can open homomorphisms and linear forms on the same Pedersen vector commitment. In <em>[x1]</em> it is namely shown how circuit</p>

    <p class="text-gray-300">ZK protocols, for arbitrary arithmetic circuits, are derived from the functionality of opening linear forms on Pedersen vector commitments.</p>

    <p class="text-gray-300">However, for any homomorphism <span class="math">f:\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}</span> and any linear form <span class="math">L:\\mathbb{Z}_{q}^{n}\\to\\mathbb{Z}_{q}</span> it is easily seen that the following map is again a homomorphism</p>

    <p class="text-gray-300"><span class="math">(f,L):\\mathbb{Z}_{q}^{n}\\to\\mathbb{G}_{T}\\times\\mathbb{Z}_{q}\\quad\\mathbf{x}\\mapsto(f(\\mathbf{x}),L(\\mathbf{x})).</span></p>

    <p class="text-gray-300">So the functionality of Protocol <span class="math">\\Pi_{c}</span>, opening homomorphisms, trivially extends to the functionality of opening homomorphisms and linear forms on the same vector commitment.</p>

    <p class="text-gray-300">Applying this approach directly results in a protocol for relation <span class="math">R_{\\textsc{partialCirc}}</span> where the communication costs, from prover to verifier, are roughly <span class="math">6\\log_{2}(n)</span> elements. These communication costs can be reduced to roughly <span class="math">4\\log_{2}(n)</span> elements, or <span class="math">2\\log_{2}(n)</span> on a pairing based platform, by applying the techniques from Section 5.1 and <em>[x1]</em>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">Various other (natural) circuit ZK scenarios exist. For example, when the circuit <span class="math">C:\\mathbb{Z}_{q}^{k}\\to\\mathbb{Z}_{q}</span> only takes the scalars <span class="math">x_{i}</span> for <span class="math">i\\in S</span> as input. Many of these scenarios are easily dealt with by plug and play (modular design) with the techniques from <em>[x1]</em>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.4 General Access Structures</h3>

    <p class="text-gray-300">Thus far, we have restricted ourselves to provers that claim to know the solutions of some (secret) subset <span class="math">S</span>, of cardinality at least <span class="math">k</span>, of <span class="math">n</span> (public) DL problems <span class="math">P_{i}=g^{x_{i}}</span>, i.e., the secret subset <span class="math">S</span> is an element of a threshold access structure</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Gamma_{k,n}=\\{A\\subset\\{1,\\ldots,n\\}:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq k\\}\\subset 2^{\\{1,\\ldots,n\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, we describe how the protocols from Section 4 can easily be generalized to arbitrary monotone access structures <span class="math">\\Gamma\\subset 2^{\\{1,\\ldots,n\\}}</span>, i.e., to provers that claim to know the solutions of some subset of <span class="math">S\\in\\Gamma</span> of <span class="math">n</span> DL problems. Recall that <span class="math">\\Gamma</span> is called a monotone access structure if for all <span class="math">A\\in\\Gamma</span> and for all <span class="math">B\\supset A</span> it holds that <span class="math">B\\in\\Gamma</span>. The proofs of partial knowledge of <em>[x10]</em> already considered arbitrary access structures and we adapt their techniques by combining them with our compression framework.</p>

    <p class="text-gray-300">Our proofs of <span class="math">k</span>-out-of-<span class="math">n</span> partial knowledge implicitly deploy a linear secret sharing scheme (LSSS) for access structure <span class="math">\\Gamma_{k,n}^{<em>}=\\Gamma_{n-k,n}</span>. Here, <span class="math">\\Gamma^{</em>}</span> denotes the dual of access structure <span class="math">\\Gamma</span>, generally given by</p>

    <p class="text-gray-300"><span class="math">\\Gamma^{*}=\\{A\\subset\\{1,\\ldots,n\\}:A^{c}\\notin\\Gamma\\}.</span></p>

    <p class="text-gray-300">More concretely the protocols of Section 4 use Shamir’s secret sharing scheme and the polynomial <span class="math">p(X)=1+\\sum_{j=1}^{n-k}a_{j}X^{j}</span> defines a secret sharing of the field element <span class="math">1</span>.</p>

    <p class="text-gray-300">To construct a proof of partial knowledge for monotone access structure <span class="math">\\Gamma</span> we simply replace <span class="math">p(i)</span> by the <span class="math">i</span>-th share (which may consist of several field elements, depending on the expansion factor) of a linear secret sharing of <span class="math">1</span>, with the randomness chosen so that the “right” shares (i.e, those corresponding to the <span class="math">x_{i}</span>’s that the prover does not know) vanish.</p>

    <p class="text-gray-300">Note that an honest prover knows <span class="math">(x_{i})_{i\\in S}</span> for some <span class="math">S\\in\\Gamma</span>. Hence, <span class="math">S^{c}\\notin\\Gamma^{*}</span> and for this reason the appropriate secret sharing of <span class="math">1</span> exists, showing completeness of the generalized proof of partial knowledge.</p>

    <p class="text-gray-300">Special soundness follows from the following observation. Let <span class="math">A\\subset\\{1,\\ldots,n\\}</span> be the subset for which all the corresponding shares vanish. Then, by linearity of the secret sharing scheme and since the secret sharing reconstructs to <span class="math">1</span>, it follows that <span class="math">A\\notin\\Gamma^{*}</span>. Hence, <span class="math">A^{c}\\in\\Gamma</span> and special soundness follows as before.</p>

    <p class="text-gray-300">The communication complexity of the resulting protocol depends logarithmically on the size of the LSSS for <span class="math">\\Gamma^{<em>}</span>, which is given by the monotone-span-program complexity of <span class="math">\\Gamma^{</em>}</span> <em>[x30]</em> and which coincides with the monotone-span-program complexity of <span class="math">\\Gamma</span> <em>[x11]</em>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">6 Acknowledgements</h2>

    <p class="text-gray-300">Thomas Attema has been supported by EU H2020 project No 780701 (PROMETHEUS) and by the Vraaggestuurd Programma Veilige Maatschappij, supervised by the Innovation Team of the Dutch Ministry of Justice and Security. Ronald Cramer has been supported by ERC ADG project No 74079 (ALGSTRONGCRYPTO) and by the NWO Gravitation Programme (QSC).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AC20. Thomas Attema and Ronald Cramer. Compressed sigma-protocol theory and practical application to plug & play secure algorithmics. In CRYPTO (3), volume 12172 of Lecture Notes in Computer Science, pages 513–543. Springer, 2020.</li>

      <li>ACK21. Thomas Attema, Ronald Cramer, and Lisa Kohl. A compressed <span class="math">\\Sigma</span>-protocol theory for lattices. IACR Cryptol. ePrint Arch., 2021:307, 2021.</li>

      <li>AFG^{+}16. Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. Structure-preserving signatures and commitments to group elements. J. Cryptology, 29(2):363–421, 2016.</li>

      <li>BAZB20. Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, and Dan Boneh. Zether: Towards privacy in a smart contract world. In Financial Cryptography, volume 12059 of Lecture Notes in Computer Science, pages 423–443. Springer, 2020.</li>

      <li>BBB^{+}18. Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society, 2018.</li>

      <li>BCC^{+}15. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Essam Ghadafi, Jens Groth, and Christophe Petit. Short accountable ring signatures based on DDH. In ESORICS (1), volume 9326 of Lecture Notes in Computer Science, pages 243–265. Springer, 2015.</li>

      <li>BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 327–357. Springer, 2016.</li>

      <li>BdM93. Josh Cohen Benaloh and Michael de Mare. One-way accumulators: A decentralized alternative to digital sinatures (extended abstract). In EUROCRYPT, volume 765 of Lecture Notes in Computer Science, pages 274–285. Springer, 1993.</li>

      <li>BSS02. Emmanuel Bresson, Jacques Stern, and Michael Szydlo. Threshold ring signatures and applications to ad-hoc groups. In CRYPTO, volume 2442 of Lecture Notes in Computer Science, pages 465–480. Springer, 2002.</li>

      <li>Cam97. Jan Camenisch. Efficient and generalized group signatures. In EUROCRYPT, volume 1233 of Lecture Notes in Computer Science, pages 465–479. Springer, 1997.</li>

      <li>CD98. Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In CRYPTO, volume 1462 of Lecture Notes in Computer Science, pages 424–441. Springer, 1998.</li>

      <li>CDS94. Ronald Cramer, Ivan Damgård, and Berry Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In CRYPTO, volume 839 of Lecture Notes in Computer Science, pages 174–187. Springer, 1994.</li>

      <li>Cra96. Ronald Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis, CWI and University of Amsterdam, 1996.</li>

      <li>CvH91. David Chaum and Eugène van Heyst. Group signatures. In EUROCRYPT, volume 547 of Lecture Notes in Computer Science, pages 257–265. Springer, 1991.</li>

      <li>Dia20. Benjamin E. Diamond. “Many-out-of-Many” proofs with applications to anonymous Zether. IACR Cryptol. ePrint Arch., 2020:293, 2020.</li>

      <li>FS86. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986.</li>

      <li>Gál95. Anna Gál. Combinatorial methods in Boolean function complexity. PhD thesis, University of Chicago, 1995.</li>

      <li>GK15. Jens Groth and Markulf Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In EUROCRYPT (2), volume 9057 of Lecture Notes in Computer Science, pages 253–280. Springer, 2015.</li>

      <li>GMR85. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In STOC, pages 291–304. ACM, 1985.</li>

      <li>GN18. Brandon Goodell and Sarang Noether. Thring signatures and their applications to spender-ambiguous digital currencies. IACR Cryptol. ePrint Arch., 2018:774, 2018.</li>

      <li>Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT, volume 6477 of Lecture Notes in Computer Science, pages 321–340. Springer, 2010.</li>

      <li>HBHW20. Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. <em>Zcash Protocol Specication - Version 2020.1.7</em>, 2020.</li>

      <li>Jiv19. Aram Jivanyan. Lelantus: Towards confidentiality and anonymity of blockchain transactions from standard assumptions. IACR Cryptol. ePrint Arch., 2019:373, 2019.</li>

    </ul>

    <p class="text-gray-300">JM20. Aram Jivanyan and Tigran Mamikonyan. Hierarchical one-out-of-many proofs with applications to blockchain privacy and ring signatures. In AsiaJCIS, pages 74–81. IEEE, 2020. Lin03. Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology, 16(3):143–184, 2003. LMR19. Russell W. F. Lai, Giulio Malavolta, and Viktoria Ronge. Succinct arguments for bilinear group arithmetic: Practical structure-preserving cryptography. In ACM Conference on Computer and Communications Security, pages 2057–2074. ACM, 2019. Mer80. Ralph C. Merkle. Protocols for public key cryptosystems. In IEEE Symposium on Security and Privacy, pages 122–134. IEEE Computer Society, 1980. MGGR13. Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed e-cash from bitcoin. In IEEE Symposium on Security and Privacy, pages 397–411. IEEE Computer Society, 2013. RST01. Ronald L. Rivest, Adi Shamir, and Yael Tauman. How to leak a secret. In ASIACRYPT, volume 2248 of Lecture Notes in Computer Science, pages 552–565. Springer, 2001. Ser20. Serhack. Mastering Monero: The Future of Private Transactions. Independently Published, 2020. SJM91. Gustavus J. Simmons, Wen-Ai Jackson, and Keith M. Martin. The geometry of shared secret schemes. Bulletin of the Institute of Combinatorics and its Applications, 1:71–88, 1991. STY00. Tomas Sander, Amnon Ta-Shma, and Moti Yung. Blind, auditable membership proofs. In Financial Cryptography, volume 1962 of Lecture Notes in Computer Science, pages 53–71. Springer, 2000.</p>

    <h2 id="sec-31" class="text-2xl font-bold">Appendix A General View on the Compression</h2>

    <p class="text-gray-300">We consider here the natural generalization of the compression Protocol 2 to an arbitrary group homomorphism <span class="math">\\Psi:\\mathbb{H}\\to\\mathbb{G}</span> for groups <span class="math">\\mathbb{H}</span> and <span class="math">\\mathbb{G}</span> of prime exponent <span class="math">q</span> and for which <span class="math">\\mathbb{H}</span> is a direct sum <span class="math">\\mathbb{H}=\\mathbb{H}^{\\prime}\\oplus\\mathbb{H}^{\\prime}</span> of a group <span class="math">\\mathbb{H}^{\\prime}</span> with itself. Thus, any <span class="math">x\\in\\mathbb{H}</span> can be written as a tuple <span class="math">x=(x_{L},x_{R})</span> of group elements <span class="math">x_{L},x_{R}\\in\\mathbb{H}^{\\prime}</span>. By convention, we write <span class="math">\\mathbb{H}^{\\prime}</span>, and thus <span class="math">\\mathbb{H}</span>, as an additive group and <span class="math">\\mathbb{G}</span> as a multiplicative group. Protocol 4, denoted by <span class="math">\\Pi_{\\Psi}</span>, below is a proof of knowledge for the relation</p>

    <p class="text-gray-300"><span class="math">R_{\\Psi}=\\left\\{(P;x)\\in\\mathbb{G}\\times\\mathbb{H}:\\Psi(x)=P\\right\\}.</span></p>

    <p class="text-gray-300">Its properties are summarized in the following theorem. The proof is along the very same lines as the proof of Theorem 2, with obvious adjustments. We provide it here for completeness.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 8 (General Compression Mechanism).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{H}=\\mathbb{H}^{\\prime}\\oplus\\mathbb{H}^{\\prime}</span> for some group <span class="math">\\mathbb{H}^{\\prime}</span>. Then <span class="math">\\Pi_{\\Psi}</span> is a <span class="math">3</span>-move protocol for relation <span class="math">R_{\\Psi}</span>. It is perfectly complete and unconditionally <span class="math">3</span>-special sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">1</span> element of <span class="math">\\mathbb{H}^{\\prime}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows directly.</p>

    <p class="text-gray-300">Special Soundness: We show that the protocol is <span class="math">3</span>-special sound. Let <span class="math">(A,B,c_{1},z_{1})</span>, <span class="math">(A,B,c_{2},z_{2})</span> and <span class="math">(A,B,c_{3},z_{3})</span> be three accepting transcripts for distinct challenges <span class="math">c_{1},c_{2},c_{3}\\in\\mathbb{Z}_{q}</span>. Let <span class="math">a_{1},a_{2},a_{3}\\in\\mathbb{Z}_{q}</span> be such that</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}1&1&1\\\\ c_{1}&c_{2}&c_{3}\\\\ c_{1}^{2}&c_{2}^{2}&c_{3}^{2}\\end{pmatrix}\\begin{pmatrix}a_{1}\\\\ a_{2}\\\\ a_{3}\\end{pmatrix}=\\begin{pmatrix}0\\\\ 1\\\\ 0\\end{pmatrix}. \\]</p>

    <p class="text-gray-300">Note that, since the challenges are distinct, this Vandermonde matrix is invertible and a solution to this equation exists. We define <span class="math">\\bar{z}=\\sum_{i=1}^{3}a_{i}(c_{i}z_{i},z_{i})</span> for which it is easily verified that <span class="math">\\Psi(\\bar{z})=P</span>. Hence, <span class="math">\\bar{z}</span> is a witness for relation <span class="math">R_{\\Psi}</span>, which completes the proof. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Protocol 4 Generic Compression Mechanism  <span class="math">\\Pi_{\\Psi}</span>  for relation  <span class="math">R_{\\Psi}</span> .</p>

    <p class="text-gray-300">|  INPUT(P; x = (xL, xR))  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A = Ψ(0, xL), B = Ψ(xR, 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">A,B</td>

            <td class="px-3 py-2 border-b border-gray-700">c ← R Zq</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z = xL + cxR</td>

            <td class="px-3 py-2 border-b border-gray-700">z</td>

            <td class="px-3 py-2 border-b border-gray-700">Ψ(cz, z) = APcBc2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Considering the setting of Section 3 and instantiating  <span class="math">\\varPsi</span>  with  <span class="math">\\varPsi:\\mathbb{Z}_q^n\\to \\mathbb{G}\\times \\mathbb{G}_T</span> ,  <span class="math">\\mathbf{x}\\mapsto (\\mathbf{g}^{\\mathbf{x}},f(\\mathbf{x}))</span>  for the considered group homomorphism  <span class="math">f:\\mathbb{Z}_q^n\\to \\mathbb{G}_T</span> , with  <span class="math">n</span>  assumed to be even so that  <span class="math">\\mathbb{Z}_q^n = \\mathbb{Z}_q^{n / 2}\\oplus \\mathbb{Z}_q^{n / 2}</span> , we recover the relation  <span class="math">R_{f}</span>  and Protocol 2 from Section 3. Similarly, we recover the pairing-based compression protocol of Section 5.1 by instantiating  <span class="math">\\varPsi</span>  with  <span class="math">\\varPsi:\\mathbb{Z}_q^n\\to \\mathbb{G}</span> ,  <span class="math">\\mathbf{x}\\mapsto \\mathbf{g}^{\\mathbf{x}}e(f(\\mathbf{x}),R)</span> .</p>

    <p class="text-gray-300">Consider the final verification  <span class="math">\\varPsi(cz,z) \\stackrel{?}{=} AP^c B^{c^2}</span>  in Protocol 4. In line with Protocol 2 in Section 3, when we define, for an arbitrary given  <span class="math">c \\in \\mathbb{Z}_q</span> , the group homomorphism  <span class="math">\\varPsi&#x27;: \\mathbb{H}&#x27; \\to \\mathbb{G}</span> ,  <span class="math">z \\mapsto \\varPsi(cz,z)</span>  and the group element  <span class="math">P&#x27; = AP^c B^{c^2}</span> , we observe that the final verification step in Protocol 4 is to check if  <span class="math">(P,z)</span>  satisfies the relation  <span class="math">R_{\\varPsi&#x27;}</span> . Therefore, if  <span class="math">\\mathbb{H}&#x27;</span>  happens to again be a direct sum  <span class="math">\\mathbb{H}&#x27; = \\mathbb{H}&#x27;&#x27; \\oplus \\mathbb{H}&#x27;&#x27;</span>  of a group  <span class="math">\\mathbb{H}&#x27;&#x27;</span>  with itself, we can replace the last communication and verification step in Protocol 2 by an execution of Protocol 2 for the relation  <span class="math">R_{\\varPsi&#x27;}</span> . Thus, if  <span class="math">\\mathbb{H}</span>  is actually the  <span class="math">n</span> -fold direct sum of a group  <span class="math">\\mathbb{H}_{\\circ}</span>  with itself for  <span class="math">n</span>  a power of 2 (which we may assume without loss of generality), we obtain a proof of knowledge for relation  <span class="math">R_{\\varPsi}</span> , where the communication costs, from prover to verifier, are  <span class="math">2\\log(n)</span>  elements of  <span class="math">\\mathbb{G}</span>  and 1 element of  <span class="math">\\mathbb{H}_{\\circ}</span> .</p>`;
---

<BaseLayout title="Compressing Proofs of $k$-Out-Of-$n$ Partial Knowledge (2020/753)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/753
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
