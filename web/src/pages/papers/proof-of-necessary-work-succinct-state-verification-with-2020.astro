---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/190';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Proof of Necessary Work: Succinct State Verification with Fairness Guarantees';
const AUTHORS_HTML = 'Assimakis Kattis, Joseph Bonneau';

const CONTENT = `    <p class="text-gray-300">Assimakis A. Kattis New York University kattis@cs.nyu.edu Joseph Bonneau New York University jcb@cs.nyu.edu</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Blockchain-based payment systems utilize an append-only log of transactions whose correctness can be verified by any observer. In almost all of today’s implementations, verification costs grow linearly in either the number of transactions or blocks in the blockchain (often both). We propose a new distributed payment system which uses Incrementally Verifiable Computation (IVC) to enable constant-time verification. Since generating the succinct proofs needed to verify correctness is more expensive, we introduce the notion of Proof of Necessary Work (PoNW), in which proof generation is an integral part of the proof-of-work used in Nakamoto consensus, effectively producing proofs using energy that would otherwise be wasted. We implement and benchmark a prototype of our system using recent recursive SNARK-based constructions, enabling stateless “light” clients to efficiently verify the entire blockchain history in about 40 milliseconds.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Balancing throughput with decentralization is a major challenge in modern cryptocurrencies. In this work, our goal is to design a payment system supporting efficient verification of the system’s entire history by any participant without trusting any third parties. Participants can join the system at any time and need only to obtain some fixed public parameters of modest size from a trusted source (e.g. the genesis block and the system’s rules).</p>

    <p class="text-gray-300">Current systems such as Bitcoin require participants to process the entire system history to verify that the current state (the most recent block in the chain) is correct. This requirement makes joining the system prohibitive for many clients, as downloading and verifying over 300 GB of system history takes days on an ordinary laptop. In practice, most clients don’t perform independent verification and rely on a trusted third party to assert the current state of the system.</p>

    <p class="text-gray-300">We address this problem using succinct proofs of state validity. These enable clients to verify any snapshot of the system using minimal bandwidth and time, even if they have no other information except the genesis state and transaction validity rules. For any block in the system, these proofs demonstrate both that there exists a sequence of valid transactions from the genesis state <span class="math">S_{0}</span> to the current block, and that the block’s branch (the sequence of predecessor blocks) is of a claimed quality <span class="math">q</span> according to the consensus protocol. In this work we focus on aggregate proof-of-work difficulty as the measure of branch quality, which is the same as in Bitcoin.</p>

    <p class="text-gray-300">Currently, systems such as Bitcoin or Ethereum require <span class="math">O(t+h)</span> work to completely verify a branch containing <span class="math">t</span> transactions and <span class="math">h</span> blocks. We are able to achieve optimal asymptotic performance of <span class="math">O(1)</span> verification costs even for a client joining the system at an arbitrary point in its history. Our techniques cannot help a client that is separated (or eclipsed) from the genuine system by a network partition. We assume a client can reach at least one node which will provide the most recent block and a proof. The client may also communicate with arbitrarily many attacker-controlled nodes; efficient verification means the client can quickly tell which block is canonical in the system.</p>

    <p class="text-gray-300">Another major issue facing Bitcoin and related cryptocurrencies is their energy consumption. These systems employ proof-of-work-based Nakamoto consensus, which provides system security by publicly verifying energy consumption. This energy consumption, while necessary for the consensus protocol, is not used for anything else and hence is often described as wasted. We design a proof-of-work puzzle which produces correctness proofs for each block as a useful byproduct, thus recycling the expended energy to enable efficient verification. Achieving this requires carefully designing the proof-of-work to replicate the properties of Bitcoin’s non-useful puzzle. Our main technical contribution is a method to deeply embed a nonce into the proof computation process, making it suitable as a progress-free proof-of-work puzzle. We formalize this intuition by introducing the notion of <span class="math">\\epsilon</span>-amortization resistance, and propose a PoNW design based on this. Our formalization of efficient proof-tagging techniques may be of independent interest.</p>

    <p class="text-gray-300">1.1 Our Contributions</p>

    <p class="text-gray-300">(1) We design and prove the correctness and security of a protocol satisfying <em>succinct state verification</em>. This ensures negligible computational requirements for any observer to verify the current system state. Our construction rests on recent advances in Incrementally Verifiable Computation (IVC) <em>[7]</em> <em>[6]</em> using Succinct Non-Interactive ARguments of Knowledge (SNARKs) <em>[29]</em> <em>[5]</em>.</p>

    <p class="text-gray-300">(2) We propose a variant of Nakamoto consensus, which we call Proof of Necessary Work. This allows us to compute proofs of block/transaction validity as part of the consensus process, making the work performed useful.</p>

    <p class="text-gray-300">(3) We implement the proof system in (1) with the consensus protocol variant in (2) at an 80-bit security level, benchmark its performance and establish feasibility. Our system:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>produces block headers of size <span class="math">&lt;500</span> bytes for any number of transactions per block.</li>

      <li>allows stateless clients to verify a block in <span class="math">&lt;40</span>ms.</li>

      <li>achieves throughput of 50 tx/block.</li>

    </ul>

    <p class="text-gray-300"><em>Current limitations.</em> In terms of throughput and block header size, our prototype is about an order of magnitude worse than Bitcoin. Bitcoin block headers are 80 bytes and throughput is about 1,000 transactions per block. However, our system allows a stateless client to rapidly verify a block (and thus its complete history) in 40 ms with 500 bytes of data downloaded. In Bitcoin, a comparable full verification of a block requires many hours of computation time and downloading hundreds of gigabytes of data.</p>

    <p class="text-gray-300">Our approach also does not reduce the burden on full/mining nodes. As with Bitcoin, these nodes must download and track the full state of the system and process all transactions. The efficient block verification provided by our system does assist miners in quickly validating new blocks broadcast on the network, which may reduce the risk of block collisions and enable faster block frequencies.</p>

    <p class="text-gray-300">Our payment system is also slightly simpler than Bitcoin, supporting only signature-based payments by individual public keys. It does not replicate Bitcoin’s rudimentary script system nor support features such as multisig transactions. However, we do provide a commitment to state in each block (like Ethereum but unlike Bitcoin) enabling efficient proofs of a user’s current balance.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Prior Work</h2>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Light Client Verification</h3>

    <p class="text-gray-300">The idea of providing portions of the blockchain to light clients for verification began with Bitcoin <em>[28]</em>, where Simple Payment Verification (SPV) clients download only block headers and Merkle inclusion proofs for specific transactions to be convinced of their validity. While this approach forgoes downloading the whole blockchain, clients must trust that the downloaded blocks contain only valid transactions due to incentives provided to miners which discourage mining invalid blocks. This approach also still requires a linear amount of memory with respect to chain length. For Bitcoin downloading only block headers requires about 10 kB per day in bandwidth, which is reasonable for up-to-date clients but non-trivial for new clients which must download the entire chain of headers (currently about 40 MB and growing).</p>

    <p class="text-gray-300">Sublinear memory complexity in SPV clients through skip-lists was first formally analyzed in <em>[22]</em> <em>[23]</em> <em>[21]</em> by Kiayias et al., where the authors propose keeping pointers to multiple previous blocks at every step to allow for fast verification. This allows the protocol to check for high-difficulty previous blocks (or ‘superblocks’), of which verifying a logarithmic number suffices to ensure security for the whole chain. This approach, however, is only feasible in the regime of fixed difficulty and thus cannot be implemented as is in current decentralized networks.</p>

    <p class="text-gray-300">Flyclient <em>[14]</em> also guarantees logarithmic complexity for transaction and proof-of-work verification, and is secure with high probability under variable difficulty even if fractions of the network are adversarially controlled. This is achieved by using Merkle Mountain Range Commitments to achieve memory improvements, and a random block sampling protocol to ensure security. However, Flyclient still requires resources linear with respect to each new transaction, and storage requirements still grow with blockchain size.</p>

    <p class="text-gray-300">Neither the work of Kiayias et al. or Flyclient enable efficient verification of transaction validity, both rely on the same argument from Bitcoin that economic incentives discourage mining a long chain of blocks containing incorrect transactions.</p>

    <p class="text-gray-300">By contrast, while Mimblewimble <em>[30]</em> does not provide sublinear verification guarantees with respect to block header size <span class="math">h</span>, it contributes an innovative framework for transaction verification. By compressing state in a ‘UTXO set’ of <span class="math">u\\leq t</span> transactions that adaptively updates with each block, it provides asymptotically better transaction verification. In Mimblewimble, history verification is linear only in the number of currently unspent coins, not the total number of transactions. While we could theoretically adapt these techniques in our work to decrease proving costs, we choose not to given practical observations that the number of unspent coins is not much smaller than the total number of transactions. The more complex predicate to verify state in MimbleWimble would likely negate any gains in proving time from compressing some transaction history.</p>

    <p class="text-gray-300">In Table 1, we provide a comparison of the asymptotic time and memory requirements of existing SPV protocols implementing transaction and/or proof-of-work verification. Given that transaction volume and chain length both grow linearly</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Technique</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transaction Verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoW Verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Memory Requirements</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bitcoin [28]/Ethereum [12]</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(t)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(h)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(h+t)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mimblewimble [30]</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(u) = O(t)</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(h)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log4(h))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NIPoPoW [23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(t)</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(h)</td>

            <td class="px-3 py-2 border-b border-gray-700">logh·(logt + log logh)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FlyClient [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">Θ(t)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2h)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2h)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Previous Work on Light-Client Verification: Asymptotic state and proof-of-work verification times for clients verifying  <span class="math">t</span>  transactions in  <span class="math">h</span>  Blocks alongside client memory requirements.</p>

    <p class="text-gray-300">over time, ideally we can enable verification that is constant with respect to both. The only other work we are aware of with this goal is the Coda Protocol framework [1]. Coda takes a similar high-level approach as our work, encoding state transitions in a recursive proof system to asymptotically optimal verification time. Our approaches are independent and vary in a number of technical details around predicate structure, with Coda choosing a different design for transaction proof aggregation. Most importantly, the main conceptual differences lie in our choice of consensus protocol. Coda implements a proof-of-stake [25] system, which must be carefully adapted for the succinct proof setting. By contrast, we implement a proof-of-work system, which requires tackling an orthogonal set of design challenges to adapt to the succinct proof setting.</p>

    <p class="text-gray-300">The proof-of-work process in Bitcoin and most modern cryptocurrencies is based on HashCash [2] and involves solving a hard puzzle for which the difficulty can be adaptively set according to the number of participants. Hardness here is taken to mean that no adversary can compute solutions to the puzzle faster than randomly guessing. An important property of such systems is that they are memoryless, or that the probability of winning does not depend on time spent computing a solution. It is important to ensure that the proof-of-work process is fair, meaning that a miner's hashrate is directly proportional to their computational power and hence that large miners do not enjoy algorithmic efficiency gains with growth. This is necessary to ensure that the network remains decentralized; without this property there would be a mathematical incentive for miners to consolidate. Of course, there may be economic and logistic incentives for miner consolidation (e.g. reduced administrative overhead) but we consider these out-of-scope.</p>

    <p class="text-gray-300">It has long been an open challenge to design a proof-of-work puzzle that is both suitable for Nakamoto consensus and also useful for some independent purpose [8]. In addition to being memoryless, the puzzle must satisfy several other prop</p>

    <p class="text-gray-300">erties such as being generated from public parameters and allowing fine-tuned adjustment of difficulty. To date, the only candidates for useful proof-of-work puzzles are highly structured problems of questionable public utility, such as finding long Cunningham chains of related prime numbers [24] or tables of relations for solving discrete log computations [20].</p>

    <p class="text-gray-300">In this work, we identify a new approach to useful proof work in proposing that the work not solve an external problem, but for aiding in verification of the system itself. We denote this as Proof of Necessary Work and show how it can be used concurrently with the succinct blockchain architecture proposed above as a suitable proof-of-work puzzle.</p>

    <p class="text-gray-300">We first define a distributed payment system in general form and then discuss required security properties. We model the processing of a payment between Alice and Bob as a transition of some state  <span class="math">S_{i}</span>  to a new state  <span class="math">S_{i+1}</span>  that represents this change of funds in a state machine. A state machine is comprised of a set of states, their transitions, and the current system state. We can assign to each state machine a state transition function, which allows the transition from one state to another given some information as input. Moreover, we work under the assumption that this is a replicated state machine, requiring local copies of the state machine in each client in order to achieve fault tolerance.</p>

    <p class="text-gray-300">Definition 1. A replicated state machine  <span class="math">\\Sigma^n</span>  with  <span class="math">n</span>  state transitions is a tuple  <span class="math">\\Sigma^n = (S_i, \\mathbf{t}_i, z_i)_{i=1}^n</span>  of states  <span class="math">S_i \\in S</span> , sets of transactions  <span class="math">\\mathbf{t}_i \\in 2^\\mathcal{T}</span>  (where  <span class="math">\\mathcal{T}</span>  is the set of valid transactions), and witnesses  <span class="math">z_i \\in \\{0,1\\}^*</span> . We denote  <span class="math">S_n</span>  as the current state of  <span class="math">\\Sigma^n</span>  and  <span class="math">S_0</span>  as its genesis state.</p>

    <p class="text-gray-300">We define our payment system state machine as follows: we have a set of participants who share a broadcast communica</p>

    <p class="text-gray-300">tion channel, and who may join or leave the system at will. There are two types of nodes we concern ourselves with here: miners and light clients.</p>

    <p class="text-gray-300">Miners: A mining (or full) node has access to the current state <span class="math">\\mathcal{S}_{i}\\in\\mathcal{S}</span> at timestep <span class="math">i</span>, and is responsible for performing proof-of-work and verifying state transitions.</p>

    <p class="text-gray-300">Light Clients: Light clients (or end-users) can issue transactions <span class="math">t\\in\\mathcal{T}</span> and verify their inclusion, but do not need to keep mutable state.</p>

    <p class="text-gray-300">We investigate how the system transitions from <span class="math">\\mathcal{S}_{i}</span> to <span class="math">\\mathcal{S}_{i+1}</span> while retaining consensus over state. Transitions between states happen through the processing of transactions by a model-specific transition function NewState. We also require a transition validation function VerifyState that ensures the state update was done correctly. By defining the notion of <em>validity</em> between state transitions, we differentiate between legitimate and illegitimate transactions and only permit processing of the former. Moreover, we require that such tuples are also internally consistent, namely that all new states are correctly validated. These are specified below.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A tuple of efficiently computable algorithms <span class="math">(\\mathsf{VerifyState},\\mathsf{NewState})</span> is considered a <em>transition</em> tuple if the following conditions hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{VerifyState}:2^{\\mathcal{T}}\\times\\mathcal{S}\\times\\mathcal{S}\\times\\{0,1\\}^{*}\\to</span> Yes/No</li>

      <li><span class="math">\\mathsf{NewState}:2^{\\mathcal{T}}\\times\\mathcal{S}\\times\\{0,1\\}^{*}\\to\\mathcal{S}</span></li>

    </ul>

    <p class="text-gray-300">and moreover we consider such a tuple <em>consistent</em> if <span class="math">\\forall\\mathcal{S}_{i},\\mathcal{S}_{i+1}\\in\\mathcal{S},\\mathbf{t}\\in 2^{\\mathcal{T}}</span> :</p>

    <p class="text-gray-300"><span class="math">\\exists z_{i}\\text{ s.t. }\\mathsf{VerifyState}(\\mathbf{t},\\mathcal{S}_{i},\\mathcal{S}_{i+1},z_{i})=\\text{Yes}</span> <span class="math">\\iff\\mathsf{NewState}(\\mathbf{t},\\mathcal{S}_{i})=\\mathcal{S}_{i+1}.</span></p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">An RSM <span class="math">\\Sigma^{n}=(\\mathcal{S}_{i},\\mathbf{t}_{i},z_{i})_{i=1}^{n}</span> is considered <em>valid</em> with respect to a consistent transition tuple <span class="math">(\\mathsf{VerifyState},\\mathsf{NewState})</span> if <span class="math">\\mathsf{VerifyState}(\\mathbf{t}_{i},\\mathcal{S}_{i},\\mathcal{S}_{i+1},z_{i+1})=\\text{Yes}</span> or equivalently <span class="math">\\mathsf{NewState}(\\mathbf{t}_{i},\\mathcal{S}_{i})=\\mathcal{S}_{i+1}</span> for all <span class="math">i\\in[n]</span>.</p>

    <p class="text-gray-300">The determination of what is considered an allowed state transition for a given system is fully specified by the <span class="math">(\\mathsf{VerifyState},\\mathsf{NewState})</span> objects. Thus, by specifying these functions as part of the implementation, we allow our definition to encompass arbitrary types of payment systems—each based on different transition functions and notions of transaction validity. For example, the Bitcoin and Ethereum protocols both define their own transition functions between blocks (states) and each one is based on its own notion of transaction validity.</p>

    <p class="text-gray-300">We can also define the property of <em>succinct verification</em> by requiring that <span class="math">\\mathsf{VerifyState}</span> runs in restricted time and that <span class="math">z_{i}</span> needs only constant space. This is formalized below.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 4.</h6>

    <p class="text-gray-300">A valid RSM <span class="math">\\Sigma^{n}=(\\mathcal{S}_{i},\\mathbf{t}_{i},z_{i})_{i=1}^{n}</span> with respect to a consistent transition tuple <span class="math">(\\mathsf{VerifyState},\\mathsf{NewState})</span> is considered <em>succinctly verifiable</em> if <span class="math">\\forall i\\in[n]</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{i}</span> has <span class="math">\\mathcal{O}(1)</span> size,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\mathsf{VerifyState}</span> runs in time $\\mathcal{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the asymptotic bounds are over <span class="math">n</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.2 Proof Carrying Data</h3>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.2.1 Definitions</h4>

    <p class="text-gray-300">We now briefly introduce Proof Carrying Data (PCD), an efficient IVC primitive instantiated using (pre-processing) SNARKs. Consider a set of system states <span class="math">\\mathcal{S}</span> with initial state <span class="math">\\mathcal{S}_{0}\\in\\mathcal{S}</span>. We denote the system’s state transition function by <span class="math">\\mathsf{UpdateState}</span> and construct a predicate <span class="math">\\Pi_{S}</span> that evaluates to 1 on input state <span class="math">\\mathcal{S}_{i+1}</span> (or a commitment to it) if and only if there exists a valid transition from some <span class="math">\\mathcal{S}_{i}</span> to <span class="math">\\mathcal{S}_{i+1}</span>. A prover repeatedly applies state transitions on the initial state to acquire state <span class="math">\\mathcal{S}_{n}</span>.</p>

    <p class="text-gray-300">A PCD system allows a verifier that only sees (a commitment to) the last state <span class="math">\\mathcal{S}_{n}</span> and a short proof <span class="math">\\pi_{n}</span> to be convinced that <span class="math">\\mathcal{S}_{n}</span> is a valid system state, i.e. a state that can be derived from <span class="math">\\mathcal{S}_{0}</span> by applying valid state transitions for all <span class="math">i</span> in the chain. More specifically, a PCD system is comprised of the following three algorithms:</p>

    <p class="text-gray-300">Setup: <span class="math">\\mathcal{G}(\\Pi_{S},1^{\\lambda})\\to(pk,vk)</span>. Key generation takes as input a predicate <span class="math">\\Pi_{S}</span> and a security parameter <span class="math">\\lambda</span>, outputting proving and verification keys.</p>

    <p class="text-gray-300">Prover: <span class="math">\\mathcal{P}(pk,\\mathcal{S}_{i+1},\\mathcal{T},\\mathcal{S}_{i},\\pi_{i},w)\\to\\pi_{i+1}</span>. The prover takes as input the proving key <span class="math">pk</span>, state <span class="math">\\mathcal{S}_{i}</span>, a proof <span class="math">\\pi_{i}</span> that <span class="math">\\mathcal{S}_{i}</span> is a valid state and a set of transactions <span class="math">\\mathbf{t}\\in 2^{\\mathcal{T}}</span>, outputting a proof <span class="math">\\pi_{i+1}</span> that <span class="math">\\mathcal{S}_{i}\\to\\mathcal{S}_{i+1}</span> is a valid state transition.</p>

    <p class="text-gray-300">Verifier: <span class="math">\\mathcal{V}(vk,B_{i},\\pi_{i})\\to\\text{Yes/No}</span>. When given as input the verification key <span class="math">vk</span>, a proof <span class="math">\\pi_{i}</span> and a commitment <span class="math">B_{i}</span> to state <span class="math">\\mathcal{S}_{i}</span>, the verifier outputs Yes if <span class="math">\\pi_{i}</span> is a valid proof that state <span class="math">\\mathcal{S}_{i}</span> is valid, outputting No with very high probability otherwise. A more complete presentation of PCD systems and their security properties can be found in Appendix B.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Transaction Layer</h2>

    <p class="text-gray-300">Given a pair <span class="math">(\\mathsf{VerifyState},\\mathsf{NewState})</span> characterizing some RSM <span class="math">\\Sigma</span>, we can define a distributed payments system (DPS) over <span class="math">\\Sigma</span> as a tuple of algorithms that together ensure the basic functionality of payment remittance over arbitrary transaction objects. This can be thought of as the ‘minimal’ client that can support a full (verifying) node. In the following definitions, we require the use of a digital signature scheme along with proof-of-work for consensus.</p>

    <p class="text-gray-300">4.1 Preliminaries</p>

    <p class="text-gray-300">We begin with the requirement for a digital signature scheme, which end-users will use to authenticate their corresponding accounts. Its corresponding security properties are standard and formally defined in Appendix C.</p>

    <p class="text-gray-300">In order to instantiate a proof-of-work system, we are required to include (and commit to) <span class="math">q_{i}</span> and <span class="math">n_{i}</span> with every proof, where <span class="math">q_{i}</span> is the quality of state <span class="math">\\mathcal{S}_{i}</span> and <span class="math">n_{i}</span> the associated nonce. This is because these quantities are needed by miners in order to follow the longest chain and achieve consensus. In addition, we associate the monetary value <span class="math">c\\in\\mathbb{N}</span> of each account with user address values <span class="math">z\\in\\mathcal{Z}</span>, of which there can be multiple in a given state. This provides us with all the ingredients needed to define the fundamental system.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.2 Minimal Payment Semantics</h3>

    <p class="text-gray-300">We define a distributed payment system (DPS) as a tuple of algorithms necessary for minimal payment functionality. In the definitions below, we denote the supplementary information string by <span class="math">*</span>, but make no assumptions about the type of information provided. This is done to ensure that information required by an (arbitrary) transition function is encompassed by our definition.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">Given a consistent RSM <span class="math">\\Sigma</span>, a Distributed Payment System (DPS) is a tuple <span class="math">\\Delta(\\Sigma)</span> consisting of: <span class="math">\\textsf{Setup}:1^{\\lambda}\\to pp</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Security parameter <span class="math">\\lambda</span></li>

      <li>Outputs: Public parameters <span class="math">pp</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{NewCoinbase}:S\\times z_{a}\\times c\\times(pk,sk)_{a}\\times*\\to t</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subset of current state <span class="math">S\\in\\mathcal{S}_{i}</span>, <span class="math">z_{a}</span> address of sender <span class="math">a</span>, <span class="math">c</span> value transferred, public-private key pair <span class="math">(pk,sk)_{a}</span></li>

      <li>Outputs: Transaction <span class="math">t</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{NewTransaction}:</span></p>

    <p class="text-gray-300"><span class="math">S\\times z_{\\{a,b\\}}\\times c_{\\{a,b\\}}\\times(pk,sk)_{a}\\times pk_{R}\\times*\\to t</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subset of current state <span class="math">s\\in\\mathcal{S}_{i}</span>, <span class="math">z_{a,b}</span> addresses of sender/receiver, <span class="math">c_{\\{a,b\\}}</span> value transferred, public-private key pair <span class="math">(pk,sk)_{a}</span>, public key <span class="math">pk_{R}</span></li>

      <li>Outputs: Transaction <span class="math">t</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{VerifyTransaction}:t\\times S\\times*\\to\\text{Yes/No}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subset of current state <span class="math">s_{1}\\in\\mathcal{S}_{i}</span>, transaction <span class="math">t</span></li>

      <li>Outputs: Yes/No</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{NewState}:S\\times\\mathbf{t}\\times*\\to\\mathcal{S}_{i+1}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subset of current state <span class="math">S\\in\\mathcal{S}_{i}</span>, list of ordered transactions <span class="math">\\mathbf{t}\\in 2^{\\mathcal{T}}</span></li>

      <li>Outputs: State <span class="math">\\mathcal{S}_{i+1}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{VerifyState}:\\mathbf{t}\\times S_{1}\\times S_{2}\\times*\\to\\text{Yes/No}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subsets of current and next state <span class="math">S_{1}\\in\\mathcal{S}_{i},S_{2}\\in\\mathcal{S}_{i+1}</span>, list of ordered transactions <span class="math">\\mathbf{t}\\in 2^{\\mathcal{T}}</span></li>

      <li>Outputs: Yes/No</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{CreateAddress}:pp_{S}\\to(pk,sk)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Public parameters <span class="math">pp_{S}</span></li>

      <li>Outputs: New public/private keys <span class="math">pk,sk\\in\\{0,1\\}^{*}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{GetBalance}:S\\times pk\\times*\\to c</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subset of current state <span class="math">S\\in\\mathcal{S}_{i}</span>, <span class="math">pk</span> corresponding to a CreateAddress output</li>

      <li>Outputs: Balance <span class="math">c</span> corresponding to <span class="math">pk</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\textsf{GetQuality}:S\\to q</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Subset of current state <span class="math">S\\in\\mathcal{S}_{i}</span></li>

      <li>Outputs: Quality <span class="math">q</span> of state <span class="math">\\mathcal{S}_{i}</span></li>

    </ul>

    <p class="text-gray-300">In terms of security, the system needs to provide both completeness and correctness guarantees. This requires that the protocol should guarantee that state transitions considered correct by VerifyState will not be rejected by compliant nodes. Similarly, satisfying correctness requires that transactions and state transitions that are invalid should not be accepted by compliant nodes. These definitions are constructed in the usual way, and we defer their formal specification to Appendix F.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.3 Compatibility with Existing Protocols</h3>

    <p class="text-gray-300">Our model can easily be adapted to describe existing blockchain-based payment systems. We illustrate this explicitly for Bitcoin to provide intuition for what the essential components of a distributed payments system are.</p>

    <p class="text-gray-300">Bitcoin: The Bitcoin protocol is a UTXO-based payment clearing system, for which a valid block update includes a set of valid ordered transactions and specific block header information. The components of the RSM are illustrated below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Transactions: The UTXOs in each block.</li>

      <li>State: The current block.</li>

      <li>Witness: Not required here, since validation happens by inspection of the ledger.</li>

      <li>NewState: Generation of a new block.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VerifyState: Validity of a block transition requires:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifying all UTXO Merkle paths.</li>

      <li>Verifying that the header is well formed.</li>

      <li>Checking the nonce satisfies proof-of-work.</li>

      <li>Ensuring all transactions are valid.</li>

    </ul>

    <p class="text-gray-300">A similar treatment would allow us to characterize Ethereum using the same basic components. This paradigm also makes obvious that, in order to verify the state of the <em>whole</em> system without any external information, we would need to iteratively validate each state transition. We use the witness <span class="math">z_{i}</span> to provide ‘hints’ to the validation function, which we will demonstrate later allows us to construct protocols tailored for much more efficient state verification.</p>

    <h2 id="sec-18" class="text-2xl font-bold">5 A DPS Designed for Succinct Verification</h2>

    <p class="text-gray-300">Here we demonstrate a specific instantiation of a DPS for which we define a transition function tailored to fast state verification by stateless clients. To achieve this, we leverage the capabilities of IVC systems and construct a succinct proof of state validity to represent each state transition. Since we will be basing our implementation of the proofs on SNARKs, we design the transition function so as to minimize SNARK proof sizes. This is critical for efficiency and establishing feasibility.</p>

    <p class="text-gray-300">Our system uses Nakamoto consensus, updating the difficulty <span class="math">d</span> of solving a given puzzle according to block timestamps. Compliant miners and light clients follow the longest chain of state transitions, assigning a (monotonically increasing) score <span class="math">q_{i}</span> to each new block. The chain with the highest score is then considered the valid chain. The system uses proof-of-work, requiring that the hash of the current block be less than the mining difficulty <span class="math">d</span>, exactly like in Bitcoin.</p>

    <p class="text-gray-300">Each participant in our system has a public and secret key that they generate when they first join the network. The participants use these keys to digitally sign transactions and verify other participants’ signatures. The state <span class="math">\\mathcal{S}_{i}</span> contains the distribution of money between the participants (stored as a tree), state quality and a nonce corresponding to the most recent proof-of-work. We also distinguish between the <span class="math">i</span>-th block, which in our case will be represented by a proof <span class="math">\\pi_{i}</span> that the <span class="math">i</span>-th state transition is valid along with the set of transactions <span class="math">\\mathbf{t}_{i}</span> corresponding to the transition, and <em>commitments</em> to state, which we denote by <span class="math">B_{i}</span> and use for client verification. We require an account-based system (unlike Bitcoin) and keep track of state with an ‘Account Tree’ of all account-value pairs. These building blocks are:</p>

    <p class="text-gray-300">Account Tree: We use a Merkle tree construction with a compressible Collision Resistant (CRT) hash function <span class="math">\\mathcal{H}:\\{0,1\\}^{\\mathcal{I}\\lambda}\\rightarrow\\{0,1\\}^{\\lambda}</span>. We assume a fixed size tree <span class="math">T</span> with height <span class="math">h</span> throughout.</p>

    <p class="text-gray-300">State: We denote <span class="math">S_{i}</span> the state after the <span class="math">i</span>-th update:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Account tree <span class="math">T^{i}</span> with leaves the accounts in state. Leaves are lexicographically ordered based on their address.</li>

      <li>The block number <span class="math">i</span>.</li>

      <li>The quality <span class="math">q_{i}</span>.</li>

      <li>The nonce <span class="math">n_{i}</span>.</li>

    </ol>

    <p class="text-gray-300">State Commitment: Set <span class="math">B_{i}</span> as the commitment to <span class="math">S_{i}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The root <span class="math">rt_{i}</span> of the Account tree <span class="math">T^{i}</span> in <span class="math">\\mathcal{S}_{i}</span>.</li>

      <li>The block number <span class="math">i</span>.</li>

      <li>The quality <span class="math">q_{i}</span>.</li>

      <li>The nonce <span class="math">n_{i}</span>.</li>

    </ol>

    <p class="text-gray-300">Protocol Initialization: We assume that initially all accounts in the Account tree are set to null. In every transition, the tree allows the following modifications:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Account Initialization: Set the public key to a non-null value and initialize the balance and the nonce. An account with a non-null public key is considered initialized. An account can be initialized only once. Uninitialized accounts have null public key.</li>

      <li>Balance Update: Modify the balance <span class="math">bal</span> of an account, ensuring that money is conserved.</li>

      <li>Nonce Update: Modify the nonce <span class="math">n</span> of an account to that of the current block.</li>

    </ol>

    <p class="text-gray-300">We denote the initial state of the system (or “genesis state”) by <span class="math">\\mathcal{S}_{0}</span>; this is agreed to by an out-of-band process. For example, a system might start with all addresses having a balance of zero or it might pre-populate some accounts with non-zero balance (colloquially known as “pre-mining”). Note that in the initial state, the Account tree is a full tree and contains one leaf/account for every address that can exist in the state. The genesis state can contain initialized and uninitialized accounts.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.1 Basic Data Structures</h3>

    <p class="text-gray-300">We define the basic data structures of our system below. We require the standard assumption of a public-key signature scheme, and take all signatures below as over some common field <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Account: An account <span class="math">\\mathbf{a}</span> is a tuple <span class="math">(\\text{addr},\\text{PK},bal,n)</span> where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>addr is the address of <span class="math">\\mathbf{a}</span>.</li>

      <li>PK is the public key of <span class="math">\\mathbf{a}</span>.</li>

      <li><span class="math">bal</span> the balance of the account (non-negative).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">n</span> the nonce of the block that contains the transaction that last modified <span class="math">\\mathbf{a}</span>.</li>

    </ol>

    <p class="text-gray-300">Address & Public Key: Each PK does not have to have a unique address. Decoupling user keys from account addresses is done to represent each account in the tree with minimal size requirements (and regardless of public key sizes) within the proof.</p>

    <p class="text-gray-300">Transactions: There are two types of transactions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coinbase:</li>

    </ol>

    <p class="text-gray-300"><span class="math">t_{c}=(\\text{addr},v,\\text{PK},\\sigma)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>addr: the address of the recipient</li>

      <li><span class="math">v</span>: the value it receives</li>

      <li><span class="math">\\sigma</span>: The digital signature of the transaction</li>

      <li>Standard</li>

    </ol>

    <p class="text-gray-300"><span class="math">t=(\\text{addr}_{s},\\text{addr}_{r},v,f,\\text{PK},\\sigma,\\text{PK}_{R})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>addr_{s},addr_{r}: the addresses of the sender and the receiver respectively</li>

      <li><span class="math">v</span> the value to be transferred from the sender to the receiver (it is a positive integer)</li>

      <li><span class="math">f</span>: Total mining fee provided</li>

      <li><span class="math">\\sigma</span>: The signature of the transaction</li>

      <li>PK: the public key that validates <span class="math">\\sigma</span></li>

      <li>PK_{R}: the public key of the recipient</li>

    </ol>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.2 State Transition Semantics</h3>

    <p class="text-gray-300">Below we define our semantics used for transaction and state transition validity. A full specification of the rest of the algorithms can be found in A.</p>

    <p class="text-gray-300">Verifying Transactions: <span class="math">\\textsc{VerifyTx}(t,T^{i})\\rightarrow\\text{Yes/No}</span> takes as input a transaction <span class="math">t</span> and an Account tree <span class="math">T^{i}</span>, outputting Yes/No (1 or 0). A transaction is considered valid if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sender and receiver are legitimate accounts in <span class="math">T^{i}</span>.</li>

      <li>Amount transferred is not more than sender’s balance.</li>

      <li>Signature authenticates over the sender’s public key.</li>

      <li>Sender and receiver accounts in the Account tree are updated correctly.</li>

      <li>Recipient’s public key matches that stored in the Account tree, or the address is uninitialized.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Updating System State: <span class="math">\\textsc{UpdateState}(\\mathcal{S}_{i},\\mathbf{t},n)\\rightarrow\\mathcal{S}_{i+1}</span> is a procedure that takes as input a state <span class="math">\\mathcal{S}_{i}</span>, am ordered set of transactions <span class="math">\\mathbf{t}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N<span class="math"> and a nonce </span>n<span class="math">. It outputs the next state </span>\\mathcal{S}_{i+1}<span class="math"> and a witness </span>w$ of objects proving the update was done correctly. A system transition is considered valid if:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All transactions in <span class="math">\\mathcal{T}</span> are valid.</li>

      <li>The previous state has performed proof-of-work.</li>

      <li>Only last transaction <span class="math">t_{N}</span> is of coinbase type.</li>

      <li>Each transaction builds on top of a previous transaction, except the first which builds on the previous root.</li>

    </ol>

    <p class="text-gray-300">All of this is registered in <span class="math">\\mathcal{S}_{i+1}</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.3 State Transition as an NP statement</h3>

    <p class="text-gray-300">In order to instantiate a DPS that is capable of verifying a given state transition function, we encode the transition function ValidState as a compliance predicate <span class="math">\\Pi_{S}</span>. With every state transition, we include a proof that the transition was <span class="math">\\Pi_{S}</span> compliant. This is done by verifying the transition from the previous state and producing an attesting witness <span class="math">w</span> in the process. In this context, we are interested in verifying the transition between two states of the Account tree by processing transactions between them into the system. This is achieved by tracking changes to the root <span class="math">rt_{i}</span> of the Account tree after the input of each transaction.</p>

    <p class="text-gray-300">We capture all requirements for transaction, proof-of-work and state validity in an NP language BLOCK-V that only accepts commitments of the form <span class="math">B_{i}=(rt^{i},q_{i},i,n_{i})</span> that build ‘correctly’ on top of a previous state. At a high level, the elements of this language are state commitments that, given some previous state’s root, have only processed valid transactions.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">5.3.1 Compliance Predicate</h4>

    <p class="text-gray-300">Given input <span class="math">B_{i+1}=(rt_{i+1},i+1,q_{i+1},n_{i+1})</span>, the compliance predicate <span class="math">\\Pi_{\\mathcal{S}}</span> evaluates to 1 if and only if all of the following are satisfied:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a previous state <span class="math">\\mathcal{S}_{i}</span> satisfying proof-of-work with nonce <span class="math">n_{i}</span> and quality <span class="math">q_{i}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. There exists a tuple of ordered transactions <span class="math">\\mathbf{t}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N<span class="math">. These transactions need to be sequentially valid with respect to </span>\\mathcal{S}_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textsc{UpdateState}(\\mathcal{S}_{i},\\mathcal{T},n_{i})=\\mathcal{S}_{i+1}</span>.</li>

    </ol>

    <p class="text-gray-300">We use the compliance predicate <span class="math">\\Pi_{\\mathcal{S}}</span> to design a PCD system consisting of algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>, as formally defined in Appendix B, where each message <span class="math">z_{i}</span> is a state commitment object <span class="math">B_{i}</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.4 DPS Specification</h3>

    <p class="text-gray-300">Here we define how the system transitions from <span class="math">\\mathcal{S}_{i}\\rightarrow\\mathcal{S}_{i+1}</span>. The first method generates a new state and associated proof of compliance, along with a nonce certifying that the system performed proof-of-work. When validating, we check that the new state <span class="math">\\mathcal{S}_{i+1}</span> is a valid next state for the system by</p>

    <p class="text-gray-300">being (a) <span class="math">\\Pi_{\\mathcal{S}}</span> compliant and (b) providing proof-of-work. Note that the validation only requires the root of the Account tree corresponding to <span class="math">\\mathcal{S}_{i}</span>, thus making it efficient enough for light clients.</p>

    <p class="text-gray-300">Algorithm 1 NewState 0: <span class="math">pp,\\mathcal{T},\\mathcal{S}_{i},\\pi_{i}</span> 0: <span class="math">\\mathcal{S}_{i+1},\\pi_{i+1}</span> 1:procedure NewState(<span class="math">pp,\\mathcal{T},\\mathcal{S}_{i},\\pi_{i}</span>) 2: if <span class="math">\\mathcal{V}(vk,\\mathcal{S}_{i},\\pi_{i})=0</span> then return <span class="math">0</span> 3: while <span class="math">\\mathcal{H}(\\pi_{i+1})&gt;d</span> do 4: Pick <span class="math">n_{i+1}</span> uniformly at random 5: <span class="math">(\\mathcal{S}_{i+1},w)\\leftarrow\\textsc{UpdateState}(\\mathcal{S}_{i},\\mathcal{T},n_{i+1})</span> 6: <span class="math">\\pi_{i+1}\\leftarrow\\mathcal{P}(pk,\\mathcal{S}_{i+1},\\mathcal{T},\\mathcal{S}_{i},\\pi_{i},w)</span> 7: return <span class="math">(\\mathcal{S}_{i+1},\\pi_{i+1})</span></p>

    <p class="text-gray-300">When updating the state of the system, each participating miner receives <span class="math">\\pi_{i+1}</span> and <span class="math">\\mathbf{t}_{i+1}</span>. This allows them to update their own state to <span class="math">\\mathcal{S}_{i+1}</span> and begin mining again. We formalize the security of our DPS scheme in the sense of the definitions presented in Appendix F.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">The protocol as defined in Section 5.4, is complete (c.f. Definition 8) and correct (c.f. Definition 9).</p>

    <p class="text-gray-300">In formalizing the correctness of our system, we rely on a random oracle similar to the construction in <em>[31]</em>, but extended to arbitrary transition functions. Proofs for the above are provided in Appendix G.</p>

    <h2 id="sec-25" class="text-2xl font-bold">6 Proof of Necessary Work</h2>

    <p class="text-gray-300">To allow proof generation to serve as a proof-of-work puzzle, we require (a) a proof <span class="math">\\pi_{i}</span> whose generation algorithm <span class="math">\\mathcal{P}</span> is moderately difficult to compute and (b) a proof-of-work puzzle <span class="math">\\mathsf{P}_{V}^{\\mathcal{H},d}</span> that requires the miner to fully recompute <span class="math">\\mathcal{P}</span> to test a potential solution. The second property is necessary for the puzzle to be progress-free for fairness to miners of differing size. Indeed, if generating unique proofs <span class="math">\\pi_{i}</span> based on randomly sampled nonces <span class="math">n_{i}</span> is sufficiently ‘hard’, then using <span class="math">\\mathsf{P}_{V}^{\\mathcal{H},d}</span> instead of a generic puzzle (such as computing the double SHA256 digest in Bitcoin) would allow us to not only perform proof-of-work with the same theoretical guarantees, but also compute a valid proof <span class="math">\\pi_{i}</span> in the process.</p>

    <p class="text-gray-300">We do not formally analyze any consensus properties, since our goal is not to design a new consensus protocol but to retain that used by Bitcoin (and similar systems) and inherit its properties. However, we would like the work done to be useful by producing proofs of each block’s validity. We introduce the notion of performing proof-of-work by proving the validity system state, which we denote as Proof of Necessary Work (PoNW).</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">6.1 Definitions</h3>

    <p class="text-gray-300">We formalize this definition below, and provide the relevant security model.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 6 (Verification Puzzle).</h6>

    <p class="text-gray-300">Given a collision-resistant pseudorandom function <span class="math">\\mathcal{H}</span> and a proof <span class="math">\\pi_{i}\\in\\mathcal{Z}</span> in some RSM with transition tuple (NewState, VerifyState), we define the <em>verification puzzle</em> <span class="math">\\mathsf{P}_{V}^{\\mathcal{H},d}:\\mathcal{S}\\times\\mathcal{S}\\times\\mathcal{Z}\\rightarrow\\{0,1\\}</span> with difficulty <span class="math">d</span> as the solution to the following function:</p>

    <p class="text-gray-300">\\[ \\mathsf{P}_{V}^{\\mathcal{H}}(\\mathcal{S}_{i},\\mathcal{S}_{i+1},\\pi_{i})=\\mathbf{1}\\left[\\begin{array}[]{c}\\text{VerifyState}(\\mathcal{S}_{i},\\mathcal{S}_{i+1},\\pi_{i})=1\\\\ \\mathcal{H}(\\pi_{i})<d\\end{array}\\right], \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{1}[\\cdot]</span> is the indicator function.</p>

    <p class="text-gray-300">By having access to a proof generating algorithm <span class="math">\\mathcal{P}(\\mathbf{t},\\mathcal{S}_{i},\\mathcal{S}_{i+1},n)\\rightarrow\\pi_{i+1}</span> that generates unique (yet valid) <span class="math">\\pi_{i}</span> for each <span class="math">n_{i}</span>, we can generate <span class="math">\\pi_{i+1}</span> for <span class="math">\\mathcal{S}_{i+1}=\\textsf{NewState}(\\mathbf{t},\\mathcal{S}_{i},\\pi_{i})</span> using a uniformly random sample <span class="math">n</span> until the puzzle condition is satisfied:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_{V}^{\\mathcal{H}}(\\mathcal{S}_{i},\\mathcal{S}_{i+1},\\mathcal{P}(\\mathbf{t},\\mathcal{S}_{i},\\mathcal{S}_{i+1},n))=1.</span></p>

    <p class="text-gray-300">Then <span class="math">\\pi_{i}</span> suffices for public verification that proof-of-work has been performed. This is because our prover will always fail with constant probability (when <span class="math">\\mathcal{H}(\\pi_{i})\\geq d</span>), so iteratively sampling new proofs (by sampling new <span class="math">n</span>) until a valid one is found can be shown, under the assumption that <span class="math">\\mathcal{P}</span> is the most efficient way to find such an <span class="math">n</span>, to be a memoryless exponential process and hence <em>fair</em>. Note that, by construction, we also guarantee that <span class="math">\\pi_{i+1}</span> is a valid witness for the RSM.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">6.1.1 An Initial Approach</h4>

    <p class="text-gray-300">A natural thought would be to require the generation of proofs until <span class="math">\\mathcal{H}(\\pi)&lt;d</span>, as is proposed in the previous section. In the case that the proof is unique to the state and witness input, we can ensure that by adding a nonce in the input we will always get a different hash for <span class="math">\\pi</span>. This requires that our prover satisfy <em>unique simulation extractability</em>, which can be shown to hold for our design choices.</p>

    <p class="text-gray-300">However, this can lead to unfair outcomes. When computing <span class="math">\\pi</span>, the adversary can retain the parts of <span class="math">\\pi</span> that don’t change between nonces and therefore substantially decrease proof generation time with respect to other provers - violating the scheme’s amortization resistance. This means the process is not memoryless, and so the fairness of the system is compromised. We thus require a mechanism through which to prevent this decomposition attack.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">6.1.2 Amortization Resistance</h4>

    <p class="text-gray-300">Just like in Nakamoto consensus, our puzzle needs to satisfy the property that solutions are equally hard to test even after testing an arbitrary number of previous solutions. In other</p>

    <p class="text-gray-300">words, a miner should not be able to amortize costs while testing multiple potential solutions. We define this property more formally below. We model PoNW as a function <span class="math">f^{\\mathcal{O}}</span> with limited access to some oracle <span class="math">\\mathcal{O}</span> that performs a hard computation in some encoding of a given group <span class="math">\\mathbb{G}</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 7 (<span class="math">\\varepsilon</span>-Amortization Resistance).</h6>

    <p class="text-gray-300">For <span class="math">\\ell\\in\\mathbb{N}</span> with <span class="math">\\ell=\\mathrm{poly}(\\lambda)</span> and inputs of length <span class="math">\\lambda</span>, a function <span class="math">f^{\\mathcal{O}}=\\{f_{n}^{\\mathcal{O}}\\}_{n\\in S}</span> with <span class="math">S=S(\\lambda)</span> is considered <span class="math">\\varepsilon</span>-hard if for all adversaries <span class="math">\\mathcal{A}</span> performing less than <span class="math">(1-\\varepsilon)N\\ell</span> queries to the oracle <span class="math">\\mathcal{O}</span>, where <span class="math">N</span> number of queries required for one evaluation of <span class="math">f_{n}^{\\mathcal{O}}</span>, the following is negligible in <span class="math">\\lambda</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr_{n\\leftarrow S^{\\ell}}\\left[\\begin{array}[]{c}\\forall i\\in[\\ell],\\pi_{i}=f_{n_{i}}^{\\mathcal{O}}(a_{i})\\end{array}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\{n_{i}\\}_{i=1}^{\\ell}\\leftarrow n\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\{\\pi_{i},a_{i}\\}_{i=1}^{\\ell}\\leftarrow\\mathcal{A}(1^{\\lambda},n)\\end{array}\\right.\\right. \\] (1)</p>

    <p class="text-gray-300">This definition captures the fact that computing multiple proofs does not come with marginal gains: indeed, provers cannot use computational advantage to batch process proofs and achieve non-negligible performance improvements. By prohibiting large miners from achieving returns-to-scale, this property is crucial in ensuring fairness. With the above objectives in mind, we now look at how to adapt our implementation to realize such a system.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">6.1.3 Prover Computational Costs</h4>

    <p class="text-gray-300">Before we look at designing an amortization-resistant PoNW system, we summarize the computationally expensive components of proof generation in Quadratic Arithmetic Program (QAP) SNARK provers such as <em>[29]</em>. For a proof with <span class="math">N</span> variables <span class="math">a\\in\\mathbb{F}^{N}</span> and <span class="math">n</span> constraints, the prover <span class="math">\\mathcal{P}</span> needs to compute the following (simplified) steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Update inputs and witnesses to <span class="math">a</span>.</li>

      <li>Compute exponentiation <span class="math">a_{i}\\rightarrow g_{i}^{a_{i}},\\forall i\\in[N]</span>, where <span class="math">g_{i}</span> the corresponding element from the proving key.</li>

    </ol>

    <p class="text-gray-300">Although asymptotically the exponentiations are the bottleneck as the security parameter grows, for lower regimes and large predicate sizes the polynomial computations dominate, taking time <span class="math">O(n\\log n)</span> where <span class="math">n</span> the number of constraints. Since updating variable assignments is orders-of-magnitude faster than the other two steps, for each new nonce a prover would need to be forced to recompute (almost) all modular exponentiations in order to achieve amortization resistance.</p>

    <p class="text-gray-300">We thus want to ensure that all variables in the proof are sufficiently altered by any change in the nonce or transactions being verified. This is done to make all variables in the proof change unpredictably with every new attempt at satisfying difficulty. Since updating variable assignments is asymptotically negligible in the other two steps and since all subsequent proof computations are functions of the variable assignments, by uniquely altering all input variables in the proof as a function of the nonce we can hope that amortization resistance is satisfied.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.2 A Fair and Efficient Construction</h3>

    <p class="text-gray-300">We modify the DPS predicate <span class="math">\\Pi</span> to ensure that most of the proof variables change unpredictably with modifications of the nonce or state. This gives us amortization resistance in exchange for increasing the number of variables and constraints in our predicate. The performance overhead originates from the need to commit to state and ‘mask’ the computation, which can be expensive for large predicates.</p>

    <p class="text-gray-300">The naive approach would be to isolate each of the different circuits in the system and show that they can be modified to change unpredictably based on some seed. The design challenge here is how to make this happen while conserving the proof’s correctness guarantees. For this, we ideally want to leverage a property specific to our predicate in order to ‘mask’ the computations. This would allow us to treat the proving system as a ‘black box’. We show how we can leverage the Pedersen hash function to transform our predicate <span class="math">\\Pi</span> to an amortization-resistant version.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first outline the requirement for commitment to state. Given some nonce <span class="math">n</span>, the prover might only change a part of the input in order to (re)check difficulty. This is an issue if the same nonce can be used with many inputs (in our case, transactions), as an adversarial prover would compute a proof and then only switch out a single transaction (or bit!), rechecking difficulty with no expensive recomputation. This means that we need to define a seed parameter $\\rho=\\mathsf{PRF}(n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{state})<span class="math"> that commits to state. For our DPS, we would need to commit to all transactions in the block, ensuring that a change to one transaction would lead to a different valid </span>\\rho<span class="math">. </span>\\mathsf{PRF}<span class="math"> here denotes a pseudorandom function, meaning that </span>\\rho<span class="math"> is semantically secure. This comes with the additional cost of verifying correct computation for one instance of </span>\\mathsf{PRF}<span class="math">. However, this can be large if we exploit no information about the underlying predicate, since the </span>\\mathsf{PRF}$ would (in the worst case) have to commit to every variable in the original predicate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fortunately, for our choice of predicate the input to <span class="math">\\mathsf{PRF}</span> need not be too large: indeed, in our DPS one only needs to commit to the two addresses involved and the amounts transferred for each transaction, and not to the public keys or signatures (assuming non-malleability) which can all be substantially larger. This is because the two addresses along with the values transferred fully specify the state transition, and thus changing any other parts of any transaction would violate what miners have stored for state. Even better, we can use <span class="math">\\rho=\\mathsf{PRF}(n,rt)</span> where <span class="math">rt</span> the root of the new state. Since this will be computed anyways as part of our protocol, we don’t actually suffer any overhead apart from having to verify the above computation. Note that this is actually constant in predicate size.</p>

    <p class="text-gray-300">We can force unique changes to the Merkle path updating the account if we require <span class="math">n</span> to be part of the leaf: since a change in the block (or nonce) would lead to a new <span class="math">n</span>, all update paths need to be recomputed if any transaction is</p>

    <p class="text-gray-300">changed. However, we also need to enforce change to the old Merkle path checking account existence. This technique is thus not ideal, since these paths do not depend on the current nonce (or state) at all, meaning that around half our variables will remain the same - giving <span class="math">\\epsilon\\approx 1/2</span>.</p>

    <p class="text-gray-300">To get around this issue, we opt for a different approach. We ‘mask’ the input variables to our hash function by interaction with <span class="math">\\rho</span> and transform the constraints of the hash function subcircuit <span class="math">C_{\\mathcal{H}}</span> into a new circuit that retains the original Proof of Knowledge (PoK) guarantees by verifying the same underlying computation. By ensuring that the inputs all change unpredictably, we hope to achieve upper bounds for amortization resistance based on the security of our <span class="math">\\mathsf{PRF}</span>.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">6.3 Quantization Effects for Slow Miners</h3>

    <p class="text-gray-300">A novel concern with our proposal when implemented with a proof-of-work consensus protocol is that checking even one proof-of-work solution can be slow (on the order of tens of seconds to minutes). When this becomes a significant fraction of the average block generation time, miners are hit with a loss of efficiency because they will be forced to discard a partially-checked puzzle solution when a block is broadcast in the middle of checking. We prove the scale of this efficiency loss in a short theorem:</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">For a miner in a proof-of-work consensus protocol that can check a single puzzle solution in time <span class="math">\\tau</span> (with the mean block arrival time normalized to 1), the miner will discard a fraction <span class="math">1-\\frac{\\tau}{e^{\\tau}-1}</span> of their work due to newly broadcast solutions.</p>

    <p class="text-gray-300">A proof of this theorem is provided in Appendix H. Note that as <span class="math">\\tau\\to 0</span> (fast puzzle checking time relative to block interval), the fraction of wasted work drops to 0. Similarly, as <span class="math">\\tau\\to\\infty</span> the fraction of wasted work approaches 1. For <span class="math">\\tau=1</span> (solutions take as long to check as the mean block interval), the fraction of wasted work is <span class="math">\\frac{e-2}{e-1}\\approx 0.42</span>, suggesting that we should aim to keep the time (even for slow miners) to get a solution significantly shorter than the mean block time.</p>

    <h2 id="sec-35" class="text-2xl font-bold">7 Implementation</h2>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">7.1 Choice of Proof System and Parameters</h3>

    <p class="text-gray-300">Since we’ll be broadcasting each proof <span class="math">\\pi_{i}</span> to the network, we would like them to be quite small (ideally <span class="math">&lt;1</span>kB). We also require that the size of <span class="math">\\pi_{i}</span> does not increase with <span class="math">i</span>, ideally staying the same size after every state transition. With these design choices in mind, we prototype our system using libsnark <em>[26]</em>, a <span class="math">\\mathbb{C}++</span> library implementing the PCD system in <em>[6]</em> using the construction from <em>[29]</em>. This is done using Succinct Non-Interactive Arguments of Knowledge (SNARKs) <em>[5]</em>, non-interactive proofs of knowledge with the additional property of succinctness: producing constant-sized proofs that can be instantly verified. We note that improved proof sizes can be obtained by using the verifier from <em>[19]</em>, which has the fastest performance and smallest proof size (consisting of 3 group elements) of all current implementations.</p>

    <p class="text-gray-300">Encoding <span class="math">\\Pi_{S}</span>: We can equivalently consider <span class="math">\\Pi_{S}</span> as an arithmetic circuit <span class="math">C_{\\Pi}</span>, evaluating to 1 on some input <span class="math">B_{i}</span> if and only if <span class="math">B_{i}\\in</span> BLOCK-V. In the implementation of <em>[6]</em>, <span class="math">C_{\\Pi}</span> is expressed in a low-level NP-complete language similar to arithmetic circuit satisfiability called Rank 1 Constraint System (R1CS) (see <em>[4]</em> for definitions). The circuit is encoded over elliptic curve elements through vectors in <span class="math">\\mathbb{F}_{p}</span>, where the number of gates increases with the size of <span class="math">\\pi_{i}</span> and the time required to generate it. By manually designing a circuit <span class="math">C_{\\Pi}</span> for our predicate, we minimize the number of gates used and provide a deployable implementation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that our system need also allow for recursive proof composition, or the capability of new proofs to check the validity of previous proofs efficiently. Since this construction depends on SNARKs over pairs of elliptic curves that form PCD-friendly cycles, we use the same pair of non-supersingular curves of prime order as <em>[6]</em>. They provide a security level of 80 bits with a field of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{298}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">7.2 Arithmetic Circuit Requirements</h3>

    <p class="text-gray-300">The vast majority of the constraints in our predicate come from verifying the existence of accounts in the tree. This requires the serial recomputation of a hash function <span class="math">\\mathcal{H}</span>, tracing the path from the given leaf to the root of the tree. To ensure that this path uniquely identifies the leaf, it is additionally required that <span class="math">\\mathcal{H}</span> be collision resistant.</p>

    <p class="text-gray-300">A tree depth of 32 for our implementation allows for 4.2 billion accounts. We compare this to 32 million unique used wallets on the Bitcoin blockchain after 10 years of operation. This requires <span class="math">32\\cdot 4=128</span> hash checks for each transaction. We use the circuit provided in libsnark to verify such proofs of inclusion and modification.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">7.2.1 Pedersen Hashes</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since it is desirable for <span class="math">\\mathcal{H}</span> to be efficiently represented with a low number of gates, we opt for using Pedersen hashes <em>[17]</em>. In verifying a Pedersen hash, we are required to compute <span class="math">\\prod_{i=1}^{D}g_{i}^{x_{i}}</span> where <span class="math">\\{x_{i}\\}_{i=1}^{D}</span> is the bit representation of the input <span class="math">x</span> and <span class="math">\\{g_{i}\\}_{i=1}^{D}</span> is a set of primitive roots for <span class="math">\\mathbb{Z}_{q}^{<em>}</span>. We encode each root as a field element and, based on the sign of each input <span class="math">x_{i}</span>, perform multiplication of an intermediate field variable <span class="math">c</span> by each <span class="math">g_{i}</span> to arrive at the digest if the corresponding <span class="math">x_{i}=1</span>. We use the same underlying group <span class="math">\\mathbb{Z}_{p}^{</em>}</span> as for the SNARK with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{298}$, which reduces in security to the discrete-logarithm problem (DLP).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We use Schnorr signatures [32] over an elliptic curve (EC), based on the hardness of DLP. This choice is motivated by our desire to minimize the size of the verifying circuit, since this has to be built inside  <span class="math">C_{\\Pi}</span> . The Schnorr verification circuit only requires two exponentiations, a hash computation, and a comparison between scalars. The same curve from the PCD construction is used, since it satisfies all security requirements and offers a security of 80bits, just like for the PCD system.</p>

    <p class="text-gray-300">Key Sizes: Schnorr signatures use elliptic curve elements as public keys, resulting in key sizes of 596 bits, or  <span class="math">298 + 1 = 299</span>  bits with point compression. Secret keys are sampled as random 298-bit strings.</p>

    <p class="text-gray-300">We now show how to randomize the computation of the Pedersen hash function. In addition to some input  <span class="math">x</span>  of length  <span class="math">n</span>  bits, our evaluation requires a pseudorandom seed  <span class="math">\\rho \\in \\{0,1\\}^n</span> . We propose a modification of Pedersen, which can be thought of as masking the underlying evaluation by using two sets of input variables:  <span class="math">\\mathcal{H}(\\rho)</span>  and  <span class="math">x_{i} \\oplus \\rho_{i}</span>  for  <span class="math">i \\in [n]</span> , where  <span class="math">\\mathcal{H}(\\cdot)</span>  the evaluation of the unaltered Pedersen function and  <span class="math">\\oplus</span>  the bit-wise XOR operation.</p>

    <p class="text-gray-300">The variable  <span class="math">h = \\mathcal{H}(\\rho)</span>  forms the 'starting point' of the evaluation. In the beginning, the prover will precompute some generator variables  <span class="math">\\nu_{i}</span>  for the specific instance of the problem. At every bit, the new circuit would also evaluate  <span class="math">z_{i} = x_{i} \\oplus \\rho_{i}</span> . It would then proceed normally: if  <span class="math">z_{i} = 1</span> , multiply the intermediate variable by  <span class="math">\\nu_{i}</span>  else by 1. By carefully choosing the  <span class="math">\\nu_{i}</span> , we can design the circuit in such a way that unpredictability based on the seed is retained by all intermediate variables except the output  <span class="math">y</span> , which we ensure is equal to  <span class="math">\\mathcal{H}(x)</span> .</p>

    <p class="text-gray-300">Correctness follows from the following observation: at step 0, the variable  <span class="math">c_{0} = w \\cdot \\mathcal{H}(\\rho) = w \\cdot \\prod_{i=1}^{n} g_{i}^{\\rho_{i}}</span>  is initialized as the hash of the seed. For all intermediate steps  <span class="math">j &amp;lt; n</span> , we have that  <span class="math">c_{j} = w \\cdot \\left( \\prod_{i=1}^{j} g_{i}^{x_{i}} \\right) \\cdot \\left( \\prod_{i=j+1}^{n} g_{i}^{\\rho_{i}} \\right)</span> . Finally, after the  <span class="math">n</span> -th bit has been processed the final intermediate variable  <span class="math">c_{n}</span>  is equal to the Pedersen hash of the original input  <span class="math">x</span>  multiplied by (the unpredictable)  <span class="math">w</span> . By multiplying with  <span class="math">w^{-1}</span> , we get  <span class="math">\\mathcal{H}(x)</span> . This follows easily from the fact that at every step we are performing the following operation:  <span class="math">c_{i} = c_{i-1} \\cdot (g_{i} \\cdot \\mathbf{1}[\\rho_{i} = 0] + g_{i}^{-1} \\cdot \\mathbf{1}[\\rho_{i} = 1])^{\\rho_{i} \\oplus x_{i}}</span> . It can be quickly checked that this computation ensures the previous recursive property when initialized with  <span class="math">c_{0} = w \\cdot \\mathcal{H}(\\rho)</span> . By induction, this implies that after the  <span class="math">n</span> -th bit, only the  <span class="math">w</span>  parameter and the exponentiations due to the bits of  <span class="math">x</span>  remain in the output variable i.e.  <span class="math">c_{n} = w \\cdot \\prod_{i=1}^{n} g_{i}^{x_{i}}</span> .</p>

    <p class="text-gray-300">Algorithm 2 MaskedPedersen Input:  <span class="math">x,\\rho \\in \\{0,1\\} ^n,g_0\\in \\mathbb{F}_p^n</span> Output:  <span class="math">y\\in \\mathbb{F}_p</span> 1: procedure CACHEGENERATORS(  <span class="math">\\rho ,g_0)</span> 2: Parse  <span class="math">\\{\\rho_i\\}_{i = 1}^n\\gets \\rho</span> 3: Compute  <span class="math">h\\gets \\mathcal{H}(\\rho)</span> 4: Compute  <span class="math">w\\gets \\mathcal{H}(h)</span> 5: for  <span class="math">i\\leq n</span>  do 6:  <span class="math">z_{i} = x_{i}\\oplus \\rho_{i}</span> 7: if  <span class="math">\\rho_{i} = 0</span>  then 8:  <span class="math">v_{i} = g_{i}^{0}</span> 9: if  <span class="math">\\rho_{i} = 1</span>  then 10:  <span class="math">v_{i} = (g_{i}^{0})^{-1}</span> 11: return  <span class="math">v,h,z,w</span> 12: procedure MASKEDHASH(z,h,v,w) 13: Parse  <span class="math">\\{z_i\\}_{i = 1}^n\\gets z,h,w\\in \\mathbb{F}_p</span> 14: Parse  <span class="math">\\{v_i\\}_{i = 1}^n\\gets v</span> 15: Define  <span class="math">q = \\{q_i\\}_{i = 1}^n c = \\{c_i\\}_{i = 0}^n</span> 16: Set  <span class="math">c_{0} = h\\cdot w</span> 17: for  <span class="math">i\\leq n</span>  do 18: if  <span class="math">z_{i} = 1</span>  then 19:  <span class="math">q_{i} = v_{i}</span> 20: if  <span class="math">z_{i} = 0</span>  then 21:  <span class="math">q_{i} = 1</span> 22:  <span class="math">c_{i} = c_{i - 1}\\cdot q_{i}</span> 23:  <span class="math">y = c_n\\cdot w^{-1}</span> 24: return  <span class="math">y</span></p>

    <p class="text-gray-300">The hardness of the prover's computation here reduces to exponentiating elements in the proving key  <span class="math">f_{i} \\in G</span>  by the variables  <span class="math">a_{i} \\in \\mathbb{F}_{p}</span>  in the circuit. At the end of the process a sum of the form  <span class="math">\\prod_{i=1}^{m} f_{i}^{a_{i}} = \\prod_{i=1}^{m} g^{a_{i} \\cdot b_{i}}</span>  needs to be calculated for some (randomly sampled)  <span class="math">b_{i} \\in \\mathbb{F}_{p}</span> . We observe that in all cases where we know that the variable  <span class="math">a_{i}</span>  has very small support (when, for example, it is boolean  <span class="math">a_{i} \\in \\{0,1\\}</span> ), the prover can always precompute once and use the same answers without performing exponentiations. However, this is not a problem since all miners would know what the precomputed answers are from the very beginning and can incorporate them in the proving key.</p>

    <p class="text-gray-300">Amortization resistance comes from computing the exponentiations corresponding to the intermediate variables  <span class="math">c_{i} \\in \\mathbb{F}_{p}</span> . Since their values can be any element of  <span class="math">\\mathbb{F}_p</span> , these can not be precomputed and would always require exponentiations. Indeed, an evaluation of the above scheme would require  <span class="math">n</span>  such computations, assuming that all potential values for  <span class="math">q_{i}, \\rho_{i}, x_{i}</span>  are provided in the proving key. This is because the prover would need to compute all values of  <span class="math">c_{i}</span>  (that they would not have seen before) since, by definition of the modified Pedersen function used here, they</p>

    <p class="text-gray-300">are next-bit-unpredictable and thus one computation cannot provide information on the next.</p>

    <p class="text-gray-300">Constant Hardness: Since amortization resistance depends on the number of exponentiations of ‘new’ (or unpredictable) field elements in the system, the number of times we update the intermediate variable in each Pedersen evaluation needs to be constant. To this end, we ‘double’ the size of the unpredictable seed <span class="math">\\rho</span> by creating a new seed <span class="math">\\rho^{*}</span> for which the <span class="math">2i</span>-th and <span class="math">2i+1</span>-th bits are set to <span class="math">01</span> or <span class="math">10</span> depending on the value of the <span class="math">i</span>-th bit of <span class="math">\\rho</span>. This additional transformation ensures that there is always a fixed number of <span class="math">1</span>’s in the seed and thus that a set number of unpredictable field elements exist in every update of the Pedersen function’s intermediate variables. This provides constant amortization resistance for each Pedersen function by ensuring that there is a constant number of ‘hard’ exponentiations to perform at each evaluation.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">7.4 Performance</h3>

    <p class="text-gray-300">We construct the DPS based on the above specifications and investigate its running time and memory consumption. Results are displayed in Table 2. Our benchmark machine was an Amazon Web Services (AWS) c5.12xlarge instance, with 48 vCPUs and 96GiB of RAM. The security properties of the DPS are based on the guarantee of <span class="math">\\Pi</span>-compliance provided by PCD. It is apparent that setup and proving times dominate both the running time and memory consumption in the protocol. Setup takes place once by a trusted third-party and hence is less critical for day-to-day performance of the system.</p>

    <p class="text-gray-300">The prover in this protocol would be run by the miners, or full nodes. These would be generating proof-of-work solutions repeatedly and would thus be computing proof instances for different input nonces. Thus, larger storage requirements (<span class="math">\\sim 5.42</span>GB key sizes) could be easily met by these nodes, as could the need for more parallelism and better computing power to bring down the proving rate.</p>

    <p class="text-gray-300">We can normalize the block time to achieve <span class="math">\\tau=1/6</span> in the sense of Theorem 2 for a proof including <span class="math">30</span> transactions. This gives us that a miner will discard in expectation <span class="math">8.05\\%</span> of their work for an efficiency of <span class="math">\\sim 92\\%</span> if all miners operated based on the above benchmarks. Since we are keeping block times constant at <span class="math">10</span> minutes, we note that any improvements in SNARK proof generation times will correspondingly increase system efficiency. Moreover, this does not depend on the way that the proofs are generated: distributed techniques among many participants (such as <em>[34]</em>) would also benefit efficiency through the corresponding decrease of average proof time.</p>

    <h2 id="sec-43" class="text-2xl font-bold">8 Future Research Challenges</h2>

    <p class="text-gray-300">Trusted setup Using SNARKs as a building block in our system introduces the issue of the one-time trusted setup. Like in other cryptocurrency systems built using SNARKs <em>[31]</em>, an adversary with knowledge of the secret parameters would be allowed to forge proofs and hence arbitrarily print money. One mitigating approach is to distribute the ceremony over many participants through a multiparty protocol <em>[10, 11]</em>, with the requirement that only one would have to be honest for security. This shows great potential for the construction of a system that can perform the setup procedure with sufficiently many participants that not only verify proofs, but also continually contribute randomness they (are supposed to) destroy.</p>

    <p class="text-gray-300">Recent work has sought to construct SNARK systems which require limited or no trusted setup. SONIC <em>[27]</em> uses an adaptively changing structured reference string (the proving/verification keys). More recent advances such as Marlin <em>[15]</em> and Fractal <em>[16]</em> provide structured reference strings for all predicates trustlessly, in addition to being the first such systems that can perform efficient recursive composition. They can thus implement transparent PCDs with proof sizes small enough to be relevant to our context. We believe our design can be adapted to work with these systems, though a careful examination of the amortization resistance properties will need to be conducted.</p>

    <p class="text-gray-300">Quantum resistance We use SNARKs based on elliptic-curve hardness assumptions which are not quantum-resistant. Recent work on practical instantiations of SNARK constructions based on lattice assumptions <em>[18]</em> or point-based PCPS and IOPs <em>[3]</em>, may offer an option for quantum-resistant SNARKs.</p>

    <p class="text-gray-300">Privacy We did not consider transaction privacy in this work, focusing instead on a simple distributed payment ledger closely matching the properties of Bitcoin. However, while we use SNARKs for their succinctness properties, the constructions here readily extend to provide zero-knowledge succinct arguments as well (zk-SNARKs). It should be straightforward to adapt to a zk-SNARK-based privacy-preserving transaction format (such as Zerocash <em>[31]</em>) and provide no additional overhead for chain verification. The main cost is that users must compute SNARK proofs to post transactions, imposing a heavier burden to use the system. It would also require careful thought to achieve amortization resistance when users are computing proofs of transaction validity.</p>

    <p class="text-gray-300">More complex transactions We implemented a simpler transaction model than Bitcoin’s, enabling only payments using a signature from a single public key. Our use of Schnorr signatures supports multi-stakeholder security models using standard threshold signing techniques. Bitcoin supports more complex payment scripts, enabling applications like atomic cross-chain swaps and off-chain payment channels that our system does not. Ethereum supports fully programmable smart contracts to control payment. In principle, a programmable state machine like Ethereum’s can be supported on our architecture using “universal” SNARK techniques such as TinyRAM <em>[4]</em>. Recent work on achieving privacy in smart contract platforms using SNARKs <em>[9, 13]</em> can potentially be adapted to our setting to enable a more powerful</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Tx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generator G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Avg. (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">σ (%)</td>

            <td class="px-3 py-2 border-b border-gray-700">Avg. (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">σ (%)</td>

            <td class="px-3 py-2 border-b border-gray-700">Avg. (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">σ (%)</td>

            <td class="px-3 py-2 border-b border-gray-700">pk (GB)</td>

            <td class="px-3 py-2 border-b border-gray-700">vk (kB)</td>

            <td class="px-3 py-2 border-b border-gray-700">π (B)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1100849</td>

            <td class="px-3 py-2 border-b border-gray-700">24.29</td>

            <td class="px-3 py-2 border-b border-gray-700">1.75</td>

            <td class="px-3 py-2 border-b border-gray-700">12.06</td>

            <td class="px-3 py-2 border-b border-gray-700">1.31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0387</td>

            <td class="px-3 py-2 border-b border-gray-700">0.21</td>

            <td class="px-3 py-2 border-b border-gray-700">0.31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.30</td>

            <td class="px-3 py-2 border-b border-gray-700">373</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">4611209</td>

            <td class="px-3 py-2 border-b border-gray-700">75.90</td>

            <td class="px-3 py-2 border-b border-gray-700">2.01</td>

            <td class="px-3 py-2 border-b border-gray-700">43.92</td>

            <td class="px-3 py-2 border-b border-gray-700">0.70</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0387</td>

            <td class="px-3 py-2 border-b border-gray-700">0.18</td>

            <td class="px-3 py-2 border-b border-gray-700">1.16</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">8999159</td>

            <td class="px-3 py-2 border-b border-gray-700">177.45</td>

            <td class="px-3 py-2 border-b border-gray-700">1.08</td>

            <td class="px-3 py-2 border-b border-gray-700">81.10</td>

            <td class="px-3 py-2 border-b border-gray-700">1.03</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0386</td>

            <td class="px-3 py-2 border-b border-gray-700">0.32</td>

            <td class="px-3 py-2 border-b border-gray-700">2.19</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">13387109</td>

            <td class="px-3 py-2 border-b border-gray-700">218.22</td>

            <td class="px-3 py-2 border-b border-gray-700">0.68</td>

            <td class="px-3 py-2 border-b border-gray-700">99.42</td>

            <td class="px-3 py-2 border-b border-gray-700">1.59</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0387</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

            <td class="px-3 py-2 border-b border-gray-700">3.35</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">17775059</td>

            <td class="px-3 py-2 border-b border-gray-700">300.97</td>

            <td class="px-3 py-2 border-b border-gray-700">1.65</td>

            <td class="px-3 py-2 border-b border-gray-700">156.83</td>

            <td class="px-3 py-2 border-b border-gray-700">1.46</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0387</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">4.30</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">22163009</td>

            <td class="px-3 py-2 border-b border-gray-700">347.56</td>

            <td class="px-3 py-2 border-b border-gray-700">0.49</td>

            <td class="px-3 py-2 border-b border-gray-700">196.91</td>

            <td class="px-3 py-2 border-b border-gray-700">2.15</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0387</td>

            <td class="px-3 py-2 border-b border-gray-700">0.49</td>

            <td class="px-3 py-2 border-b border-gray-700">5.42</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Prototype Times and Key Sizes for Predicates verifying different numbers of transactions: Average running times for setup  <span class="math">\\mathcal{G}</span> , prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  over 10 iterations are shown alongside proving/verification key and proof sizes.</p>

    <p class="text-gray-300">programming model with efficient verification.</p>

    <p class="text-gray-300">More complex consensus rules We adapted Bitcoin's relatively simple linear longest-chain rule. Many more complex DAG-based proposals exist which improve on Bitcoin's consensus protocols. All of these involve a different formul for computing the quality of a specific block in the chain. Our approach does not preclude the use of more complex predicates for. By setting the quality accordingly and ensuring that  <span class="math">\\pi_{i}</span>  also proves that the required stage in the protocol was executed correctly, we can ensure that any consensus protocol can be used in this way.</p>

    <p class="text-gray-300">Parallelism Our current construction uses relatively little parallelism in proof-construction. Recent advances [34] enable constructing larger proofs using many parallel workers, a model that adapts readily to cryptocurrencies which typically feature large mining pools. Exploring this is an important avenue for future work, especially given the order-of-magnitude improvements in the size of computable predicates.</p>

    <p class="text-gray-300">Hardware acceleration Just like in the context of Bitcoin mining, there is potential to achieve substantial improvements in the computation of such proofs by the usage of specialized hardware. The design of Field Programmable Gate Arrays (FPGAs) or Application Specific Integrated Circuits (ASICs) that are especially created to compute the proof corresponding to a given predicate would lead to order-of-magnitude improvements in proving time and thus substantially minimize quantization effects. Such specialized hardware, however, would be expensive to construct given the purported memory-hardness of most current SNARK designs. Moreover, such hardware would also provide a large barrier to entry for most miners due to the large upfront existing costs for its design. This would have the potential to impact the fairness of the distributed system.</p>

    <p class="text-gray-300">We present the minimal transaction semantics for a distributed payment system, alongside correctness and completeness definitions. Although our framework can be used modularly with any system transition function desired, it is fundamentally an account-based model of keeping state that uses transactions to update state (or account contents) over discrete time intervals.</p>

    <p class="text-gray-300">We could alternatively have designed a 'UTXO'-based model, but we felt that storing state in individual accounts lends itself more easily to generalization over arbitrary transition functions simply by validating the individual transactions that update state. Moreover, even though coin-based models have been historically favored in the design of privacy-focused protocols [31, 33], the expressive powers of our system are only limited by the need to verify membership of state in some NP language. Our system could be adapted to predicates can be designed for any substantially complex task, such as smart contracts.</p>

    <p class="text-gray-300">However, the design of such a system would require more efficient proof generation. While a basic money-remittance system is feasible with today's proof systems, further work is needed to deploy substantially more complex predicates. The superlinear relationship between predicate size and proof generation time means generating such proofs for more complex predicates quickly becomes prohibitive. Recent advances in lowering proof generation times in SNARKs are very promising in bridging this gap, as is recent work in distributing proof computations over multiple participants.</p>

    <p class="text-gray-300">Finally, we introduce Proof of Necessary Work, which performs computation necessary for system verification as part of the proof-of-work computation. We ensure fairness in our system by forcing the prover to unpredictably alter proof variables with each nonce, making it secure against 'churning' attacks. This process leverages the homomorphic properties of our hash function, and we believe that more general techniques to do this would be of great interest.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] O(1) labs. https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf. Accessed: 2019-04-15.</li>

      <li>[2] Adam Back et al. Hashcash-a denial of service counter-measure. 2002.</li>

      <li>[3] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptology ePrint Archive, 2018:46, 2018.</li>

      <li>[4] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. Snarks for c: Verifying program executions succinctly and in zero knowledge. In Advances in Cryptology–CRYPTO 2013, pages 90–108. Springer, 2013.</li>

      <li>[5] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive arguments for a von neumann architecture. IACR Cryptology ePrint Archive, 2013:879, 2013.</li>

      <li>[6] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge via cycles of elliptic curves. Algorithmica, 79(4):1102–1160, 2017.</li>

      <li>[7] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for snarks and proof-carrying data. In Proceedings of the forty-fifth annual ACM symposium on Theory of computing, pages 111–120. ACM, 2013.</li>

      <li>[8] Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A. Kroll, and Edward W. Felten. Research Perspectives and Challenges for Bitcoin and Cryptocurrencies. In 2015 IEEE Symposium on Security and Privacy, May 2015.</li>

      <li>[9] Sean Bowe, Alessandro Chiesa, Matthew Green, Ian Miers, Pratyush Mishra, and Howard Wu. Zexe: Enabling decentralized private computation. Cryptology ePrint Archive, Report 2018/962, 2018. https://eprint.iacr.org/2018/962.</li>

      <li>[10] Sean Bowe, Ariel Gabizon, and Matthew D Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-snark. In International Conference on Financial Cryptography and Data Security, pages 64–77. Springer, 2018.</li>

      <li>[11] Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable multi-party computation for zk-snark parameters in the random beacon model. IACR Cryptology ePrint Archive, 2017:1050, 2017.</li>

      <li>[12] Vitalik Buterin. Ethereum: A next-generation smart contract and decentralized application platform, 2014. Accessed: 2016-08-22.</li>

      <li>[13] Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, and Dan Boneh. Zether: Towards privacy in a smart contract world. Cryptology ePrint Archive, Report 2019/191, 2019. https://eprint.iacr.org/2019/191.</li>

      <li>[14] Benedikt Bünz, Lucianna Kiffer, Loi Luu, and Mahdi Zamani. Flyclient: Super-light clients for cryptocurrencies. Cryptology ePrint Archive, Report 2019/226, 2019. https://eprint.iacr.org/2019/226.</li>

      <li>[15] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zksnarks with universal and updatable srs. Cryptology ePrint Archive, Report 2019/1047, 2019. https://eprint.iacr.org/2019/1047.</li>

      <li>[16] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. Cryptology ePrint Archive, Report 2019/1076, 2019. https://eprint.iacr.org/2019/1076.</li>

      <li>[17] Ivan B Damgård, Torben P Pedersen, and Birgit Pfitzmann. On the existence of statistically hiding bit commitment schemes and fail-stop signatures. In Annual International Cryptology Conference, pages 250–265. Springer, 1993.</li>

      <li>[18] Rosario Gennaro, Michele Minelli, Anca Nitulescu, and Michele Orrù. Lattice-based zk-snarks from square span programs. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, pages 556–573. ACM, 2018.</li>

      <li>[19] Jens Groth. On the size of pairing-based non-interactive arguments. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 305–326. Springer, 2016.</li>

      <li>[20] Marcella Hastings, Nadia Heninger, and Eric Wustrow. The proof is in the pudding: Proofs of work for solving discrete logarithms. Cryptology ePrint Archive, Report 2018/939, 2018. https://eprint.iacr.org/2018/939.</li>

      <li>[21] Kostis Karantias, Aggelos Kiayias, Nikos Leonardos, and Dionysis Zindros. Compact storage of superblocks for nipopow applications. Cryptology ePrint Archive, Report 2019/1444, 2019. https://eprint.iacr.org/2019/1444.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[22] Aggelos Kiayias, Nikolaos Lamprou, and Aikaterini-Panagiota Stouka. Proofs of proofs of work with sublinear complexity. In International Conference on Financial Cryptography and Data Security, pages 61-78. Springer, 2016. [23] Aggelos Kiayias, Andrew Miller, and Dionysis Zindros. Non-interactive proofs of proof-of-work. IACR Cryptology ePrint Archive, 2017:963, 2017. [24] Sunny King. Primecoin: Cryptocurrency with prime number proof-of-work. July 7th, 1(6), 2013. [25] Sunny King and Scott Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. self-published paper, August, 19, 2012. [26] SCIPR Lab. libsnark: a c++ library for zksnark proofs. [27] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updateable structured reference strings. Cryptology ePrint Archive, Report 2019/099, 2019. https://eprint.iacr.org/2019/099. [28] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system," http://bitcoin.org/bitcoin.pdf. [29] Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. Cryptology ePrint Archive, Report 2013/279, 2013. https://eprint.iacr.org/2013/279. [30] Andrew Poelstra. Mimblewimble, 2016. [31] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459-474. IEEE, 2014. [32] Claus-Peter Schnorr. Efficient identification and signatures for smart cards. In Conference on the Theory and Application of Cryptology, pages 239-252. Springer, 1989. [33] Nicolas Van Saberhagen. Cryptonote v 2.0, 2013. [34] Howard Wu, Wenting Zheng, Alessandro Chiesa, Raluca Ada Popa, and Ion Stoica. {DIZK}: A distributed zero knowledge proof system. In 27th {USENIX} Security Symposium ( <span class="math">\\{\\text{USENIX}\\}</span>  Security 18), pages 675-692, 2018.</p>

    <p class="text-gray-300">Setup: This algorithm is run once by a trusted third party to initialize the parameters of the system. It takes as input security parameters  <span class="math">\\lambda</span> ,  <span class="math">\\mu</span>  and outputs public parameters  <span class="math">pp = (pk, vk, pp_{sig})</span>  where  <span class="math">pk, vk</span>  are the proving key and the verification key of the PCD system respectively and  <span class="math">pp_{sig}</span>  are the public parameters for the signature scheme.</p>

    <p class="text-gray-300">Input:  <span class="math">1^{\\lambda}, 1^{\\mu}</span></p>

    <p class="text-gray-300">Output:  <span class="math">pp</span></p>

    <p class="text-gray-300">1: procedure SETUP(1 <span class="math">\\lambda</span> , 1 <span class="math">\\mu</span> ) 2:  <span class="math">(pk, vk) \\gets \\mathcal{G}(1^{\\lambda}, \\Pi_{S})</span> 3:  <span class="math">pp_{sig} \\gets \\mathrm{SC - SETUP}(1^{\\mu})</span> 4: return  <span class="math">(pk, vk, pp_{sig})</span></p>

    <p class="text-gray-300">Creating Transactions: Algorithm 4 creates a send transaction, while the Algorithm 5 a coinbase transaction. Note that these algorithms do not provide guarantees about the validity of the transaction created.</p>

    <p class="text-gray-300">Input:  <span class="math">pp, \\mathrm{addr}_s, \\mathrm{addr}_r, v, f, \\mathrm{PK}, \\mathrm{SK}, \\mathrm{PK}_R</span></p>

    <p class="text-gray-300">Output:  <span class="math">t</span></p>

    <p class="text-gray-300">1: procedure NEWTX(pp, addr  <span class="math">\\{s,r\\}</span> ,  <span class="math">v,f,\\mathrm{PK},\\mathrm{SK},\\mathrm{PK}_R)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2:  $\\sigma \\gets \\mathrm{SIGN}(\\mathrm{SK},\\mathrm{addr}_s\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{addr}_r\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{addr}_s.n)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3: return (addrs, addrr, vf, PK, σ, PKR)</p>

    <p class="text-gray-300">Input:  <span class="math">pp, \\mathrm{addr}_r, v, \\mathrm{PK}, \\mathrm{SK}</span></p>

    <p class="text-gray-300">Output:  <span class="math">tx</span></p>

    <p class="text-gray-300">1: procedure COINBASETX(pp, addrr, v, PK, SK)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2:  $\\sigma \\gets \\mathrm{SIGN}(SK, \\mathrm{addr}_r \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{addr}_r n)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3: return (addrr, v, PK, σ)</p>

    <p class="text-gray-300">CreateAddress: CreateAddress  <span class="math">(pp_{sig})\\to (\\mathrm{PK},\\mathrm{SK})</span></p>

    <p class="text-gray-300">GetQuality: GetQuality  <span class="math">(S_{i})\\to q_{i}</span></p>

    <p class="text-gray-300">GetBalance: GetBalance  <span class="math">(\\mathrm{PK}, S_i) \\to \\mathbf{a}.\\nu</span>  where  <span class="math">\\mathbf{a}</span>  is the leaf in  <span class="math">S_i</span>  with  <span class="math">\\mathbf{a}.\\mathrm{PK} = \\mathrm{PK}</span></p>

    <p class="text-gray-300">B Proof Carrying Data (PCD)</p>

    <p class="text-gray-300">Define an online distributed system with state <span class="math">\\mathcal{S}</span> and initial state <span class="math">\\mathcal{S}_{0}</span>. The system transitions from a state <span class="math">\\mathcal{S}_{i}</span> to <span class="math">\\mathcal{S}_{i+1}</span> through a function UpdateState. The security goal is to ensure that all the states that the system transitions to are compliant with a predicate <span class="math">\\Pi</span> representing a valid state update. Proof Carrying Data ensures this by attaching short and easy to verify proofs of <span class="math">\\Pi</span>-compliance to each state the system transitions to.</p>

    <p class="text-gray-300">Specifically, we assume that we have a key generator <span class="math">\\mathcal{G}</span> that sets up a proving and verification key. Anyone can use a prover <span class="math">\\mathcal{P}</span>, which is given as input the proving key, a prior state <span class="math">\\mathcal{S}_{i}</span> with a proof <span class="math">\\pi_{i}</span> and a new state <span class="math">\\mathcal{S}_{i+1}</span>, to generate a proof <span class="math">\\pi_{i+1}</span> attesting that <span class="math">\\mathcal{S}_{i+1}</span> is <span class="math">\\Pi</span>-compliant. One can then use a verifier <span class="math">\\mathcal{V}</span>, which is given as input the verification key, a state <span class="math">\\mathcal{S}_{i}</span> and a proof <span class="math">\\pi_{i}</span> to verify that <span class="math">\\mathcal{S}_{i}</span> is <span class="math">\\Pi</span>-compliant.</p>

    <p class="text-gray-300">Transcripts Given <span class="math">n_{\\mathcal{S}},n_{w}</span> and field <span class="math">\\mathbb{F}</span>, an <span class="math">\\mathbb{F}</span> arithmetic-transcript is a triple <span class="math">Tr=(k,w,\\mathcal{S})</span>, where <span class="math">k&gt;0</span>, <span class="math">w</span> maps each <span class="math">0&lt;i\\leq k</span> to a value in <span class="math">\\mathbb{F}^{n_{w}}</span> and <span class="math">\\mathcal{S}</span> maps each <span class="math">0&lt;i\\leq k+1</span> to a value <span class="math">\\mathbb{F}^{n_{\\mathcal{S}}}</span>. The output of <span class="math">Tr</span>, denoted <span class="math">out(Tr)</span> equals <span class="math">\\mathcal{S}_{k+1}</span>.</p>

    <p class="text-gray-300">Intuitively, <span class="math">w_{i}</span> represents the auxiliary data used by the node that performs the <span class="math">i</span>-th state transition. <span class="math">\\mathcal{S}_{i}</span> represents the output state of the <span class="math">i</span>-th state transition. Typically a node that performs the <span class="math">i</span>-th state transition uses the auxiliary data <span class="math">w_{i}</span> and an prior state <span class="math">\\mathcal{S}_{i}</span> to compute the new state <span class="math">\\mathcal{S}_{i+1}\\leftarrow\\text{UpdateState}(\\mathcal{S}_{i},w_{i})</span>.</p>

    <p class="text-gray-300">Compliance: Given field <span class="math">\\mathbb{F}</span> and <span class="math">n_{\\mathcal{S}},n_{w}\\in\\mathbb{N}</span>, an <span class="math">\\mathbb{F}</span>-arithmetic compliance predicate <span class="math">\\Pi</span> (for state size <span class="math">n_{\\mathcal{S}}</span> and auxiliary input size <span class="math">n_{w}</span>) is an <span class="math">\\mathbb{F}</span>-arithmetic circuit with domain <span class="math">\\mathbb{F}^{n_{\\mathcal{S}}}\\times\\mathbb{F}^{n_{w}}\\times\\mathbb{F}^{n_{\\mathcal{S}}}\\times\\mathbb{F}</span>. The compliance predicate <span class="math">\\Pi</span> specifies whether a given transcript <span class="math">Tr</span> is compliant or not. Consider any transcript <span class="math">Tr</span> with state size <span class="math">n_{\\mathcal{S}}</span> and auxiliary input size <span class="math">n_{w}</span>. We say that <span class="math">Tr=(k,w,\\mathcal{S})</span> is <span class="math">\\Pi</span>-compliant, denoted <span class="math">\\Pi(Tr)=0</span>, if, for every <span class="math">0&lt;i\\leq k</span> it holds that:</p>

    <p class="text-gray-300"><span class="math">\\Pi\\big{(}\\mathcal{S}_{i},w_{i},\\mathcal{S}_{i+1},b_{base}\\big{)}=1,</span></p>

    <p class="text-gray-300">where <span class="math">b_{base}\\in\\{0,1\\}</span> is the base case flag (i.e., equals <span class="math">1</span> if and only if <span class="math">i=1</span>). Furthermore, we say that a state <span class="math">s</span> is <span class="math">\\Pi</span>-compliant if there is <span class="math">Tr</span> such that <span class="math">\\Pi(Tr)=0</span> and <span class="math">out(Tr)=s</span>.</p>

    <p class="text-gray-300">We are now ready to describe the syntax, semantics, and security of a proof-carrying data system:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}</span> is a procedure that takes as input a compliance predicate <span class="math">\\Pi</span> and some security parameter <span class="math">\\lambda</span> and outputs a proving key <span class="math">pk</span> and a verification key <span class="math">vk</span>. We assume without loss of generality that <span class="math">pk</span> contains (a description of the predicate <span class="math">\\Pi</span>).</li>

      <li><span class="math">\\mathcal{P}</span> takes as input a proving key <span class="math">pk</span>, auxiliary input <span class="math">w</span>, a state <span class="math">\\mathcal{S}_{i+1}</span> and a state <span class="math">\\mathcal{S}_{i}</span> with proof <span class="math">\\pi_{i}</span> and outputs a proof <span class="math">\\pi_{i+1}</span> for the statement that <span class="math">\\mathcal{S}_{i+1}</span> is <span class="math">\\Pi</span>-compliant.</li>

      <li><span class="math">\\mathcal{V}</span> takes as input a verification key <span class="math">vk</span>, a state <span class="math">\\mathcal{S}_{i}</span> and a proof <span class="math">\\pi_{i}</span> and outputs <span class="math">b=1</span> if <span class="math">\\mathcal{S}_{i}</span> is <span class="math">\\Pi</span>-compliant.</li>

    </ul>

    <p class="text-gray-300">Completeness:. This is based on an interaction between a computationally unbounded adversary <span class="math">\\mathcal{A}</span> and the prover <span class="math">\\mathcal{P}</span>, who are both given the predicate <span class="math">\\Pi</span> and the common string <span class="math">(pk,vk)</span>. We build transcripts through the following:</p>

    <p class="text-gray-300"><span class="math">\\text{ProofGen}(\\Pi,pk,\\mathcal{A},\\mathcal{P})\\rightarrow(\\mathcal{S}_{i},\\pi_{i},T)</span></p>

    <p class="text-gray-300">For a full definition, see <em>[7]</em>. The adversary will provide witnesses <span class="math">w\\in\\mathbb{F}^{n_{w}}</span> and output <span class="math">\\mathcal{S}_{i}\\in\\mathbb{F}^{n_{\\mathcal{S}}}</span> to the transcript for each transition. <span class="math">\\mathcal{P}</span> then attaches a proof of compliance <span class="math">\\pi_{i}</span> to every output <span class="math">\\mathcal{S}_{i}</span> in the transcript. Using this, we have that for every predicate <span class="math">\\Pi</span>, the following is negligible in <span class="math">\\mu</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}\\Pi(T)=1&(pk,vk)\\leftarrow\\mathcal{G}(1^{\\mu})\\\\ \\mathcal{V}(vk,\\pi,\\mathcal{S})\\neq 1&\\mathcal{G}(1^{\\lambda},\\Pi)\\\\ out(Tr)\\neq S\\lor\\Pi(Tr)\\neq 1&\\mathcal{G}(pk,vk)\\\\ Tr&\\mathcal{E}(pk,vk)\\end{array}\\right]. \\]</p>

    <p class="text-gray-300">Security Properties: If the verifier accepts a proof <span class="math">\\pi</span> for a state <span class="math">S</span>, the prover “knows" a compliant transcript <span class="math">Tr</span> with output <span class="math">S</span>. Namely, for any constant <span class="math">c&gt;0</span> and every polynomial size adversary <span class="math">\\mathcal{A}</span> there is a polynomial-size witness extractor <span class="math">E</span> s.t. for every large enough security parameter <span class="math">\\lambda</span>, for every <span class="math">\\mathbb{F}</span>-arithmetic compliance predicate <span class="math">\\Pi</span> of size <span class="math">\\lambda^{c}</span>, the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}\\mathcal{V}(vk,S,\\pi)=1&(pk,vk)\\leftarrow\\mathcal{G}(1^{\\lambda},\\Pi)\\\\ out(Tr)\\neq S\\lor\\Pi(Tr)\\neq 1&\\mathcal{G}(pk,vk)\\\\ Tr&\\mathcal{E}(pk,vk)\\end{array}\\right] \\]</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">B.0.1 Constant-Depth Compliance Predicates</h4>

    <p class="text-gray-300">It should be noted that PCDs face trade-offs based on the depth of any given transcript <span class="math">Tr</span>. In this context, the depth is equivalent to the length of the path from <span class="math">\\mathcal{S}_{0}</span> to the current state. Unfortunately, in order for the security properties of the PCD system to hold for a meaningful number of transitions, we need to limit ourselves to constant-depth compliance predicates. However, in this case we are interested in verifying all transitions in a path from the genesis block, which would require a polynomial number of nodes in the transcript.</p>

    <p class="text-gray-300">We solve this problem using the construction of Bitansky et al. <em>[7]</em>, wherein a polynomial depth predicate expressing an NP language <span class="math">\\mathcal{L}</span> can be efficiently transformed into a constant-depth predicate <span class="math">Tree(\\mathcal{L})</span>. The transformation requires a CRT hash function <span class="math">\\mathcal{H}</span> and stores all proofs (of <span class="math">\\mathcal{L}</span> membership) in a tree to ‘keep track’ of their position by using only a constant number of operations.</p>

    <p class="text-gray-300">We achieve this in our construction by keeping the state commitments <span class="math">B_{i}</span> of each transition in an (ordered) Merkle tree, with all leaves initialized to zero. By requiring a proof of update of each state to the next at every transition, we ensure the same security guarantees as for <span class="math">\\mathcal{L}</span> (i.e. that <span class="math">x\\in\\mathcal{L}\\Longleftrightarrow x\\in Tree(\\mathcal{L})</span>). In practice, this transformation only requires the additional verification of a single Merkle update path and thus does not meaningfully impact performance.</p>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix C Digital Signature Schemes</h2>

    <p class="text-gray-300">We define a digital signature scheme as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{SC\\text{-}Setup}(1^{\\mu})\\rightarrow pp_{sig}</span>: Setup generating public parameters based on security parameter <span class="math">\\mu</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{CA}(pp_{sig}) \\to (\\mathrm{PK}, \\mathrm{SK})</span>  takes as input  <span class="math">pp_{sig}</span>  and outputs a public key PK and a private key SK.</li>

      <li><span class="math">\\mathrm{SIGN}(SK, m) \\to \\sigma</span>  takes as input a secret key SK and some message  <span class="math">m</span> , outputting a signature  <span class="math">\\sigma</span> .</li>

      <li>VS(PK,  <span class="math">m, \\sigma</span> ) is a procedure that takes as input a public key PK, some message  <span class="math">m</span>  and some signature  <span class="math">\\sigma</span>  and outputs a bit denoting Yes/No.</li>

    </ul>

    <p class="text-gray-300">The above signing scheme should satisfy the following security properties:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {V S} (\\mathrm {P K}, m, \\mathrm {S I G N} (\\mathrm {S K}, m)) = 1</span></div>

    <p class="text-gray-300">Security: For all non-uniform probabilistic polynomial time adversaries  <span class="math">\\mathcal{A}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\sigma \\notin Q &amp;amp; p p _ {s i g} \\leftarrow \\mathrm {S C - S E T U P} (1 ^ {\\mu}) \\\\ \\mathrm {V S} (\\mathrm {P K}, m, \\sigma) = 1 &amp;amp; (\\mathrm {P K}, \\mathrm {S K}) \\leftarrow \\mathrm {C A} (p p _ {s i g}) \\\\ &amp;amp; (m, \\sigma) \\leftarrow \\mathcal {A} ^ {\\mathrm {S I G N} (\\mathrm {S K}, \\cdot)} (\\mathrm {P K}, 1 ^ {\\mu}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">is negligible in  <span class="math">\\mu</span> . Here  <span class="math">\\mathcal{A}^{\\mathrm{SIGN}}(\\mathrm{SK},\\cdot)</span>  denotes that  <span class="math">\\mathcal{A}</span>  has access to the oracle,  <span class="math">\\mathrm{SIGN}(\\mathrm{SK},\\cdot)Q</span>  denotes the set of queries on  <span class="math">\\mathrm{SIGN}</span>  made by  <span class="math">\\mathcal{A}</span> , which knows the public key PK and the security parameter  <span class="math">\\mu</span> . Note that we require that any adversary cannot directly query the string,  <span class="math">m</span> , on  <span class="math">\\mathrm{SIGN}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider inputs  <span class="math">s, e \\in \\mathbb{F}_q</span>  and  <span class="math">pk = (pk_x, pk_y) \\in E(\\mathbb{F}_q) \\subset \\mathbb{F}_q \\times \\mathbb{F}_q</span>  to a circuit  <span class="math">C_{\\mathrm{Sig}}</span> . Verification of a signature  <span class="math">(s, e) \\in \\mathbb{F}_q \\times \\mathbb{F}_q</span>  for some  <span class="math">m</span>  requires that  $e = \\mathcal{H}(G^s \\cdot Q^e \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)<span class="math"> , where  </span>Q<span class="math">  the given public key and  </span>G$  the generator of the underlying group.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We built an exponentiation subcircuit  <span class="math">C_{\\mathrm{exp}}</span>  to verify the computation of  <span class="math">G^{s}</span>  and  <span class="math">pk^{e}</span> , with  <span class="math">G</span>  hardcoded at setup.  <span class="math">C_{\\mathrm{exp}}(S,x)</span>  parses two field elements as an elliptic curve point  <span class="math">S</span> , it also parses a scalar by which to multiply the curve point. We use the "double-and-add" method, consisting of serial multiplications and squarings of  <span class="math">S</span>  to verify that exponentiation was correctly performed. We then compute the hash of the message concatenated to the bit-representation of  <span class="math">G^{s} \\cdot pk^{e}</span> . This is done using an instantiation of a Pedersen hash circuit. An additional final constraint ensures that  <span class="math">d = e</span>  for the signature to verify.</p>

    <p class="text-gray-300">We specify VerifyTx in Algorithm 6 and UpdateState in Algorithm 7. Together they define the state transitions in the model set out by our DPS and are used to construct the PCD. If the above accepts, then the participant accepts  <span class="math">S_{i+1}</span>  (corresponding to commitment  <span class="math">B_{i+1}</span> ) as the new state of the system with associated compliance proof  <span class="math">\\pi_{i+1}</span> .</p>

    <p class="text-gray-300">Algorithm 6 VerifyTx Input:  <span class="math">(t,T^i)</span> Output: bit  <span class="math">b</span> 1: procedure VERIFYTx(t,T^i) 2: Parse  <span class="math">t</span> 3: if  <span class="math">t = (\\mathrm{addr}_s,\\mathrm{addr}_r,\\nu ,f,\\mathrm{PK},\\sigma ,\\mathrm{PK}_R)</span>  then 4: if  <span class="math">\\nu &amp;lt; 0</span>  then 5: return 0 6: Let  <span class="math">\\mathbf{a}_s</span>  the account in  <span class="math">T^i</span>  s.t.  <span class="math">\\mathbf{a}_s.\\mathrm{addr} = \\mathrm{addr}_s</span> 7: if  <span class="math">\\mathbf{a}_s.\\mathrm{PK}\\neq \\mathrm{PK}</span>  then 8: return 0 9: if  <span class="math">\\mathbf{a}_r.\\mathrm{PK}\\neq \\mathrm{nil}</span>  and  <span class="math">\\mathbf{a}_r.\\mathrm{PK}\\neq \\mathrm{PK}_R</span>  then 10: return 0</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11:  $m\\gets \\mathrm{addr}_s\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{addr}_r\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{a}_r.n$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">12: if VS(PK,m,σ)=0 then 13: return 0 14: // Check for sufficient balance 15: if  <span class="math">\\mathbf{a}_s.\\mathrm{bal} &amp;lt;   v + f</span>  then 16: return 0 17: 18: else if tx=(addr,v,PK,σ) then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19: if VS(PK,addr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">addr.n,σ)=0 then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">20: return 0 21: Let a the account in  <span class="math">T^i</span>  s.t. a.addr = addr 22: if a.PK≠nil and a.PK≠PK then 23: return 0 24: else 25: return 0 26: return 1</p>

    <p class="text-gray-300">We first define the data structures used in our constructions, and then look at the NP statement that defines what a block needs to be valid.</p>

    <p class="text-gray-300">Here we define a proof of modification  <span class="math">\\pi^{mod}(\\mathrm{acc}_A,\\mathrm{acc}_B)</span>  of some account  <span class="math">\\mathrm{acc}_A</span>  to  <span class="math">\\mathrm{acc}_B</span>  in Account tree  <span class="math">T</span> . We also provide definitions for each of these proofs and their corresponding properties.</p>

    <p class="text-gray-300">Paths of Inclusion: We define a path of a certain leaf to the root, along with the notion of a 'full' path that also includes the other child node. These are important in constructing proofs of inclusion of nodes in a given tree. The two objects are defined below:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>path(acc,  <span class="math">q</span> ) = (acc,  <span class="math">v_0</span> ,  <span class="math">\\{v_k\\}_{k=1}^q</span> ) where  <span class="math">q \\in [h-1]</span></li>

      <li>fullpath(acc) = (acc,  <span class="math">v_0</span> ,  <span class="math">\\{c_k, v_k, i_k\\}_{k=1}^{h-1}</span> )</li>

    </ol>

    <p class="text-gray-300">Definitions of the parameters above are given here:</p>

    <p class="text-gray-300">Algorithm 7 UpdateState Input:  <span class="math">(S_{i},\\mathbf{t},n)</span> Output:  <span class="math">(S_{i + 1})</span> 1: procedure UPDATESTATE  <span class="math">(S_{i},\\mathbf{t},n)</span> 2: Parse  <span class="math">S_{i}\\gets (T^{i},i,q_{i},n_{i})</span>  , return 0 if this fails</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3:  $N\\gets</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4:  <span class="math">T_0^i\\gets T^i</span> 5:  <span class="math">\\nu_{Tfee}\\gets 0</span> 6: for  <span class="math">j\\gets 1,\\dots ,N - 1</span>  do 7:  <span class="math">t_j\\gets (\\mathrm{addr}_s,\\mathrm{addr}_r,\\nu_f,\\mathrm{PK},\\sigma ,\\mathrm{PK}_R)</span> 8: if VERIFYTX  <span class="math">(t_j,T_{j - 1}^i) = 0</span>  then 9: return 0 10:  <span class="math">T_{j}^{i}\\gets T_{j - 1}^{i} / /</span>  Initialize  <span class="math">T_{j}^{i}</span> 11: Define  <span class="math">\\mathbf{a}_s</span>  as leaf of  <span class="math">T_{j - 1}^{i}</span>  s.t.  <span class="math">\\mathbf{a}_s</span>  .addr  <span class="math">=</span>  addr  <span class="math">s</span> 12: Update  <span class="math">T_{j}^{i}</span>  .. 13: Set  <span class="math">\\mathbf{a}_s</span>  .bal  <span class="math">\\leftarrow</span>  a.bal-txj.v-txj.f 14: Set  <span class="math">\\mathbf{a}_s.n\\gets n</span> 15: Define  <span class="math">\\mathbf{a}_r</span>  as leaf of  <span class="math">T_{j - 1}^{i}</span>  s.t.  <span class="math">\\mathbf{a}_r</span>  .addr  <span class="math">=</span>  addr  <span class="math">r</span> 16: Update  <span class="math">T_{j}^{i}</span>  .. 17: Set  <span class="math">\\mathbf{a}_r</span>  .bal  <span class="math">\\leftarrow</span>  a.bal+txj.v 18: Set  <span class="math">\\mathbf{a}_r.n\\gets n</span> 19: If  <span class="math">\\mathbf{a}_r</span>  .PK  <span class="math">=</span>  nil, set  <span class="math">\\mathbf{a}_r</span>  .PK  <span class="math">\\leftarrow</span>  PKR 20:  <span class="math">\\nu_{Tfee} = \\nu_{Tfee} + tx_j.f</span> 21:  <span class="math">t_N\\gets (\\mathrm{addr},\\nu ,\\mathrm{PK},\\sigma)</span> 22: if VERIFYTX  <span class="math">(t_N,T_{N - 1}^i) = 0</span>  then 23: return 0 24: if  <span class="math">\\nu \\neq \\nu_{mint} + \\nu_{Tfee}</span>  then 25: return 0 26:  <span class="math">T_{N}^{i}\\gets T_{N - 1}^{i}</span> 27: Define  <span class="math">\\mathbf{a}_m</span>  as leaf of  <span class="math">T_{N - 1}^{i}</span>  s.t.  <span class="math">\\mathbf{a}_m</span>  .addr  <span class="math">=</span>  addr  <span class="math">m</span> 28: Update  <span class="math">T_{N}^{i}</span>  .. 29: Set  <span class="math">\\mathbf{a}_m</span>  .bal  <span class="math">\\leftarrow</span>  a.bal+v 30: Set  <span class="math">\\mathbf{a}_m.n\\gets n</span> 31: If  <span class="math">\\mathbf{a}_m</span>  .PK  <span class="math">=</span>  nil, set  <span class="math">\\mathbf{a}_m</span>  .PK  <span class="math">\\leftarrow</span>  PK 32:  <span class="math">q_{i + 1}\\gets q_i + 1</span> 33:  <span class="math">S_{i + 1} = (T_N^i,i + 1,q_{i + 1},n)</span> 34: return  <span class="math">S_{i + 1}</span></p>

    <p class="text-gray-300">Algorithm 8 VerifyState Input:  <span class="math">pp, B_i, \\pi_i, B_{i+1}, \\pi_{i+1}</span> Output:  <span class="math">\\{0,1\\}</span> 1: procedure VERIFYSTATE(pp,  <span class="math">B_i, \\pi_i, B_{i+1}, \\pi_{i+1}</span> ) 2: if  <span class="math">\\mathcal{V}(\\nu k, B_{\\{i,i+1\\}}, \\pi_{\\{i,i+1\\}}) = 0</span>  then 3: return 0 4: if  <span class="math">\\mathcal{H}(\\pi_{i+1}) &amp;gt; d</span>  then 5: return 0 6: return 1</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>acc is the account in question and  <span class="math">\\nu_{0} = \\mathcal{H}(\\mathrm{acc})</span></li>

      <li><span class="math">q\\in [h - 1]</span>  is the length of the desired path</li>

      <li><span class="math">\\nu_{k}</span>  is the  <span class="math">k</span> -th node in the path from the leaf acc to the root. By construction it holds that  <span class="math">\\mathcal{H}(\\nu_{k-1}, c_{k}) = \\nu_{k}</span>  if  <span class="math">i_{k} = 0</span>  and  <span class="math">\\mathcal{H}(c_{k}, \\nu_{k-1}) = \\nu_{k}</span>  otherwise.</li>

    </ol>

    <p class="text-gray-300">Leaf Order: By construction the leaves of  <span class="math">T</span>  follow a given canonical ordering. We use the unique path from the root to a given leaf to define this ordering. More specifically, we consider the address  <span class="math">\\mathrm{addr} \\in \\{0,1\\}^h</span>  of some account acc to denote the  <span class="math">i</span> -th leaf where  <span class="math">i = 2^{acc}</span> . It is immediate that this is a unique total ordering of all accounts in  <span class="math">T</span> .</p>

    <p class="text-gray-300">Proof of Modification: We now define a proof of modification of a certain leaf  <span class="math">\\mathrm{acc}_A</span>  to  <span class="math">\\mathrm{acc}_B</span> :</p>

    <p class="text-gray-300"><span class="math">\\pi^{mod}(\\mathrm{acc}_A,\\mathrm{acc}_B) = (\\mathrm{fullpath}(\\mathrm{acc}_A),\\mathrm{path}(\\mathrm{acc}_B,h - 1))</span></p>

    <p class="text-gray-300">We say that a proof of modification is consistent if it satisfies Algorithm 9.</p>

    <p class="text-gray-300">We also define the following two values related to the inclusion proof object  <span class="math">\\pi^{mod} = \\pi^{mod}(\\mathrm{acc}_A,\\mathrm{acc}_B)</span> :</p>

    <p class="text-gray-300"><span class="math">\\pi^{mod} = (\\text{fullpath}(\\text{acc}_A), \\text{path}(\\text{acc}_B, h - 1))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>firstroot  <span class="math">(\\pi^{mod}) =</span>  root(fullpath(accA))</li>

      <li>lastroot  <span class="math">(\\pi^{mod}) = \\text{root}(\\text{path}(\\text{acc}_B, h - 1))</span></li>

    </ul>

    <p class="text-gray-300">Inclusion Sequence: We are also interested in lists of inclusion proofs, of which we want valid sequences of proofs, which are defined for the  <span class="math">i</span> -th state based on the tuple below:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Seq}_{\\mathrm{j}} = \\left(N,rt_{j - 1},\\{\\pi_{debit}^{mod,i},\\pi_{credit}^{mod,i}\\}_{i = 1}^{N},\\pi_{CB}^{mod},rt_{j}\\right)</span></p>

    <p class="text-gray-300">where we define:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">N</span>  the total number of transactions to be processed (excluding the coinbase)</li>

      <li><span class="math">rt_{j-1}</span>  and  <span class="math">rt_j</span>  the root of  <span class="math">T</span>  before and after all updates have been processed respectively</li>

      <li><span class="math">\\mathrm{acc}_{debit}^{1,i}</span>  and  <span class="math">\\mathrm{acc}_{debit}^{2,i}</span>  the debit account before and after the  <span class="math">i</span> -th transaction</li>

    </ul>

    <p class="text-gray-300">Algorithm 9 Modification Consistency Input:  <span class="math">\\pi^{mod}(\\mathrm{acc}_A,\\mathrm{acc}_B) = (\\mathrm{fullpath}(\\mathrm{acc}_A),\\mathrm{path}(\\mathrm{acc}_B,j))</span> Output:  <span class="math">b\\in \\{0,1\\}</span> 1: procedure CONSISTENCY  <span class="math">(\\pi^{mod}(\\mathrm{acc}_A,\\mathrm{acc}_B))</span> 2: fullpath  <span class="math">(\\mathrm{acc}_A)\\gets (\\mathrm{acc}_A,v_0^A,\\{c_k^A,v_k^A,i_k^A\\}_{k = 1}^{h - 1})</span> 3: path  <span class="math">(\\mathrm{acc}_B,j)\\gets (\\mathrm{acc}_B,v_0^B,\\{v_k^B\\}_{k = 1}^j)</span> 4: Check the following, return 0 if any fail: 5:  <span class="math">j = h - 1</span> 6:  <span class="math">\\mathcal{H}(\\mathrm{acc}_A) = v_0^A</span> 7:  <span class="math">\\mathcal{H}(\\mathrm{acc}_B) = v_0^B</span> 8: for  <span class="math">k\\in [h - 1]</span>  do 9: if  <span class="math">i_k = 0</span>  then 10: if  <span class="math">\\mathcal{H}(v_{k - 1}^A,c_k^A)\\neq v_k^A</span>  then 11: return 0 12: if  <span class="math">\\mathcal{H}(v_{k - 1}^B,c_k^B)\\neq v_k^B</span>  then 13: return 0 14: else 15: if  <span class="math">\\mathcal{H}(c_k^A,v_{k - 1}^A)\\neq v_k^A</span>  then 16: return 0 17: if  <span class="math">\\mathcal{H}(c_k^B,v_{k - 1}^B)\\neq v_k^B</span>  then 18: return 0 19: return 1</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{acc}_{credit}^{1,i}</span>  and  <span class="math">\\mathrm{acc}_{credit}^{2,i}</span>  the credit account before and after the  <span class="math">i</span> -th transaction</li>

      <li><span class="math">\\mathrm{acc}_{CB}^{1}</span>  and  <span class="math">\\mathrm{acc}_{CB}^{2}</span>  coinbase account before and after modification</li>

      <li><span class="math">\\pi_{user}^{mod,i} = (\\mathrm{acc}_{user}^{1,i},\\mathrm{acc}_{user}^{2,i})</span>  the modification proofs for each transaction</li>

    </ul>

    <p class="text-gray-300">We consider a valid proof sequence to be a tuple that satisfies the following algorithm.</p>

    <p class="text-gray-300">We construct the following NP statement, which checks for the validity of a certain block. Instances are tuples  <span class="math">B_{i} = (rt^{i}, i, q_{i}, n_{i})</span>  where  <span class="math">rt^{i}</span>  the root of tree  <span class="math">T^{i}</span>  corresponding to  <span class="math">S_{i}</span>  with nonce  <span class="math">n_{i}</span> , while witnesses  <span class="math">w</span>  are defined by:</p>

    <p class="text-gray-300"><span class="math">(N,\\{\\pi_{debit}^{mod,j},\\pi_{credit}^{mod,j},s^j,v_s^i,v_m^j\\}_{j = 1}^N,\\pi_{CB}^{mod},s_{CB},\\pi_{i - 1},B_{i - 1},n_i),</span></p>

    <p class="text-gray-300">where we define:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">N</span>  the number of transactions in the block</li>

      <li><span class="math">s^j</span>  signature for  <span class="math">tx_{j}</span> <span class="math">s_{CB}</span>  signature for coinbase</li>

      <li><span class="math">\\nu_{s}^{i},\\nu_{m}^{j}</span>  amounts sent to credit account and miner respectively in  <span class="math">tx_{j}</span></li>

      <li><span class="math">\\pi_{debit}^{mod,i} = \\pi^{mod}(\\mathrm{acc}_{debit}^{1,j},\\mathrm{acc}_{debit}^{2,j})</span>  proof of modification of debit account</li>

      <li><span class="math">\\pi_{credit}^{mod,i} = \\pi^{mod}(\\mathrm{acc}_{credit}^{1,j},\\mathrm{acc}_{credit}^{2,j})</span>  proof of modification of credit account</li>

    </ol>

    <p class="text-gray-300">Algorithm 10 Valid Proof Sequence Input:  <span class="math">\\mathrm{Seq}_{\\mathrm{j}} = \\left(N,rt_{j - 1},\\{\\pi_{debit}^{mod,i},\\pi_{credit}^{mod,j}\\}_{i = 1}^{N},\\pi_{CB}^{mod},rt_{j}\\right)</span> Output:  <span class="math">b</span> 1: procedure VALSEQ(Seqj) 2: if  <span class="math">rt_{j - 1}\\neq</span>  firstroot  <span class="math">(\\pi_{debit}^{mod,1})</span>  then 3: return 0 4: for  <span class="math">i</span>  from 1 to [N] do: 5: if lastroot  <span class="math">(\\pi_{debit}^{mod,i})\\neq</span>  firstroot  <span class="math">(\\pi_{credit}^{mod,i})</span>  then 6: return 0 7: if  <span class="math">i &amp;lt; N</span>  then 8: if lastroot  <span class="math">(\\pi_{credit}^{mod,i})\\neq</span>  firstroot  <span class="math">(\\pi_{debit}^{mod,i + 1})</span>  then 9: return 0 10: if lastroot  <span class="math">(\\pi_{credit}^{mod,N})\\neq</span>  firstroot  <span class="math">(\\pi_{CB}^{mod})</span>  then 11: return 0 12: if lastroot  <span class="math">(\\pi_{CB}^{mod})\\neq rt_j</span>  then 13: return 0 14: return 1</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{CB}^{mod} = \\pi^{mod}(\\mathrm{acc}_{CB}^{1},\\mathrm{acc}_{CB}^{2})</span>  proof of modification of coinbase account</li>

      <li><span class="math">B_{i - 1} = (rt^{i - 1},i - 1,q_{i - 1},n_{i - 1})</span>  previous state commitment and  <span class="math">\\pi_{i - 1}</span>  previous proof</li>

      <li>Current  <span class="math">n_i</span>  proof-of-work nonce</li>

    </ol>

    <p class="text-gray-300">We define the language BLOCK-V with state commitment objects  <span class="math">B_{i} = (rt^{i},i,q_{i},n_{i})</span>  as candidate elements:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {B L O C K - V} = \\left\\{B _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\exists w \\text {s . t . V A L I D B L O C K} \\left(B _ {i}, w\\right) = 1 \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where VALIDBLOCK is defined below:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">\\mathcal{H}(\\pi_{i - 1})\\leq d</span></li>

      <li>Define  <span class="math">\\nu_{fees} = 0</span></li>

      <li>For  <span class="math">j \\in [N]</span> , return 0 if any of the following fail:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathrm{acc}_{debit}^{j,1}\\gets (\\mathrm{addr}_{debit}^{j,1},\\mathrm{PK}_{debit}^{j,1},\\nu_{debit}^{j,1},n_{debit}^{j,1})</span> (b)  <span class="math">\\mathrm{acc}_{debit}^{j,2}\\gets (\\mathrm{addr}_{debit}^{j,2},\\mathrm{PK}_{debit}^{j,2},\\nu_{debit}^{j,2},n_{debit}^{j,2})</span> (c)  <span class="math">\\mathrm{acc}_{credit}^{j,1}\\gets (\\mathrm{addr}_{credit}^{j,1},\\mathrm{PK}_{credit}^{j,1},\\nu_{credit}^{j,1},n_{credit}^{j,1})</span> (d)  <span class="math">\\mathrm{acc}_{credit}^{j,2}\\gets (\\mathrm{addr}_{credit}^{j,2},\\mathrm{PK}_{credit}^{j,2},\\nu_{credit}^{j,2},n_{credit}^{j,2})</span> (e) CONSISTENT  <span class="math">(\\pi_{debit}^{mod,j}) = 1</span> (f) CONSISTENT  <span class="math">(\\pi_{credit}^{mod,j}) = 1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(g) VS  $(\\mathrm{PK}_{debit}^{j,1},\\mathrm{addr}_{debit}^{j,1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{addr}_{credit}^{j,1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu_{m}^{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu_{s}^{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_{debit}^{j,1},s^{j}) = 1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(h)  <span class="math">n_i = n_{debit}^{j,2} = n_{credit}^{j,2}</span> (i)  <span class="math">\\mathrm{PK}_{debit}^{j,1} = \\mathrm{PK}_{debit}^{j,2}</span> (j)  <span class="math">\\mathrm{PK}_{credit}^{j,1} = \\mathrm{PK}_{credit}^{j,2}</span>  or  <span class="math">\\mathrm{PK}_{credit}^{j,2} = \\bot</span> (k)  <span class="math">\\nu_{debit}^{j,1} = \\nu_m^j +\\nu_s^j +\\nu_{debit}^{j,2}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">v_{credit}^{j,2}=v_{s}^{j}+v_{credit}^{j,1}</span></li>

      <li>Set <span class="math">v_{fees}=v_{fees}+v_{m}^{j}</span></li>

      <li><span class="math">\\text{acc}_{CB}^{1}\\leftarrow(\\text{addr}_{CB}^{1},\\text{PK}_{CB}^{1},v_{CB}^{1},n_{CB}^{1})</span></li>

      <li><span class="math">\\text{acc}_{CB}^{2}\\leftarrow(\\text{addr}_{CB}^{2},\\text{PK}_{CB}^{2},v_{CB}^{2},n_{CB}^{2})</span></li>

      <li>Verify <span class="math">\\text{PK}_{CB}^{1}=\\text{PK}_{CB}^{2}</span></li>

      <li>Verify <span class="math">\\text{addr}_{CB}^{1}=\\text{addr}_{CB}^{2}</span></li>

      <li>Verify <span class="math">v_{CB}^{2}=v_{1}^{1}=v_{0}+v_{fees}</span></li>

      <li>Verify <span class="math">\\textsc{Consistent}(\\pi_{CB}^{mod})=1</span></li>

      <li>Verify that <span class="math">n_{CB}^{2}=n_{i}</span></li>

      <li>Verify that the following equal 1:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\textsc{VS}(\\text{PK}_{CB}^{1},\\text{addr}_{CB}^{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{fees}+v_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_{CB}^{1},s_{CB})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\textsc{ValSeq}\\left(N,rt_{i-1},\\{\\pi_{debit}^{mod,j},\\pi_{credit}^{mod,j}\\}_{j=1}^{N},\\pi_{CB}^{mod},rt_{i}\\right)</span></p>

    <h2 id="sec-59" class="text-2xl font-bold">Appendix F Security Properties</h2>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">F.1 Completeness</h3>

    <p class="text-gray-300">It is important for the protocol to allow transactions formed by honest parties to be accepted and processed. This requires that it satisfy the property of completeness. We define completeness in the standard way, by requiring that no polynomial-sized adversary can win the incompleteness experiment with non-negligible probability. We formalize this below, where the experiment is an interaction between an algorithm <span class="math">\\mathcal{A}</span> and a challenger <span class="math">\\mathcal{C}</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">We say that a DPS <span class="math">\\Pi</span> is <em>complete</em> if, for all <span class="math">\\text{poly}(\\lambda)</span>-size algorithms <span class="math">\\mathcal{A}</span> and large enough <span class="math">\\lambda</span>, the adversary wins INCOMP with at most negligible probability:</p>

    <p class="text-gray-300"><span class="math">Pr[\\textsc{INCOMP}(\\mathcal{A},\\Pi,\\lambda)=1]\\leq negl(\\lambda)</span></p>

    <p class="text-gray-300"><span class="math">\\textsc{INCOMP}(\\Pi,\\lambda,\\mathcal{A})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> samples <span class="math">pp\\leftarrow\\text{Setup}(1^{\\lambda})</span>, sending <span class="math">pp</span> to <span class="math">\\mathcal{A}</span></li>

      <li><span class="math">\\mathcal{A}</span> sends <span class="math">\\mathcal{C}</span> the following:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A state <span class="math">S_{i}</span></li>

      <li>Three addresses <span class="math">z_{a},z_{b},z_{CB}</span></li>

      <li>Positive integer values <span class="math">c_{s}</span>, <span class="math">c_{f}</span>, <span class="math">c_{m}</span></li>

      <li>A key pair <span class="math">(\\text{PK},\\text{SK})</span> corresponding to address <span class="math">\\mathbf{a}</span></li>

      <li>A public key <span class="math">\\text{PK}_{B}</span></li>

      <li>A key pair <span class="math">(\\text{PK}_{CB},\\text{SK}_{CB})</span></li>

      <li>Two signatures <span class="math">\\sigma</span>, <span class="math">\\sigma_{CB}</span></li>

      <li>Information strings <span class="math">\\textsc{info}_{S},\\textsc{info}_{\\sigma},\\textsc{info}_{\\sigma_{2}}</span></li>

      <li><span class="math">\\mathcal{C}</span> checks that the following hold, outputting 0 if any test fails:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the key pairs are well formed</li>

      <li>Check that all addresses are different</li>

      <li>Check that</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\textsc{VS}(\\text{PK},z_{a}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{b}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{f}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsc{info}_{\\sigma},\\sigma)=1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\textsc{VS}(\\text{PK}_{CB},z_{CB}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{m}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsc{info}_{\\sigma_{2}},\\sigma_{CB})=1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VerifyState<span class="math">(pp,S_{i},\\textsc{info}_{S})=1</span></li>

      <li>Account <span class="math">\\mathbf{a}</span> with <span class="math">\\mathbf{a}.\\text{addr}=z_{a}</span> exists in <span class="math">S_{i}</span> and is non-null with public key PK</li>

      <li>If account <span class="math">\\mathbf{b}</span> with <span class="math">\\mathbf{b}.\\text{addr}=z_{b}</span> is initialized, check that it has public key <span class="math">\\text{PK}_{B}</span></li>

      <li>GetBalance<span class="math">(pp,S_{i},\\text{PK})\\geq c_{s}+c_{f}</span></li>

      <li><span class="math">c_{f}\\leq c_{m}</span></li>

      <li><span class="math">\\mathcal{C}</span> constructs a send transaction <span class="math">t</span> with the given parameters:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\text{NewTransaction}(pp,z_{a},z_{b},c_{s},c_{f},(\\text{PK},\\text{SK}),\\text{PK}_{B})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> constructs a coinbase transaction <span class="math">t_{CB}</span> with the given parameters:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\text{NewCoinbase}(pp,z_{CB},c_{m},(\\text{PK}_{CB},\\text{SK}_{CB}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> checks that the following hold, outputting 0 if any test fails:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VerifyTransaction<span class="math">(pp,t,S_{i})=1</span></li>

      <li>VerifyTransaction<span class="math">(pp,t_{CB},S_{i})=1</span></li>

      <li>Compute the state transition:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(S_{i+1},\\textsc{info}_{S_{2}})=\\text{NewState}(pp,\\{t,t_{CB}\\},S_{i},\\textsc{info}_{S})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output 1 if any of the following hold:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t\\neq(z_{a},z_{b},c_{s},c_{f},\\text{PK},\\sigma,\\text{PK}_{R})</span></li>

      <li><span class="math">t_{CB}\\neq(z_{CB},c_{m},\\text{PK}_{CB},\\sigma_{CB})</span></li>

      <li>GetBalance<span class="math">(\\text{PK}_{B},S_{i+1})\\neq\\text{GetBalance}(\\text{PK}_{B},S_{i})+c_{s}</span></li>

      <li>GetBalance<span class="math">(\\text{PK}_{CB},S_{i+1})\\neq\\text{GetBalance}(\\text{PK}_{CB},S_{i})+c_{m}</span></li>

      <li>GetBalance<span class="math">(\\text{PK},S_{i})\\neq\\text{GetBalance}(\\text{PK},S_{i+1})+c_{s}+c_{f}</span></li>

      <li>VerifyState<span class="math">(pp,S_{i+1},\\textsc{info}_{S_{2}})=0</span></li>

    </ol>

    <p class="text-gray-300">F.2 Correctness</p>

    <p class="text-gray-300">In order to correctly set up the threat model, we need to define an oracle <span class="math">\\mathcal{O}</span> that will initialize the DPS based on some public parameters <span class="math">pp</span>, keep the state of the system <span class="math">\\mathcal{S}_{i}</span> along with an information string <span class="math">\\mathsf{info}_{S}</span>, and allow queries from the adversary. It will also keep counters <span class="math">C,D,E</span> initialized to zero and an initially empty set <span class="math">\\mathsf{ADDR}</span>. The possible queries are:</p>

    <p class="text-gray-300">CreateAddress:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate <span class="math">(\\text{PK},\\text{SK})\\leftarrow\\mathsf{CA}(pp_{sig})</span></li>

      <li>Add <span class="math">(\\text{PK},\\text{SK})</span> to <span class="math">\\mathsf{ADDR}</span></li>

      <li>Return PK</li>

    </ol>

    <p class="text-gray-300">LookupAddress:<span class="math">(z_{a})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find the public key PK for account <span class="math">z_{a}</span></li>

      <li>If PK is not in <span class="math">\\mathsf{ADDR}</span>, return zero</li>

      <li>Return <span class="math">\\text{GetBalance}(\\text{PK},\\mathcal{S})</span></li>

    </ol>

    <p class="text-gray-300">RequestTransactions:</p>

    <p class="text-gray-300"><span class="math">(z_{a},z_{b},c_{s},c_{f},\\text{PK},\\text{PK}_{B},z_{CB},c_{m},\\text{PK}_{CB})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">\\text{PK},\\text{PK}_{CB}\\in\\mathsf{ADDR}</span></li>

      <li>Retrieve SK and <span class="math">\\text{SK}_{CB}</span> and obtain <span class="math">\\sigma,\\sigma_{CB}</span></li>

      <li><span class="math">t\\leftarrow(z_{a},z_{b},c_{s},c_{f},\\text{PK},\\sigma,\\text{PK}_{B})</span></li>

      <li><span class="math">t_{CB}\\leftarrow(z_{CB},c_{m},\\text{PK}_{CB},\\sigma_{CB})</span></li>

      <li>Check that <span class="math">\\text{VerifyTransaction}(pp,t,\\mathcal{S})=1</span></li>

      <li>Check that <span class="math">\\text{VerifyTransaction}(pp,t_{CB},\\mathcal{S})=1</span></li>

      <li><span class="math">E_{0}=\\text{GetBalance}(\\text{PK}_{B},\\mathcal{S})</span></li>

      <li>Update the state and information string:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathcal{S}_{2},\\mathsf{info}_{S_{2}})\\leftarrow\\text{NewState}(pp,\\{t,t_{CB}\\},\\mathcal{S},\\mathsf{info}_{S})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\text{VerifyState}(pp,\\mathcal{S}_{2},\\mathsf{info}_{S_{2}})=1</span>, set</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{S}=\\mathcal{S}_{2},\\mathsf{info}_{S}=\\mathsf{info}_{S_{2}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">c_{s}=\\text{GetBalance}(\\text{PK}_{B},\\mathcal{S})-E_{0}</span></li>

      <li>If <span class="math">\\text{PK}_{B}\\not\\in\\mathsf{ADDR}</span>, set</li>

    </ol>

    <p class="text-gray-300"><span class="math">E=E+c_{s}</span></p>

    <p class="text-gray-300">AddTransactions:<span class="math">(t,t_{CB})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(z_{a},z_{b},c_{s},c_{f},\\text{PK},\\sigma,\\text{PK}_{B})\\leftarrow t</span></li>

      <li><span class="math">(z_{CB},c_{m},\\text{PK}_{CB},\\sigma_{CB})\\leftarrow t_{CB}</span></li>

      <li>Check that <span class="math">\\text{VerifyTransaction}(pp,t,\\mathcal{S})=1</span></li>

      <li>Check that <span class="math">\\text{VerifyTransaction}(pp,t_{CB},\\mathcal{S})=1</span></li>

      <li><span class="math">C_{0}=\\text{LookupAddress}(z_{b})</span></li>

      <li><span class="math">D_{0}=\\text{GetBalance}(\\text{PK}_{CB},\\mathcal{S})</span></li>

      <li>Update the state and information string:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathcal{S}_{2},\\mathsf{info}_{S_{2}})\\leftarrow\\text{NewState}(pp,\\{t,t_{CB}\\},\\mathcal{S},\\mathsf{info}_{S})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">c_{m}=\\text{GetBalance}(\\text{PK}_{CB},\\mathcal{S})-D_{0}</span></li>

      <li>If <span class="math">\\text{PK}_{B}\\in\\mathsf{ADDR}</span>, check that</li>

    </ol>

    <p class="text-gray-300"><span class="math">c_{s}=\\text{LookupAddress}(z_{b})-C_{0}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\text{VerifyState}(pp,\\mathcal{S}_{2},\\mathsf{info}_{S_{2}})=1</span>, set</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{S}=\\mathcal{S}_{2},\\mathsf{info}_{S}=\\mathsf{info}_{S_{2}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">C=C+\\text{LookupAddress}(z_{b})-C_{0}</span></li>

      <li>Set <span class="math">D=D+c_{m}</span></li>

    </ol>

    <p class="text-gray-300">We are now ready to define the correctness experiment, which will prove security for our system.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">We say that a DPS <span class="math">\\Pi</span> is <em>correct</em> if, for all <span class="math">\\text{poly}(\\lambda)</span>-size adversaries <span class="math">\\mathcal{A}</span> and large enough <span class="math">\\lambda</span>, the adversary wins <span class="math">\\text{INCOR}</span> with at most negligible probability:</p>

    <p class="text-gray-300"><span class="math">Pr[\\text{INCOR}(\\mathcal{S},\\Pi,\\lambda)=1]\\leq negl(\\lambda)</span></p>

    <p class="text-gray-300">The game below refers to an interaction between an adversary <span class="math">\\mathcal{A}</span> and challenger <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300"><span class="math">\\text{INCOR}(\\Pi,\\lambda,\\mathcal{A})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> samples <span class="math">pp\\leftarrow\\text{Setup}(1^{\\lambda})</span>, sending <span class="math">pp</span> to <span class="math">\\mathcal{A}</span></li>

      <li><span class="math">\\mathcal{C}</span> instantiates an oracle <span class="math">\\mathcal{O}</span> based on <span class="math">\\Pi</span></li>

      <li><span class="math">\\mathcal{A}</span> issues queries to <span class="math">\\mathcal{O}</span></li>

      <li><span class="math">\\mathcal{A}</span> sends a set of addresses <span class="math">\\{z_{i}\\}_{i=1}^{K}</span> to <span class="math">\\mathcal{C}</span></li>

      <li><span class="math">\\mathcal{C}</span> then adds together in a variable <span class="math">v</span> all the balances of the addresses <span class="math">\\text{PK}_{i}</span> corresponding to <span class="math">z_{i}</span> for which <span class="math">\\text{PK}_{i}\\not\\in\\mathsf{ADDR}</span></li>

      <li><span class="math">\\mathcal{C}</span> outputs <span class="math">1</span> if <span class="math">v+C&gt;D+E</span></li>

    </ol>

    <h2 id="sec-63" class="text-2xl font-bold">Appendix G Proof of Theorem 1</h2>

    <h3 id="sec-64" class="text-xl font-semibold mt-8">G.1 Completeness</h3>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In step (3), <span class="math">\\mathcal{C}</span> ensures the transaction and state provided are valid. Since the transactions involve different addresses, we do not worry about one referencing the other.</p>

    <p class="text-gray-300">We look at all the ways the adversary can win. Firstly, (a) and (b) are impossible since <span class="math">\\mathsf{NewTransaction}</span> signs and creates the given transactions without changing parameters. By the completeness property of the signature scheme, the valid signatures will always verify.</p>

    <p class="text-gray-300">Since the new state will be built according to UpdateState by exactly matching the balances of the participants according to the transaction amounts, we also ensure the equalities in (c), (d) and (e).</p>

    <p class="text-gray-300">Finally, we know by completeness of the PCD that in the case of a valid state transition the verifier will reject with negligible probability. In our case, <span class="math">\\inf_{S}=\\pi_{i}</span> and <span class="math">\\inf_{S_{S}}=\\pi_{i+1}</span>. Since Setup runs <span class="math">\\mathcal{G}</span>, NewState runs <span class="math">\\mathcal{P}</span> and VerifyState runs <span class="math">\\mathcal{V}</span>, we know that:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c c}\\Pi(T)=1&(pk,vk)\\leftarrow\\mathcal{G}(1^{\\mu})\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}(vk,\\pi_{i+1},\\mathcal{S}_{t+1})\\neq 1&\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(\\mathcal{S}_{t+1},\\pi_{i+1},T)\\leftarrow\\mathrm{PG}(\\Pi,pk,\\mathcal{A},\\mathcal{P})\\end{array} \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can think of <span class="math">\\mathcal{A}</span> as providing <span class="math">\\mathcal{S}_{i},\\mathcal{S}_{i+1}</span> and local information <span class="math">\\{t,t_{CB}\\}</span>, with <span class="math">\\mathcal{P}</span> providing proof <span class="math">\\pi_{i+1}</span> through ProofGen (PG). From (6), we know that this is a valid state transition for our predicate, so remains to show that the transcript up to <span class="math">\\mathcal{S}_{i}</span> is compliant. By the Proof of Knowledge property there exists an extractor <span class="math">\\mathbb{E}_{\\mathcal{P}}(pk,\\mathcal{S}_{i})\\rightarrow T_{i}</span> with <span class="math">out(T_{i})=\\mathcal{S}_{i}</span> and <span class="math">\\Pi(T_{i})=1</span> with high probability <span class="math">1-\\mathrm{negl}(\\mu)</span>. This means that <span class="math">\\Pi(T)=1</span> as all transitions are valid with high probability and so since <span class="math">\\mathcal{V}(vk,\\mathcal{S}_{i},\\pi_{i})=1</span> the adversary cannot activate (f) to win the game non-negligibly.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">G.2 Correctness</h3>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The adversary only changes the state when they call AddTransactions and RequestTransactions. We assume they perform <span class="math">N</span> calls and submit <span class="math">\\{t^{i},t^{i}_{CB}\\}_{i=1}^{n}</span> at each step to set <span class="math">\\mathcal{S}_{i}\\rightarrow\\mathcal{S}_{i+1}</span>. Since NewState calls <span class="math">\\mathcal{P}</span> to generate the transition at every step and we know that <span class="math">\\forall i\\in[N],\\text{VerifyState}(pp,\\mathcal{S}_{i},\\pi_{i})=1</span>, the transcript T recording these updates satisfies <span class="math">\\Pi(\\mathrm{T})=1</span> with high probability. From here we presume without loss of generality that every state <span class="math">\\mathcal{S}_{i}</span> is consistent with <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300"><span class="math">C</span> measures how much value <span class="math">\\mathcal{A}</span> has transferred to honest parties in <span class="math">\\mathsf{ADDR}</span>, <span class="math">D</span> how many coinbase transactions <span class="math">\\mathcal{A}</span> has won, and <span class="math">E</span> how much money they have received from honest nodes. Since this cannot hold if balance is always conserved, we look at the possible options:</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Option 1:</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The adversary has been able to use some <span class="math">\\mathrm{PK}\\in\\mathsf{ADDR}</span> in AddTransactions. However, <span class="math">\\mathcal{A}</span> only has oracle access to signatures of <em>other</em> messages from <span class="math">\\mathrm{PK}\\in\\mathsf{ADDR}</span> so recreating one it has not seen non-negligibly would violate the security of the signature scheme. In order to validate a transaction, the adversary needs to sign a message including the nonce <span class="math">n</span> of the last block that modified the account, which is always different with high probability. Therefore they would have to generate a signature for a unique message $m=\\mathrm{addr}_{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{addr}_{r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{2}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n<span class="math">, which has not been seen before in a query to RequestTransactions, as </span>n<span class="math"> always updates when a transaction is processed requiring a new </span>m$ even if all other parameters remain the same.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-69" class="text-base font-medium mt-4">Option 2:</h6>

    <p class="text-gray-300">Balance is not conserved in at least one transaction. Since <span class="math">\\Pi(T)=1</span>, this is immediately false with high-probability since all transactions added were valid and thus conserve balance between accounts by the requirements of ValidState.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Option 3:</h6>

    <p class="text-gray-300">There exists a different compliant transcript <span class="math">\\mathrm{T}_{2}</span> with the same value for <span class="math">\\mathcal{S}_{i}</span> for some <span class="math">i</span>. This would mean that transactions valid for <span class="math">\\mathrm{T}_{2}</span> could be verified by <span class="math">\\mathrm{T}</span> at the <span class="math">i</span>-th step and thus violate the required expression. However, by design <span class="math">\\mathcal{S}_{i}</span> is the root of a Merkle tree based on <span class="math">\\mathcal{H}</span>, which is a collision-resistant hash function. Suffices to show that a different transcript would imply a collision in <span class="math">\\mathcal{H}</span>.</p>

    <p class="text-gray-300">Since the two transcripts differ, there exists a first node <span class="math">j</span> in which they have at least one differing transaction. Let the two resulting Merkle tree roots be <span class="math">\\mathrm{root}(T^{<em>}(j))</span> and <span class="math">\\mathrm{root}(T(j))</span> after that update. Since the transactions were different, the two trees will differ in at least one leaf by <span class="math">l\\neq l^{</em>}</span> and have that <span class="math">\\mathrm{root}(T^{<em>}(j))\\neq\\mathrm{root}(T(j))</span>. Since the predicate recognizes Tree(BLOCK-V), we store the account Merkle tree root <span class="math">\\mathrm{root}(T(i))</span> in the <span class="math">i</span>-th leaf of another Merkle tree whose root is <span class="math">\\mathcal{S}_{i}</span> for the <span class="math">i</span>-th step. This means that there exists an authentication path from <span class="math">\\mathrm{root}(T^{</em>})</span> and <span class="math">\\mathrm{root}(T)</span> to the same <span class="math">\\mathcal{S}_{i}</span>. Since <span class="math">l\\neq l^{<em>}</span> and <span class="math">\\mathrm{root}(T^{</em>}(j))\\neq\\mathrm{root}(T(j))</span>, this is a contradiction. ∎</p>

    <h2 id="sec-71" class="text-2xl font-bold">Appendix H Proof of Theorem 2</h2>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume that a blocks are found in a Poisson process with a mean of <span class="math">\\lambda=1</span> and an individual miner can check one puzzle solution in time <span class="math">\\tau</span>. Consider the expected number of blocks this individual miner is able to check before the network broadcasts a solution. A block will be found by the network in less than time <span class="math">\\tau</span> with probability:</p>

    <p class="text-gray-300"><span class="math">\\int_{0}^{\\tau}e^{-x}dx=1-e^{\\tau}.</span></p>

    <p class="text-gray-300">In this case, the miner will not even finish checking a single block. If the network does not broadcast a block within time <span class="math">\\tau</span>, the miner will check at least one block. The Poisson process then repeats, since it is memoryless. So the expected number of blocks checked is:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{E}_{blocks}</span> <span class="math">=(1-e^{\\tau})\\cdot 0+e^{-\\tau}\\cdot(1+\\mathrm{E}_{blocks})</span> <span class="math">e^{\\tau}\\cdot\\mathrm{E}_{blocks}</span> <span class="math">=1+\\mathrm{E}_{blocks}\\mathrm{E}_{blocks}</span> <span class="math">=\\frac{1}{e^{\\tau}-1}.</span></p>

    <p class="text-gray-300">If no partially-checked solutions were wasted, the miner would always expect to check <span class="math">\\frac{1}{\\tau}</span> solutions. Thus, the fraction of wasted work is:</p>

    <p class="text-gray-300"><span class="math">1-\\frac{\\frac{1}{e^{\\tau}-1}}{\\frac{1}{\\tau}}=1-\\frac{\\tau}{e^{\\tau}-1}.</span></p>

    <p class="text-gray-300">∎</p>`;
---

<BaseLayout title="Proof of Necessary Work: Succinct State Verification with Fa... (2020/190)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/190
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
