---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/238';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On the Power of Polynomial Preprocessing: Proving Computations in Sublinear Time, and More';
const AUTHORS_HTML = 'Matteo Campanelli, Mario Carrillo, Ignacio Cascudo, Dario Fiore, Danilo Francati, Rosario Gennaro';

const CONTENT = `    <p class="text-gray-300">Matteo Campanelli^{1}, Mario Carrillo^{2}, Ignacio Cascudo^{3}, Dario Fiore^{3}, Danilo Francati^{4}, and Rosario Gennaro^{5}</p>

    <p class="text-gray-300">^{1} Offchain Labs ^{2} Universitat Rovira i Virgili ^{3} IMDEA Software Institute ^{4} Royal Holloway University of London ^{5} The City College of New York</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Cryptographic proof systems enable a verifier to be convinced of a computation’s correctness without re-executing it; common efficiency requirements include both succinct proofs and fast verification. In this work we put forth the general study of cryptographic proof systems with <em>sublinear</em> proving time (after a preprocessing).</p>

    <p class="text-gray-300">Prior work has achieved sublinear proving only for limited computational settings (e.g., vector commitments and lookup arguments), relying on specific assumptions or through non-black-box use of cryptographic primitives. In this work we lift many of these limitations through the systematic study of a specific object: polynomial commitments (PC) with sublinear proving time, a choice motivated by the crucial role that PC play in the design of efficient cryptographic schemes.</p>

    <p class="text-gray-300">We show a simple construction of a PC with sublinear prover based on any vector commitment scheme (VC) and any preprocessing technique for fast polynomial evaluation. We prove that this PC satisfies <em>evaluation binding</em>, which is the standard security notion for PC, and show how to expand our construction to achieve the stronger notion of knowledge soundness (extractability).</p>

    <p class="text-gray-300">Next, we study applications of PCs with sublinear prover. The first one is to construct <em>index-efficient</em> SNARKs, that are SNARKs where the prover is sublinear, after preprocessing, in the size of the index (i.e., the NP-relation describing the proven statement). We propose a method to transform a class of standard Polynomial Interactive Oracle Proofs (PIOPs) into index-efficient PIOPs, obtaining two results that advance the state of the art: the first lookup argument for unstructured tables in which the prover is sublinear in the size of the table, while making only black-box use of a VC and thus allowing instantiations from generic assumptions such as collision-resistant hash functions, and the first transparent SNARK for circuits where the prover is sublinear in the number of addition gates. Finally, our last application is a transformation that builds <em>UC-secure</em> SNARKs from simulation-extractable ones, with an approximately linear overhead in proving time (as opposed to quadratic in prior work).</p>

    <p class="text-gray-300">Table of Contents</p>

    <p class="text-gray-300">On the Power of Polynomial Preprocessing: ... 1 Matteo Campanelli, Mario Carrillo, Ignacio Cascudo, Dario Fiore, Danilo Francati, and Rosario Gennaro 1 Introduction ... 4 1.1 Our Results ... 5 1.2 Overview of our techniques ... 6 1.3 Related Work ... 10 2 Preliminaries ... 11 2.1 Polynomial Commitment ... 12 2.2 Vector Commitments ... 13 2.3 SNARKs for Indexed Relations ... 14 3 Polynomial Preprocessing Schemes ... 14 3.1 Kedlaya-Umans technique as PP scheme ... 16 4 Polynomial Commitments with Fast Opening ... 17 4.1 Evaluation Binding (VC-based) Polynomial Commitment with Fast Opening ... 18 4.2 Beyond Evaluation Binding ... 20 5 Index-Efficient SNARKs ... 20 5.1 Index-Efficient PIOPs and Applications to Index-Efficient SNARKs ... 21 5.2 Our Construction of Index-Efficient PIOPs ... 23 5.3 Application to Table-Efficient Lookup Arguments ... 25 5.4 Application to Index-Efficient SNARKs for Circuits ... 26 6 Witness-Succinct UC SNARKs with Nearly Optimal Proving Time ... 28 6.1 Instantiating our Hybrid Construction ... 31 6.2 Our Main Result on Succinct UC-NIZKs ... 32 A Further Preliminaries ... 37 A.1 Definitions of Polynomial Commitments ... 37 A.2 Definitions of Vector Commitments ... 38 B Lack of Strong Evaluation Binding of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> ... 38 C Knowledge Sound (SNARK-based) Polynomial Commitment with Fast Opening ... 41 D Supporting Material for UC SNARKs ... 43 D.1 UC Framework ... 43 D.2 (Succinct) Non Interactive Zero-Knowledge Proofs ... 44 D.3 Special Properties of Polynomial Commitments and Polynomial Encoding Schemes <span class="math">\\left[\\mathrm{GKO}^{+}23,\\mathrm{BCC}^{+}24\\right]</span> ... 46 D.4 Additional Relevant Cryptographic Preliminaries ... 49 D.5 The compiler <span class="math">\\Pi_{\\mathsf{GKOPTT}}</span> of <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> ... 51 E Supporting Proofs ... 52 E.1 Proof of Theorem 4 ... 52 E.2 Proof of Lemmas 1 and 2 ... 54 E.3 Proof of Lemma 3 ... 58</p>

    <p class="text-gray-300">F Our “Hybrid” Construction and Other Instantiations of the <span class="math">\\mathrm{[GKO^{+}23]}</span> Compiler in Literature</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3</li>

    </ul>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Cryptographic proof systems allow a weak machine <span class="math">\\mathcal{V}</span> to be persuaded by a (potentially malicious) prover <span class="math">\\mathcal{P}</span> that a computation <span class="math">C</span> produces a specific output on some input <span class="math">x</span>. Efficient proofs typically require both <em>low</em> communication complexity (e.g., that the “certificate” of the computation be short) and verification efficiency. In particular, we are usually interested in the verifier working sublinearly in the complexity <span class="math">T</span> of the computation <span class="math">C</span>. This efficiency profile is possible, naturally, only after the verifier has performed (once and for all) a preprocessing stage of the computation <span class="math">C</span>, of which it keeps a short digest (e.g., a verification key).</p>

    <p class="text-gray-300">In this work, we tackle the following research direction:</p>

    <p class="text-gray-300"><em>Is it possible to build proof systems where the prover can also run in time sublinear in <span class="math">T</span> (after a preprocessing)?</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This seemingly paradoxical property <em>already</em> appears in the literature, albeit with some limitations. For example, in <em>vector commitments</em> (VCs) <em>[x10]</em>, which can be viewed as succinct arguments that a certain <span class="math">v</span> is the <span class="math">i</span>-th value of a committed vector, one can precompute the opening proofs for all positions in such a way that, at proving time, only the correct proofs needs to be fetched. Some schemes even support a nontrivial form of this functionality to generate succinct proofs for arbitrary subsets of positions <em>[x1, TAB^{+}20, CFG^{+}20]</em>. However, VCs are succinct arguments with a limited expressivity because their statements are the positions, i.e., integers from a polynomial-size set. In <em>lookup arguments</em>, which allow proving that each entry of a committed vector <span class="math">\\mathbf{v}</span> is in a large committed table <span class="math">\\mathbf{t}</span>, it is a desirable feature that the proving time be sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. However, in the state of the art, this efficiency profile is only achieved by constructions that make non-black box use of cryptographic schemes (e.g., due to encoding Merkle trees in a circuit <em>[BFR^{+}13]</em> or to recursion <em>[x2]</em>), by pairing-based schemes <em>[ZBK^{+}22, ZGK^{+}22, x11, x12, x13]</em>, or in the special case of structured tables <em>[x29]</em>. The same limitations of lookup arguments apply to existing SNARKs for RAM computation with space complexity </span>S<span class="math"> and time complexity </span>T=o(S)<span class="math">, in which one wishes the proving time to be sublinear in </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This state of affairs shows that more is to be understood about the feasibility of succinct arguments with sub-linear prover. In particular, a desirable goal is to achieve sublinear proving for relatively general functionalities, with constructions that make black-box use of cryptographic primitives and can be instantiated from a variety of assumptions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this work, we achieve this goal by focusing on a specific type of computation: <em>proving evaluations of committed polynomials</em>. Polynomial commitment schemes (PC) <em>[x24]</em> are a cryptographic primitive that allows a prover to commit to a polynomial <span class="math">f</span> with a string <span class="math">\\mathsf{cm}</span> (commitment) and subsequently produce a proof of the correctness <span class="math">\\pi_{x}</span> of its evaluation <span class="math">y=f(x)</span> at any point <span class="math">x</span>. Consider the case of a polynomial <span class="math">f</span> with <span class="math">m</span> variables of degree less than <span class="math">d</span> in each variable, which can be described by a vector of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d^{m}<span class="math"> coefficients. The crucial property of polynomial commitments is succinctness: both the commitment string and the evaluation proofs must be “short”, i.e., sublinear in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (and ideally, also the verification time should be sublinear in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">PCs have already proved to have a central role in the design of SNARKs, and have many other applications (e.g., verifiable secret sharing). For this reason, we believe that the study of PCs with sublinear proving time can be a stepping stone towards the achievement of sublinear</p>

    <p class="text-gray-300">proving for more general computations, and a <em>valuable tool</em> with applications beyond the specifics of cryptographic proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Research in PC has been focused on improving the efficiency of the verifier, whereas it is widely accepted that the prover must run at least linearly in the size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d^{m}<span class="math"> of the </span>m<span class="math">-variate polynomial. In fact, this linear-time behavior appears unavoidable in order to, at the very least, compute the output </span>y=f(x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this work, we challenge this state of affairs by investigating the <em>design</em> and the <em>applications</em> of polynomial commitments with a sublinear prover. In such a scheme, at commitment time the prover also performs a preprocessing of the polynomial <span class="math">f</span> which results in some auxiliary information aux. Later, when asked to prove an evaluation of <span class="math">f</span> at an input <span class="math">x</span>, the prover can use aux to quickly produce the evaluation <span class="math">y=f(x)</span> and its proof in sublinear time. Preprocessing schemes to quickly evaluate polynomials have been known in the complexity literature for some time now, e.g. the work by Kedlaya and Umans <em>[x14, x15]</em> (KU in short) that we use in this paper. Our challenge was to make sure we could quickly compute the proofs too, and achieve provable and meaningful notions of security for the resulting PC. In contrast to vector commitments or lookup arguments, where one could think of computing a proof for each position in the preprocessing stage, the challenge in PC is that the number of evaluation points is exponential, that is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R^{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for a polynomial defined over a ring </span>R$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">Constructing PCs with sublinear prover: Towards finding constructions of PCs with sublinear proving time, we observe that the recent work of Ateniese et al. <em>[ABC^{+}24]</em> proposes a novel cryptographic scheme, dubbed verifiable data structure for univariate polynomial evaluations, which can also be seen as a PC for univariate polynomials satisfying a weaker security notion—<em>weak evaluation binding</em>—which states that an adversary should not be able to produce valid proofs for a false evaluation <span class="math">y\\neq f(x)</span> and with respect to <em>honestly</em> generated commitments to <span class="math">f</span>. Their construction achieves sublinear proving time by combining the preprocessing-based fast evaluation techniques for univariate polynomials of Kedlaya and Umans <em>[x14, x15]</em> together with a vector commitment.</p>

    <p class="text-gray-300">In our work, we formalize a construction of PC with sublinear proving time by generalizing the construction of <em>[ABC^{+}24]</em> to the case of multivariate polynomials (this is crucial for some of our applications) and by proving that it satisfies the standard security notion of PC, <em>evaluation binding</em>. The latter guarantees that it is hard to generate two (possibly malicious) proofs that are accepted with respect to the same (possibly malicious) commitment, the same point evaluation point <span class="math">x</span>, but claiming distinct outputs <span class="math">y\\neq y^{\\prime}</span>. Since evaluation binding may be insufficient in some applications, we also show how to extend the PC construction to achieve stronger security, specifically knowledge soundness, albeit this comes at the price of employing a SNARK.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This PC scheme has fast openings, meaning that opening proofs can be computed in sublinear time in the description of the polynomial <span class="math">f</span>. In particular, for a univariate polynomial <span class="math">f</span> of degree at most <span class="math">d-1</span> (i.e., $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d<span class="math">), this means proving in time </span>\\mathsf{poly}(\\log d)<span class="math">, whereas, for an </span>m<span class="math">-variate polynomial </span>f<span class="math"> of degree at most </span>d-1<span class="math"> in each variable (i.e., </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d^{m}<span class="math">), it means proving in time </span>\\mathsf{poly}(d,m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Section 1.2 for an informal description of the technical challenges involved in formalizing the construction in <em>[ABC^{+}24]</em> as a PC and extending it to the multivariate case.</p>

    <p class="text-gray-300">Index-Efficient SNARKs: We present an application of PCs with sublinear prover to construct SNARKs where the prover can be sublinear, after preprocessing, in the size of the NP relation – what</p>

    <p class="text-gray-300">is usually referred to as the “index”. We call this property <em>index-efficiency</em>. To build index-efficient SNARKs, we refine the popular framework to build SNARKs from polynomial interactive oracle proofs (PIOPs) and PCs <em>[CHM^{+}20, x1]</em> showing how index-efficient SNARKs can be constructed black-box from index-efficient PIOPs and PCs with sublinear prover. Next, to instantiate this framework, our main technical contribution is a method to transform a class of standard PIOPs into index-efficient PIOPs. Interestingly, the combination of all our results yields two novel applications.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- *Application 1: new general lookup arguments with $o\\bigl{(}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bigr{)}<span class="math"> prover<em>: we present the first lookup argument for unstructured tables in which the prover is sublinear in the size of the table </span>T$, while making only black-box use of a VC and thus allowing instantiations from generic assumptions such as collision-resistant hash functions. As mentioned earlier in the paper, prior lookup arguments with sublinear provers make non-black-box use of cryptographic schemes </em>[BFR^{+}13, x2]<em>, rely on pairings </em>[ZBK^{+}22, ZGK^{+}22, x12, x11]<em>, or can only deal with structured tables </em>[x26]*.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Application 2: transparent SNARKs for circuits with <span class="math">o\\bigl{(}\\#\\mathsf{gates}(+)\\bigr{)}</span> prover</em>: Our second application is the first universal SNARK for circuits (with transparent setup) in which the prover is sublinear in the number of addition gates. This also gives us the first SNARK of this kind with a <em>transparent</em> setup. Prior SNARKs in which the prover running time does not depend on the number of addition gates are either circuit-specific <em>[x13, x15]</em> or, if universal, (<em>[GKM^{+}18]</em>) do rely on structured reference strings that need a trusted setup.</li>

    </ul>

    <p class="text-gray-300">Witness-Succinct UC-SNARKs: We present an application of PCs with sublinear prover, like the ones we constructed above, to build a compiler from simulation-extractable SNARKs to UC-secure SNARKs, in which the prover is quasilinear in the size of the witness. We design our compiler by extending the one of Ganesh et al. <em>[GKO^{+}23]</em>. However, while the compiler of <em>[GKO^{+}23]</em> yields schemes with quadratic proving time, ours achieves approximately linear (i.e. <span class="math">O(n^{1+\\epsilon})</span> proving time.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Overview of our techniques</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PCs with fast opening. Kedlaya and Umans (KU) <em>[x20, x21]</em> show how a univariate polynomial <span class="math">f</span> with <span class="math">d</span> coefficients can be preprocessed and stored as a data structure <span class="math">\\mathsf{DS}</span> of <span class="math">O(d^{1+\\epsilon})</span> elements. Following this step, it is possible to evaluate <span class="math">y=f(x)</span> by simply querying <span class="math">\\mathsf{DS}</span> on <span class="math">\\mathsf{poly}(\\log d)</span> points (see Theorem 3 for the precise statement). In <em>[ABC^{+}24]</em>, Ateniese et al. show ho to make the KU-based data structure verifiable by using a vector commitment (VC) on top of it. The idea is to use the VC to commit to the data structure <span class="math">\\mathsf{DS}</span> encoding the preprocessing of the polynomial <span class="math">f</span>. At evaluation time, to prove <span class="math">y=f(x)</span>, the prover opens the <span class="math">k=\\mathsf{poly}(\\log d)</span> values required to evaluate <span class="math">f</span> at <span class="math">x</span>, and the verifiers run the KU evaluation algorithm themselves using those <span class="math">k</span> points and check a VC opening for each of them. If the VC has (poly)logarithmic opening proofs, then the entire opening proof for our PC is sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, and so is the running time of the verifier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this paper, we extend this PC construction to work for <span class="math">m</span>-variate polynomials of degree <span class="math">d</span>, relying on the KU’s preprocessing result for multivariate polynomials. The complexity of KU’s technique in this case has been explored in <em>[x22]</em>, showing that one evaluation can be computed with <span class="math">\\mathsf{poly}(d,m)</span> queries to the data structure <span class="math">\\mathsf{DS}</span> obtained after preprocessing, and that the size of <span class="math">\\mathsf{DS}</span> is <span class="math">d^{m}\\cdot\\mathsf{poly}(d,m)\\cdot O(m^{m})</span> (see Theorem 2). Observe that the query complexity <span class="math">\\mathsf{poly}(d,m)</span> is sublinear in the size of the multivariate polynomial $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d^{m}<span class="math">. In our PC scheme, as in <em>[ABC^{+}24]</em>, we use a VC to commit to </span>\\mathsf{DS}<span class="math"> and to open the </span>\\mathsf{poly}(d,m)$ values needed to compute the evaluation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We highlight that, in the multivariate case, <span class="math">\\mathsf{DS}</span> is not of polynomial size in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for every choice of </span>d<span class="math"> and </span>m<span class="math"> (a necessary requirement for having a polynomial-time PC). This is because the size of the data structure depends on the factor </span>m^{m}<span class="math">, as described above. To avoid this issue, we show a selection of parameters that yield a PC with polynomial-time preprocessing time and space. We provide more details in Section 3, where we focus in particular on going beyond constant arity </span>m$. Concretely, we show the following consequence of Theorem 2 and our PC construction:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-5" class="text-base font-medium mt-4">Corollary 2 (Informal).</h6>

    <p class="text-gray-300">Assuming collision resistance hash functions, there exists a PC scheme for polynomials in <span class="math">\\mathbb{Z}_{q}[X_{1},\\ldots,X_{m}],\\ q\\approx 2^{\\lambda}</span>, with the following running times</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For univariate polynomials (<span class="math">m=1</span>) of degree at most <span class="math">d\\in\\mathsf{poly}(\\lambda)</span>, the committing time is <span class="math">\\mathsf{poly}(\\lambda,\\log d)\\cdot O(d^{1+\\epsilon})</span> and the opening time is <span class="math">\\mathsf{poly}(\\lambda,\\log d)</span> for every positive constant <span class="math">\\epsilon&gt;0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For multivariate polynomials <span class="math">f</span> where <span class="math">\\mathsf{deg}_{1}(f),\\ldots,\\mathsf{deg}_{m}(f)&lt;d</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=d^{m}=\\mathsf{poly}(\\lambda)<span class="math"> and where </span>d=\\log^{3/\\epsilon}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> (which implies </span>m=\\frac{\\epsilon}{3}\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/(\\log\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">) for an (arbitrary) constant </span>\\epsilon>0<span class="math">, we have committing time </span>\\mathsf{poly}(\\lambda,m,d)\\cdot O(d^{m(1+\\epsilon)})<span class="math"> and opening time </span>\\mathsf{poly}(\\lambda,m,d)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The result above does not directly cover the relevant case, for many applications, of multilinear <span class="math">m</span>-variate polynomials (<span class="math">d=2</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{m}=\\mathsf{poly}(\\lambda)$); however, we will show how it can still be used in a concrete application in such a setting, namely in our construction of index-efficient PIOPs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One of our contributions with respect to this construction of PC with sublinear prover is to prove that it satisfies <em>evaluation binding</em>, the standard security notion for PCs, which informally says that for any committed string <span class="math">\\mathsf{cm}</span> (even a maliciously generated one), it is infeasible to produce valid openings for the same evaluation point <span class="math">x</span> and two different outputs. In our PC construction, this security notion is inherited by the <em>position binding</em> security property of the underlying VC, which guarantees that given a committed vector <span class="math">\\mathsf{DS}</span> it is infeasible to find an index <span class="math">i</span> and two different valid openings of <span class="math">\\mathsf{DS}</span> at <span class="math">i</span> (see Theorem 4).</p>

    <p class="text-gray-300">Stronger notions of security for PC can be defined as follows: <em>strong evaluation binding</em> <em>[x18, x10]</em> says that, for any sequence of valid opening proofs for evaluations <span class="math">y_{i}=f(x_{i})</span>, there must exist a (univariate or multivariate depending on the polynomial space) polynomial <span class="math">f</span> of degree <span class="math">d</span> such that <span class="math">f(x_{i})=y_{i}</span>. Even stronger is <em>knowledge soundness</em> which says that such polynomial can be <em>extracted</em> from such proofs.</p>

    <p class="text-gray-300">We first show (Appendix B) that our combination of KU with VC, does <em>not</em> satisfy strong evaluation binding. Intuitively the reason is that there are many more possible tables <span class="math">\\mathsf{DS}</span> than polynomials of degree <span class="math">d</span> and therefore simply committing to a table does not readily identify a <em>single</em> polynomial. We then discuss (Appendix C) possible ways to achieve strong evaluation binding and/or knowledge soundness by augmenting the commitment phase with a SNARK to guarantee that the <span class="math">\\mathsf{DS}</span> committed by the VC is indeed the result of a correctly executed preprocessing on the polynomial <span class="math">f</span>.</p>

    <p class="text-gray-300">Index-Efficient SNARKs. Our first step towards constructing index-efficient SNARKs is an adaptation of the popular framework for building SNARKs from PIOPs and PCs <em>[CHM^{+}20, x1]</em>. In brief, in a PIOP a computation <span class="math">F</span>, also known as the “index”, is “arithmetized” and preprocessed into a small set of polynomials to which the verifier has oracle access. Next, prover and verifier interact: the prover sends oracle polynomials and the verifier sends random challenges. Finally, the</p>

    <p class="text-gray-300">verifier can query, on a small set of points, all the polynomials sent by the prover as well as the index polynomials. The compilation of the idealized PIOP into a succinct argument consists into replacing the oracles by commitments, while the queries of the verifier are replaced by having the prover evaluate the polynomials and prove these evaluations with the PC scheme.</p>

    <p class="text-gray-300">To achieve index-efficiency, we adapt this compiler with three main changes. (i) We assume that the PIOP is index-efficient, namely the PIOP prover is sublinear in the size of the index. (ii) We commit to the index polynomials using a PC scheme with sublinear prover. (iii) For every query of the PIOP verifier to the index polynomials, we let the prover use fast-evaluation techniques to compute the result and the sub-linear proof generation to compute the evaluation proof.</p>

    <p class="text-gray-300">Equipped with this framework and with our PC construction, then we turn our attention to constructing index-efficient PIOPs. To take advantage of existing literature, we tackle the problem by proposing a transformation from a class of standard PIOPs to index-efficient PIOPs. Roughly speaking, our transformation applies to PIOPs in which the prover algorithm can be implemented using a small number of evaluations of the index polynomials. While in the original PIOP each of these evaluations must be fully computed by the prover (in at least linear time), in our case we exploit preprocessing techniques and replace them by fast evaluations, e.g., using <em>[x13]</em>. This step is clearly natural. However, the main technical obstacle is that PIOPs normally work with multilinear polynomials (which is the most popular case in the literature) but the known results for preprocessing schemes only capture either univariate polynomials or multivariate polynomials with a very specific choice of parameters <span class="math">m</span> and <span class="math">d</span>, which in particular requires a degree larger than <span class="math">1</span> to achieve efficiency.</p>

    <p class="text-gray-300">For this reason, we additionally make the assumption that our starting class of standard PIOPs satisfy the property that, when we replace each multilinear polynomial produced by the indexer algorithm by a polynomial of degree <span class="math">d&gt;1</span> that agrees with it when evaluated on the boolean hypercube, the PIOP is still correct and knowledge sound. This assumption seems to be a natural property satisfied by most PIOP constructions, e.g., <em>[x20, x1, x12]</em>. See Theorem 6 for the concrete statement of these requirements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, the idea of the transformation (Construction 2) is that we can use a “change of basis” technique as follows. We encode a multilinear <span class="math">n</span>-variate polynomial <span class="math">\\tilde{f}</span> with a degree-<span class="math">d</span> <span class="math">m</span>-variate polynomial <span class="math">\\hat{f}</span> where <span class="math">m&lt;n</span> and <span class="math">(d+1)^{m}=2^{n}</span>. We show how to construct a degree-<span class="math">d</span> polynomial <span class="math">f</span> in <span class="math">n</span> variables such that: (a) <span class="math">f</span> agrees with <span class="math">\\tilde{f}</span> on the boolean hypercube; (b) an evaluation <span class="math">f(\\mathbf{z})</span> can be efficiently obtained from an evaluation <span class="math">\\tilde{f}(G(\\mathbf{z}))</span>, where <span class="math">G</span> is a linear function. These two properties yield the desired outcome. By (a) and our assumptions on the PIOP we can replace <span class="math">\\tilde{f}</span> by <span class="math">f</span> in the PIOP while preserving correctness and soundness (albeit with a larger loss $d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By property (b) we get fast evaluations since we have freedom to choose the parameters <span class="math">m</span> and <span class="math">d</span> of <span class="math">\\tilde{f}</span> in a suitable way to allow fast evaluation techniques.</p>

    <p class="text-gray-300">We refer to Section 5.2 for more details.</p>

    <p class="text-gray-300">Table-Efficient Lookup Arguments. Our application to table-efficient lookup arguments derives by observing that (a slight generalization of) the GeneralizedLasso protocol from <em>[x17]</em> is a PIOP that satisfies all the conditions needed for our transformation. In particular, in this protocol the indexer produces a multilinear polynomial encoding of the (possibly unstructured) table. This observation, in combination with all the results described earlier yields the first table-efficient lookup argument for unstructured tables that makes only black-box use of a VC and thus allows instantiations from generic assumptions such as collision-resistant hash functions.</p>

    <p class="text-gray-300">Index-Efficient SNARKs for Circuits. The main ingredient that yields our application to index-efficient SNARKs for circuits, where the prover is sublinear in the number of addition gates, is an index-efficient PIOP for linear checks. In this PIOP, after a preprocessing of the “index” matrix <span class="math">\\mathbf{M}</span> of dimension <span class="math">N\\times N</span>, one can prove that <span class="math">\\mathbf{M}\\cdot\\mathbf{z}=\\mathbf{v}</span> by running in time <span class="math">N\\mathsf{polylog}(N)</span>, that is sublinear in <span class="math">N^2</span>. We obtain this index-efficient PIOP for linear checks by applying our transformation to a PIOP based on Thaler’s matrix multiplication protocol [Thaler13] where, we show, it is possible to implement the prover using <span class="math">O(N\\log N)</span> evaluation calls of the multilinear polynomial <span class="math">\\tilde{M}(\\cdot)</span> interpolating <span class="math">\\mathbf{M}</span>. Then we can replace each of these calls with a fast evaluation that costs <span class="math">\\mathsf{polylog}(N)</span>. Finally, we obtain the index-efficient SNARK for circuits by using the index-efficient PIOP for linear checks to build an index-efficient PIOP for R1CS where the prover is sublinear in the number of nonzero entries of the index matrices, and then applying our index-efficient compiler that uses PCs with fast openings.</p>

    <p class="text-gray-300">Efficient SE-to-UC SNARK compiler The Universal Composability (UC) framework is considered the “gold-standard” of security for cryptographic protocols. It ensures that protocols remain secure even when composed with others in arbitrary environments, which is a crucial property for SNARKs since they are almost always used in the context of larger protocols. However, a fundamental challenge arises when trying to prove UC-security for SNARKs: the “knowledge extractor” has to be “straight-line” (non-rewinding) and black-box (i.e., having only access to the I/O of the adversary). Prior work has tackled this problem but commonly it suffers from losing succinctness or being restricted to arguments with a very specific structure.</p>

    <p class="text-gray-300">Our starting point instead is the generic compiler by Ganesh et al. [GKO+23] which builds a UC-secure witness-succinct SNARK generically from any simulation-extractable one. Their approach can be informally described as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The witness <span class="math">w</span> is represented as a polynomial <span class="math">f_w</span> via a redundant randomized encoding, which is committed with a PC <span class="math">\\mathsf{cm}_w = \\mathsf{PC}.\\mathsf{Com}(f_w)</span>;</li>

      <li>The SE-SNARK is used to prove that <span class="math">w</span> is a valid witness and that <span class="math">\\mathsf{cm}_w</span> is a valid PC commitment to the correct randomized polynomial for <span class="math">w</span>;</li>

      <li><span class="math">r</span> evaluations of <span class="math">f_w</span> are provided to the verifier together with their evaluation proofs with respect to <span class="math">f_w</span></li>

    </ul>

    <p class="text-gray-300">In the last step <span class="math">r</span> is chosen small enough to guarantee succinctness of the final proof. Additionally the <span class="math">r</span> evaluations must satisfy a particular property meant to enforce a “proof of work” by the prover (generalizing Fischlin’s approach [Fischlin05]). This step requires the prover to actually evaluate <span class="math">f_w</span> at a linear number of points (to find the <span class="math">r</span> ones that satisfy the property – only this small fraction of them is revealed), and from this high number of queries, the extractor (which sees all the queries the prover makes, not just the <span class="math">r</span> revealed ones) can reconstruct the witness. No knowledge about <span class="math">w</span> is leaked due to two facts: (i) <span class="math">w</span> is encoded via a randomized polynomial, and <span class="math">r</span> is small enough;</p>

    <p class="text-gray-300">8 In the reduction from circuits to R1CS, the number of nonzero entries correspond to the number of addition gates.</p>

    <p class="text-gray-300">9 Here we are referring to two lines of works. The first adopts some form of encryption of the witness, making the proof size at least linear in witness size [ARS20,BS21,AGRS23,KZM+15]. Another line of work, like the recent [CF24], leverages the straight-line-extractability properties of Kilian-like constructions but is applicable only to arguments stemming from Interactive Oracle Proofs (an interactive form of PCPs [BCS16]).</p>

    <p class="text-gray-300">10 A SNARK is circuit-succinct if the proof is sublinear in the circuit size, and witness-succinct – which is the most stringent succinctness property – if it also sublinear in the witness size. Circuit-succinct UC-secure SNARKs were known before [GKO+23].</p>

    <p class="text-gray-300">(ii) the PC they use (KZG <em>[x10]</em>) has the “evaluation-hiding” property that an opening proof for a particular point reveals no information about the value of the polynomial at other points.</p>

    <p class="text-gray-300">This approach however blows up the complexity of the prover: evaluating <span class="math">f_{w}</span> at a linear number of points, without preprocessing, yields a quadratic total running time. A naive application of our sublinear opening PC does not work because the KU technique does not guarantee that our PC is evaluation-hiding (see Section 6). Therefore, we modify the <em>[GKO^{+}23]</em> compiler in two major ways:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To achieve hiding, we use a different <em>hybrid</em> encoding for the witness. We first encrypt it <span class="math">\\mathsf{ct}=\\mathsf{Enc}(\\mathsf{sk},w)</span> using any symmetric encryption scheme. We then encode <span class="math">\\mathsf{sk}</span> with a randomized polynomial <span class="math">g</span>, while the ciphertext <span class="math">\\mathsf{ct}</span> is instead encoded deterministically as a polynomial <span class="math">f</span> (e.g. by parsing it as coefficients over a field)</li>

      <li>We use two different PCs to commit to our hybrid encoding of the witness. The randomized polynomial <span class="math">g</span> is committed via KZG <em>[x10]</em>, while <span class="math">f</span> is committed using our KU-based PC with fast opening.</li>

    </ol>

    <p class="text-gray-300">Note that our scheme is approximately linear for the Prover since the openings of <span class="math">f</span> take sublinear time with our PC (note that the degree of <span class="math">g</span> is independent of the size of <span class="math">w</span> so those openings do not count), with the additional cost for the prover of <span class="math">O(n^{1+\\epsilon})</span> for preprocessing. Zero-Knowledge is preserved because (as in <em>[GKO^{+}23]</em>) the randomization of the encoding of <span class="math">\\mathsf{sk}</span> means that no knowledge is leaked about <span class="math">\\mathsf{sk}</span> even after <span class="math">r</span> evaluations are revealed, due also to the fact that <span class="math">\\mathsf{sk}</span> is committed with an evaluation-hiding PC. The <span class="math">r</span> evaluations may leak knowledge of the value <span class="math">\\mathsf{ct}</span> (since that is encoded deterministically, and the PC is not evaluation-hiding), but these amount to encryptions of <span class="math">w</span> under <span class="math">\\mathsf{sk}</span>; therefore, they hide <span class="math">w</span> since no further knowledge is leaked on <span class="math">\\mathsf{sk}</span>.</p>

    <p class="text-gray-300"><em>The reader can find an expanded version of our technical overview on our UC-SNARK applications at the beginning of Section 6.</em></p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As we discussed earlier, the KU polynomial preprocessing technique was introduced as a tool in the design of cryptographic protocols by Lin et al. who built a <em>Doubly Efficient Private Information Retrival (DEPIR)</em> scheme <em>[x14]</em>. A Private Information Retrieval (PIR) scheme, is a protocol between a Server holding a database <span class="math">\\mathsf{DB}</span> and a Client who queries <span class="math">\\mathsf{DB}</span> on an index <span class="math">i</span>. At the end of the protocol the Client learns <span class="math">\\mathsf{DB}(i)</span> while the Server has no information on what index was queried. The crucial property of PIR is that communication between the parties be sublinear in $N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{DB}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (otherwise the solution is trivial by having the Server send the entire </span>\\mathsf{DB}<span class="math"> to the Client). Before <em>[x14]</em> it was widely believed that any PIR scheme required the Server to work in </span>\\Omega(N)<span class="math"> steps, since if the Server did not read every item in the database, he would get information about </span>i<span class="math">. Surprisingly <em>[x14]</em> shows that by preprocessing </span>\\mathsf{DB}<span class="math"> into a data structure </span>\\mathsf{DS}_{\\mathsf{DB}}<span class="math"> using KU it is possible to answer a query by only looking at a </span>O(\\log^{c}N)<span class="math"> entries in </span>\\mathsf{DS}_{\\mathsf{DB}}$ yielding a ”doubly efficient” PIR for both Server and Client.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Ateniese et al. <em>[ABC^{+}24]</em> showed that the KU (univariate) technique can be used to improve the efficiency of <em>proofs of storage</em>. Assume that a storage provider needs to prove to a client that it is storing a file <span class="math">F</span>. One approach is to encode <span class="math">F</span> as a univariate polynomial <span class="math">f</span>. Then, by querying the polynomial at a random point, the client can be assured that the file is still stored (indeed, the file can theoretically be retrieved by querying a sufficient number of points to allow interpolation of <span class="math">f</span>). However, this approach requires the provider to read the entire file every time in order to evaluate</p>

    <p class="text-gray-300"><span class="math">f</span>. By using KU, the file is encoded into a larger data structure <span class="math">\\mathsf{DS}</span>, which allows the provider to answer in sublinear time.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Discussion and Future Work</h4>

    <p class="text-gray-300">On practical instantiations: We acknowledge that our work is unlikely to be <em>immediately</em> practical due to the large constants in the specific preprocessing scheme <em>[x10]</em> that we use. Given the many practical applications that motivated this work, and that we show can be built from PC with fast opening, it is an important research question to investigate different approaches for polynomial preprocessing, with the goal of getting schemes that are more practically feasible.</p>

    <p class="text-gray-300">More functionalities with sublinear proving? We showcase our framework for general relations provable in sublinear time, <em>index-efficient</em> PIOPs, by obtaining a new construction of table-efficient lookup arguments and index-efficient SNARK for circuits. Yet interesting open questions remain: Can we build index-efficient PIOPs for other relations that would be surprising to prove in sublinear time (and from relatively simple tools)? For what kinds of relations is it even conceivable to achieve sublinear proving?</p>

    <p class="text-gray-300">More properties/applications for commitments with fast openings? To go beyond evaluation binding, our PC construction must be augmented with a SNARK. Is that inherent, or can strong binding/extractability for PC with fast opening be achieved with simpler tools/weaker assumptions? What about hiding (which as we point out, does not readily hold for our scheme)? Can we build such a a commitment <em>directly</em> for <em>multilinear</em> polynomials, rather than go through the workaround we use for index-efficient PIOPs? What are other settings, beyond the one in this work—UC-NIZK compiler—where amortizing an expensive preprocessing yields a better efficiency overall?</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Notation</h4>

    <p class="text-gray-300">For any integer <span class="math">n\\geq 1</span>, define <span class="math">[n]=\\{1,\\ldots,n\\}</span>. We use <span class="math">\\lambda\\in\\mathbb{N}</span> to denote the security parameter. A function <span class="math">\\epsilon:\\mathbb{N}\\to\\mathbb{R}</span> is said to be <em>negligible</em>, denoted <span class="math">\\epsilon(\\lambda)\\in\\mathsf{negl}(\\lambda)</span> if for every positive polynomial <span class="math">p(\\cdot)</span> and all sufficiently large <span class="math">\\lambda</span> it holds that <span class="math">\\epsilon(\\lambda)&lt;1/p(\\lambda)</span>. A function <span class="math">p(\\lambda)</span> is polynomial, denoted <span class="math">p(\\lambda)\\in\\mathsf{poly}(\\lambda)</span>, if <span class="math">p(\\lambda)=O(\\lambda^{c})</span> for some constant <span class="math">c&gt;0</span>. In the context of cryptographic primitives we use a special notation to emphasize asymptotic behavior “independent” of the security parameter <span class="math">\\lambda</span>: we write <span class="math">f=O_{\\lambda}(g(n))</span> if there exists a fixed polynomial <span class="math">\\lambda^{c}</span> such that <span class="math">f=O(\\lambda^{c}\\cdot g(n))</span>. We denote by <span class="math">\\widetilde{O}_{\\lambda}(f(n))</span> quasi-linear running time, i.e. <span class="math">\\widetilde{O}_{\\lambda}\\big{(}f(n)\\mathsf{polylog}(f(n))\\big{)}</span> We say that an algorithm is probabilistic polynomial time (abbreviated <span class="math">PPT</span>) if its running time is bounded by a polynomial function <span class="math">p(\\lambda)</span>. For a finite set <span class="math">S</span>, we write <span class="math">a\\leftarrow\\!\\!s</span> <span class="math">S</span> to mean that <span class="math">a</span> is sampled uniformly at random from <span class="math">S</span>. For an algorithm <span class="math">\\mathcal{A}</span>, we write <span class="math">y\\leftarrow\\mathcal{A}(x)</span> to denote executing <span class="math">\\mathcal{A}</span> on input <span class="math">x</span> and assigning its output to <span class="math">y</span>. Given <span class="math">f:X\\to Y</span>and <span class="math">\\mathbf{v}=(v_{1},\\ldots,v_{n})\\subseteq X^{n}</span>, we denote by <span class="math">f(\\mathbf{v})</span> the vector in <span class="math">Y^{n}</span> obtained through element-wise evaluation of <span class="math">f</span> on <span class="math">\\mathbf{v}</span>. We denote by <span class="math">\\mathsf{polyFromCoeffs}(\\mathbf{v})</span> the polynomial <span class="math">p(X):=\\sum_{i=0}^{n-1}v_{i+1}X^{i}</span> whose coefficients are the elements of <span class="math">\\mathbf{v}</span>. An <em>indexed relation</em> <span class="math">\\mathcal{R}</span> is a set of tuples <span class="math">(\\mathfrak{i},\\mathtt{x};\\mathtt{w})</span> where <span class="math">\\mathfrak{i}</span> is the index, <span class="math">\\mathtt{x}</span> the statement and <span class="math">\\mathtt{w}</span> the witness. The language <span class="math">\\mathcal{L}(\\mathcal{R})</span> associated to a relation <span class="math">\\mathcal{R}</span> is the set of pairs <span class="math">(\\mathfrak{i},\\mathtt{x})</span> for which there exists a witness <span class="math">\\mathtt{w}</span> such that <span class="math">(\\mathfrak{i},\\mathtt{x};\\mathtt{w})\\in\\mathcal{R}</span>.</p>

    <p class="text-gray-300">Approximately-linear time. If an algorithm runs in time <span class="math">O_{\\lambda}(n^{1+\\epsilon})</span> in a parameter <span class="math">n</span> for any positive constant <span class="math">\\epsilon&gt;0</span>, we say that it runs in <em>approximately-linear time</em>. For sake of brevity,</p>

    <p class="text-gray-300">we often simply write that “an algorithm runs in time <span class="math">O_{\\lambda}(n^{1+\\epsilon})</span>” meaning implicitly “for any (unspecified) constant <span class="math">\\epsilon&gt;0</span>”.</p>

    <p class="text-gray-300">RAM model. Our work focuses on the application of preprocessing techniques to build fast and efficient schemes. Even if not directly specified, all efficiency properties and running times will be measured in the RAM model of computation, which allows an algorithm to run in time sublinear its input size.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 Polynomial Commitment</h3>

    <p class="text-gray-300">A polynomial commitment scheme allows a prover to commit to a (possibly multivariate) polynomial <span class="math">f\\in R[X_{1},\\ldots,X_{m}]</span>, producing a commitment value <span class="math">\\mathsf{cm}</span>, and then compute proofs <span class="math">\\pi_{x}</span> demonstrating that <span class="math">y</span> is the correct evaluation of the committed <span class="math">f</span> at an input <span class="math">x\\in R^{m}</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 1 (Polynomial Commitment <em>[x14]</em>).</h6>

    <p class="text-gray-300">A polynomial commitment scheme <span class="math">\\mathsf{PC}</span> for multivariate polynomials over a ring <span class="math">R</span> is defined by the following algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda},m,d)\\to\\mathsf{ck}</span>: On input the security parameter <span class="math">\\lambda</span>, the number of variables <span class="math">m</span>, and a bound <span class="math">d</span> for the degree of each variable, the setup algorithm outputs a public commitment key <span class="math">\\mathsf{ck}</span>, which implicitly defines the message space of the commitment scheme <span class="math">\\mathcal{P}_{m,d}=\\{f\\in R[X_{1},\\ldots,X_{m}]\\mid\\mathsf{deg}_{i}(f)&lt;d,\\forall i\\in[m]\\}</span>. <span class="math">\\mathsf{Com}(\\mathsf{ck},f;r)\\to(\\mathsf{cm},\\mathsf{aux})</span>: On input the commitment key <span class="math">\\mathsf{ck}</span>, a polynomial <span class="math">f\\in\\mathcal{P}_{m,d}</span>, and (possibly) a randomness <span class="math">r</span>, the commit algorithm outputs a commitment <span class="math">\\mathsf{cm}</span> and an auxiliary information <span class="math">\\mathsf{aux}</span>. <span class="math">\\mathsf{Open}(\\mathsf{ck},x,\\mathsf{aux})\\to\\pi_{x}</span>: On input the commitment key <span class="math">\\mathsf{ck}</span>, a point <span class="math">x\\in R^{m}</span>, and auxiliary information <span class="math">\\mathsf{aux}</span>, the open algorithm outputs a proof <span class="math">\\pi_{x}</span>. <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})\\to b</span>: On input the commitment key <span class="math">\\mathsf{ck}</span>, the commitment <span class="math">\\mathsf{cm}</span>, <span class="math">x\\in R^{m},y\\in R</span>, and a proof <span class="math">\\pi_{x}</span>, the verification algorithm outputs <span class="math">b\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">Correctness ensures that honestly generated proofs always pass verification. See Appendix A.1 for the formal definition. Furthermore, we are interested in (fully) succinct schemes, i.e., the sizes of commitments and proofs, as well as the running time of <span class="math">\\mathsf{Ver}</span>, are sublinear in the size of the polynomial.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 2 (Succinctness of <span class="math">\\mathsf{PC}</span>).</h6>

    <p class="text-gray-300">We say that a polynomial commitment scheme <span class="math">\\mathsf{PC}</span> is succinct if the size of the commitments produced by <span class="math">\\mathsf{Com}</span>, the proofs produced by <span class="math">\\mathsf{Open}</span> and the running time of <span class="math">\\mathsf{Ver}</span> are sublinear (e.g., polylogarithmic) in the size of the polynomial.</p>

    <p class="text-gray-300">A polynomial commitment scheme must satisfy at least one of the following security properties, which we define in order from weaker to stronger:</p>

    <p class="text-gray-300">It is computationally infeasible to find two different polynomials <span class="math">f\\neq f^{\\prime}</span> (and two randomnesses <span class="math">r</span> and <span class="math">r^{\\prime}</span> that produce the same commitment <span class="math">\\mathsf{cm}</span>. It is computationally infeasible to produce a verifying proof <span class="math">\\pi_{x}</span> for an incorrect evaluation <span class="math">y\\neq f(x)</span> when the commitment <span class="math">\\mathsf{cm}</span> of <span class="math">f</span> (required for verification) is honestly computed. It extends the guarantees of weak evaluation binding even in the presence of a maliciously computed commitment <span class="math">\\mathsf{cm}</span></p>

    <p class="text-gray-300">Strong evaluation binding. It guarantees that, for any maliciously chosen sequence of verifying proofs <span class="math">\\pi_{i}</span> for evaluations <span class="math">y_{i}</span> and points <span class="math">x_{i}</span>, there must exist a polynomial <span class="math">f\\in\\mathcal{P}_{m,d}</span> (where <span class="math">\\mathcal{P}_{m,d}</span> is the supported domain of the polynomial commitment scheme) such that <span class="math">f(x_{i})=y_{i}</span>. Knowledge soundness. This last property says that it exists of an efficient non-black-box extractor able to extract the committed polynomial <span class="math">f</span> if the corresponding adversary is able to provide verifying proofs.</p>

    <p class="text-gray-300">Below, we provide the formal definition of evaluation binding. We refer the reader to Appendix A.1 for the remaining ones.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3 (Evaluation Binding of PC).</h6>

    <p class="text-gray-300">A polynomial commitment scheme PC satisfies evaluation binding if for any PPT adversary <span class="math">\\mathcal{A}</span>, the following holds:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\textsf{Ver}(\\textsf{ck},\\textsf{cm},x,y,\\pi_{x})=1\\wedge\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{Ver}(\\textsf{ck},\\textsf{cm},x,y^{\\prime},\\pi_{x}^{\\prime})=1\\wedge\\ y\\neq y^{\\prime}\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\textsf{ck}\\leftarrow\\textsf{Setup}(1^{\\lambda},m,d)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\textsf{cm},x,y,\\pi_{x},y^{\\prime},\\pi_{x}^{\\prime})\\leftarrow\\mathcal{A}(\\textsf{ck})\\end{array}\\bigg{]}\\in\\textsf{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">The following theorem relates the above five security definitions. Such relations are standard and we refer the reader to <em>[x10, x2]</em> for more details.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let PC be a correct polynomial commitment scheme. Then,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If PC is weak evaluation binding then PC is also binding.</li>

      <li>If PC is evaluation binding then PC is weak evaluation binding.</li>

      <li>If PC is strong evaluation binding then PC is evaluation binding.</li>

      <li>If PC satisfies non-black-box (resp. black-box) knowledge soundness then PC is strong evaluation binding.</li>

    </ol>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.2 Vector Commitments</h3>

    <p class="text-gray-300">A vector commitment (VC) scheme permits to commit on vector of messages and later open individual positions. We make use of the standard definition of VC composed of algorithms (<span class="math">\\textsf{Setup},\\textsf{Com},\\textsf{Open},\\textsf{Ver}</span>), satisfying correctness and position binding (see Appendix A.2 for more details.).</p>

    <p class="text-gray-300">We are interested in succinct vector commitments schemes, meaning that the sizes of commitments and proofs, as well as the running time of <span class="math">\\textsf{Ver}</span>, are sublinear in the size of the vector.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 4 (Succinctness of VC).</h6>

    <p class="text-gray-300">We say that VC is succinct if the size of the commitments produced by <span class="math">\\textsf{Com}</span>, the proofs produced by <span class="math">\\textsf{Open}</span> and the running time of <span class="math">\\textsf{Ver}</span> are <span class="math">\\textsf{poly}(\\lambda,\\log n)</span> where <span class="math">n</span> is the size of the vector.</p>

    <p class="text-gray-300">In addition to the above, we formalize the notion of vector commitments in which the opening algorithm is “fast”, i.e., polylogarithmic after a one-time preprocessing which happens at commitment time. To model that the preprocessing cost of the commitment can be amortized, our definition requires <span class="math">\\textsf{Com}</span> to run in quasilinear time.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 5 (VC with Fast Opening).</h6>

    <p class="text-gray-300">We say that a vector commitment scheme VC has fast openings if the running time <span class="math">\\textsf{T}_{\\textsf{Com}}(\\lambda,n)</span> of <span class="math">\\textsf{Com}</span> is <span class="math">\\textsf{poly}(\\lambda,\\log n)\\cdot n</span>, and the running time <span class="math">\\textsf{T}_{\\textsf{Open}}(\\lambda,n)</span> of <span class="math">\\textsf{Open}</span> is <span class="math">\\textsf{poly}(\\lambda,\\log n)</span>.</p>

    <p class="text-gray-300">A natural instantiation of VC satisfying position binding, succinctness, and fast openings, is Merkle tree <em>[x23]</em>, which can be built from collusion resistant hash functions (CHRF). Other instantiations are discussed in Appendix A.2.</p>

    <p class="text-gray-300">2.3 SNARKs for Indexed Relations</p>

    <p class="text-gray-300">We recall the definition of succinct non-interactive arguments of knowledge (SNARKs) for indexed relations.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 6 (SNARK).</h6>

    <p class="text-gray-300">A SNARK for an indexed relation <span class="math">\\mathcal{R}</span> is defined by the following algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda})\\to\\mathsf{srs}</span>: On input the security parameter <span class="math">\\lambda</span>, the randomized setup algorithm returns a structured reference <span class="math">\\mathsf{srs}</span>. <span class="math">\\mathsf{Index}(\\mathsf{srs},\\mathfrak{i})\\to(\\mathsf{pk}_{\\mathfrak{i}},\\mathsf{vk}_{\\mathfrak{i}})</span> On input the structured references <span class="math">\\mathsf{srs}</span> and an index <span class="math">\\mathfrak{i}</span>, the deterministic indexing algorithm outputs a proving key <span class="math">\\mathsf{pk}_{\\mathfrak{i}}</span> and a verification key <span class="math">\\mathsf{vk}_{\\mathfrak{i}}</span>. <span class="math">\\mathsf{Prove}(\\mathsf{pk}_{\\mathfrak{i}},\\mathbbmss,\\mathbbmw)\\to\\pi</span> On input the proving key <span class="math">\\mathsf{pk}_{\\mathfrak{i}}</span> (for index <span class="math">\\mathfrak{i}</span>), a statement-witness pair <span class="math">(\\mathbbmss,\\mathbbmw)</span> such that <span class="math">(\\mathfrak{i},\\mathbbmss,\\mathbbmw)\\in\\mathcal{R}</span>, the randomized proving algorithm outputs a proof <span class="math">\\pi</span>. <span class="math">\\mathsf{Ver}(\\mathsf{vk}_{\\mathfrak{i}},\\mathbbmss,\\pi)\\to b</span> On input the verification key <span class="math">\\mathsf{vk}_{\\mathfrak{i}}</span> (for index <span class="math">\\mathfrak{i}</span>), a statement <span class="math">\\mathbbmss</span>, and proof <span class="math">\\pi</span>, the deterministic verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 7 (Correctness of SNARK).</h6>

    <p class="text-gray-300">A SNARK for an indexed relation <span class="math">\\mathcal{R}</span> is correct if for any <span class="math">(\\mathfrak{i},\\mathbbmss,\\mathbbmw)\\in\\mathcal{R}</span> we have:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathsf{Ver}(\\mathsf{vk}_{\\mathfrak{i}},\\mathbbmss,\\pi)=1\\begin{vmatrix}(\\mathsf{pk}_{\\mathfrak{i}},\\mathsf{vk}_{\\mathfrak{i}})\\leftarrow\\mathsf{Index}(\\mathsf{Setup}(1^{\\lambda}),\\mathfrak{i})\\\\ \\pi\\leftarrow\\mathsf{Prove}(\\mathsf{pk}_{\\mathfrak{i}},\\mathbbmss,\\mathbbmw)\\end{vmatrix}\\right]=1. \\]</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 8 (Succinctness of SNARK).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A SNARK is succinct if <span class="math">\\mathsf{Prove}</span> outputs proofs of size $\\mathsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbmw</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, the running time of </span>\\mathsf{Prove}<span class="math"> is </span>\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbmss</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbmw</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and the running time of </span>\\mathsf{Ver}<span class="math"> is </span>\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbmss</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbbmw</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 9 (Knowledge soundness of SNARK).</h6>

    <p class="text-gray-300">A SNARK for an indexed relation <span class="math">\\mathcal{R}</span> satisfies knowledge soundness if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, there exists a polynomial-time extractor <span class="math">\\mathsf{Ext}_{\\mathcal{A}}</span> (running on the same input of <span class="math">\\mathcal{A}</span>, including its random coins) such that:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathsf{Ver}(\\mathsf{vk}_{\\mathfrak{i}},\\mathbbmss,\\pi)=1\\begin{vmatrix}\\mathsf{srs}\\leftarrow\\mathsf{Setup}(1^{\\lambda})\\\\ ((\\mathfrak{i},\\mathbbmss,\\pi),\\mathbbmw)\\leftarrow(\\mathcal{A}(\\mathsf{srs}),\\mathsf{Ext}_{\\mathcal{A}}(\\mathsf{srs})),\\\\ (\\mathsf{pk}_{\\mathfrak{i}},\\mathsf{vk}_{\\mathfrak{i}})\\leftarrow\\mathsf{Index}(\\mathsf{srs},\\mathsf{vk},\\mathfrak{i})\\end{vmatrix}\\right]\\in\\mathsf{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">The above definition assumes a non-black-box extractor. Sometimes we make us of the black-box knowledge soundness flavour, which is identical to the above except that the extractor <span class="math">\\mathsf{Ext}</span> is universal.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3 Polynomial Preprocessing Schemes</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we define a building block called the polynomial preprocessing scheme (PP). Intuitively, a PP scheme abstracts algorithmic methods (such as <em>[x10, x11]</em>) that enable the fast evaluation of a polynomial <span class="math">f\\in R[X_{1},\\ldots,X_{m}]</span> at any given point <span class="math">x\\in R^{m}</span>, after performing a one-time preprocessing. The main objective of a PP is to achieve an evaluation time complexity that is significantly lower (e.g., sublinear) than the natural polynomial evaluation, which requires reading the entire description of <span class="math">f</span>, whose size is $O(d^{m}\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">Definition 10 (Polynomial Preprocessing Scheme). A polynomial preprocessing scheme PP is defined by the following algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Params}(R,m,d)\\to \\mathsf{pp}</span>: On input the description of a ring <span class="math">R</span>, the number of variables <span class="math">m\\in \\mathbb{N}</span>, and the degree <span class="math">d\\in \\mathbb{N}</span>, the randomized parameter generation algorithm outputs the parameters <span class="math">\\mathsf{pp}</span> that can be used for the execution of the following algorithms on <span class="math">m</span>-variate polynomials of individual degree at most <span class="math">d</span>. We assume the public parameters <span class="math">\\mathsf{pp}</span> includes an upper bound <span class="math">S</span> on the size of the data structures produced by the preprocessing algorithm below.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PreProcess}(\\mathsf{pp},f)\\to \\mathsf{DS}</span>: On input a <span class="math">m</span>-variate polynomial <span class="math">f\\in R[X_1,\\ldots ,X_m]</span> of individual degree at most <span class="math">d</span>, the randomized preprocess algorithm outputs a data structure <span class="math">\\mathsf{DS} = (v_{1},\\dots,v_{S})</span> (where <span class="math">S</span> is the data structure upper bound contained in <span class="math">p</span>). We model <span class="math">\\mathsf{DS}</span> as a vector in <span class="math">\\mathcal{M}^S</span> for a message space <span class="math">\\mathcal{M}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Lookup}(\\mathsf{pp},x)\\to (i_j)_{j\\in [k]}</span>: On input the public parameters <span class="math">\\mathsf{pp}</span> and a point <span class="math">x\\in R^m</span>, the deterministic lookup algorithm outputs <span class="math">k</span> indices <span class="math">i_1,\\ldots ,i_k\\in [S]</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Reconstruct}(\\mathsf{pp},x,v_1,\\dots,v_k)\\to y</span>: On input the public parameters <span class="math">\\mathsf{pp}</span>, an evaluation point <span class="math">x\\in R^m</span>, and <span class="math">k</span> values <span class="math">v_{1},\\ldots ,v_{k}\\in \\mathcal{M}</span>, the deterministic reconstruct algorithm outputs a value <span class="math">y\\in R</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Looking ahead, we are interested into efficient PP schemes which access only a "small" subset <span class="math">(v_{i_k})_{i\\in [k]}</span> of the data structure DS (i.e., $k\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). To accomplish this, it is necessary to work in the RAM model of computation to efficiently retrieve </span>(v_{i_k})_{i\\in [k]}$ from DS.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Correctness says that the reconstruction algorithm computes <span class="math">f(x)</span> when <span class="math">(v_{1},\\ldots ,v_{k}) = (\\mathsf{DS}_{i_{1}},\\ldots ,</span> <span class="math">\\mathsf{DS}_{i_k})</span>, for DS the data structure computed by the preprocess algorithm and <span class="math">(i_1,\\dots ,i_k)</span> the indices outputted by the lookup algorithm.</p>

    <p class="text-gray-300">Definition 11 (Correctness of PP). A polynomial preprocessing scheme PP is correct for a ring <span class="math">R</span> if for any integers <span class="math">m, d \\in \\mathbb{N}</span>, any polynomial <span class="math">f \\in R[X_1, \\ldots, X_m]</span> such that <span class="math">\\deg_1(f), \\ldots, \\deg_m(f) &amp;lt; d</span>, and for any point <span class="math">x \\in R^m</span>, we have <span class="math">\\mathsf{Reconstruct}(\\mathsf{pp}, x, v_{i_1}, \\ldots, v_{i_k}) = f(x)</span> where <span class="math">\\mathsf{pp} \\gets \\mathsf{Params}(R, m, d)</span>, <span class="math">(v_i)_{i \\in [S]} \\gets \\mathsf{PreProcess}(\\mathsf{pp}, f)</span>, and <span class="math">(i_1, \\ldots, i_k) \\gets \\mathsf{Lookup}(\\mathsf{pp}, x)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The property below capture the main benefit of using a PP scheme, i.e., enabling fast polynomial evaluation (compared to reading the entire polynomial) at the price of having a one-time preprocessing. We observe that the definition below allows <span class="math">\\mathsf{PreProcess}</span> to be "slow" and produce data structures of size larger than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d^{m}$. This is because, to enable fast evaluation, such schemes (e.g., [KU11,KU08]) encode additional and redundant information into DS.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 12 (Efficiency of PP). A polynomial preprocessing scheme PP satisfies efficiency for <span class="math">R</span> if, for every <span class="math">d, m \\in \\mathbb{N}</span>, for every polynomial <span class="math">f \\in R[X_1, \\ldots, X_m]</span> such that <span class="math">\\deg_1(f), \\ldots, \\deg_m(f) &amp;lt; d</span>, we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. the running time of both Lookup and Reconstruct is $\\mathsf{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log d)<span class="math"> (resp. </span>\\mathsf{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, d, m)<span class="math">) for the univariate case </span>m = 1<span class="math"> (resp. multivariate case </span>m &gt; 1$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 1 (Comparison with <span class="math">[ABC^{+}24]</span>). In <span class="math">[ABC^{+}24]</span>, Ateniese et al. propose an abstraction with the same intent as ours: abstracting any algorithmic method of preprocessing polynomials.</p>

    <p class="text-gray-300">Despite both abstractions (<em>[ABC^{+}24]</em> and ours) having the same final objective, there are crucial differences.</p>

    <p class="text-gray-300">The abstraction by Ateniese et al., named the data structure for univariate polynomial evaluation, is composed of two algorithms: (<span class="math">i</span>) GenData, which computes the data structure given the polynomial to be evaluated, and (<span class="math">ii</span>) Eval, which outputs <span class="math">f(x)</span> given the entire data structure and the point <span class="math">x</span>. This abstraction does not explicitly highlight that these algorithms leverage the RAM model to achieve efficiency. In particular, Eval hides inside the fact that a subset of the large data structure (provided as input) is retrieved to compute the final output <span class="math">y</span>. For this reason, <em>[ABC^{+}24]</em> formalizes, alongside the abstraction, the notion of localized RAM computation, which captures the idea that if a RAM computation outputs <span class="math">y</span> by reading a subset of a large input (e.g., a data structure), then there exists a method (the localized RAM computation) to compute the same output using only the subset accessed by the original computation. In other words, the original computation depends only on a subset of the large input.</p>

    <p class="text-gray-300">In this regard, our abstraction is simpler and makes this aspect more explicit. In a nutshell, Definition 10 decouples the RAM algorithm Eval of <em>[ABC^{+}24]</em> into two separate ones: Lookup entitled to identify the subset (determined by the indexes <span class="math">(i_{1},\\ldots,i_{k})</span>) of the data structure <span class="math">\\mathsf{DS}=(v_{1},\\ldots,v_{S})</span> that must be accessed to compute the correct output, and Reconstruct which computes the actual output <span class="math">y</span> given the subset <span class="math">(v_{i_{1}},\\ldots,v_{i_{k}})\\subseteq\\mathsf{DS}</span>. We emphasize that our abstraction captures PP schemes such that indexes computed by Lookup depend only on the point <span class="math">x</span>, which is indeed the case for the data structures in <em>[x14, x15]</em>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.1 Kedlaya-Umans technique as PP scheme</h3>

    <p class="text-gray-300">In <em>[x15]</em>, Kedlaya and Umans describe an elegant and efficient method for the fast evaluation of polynomials with preprocessing. Their method (which is the one we focus on in this work) is perfectly captured by our PP abstraction. For the sake of our results, we focus on the case of the ring of integers <span class="math">\\mathbb{Z}_{q}</span>, as also summarized in <em>[x17, x17, Theorem A.4]</em>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 2 (Kedlaya-Umans PP scheme <em>[x17, Theorem A.4]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">q\\in\\mathbb{N}</span>. There exists an efficient polynomial preprocessing scheme for the ring <span class="math">R=\\mathbb{Z}_{q}</span> and for <span class="math">m</span>-variate polynomials <span class="math">f\\in R[X_{1},\\ldots,X_{m}]</span> of individual degree <span class="math">\\mathsf{deg}_{1}(f),\\ldots,\\mathsf{deg}_{m}(f)&lt;d</span>.</p>

    <p class="text-gray-300">In more details, the efficiency of KU polynomial preprocessing scheme is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the running time of both Lookup and Reconstruct is <span class="math">\\mathsf{poly}(\\log q,d,m)</span>;</li>

      <li>the running time of <span class="math">\\mathsf{PreProcess}</span> and the size <span class="math">S</span> of the data structure <span class="math">\\mathsf{DS}</span> that it produces are <span class="math">d^{m}\\cdot\\mathsf{poly}(\\log q,m,d)\\cdot O(m(\\log m+\\log d+\\log\\log q))^{m}</span>.</li>

    </ol>

    <p class="text-gray-300">In the remaining part of this work, we refer to the aforementioned PP scheme as KU-based PP.</p>

    <p class="text-gray-300">When focusing on polynomial-time algorithms (as in this work), we can easily observe that parameters matter when considering Theorem 2. Indeed, preprocessing some <span class="math">\\mathsf{poly}(\\lambda)</span>-size polynomials using the KU-based PP scheme of Theorem 2 can cause the preprocessing algorithm <span class="math">\\mathsf{PreProcess}</span> (and the corresponding size <span class="math">S</span> of the output data structure) to be exponential in the security parameter <span class="math">\\lambda</span>. For instance, <span class="math">\\mathsf{PreProcess}</span> runs in exponential time if we consider: (<span class="math">i</span>) <span class="math">\\mathsf{poly}(\\lambda)</span>-variate polynomials (due to the <span class="math">O(m^{m})</span> term present in Theorem 2), or (<span class="math">ii</span>) <span class="math">O(\\log\\lambda)</span>-variate polynomials of individual degree <span class="math">d\\in\\mathsf{poly}(\\lambda)</span> (due to the <span class="math">d^{m}</span> term in Theorem 2).</p>

    <p class="text-gray-300">Unfortunately, even the case of multilinear <span class="math">m</span>-variate polynomials, where <span class="math">2^{m}=N=\\mathsf{poly}(\\lambda)</span>, implies <span class="math">\\mathsf{PreProcess}</span> to run in superpolynomial time due to <span class="math">O(m^{m})=O(N^{\\log N})</span>. This is the use case arising in most applications of polynomial commitments to SNARKs where multilinear polynomials are used to encode <span class="math">N</span>-long vectors via interpolation and thus we cannot apply the KU preprocessing technique in a straightforward way to this important use case.</p>

    <p class="text-gray-300">For this reason, in the following corollary we show a selection of parameters to instantiate Theorem 2 in such a way that the preprocessing (resp. evaluation) time is slightly superlinear (resp. polylogarithmic) in the size of the polynomial. These will be the parameters of interest in this work.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Corollary 1 (KU-based PP scheme for multivariate polynomials).</h6>

    <p class="text-gray-300">Let <span class="math">\\lambda\\in\\mathbb{N}</span> be a security parameter, and let <span class="math">q,d,N</span> such that <span class="math">q\\approx 2^{\\lambda}</span>, <span class="math">N=d^{m}\\in\\mathsf{poly}(\\lambda)</span>, and <span class="math">d=\\log^{3/\\epsilon}(N)</span> for some constant <span class="math">\\epsilon&gt;0</span>. Then, there exists a (KU-based) PP scheme for <span class="math">m</span>-variate polynomials <span class="math">f\\in\\mathbb{Z}_{q}[X_{1},\\ldots,X_{m}]</span> of individual degree <span class="math">\\mathsf{deg}_{1}(f),\\ldots,\\mathsf{deg}_{m}(f)&lt;d</span> achieving the following efficiency property:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the running time of both <span class="math">\\mathsf{Lookup}</span> and <span class="math">\\mathsf{Reconstruct}</span> is <span class="math">\\mathsf{poly}(\\log q,d,m)</span>;</li>

      <li>the running time of <span class="math">\\mathsf{PreProcess}</span> and the size <span class="math">S</span> of the data structure <span class="math">\\mathsf{DS}</span> that it produces are <span class="math">O(N^{1+\\epsilon})\\cdot\\mathsf{poly}(\\log q,\\log N)</span>.</li>

    </ol>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Observe that our parameters’ choice gives <span class="math">m=\\frac{\\epsilon}{3}\\log(N)/(\\log\\log N)</span>. Hence, the proof follows by leveraging Theorem 2 by using the following bounds (similar to <em>[x14, x15]</em>): <span class="math">m^{m}\\leq(\\log N)^{\\frac{\\epsilon}{3}\\log(N)/(\\log\\log N)}=N^{\\epsilon/3}</span>, and <span class="math">O(\\log m+\\log d+\\log\\lambda)^{m}\\leq O(\\log N)^{m}\\leq O(1)^{m}(\\log N)^{m}\\leq O(N^{\\epsilon/3})N^{\\epsilon/3}</span>. ∎</p>

    <p class="text-gray-300">As observed, the parameters in Theorem 2 do not result in an efficient PP scheme for univariate polynomials. Specifically, when <span class="math">m=1</span>, the evaluation time becomes polynomial in the degree <span class="math">d</span>, which is at least as large (or potentially larger) than the size of the polynomial itself. However, for the univariate case, we can obtain polylogarithmic efficiency by encoding the degree <span class="math">d</span> univariate polynomial into a multivariate one. This is essentially the result shown in <em>[x13, Theorem 5.1]</em>, which we report below.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 3 (KU-based PP scheme for univariate polynomials <em>[x13, Theorem 5.1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\lambda\\in\\mathbb{N}</span> be a security parameter, and let <span class="math">q,d</span> such that <span class="math">q\\approx 2^{\\lambda}</span>, <span class="math">d\\in\\mathsf{poly}(\\lambda)</span>. Then, there exists a (KU-based) PP scheme for univariate polynomials <span class="math">f\\in\\mathbb{Z}_{q}[X]</span> of degree <span class="math">\\mathsf{deg}(f)&lt;d</span> achieving the following efficiency property:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the running time of both <span class="math">\\mathsf{Lookup}</span> and <span class="math">\\mathsf{Reconstruct}</span> is <span class="math">\\mathsf{poly}(\\log q,\\log d)</span>;</li>

      <li>the running time of <span class="math">\\mathsf{PreProcess}</span> and the size <span class="math">S</span> of the data structure <span class="math">\\mathsf{DS}</span> that it produces are <span class="math">O(d^{1+\\epsilon})\\cdot\\mathsf{poly}(\\log q,\\log d)</span>.</li>

    </ol>

    <h2 id="sec-28" class="text-2xl font-bold">4 Polynomial Commitments with Fast Opening</h2>

    <p class="text-gray-300">We show how to construct polynomial commitment schemes which achieve a sublinear opening time. Below, we formally define this efficiency notion, dubbed fast openings, which is reminiscent to that of VC (see Definition 5) but adapted to the polynomial setting.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 13 (<span class="math">\\mathsf{PC}</span> with Fast Opening).</h6>

    <p class="text-gray-300">We say that a polynomial commitment scheme <span class="math">\\mathsf{PC}</span> for multivariate (resp. univariate) polynomials over a ring <span class="math">R</span> has fast openings if the running time</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{T}_{\\mathsf{Com}}(\\lambda, d, m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> of </span>\\mathsf{Com}<span class="math"> is </span>\\mathsf{poly}(\\lambda, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, d^m)<span class="math"> (resp. </span>\\mathsf{poly}(\\lambda, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, d)<span class="math">), and the running time </span>\\mathsf{T}_{\\mathsf{Open}}(\\lambda, d, m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> of </span>\\mathsf{Open}<span class="math"> is </span>\\mathsf{poly}(\\lambda, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, d, m)<span class="math"> (resp. </span>\\mathsf{poly}(\\lambda, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log d)<span class="math">), where the parameters </span>m<span class="math"> (number of variables) and </span>d$ (maximum individual degree) are chosen on setup.¹⁶</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We highlight that achieving fast openings in PC is much more challenging than in the vector commitment setting. Given a committed vector of polynomial size, there are only a polynomial number of indices that can be opened. Thus, fast opening can be achieved by preprocessing all those proofs and leveraging the RAM model to retrieve each of these proofs when needed. However, in PC, the number of possible proofs corresponds to the cardinality of the point space <span class="math">R^m</span> of the target polynomials <span class="math">f \\in R[X_1, \\ldots, X_m]</span>. For some choices of parameters (e.g., <span class="math">m \\in \\omega(\\log(\\lambda))</span>) the cardinality of <span class="math">R^m</span> is exponential in <span class="math">\\lambda</span>. Hence, simply preprocessing all proofs is not feasible and would result in exponential memory usage. This is essentially the reason why research focuses on building PP schemes, i.e., efficient algorithms for polynomial evaluation at all points (such as [KU08,KU11]).¹⁷</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.1 Evaluation Binding (VC-based) Polynomial Commitment with Fast Opening</h2>

    <p class="text-gray-300">Our main construction, dubbed <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span>, is obtained by combining a PP scheme (Definition 10) with a VC that enjoys fast opening time (Definition 5). The basic idea of the construction <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> is that the commitment algorithm runs the preprocessing algorithm of the PP scheme and uses the VC to commit to the blocks of resulting data structure DS. Next, in order to prove an evaluation in a point <span class="math">x</span>, one can give to the verifier the blocks of DS at the <span class="math">k</span> indices identified by PP.Lookup for the point <span class="math">x</span>, along with opening proofs for those indices. The verifier can check this proof and runs the PP.Reconstruct algorithm to recover <span class="math">f(x)</span>. The prove that this construction <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> satisfies evaluation binding, yet it is provably not strong evaluation binding. Therefore, in Section 4.2 we show how to build PCs with sublinear opening time that achieve stronger security.</p>

    <p class="text-gray-300">We highlight that this technique is used in [ABC⁺24] to build a verifiable data structure for polynomial evaluation. Also, [ABC⁺24] mentions in the introduction the possibility of viewing their data structure as a polynomial commitment. However, our objective is to carefully analyze and provide a formal treatment of this statement in the setting of polynomial commitments, aiming at clarifying the extent to which security is guaranteed.</p>

    <p class="text-gray-300"><strong>Construction 1</strong> Let PP be a PP scheme (Definition 10) and VC be a vector commitment (Definition 22) scheme for a message space <span class="math">\\{0,1\\}^*</span>. We build a PC scheme <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> for multivariate polynomials over a ring <span class="math">R</span> as follows:</p>

    <p class="text-gray-300">Setup<span class="math">(1^{\\lambda}, m, d) \\to \\mathsf{ck}</span>: On input the security parameter <span class="math">\\lambda</span>, the number of variables <span class="math">m</span>, and a bound <span class="math">d</span> for the degree of each variable, the setup algorithm computes <span class="math">\\mathsf{pp} \\gets \\mathsf{PP.Params}(R, m, d)</span> and <span class="math">\\mathsf{ck}_{\\mathsf{VC}} \\gets \\mathsf{VC.Setup}(1^{\\lambda}, S)</span>, where <span class="math">S</span> is the upper bound on the size of the data structure included in <span class="math">\\mathsf{pp}</span> (see Definition 10). Finally, it outputs <span class="math">\\mathsf{ck} = (\\mathsf{pp}, \\mathsf{ck}_{\\mathsf{VC}})</span>.</p>

    <p class="text-gray-300">Com(ck, f; r) → (cm, aux): On input the commitment key <span class="math">\\mathsf{ck} = (\\mathsf{pp}, \\mathsf{ck}_{\\mathsf{VC}})</span>, a polynomial <span class="math">f \\in \\mathcal{P}_{m,d}</span>, and a randomness <span class="math">r</span>, the commit algorithm computes <span class="math">\\mathsf{DS} \\gets \\mathsf{PP.PreProcess}(\\mathsf{pp}, f)</span> and <span class="math">(\\mathsf{cm}_{\\mathsf{DS}}, \\mathsf{aux}_{\\mathsf{DS}}) \\gets \\mathsf{VC.Com}(\\mathsf{ck}_{\\mathsf{VC}}, \\mathsf{DS}; r)</span> (recall that <span class="math">\\mathsf{DS}</span> is a vector, i.e., <span class="math">\\mathsf{DS} = (v_1, \\ldots, v_S)</span>). Finally, it outputs <span class="math">\\mathsf{cm} = \\mathsf{cm}_{\\mathsf{DS}}</span> and <span class="math">\\mathsf{aux} = (\\mathsf{aux}_{\\mathsf{DS}}, \\mathsf{DS})</span>.</p>

    <p class="text-gray-300">¹⁶ Observe that being polynomial in the variables <span class="math">d</span> and <span class="math">m</span> (the complexity of <span class="math">\\mathsf{Open}</span>) implies being sublinear in the size <span class="math">d^m</span> of the multivariate polynomial.</p>

    <p class="text-gray-300">¹⁷ While considering PC with fast openings, a crucial requirement is the balance between memory usage (to store the precomputed data) and running time of <span class="math">\\mathsf{Open}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Open}(\\mathsf{ck},x,\\mathsf{aux})\\to\\pi_{x}</span>: On input the commitment key <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}})</span>, a point <span class="math">x\\in R^{m}</span>, and auxiliary information <span class="math">\\mathsf{aux}=(\\mathsf{aux}_{\\mathsf{DS}},\\mathsf{DS})</span> where <span class="math">\\mathsf{DS}=(v_{1},\\ldots,v_{S})</span>, the open algorithm retrieves the indexes <span class="math">(i_{1},...,i_{k})\\leftarrow\\mathsf{PP}.\\mathsf{Lookup}(\\mathsf{pp},x)</span> and compute an opening proof <span class="math">\\pi_{j}\\leftarrow\\mathsf{VC}.\\mathsf{Open}(\\mathsf{ck}_{\\mathsf{VC}},i_{j},</span> <span class="math">\\mathsf{aux}_{\\mathsf{DS}})</span> for every <span class="math">j\\in[k]</span>. Finally, it outputs <span class="math">\\pi_{x}=(v_{i_{j}},\\pi_{j})_{j\\in[k]}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})\\to b</span>: On input the commitment key <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}})</span>, the commitment <span class="math">\\mathsf{cm}=\\mathsf{cm}_{\\mathsf{DS}}</span>, <span class="math">x\\in R^{m}</span>, an evaluation <span class="math">y\\in R</span>, and a proof <span class="math">\\pi_{x}=(v_{j},\\pi_{j})_{j\\in[k]}</span>, the verification algorithm outputs <span class="math">b\\in\\{0,1\\}</span> equals to <span class="math">\\bigwedge_{j\\in[k]}\\mathsf{VC}.\\mathsf{Ver}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}},i_{j},v_{j},\\pi_{j})\\stackrel{{\\scriptstyle?}}{{=}}1\\ \\land\\ y\\stackrel{{\\scriptstyle?}}{{=}}\\mathsf{PP}.\\mathsf{Reconstruct}(\\mathsf{pp},</span> <span class="math">x,v_{1},\\ldots,v_{k})</span>.</p>

    <p class="text-gray-300">Below, we state the properties achieved by our <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> of Construction 1 and we defer the formal proof to Appendix E.1.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PP}</span>, <span class="math">\\mathsf{VC}</span>, and <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> as defined in Construction 1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If both <span class="math">\\mathsf{PP}</span> and <span class="math">\\mathsf{VC}</span> satisfy correctness (Definitions 11 and 23), then <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> satisfies correctness (Definition 17).</li>

      <li>If <span class="math">\\mathsf{VC}</span> satisfies position binding (Definition 24), then <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> satisfies evaluation binding (Definition 3).</li>

      <li>If <span class="math">\\mathsf{PP}</span> satisfies efficiency (Definition 12) and <span class="math">\\mathsf{VC}</span> satisfies succinctness (Definition 4), then <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> satisfies succinctness (Definition 2).</li>

      <li>If <span class="math">\\mathsf{PP}</span> satisfies efficiency (Definition 12) and <span class="math">\\mathsf{VC}</span> satisfies fast openings (Definition 5), then <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> satisfies fast openings (Definition 13).</li>

    </ol>

    <p class="text-gray-300">Instantiations. One can obtain several instantiations of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> by using the KU-based PP schemes for either multivariate (Corollary 1) or univariate (Theorem 3) polynomials, and a VC with fast openings such as Merkle trees <em>[x18]</em>, KZG <em>[x14]</em> or <em>[CFG^{+}20]</em>. The following corollary provides an example of instantiation considering <span class="math">R=\\mathbb{Z}_{q}</span> and using Merkle trees <em>[x18]</em>. For the multivariate case, we focus on particular choices of parameters <span class="math">d</span> and <span class="math">m</span> that yield a polynomial-time instantiation of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Corollary 2 (Polynomial-time instantiations of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span>).</h6>

    <p class="text-gray-300">Assuming collision resistance hash functions, there exists a PC scheme <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> for multivariate (resp. univariate) polynomials over the ring <span class="math">R=\\mathbb{Z}_{q}</span> for <span class="math">q\\approx 2^{\\lambda}</span> that satisfies correctness, succinctness, evaluation binding, and fast opening where the running times of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}.\\mathsf{Com}</span> and <span class="math">\\mathsf{PC}_{\\mathsf{VC}}.\\mathsf{Open}</span> are defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For univariate polynomials of degree at most <span class="math">d\\in\\mathsf{poly}(\\lambda)</span>, we have <span class="math">\\mathsf{T}_{\\mathsf{PC}.\\mathsf{Com}}=\\mathsf{poly}(\\lambda,\\log d)\\cdot O(d^{1+\\epsilon})</span> and <span class="math">\\mathsf{T}_{\\mathsf{PC}.\\mathsf{Open}}=\\mathsf{poly}(\\lambda,\\log d)</span> for every positive constant <span class="math">\\epsilon&gt;0</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For <span class="math">m</span>-variate polynomials such that <span class="math">\\mathsf{deg}_{1}(f),\\ldots,\\mathsf{deg}_{m}(f)&lt;d</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=d^{m}=\\mathsf{poly}(\\lambda)<span class="math">, and </span>d=\\log^{3/\\epsilon}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> (which in turn implies </span>m=\\frac{\\epsilon}{3}\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/(\\log\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">), we have </span>\\mathsf{T}_{\\mathsf{PC}.\\mathsf{Com}}=\\mathsf{poly}(\\lambda,m,d)\\cdot O(d^{m(1+\\epsilon)})<span class="math"> and </span>\\mathsf{T}_{\\mathsf{PC}.\\mathsf{Open}}=\\mathsf{poly}(\\lambda,m,d)<span class="math"> for every positive constant </span>\\epsilon>0<span class="math">. Observe that for our choices of </span>d<span class="math"> and </span>m<span class="math">, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d^{m}\\in\\mathsf{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lack of Strong Evaluation Binding. Theorem 4 states the evaluation binding property of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span>. A natural question is whether the same construction achieves stronger binding notions, such as strong evaluation binding or knowledge soundness. In Appendix B, we give a negative answer to this question, showing that <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> is not strongly evaluation binding. In a nutshell, the core functioning of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> relies on the usage of data structures <span class="math">\\mathsf{DS}</span>, whose space is larger than that of the polynomial space <span class="math">\\mathcal{P}_{m,d}</span>. This allows an adversary to commit to an inconsistent data structure (with one block sampled at random) whose resulting evaluations (output of <span class="math">\\mathsf{PP.Reconstruct}</span>) can be interpolated only from polynomials of larger degrees (lying outside <span class="math">\\mathcal{P}_{m,d}</span>). We provide more details in Appendix B.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.2 Beyond Evaluation Binding</h3>

    <p class="text-gray-300">In Appendix C, we show that deploying a SNARK on top of Construction 1 is sufficient to construct a knowledge-sound polynomial commitment scheme (recall that knowledge soundness implies strong evaluation binding; see Theorem 1).</p>

    <p class="text-gray-300">In a nutshell, during the execution of <span class="math">\\mathsf{Com}</span>, our approach is to compute a commitment <span class="math">\\mathsf{cm}=\\mathsf{cm}_{\\mathsf{DS}}</span> (where <span class="math">\\mathsf{cm}_{\\mathsf{DS}}</span> is computed as defined in Construction 1). In addition, we include into the auxiliary information a proof of correctness <span class="math">\\pi</span> demonstrating that <span class="math">\\mathsf{DS}</span> has been computed by running <span class="math">\\mathsf{PP.PreProcess}</span>. This can be accomplished by using a SNARK for the following relation:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{VC,PP}}=\\{((\\mathsf{pp},\\mathsf{ck},\\mathsf{cm}),(f,r))\\mid(\\mathsf{cm},\\cdot)=\\mathsf{VC.Com}(\\mathsf{ck},\\mathsf{PP.PreProcess}(\\mathsf{pp},f);r)\\}</span> (1)</p>

    <p class="text-gray-300">Each time an opening proof is computed, we include <span class="math">\\pi</span> into it. Then, when verifying an opening proof, we simply perform all steps defined in Construction 1 and, in addition, verify the correctness of the commitment by checking <span class="math">\\pi</span>. Observe that the resulting <span class="math">\\mathsf{PC}</span> still achieves the succinctness and fast opening properties (the latter thanks to the succinctness property of SNARKs). We refer the reader to Appendix C for more details.</p>

    <p class="text-gray-300">Engineering the (SNARK) relation through algebraic approaches. The aforementioned approach requires a SNARK supporting <span class="math">\\mathcal{R}_{\\mathsf{VC,PP}}</span>, which, in turn, relies on the entire computation of <span class="math">\\mathsf{PP.PreProcess}(\\mathsf{pp},f)</span>. By opening the box, we observe that the PP scheme of Kedlaya and Umans <em>[x13, x14]</em> has an algebraic structure. For example, the data structure <span class="math">\\mathsf{DS}</span> (output by <span class="math">\\mathsf{PP.PreProcess}</span>) consists of multiple small tables, each containing all evaluations of a multivariate polynomial <span class="math">f_{i}</span> (derived by manipulating the original one) modulo a small prime <span class="math">p_{i}</span>. Due to the algebraic nature of this PP scheme, we envision the possibility of engineering and simplifying the SNARK relation to achieve a faster <span class="math">\\mathsf{PC}</span>. However, this direction is outside the scope of this paper, and we leave it as a possible direction for future work.</p>

    <h2 id="sec-34" class="text-2xl font-bold">5 Index-Efficient SNARKs</h2>

    <p class="text-gray-300">We give applications of polynomial preprocessing schemes and PCs with fast opening to construct <em>index-efficient SNARKs</em>, i.e., preprocessing SNARKs in which the prover runs in time which is sub-linear in the size of the index.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 14 (Index-Efficient SNARKs).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a preprocessing SNARK (Definition 6) for an indexed <span class="math">\\mathcal{R}</span> is index-efficient if the running time of the prover is polylogarithmic in the size of the index, i.e., $\\mathsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To construct index-efficient SNARKs, we proceed as follows. First, we formalize the notion of index-efficient PIOPs, which are a class of PIOPs in which the prover’s running time depends polylogarithmically on the size of the index. Second, we show how to use index-efficient PIOPs along with PCs with fast openings in order to construct an index-efficient SNARK. Third, in Section 5.2 we study the feasibility of instantiating the above result, namely the existence of index-efficient PIOPs. Our result is a technique to transform a class of (non-index-efficient) PIOPs into index-efficient ones. Finally, in Section 5.3 we show how the combination of the three results above can be used to obtain new table-efficient lookup arguments.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.1 Index-Efficient PIOPs and Applications to Index-Efficient SNARKs</h3>

    <p class="text-gray-300">We start by recalling the definition of polynomial interactive oracle proofs (PIOP) for indexed relations.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 15 (Polynomial IOPs).</h6>

    <p class="text-gray-300">Let <span class="math">R</span> be a ring and <span class="math">\\mathcal{R}</span> be an indexed relation. A polynomial IOP for <span class="math">\\mathcal{R}</span> is defined by a tuple <span class="math">(\\mathcal{I},\\mathcal{P},\\mathcal{V})</span> such that:</p>

    <p class="text-gray-300">Let <span class="math">R</span> be a deterministic algorithm that on input the index <span class="math">\\mathfrak{i}</span> outputs <span class="math">\\mathsf{i}</span> oracle polynomials <span class="math">p_{1}^{\\mathfrak{i}},\\ldots,p_{l}^{\\mathfrak{i}}</span>. The prover <span class="math">\\mathcal{P}</span> and the verifier <span class="math">\\mathcal{V}</span> run an interactive protocol, compactly denoted by <span class="math">\\langle\\mathcal{P}(\\mathfrak{i},\\mathbf{x},\\mathsf{w}),\\mathcal{V}^{\\mathcal{I}(\\mathfrak{i})}(\\mathbf{x})\\rangle</span>, where in each round the prover <span class="math">\\mathcal{P}</span> sends oracle polynomials and/or ring elements, and the verifier <span class="math">\\mathcal{V}</span> sends random challenges. Each oracle <span class="math">\\llbracket p\\rrbracket</span> specifies the number of variables <span class="math">m</span> and the degree in each variable. The verifier can query all the oracles, the ones sent by the prover and the ones generated by <span class="math">\\mathcal{I}</span>, at arbitrary points <span class="math">\\mathbf{r}\\in R^{m}</span>. At the end of the execution, <span class="math">\\mathcal{V}</span> accepts or rejects. For any honest execution of <span class="math">\\langle\\mathcal{P}(\\mathfrak{i},\\mathbf{x},\\mathsf{w}),\\mathcal{V}^{\\mathcal{I}(\\mathfrak{i})}(\\mathbf{x})\\rangle</span> on <span class="math">(\\mathfrak{i},\\mathbf{x};\\mathsf{w})\\in\\mathcal{R}</span>, the verifier accepts. A PIOP is <span class="math">\\delta</span>-sound if for any unbounded adversary <span class="math">\\mathcal{A}</span> and any <span class="math">(\\mathfrak{i},\\mathbf{x})\\notin\\mathcal{L}(\\mathcal{R})</span>, we have <span class="math">\\Pr\\left[\\langle\\mathcal{A}(\\mathfrak{i},\\mathbf{x}),\\mathcal{V}^{\\mathcal{I}(\\mathfrak{i})}(\\mathbf{x})\\rangle=1\\right]\\leq\\delta</span>. A PIOP is <span class="math">\\delta</span>-knowledge-sound if there exists a PPT oracle machine <span class="math">\\mathsf{Ext}</span> (which can query all the oracle polynomials at arbitrary points) such that for any adversary <span class="math">\\mathcal{A}</span> and any <span class="math">(\\mathfrak{i},\\mathbf{x})</span>, the following probability holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\langle\\mathcal{A}(\\mathfrak{i},\\mathbf{x}),\\mathcal{V}^{\\mathcal{I}(\\mathfrak{i})}(\\mathbf{x})\\rangle=1\\ \\wedge\\ (\\mathfrak{i},\\mathbf{x};\\mathsf{w})\\notin\\mathcal{R}\\ \\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{w}\\leftarrow\\mathsf{Ext}^{\\mathcal{A}}(\\mathfrak{i},\\mathbf{x})\\right]\\leq\\delta.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We measure the efficiency of a PIOP according to the following metrics: the running times <span class="math">\\mathsf{T}_{\\mathcal{P}}</span> and <span class="math">\\mathsf{T}_{\\mathcal{V}}</span> of prover and verifier, the number of rounds <span class="math">\\mathsf{r}</span>, the query complexity <span class="math">\\mathsf{q}</span> (i.e., number of queries performed by the verifier), the number of oracles sent by the prover <span class="math">\\mathsf{o}</span>, and the size <span class="math">\\mathsf{s}</span> of the proof oracles (i.e., the sum of length of all the polynomials sent by the prover).</p>

    <p class="text-gray-300">Next we define a class of PIOPs in which the prover’s running time depends polylogarithmically on the size of the index. This is however possible after a preprocessing of the index performed by the indexer. More formally:</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 16 (Index-Efficient PIOPs).</h6>

    <p class="text-gray-300">A PIOP for an indexed relation <span class="math">\\mathcal{R}</span> is called index-efficient if it satisfies the following conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The indexer <span class="math">\\mathcal{I}(\\mathfrak{i})</span> outputs oracle polynomials <span class="math">p_{1}^{\\mathfrak{i}},\\ldots,p_{1}^{\\mathfrak{i}}</span> and a preprocessed index <span class="math">\\mathsf{hk}_{\\mathfrak{i}}</span>.</li>

      <li>The prover <span class="math">\\mathcal{P}(\\mathsf{hk}_{\\mathfrak{i}},\\mathtt{x},\\mathtt{w})</span> works as in a standard PIOP except that it takes as input <span class="math">\\mathsf{hk}_{\\mathfrak{i}}</span> instead of the plain index <span class="math">\\mathfrak{i}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Efficiency: the running time of the prover <span class="math">\\mathsf{T}_{\\mathcal{P}}</span> is $\\mathsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Compiling Index-Efficient PIOPs into Index-Efficient SNARKs.</h4>

    <p class="text-gray-300">We show that given an index-efficient PIOP and a PC with fast openings it is possible to construct an index-efficient SNARK.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 5 (Index-Efficient Compilation of PIOPs).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{\\Pi}</span> be a PIOP for a ring <span class="math">R</span> and an indexed relation <span class="math">\\mathcal{R}</span>, let <span class="math">\\mathsf{PP}</span> be a polynomial preprocessing scheme, and let <span class="math">\\mathsf{PC}</span> and <span class="math">\\mathsf{subPC}</span> be two polynomial commitment schemes for polynomials with coefficients in <span class="math">R</span>. If <span class="math">\\mathsf{\\Pi}</span> has <span class="math">\\mathsf{negl}(\\lambda)</span>-knowledge soundness, <span class="math">\\mathsf{PC}</span> is knowledge-sound (Definition 21) and <span class="math">\\mathsf{subPC}</span> is weak evaluation binding (Definition 19) then there exists a public-coin interactive argument <span class="math">\\Pi</span> for the indexed relation <span class="math">\\mathcal{R}</span>. Furthermore, if <span class="math">\\mathsf{\\Pi}</span> is index-efficient and <span class="math">\\mathsf{subPC}</span> has fast openings, then <span class="math">\\Pi</span> is index-efficient.</p>

    <p class="text-gray-300">The construction <span class="math">\\Pi</span> is obtained via a slight variant of the usual PIOP compilation appeared in previous work <em>[CHM+20, BFS20]</em>. The main difference is that the polynomials produced by the PIOP indexer are committed using the PC scheme <span class="math">\\mathsf{subPC}</span> with fast opening; this occurs in the preprocessing phase of the argument system. Later, for every PIOP verifier’s query to such polynomials, the prover uses the PP scheme to fast-evaluate the polynomial and the PC’s fast opening to create a proof. Since this compiler is similar to previous work, we give an informal presentation emphasizing the main differences in more detail.</p>

    <p class="text-gray-300"><span class="math">\\Pi</span>.<span class="math">\\mathsf{Setup}</span> runs the setup algorithms of both <span class="math">\\mathsf{PC}</span> and <span class="math">\\mathsf{subPC}</span> and store in <span class="math">\\mathsf{srs}</span> their commitment keys. Given an index <span class="math">\\mathfrak{i}</span>, <span class="math">\\Pi</span>.<span class="math">\\mathsf{Index}(\\mathsf{srs},\\mathfrak{i})</span> calls the PIOP indexer <span class="math">(p_{1}^{\\mathfrak{i}},\\ldots,p_{1}^{\\mathfrak{i}},\\mathsf{hk}_{\\mathfrak{i}})\\leftarrow\\mathcal{I}(\\mathfrak{i})</span> and then, for each polynomial <span class="math">p_{i}^{\\mathfrak{i}}</span> it runs the PP preprocessing, <span class="math">\\mathsf{DS}_{i}\\leftarrow\\mathsf{PP}.\\mathsf{PreProcess}(p_{i}^{\\mathfrak{i}})</span>, commits to it using <span class="math">\\mathsf{subPC}</span>, and stores all this preprocessed information in <span class="math">\\mathsf{pk}_{\\mathfrak{i}}</span> and the commitments in <span class="math">\\mathsf{vk}_{\\mathfrak{i}}</span>.</p>

    <p class="text-gray-300">The prover <span class="math">\\Pi</span>.<span class="math">\\mathsf{Prove}(\\mathsf{pk}_{\\mathfrak{i}},\\mathtt{x},\\mathtt{w})</span> runs the PIOP prover <span class="math">\\mathcal{P}(\\mathsf{hk}_{\\mathfrak{i}},\\mathtt{x},\\mathtt{w})</span> until the end of the interactive protocol with <span class="math">\\mathsf{\\Pi}</span>.<span class="math">\\mathcal{V}</span> by sending to the verifier, in each round, commitments to the polynomials generated by <span class="math">\\mathsf{\\Pi}</span>.<span class="math">\\mathcal{P}</span> computed using <span class="math">\\mathsf{PC}</span>. Finally, for every query of <span class="math">\\mathcal{V}</span> to a polynomial the prover of <span class="math">\\Pi</span> evaluates the polynomial and produces an evaluation for it. In particular, for polynomials produced by <span class="math">\\mathcal{P}</span> this is done using standard evaluation and by using <span class="math">\\mathsf{PC}</span> for the evaluation proofs; this is the same as in previous compilers. For polynomials produced by <span class="math">\\mathcal{I}</span>, the evaluations are performed using the PP scheme and the proofs are generated using <span class="math">\\mathsf{subPC}</span>.<span class="math">\\mathsf{Open}</span> algorithm.</p>

    <p class="text-gray-300">The verifier <span class="math">\\Pi</span>.<span class="math">\\mathsf{Ver}</span> runs the PIOP verifier <span class="math">\\mathsf{\\Pi}</span>.<span class="math">\\mathcal{V}</span> and checks the validity of all the evaluations and the associated proofs using <span class="math">\\mathsf{PC}</span> or <span class="math">\\mathsf{subPC}</span>.</p>

    <p class="text-gray-300">Compared to previous work, the main difference in the proof of knowledge soundness of <span class="math">\\Pi</span> is that our compiler uses two different polynomial commitments. The crucial observation is that we commit the polynomials produced by the PIOP indexer <span class="math">\\mathcal{I}</span> as part of the <span class="math">\\Pi</span>.<span class="math">\\mathsf{Index}</span> algorithm and thus any incorrectly proven evaluation of these polynomials (which can be checked without extraction) can be reduced to the weak evaluation binding property of <span class="math">\\mathsf{subPC}</span>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The efficiency of the resulting argument depends on the efficiency of <span class="math">\\Pi</span>, <span class="math">\\mathsf{PP}</span>, <span class="math">\\mathsf{PC}</span>, and <span class="math">\\mathsf{subPC}</span> as follows. For <span class="math">\\Pi</span>, let <span class="math">\\mathsf{T}_{\\Pi,\\mathcal{P}}</span> and <span class="math">\\mathsf{T}_{\\Pi,\\mathcal{V}}</span> be its prover and verifier running times, and let <span class="math">\\mathsf{r},\\mathsf{q}_{\\mathcal{I}},\\mathsf{q}_{\\mathcal{P}},\\mathsf{o},\\mathsf{s}</span> be, respectively, its round complexity, number of verifier’s queries to <span class="math">\\mathcal{I}</span>’s and <span class="math">\\mathcal{P}</span>’s oracles respectively, number of prover’s oracles, and total size of the prover’s oracles. For <span class="math">\\mathsf{PC}</span>, let <span class="math">\\mathsf{T}_{\\mathsf{PC},\\mathsf{Com}},\\mathsf{T}_{\\mathsf{PC},\\mathsf{Open}},\\mathsf{T}_{\\mathsf{PC},\\mathsf{Ver}}</span> be the running times of the corresponding algorithms, and let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathsf{PC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> be the size of a commitment and a proof respectively, and consider analogous notations for </span>\\mathsf{subPC}<span class="math"> complexity. Then the argument </span>\\varPi$ enjoys the following efficiency:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proving time is <span class="math">\\mathsf{T}_{\\Pi,\\mathcal{P}}+\\mathsf{T}_{\\mathsf{PC},\\mathsf{Com}}\\cdot\\mathsf{s}+(\\mathsf{T}_{\\mathsf{subPC},\\mathsf{Open}}+\\mathsf{T}_{\\mathsf{PP},\\mathsf{Lookup}}+\\mathsf{T}_{\\mathsf{PP},\\mathsf{Reconstruct}})\\cdot\\mathsf{q}_{\\mathcal{I}}+\\mathsf{T}_{\\mathsf{PC},\\mathsf{Open}}\\cdot\\mathsf{q}_{\\mathcal{P}}</span></li>

      <li>Verifier time is <span class="math">\\mathsf{T}_{\\Pi,\\mathcal{V}}+\\mathsf{T}_{\\mathsf{subPC},\\mathsf{Ver}}\\cdot\\mathsf{q}_{\\mathcal{I}}+\\mathsf{T}_{\\mathsf{PC},\\mathsf{Ver}}\\cdot\\mathsf{q}_{\\mathcal{P}}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof size is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathsf{o}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathsf{PC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathsf{q}_{\\mathcal{P}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One can see that the index-efficiency of <span class="math">\\varPi</span>’s prover follows by the facts that the following terms are all polylogarithmic in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">: </span>\\mathsf{T}_{\\Pi,\\mathcal{P}}<span class="math">, and thus </span>\\mathsf{s}<span class="math"> and </span>\\mathsf{q}_{\\mathcal{P}}<span class="math">, due to the index-efficiency of </span>\\Pi<span class="math">, </span>\\mathsf{q}_{\\mathcal{I}}<span class="math"> due to the succinctness of the PIOP, </span>\\mathsf{T}_{\\mathsf{subPC},\\mathsf{Open}}<span class="math"> due to the fast opening property of </span>\\mathsf{subPC}<span class="math">, </span>\\mathsf{T}_{\\mathsf{PP},\\mathsf{Lookup}}+\\mathsf{T}_{\\mathsf{PP},\\mathsf{Reconstruct}}<span class="math"> due to the efficiency of </span>\\mathsf{PP}<span class="math">, and </span>\\mathsf{T}_{\\mathsf{PC},\\mathsf{Open}}<span class="math"> since it is a function of the size of the polynomials produced by </span>\\Pi.\\mathcal{P}<span class="math"> which is polylogarithmic in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> due to the index-efficiency of </span>\\Pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.2 Our Construction of Index-Efficient PIOPs</h3>

    <p class="text-gray-300">In the following theorem we show how to transform a class of (non-index-efficient) PIOPs into index-efficient ones. The main technical obstacle in this transformation is that we want to transform PIOPs that work with multilinear polynomials (which is the most popular case in the literature) but the known results for preprocessing schemes only capture either univariate polynomials or multivariate polynomials with very specific configuration in terms of number of variables and degree. Our contribution is a technique that solves this issue by encoding the multilinear polynomial with a low-degree multivariate polynomial for which we can use a PP scheme.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 6 (Index-Efficient PIOPs from PP schemes).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PP}</span> be a polynomial preprocessing scheme for <span class="math">m</span>-variate polynomials of degree <span class="math">\\leq d</span> such that <span class="math">(d+1)^{m}=2^{n}</span> and <span class="math">d</span> is at most <span class="math">\\mathsf{poly}(n)</span>. Let <span class="math">\\Pi</span> be a PIOP for a finite field <span class="math">\\mathbb{F}=\\mathbb{Z}_{q}</span> for a prime <span class="math">q\\approx 2^{\\lambda}</span> and for an indexed relation <span class="math">\\mathcal{R}</span>, where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi.\\mathcal{I}</span> produces multilinear polynomials <span class="math">\\tilde{p}_{1}^{\\dot{\\mathfrak{s}}},\\ldots,\\tilde{p}_{i}^{\\dot{\\mathfrak{s}}}\\in\\mathbb{Z}_{q}[X_{1},\\ldots,X_{n}]</span>.</li>

    </ol>

    <p class="text-gray-300">There is an implementation of <span class="math">\\Pi</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it remains correct if one replaces each indexer’s multilinear polynomial <span class="math">\\tilde{p}_{j}^{\\dot{\\mathfrak{s}}}</span> with a polynomial <span class="math">p_{j}^{\\dot{\\mathfrak{s}}}</span> of higher degree <span class="math">d&gt;1</span> that agrees on the boolean hypercube, i.e., <span class="math">\\forall\\mathbf{b}\\in\\{0,1\\}^{n}:\\tilde{p}_{j}^{\\dot{\\mathfrak{s}}}(\\mathbf{b})=p_{j}^{\\dot{\\mathfrak{s}}}(\\mathbf{b})</span>;</li>

      <li>the prover’s algorithm has only oracle access to the indexer’s polynomials and its running time is <span class="math">\\mathsf{T}_{\\Pi,\\mathcal{P}}=\\mathsf{T}_{\\mathbb{F}}+\\mathsf{T}_{\\dot{\\mathfrak{s}}}</span>, where <span class="math">\\mathsf{T}_{\\mathbb{F}}</span> is the number of field operations and <span class="math">\\mathsf{T}_{\\dot{\\mathfrak{s}}}</span> the number of oracle calls to the indexer’s polynomials;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. the prover’s time <span class="math">\\mathsf{T}_{\\mathbb{F}},\\mathsf{T}_{\\dot{\\mathfrak{s}}}</span> and the remaining efficiency measures of <span class="math">\\Pi</span> depend only polynomially on the degree <span class="math">d</span> and the number of variables <span class="math">n</span> of the indexer’s polynomials (namely, we can express them as functions <span class="math">\\mathsf{T}_{\\mathbb{F}}(d,n),\\mathsf{T}_{\\dot{\\mathfrak{s}}}(d,n),\\mathsf{r}(d,n)</span>, <span class="math">\\mathsf{q}(d,n)</span>, <span class="math">\\mathsf{o}(d,n)</span>, <span class="math">\\mathsf{s}(d,n)</span>, ignoring for simplicity their dependence on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$);</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>it achieves <span class="math">\\delta(d,n)</span>-knowledge-soundness with <span class="math">\\delta(d,n)=\\mathsf{negl}(\\lambda)</span> whenever <span class="math">d=\\mathsf{poly}(\\lambda)</span>.</li>

    </ol>

    <p class="text-gray-300">Then, there exists an index-efficient PIOP <span class="math">\\hat{\\Pi}</span> for the indexed relation <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">We now provide the required preliminaries on Lagrange interpolation before describing our index-efficient PIOP construction <span class="math">\\hat{\\Pi}</span> (see Construction 2) stated in Theorem 6 above. Then, we provide the corresponding proof.</p>

    <p class="text-gray-300"><strong>Preliminaries on Lagrange interpolation.</strong> For any <span class="math">\\mathbf{b} \\in \\{0,1\\}^n</span>, let <span class="math">\\tilde{eq}(\\mathbf{X};\\mathbf{b}) = \\prod_{i=1}^{n}(X_i b_i + (1 - X_i)(1 - b_i))</span> be the multilinear polynomial in <span class="math">\\mathbb{F}[\\mathbf{X}]</span> such that, for every <span class="math">\\mathbf{x} \\in \\{0,1\\}^n</span>, <span class="math">\\tilde{eq}(\\mathbf{x};\\mathbf{b}) = 1</span> if <span class="math">\\mathbf{x} = \\mathbf{b}</span>, and is 0 otherwise. The set <span class="math">\\{\\tilde{eq}(\\mathbf{X};\\mathbf{b}) : \\mathbf{b} \\in \\{0,1\\}^n\\}</span> is the set of Lagrange basis polynomials for interpolation domain <span class="math">\\{0,1\\}^n</span>. Here we shortly call it a <span class="math">\\{0,1\\}^n</span>-basis.</p>

    <p class="text-gray-300">Given a set <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> of size <span class="math">d + 1</span>, we define the <span class="math">m</span>-variate polynomials <span class="math">\\{L(\\mathbf{Y};\\mathbf{h}) : \\mathbf{h} \\in \\mathbb{H}^m\\}</span> of individual degree <span class="math">\\leq d</span> such that, for every <span class="math">\\mathbf{y} \\in \\mathbb{H}^m</span>, <span class="math">L(\\mathbf{y};\\mathbf{h}) = 1</span> if <span class="math">\\mathbf{y} = \\mathbf{h}</span>, and is 0 otherwise. These polynomials are the set of Lagrange basis polynomials for interpolation domain <span class="math">\\mathbb{H}^m</span>, or shortly an <span class="math">\\mathbb{H}^m</span>-basis.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">h \\in \\mathbb{H}</span>, let <span class="math">L&#x27;(X, h)</span> be the <span class="math">h</span>-th Lagrange univariate polynomial for interpolation domain <span class="math">\\mathbb{H}</span>, i.e., <span class="math">L&#x27;(X; h) = \\prod_{h&#x27; \\in \\mathbb{H}, h&#x27; \\neq h} \\frac{X - h&#x27;}{h - h&#x27;}</span>, that is of degree $d =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">. Then, </span>L<span class="math"> is the product of the </span>m<span class="math"> Lagrange polynomials </span>L(X_1, \\ldots, X_m; h_1, \\ldots, h_m) = \\prod_{i=1}^{m} L'(X_i; h_i)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\mathbb{F} = \\mathbb{Z}_q</span>, let <span class="math">\\mathbb{H} = \\{0,1,\\dots,d\\}</span> and let <span class="math">m,n,\\delta \\in \\mathbb{Z}</span> such that <span class="math">(d + 1)^m = 2^n</span> and <span class="math">\\delta \\cdot m = n</span> (i.e. <span class="math">\\delta = \\log_2(d + 1)</span>). We define the linear map:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathsf {G}: \\mathbb {F} ^ {n} \\to \\mathbb {F} ^ {m}, \\quad (x _ {1}, \\dots , x _ {n}) \\mapsto \\left(\\sum_ {\\eta = 1} ^ {\\delta} x _ {\\delta (k - 1) + \\eta} \\cdot 2 ^ {\\eta - 1}\\right) _ {k = 1} ^ {m}. ^ {2 2}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Construction 2 (Index-efficient PIOP)</strong> Let <span class="math">\\Pi</span> be a PIOP (Definition 15) and PP be a polynomial preprocessing scheme (Definition 12). Then, we build an index-efficient PIOP <span class="math">\\hat{\\Pi}</span> as follows:</p>

    <p class="text-gray-300"><strong>Indexer</strong> <span class="math">\\hat{\\Pi}.\\mathcal{I}(\\mathfrak{i})</span>: First, it runs the indexer of <span class="math">\\Pi</span> to get the multilinear polynomials <span class="math">(\\tilde{p}_1^{\\mathfrak{i}},\\ldots ,\\tilde{p}_{\\mathfrak{i}}^{\\mathfrak{i}})\\gets \\mathcal{I}(\\mathfrak{i})</span>. Then, for each polynomial <span class="math">\\tilde{p}_j^{\\mathfrak{i}}</span>, it proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose integers <span class="math">m, d</span> such that <span class="math">(d + 1)^m = 2^n</span> and for which there exists an efficient PP scheme, and generate <span class="math">\\mathsf{PP.Params}(\\mathbb{Z}_q, m, d)</span>.</li>

      <li>Build the <span class="math">m</span>-variate polynomial <span class="math">\\hat{p}_j^{\\mathfrak{i}}(Y_1, \\ldots, Y_m) = \\sum_{\\mathbf{b} \\in \\{0, 1\\}^n} \\tilde{p}_j^{\\mathfrak{i}}(\\mathbf{b}) \\cdot L(Y_1, \\ldots, Y_m; \\mathsf{G}(\\mathbf{b}))</span> of individual degree <span class="math">\\leq d</span> such that <span class="math">(d + 1)^m = 2^n</span>.</li>

      <li>Compute <span class="math">\\mathsf{hk}_{\\mathfrak{i}} = \\mathsf{DS}_j \\gets \\mathsf{PP.PreProcess}(\\mathsf{pp}, \\hat{p}_j^{\\mathfrak{i}})</span>.</li>

      <li>Build the multivariate polynomial <span class="math">p_j^{\\mathfrak{i}}(X_1, \\ldots, X_n) = \\hat{p}_j^{\\mathfrak{i}}(\\mathsf{G}(X_1, \\ldots, X_n)) = \\hat{p}_j^{\\mathfrak{i}}((\\sum_{\\eta \\in [\\delta]} X_{\\delta(k-1)+\\eta} \\cdot 2^{\\eta-1})_{k \\in [m]})</span>.</li>

    </ul>

    <p class="text-gray-300">Finally, it outputs <span class="math">p_1^{\\mathfrak{i}}, \\ldots, p_l^{\\mathfrak{i}}</span> and <span class="math">\\mathsf{hk}_{\\mathfrak{i}} = (\\mathsf{DS}_1, \\ldots, \\mathsf{DS}_i)</span>.</p>

    <p class="text-gray-300"><strong>Prover</strong> <span class="math">\\hat{\\Pi}.\\mathcal{P}(\\mathsf{hk}_{\\mathfrak{i}},\\mathbb{x},\\mathbb{w})</span>: It runs <span class="math">\\Pi.\\mathcal{P}</span> on <span class="math">(\\mathbb{x},\\mathbb{w})</span> and for every oracle call of <span class="math">\\Pi.\\mathcal{P}</span> to <span class="math">p_j^{\\mathfrak{i}}</span> on a point <span class="math">\\mathbf{z} \\in \\mathbb{F}^n</span>, <span class="math">\\hat{\\Pi}.\\mathcal{P}</span> answers as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\hat{\\mathbf{z}} = (\\hat{z}_i)_{i\\in [m]} = \\mathsf{G}(\\mathbf{z})</span>, the evaluation <span class="math">y_{j} = \\hat{p}_{j}^{\\mathfrak{i}}(\\hat{\\mathbf{z}})</span> where <span class="math">(i_j)_{j\\in [k]}\\gets \\mathsf{PP.Lookup}(\\mathsf{pp},\\hat{\\mathbf{z}})</span> and <span class="math">y_{j}\\gets \\mathsf{PP.Reconstruct}(\\mathsf{pp},\\mathsf{DS}_{j,i_1},\\ldots ,\\mathsf{DS}_{j,i_k})</span>.</li>

      <li>Return <span class="math">y_{j}</span> to <span class="math">\\Pi .\\mathcal{P}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Verifier</strong> <span class="math">\\hat{\\Pi}.\\mathcal{V}(\\mathbb{x})</span>: This is identical to <span class="math">\\Pi.\\mathcal{V}</span>.</p>

    <p class="text-gray-300"><strong>Correctness of <span class="math">\\hat{\\Pi}</span>.</strong> Notice that <span class="math">p_j^{\\mathfrak{i}}</span> is an <span class="math">n</span>-variate polynomial of individual degree <span class="math">\\leq d</span> that agrees with <span class="math">\\tilde{p}_j^{\\mathfrak{i}}</span> over the <span class="math">n</span>-dimensional hypercube since</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathbf {b} \\in \\{0, 1 \\} ^ {n}: \\tilde {p} _ {j} ^ {\\mathfrak {i}} (\\mathbf {b}) = \\hat {p} _ {j} ^ {\\mathfrak {i}} (\\mathsf {G} (\\mathbf {b})) = p _ {j} ^ {\\mathfrak {i}} (\\mathbf {b})</span></div>

    <p class="text-gray-300">22 This is almost the same as the gadget matrix of lattice-based cryptosystems.</p>

    <p class="text-gray-300">where the second equality follows by construction of <span class="math">p_j^\\downarrow</span> from <span class="math">\\tilde{p}_j^\\downarrow</span>, and the second equality by construction of <span class="math">\\tilde{p}_j^\\downarrow</span> from <span class="math">\\tilde{p}_j^\\downarrow</span> and the fact that <span class="math">\\forall \\mathbf{b}, \\mathbf{b}&#x27; \\in \\{0,1\\}^n</span>, <span class="math">L(\\mathsf{G}(\\mathbf{b}), \\mathsf{G}(\\mathbf{b}&#x27;)) = 1</span> if <span class="math">\\mathbf{b}&#x27; = \\mathbf{b}</span> and is 0 otherwise. Therefore by property (2) in the Theorem statement, we get correctness from that of <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">Efficiency of <span class="math">\\hat{\\Pi}</span>. Let us start by analyzing the efficiency of the prover. <span class="math">\\hat{\\Pi}.\\mathcal{P}</span> executes <span class="math">\\Pi.\\mathcal{P}</span> while simulating each of the <span class="math">\\mathsf{T}_{\\downarrow}</span> oracle calls of <span class="math">\\Pi.\\mathcal{P}</span> to the indexer multilinear polynomials by first computing <span class="math">\\mathbf{z}</span>, which takes <span class="math">O(n)</span> <span class="math">\\mathbb{Z}_q</span>-operations, and then by doing a fast evaluation of the polynomial using the PP scheme, which costs <span class="math">\\mathsf{poly}(\\log q,n)</span> due to the efficiency property of <span class="math">\\mathsf{PP}</span>. Hence, <span class="math">\\mathsf{T}_{\\hat{\\Pi},\\mathcal{P}} = \\mathsf{T}_{\\mathbb{F}}(d,n) + \\mathsf{T}_{\\downarrow}(d,n) \\cdot \\mathsf{poly}(\\log q,n)</span> which depends only polynomially on <span class="math">n</span> if so do <span class="math">\\mathsf{T}_{\\mathbb{F}}(d,n), \\mathsf{T}_{\\downarrow}(d,n)</span> and <span class="math">d</span>, as assumed in the Theorem's statement. The same polynomial dependence on <span class="math">n</span> holds for all the other efficiency measures.</p>

    <p class="text-gray-300">Security of <span class="math">\\hat{\\Pi}</span>. It is immediate to see that by construction, if <span class="math">\\Pi</span> has <span class="math">\\delta(d,n)</span>-knowledge-soundness, then so does <span class="math">\\hat{\\Pi}</span>. By the property (5) of <span class="math">\\Pi</span> in the assumption of the theorem, <span class="math">\\Pi</span> has knowledge-soundness <span class="math">\\delta(d,n) = \\mathsf{negl}(\\lambda)</span> whenever <span class="math">d = \\mathsf{poly}(\\lambda)</span>, which is the case as shown in the efficiency proof since <span class="math">d = \\mathsf{poly}(n) = \\mathsf{polylog}(\\lambda)</span>.</p>

    <h2 id="sec-43" class="text-2xl font-bold">5.3 Application to Table-Efficient Lookup Arguments</h2>

    <p class="text-gray-300">As a novel application of our techniques in this section, we can instantiate Theorem 6 using the GeneralizedLasso PIOP in [STW24, Appendix F.2] which supports lookup relations over arbitrary tables. In a nutshell, this is a PIOP in which the indexer produces a multilinear polynomial <span class="math">\\tilde{t} \\in \\mathbb{F}[X_1, \\ldots, X_n]</span> such that each <span class="math">\\tilde{t}(\\mathbf{b})</span> encodes a distinct value of the lookup table, and then the prover can send a multilinear polynomial <span class="math">\\tilde{a} \\in \\mathbb{F}[X_1, \\ldots, X_\\mu]</span> and convince the verifier that <span class="math">\\forall \\mathbf{j} \\in \\{0,1\\}^\\mu : \\tilde{a}(\\mathbf{j}) \\in \\{\\tilde{t}(\\mathbf{b}) : \\mathbf{b} \\in \\{0,1\\}^n\\}</span>.</p>

    <p class="text-gray-300">A crucial building block of the GeneralizedLasso PIOP is a PIOP for sparse-dense sumcheck in which the prover wants to convince the verifier that <span class="math">y = \\sum_{\\mathbf{b} \\in \\{0,1\\}^n} \\tilde{u}(\\mathbf{b}) \\cdot \\tilde{t}(\\mathbf{b})</span> where <span class="math">\\tilde{t}</span> is the same multilinear polynomial produced by the indexer, and <span class="math">\\tilde{u}</span> is a multilinear <span class="math">n</span>-variate polynomial (implicitly defined by other polynomials previously sent by the prover) that is sparse, namely the number of nonzero values in <span class="math">\\{\\tilde{u}(\\mathbf{b}) : \\mathbf{b} \\in \\{0,1\\}^n\\}</span> is <span class="math">2^\\mu \\ll 2^n</span>. This PIOP for sparse-dense sumcheck is the only component of the protocol that depends on the large polynomial <span class="math">\\tilde{t}</span>.</p>

    <p class="text-gray-300">This PIOP is simply a PIOP for the sumcheck protocol over the polynomial <span class="math">g(\\mathbf{X}) = \\tilde{u}(\\mathbf{X}) \\cdot \\tilde{t}(\\mathbf{X})</span> and its main distinction is that [STW24, Theorem 6] shows how to implement its prover in <span class="math">(2^{\\mu} \\cdot n \\cdot \\text{EvalTime}(\\tilde{t}))</span> field operations. This result is useful in those use cases where the polynomial associated to the lookup table has a closed form that allows fast evaluation (e.g., <span class="math">\\text{poly}(n)</span>) and thus whenever <span class="math">2^{\\mu} \\ll 2^{n}</span> the prover time loosely depends on the size of the table.</p>

    <p class="text-gray-300">Next, we show a generalized description of the sparse-dense sumcheck PIOP [STW24] that makes it obvious that it handles the general case of a polynomial <span class="math">t</span> which is not necessarily multilinear. Let <span class="math">S_{u} = \\{\\mathbf{b}\\in \\{0,1\\}^{n}:\\tilde{u} (\\mathbf{b})\\neq 0\\}</span> be the set of indices where <span class="math">\\tilde{u} (\\mathbf{b})</span> is nonzero and assume that the prover stores <span class="math">\\tilde{u}</span> in evaluation form <span class="math">\\{\\tilde{u} (\\mathbf{b})\\}</span>. The sparse-dense sumcheck PIOP [STW24] is defined as follows:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">Let us now see how this PIOP satisfies the 5 requirements of Theorem 6, and thus it can be compiled into an index-efficient PIOP.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first requirement, that  <span class="math">\\tilde{t}</span>  is multilinear, is by construction in [STW24].</li>

      <li>If we replace the multilinear  <span class="math">\\tilde{t}</span>  by a polynomial  <span class="math">t</span>  of degree  <span class="math">d &amp;gt; 1</span>  (which agrees with  <span class="math">\\tilde{t}</span>  on the boolean hypercube), the correctness is preserved because the sumcheck claim  <span class="math">y = \\sum_{\\mathbf{b} \\in \\{0,1\\}^n} \\tilde{u}(\\mathbf{b}) \\cdot \\tilde{t}(\\mathbf{b})</span>  remains identical.</li>

      <li>By our description above, it is straightforward to see that the prover can be implemented using calls to the  <span class="math">\\tilde{t} (\\cdot)</span>  polynomial.</li>

      <li>Let  <span class="math">d = \\deg(\\tilde{t})</span> . Then by inspection of the algorithm above, the prover performs  <span class="math">\\mathsf{T}_{\\mathbb{F}} = O(2^{\\mu} \\cdot n \\cdot d)</span>  field operations, plus  <span class="math">\\mathsf{T}_{\\mathbb{i}} = O(2^{\\mu} \\cdot n \\cdot d)</span>  evaluation calls to  <span class="math">\\tilde{t}(\\cdot)</span> . Furthermore, by the efficiency profile of the sumcheck protocol executed on a polynomial of degree  <span class="math">\\leq d + 1</span> , we have that: the verifier makes  <span class="math">\\mathfrak{q}_{\\mathcal{I}}(d,n) = 1</span>  query to the indexer's polynomial  <span class="math">\\tilde{t}</span>  and  <span class="math">\\mathfrak{q}_{\\mathcal{P}}(d,n) = 1</span>  query to the prover's polynomial  <span class="math">\\tilde{u}</span> , and the prover sends  <span class="math">O(dn)</span>  field elements in  <span class="math">n</span>  rounds.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5.  <span class="math">\\Pi</span>  achieves  <span class="math">\\delta(d, n)</span> -knowledge-soundness with  $\\delta(d, n) = \\frac{n(d + 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , where  </span>d = \\deg(\\tilde{t})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we show how to use our Theorem 6 to obtain another new result: an index-efficient PIOP for linear checks, namely to prove that  <span class="math">\\mathbf{v} = \\mathbf{M} \\cdot \\mathbf{z}</span>  in time  <span class="math">N \\cdot \\mathrm{polylog}(N)</span>  when the  <span class="math">N \\times N</span>  matrix  <span class="math">\\mathbf{M}</span>  is fixed and preprocessed and  <span class="math">\\mathbf{v}, \\mathbf{z}</span>  are two vectors sent by the prover. This result is new because in existing PIOPs the prover complexity is at best  $O(\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, N))<span class="math"> , hence linear in the number of nonzero entries of the matrix  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , which is  </span>N^2$ ) in the worst case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our new index-efficient PIOP for linear checks can be used to construct an index-efficient PIOP for (universal) rank-1 constraint systems (R1CS), which can be in turn used to build an index-efficient PIOP for circuit satisfiability. In R1CS, the universal relation is indexed by matrix tuples  <span class="math">(\\mathbf{A},\\mathbf{B},\\mathbf{C})</span>  and the prover needs to convince the verifier that  <span class="math">\\exists \\mathbf{z}:(\\mathbf{A}\\cdot \\mathbf{z})\\circ (\\mathbf{B}\\cdot \\mathbf{z}) = (\\mathbf{C}\\cdot \\mathbf{z})</span> . Several works show how to construct a PIOP for R1CS by combining a PIOP for linear checks (or</p>

    <p class="text-gray-300">"lincheck"), to prove  <span class="math">\\exists \\mathbf{a}, \\mathbf{b}, \\mathbf{c}, \\mathbf{z}: \\mathbf{a} = \\mathbf{A} \\cdot \\mathbf{z}, \\mathbf{b} = \\mathbf{B} \\cdot \\mathbf{z}, \\mathbf{c} = \\mathbf{C} \\cdot \\mathbf{z}</span> , with a PIOP for Hadamard products, to prove that  <span class="math">\\mathbf{a} \\circ \\mathbf{b} = \\mathbf{c}</span> . Therefore, to build an index-efficient PIOP for R1CS we can simply replace the lincheck PIOP in other constructions, e.g., [Set20], with our index-efficient one. This way, after preprocessing the matrices  <span class="math">\\mathbf{A}, \\mathbf{B}, \\mathbf{C}</span> , the prover's running time does not depend on their density and thus it is index-efficient whenever the number of nonzero entries is  <span class="math">\\omega(N\\mathrm{polylog}(N))</span> . This is for example the case for circuits with many more addition gates than multiplication gates e.g.,  <span class="math">O(N^2)</span>  addition gates and  <span class="math">O(N)</span>  multiplication gates.</p>

    <p class="text-gray-300">Our Index-Efficient Lincheck PIOP. We construct this PIOP by instantiating Theorem 6 with the following, not index-efficient, PIOP. This is a PIOP in which the indexer produces a multilinear polynomial  <span class="math">\\tilde{M} \\in \\mathbb{F}[X_1, \\ldots, X_{2n}]</span> , and then the prover sends two multilinear polynomials  <span class="math">\\tilde{z}, \\tilde{v} \\in \\mathbb{F}[X_1, \\ldots, X_n]</span>  and convinces the verifier that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathbf {h} \\in \\{0, 1 \\} ^ {n}: \\tilde {v} (\\mathbf {h}) = \\sum_ {\\mathbf {b} \\in \\{0, 1 \\} ^ {n}} \\tilde {M} (\\mathbf {h}, \\mathbf {b}) \\cdot \\tilde {z} (\\mathbf {b}).</span></div>

    <p class="text-gray-300">If we think of  <span class="math">\\tilde{M},\\tilde{z},\\tilde{v}</span>  as polynomials interpolating an  <span class="math">N\\times N</span>  matrix  <span class="math">\\mathbf{M}</span>  and two vectors  <span class="math">\\mathbf{z},\\mathbf{v}</span>  of size  <span class="math">N = 2^n</span>  respectively, then this PIOP proves that  <span class="math">\\mathbf{v} = \\mathbf{M}\\cdot \\mathbf{z}</span> .</p>

    <p class="text-gray-300">This PIOP is a rewriting of the matrix multiplication interactive proof of Thaler [Tha13] in which one matrix,  <span class="math">\\mathbf{M}</span> , is fixed and the others have only one column. The crucial observation that we provide in this section is the fact that the prover of this PIOP can be implemented in a way that satisfies the requirements 2-5 of our Theorem 6, and thus it can be compiled into an index-efficient PIOP in which the prover running time is sub-linear in the size of the matrix  <span class="math">\\mathbf{M}</span> . Next, we provide a description of this PIOP.</p>

    <pre><code class="language-latex">Lincheck PIOP for  $\\forall \\mathbf{h}\\in \\{0,1\\} ^n:\\tilde{v} (\\mathbf{h}) = \\sum_{\\mathbf{b}\\in \\{0,1\\} ^n}\\tilde{M} (\\mathbf{h},\\mathbf{b})\\cdot \\tilde{z} (\\mathbf{b})$
Verifier: Send  $\\mathbf{s}\\gets \\mathbf{s}\\mathbb{F}^n$  Run sumcheck to prove  $\\tilde{v} (\\mathbf{s}) = \\sum_{\\mathbf{b}\\in \\{0,1\\} ^n}\\tilde{M} (\\mathbf{s},\\mathbf{b})\\cdot \\tilde{z} (\\mathbf{b}).$  for  $j = 1,\\ldots ,n$  do Below, assume  $E[c] = 1$  and that all  $g_{j,k}$  are initialized to O. Prover  $\\mathcal{P}^{M(\\cdot)}$  .. for b in  $\\{0,1\\} ^n$  do E[b1,...,bj-1]  $= \\acute{e} q(r_1,\\dots,r_{j - 1};b_1,\\dots,b_{j - 1})$ $E[b_1,\\dots,b_{j - 1}]\\leftarrow E[b_1,\\dots,b_{j - 2}]\\cdot \\acute{e} q(r_{j - 1};b_{j - 1})$  for  $k = 0,1,\\ldots d + 1$  do  $g_{j,k}\\gets g_{j,k} + \\tilde{M} (\\mathbf{s},r_1,\\dots,r_{j - 1},k,b_{j + 1},\\dots,b_n)\\cdot E[b_1,\\dots,b_{j - 1}]\\cdot \\acute{e} q(k;b_j)\\cdot \\tilde{z} (\\mathbf{b})$  //  $g_{j,k} = \\sum_{\\mathbf{b}\\in \\{0,1\\} ^n}\\tilde{M} (\\mathbf{s},r_1,\\dots,r_{j - 1},k,b_{j + 1},\\dots,b_n)\\cdot \\acute{e} q(r_1,\\dots,r_{j - 1},k,b_{j + 1},\\dots,b_n,\\mathbf{b})\\cdot \\tilde{z} (\\mathbf{b})$  Send  $(g_{j,0},\\ldots ,g_{j,d + 1})$  Verifier: Send  $r_j\\gets \\mathbf{s}\\mathbb{F}$
Verifier:  $\\mathcal{V}^{\\tilde{M} (\\cdot),\\tilde{z} (\\cdot),\\tilde{v} (\\cdot)}$  : Query  $\\tilde{M} (\\mathbf{s},r_1,\\dots,r_n),\\tilde{z} (r_1,\\dots,r_n),\\tilde{v} (\\mathbf{s})$  and accept if the following condition holds:  $\\left(\\forall j\\in [m]:g_{j - 1}(r_{j - 1})\\stackrel {?}{=}\\sum_{\\mathbf{b}\\in \\{0,1\\}}g_j(b)\\right)\\wedge \\left(g_n(r_n)\\stackrel {?}{=}\\tilde{u} (r_1,\\dots,r_n)\\cdot \\tilde{M} (\\mathbf{s},r_1,\\dots,r_n)\\right)$  where  $g_0(r_0) = \\tilde{v} (\\mathbf{s})$  and  $g_{j}(X)\\gets$  Interpolate(  $\\{0,\\ldots ,d + 1\\} ,\\{g_{j,0},\\ldots ,g_{j,d + 1}\\})$</code></pre>

    <p class="text-gray-300">Let us now see how this PIOP satisfies the 5 requirements of Theorem 6, and thus it can be compiled into an index-efficient PIOP.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first requirement, that  <span class="math">\\tilde{M}</span>  is multilinear, is by construction.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If we replace the multilinear <span class="math">\\tilde{M}</span> by a polynomial <span class="math">M</span> of degree <span class="math">d&gt;1</span> (which agrees with <span class="math">\\tilde{M}</span> on the boolean hypercube), the correctness is preserved because the claim <span class="math">\\forall\\mathbf{h}\\in\\{0,1\\}^{n}:\\tilde{v}(\\mathbf{h})=\\sum_{\\mathbf{b}\\in\\{0,1\\}^{n}}M(\\mathbf{h},\\mathbf{b})\\cdot\\tilde{z}(\\mathbf{b})</span> remains identical.</li>

      <li>By our description above, it is straightforward to see that the prover can be implemented using calls to the <span class="math">\\tilde{M}(\\cdot)</span> polynomial.</li>

      <li>Let <span class="math">d=\\mathsf{deg}(\\tilde{M})</span>. Then by inspection of the algorithm above, the prover performs <span class="math">\\mathsf{T}_{\\mathbb{F}}=O(2^{n}\\cdot n\\cdot d)</span> field operations, plus <span class="math">\\mathsf{T}_{\\mathbb{i}}=O(2^{n}\\cdot n\\cdot d)</span> evaluation calls to <span class="math">\\tilde{M}(\\cdot)</span>. Furthermore, by the efficiency profile of the sumcheck protocol executed on a polynomial of degree <span class="math">\\leq d+1</span>, we have that: the verifier makes <span class="math">\\mathsf{q}_{\\mathcal{I}}(d,n)=1</span> query to the indexer’s polynomial <span class="math">\\tilde{M}</span> and <span class="math">\\mathsf{q}_{\\mathcal{P}}(d,n)=2</span> queries to the prover’s polynomials <span class="math">\\tilde{v},\\tilde{z}</span>, and the prover sends <span class="math">O(dn)</span> field elements in <span class="math">n</span> rounds.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. <span class="math">\\mathsf{\\Pi}</span> achieves <span class="math">\\delta(d,n)</span>-knowledge-soundness with $\\delta(d,n)=\\frac{n(2d+1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, where </span>d=\\mathsf{deg}(\\tilde{M})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-45" class="text-2xl font-bold">6 Witness-Succinct UC SNARKs with Nearly Optimal Proving Time</h2>

    <p class="text-gray-300">Here, we show how to obtain UC-SNARKs with approximately-linear proving time generically from PCs with fast opening. The reader is referred to the introduction for a discussion of the importance of proving SNARKs in the UC model and the associated challenges. All the polynomial commitments in this section are implicitly for the <em>univariate case</em> only.</p>

    <p class="text-gray-300">Our starting point is <em>[GKO^{+}23]</em>, which proposes a general and elegant compiler which maps any simulation-extractable zkSNARK <span class="math">\\Pi</span> into an UC-secure one. In order to obtain straight-line extractability they adopt a Fischlin-style proof-of-work <em>[x10]</em>: the witness is extracted by observing the prover’s queries to the random oracle (queries that are “forced on” the prover by the proof-of-work aspect of technique). A key step of their approach involves the prover sending a polynomial commitment, allegedly opening to (an encoding of) the witness.</p>

    <p class="text-gray-300">Efficiency-preserving transformations. One of the advantages of the compiler in <em>[GKO^{+}23]</em> is that it preserves the essential verification and communication complexity of the original zkSNARK <span class="math">\\Pi</span> Unfortunately, for proving time, the same compiler substantially changes the prover’s efficiency profile: even if the original proving time of <span class="math">\\Pi</span> is <span class="math">O(n)</span> (where <span class="math">n</span> is the size of the witness), the resulting UC zkSNARK will run in time at least <span class="math">O(n^{2})</span>.</p>

    <p class="text-gray-300">The overhead above stems from the requirement in <em>[GKO^{+}23]</em> that the prover queries the random oracle multiple times during the proof-of-work stage. Recall that, as mentioned above, the prover holds a commitment <span class="math">\\mathsf{cm}_{f}</span> to a univariate polynomial <span class="math">f</span> dependent on the witness. Each of the prover’s query <span class="math">q</span> to the random oracle is supposed to include, among other elements, a tuple <span class="math">(z,y,\\pi)</span> where <span class="math">\\pi</span> is an evaluation proof for <span class="math">\\mathsf{cm}_{f}</span> showing that <span class="math">f(z)=y</span>. The prover performs <span class="math">\\approx n</span> of these invocations throughout the protocol. If at this step, we are applying a <em>standard</em> polynomial commitments, then each evaluation proof requires approximately <span class="math">O(\\mathsf{deg}(f))</span> steps. Since it holds that <span class="math">\\mathsf{deg}(f)\\geq n</span>, a traditional polynomial commitment will lead to a total quadratic proving time.</p>

    <p class="text-gray-300">A first (flawed) approach. It seems that using our PC with sublinear opening time in the compiler in <em>[GKO^{+}23]</em>, would remove this quadratic complexity. At commitment time, the prover will spend <span class="math">O_{\\lambda}(n^{1+\\epsilon})</span> time (see preliminaries) to generate the polynomial commitment and will then store the appropriate auxiliary information; for each of the <span class="math">\\approx n</span> queries to the RO the prover computes</p>

    <p class="text-gray-300">an evaluation opening and each can be performed in <span class="math">O(\\mathsf{polylog}(n))</span> time with our construction in Section 4. Since the total proving time is <span class="math">\\approx n\\cdot\\mathsf{polylog}(n)\\in O_{\\lambda}(n^{1+\\epsilon})</span>, we obtain as a result an approximately-linear time prover (as long as the original zkSNARK prover runs in quasilinear-time). As an implication, we have the first compiler for general SNARKs with such property. Notice that, if the zkSNARK has polylogarithmic proof size and verification time, these are also preserved.</p>

    <p class="text-gray-300">Unfortunately, the above approach is flawed because our PC is not directly applicable to the the compiler in <em>[GKO^{+}23]</em> which requires the PC to satisfy some “special” properties which are <em>not</em> all satisfied by our PC.</p>

    <p class="text-gray-300">Solving the additional challenges. The first special property is a soft form of non-malleability: it informally states that an efficient adversary should not be able to produce two different evaluation proofs for the same input point <span class="math">z</span> for an honestly generated polynomial commitment (“<em>unique proofs</em>”). Our construction <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> does already satisfy this property (see Theorem 7).</p>

    <p class="text-gray-300">The second required property is a form of hiding. In order to state it, we first recall the methodology followed in the compiler in <em>[GKO^{+}23]</em>, which can be thought of as an <em>encode&commit</em> approach where the prover computes <span class="math">\\mathsf{cm}_{f}\\leftarrow\\mathsf{PC}.{\\mathsf{Com}}(f_{\\mathsf{w}})</span> where <span class="math">f_{\\mathsf{w}}\\leftarrow\\mathsf{PES}.{\\mathsf{Enc}}(\\mathsf{w})</span>. That is, it first encodes the witness (a vector) into a polynomial—using a “polynomial encoding scheme” <span class="math">\\mathsf{PES}</span>—to which it then commits using a polynomial commitment <span class="math">\\mathsf{PC}</span>. The encoding algorithm is randomized and its role is to <em>mask</em> the witness, so that the latter is still hidden to the verifier even after seeing several—approximately <span class="math">\\lambda</span>—polynomial evaluation proofs. If this is the case we say that the polynomial commitment <span class="math">\\mathsf{PC}</span> is “<em>evaluation-hiding</em>” with respect to the encoding scheme <span class="math">\\mathsf{PES}</span>. The reason this notion relies on an additional object, the encoding scheme, is that it allows it to coexist with the requirement over unique proofs. In fact, the latter can be satisfied, at least seemingly, only by a <span class="math">\\mathsf{PC}</span> with <em>deterministic</em> commitment and proving algorithms. This rules out some intuitive-but-wrong approaches; for example, applying a ZK proof systems to achieve this hiding property is not an option.</p>

    <p class="text-gray-300">Our construction in Section 4 does not directly satisfy evaluation-hiding for any of the polynomial encoding schemes in literature we are aware of (we give additional details in Appendix F). The reason is that the underlying approach of Section 4 might inherently have too much leakage. As a consequence, we need to develop a method that can be applied to the compiler from <em>[GKO^{+}23]</em> despite the limitations of our constructions.</p>

    <p class="text-gray-300">Our approach: “bootstrapping” evaluation-hiding. Recall that our main goal is to be able to produce evaluation proofs obtaining, at the same time, three requirements: <span class="math">(i)</span> sublinear opening time; <span class="math">(ii)</span> evaluation-hiding w.r.t. <em>some</em> encoding scheme; <span class="math">(iii)</span> unique proofs. We will temporarily ignore the last property and focus on the tension between the first two. Our solution will turn out to be a <em>hybrid</em> approach that, given:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a polynomial commitment subPC satisfying <span class="math">(i)</span>;</li>

      <li>a polynomial commitment hidPC that is evaluation hiding w.r.t. an encoding scheme hidPC (i.e., that together satisfy <span class="math">(ii)</span>);</li>

    </ul>

    <p class="text-gray-300">obtains a polynomial commitment scheme (and a companion encoding scheme) allowing us to satisfy both <span class="math">(i)</span> and <span class="math">(ii)</span> at the same time. Our approach is relying on subPC to the heavy lifting</p>

    <p class="text-gray-300">in terms of opening proofs, but at the same time it is relying completely on <span class="math">(\\mathsf{hidPC},\\mathsf{hidPES})</span> for evaluation-hiding <em>without having to pay in the total size of the witness</em> (and thus losing property <span class="math">(i)</span>).</p>

    <p class="text-gray-300">In a nutshell, what we do is this. For encoding, we first sample a (symmetric) encryption key <span class="math">\\mathsf{sk}</span> and encrypt the witness obtaining a ciphertext <span class="math">\\mathsf{ct}\\leftarrow\\mathsf{SKE.Enc}(\\mathsf{sk},\\mathsf{w})</span> (both <span class="math">\\mathsf{sk}</span> and <span class="math">\\mathsf{ct}</span>, vectors of scalars); we then build two polynomials <span class="math">f(X):=\\sum_{i}X^{i-1}\\mathsf{ct}_{i}</span> and <span class="math">g(X):=\\mathsf{hidPES.Enc}(\\mathsf{sk})</span>. In order to commit to this encoding, we generate <span class="math">\\mathsf{cm}_{f}\\leftarrow\\mathsf{subPC.Com}(f)</span> and <span class="math">\\mathsf{cm}_{g}\\leftarrow\\mathsf{hidPC.Com}(g)</span>. At opening time, we produce two proofs, one for each commitment. (Note: in exposition above, for simplicity, we “produce in output” <em>two</em> commitments and <em>two</em> encodings, whereas the framework in <em>[GKO^{+}23]</em> expects just one of each. This is easy to fix—as we show in our formal treatment in Fig. 1 —by what is essentially a concatenation of the coefficients and the commitments). In the rest of this section we refer to the resulting “hybrid” polynomial commitment and encoding scheme respectively as <span class="math">\\mathsf{PC}^{\\mathrm{hyb}}</span> and <span class="math">\\mathsf{PES}^{\\mathrm{hyb}}</span>.</p>

    <p class="text-gray-300">As for security, we are able to achieve property <span class="math">(i)</span> because the (hiding) scheme with “slow” openings is operating on a very small polynomial (of degree roughly <span class="math">\\lambda</span>, the size of the encoding of the secret key); we are able to achieve property <span class="math">(ii)</span> because the ciphertexts reveal nothing about the witness (by semantic security) and the openings from <span class="math">\\mathsf{cm}_{g}</span> reveal nothing about the secret key thanks to its evaluation-hiding property. It is straightforward to see that if both polynomial commitments have unique proofs so does the resulting one.</p>

    <p class="text-gray-300">We see our approach as a technique of independent interest since it allows to transform any polynomial commitment scheme into one satisfying evaluation hiding by “piggybacking” on an some other <em>already</em> evaluation-hiding scheme, using it only over a limited portion of the polynomial (e.g., linear in <span class="math">\\lambda</span>). This can be useful, as in our setting, where we want to leverage efficiency properties of a polynomial commitment scheme that is otherwise “too leaky”. The fact that our transformation also preserves unique proofs makes it essentially a bootstrapping technique for the <em>[GKO^{+}23]</em> compiler (see also Appendix F).</p>

    <p class="text-gray-300">We remark that some of the definitions used in the theorems in this section are in the appendix; the espacesential intuitions behind them was, however, given in the the main text.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 1. Our "hybrid" encoding  <span class="math">\\mathsf{PES}^{\\mathrm{hyb}}</span>  and related PC scheme  <span class="math">\\mathsf{PC}^{\\mathrm{hyb}}</span>  for the compiler in Appendix D.5. Above  <span class="math">\\mathcal{Z}_k</span>  is the polynomial vanishing in some known domain of size  <span class="math">k</span> . The key  <span class="math">\\mathbf{sk}</span>  is parsed as a vector of  <span class="math">\\kappa</span>  scalars, where  <span class="math">\\kappa</span>  is a public element depending on the encryption scheme and the size of its key.</p>

    <p class="text-gray-300">We provide the formal description of the "hybrid" polynomial commitment  <span class="math">\\mathsf{PC}^{\\mathrm{hyb}}</span>  and the encoding scheme  <span class="math">\\mathsf{PES}^{\\mathrm{hyb}}</span>  (based on hidPC and subPC, as described above) in Figure 1. Next, we discuss how to instantiate the building blocks in our hybrid approach, informally presented in the last paragraphs, and state some of its basic properties. The notions of unique proofs and evaluation hiding are provided in the appendix (Definition 30 and Definition 32), but the reader can find their informal description in the technical overview. We state only the formal lemmas (defining the properties required by underlying hidPC and subPC) which, in turn, will allow us to establish the final security of  <span class="math">\\mathsf{PC}^{\\mathrm{hyb}}</span>  and  <span class="math">\\mathsf{PES}^{\\mathrm{hyb}}</span> . The formal proofs of the following two lemmas appear in Appendix E.2.</p>

    <p class="text-gray-300">Lemma 1. If hidPC and subPC are polynomial commitments satisfying completeness, (weak) evaluation binding and the unique proof property (Definition 30 in the appendix) then  <span class="math">\\mathsf{PC}^{hyb}</span>  (previous paragraphs; Fig. 1) satisfies the unique proof property.</p>

    <p class="text-gray-300">Lemma 2. If hidPC satisfies evaluation hiding (Definition 32) with respect to hidPES then  <span class="math">\\mathsf{PC}^{hyb}</span>  in Fig. 1 satisfies evaluation hiding with respect to  <span class="math">\\mathsf{PES}^{hyb}</span> .</p>

    <p class="text-gray-300">We now show that our PC Construction 1 satisfies the unique proof property whenever the underlying vector commitment also has unique proofs (this notion is a straightforward counterpart of the one for polynomial commitments and is in Definition 34 in the appendix). Recall that unique proofs property is one of the necessary properties of hidPC and subPC as stated in Lemma 1. We refer the reader to Appendix E.3 for the formal proof.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">If the underlying VC satisfies position binding (Definition 24) and unique proofs (Definition 34) then the <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> construction in Section 4 is a polynomial commitment with unique proofs (Definition 30).</p>

    <p class="text-gray-300">The lemma above, together with the fact that Merkle Trees have computationally unique proofs (this follows directly from collision-resistance) gives us a candidate instantiation for our hybrid construction.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300">If there exist CRHF then there exists a polynomial commitment <span class="math">\\mathsf{subPC}</span> satisfying evaluation binding and unique proofs; for a polynomial of degree <span class="math">d</span>, it features <span class="math">O_{\\lambda}(1)</span>-sized commitments, <span class="math">O_{\\lambda}(d^{1+\\epsilon})</span> commitment time, <span class="math">O_{\\lambda}(\\mathsf{polylog}(d))</span> opening time and evaluation proofs/verification of size/time <span class="math">O_{\\lambda}(\\mathsf{polylog}(d))</span>.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Instantiating <span class="math">\\mathsf{PC}^{\\mathsf{hyb}}</span> and <span class="math">\\mathsf{PES}^{\\mathsf{hyb}}</span>.</h4>

    <p class="text-gray-300">We will use Theorem 7 in order to instantiate <span class="math">\\mathsf{subPC}</span> in Fig. 1. All we are left with is to instantiate <span class="math">\\mathsf{hidPC}</span> and <span class="math">\\mathsf{hidPES}</span>, for which we will use some of the building blocks from the work in <em>[GKO+23]</em>. We will use KZG <em>[x13]</em> as a PC. It features constant-size commitments, proofs and verification; it is secure under the standard Strong Diffie-Hellman (SDH) assumption <em>[x1]</em>.</p>

    <p class="text-gray-300">KZG was shown in <em>[GKO+23]</em> to be evaluation hiding with respect an encoding <span class="math">\\mathsf{PES}_{\\mathsf{coeff}}</span>, which we pick as our choice for <span class="math">\\mathsf{hidPES}</span>. This simple encoding essentially, transforms the input secret vector (in our case case the secret key <span class="math">\\mathsf{sk}</span>) by parsing it as the vector of coefficients of a polynomial and concatenating <span class="math">\\approx\\lambda</span> random freshly sampled coefficients. Its resulting output polynomial is therefore of size <span class="math">O(\\mathsf{poly}(\\lambda))</span>. Full formal treatment of these building blocks is in Appendix D.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Remark 2 (Efficiency of <span class="math">\\mathsf{PC}^{hyb}</span> and <span class="math">\\mathsf{PES}^{hyb}</span>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The resulting efficiency of our hybrid construction (in all metrics) stems from the sum of the efficiency profiles of the its building blocks. Recall that at encoding time we perform an encryption of the witness and we produce an encoding (through <span class="math">\\mathsf{hidPES}</span>) of <span class="math">\\mathsf{sk}</span>. The polynomial commitment algorithms invoke commitment/opening/verification of each of the two underlying schemes. For our specific instantiations, from the above and Theorem 7, we can conclude that: i) encryption dominates the costs in our hybrid encoding scheme, and thus the latter runs in linear time, i.e. $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; the costs in the resulting polynomial commitment are dominated by those of </span>\\mathsf{subPC}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following theorem, whose proof is immediate from the observations and results in this section, we use the fact that the SDH assumption implies DLOG and the existence of CRHF (see Remark 3 in Appendix D).</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">Under the SDH assumption (<em>[x1]</em>) there exist a polynomial commitment <span class="math">\\mathsf{PC}^{hyb}</span> with the properties and efficiency in Theorem 7 and an encoding scheme <span class="math">\\mathsf{PES}^{hyb}</span> with linear-time encoding/decoding such that <span class="math">\\mathsf{PC}^{hyb}</span> is evaluation hiding with respect to <span class="math">\\mathsf{PES}^{hyb}</span>.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">6.2 Our Main Result on Succinct UC-NIZKs</h3>

    <p class="text-gray-300">Before stating our own result, we first recall one regarding the compiler from <em>[GKO+23]</em>. The latter, on input a PC (with some extra properties) and a simulation-extractable NIZK, outputs a</p>

    <p class="text-gray-300">compiled protocol <span class="math">\\Pi_{\\mathsf{GKOPTT}}</span> implementing a UC-NIZK (we refer the reader to Appendix D.5 for the full description of the scheme). The following theorem summarizes its efficiency properties.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 9 (Implicit in <em>[GKO^{+}23, BCC^{+}24]</em>).</h6>

    <p class="text-gray-300">Consider the following primitives:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>NIZK be a simulation-extractable NIZK (Definition 28), which, for a witness of size <span class="math">n</span>, has: proof size <span class="math">O_{\\lambda}(\\ell_{\\mathsf{NIZK}}(n))</span>, quasi-linear proving time (i.e., <span class="math">\\mathsf{T}_{\\mathsf{NIZK.Prove}}=\\widetilde{O}_{\\lambda}(n)</span>), and verification time <span class="math">O_{\\lambda}(\\ell_{\\mathsf{NIZK}}(n))</span>.</li>

      <li>PC be a polynomial commitment having weak evaluation binding (Definition 19), unique proofs (Definition 30), commitments and evaluation proofs both of size <span class="math">O_{\\lambda}(\\ell_{\\mathsf{PC}}(d))</span>, commitment and proving time <span class="math">O_{\\lambda}(\\mathsf{T}_{\\mathsf{PC.Com}}(d))</span> and <span class="math">O_{\\lambda}(\\mathsf{T}_{\\mathsf{PC.Open}}(d))</span> respectively, and verification time <span class="math">O_{\\lambda}(\\ell_{\\mathsf{PC}}(d))</span>.</li>

      <li><span class="math">\\mathsf{PES}=(\\mathsf{Enc},\\mathsf{Dec})</span> be an encoding scheme (Definition 31) s.t. PC is evaluation hiding (Definition 32) with respect to PES and with linear encoding time.</li>

    </ul>

    <p class="text-gray-300">Then, there exists a UC-NIZK (Definition 29) with proof size <span class="math">O_{\\lambda}\\big{(}\\ell_{\\mathsf{NIZK}}(n)+\\ell_{\\mathsf{PC}}(n)\\big{)}</span>, proving time <span class="math">\\widetilde{O}_{\\lambda}\\big{(}\\mathsf{T}_{\\mathsf{PC.Com}}(n)+n\\cdot\\mathsf{T}_{\\mathsf{PC.Open}}(n)\\big{)}</span>, and verification time <span class="math">O_{\\lambda}(\\ell_{\\mathsf{NIZK}}(n)+\\ell_{\\mathsf{PC}}(n))</span>.</p>

    <p class="text-gray-300">Our main technical result of this section is a general theorem showing one can instantiate the compiler in <em>[GKO^{+}23]</em> from any (reasonably efficient) simulation-extractable NIZK and obtain a UC-secure NIZK with approximately-linear time and polylog proof size and verification. The theorem follows by plugging in Theorem 9 our “hybrid” <span class="math">\\mathsf{PC}^{\\mathrm{hyb}}</span> and <span class="math">\\mathsf{PC}^{\\mathrm{hyb}}</span> instantiated as described in this section.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 10.</h6>

    <p class="text-gray-300">Under the Strong Diffie-Hellman assumption (<em>[BB04]</em>), if there exists a simulation-extractable NIZK NIZK with quasilinear proving-time and proof size and verification time <span class="math">O_{\\lambda}(\\mathsf{polylog}(n))</span> (for a witness of size <span class="math">n</span>), then there exists a UC-NIZK (Definition 29 in Appendix D) with <span class="math">O_{\\lambda}(\\mathsf{polylog}(n))</span> proof size and verification time and approximately-linear proving time.</p>

    <p class="text-gray-300">When instantiated with the pairing-based simulation-extractable scheme from Groth and Maller <em>[GM17]</em>—whose security relies on the usual flavor of knowledge-of-exponent assumptions (see Appendix D.4)—we obtain the following result.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">Under the Strong Diffie-Hellman assumption (<em>[BB04]</em>), the Computational Polynomial Assumption and the XPKE Assumption (<em>[GM17]</em>) there exists a UC-NIZK with <span class="math">O_{\\lambda}(\\mathsf{polylog}(n))</span> proof size and verification and approximately-linear proving time.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Acknowledgments.</h4>

    <p class="text-gray-300">The authors thank Dario Catalano and Emanuele Giunta for collaborating during an early stage of this project, and the anonymous CRYPTO 2025 reviewers for hinting the possibility of using preprocessing to construct index-efficient SNARKs for R1CS. Matteo Campanelli would like to thank Justin Thaler and Mathias Hall-Andersen for their thoughtful comments around polynomial commitments based on the techniques in Kedlaya-Umans.</p>

    <h2 id="sec-57" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABC^{+}24] Giuseppe Ateniese, Foteini Baldimtsi, Matteo Campanelli, Danilo Francati, and Ioanna Karantaidou. Advancing scalability in decentralized storage: a novel approach to proof-of-replication via polynomial evaluation. In Annual International Cryptology Conference, pages 3–39. Springer, 2024.</li>

      <li>[</li>

    </ul>

    <p class="text-gray-300">AGRS23. Behzad Abdolmaleki, Noemi Glaeser, Sebastian Ramacher, and Daniel Slamanig. Universally composable NIZKs: Circuit-succinct, non-malleable and CRS-updatable. Cryptology ePrint Archive, Report 2023/097, 2023.</p>

    <p class="text-gray-300">ARS20. Behzad Abdolmaleki, Sebastian Ramacher, and Daniel Slamanig. Lift-and-shift: Obtaining simulation extractable subversion and updatable SNARKs generically. In Jay Ligatti, Xinming Ou, Jonathan Katz, and Giovanni Vigna, editors, ACM CCS 2020: 27th Conference on Computer and Communications Security, pages 1987–2005, Virtual Event, USA, November 9–13, 2020. ACM Press.</p>

    <p class="text-gray-300">BB04. Dan Boneh and Xavier Boyen. Efficient selective-ID secure identity based encryption without random oracles. In Christian Cachin and Jan Camenisch, editors, Advances in Cryptology – EUROCRYPT 2004, volume 3027 of Lecture Notes in Computer Science, pages 223–238, Interlaken, Switzerland, May 2–6, 2004. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">BBF19. Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching techniques for accumulators with applications to IOPs and stateless blockchains. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology – CRYPTO 2019, Part I, volume 11692 of Lecture Notes in Computer Science, pages 561–586, Santa Barbara, CA, USA, August 18–22, 2019. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">BC23. Benedikt Bünz and Binyi Chen. Protostar: Generic efficient accumulation/folding for special-sound protocols. In Jian Guo and Ron Steinfeld, editors, Advances in Cryptology – ASIACRYPT 2023, Part II, volume 14439 of Lecture Notes in Computer Science, pages 77–110, Guangzhou, China, December 4–8, 2023. Springer, Singapore, Singapore.</p>

    <p class="text-gray-300">BCC^{+}24. Christian Badertscher, Matteo Campanelli, Michele Ciampi, Luigi Russo, and Luisa Siniscalchi. Universally composable SNARKs with transparent setup without programmable random oracle. Cryptology ePrint Archive, Paper 2024/1549, 2024.</p>

    <p class="text-gray-300">BCFL23. David Balbás, Dario Catalano, Dario Fiore, and Russell W. F. Lai. Chainable functional commitments for unbounded-depth circuits. In Guy N. Rothblum and Hoeteck Wee, editors, TCC 2023: 21st Theory of Cryptography Conference, Part III, volume 14371 of Lecture Notes in Computer Science, pages 363–393, Taipei, Taiwan, November 29 – December 2, 2023. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B: 14th Theory of Cryptography Conference, Part II, volume 9986 of Lecture Notes in Computer Science, pages 31–60, Beijing, China, October 31 – November 3, 2016. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">BFR^{+}13. Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Verifying computations with state. In Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles, SOSP ’13, page 341–357, New York, NY, USA, 2013. Association for Computing Machinery.</p>

    <p class="text-gray-300">BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, Advances in Cryptology – EUROCRYPT 2020, Part I, volume 12105 of Lecture Notes in Computer Science, pages 677–706, Zagreb, Croatia, May 10–14, 2020. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">BS21. Karim Baghery and Mahdi Sedaghat. Tiramisu: Black-box simulation extractable NIZKs in the updatable CRS model. In Mauro Conti, Marc Stevens, and Stephan Krenn, editors, CANS 21: 20th International Conference on Cryptology and Network Security, volume 13099 of Lecture Notes in Computer Science, pages 531–551, Vienna, Austria, December 13–15, 2021. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">Can01. Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd Annual Symposium on Foundations of Computer Science, pages 136–145, Las Vegas, NV, USA, October 14–17, 2001. IEEE Computer Society Press.</p>

    <p class="text-gray-300">CBBZ23. Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with linear-time prover and high-degree custom gates. In Carmit Hazay and Martijn Stam, editors, Advances in Cryptology – EUROCRYPT 2023, Part II, volume 14005 of Lecture Notes in Computer Science, pages 499–530, Lyon, France, April 23–27, 2023. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CDG^{+}18. Jan Camenisch, Manu Drijvers, Tommaso Gagliardoni, Anja Lehmann, and Gregory Neven. The wonderful world of global random oracles. In Jesper Buus Nielsen and Vincent Rijmen, editors, Advances in Cryptology – EUROCRYPT 2018, Part I, volume 10820 of Lecture Notes in Computer Science, pages 280–312, Tel Aviv, Israel, April 29 – May 3, 2018. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CDPW07. Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Salil P. Vadhan, editor, TCC 2007: 4th Theory of Cryptography Conference, volume 4392 of Lecture Notes in Computer Science, pages 61–85, Amsterdam, The Netherlands, February 21–24, 2007. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">CF13. Dario Catalano and Dario Fiore. Vector commitments and their applications. In Kaoru Kurosawa and Goichiro Hanaoka, editors, PKC 2013: 16th International Conference on Theory and Practice of Public Key Cryptography, volume 7778 of Lecture Notes in Computer Science, pages 55–72, Nara, Japan, February 26 – March 1, 2013. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">CF24. Alessandro Chiesa and Giacomo Fenzi. zkSNARKs in the ROM with unconditional UC-security. In Elette Boyle and Mohammad Mahmoody, editors, TCC 2024: 22nd Theory of Cryptography Conference, Part I, volume 15364 of Lecture Notes in Computer Science, pages 67–89, Milan, Italy, December 2–6, 2024. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CFF^{+}24. Matteo Campanelli, Antonio Faonio, Dario Fiore, Tianyu Li, and Helger Lipmaa. Lookup arguments: Improvements, extensions and applications to zero-knowledge decision trees. In Qiang Tang and Vanessa Teague, editors, PKC 2024: 27th International Conference on Theory and Practice of Public Key Cryptography, Part II, volume 14602 of Lecture Notes in Computer Science, pages 337–369, Sydney, NSW, Australia, April 15–17, 2024. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CFG^{+}20. Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, and Luca Nizzardo. Incrementally aggregatable vector commitments and applications to verifiable decentralized storage. In Shiho Moriai and Huaxiong Wang, editors, Advances in Cryptology – ASIACRYPT 2020, Part II, volume 12492 of Lecture Notes in Computer Science, pages 3–35, Daejeon, South Korea, December 7–11, 2020. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CFG25. Matteo Campanelli, Dario Fiore, and Rosario Gennaro. Natively compatible super-efficient lookup arguments and how to apply them. Journal of Cryptology, 38(1):14, 2025.</p>

    <p class="text-gray-300">CFT22. Dario Catalano, Dario Fiore, and Ida Tucker. Additive-homomorphic functional commitments and applications to homomorphic signatures. In Shweta Agrawal and Dongdai Lin, editors, Advances in Cryptology – ASIACRYPT 2022, Part IV, volume 13794 of Lecture Notes in Computer Science, pages 159–188, Taipei, Taiwan, December 5–9, 2022. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CHM^{+}20. Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Psi Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, Advances in Cryptology – EUROCRYPT 2020, Part I, volume 12105 of Lecture Notes in Computer Science, pages 738–768, Zagreb, Croatia, May 10–14, 2020. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">CJS14. Ran Canetti, Abhishek Jain, and Alessandra Scafuro. Practical UC security with a global random oracle. In Gail-Joon Ahn, Moti Yung, and Ninghui Li, editors, ACM CCS 2014: 21st Conference on Computer and Communications Security, pages 597–608, Scottsdale, AZ, USA, November 3–7, 2014. ACM Press.</p>

    <p class="text-gray-300">EFG22. Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. Cryptology ePrint Archive, Report 2022/1763, 2022.</p>

    <p class="text-gray-300">Fis05. Marc Fischlin. Communication-efficient non-interactive proofs of knowledge with online extractors. In Victor Shoup, editor, Advances in Cryptology – CRYPTO 2005, volume 3621 of Lecture Notes in Computer Science, pages 152–168, Santa Barbara, CA, USA, August 14–18, 2005. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">FKMV12. Sebastian Faust, Markulf Kohlweiss, Giorgia Azzurra Marson, and Daniele Venturi. On the non-malleability of the Fiat-Shamir transform. In Steven D. Galbraith and Mridul Nandi, editors, Progress in Cryptology - INDOCRYPT 2012: 13th International Conference in Cryptology in India, volume 7668 of Lecture Notes in Computer Science, pages 60–79, Kolkata, India, December 9–12, 2012. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, Advances in Cryptology – EUROCRYPT 2013, volume 7881 of Lecture Notes in Computer Science, pages 626–645, Athens, Greece, May 26–30, 2013. Springer Berlin Heidelberg, Germany.</p>

    <p class="text-gray-300">GKM^{+}18. Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In Hovav Shacham and Alexandra Boldyreva, editors, Advances in Cryptology – CRYPTO 2018, Part III, volume 10993 of Lecture Notes in Computer Science, pages 698–728, Santa Barbara, CA, USA, August 19–23, 2018. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">GKO^{+}23. Chaya Ganesh, Yashvanth Kondi, Claudio Orlandi, Mahak Pancholi, Akira Takahashi, and Daniel Tschudi. Witness-succinct universally-composable SNARKs. In Carmit Hazay and Martijn Stam, editors, Advances in Cryptology – EUROCRYPT 2023, Part II, volume 14005 of Lecture Notes in Computer Science, pages 315–346, Lyon, France, April 23–27, 2023. Springer, Cham, Switzerland.</p>

    <p class="text-gray-300">GM17. Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of knowledge from simulation-extractable SNARKs. In Jonathan Katz and Hovav Shacham, editors, Advances in Cryptology –</p>

    <p class="text-gray-300">CRYPTO 2017, Part II, volume 10402 of Lecture Notes in Computer Science, pages 581–612, Santa Barbara, CA, USA, August 20–24, 2017. Springer, Cham, Switzerland.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GOP^{+}22. Chaya Ganesh, Claudio Orlandi, Mahak Pancholi, Akira Takahashi, and Daniel Tschudi. Fiat-shamir bulletproofs are non-malleable (in the algebraic group model). In Orr Dunkelman and Stefan Dziembowski, editors, Advances in Cryptology – EUROCRYPT 2022, Part II, volume 13276 of Lecture Notes in Computer Science, pages 397–426, Trondheim, Norway, May 30 – June 3, 2022. Springer, Cham, Switzerland.</li>

      <li>GOS12. Jens Groth, Rafail Ostrovsky, and Amit Sahai. New techniques for noninteractive zero-knowledge. Journal of the ACM (JACM), 59(3):1–35, 2012.</li>

      <li>Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, Advances in Cryptology – EUROCRYPT 2016, Part II, volume 9666 of Lecture Notes in Computer Science, pages 305–326, Vienna, Austria, May 8–12, 2016. Springer Berlin Heidelberg, Germany.</li>

      <li>KU08. Kiran S. Kedlaya and Christopher Umans. Fast modular composition in any characteristic. In 49th Annual Symposium on Foundations of Computer Science, pages 146–155, Philadelphia, PA, USA, October 25–28, 2008. IEEE Computer Society Press.</li>

      <li>KU11. Kiran S Kedlaya and Christopher Umans. Fast polynomial factorization and modular composition. SIAM Journal on Computing, 40(6):1767–1802, 2011.</li>

      <li>KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, Advances in Cryptology – ASIACRYPT 2010, volume 6477 of Lecture Notes in Computer Science, pages 177–194, Singapore, December 5–9, 2010. Springer Berlin Heidelberg, Germany.</li>

      <li>KZM^{+}15. Ahmed Kosba, Zhichao Zhao, Andrew Miller, Yi Qian, Hubert Chan, Charalampos Papamanthou, Rafael Pass, abhi shelat, and Elaine Shi. C<span class="math">\\varnothing</span>c<span class="math">\\varnothing</span>: A framework for building composable zero-knowledge proofs. Cryptology ePrint Archive, Report 2015/1093, 2015.</li>

      <li>LM19. Russell W. F. Lai and Giulio Malavolta. Subvector commitments with application to succinct arguments. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology – CRYPTO 2019, Part I, volume 11692 of Lecture Notes in Computer Science, pages 530–560, Santa Barbara, CA, USA, August 18–22, 2019. Springer, Cham, Switzerland.</li>

      <li>LMW22. Wei-Kai Lin, Ethan Mook, and Daniel Wichs. Doubly efficient private information retrieval and fully homomorphic ram computation from ring lwe. Cryptology ePrint Archive, 2022.</li>

      <li>LMW23. Wei-Kai Lin, Ethan Mook, and Daniel Wichs. Doubly efficient private information retrieval and fully homomorphic RAM computation from ring LWE. In Barna Saha and Rocco A. Servedio, editors, 55th Annual ACM Symposium on Theory of Computing, pages 595–608, Orlando, FL, USA, June 20–23, 2023. ACM Press.</li>

      <li>Mer88. Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl Pomerance, editor, Advances in Cryptology – CRYPTO’87, volume 293 of Lecture Notes in Computer Science, pages 369–378, Santa Barbara, CA, USA, August 16–20, 1988. Springer Berlin Heidelberg, Germany.</li>

      <li>Set20. Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, Advances in Cryptology – CRYPTO 2020, Part III, volume 12172 of Lecture Notes in Computer Science, pages 704–737, Santa Barbara, CA, USA, August 17–21, 2020. Springer, Cham, Switzerland.</li>

      <li>STW24. Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Unlocking the lookup singularity with Lasso. In Marc Joye and Gregor Leander, editors, Advances in Cryptology – EUROCRYPT 2024, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 180–209, Zurich, Switzerland, May 26–30, 2024. Springer, Cham, Switzerland.</li>

      <li>TAB^{+}20. Alin Tomescu, Ittai Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, and Dmitry Khovratovich. Aggregatable subvector commitments for stateless cryptocurrencies. In Clemente Galdi and Vladimir Kolesnikov, editors, SCN 20: 12th International Conference on Security in Communication Networks, volume 12238 of Lecture Notes in Computer Science, pages 45–64, Amalfi, Italy, September 14–16, 2020. Springer, Cham, Switzerland.</li>

      <li>Tha13. Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay, editors, Advances in Cryptology – CRYPTO 2013, Part II, volume 8043 of Lecture Notes in Computer Science, pages 71–89, Santa Barbara, CA, USA, August 18–22, 2013. Springer Berlin Heidelberg, Germany.</li>

      <li>ZBK^{+}22. Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022: 29th Conference on Computer and Communications Security, pages 3121–3134, Los Angeles, CA, USA, November 7–11, 2022. ACM Press.</li>

    </ul>

    <p class="text-gray-300">\\mathrm{ZGK^{+}22} . Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla Ràfols. Baloo: Nearly optimal lookup arguments. Cryptology ePrint Archive, Report 2022/1565, 2022.</p>

    <p class="text-gray-300">Definition 17 (Correctness of PC). A polynomial commitment scheme PC as defined above is correct if  <span class="math">\\forall \\lambda, m, d \\in \\mathbb{N}</span> , for any polynomial  <span class="math">f \\in \\mathcal{P}_{m,d}</span> , for any point  <span class="math">x \\in R^m</span> , and for any randomness  <span class="math">r \\in \\{0,1\\}^*</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathsf {V e r} (\\mathsf {c k}, \\mathsf {c m}, x, f (x), \\pi_ {x}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, m, d) \\\\ (\\mathsf {c m}, \\mathsf {a u x}) \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, f; r) \\\\ \\pi_ {x} \\leftarrow \\mathsf {O p e n} (\\mathsf {c k}, x, \\mathsf {a u x}) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 18 (Binding of PC). A polynomial commitment scheme PC satisfies commitment binding if for any PPT adversary  <span class="math">\\mathcal{A}</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\operatorname {C o m} (\\mathsf {c k}, f; r) = \\operatorname {C o m} (\\mathsf {c k}, f ^ {\\prime}; r ^ {\\prime}) &amp;amp; \\mathsf {c k} \\leftarrow \\operatorname {S e t u p} (1 ^ {\\lambda}, m, d) \\\\ \\wedge f \\neq f ^ {\\prime} &amp;amp; (f, r, f ^ {\\prime}, r ^ {\\prime}) \\leftarrow \\mathcal {A} (\\mathsf {c k}) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition 19 (Weak Evaluation Binding of PC). A polynomial commitment scheme PC satisfies weak evaluation binding if for any PPT adversary  <span class="math">\\mathcal{A}</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {V e r} (\\mathsf {c k}, \\mathsf {c m}, x, y, \\pi_ {x}) = 1 &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, m, d) \\\\ \\wedge y \\neq f (x) &amp;amp; (f, r, x, y, \\pi_ {x}) \\leftarrow \\mathcal {A} (\\mathsf {c k}) \\\\ &amp;amp; (\\mathsf {c m}, \\mathsf {a u x}) \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, f; r) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition 20 (Strong Evaluation Binding of PC). A polynomial commitment scheme PC satisfies strong evaluation binding if for any PPT adversary  <span class="math">\\mathcal{A}</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} \\forall i \\in [ N ], \\mathsf {V e r} (\\mathsf {c k}, \\mathsf {c m}, x _ {i}, y _ {i}, \\pi_ {i}) = 1 \\\\ \\wedge \\nexists f \\in \\mathcal {P} _ {m, d}, \\forall i \\in [ N ], f (x _ {i}) = y _ {i} \\end{array} \\right] \\begin{array}{l} \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, m, d) \\\\ (\\mathsf {c m}, \\{x _ {i}, y _ {i}, \\pi_ {i} \\} _ {i \\in [ N ]}) \\leftarrow \\mathcal {A} (\\mathsf {c k}) \\end{array} \\in \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Definition 21 (Non-black-box Knowledge Soundness of PC). A polynomial commitment scheme PC satisfies non-black-box knowledge soundness if for any PPT adversary  <span class="math">\\mathcal{A}</span>  there exists a polynomial-time extractor  <span class="math">\\operatorname{Ext}_{\\mathcal{A}}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {V e r} (\\mathsf {c k}, \\mathsf {c m}, x, y, \\pi_ {x}) = 1 \\wedge &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, m, d) \\\\ ((c m, \\cdot) \\neq \\mathsf {C o m} (\\mathsf {c k}, f; r) \\vee y \\neq f (x)) &amp;amp; (c m, x, y, \\pi_ {x}) \\leftarrow \\mathcal {A} (\\mathsf {c k}) \\\\ &amp;amp; (f, r) \\leftarrow \\mathsf {E x t} _ {\\mathcal {A}} (\\mathsf {c k}) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Sometimes we will refer to black-box knowledge soundness which is essentially identical to the above definition except that the extractor  <span class="math">\\mathsf{Ext}</span>  is universal.</p>

    <p class="text-gray-300">A.2 Definitions of Vector Commitments</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 22 (Vector Commitments <em>[x10]</em>).</h6>

    <p class="text-gray-300">A vector commitment scheme <span class="math">\\mathsf{VC}</span> for a message space <span class="math">\\mathcal{M}</span> is defined by the following algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda},n)\\to\\mathsf{ck}</span>: On input the security parameter <span class="math">\\lambda</span> and a bound <span class="math">n</span> for the length of the committed vectors, the setup algorithm outputs a public commitment key <span class="math">\\mathsf{ck}</span>. <span class="math">\\mathsf{Com}(\\mathsf{ck},\\mathbf{v};r)\\to(\\mathsf{cm},\\mathsf{aux})</span>: On input the commitment key <span class="math">\\mathsf{ck}</span>, a vector <span class="math">\\mathbf{v}\\in\\mathcal{M}^{n}</span>, and (possibly) a randomness <span class="math">r</span>, the commit algorithm outputs a commitment <span class="math">\\mathsf{cm}</span> and an auxiliary information <span class="math">\\mathsf{aux}</span>. <span class="math">\\mathsf{Open}(\\mathsf{ck},i,\\mathsf{aux})\\to\\pi_{i}</span>: On input the commitment key <span class="math">\\mathsf{ck}</span>, an index <span class="math">i\\in[n]</span>, and auxiliary information <span class="math">\\mathsf{aux}</span>, the open algorithm outputs a proof <span class="math">\\pi_{i}</span>. <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},i,y,\\pi_{i})\\to b</span>: On input the commitment key <span class="math">\\mathsf{ck}</span>, the commitment <span class="math">\\mathsf{cm}</span>, index <span class="math">i\\in[n]</span>, value <span class="math">y\\in\\mathcal{M}</span>, and a proof <span class="math">\\pi_{i}</span>, the verification algorithm outputs a bit <span class="math">b\\in\\{0,1\\}</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 23 (Correctness of <span class="math">\\mathsf{VC}</span>).</h6>

    <p class="text-gray-300">A vector commitment scheme <span class="math">\\mathsf{VC}</span> as defined above is correct if <span class="math">\\forall\\lambda,n\\in\\mathbb{N}</span>, for any vector <span class="math">\\mathbf{v}\\in\\mathcal{M}^{n}</span>, for any randomness <span class="math">r\\in\\{0,1\\}^{*}</span>, and <span class="math">\\forall i\\in[n]</span>, the following holds:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},i,v_{i},\\pi_{i})=1\\begin{vmatrix}\\mathsf{ck}\\leftarrow\\mathsf{Setup}(1^{\\lambda},n)\\\\ (\\mathsf{cm},\\mathsf{aux})\\leftarrow\\mathsf{Com}(\\mathsf{ck},\\mathbf{v};r)\\\\ \\pi_{i}\\leftarrow\\mathsf{Open}(\\mathsf{ck},i,\\mathsf{aux})\\end{vmatrix}\\right]=1. \\]</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Definition 24 (Position Binding).</h6>

    <p class="text-gray-300">A vector commitment scheme <span class="math">\\mathsf{VC}</span> satisfies position binding if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, the following holds:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},i,y,\\pi_{i})=1\\\\ \\wedge\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},i,y^{\\prime},\\pi^{\\prime}_{i})=1\\\\ \\wedge y\\neq y^{\\prime}\\end{array}\\begin{vmatrix}\\mathsf{ck}\\leftarrow\\mathsf{Setup}(1^{\\lambda},n)\\\\ (\\mathsf{cm},i,y,\\pi_{i},y^{\\prime},\\pi^{\\prime}_{i})\\leftarrow\\mathcal{A}(\\mathsf{ck})\\end{vmatrix}\\right]\\in\\mathsf{negl}(\\lambda). \\]</p>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">Instatiations of VC with fast openings.</h4>

    <p class="text-gray-300">We recall a few instantiations of VCs with fast opening:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Merkle trees <em>[x22]</em> are position binding based on collision resistant hash functions, achieve <span class="math">O(\\lambda\\log n)</span> succinctness, and have fast opening with <span class="math">\\mathsf{T_{Com}}(\\lambda,n)=\\mathsf{poly}(\\lambda)\\cdot n</span> and <span class="math">\\mathsf{T_{Open}}(\\lambda,n)=O(\\lambda\\log n)</span>. The fast opening follows by storing all the nodes of the tree which can be accessed in constant time in the RAM model.</li>

      <li>VCs with quasilinear algorithms to compute openings for all positions. There are a variety of schemes where succinctness and <span class="math">\\mathsf{T_{Open}}(\\lambda,n)</span> are a fixed <span class="math">\\mathsf{poly}(\\lambda)</span>, and where <span class="math">\\mathsf{T_{Com}}(\\lambda,n)=\\mathsf{poly}(\\lambda)\\cdot n\\log n</span> (e.g., for the KZG-based VC from pairings <em>[x24]</em>) or <span class="math">\\mathsf{T_{Com}}(\\lambda,n)=\\mathsf{poly}(\\lambda)\\cdot n\\log^{2}n</span> (e.g., for schemes based on hidden-order groups like <em>[x10, x1, CFG^{+}20]</em>). In fact, Campanelli et al. <em>[CFG^{+}20]</em> show that fast opening follows from any VC with incremental (dis)aggregation.</li>

    </ul>

    <h2 id="sec-64" class="text-2xl font-bold">Appendix B Lack of Strong Evaluation Binding of <span class="math">\\mathsf{PC_{VC}}</span></h2>

    <p class="text-gray-300">Theorem 4 states the evaluation binding property of <span class="math">\\mathsf{PC_{VC}}</span>, which is the standard security notion of polynomial commitments. One may wonder if our construction can satisfy one of the stronger</p>

    <p class="text-gray-300">properties such as strong evaluation binding (Definition 20) or knowledge soundness (Definition 21). In the following theorem we show that, when the PP scheme of Construction 1 is instantiated with the KU-based scheme <em>[x13, x14]</em>, then the resulting <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> is not strongly evaluation binding.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">If the PP scheme of Construction 1 is instantiated with the PP scheme from Theorem 2, then the resulting <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> does not satisfy strong evaluation binding.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first describe the general strategy to construct attacks, and then show a concrete instantiation.</p>

    <p class="text-gray-300">The core observation at the base of the proof is that the space of the data structures is significantly larger than the space of the polynomials we preprocess, whereas, to answer a specific point query, we read only a small subset (<span class="math">k</span> values) of the data structure <span class="math">\\mathsf{DS}</span>. To win the strong evaluation binding experiment, it is sufficient to satisfy the following two conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>provide <span class="math">d^{m}</span> valid proofs <span class="math">\\{\\pi_{x_{i}}\\}_{i\\in[d^{m}]}</span> and evaluations <span class="math">\\{y_{i}\\}_{i\\in[d^{m}]}</span> w.r.t. a set of points <span class="math">\\{x_{i}\\}_{i\\in[d^{m}]}</span> such that the evaluations uniquely determine a polynomial <span class="math">f\\in\\mathcal{P}_{m,d}</span> with <span class="math">f(x_{i})=y_{i}</span> for all <span class="math">i\\in[d^{m}]</span>. For simplicity we will set <span class="math">f=0</span>, i.e. the set of points <span class="math">\\{x_{i}\\}_{i\\in[d^{m}]}</span> should be such that no nonzero polynomial from <span class="math">\\mathcal{P}_{m,d}</span> can evaluate to <span class="math">0</span> in all points. Accordingly, we will set <span class="math">y_{i}=0</span> for all <span class="math">i\\in[d^{m}]</span>.</li>

      <li>provide an additional verifying proof <span class="math">\\tilde{\\pi}_{x}</span> for a new point <span class="math">\\tilde{x}</span> whose claimed evaluation <span class="math">\\tilde{y}</span> is different from <span class="math">0</span>.</li>

    </ol>

    <p class="text-gray-300">A sufficient condition to satisfy condition 1 above is that the set of points <span class="math">\\{x_{i}\\}_{i\\in[d^{m}]}</span> is of the form <span class="math">S^{m}</span>, with <span class="math">S\\subseteq\\mathbb{Z}_{q}</span> being of size <span class="math">d</span> (indeed in these conditions we have a Lagrange basis of <span class="math">\\mathcal{P}_{m,d}</span> with respect to these set of points as shown in Section 5.2). When using the <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> of Theorem 11, condition 2 can be achieved by selecting a point <span class="math">\\tilde{x}</span> such that running <span class="math">\\mathsf{PP.Lookup}(\\mathsf{pp},\\tilde{x})</span> produces indices <span class="math">\\tilde{i}_{1},\\ldots,\\tilde{i}_{k}</span> some of which are never queried by <span class="math">\\mathsf{PP.Lookup}(\\mathsf{pp},x_{i})</span> for all <span class="math">x_{i}\\in S^{m}</span>. Without loss of generality let <span class="math">\\tilde{i}_{1},\\tilde{i}_{2},\\ldots,\\tilde{i}_{\\ell}</span> be those previously unqueried indices. Given <span class="math">\\mathsf{DS}\\leftarrow\\mathsf{PP.PreProcess}(pp,0)</span> we need to be able to change some of <span class="math">v_{\\tilde{i}_{1}},\\ldots,v_{\\tilde{i}_{\\ell}}</span> in <span class="math">\\mathsf{DS}</span> (without modifying the remaining <span class="math">v_{\\tilde{i}_{\\ell+1}},\\ldots,v_{\\tilde{i}_{k}}</span>) in such a way that <span class="math">\\mathsf{PP.Reconstruct}(\\mathsf{pp},\\tilde{x},v_{\\tilde{i}_{1}},\\ldots,v_{\\tilde{i}_{k}})</span> outputs a value <span class="math">y</span> different from <span class="math">0</span>.</p>

    <p class="text-gray-300">Under the conditions above we have the following attack:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathsf{DS}\\leftarrow\\mathsf{PP.PreProcess}(pp,0)</span>. Modify the values <span class="math">v_{\\tilde{i}_{1}},\\ldots,v_{\\tilde{i}_{\\ell}}</span> in <span class="math">\\mathsf{DS}</span> as above and commit to the resulting modified <span class="math">\\mathsf{DS}</span> with <span class="math">\\mathsf{PC}_{\\mathsf{VC}}.\\mathsf{Com}</span>.</li>

      <li>Compute the proofs <span class="math">\\pi_{x_{i}}</span> for all <span class="math">x_{i}</span> and <span class="math">\\tilde{\\pi}_{x}</span> for <span class="math">\\tilde{x}</span> as in <span class="math">\\mathsf{PP.Open}</span>.</li>

    </ul>

    <p class="text-gray-300">Clearly the resulting openings will be correct, the proofs <span class="math">\\pi_{x_{i}}</span> will open to <span class="math">f=0</span> and the proof <span class="math">\\tilde{x}</span> will open to a value <span class="math">y</span> different from <span class="math">0</span>. Because <span class="math">0</span> is the only polynomial consistent with the evaluations on all <span class="math">x_{i}</span> being <span class="math">0</span>, there cannot be any polynomial <span class="math">f</span> in <span class="math">\\mathcal{P}_{m,d}</span> simultaneously consistent with <span class="math">f(x_{i})=0</span> for <span class="math">i\\in[d^{m}]</span> and <span class="math">f(\\tilde{x})=y</span>, breaking strong binding.</p>

    <p class="text-gray-300">We show an explicit choice of <span class="math">\\{x_{i}\\}_{i\\in[d^{m}]}</span> and <span class="math">\\tilde{x}</span> for large enough <span class="math">q</span>. For this, we recall that we are using the 2-level recursion version of the Kedlaya-Umans preprocessing algorithm presented in <em>[x17, Theorem A.4]</em>). The data structure output by <span class="math">\\mathsf{PP.PreProcess}(pp,f)</span> consists of subtables <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> indexed by pairs <span class="math">(p,p^{\\prime})</span> running over a certain subset of pairs of primes where in particular it always holds <span class="math">p^{\\prime}&lt;p</span>. The primes <span class="math">p</span> run over the set <span class="math">\\mathcal{P}</span> of all primes less than some bound that guarantees that <span class="math">\\prod_{p\\in\\mathcal{P}}p&gt;M</span> where <span class="math">M</span> is the maximum possible value of any <span class="math">f(x)</span> (for all <span class="math">f\\in\\mathcal{P}_{m,d}</span> and <span class="math">x\\in\\mathbb{Z}_{q}^{m}</span>) when both <span class="math">f</span> and <span class="math">x</span> are lifted to the integers (i.e. computed without reduction mod <span class="math">q</span>). Concretely, <span class="math">M=d^{m}q^{m(d-1)+1}</span>. While in <em>[x13, x14, x17]</em> the set <span class="math">\\mathcal{P}</span> is taken to be</p>

    <p class="text-gray-300">all primes up to <span class="math">16\\log M</span> so that it works uniformly for any choice of <span class="math">d,q,m</span>, here we are going to assume that we use instead the minimal set such that <span class="math">\\prod_{p\\in\\mathcal{P}}p&gt;M</span> (i.e., if <span class="math">p_{\\max}</span> denotes the largest prime in the set, then <span class="math">\\prod_{p\\in\\mathcal{P}\\setminus\\{p_{\\max}\\}}&lt;M</span>) since this is enough to apply the algorithm and simplifies the exposition. Of course, in particular we have <span class="math">p_{\\max}\\leq 16\\log M</span>.</p>

    <p class="text-gray-300">Each sub-table <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> of the data structure contains the evaluations of certain polynomial <span class="math">f_{p,p^{\\prime}}</span> on all <span class="math">a\\in\\mathbb{Z}_{p^{\\prime}}^{m}</span>; the polynomial <span class="math">f_{p,p^{\\prime}}</span> is obtained by first lifting <span class="math">f</span> to <span class="math">\\mathbb{Z}[X_{1},\\ldots,X_{m}]</span>, then reducing modulo <span class="math">p</span> and then repeating this operation on the resulting polynomial and <span class="math">p^{\\prime}</span>. Note that, in particular for <span class="math">\\mathsf{DS}\\leftarrow\\mathsf{PP}.{\\mathsf{PreProcess}}(pp,0)</span>, all entries at all tables <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> are <span class="math">0</span>. When evaluating <span class="math">f</span> on any <span class="math">x\\in\\mathbb{Z}_{q}^{m}</span>, only one index is queried for each <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span>, namely the one containing <span class="math">f_{p,p^{\\prime}}(a)</span> such that <span class="math">a</span> is obtained from <span class="math">x</span> by first lifting to <span class="math">\\mathbb{Z}^{m}</span>, then reducing modulo <span class="math">p</span> and repeating the operation again for <span class="math">p^{\\prime}</span> (we abbreviate this by writing <span class="math">a=x\\bmod p\\bmod p^{\\prime}</span>).</p>

    <p class="text-gray-300">Let us partition <span class="math">\\mathcal{P}</span> as <span class="math">\\mathcal{P}=\\mathcal{P}_{\\mathrm{small}}\\cup\\mathcal{P}_{\\mathrm{large}}</span> such that: i) all primes in <span class="math">\\mathcal{P}_{\\mathrm{small}}</span> are smaller than those in <span class="math">\\mathcal{P}_{\\mathrm{large}}</span>; ii) <span class="math">(\\prod_{p\\in\\mathcal{P}_{\\mathrm{small}}}p)&gt;p_{\\max}</span>; and iii) <span class="math">\\mathcal{P}_{\\mathrm{small}}</span> is minimal satisfying conditions i) and ii). Note <span class="math">\\mathcal{P}_{\\mathrm{large}}</span> is non-empty: indeed <span class="math">\\mathcal{P}_{\\mathrm{small}}\\subseteq\\mathcal{P}\\setminus\\{p_{\\max}\\}</span> because the product of all primes in <span class="math">\\mathcal{P}\\setminus\\{p_{\\max}\\}</span> is always larger than the next prime <span class="math">p_{\\max}</span>, as otherwise we would reach a contradiction when considering the primality of <span class="math">(\\prod_{p\\in\\mathcal{P}\\setminus\\{p_{\\max}\\}}p)-1</span>. We call <span class="math">P=\\prod_{p\\in\\mathcal{P}_{\\mathrm{small}}}p</span> and <span class="math">Q=\\prod_{p\\in\\mathcal{P}_{\\mathrm{large}}}p</span>. From the above we have <span class="math">P&gt;p_{\\max}</span> but also <span class="math">Q=PQ/P&lt;PQ/p_{\\max}=\\prod_{p\\in\\mathcal{P}\\setminus\\{p_{\\max}\\}}&lt;M</span>.</p>

    <p class="text-gray-300">Our attack now applies when <span class="math">q&gt;d(p_{\\max})^{2}</span>. This holds when <span class="math">q</span> is large enough with respect to <span class="math">d</span> and <span class="math">m</span>, because we know <span class="math">d(p_{\\max})^{2}\\leq 16^{2}d(\\log M)^{2}</span>, but <span class="math">\\log M=O(\\log q)</span>. Under these conditions, we have that <span class="math">q&gt;dP</span>. Indeed, if <span class="math">P&gt;q/d&gt;(p_{\\max})^{2}</span> then we would contradict our choice that our partition is such that <span class="math">\\mathcal{P}_{\\mathrm{small}}</span> is minimal: we can remove the largest prime from <span class="math">\\mathcal{P}_{\\mathrm{small}}</span> and we would still have <span class="math">P&gt;p_{\\max}</span>.</p>

    <p class="text-gray-300">From <span class="math">q&gt;dP</span>, we conclude there are at least <span class="math">d</span> values <span class="math">s</span> in <span class="math">\\mathbb{Z}_{q}</span> such that when lifted to <span class="math">\\mathbb{Z}</span>, we have <span class="math">s\\bmod P=1</span>. Let <span class="math">S</span> be the set of these <span class="math">d</span> values, let <span class="math">\\{x_{i}\\}_{i\\in[d^{m}]}=S^{m}</span> (which satisfies condition 1 as explained above) and <span class="math">\\tilde{x}=(0,0,\\ldots,0)</span>. Finally we will choose the evaluation <span class="math">\\tilde{y}</span> to be <span class="math">Q\\bmod q</span>, which is different than <span class="math">0</span> because <span class="math">Q</span> is a product of primes smaller than <span class="math">q</span>.</p>

    <p class="text-gray-300">By construction, for every <span class="math">x_{i}</span>, we have the following: at every <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> with <span class="math">p\\in\\mathcal{P}_{\\mathrm{small}}</span>, <span class="math">\\mathsf{PP}.{\\mathsf{Lookup}}(\\mathsf{pp},x_{i})</span> queries the index containing <span class="math">f_{p,p^{\\prime}}(1,1,\\ldots,1)</span> because all the coordinates of every <span class="math">x_{i}</span> are <span class="math">1</span> modulo <span class="math">P=\\prod_{p\\in\\mathcal{P}_{\\mathrm{small}}}p</span>.</p>

    <p class="text-gray-300">On the other hand, <span class="math">\\mathsf{PP}.{\\mathsf{Lookup}}(\\mathsf{pp},\\tilde{x})</span> queries the index of every table <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> containing <span class="math">f_{p,p^{\\prime}}(0,0,\\ldots,0)</span>. In particular the indices queried by <span class="math">\\mathsf{PP}.{\\mathsf{Lookup}}(\\mathsf{pp},\\tilde{x})</span> at every table <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> with <span class="math">p</span> in <span class="math">\\mathcal{P}_{\\mathrm{small}}</span> have not been queried by any <span class="math">\\mathsf{PP}.{\\mathsf{Lookup}}(\\mathsf{pp},x_{i})</span>.</p>

    <p class="text-gray-300">We can therefore change the entries <span class="math">v_{i}</span> containing <span class="math">f_{p,p^{\\prime}}(0,0,\\ldots,0)</span> at tables <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> for every prime <span class="math">p</span> in <span class="math">\\mathcal{P}_{\\mathrm{small}}</span> to be instead <span class="math">v_{i}^{\\prime}=Q\\bmod p\\bmod p^{\\prime}</span>. On the other hand, for <span class="math">p</span> in <span class="math">\\mathcal{P}_{\\mathrm{large}}</span> we have <span class="math">Q=0\\bmod p</span>, so the unmodified <span class="math">0</span> values in tables <span class="math">\\mathcal{T}_{p,p^{\\prime}}</span> are already consistent with the claimed evaluation <span class="math">f(\\tilde{x})=Q\\bmod q</span>.</p>

    <p class="text-gray-300">In summary, after doing these changes and calling <span class="math">v_{\\tilde{i}_{1}}^{\\prime},\\ldots,v_{\\tilde{i}_{k}}^{\\prime}</span> the modified values at the queried indices for <span class="math">\\tilde{x}</span> we have <span class="math">\\mathsf{PP}.{\\mathsf{Reconstruct}}(pp,\\tilde{x},v_{\\tilde{i}_{1}}^{\\prime},\\ldots,v_{\\tilde{i}_{k}}^{\\prime})=Q\\bmod q</span> by correctness of Kedlaya-Umans (where we are also using that <span class="math">Q&lt;M</span>), while <span class="math">\\mathsf{PP}.{\\mathsf{Reconstruct}}</span> outputs <span class="math">0</span> when applied to <span class="math">x_{i}</span> and the corresponding unmodified entry values, which are all <span class="math">0</span>. Therefore the attack above will work.</p>

    <p class="text-gray-300">C Knowledge Sound (SNARK-based) Polynomial Commitment with Fast Opening</p>

    <p class="text-gray-300">The following construction make use of a SNARK for the (non-indexed) relation defined in Equation (1). Despite our preliminaries focus on indexed relations, the syntax and properties of non-indexed relations can be easily derived from Definition 6.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Construction 3</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PP}</span> be a PP scheme (Definition 10) and <span class="math">\\mathsf{VC}</span> be a vector commitment scheme (Definition 22) for a message space <span class="math">\\{0,1\\}^{*}</span>. Also, let <span class="math">\\mathsf{SNARK}</span> be a SNARK for the relation <span class="math">\\mathcal{R}_{\\mathsf{VC},\\mathsf{PP}}</span> (Equation (1)) parametrized by a <span class="math">\\mathsf{VC}</span> and <span class="math">\\mathsf{PP}</span> scheme (e.g., as the ones of Construction 1). We build a PC scheme <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> for multivariate polynomials over a ring <span class="math">R</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda},m,d)\\to\\mathsf{ck}</span>: On input the security parameter <span class="math">\\lambda</span>, the number of variables <span class="math">m</span>, and a bound <span class="math">d</span> for the degree of each variable, the setup algorithm computes <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{PP.Params}(R,m,d)</span>, <span class="math">\\mathsf{ck}_{\\mathsf{VC}}\\leftarrow\\mathsf{VC.Setup}(1^{\\lambda},S)</span>, and <span class="math">\\mathsf{srs}\\leftarrow\\mathsf{SNARK.Setup}(1^{\\lambda},\\mathcal{R}_{\\mathsf{VC},\\mathsf{PP}})</span>, where <span class="math">S</span> is the upper bound on the size of the data structure included in <span class="math">\\mathsf{pp}</span> (see Definition 10). Finally, it outputs <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs})</span>. <span class="math">\\mathsf{Com}(\\mathsf{ck},f;r)\\to(\\mathsf{cm},\\mathsf{aux})</span>: On input the commitment key <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs})</span>, a polynomial <span class="math">f\\in\\mathcal{P}_{m,d}</span>, and a randomness <span class="math">r</span>, the commit algorithm computes <span class="math">\\mathsf{DS}\\leftarrow\\mathsf{PP.PreProcess}(\\mathsf{pp},f)</span> and <span class="math">(\\mathsf{cm}_{\\mathsf{DS}},\\mathsf{aux}_{\\mathsf{DS}})\\leftarrow\\mathsf{VC.Com}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{DS};r)</span> (recall that <span class="math">\\mathsf{DS}</span> is a vector, i.e., <span class="math">\\mathsf{DS}=(v_{1},\\ldots,v_{S})</span>). Finally, it outputs <span class="math">\\mathsf{cm}=\\mathsf{cm}_{\\mathsf{DS}}</span> and <span class="math">\\mathsf{aux}=(\\mathsf{aux}_{\\mathsf{DS}},\\mathsf{DS},\\pi_{\\mathsf{DS}})</span> where <span class="math">\\pi_{\\mathsf{DS}}\\leftarrow\\mathsf{SNARK.Prove}(\\mathsf{srs},(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}}),(f,r))</span>. <span class="math">\\mathsf{Open}(\\mathsf{ck},x,\\mathsf{aux})\\to\\pi_{x}</span>: On input the commitment key <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs})</span>, a point <span class="math">x\\in R^{m}</span>, and auxiliary information <span class="math">\\mathsf{aux}=(\\mathsf{aux}_{\\mathsf{DS}},\\mathsf{DS},\\pi_{\\mathsf{DS}})</span> where <span class="math">\\mathsf{DS}=(v_{1},\\ldots,v_{S})</span>, the open algorithm retrieves the indexes <span class="math">(i_{1},...,i_{k})\\leftarrow\\mathsf{PP.Lookup}(\\mathsf{pp},x)</span> and compute an opening proof <span class="math">\\pi_{j}\\leftarrow\\mathsf{VC.Open}(\\mathsf{ck}_{\\mathsf{VC}},i_{j},\\mathsf{aux}_{\\mathsf{DS}})</span> for every <span class="math">j\\in[k]</span>. Finally, it outputs <span class="math">\\pi_{x}=(\\pi_{\\mathsf{DS}},v_{j},\\pi_{j})_{j\\in[k]}</span>. <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})\\to b</span>: On input the commitment key <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs})</span>, the commitment <span class="math">\\mathsf{cm}=\\mathsf{cm}_{\\mathsf{DS}}</span>, a point <span class="math">x\\in R^{m}</span>, an evaluation <span class="math">y\\in R</span>, and a proof <span class="math">\\pi_{x}=(\\pi_{\\mathsf{DS}},v_{j},\\pi_{j})_{j\\in[k]}</span>, the verification algorithm outputs a decision bit <span class="math">b\\in\\{0,1\\}</span> equals to <span class="math">\\bigwedge_{j\\in[k]}\\mathsf{VC.Ver}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}},i_{j},v_{j},\\pi_{j})\\stackrel{{\\scriptstyle?}}{{=}}1\\ \\wedge\\ y\\stackrel{{\\scriptstyle?}}{{=}}\\mathsf{PP.Reconstruct}(\\mathsf{pp},x,v_{1},\\ldots,v_{k})\\ \\wedge\\ \\mathsf{SNARK.Ver}(\\mathsf{srs},(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}}),\\pi)\\stackrel{{\\scriptstyle?}}{{=}}1</span>.</p>

    <p class="text-gray-300">Below, we state the properties and security of our <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> of Construction 3. Observe that the theorem below states that <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> is knowledge sound which, in turn, implies strong evaluation binding (Theorem 1).</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Theorem 12</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PP}</span>, <span class="math">\\mathsf{VC}</span>, <span class="math">\\mathsf{SNARK}</span>, and <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> as defined in Construction 3.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{PP}</span>, <span class="math">\\mathsf{VC}</span>, and <span class="math">\\mathsf{SNARK}</span> satisfy correctness (Definitions 7, 11 and 23), then <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> satisfies correctness (Definition 17).</li>

      <li>If <span class="math">\\mathsf{VC}</span> satisfies position binding (Definition 24) and <span class="math">\\mathsf{SNARK}</span> satisfies non-black-box (resp. black-box) knowledge soundness (Definition 9), then <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> satisfies non-black-box (resp. black-box) knowledge soundness (Definition 21).</li>

      <li>If <span class="math">\\mathsf{PP}</span> satisfies efficiency (Definition 12), <span class="math">\\mathsf{VC}</span> and <span class="math">\\mathsf{SNARK}</span> satisfy succinctness (Definitions 4 and 8), then <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> satisfies succinctness (Definition 2).</li>

      <li>If <span class="math">\\mathsf{PP}</span> satisfies efficiency (Definition 12), <span class="math">\\mathsf{VC}</span> satisfies fast openings (Definition 5), and <span class="math">\\mathsf{SNARK}</span> satisfies succinctness (Definition 8), then <span class="math">\\mathsf{PC}_{\\mathsf{SNARK}}</span> satisfies fast openings (Definition 13).</li>

    </ol>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness. The correctness of PC_{SNARK} follows directly from the correctness of PP, VC, and SNARK.</p>

    <p class="text-gray-300">Non-black-box (resp. black-box) knowledge soundness. The following proof is for the non-black-box case. Still, assuming that SNARK satisfies black-box knowledge soundness, the proof can be extended to the black-box knowledge soundness case of PC_{SNARK}.</p>

    <p class="text-gray-300">We begin by showing that an adversary <span class="math">\\mathcal{A}</span> for the (non-black-box) knowledge soundness experiment of PC_{SNARK} can be transformed into an adversary <span class="math">\\mathcal{B}</span> for the (non-black-box) knowledge soundness experiment of SNARK. We define <span class="math">\\mathcal{B}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive as input srs.</li>

      <li>Sample <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{PP}.{\\mathsf{Setup}}(R,m,d)</span> and <span class="math">\\mathsf{ck}_{\\mathsf{VC}}\\leftarrow\\mathsf{VC}.{\\mathsf{Setup}}(1^{\\lambda},S)</span>.</li>

      <li>Execute <span class="math">\\mathcal{A}</span> on input <span class="math">\\mathsf{ck}=(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs})</span> and receive <span class="math">(\\mathsf{cm},x,y,\\pi_{x})</span> where <span class="math">\\mathsf{cm}=\\mathsf{cm}_{\\mathsf{DS}}</span> and <span class="math">\\pi_{x}=(\\pi_{\\mathsf{DS}},v_{j},\\pi_{j})</span>.</li>

      <li>Output <span class="math">((\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs}),\\pi_{\\mathsf{DS}})</span>.</li>

    </ul>

    <p class="text-gray-300">It is easy to see that the output of <span class="math">\\mathcal{B}</span> satisfies SNARK.<span class="math">\\mathsf{Ver}(\\mathsf{srs},(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}}),\\pi)=1</span> whenever the output of <span class="math">\\mathcal{A}</span> satisfies <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})=1</span>. This is because <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})=1</span> implies:</p>

    <p class="text-gray-300"><span class="math">\\wedge_{j\\in[k]}\\mathsf{VC}.{\\mathsf{Ver}}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}},i_{j},v_{j},\\pi_{j})=1,</span> (2) <span class="math">\\mathsf{PP}.{\\mathsf{Reconstruct}}(\\mathsf{pp},x,v_{1},\\ldots,v_{k})=y,\\text{ and}</span> (3) <span class="math">\\mathsf{SNARK}.{\\mathsf{Ver}}(\\mathsf{srs},(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}}),\\pi)=1.</span> (4)</p>

    <p class="text-gray-300">By leveraging the (non-black-box) knowledge soundness of SNARK, we have that there exists an extractor <span class="math">\\mathsf{Ext}_{\\mathcal{B}}</span> satisfying the following:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\mathsf{SNARK}.{\\mathsf{Ver}}(\\mathsf{srs},(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs}),\\pi_{\\mathsf{DS}})=1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\wedge\\ ((\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs}),(f,r))\\notin\\mathcal{R}_{\\mathsf{PP},\\mathsf{VC}}\\end{array}\\right]\\begin{array}[]{l}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}\\mathsf{srs}\\leftarrow\\mathsf{Setup}(1^{\\lambda}),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">((\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs}),\\pi_{\\mathsf{DS}})\\leftarrow\\mathcal{B}(\\mathsf{srs}),\\\\ (f,r)\\leftarrow\\mathsf{Ext}_{\\mathcal{B}}(\\mathsf{srs})\\end{array}\\right.\\right]\\in\\mathsf{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">To conclude the proof, it is sufficient to show that <span class="math">\\mathsf{Ext}_{\\mathcal{B}}</span> can be used to construct an extractor <span class="math">\\mathsf{Ext}_{\\mathcal{A}}</span> for the adversary <span class="math">\\mathcal{A}</span>. We now demonstrate that it is sufficient to set <span class="math">\\mathsf{Ext}_{\\mathcal{A}}(\\mathsf{ck})=\\mathsf{Ext}_{\\mathcal{A}}(\\mathsf{pp},\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{srs})=\\mathsf{Ext}_{\\mathcal{B}}(\\mathsf{srs})</span>.</p>

    <p class="text-gray-300">First, given that <span class="math">\\mathcal{A}</span> satisfies <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})=1</span>, it follows that Equation (4) holds. Furthermore, assuming Equation (4) holds, we obtain <span class="math">\\mathsf{Ext}_{\\mathcal{A}}(\\mathsf{ck})=\\mathsf{Ext}_{\\mathcal{B}}(\\mathsf{srs})\\rightarrow(f,r)\\in\\mathcal{R}_{\\mathsf{VC},\\mathsf{PP}}</span>, which implies that <span class="math">(\\mathsf{cm}_{\\mathsf{DS}},\\cdot)=\\mathsf{VC}.{\\mathsf{Com}}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{DS};r)</span>, where <span class="math">\\mathsf{DS}\\leftarrow\\mathsf{PP}.{\\mathsf{PreProcess}}(\\mathsf{pp},f)</span>. That is, <span class="math">\\mathsf{cm}_{\\mathsf{DS}}</span> and <span class="math">\\mathsf{DS}</span> are honestly computed using <span class="math">f</span> and randomness <span class="math">r</span>. This implies that:</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{cm},\\cdot)=\\mathsf{Com}(\\mathsf{ck},f;r).</span> (5)</p>

    <p class="text-gray-300">Second, given that <span class="math">\\mathcal{A}</span> satisfies <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},x,y,\\pi_{x})=1</span> and considering Equation (3), Equation (2), along with the position-binding property of <span class="math">\\mathsf{VC}</span>, we obtain that each <span class="math">v_{j}</span> (for <span class="math">j\\in[k]</span>) contained in the proof <span class="math">\\pi_{x}</span> corresponds to the correct block of the honestly computed data structure <span class="math">\\mathsf{DS}</span>, located at the correct position <span class="math">i_{j}</span>, where <span class="math">(i_{1},\\ldots,i_{k})\\leftarrow\\mathsf{PP}.{\\mathsf{Lookup}}(\\mathsf{pp},x)</span>.</p>

    <p class="text-gray-300">Consequently, by the correctness of <span class="math">\\mathsf{PP}</span>, we obtain:</p>

    <p class="text-gray-300"><span class="math">y=f(x)=\\mathsf{PP}.{\\mathsf{Reconstruct}}(\\mathsf{pp},v_{i_{1}},\\ldots,v_{i_{k}}).</span> (6)</p>

    <p class="text-gray-300">By combining Equations (5) and (6), we conclude that whenever <span class="math">\\mathcal{A}</span> satisfies <span class="math">\\textsf{Ver}(\\textsf{ck},\\textsf{cm},x,y,\\pi_{x})=1</span>, the extractor <span class="math">\\textsf{Ext}_{\\mathcal{A}}(\\textsf{cm})=\\textsf{Ext}_{\\mathcal{B}}(\\textsf{srs})</span> is able to extract, with overwhelming probability, a polynomial <span class="math">f</span> and randomness <span class="math">r</span> such that <span class="math">(\\textsf{cm},\\cdot)=\\textsf{Com}(\\textsf{ck},f;r)\\wedge y=f(x)</span>. Thus, <span class="math">\\textsf{PC}_{\\textsf{SNARK}}</span> satisfies (non-black-box) knowledge soundness.</p>

    <p class="text-gray-300">Succinctness. For both univariate and multivariate polynomials, the proof is analogous to that of Theorem 4 (Appendix E.1), except for the following aspects:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The opening proof of <span class="math">\\textsf{PC}_{\\textsf{SNARK}}</span> additionally includes a SNARK proof <span class="math">\\pi_{\\textsf{DS}}</span>. Since SNARK satisfies succinctness, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\textsf{DS}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\textsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where </span>\\textsf{\\tt s}=(\\textsf{pp},\\textsf{ck}_{\\textsf{VC}},\\textsf{cm}_{\\textsf{DS}})<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Hence, the opening proofs of </span>\\textsf{PC}_{\\textsf{SNARK}}<span class="math"> remain bounded by </span>\\textsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)$, as in the proof of Theorem 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fast Openings. For both univariate and multivariate polynomials, the proof is analogous to that of Theorem 4 (Appendix E.1), except that the running time of <span class="math">\\textsf{Com}</span> in <span class="math">\\textsf{PC}_{\\textsf{SNARK}}</span> additionally includes the running time of SNARK.Prove. The latter is polynomial in the statement <span class="math">\\textsf{\\tt s}=(\\textsf{pp},\\textsf{ck}_{\\textsf{VC}},\\textsf{cm}_{\\textsf{DS}})</span> and witness <span class="math">\\textsf{w}=(f,r)</span>. Hence, the running time of <span class="math">\\textsf{Com}</span> remains bounded by $\\textsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d^{m})$, as in the proof of Theorem 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-70" class="text-2xl font-bold">Appendix D Supporting Material for UC SNARKs</h2>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">D.1 UC Framework</h3>

    <p class="text-gray-300">In this work, we use the <em>Universal Composability</em> (UC) framework <em>[x10]</em> for security proofs. UC follows the simulation-based paradigm where the security of a protocol is defined with respect to an ideal world where a trusted party, the functionality <span class="math">\\mathcal{F}</span>, does the all of the computation. Informally, a protocol securely realizes <span class="math">\\mathcal{F}</span> in the real world if for any real world adversary there exist an <em>equivalent</em> ideal world adversary (the simulator), “equivalent” meaning that any outside observer (the environment) cannot distinguish between the real protocol execution and the ideal execution. UC’s composition theorem ensures that one can safely compose protocols that have been proven UC-secure.</p>

    <h4 id="sec-72" class="text-lg font-semibold mt-6">Global Random Oracle.</h4>

    <p class="text-gray-300">More precisely, we use the generalized UC (GUC) framework <em>[x11]</em> which allows to model global functionalities that are shared between different protocol instances. We consider a hybrid-model where parties have access to a (non-programmable) global random oracle <span class="math">\\mathcal{G}_{\\textsf{RO}}</span> as introduced in <em>[x16]</em>. We follow the simplified description from <em>[CDG^{+}18]</em>. The <span class="math">\\mathcal{G}_{\\textsf{RO}}</span> functionality can be queried by any party and the ideal adversary with two commands: query and observe. The environment can query <span class="math">\\mathcal{G}_{\\textsf{RO}}</span> by spawning additional dummy parties outside the context of the current protocol execution. <span class="math">\\mathcal{G}_{\\textsf{RO}}</span> answers all new query command by lazy sampling from the domain and stores them locally in a list <span class="math">\\mathcal{Q}</span>. A repeated query requires a simple lookup in <span class="math">\\mathcal{Q}</span>. Some query queries are marked “illegitimate” and can be observed via observe command. Next we explain which query counts as an illegitimate one. Each party is associated with its party identifier pid and a session identifier sid. When a party queries <span class="math">\\mathcal{G}_{\\textsf{RO}}</span> with the command <span class="math">(\\textsf{query},x)</span>, the query is parsed as <span class="math">(s,x^{\\prime})</span> where <span class="math">s</span> denotes the session identifier associated with the party. A</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  is parametrized by the output length  <span class="math">\\ell (\\lambda)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query Upon receiving a query (QUERY,  <span class="math">x</span> ), from some party  <span class="math">\\mathcal{P} = (\\mathrm{pid}, \\mathrm{sid})</span>  or from the adversary Sim do:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Look up  <span class="math">v</span>  if there is a pair  <span class="math">(x, v)</span>  for some  <span class="math">v \\in \\{0, 1\\}^{\\ell(\\lambda)}</span>  in the (initially empty) list  <span class="math">\\mathcal{Q}</span>  of past queries. Else, choose uniformly  <span class="math">v \\in \\{0, 1\\}^{\\ell(\\lambda)}</span>  and store the pair  <span class="math">(x, v)</span>  in  <span class="math">\\mathcal{Q}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Parse  <span class="math">x</span>  as  <span class="math">(s, x&#x27;)</span> . If  <span class="math">\\mathsf{sid} \\neq s</span>  then add  <span class="math">(s, x&#x27;, v)</span>  to the (initially empty) list of illegitimate queries for SID  <span class="math">s</span> , that is denoted by  $\\mathcal{Q}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return  <span class="math">v</span>  to  <span class="math">\\mathcal{P}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Observe Upon receiving a request (OBSERVE, sid) from the adversary Sim, return the list  $\\mathcal{Q}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{sid}}$  of illegitimate queries for SID sid to the adversary.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 2. Functionality for Global Random Oracle  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  [CDG+18]</p>

    <p class="text-gray-300">query is marked as illegitimate if the sid field of the query differs from the sid associated to the party making the query. In other words, these are the queries made outside the context of the current session execution. We formally define the functionality  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  in Fig. 2.</p>

    <p class="text-gray-300">Definition 25 (UC Security in the Global ROM [CDPW07,CJS14]). Let  <span class="math">\\mathcal{F},\\mathcal{F}^{\\prime}</span>  be  <span class="math">m</span>  -party functionalities and  <span class="math">\\Pi</span>  be a protocol. We say that  <span class="math">\\Pi</span>  UC-realizes  <span class="math">\\mathcal{F}</span>  in the  <span class="math">\\mathcal{G}_{\\mathrm{RO}},\\mathcal{F}^{\\prime}</span>  -hybrid model if for any hybrid-model PPT adversary  <span class="math">\\mathcal{A}</span> , there exists an ideal process PPT adversary Sim such that for every PPT environment  <span class="math">\\mathcal{Z}</span> , it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\{\\text {I D E A L} _ {\\mathcal {F}, \\text {S i m}, \\mathcal {Z}} ^ {\\mathcal {G} _ {\\mathrm {R O}}} (\\mathbf {x}, \\lambda , z) \\} _ {\\mathbf {x}, \\lambda , z} \\approx \\{\\text {R E A L} _ {\\mathcal {F} ^ {\\prime}, \\Pi , \\mathcal {A}, \\mathcal {Z}} ^ {\\mathcal {G} _ {\\mathrm {R O}}} (\\mathbf {x}, \\lambda , z) \\} _ {\\mathbf {x}, \\lambda , z}</span></div>

    <p class="text-gray-300">where REAL is the outputs of the honest parties and the adversary  <span class="math">\\mathcal{A}</span>  after a real execution of protocol  <span class="math">\\Pi</span>  with input  <span class="math">\\mathbf{x} = (x_{1},\\ldots ,x_{m})</span>  for parties  <span class="math">P_{1},\\ldots ,P_{m}</span>  where each  <span class="math">x_{i}\\in \\{0,1\\}^{<em>}</span> ,  <span class="math">z\\in \\{0,1\\}^{</em>}</span>  is the auxiliary input for  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\lambda</span>  is the security parameter. IDEAL is the analogous distribution in an ideal execution with a trusted party that computes  <span class="math">\\mathcal{F}</span>  for the parties and hands the output to the designated players.</p>

    <h2 id="sec-73" class="text-2xl font-bold">D.2 (Succinct) Non Interactive Zero-Knowledge Proofs</h2>

    <p class="text-gray-300">Although we already defined SNARK for indexed relations in ??, in this section we provide an alternative syntax and formalism in order to stay as faithful as possible to the original treatment in  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> ; we will also not be needing indexed relations.</p>

    <p class="text-gray-300">A non-interactive proof system for relation  <span class="math">\\mathcal{R}</span> , denoted by  <span class="math">\\Pi_{\\mathcal{R}}</span> , consists a tuple of algorithms  <span class="math">(\\text{Setup}, \\mathcal{O}_{\\text{Setup}}, \\mathcal{P}, \\mathcal{V})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span> : Takes as input the security parameter  <span class="math">\\lambda</span>  and outputs public parameters  <span class="math">\\mathsf{pp}</span> . Once Setup is invoked we assume that all of the following algorithms take  <span class="math">\\mathsf{pp}</span>  as an implicit input.</li>

      <li><span class="math">\\mathsf{out} \\gets \\mathcal{O}_{\\mathsf{Setup}}(\\mathsf{in})</span> : A stateful setup oracle that takes an input string in and outputs out.</li>

      <li><span class="math">\\pi \\gets \\mathcal{P}^{\\mathcal{O}_{\\mathrm{Setup}}}(x, w)</span> : Takes as input a statement  <span class="math">x</span>  and witness  <span class="math">w</span> , and outputs a proof  <span class="math">\\pi</span>  if  <span class="math">(x, w) \\in \\mathcal{R}</span> .</li>

      <li><span class="math">b \\gets \\mathcal{V}^{\\mathcal{O}_{\\text{Setup}}}(x, \\pi)</span> : Takes as input a statement  <span class="math">x</span>  and proof  <span class="math">\\pi</span> , and outputs a bit  <span class="math">b</span> , indicating "accept" or "reject".</li>

    </ul>

    <p class="text-gray-300">We introduce the setup oracle <span class="math">\\mathcal{O}_{\\mathsf{Setup}}</span> to the notation of NIZKs to capture the two typical setup assumptions in an abstract manner. That is, if a proof system is instantiated in the CRS model, then <span class="math">\\mathcal{O}_{\\mathsf{Setup}}</span> internally generates crs upon receiving a query with any input for the first time, and keeps outputting the same crs regardless of the input. When instantiating the RO model, <span class="math">\\mathcal{O}_{\\mathsf{Setup}}</span> is initialized with an empty query-response table and proceeds as follows. On receiving <span class="math">\\mathsf{in}\\in\\{0,1\\}^{*}</span>, if <span class="math">\\mathsf{in}</span> has never been queried, sample uniform <span class="math">\\mathsf{out}\\in\\{0,1\\}^{\\ell(\\lambda)}</span>, store <span class="math">(\\mathsf{in},\\mathsf{out})</span> in the table, and return <span class="math">\\mathsf{out}</span>. Otherwise, look up the table to find <span class="math">\\mathsf{out}</span> associated with <span class="math">\\mathsf{in}</span>, and return <span class="math">\\mathsf{out}</span>.</p>

    <p class="text-gray-300">We define three basic security properties for <span class="math">\\Pi_{\\mathcal{R}}</span> in the stand-alone setting.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Definition 26 (Completeness).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathcal{R}}</span> satisfies <em>completeness</em> if for every <span class="math">(x,w)\\in\\mathcal{R}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[b=1\\,:\\ \\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda});\\pi\\leftarrow\\mathcal{P}^{\\mathcal{O}_{\\mathsf{Setup}}}(x,w);b\\leftarrow\\mathcal{V}^{\\mathcal{O}_{\\mathsf{Setup}}}(x,\\pi)\\right]=1.</span></p>

    <p class="text-gray-300">We define zero-knowledge by following the syntax of <em>[x10, GOP^{+}22]</em>. A zero-knowledge simulator <span class="math">\\mathcal{S}</span> is defined as a stateful algorithm with initial state <span class="math">\\mathsf{st}=\\mathsf{pp}</span> that operates in two modes. The first mode, <span class="math">(\\mathsf{out},\\mathsf{st}^{\\prime})\\leftarrow\\mathcal{S}(1,\\mathsf{st},\\mathsf{in})</span> takes care of handling calls to the oracle <span class="math">\\mathcal{O}_{\\mathsf{Setup}}</span> on input <span class="math">\\mathsf{in}</span>. The second mode, <span class="math">(\\pi,\\mathsf{st}^{\\prime})\\leftarrow\\mathcal{S}(2,\\mathsf{st},x)</span> simulates a proof for the input statement <span class="math">x</span>. For convenience we define three “wrapper” oracles. These oracles are stateful and share the internal state <span class="math">\\mathsf{st}</span>, which initially contains an empty string.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}_{1}(\\mathsf{in})</span> to denote the oracle that returns the first output of <span class="math">\\mathcal{S}(1,\\mathsf{st},\\mathsf{in})</span>;</li>

      <li><span class="math">\\mathcal{S}_{2}(x,w)</span> that returns the first output of <span class="math">\\mathcal{S}(2,\\mathsf{st},x)</span> if <span class="math">(x,w)\\in\\mathcal{R}</span> and <span class="math">\\perp</span> otherwise;</li>

      <li><span class="math">\\mathcal{S}_{2}^{\\prime}(x)</span> that returns the first output of <span class="math">\\mathcal{S}(2,\\mathsf{st},x)</span>.</li>

    </ul>

    <h6 id="sec-75" class="text-base font-medium mt-4">Definition 27 ((Unbounded) Zero-Knowledge).</h6>

    <p class="text-gray-300">Consider a non-interactive proof system <span class="math">\\Pi_{\\mathcal{R}}=(\\mathsf{Setup},\\mathcal{O}_{\\mathsf{Setup}},\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span>. <span class="math">\\Pi_{\\mathcal{R}}</span> is unbounded <em>non-interactive zero-knowledge</em> (<span class="math">\\mathsf{NIZK}</span>), if there exists a <span class="math">\\mathsf{PPT}</span> simulator <span class="math">\\mathcal{S}</span> with wrapper oracles <span class="math">\\mathcal{S}_{1}</span> and <span class="math">\\mathcal{S}_{2}</span> such that for all <span class="math">\\mathsf{PPT}</span> adversaries <span class="math">\\mathcal{A}</span> it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[b=1\\,:\\ \\ \\ \\ \\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda});\\right]\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">b\\leftarrow\\mathcal{A}^{\\mathcal{O}_{\\mathsf{Setup}},\\mathcal{P}}(\\mathsf{pp})\\right]-\\Pr\\left[b=1\\,:\\ \\ \\ \\ \\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda});\\right]\\\\ b\\leftarrow\\mathcal{A}^{\\mathcal{S}_{1},\\mathcal{S}_{2}}(\\mathsf{pp})\\right]\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\mathsf{negl}(\\lambda). \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we define simulation extractability, which essentially guarantees that proofs are <em>non-malleable</em>. We stress that the present definition is weaker than what is necessary for realizing UC security, because the extractor algorithm here is <em>non-black-box</em>, i.e., it requires looking into the code of the adversary. The definition is an abstracted version of <em>[x14]</em> and the schemes satisfying their definition clearly meet the version below by instantiating <span class="math">\\mathcal{S}</span> with trapdoor’d CRS generator in mode 1 and ZK simulator in mode 2. (Following <em>[x14]</em>, we also assume the relation <span class="math">\\mathcal{R}</span>, which may potentially contain auxiliary inputs, is <em>benign</em>, i.e. it is distributed in such a way that the SNARKs for <span class="math">\\mathcal{R}</span> can be simulation extractable)</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Definition 28 ((Non-black-box) Simulation Extractability).</h6>

    <p class="text-gray-300">Consider a non-interactive proof system <span class="math">\\Pi_{\\mathcal{R}}=(\\mathsf{Setup},\\mathcal{O}_{\\mathsf{Setup}},\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span> with a <span class="math">\\mathsf{NIZK}</span> simulator <span class="math">\\mathcal{S}</span>. Let <span class="math">(\\mathcal{S}_{1},\\mathcal{S}_{2}^{\\prime})</span> be wrapper oracles for <span class="math">\\mathcal{S}</span> as defined above. <span class="math">\\Pi_{\\mathcal{R}}</span> is non-black-box <em>simulation-extractable</em> (<span class="math">\\mathsf{SIM}</span>-<span class="math">\\mathsf{EXT}</span>) with respect to <span class="math">\\mathcal{S}</span>, if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, there exists a <span class="math">\\mathsf{PPT}</span> extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(x,\\pi)\\notin\\mathcal{Q}\\wedge\\,(x,w)\\notin\\mathcal{R}&{\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda});(x,\\pi)\\leftarrow\\mathcal{A}^{\\mathcal{S}_{1},\\mathcal{S}_{2}^{\\prime}}(\\mathsf{pp});}\\\\ \\wedge b=1&b\\leftarrow\\mathcal{V}^{\\mathcal{S}_{1}}(x,\\pi);w\\leftarrow\\mathcal{E}_{\\mathcal{A}}(x,\\pi,\\mathsf{state}_{\\mathcal{A}},\\mathsf{st})\\end{matrix}\\right]<\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{Setup}}</span>  is parametrized by a security parameter  <span class="math">\\lambda</span>  and a degree bound  <span class="math">D &amp;gt; 0</span>  and runs with parties  <span class="math">P_{1},\\ldots ,P_{N}</span>  and an ideal process adversary Sim.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parameters Upon receiving input (GENPARAMS, sid) from a party  <span class="math">P_{i}</span> , if no pp has been stored, run pp ← Setup(1 <span class="math">\\lambda</span> ), initialize oracle  <span class="math">\\mathcal{O}_{\\text{Setup}}</span>  with pp, and store pp. Send (PARAMS, sid, pp) to  <span class="math">P_{i}</span> .</li>

      <li>Commitment Key Upon receiving input (GENKEY, sid) from a party  <span class="math">P_{i}</span> , if no ck has been stored, run ck ← Setup(1 <span class="math">\\lambda</span> , D) and store ck. Send (COMKEY, sid, ck) to  <span class="math">P_{i}</span> .</li>

      <li>Setup Upon receiving input (SETUP, sid, in) from a party  <span class="math">P_{i}</span> , ignore if  <span class="math">\\mathcal{O}_{\\text{Setup}}</span>  has not been initialized with pp. Otherwise run out  <span class="math">\\leftarrow \\mathcal{O}_{\\text{Setup}}(\\text{in})</span>  using the current state of  <span class="math">\\mathcal{O}_{\\text{Setup}}</span>  and send (SETUP, sid, out) to  <span class="math">P_{i}</span> .</li>

    </ul>

    <p class="text-gray-300">Fig. 3.  <span class="math">N</span> -party functionality for setup  <span class="math">\\mathcal{F}_{\\mathrm{Setup}}</span></p>

    <p class="text-gray-300">where  <span class="math">\\mathsf{st}</span>  is the final state of the simulator  <span class="math">S</span> ,  <span class="math">\\mathsf{state}_{\\mathcal{A}}</span>  is a string containing all inputs and outputs of  <span class="math">\\mathcal{A}</span> , including random coins, and  <span class="math">\\mathcal{Q}</span>  is a set of statement-proof pairs  <span class="math">(x,\\pi)</span>  with  <span class="math">x</span>  being a statement queried by  <span class="math">\\mathcal{A}</span>  to the proof simulation wrapper oracle  <span class="math">S_2&#x27;</span> , and  <span class="math">\\pi</span>  being the corresponding simulated proof, respectively.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{NIZK}}</span>  is parametrized by polynomial-time-decidable relation  <span class="math">\\mathcal{R} \\in \\{0,1\\}^<em> \\times \\{0,1\\}^</em></span> , and runs with parties  <span class="math">P_1, \\ldots, P_N</span>  and an ideal process adversary Sim. It stores proof table  <span class="math">\\mathcal{Q}</span>  which is initially empty.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof Upon receiving input (PROVE, sid, ssid,  <span class="math">x, w</span> ) from a party  <span class="math">P_i</span> , ignore if  <span class="math">(x, w) \\notin \\mathcal{R}</span> . Otherwise, send (PROVE, sid,  <span class="math">x</span> ) to Sim. Upon receiving (PROOF,  <span class="math">\\pi</span> ) from Sim, store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span>  and send (PROOF, sid, ssid,  <span class="math">\\pi</span> ) to  <span class="math">P_i</span> .</li>

      <li>Verification Upon receiving input (VERIFY, sid, ssid,  <span class="math">x, \\pi</span> ) from a party  <span class="math">P_i</span> , if  <span class="math">(x, \\pi)</span>  is not stored in  <span class="math">\\mathcal{Q}</span> , then send (VERIFY, sid,  <span class="math">x, \\pi</span> ) to Sim. Upon receiving (WITNESS,  <span class="math">w</span> ) from Sim, if  <span class="math">(x, w) \\in \\mathcal{R}</span> , store  <span class="math">(x, \\pi)</span>  in  <span class="math">\\mathcal{Q}</span> . Finally, return (VERIFICATION, sid, ssid,  <span class="math">(x, \\pi) \\in_{\\tau} \\mathcal{Q}</span> ) to  <span class="math">P_i</span> .</li>

    </ul>

    <p class="text-gray-300">Fig. 4.  <span class="math">N</span> -party functionality for non-interactive zero-knowledge  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}</span></p>

    <p class="text-gray-300">The ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{Setup}}</span>  that provides the setup and oracle for non-interactive proof system  <span class="math">\\varPi_{\\mathcal{R}} = (\\mathrm{Setup},\\mathcal{O}_{\\mathrm{Setup}},\\mathcal{P},\\mathcal{V})</span>  is described in Fig. 3.</p>

    <p class="text-gray-300">Our final goal is to compile  <span class="math">\\Pi_{\\mathcal{R}}</span>  with the above basic security properties into a UC-secure NIZK protocol  <span class="math">\\Pi_{\\mathcal{R}}</span> . The ideal functionality for Non-interactive Zero-Knowledge  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}</span>  is defined in Fig. 4. The functionality is taken from [GOS12] with a minor difference being that  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}</span>  explicitly informs Sim of the associated session ID.</p>

    <p class="text-gray-300">Definition 29. Let  <span class="math">\\mathcal{R}</span>  be an NP-relation. We say that a protocol  <span class="math">\\Pi</span>  is a UC NIZK if it UC-realizes  <span class="math">\\mathcal{F}_{\\mathrm{NIZK}}</span>  (Fig. 4) in the  <span class="math">(\\mathcal{G}_{\\mathrm{RO}}, \\mathcal{F}_{\\mathrm{Setup}})</span> -hybrid model for relation  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">In this section we follow  <span class="math">\\left[\\mathrm{GKO}^{+}23, \\mathrm{BCC}^{+}24\\right]</span>  and define a series of properties and notions that are ancillary to polynomial commitments. These include: unique proofs property, polynomial encoding</p>

    <p class="text-gray-300">scheme, evaluation hiding, non-extrapolation (which we will present only to show it is implied by evaluation hiding and thus justify why we do not include it among our hypothesis in Theorem 9). Notice that all the polynomials assumed in this section are univariate.</p>

    <p class="text-gray-300">Definition 30 (Unique Proof (Polynomial Commitments)). We say a polynomial commitment scheme has unique proofs if, for all PPT adversaries  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\pi \\neq \\pi^ {\\prime} &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (\\lambda , d); \\\\ \\wedge b = 1 &amp;amp; (c, z, y, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} (\\mathsf {c k}); \\\\ \\wedge b ^ {\\prime} = 1 &amp;amp; b \\leftarrow \\mathsf {V e r} (\\mathsf {c k}, c, z, y, \\pi); \\\\ &amp;amp; b ^ {\\prime} \\leftarrow \\mathsf {V e r} (\\mathsf {c k}, c, z, y, \\pi^ {\\prime}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">We adopt the definition of polynomial encoding scheme from  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span>  (using the variant formalization presented in  <span class="math">\\left[\\mathrm{BCC}^{+}24\\right]</span> ). At its essence, a polynomial encoding scheme takes a vector of field elements and outputs a corresponding (appropriately masked) polynomial.</p>

    <p class="text-gray-300">Definition 31 (Polynomial Encoding Scheme). A polynomial encoding scheme, denoted by  <span class="math">= \\mathsf{PES}</span> , is a tuple of algorithms (Enc, Dec)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f \\gets \\mathsf{Enc}(1^{\\lambda}, \\mathbf{w}, n, \\ell; \\pmb{\\rho})</span> : Takes as inputs a security parameter,  <span class="math">\\mathbf{w} \\in \\mathbb{F}^n</span> , dimension of the vector  <span class="math">n &amp;gt; 0</span> , evaluation bound  <span class="math">\\ell &amp;gt; 0</span> , and randomness  <span class="math">\\pmb{\\rho} \\in \\mathbb{F}^{\\ell}</span> , and outputs a polynomial  <span class="math">f \\in \\mathbb{F}_{&lt;d}[x]</span> <span class="math">f=&quot;&quot; </span>d<span class="math">=&quot;&quot; </span>f\\in="" <span class="math">n=&quot;&quot; </span>n<span class="math">=&quot;&quot; a=&quot;&quot; as=&quot;&quot; for=&quot;&quot; function=&quot;&quot; inputs=&quot;&quot; of=&quot;&quot; parameters,=&quot;&quot; p(s)=&quot;&quot; security=&quot;&quot; takes=&quot;&quot; that=&quot;&quot; the=&quot;&quot; where=&quot;&quot;&gt; 0</span> , and  <span class="math">\\ell &amp;gt; 0</span> , and deterministically outputs  <span class="math">\\mathbf{w}&#x27; \\in \\mathbb{F}^n</span> .</li>

    </ul>

    <p class="text-gray-300">We say  <span class="math">= \\mathsf{PES}</span>  is correct if  <span class="math">\\mathbf{w} = \\mathsf{Dec}(1^{\\lambda},\\mathsf{Enc}(1^{\\lambda},\\mathbf{w},n,\\ell ;\\pmb {\\rho}),n,\\ell)</span>  for any  <span class="math">n &amp;gt; 0</span> <span class="math">\\ell &amp;gt;0</span> <span class="math">\\mathbf{w}\\in \\mathbb{F}^n</span>  and  <span class="math">\\pmb {\\rho}\\in \\mathbb{F}^{\\ell}</span> . We define the stretch factor stretch  <span class="math">(\\lambda ,n,\\ell)</span>  of the PES as the difference between the size of the encoding and the original size of the vector  <span class="math">\\mathbf{w}</span> , i.e., stretch  <span class="math">(\\lambda ,n,\\ell)</span>  will always be equal to  <span class="math">\\deg (f) + 1 - n</span> . We say that a polynomial encoding scheme is " <span class="math">n\\to_{\\lambda}d&quot;</span>  if, on input a security parameter  <span class="math">\\lambda</span>  and a string of size  <span class="math">n</span> , it outputs a polynomial of degree  <span class="math">d</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We only consider polynomial encoding schemes where the size of the field domain is exponential in the security parameter, i.e.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in O(2^{\\lambda})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 32 ( <span class="math">\\phi</span> -Evaluation Hiding). Let  <span class="math">PCS = (\\text{Setup}, \\text{Com}, \\text{Open}, \\text{Ver})</span>  be a polynomial commitment scheme in the random oracle model  <span class="math">\\mathcal{O}_{\\text{Setup}}</span>  and  <span class="math">PES = (\\text{Enc}, \\text{Dec})</span>  be a polynomial encoding scheme. We say  <span class="math">PCS</span>  is  <span class="math">\\phi</span> -evaluation hiding with respect to  <span class="math">= \\text{PES}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , for all  <span class="math">\\lambda, n, r \\in \\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math-block"> \\Pr \\left[ \\begin{array}{c} \\ell := \\phi (\\lambda , n, r); d := n + \\mathsf {s t r e t c h} (\\lambda , n, \\ell); \\\\ \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, d); \\\\ \\mathbb {F} ^ {n} \\ni \\mathbf {w} \\leftarrow \\mathcal {A} _ {1} (\\mathsf {c k}); \\mathbf {z} \\leftarrow \\S \\mathbb {F} ^ {r} \\\\ \\rho_ {w} \\leftarrow \\S \\mathbb {F} ^ {\\ell}; b \\leftarrow \\S \\{0, 1 \\}; \\\\ f \\leftarrow \\mathsf {E n c} (1 ^ {\\lambda}, b \\cdot \\mathbf {w}, n, \\ell ; \\rho_ {w}); \\\\ c \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, f); \\\\ \\mathbf {y} := f (\\mathbf {z}); \\\\ \\pi \\leftarrow \\mathsf {O p e n} (\\mathsf {c k}, c, \\mathbf {z}, \\mathbf {y}, f); \\\\ b ^ {\\prime} \\leftarrow \\mathcal {A} _ {2} (c, \\mathbf {y}, \\pi) \\end{array} \\right] \\leq \\frac {1}{2} + \\mathsf {n e g l} (\\lambda) </span></d}[x]$></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\mathcal{A}_1, \\mathcal{A}_2</span>  share the internal states,  <span class="math">\\mathbf{y} := f(\\mathbf{z})</span>  denotes setting  <span class="math">y_i := f(z_i)</span>  for all  $i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> ,  </span>\\pi \\gets \\mathrm{Open}(\\mathsf{ck}, c, \\mathbf{z}, \\mathbf{y}, f)<span class="math">  denotes setting  </span>\\pi_i \\gets \\mathrm{Open}(\\mathsf{ck}, c, z_i, y_i, f)<span class="math">  for all  </span>i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> . If PCS is  </span>\\phi<span class="math"> -evaluation hiding with respect to PES for some  </span>\\phi \\in O_{\\lambda}(n + r)$  then we simply say that "PCS is evaluation hiding with respect to PES".</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 33 ( <span class="math">\\phi</span> -Non-Extrapolation). Let  <span class="math">PCS = (\\text{Setup}, \\text{Com}, \\text{Open}, \\text{Ver})</span>  be a polynomial commitment scheme in the random oracle model  <span class="math">\\mathcal{O}_{\\text{Setup}}</span>  and  <span class="math">PES = (\\text{Enc}, \\text{Dec})</span>  be a polynomial encoding scheme. We say  <span class="math">PCS</span>  supports  <span class="math">\\phi</span> -non-extrapolation with respect to  <span class="math">= \\text{PES}</span>  if for all PPT adversaries  <span class="math">\\mathcal{A}</span> , for all  <span class="math">\\lambda, n, r \\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; \\ell := \\phi (\\lambda , n, r); d := n + \\mathsf {s t r e t c h} (\\lambda , n, \\ell); \\\\ &amp;amp; \\mathsf {c k} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, d); \\\\ &amp;amp; \\mathbf {z} \\leftarrow \\S \\mathbb {F} ^ {r}; \\rho_ {w} \\leftarrow \\S \\mathbb {F} ^ {\\ell}; \\\\ &amp;amp; f \\leftarrow \\mathsf {E n c} (1 ^ {\\lambda}, 0 ^ {n}, n, \\ell ; \\rho_ {w}); \\\\ &amp;amp; c \\leftarrow \\mathsf {C o m} (\\mathsf {c k}, f); \\\\ &amp;amp; \\mathbf {y} := f (\\mathbf {z}); \\\\ &amp;amp; \\boldsymbol {\\pi} \\leftarrow \\mathsf {O p e n} (\\mathsf {c k}, c, \\mathbf {z}, \\mathbf {y}, f); z ^ {*} \\leftarrow \\S \\mathbb {F} \\\\ &amp;amp; (y ^ {*}, \\pi^ {*}) \\leftarrow \\mathcal {A} (\\mathsf {c k}, c, \\mathbf {z}, \\mathbf {y}, \\boldsymbol {\\pi}, z ^ {*}); \\\\ &amp;amp; v \\leftarrow \\mathsf {V e r} (\\mathsf {c k}, c, z ^ {*}, y ^ {*}, \\pi^ {*}) \\end{array} \\right] \\in \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">In its original presentation in  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span> , non-extrapolation property is described as something to be "proven separately". However, it is in fact implied by  <span class="math">\\phi</span> -evaluation hiding in all scenarios of interest (as also hinted in  <span class="math">\\left[\\mathrm{BCC}^{+}24\\right]</span> ). An implication of this is that one can remove non-extrapolation from the requirements of the compiler in  <span class="math">\\left[\\mathrm{GKO}^{+}23\\right]</span>  (and therefore in Theorem 9). We formalize this intuition in the following theorem (whose proof is essentially the same as in  <span class="math">\\left[\\mathrm{BCC}^{+}24\\right]</span>  where it is used to prove a more specific statement).</p>

    <p class="text-gray-300">Theorem 13. A polynomial commitment satisfying weak evaluation binding and  <span class="math">\\phi</span> -evaluation hiding with respect to a polynomial encoding scheme also satisfies  <span class="math">\\phi</span> -non-extrapolation with respect to the same encoding scheme.</p>

    <p class="text-gray-300">Proof. Consider the following hybrids:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_0</span> : this is the same as the game in Definition 33 where an all-zero vector of length  <span class="math">n</span>  is encoded as a polynomial and we provide the adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  with up to  <span class="math">r</span>  evaluation points and corresponding evaluation proofs.</li>

      <li><span class="math">\\mathsf{Hyb}_1</span> : we now change part of the challenger's code. Instead of encoding an all-zero vector, we proceed by sampling a set of random evaluations and then using (in part) the evaluation points required by the adversary to interpolate the polynomial. More in detail:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we first sample  <span class="math">d</span>  random evaluations  <span class="math">y_{i}\\gets \\S \\mathbb{F}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  <span class="math">\\mathbf{z}</span>  be the sampled evaluation points and let  <span class="math">\\mathbf{z}&#x27;</span>  a vector of unique points in  <span class="math">\\mathbf{z}</span> . Let  $r' :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and let  </span>n' := d - r'$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">n&#x27;</span>  points  <span class="math">\\mathbf{z}&#x27;&#x27;</span>  from  <span class="math">\\mathbb{F}^{n&#x27;}</span> .</li>

      <li>Interpolate  <span class="math">f</span>  so that  <span class="math">f(z_{i}^{\\prime}) = y_{i}</span>  for  <span class="math">i \\in [r&#x27;]</span>  and  <span class="math">f(z_{j}^{\\prime \\prime}) = y_{j + r&#x27;}</span>  for  <span class="math">j \\in [n&#x27;]</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute commitments and evaluation proofs as before.</li>

    </ul>

    <p class="text-gray-300">By applying <span class="math">\\phi</span>-evaluation hiding we can conclude that the two hybrids are indistinguishable and therefore the polynomial <span class="math">f</span> looks random to <span class="math">\\mathcal{A}</span> after requesting <span class="math">r</span> evaluations. Let us now consider <span class="math">(y^{<em>},\\pi^{</em>})</span>, the output of <span class="math">\\mathcal{A}_{2}</span> for <span class="math">z^{<em>}\\leftarrow\\S\\E</span>. By the previous observation, the probability that <span class="math">\\Pr[y^{</em>}=f(z^{<em>})]</span> is negligible. If <span class="math">y^{</em>}\\neq f(z^{*})</span> and <span class="math">\\mathcal{A}</span> wins it is then possible to break evaluation binding since we can produce two valid evaluation proofs for two distinct points for the same committed polynomial. This concludes the proof.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">D.4 Additional Relevant Cryptographic Preliminaries</h3>

    <p class="text-gray-300">Unique Proofs for Vector Commitments. We leverage the following property to prove that our construction of polynomial commitments with sublinear opening <span class="math">\\PC_{\\VC}</span> has unique proofs.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Definition 34 (Unique Proof (Vector Commitments)).</h6>

    <p class="text-gray-300">We say a vector commitment scheme has unique proofs if, for all PPT adversaries <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{cc}\\pi\\neq\\pi^{\\prime}&\\text{\\sf ck}\\leftarrow\\text{\\sf Setup}(1^{\\lambda},n)\\\\ \\wedge\\ b=1&:\\text{\\sf(cm},i,y,\\pi,\\pi^{\\prime})\\leftarrow\\mathcal{A}(\\text{\\sf ck});\\\\ \\wedge\\ b^{\\prime}=1&&b\\leftarrow\\text{\\sf Ver}(\\text{\\sf ck},\\text{\\sf cm},i,y,\\pi);\\\\ &\\hskip 14.22636ptb^{\\prime}\\leftarrow\\text{\\sf Ver}(\\text{\\sf ck},\\text{\\sf cm},i,y,\\pi^{\\prime})\\end{array}\\right]\\in\\text{\\sf negl}(\\lambda). \\]</p>

    <p class="text-gray-300">Strong Diffie-Hellman Assumption.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Definition 35 (SDH Assumption <em>[x1]</em>).</h6>

    <p class="text-gray-300">The strong Diffie-Hellman assumption (SDH) holds with respect to a bilinear group generator BGen if for all PPT adversaries <span class="math">\\mathcal{A}</span> and degree bound <span class="math">D&gt;0</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[t=g^{\\frac{1}{\\alpha+c}}\\mid\\mathcal{G}\\leftarrow\\text{\\sf BGen}(1^{\\lambda});\\alpha\\leftarrow\\S\\E;\\sigma:=(\\{g^{\\alpha^{i}}\\}_{i=0}^{D-1},h^{\\alpha});(t,c)\\leftarrow\\mathcal{A}(\\mathcal{G},\\sigma)\\right]\\in\\text{\\sf negl}(\\lambda)</span></p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">In the statement of Theorem 8 we use some of the implications of SDH in terms of cryptographic assumptions and primitives, namely: <span class="math">\\SDH\\implies\\text{\\sf DLOG}\\implies\\exists\\text{\\sf CRHF}</span> (via Pedersen hashing) and <span class="math">\\text{\\sf DLOG}\\implies\\exists\\text{\\sf OWF}\\implies\\exists\\text{\\sf SKE}</span>.</p>

    <p class="text-gray-300">The KZG Polynomial Commitment Scheme <em>[x11]</em>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Construction 4 (KZG PC scheme <em>[x11]</em>)</h6>

    <p class="text-gray-300">The KZG PC scheme of <em>[x11]</em> is defined as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\text{\\sf Setup}(1^{\\lambda},D)</span>: Generate the parameters of a bilinear group <span class="math">\\mathcal{G}=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},q,g,h,e)</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q<span class="math"> is prime, </span>\\langle g\\rangle=\\mathbb{G}_{1}<span class="math">, </span>\\langle h\\rangle=\\mathbb{G}_{2}<span class="math">, and </span>e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}<span class="math"> is an efficiently computable, non-degenerate biinear map. The group order </span>q<span class="math"> also determines </span>\\E:=\\E_{q}<span class="math"> and a set of supported polynomials </span>\\E_{<D}[X]<span class="math">. Sample </span>\\alpha\\in\\E<span class="math"> uniformly, and compute </span>\\sigma=(g,g^{\\alpha},\\ldots,g^{\\alpha^{D-1}},h,h^{\\alpha})<span class="math">. Output </span>\\text{\\sf ck}=(\\mathcal{G},\\sigma)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{\\sf Com}(\\text{\\sf ck},f,d)</span>: On input <span class="math">\\text{\\sf ck}</span>, a polynomial <span class="math">f\\in\\E_{&lt;d}[X]</span>, and a degree bound <span class="math">d\\leq D</span>, compute a shifted polynomial <span class="math">\\hat{f}=X^{D-d}\\cdot f</span>, and generate a commitment as <span class="math">\\mathbf{c}=(g^{f(\\alpha)},g^{\\hat{f}(\\alpha)})</span> and output <span class="math">\\mathbf{c}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Open}(\\mathsf{ck},c,d,z,f(z),f)</span>: Compute <span class="math">\\omega(X)=(f(X)-f(z))/(X-z)</span> and <span class="math">\\hat{\\omega}(X)=(\\hat{f}(X)-\\hat{f}(z))/(X-z)</span>, <span class="math">\\hat{f}</span> computed as above. Output <span class="math">\\bm{\\pi}=(g^{\\omega(\\alpha)},g^{\\hat{\\omega}(\\alpha)},\\hat{f}(z))</span>. <span class="math">\\mathsf{Ver}(\\mathsf{ck},\\mathbf{c},d,z,y,\\bm{\\pi})</span>: Parse <span class="math">\\mathbf{c}=(c,\\hat{c})</span> and <span class="math">\\bm{\\pi}=(\\pi,\\hat{\\pi},\\hat{y})</span>. Accept if and only if <span class="math">e(c/g^{y},h)=e(\\pi,h^{\\alpha}/h^{z})</span>, <span class="math">e(\\hat{c}/g^{\\hat{y}},h)=e(\\hat{\\pi},g^{\\alpha}/h^{z})</span>, and <span class="math">\\hat{y}=z^{D-d}\\cdot y</span>.</p>

    <p class="text-gray-300">The security of <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}</span> relies on the SDH assumption (Definition 35). We can prove it satisfies some of our properties of interests with respect to the simple following polynomial encoding scheme:</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Definition 36 (Coefficient-based PES <em>[GKO^{+}23]</em>).</h6>

    <p class="text-gray-300">The coefficient-based polynomial encoding scheme <span class="math">\\mathsf{PES}_{\\mathsf{coeff}}</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Enc}(1^{\\lambda},\\mathbf{w},n,\\ell;\\bm{\\rho})</span>: Return <span class="math">f(X):=\\sum_{i=1}^{n}w_{i}X^{i-1}+\\sum_{i=1}^{\\ell}\\rho_{i}X^{n+i-1}</span>;</li>

      <li><span class="math">\\mathsf{Dec}(1^{\\lambda},f,n,\\ell)</span>: Return the first <span class="math">n</span> coefficients of <span class="math">f</span>.</li>

    </ul>

    <h6 id="sec-84" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">(<em>[GKO^{+}23]</em>) <span class="math">\\mathsf{PC}_{\\mathsf{KZG}}</span> satisfies the unique proofs (Definition 30) and evaluation binding property under the SDH assumption. It is also <span class="math">\\phi</span>-evaluation hiding (Definition 32) with respect to the polynomial encoding scheme <span class="math">\\mathsf{PES}_{\\mathsf{coeff}}</span> (Definition 36) where <span class="math">\\phi(\\cdot,\\cdot,r):=r+1</span>.</p>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">Secret-Key Encryption</h4>

    <p class="text-gray-300">A symmetric encryption (SKE) scheme with message space <span class="math">\\mathcal{M}</span> is composed of the following polynomial-time algorithms:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KGen}(1^{\\lambda})</span>: The randomized key generator takes as input the security parameter <span class="math">1^{\\lambda}</span> and outputs a symmetric key <span class="math">\\mathsf{sk}</span>. <span class="math">\\mathsf{Enc}(\\mathsf{sk},m)</span>: The randomized encryption algorithm takes as input a symmetric key <span class="math">\\mathsf{sk}</span> and a message <span class="math">m\\in\\mathcal{M}</span>, it outputs a ciphertext <span class="math">\\mathsf{ct}</span>. <span class="math">\\mathsf{Dec}(\\mathsf{sk},\\mathsf{ct})</span>: The deterministic decryption algorithm takes as input a symmetric key <span class="math">\\mathsf{sk}</span> and a ciphertext <span class="math">\\mathsf{ct}</span>, it outputs a message <span class="math">m</span>.</p>

    <p class="text-gray-300">A SKE is correct if the honest ciphertext correctly decrypts.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition 37 (Correctness of SKE).</h6>

    <p class="text-gray-300">A SKE <span class="math">\\mathsf{SKE}</span> with message space <span class="math">\\mathcal{M}</span> is correct if <span class="math">\\forall\\lambda\\in\\mathbb{N}</span>, <span class="math">\\forall m\\in\\mathcal{M}</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\mathsf{Dec}(\\mathsf{sk},\\mathsf{Enc}(\\mathsf{sk},m))=m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}\\leftarrow\\S\\mathsf{KGen}(1^{\\lambda})]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-87" class="text-base font-medium mt-4">Definition 38 (Semantic security of SKE).</h6>

    <p class="text-gray-300">We say that a SKE <span class="math">\\mathsf{SKE}</span> with message space <span class="math">\\mathcal{M}</span> is semantically secure if for every <span class="math">m_{0},m_{1}\\in\\mathcal{M}</span>, every PPT adversaries <span class="math">\\mathcal{A}</span>, we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathsf{G}^{\\mathsf{SKEsec}}_{\\mathsf{SKE},\\mathcal{A},m_{0},m_{1}}(\\lambda)=1]-\\frac{1}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{negl}(\\lambda),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the experiment <span class="math">\\mathsf{G}^{\\mathsf{SKEsec}}_{\\mathsf{SKE},\\mathcal{A},m_{0},m_{1}}(\\lambda)</span> is depicted in Figure 5.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Definition 39 (Admissible SKE).</h6>

    <p class="text-gray-300">We say that a SKE <span class="math">\\mathsf{SKE}</span> is admissible with respect to a polynomial commitment <span class="math">\\mathsf{PC}</span> if the following holds: let <span class="math">\\lambda</span> be any security parameter and let <span class="math">\\mathbb{F}</span> be the scalar field supported by <span class="math">\\mathsf{PC}</span> when the commitment key is generated with security parameter <span class="math">\\lambda</span>, then on input the same security parameter <span class="math">\\lambda</span>, <span class="math">\\mathsf{SKE}</span> has keys, plaintexts and ciphertexts that are vectors of elements in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig.5. SKE semantic security.</p>

    <p class="text-gray-300">Simulation-extractability of NIZKs in literature. In the theorems below  <span class="math">n</span>  is the multiplicative complexity of the arithmetic circuit describing the relation. The verifier has an additive overhead linear in the size of the public input which below we keep implicit since irrelevant in the compiler from [GKO+23].</p>

    <p class="text-gray-300">Theorem 14 ([GM17]). Under the Computational Polynomial Assumption and the XPKE Assumption <span class="math">^{30}</span>  (See Assumption 4.1 and 4.2 in [GM17]), there exists a simulation-extractable NIZK with  <span class="math">O_{\\lambda}(1)</span>  proofs of size and verification time and proving time  <span class="math">\\widetilde{O}_{\\lambda}(n)</span> .</p>

    <p class="text-gray-300">In this section, we describe the compiler  <span class="math">\\Pi_{\\mathsf{GKOPTT}}</span>  of  <span class="math">[\\mathsf{GKO}^{+}23]</span>  for NP-relation  <span class="math">\\mathcal{R}</span>  following the presentation in  <span class="math">[\\mathrm{BCC}^{+}24]</span> . Specifically, the compiler makes use of the following tools:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi_{\\mathsf{PCS}}</span> , a polynomial commitment scheme with weak evaluation binding, unique proofs (Definition 30),  <span class="math">\\phi</span> -evaluation hiding (Definition 32) with respect to a companion encoding scheme  <span class="math">\\mathsf{PES} = (\\mathsf{Enc}, \\mathsf{Dec})</span>  (Definition 31).</li>

      <li>Let  <span class="math">\\Pi_{\\mathsf{NIZK}}</span>  be a simulation-extractable NIZK (Definition 28), for the relation  <span class="math">\\mathcal{R}_{\\mathsf{NIZK}} = \\{((x, \\mathsf{ck}, n, \\ell), (w, \\pmb{\\rho}_w)) : (x, w) \\in \\mathcal{R} \\land \\mathsf{cm} = \\mathsf{Com}(\\mathsf{ck}, \\mathsf{Enc}(\\mathbf{w}, n, \\ell; \\pmb{\\rho}_w))\\}</span>  where  <span class="math">\\mathbf{w}</span>  denotes the witness  <span class="math">w</span>  parsed as a vector of field elements in  <span class="math">\\mathbb{F}^n</span> .</li>

    </ul>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\mathrm{GKOPTT}}</span>  is parameterized by:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Security parameter  <span class="math">\\lambda</span></li>

      <li>Finite field  <span class="math">\\mathbb{F}</span></li>

      <li>Evaluation hiding factor  <span class="math">\\phi : \\mathbb{Z}^{+} \\times \\mathbb{Z}^{+} \\times \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}</span>  and stretch stretch:  <span class="math">\\mathbb{Z}^{+} \\times \\mathbb{Z}^{+} \\times \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}</span></li>

      <li>Number of parallel repetitions  <span class="math">r = r(\\lambda) &amp;gt; 0</span></li>

      <li>Proof-of-work parameter  <span class="math">b(\\lambda) &amp;gt; 0</span></li>

      <li>Bound  <span class="math">T(\\lambda) &amp;gt; 0</span></li>

      <li>Maximum degree bound  <span class="math">D &amp;gt; 0</span>  for  <span class="math">\\Pi_{\\mathrm{PCS}}</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof: On input (PROVE, sid,  <span class="math">x,w</span> ), ignore if  <span class="math">(x,w) \\notin \\mathcal{R}</span> ; otherwise,  <span class="math">\\mathrm{P}_i</span>  does:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (QUERY, (sid,  <span class="math">x</span> , genparamssproof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back pp.</li>

      <li>Send (QUERY, (sid,  <span class="math">x</span> , genparamspc)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back ck.</li>

      <li>Parse  <span class="math">w = \\mathbf{w} \\in \\mathbb{F}^n</span> . Let  <span class="math">\\ell := \\phi(\\lambda, n, r)</span>  and  <span class="math">d := \\text{stretch}(\\lambda, n, \\ell) + n</span> . If  <span class="math">d &amp;gt; D</span> , abort by outputting (PROOF, sid,  <span class="math">\\bot</span> ).</li>

      <li>Generate a polynomial encoding of the witness vector:  <span class="math">f \\gets \\mathsf{Enc}\\left(1^{\\lambda}, \\mathbf{w}, n, \\ell; \\boldsymbol{\\rho}_{w}\\right)</span> , where  <span class="math">\\boldsymbol{\\rho}_{w} \\gets \\mathbb{F}^{\\ell}</span> .</li>

      <li>Generate a commitment to the polynomial encoding:  <span class="math">(\\mathsf{cm},\\mathsf{aux})\\gets \\mathsf{Com}(\\mathsf{ck},f)</span></li>

      <li>Run the prover  <span class="math">\\mathcal{P}</span>  of  <span class="math">\\Pi_{\\mathrm{NIZK}}</span>  on input  <span class="math">x&#x27; = (\\mathsf{pp}, (x, \\mathsf{ck}, n, \\ell))</span>  and  <span class="math">w&#x27; = (w, \\rho_w)</span>  to obtain a proof  <span class="math">\\pi&#x27;</span> . Whenever  <span class="math">\\mathcal{P}</span>  makes a call to  <span class="math">\\mathcal{O}_{\\mathrm{Setup}}</span>  with input in, send (QUERY, (sid, in, proof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  to receive a response out which is forwarded to  <span class="math">\\mathcal{P}</span> .</li>

      <li>Initialize empty sets  <span class="math">\\mathbf{z},\\mathbf{y}</span>  , and  <span class="math">\\pi_{\\mathrm{PCS}}</span></li>

      <li>For each iteration  <span class="math">i\\in [r]</span>  do: (a) Initialize counter  <span class="math">\\mathsf{ctr}\\coloneqq 0</span>  and set of used evaluation points  <span class="math">\\mathcal{D}_i\\coloneqq \\emptyset</span>  (b) If  <span class="math">\\mathsf{ctr} = T</span>  , abort by outputting (PROOF, sid, runout_eval).</li>

    </ol>

    <p class="text-gray-300">(c) Sample point:  <span class="math">z_{i}\\gets \\mathbb{F}\\backslash \\mathcal{D}_{i}</span>  . Update ctr := ctr + 1 and  <span class="math">\\mathcal{D}_i\\coloneqq \\mathcal{D}_i\\cup \\{z_i\\}</span> (d) Compute  <span class="math">y_{i} = f(z_{i})</span>  and evaluation proof  <span class="math">\\pi_i\\gets \\mathrm{Open}(\\mathsf{ck},\\mathsf{cm},z_i,y_i,\\mathsf{aux})</span> (e) Send (QUERY, (sid,  <span class="math">(\\mathcal{C}&#x27;, \\mathsf{cm}, z_i, y_i, \\pi_i, i))</span> ) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> . Upon receiving  <span class="math">v</span>  from  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> , if the first  <span class="math">b</span>  bits of  <span class="math">v</span>  are not  <span class="math">0^b</span> , go to step 8b. Otherwise, store  <span class="math">z_i, y_i</span> , and  <span class="math">\\pi_i</span>  in  <span class="math">\\mathbf{z}, \\mathbf{y}</span> , and  <span class="math">\\pi_{\\mathrm{PCS}}</span> , respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output (PROOF, sid,  <span class="math">\\pi</span> ), where  <span class="math">\\pi := (\\pi&#x27;, \\mathsf{cm}, \\mathbf{z}, \\mathbf{y}, \\pi_{\\mathrm{PCS}})</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification: Upon receiving input (VERIFY, sid,  <span class="math">\\mathcal{C},\\pi</span> ),  <span class="math">\\mathrm{P}_i</span>  does:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send (QUERY, (sid,  <span class="math">x</span> , genparamssproof)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back pp.</li>

      <li>Send (QUERY, (sid,  <span class="math">x</span> , genparamspc)) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span>  receiving back ck.</li>

      <li>Parse  <span class="math">\\pi = (\\pi&#x27;, \\mathsf{cm}, \\mathbf{z}, \\mathbf{y}, \\pi_{\\mathrm{PCS}})</span> . Derive the witness size  <span class="math">n</span>  from the description of  <span class="math">\\mathcal{C}</span> . Compute  <span class="math">\\ell</span>  and  <span class="math">d</span>  as Proof would and if  <span class="math">d &amp;gt; D</span>  abort by outputting (VERIFICATION, sid, 0).</li>

      <li>Define the statement  <span class="math">x&#x27;</span>  as the Proof step would.</li>

      <li>Parse  <span class="math">\\mathbf{z} = (z_i)_{i\\in [r]}</span> ,  <span class="math">\\mathbf{y} = (y_i)_{i\\in [r]}</span> , and  <span class="math">\\pi_{\\mathrm{PCS}} = (\\pi_i)_{i\\in [r]}</span> .</li>

      <li>Output (VERIFICATION, sid,1) if all of the following checks pass, otherwise output (VERIFICATION, sid, 0):</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\Pi_{\\mathcal{R}}.\\mathcal{V}(\\mathsf{pp},x&#x27;,\\pi &#x27;)</span>  outputs 1. (Calls to  <span class="math">\\mathcal{O}_{\\mathrm{Setup}}</span>  by  <span class="math">\\mathcal{V}</span>  handled like above). (b) For all  <span class="math">i\\in [r]:1 = \\mathsf{Ver}(\\mathsf{ck},\\mathsf{cm},d,z_i,y_i,\\pi_i)</span> (c) For all  <span class="math">i \\in [r]</span> : send (QUERY, (sid,  <span class="math">(\\mathcal{C}&#x27;, \\mathsf{cm}, z_i, y_i, \\pi_i, i))</span> ) to  <span class="math">\\mathcal{G}_{\\mathrm{RO}}</span> , and the first  <span class="math">b</span>  bits of the return value  <span class="math">v_i</span>  are  <span class="math">0^b</span> .</p>

    <p class="text-gray-300">Correctness. The correctness of  <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span>  follows from the correctness of PP and VC, respectively; this is straightforward by inspection.</p>

    <p class="text-gray-300">Evaluation Binding. We proceed by contradiction. Assume an adversary  <span class="math">\\mathcal{A}</span>  that breaks the evaluation binding of  <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span>  with non-negligible probability  <span class="math">\\epsilon</span> . We demonstrate how to construct an adversary  <span class="math">\\mathcal{B}</span>  that breaks the position binding of VC with the same probability.  <span class="math">\\mathcal{B}</span>  selects the public parameters  <span class="math">\\mathsf{pp} \\gets \\mathsf{PP.ParamS}(R, m, d)</span>  of the PP scheme and receives from the challenger a VC commitment key  <span class="math">\\mathsf{ck}_{\\mathsf{VC}}</span>  corresponding to the length  <span class="math">S</span>  in  <span class="math">\\mathsf{pp}</span> . Then,  <span class="math">\\mathcal{B}</span>  runs  <span class="math">\\mathcal{A}</span>  on input  <span class="math">\\mathsf{ck} = (\\mathsf{ck}_{\\mathsf{VC}}, \\mathsf{pp})</span> , which, in turn, returns  <span class="math">(\\mathsf{cm}, x, y, \\pi_x, y&#x27;, \\pi_x&#x27;)</span>  to  <span class="math">\\mathcal{B}</span> , where:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {V e r} (\\operatorname {c k}, \\operatorname {c m}, x, y, \\pi_ {x}) = 1 \\wedge \\operatorname {V e r} (\\operatorname {c k}, \\operatorname {c m}, x, y ^ {\\prime}, \\pi_ {x} ^ {\\prime}) = 1 \\wedge y \\neq y ^ {\\prime}.</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{cm}=\\mathsf{cm}_{\\mathsf{DS}}</span>, <span class="math">\\pi_{x}=(v_{1},\\pi_{1},\\ldots,v_{k},\\pi_{k})</span>, and <span class="math">\\pi^{\\prime}_{x}=(v^{\\prime}_{1},\\pi^{\\prime}_{1},\\ldots,v^{\\prime}_{k},\\pi^{\\prime}_{k})</span>. Then, the above equation can be rewritten as follows:</p>

    <p class="text-gray-300"><span class="math">\\bigwedge_{j\\in[k]}\\mathsf{VC.Ver}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}},i_{j},v_{j},\\pi_{j})=1</span> <span class="math">\\wedge</span> <span class="math">y=\\mathsf{PP.Reconstruct}(\\mathsf{pp},x,v_{1},\\ldots,v_{k})</span> <span class="math">\\wedge</span> <span class="math">\\bigwedge_{j\\in[k]}\\mathsf{VC.Ver}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}},i_{j},v^{\\prime}_{j},\\pi^{\\prime}_{j})=1</span> <span class="math">\\wedge</span> <span class="math">y^{\\prime}=\\mathsf{PP.Reconstruct}(\\mathsf{pp},x,v^{\\prime}_{1},\\ldots,v^{\\prime}_{k})</span> <span class="math">\\wedge</span> <span class="math">y\\neq y^{\\prime}</span></p>

    <p class="text-gray-300">where <span class="math">(i_{1},\\ldots,i_{k})\\leftarrow\\mathsf{PP.Lookup}(\\mathsf{pp},x)</span>.</p>

    <p class="text-gray-300">Consider the following two mutually exclusive cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(v_{1},...,v_{k})=(v^{\\prime}_{1},...,v^{\\prime}_{k})</span>. Then, we obtain</li>

    </ul>

    <p class="text-gray-300"><span class="math">y=\\mathsf{PP.Reconstruct}(\\mathsf{pp},x,v_{1},\\ldots,v_{k})=\\mathsf{PP.Reconstruct}(\\mathsf{pp},x,v^{\\prime}_{1},\\ldots,v^{\\prime}_{k})=y^{\\prime}</span></p>

    <p class="text-gray-300">which contradicts <span class="math">y\\neq y^{\\prime}</span> as defined above.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(v_{1},...,v_{k})\\neq(v^{\\prime}_{1},...,v^{\\prime}_{k})</span>. Then, there exists some <span class="math">j\\in[k]</span> such that <span class="math">v_{j}\\neq v^{\\prime}_{j}</span> and <span class="math">\\mathsf{VC.Ver}(\\mathsf{ck}_{\\mathsf{VC}}</span>, <span class="math">\\mathsf{cm}_{\\mathsf{DS}},i_{j},v_{j},\\pi_{j})=\\mathsf{VC.Ver}(\\mathsf{ck}_{\\mathsf{VC}},\\mathsf{cm}_{\\mathsf{DS}},i_{j},v^{\\prime}_{j},\\pi^{\\prime}_{j})=1</span>. In this case, <span class="math">\\mathcal{B}</span> returns <span class="math">(\\mathsf{cm}_{\\mathsf{DS}},i_{j},v_{j},\\pi_{j},v^{\\prime}_{j}</span>, <span class="math">\\pi^{\\prime}_{j})</span>, which contradicts the position binding property of <span class="math">\\mathsf{VC}</span>.</li>

    </ul>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300">Succinctness. We prove the succinctness of <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> for the multivariate case. The proof for univariate polynomials is analogous.</p>

    <p class="text-gray-300">Regarding the commitment size, we observe that <span class="math">\\mathsf{cm}</span> corresponds to <span class="math">\\mathsf{cm}_{\\mathsf{DS}}</span>, i.e., the <span class="math">\\mathsf{VC}</span> commitment over the vector <span class="math">\\mathsf{DS}</span> (data structure) of size <span class="math">S</span>. By combining the succinctness of <span class="math">\\mathsf{VC}</span> and the efficiency of <span class="math">\\mathsf{PP}</span>, we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$S\\in\\mathsf{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d^{m})\\text{ and }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm}_{\\mathsf{DS}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{poly}(\\lambda\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log(S)).$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above implies that the size of <span class="math">\\mathsf{cm}</span> in <span class="math">\\mathsf{PC}</span> is $\\mathsf{poly}(\\lambda\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log(d^{m}))<span class="math">, where </span>d^{m}$ represents the size of the polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Regarding the opening proof size, we note that <span class="math">\\pi_{x}</span> consists of <span class="math">k</span> opening proofs <span class="math">\\{\\pi_{j}\\}_{j\\in[k]}</span> and <span class="math">k</span> blocks <span class="math">\\{v_{j}\\}_{j\\in[k]}</span> of the data structure <span class="math">S</span>, where <span class="math">k</span> is the number of indices generated by <span class="math">\\mathsf{PP.Lookup}</span>. By combining the succinctness of <span class="math">\\mathsf{VC}</span> and the efficiency of <span class="math">\\mathsf{PP}</span>, we obtain:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)\\text{ and }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log(S)),$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">S</span> is as defined in Equation (7), and the bounds on <span class="math">k</span> and <span class="math">v_{j}</span> are derived from the running time of both <span class="math">\\mathsf{PP.Lookup}</span> and <span class="math">\\mathsf{PP.Reconstruct}</span> (see Definition 12). By combining these observations, we conclude that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\in\\mathsf{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, the running time of <span class="math">\\mathsf{Ver}</span> in <span class="math">\\mathsf{PC}_{\\mathsf{VC}}</span> can be decomposed as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The running time of both <span class="math">\\mathsf{PP.Lookup}</span> and <span class="math">\\mathsf{PP.Reconstruct}</span>, which is bounded by $\\mathsf{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)<span class="math">, as </span>\\mathsf{PP}$ satisfies efficiency.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">k</span> times the running time of VC.Ver, where both are bounded by $\\poly(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)<span class="math">. This follows from the fact that </span>k\\in\\poly(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)$, as defined in Equation (8), and that VC satisfies succinctness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This concludes the proof.</p>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">Fast Openings</h3>

    <p class="text-gray-300">We prove the fast openings of PC_{VC} for the multivariate case. The proof for univariate polynomials is analogous.</p>

    <p class="text-gray-300">The running time of Com in PC_{VC} can be decomposed as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The running time of PP.PreProcess, which is bounded by $\\poly(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d^{m})$ since PP is efficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By combining these observations, we conclude that Com runs in time $\\poly(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d^{m})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, the running time of Open in PC_{VC} can be decomposed as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The running time of PP.Lookup, which is bounded by $\\poly(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)$ since PP is efficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">These bounds imply that Open runs in time $\\poly(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">E.2 Proof of Lemmas 1 and 2</h3>

    <p class="text-gray-300">Proof of Lemma 1. The proof is straightforward and we present only an informal outline. Recall that the unique proof property (informally) states that no efficient adversary can produce a polynomial commitment cm, a claimed evaluation output <span class="math">y</span> and two different accepting proofs <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span> for cm and <span class="math">y</span>. The proof follows by contradiction: if we assume that there exists such an adversary for PC^{hyb} then we are able to break either the unique proof property or the evaluation binding for at least one of the two underlying schemes hidPC and subPC. More in detail: recall from Fig. 1 that a proof for PC^{hyb} consists of a tuple <span class="math">(\\pi_{f},\\pi_{g},y_{g})</span>. Now assume an adversary that successfully provides two different tuples <span class="math">\\pi:=(\\pi_{f},\\pi_{g},y_{g})</span> and <span class="math">\\pi^{\\prime}:=\\left(\\pi_{f}^{\\prime},\\pi_{g}^{\\prime},y_{g}^{\\prime}\\right)</span>. There are two possibilities: either we have that (i) <span class="math">y_{g}=y_{g}^{\\prime}</span>, or (ii) <span class="math">y_{g}\\neq y_{g}^{\\prime}</span>. If (i) holds then we must have <span class="math">\\pi_{\\omega}\\neq\\pi_{\\omega}^{\\prime}</span> (with <span class="math">\\omega\\in\\{f,g\\}</span>) implying that we are able to produce two distinct proofs for the same point <span class="math">y_{g}</span> (resp. <span class="math">y_{f}:=y-y_{g}</span>) for the polynomial commitment hidPC (resp. subPC). If (ii) then <span class="math">\\pi_{g}</span> is a valid proof claiming evaluation output <span class="math">y_{g}</span> and <span class="math">\\pi_{g}^{\\prime}</span> is a valid proof claiming evaluation output <span class="math">y_{g}^{\\prime}\\neq y_{g}</span>, contradicting the assumption on hidPC satisfying evaluation binding.</p>

    <p class="text-gray-300">Proof of Lemma 2. Consider an adversary <span class="math">\\mathcal{A}_{\\phi}^{\\mathrm{hyb}}=(\\mathcal{A}_{\\phi,1}^{\\mathrm{hyb}},\\mathcal{A}_{\\phi,2}^{\\mathrm{hyb}})</span> against the <span class="math">\\phi</span>-evaluation game for PC^{hyb} and parameters <span class="math">\\lambda,n,r\\in\\mathbb{N}</span> (all other parameters are determined by these; see caption of Fig. 7). We define a series of hybrids. The first hybrid <span class="math">\\mathcal{H}_{0}</span> (Fig. 7) corresponds to the <span class="math">\\phi</span>-hiding game where we encode the vector w provided by the adversary. We fully expand the encoding step of the polynomial encoding scheme PES^{hyb} since this is where the changes will occur between hybrids. The last hybrid <span class="math">\\mathcal{H}_{3}</span> (Fig. 7) corresponds to the same game as <span class="math">\\mathcal{H}_{0}</span> but where we encode the vector of all zeros instead of what is provided by the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{H}_{0}\\approx\\mathcal{H}_{1}:</span> the difference between these two games is that in <span class="math">\\mathcal{H}_{1}</span> has to do with how we define the polynomial <span class="math">g</span>: instead of producing it as an encoding of <span class="math">\\mathsf{sk}</span>, we instead encode a dummy string of all zeros. In order to show that <span class="math">\\mathcal{H}_{0}\\not\\approx\\mathcal{H}_{1}</span> we can build an adversary <span class="math">\\mathcal{A}_{\\phi}^{\\text{hid}}</span> (shown in Appendix E.2) against the <span class="math">\\phi</span>-hiding game. This adversary would emulate all the other parts of the execution (the ciphertexts, the commitment and the polynomial commitment proofs for <span class="math">f</span>, etc.) and then use the output of <span class="math">\\mathcal{A}_{\\phi}^{\\text{hyb}}</span> to identify whether it has received an encoding of <span class="math">\\mathsf{sk}</span> or <span class="math">\\mathbf{0}</span>.</li>

      <li><span class="math">\\mathcal{H}_{1}\\approx\\mathcal{H}_{2}:</span> the only difference between these two hybrids is what is actually encrypted in the output of <span class="math">\\mathsf{PES}^{\\text{hyb}}.\\mathsf{Enc}</span> (<span class="math">\\mathbf{w}</span> or <span class="math">\\mathbf{0}</span>). We can rely on semantic security to claim that the difference in the advantage of the adversary is negligible. We construct a reduction against semantic security (Definition 38) so that a noticeable difference in output between the two hybrids corresponds to a noticeable advantage against the semantic security experiment leading to a contradiction. Our reduction to semantic security (Definition 38) is straightforward and at the high level works as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the target messages are (<span class="math">m_{0}:=\\mathbf{w},m_{1}:=\\mathbf{0}</span>);</li>

      <li>the challenger generates a secret key and provides the adversary with an encryption <span class="math">\\mathsf{ct}^{\\star}</span> of <span class="math">m_{b}</span> where <span class="math">b\\leftarrow\\</span> <span class="math">\\{0,1\\}</span>;</li>

      <li>the adversary constructs <span class="math">g</span> exactly as done in both <span class="math">\\mathcal{H}_{1}</span> and <span class="math">\\mathcal{H}_{2}</span> (as an encoding of <span class="math">\\mathbf{0}</span>), <span class="math">f</span> as <span class="math">\\mathsf{polyFromCoeffs}(\\mathsf{ct}^{\\star})</span>, it then proceeds following the rest of the pseudocode in <span class="math">\\mathcal{H}_{1}</span> (and hence <span class="math">\\mathcal{H}_{2}</span>).</li>

      <li>the adversary finally outputs <span class="math">b^{\\prime}</span>.</li>

      <li><span class="math">\\mathcal{H}_{2}\\approx\\mathcal{H}_{3}:</span> here we restore the encoding of <span class="math">\\mathsf{sk}</span> to generate <span class="math">g</span>; we can argue exactly as we did to show <span class="math">\\mathcal{H}_{0}\\approx\\mathcal{H}_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">Since we have shown that <span class="math">\\mathcal{H}_{0}\\approx\\mathcal{H}_{3}</span>, we can immediately conclude that the advantage of any PPT adversary against <span class="math">\\phi</span>-hiding would be negligible.</p>

    <h2 id="sec-95" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 6. Reduction to the evaluation hiding of hidPES. We assume  <span class="math">\\mathcal{A}_{\\phi}^{\\mathrm{hid}}</span>  is stateful. Notation-wise,  <span class="math">F(\\mathbf{v})</span>  denotes the result of applying  <span class="math">F</span>  to each element of  <span class="math">\\mathbf{v}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H0:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H1:</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ck← hidPC.Setup(1λ,k)</td>

            <td class="px-3 py-2 border-b border-gray-700">ck← hidPC.Setup(1λ,k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ck'← subPC.Setup(1λ,d-k)</td>

            <td class="px-3 py-2 border-b border-gray-700">ck'← subPC.Setup(1λ,d-k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F^n⊗w← Aθyb(1(ck,ck'))</td>

            <td class="px-3 py-2 border-b border-gray-700">F^n⊗w← Aθyb(1(ck,ck'))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z←$ F^r</td>

            <td class="px-3 py-2 border-b border-gray-700">z←$ F^r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sk← SKE.KG(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">sk← SKE.KG(1λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ct← SKE.Enc(sk,w)</td>

            <td class="px-3 py-2 border-b border-gray-700">ct← SKE.Enc(sk,w)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f(X):=polyFromCoeffs(ct)</td>

            <td class="px-3 py-2 border-b border-gray-700">f(X):=polyFromCoeffs(ct)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y_f← f(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">y_f← f(z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g← hidPES.Enc(sk,κ,ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">g← hidPES.Enc(0,κ,ℓ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y_g← g(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">y_g← g(z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y← y_f + Z_k(z)·y_g</td>

            <td class="px-3 py-2 border-b border-gray-700">y← y_f + Z_k(z)·y_g</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(cm_f,aux_f)← subPC.Com(ck',f)</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm_f,aux_f)← subPC.Com(ck',f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(cm_g,aux_g)← hidPC.Com(ck,g)</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm_g,aux_g)← hidPC.Com(ck,g)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πf← subPC.Open(ck',aux_f,z,y_f)</td>

            <td class="px-3 py-2 border-b border-gray-700">πf← subPC.Open(ck',aux_f,z,y_f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πg← hidPC.Open(ck,aux_g,z,y_g)</td>

            <td class="px-3 py-2 border-b border-gray-700">πg← hidPC.Open(ck,aux_g,z,y_g)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">π:=((πf,1,πg,1),..., (πf,r,πg,r))</td>

            <td class="px-3 py-2 border-b border-gray-700">π:=((πf,1,πg,1),..., (πf,r,πg,r))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b'← Aθyb(1(cm_f,cm_g),z,y,π)</td>

            <td class="px-3 py-2 border-b border-gray-700">b'← Aθyb(1(cm_f,cm_g),z,y,π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b'</td>

            <td class="px-3 py-2 border-b border-gray-700">return b'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">H2:</td>

            <td class="px-3 py-2 border-b border-gray-700">H3:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ck← hidPC.Setup(1λ,k)</td>

            <td class="px-3 py-2 border-b border-gray-700">ck← hidPC.Setup(1λ,k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ck'← subPC.Setup(1λ,d-k)</td>

            <td class="px-3 py-2 border-b border-gray-700">ck'← subPC.Setup(1λ,d-k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F^n⊗w← Aθyb(1(ck,ck'))</td>

            <td class="px-3 py-2 border-b border-gray-700">F^n⊗w← Aθyb(1(ck,ck'))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z←$ F^r</td>

            <td class="px-3 py-2 border-b border-gray-700">z←$ F^r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sk← SKE.KG(1λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">sk← SKE.KG(1λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ct← SKE.Enc(sk,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">ct← SKE.Enc(sk,0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f(X):=polyFromCoeffs(ct)</td>

            <td class="px-3 py-2 border-b border-gray-700">f(X):=polyFromCoeffs(ct)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y_f← f(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">y_f← f(z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g← hidPES.Enc(0,κ,ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">g← hidPES.Enc(sk,κ,ℓ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y_g← g(z)</td>

            <td class="px-3 py-2 border-b border-gray-700">y_g← g(z)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y← y_f + Z_k(z)·y_g</td>

            <td class="px-3 py-2 border-b border-gray-700">y← y_f + Z_k(z)·y_g</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(cm_f,aux_f)← subPC.Com(ck',f)</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm_f,aux_f)← subPC.Com(ck',f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(cm_g,aux_g)← hidPC.Com(ck,g)</td>

            <td class="px-3 py-2 border-b border-gray-700">(cm_g,aux_g)← hidPC.Com(ck,g)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πf← subPC.Open(ck',aux_f,z,y_f)</td>

            <td class="px-3 py-2 border-b border-gray-700">πf← subPC.Open(ck',aux_f,z,y_f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πg← hidPC.Open(ck,aux_g,z,y_g)</td>

            <td class="px-3 py-2 border-b border-gray-700">πg← hidPC.Open(ck,aux_g,z,y_g)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">π:=((πf,1,πg,1),..., (πf,r,πg,r))</td>

            <td class="px-3 py-2 border-b border-gray-700">π:=((πf,1,πg,1),..., (πf,r,πg,r))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b'← Aθyb(1(cm_f,cm_g),z,y,π)</td>

            <td class="px-3 py-2 border-b border-gray-700">b'← Aθyb(1(cm_f,cm_g),z,y,π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return b'</td>

            <td class="px-3 py-2 border-b border-gray-700">return b'</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 7. Hybrids in the proof of evaluation hiding (changes compared to the previous hybrid are hinted in magenta). Hybrids are parametrized by  <span class="math">\\lambda, n, r</span> . Above,  $\\kappa =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>k := \\kappa + \\text{stretch}(\\lambda, \\kappa, \\ell)<span class="math">  where  </span>\\ell := \\phi(\\lambda, \\kappa, r)<span class="math">  and stretch is the stretch function of hidPES;  </span>d := k +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{ct}_{\\mathbf{w}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">E.3 Proof of Lemma 3</p>

    <p class="text-gray-300">Consider an adversary against the unique proof property for polynomial commitments (Definition 30) and let <span class="math">\\pi,\\pi^{\\prime}</span> be the two proofs that it generates. Denote by <span class="math">\\mathbf{v}</span> and <span class="math">\\mathbf{v}^{\\prime}</span> the values in <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span> respectively as by the notation in the verification algorithm in Section 4. Then there are two cases: (A) <span class="math">\\mathbf{v}\\neq\\mathbf{v}^{\\prime}</span>; (B) <span class="math">\\mathbf{v}=\\mathbf{v}^{\\prime}</span>. If case (A) occurs it is easy to see that one can break position binding. This is because the two verification executions will have the same set of indices returned by <span class="math">\\mathsf{PP.Lookup(pp},x)</span> and therefore there will be an index <span class="math">i</span> for which the adversary is successfully proving two distinct values <span class="math">v_{i}\\neq v_{i}^{\\prime}</span>. Case (B) can directly be reduced to the unique proof property of the underlying vector commitment.</p>

    <h2 id="sec-96" class="text-2xl font-bold">Appendix F Our “Hybrid” Construction and Other Instantiations of the <em>[GKO^{+}23]</em> Compiler in Literature</h2>

    <h4 id="sec-97" class="text-lg font-semibold mt-6">Instantiations in <em>[GKO^{+}23]</em></h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In <em>[GKO^{+}23]</em>, Ganesh et al. discuss simple forms of polynomial encodings (some described in Appendix D) which allows the KZG polynomial commitment <em>[x10]</em> to satisfy evaluation-hiding. One of their approaches is based on adding <em>masking coefficients</em> to the polynomial whose vector coefficients is <span class="math">\\mathbf{w}</span>. That is, <span class="math">\\mathsf{Enc}(\\mathbf{w})</span> returns <span class="math">f(X):=\\sum_{i=1}^{n}w_{i}X^{i-1}+\\sum_{i=1}^{\\ell}\\rho_{i}X^{n+i-1}</span> where the <span class="math">\\rho_{i}</span>-s are freshly sampled scalars and <span class="math">\\ell</span> is a parameter determining the level of “masking”. They also propose a similar approach based on polynomial interpolations, that is, the encoding returns a polynomial obtained as follows: let <span class="math">\\rho_{1},\\ldots,\\rho_{\\ell}</span> be some random scalars; encoding then returns the polynomial obtained through interpolation (over a fixed domain) of the vector $(\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{1},\\ldots,\\rho_{\\ell})$. Ganesh et al. show that the KZG polynomial commitment <em>[x10]</em> is evaluation-hiding with respect to these two encoding schemes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The encoding schemes above cannot provide hiding for our construction in Section 4, at least directly and with the analysis from <em>[GKO^{+}23]</em>. The reason is that those techniques, when adding <span class="math">\\ell</span> random coefficients/evaluations, can provide security up to <span class="math">\\ell-1</span> evaluations seen by the adversary (the intuition behind the security of KZG when paired with them can roughly be reduced to this observation). However, our construction, at each opening provides <em>several</em> evaluations of polynomials directly related to <span class="math">\\mathbf{w}</span>; recall, in fact that at each opening, we provide evaluations of polynomials corresponding to some type of CRT encoding of the original polynomial (each of these sub-polynomials is related to the original polynomials evaluated modulo <span class="math">p</span>, where <span class="math">p</span> is a relatively small prime). As a consequence, at each evaluation we are intuitively leaking significantly more than what we leak with an approach like the one based on KZG.</p>

    <p class="text-gray-300">It is at least conceivable that a more sophisticated analysis could show that this type of encodings could yield evaluation hiding if one used an appropriate number of extra coefficient/evaluations. However, this may reveal to be quite complicated (at the very least, it eluded some initial attempts on our side). We leave this as an interesting open problem.</p>

    <p class="text-gray-300">The recent work in <em>[BCC^{+}24]</em> also provides a PC and PES with similar properties. Their constructions cannot unfortunately be used in our setting: their PC verifier runs in linear time and, while their PES <em>might</em> be evaluation hiding when paired with our <span class="math">\\mathsf{PC_{VC}}</span>, it would require an extremely complex analysis, similar to the one they need to do to show the compatibility of their PES with their Bulletproofs-based PC (in contrast, our hybrid approach is very simple to prove secure). For this reason we do not pursue this path.</p>

    <p class="text-gray-300">Viceversa, our construction, <em>cannot</em> provide a simpler solution for their setting: since they require transparent constructions they cannot rely on KZG-like constructions as we do and thus need to bootstrap the <em>[GKO^{+}23]</em> framework with new tools themselves.</p>`;
---

<BaseLayout title="On the Power of Polynomial Preprocessing: Proving Computatio... (2025/238)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/238
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
