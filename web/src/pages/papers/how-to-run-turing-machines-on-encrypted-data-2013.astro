---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/229';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'How to Run Turing Machines on Encrypted Data';
const AUTHORS_HTML = 'Shafi Goldwasser, Yael Kalai, Raluca Ada Popa, Vinod Vaikuntanathan, Nickolai Zeldovich';

const CONTENT = `    <p class="text-gray-300">Shafi Goldwasser⋆ Yael Kalai† Raluca Ada Popa⋆ Vinod Vaikuntanathan◃▹ Nickolai Zeldovich⋆</p>

    <p class="text-gray-300">⋆ MIT CSAIL † Microsoft Research ◃▹ University of Toronto</p>

    <p class="text-gray-300">Abstract. Algorithms for computing on encrypted data promise to be a fundamental building block of cryptography. The way one models such algorithms has a crucial effect on the efficiency and usefulness of the resulting cryptographic schemes. As of today, almost all known schemes for fully homomorphic encryption, functional encryption, and garbling schemes work by modeling algorithms as circuits rather than as Turing machines.</p>

    <p class="text-gray-300">As a consequence of this modeling, evaluating an algorithm over encrypted data is as slow as the worst-case running time of that algorithm, a dire fact for many tasks. In addition, in settings where an evaluator needs a description of the algorithm itself in some "encoded" form, the cost of computing and communicating such encoding is as large as the worst-case running time of this algorithm.</p>

    <p class="text-gray-300">In this work, we construct cryptographic schemes for computing Turing machines on encrypted data that avoid the worst-case problem. Specifically, we show:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An attribute-based encryption scheme for any polynomial-time Turing machine and Random Access Machine (RAM).</li>

      <li>A (single-key and succinct) functional encryption scheme for any polynomialtime Turing machine.</li>

      <li>A reusable garbling scheme for any polynomial-time Turing machine.</li>

      <li>These three schemes have the property that the size of a key or of a garbling for a Turing machine is very short: it depends only on the description of the Turing machine and not on its running time.</li>

      <li>Previously, the only existing constructions of such schemes were for depth-d circuits, where all the parameters grow with d. Our constructions remove this depth d restriction, have short keys, and moreover, avoid the worst-case running time.</li>

      <li>A variant of fully homomorphic encryption scheme for Turing machines, where one can evaluate a Turing machine M on an encrypted input x in time that is dependent on the running time of M <em>on input</em> x as opposed to the worst-case runtime of M. Previously, such a result was known only for a restricted class of Turing machines and it required an expensive preprocessing phase (with worst-case runtime); our constructions remove both restrictions.</li>

    </ul>

    <p class="text-gray-300">Our results are obtained via a reduction from SNARKs (Bitanski et al) and an "extractable" variant of witness encryption, a scheme introduced by Garg <em>et al.</em>. We prove that the new assumption is secure in the generic group model. We also point out the connection between (the variant of) witness encryption and the obfuscation of point filter functions as defined by Goldwasser and Kalai in 2005.</p>

    <p class="text-gray-300">Keywords: Computing on encrypted data; Functional encryption; Fully homomorphic encryption; Turing machines; Input-specific running time.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Almost all known cryptographic constructions for computing on encrypted data model algorithms as circuits instead of Turing machines.<sup>1</sup> The most notable such constructions are fully homomorphic encryption, attribute-based encryption, functional encryption, and garbling schemes. There are at least two unfortunate consequences of modeling algorithms as circuits.</p>

    <p class="text-gray-300">The first consequence of using circuits is that evaluating an algorithm A on encrypted data is at least as slow as the <em>worst-case</em> running time of algorithm A on all inputs of a certain size. Ideally, the runtime of A on input x should be the time A takes to run on x. The reason for this slowdown is that all the known transformations from Turing machines to circuits essentially work by unrolling loops to their worst-case runtime, and by considering all branches of a computation. Even if the cryptographic overhead of these schemes were zero, such worst-case runtime can still make the computation prohibitively slow: for example, the simplex algorithm for linear programming runs in polynomial time on most instances one encounters in practice, but in exponential time on rare inputs.</p>

    <p class="text-gray-300">Some schemes for computing on encrypted data (such as functional encryption and garbling schemes) require the evaluator to obtain a token for an algorithm A in order to run A on the encrypted data. The second consequence of modeling algorithms as circuits is that the size of the token is as large as the running time of the algorithm, instead of depending only on the description of the algorithm, which can be much shorter.</p>

    <p class="text-gray-300">The earliest example of using circuits for computing on encrypted data is Yao's secure function evaluation protocol [\\[Yao86\\]](#page-17-0) which takes as input any polynomial time computable function f – specified by a circuit – and outputs a "garbled circuit" with the same input-output functionality. Such worst-case runtime also affects known two-party and multi-party protocols for general secure function evaluation <a href="#page-17-0">\\[Yao86,</a><a href="#page-17-1">GMW87</a><a href="#page-16-0">,BGW88,</a>[CCD88\\]](#page-16-1).</p>

    <p class="text-gray-300">More recent constructions for computing on encrypted data also use circuits to model computation and thus suffer from the worst-case slowdown: fully homomorphic encryption schemes (FHE) <a href="#page-17-2">\\[Gen09</a><a href="#page-16-2">,BV11a,</a><a href="#page-16-3">BV11b</a><a href="#page-16-4">,BGV12</a>[,Bra12\\]](#page-16-5), attribute-based encryption (ABE) schemes <a href="#page-17-3">\\[GVW13,</a><a href="#page-17-4">GGH</a><sup>+</sup>13b[,GGH13a\\]](#page-17-5), and functional encryption (FE) schemes for general functions <a href="#page-17-6">\\[SS10</a><a href="#page-17-7">,GVW12,</a><a href="#page-17-8">GKP</a><sup>+</sup>13].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this work, we construct cryptographic schemes for Turing machines, thus removing the two major limitations of circuits discussed above. We construct attribute-based encryption, single-key (succinct) functional encryption, reusable garbling schemes, and a version of FHE for polynomial-time Turing machines. For each of these schemes, we show that the time to evaluate a Turing machine M on an input x is <em>input specific</em>: it depends on the runtime of M on x and not on the worst-case runtime of M on all inputs of length n where n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. Moreover, we show that the token an evaluator needs to run a Turing machine M on encrypted data is short: its size depends on the size of <em>the description of the Turing machine</em> M and not on M's runtime. Our schemes are for</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>1</sup> An exception is the garbling scheme of [\\[LO12\\]](#page-17-9) for RAMs, but this scheme also suffers from worst-case running time problem (see Sec. <a href="#page-2-0">1.1\\)</a>.</p>

    <p class="text-gray-300">both uniform and non-uniform Turing machines (so in particular, they can compute any circuits).</p>

    <p class="text-gray-300">Since the evaluator can compute a Turing machine M in input-specific runtime, it means that the evaluator necessarily learns the runtime of M on specific inputs. In some of the schemes we consider, such as ABE, such runtime provides no new information to the evaluator. In other schemes, such as FE, the evaluator could learn additional information from the runtime. This is why we also provide a second functional encryption scheme that does not leak the runtime and runs in worst-case time, while still benefiting from the Turing machine model because it has short tokens. Depending on how one weighs leaking runtime versus worst-case performance, one can choose one scheme or the other.</p>

    <p class="text-gray-300">Our schemes are based on extractable witness encryption, a variant of the witness encryption notion of Garg <em>et al.</em> [\\[GGSW13\\]](#page-17-10). We show how to obtain such an extractable witness encryption scheme using the construction of Garg <em>et al.</em> [\\[GGSW13\\]](#page-17-10), by strengthening their assumption with a knowledge property. We prove the new assumption secure in the generic group model. Interestingly, we show that extractable witness encryption is closely related to (weakly) obfuscatable point-filter functions [\\[GK05\\]](#page-17-11).</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our results</h3>

    <p class="text-gray-300">We now explain our results in detail.</p>

    <p class="text-gray-300">Attribute-based encryption (ABE) for Turing machines and RAMs. Attribute-based encryption schemes, originally defined by Sahai and Waters [\\[SW05\\]](#page-17-12), allow a user holding the master secret key msk to generate a function key sk<sup>f</sup> for any predicate f of his choice, where sk<sup>f</sup> does not hide f. Using the master public key mpk, anyone can encrypt a message m with respect to an "attribute" x: such a ciphertext is denoted by Enc(x; m). The ciphertext Enc(x; m) does not hide x, and hides only m. Given a function key sk<sup>f</sup> and a ciphertext Enc(x; m), one can compute m if f(x) = 1. On the other hand, if f(x) = 0, ABE leaks no information about m and provides semantic security.</p>

    <p class="text-gray-300">Attribute-based encryption is a powerful primitive and has thus received significant attention <a href="#page-17-13">\\[GPSW06</a><a href="#page-17-14">,LOS</a><sup>+</sup>10<a href="#page-17-15">,LW12</a>[,GVW13\\]](#page-17-3). The state-of-the-art is the scheme of Gorbunov <em>et al.</em> [\\[GVW13\\]](#page-17-3): based on the LWE assumption, they construct an ABE for the class of all circuits of depth at most d, where the efficiency of the scheme (such as the size of the ciphertexts) decreases polynomially with d. In concurrent work, Garg <em>et al.</em> constructed ABE schemes with similar properties <a href="#page-17-4">\\[GGH</a><sup>+</sup>13b], and an ABE scheme with large ciphertexts [\\[GGSW13\\]](#page-17-10), both from candidate multi-linear maps.</p>

    <p class="text-gray-300">In this work, we construct an attribute-based encryption scheme for all circuits, with no restriction on the depth. More importantly, we model functions as Turing machines (with possibly non-uniform advice), as opposed to circuits as in previous work. Computing a function key skM, corresponding to a Turing machine M, takes roughly linear time in the <em>size of the description</em> of M, <em>independent of the runtime</em> of M. Moreover, given sk<sup>M</sup> and Enc(x; m) where f(x) = 1, one can compute m in time that depends only on the time it takes to compute M <em>on input</em> x as opposed to the worst-case running time of M. We prove the security of our scheme with respect to a non-adaptive</p>

    <p class="text-gray-300">simulation-based definition (we refer the reader to Sec. <a href="#page-10-0">3</a> for details). We then show that a modification of our construction provides ABE for RAMs.</p>

    <p class="text-gray-300">Theorem 1 (Informal). <em>There exists an attribute-based encryption scheme (as defined in Defs. <a href="#page-9-0">3,</a> <a href="#page-10-1">4\\)</a> for (uniform or non-uniform) polynomial-time Turing machines and RAMs from the assumptions in Sec. <a href="#page-5-0">1.2.</a></em></p>

    <p class="text-gray-300">Interestingly, we show how to extend our ABE scheme beyond Turing machines and RAMs: for example, an evaluator can choose by himself which Turing machines to run on the ciphertexts, as long as they satisfy some property expressed in a function key.</p>

    <p class="text-gray-300">Functional encryption (FE) for Turing machines. Functional encryption, formalized by Boneh, Sahai and Waters [\\[BSW11\\]](#page-16-6), is a generalization of attribute-based encryption. In functional encryption, a user holding the master secret key msk can generate a function key sk<sup>f</sup> corresponding to a function f; then, anyone having a ciphertext Enc(x) and a function key sk<sup>f</sup> can compute f(x), but learns nothing else about the input x.</p>

    <p class="text-gray-300">So far, the only many-keys FE schemes known (schemes in which the secret key owner can securely release an unbounded number of function keys) are for the innerproduct predicates <a href="#page-17-16">\\[KSW08,</a>[SSW09\\]](#page-17-17). For general functions, Agrawal <em>et al.</em> [\\[AGVW12\\]](#page-16-7) showed that there does not exist a many-keys FE scheme if one wants to achieve a natural simulation-based security definition<sup>2</sup> , so the natural question was to construct a singlekey functional encryption scheme for general functions. Sahai and Seyalioglu [\\[SS10\\]](#page-17-6), Gorbunov <em>et al.</em> [\\[GVW12\\]](#page-17-7), and Goldwasser <em>et al.</em> <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] constructed such schemes for circuits. The work of Goldwasser <em>et al.</em> <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] is the first to provide succinct ciphertexts: the ciphertext size is much smaller than the circuit size; they constructed a <em>succinct</em> single-key FE scheme for any depth d circuit, where the parameters of the scheme grow with d (but are independent of the circuit size).</p>

    <p class="text-gray-300">In this work, we not only remove this depth-d restriction, but we model functions as (possibly non-uniform) Turing machines, as opposed to circuits as in prior work. Our schemes have short function keys: computing the function key of a Turing machine M depends only on the size of M and does not depend on the runtime of M. We note that in all previous schemes for general functions the size of a function key for a function f grows (at least linearly) with the worst-case runtime of f. We note however, that as opposed to our ABE scheme, in a functional encryption scheme, given Enc(x) and skM, the time it takes to compute M(x) must be proportional to the worst-case runtime of M, since the runtime of M on input x may leak sensitive information about x. However, if one is willing to slightly relax security and allow leaking the runtime of M on the secret input x, then we also show how to construct a decryption algorithm that has input-specific runtime (i.e., runs in time polynomial in the runtime of M on input x) – we denote this by <em>input-specific runtime functional encryption</em>.</p>

    <p class="text-gray-300">Theorem 2 (Informal). <em>There exists a single-key (succinct) functional encryption scheme and input-specific runtime functional encryption scheme for (uniform or nonuniform) polynomial-time Turing machines from the assumptions in Sec. <a href="#page-5-0">1.2.</a></em></p>

    <p class="text-gray-300"><sup>2</sup> Their lower bound does not apply to weaker security definitions.</p>

    <p class="text-gray-300">Variant of FHE for Turing machines. We construct a variant of FHE where one can evaluate a Turing machine M on a ciphertext Enc(x) in time that depends on the runtime of P <em>on the specific input</em> x. We naturally call this scheme <em>input-specific FHE</em>. At first glance, this may seem impossible, since revealing the runtime of P on input x may reveal secret information about x. However, for many Turing machines M, revealing only the runtime of M is not harmful, and it can provide significant efficiency gains.</p>

    <p class="text-gray-300">Our construction is an improvement of Goldwasser <em>e</em>t al. <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] who showed how to construct input-specific runtime FHE from single-key functional encryption. As in Goldwasser <em>et al.</em> <a href="#page-17-8">\\[GKP</a><sup>+</sup>13], we also encrypt a Turing machine M and x together into a token tkM,x. Producing such a token depends only on the size of x and M, and not on the running time of M. The evaluator can use tkM,x and public information to compute M(x) in input-specific time. The reason we provide a token for M at all is for security: the FHE evaluator must no longer be able to evaluate TMs of its choice on the encrypted inputs because the running time of those TMs can leak the input entirely. We combine M and x in tkM,x for a technical reason stemming from the fact that the FE scheme we use in the construction is single-key – we elaborate in our full paper.</p>

    <p class="text-gray-300">Comparing to <a href="#page-17-8">\\[GKP</a><sup>+</sup>13], we make the following improvements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Remove costly preprocessing.</em> <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] had an expensive preprocessing phase taking as long as the worst-case runtime. With our scheme, the preprocessing is cheap: polynomial in the size of the TMs and independent of the worst-case runtime (so in fact it can be performed in the online phase).</li>

      <li><em>Works for any polynomial-time Turing machine.</em> Because the ciphertext size in <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] depended on the depth of the worst-case circuit representation of the class of Turing machines, <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] only allowed a restricted class of Turing machines: the class of TMs that can be expressed by shallow-depth circuits (e.g., log-space Turing machines). Our result does not have the depth restriction and thus applies to any class of Turing machines with runtime upper-bounded by a polynomial.</li>

    </ul>

    <p class="text-gray-300">Theorem 3 (Informal). <em>There exists an input-specific-runtime fully homomorphic encryption scheme for (uniform or non-uniform) polynomial-time Turing machines based on the assumptions in Sec. <a href="#page-5-0">1.2.</a></em></p>

    <p class="text-gray-300">Reusable garbling scheme for Turing machines. Garbling schemes, introduced in the seminal work of Yao [\\[Yao86\\]](#page-17-0), have found many applications in cryptography. In such schemes, a user can "garble" a function f and then encode an input x in a token tkx. Given a garbling of f and a token tkx, one can compute f(x), but learns nothing else about f or x. Some works also considered an authenticity property <a href="#page-16-8">\\[BHR12,</a>[GVW13\\]](#page-17-3), on which we do not dwell. Traditional garbling schemes are one-time: they are secure only if an adversary gets a token for at most one input. A reusable garbling scheme is secure when the adversary gets an unbounded number of tokens.</p>

    <p class="text-gray-300">In known garbling schemes (even non-reusable ones), the size of the garbling is as large as the worst-case runtime of f. Often, the reason is that programs are modeled as circuits, and the size of the garbling is at least the size of the corresponding circuit. In this work, we construct a (reusable) garbling scheme for (uniform or non-uniform) Turing machines, where the size of the garbling depends only on the size of the Turing machine, and is <em>independent of its runtime</em>. The work of [\\[LO12\\]](#page-17-9) is an exception from the</p>

    <p class="text-gray-300">circuit model: they model computation as RAM, but their scheme still has large garbling size, at least as large as the worst-case running time.</p>

    <p class="text-gray-300">As in our FHE and FE schemes, if one allows leaking the runtime of M on input x, we can additionally avoid worst-case evaluation time and obtain an input-specific reusable garbling scheme: given a garbling for a Turing machine M and a token tkx, the time to compute M(x) is polynomial in the runtime of M on the specific input x.</p>

    <p class="text-gray-300">Goldwasser <em>e</em>t al. <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] provide a reusable garbling scheme only for depth bounded circuits; our schemes remove the depth dependency, provide short garbling size, and can additionally avoid worst-case running time.</p>

    <p class="text-gray-300">Theorem 4 (Informal). <em>There exists a reusable garbling scheme and an input-specific reusable garbling scheme for (uniform or non-uniform) polynomial-time Turing machines from the assumptions in Sec. <a href="#page-5-0">1.2.</a></em></p>

    <p class="text-gray-300">In summary, our work models computation on encrypted data as Turing machines and thus avoids the worst-case "curse" for a set of well-known cryptographic notions.</p>

    <p class="text-gray-300"><em>Remark 1.</em> Interestingly, we can easily overcome the worst-case curse for interactive tasks such as two-party and multi-party protocols as follows. To securely evaluate a Turing machine M, we evaluate the Turing machines M1, . . . , Mω(log <sup>n</sup>) sequentially, where M<sup>i</sup> runs the Turing machine M for 2 i steps and outputs M's answer if M halted in 2 i steps, otherwise ⊥. To evaluate M<sup>i</sup> , we simply use existing multi-party protocols. Note that the circuit size for M<sup>i</sup> is poly(2<sup>i</sup> ), and since we halt the computation as soon as we get a non-⊥ answer, the protocol runs in input-specific time. The reason we can overcome the worst-case curse in this manner is that interaction is allowed. In this work, we focus on non-interactive tasks, which are more challenging.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1.2 Our Assumptions</h2>

    <p class="text-gray-300">Our schemes rely on two assumptions: extractable witness encryption and the existence of SNARKs.</p>

    <p class="text-gray-300">Extractable Witness Encryption. The recent work of Garg <em>et al.</em> [\\[GGSW13\\]](#page-17-10) constructs a new primitive called witness encryption (WE). Such a scheme is associated with some NP complete language L. Given an instance x and a message m, any user can encrypt m with respect to x; this is denoted by Encx(m). Given Encx(m) and a valid witness w of x, any user can decrypt x efficiently. On the other hand, if x is not in the language, the scheme provides semantic security.</p>

    <p class="text-gray-300">In our work, we additionally assume that the [\\[GGSW13\\]](#page-17-10) scheme is extractable: if an adversary can break semantic security for an instance x, an extractor can extract the witness for x. Such an extractable scheme can be constructed from an extractable version of the [\\[GGSW13\\]](#page-17-10) assumption (called extractable DGE No-Exact-Cover assumption) so we strengthen their assumption. While we state our assumption in a decisional form for simplicity, the search version of the assumption suffices for our schemes because we can use hard-core predicates to mask the one bit we care to hide (m).</p>

    <p class="text-gray-300">We validate our assumption in the generic group model: we prove that no polynomialtime adversary can break the assumption in the generic group model where adversaries</p>

    <p class="text-gray-300">can only use multilinear map operations as a black-box. We refer the reader to our full paper for more details on the assumption, and emphasize that we view our result as a reduction from any extractable witness encryption scheme, as opposed to a result that is tied to the specific computational assumption.</p>

    <p class="text-gray-300">We show that, interestingly, extractable witness encryption is highly related to another task that was already well-known in the cryptographic literature: (weakly) obfuscating point-filter functions, defined by Goldwasser and Kalai [\\[GK05\\]](#page-17-11). Informally, point-filter functions for a language L ∈ NP with witness relation R<sup>L</sup> are a class of functions {δx,b}, indexed by a string x ∈ {0, 1} <sup>n</sup> and a bit b ∈ {0, 1} that behave as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{x,b}(w) = \\begin{cases} (x,b), &amp; \\text{if } (x,w) \\in R_L, \\\\ (x,\\perp), &amp; \\text{otherwise.} \\end{cases}</span></div>

    <p class="text-gray-300">It can be shown that extractable witness encryption is indeed equivalent to (weakly) obfuscating point filter function. Thus, the former implies the consequences of the later regarding the impossibility of obfuscation for a wide range of natural tasks based on [\\[GK05\\]](#page-17-11). See our full paper for more details.</p>

    <p class="text-gray-300">The existence of SNARKs (Succinct Non-interactive Arguments of Knowledge). Bitansky <em>et al.</em> [\\[BCCT13\\]](#page-16-9) construct SNARKs in a generic way (via a reduction from weaker SNARKs). Their work is based on "knowledge of exponent assumptions", and the existence of collision resistant hash functions.</p>

    <p class="text-gray-300">If we remove SNARKs from our constructions, we still obtain novel schemes over prior work because the sizes of the function keys and of the garbling remain short, linear in the size of the Turing machine. Without SNARKs, though, the loss is that the ciphertext size grows with the running time of the Turing machines.</p>

    <p class="text-gray-300">Our FE, FHE, and reusable garbling schemes additionally rely on the existence of a fully homomorphic encryption scheme, which can be obtained from the LWE assumption with circular security [\\[BGV12\\]](#page-16-4).</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.3 Techniques overview</h4>

    <p class="text-gray-300">ABE for Turing machines. The main technical challenge in this work is constructing an ABE scheme for Turing machines.</p>

    <p class="text-gray-300">Our construction starts with witness encryption and a signature scheme. The function key for a Turing machine M is simply a signature of M. The master secret and public keys generated during setup are the secret and verification keys (SigSK, VK) for the signature scheme. To encrypt a bit b with respect to a (public) attribute x, we compute a witness encryption Encx<sup>∗</sup> (b), where x <sup>∗</sup> = (x, VK) and where a valid witness for x ∗ is a tuple (M, σ, π), where M is a Turing machine, σ is a signature of M using SigSK, and π the tableau of the computation, which can be interpreted as a "proof" that M(x) = 1.</p>

    <p class="text-gray-300">Loosely speaking, the security proof proceeds as follows. Suppose there exists a successful adversary A for our ABE scheme. Then, given Encx<sup>∗</sup> (b), the ABE encryption of a random bit b, and several secret keys sk<sup>M</sup><sup>i</sup> = σ<sup>i</sup> such that Mi(x) = 0, A succeeds in guessing b with non-negligible advantage. The security of the extractable witness encryption implies that there exists a poly-time extractor that extracts a valid witness from A with non-negligible probability. Recall that a valid witness is a triplet of the form (M<sup>∗</sup> , σ<sup>∗</sup> , π<sup>∗</sup> ) where σ ∗ is a valid signature of the Turing machine M<sup>∗</sup> and π ∗ is a proof that M<sup>∗</sup> (x) = 1. Note that since Mi(x) = 0 for every i, it must be the case that M<sup>∗</sup> ̸= M, which contradicts the unforgeability of the signature scheme.</p>

    <p class="text-gray-300">Unfortunately, this idea does not quite give us the results we want. The reason is that the time to check a witness for an instance x <sup>∗</sup> = (x, VK) is very long because it involves checking the tableau π of M on input x. In this case, the witness encryption of Garg <em>et al.</em> [\\[GGSW13\\]](#page-17-10) is not "succinct": the size of the ciphertext Encx<sup>∗</sup> (b) grows with the time to check the witness. Thus, the approach above gives us a non-succinct ABE scheme, where the size of a ciphertext depends on the worst-case runtime of any (allowed) Turing machine.</p>

    <p class="text-gray-300">To obtain succinctness, we use a SNARG scheme [\\[BCCT13\\]](#page-16-9). A SNARG has a common reference string crs, which is assumed to be securely generated. Any user can prove any NP statement by computing a proof π. The length of the crs, the length of the proofs, and the time to verify a proof are all <em>short</em>: depending only on the security parameter, and not on the time to verify the NP witness.</p>

    <p class="text-gray-300">Encx<sup>∗</sup> (b) now proceeds as follows. It generates a crs corresponding the underlying SNARG scheme. To encrypt a bit b w.r.t. a public attribute x, it simply computes Encx<sup>∗</sup> (b), where x ∗ is now (x, crs, VK). A valid witness for x ∗ is a tuple of the form (M, σ, π) where σ is a valid signature of the Turing machine M, and π is a <em>succinct</em> SNARG proof that M(x) = 1. The fact that π can be verified in a short time makes the WE ciphertext succinct, as desired.</p>

    <p class="text-gray-300">This gives us an ABE for Turing machines. Because SNARKs are for NP, our resulting ABE scheme is for any class of Turing machines for which there exists a polynomial that upper bounds the runtime of all machines in the class.</p>

    <p class="text-gray-300">There scheme still has a slight drawback: it is succinct only for uniform Turing machines. If the Turing machines have non-uniform advice as large as the runtime, the resulting ABE ciphertexts are non-succinct. We would like our ABE scheme to be a generalization of previous work on circuits, and in particular to be succinct for any non-uniform Turing machine. To this end, we replace the SNARG scheme with a SNARK scheme (succinct non-interactive argument of knowledge) scheme. SNARKs have the additional property that if an adversary A succeeds in proving that x ∈ L, an extractor can extract a corresponding witness w from A.</p>

    <p class="text-gray-300">The final ABE scheme is as before, except that now a valid witness for x <sup>∗</sup> = (x, crs, VK) is a pair (π, t) (without the Turing machine and the signature), where π is a proof-of-knowledge of a Turing machine M and a signature σ such that σ is a valid signature of M and M(x) = 1. Now the witness size and the verification time is efficient (independent of the size of the Turing machine or its runtime). We refer the reader to Sec. <a href="#page-10-0">3</a> for more details on our ABE scheme and the security proof.</p>

    <p class="text-gray-300">Functional encryption for Turing machines. We use the reduction of Goldwasser <em>et al.</em> <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] to construct a (single-key and succinct) FE scheme from FHE and ABE. Their reduction is for circuits so we need to adapt it to Turing machines. The main technical issue is that we need to perform the FHE evaluation of a Turing machine M. To achieve this goal, we construct a new Turing machine MFHE that evaluates homomorphically the transition function of M for a t number of times. The problem is that MFHE needs to know what inputs to read from M's tape to feed into the FHE evaluation, but the movement of the head in M is an output of the transition function, so it is encrypted with FHE and unavailable to  <span class="math">M_{\\mathsf{FHE}}</span> . To solve this issue, we transform M into an <em>oblivious</em> Turing machine using Pippenger-Fischer [PF79]: now the movement of the head follows a fixed and known pattern independent of the input to M.</p>

    <p class="text-gray-300">If one allows the runtime of M on x to leak, we can provide a second FE scheme FE\\<em> whose decryption algorithm runs in input-specific time. We construct FE\\</em> as a reduction from our FE scheme above using the idea of [GKP+13]: instead of generating a function key  <span class="math">\\mathsf{sk}_M</span>  for a Turing machine M, we generate many function keys  <span class="math">\\mathsf{sk}_{M_1},\\ldots,\\mathsf{sk}_{M_{\\log B_n}}</span> , where  <span class="math">M_i</span>  is the Turing machine that runs M for  <span class="math">2^i</span>  time steps, and either outputs the output of M or  <span class="math">\\bot</span>  if M did not halt in  <span class="math">2^i</span>  steps; the parameter  <span class="math">B_n</span>  is a global bound on the runtime of the Turing machines we consider. To generate  <span class="math">\\log B_n</span>  function keys, we use  <span class="math">\\log B_n</span>  instances of our single-key functional encryption scheme above, by generating fresh keys for every instance of it. Moreover, since the underlying functional encryption scheme is for Turing machines, generating  <span class="math">\\mathsf{sk}_{M_i}</span>  can be done very efficiently, in time polynomial in the  <span class="math">\\mathit{size}</span>  of  <span class="math">M_i</span> , independent on the runtime of  <span class="math">M_i</span> .</p>

    <p class="text-gray-300">On input a ciphertext  <span class="math">\\operatorname{Enc}(x)</span>  and a function  <span class="math">\\operatorname{key}\\left(\\operatorname{sk}_{M_1},\\ldots,\\operatorname{sk}_{M_{\\log B}}\\right)</span>  for the Turing machine M, the decryption algorithm first tries to decrypt with  <span class="math">\\operatorname{sk}_{M_1}</span> , then tries with  <span class="math">\\operatorname{sk}_{M_2}</span> , and so on. The first time that it succeeds it stops. Note that the runtime of this decryption algorithm depends on the runtime of M on the <em>specific input</em> x, denoted by  <span class="math">t_x</span> . This is the case since it runs the original decryption algorithm (which runs in the worst-case) only with the secret  <span class="math">\\operatorname{keys} \\operatorname{sk}_{M_1},\\ldots,\\operatorname{sk}_{M_{\\log t_x}}</span> , and all the Turing machines  <span class="math">M_1,\\ldots,M_{\\log t_x}</span>  run in time at most  <span class="math">t_x</span> .</p>

    <p class="text-gray-300"><strong>Reusable garbling and a variant of FHE for Turing machines.</strong> In our full version, we show how to construct these schemes from our FE scheme using a similar reduction to [GKP+13].</p>

    <p class="text-gray-300">Other related work. We discuss other related work in the full version of our paper.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.4 Paper Roadmap</h4>

    <p class="text-gray-300">The rest of this paper is organized as follows. We provide definitions for extractable witness encryption and ABE in Sec. 2, and refer the reader to our full paper for other relevant preliminaries. Next, Sec. 3 presents our ABE scheme for Turing machines, which we prove formally in our full paper. Finally, Sections 4 and 4.2 show how to construct functional encryption for Turing machines. Due to space constraints, in our full paper, we present the construction of extractable witness encryption and prove the new assumption in the generic group model, we show that extractable witness encryption implies (weakly) obfuscatable point filter functions and deduce implications to obfuscation, and we present the construction of FHE for Turing machines.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">2 Preliminaries</h4>

    <p class="text-gray-300">In this section, we define extractable witness encryption and ABE for Turing machines, and refer the reader to our full paper for definitions of FE for Turing machines, SNARKs, and other relevant preliminaries.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">2.1 Notation</h4>

    <p class="text-gray-300">We let κ denote the security parameter throughout this paper. For a distribution D, we say x ← D when x is sampled from the distribution D. If S is a finite set, by x ← S, we mean x is sampled from the uniform distribution over the set S.</p>

    <p class="text-gray-300">We say that a function f is negligible in an input parameter κ, if for all d > 0, there exists K such that for all κ > K, f(κ) < k−<sup>d</sup> . For brevity, we write: for all sufficiently large κ, f(κ) = negl(κ).</p>

    <h2 id="sec-9" class="text-2xl font-bold">2.2 Witness encryption (WE)</h2>

    <p class="text-gray-300">The syntax of WE is as defined by Garg et al. [\\[GGSW13\\]](#page-17-10), but the security definition has an additional extractability property.</p>

    <p class="text-gray-300">Definition 1 (Witness Encryption). <em>A witness encryption for a language</em> L ∈ <em>NP with corresponding witness relation</em> R<sup>L</sup> <em>consists of two polynomial-time algorithms</em> (WE.Enc, WE.Dec) <em>such that</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Encryption</em> WE.Enc(1<sup>κ</sup> , x, b)<em>: takes as input a security parameter</em> κ<em>,</em> x ∈ {0, 1} ∗ <em>and a bit</em> b <em>and outputs a ciphertext</em> ct<em>.</em></li>

      <li><em>Decryption</em> WE.Dec(w, ct)<em>: takes as input</em> w ∈ {0, 1} <sup>∗</sup> <em>and a ciphertext</em> ct <em>and outputs a bit</em> b <em>or the symbol</em> ⊥<em>.</em></li>

    </ul>

    <p class="text-gray-300"><em>Correctness: For all</em> (x, w) ∈ RL<em>, for all bits</em> b<em>, for every sufficiently large security parameter</em> κ<em>:</em></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathsf{ct} \\leftarrow \\mathsf{WE}.\\mathsf{Enc}(1^{\\kappa}, x, b) : \\mathsf{WE}.\\mathsf{Dec}(w, \\mathsf{ct}) = b] = 1 - \\operatorname{negl}(\\kappa).</span></div>

    <p class="text-gray-300">Definition 2 (Extractable security). <em>A witness encryption scheme for a language</em> L ∈ <em>NP is secure if for all p.p.t. adversaries</em> A<em>, and all poly</em> q<em>, there exists a p.p.t. extractor</em> E <em>and a poly</em> p<em>, such that for all auxiliary inputs</em> z <em>and for all</em> x ∈ {0, 1} ∗ <em>, the following holds:</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\Pr[b \\leftarrow \\{0,1\\}; \\mathsf{ct} \\leftarrow \\mathsf{WE}.\\mathsf{Enc}(1^\\kappa, x, b) : A(x, \\mathsf{ct}, z) = b] &\\geq 1/2 + 1/q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\Rightarrow & \\Pr[E(x, z) = w : \\ (x, w) \\in R_L] \\geq 1/p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">). \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-10" class="text-2xl font-bold">2.3 Attribute-based encryption (ABE) for Turing machines</h2>

    <p class="text-gray-300">We define the syntax and security of ABE for Turing machines.</p>

    <p class="text-gray-300"><span id="page-9-0"></span>Definition 3 (ABE for Turing machines). <em>An attribute-based encryption scheme</em> ABE <em>for a class of Turing machines</em> T <em>is a tuple of four algorithms (</em>ABE.Setup<em>,</em> ABE.KeyGen<em>,</em> ABE.Enc<em>,</em> ABE.Dec<em>), the first three of which are p.p.t., such that:</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ABE.Setup(1<sup>κ</sup> ) <em>takes as input the security parameter</em> 1 <sup>κ</sup> <em>and outputs a master public key</em> mpk <em>and a master secret key</em> msk<em>.</em></li>

      <li>ABE.KeyGen(msk, M) <em>takes as input the master secret key</em> msk<em>, a Turing machine</em> M ∈ T <em>, and outputs a function key</em> skM<em>.</em></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ABE.Enc(mpk, x, b) <em>takes as input the master public key</em> mpk<em>, an attribute</em> x ∈ {0, 1} ∗ <em>, and a bit</em> b <em>and outputs a ciphertext</em> ct<em>.</em></li>

      <li>ABE.Dec(skM, ct) <em>takes as input a key</em> sk<sup>M</sup> <em>and a ciphertext</em> c <em>and outputs a bit.</em></li>

    </ul>

    <p class="text-gray-300"><em>Correctness. For all Turing machines</em> M ∈ T <em>, for all attributes</em> x ∈ {0, 1} ∗ <em>, for all bits</em> b<em>, for</em> κ <em>sufficiently large,</em></p>

    <pre><code class="language-text">Pr[(mpk, msk) ← ABE.Setup(1κ
                               ); fskf ← ABE.KeyGen(fmsk, f);
   c ← ABE.Enc(fmpk, x) : ABE.Dec(fskf , 1
                                           t
                                            , c) = f(x)]
   = 1 − negl(κ).</code></pre>

    <p class="text-gray-300"><em>Efficiency. There exists a polynomial</em> p <em>such that the running time of</em> ABE.Dec(skM, ct) <em>is at most</em> p(κ,runtime(M, x))<em>.</em></p>

    <p class="text-gray-300">The efficiency property states that the work of the decryption depends on the run time of a Turing machine on the attribute. Since ABE.Setup, ABE.KeyGen and ABE.Enc are p.p.t.-s, their running time depends only on the security parameter and not on the running time of the Turing machines (except for a logarithmic dependency on it).</p>

    <p class="text-gray-300">Our security definition is full (the adversary can choose the challenge attribute based on the public key) and non-adaptive (the adversary chooses the Turing machines before getting the challenge ciphertext).</p>

    <p class="text-gray-300"><span id="page-10-1"></span>Definition 4 (Attribute-based encryption security). <em>Let</em> ABE <em>be an attribute-based encryption scheme for a class of Turing machines</em> T <em>and let</em> A = (A1, A2) <em>be an adversary. Consider the following experiment.</em></p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">ExpABE(1<sup>κ</sup> ):</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>1:</em> (mpk, msk) ← ABE.Setup(1<sup>κ</sup> )</li>

      <li><em>2:</em> (x,state) ← A ABE.KeyGen(msk,·) 1 (mpk)</li>

      <li><em>3:</em> Choose a bit b at random and let ct ← ABE.Enc(mpk, x, b).</li>

      <li><em>4:</em> b ′ ← A2(state, ct)<em>.</em></li>

      <li><em>5:</em> If, b = b ′ and for all Turing machines M that A requests to oracle ABE.KeyGen(msk, ·), we have M(x) = 0, output 1, else output 0.</li>

    </ul>

    <p class="text-gray-300"><em>We say that the scheme is a secure attribute-based encryption for Turing machines if for all p.p.t. adversaries</em> A<em>, and for all sufficiently large</em> κ<em>:</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Adv_{\\mathsf{ABE},A} :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathsf{Exp}_{\\mathsf{ABE},A}(1^{\\kappa}) = 1] - 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\operatorname{negl}(\\kappa).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-12" class="text-2xl font-bold">3 Attribute-based Encryption for Turing Machines and RAMs</h2>

    <p class="text-gray-300">We construct an ABE scheme for Turing machines based on three ingredients:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>an extractable witness encryption scheme WE = (WE.Enc, WE.Dec) based on the work of [\\[GGSW13\\]](#page-17-10), on which we elaborate in Sec. <a href="#page-9-1">2.2,</a></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. a succinct argument of knowledge scheme, SNARK = (SNARK.Gen, SNARK.Prover, SNARK.Verify), based on the work of [\\[BCCT13\\]](#page-16-9),</li>

      <li>3. an existentially unforgeable signature scheme secure against adaptive chosen message attacks SIG = (SIG.KeyGen,SIG.Sign, SIG.Verify) [\\[GMR88\\]](#page-17-19).</li>

    </ul>

    <p class="text-gray-300"><span id="page-11-0"></span>Theorem 5. <em>Assuming the above three primitives, there exists a secure attribute-based encryption scheme (as per Def. <a href="#page-10-1">4\\)</a> for any class of (uniform or non-uniform) Turing machines</em> T <em>, for which there exists a polynomial</em> p <em>such that the runtime of every machine in</em> T <em>is upper-bounded by</em> p<em>.</em></p>

    <p class="text-gray-300">The p restriction comes from the fact that SNARKs are for NP. From now on, for brevity, we will refer to such a class by "a class of Turing machines with runtime upper-bounded by some polynomial".</p>

    <p class="text-gray-300">Corollary 1. <em>There exists a secure attribute-based encryption scheme for any class of (uniform or non-uniform) Turing machines whose runtime is upper-bounded by some polynomial under the extractable DGE No-Exact-Cover assumption, "knowledge of exponent assumption", and the existence of collision-resistant hash functions (Sec. <a href="#page-5-0">1.2\\)</a>.</em></p>

    <h2 id="sec-13" class="text-2xl font-bold">3.1 Construction preliminaries</h2>

    <p class="text-gray-300">We advise the reader to recall the intuition we provided in technique overview, Sec. <a href="#page-6-0">1.3.</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The language L for SNARK. We define L by defining its relation, RL. Let R<sup>L</sup> be the following instance-witness relation: the instance is of the form y = (VK, x, t) (a verification key VK for a signature scheme, an input x, and a time bound t) and the witness is of the form w = (M, σ), for M a Turing machine and σ a signature. Then, (y, w) ∈ R<sup>L</sup> iff SIG.Verify(VK, M, σ) = 1 and M halts on x in at most t steps and outputs one. Moreover, t < p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">), where p is a polynomial upper-bound on the runtime of every Turing machine in the class of interest. Let (SNARK.Gen, SNARK.Prover, SNARK.Verify) be a SNARK system for L.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Language L ∗ for WE. Based on the above language L and the SNARK system (SNARK.Gen, SNARK.Prover, SNARK.Verify) for L, we define a language L ∗ for the witness encryption scheme using the witness relation RL<sup>∗</sup> as follows:</p>

    <p class="text-gray-300"><span class="math-block">R_{L^<em>}\\left[x^</em>=(x,\\mathsf{crs},\\mathsf{VK}),w^*=(\\pi,t)\\right]=1</span>  iff SNARK.  <span class="math">\\mathsf{Verify}(\\mathsf{crs},(\\mathsf{VK},x,t),\\pi)=1</span> .</p>

    <p class="text-gray-300">Let WE = (WE.Enc, WE.Dec) be an extractable witness encryption scheme for the witness relation RL<sup>∗</sup> .</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">3.2 Construction of ABE for Turing machines</h4>

    <p class="text-gray-300">Our construction of ABE = (ABE.Setup, ABE.KeyGen, ABE.Enc, ABE.Dec) for Turing machines proceeds as follows. Let T be the class of (uniform or non-uniform) polynomial time Turing machines for the ABE scheme.</p>

    <p class="text-gray-300">Setup ABE.Setup(1<sup>κ</sup> ) where κ is the security parameter: 1. Sample a verification key / signing key pair (VK, SigSK)  <span class="math">\\leftarrow</span>  SIG.KeyGen( <span class="math">1^{\\kappa}</span> ), and output mpk := VK and msk := SigSK.</p>

    <p class="text-gray-300"><strong>Encryption</strong> ABE.Enc(mpk, x, b) where mpk = VK,  <span class="math">x \\in \\{0, 1\\}^*</span>  and  <span class="math">b \\in \\{0, 1\\}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Run the SNARK generator SNARK. Gen to get crs  <span class="math">\\leftarrow</span>  SNARK. Gen <span class="math">(1^{\\kappa})</span> .</li>

      <li>2. Let  <span class="math">x^<em> = (x, \\operatorname{crs}, \\operatorname{VK})</span> . Compute  <span class="math">\\operatorname{ct}_{\\operatorname{WE}} \\leftarrow \\operatorname{WE.Enc}(1^{\\kappa}, x^</em>, b)</span> .</li>

      <li>3. Output  <span class="math">\\operatorname{ct} := (x^*, \\operatorname{ct}_{\\mathsf{WE}})</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Key generation</strong> ABE. <span class="math">\\mathsf{KeyGen}(\\mathsf{msk}, M)</span>  where M is a Turing machine:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\sigma \\leftarrow \\mathsf{SIG}.\\mathsf{Sign}(\\mathsf{SigSK},M)</span>  and output  <span class="math">\\mathsf{sk}_M := (M,\\sigma)</span> .</li>

    </ol>

    <p class="text-gray-300"><strong>Decryption</strong> ABE.Dec( <span class="math">\\mathsf{sk}_M</span> , ct) where  <span class="math">\\mathsf{sk}_M = (M, \\sigma)</span>  and  <span class="math">\\mathsf{ct} = (x^* = (x, \\mathsf{crs}, \\mathsf{VK}), \\mathsf{ct}_{\\mathsf{WE}})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Run M on x and let t be the number of steps after which M halts (note that M is a polynomial time Turing machine so it must halt within a polynomial number of steps).</li>

      <li>2. If M(x) = 0, output  <span class="math">\\perp</span>  and exit.</li>

      <li>3. Otherwise, let  <span class="math">w := (M, \\sigma)</span>  and note that  <span class="math">((VK, x, t), w) \\in R_L</span> .</li>

      <li>4. Run SNARK.Prover to obtain a proof  <span class="math">\\pi \\leftarrow \\mathsf{SNARK.Prover}(\\mathsf{crs}, (\\mathsf{VK}, x, t), w)</span> .</li>

      <li>5. Let  <span class="math">w^<em> = (\\pi, t)</span> . Compute and output WE. <span class="math">Dec(w^</em>, ct_{WE})</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Proof Intuition.</strong> We prove Th. 5 formally in our full version, and we only provide intuition here for the security proof. We start by assuming the ABE scheme is not secure, and reach a contradiction by showing that one can forge signatures using the extractability properties of the WE and SNARK schemes. Therefore, assume there is an adversary for ABE,  <span class="math">A_{\\text{ABE}} = (A_{\\text{ABE},1}, A_{\\text{ABE},2})</span> . We will show how to construct an adversary  <span class="math">A_{\\text{WE}}</span>  for the WE scheme:  <span class="math">A_{\\text{WE}}</span>  simply embeds its challenge ciphertext into the ciphertext for  <span class="math">A_{\\text{ABE}}</span>  and lets  <span class="math">A_{\\text{ABE}}</span>  decide.</p>

    <p class="text-gray-300">Once we have the adversary  <span class="math">A_{\\rm WE}</span> , by the security definition of WE, we also have an extractor  <span class="math">E_{\\rm WE}</span>  which on input  <span class="math">x^<em></span> , outputs a valid witness  <span class="math">w^</em>=(\\pi,t)</span>  of  <span class="math">(x^<em>,w^</em>)\\in R_{L^<em>}</span> . Using  <span class="math">E_{\\rm WE}</span> , we construct a prover  <span class="math">P^</em></span>  for the SNARK system that is able to construct an instance  <span class="math">y=({\\sf VK},x,t)</span>  and a proof  <span class="math">\\pi</span>  for which the SNARK verifier accepts. By the proof of knowledge property of the SNARK, there exists an extractor  <span class="math">E_{\\sf SNARK}</span>  that outputs a witness for the SNARK language L, namely  <span class="math">w=(M,\\sigma)</span> , such that  <span class="math">(y,w)\\in R_L</span> . This means that M(x)=1 and that  <span class="math">\\sigma</span>  is a correct signature on M; but  <span class="math">A_{\\sf ABE}</span>  only asked for signatures of Turing machines  <span class="math">M_i</span>  for which  <span class="math">M_i(x)=0</span> . Therefore,  <span class="math">(M,\\sigma)</span>  are a new signature pair and thus we used  <span class="math">P^*</span>  and  <span class="math">E_{\\sf SNARK}</span>  to forge a signature and reach a contradiction.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">3.3 ABE for RAMs</h4>

    <p class="text-gray-300">In this section, we discuss how to construct ABE for RAMs. This construction is similar to our construction for Turing machines, so we only mention the main differences here: the language L for the SNARK and ABE.KeyGen. See our full paper for more details. Let (M,D) be a RAM pair: a RAM machine M and memory D.</p>

    <p class="text-gray-300">The language L for SNARK. Let  <span class="math">R_L</span>  be the following instance-witness relation: the instance is of the form y = (VK, x, t) (a verification key VK for a signature scheme, an input x, and a time bound t) and the witness is of the form w = <span class="math">(r, M, \\sigma_{(r,M)}, S, \\{i, D_i, \\sigma_{(r,i,D_i)}\\}_{i \\in S})</span> , where r is a nonce, M a machine,  <span class="math">\\sigma_{(M,r)}</span>  is a signature on the description of the machine M and the nonce r, S is a set of integers that represent memory addresses (the memory accesses M makes to D),  <span class="math">D_i</span>  is the value in the i-th slot of memory and  <span class="math">\\sigma_{r,i,D_i}</span>  is a signature on r and  <span class="math">D_i</span> . Then,  <span class="math">(y,w) \\in R_L</span>  iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. SIG.Verify(VK,  <span class="math">(r, M), \\sigma_{(r,M)}</span> ) = 1,</li>

      <li>2. SIG.Verify(VK,  <span class="math">(r, i, D_i)</span> ,  <span class="math">\\sigma_{(r,i,D_i)}</span> ) = 1 for all  <span class="math">i \\in S</span> ,</li>

      <li>3. M halts on x in at most t, all of its memory queries are in S, and outputs one.</li>

    </ul>

    <p class="text-gray-300"><strong>Key generation</strong> ABE.KeyGen(msk, M, D) where M is a RAM and D its memory:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Choose  <span class="math">r \\leftarrow \\{0,1\\}^{\\text{poly}(\\kappa)}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2. Compute  <span class="math">\\sigma_{(r,M)} \\leftarrow \\mathsf{SIG.Sign}(\\mathsf{SigSK},(r,M))</span> . 3. For every  $i \\in 1 \\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , compute  </span>\\sigma_{(r,i,D_i)} \\leftarrow \\mathsf{SIG.Sign}(\\mathsf{SigSK},(r,i,D_i))<span class="math"> . 4. Output  </span>(r,M,\\sigma_{(r,M)},\\{D_i,\\sigma_{(r,i,D_i)}\\}_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key generation runtime and the function key size are polynomial in the description of the RAM and the size of</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, but they do not depend on the runtime of the RAM. (As a remark, to obtain a slightly shorter key size, one can sign a Merkle tree over the entries in D.) The time to decrypt also only depends on the time to run the RAM and not on its worst case running time or on the memory size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-16" class="text-lg font-semibold mt-6"><strong>Beyond ABE for Turing machines and RAMs</strong></h4>

    <p class="text-gray-300">Interestingly, it turns out the expressivity of our ABE construction goes beyond that of Turing machines and RAMs. The ABE construction can be easily changed to allow the evaluator to provide an additional input  <span class="math">\\alpha</span>  to the computation. That is, given a function key  <span class="math">sk_M</span> , a ciphertext  <span class="math">ct_{x,m}</span> , an evaluator can choose an input  <span class="math">\\alpha</span>  by himself; then if  <span class="math">M(x,\\alpha)=1</span> , ABE. Dec outputs m, otherwise, it outputs  <span class="math">\\perp</span> . To construct such an ABE, one only has to change the SNARK language L such that an instance has the form (VK, x, t) and a witness is  <span class="math">(M, \\sigma, \\alpha)</span>  with  <span class="math">M(x, \\alpha) = 1</span>  and  <span class="math">\\sigma</span>  verifies M.</p>

    <p class="text-gray-300">This extra input  <span class="math">\\alpha</span>  makes the scheme significantly more expressive. We illustrate on two examples. The first example allows the secret key owner to delegate the choice of Turing machines to another user, say Alice, by issuing a function key for Alice; then Alice can choose Turing machines of her choice to run on the ciphertexts, without contacting the secret key owner. To construct this example, the secret key owner generates  <span class="math">\\mathsf{sk}_{U_{\\mathsf{Align}}}</span> where  <span class="math">U_{Alice}</span>  is a universal circuit containing Alice's public key.  <span class="math">U_{Alice}</span>  takes as input  <span class="math">\\alpha = (\\mathsf{TM}, \\sigma(\\mathsf{TM}))</span>  and x: it first checks that  <span class="math">\\sigma(\\mathsf{TM})</span>  verifies with Alice's public key as being a signature of TM, and if so, it runs TM(x). Now Alice can choose any Turing machine TM she wishes, and as long as she signs it, she will be able to evaluate it on the ciphertext. In fact, the secret key owner can delegate the choice of Turing machines to any group of people, and he can even express complex policies, e.g. "allow any Turing machine that is signed by (Alice and Bob) or Chris".</p>

    <p class="text-gray-300">The second example is to run any approved RAM on any approved database, where approved means that it was signed by the secret key owner. We do not elaborate further on this construction and its applications in this short paper version.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4 Functional encryption for Turing machines</h2>

    <p class="text-gray-300">In this section we construct a (single-key and succinct) functional encryption scheme for Turing machines. We refer the reader to our full paper for a definition of FE for Turing machines.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Theorem 6. <em>Assuming we have:</em></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>an attribute-based encryption scheme for any class of (uniform or non-uniform) Turing machines with running time upper-bounded by a polynomial, and</em></li>

      <li><em>a fully homomorphic encryption scheme,</em></li>

    </ul>

    <p class="text-gray-300"><em>there is a (single-key and succinct) functional encryption scheme for any class of (uniform or non-uniform) Turing machines with running time upper-bounded by a polynomial.</em></p>

    <p class="text-gray-300"><span id="page-14-1"></span>Theorem 7. <em>Assuming there exists a (single-key and succinct) functional encryption scheme for any class of (uniform or non-uniform) Turing machines with running time bounded by a polynomial, there is a (single-key and succinct) input-specific runtime functional encryption scheme for any class of (uniform or non-uniform) Turing machines with running time bounded by a polynomial.</em></p>

    <p class="text-gray-300">Corollary 2. <em>There exists a secure (single-key and succinct) functional encryption scheme</em> FE <em>and a (single-key) input-specific runtime functional encryption scheme</em> FE<sup>∗</sup> <em>for any class of (uniform or non-uniform) Turing machines with runtime bounded by a polynomial under the extractable DGE No-Exact-Cover assumption, "knowledge of exponent assumption", and the LWE assumption with circular security (Sec. <a href="#page-5-0">1.2\\)</a>.</em></p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.1 FE for Turing machines construction (FE)</h3>

    <p class="text-gray-300">Recall the construction overview provided in Sec. <a href="#page-6-0">1.3.</a> We follow the reduction of Goldwasser <em>et al.</em> <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] who showed how to construct a (single-key and succinct) functional encryption scheme from any ABE and FHE scheme, where functions were modeled as circuits.</p>

    <p class="text-gray-300">Our construction of FE = (FE.Setup, FE.KeyGen, FE.Enc, FE.Dec) proceeds similarly to the <a href="#page-17-8">\\[GKP</a><sup>+</sup>13] construction, with the main difference being that we work with Turing machines instead of circuits. There are two places in the reduction where the treatment of circuits is different from the treatment of Turing machines: in the use of the ABE and FHE schemes. To adapt the reduction to Turing machines, we first use our ABE for Turing machines scheme. Second, we need to construct a Turing machine MFHE that performs the FHE evaluation of another Turing machine M. We only present here the construction of MFHE and delegate the full FE construction to our full paper.</p>

    <p class="text-gray-300">Based on the intuition provided in Sec. <a href="#page-6-0">1.3,</a> we describe a compiler CompileFHE that takes as input a Turing machine M and a number of steps t and produces a Turing machine MFHE that computes the FHE evaluation of M for t steps. In the following, let xˆ denote the FHE encryption of x.</p>

    <p class="text-gray-300">Algorithm 1 (CompileFHE(M, t))</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Use the Pippenger-Fischer transformation [PF79] for time bound t to transform M into an oblivious Turing machine  <span class="math">M_O</span>  with head movement function next. next is a function that takes as input i, the current step in the computation, and outputs whether the head of  <span class="math">M_O</span>  should move left or right on the tape. The Turing machine  <span class="math">M_O</span>  has a transition function  <span class="math">\\delta</span> :  <span class="math">\\delta</span>  takes as input a tape input bit b, a state state and outputs a new state state', and the new content b' for the new tape location which is indicated by next.</li>

      <li>2. Based on  <span class="math">(M_O, \\text{next})</span> , construct a new Turing machine  <span class="math">M_{\\text{FHE}}</span>  that takes as input an FHE public key hpk and an input encryption  <span class="math">\\hat{x}</span> .  <span class="math">M_{\\text{FHE}}</span>  evaluates homomorphically the transition function  <span class="math">\\delta</span>  of  <span class="math">M_O</span>  for t steps. Each cell of the tape of  <span class="math">M_O</span>  corresponds to the FHE encryption of the cell value for  <span class="math">M_{\\text{FHE}}</span> . At step i,  <span class="math">M_{\\text{FHE}}</span>  maintains the FHE encryption of the state of  <span class="math">M_O</span>  at time i:  <span class="math">\\widehat{\\text{state}}_i</span> . At step i,  <span class="math">M_{\\text{FHE}}</span>  takes as input the encrypted bit from the input tape  <span class="math">\\hat{b}</span>  that the head currently points at, the current encrypted state  <span class="math">\\widehat{\\text{state}}_i</span> , and outputs an encrypted new state  <span class="math">\\widehat{\\text{state}}_{i+1}</span>  and a new content  <span class="math">\\widehat{b&#x27;}</span> .  <span class="math">M_{\\text{FHE}}</span>  updates the current cell with  <span class="math">\\widehat{b&#x27;}</span>  and then computes next(i) to determine whether to move left or right.</li>

      <li>3. Output the description of  <span class="math">M_{\\mathsf{FHE}}</span> .</li>

    </ul>

    <p class="text-gray-300">Note that the running time of Compile<sub>FHE</sub> and  <span class="math">M_{\\rm FHE}</span>  is polynomial in t.</p>

    <h2 id="sec-20" class="text-2xl font-bold">4.2 Input-specific runtime functional encryption for Turing machines (FE\\*)</h2>

    <p class="text-gray-300">In what follows we show how to convert a (single-key) functional encryption scheme for Turing machines FE into one where the decryption algorithm, on input a function key for M denoted  <span class="math">fsk_M</span>  and FE.Enc(MPK, x), runs in time that depends on the runtime of M on input x. Denote by  <span class="math">FE^*</span>  such a functional encryption scheme. We refer the reader to Sec. 1.3 for the construction overview and to our full paper for the definition of input-specific runtime functional encryption.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6"><strong>Setup</strong> <span class="math">\\mathsf{FE}^*</span> . Setup <span class="math">(1^{\\kappa})</span> :</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Generate  <span class="math">\\tau := \\log B_n</span>  independent pair of keys for the FE scheme:  <span class="math">(\\mathsf{msk}_i, \\mathsf{mpk}_i) \\leftarrow \\mathsf{FE}.\\mathsf{Setup}(1^\\kappa)</span> .</li>

      <li>2. Output MPK :=  <span class="math">(mpk_1, ..., mpk_{\\tau})</span>  and MSK :=  <span class="math">(msk_1, ..., msk_{\\tau})</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Key Generation</strong>  <span class="math">FE^*</span> . KeyGen(MSK, M): with MSK = (msk<sub>1</sub>,..., msk<sub> <span class="math">\\tau</span> </sub>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Let  <span class="math">M_i</span>  be the Turing machine that runs M for  <span class="math">2^i</span>  steps and outputs M(x) if M finishes in that number of steps, otherwise, it outputs  <span class="math">\\bot</span> . Let  <span class="math">t_i</span>  be the number of steps  <span class="math">M_i</span>  runs for.<sup>3</sup></li>

      <li>2. Let  <span class="math">fsk_{M_i} \\leftarrow FE.KeyGen(msk_i, M_i, t_i)</span> , for  <span class="math">i = 1 \\dots \\tau</span> .</li>

      <li>3. Output  <span class="math">fsk_M := (fsk_{M_1}, \\dots, fsk_{M_{\\tau}})</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Encryption</strong>  <span class="math">FE^*</span> . Enc(MPK, x) with  <span class="math">MPK = (mpk_1, ..., mpk_{\\tau})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\mathsf{ct}_i \\leftarrow \\mathsf{FE}.\\mathsf{Enc}(\\mathsf{mpk}_i, x)</span>  for  <span class="math">i = 1 \\dots \\tau</span> .</li>

    </ol>

    <p class="text-gray-300"><sup>&</sup>lt;sup>3</sup> Note that  <span class="math">t_i</span>  may be slightly larger than  <span class="math">2^i</span> , since  <span class="math">t_i</span>  is the number of steps it takes to simulate a Turing machine that runs for  <span class="math">2^i</span>  steps.</p>

    <pre><code class="language-text">2. Output ct := (ct1, . . . , ctτ ).
Decryption FE∗
                 .Dec(fskM, ct): for fskM = (fskM1
                                                         , . . . , fskMτ
                                                                      ), ct = (ct1, . . . , ctτ ).
1. Starting with i = 1, repeat until v ̸= ⊥:
  (a) v ← FE.Dec(fskMi
                            , cti)
  (b) i ← i + 1</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output v.</li>

    </ol>

    <p class="text-gray-300">Based on this construction, we prove Th. <a href="#page-14-1">7</a> in our full paper.</p>

    <p class="text-gray-300">We would like to thank the authors of the witness encryption paper [\\[GGH13a\\]](#page-17-5) and Zvika Brakerski for useful discussions. This work was supported by an NSERC Discovery Grant, by DARPA awards FA8750-11-2-0225 and N66001-10-2-4089, by NSF awards CNS-1053143 and IIS-1065219, and by Google. The U.S. Government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the author and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-16-7"></span>AGVW12. Shweta Agrawal, Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Functional encryption: New perspectives and lower bounds. <em>Cryptology ePrint Archive, Report 2012/468</em>, 2012. <http://eprint.iacr.org/>.</li>

      <li><span id="page-16-9"></span>BCCT13. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In <em>STOC</em>, 2013.</li>

      <li><span id="page-16-4"></span>BGV12. Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (Leveled) fully homomorphic encryption without bootstrapping. In <em>ITCS</em>, pages 309–325, 2012.</li>

      <li><span id="page-16-0"></span>BGW88. Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In <em>STOC</em>, pages 1–10, 1988.</li>

      <li><span id="page-16-8"></span>BHR12. Mihir Bellare, Viet Tung Hoang, and Phillip Rogaway. Foundations of garbled circuits. In <em>ACM CCS</em>, pages 784–796, 2012.</li>

      <li><span id="page-16-5"></span>Bra12. Zvika Brakerski. Fully homomorphic encryption without modulus switching from classical GapSVP. In <em>CRYPTO</em>, pages 868–886, 2012.</li>

      <li><span id="page-16-6"></span>BSW11. Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In <em>TCC</em>, pages 253–273, 2011.</li>

      <li><span id="page-16-2"></span>BV11a. Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) LWE. In <em>FOCS</em>, pages 97–106, 2011.</li>

      <li><span id="page-16-3"></span>BV11b. Zvika Brakerski and Vinod Vaikuntanathan. Fully homomorphic encryption from ring-LWE and security for key dependent messages. In <em>CRYPTO</em>, pages 505–524, 2011.</li>

      <li><span id="page-16-1"></span>CCD88. David Chaum, Claude Crépeau, and Ivan Damgård. Multiparty unconditionally secure protocols (extended abstract). In <em>STOC</em>, pages 11–19, 1988.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-17-2"></span>Gen09. Craig Gentry. Fully homomorphic encryption using ideal lattices. In <em>STOC</em>, pages 169–178, 2009.</li>

      <li><span id="page-17-5"></span>GGH13a. Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear maps from ideal lattices and applications. In <em>EUROCRYPT</em>, pages 1–17, 2013.</li>

      <li><span id="page-17-4"></span>GGH<sup>+</sup>13b. Sanjam Garg, Craig Gentry, Shai Halevi, Amit Sahai, and Brent Waters. Attributebased encryption for circuits from multilinear maps, 2013.</li>

      <li><span id="page-17-10"></span>GGSW13. Sanjam Garg, Craig Gentry, Amit Sahai, and Brent Waters. Witness encryption and its applications. In <em>STOC</em>, 2013.</li>

      <li><span id="page-17-11"></span>GK05. Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In <em>FOCS</em>, pages 553–562, 2005.</li>

      <li><span id="page-17-8"></span>GKP<sup>+</sup>13. Shafi Goldwasser, Yael Kalai, Raluca Ada Popa, Vinod Vaikuntanathan, and Nickolai Zeldovich. Reusable garbled circuits and succinct functional encryption. In <em>STOC</em>, 2013.</li>

      <li><span id="page-17-19"></span>GMR88. Shafi Goldwasser, Silvio Micali, and Ronald L. Rivest. A digital signature scheme secure against adaptive chosen-message attacks. <em>SIAM J. Comput.</em>, pages 281–308, 1988.</li>

      <li><span id="page-17-1"></span>GMW87. O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game. In <em>STOC</em>, pages 218–229, 1987.</li>

      <li><span id="page-17-13"></span>GPSW06. Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In <em>ACM CCS</em>, pages 89–98, 2006.</li>

      <li><span id="page-17-7"></span>GVW12. Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Functional encryption with bounded collusions via multi-party computation. In <em>CRYPTO</em>, pages 162–179, August 2012.</li>

      <li><span id="page-17-3"></span>GVW13. Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Attribute-based encryption for circuits. In <em>STOC</em>, 2013.</li>

      <li><span id="page-17-16"></span>KSW08. Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In <em>EUROCRYPT</em>, pages 146–162, 2008.</li>

      <li><span id="page-17-9"></span>LO12. Steve Lu and Rafail Ostrovsky. How to garble RAM programs. In <em>Eurocrypt</em>, pages 719–734, 2012.</li>

      <li><span id="page-17-14"></span>LOS<sup>+</sup>10. Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In <em>EUROCRYPT</em>, pages 62–91, 2010.</li>

      <li><span id="page-17-15"></span>LW12. Allison B. Lewko and Brent Waters. New proof methods for attribute-based encryption: Achieving full security through selective techniques. In <em>CRYPTO</em>, 2012.</li>

      <li><span id="page-17-18"></span>PF79. Nicholas Pippenger and Michael J. Fischer. Relations among complexity measures. <em>J. ACM</em>, 26(2):361–381, 1979.</li>

      <li><span id="page-17-6"></span>SS10. Amit Sahai and Hakan Seyalioglu. Worry-free encryption: functional encryption with public keys. In <em>ACM CCS</em>, pages 463–472, 2010.</li>

      <li><span id="page-17-17"></span>SSW09. Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In <em>TCC</em>, pages 457–473, 2009.</li>

      <li><span id="page-17-12"></span>SW05. Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In <em>EUROCRYPT</em>, pages 457–473, 2005.</li>

      <li><span id="page-17-0"></span>Yao86. Andrew C. Yao. How to generate and exchange secrets (extended abstract). In <em>FOCS</em>, pages 162–167, 1986.</li>

    </ul>`;
---

<BaseLayout title="How to Run Turing Machines on Encrypted Data (2013/229)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/229
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
