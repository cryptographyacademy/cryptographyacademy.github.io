---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/309';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Power of Verification Queries in Message Authentication and Authenticated Encryption';
const AUTHORS_HTML = 'Mihir Bellare, Oded Goldreich, Anton Mityagin';

const CONTENT = `    <p class="text-gray-300">The Power of Verification Queries in Message Authentication and Authenticated Encryption</p>

    <p class="text-gray-300">MIHIR BELLARE* ODED GOLDREICH† ANTON MITYAGIN‡</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">This paper points out that, contrary to popular belief, allowing a message authentication adversary multiple verification attempts towards forgery is not equivalent to allowing it a single one, so that the notion of security that most message authentication schemes are proven to meet does not guarantee their security in practice. We then show, however, that the equivalence does hold for strong unforgeability. Based on this we recover security of popular classes of message authentication schemes such as MACs (including HMAC and PRF-based MACs) and CW-schemes. Furthermore, in many cases we do so with a tight security reduction, so that in the end the news we bring is surprisingly positive given the initial negative result. Finally, we show analogous results for authenticated encryption.</p>

    <p class="text-gray-300">Keywords: Message authentication, PRFs, Carter-Wegman, symmetric encryption, authenticated encryption.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">MESSAGE AUTHENTICATION. A message authentication (ma) scheme allows parties sharing a key <span class="math">K</span> to authenticate data they send to each other. The sender applies a tag generation algorithm TG to <span class="math">K</span> and the message <span class="math">M</span> to get a tag Tag, and then sends <span class="math">M, Tag</span> to the receiver. The latter applies a verification algorithm VF to <span class="math">K</span>, a received message, and its accompanying tag, to get an output of 1 (accept) or 0 (reject), indicating whether or not the message should be considered authentic.</p>

    <p class="text-gray-300">Message authentication schemes are pervasive in practice. In a typical usage, public-key cryptography is first used to exchange a private key <span class="math">K</span>, and the latter is then used to authenticate (and also possibly encrypt) data. This happens in Internet security protocols like SSL (used to secure credit card numbers in electronic commerce) SSH (secure remote login) and IPSEC.</p>

    <p class="text-gray-300">Much work goes into obtaining high-performance, secure ma-schemes, and there are a variety of schemes in existence and use, including HMAC [1], block-cipher based MACs [5, 22, 10, 4, 11, 20, 17, 18] and Carter-Wegman (CW) ma-schemes [25, 21, 23, 16, 8, 9].</p>

    <p class="text-gray-300">This paper points out that the notion of security that most of these schemes are proven to meet does not guarantee their security in practice, and then looks into remedies.</p>

    <p class="text-gray-300">*Dept. of Computer Science &amp; Engineering, University of California, San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA. Email: mihir@cs.ucsd.edu. URL: http://www-cse.ucsd.edu/users/mihir. Supported in part by NSF grants CCR-0098123, ANR-0129617 and CCR-0208842, and by an IBM Faculty Partnership Development Award.</p>

    <p class="text-gray-300">†Department of Computer Science, Weizmann Institute of Science, Rehovot, Israel. Email: oded.goldreich@weizmann.ac.il. URL: http://www.wisdom.weizmann.ac.il/~oded/homepage.html.</p>

    <p class="text-gray-300">‡Dept. of Computer Science &amp; Engineering, University of California, San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA. Email: amityagin@cs.ucsd.edu. URL: http://www-cse.ucsd.edu/users/amityagin. Supported in part by above-mentioned grants of first author.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 UF-1<span class="math">\\nRightarrow</span>UF-M</h3>

    <p class="text-gray-300">Two definitions. The natural definition of security <em>[5]</em> comes by extending the one for digital signatures <em>[15]</em>. Namely, an adversary, allowed a chosen-message attack (via access to a tagging oracle <span class="math">\\mathsf{TG}(K,\\cdot)</span>), should be unable to produce a message-tag pair <span class="math">M,\\mathit{Tag}</span> that is valid (meaning <span class="math">\\mathsf{VF}(K,M,\\mathit{Tag})=1</span>) and for which the message is new (meaning, was not queried to the tagging oracle).</p>

    <p class="text-gray-300">This definition however gives the adversary only one verification attempt. An alternative definition <em>[4]</em> gives the adversary, in addition to the tagging oracle, also a verification oracle <span class="math">\\mathsf{VF}(K,\\cdot,\\cdot)</span>. The adversary should be unable to make a query <span class="math">M,\\mathit{Tag}</span> to its verification oracle such that the latter returns <span class="math">1</span> but <span class="math">M</span> was not previously queried to the tag oracle.</p>

    <p class="text-gray-300">Let us refer to this second definition as UF-M (UnForgeability under Multiple verification queries). Note that the first (standard) definition we discussed above is just the special case of the second one in which only a single verification query is allowed, so henceforth we think of it this way and refer to it as UF-1 (UnForgeability under a single verification query).</p>

    <p class="text-gray-300">In practice, it is certainly possible for an adversary to make multiple verification attempts. (For example a server authenticating a client under their common key functions as the verification oracle, and an adversary can forward many transmissions to it.) A scheme that is UF-1 but not UF-M is thus clearly not providing adequate security for practical usage.</p>

    <p class="text-gray-300">Equivalent? It turns out that this fact (namely, that UF-M is the “right” notion, not UF-1) is actually quite well understood in the community and literature. Nonetheless, it is the UF-1 notion that most schemes are proven to meet <em>[5, 22, 1, 10, 11, 8, 9, 17, 18, 20]</em>. (Exceptions are <em>[4, 3]</em>.) Why?</p>

    <p class="text-gray-300">It appears to be due to the belief that UF-1 <span class="math">\\Rightarrow</span> UF-M. More precisely, the belief is that if an adversary <span class="math">A</span> makes <span class="math">v</span> verification oracle queries, its advantage (probability of forgery) is not more than <span class="math">v</span> times that of an adversary <span class="math">B</span> of comparable time making just one verification oracle query. So the belief is that although a difference in concrete security does manifest itself, UF-1 and UF-M are polynomially equivalent. The folklore argument for this is that <span class="math">B</span> can guess one of the verification queries of <span class="math">A</span> to use as its own, single verification query, answering previous ones by “0.”</p>

    <p class="text-gray-300">Not equivalent. In Section 3 we show why the above-mentioned folklore argument is incorrect. This leaves open the question of whether or not it can be patched to show the equivalence, but we then go on to show that it cannot. Namely we show in Theorem 4.1 that UF-1 <span class="math">\\nRightarrow</span> UF-M. We do this by presenting a ma-scheme that is UF-1 but is not UF-M. (Naturally this requires the assumption that some UF-1 ma-scheme exists, otherwise the question is moot.) Thus, contrary to expectation, the UF-1 and UF-M notions are not equivalent.</p>

    <p class="text-gray-300">Intuitively, the problem is malleability <em>[12]</em>. In particular multiple verification queries can add power when an adversary can modify a valid tag for a message into another, different valid tag for the same message.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.2 SUF-1<span class="math">\\Rightarrow</span>SUF-M</h3>

    <p class="text-gray-300">Next we establish a useful positive result, namely that the equivalence (between security under one or many verification queries) does hold under a stronger notion of unforgeability than the one considered above.</p>

    <p class="text-gray-300">Strong unforgeability. Strong unforgeability <em>[6]</em> means the adversary is not only unable to forge a tag for a new message, but also unable to forge a new tag for an old (meaning, already tagged) message. The formalization is with respect to adversaries getting both a tagging and a</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: An arrow represents an implication and a barred arrow represents a separation.</p>

    <p class="text-gray-300">verification oracle as above, so again there is both a single verification query version (that we denote SUF-1) and a multiple verification query version (that we denote SUF-M).</p>

    <p class="text-gray-300">We show (cf. Theorem 5.1 and Corollary 5.2) that  <span class="math">\\mathrm{SUF - 1}\\Rightarrow \\mathrm{SUF - M}</span> . Thus, in contrast to (mere) unforgeability, the strong versions of the notions are equivalent.</p>

    <p class="text-gray-300">RELATIONS. Figure 1.2 summarizes the relations between the four notions we have discussed, in the style of [2]. For each pair  <span class="math">\\mathbf{A},\\mathbf{B}\\in \\{\\mathrm{UF - 1,UF - M,SUF - 1,SUF - M}\\}</span>  of notions we show one of the following: (1) An implication  <span class="math">\\mathbf{A}\\Rightarrow \\mathbf{B}</span>  (this means we prove that any ma-scheme achieving  <span class="math">\\mathbf{A}</span>  also achieves  <span class="math">\\mathbf{B}</span> ); or (2) A separation  <span class="math">\\mathbf{A}\\nRightarrow \\mathbf{B}</span>  (this means we give a construction of a ma-scheme that meets notion  <span class="math">\\mathbf{A}</span>  but does not meet notion  <span class="math">\\mathbf{B}</span> ). A separation  <span class="math">\\mathbf{A}\\nRightarrow \\mathbf{B}</span>  is always under the (minimal) assumption that there exists a scheme meeting notion  <span class="math">\\mathbf{A}</span> .</p>

    <p class="text-gray-300">The fact that UF-1  <span class="math">\\nRightarrow</span>  UF-M means that what has been proved about specific existing ma-schemes does not guarantee their security under multiple verification attempts and hence in practice, but does not mean that these particular schemes are not UF-M. We now ask whether it may be possible, via other routes, to prove UF-M security of existing schemes.</p>

    <p class="text-gray-300">In answering this question, it would be much preferable to avoid re-entering the (sometimes complex) proofs of security of these ma-schemes. Our approach, instead, is to consider some special classes of ma-schemes such that (1) known schemes have been proved to fall into one of these classes, and (2) we can show that any scheme in the class is SUF-1. Then, via our SUF-1  <span class="math">\\Rightarrow</span>  SUF-M implication, and existing results about the schemes, we can conclude that they are UF-M (and in fact SUF-M) secure. We implement this program as follows.</p>

    <p class="text-gray-300">The first class of ma-schemes we consider are UF-1 MACs. (A ma-scheme is a message authentication code, or MAC, if its tagging function is stateless and deterministic, and verification is done by applying the tagging function to compute the correct tag of the given message and comparing this with the candidate tag.) It is easy to see (cf. Proposition 6.1) that any UF-1 MAC is in fact SUF-1, and hence (by Corollary 5.2) UF-M and SUF-M. As an application, since HMAC, proven UF-1 in [1], is a MAC, the above tells us that it is UF-M and SUF-M secure.</p>

    <p class="text-gray-300">An important subclass of MACs are PRF based ones, where the tagging function is pseudorandom. These are UF-1 [14, 5] and thus by the above automatically SUF-1, UF-M and SUF-M. Since the tagging algorithms of block-cipher based constructs like various CBC-MACs [5, 10, 22], PMAC [11], TMAC [17] and OMAC [18] are shown in the cited papers to be PRFs, we can conclude that the corresponding MACs are UF-M and SUF-M.</p>

    <p class="text-gray-300">The second class of ma-schemes we consider are Carter-Wegman (CW) ma-schemes [25]. These schemes are randomized or counter-based, and hence not MACs, so Proposition 6.1 does not apply. However, via an extension of the standard proof establishing the UF-1 security of these ma-schemes [21, 23, 16, 8, 9], we can establish their SUF-1 security as well. Hence by Corollary 5.2, they too are UF-M and SUF-M. In particular, UMAC [8, 9] and MMH-MAC [16] are CW ma-schemes shown in the cited papers to be UF-1, and hence are UF-M and SUF-M by the above.</p>

    <p class="text-gray-300">1.4 Reduction tightness and concrete security improvements</p>

    <p class="text-gray-300">The results above are with respect to asymptotic definitions of security, where meeting a notion means that the success probability of any polynomial-time adversary is a negligible function of the security parameter. This is indeed the conceptually appropriate setting in which to study security relations at the first cut. However, for practical purposes, the concrete security of reductions can be important, and we now address this issue.</p>

    <p class="text-gray-300">Quality of the SUF-<span class="math">1\\Rightarrow</span> SUF-M reduction, and its impact. The reduction of Theorem 5.1, which establishes that SUF-<span class="math">1\\Rightarrow</span> SUF-M, is not tight: given a polynomial-time adversary <span class="math">A</span> making <span class="math">v</span> verification attempts and succeeding with probability <span class="math">a</span>, it delivers a polynomial-time adversary <span class="math">B</span> making one verification attempt and succeeding with probability at least <span class="math">b=a/v</span>. The above-mentioned results showing UF-M and SUF-M security of various classes of schemes inherit this loss in security through their reliance on Theorem 5.1. Unfortunately this loss can be significant in practice. Consider for example PRF-based MACs using a block cipher with block-length <span class="math">n</span>. Typically <em>[5, 10, 22, 11, 17, 18]</em> it is shown that the probability of forgery under <span class="math">t</span> tagging queries, each of at most <span class="math">m</span> blocks, is roughly <span class="math">m^{2}t^{2}/2^{n}</span>. With AES (<span class="math">n=128</span>) and assuming 1Kbyte messages (<span class="math">m=2^{13}</span>) this provides UF-1 security until around <span class="math">t=2^{51}</span> messages are tagged, which is adequate if we only cared about UF-1, but of course we don’t. Obtaining UF-M/SUF-M via Theorem 5.1, we get that the probability of forgery under <span class="math">v</span> verification queries is roughly <span class="math">vm^{2}t^{2}/2^{n}</span>, with <span class="math">t,m</span> as before. Now, for example, a guarantee of security against <span class="math">v=2^{34}</span> verification attempts requires that at most <span class="math">t=2^{34}</span> messages are tagged. These numbers are not large enough for comfort, and things get substantially worse if we consider legacy ciphers with block length <span class="math">n=64</span>.</p>

    <p class="text-gray-300">No better general reduction. The first question to ask given the above is whether there is a better reduction showing SUF-<span class="math">1\\Rightarrow</span> SUF-M. Proposition 7.1 shows that the answer is no. It does this by presenting a MAC for which there is a polynomial-time attack having constant probability of strong forgeability with <span class="math">v</span> queries, but for which no polynomial-time attack making only one verification query succeeds in strong forgery with probability significantly better than <span class="math">1/v</span>. This shows (cf. Corollary 7.2) that no reduction could deliver a reduction factor that is better than that of Theorem 5.1 by more than a constant factor, even for the special case of ma schemes that are MACs.</p>

    <p class="text-gray-300">Improvements in special cases. Although a general concrete-security improvement is ruled out by the above, we are able to find such improvements for important subclasses of ma-schemes. Proposition 7.3 presents an essentially tight reduction of SUF-M to the pseudorandomness of the MAC in the case the latter is PRF-based. Continuing the above example, this will imply that the probability of forgery under <span class="math">v</span> verification queries is roughly <span class="math">m^{2}(v^{2}+t^{2})/2^{n}</span>, with <span class="math">v,t,m</span> as before. Now (for 1Kbyte messages) we have a guarantee of security against <span class="math">v=2^{50}</span> verification attempts even if up to <span class="math">t=2^{50}</span> messages are tagged.</p>

    <p class="text-gray-300">This is a substantial improvement. It is particularly valuable since so many ma-schemes are PRF-based <em>[5, 10, 22, 11, 17, 18]</em>, and we note it can also be applied to HMAC, whose tagging algorithms is often assumed to be a PRF, due to its usage for tasks such as key-derivation. (We note the proof of <em>[1]</em> extends to establish its security as a PRF if we are willing to assume the underlying compression function is a PRF.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.5 The case of authenticated encryption</h3>

    <p class="text-gray-300">There are two notions of integrity for authenticated encryption: integrity of plaintexts (an analog of standard unforgeability for ma-schemes) and integrity of ciphertexts (an analog of strong un</p>

    <p class="text-gray-300">forgeability for ma-schemes). In either case we may consider versions with one or more verification attempts (here the verification oracle takes a ciphertext and says whether or not it is valid) leading to four notions, INT-PTXT-1, INT-PTXT-M, INT-CTXT-1, INT-CTXT-M. In the literature, INT-CTXT-1 was defined in <em>[19, 7]</em>, and INT-CTXT-M, INT-PTXT-M in <em>[6]</em>. INT-PTXT-1 was not defined prior to our paper. Our main results about ma-schemes extend, and in particular we show that INT-PTXT-1 <span class="math">\\nRightarrow</span> INT-PTXT-M but INT-CTXT-1 <span class="math">\\Rightarrow</span> INT-CTXT-M. This material is covered in Appendix B and the relations are depicted in Figure B.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.6 Remarks</h3>

    <p class="text-gray-300">One might consider a multiple verification version of the definition of digital signatures as well, but it is clearly equivalent to the standard definition of <em>[15]</em> because verification takes place under a key that is public (and in particular available to the adversary).</p>

    <p class="text-gray-300">In practice, “throttling” is often used to limit the number of verification attempts an adversary can make. (The verification server refuses further requests under a key for which some number of verification attempts have been previously rejected). It would be a mistake to think that the use of throttling means that UF-1 security suffices. For one thing, one surely cannot limit a user to just one verification attempt before revoking their key, for a few rejections can occur for natural reasons such as corrupted transmissions. Also, revocation of keys brings key-management costs. Thus we feel that for practice the most desirable situation is to have schemes providing security against a large number of verification attempts.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.7 Related work</h3>

    <p class="text-gray-300">In his recent textbook <em>[13]</em>, the second author of this paper noted that UF-1 <span class="math">\\nRightarrow</span> UF-M, and also that the implication is true for the class of <em>unique</em> UF-1 ma-schemes. (In such a scheme there exists for every key and message at most one tag that the verification algorithm accepts.) The present paper represents the submission of this material to a research venue while adding significant improvements, extensions and applications. In particular we establish UF-M for SUF-1 schemes, which is a strictly larger class than the class of unique UF-1 ma-schemes. (Every unique UF-1 ma-scheme is SUF-1, but there are SUF-1 ma-schemes, such as CW-ma-schemes, that are not unique.) Other contributions of the paper not present in the textbook are: consideration of the UF-M security of specific existing ma-schemes in the literature as discussed in Section 1.3 above; tightness of the main reduction and concrete security improvements as discussed in Section 1.4 above; and authenticated encryption as discussed in Section 1.5 above.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Definitions</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. By $a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots<span class="math"> we denote an encoding of objects </span>a,b,c,\\ldots<span class="math"> into a binary string in such a way that the constituents are uniquely recoverable in linear time. If </span>n<span class="math"> is an integer then </span>\\langle n\\rangle<span class="math"> denotes its binary representation and </span>[n]=\\{1,\\ldots,n\\}<span class="math">. If </span>x<span class="math"> is a string then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its length and </span>x[i]<span class="math"> denotes its </span>i<span class="math">-th bit, for </span>i\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">. If </span>A<span class="math"> is a randomized algorithm then </span>a\\xleftarrow{\\text{\\<span class="math">}}A(x,y,\\cdots)</span> means that <span class="math">A</span> is executed on inputs <span class="math">x,y,\\ldots</span> with fresh coins and <span class="math">a</span> denotes the outcome. If <span class="math">S</span> is a set then <span class="math">s\\xleftarrow{\\text{\\</span>}}S<span class="math"> means that </span>s<span class="math"> is chosen uniformly at random from </span>S<span class="math">. If </span>x,y<span class="math"> are objects then </span>x\\leftarrow y<span class="math"> means </span>x<span class="math"> is assigned the value </span>y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Message authentication schemes. A <em>message-authentication scheme</em> (ma-scheme) <span class="math">\\Pi=(\\mathsf{TG}</span>, <span class="math">\\mathsf{VF}</span>) is a pair of polynomial-time algorithms, where</p>

    <p class="text-gray-300">Experiment  <span class="math">\\mathbf{Exp}_{\\Pi ,A}^{\\mathrm{type}}(k)</span></p>

    <p class="text-gray-300"><span class="math">K\\stackrel {\\mathrm{s}}{\\leftarrow}\\{0,1\\}^{l(k)};\\mathsf{count}\\leftarrow 0;\\mathsf{f}\\leftarrow 0;\\mathsf{sf}\\leftarrow 0</span></p>

    <p class="text-gray-300">Run  <span class="math">A</span>  on input  <span class="math">1^k</span> , replying to its oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">M</span>  to  <span class="math">\\mathsf{TG}(K, \\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname{Tag} \\stackrel{\\text{s}}{\\leftarrow} \\mathsf{TG}(K, M)</span> ;  <span class="math">\\operatorname{TAGSET}[M] \\leftarrow \\operatorname{TAGSET}[M] \\cup \\{\\operatorname{Tag}\\}</span> ; Return Tag to  <span class="math">A</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">M</span> , Tag to  <span class="math">\\mathsf{VF}(K, \\cdot, \\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">d\\gets \\mathsf{VF}(K,M,\\mathsf{Tag})</span>  ; count  <span class="math">\\leftarrow</span>  count  <span class="math">+1</span></p>

    <p class="text-gray-300">If  <span class="math">d = 1</span>  then</p>

    <p class="text-gray-300">If  <span class="math">\\mathrm{TAGSET}[M] = \\emptyset</span>  then  <span class="math">f\\gets 1</span>  ; If  <span class="math">T a g\\notin T a g S e t[M]</span>  then  <span class="math">s f\\gets 1</span></p>

    <p class="text-gray-300">Return  <span class="math">d</span>  to  <span class="math">A</span></p>

    <p class="text-gray-300">If (type =UF-1) then return (count = 1) ∧ f</p>

    <p class="text-gray-300">If (type =UF-M) then return f</p>

    <p class="text-gray-300">If (type =SUF-1) then return (count = 1) ∧ sf</p>

    <p class="text-gray-300">If (type =SUF-M) then return sf</p>

    <p class="text-gray-300">Figure 2: Experiment defining our four notions of security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The tag-generation algorithm TG, which may be randomized or stateful, takes a key  <span class="math">K \\in \\{0,1\\}^{l(k)}</span> , where  <span class="math">k \\in \\mathbb{N}</span>  is the security parameter, and a message  <span class="math">M \\in \\{0,1\\}^<em></span>  to return a tag  <span class="math">Tag \\in \\{0,1\\}^</em></span> . The function  <span class="math">l(\\cdot)</span>  is the key-length.</li>

      <li>The deterministic, stateless verification algorithm VF takes a key  <span class="math">K \\in \\{0,1\\}^{l(k)}</span> , a message  <span class="math">M \\in \\{0,1\\}^<em></span>  and a candidate tag  <span class="math">Tag \\in \\{0,1\\}^</em></span>  to return either 1 (ACCEPT) or 0 (REJECT).</li>

    </ul>

    <p class="text-gray-300">We require the following completeness condition:  <span class="math">\\mathsf{VF}(K,M,\\mathsf{TG}(K,M)) = 1</span>  with probability 1 for any  <span class="math">k</span> , any  <span class="math">K\\in \\{0,1\\}^{l(k)}</span> , and any  <span class="math">M\\in \\{0,1\\}^*</span> . We say that  <span class="math">\\Pi</span>  is a message authentication code (MAC) if  <span class="math">\\mathsf{TG}</span>  is (stateless and) deterministic, and also  <span class="math">\\mathsf{VF}(K,M,Tag)</span>  is defined via: If  <span class="math">Tag = \\mathsf{TG}(K,M)</span>  then return 1 else return 0.</p>

    <p class="text-gray-300">For simplicity we will focus for now on stateless schemes. (Meaning ones where  <span class="math">\\mathsf{TG}</span>  is stateless. Verification is always stateless). We also assume that  <span class="math">\\mathsf{TG}</span>  applies to any message  <span class="math">M\\in \\{0,1\\}^*</span> . In some later cases we will want to consider that the  <span class="math">\\mathsf{TG}(K,\\cdot)</span>  algorithm only applies to strings in some message space associated to  <span class="math">k</span> . (This happens because in practice the messages are often restricted in some way, for example to a maximum length or to length a multiple of some block length.) In that case the completeness condition only applies to messages in this space.</p>

    <p class="text-gray-300">FOUR SECURITY NOTIONS. We provide the formal definitions and then some explanations. Let  <span class="math">\\Pi = (\\mathsf{TG},\\mathsf{VF})</span>  be a message authentication scheme. Let type  <span class="math">\\in</span>  {UF-1, UF-M, SUF-1, SUF-M}. Let  <span class="math">A</span>  be an adversary with access to a tagging oracle and a verification oracle, and let  <span class="math">k\\in \\mathbb{N}</span> . We define the experiment depicted in Figure 2. We let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , A} ^ {\\text {t y p e}} (k) = \\Pr \\left[ \\mathbf {E x p} _ {\\Pi , A} ^ {\\text {t y p e}} (k) = 1 \\right]</span></div>

    <p class="text-gray-300">denote the winning probability for  <span class="math">A</span>  in the experiment in question. We say that  <span class="math">\\Pi</span>  is type-secure if the function  <span class="math">\\mathbf{Adv}_{\\Pi, A}^{\\mathrm{type}}(\\cdot)</span>  is negligible for any polynomial time adversary  <span class="math">A</span> .</p>

    <p class="text-gray-300">In the experiment, naturally,  <span class="math">A</span> 's tagging oracle queries are answered via  <span class="math">\\mathsf{TG}(K,\\cdot)</span>  and its verification oracle queries via  <span class="math">\\mathsf{VF}(K,\\cdot,\\cdot)</span> . The rest is book-keeping. The flag  <span class="math">\\mathsf{f}</span>  is set to 1 if the conditions of standard forgery are met, and the flag  <span class="math">\\mathsf{sf}</span>  is set to 1 if the conditions of a strong forgery are met. It is assumed that the set  <span class="math">\\mathrm{TAGSET}[M]</span>  is initially empty for all  <span class="math">M</span> . The counter count keeps track of the number of verification queries made.</p>

    <p class="text-gray-300">PRFs and PRF-based MACs. Let <span class="math">F</span> be a family of functions with domain <span class="math">\\{D_{k}\\}_{k\\in\\mathbb{N}}</span>, output length <span class="math">\\tau(\\cdot)</span> and key-length <span class="math">l(\\cdot)</span>. This means that <span class="math">F(K,M)</span> is a <span class="math">\\tau(k)</span>-bit string for each <span class="math">k</span>, each <span class="math">l(k)</span>-bit key <span class="math">K</span> and each input <span class="math">M\\in D_{k}</span>, and can be computed in polynomial time. Recall <em>[14, 5]</em> that if <span class="math">B</span> is an adversary with an oracle for a function <span class="math">f</span>: <span class="math">D_{k}\\to\\{0,1\\}^{\\tau(k)}</span> then its prf-advantage is</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\text{PRF}}_{F,B}(k)\\ =\\ \\Pr\\Big{[}\\,B^{F(K,\\cdot)}(1^{k})=1\\,\\Big{]}-\\Pr\\Big{[}\\,B^{f(\\cdot)}(1^{k})=1\\,\\Big{]}\\ ,</span></p>

    <p class="text-gray-300">the first probability being over <span class="math">K\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\{0,1\\}^{l(k)}</span> and the second over <span class="math">f\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathsf{Maps}(D_{k},\\{0,1\\}^{\\tau(k)})</span>, where <span class="math">\\mathsf{Maps}(D,R)</span> is the set of all functions mapping from domain <span class="math">D</span> to range <span class="math">R</span>. We say that <span class="math">F</span> is a PRF if <span class="math">\\mathbf{Adv}^{\\text{PRF}}_{F,B}(\\cdot)</span> is negligible for all polynomial-time adversaries <span class="math">B</span>. We associate to <span class="math">F</span> the ma-scheme <span class="math">\\Pi[F]=(F,\\mathsf{VF})</span>, where <span class="math">\\mathsf{VF}(K,M,\\mathsf{Tag})</span> returns <span class="math">1</span> if <span class="math">F(K,M)=\\mathsf{Tag}</span> and <span class="math">0</span> otherwise. The message space associated to <span class="math">k</span> is <span class="math">D_{k}</span>. A ma-scheme <span class="math">\\Pi</span> is said to be <em>PRF-based</em> if there is a family <span class="math">F</span> such <span class="math">\\Pi=\\Pi[F]</span>. Note that a PRF-based ma-scheme is a MAC.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Template of a reduction</h2>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathsf{TG},\\mathsf{VF})</span> be a UF-1 secure ma-scheme. As we noted earlier, there is a belief that one can prove it also UF-M secure. Here we will present the template of the “proof” that people appear to have in mind and see why it does not work. This is useful for two reasons: it lends some insight into the later counter-example showing UF-1 <span class="math">\\nRightarrow</span> UF-M, and the same template will be later appropriately used to show that SUF-1 <span class="math">\\Rightarrow</span> SUF-M.</p>

    <p class="text-gray-300">Let <span class="math">A</span> be a polynomial-time UF-M adversary attacking <span class="math">\\Pi</span>, and let <span class="math">v(\\cdot)</span> bound the number of verification-oracle queries made by <span class="math">A</span>. (This means <span class="math">v(k)\\leq\\text{poly}(k)</span> is a polynomial-time computable function such that the number of verification queries made by <span class="math">A</span> on input <span class="math">1^{k}</span> is at most <span class="math">v(k)</span> with probability one, regardless of how answers to any oracle queries of <span class="math">A</span> are computed.) We want to define a UF-1 adversary <span class="math">B</span> such that for every <span class="math">k</span> the following inequality, which we refer to as <span class="math">\\mathbf{Eq}[A,B,k]</span> holds:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Eq}[A,B,k]:\\hskip 28.45274pt\\mathbf{Adv}^{\\text{UF-1}}_{\\Pi,B}(k)\\ \\geq\\ \\frac{1}{v(k)}\\cdot\\mathbf{Adv}^{\\text{UF-M}}_{\\Pi,A}(k)\\ .</span></p>

    <p class="text-gray-300">The idea is for <span class="math">B</span> to guess and output the first successful verification query made by <span class="math">A</span>, answering all others negatively without consulting its verification oracle. The corresponding adversary, which we call <span class="math">B_{1}</span>, is defined by the part of the code of Figure 3 that omits the boxed statements. (Ignore the boxed statements for now.) Let <span class="math">I</span> be the random variable, in <span class="math">\\mathbf{Exp}^{\\text{UF-M}}_{\\Pi,A}(k)</span>, that takes value the first verification query made by <span class="math">A</span> to which the answer of the verification oracle is <span class="math">1</span> and the message was not previously queried to the tagging oracle. Now we would like to claim that the guess <span class="math">\\mathsf{guess}</span> made by <span class="math">B_{1}</span> equals <span class="math">I</span> with probability at least <span class="math">1/v(k)</span>, and thus <span class="math">\\mathbf{Eq}[A,B_{1},k]</span> is true.</p>

    <p class="text-gray-300">However, this is not true. For example, <span class="math">A</span> might make a query <span class="math">M</span> to its tagging oracle, get back a tag <span class="math">\\mathsf{Tag}</span>, and immediately make query <span class="math">M,\\mathsf{Tag}</span> to its verification oracle. Let us imagine that, after this, it makes another verification oracle query <span class="math">M^{\\prime},\\mathsf{Tag}^{\\prime}</span> that is valid, with <span class="math">M^{\\prime}\\neq M</span>, so that it wins with probability one. However, <span class="math">B_{1}</span>’s simulation is inaccurate, because (in the case <span class="math">\\mathsf{guess}\\geq 2</span>) the verification oracle would have returned <span class="math">1</span> in answer to <span class="math">A</span>’s first query to it, but <span class="math">B_{1}</span> returns <span class="math">0</span> to <span class="math">A</span> as the answer. So <span class="math">B_{1}</span>’s advantage is <span class="math">0</span>. (In the case <span class="math">\\mathsf{guess}=1</span>, <span class="math">B_{1}</span> does not win because <span class="math">M</span> was queried to the tagging oracle and is not new).</p>

    <p class="text-gray-300">This seems easily fixed by comparing tags in verification oracle queries to ones returned previously by the tagging oracle. Namely, we consider adversary <span class="math">B_{2}</span> of Figure 3 that now includes the boxed statements. For our example <span class="math">A</span> above, <span class="math">B_{2}</span>’s simulation is now correct, and thus <span class="math">\\mathbf{Eq}[A,B,k]</span> is true. However, in general, this strategy is still wrong, meaning there are adversaries <span class="math">A</span> for which <span class="math">\\mathbf{Eq}[A,B_{2},k]</span> does not hold. The reason is malleability. Suppose <span class="math">A</span> begins by making a query <span class="math">M</span> to</p>

    <p class="text-gray-300">Adversary  <span class="math">B_{b}^{\\mathsf{TG}(K,\\cdot),\\mathsf{VF}(K,\\cdot,\\cdot)}(1^{k})</span> <span class="math">(b\\in \\{1,2\\})</span></p>

    <p class="text-gray-300">count  <span class="math">\\leftarrow 0</span>  ; guess  <span class="math">\\stackrel{\\S}{F}</span> <span class="math">[v(k)]</span></p>

    <p class="text-gray-300">Run  <span class="math">A</span>  on input  <span class="math">1^k</span> , replying to its oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">M</span>  to  <span class="math">\\mathsf{TG}(K, \\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname{Tag} \\stackrel{\\S}{\\leftarrow} \\mathsf{TG}(K, M)</span> ;  <span class="math">\\boxed{\\mathrm{TAGSET}[M] \\leftarrow \\mathrm{TAGSET}[M] \\cup \\{\\mathrm{Tag}\\}}</span> ; Return Tag to  <span class="math">A</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">M</span> , Tag to  <span class="math">\\mathsf{VF}(K, \\cdot, \\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300">count  <span class="math">\\leftarrow</span>  count + 1</p>

    <p class="text-gray-300">If (count &gt; guess) then Halt</p>

    <p class="text-gray-300">If (Tag  <span class="math">\\in</span>  TAGSET[M]) then return 1 to  <span class="math">A</span></p>

    <p class="text-gray-300">If (count &lt; guess) then return 0 to  <span class="math">A</span></p>

    <p class="text-gray-300">If (count = guess) then  <span class="math">d \\gets \\mathsf{VF}(K, M, \\mathsf{Tag})</span> ; Halt</p>

    <p class="text-gray-300">Figure 3: UF-1 adversaries  <span class="math">B_{1}, B_{2}</span>  derived from UF-M adversary  <span class="math">A</span> . Adversary  <span class="math">B_{1}</span>  omits the boxed statements while  <span class="math">B_{2}</span>  includes them.</p>

    <p class="text-gray-300">its tagging oracle, getting back a tag Tag, and is then capable of modifying Tag to some different value Tag such that  <span class="math">\\mathsf{VF}(K,M,\\overline{\\mathsf{Tag}}) = 1</span> . Let it then make query  <span class="math">M</span> ,  <span class="math">\\overline{\\mathsf{Tag}}</span>  to its verification oracle. As before, imagine that, after this, it makes another verification oracle query  <span class="math">M&#x27;</span> ,  <span class="math">\\mathsf{Tag}&#x27;</span>  that is valid, with  <span class="math">M&#x27; \\neq M</span> , so that it wins with probability one. Now, again,  <span class="math">B_2</span> 's simulation is inaccurate, because (in the case guess  <span class="math">\\geq 2</span> ) the verification oracle would have returned 1 in answer to  <span class="math">A</span> 's first query to it, but  <span class="math">B_2</span>  returns 0 to  <span class="math">A</span>  as the answer. So  <span class="math">B_2</span> 's advantage is 0.</p>

    <p class="text-gray-300">This time, it is not clear how to fix  <span class="math">B_{2}</span> , because in general it is not clear how to detect whether  <span class="math">\\overline{Tag}</span>  is a valid tag for  <span class="math">M</span>  without querying the verification oracle. Theorem 4.1 implies that this difficulty is not surmountable. On the other hand Theorem 5.1 shows that if  <span class="math">\\Pi</span>  was SUF-1 rather than merely UF-1 then this problem can be overcome to show that  <span class="math">\\Pi</span>  is also SUF-M.</p>

    <p class="text-gray-300">The above discussion leaves open the question of whether  <span class="math">\\mathrm{UF - 1}\\Rightarrow \\mathrm{UF - M}</span>  or not. Perhaps the proof could be patched? The following theorem implies that it cannot, because the underlying claim is simply not true.</p>

    <p class="text-gray-300">Theorem 4.1 [UF-1  <span class="math">\\nRightarrow</span>  UF-M] Assume there exists a UF-1-secure ma-scheme. Then there exists a UF-1-secure ma-scheme that is not UF-M-secure.</p>

    <p class="text-gray-300">The rest of this section is devoted to a proof of Theorem 4.1. By assumption there exists a UF-1-secure ma-scheme  <span class="math">\\Pi = (\\mathsf{TG},\\mathsf{VF})</span> . Let  <span class="math">l</span>  be its key-length. We build from it the ma-scheme  <span class="math">\\overline{\\Pi} = (\\overline{\\mathsf{MAC}},\\overline{\\mathsf{VF}})</span>  whose constituent algorithms are specified below:</p>

    <p class="text-gray-300">Algorithm  <span class="math">\\overline{\\mathsf{MAC}} (K,M)</span>  Algorithm  <span class="math">\\overline{\\mathsf{VF}} (K,M,\\overline{\\mathsf{Tag}})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tag  <span class="math">\\leftarrow</span>  TG(K,M) Parse Tag as Tag  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle i\\rangle<span class="math">  where  </span>i\\in \\{0,1,\\dots ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> </span>T a g\\gets T a g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle 0\\rangle<span class="math"> </span>d\\gets \\mathsf{VF}(K,M,\\mathsf{T a g})<span class="math">  Return Tag If  </span>(d = 0<span class="math">  or  </span>i = 0)<span class="math">  then return  </span>d<span class="math">  If  </span>(d = 1<span class="math">  and  </span>i\\geq 1)<span class="math">  then return  </span>K[i]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recall that  <span class="math">K[i]</span>  denotes the  <span class="math">i</span> -th bit of the key  <span class="math">K</span> . The key-length of the new scheme is also  <span class="math">l</span> . We first note that the scheme satisfies the completeness condition. Indeed, if  <span class="math">\\overline{Tag}</span>  is an output of</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\overline{\\mathsf{MAC}}(K,M)</span> then it has the form $Tag\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle i\\rangle<span class="math"> with </span>i = 0<span class="math">. Thus the first “If” statement of </span>\\overline{\\mathsf{VF}}(K,M,\\overline{Tag})<span class="math"> applies and returns </span>d<span class="math">, which is 1 by completeness of </span>\\Pi<span class="math">. Now we present an attack to show </span>\\overline{\\Pi}$ is not secure against an adversary making more than one query to its verification oracle.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Claim 4.2</strong> <span class="math">\\overline{\\Pi}</span> is not UF-M-secure.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Consider the following UF-M-adversary <span class="math">\\overline{A}</span> against <span class="math">\\overline{\\Pi}</span>:</p>

    <p class="text-gray-300"><strong>Adversary</strong> <span class="math">\\overline{A}^{\\overline{\\mathsf{MAC}}(K,\\cdot),\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)}(1^k)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">M_1</span> be any message and let <span class="math">\\overline{Tag}_1 \\stackrel{\\text{\\</span>}}{\\leftarrow} \\overline{\\mathsf{MAC}}(K, M_1)$</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Parse <span class="math">\\overline{Tag}_1</span> as $Tag_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle 0\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">M_2</span> be any message different from <span class="math">M_1</span></li>

      <li><span class="math">\\overline{Tag}_2 \\stackrel{\\text{\\</span>}}{\\leftarrow} \\overline{\\mathsf{MAC}}(L, M_2)<span class="math">; </span>d \\gets \\overline{\\mathsf{VF}}(K, M_2, \\overline{Tag}_2)$</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adversary <span class="math">\\overline{A}</span> obtains the tag of a message <span class="math">M_1</span> using its tagging oracle. The definition of the algorithm <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span> then tells us that, above, <span class="math">L[i] = K[i]</span> is the <span class="math">i</span>-th bit of the key <span class="math">K</span> for all $i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">. In other words, </span>\\overline{A}<span class="math"> has succeeded in recovering the key. Then it can, of course, easily win, by forging the tag of some new message </span>M_2<span class="math">. (Note that its computation of </span>\\overline{Tag}_2<span class="math"> is not an oracle query. </span>\\overline{A}<span class="math"> simply runs algorithm </span>\\overline{\\mathsf{MAC}}<span class="math"> with key </span>L<span class="math"> and message </span>M_2<span class="math">.) Thus </span>\\mathbf{Adv}_{\\overline{\\Pi},\\overline{A}}^{\\mathrm{UF-M}}(k) = 1<span class="math">. Since </span>\\overline{A}$ is polynomial-time, the claim is justified.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next we show that <span class="math">\\overline{\\Pi}</span> retains the UF-1 security of <span class="math">\\Pi</span>. The intuition is simple. In order to make <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span> accept, an adversary must have a message-tag pair that is valid for <span class="math">\\mathsf{VF}(K,\\cdot,\\cdot)</span>. On the other hand, being limited to one verification oracle query, it cannot make any use of any information that the verification oracle returns in answer to this query, since its game is effectively over once the query is made. Here now is the formal claim and proof.</p>

    <p class="text-gray-300"><strong>Claim 4.3</strong> <span class="math">\\overline{\\Pi}</span> is UF-1-secure.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Let <span class="math">\\overline{A}</span> be any polynomial-time UF-1-adversary attacking <span class="math">\\overline{\\Pi}</span>. We can assume it makes exactly one query to its verification oracle. We construct a polynomial-time UF-1 adversary <span class="math">A</span> attacking <span class="math">\\Pi</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{\\overline{\\Pi},\\overline{A}}^{\\mathrm{UF-1}}(k) \\leq \\mathbf{Adv}_{\\Pi,A}^{\\mathrm{UF-1}}(k). \\tag{1}</span></div>

    <p class="text-gray-300">Here is how <span class="math">A</span> works:</p>

    <p class="text-gray-300"><strong>Adversary</strong> <span class="math">A^{\\mathsf{TG}(K,\\cdot),\\mathsf{VF}(K,\\cdot,\\cdot)}(1^k)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\overline{A}</span> on input <span class="math">1^k</span>, replying to its oracle queries as follows:</li>

      <li>When <span class="math">\\overline{A}</span> makes a query <span class="math">M</span> to <span class="math">\\overline{\\mathsf{MAC}}(K,\\cdot)</span> do</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tag \\stackrel{\\text{\\$}}{\\leftarrow} \\mathsf{TG}(K, M); \\overline{Tag} \\gets Tag\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle 0\\rangle; \\text{Return } \\overline{Tag} \\text{ to } \\overline{A}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\overline{A}</span> makes a query <span class="math">M</span>, <span class="math">\\overline{Tag}</span> to <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span> do</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Parse } \\overline{Tag} \\text{ as } Tag\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle i\\rangle \\text{ where } i \\in \\{0, 1, \\ldots, k\\}; d \\gets \\mathsf{VF}(K, M, Tag); \\text{ Halt}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">A</span> does not return to <span class="math">\\overline{A}</span> any answer to <span class="math">\\overline{A}</span>'s (unique) verification-oracle query. (Not knowing <span class="math">K</span>, it would not know how). It simply uses this query to make its own verification-oracle query, and halts. Equation (1) is true because <span class="math">A</span>'s simulation of replies to queries of the tagging oracle is perfect, and also because $\\overline{\\mathsf{VF}}(K,M, Tag\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle i\\rangle)<span class="math"> returns 1 only if </span>\\mathsf{VF}(K,M, Tag)$ returns 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This concludes the proof of Theorem 4.1. We now make some remarks that help relate this result to upcoming ones.</p>

    <p class="text-gray-300"><strong>Remark 4.4</strong> The ma-scheme <span class="math">\\overline{\\Pi}</span> of our counter-example is not a MAC. Although <span class="math">\\overline{\\mathsf{MAC}}(K,\\cdot)</span> is deterministic, the second requirement of MACs is violated: verification <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span> is not done by recomputing <span class="math">\\overline{\\mathsf{MAC}}(K,\\cdot)</span> and comparing it with an input tag. This is relevant because otherwise we could contradict Proposition 6.1.</p>

    <p class="text-gray-300"><strong>Remark 4.5</strong> The ma-scheme <span class="math">\\overline{\\Pi}</span> of our counter-example is not SUF-1 due to the following adversary:</p>

    <p class="text-gray-300">Adversary <span class="math">\\overline{A}^{\\overline{\\mathsf{MAC}}(K,\\cdot),\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)}(1^{k})</span></p>

    <p class="text-gray-300">Let <span class="math">M</span> be any message and let <span class="math">\\overline{Tag} \\leftarrow \\overline{\\mathsf{MAC}}(K,M_1)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parse <span class="math">\\overline{Tag}</span> as $Tag\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle 0\\rangle<span class="math">; </span>d \\leftarrow \\overline{\\mathsf{VF}}(K,M, Tag\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle 1\\rangle)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The verification oracle accepts if <span class="math">K[1] = 1</span>. Since <span class="math">K</span> is chosen at random we have <span class="math">\\mathbf{Adv}_{\\overline{\\Pi},A}^{\\mathrm{SUF - 1}}(k) = 1/2</span>. This is relevant because otherwise we would contradict Corollary 5.2.</p>

    <p class="text-gray-300">In contrast to the case of standard unforgeability, under the strong unforgeability definition, the single and multiple verification query versions are equivalent. We prove the equivalence and also state the quantitative relation between the advantages, since this is important for practical applications.</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> [SUF-1 <span class="math">\\Rightarrow</span> SUF-M] Let <span class="math">\\Pi = (\\mathsf{TG},\\mathsf{VF})</span> be a ma-scheme. Let <span class="math">A</span> be an adversary making at most <span class="math">v(\\cdot)</span> verification queries. Then there exists an adversary <span class="math">B</span>, making only one verification query, such that for all <span class="math">k \\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{\\Pi,A}^{\\mathrm{SUF - M}}(k) \\leq v(k) \\cdot \\mathbf{Adv}_{\\Pi,B}^{\\mathrm{SUF - 1}}(k). \\tag{2}</span></div>

    <p class="text-gray-300">Furthermore, the number of tagging queries made by <span class="math">B</span> is the same as the number made by <span class="math">A</span>, and the running time of <span class="math">B</span> is that of <span class="math">A</span> plus <span class="math">O((v + t)\\tau)</span> where <span class="math">t(\\cdot)</span> is a bound on the number of tagging queries made by <span class="math">A</span> and <span class="math">\\tau(\\cdot)</span> is a bound on the lengths of messages and tags in <span class="math">A</span>'s oracle queries.</p>

    <p class="text-gray-300">The following is immediate:</p>

    <p class="text-gray-300"><strong>Corollary 5.2</strong> [SUF-1 <span class="math">\\Rightarrow</span> SUF-M] If a ma-scheme is SUF-1 secure then it is also SUF-M secure.</p>

    <p class="text-gray-300">Since the relations <span class="math">\\mathrm{SUF - M} \\Rightarrow \\mathrm{UF - M}</span> and <span class="math">\\mathrm{UF - M} \\Rightarrow \\mathrm{UF - 1}</span> are trivial, it follows that a ma-scheme that is SUF-1 secure is also <span class="math">\\mathrm{SUF - M}, \\mathrm{UF - M}</span> and <span class="math">\\mathrm{UF - 1}</span> secure, meaning meets all the four notions we have considered.</p>

    <p class="text-gray-300"><strong>Proof of Theorem 5.1:</strong> The required adversary <span class="math">B</span> is exactly the one called <span class="math">B_{2}</span> in Figure 3. For the analysis, let <span class="math">(M_1, Tag_1), (M_2, Tag_2), \\ldots</span> denote the verification-oracle queries made by <span class="math">A</span> in <span class="math">\\mathbf{Exp}_{\\Pi,A}^{\\mathrm{SUF - M}}(k)</span>. Let the random variable <span class="math">I</span> take value the smallest index <span class="math">i</span> such that <span class="math">\\mathsf{VF}(K, M_i, Tag_i) = 1</span> and <span class="math">Tag_i \\notin \\mathrm{TagSet}[M_i]</span> if such an index exists, and 0 otherwise.</p>

    <p class="text-gray-300">In the simulation of <span class="math">A</span> provided by <span class="math">B</span>, we notice that if <span class="math">\\mathsf{guess} \\leq I</span>, then for all <span class="math">1 \\leq i &amp;lt; \\mathsf{guess}</span>, the reply provided by <span class="math">B</span> to the <span class="math">i</span>-th verification-oracle query of <span class="math">A</span> is correct, meaning equals <span class="math">\\mathsf{VF}(K, M_i, Tag_i)</span>. On the other hand the random choice of <span class="math">\\mathsf{guess}</span> is independent of the view of <span class="math">A</span> as long as <span class="math">B</span> has not halted. So</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{\\Pi,B}^{\\mathrm{SUF - 1}}(k) = \\Pr \\left[ \\mathsf{guess} = I \\wedge I \\geq 1 \\right] \\geq \\Pr \\left[ \\mathsf{guess} = I \\right] \\cdot \\Pr \\left[ I \\geq 1 \\right] = \\frac{1}{v(k)} \\cdot \\mathbf{Adv}_{\\Pi,A}^{\\mathrm{SUF - M}}(k).</span></div>

    <p class="text-gray-300">This establishes Equation (2).</p>

    <h2 id="sec-11" class="text-2xl font-bold">6 Classes of <span class="math">\\mathsf{SUF-1}</span> ma-schemes</h2>

    <p class="text-gray-300">Towards applying Corollary 5.2 to existing ma-schemes, we establish SUF-1 for certain important classes.</p>

    <p class="text-gray-300">MACs. Suppose ma-scheme <span class="math">\\Pi=(\\mathsf{TG},\\mathsf{VF})</span> is a MAC. This implies that for any message <span class="math">M</span> and key <span class="math">K</span> there is only one tag that <span class="math">\\mathsf{VF}</span> will accept, namely <span class="math">\\mathsf{TG}(K,M)</span>. Thus:</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proposition 6.1</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be a UF-1 MAC. Then it is also SUF-1.</p>

    <p class="text-gray-300">So by Corollary 5.2, any UF-1 MAC is UF-M and SUF-M. As an application, since HMAC is proven UF-1 in <em>[1]</em>, the above shows it is UF-M and SUF-M.</p>

    <p class="text-gray-300">PRF-based MACs. Any PRF-based MAC is UF-M secure <em>[5]</em>, and, being a MAC, we can then apply the above to get UF-M, SUF-M security. It is worth stating the concrete security of the reduction underlying this easy result, however, since it provides the backdrop for our later improvement:</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proposition 6.2</h6>

    <p class="text-gray-300">[PRF-based MACs are SUF-M, basic reduction] Let <span class="math">F</span> be a PRF with output-length <span class="math">\\tau(\\cdot)</span>. Let <span class="math">A</span> be an adversary making at most <span class="math">v(\\cdot)</span> verification queries. Then there exists a PRF adversary <span class="math">B</span> such that for any <span class="math">k\\in\\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\text{SUF-M}}_{\\Pi[F],A}(k)\\ \\leq\\ \\frac{v(k)}{2^{\\tau(k)}}+v(k)\\cdot\\mathbf{Adv}^{\\text{PRF}}_{F,B}(k)\\;.</span> (3)</p>

    <p class="text-gray-300">Furthermore, the number of oracle queries made by <span class="math">B</span> is at most <span class="math">t(\\cdot)+1</span>, and the running time of <span class="math">B</span> is that of <span class="math">A</span> plus <span class="math">O((v+t)\\tau)</span>, where <span class="math">t(\\cdot)</span> is a bound on the number of tagging queries made by <span class="math">A</span>.</p>

    <p class="text-gray-300">As an application, various CBC-MACs <em>[5, 10, 22]</em>, PMAC <em>[11]</em>, TMAC <em>[17]</em> and OMAC <em>[18]</em> are UF-M and SUF-M. (But Proposition 7.3 yields better results.)</p>

    <p class="text-gray-300">CW-ma-schemes. The Carter-Wegman paradigm <em>[25]</em> is now yielding the most efficient ma-schemes. UMAC <em>[8, 9]</em> is the canonical example. These schemes are nonce-based (the nonce is either a counter or a random number) and in particular are not MACs in the sense defined above, so the above does not apply. Via a closer look at the proof of the UF-1 security <em>[21, 23, 16, 8, 9]</em>, however, one can establish SUF-1 as well. Details follow. For simplicity we consider only the case where the nonce is a counter.</p>

    <p class="text-gray-300">Let <span class="math">H</span> be a family of functions with domain <span class="math">\\{D_{k}\\}_{k\\in\\mathbb{N}}</span>, output length <span class="math">\\tau(\\cdot)</span> and key-length <span class="math">l_{H}(\\cdot)</span>. Let <span class="math">F</span> be a family of functions with domain <span class="math">\\{\\{0,1\\}^{k}\\}_{k\\in\\mathbb{N}}</span>, output length <span class="math">\\tau(\\cdot)</span> and key-length <span class="math">l_{F}(\\cdot)</span>. We associate to them the counter-based CW ma-scheme <span class="math">\\Pi[H,F]</span> which has key-length <span class="math">l_{H}(\\cdot)+l_{F}(\\cdot)</span> and the following tagging and verification algorithms. Below, <span class="math">N</span> is a <span class="math">k</span>-bit counter which is initially <span class="math">0</span> and then incremented with each invocation of <span class="math">\\mathsf{TG}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm $\\mathsf{TG}(HK\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FK,M)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">N\\leftarrow N+1</span> <span class="math">\\text{Tag}\\leftarrow(N,F(FK,N)\\oplus H(HK,M))</span> <span class="math">\\text{Return}\\ \\text{Tag}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm $\\mathsf{VF}(HK\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FK,M,\\text{Tag})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{Parse}\\ \\text{Tag}\\ \\text{as}\\ (N,\\sigma)</span> <span class="math">\\sigma^{\\prime}\\leftarrow F(FK,N)\\oplus H(HK,M)</span> <span class="math">\\text{If}\\ (\\sigma=\\sigma^{\\prime})\\ \\text{then return 1 else return 0}</span></p>

    <p class="text-gray-300">The message space is the domain of <span class="math">H</span>. The proof of the following is in Appendix A.1.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proposition 6.3</h6>

    <p class="text-gray-300">[Security of CW-ma-schemes] Let families <span class="math">H,F</span> be as above, both with output-length <span class="math">\\tau(\\cdot)</span>. Assume <span class="math">H</span> is an <span class="math">\\epsilon(\\cdot)</span>-AXU family and <span class="math">F</span> is a PRF. Let <span class="math">\\Pi[H,F]</span> be the associated CW-ma-scheme as above. Let <span class="math">A</span> be any adversary who makes at most <span class="math">t(k)&lt;2^{k}</span> queries to its tagging oracle and one query to its verification oracle. Then there exists a PRF adversary <span class="math">B</span> such that for all <span class="math">k\\in\\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\text{SUF-1}}_{\\Pi[H,F],A}(k)\\ \\leq\\ 2^{-\\tau(k)}+\\epsilon(k)+\\mathbf{Adv}^{\\text{PRF}}_{F,B}(k)\\;.</span> (4)</p>

    <p class="text-gray-300">Furthermore, the number of oracle queries made by <span class="math">B</span> is <span class="math">t(\\cdot)+1</span> and the running time of <span class="math">B</span> is that of <span class="math">A</span> plus <span class="math">O(t\\tau)</span>. <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">Since UMAC <em>[8, 9]</em> and MMH-MAC <em>[16]</em> were shown to be UF-1 in the cited papers, the above together with Corollary 5.2 shows they are UF-M and SUF-M.</p>

    <h2 id="sec-15" class="text-2xl font-bold">7 Reduction tightness and concrete security improvements</h2>

    <p class="text-gray-300">Using Theorem 5.1 to establish UF-M and SUF-M security of ma-schemes results, as per Equation (2), in a factor <span class="math">v(\\cdot)</span> loss in the advantage. As we have discussed in Section 1.4, this can be appreciable in practice. This section looks into getting better reductions.</p>

    <p class="text-gray-300">No better SUF-1 <span class="math">\\Rightarrow</span> SUF-M reduction. The first, natural question to ask is whether Theorem 5.1 represents the best possible reduction, or whether there is a better one. We claim there is no better one, even for the special case of ma-schemes that are MACs. To establish this we begin with the following, whose proof is in Appendix A.2:</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 7.1</h6>

    <p class="text-gray-300">Assume PRFs exist. Then for any polynomial <span class="math">v(\\cdot)</span> there exists a MAC <span class="math">\\Pi</span> such that</p>

    <p class="text-gray-300">There exists a polynomial-time adversary <span class="math">A</span> that makes at most <span class="math">v(\\cdot)</span> verification queries and achieves <span class="math">\\mathbf{Adv}^{\\text{SUF-M}}_{\\Pi,A}(k)=1</span>, and For any polynomial-time adversary <span class="math">B</span> making only one verification query, there is a negligible function <span class="math">s(\\cdot)</span> such that <span class="math">\\mathbf{Adv}^{\\text{SUF-1}}_{\\Pi,B}(k)\\leq 2/v(k)+s(k)</span> for all <span class="math">k\\in\\mathbb{N}</span>. <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">Now let us see why this Proposition shows that the reduction of Theorem 5.1 cannot be improved. View a reduction as a transform <span class="math">\\mathcal{B}</span> that given a ma-scheme <span class="math">\\Pi</span>, a polynomial <span class="math">v</span> and a polynomial-time adversary <span class="math">A</span> making <span class="math">v</span> verification queries, outputs a polynomial-time SUF-1 adversary <span class="math">\\mathcal{B}(\\Pi,v,A)</span>. We say that <span class="math">\\mathcal{B}</span> has <em>reduction factor</em> <span class="math">\\phi(\\cdot)</span> if</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\text{SUF-1}}_{\\Pi,\\,\\mathcal{B}(\\Pi,v,A)}(k)\\ \\geq\\ \\phi(v(k))\\cdot\\mathbf{Adv}^{\\text{SUF-M}}_{\\Pi,A}(k)</span></p>

    <p class="text-gray-300">for all <span class="math">\\Pi,A</span> and <span class="math">k</span>. Theorem 5.1 provides a reduction with reduction factor <span class="math">\\phi(n)=1/n</span>. Now we claim:</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Corollary 7.2</h6>

    <p class="text-gray-300">If PRFs exist then the reduction factor of any reduction is <span class="math">O(1/n)</span>. <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">So no reduction has a reduction factor that is better than the one of Theorem 5.1 by more than a constant factor. The proof of Corollary 7.2 is in Appendix A.2.</p>

    <p class="text-gray-300">One might observe that the MAC of Proposition 7.1 is neither SUF-1 nor SUF-M secure. This did not preclude it being useful with regard to establishing the un-improvability of the reduction of Theorem 5.1, for the ma-scheme in that theorem is also not assumed to be secure in any sense. Indeed, a reduction transforms an adversary of one type into an adversary of another type with some relation between the advantages, regardless of whether the underlying scheme is secure or not, so the tightness of its reduction factor may be assessed via its performance on insecure schemes.</p>

    <p class="text-gray-300">Improvements for PRF based MACs. Although the above precludes improved concrete security results for MACs in general, we note that one can improve the reduction for PRF-based MACs given in Proposition 6.2 to show the following, whose proof is in Appendix A.3:</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proposition 7.3</h6>

    <p class="text-gray-300"><em>[x12]</em> [PRF-based MACs are SUF-M, improved version] Let <span class="math">F</span> be a PRF with output-length <span class="math">\\tau(\\cdot)</span>. Let <span class="math">A</span> be an adversary making at most <span class="math">v(\\cdot)</span> verification queries. Then there exists a PRF adversary <span class="math">B</span> such that for any <span class="math">k\\in\\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\text{SUF-M}}_{\\Pi[F],A}(k)\\ \\leq\\ \\frac{v(k)}{2^{\\tau(k)}}+\\mathbf{Adv}^{\\text{PRF}}_{F,B}(k)\\;.</span> (5)</p>

    <p class="text-gray-300">Furthermore, the number of oracle queries made by <span class="math">B</span> is at most <span class="math">v(\\cdot)+t(\\cdot)</span>, and the running time of <span class="math">B</span> is that of <span class="math">A</span> plus <span class="math">O((v+t)\\tau)</span>, where <span class="math">t(\\cdot)</span> is a bound on the number of tagging queries made by <span class="math">A</span>.</p>

    <p class="text-gray-300">The improvement relative to Proposition 6.2 is to eliminate the factor of <span class="math">v(k)</span> multiplying <span class="math">\\mathbf{Adv}^{\\text{PRF}}_{F,B}(k)</span> at the cost of allowing <span class="math">B</span> an extra <span class="math">v(\\cdot)</span> verification queries. However, typically <span class="math">t(\\cdot)\\geq v(\\cdot)</span>, so the number of oracle queries of <span class="math">B</span> in fact only increases by a constant factor and the improvement is essentially for free. Now, under typical choices of <span class="math">\\tau(\\cdot)</span>, the <span class="math">v(k)2^{-\\tau(k)}</span> term is negligible compared to the other term, so roughly the bound is better than that of Proposition 6.2 by a factor <span class="math">v(k)</span>. This forms the basis for the examples, discussed in Section 1.4, which showed that the improvement has appreciable practical impact. We note that as applications we obtain UF-M, SUF-M security for the CBC-MACs <em>[5, 10, 22]</em>, PMAC <em>[11]</em>, TMAC <em>[17]</em> and OMAC <em>[18]</em> with concrete security that is better than that envisaged at the time people believed UF-<span class="math">1\\Rightarrow</span> UF-M, even though we now know this implication is not even true.</p>

    <h2 id="sec-19" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Bodo Moeller for comments on a previous draft.</p>

    <h2 id="sec-20" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Bellare, R. Canetti and H. Krawczyk. Keying hash functions for message authentication. Advances in Cryptology – CRYPTO ’96, Lecture Notes in Computer Science Vol. 1109, N. Koblitz ed., Springer-Verlag, 1996.</li>

      <li>[2] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. Advances in Cryptology – CRYPTO ’98, Lecture Notes in Computer Science Vol. 1462, H. Krawczyk ed., Springer-Verlag, 1998.</li>

      <li>[3] M. Bellare, O. Goldreich and H. Krawczyk. Stateless evaluation of pseudorandom functions: Security beyond the birthday barrier. Advances in Cryptology – CRYPTO ’96, Lecture Notes in Computer Science Vol. 1109, N. Koblitz ed., Springer-Verlag, 1996.</li>

      <li>[4] M. Bellare, R. Guérin and P. Rogaway. XOR MACs: New methods for message authentication using finite pseudorandom functions. Advances in Cryptology – CRYPTO ’95, Lecture Notes in Computer Science Vol. 963, D. Coppersmith ed., Springer-Verlag, 1995.</li>

      <li>[5] M. Bellare, J. Kilian and P. Rogaway. The security of the cipher block chaining message authentication code. Journal of Computer and System Sciences, Vol. 61, No. 3, Dec 2000, pp. 362–399.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[6] M. Bellare and C. Namprempre. Authenticated encryption: Relations among notions and analysis of the generic composition paradigm. Advances in Cryptology – ASIACRYPT ’00, Lecture Notes in Computer Science Vol. 1976, T. Okamoto ed., Springer-Verlag, 2000.</p>

    <p class="text-gray-300">[7] M. Bellare and P. Rogaway. Encode-then-encipher encryption: How to exploit nonces or redundancy in plaintexts for efficient cryptography. Advances in Cryptology – ASIACRYPT ’00, Lecture Notes in Computer Science Vol. 1976, T. Okamoto ed., Springer-Verlag, 2000.</p>

    <p class="text-gray-300">[8] J. Black, S. Halevi, H. Krawczyk, T. Krovetz and P. Rogaway. UMAC: Fast and Secure Message Authentication. Advances in Cryptology – CRYPTO ’99, Lecture Notes in Computer Science Vol. 1666, M. Wiener ed., Springer-Verlag, 1999. [Preliminary version of [9]].</p>

    <p class="text-gray-300">[9] J. Black, S. Halevi, H. Krawczyk, T. Krovetz and P. Rogaway. UMAC: Fast and Secure Message Authentication. http://www.cs.ucdavis.edu/~rogaway/papers/umac-full.ps. [Full version of [8]].</p>

    <p class="text-gray-300">[10] J. BLACK AND P. ROGAWAY. CBC MACs for arbitrary-length messages: The three-key constructions. Advances in Cryptology – CRYPTO ’00, Lecture Notes in Computer Science Vol. 1880, M. Bellare ed., Springer-Verlag, 2000.</p>

    <p class="text-gray-300">[11] J. BLACK AND P. ROGAWAY. A block-cipher mode of operation for parallelizable message authentication. Advances in Cryptology – EUROCRYPT ’02, Lecture Notes in Computer Science Vol. 2332, L. Knudsen ed., Springer-Verlag, 2002.</p>

    <p class="text-gray-300">[12] D. DOLEV, C. DWORK, AND M. NAOR. Nonmalleable cryptography. SIAM Journal of Computing, Vol. 30, No. 2, 2000, pp. 391–437.</p>

    <p class="text-gray-300">[13] O. GOLDREICH. Foundations of Cryptography: Volume II, Basic applications. Cambridge University Press, 2004.</p>

    <p class="text-gray-300">[14] O. GOLDREICH, S. GOLDWASSER AND S. MICALI. How to construct random functions. Journal of the ACM, Vol. 33, No. 4, 1986, pp. 210–217.</p>

    <p class="text-gray-300">[15] S. GOLDWASSER, S. MICALI AND R. RIVEST. A digital signature scheme secure against adaptive chosen-message attacks. SIAM Journal of Computing, Vol. 17, No. 2, 1988, pp. 281–308.</p>

    <p class="text-gray-300">[16] S. HALEVI AND H. KRAWCZYK. MMH: Message authentication in software in the Gbit/sec rate. Fast Software Encryption ’97, Lecture Notes in Computer Science Vol. 1267, E. Biham ed., Springer-Verlag, 1997.</p>

    <p class="text-gray-300">[17] T. IWATA AND K. KUROSAWA. TMAC: Two-Key CBC MAC. Topics in Cryptology – CTRSA ’02, Lecture Notes in Computer Science Vol. 2271, B. Preneel ed., Springer-Verlag, 2002.</p>

    <p class="text-gray-300">[18] T. IWATA AND K. KUROSAWA. OMAC: One-key CBC MAC. Fast Software Encryption ’03, Lecture Notes in Computer Science Vol. 2887, T. Johansson ed., Springer-Verlag, 2003.</p>

    <p class="text-gray-300">[19] J. KATZ AND M. YUNG. Unforgeable encryption and chosen-ciphertext secure modes of operation. Fast Software Encryption ’00, Lecture Notes in Computer Science Vol. 1978, B. Schneier ed., Springer-Verlag, 2000.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">[20] E. Jaulmes, A. Joux and F. Valette. On the security of randomized CBC-MAC beyond the birthday paradox limit: A new construction. Fast Software Encryption ’02, Lecture Notes in Computer Science Vol. 2365, J. Daemen and V. Rijmen ed., Springer-Verlag, 2002.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[21] H. Krawczyk. LFSR-based hashing and authentication. Advances in Cryptology – CRYPTO ’94, Lecture Notes in Computer Science Vol. 839, Y. Desmedt ed., Springer-Verlag, 1994.</li>

      <li>[22] E. Petrank and C. Rackoff. CBC MAC for real-time data sources. Journal of Cryptology, Vol. 13, No. 3, 2000, pp. 315–338.</li>

      <li>[23] P. Rogaway. Bucket hashing and its application to fast message authentication. Jounral of Cryptology, Vol. 12, No. 2, 1999, pp. 91–115.</li>

      <li>[24] D. Stinson. Cryptography theory and practice, Second edition. Chapman and Hall/CRC, 2002.</li>

      <li>[25] M. Wegman and L. Carter. New hash functions and their use in authentication and set equality. Journal of Computer and System Sciences, Vol. 22, No. 3, 1981, pp. 265–279.</li>

    </ul>

    <h2 id="sec-21" class="text-2xl font-bold">Appendix A Proofs</h2>

    <p class="text-gray-300">This section provides proofs omitted from the body of the paper.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">A.1 Proof of Proposition 6.3</h3>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Proof of Proposition 6.3:</h4>

    <p class="text-gray-300">The main part of the security proof considers the thought experiment in which <span class="math">F(FK,\\cdot)</span> is replaced by a random function <span class="math">f(\\cdot)</span> with output-length <span class="math">\\tau(\\cdot)</span>. Formally, this means we consider the security of the ma-scheme <span class="math">\\Pi[H,R]</span> where <span class="math">R</span> is the family of all functions having the same domain and output-length as <span class="math">F</span>. We now bound <span class="math">\\mathbf{Adv}^{\\mathrm{SUF-1}}_{\\Pi[H,R],A}(k)</span>.</p>

    <p class="text-gray-300">By assumption <span class="math">A</span> makes at most <span class="math">2^{k}</span> tagging queries, thus the tagging oracle never replies to two queries with the same nonce. Let <span class="math">M,(N,S)</span> denote the single verification query made by <span class="math">A</span>. If the nonce <span class="math">N</span> is new, then clearly the probability that the tag is correct is at most <span class="math">2^{-\\tau(k)}</span> since <span class="math">f</span> has never before been invoked on input <span class="math">N</span>.</p>

    <p class="text-gray-300">However, there could have been a previous query <span class="math">M^{\\prime}</span> to the tagging oracle returning a tag of the form <span class="math">(N,S^{\\prime})</span>. If <span class="math">M^{\\prime}=M</span> then the only way that <span class="math">(N,S)</span> is a correct tag for <span class="math">M</span> is that <span class="math">S^{\\prime}=S</span>, so in this case there is no strong forgery. So assume <span class="math">M^{\\prime}\\neq M</span>. In that case the argument reduces to that of the UF-1 case. Namely, we have</p>

    <p class="text-gray-300"><span class="math">S\\oplus S^{\\prime}\\ =\\ (f(N)\\oplus h(M))\\oplus(f(N)\\oplus h(M^{\\prime}))=h(M)\\oplus h(M^{\\prime})</span></p>

    <p class="text-gray-300">and the probability that this can happen is at most <span class="math">\\epsilon(k)</span> by assumption that <span class="math">H</span> is <span class="math">\\epsilon(\\cdot)</span>-AXU. In summary</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathrm{SUF-1}}_{\\Pi[H,R],A}(k)\\ \\leq\\ 2^{-\\tau(k)}+\\epsilon(k)\\ .</span></p>

    <p class="text-gray-300">Now one can lift this to the statement of the Proposition, using the assumption that <span class="math">F</span> is a PRF, in a standard way.</p>

    <p class="text-gray-300">A.2 Proofs of Proposition 7.1 and Corollary 7.2</p>

    <p class="text-gray-300">Proof of Proposition 7.1: Let <span class="math">w(\\cdot) = \\lfloor \\log_2 v(\\cdot) \\rfloor</span>. Let <span class="math">F</span> be a PRF with output-length <span class="math">w(\\cdot)</span> and let <span class="math">\\Pi = \\Pi[F] = (\\mathsf{TG}, \\mathsf{VF})</span> be the associated PRF-based MAC, with message space the domain of <span class="math">F</span> and key-length that of <span class="math">F</span>. (Note by definition <span class="math">\\mathsf{TG} = F</span>.) Adversary <span class="math">A</span> works as follows:</p>

    <p class="text-gray-300">Adversary <span class="math">A^{\\mathsf{TG}(K,\\cdot),\\mathsf{VF}(K,\\cdot,\\cdot)}(1^{k})</span></p>

    <p class="text-gray-300">Let <span class="math">M</span> be an arbitrary message in the message space</p>

    <p class="text-gray-300">For each <span class="math">\\mathrm{Tag} \\in \\{0,1\\}^{w(k)}</span> do <span class="math">d(\\mathrm{Tag}) \\gets \\mathsf{VF}(K,M,\\mathrm{Tag})</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathsf{TG}(K,M) = F(K,M) \\in \\{0,1\\}^{w(k)}</span> we have <span class="math">\\mathbf{Adv}_{\\Pi,A}^{\\mathrm{SUF - M}}(k) = 1</span>. The number of verification queries made by <span class="math">A</span> is <span class="math">2^{w(k)} \\leq v(k)</span>. So we have item (1) of the Proposition. Now suppose <span class="math">B</span> is a polynomial-time adversary making only one verification query. We associate to it the polynomial-time PRF adversary <span class="math">D</span> that, given an oracle <span class="math">f(\\cdot)</span>, works as follows. It runs <span class="math">B</span> on input <span class="math">1^{k}</span>. When <span class="math">B</span> makes a query <span class="math">M</span> to its tagging oracle, <span class="math">D</span> returns <span class="math">f(M)</span> to <span class="math">B</span>. When <span class="math">B</span> makes a query <span class="math">M, \\mathrm{Tag}</span> to its verification oracle, <span class="math">D</span> halts, outputting 1 if <span class="math">f(M) = \\mathrm{Tag}</span> and <span class="math">M</span> was not a query to the tagging oracle, and outputting 0 otherwise. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ D ^ {F (K, \\cdot)} \\left(1 ^ {k}\\right) = 1 \\right] = \\mathbf {A d v} _ {\\Pi , B} ^ {\\mathrm {S U F - 1}} (k) \\quad \\text {and} \\quad \\Pr \\left[ B ^ {f (\\cdot)} \\left(1 ^ {k}\\right) = 1 \\right] \\leq \\frac {1}{2 ^ {w (k)}} \\leq \\frac {2}{v (k)},</span></div>

    <p class="text-gray-300">where in the first case the probability is over a random choice of <span class="math">K</span> and in the second over a random choice of function <span class="math">f</span>. So we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , B} ^ {\\mathrm {S U F - 1}} (k) \\leq \\frac {2}{v (k)} + \\mathbf {A d v} _ {F, B} ^ {\\mathrm {P R F}} (k).</span></div>

    <p class="text-gray-300">Since the last function is negligible, we have item (2) of the Proposition.</p>

    <p class="text-gray-300">Proof of Corollary 7.2: Let <span class="math">v(\\cdot)</span> be a polynomial and let <span class="math">\\Pi</span> be the MAC associated to it by Proposition 7.1. Let <span class="math">\\mathcal{B}</span> be a reduction with reduction factor <span class="math">\\phi</span>. Proposition 7.1 says there is a polynomial-time SUF-M adversary <span class="math">A</span>, making <span class="math">v(\\cdot)</span> verification queries, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , \\mathcal {B} (\\Pi , v, A)} ^ {\\mathrm {S U F - 1}} (k) \\leq \\frac {\\Theta (1)}{v (k)} = \\frac {\\Theta (1)}{v (k)} \\cdot \\mathbf {A d v} _ {\\Pi , A} ^ {\\mathrm {S U F - M}} (k)</span></div>

    <p class="text-gray-300">for all <span class="math">k</span>. So <span class="math">\\phi (n) = O(1 / n)</span>.</p>

    <h2 id="sec-24" class="text-2xl font-bold">A.3 Proof of Proposition 7.3</h2>

    <p class="text-gray-300">Proof of Proposition 7.3: Adversary <span class="math">B</span> is given input <span class="math">1^k</span> and an oracle <span class="math">f\\colon D_k\\to \\{0,1\\}^{\\tau (k)}</span>. It runs <span class="math">A</span> on input <span class="math">1^{k}</span>. When <span class="math">A</span> makes a query <span class="math">M</span> to its tagging oracle, <span class="math">B</span> responds with <span class="math">f(M)</span>. When <span class="math">A</span> makes a query <span class="math">M,\\mathrm{Tag}</span> to its verification oracle, <span class="math">B</span> returns 1 to <span class="math">A</span> if <span class="math">f(M) = \\mathrm{Tag}</span> and 0 otherwise. Finally, <span class="math">B</span> outputs 1 if <span class="math">A</span> succeeded in strong forgery, and 0 otherwise. (In the first case it is betting <span class="math">f</span> is an instance of <span class="math">F</span>, and in the second it is betting <span class="math">f</span> was chosen at random from <span class="math">\\mathsf{Maps}(D_k,\\{0,1\\}^{\\tau (k)})</span>. The analysis is standard.)</p>

    <h2 id="sec-25" class="text-2xl font-bold">B Results for authenticated encryption</h2>

    <p class="text-gray-300">An authenticated encryption scheme is a symmetric encryption scheme that simultaneously provides privacy and authenticity. We are not concerned here with the privacy. Let us state the definitions of authenticity we consider.</p>

    <p class="text-gray-300">Experiment  <span class="math">\\mathbf{Exp}_{\\Pi ,A}^{\\mathrm{type}}(k)</span></p>

    <p class="text-gray-300"><span class="math">K\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{l(k)};\\mathsf{count}\\leftarrow 0;\\mathsf{fp}\\leftarrow 0;\\mathsf{fc}\\leftarrow 0</span></p>

    <p class="text-gray-300">Run  <span class="math">A</span>  on input  <span class="math">1^k</span> , replying to its oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">M</span>  to  <span class="math">\\mathsf{Enc}_K(\\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">C \\leftarrow \\mathsf{Enc}_K(M)</span> ;  <span class="math">\\mathrm{CTXTSET}M \\leftarrow \\mathrm{CTXTSET}M \\cup \\{C\\}</span> ; Return  <span class="math">C</span>  to  <span class="math">A</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">C</span>  to  <span class="math">\\mathsf{De}^*(\\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">d\\gets \\mathsf{De}_K^* (C);\\mathsf{count}\\gets \\mathsf{count} + 1</span></p>

    <p class="text-gray-300">If  <span class="math">d = 1</span>  then</p>

    <p class="text-gray-300">If  <span class="math">\\mathrm{CTXTSET}M = \\emptyset</span>  then  <span class="math">\\mathsf{fp}\\gets 1</span> ; If  <span class="math">C\\notin \\mathrm{CTXTSET}M</span>  then  <span class="math">\\mathsf{fc}\\gets 1</span></p>

    <p class="text-gray-300">Return  <span class="math">d</span>  to  <span class="math">A</span></p>

    <p class="text-gray-300">If (type =INT-PTXT-1) then return (count = 1) ∧ fp</p>

    <p class="text-gray-300">If (type =INT-PTXT-M) then return fp</p>

    <p class="text-gray-300">If (type =INT-CTXT-1) then return (count = 1) ∧ fc</p>

    <p class="text-gray-300">If (type =INT-CTXT-M) then return fc</p>

    <p class="text-gray-300">Figure 4: Experiment defining four notions of security of authenticated encryption scheme.</p>

    <p class="text-gray-300">FOUR SECURITY NOTIONS. A symmetric encryption scheme  <span class="math">\\Pi = (\\mathsf{Kg},\\mathsf{Enc},\\mathsf{De})</span>  is specified as usual via its key-generation, encryption and decryption algorithms. The last either returns a string or the symbol  <span class="math">\\perp</span>  to indicate rejection. The scheme has an associated key-length  <span class="math">l(\\cdot)</span> . We associate to the scheme a verification algorithm  <span class="math">\\mathsf{De}^<em></span>  that on input a key  <span class="math">K</span>  and ciphertext  <span class="math">C</span>  runs  <span class="math">\\mathsf{De}(K,C)</span> , returning 0 if the result is  <span class="math">\\perp</span>  and 1 otherwise. We now formally define four notions of integrity. (We use the term integrity synonymously with authenticity.) Let type  <span class="math">\\in</span>  {INT-PTXT-1, INT-PTXT-M, INT-CTXT-1, INT-CTXT-M}. Let  <span class="math">A</span>  be an adversary with access to an encryption oracle  <span class="math">\\mathsf{Enc}(K,\\cdot)</span>  and a verification oracle  <span class="math">\\mathsf{De}^</em>(K,\\cdot)</span> , and let  <span class="math">k\\in \\mathbb{N}</span> . We define the experiment depicted in Figure 4. We let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , A} ^ {\\text {t y p e}} (k) = \\Pr \\left[ \\mathbf {E x p} _ {\\Pi , A} ^ {\\text {t y p e}} (k) = 1 \\right]</span></div>

    <p class="text-gray-300">denote the winning probability for  <span class="math">A</span>  in the experiment in question. We say that  <span class="math">\\Pi</span>  is type-secure if the function  <span class="math">\\mathbf{Adv}_{\\Pi, A}^{\\mathrm{type}}(\\cdot)</span>  is negligible for any polynomial time adversary  <span class="math">A</span> .</p>

    <p class="text-gray-300">In the experiment, access to the encryption oracle allows the adversary to mount a chosen-message attack. The adversary succeeds if it makes the verification oracle accept an "illegitimate ciphertext." Integrity of plaintexts calls a ciphertext illegitimate if the corresponding plaintext was never queried to the encryption oracle, while integrity of ciphertexts calls a ciphertext illegitimate if it was never returned by the encryption oracle. In each case one may allow either one or many verification queries, giving rise to the four notions we have defined. Historically, INT-PTXT-M and INT-CTXT-M are from [6] while INT-CTXT-1 is from [19, 7]. INT-PTXT-1 is new.</p>

    <p class="text-gray-300">RESULTS. We depict in Figure B the relations between the four notions of integrity for symmetric encryption schemes. As usual, arrows represent implications and barred arrows represent separations. INT-CTXT-M  <span class="math">\\Rightarrow</span>  INT-PTXT-M and INT-PTXT-M  <span class="math">\\nRightarrow</span>  INT-CTXT-M were known [6], and easily extend to show INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-PTXT-1 and INT-PTXT-1  <span class="math">\\nRightarrow</span>  INT-CTXT-1. Our main results are INT-PTXT-1  <span class="math">\\nRightarrow</span>  INT-PTXT-M and INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M. We also show that the latter reduction is tight. Formal statements follow.</p>

    <p class="text-gray-300">Theorem B.1 [INT-PTXT-1  <span class="math">\\nRightarrow</span>  INT-PTXT-M] Assume there exists an INT-PTXT-1-secure sym</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 5: An arrow represents an implication and a barred arrow represents a separation.</p>

    <p class="text-gray-300">metric encryption scheme. Then there exists an INT-PTXT-1-secure symmetric encryption scheme which is not INT-PTXT-M-secure.</p>

    <p class="text-gray-300">Proof: By assumption there exists a INT-PTXT-1-secure symmetric key encryption scheme  <span class="math">\\Pi = (\\mathsf{Kg},\\mathsf{Enc},\\mathsf{De})</span> . The counterexample is the symmetric key encryption scheme  <span class="math">\\overline{\\Pi} = (\\overline{\\mathsf{Kg}},\\overline{\\mathsf{Enc}},\\overline{\\mathsf{De}})</span>  whose key-generation algorithm  <span class="math">\\overline{\\mathsf{Kg}}</span>  is the same as  <span class="math">\\mathsf{Kg}</span>  and whose encryption and decryption algorithms are specified below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm Enc(K,M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm De(K,bar)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">c← Enc(K,M)</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse c as c</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><i> where i ∈ {0,1,...,</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">barc← c</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><0></td>

            <td class="px-3 py-2 border-b border-gray-700">M← De(K,c)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return bar</td>

            <td class="px-3 py-2 border-b border-gray-700">If (M = ⊥ or i = 0) then return M</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | If (M ≠ ⊥ and i ≥ 1 and K[i] = 1) then return M  |</p>

    <p class="text-gray-300">|   | If (M ≠ ⊥ and i ≥ 1 and K[i] = 0) then return ⊥  |</p>

    <p class="text-gray-300">This encryption scheme has the following 2 properties:</p>

    <p class="text-gray-300">(1) There exists polynomial-time adversary  <span class="math">\\overline{A}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\overline {{\\Pi , A}}} ^ {\\mathrm {I N T - P T X T - M}} (k) = 1.</span></div>

    <p class="text-gray-300">(2) Let  <span class="math">\\overline{A}</span>  be any polynomial-time INT-PTXT-1-adversary attacking  <span class="math">\\overline{\\Pi}</span> . We can assume it makes exactly one query to its verification oracle. Then there exists a polynomial-time INT-PTXT-1 adversary  <span class="math">A</span>  attacking  <span class="math">\\Pi</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , \\overline {{A}}} ^ {\\mathrm {I N T - P T X T - 1}} (k) \\leq \\mathbf {A d v} _ {\\Pi , A} ^ {\\mathrm {I N T - P T X T - 1}} (k).</span></div>

    <p class="text-gray-300">The proofs of these claims are analogous to the ones for ma-schemes and thus we omit them.</p>

    <p class="text-gray-300">Theorem B.2 [INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M] Let  <span class="math">\\Pi = (\\mathsf{Kg},\\mathsf{Enc},\\mathsf{De})</span>  be a symmetric encryption scheme. Let  <span class="math">A</span>  be an adversary making at most  <span class="math">v(\\cdot)</span>  verification queries. Then there exists an adversary  <span class="math">B</span> , making only one verification query, such that for all  <span class="math">k\\in \\mathbb{N}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\Pi , A} ^ {\\mathrm {I N T - C T X T - M}} (k) \\leq v (k) \\cdot \\mathbf {A d v} _ {\\Pi , B} ^ {\\mathrm {I N T - C T X T - 1}} (k). \\tag {6}</span></div>

    <p class="text-gray-300">Furthermore, the number of encryption queries made by  <span class="math">B</span>  is the same as the number made by  <span class="math">A</span> , and the running time of  <span class="math">B</span>  is that of  <span class="math">A</span>  plus  <span class="math">O((v + t)\\tau)</span>  where  <span class="math">t(\\cdot)</span>  is a bound on the number of encryption queries made by  <span class="math">A</span>  and  <span class="math">\\tau(\\cdot)</span>  is a bound on the lengths of messages and ciphertexts in  <span class="math">A</span> 's oracle queries.</p>

    <p class="text-gray-300">Proof: Adversary  <span class="math">B</span>  is specified below:</p>

    <p class="text-gray-300">Adversary  <span class="math">B^{\\mathsf{Enc}(K,\\cdot),\\mathsf{De}^{*}(K,\\cdot)}(1^{k})</span></p>

    <p class="text-gray-300">count  <span class="math">\\leftarrow 0</span>  ; guess  <span class="math">\\stackrel{\\S}{\\leftarrow}[v(k)]</span>  ; CTXTSET  <span class="math">\\leftarrow \\emptyset</span></p>

    <p class="text-gray-300">Run  <span class="math">A</span>  on input  <span class="math">1^k</span> , replying to its oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">M</span>  to  <span class="math">\\mathsf{Enc}(K, \\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{c}\\stackrel {\\mathrm{s}}{\\leftarrow}\\mathsf{Enc}(K,M);\\quad \\mathrm{CTXTSET}\\leftarrow \\mathrm{CTXTSET}\\cup \\{\\mathrm{c}\\} ;\\quad \\mathrm{Return~c~to~}A</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">A</span>  makes a query  <span class="math">c</span>  to  <span class="math">\\mathsf{De}^*(K, \\cdot)</span>  do</li>

    </ul>

    <p class="text-gray-300">count  <span class="math">\\leftarrow</span>  count + 1</p>

    <p class="text-gray-300">If (count &gt; guess) then Halt</p>

    <p class="text-gray-300">If  <span class="math">(\\mathrm{c}\\in \\mathrm{CTXTSET})</span>  then return 1 to  <span class="math">A</span></p>

    <p class="text-gray-300">If (count &lt; guess) then return 0 to  <span class="math">A</span></p>

    <p class="text-gray-300">If (count = guess) then  <span class="math">d \\gets \\mathsf{De}^*(K, \\mathrm{c})</span> ; Halt</p>

    <p class="text-gray-300">For the analysis, let  <span class="math">\\mathrm{c}_1, \\mathrm{c}_2, \\ldots</span>  denote the verification-oracle queries made by  <span class="math">A</span>  in  <span class="math">\\mathbf{Exp}_{\\Pi, A}^{\\mathrm{INT-CTXT-M}}(k)</span> . Let the random variable  <span class="math">I</span>  take value the smallest index  <span class="math">i</span>  such that  <span class="math">\\mathsf{De}^*(K, \\mathrm{c}_i) = 1</span>  and  <span class="math">\\mathrm{c}_i \\notin \\mathrm{CTXTSET}</span> , and 0 otherwise.</p>

    <p class="text-gray-300">In the simulation of  <span class="math">A</span>  provided by  <span class="math">B</span> , we notice that if  <span class="math">\\text{guess} \\leq I</span> , then for all  <span class="math">1 \\leq i &amp;lt; \\text{guess}</span> , the reply provided by  <span class="math">B</span>  to the  <span class="math">i</span> -th verification-oracle query of  <span class="math">A</span>  is correct, meaning equals  <span class="math">\\mathsf{De}^*(K, \\mathsf{c}_i)</span> . On the other hand the random choice of guess is independent of the view of  <span class="math">A</span>  as long as  <span class="math">B</span>  has not halted. So</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A d v} _ {\\Pi , B} ^ {\\text {I N T - C T X T - 1}} (k) = \\Pr [ \\text {g u e s s} = I \\wedge I \\geq 1 ] \\\\ \\geq \\Pr [ \\text {g u e s s} = I ] \\cdot \\Pr [ I \\geq 1 ] \\\\ = \\frac {1}{v (k)} \\cdot \\mathbf {A d v} _ {\\Pi , A} ^ {\\text {I N T - C T X T - M}} (k). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This establishes Equation (6).</p>

    <p class="text-gray-300">Corollary B.3 [SUF-1  <span class="math">\\Rightarrow</span>  SUF-M] If a symmetric encryption scheme is INT-CTXT-1-secure then it is also INT-CTXT-M-secure.</p>

    <p class="text-gray-300">NO BETTER INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M REDUCTION. Theorem B.2 establishes INT-CTXT-M-security with a factor of  <span class="math">v(k)</span>  security loss. We claim that this loss is unavoidable and there is no better reduction. To prove it we will use the results for me-schemes from Section 7.</p>

    <p class="text-gray-300">Proposition B.4 Assume PRFs exist. Then for any polynomial  <span class="math">v(\\cdot)</span>  there exists a symmetric encryption scheme  <span class="math">\\Pi</span>  such that</p>

    <p class="text-gray-300">(1) There exists a polynomial-time adversary  <span class="math">A</span>  that makes at most  <span class="math">v(\\cdot)</span>  verification queries and achieves  <span class="math">\\mathbf{Adv}_{\\Pi, A}^{\\mathrm{INT-CTXT-M}}(k) = 1</span> , and (2) For any polynomial-time adversary  <span class="math">B</span>  making only one verification query, there is a negligible function  <span class="math">s(\\cdot)</span>  such that  <span class="math">\\mathbf{Adv}_{\\Pi,B}^{\\mathrm{INT-CTXT-1}}(k) \\leq 2 / v(k) + s(k)</span>  for all  <span class="math">k \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Proof: Consider the MAC scheme  <span class="math">\\Pi = (\\mathsf{TG},\\mathsf{VF})</span>  from the proof of Proposition 7.1. Using it we construct a symmetric encryption scheme  <span class="math">\\Pi^{*} = (\\mathsf{Kg},\\mathsf{Enc},\\mathsf{De})</span>  whose constituent algorithms are given below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm Kg(1k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm Enc(K,M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm De(K,c)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">K←$ {0,1}l(k)</td>

            <td class="px-3 py-2 border-b border-gray-700">Tag← TG(K,M)</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse c as M∥ Tag, Tag ∈ {0,1}τ(k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Return K</td>

            <td class="px-3 py-2 border-b border-gray-700">c← M∥ Tag</td>

            <td class="px-3 py-2 border-b border-gray-700">d← VF(M, Tag)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Return c</td>

            <td class="px-3 py-2 border-b border-gray-700">If (d=1) return M; otherwise return ⊥</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Following Proposition 7.1, there exists adversary <span class="math">A&#x27;</span> against <span class="math">\\Pi</span> such that <span class="math">\\mathbf{Adv}_{\\Pi,A&#x27;}^{\\mathrm{SUF-M}}(k) = 1</span>. Such adversary could be naturally modified to the adversary <span class="math">A</span> against encryption scheme <span class="math">\\Pi^*</span>:</p>

    <p class="text-gray-300">Adversary <span class="math">A^{\\mathsf{Enc}(K,\\cdot),\\mathsf{De}^*(K,\\cdot)}(1^k)</span></p>

    <p class="text-gray-300">Run <span class="math">A&#x27;(1^k)</span> and answer its oracle queries as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{TG}(M):</span> $\\quad \\mathrm{c} \\leftarrow \\mathsf{Enc}(K, M); \\text{parse } \\mathrm{c} \\text{ as } M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tag} \\text{ where } \\mathrm{Tag} \\in \\{0, 1\\}^{\\tau(k)}; \\text{ return } \\mathrm{Tag} \\text{ to } A'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{VF}(M, \\mathrm{Tag}):</span> $\\quad \\mathrm{c} \\leftarrow M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tag}; d \\leftarrow \\mathsf{De}^*(K, \\mathrm{c}); \\text{ return } d \\text{ to } A'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that <span class="math">A&#x27;</span> wins SUF-M-experiment against <span class="math">\\Pi</span> exactly when <span class="math">A</span> wins INT-CTXT-M-experiment against <span class="math">\\Pi^<em></span> and thus <span class="math">\\mathbf{Adv}_{\\Pi^</em>, A}^{\\mathrm{INT-CTXT-M}}(k) = \\mathbf{Adv}_{\\Pi, A&#x27;}^{\\mathrm{SUF-M}}(k) = 1</span>. This proves item (1) of the proposition.</p>

    <p class="text-gray-300">Now consider an arbitrary INT-CTXT-1-adversary <span class="math">B</span> against <span class="math">\\Pi^*</span>. Similarly to the previous case we modify <span class="math">B</span> into the following SUF-1-adversary <span class="math">B&#x27;</span> against <span class="math">\\Pi</span>:</p>

    <p class="text-gray-300">Adversary <span class="math">B^{\\prime \\mathsf{TG}(K,\\cdot),\\mathsf{VF}(K,\\cdot,\\cdot)}(1^{k})</span></p>

    <p class="text-gray-300">Run <span class="math">B(1^{k})</span> and answer its oracle queries as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Enc}(M):</span> $\\quad \\mathrm{Tag} \\leftarrow \\mathsf{TG}(K, M); \\mathrm{c} \\leftarrow M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tag}; \\text{ Return } \\mathrm{c} \\text{ to } B$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{De}^*(\\mathrm{c}):</span> $\\quad \\text{ Parse } \\mathrm{c} \\text{ as } M \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Tag}, \\mathrm{Tag} \\in \\{0, 1\\}^{\\tau(k)}; d \\leftarrow \\mathsf{VF}(M, \\mathrm{Tag}); \\text{ return } d \\text{ to } B$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that <span class="math">B</span> wins INT-CTXT-1-experiment against <span class="math">\\Pi^*</span> exactly when <span class="math">B&#x27;</span> wins SUF-1-experiment <span class="math">\\Pi</span>. By Proposition 7.1, <span class="math">\\mathbf{Adv}_{\\Pi,B&#x27;}^{\\mathrm{SUF-1}}(k) &amp;lt; 2 / v(k) + s(k)</span> for some negligible function <span class="math">s(\\cdot)</span>. Therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{\\Pi^*, B}^{\\mathrm{INT-CTXT-1}}(k) = \\mathbf{Adv}_{\\Pi, B&#x27;}^{\\mathrm{SUF-1}}(k) &amp;lt; 2 / v(k) + s(k)</span></div>

    <p class="text-gray-300">as claimed.</p>

    <p class="text-gray-300">Note that the symmetric encryption scheme in our counter-example does not provide any privacy, since the plaintext is present in the clear in the corresponding ciphertext. This does not affect the fact that the example we construct shows what it is supposed to. It is possible to extend this example to one where the symmetric encryption scheme does provide privacy.</p>

    <p class="text-gray-300">Recall that Theorem B.2 provides a reduction with a reduction factor <span class="math">1 / n</span>. Proposition B.4 implies that no better reduction factor is possible:</p>

    <p class="text-gray-300">Corollary B.5 If PRFs exist then the reduction factor of any INT-CTXT-1 <span class="math">\\Rightarrow</span> INT-CTXT-M reduction is <span class="math">O(1 / n)</span>.</p>

    <p class="text-gray-300">20</p>`;
---

<BaseLayout title="The Power of Verification Queries in Message Authentication ... (2004/309)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/309
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
