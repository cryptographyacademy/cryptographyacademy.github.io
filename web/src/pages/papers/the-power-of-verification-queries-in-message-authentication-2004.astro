---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/309';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'The Power of Verification Queries in Message Authentication and Authenticated Encryption';
const AUTHORS_HTML = 'Mihir Bellare&lt;sup&gt;∗&lt;/sup&gt; Oded Goldreich† Anton Mityagin‡';

const CONTENT = `    <p class="text-gray-300">Mihir Bellare&lt;sup&gt;∗&lt;/sup&gt; Oded Goldreich† Anton Mityagin‡</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">This paper points out that, contrary to popular belief, allowing a message authentication adversary multiple verification attempts towards forgery is not equivalent to allowing it a single one, so that the notion of security that most message authentication schemes are proven to meet does not guarantee their security in practice. We then show, however, that the equivalence does hold for strong unforgeability. Based on this we recover security of popular classes of message authentication schemes such as MACs (including HMAC and PRF-based MACs) and CWschemes. Furthermore, in many cases we do so with a tight security reduction, so that in the end the news we bring is surprisingly positive given the initial negative result. Finally, we show analogous results for authenticated encryption.</p>

    <p class="text-gray-300">Keywords: Message authentication, PRFs, Carter-Wegman, symmetric encryption, authenticated encryption.</p>

    <p class="text-gray-300">Message authentication. A message authentication (ma) scheme allows parties sharing a key K to authenticate data they send to each other. The sender applies a tag generation algorithm TG to K and the message M to get a tag Tag, and then sends M, Tag to the receiver. The latter applies a verification algorithm VF to K, a received message, and its accompanying tag, to get an output of 1 (accept) or 0 (reject), indicating whether or not the message should be considered authentic.</p>

    <p class="text-gray-300">Message authentication schemes are pervasive in practice. In a typical usage, public-key cryptography is first used to exchange a private key K, and the latter is then used to authenticate (and also possibly encrypt) data. This happens in Internet security protocols like SSL (used to secure credit card numbers in electronic commerce) SSH (secure remote login) and IPSEC.</p>

    <p class="text-gray-300">Much work goes into obtaining high-performance, secure ma-schemes, and there are a variety of schemes in existence and use, including HMAC [1], block-cipher based MACs [5, 22, 10, 4, 11, 20, 17, 18] and Carter-Wegman (CW) ma-schemes [25, 21, 23, 16, 8, 9].</p>

    <p class="text-gray-300">This paper points out that the notion of security that most of these schemes are proven to meet does not guarantee their security in practice, and then looks into remedies.</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;Dept. of Computer Science &amp; Engineering, University of California, San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA. Email: mihir@cs.ucsd.edu. URL: http://www-cse.ucsd.edu/users/mihir. Supported in part by NSF grants CCR-0098123, ANR-0129617 and CCR-0208842, and by an IBM Faculty Partnership Development Award.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt;Department of Computer Science, Weizmann Institute of Science, Rehovot, Israel. Email: oded.goldreich@ weizmann.ac.il. URL: http://www.wisdom.weizmann.ac.il/˜oded/homepage.html.</p>

    <p class="text-gray-300">&lt;sup&gt;‡&lt;/sup&gt;Dept. of Computer Science &amp; Engineering, University of California, San Diego, 9500 Gilman Drive, La Jolla, CA 92093, USA. Email: amityagin@cs.ucsd.edu. URL: http://www-cse.ucsd.edu/users/amityagin. Supported in part by above-mentioned grants of first author.</p>

    <p class="text-gray-300">Two definitions. The natural definition of security [5] comes by extending the one for digital signatures [15]. Namely, an adversary, allowed a chosen-message attack (via access to a tagging oracle TG(K, ·)), should be unable to produce a message-tag pair M, Tag that is valid (meaning VF(K, M, Tag) = 1) and for which the message is new (meaning, was not queried to the tagging oracle).</p>

    <p class="text-gray-300">This definition however gives the adversary only one verification attempt. An alternative definition [4] gives the adversary, in addition to the tagging oracle, also a verification oracle VF(K, ·, ·). The adversary should be unable to make a query M, Tag to its verification oracle such that the latter returns 1 but M was not previously queried to the tag oracle.</p>

    <p class="text-gray-300">Let us refer to this second definition as UF-M (UnForgeability under Multiple verification queries). Note that the first (standard) definition we discussed above is just the special case of the second one in which only a single verification query is allowed, so henceforth we think of it this way and refer to it as UF-1 (UnForgeability under a single verification query).</p>

    <p class="text-gray-300">In practice, it is certainly possible for an adversary to make multiple verification attempts. (For example a server authenticating a client under their common key functions as the verification oracle, and an adversary can forward many transmissions to it.) A scheme that is UF-1 but not UF-M is thus clearly not providing adequate security for practical usage.</p>

    <p class="text-gray-300">Equivalent? It turns out that this fact (namely, that UF-M is the &quot;right&quot; notion, not UF-1) is actually quite well understood in the community and literature. Nonetheless, it is the UF-1 notion that most schemes are proven to meet [5, 22, 1, 10, 11, 8, 9, 17, 18, 20]. (Exceptions are [4, 3].) Why?</p>

    <p class="text-gray-300">It appears to be due to the belief that UF-1 ⇒ UF-M. More precisely, the belief is that if an adversary A makes v verification oracle queries, its advantage (probability of forgery) is not more than v times that of an adversary B of comparable time making just one verification oracle query. So the belief is that although a difference in concrete security does manifest itself, UF-1 and UF-M are polynomially equivalent. The folklore argument for this is that B can guess one of the verification queries of A to use as its own, single verification query, answering previous ones by &quot;0.&quot;</p>

    <p class="text-gray-300">Not equivalent. In Section 3 we show why the above-mentioned folklore argument is incorrect. This leaves open the question of whether or not it can be patched to show the equivalence, but we then go on to show that it cannot. Namely we show in Theorem 4.1 that UF-1 ; UF-M. We do this by presenting a ma-scheme that is UF-1 but is not UF-M. (Naturally this requires the assumption that some UF-1 ma-scheme exists, otherwise the question is moot.) Thus, contrary to expectation, the UF-1 and UF-M notions are not equivalent.</p>

    <p class="text-gray-300">Intuitively, the problem is malleability [12]. In particular multiple verification queries can add power when an adversary can modify a valid tag for a message into another, different valid tag for the same message.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1.2 SUF-1⇒SUF-M</h2>

    <p class="text-gray-300">Next we establish a useful positive result, namely that the equivalence (between security under one or many verification queries) does hold under a stronger notion of unforgeability than the one considered above.</p>

    <p class="text-gray-300">Strong unforgeability. Strong unforgeability [6] means the adversary is not only unable to forge a tag for a new message, but also unable to forge a new tag for an old (meaning, already tagged) message. The formalization is with respect to adversaries getting both a tagging and a</p>

    <p class="text-gray-300">    <img src="_page_2_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: An arrow represents an implication and a barred arrow represents a separation.</p>

    <p class="text-gray-300">verification oracle as above, so again there is both a single verification query version (that we denote SUF-1) and a multiple verification query version (that we denote SUF-M).</p>

    <p class="text-gray-300">We show (cf. Theorem 5.1 and Corollary 5.2) that SUF-1 ⇒ SUF-M. Thus, in contrast to (mere) unforgeability, the strong versions of the notions are equivalent.</p>

    <p class="text-gray-300">Relations. Figure 1.2 summarizes the relations between the four notions we have discussed, in the style of [2]. For each pair A, B ∈ {UF-1, UF-M, SUF-1, SUF-M} of notions we show one of the following: (1) An implication A ⇒ B (this means we prove that any ma-scheme achieving A also achieves B); or (2) A separation A ; B (this means we give a construction of a ma-scheme that meets notion A but does not meet notion B). A separation A ; B is always under the (minimal) assumption that there exists a scheme meeting notion A.</p>

    <p class="text-gray-300">The fact that UF-1 ; UF-M means that what has been proved about specific existing ma-schemes does not guarantee their security under multiple verification attempts and hence in practice, but does not mean that these particular schemes are not UF-M. We now ask whether it may be possible, via other routes, to prove UF-M security of existing schemes.</p>

    <p class="text-gray-300">In answering this question, it would be much preferable to avoid re-entering the (sometimes complex) proofs of security of these ma-schemes. Our approach, instead, is to consider some special classes of ma-schemes such that (1) known schemes have been proved to fall into one of these classes, and (2) we can show that any scheme in the class is SUF-1. Then, via our SUF-1 ⇒ SUF-M implication, and existing results about the schemes, we can conclude that they are UF-M (and in fact SUF-M) secure. We implement this program as follows.</p>

    <p class="text-gray-300">The first class of ma-schemes we consider are UF-1 MACs. (A ma-scheme is a message authentication code, or MAC, if its tagging function is stateless and deterministic, and verification is done by applying the tagging function to compute the correct tag of the given message and comparing this with the candidate tag.) It is easy to see (cf. Proposition 6.1) that any UF-1 MAC is in fact SUF-1, and hence (by Corollary 5.2) UF-M and SUF-M. As an application, since HMAC, proven UF-1 in [1], is a MAC, the above tells us that it is UF-M and SUF-M secure.</p>

    <p class="text-gray-300">An important subclass of MACs are PRF based ones, where the tagging function is pseudorandom. These are UF-1 [14, 5] and thus by the above automatically SUF-1, UF-M and SUF-M. Since the tagging algorithms of block-cipher based constructs like various CBC-MACs [5, 10, 22], PMAC [11], TMAC [17] and OMAC [18] are shown in the cited papers to be PRFs, we can conclude that the corresponding MACs are UF-M and SUF-M.</p>

    <p class="text-gray-300">The second class of ma-schemes we consider are Carter-Wegman (CW) ma-schemes [25]. These schemes are randomized or counter-based, and hence not MACs, so Proposition 6.1 does not apply. However, via an extension of the standard proof establishing the UF-1 security of these ma-schemes [21, 23, 16, 8, 9], we can establish their SUF-1 security as well. Hence by Corollary 5.2, they too are UF-M and SUF-M. In particular, UMAC [8, 9] and MMH-MAC [16] are CW ma-schemes shown in the cited papers to be UF-1, and hence are UF-M and SUF-M by the above.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.4 Reduction tightness and concrete security improvements</h3>

    <p class="text-gray-300">The results above are with respect to asymptotic definitions of security, where meeting a notion means that the success probability of any polynomial-time adversary is a negligible function of the security parameter. This is indeed the conceptually appropriate setting in which to study security relations at the first cut. However, for practical purposes, the concrete security of reductions can be important, and we now address this issue.</p>

    <p class="text-gray-300">Quality of the SUF-1 ⇒ SUF-M reduction, and its impact. The reduction of Theorem 5.1, which establishes that SUF-1 ⇒ SUF-M, is not tight: given a polynomial-time adversary A making v verification attempts and succeeding with probability a, it delivers a polynomial-time adversary B making one verification attempt and succeeding with probability at least b = a/v. The abovementioned results showing UF-M and SUF-M security of various classes of schemes inherit this loss in security through their reliance on Theorem 5.1. Unfortunately this loss can be significant in practice. Consider for example PRF-based MACs using a block cipher with block-length n. Typically [5, 10, 22, 11, 17, 18] it is shown that the probability of forgery under t tagging queries, each of at most m blocks, is roughly m&lt;sup&gt;2&lt;/sup&gt; t &lt;sup&gt;2&lt;/sup&gt;/2 n . With AES (n = 128) and assuming 1Kbyte messages (m = 2 &lt;sup&gt;13&lt;/sup&gt;) this provides UF-1 security until around t = 2 &lt;sup&gt;51&lt;/sup&gt; messages are tagged, which is adequate if we only cared about UF-1, but of course we don't. Obtaining UF-M/SUF-M via Theorem 5.1, we get that the probability of forgery under v verification queries is roughly vm&lt;sup&gt;2&lt;/sup&gt; t &lt;sup&gt;2&lt;/sup&gt;/2 n , with t, m as before. Now, for example, a guarantee of security against v = 2 &lt;sup&gt;34&lt;/sup&gt; verification attempts requires that at most t = 2 &lt;sup&gt;34&lt;/sup&gt; messages are tagged. These numbers are not large enough for comfort, and things get substantially worse if we consider legacy ciphers with block length n = 64.</p>

    <p class="text-gray-300">No better general reduction. The first question to ask given the above is whether there is a better reduction showing SUF-1 ⇒ SUF-M. Proposition 7.1 shows that the answer is no. It does this by presenting a MAC for which there is a polynomial-time attack having constant probability of strong forgeability with v queries, but for which no polynomial-time attack making only one verification query succeeds in strong forgery with probability significantly better than 1/v. This shows (cf. Corollary 7.2) that no reduction could deliver a reduction factor that is better than that of Theorem 5.1 by more than a constant factor, even for the special case of ma schemes that are MACs.</p>

    <p class="text-gray-300">Improvements in special cases. Although a general concrete-security improvement is ruled out by the above, we are able to find such improvements for important subclasses of ma-schemes. Proposition 7.3 presents an essentially tight reduction of SUF-M to the pseudorandomness of the MAC in the case the latter is PRF-based. Continuing the above example, this will imply that the probability of forgery under v verification queries is roughly m&lt;sup&gt;2&lt;/sup&gt; (v &lt;sup&gt;2&lt;/sup&gt; + t 2 )/2 n , with v,t, m as before. Now (for 1Kbyte messages) we have a guarantee of security against v = 2 &lt;sup&gt;50&lt;/sup&gt; verification attempts even if up to t = 2 &lt;sup&gt;50&lt;/sup&gt; messages are tagged.</p>

    <p class="text-gray-300">This is a substantial improvement. It is particularly valuable since so many ma-schemes are PRF-based [5, 10, 22, 11, 17, 18], and we note it can also be applied to HMAC, whose tagging algorithms is often assumed to be a PRF, due to its usage for tasks such as key-derivation. (We note the proof of [1] extends to establish its security as a PRF if we are willing to assume the underlying compression function is a PRF.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.5 The case of authenticated encryption</h3>

    <p class="text-gray-300">There are two notions of integrity for authenticated encryption: integrity of plaintexts (an analog of standard unforgeability for ma-schemes) and integrity of ciphertexts (an analog of strong unforgeability for ma-schemes). In either case we may consider versions with one or more verification attempts (here the verification oracle takes a ciphertext and says whether or not it is valid) leading to four notions, INT-PTXT-1,INT-PTXT-M,INT-CTXT-1,INT-CTXT-M. In the literature, INT-CTXT-1 was defined in [19, 7], and INT-CTXT-M,INT-PTXT-M in [6]. INT-PTXT-1 was not defined prior to our paper. Our main results about ma-schemes extend, and in particular we show that INT-PTXT-1 ; INT-PTXT-M but INT-CTXT-1 ⇒ INT-CTXT-M. This material is covered in Appendix B and the relations are depicted in Figure B.</p>

    <h2 id="sec-5" class="text-2xl font-bold">1.6 Remarks</h2>

    <p class="text-gray-300">One might consider a multiple verification version of the definition of digital signatures as well, but it is clearly equivalent to the standard definition of [15] because verification takes place under a key that is public (and in particular available to the adversary).</p>

    <p class="text-gray-300">In practice, &quot;throttling&quot; is often used to limit the number of verification attempts an adversary can make. (The verification server refuses further requests under a key for which some number of verification attempts have been previously rejected). It would be a mistake to think that the use of throttling means that UF-1 security suffices. For one thing, one surely cannot limit a user to just one verification attempt before revoking their key, for a few rejections can occur for natural reasons such as corrupted transmissions. Also, revocation of keys brings key-management costs. Thus we feel that for practice the most desirable situation is to have schemes providing security against a large number of verification attempts.</p>

    <h2 id="sec-6" class="text-2xl font-bold">1.7 Related work</h2>

    <p class="text-gray-300">In his recent textbook [13], the second author of this paper noted that UF-1 ; UF-M, and also that the implication is true for the class of unique UF-1 ma-schemes. (In such a scheme there exists for every key and message at most one tag that the verification algorithm accepts.) The present paper represents the submission of this material to a research venue while adding significant improvements, extensions and applications. In particular we establish UF-M for SUF-1 schemes, which is a strictly larger class than the class of unique UF-1 ma-schemes. (Every unique UF-1 ma-scheme is SUF-1, but there are SUF-1 ma-schemes, such as CW-ma-schemes, that are not unique.) Other contributions of the paper not present in the textbook are: consideration of the UF-M security of specific existing ma-schemes in the literature as discussed in Section 1.3 above; tightness of the main reduction and concrete security improvements as discussed in Section 1.4 above; and authenticated encryption as discussed in Section 1.5 above.</p>

    <p class="text-gray-300">Notation. By akbkck · · · we denote an encoding of objects a, b, c, . . . into a binary string in such a way that the constituents are uniquely recoverable in linear time. If n is an integer then hni denotes its binary representation and [n] = {1, . . . , n}. If x is a string then |x| denotes its length and x[i] denotes its i-th bit, for i ∈ [|x|]. If A is a randomized algorithm then a $← A(x, y, · · ·) means that A is executed on inputs x, y, . . . with fresh coins and a denotes the outcome. If S is a set then s $← S means that s is chosen uniformly at random from S. If x, y are objects then x ← y means x is assigned the value y.</p>

    <p class="text-gray-300">Message authentication schemes. A message-authentication scheme (ma-scheme) Π = (TG, VF) is a pair of polynomial-time algorithms, where</p>

    <pre><code class="language-text">Experiment \\mathbf{Exp}_{\\Pi,A}^{\\mathsf{type}}(k)
    K \\stackrel{\\$}{\\leftarrow} \\{0,1\\}^{l(k)}; count \\leftarrow 0; f \\leftarrow 0; sf \\leftarrow 0
    Run A on input 1^k, replying to its oracle queries as follows:
         When A makes a query M to \\mathsf{TG}(K,\\cdot) do
              Tag \\stackrel{\\$}{\\leftarrow} \\mathsf{TG}(K, M); TagSet[M] \\leftarrow TagSet[M] \\cup \\{Tag\\}; Return Tag to A
         When A makes a query M, Tag to VF(K,\\cdot,\\cdot) do
             d \\leftarrow \\mathsf{VF}(K, M, Tag); count \\leftarrow count +1
             If d = 1 then
                  If TAGSET[M] = \\emptyset then f \\leftarrow 1; If Tag \\notin TAGSET[M] then sf \\leftarrow 1
             Return d to A
                               then return (count = 1) \\wedge f
    If (type = UF-1)
    If (type = UF-M)
                               then return f
                               then return (count = 1) \\wedge sf
    If (type = SUF-1)
    If (type = SUF-M) then return sf
</code></pre>

    <p class="text-gray-300">Figure 2: Experiment defining our four notions of security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The tag-generation algorithm TG, which may be randomized or stateful, takes a key  <span class="math">K \\in \\{0,1\\}^{l(k)}</span> , where  <span class="math">k \\in \\mathbb{N}</span>  is the security parameter, and a message  <span class="math">M \\in \\{0,1\\}^*</span>  to return a tag  <span class="math">Tag \\in \\{0,1\\}^*</span> . The function  <span class="math">l(\\cdot)</span>  is the key-length.</li>
      <li>The deterministic, stateless verification algorithm VF takes a key  <span class="math">K \\in \\{0,1\\}^{l(k)}</span> , a message  <span class="math">M \\in \\{0,1\\}^*</span>  and a candidate tag  <span class="math">Tag \\in \\{0,1\\}^*</span>  to return either 1 (ACCEPT) or 0 (REJECT).</li>
    </ul>

    <p class="text-gray-300">We require the following completeness condition:  <span class="math">\\mathsf{VF}(K,M,\\mathsf{TG}(K,M))=1</span>  with probability 1 for any k, any  <span class="math">K\\in\\{0,1\\}^{l(k)}</span> , and any  <span class="math">M\\in\\{0,1\\}^*</span> . We say that  <span class="math">\\Pi</span>  is a message authentication code (MAC) if  <span class="math">\\mathsf{TG}</span>  is (stateless and) deterministic, and also  <span class="math">\\mathsf{VF}(K,M,Tag)</span>  is defined via: If  <span class="math">Tag=\\mathsf{TG}(K,M)</span>  then return 1 else return 0.</p>

    <p class="text-gray-300">For simplicity we will focus for now on stateless schemes. (Meaning ones where TG is stateless. Verification is always stateless). We also assume that TG applies to any message  <span class="math">M \\in \\{0,1\\}^*</span> . In some later cases we will want to consider that the TG <span class="math">(K,\\cdot)</span>  algorithm only applies to strings in some message space associated to k. (This happens because in practice the messages are often restricted in some way, for example to a maximum length or to length a multiple of some block length.) In that case the completeness condition only applies to messages in this space.</p>

    <p class="text-gray-300">FOUR SECURITY NOTIONS. We provide the formal definitions and then some explanations. Let  <span class="math">\\Pi = (\\mathsf{TG}, \\mathsf{VF})</span>  be a message authentication scheme. Let  <span class="math">\\mathsf{type} \\in \\{\\mathsf{UF-1}, \\mathsf{UF-M}, \\mathsf{SUF-1}, \\mathsf{SUF-M}\\}</span> . Let A be an adversary with access to a tagging oracle and a verification oracle, and let  <span class="math">k \\in \\mathbb{N}</span> . We define the experiment depicted in Figure 2. We let</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathsf{type}}_{\\Pi,A}(k) \\; = \\; \\Pr \\left[ \\; \\mathbf{Exp}^{\\mathsf{type}}_{\\Pi,A}(k) = 1 \\; \\right]</span>$</p>

    <p class="text-gray-300">denote the winning probability for A in the experiment in question. We say that  <span class="math">\\Pi</span>  is type-secure if the function  <span class="math">\\mathbf{Adv}_{\\Pi,A}^{\\mathsf{type}}(\\cdot)</span>  is negligible for any polynomial time adversary A.</p>

    <p class="text-gray-300">In the experiment, naturally, A's tagging oracle queries are answered via  <span class="math">\\mathsf{TG}(K,\\cdot)</span>  and its verification oracle queries via  <span class="math">\\mathsf{VF}(K,\\cdot,\\cdot)</span> . The rest is book-keeping. The flag  <span class="math">\\mathsf{f}</span>  is set to 1 if the conditions of standard forgery are met, and the flag  <span class="math">\\mathsf{sf}</span>  is set to 1 if the conditions of a strong forgery are met. It is assumed that the set  <span class="math">\\mathsf{TAGSET}[M]</span>  is initially empty for all M. The counter count keeps track of the number of verification queries made.</p>

    <p class="text-gray-300">PRFs and PRF-based MACs. Let F be a family of functions with domain  <span class="math">\\{D_k\\}_{k\\in\\mathbb{N}}</span> , output length  <span class="math">\\tau(\\cdot)</span>  and key-length  <span class="math">l(\\cdot)</span> . This means that F(K,M) is a  <span class="math">\\tau(k)</span> -bit string for each k, each l(k)-bit key K and each input  <span class="math">M \\in D_k</span> , and can be computed in polynomial time. Recall [14, 5] that if B is an adversary with an oracle for a function  <span class="math">f: D_k \\to \\{0,1\\}^{\\tau(k)}</span>  then its prf-advantage is</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{PRF}}_{F,B}(k) \\ = \\ \\mathrm{Pr}\\left[\\,B^{F(K,\\cdot)}(1^k) = 1\\,\\right] - \\mathrm{Pr}\\left[\\,B^{f(\\cdot)}(1^k) = 1\\,\\right]\\,,</span>$</p>

    <p class="text-gray-300">the first probability being over  <span class="math">K \\stackrel{\\</span>}{\\leftarrow} {0,1}^{l(k)}$  and the second over  <span class="math">f \\stackrel{\\</span>}{\\leftarrow} \\mathsf{Maps}(D_k, {0,1}^{\\tau(k)})$ , where  <span class="math">\\mathsf{Maps}(D,R)</span>  is the set of all functions mapping from domain D to range R. We say that F is a PRF if  <span class="math">\\mathbf{Adv}_{F,B}^{\\mathsf{PRF}}(\\cdot)</span>  is negligible for all polynomial-time adversaries B. We associate to F the ma-scheme  <span class="math">\\Pi[F] = (F, \\mathsf{VF})</span> , where  <span class="math">\\mathsf{VF}(K, M, Tag)</span>  returns 1 if F(K, M) = Tag and 0 otherwise. The message space associated to k is  <span class="math">D_k</span> . A ma-scheme  <span class="math">\\Pi</span>  is said to be PRF-based if there is a family F such  <span class="math">\\Pi = \\Pi[F]</span> . Note that a PRF-based ma-scheme is a MAC.</p>

    <p class="text-gray-300">Let  <span class="math">\\Pi = (\\mathsf{TG}, \\mathsf{VF})</span>  be a UF-1 secure ma-scheme. As we noted earlier, there is a belief that one can prove it also UF-M secure. Here we will present the template of the &quot;proof&quot; that people appear to have in mind and see why it does not work. This is useful for two reasons: it lends some insight into the later counter-example showing UF-1  <span class="math">\\Rightarrow</span>  UF-M, and the same template will be later appropriately used to show that SUF-1  <span class="math">\\Rightarrow</span>  SUF-M.</p>

    <p class="text-gray-300">Let A be a polynomial-time UF-M adversary attacking  <span class="math">\\Pi</span> , and let  <span class="math">v(\\cdot)</span>  bound the number of verification-oracle queries made by A. (This means  <span class="math">v(k) \\leq \\text{poly}(k)</span>  is a polynomial-time computable function such that the number of verification queries made by A on input  <span class="math">1^k</span>  is at most v(k) with probability one, regardless of how answers to any oracle queries of A are computed.) We want to define a UF-1 adversary B such that for every k the following inequality, which we refer to as  <span class="math">\\mathbf{Eq}[A, B, k]</span>  holds:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Eq}[A,B,k]: \\qquad \\quad \\mathbf{Adv}^{\\mathrm{UF-1}}_{\\Pi,B}(k) \\ \\geq \\ \\frac{1}{v(k)} \\cdot \\mathbf{Adv}^{\\mathrm{UF-M}}_{\\Pi,A}(k) \\ .</span>$</p>

    <p class="text-gray-300">The idea is for B to guess and output the first successful verification query made by A, answering all others negatively without consulting its verification oracle. The corresponding adversary, which we call  <span class="math">B_1</span> , is defined by the part of the code of Figure 3 that omits the boxed statements. (Ignore the boxed statements for now.) Let I be the random variable, in  <span class="math">\\mathbf{Exp}_{\\Pi,A}^{\\mathrm{UF-M}}(k)</span> , that takes value the first verification query made by A to which the answer of the verification oracle is 1 and the message was not previously queried to the tagging oracle. Now we would like to claim that the guess guess made by  <span class="math">B_1</span>  equals I with probability at least 1/v(k), and thus  <span class="math">\\mathbf{Eq}[A, B_1, k]</span>  is true.</p>

    <p class="text-gray-300">However, this is not true. For example, A might make a query M to its tagging oracle, get back a tag Tag, and immediately make query M, Tag to its verification oracle. Let us imagine that, after this, it makes another verification oracle query M', Tag' that is valid, with  <span class="math">M&#x27; \\neq M</span> , so that it wins with probability one. However,  <span class="math">B_1</span> 's simulation is inaccurate, because (in the case guess  <span class="math">\\geq 2</span> ) the verification oracle would have returned 1 in answer to A's first query to it, but  <span class="math">B_1</span>  returns 0 to A as the answer. So  <span class="math">B_1</span> 's advantage is 0. (In the case guess = 1,  <span class="math">B_1</span>  does not win because M was queried to the tagging oracle and is not new).</p>

    <p class="text-gray-300">This seems easily fixed by comparing tags in verification oracle queries to ones returned previously by the tagging oracle. Namely, we consider adversary  <span class="math">B_2</span>  of Figure 3 that now includes the boxed statements. For our example A above,  <span class="math">B_2</span> 's simulation is now correct, and thus  <span class="math">\\mathbf{Eq}[A, B, k]</span>  is true. However, in general, this strategy is still wrong, meaning there are adversaries A for which  <span class="math">\\mathbf{Eq}[A, B_2, k]</span>  does not hold. The reason is malleability. Suppose A begins by making a query M to</p>

    <pre><code class="language-text">Adversary B
            TG(K,·),VF(K,·,·)
            b
                          (1k
                             ) (b ∈ {1, 2})
   count ← 0 ; guess
                    $← [v(k)]
   Run A on input 1
                     k
                      , replying to its oracle queries as follows:
   – When A makes a query M to TG(K, ·) do
          Tag
              $← TG(K, M) ; TagSet[M] ← TagSet[M] ∪ {Tag} ; Return Tag to A
   – When A makes a query M, Tag to VF(K, ·, ·) do
          count ← count + 1
          If (count &gt; guess) then Halt
          If (Tag ∈ TagSet[M]) then return 1 to A
          If (count &lt; guess) then return 0 to A
          If (count = guess) then d ← VF(K, M, Tag) ; Halt
</code></pre>

    <p class="text-gray-300">Figure 3: UF-1 adversaries B1, B&lt;sup&gt;2&lt;/sup&gt; derived from UF-M adversary A. Adversary B&lt;sup&gt;1&lt;/sup&gt; omits the boxed statements while B&lt;sup&gt;2&lt;/sup&gt; includes them.</p>

    <p class="text-gray-300">its tagging oracle, getting back a tag Tag, and is then capable of modifying Tag to some different value Tag such that VF(K, M, Tag) = 1. Let it then make query M, Tag to its verification oracle. As before, imagine that, after this, it makes another verification oracle query M&lt;sup&gt;0&lt;/sup&gt; , Tag&lt;sup&gt;0&lt;/sup&gt; that is valid, with M&lt;sup&gt;0&lt;/sup&gt; 6= M, so that it wins with probability one. Now, again, B2's simulation is inaccurate, because (in the case guess ≥ 2) the verification oracle would have returned 1 in answer to A's first query to it, but B&lt;sup&gt;2&lt;/sup&gt; returns 0 to A as the answer. So B2's advantage is 0.</p>

    <p class="text-gray-300">This time, it is not clear how to fix B2, because in general it is not clear how to detect whether Tag is a valid tag for M without querying the verification oracle. Theorem 4.1 implies that this difficulty is not surmountable. On the other hand Theorem 5.1 shows that if Π was SUF-1 rather than merely UF-1 then this problem can be overcome to show that Π is also SUF-M.</p>

    <p class="text-gray-300">The above discussion leaves open the question of whether UF-1 ⇒ UF-M or not. Perhaps the proof could be patched? The following theorem implies that it cannot, because the underlying claim is simply not true.</p>

    <p class="text-gray-300">Theorem 4.1 [UF-1 ; UF-M] Assume there exists a UF-1-secure ma-scheme. Then there exists a UF-1-secure ma-scheme that is not UF-M-secure.</p>

    <p class="text-gray-300">The rest of this section is devoted to a proof of Theorem 4.1. By assumption there exists a UF-1 secure ma-scheme Π = (TG, VF). Let l be its key-length. We build from it the ma-scheme Π = (MAC, VF) whose constituent algorithms are specified below:</p>

    <pre><code class="language-text">Algorithm MAC(K, M)
   Tag ← TG(K, M)
   Tag ← Tagkh0i
   Return Tag
                         Algorithm VF(K, M, Tag)
                            Parse Tag as Tagkhii where i ∈ {0, 1, . . . , |K|}
                            d ← VF(K, M, Tag)
                            If (d = 0 or i = 0) then return d
                            If (d = 1 and i ≥ 1) then return K[i]
</code></pre>

    <p class="text-gray-300">Recall that K[i] denotes the i-th bit of the key K. The key-length of the new scheme is also l. We first note that the scheme satisfies the completeness condition. Indeed, if Tag is an output of  <span class="math">\\overline{\\mathsf{MAC}}(K,M)</span>  then it has the form  <span class="math">Tag \\|\\langle i \\rangle</span>  with i=0. Thus the first &quot;If&quot; statement of  <span class="math">\\overline{\\mathsf{VF}}(K,M,\\overline{Tag})</span>  applies and returns d, which is 1 by completeness of  <span class="math">\\Pi</span> . Now we present an attack to show  <span class="math">\\overline{\\Pi}</span>  is not secure against an adversary making more than one query to its verification oracle.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Claim 4.2 <span class="math">\\overline{\\Pi}</span> is not UF-M-secure.</h4>

    <p class="text-gray-300"><strong>Proof:</strong> Consider the following UF-M-adversary  <span class="math">\\overline{A}</span>  against  <span class="math">\\overline{\\Pi}</span> :</p>

    <p class="text-gray-300">Adversary
<span class="math">$\\overline{A}^{\\overline{\\mathsf{MAC}}(K,\\cdot),\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)}(1^k)</span>$</p>

    <p class="text-gray-300">Let  <span class="math">M_1</span>  be any message and let  <span class="math">\\overline{Tag}_1 \\overset{\\</span>}{\\leftarrow} \\overline{\\mathsf{MAC}}(K,M_1)$
Parse  <span class="math">\\overline{Tag}_1</span>  as  <span class="math">Tag_1 \\| \\langle 0 \\rangle</span>
For  <span class="math">i=1,\\ldots,l(k)</span>  do  <span class="math">L[i] \\leftarrow \\overline{\\mathsf{VF}}(K,M_1,Tag_1 \\| \\langle i \\rangle)</span>
Let  <span class="math">M_2</span>  be any message different from  <span class="math">M_1</span>
<span class="math">\\overline{Tag}_2 \\overset{\\</span>}{\\leftarrow} \\overline{\\mathsf{MAC}}(L,M_2)$ ;  <span class="math">d \\leftarrow \\overline{\\mathsf{VF}}(K,M_2,\\overline{Tag}_2)</span></p>

    <p class="text-gray-300">Adversary  <span class="math">\\overline{A}</span>  obtains the tag of a message  <span class="math">M_1</span>  using its tagging oracle. The definition of the algorithm  <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span>  then tells us that, above, L[i]=K[i] is the i-th bit of the key K for all  <span class="math">i\\in[|K|]</span> . In other words,  <span class="math">\\overline{A}</span>  has succeeded in recovering the key. Then it can, of course, easily win, by forging the tag of some new message  <span class="math">M_2</span> . (Note that its computation of  <span class="math">\\overline{Tag}_2</span>  is not an oracle query.  <span class="math">\\overline{A}</span>  simply runs algorithm  <span class="math">\\overline{\\mathsf{MAC}}</span>  with key L and message  <span class="math">M_2</span> .) Thus  <span class="math">\\mathbf{Adv}_{\\overline{\\Pi},\\overline{A}}^{\\mathrm{UF-M}}(k)=1</span> . Since  <span class="math">\\overline{A}</span>  is polynomial-time, the claim is justified.  <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300">Next we show that  <span class="math">\\overline{\\Pi}</span>  retains the UF-1 security of  <span class="math">\\Pi</span> . The intuition is simple. In order to make  <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span>  accept, an adversary must have a message-tag pair that is valid for  <span class="math">\\mathsf{VF}(K,\\cdot,\\cdot)</span> . On the other hand, being limited to one verification oracle query, it cannot make any use of any information that the verification oracle returns in answer to this query, since its game is effectively over once the query is made. Here now is the formal claim and proof.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Claim 4.3 <span class="math">\\overline{\\Pi}</span> is UF-1-secure.</h4>

    <p class="text-gray-300"><strong>Proof:</strong> Let  <span class="math">\\overline{A}</span>  be any polynomial-time UF-1-adversary attacking  <span class="math">\\overline{\\Pi}</span> . We can assume it makes exactly one query to its verification oracle. We construct a polynomial-time UF-1 adversary A attacking  <span class="math">\\Pi</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\overline{\\Pi},\\overline{A}}^{\\mathrm{UF-1}}(k) \\leq \\mathbf{Adv}_{\\Pi,A}^{\\mathrm{UF-1}}(k) . \\tag{1}</span>$</p>

    <p class="text-gray-300">Here is how A works:</p>

    <p class="text-gray-300">Adversary  <span class="math">A^{\\mathsf{TG}(K,\\cdot),\\mathsf{VF}(K,\\cdot,\\cdot)}(1^k)</span></p>

    <p class="text-gray-300">Run  <span class="math">\\overline{A}</span>  on input  <span class="math">1^k</span> , replying to its oracle queries as follows:</p>

    <p class="text-gray-300">– When  <span class="math">\\overline{A}</span>  makes a query M to  <span class="math">\\overline{\\mathsf{MAC}}(K,\\cdot)</span>  do</p>

    <p class="text-gray-300"><span class="math">$Tag \\stackrel{\\</span>}{\\leftarrow} \\mathsf{TG}(K, M) ; ; ; \\overline{Tag} \\leftarrow Tag |\\langle 0 \\rangle ; ; ; \\text{Return } \\overline{Tag} \\text{ to } \\overline{A}$$</p>

    <p class="text-gray-300">– When  <span class="math">\\overline{A}</span>  makes a query  <span class="math">M, \\overline{Tag}</span>  to  <span class="math">\\overline{\\mathsf{VF}}(K, \\cdot, \\cdot)</span>  do</p>

    <p class="text-gray-300">Parse
<span class="math">$\\overline{Tag}</span>$
as  <span class="math">Tag \\|\\langle i \\rangle</span>  where  <span class="math">i \\in \\{0, 1, \\dots, k\\}</span> ;  <span class="math">d \\leftarrow \\mathsf{VF}(K, M, Tag)</span> ; Halt</p>

    <p class="text-gray-300">A does not return to  <span class="math">\\overline{A}</span>  any answer to  <span class="math">\\overline{A}</span> 's (unique) verification-oracle query. (Not knowing K, it would not know how). It simply uses this query to make its own verification-oracle query, and halts. Equation (1) is true because A's simulation of replies to queries of the tagging oracle is perfect, and also because  <span class="math">\\overline{\\mathsf{VF}}(K, M, Tag||\\langle i \\rangle)</span>  returns 1 only if  <span class="math">\\mathsf{VF}(K, M, Tag)</span>  returns 1.</p>

    <p class="text-gray-300">This concludes the proof of Theorem 4.1. We now make some remarks that help relate this result to upcoming ones.</p>

    <p class="text-gray-300"><strong>Remark 4.4</strong> The ma-scheme  <span class="math">\\overline{\\Pi}</span>  of our counter-example is not a MAC. Although  <span class="math">\\overline{\\mathsf{MAC}}(K,\\cdot)</span>  is deterministic, the second requirement of MACs is violated: verification  <span class="math">\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)</span>  is not done by recomputing  <span class="math">\\overline{\\mathsf{MAC}}(K,\\cdot)</span>  and comparing it with an input tag. This is relevant because otherwise we could contradict Proposition 6.1.  <span class="math">\\blacksquare</span></p>

    <p class="text-gray-300"><strong>Remark 4.5</strong> The ma-scheme  <span class="math">\\overline{\\Pi}</span>  of our counter-example is not SUF-1 due to the following adversary:</p>

    <pre><code class="language-text">Adversary \\overline{A}^{\\overline{\\mathsf{MAC}}(K,\\cdot),\\overline{\\mathsf{VF}}(K,\\cdot,\\cdot)}(1^k)
Let M be any message and let \\overline{Tag} \\xleftarrow{\\$} \\overline{\\mathsf{MAC}}(K,M_1)
Parse \\overline{Tag} as Tag \\| \\langle 0 \\rangle; d \\leftarrow \\overline{\\mathsf{VF}}(K,M,Tag \\| \\langle 1 \\rangle)
</code></pre>

    <p class="text-gray-300">The verification oracle accepts if K[1] = 1. Since K is chosen at random we have  <span class="math">\\mathbf{Adv}_{\\overline{\\Pi},\\overline{A}}^{\\text{SUF-1}}(k) = 1/2</span> . This is relevant because otherwise we would contradict Corollary 5.2.</p>

    <p class="text-gray-300">In contrast to the case of standard unforgeability, under the strong unforgeability definition, the single and multiple verification query versions are equivalent. We prove the equivalence and also state the quantitative relation between the advantages, since this is important for practical applications.</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> [SUF-1  <span class="math">\\Rightarrow</span>  SUF-M] Let  <span class="math">\\Pi = (\\mathsf{TG}, \\mathsf{VF})</span>  be a ma-scheme. Let A be an adversary making at most  <span class="math">v(\\cdot)</span>  verification queries. Then there exists an adversary B, making only one verification query, such that for all  <span class="math">k \\in \\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi,A}^{\\text{SUF-M}}(k) \\leq v(k) \\cdot \\mathbf{Adv}_{\\Pi,B}^{\\text{SUF-1}}(k) . \\tag{2}</span>$</p>

    <p class="text-gray-300">Furthermore, the number of tagging queries made by B is the same as the number made by A, and the running time of B is that of A plus  <span class="math">O((v+t)\\tau)</span>  where  <span class="math">t(\\cdot)</span>  is a bound on the number of tagging queries made by A and  <span class="math">\\tau(\\cdot)</span>  is a bound on the lengths of messages and tags in A's oracle queries.</p>

    <p class="text-gray-300">The following is immediate:</p>

    <p class="text-gray-300">Corollary 5.2 [SUF-1  <span class="math">\\Rightarrow</span>  SUF-M] If a ma-scheme is SUF-1 secure then it is also SUF-M secure.</p>

    <p class="text-gray-300">Since the relations SUF-M  <span class="math">\\Rightarrow</span>  UF-M and UF-M  <span class="math">\\Rightarrow</span>  UF-1 are trivial, it follows that a ma-scheme that is SUF-1 secure is also SUF-M, UF-M and UF-1 secure, meaning meets all the four notions we have considered.</p>

    <p class="text-gray-300"><strong>Proof of Theorem 5.1:</strong> The required adversary B is exactly the one called  <span class="math">B_2</span>  in Figure 3. For the analysis, let  <span class="math">(M_1, Tag_1), (M_2, Tag_2), \\ldots</span>  denote the verification-oracle queries made by A in  <span class="math">\\mathbf{Exp}_{\\Pi,A}^{\\mathrm{SUF-M}}(k)</span> . Let the random variable I take value the smallest index i such that  <span class="math">\\mathsf{VF}(K, M_i, Tag_i) = 1</span>  and  <span class="math">Tag_i \\notin \\mathsf{TAGSET}[M_i]</span>  if such an index exists, and 0 otherwise.</p>

    <p class="text-gray-300">In the simulation of A provided by B, we notice that if guess  <span class="math">\\leq I</span> , then for all  <span class="math">1 \\leq i &lt; guess</span> , the reply provided by B to the i-th verification-oracle query of A is correct, meaning equals  <span class="math">\\mathsf{VF}(K, M_i, Tag_i)</span> . On the other hand the random choice of guess is independent of the view of A as long as B has not halted. So</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{SUF-1}}_{\\Pi,B}(k) \\; = \\; \\Pr \\left[ \\; \\mathsf{guess} = I \\wedge I \\geq 1 \\; \\right] \\; \\geq \\; \\Pr \\left[ \\; \\mathsf{guess} = I \\; \\right] \\cdot \\Pr \\left[ \\; I \\geq 1 \\; \\right] \\; = \\; \\frac{1}{v(k)} \\cdot \\mathbf{Adv}^{\\mathrm{SUF-M}}_{\\Pi,A}(k) \\; .</span>$</p>

    <p class="text-gray-300">Towards applying Corollary 5.2 to existing ma-schemes, we establish SUF-1 for certain important classes.</p>

    <p class="text-gray-300">MACs. Suppose ma-scheme Π = (TG, VF) is a MAC. This implies that for any message M and key K there is only one tag that VF will accept, namely TG(K, M). Thus:</p>

    <p class="text-gray-300">Proposition 6.1 Let Π be a UF-1 MAC. Then it is also SUF-1.</p>

    <p class="text-gray-300">So by Corollary 5.2, any UF-1 MAC is UF-M and SUF-M. As an application, since HMAC is proven UF-1 in [1], the above shows it is UF-M and SUF-M.</p>

    <p class="text-gray-300">PRF-based MACs. Any PRF-based MAC is UF-M secure [5], and, being a MAC, we can then apply the above to get UF-M, SUF-M security. It is worth stating the concrete security of the reduction underlying this easy result, however, since it provides the backdrop for our later improvement:</p>

    <p class="text-gray-300">Proposition 6.2 [PRF-based MACs are SUF-M, basic reduction] Let F be a PRF with outputlength τ (·). Let A be an adversary making at most v(·) verification queries. Then there exists a PRF adversary B such that for any k ∈ N</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi[F],A}^{\\text{SUF-M}}(k) \\leq \\frac{v(k)}{2^{\\tau(k)}} + v(k) \\cdot \\mathbf{Adv}_{F,B}^{\\text{PRF}}(k) . \\tag{3}</span>$</p>

    <p class="text-gray-300">Furthermore, the number of oracle queries made by B is at most t(·) + 1, and the running time of B is that of A plus O((v + t)τ ), where t(·) is a bound on the number of tagging queries made by A.</p>

    <p class="text-gray-300">As an application, various CBC-MACs [5, 10, 22], PMAC [11], TMAC [17] and OMAC [18] are UF-M and SUF-M. (But Proposition 7.3 yields better results.)</p>

    <p class="text-gray-300">CW-ma-schemes. The Carter-Wegman paradigm [25] is now yielding the most efficient maschemes. UMAC [8, 9] is the canonical example. These schemes are nonce-based (the nonce is either a counter or a random number) and in particular are not MACs in the sense defined above, so the above does not apply. Via a closer look at the proof of the UF-1 security [21, 23, 16, 8, 9], however, one can establish SUF-1 as well. Details follow. For simplicity we consider only the case where the nonce is a counter.</p>

    <p class="text-gray-300">Let H be a family of functions with domain {Dk}k∈N, output length τ (·) and key-length lH(·). Let F be a family of functions with domain {{0, 1} &lt;sup&gt;k&lt;/sup&gt;}k∈N, output length τ (·) and key-length l&lt;sup&gt;F&lt;/sup&gt; (·). We associate to them the counter-based CW ma-scheme Π[H, F] which has key-length lH(·)+l&lt;sup&gt;F&lt;/sup&gt; (·) and the following tagging and verification algorithms. Below, N is a k-bit counter which is initially 0 and then incremented with each invocation of TG.</p>

    <p class="text-gray-300">Algorithm
<span class="math">$\\mathsf{TG}(HK \\| FK, M)</span>$
Algorithm  <span class="math">\\mathsf{VF}(HK \\| FK, M, Tag)</span>  Parse  <span class="math">Tag</span>  as  <span class="math">(N, \\sigma)</span>
<span class="math">$\\sigma&#x27; \\leftarrow F(FK, N) \\oplus H(HK, M)</span>$
Return  <span class="math">Tag</span>  If  <span class="math">(\\sigma = \\sigma&#x27;)</span>  then return 1 else return 0</p>

    <p class="text-gray-300">The message space is the domain of H. The proof of the following is in Appendix A.1.</p>

    <p class="text-gray-300"><strong>Proposition 6.3</strong> [Security of CW-ma-schemes] Let families H, F be as above, both with outputlength  <span class="math">\\tau(\\cdot)</span> . Assume H is an  <span class="math">\\epsilon(\\cdot)</span> -AXU family and F is a PRF. Let  <span class="math">\\Pi[H, F]</span>  be the associated CW-ma-scheme as above. Let A be any adversary who makes at most  <span class="math">t(k) &lt; 2^k</span>  queries to its tagging oracle and one query to its verification oracle. Then there exists a PRF adversary B such that for all  <span class="math">k \\in \\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi[H,F],A}^{\\text{SUF-1}}(k) \\leq 2^{-\\tau(k)} + \\epsilon(k) + \\mathbf{Adv}_{F,B}^{\\text{PRF}}(k) . \\tag{4}</span>$</p>

    <p class="text-gray-300">Furthermore, the number of oracle queries made by B is  <span class="math">t(\\cdot) + 1</span>  and the running time of B is that of A plus  <span class="math">O(t\\tau)</span> .</p>

    <p class="text-gray-300">Since UMAC [8, 9] and MMH-MAC [16] were shown to be UF-1 in the cited papers, the above together with Corollary 5.2 shows they are UF-M and SUF-M.</p>

    <p class="text-gray-300">Using Theorem 5.1 to establish UF-M and SUF-M security of ma-schemes results, as per Equation (2), in a factor  <span class="math">v(\\cdot)</span>  loss in the advantage. As we have discussed in Section 1.4, this can be appreciable in practice. This section looks into getting better reductions.</p>

    <p class="text-gray-300">NO BETTER SUF-1  <span class="math">\\Rightarrow</span>  SUF-M REDUCTION. The first, natural question to ask is whether Theorem 5.1 represents the best possible reduction, or whether there is a better one. We claim there is no better one, even for the special case of ma-schemes that are MACs. To establish this we begin with the following, whose proof is in Appendix A.2:</p>

    <p class="text-gray-300"><strong>Proposition 7.1</strong> Assume PRFs exist. Then for any polynomial  <span class="math">v(\\cdot)</span>  there exists a MAC  <span class="math">\\Pi</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) There exists a polynomial-time adversary A that makes at most  <span class="math">v(\\cdot)</span>  verification queries and achieves  <span class="math">\\mathbf{Adv}_{\\Pi,A}^{\\mathrm{SUF-M}}(k) = 1</span> , and</li>
      <li>(2) For any polynomial-time adversary B making only one verification query, there is a negligible function  <span class="math">s(\\cdot)</span>  such that  <span class="math">\\mathbf{Adv}_{\\Pi,B}^{\\mathrm{SUF-1}}(k) \\leq 2/v(k) + s(k)</span>  for all  <span class="math">k \\in \\mathbb{N}</span> .</li>
    </ul>

    <p class="text-gray-300">Now let us see why this Proposition shows that the reduction of Theorem 5.1 cannot be improved. View a reduction as a transform  <span class="math">\\mathcal{B}</span>  that given a ma-scheme  <span class="math">\\Pi</span> , a polynomial v and a polynomial-time adversary A making v verification queries, outputs a polynomial-time SUF-1 adversary  <span class="math">\\mathcal{B}(\\Pi, v, A)</span> . We say that  <span class="math">\\mathcal{B}</span>  has reduction factor  <span class="math">\\phi(\\cdot)</span>  if</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{SUF-1}}_{\\Pi,\\,\\mathcal{B}(\\Pi,v,A)}(k) \\; \\geq \\; \\phi(v(k)) \\cdot \\mathbf{Adv}^{\\mathrm{SUF-M}}_{\\Pi,A}(k)</span>$</p>

    <p class="text-gray-300">for all  <span class="math">\\Pi, A</span>  and k. Theorem 5.1 provides a reduction with reduction factor  <span class="math">\\phi(n) = 1/n</span> . Now we claim:</p>

    <p class="text-gray-300">Corollary 7.2 If PRFs exist then the reduction factor of any reduction is O(1/n).</p>

    <p class="text-gray-300">So no reduction has a reduction factor that is better than the one of Theorem 5.1 by more than a constant factor. The proof of Corollary 7.2 is in Appendix A.2.</p>

    <p class="text-gray-300">One might observe that the MAC of Proposition 7.1 is neither SUF-1 nor SUF-M secure. This did not preclude it being useful with regard to establishing the un-improvability of the reduction of Theorem 5.1, for the ma-scheme in that theorem is also not assumed to be secure in any sense. Indeed, a reduction transforms an adversary of one type into an adversary of another type with some relation between the advantages, regardless of whether the underlying scheme is secure or not, so the tightness of its reduction factor may be assessed via its performance on insecure schemes.</p>

    <p class="text-gray-300">Improvements for PRF based MACs. Although the above precludes improved concrete security results for MACs in general, we note that one can improve the reduction for PRF-based MACs given in Proposition 6.2 to show the following, whose proof is in Appendix A.3:</p>

    <p class="text-gray-300">Proposition 7.3 [PRF-based MACs are SUF-M, improved version] Let F be a PRF with outputlength τ (·). Let A be an adversary making at most v(·) verification queries. Then there exists a PRF adversary B such that for any k ∈ N</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi[F],A}^{\\text{SUF-M}}(k) \\leq \\frac{v(k)}{2^{\\tau(k)}} + \\mathbf{Adv}_{F,B}^{\\text{PRF}}(k) . \\tag{5}</span>$</p>

    <p class="text-gray-300">Furthermore, the number of oracle queries made by B is at most v(·) + t(·), and the running time of B is that of A plus O((v + t)τ ), where t(·) is a bound on the number of tagging queries made by A.</p>

    <p class="text-gray-300">The improvement relative to Proposition 6.2 is to eliminate the factor of v(k) multiplying AdvPRF F,B (k) at the cost of allowing B an extra v(·) verification queries. However, typically t(·) ≥ v(·), so the number of oracle queries of B in fact only increases by a constant factor and the improvement is essentially for free. Now, under typical choices of τ (·), the v(k)2−τ(k) term is negligible compared to the other term, so roughly the bound is better than that of Proposition 6.2 by a factor v(k). This forms the basis for the examples, discussed in Section 1.4, which showed that the improvement has appreciable practical impact. We note that as applications we obtain UF-M, SUF-M security for the CBC-MACs [5, 10, 22], PMAC [11], TMAC [17] and OMAC [18] with concrete security that is better than that envisaged at the time people believed UF-1 ⇒ UF-M, even though we now know this implication is not even true.</p>

    <p class="text-gray-300">We thank Bodo Moeller for comments on a previous draft.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] M. Bellare, R. Canetti and H. Krawczyk. Keying hash functions for message authentication. Advances in Cryptology – CRYPTO '96, Lecture Notes in Computer Science Vol. 1109, N. Koblitz ed., Springer-Verlag, 1996.</p></li>
      <li><p class="text-gray-300">[2] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. Advances in Cryptology – CRYPTO '98, Lecture Notes in Computer Science Vol. 1462, H. Krawczyk ed., Springer-Verlag, 1998.</p></li>
      <li><p class="text-gray-300">[3] M. Bellare, O. Goldreich and H. Krawczyk. Stateless evaluation of pseudorandom functions: Security beyond the birthday barrier. Advances in Cryptology – CRYPTO '96, Lecture Notes in Computer Science Vol. 1109, N. Koblitz ed., Springer-Verlag, 1996.</p></li>
      <li><p class="text-gray-300">[4] M. Bellare, R. Guerin ´ and P. Rogaway. XOR MACs: New methods for message authentication using finite pseudorandom functions. Advances in Cryptology – CRYPTO '95, Lecture Notes in Computer Science Vol. 963, D. Coppersmith ed., Springer-Verlag, 1995.</p></li>
      <li><p class="text-gray-300">[5] M. Bellare, J. Kilian and P. Rogaway. The security of the cipher block chaining message authentication code. Journal of Computer and System Sciences, Vol. 61, No. 3, Dec 2000, pp. 362–399.</p></li>
      <li><p class="text-gray-300">[6] M. Bellare and C. Namprempre. Authenticated encryption: Relations among notions and analysis of the generic composition paradigm. Advances in Cryptology – ASIACRYPT '00, Lecture Notes in Computer Science Vol. 1976, T. Okamoto ed., Springer-Verlag, 2000.</p></li>
      <li><p class="text-gray-300">[7] M. Bellare and P. Rogaway. Encode-then-encipher encryption: How to exploit nonces or redundancy in plaintexts for efficient cryptography. Advances in Cryptology – ASIACRYPT '00, Lecture Notes in Computer Science Vol. 1976, T. Okamoto ed., Springer-Verlag, 2000.</p></li>
      <li><p class="text-gray-300">[8] J. Black, S. Halevi, H. Krawczyk, T. Krovetz and P. Rogaway. UMAC: Fast and Secure Message Authentication. Advances in Cryptology – CRYPTO '99, Lecture Notes in Computer Science Vol. 1666, M. Wiener ed., Springer-Verlag, 1999. [Preliminary version of [9]].</p></li>
      <li><p class="text-gray-300">[9] J. Black, S. Halevi, H. Krawczyk, T. Krovetz and P. Rogaway. UMAC: Fast and Secure Message Authentication. http://www.cs.ucdavis.edu/~rogaway/papers/ umac-full.ps. [Full version of [8]].</p></li>
      <li><p class="text-gray-300">[10] J. Black and P. Rogaway. CBC MACs for arbitrary-length messages: The three-key constructions. Advances in Cryptology – CRYPTO '00, Lecture Notes in Computer Science Vol. 1880, M. Bellare ed., Springer-Verlag, 2000.</p></li>
      <li><p class="text-gray-300">[11] J. Black and P. Rogaway. A block-cipher mode of operation for parallelizable message authentication. Advances in Cryptology – EUROCRYPT '02, Lecture Notes in Computer Science Vol. 2332, L. Knudsen ed., Springer-Verlag, 2002.</p></li>
      <li><p class="text-gray-300">[12] D. Dolev, C. Dwork, and M. Naor. Nonmalleable cryptography. SIAM Journal of Computing, Vol. 30, No. 2, 2000, pp. 391–437.</p></li>
      <li><p class="text-gray-300">[13] O. Goldreich. Foundations of Cryptography: Volume II, Basic applications. Cambridge University Press, 2004.</p></li>
      <li><p class="text-gray-300">[14] O. Goldreich, S. Goldwasser and S. Micali. How to construct random functions. Journal of the ACM, Vol. 33, No. 4, 1986, pp. 210–217.</p></li>
      <li><p class="text-gray-300">[15] S. Goldwasser, S. Micali and R. Rivest. A digital signature scheme secure against adaptive chosen-message attacks. SIAM Journal of Computing, Vol. 17, No. 2, 1988, pp. 281– 308.</p></li>
      <li><p class="text-gray-300">[16] S. Halevi and H. Krawczyk. MMH: Message authentication in software in the Gbit/sec rate. Fast Software Encryption '97, Lecture Notes in Computer Science Vol. 1267, E. Biham ed., Springer-Verlag, 1997.</p></li>
      <li><p class="text-gray-300">[17] T. Iwata and K. Kurosawa. TMAC: Two-Key CBC MAC. Topics in Cryptology CT-RSA '02, Lecture Notes in Computer Science Vol. 2271, B. Preneel ed., Springer-Verlag, 2002.</p></li>
      <li><p class="text-gray-300">[18] T. Iwata and K. Kurosawa. OMAC: One-key CBC MAC. Fast Software Encryption '03, Lecture Notes in Computer Science Vol. 2887, T. Johansson ed., Springer-Verlag, 2003.</p></li>
      <li><p class="text-gray-300">[19] J. Katz and M. Yung. Unforgeable encryption and chosen-ciphertext secure modes of operation. Fast Software Encryption '00, Lecture Notes in Computer Science Vol. 1978, B. Schneier ed., Springer-Verlag, 2000.</p></li>
      <li><p class="text-gray-300">[20] E. Jaulmes, A. Joux and F. Valette. On the security of randomized CBC-MAC beyond the birthday paradox limit: A new construction. <em>Fast Software Encryption '02</em>, Lecture Notes in Computer Science Vol. 2365, J. Daemen and V. Rijmen ed., Springer-Verlag, 2002.</p></li>
      <li><p class="text-gray-300">[21] H. KRAWCZYK. LFSR-based hashing and authentication. Advances in Cryptology CRYPTO '94, Lecture Notes in Computer Science Vol. 839, Y. Desmedt ed., Springer-Verlag, 1994.</p></li>
      <li><p class="text-gray-300">[22] E. Petrank and C. Rackoff. CBC MAC for real-time data sources. <em>Journal of Cryptology</em>, Vol. 13, No. 3, 2000, pp. 315–338.</p></li>
      <li><p class="text-gray-300">[23] P. Rogaway. Bucket hashing and its application to fast message authentication. <em>Journal of Cryptology</em>, Vol. 12, No. 2, 1999, pp. 91–115.</p></li>
      <li><p class="text-gray-300">[24] D. STINSON. Cryptography theory and practice, Second edition. Chapman and Hall/CRC, 2002.</p></li>
      <li><p class="text-gray-300">[25] M. WEGMAN AND L. CARTER. New hash functions and their use in authentication and set equality. <em>Journal of Computer and System Sciences</em>, Vol. 22, No. 3, 1981, pp. 265–279.</p></li>
    </ul>

    <h2 id="sec-9" class="text-2xl font-bold">A Proofs</h2>

    <p class="text-gray-300">This section provides proofs omitted from the body of the paper.</p>

    <h2 id="sec-10" class="text-2xl font-bold">A.1 Proof of Proposition 6.3</h2>

    <p class="text-gray-300"><strong>Proof of Proposition 6.3:</strong> The main part of the security proof considers the thought experiment in which  <span class="math">F(FK,\\cdot)</span>  is replaced by a random function  <span class="math">f(\\cdot)</span>  with output-length  <span class="math">\\tau(\\cdot)</span> . Formally, this means we consider the security of the ma-scheme  <span class="math">\\Pi[H,R]</span>  where R is the family of all functions having the same domain and output-length as F. We now bound  <span class="math">\\mathbf{Adv}_{\\Pi[H,R],A}^{\\mathrm{SUF-1}}(k)</span> .</p>

    <p class="text-gray-300">By assumption A makes at most  <span class="math">2^k</span>  tagging queries, thus the tagging oracle never replies to two queries with the same nonce. Let M, (N, S) denote the single verification query made by A. If the nonce N is new, then clearly the probability that the tag is correct is at most  <span class="math">2^{-\\tau(k)}</span>  since f has never before been invoked on input N.</p>

    <p class="text-gray-300">However, there could have been a previous query M' to the tagging oracle returning a tag of the form (N, S'). If M' = M then the only way that (N, S) is a correct tag for M is that S' = S, so in this case there is no strong forgery. So assume  <span class="math">M&#x27; \\neq M</span> . In that case the argument reduces to that of the UF-1 case. Namely, we have</p>

    <p class="text-gray-300"><span class="math">$S \\oplus S&#x27; = (f(N) \\oplus h(M)) \\oplus (f(N) \\oplus h(M&#x27;)) = h(M) \\oplus h(M&#x27;)</span>$</p>

    <p class="text-gray-300">and the probability that this can happen is at most  <span class="math">\\epsilon(k)</span>  by assumption that H is  <span class="math">\\epsilon(\\cdot)</span> -AXU. In summary</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{SUF-1}}_{\\Pi[H,R],A}(k) \\leq 2^{-\\tau(k)} + \\epsilon(k)</span>$
.</p>

    <p class="text-gray-300">Now one can lift this to the statement of the Proposition, using the assumption that F is a PRF, in a standard way.</p>

    <h2 id="sec-11" class="text-2xl font-bold">A.2 Proofs of Proposition 7.1 and Corollary 7.2</h2>

    <p class="text-gray-300">Proof of Proposition 7.1: Let w(·) = blog&lt;sup&gt;2&lt;/sup&gt; v(·)c. Let F be a PRF with output-length w(·) and let Π = Π[F] = (TG, VF) be the associated PRF-based MAC, with message space the domain of F and key-length that of F. (Note by definition TG = F.) Adversary A works as follows:</p>

    <p class="text-gray-300">Adversary ATG(K,·),VF(K,·,·) (1&lt;sup&gt;k&lt;/sup&gt; )</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">Let M be an arbitrary message in the message space For each Tag ∈ {0, 1} &lt;sup&gt;w&lt;/sup&gt;(k) do d(Tag) ← VF(K, M, Tag)</p>

    </blockquote>

    <p class="text-gray-300">Since TG(K, M) = F(K, M) ∈ {0, 1} &lt;sup&gt;w&lt;/sup&gt;(k) we have AdvSUF-&lt;sup&gt;M&lt;/sup&gt; &lt;sup&gt;Π&lt;/sup&gt;,A (k) = 1. The number of verification queries made by A is 2 &lt;sup&gt;w&lt;/sup&gt;(k) ≤ v(k). So we have item (1) of the Proposition. Now suppose B is a polynomial-time adversary making only one verification query. We associate to it the polynomialtime PRF adversary D that, given an oracle f(·), works as follows. It runs B on input 1 k . When B makes a query M to its tagging oracle, D returns f(M) to B. When B makes a query M, Tag to its verification oracle, D halts, outputting 1 if f(M) = Tag and M was not a query to the tagging oracle, and outputting 0 otherwise. Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[D^{F(K,\\cdot)}(1^k) = 1\\right] = \\mathbf{Adv}_{\\Pi,B}^{\\text{SUF-1}}(k) \\quad \\text{ and } \\quad \\Pr\\left[B^{f(\\cdot)}(1^k) = 1\\right] \\leq \\frac{1}{2^{w(k)}} \\leq \\frac{2}{v(k)},</span>$</p>

    <p class="text-gray-300">where in the first case the probability is over a random choice of K and in the second over a random choice of function f. So we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi,B}^{\\text{SUF-1}}(k) \\leq \\frac{2}{v(k)} + \\mathbf{Adv}_{F,B}^{\\text{PRF}}(k)</span>$
.</p>

    <p class="text-gray-300">Since the last function is negligible, we have item (2) of the Proposition.</p>

    <p class="text-gray-300">Proof of Corollary 7.2: Let v(·) be a polynomial and let Π be the MAC associated to it by Proposition 7.1. Let B be a reduction with reduction factor φ. Proposition 7.1 says there is a polynomial-time SUF-M adversary A, making v(·) verification queries, such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi,\\,\\mathcal{B}(\\Pi,v,A)}^{\\mathrm{SUF-1}}(k) \\; \\leq \\; \\frac{\\Theta(1)}{v(k)} \\; = \\; \\frac{\\Theta(1)}{v(k)} \\cdot \\mathbf{Adv}_{\\Pi,A}^{\\mathrm{SUF-M}}(k)</span>$</p>

    <p class="text-gray-300">for all k. So φ(n) = O(1/n).</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">A.3 Proof of Proposition 7.3</h3>

    <p class="text-gray-300">Proof of Proposition 7.3: Adversary B is given input 1 &lt;sup&gt;k&lt;/sup&gt; and an oracle f: D&lt;sup&gt;k&lt;/sup&gt; → {0, 1} τ(k) . It runs A on input 1 k . When A makes a query M to its tagging oracle, B responds with f(M). When A makes a query M, Tag to its verification oracle, B returns 1 to A if f(M) = Tag and 0 otherwise. Finally, B outputs 1 if A succeeded in strong forgery, and 0 otherwise. (In the first case it is betting f is an instance of F, and in the second it is betting f was chosen at random from Maps(Dk, {0, 1} τ(k) ). The analysis is standard.</p>

    <p class="text-gray-300">An authenticated encryption scheme is a symmetric encryption scheme that simultaneously provides privacy and authenticity. We are not concerned here with the privacy. Let us state the definitions of authenticity we consider.</p>

    <pre><code class="language-text">Experiment \\mathbf{Exp}_{\\Pi,A}^{\\mathsf{type}}(k)
    K \\stackrel{\\$}{\\leftarrow} \\{0,1\\}^{l(k)}; count \\leftarrow 0; fp \\leftarrow 0; fc \\leftarrow 0
     Run A on input 1^k, replying to its oracle queries as follows:
         When A makes a query M to Enc_K(\\cdot) do
              C \\stackrel{\\$}{\\leftarrow} \\mathsf{Enc}_K(M); CTXTSETM \\leftarrow \\mathsf{CTXTSET}M \\cup \\{C\\}; Return C to A
         When A makes a query C to De^*(\\cdot) do
              d \\leftarrow \\mathsf{De}_K^*(C) \\; ; \\; \\mathsf{count} \\leftarrow \\mathsf{count} + 1
              If d = 1 then
                   If CTXTSETM = \\emptyset then \\mathsf{fp} \\leftarrow 1; If C \\notin \\mathsf{CTXTSET}M then \\mathsf{fc} \\leftarrow 1
              Return d to A
     If (type = INT-PTXT-1)
                                            then return (count = 1) \\wedge fp
     If (type = INT-PTXT-M)
                                           then return fp
                                            then return (count = 1) \\wedge fc
     If (type = INT-CTXT-1)
     If (type = INT-CTXT-M)
                                           then return fc
</code></pre>

    <p class="text-gray-300">Figure 4: Experiment defining four notions of security of authenticated encryption scheme.</p>

    <p class="text-gray-300">FOUR SECURITY NOTIONS. A symmetric encryption scheme  <span class="math">\\Pi = (\\mathsf{Kg}, \\mathsf{Enc}, \\mathsf{De})</span>  is specified as usual via its key-generation, encryption and decryption algorithms. The last either returns a string or the symbol  <span class="math">\\bot</span>  to indicate rejection. The scheme has an associated key-length  <span class="math">l(\\cdot)</span> . We associate to the scheme a verification algorithm  <span class="math">\\mathsf{De}^*</span>  that on input a key K and ciphertext C runs  <span class="math">\\mathsf{De}(K,C)</span> , returning 0 if the result is  <span class="math">\\bot</span>  and 1 otherwise. We now formally define four notions of integrity. (We use the term integrity synonymously with authenticity.) Let  <span class="math">\\mathsf{type} \\in \\{\\mathsf{INT-PTXT-1}, \\mathsf{INT-PTXT-M}, \\mathsf{INT-CTXT-1}, \\mathsf{INT-CTXT-M}\\}</span> . Let A be an adversary with access to an encryption oracle  <span class="math">\\mathsf{Enc}(K,\\cdot)</span>  and a verification oracle  <span class="math">\\mathsf{De}^*(K,\\cdot)</span> , and let  <span class="math">k \\in \\mathbb{N}</span> . We define the experiment depicted in Figure 4. We let</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathsf{type}}_{\\Pi,A}(k) \\; = \\; \\Pr \\left[ \\; \\mathbf{Exp}^{\\mathsf{type}}_{\\Pi,A}(k) = 1 \\; \\right]</span>$</p>

    <p class="text-gray-300">denote the winning probability for A in the experiment in question. We say that  <span class="math">\\Pi</span>  is type-secure if the function  <span class="math">\\mathbf{Adv}_{\\Pi,A}^{\\mathsf{type}}(\\cdot)</span>  is negligible for any polynomial time adversary A.</p>

    <p class="text-gray-300">In the experiment, access to the encryption oracle allows the adversary to mount a chosen-message attack. The adversary succeeds if it makes the verification oracle accept an &quot;illegitimate ciphertext.&quot; Integrity of plaintexts calls a ciphertext illegitimate if the corresponding plaintext was never queried to the encryption oracle, while integrity of ciphertexts calls a ciphertext illegitimate if it was never returned by the encryption oracle. In each case one may allow either one or many verification queries, giving rise to the four notions we have defined. Historically, INT-PTXT-M and INT-CTXT-M are from [6] while INT-CTXT-1 is from [19, 7]. INT-PTXT-1 is new.</p>

    <p class="text-gray-300">RESULTS. We depict in Figure B the relations between the four notions of integrity for symmetric encryption schemes. As usual, arrows represent implications and barred arrows represent separations. INT-CTXT-M  <span class="math">\\Rightarrow</span>  INT-PTXT-M and INT-PTXT-M  <span class="math">\\Rightarrow</span>  INT-CTXT-M were known [6], and easily extend to show INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-PTXT-1 and INT-PTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-1. Our main results are INT-PTXT-1  <span class="math">\\Rightarrow</span>  INT-PTXT-M and INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M. We also show that the latter reduction is tight. Formal statements follow.</p>

    <p class="text-gray-300"><strong>Theorem B.1</strong> [INT-PTXT-1 ≠ INT-PTXT-M] Assume there exists an INT-PTXT-1-secure sym-</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 5: An arrow represents an implication and a barred arrow represents a separation.</p>

    <p class="text-gray-300">metric encryption scheme. Then there exists an INT-PTXT-1-secure symmetric encryption scheme which is not INT-PTXT-M-secure.</p>

    <p class="text-gray-300"><strong>Proof:</strong> By assumption there exists a INT-PTXT-1-secure symmetric key encryption scheme  <span class="math">\\overline{\\Pi} = (Kg, Enc, De)</span> . The counterexample is the symmetric key encryption scheme  <span class="math">\\overline{\\Pi} = (\\overline{Kg}, \\overline{Enc}, \\overline{De})</span>  whose key-generation algorithm  <span class="math">\\overline{Kg}</span>  is the same as Kg and whose encryption and decryption algorithms are specified below:</p>

    <p class="text-gray-300">Algorithm
<span class="math">$\\overline{\\mathsf{Enc}}(K,M)</span>$
| Algorithm  <span class="math">\\overline{\\mathsf{De}}(K,\\overline{\\mathtt{c}})</span>  |  <span class="math">\\mathsf{C} \\leftarrow \\mathsf{Enc}(K,M)</span>  |  <span class="math">\\mathsf{Parse c as c} \\| \\langle i \\rangle \\text{ where } i \\in \\{0,1,\\ldots,|K|\\}</span>  |  <span class="math">\\mathsf{C} \\leftarrow \\mathsf{C} \\| \\langle 0 \\rangle</span>  |  <span class="math">\\mathsf{Return } \\overline{\\mathtt{c}}</span>  |  <span class="math">\\mathsf{If } (M = \\bot \\text{ or } i = 0) \\text{ then return } M</span>  |  <span class="math">\\mathsf{If } (M \\neq \\bot \\text{ and } i \\geq 1 \\text{ and } K[i] = 1) \\text{ then return } M</span>  |  <span class="math">\\mathsf{If } (M \\neq \\bot \\text{ and } i \\geq 1 \\text{ and } K[i] = 0) \\text{ then return } \\bot</span></p>

    <p class="text-gray-300">This encryption scheme has the following 2 properties:</p>

    <p class="text-gray-300">(1) There exists polynomial-time adversary  <span class="math">\\overline{A}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\overline{\\Pi}.\\overline{A}}^{\\underline{\\mathrm{INT}}-\\mathrm{PTXT-M}}(k) = 1.</span>$</p>

    <p class="text-gray-300">(2) Let  <span class="math">\\overline{A}</span>  be any polynomial-time INT-PTXT-1-adversary attacking  <span class="math">\\overline{\\Pi}</span> . We can assume it makes exactly one query to its verification oracle. Then there exists a polynomial-time INT-PTXT-1 adversary A attacking  <span class="math">\\Pi</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\overline{\\Pi},\\overline{A}}^{\\mathrm{INT-PTXT-1}}(k) \\ \\leq \\ \\mathbf{Adv}_{\\Pi,A}^{\\mathrm{INT-PTXT-1}}(k) \\ .</span>$</p>

    <p class="text-gray-300">The proofs of these claims are analogous to the ones for ma-schemes and thus we omit them.</p>

    <p class="text-gray-300"><strong>Theorem B.2</strong> [INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M] Let  <span class="math">\\Pi = (\\mathsf{Kg}, \\mathsf{Enc}, \\mathsf{De})</span>  be a symmetric encryption scheme. Let A be an adversary making at most  <span class="math">v(\\cdot)</span>  verification queries. Then there exists an adversary B, making only one verification query, such that for all  <span class="math">k \\in \\mathbb{N}</span></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi,A}^{\\text{INT-CTXT-M}}(k) \\leq v(k) \\cdot \\mathbf{Adv}_{\\Pi,B}^{\\text{INT-CTXT-1}}(k) . \\tag{6}</span>$</p>

    <p class="text-gray-300">Furthermore, the number of encryption queries made by B is the same as the number made by A, and the running time of B is that of A plus  <span class="math">O((v+t)\\tau)</span>  where  <span class="math">t(\\cdot)</span>  is a bound on the number of encryption queries made by A and  <span class="math">\\tau(\\cdot)</span>  is a bound on the lengths of messages and ciphertexts in A's oracle queries.</p>

    <p class="text-gray-300"><strong>Proof:</strong> Adversary B is specified below:</p>

    <p class="text-gray-300">Adversary
<span class="math">$B^{\\mathsf{Enc}(K,\\cdot),\\mathsf{De}^*(K,\\cdot)}(1^k)</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathsf{count} \\leftarrow 0 \\; ; \\; \\mathsf{guess} \\stackrel{\\</span>}{\\leftarrow} [v(k)] ; ; ; \\mathsf{CTXTSET} \\leftarrow \\emptyset$</p>

    <p class="text-gray-300">Run A on input  <span class="math">1^k</span> , replying to its oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When A makes a query M to  <span class="math">\\operatorname{Enc}(K,\\cdot)</span>  do  <span class="math">c \\stackrel{\\</span>}{\\leftarrow} \\operatorname{Enc}(K,M)$ ; CTXTSET  <span class="math">\\leftarrow</span>  CTXTSET  <span class="math">\\cup \\{c\\}</span> ; Return c to A When A makes a query c to  <span class="math">\\operatorname{De}^*(K,\\cdot)</span>  do count  <span class="math">\\leftarrow</span>  count + 1 If (count &gt; guess) then Halt    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">(c \\in CTXTSET)</span>  then return 1 to A</li>
      <li>If (count &lt; guess) then return 0 to A</li>
      <li>If (count = guess) then  <span class="math">d \\leftarrow \\mathsf{De}^*(K, c)</span> ; Halt</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">For the analysis, let  <span class="math">c_1, c_2, \\ldots</span>  denote the verification-oracle queries made by A in  <span class="math">\\mathbf{Exp}_{\\Pi,A}^{\\mathrm{INT-CTXT-M}}(k)</span> . Let the random variable I take value the smallest index i such that  <span class="math">\\mathsf{De}^*(K, c_i) = 1</span>  and  <span class="math">c_i \\not\\in \\mathsf{CTXTSet}</span> , and 0 otherwise.</p>

    <p class="text-gray-300">In the simulation of A provided by B, we notice that if guess  <span class="math">\\leq I</span> , then for all  <span class="math">1 \\leq i &lt;</span>  guess, the reply provided by B to the i-th verification-oracle query of A is correct, meaning equals  <span class="math">\\mathsf{De}^*(K, c_i)</span> . On the other hand the random choice of guess is independent of the view of A as long as B has not halted. So</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Adv}_{\\Pi,B}^{\\mathrm{INT-CTXT-1}}(k) &amp;= &amp; \\Pr\\left[\\,\\mathsf{guess} = I \\wedge I \\geq 1\\,\\right] \\\\ &amp;\\geq &amp; \\Pr\\left[\\,\\mathsf{guess} = I\\,\\right] \\cdot \\Pr\\left[\\,I \\geq 1\\,\\right] \\\\ &amp;= &amp; \\frac{1}{v(k)} \\cdot \\mathbf{Adv}_{\\Pi,A}^{\\mathrm{INT-CTXT-M}}(k) \\;. \\end{split}</span>$</p>

    <p class="text-gray-300">This establishes Equation (6).</p>

    <p class="text-gray-300">Corollary B.3 [SUF-1  <span class="math">\\Rightarrow</span>  SUF-M] If a symmetric encryption scheme is INT-CTXT-1-secure then it is also INT-CTXT-M-secure.</p>

    <p class="text-gray-300">NO BETTER INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M REDUCTION. Theorem B.2 establishes INT-CTXT-M-security with a factor of v(k) security loss. We claim that this loss is unavoidable and there is no better reduction. To prove it we will use the results for me-schemes from Section 7.</p>

    <p class="text-gray-300"><strong>Proposition B.4</strong> Assume PRFs exist. Then for any polynomial  <span class="math">v(\\cdot)</span>  there exists a symmetric encryption scheme  <span class="math">\\Pi</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) There exists a polynomial-time adversary A that makes at most  <span class="math">v(\\cdot)</span>  verification queries and achieves  <span class="math">\\mathbf{Adv}_{\\Pi,A}^{\\text{INT-CTXT-M}}(k) = 1</span> , and</li>
      <li>(2) For any polynomial-time adversary B making only one verification query, there is a negligible function  <span class="math">s(\\cdot)</span>  such that  <span class="math">\\mathbf{Adv}_{\\Pi,B}^{\\text{INT-CTXT-1}}(k) \\leq 2/v(k) + s(k)</span>  for all  <span class="math">k \\in \\mathbb{N}</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Proof:</strong> Consider the MAC scheme  <span class="math">\\Pi = (\\mathsf{TG}, \\mathsf{VF})</span>  from the proof of Proposition 7.1. Using it we construct a symmetric encryption scheme  <span class="math">\\Pi^* = (\\mathsf{Kg}, \\mathsf{Enc}, \\mathsf{De})</span>  whose constituent algorithms are given below:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c|c} \\text{Algorithm } \\mathsf{Kg}(1^k) &amp; \\mathsf{Algorithm } \\mathsf{Enc}(K,M) \\\\ K \\overset{\\</span>}{\\leftarrow} {0,1}^{l(k)} &amp; Tag \\leftarrow \\mathsf{TG}(K,M) \\ \\mathsf{Return } K &amp; \\mathsf{c} \\leftarrow M | Tag \\ &amp; \\mathsf{Return } \\mathsf{c} &amp; \\mathsf{If } (d=1) \\mathsf{ return } M; \\mathsf{ otherwise } \\mathsf{return } \\bot \\ \\end{array}$$</p>

    <p class="text-gray-300">Following Proposition 7.1, there exists adversary A' against  <span class="math">\\Pi</span>  such that  <span class="math">\\mathbf{Adv}_{\\Pi,A&#x27;}^{\\text{SUF-M}}(k) = 1</span> . Such adversary could be naturally modified to the adversary A against encryption scheme  <span class="math">\\Pi^*</span> :</p>

    <pre><code class="language-text">Adversary A^{\\mathsf{Enc}(K,\\cdot),\\mathsf{De}^*(K,\\cdot)}(1^k)
</code></pre>

    <p class="text-gray-300">Run  <span class="math">A&#x27;(1^k)</span>  and answer its oracle queries as follows:</p>

    <pre><code class="language-text">\\mathsf{TG}(M): \\mathsf{c} \\leftarrow \\mathsf{Enc}(K,M); parse \\mathsf{c} as M \\| Tag where Tag \\in \\{0,1\\}^{\\tau(k)}; return Tag to A&#x27; \\mathsf{VF}(M,Tag): \\mathsf{c} \\leftarrow M \\| Tag; d \\leftarrow \\mathsf{De}^*(K,\\mathsf{c}); return d to A&#x27;
</code></pre>

    <p class="text-gray-300">Note that A' wins SUF-M-experiment against  <span class="math">\\Pi</span>  exactly when A wins INT-CTXT-M-experiment against  <span class="math">\\Pi^*</span>  and thus  <span class="math">\\mathbf{Adv}_{\\Pi^*,A}^{\\mathrm{INT-CTXT-M}}(k) = \\mathbf{Adv}_{\\Pi,A&#x27;}^{\\mathrm{SUF-M}}(k) = 1</span> . This proves item (1) of the proposition.</p>

    <p class="text-gray-300">Now consider an arbitrary INT-CTXT-1-adversary B against  <span class="math">\\Pi^*</span> . Similarly to the previous case we modify B into the following SUF-1-adversary B' against  <span class="math">\\Pi</span> :</p>

    <pre><code class="language-text">Adversary B&#x27;^{\\mathsf{TG}(K,\\cdot),\\mathsf{VF}(K,\\cdot,\\cdot)}(1^k)
</code></pre>

    <p class="text-gray-300">Run  <span class="math">B(1^k)</span>  and answer its oracle queries as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Enc}(M): Tag \\leftarrow \\mathsf{TG}(K,M); \\ \\mathsf{c} \\leftarrow M \\| Tag; \\ \\mathsf{Return} \\ \\mathsf{c} \\ \\mathsf{to} \\ B</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{De}^*(\\mathsf{c}):</span>  Parse c as  <span class="math">M \\| Tag, Tag \\in \\{0,1\\}^{\\tau(k)}; d \\leftarrow \\mathsf{VF}(M, Tag);</span>  return d to B</p>

    <p class="text-gray-300">Note that B wins INT-CTXT-1-experiment against  <span class="math">\\Pi^*</span>  exactly when B' wins SUF-1-experiment  <span class="math">\\Pi</span> . By Proposition 7.1,  <span class="math">\\mathbf{Adv}_{\\Pi,B&#x27;}^{\\mathrm{SUF-1}}(k) &lt; 2/v(k) + s(k)</span>  for some negligible function  <span class="math">s(\\cdot)</span> . Therefore</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\Pi^*,B}^{\\text{INT-CTXT-1}}(k) = \\mathbf{Adv}_{\\Pi,B&#x27;}^{\\text{SUF-1}}(k) &lt; 2/v(k) + s(k)</span>$</p>

    <p class="text-gray-300">as claimed.</p>

    <p class="text-gray-300">Note that the symmetric encryption scheme in our counter-example does not provide any privacy, since the plaintext is present in the clear in the corresponding ciphertext. This does not affect the fact that the example we construct shows what it is supposed to. It is possible to extend this example to one where the symmetric encryption scheme does provide privacy.</p>

    <p class="text-gray-300">Recall that Theorem B.2 provides a reduction with a reduction factor 1/n. Proposition B.4 implies than no better reduction factor is possible:</p>

    <p class="text-gray-300">Corollary B.5 If PRFs exist then the reduction factor of any INT-CTXT-1  <span class="math">\\Rightarrow</span>  INT-CTXT-M reduction is O(1/n).</p>

`;
---

<BaseLayout title="The Power of Verification Queries in Message Authentication ... (2004/309)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/309
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-power-of-verification-queries-in-message-authentication-2004" />
  </article>
</BaseLayout>
