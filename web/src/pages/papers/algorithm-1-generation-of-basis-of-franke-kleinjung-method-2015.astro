---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1179';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-19';
const TITLE_HTML = 'A construction of 3-dimensional lattice sieve for number field sieve over F_{p^n}';
const AUTHORS_HTML = 'Kenichiro Hayasaka, Kazumaro Aoki, Tetsutaro Kobayashi, Tsuyoshi Takagi';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The security of pairing-based cryptography is based on the hardness of solving the discrete logarithm problem (DLP) over extension field F_{p^n} of characteristic p and degree n. Joux et al. proposed an asymptotically fastest algorithm for solving DLP over F_{p^n} (JLSV06-NFS) as the extension of the number field sieve over prime field F
_p (JL03-NFS). The lattice sieve is often used for a large-scaled experiment of solving DLP over F_p by the number field sieve. Franke and Kleinjung proposed a 2-dimensional lattice sieve which  efficiently enumerates all the points in a given sieve region of the lattice. However, we have to consider a sieve region of more than 2 dimensions in the lattice sieve of JLSV06-NFS.
In this paper, we extend the Franke-Kleinjung method to 3-dimensional  sieve region. We construct an appropriate basis using the Hermite normal form, which can enumerate the points in a given sieve region of the 3-dimensional lattice. From our experiment on F_{p^{12}} of 303 bits, we are able to enumerate more than 90\\% of the points in a sieve region in the lattice generated by special-q. Moreover, we implement the number field sieve using the proposed 3-dimensional lattice sieve. Our implementation of the JLSV06 over F_{p^6} of 240 bits is about as efficient as that of the current record over F_{p^6} using 3-dimensional line sieve by Zajac.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> number field sieve</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 The number field sieve over <span class="math">GF(p^n)</span> (JLSV06-NFS)</h2>

    <p class="text-gray-300">In this section, we describe an outline of the number field sieve over an extension field  <span class="math">GF(p^n)</span>  proposed by Joux et al. [10] (JLSV06-NFS) that contains a sieve step implemented with the lattice sieve we focus in this paper.</p>

    <p class="text-gray-300">In the polynomial selection step of JLSV06-NFS, we choose two irreducible polynomials  <span class="math">f_1, f_2 \\in \\mathbb{Z}[X]</span>  s.t.  <span class="math">f_1 \\neq f_2</span> , deg  <span class="math">f_1 = n</span> ,  <span class="math">f_1</span>  are irreducible in GF(p) and  <span class="math">f_1|f_2 \\pmod{p}</span> . Such a polynomial  <span class="math">f_2</span>  can be generated by adding p to  <span class="math">f_1</span> . Then there exists a common root v of  <span class="math">f_1(X) = 0</span>  and  <span class="math">f_2(X) = 0</span>  in GF( <span class="math">p^n</span> ). Denote by  <span class="math">\\alpha_1, \\alpha_2 \\in \\mathbb{C}</span>  a root of  <span class="math">f_1(X) = 0</span>  and  <span class="math">f_2(X) = 0</span> , respectively. We also denote by  <span class="math">\\mathcal{O}_1</span>  and  <span class="math">\\mathcal{O}_2</span>  the ring of integers of the number fields  <span class="math">\\mathbb{Q}(\\alpha_1)</span>  and  <span class="math">\\mathbb{Q}(\\alpha_2)</span> , respectively. For the orders  <span class="math">\\mathbb{Z}[\\alpha_1] \\subseteq \\mathcal{O}_1</span>  and  <span class="math">\\mathbb{Z}[\\alpha_2] \\subseteq \\mathcal{O}_2</span> , there are homomorphism maps  <span class="math">\\phi_i : \\mathbb{Z}[\\alpha_i] \\to \\text{GF}(p^n)</span> ,  <span class="math">\\alpha_i \\mapsto v</span>  (i = 1, 2).</p>

    <p class="text-gray-300">In the sieve step, we try to find many relations arisen from both  <span class="math">\\mathcal{O}_1</span>  and  <span class="math">\\mathcal{O}_2</span> . In the beginning of this step, we choose the smoothness bound  <span class="math">B_1, B_2 \\in \\mathbb{R}_{&gt;0}</span>  and an integer  <span class="math">t \\geq 1</span> . For the above polynomials  <span class="math">f_1, f_2</span>  and a column vector  <span class="math">\\mathbf{a} = (a_0, a_1, \\dots, a_t)^{\\mathrm{T}} \\in \\mathbb{Z}^{t+1}</span> , we define the norm of  <span class="math">\\mathbf{a}</span>  for  <span class="math">f_i</span>  as  <span class="math">N_i(\\mathbf{a}) = N_i \\left( \\sum_{j=0}^t a_j \\alpha_i^j \\right) = |\\mathrm{Res}(\\sum_{j=0}^t a_j X^j, f_i(X))|</span> , where  <span class="math">\\mathrm{Res}(f, g)</span>  denotes the resultant of two polynomials f and  <span class="math">g \\in \\mathbb{Z}[X]</span> .</p>

    <p class="text-gray-300">Let the factor bases  <span class="math">\\mathcal{B}_1, \\mathcal{B}_2</span>  be</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{B}_{i} = \\left\\{ \\begin{array}{c} q: \\text{ prime}, q \\leq B_{i}, \\\\ g: \\text{ irreducible monic polynomial in } \\mathrm{GF}(q)[X], \\\\ g \\mid f_{i} \\bmod q, \\ \\deg g \\leq t \\right\\} \\end{array} \\right\\} (i = 1, 2).</span>$</p>

    <p class="text-gray-300">We call a hit tuple  <span class="math">\\mathbf{a}=(a_0,a_1,\\ldots,a_t)^{\\mathrm{T}}\\in\\mathbb{Z}^{t+1}</span>  if  <span class="math">\\mathbf{a}</span>  satisfies following conditions:  <span class="math">N_1</span>  ( <span class="math">\\mathbf{a}</span> ) is  <span class="math">B_1</span> -smooth,  <span class="math">N_2</span>  ( <span class="math">\\mathbf{a}</span> ) is  <span class="math">B_2</span> -smooth and  <span class="math">\\sum_{j=0}^t a_j X^j</span>  is irreducible in  <span class="math">\\mathbb{Z}[X]</span> . A hit tuple  <span class="math">\\mathbf{a}</span>  has a property  <span class="math">(\\sum_{j=0}^t a_j \\alpha_i^j) \\mathcal{O}_i = \\prod_{\\mathfrak{q}_{i,j} \\in \\mathcal{B}_i} \\mathfrak{q}_{i,j}^{\\varepsilon_{i,j}}</span>  for i=1 and 2, where  <span class="math">\\varepsilon_{i,j}</span>  is the exponent that we can compute from the prime decomposition of  <span class="math">N_i</span>  ( <span class="math">\\mathbf{a}</span> ) =  <span class="math">\\prod_{q: \\mathrm{prime}, q \\leq B_i} q^{e_q}</span>  for  <span class="math">q \\nmid [\\mathcal{O}_i : \\mathbb{Z}[\\alpha_i]]</span> .</p>

    <p class="text-gray-300">From homomorphism maps  <span class="math">\\phi_1, \\phi_2</span>  and a hit tuple <strong>a</strong>, we obtain the following relation of the discrete logarithm</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\sum_{\\mathfrak{q}_{1,j} \\in \\mathcal{B}_1} \\varepsilon_{i,j} \\log \\phi_1(\\mathfrak{q}_{1,j}) + \\sum_{j=1}^{r_1} \\lambda_{i,j} \\log \\varLambda_{1,j} &amp;\\equiv \\\\ \\sum_{\\mathfrak{q}_{2,j} \\in \\mathcal{B}_2} \\varepsilon_{i,j} \\log \\phi_2(\\mathfrak{q}_{2,j}) + \\sum_{j=1}^{r_2} \\lambda_{i,j} \\log \\varLambda_{2,j} \\pmod{p^n-1}, \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\log \\phi_i(\\mathfrak{q}_{i,j})</span>  and  <span class="math">\\log \\Lambda_{i,j}</span>  are called the virtual logarithms [9, 20],  <span class="math">\\lambda_{i,j}</span>  is the character map proposed by Schirokauer [19] and  <span class="math">r_i</span>  is the torsion-free rank of  <span class="math">\\mathcal{O}_i</span>  for i = 1, 2.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{H}_a \\subset \\mathbb{Z}^{t+1}</span>  be the (t+1)-dimensional sieve region. In the sieve step, we find more than  <span class="math">\\sharp \\mathcal{B}_1 + \\sharp \\mathcal{B}_2 + 2n</span>  hit tuples <strong>a</strong> in  <span class="math">\\mathcal{H}_a</span> .</p>

    <p class="text-gray-300">Finally, in the linear algebra step, we compute  <span class="math">\\log \\phi_i(\\mathfrak{q}_{i,j})</span> ,  <span class="math">\\log \\Lambda_{i,j} \\pmod{p^n-1}</span>  by solving the linear system consists of the relations.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Sieve in multi-dimensions</h2>

    <p class="text-gray-300">In the following we describe how to find relations of JLSV06-NFS using the line sieve and the lattice sieve in multi-dimensions discussed by Zajac in [23,6].</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Line sieve in multi-dimensions</h3>

    <p class="text-gray-300">In the sieve method, we search hit tuples  <span class="math">\\mathbf{a} = (a_0, a_1, \\dots, a_t)^{\\mathrm{T}}</span>  whose norm  <span class="math">N_i</span>  (a) is divisible by  <span class="math">q^{\\deg g}</span>  for all  <span class="math">\\mathfrak{q} = (q, g) \\in \\mathcal{B}_i</span> . Note that we have relationship</p>

    <p class="text-gray-300"><span class="math">$g(X) \\left| \\sum_{j=0}^{t} a_j X^j \\mod q \\right| \\Rightarrow q^{\\deg g} \\left| N_i(\\mathbf{a}) \\right|.</span>$
(1)</p>

    <p class="text-gray-300">In the following we describe how to find the polynomials that satisfies the sufficient condition in (1), namely polynomials  <span class="math">\\sum_{j=0}^{t} a_j X^j</span>  divisible by  <span class="math">g(X) \\mod q</span> .</p>

    <p class="text-gray-300">Let  <span class="math">I_d</span>  be an identity matrix of size  <span class="math">d \\times d</span> . The set of all polynomials  <span class="math">\\sum_{j=0}^t a_j X^j</span>  in  <span class="math">\\mathbb{Z}[X]</span>  of degree less than or equal to t that is divisible by g(X) mod q is generated by the integer linear combination of the columns of the following matrix of size  <span class="math">(t+1) \\times (t+1)</span> :</p>

    <p class="text-gray-300">$$\\begin{pmatrix}
qI_{\\deg g} &amp; g_0 &amp; 0 \\
\\vdots &amp; \\ddots &amp; g_0 \\
\\vdots &amp; \\ddots &amp; \\vdots \\
g_{\\deg g} &amp; \\ddots &amp; \\vdots \\
0 &amp; g_{\\deg g}
\\end{pmatrix},$$
(2)</p>

    <p class="text-gray-300">where  <span class="math">g_0, \\ldots, g_{\\deg g}</span>  are the coefficient of the polynomial  <span class="math">g(X) = \\sum_{j=0}^{\\deg g} g_j X^j</span> , respectively. Denote by  <span class="math">M_{\\mathfrak{q}}</span>  the Hermite normal form of this matrix, i.e.,</p>

    <p class="text-gray-300"><span class="math">$M_{\\mathfrak{q}} = \\left(\\frac{qI_{\\deg g} \\mid T_{\\mathfrak{q}}}{0 \\mid I_{t-\\deg q+1}}\\right),\\tag{3}</span>$</p>

    <p class="text-gray-300">where  <span class="math">T_{\\mathfrak{q}}</span>  is an integer matrix whose size is  <span class="math">\\deg g \\times (t - \\deg g + 1)</span> . Therefore we obtain the relationship</p>

    <p class="text-gray-300"><span class="math">$(a_0, a_1, \\dots, a_{\\deg g-1})^{\\mathrm{T}} \\equiv T_{\\mathfrak{q}} (a_{\\deg g}, a_{\\deg g+2}, \\dots, a_{t+1})^{\\mathrm{T}} \\mod q</span>$</p>

    <p class="text-gray-300">for polynomial  <span class="math">\\sum_{j=0}^t a_j X^j</span>  divisible by  <span class="math">g(X) \\mod q</span> . We namely can find the hit tuple  <span class="math">\\mathbf{a} = (a_0, a_1, \\dots, a_t)^{\\mathrm{T}}</span>  by repeatedly adding q to each entry of vector  <span class="math">(a_0, a_1, \\dots, a_{\\deg q-1})^{\\mathrm{T}}</span> .</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Lattice sieve in multi-dimensions</h3>

    <p class="text-gray-300">The lattice sieve tries to find a candidate of hit tuples in the lattice whose points are divisible by  <span class="math">\\mathfrak{q} \\in \\mathcal{B}_i</span>  (i = 1, 2) (called special- <span class="math">\\mathfrak{q}</span> ).</p>

    <p class="text-gray-300">Let  <span class="math">\\mathfrak{r}=(r,h)\\in\\mathcal{B}_i(i=1,2)</span>  be a different element from  <span class="math">\\mathfrak{q}</span> , and we define  <span class="math">M_{\\mathfrak{r}}</span>  and  <span class="math">T_{\\mathfrak{r}}</span>  be the matrix generated by the same method of Equation (3), where  <span class="math">M_{\\mathfrak{r}}</span>  and  <span class="math">T_{\\mathfrak{r}}</span>  are integer matrices whose sizes are  <span class="math">(t+1)\\times(t+1)</span>  and  <span class="math">\\deg h\\times(t-\\deg h+1)</span> , respectively. Then we have the relationship  <span class="math">(a_0,a_1,\\ldots,a_{\\deg h-1})^{\\mathrm{T}}\\equiv T_{\\mathfrak{r}}\\ (a_{\\deg h},a_{\\deg h+2},\\ldots,a_{t+1})^{\\mathrm{T}}\\ \\mathrm{mod}\\ r</span>  for polynomial  <span class="math">\\sum_{j=0}^t a_j X^j</span>  divisible by h(X) mod r.</p>

    <p class="text-gray-300">Next, let  <span class="math">M_{\\mathfrak{q}}^{\\mathrm{LLL}}</span>  be the matrix generated by LLL reduction algorithm [14] from  <span class="math">M_{\\mathfrak{q}}</span>  of Equation (3). We decompose the  <span class="math">(t+1)\\times(t+1)</span>  matrix  <span class="math">M_{\\mathfrak{q}}^{\\mathrm{LLL}}</span>  into the deg  <span class="math">h\\times(t+1)</span>  matrix  <span class="math">M_{\\mathfrak{q},1}^{\\mathrm{LLL}}</span>  and the  <span class="math">(t-\\deg h+1)\\times(t+1)</span>  matrix  <span class="math">M_{\\mathfrak{q},2}^{\\mathrm{LLL}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$M_{\\mathfrak{q}}^{\\mathrm{LLL}} = \\left(\\frac{M_{\\mathfrak{q},1}^{\\mathrm{LLL}}}{M_{\\mathfrak{q},2}^{\\mathrm{LLL}}}\\right). \\tag{4}</span>$</p>

    <p class="text-gray-300">    <img src="_page_4_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 1.</strong> An example of an enumeration of lattice points with the generated basis  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  by the Franke-Kleinjung method on 2 dimensions</p>

    <p class="text-gray-300">Then the solution  <span class="math">\\mathbf{x} \\in \\mathbb{Z}^{t+1}</span>  of  <span class="math">(M_{\\mathfrak{q},1}^{\\mathrm{LLL}} - T_{\\mathfrak{r}} M_{\\mathfrak{q},2}^{\\mathrm{LLL}})\\mathbf{x} \\equiv 0 \\pmod{r}</span>  becomes a hit tuple in the lattice whose points divisible by  <span class="math">\\mathfrak{q}</span> . We denote by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  the matrix whose columns are the basis of kernel of the linear map  <span class="math">(M_{\\mathfrak{q},1}^{\\mathrm{LLL}} - T_{\\mathfrak{r}} M_{\\mathfrak{q},2}^{\\mathrm{LLL}}) \\pmod{r}</span> , then  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  becomes a matrix of size  <span class="math">(t+1) \\times (t+1)</span> . The basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  can be generated by the algorithm proposed by Hayasaka et al. [6].</p>

    <p class="text-gray-300">In the lattice sieve we run the points on lattice  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span>  in the sieve region  <span class="math">\\mathcal{H}_c \\subset \\mathbb{Z}^{t+1}</span>  (<strong>c</strong>-space):</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{H}_c = \\{(c_0, c_1, \\dots, c_t)^{\\mathrm{T}} \\in \\mathbb{Z}^{t+1} \\mid -I/2 \\le c_i &lt; I/2 (i = 0, 1, \\dots, t-1), 0 \\le c_t &lt; J\\},\\</span>$</p>

    <p class="text-gray-300">where  <span class="math">I, J \\in \\mathbb{Z}_{&gt;0}</span>  and I is even. I, J are called the bound of sieve region. One of the main operations in the lattice sieve is to enumerate the points in the sieve region  <span class="math">\\mathcal{H}_c</span>  of lattice  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}</span> .</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 The Franke-Kleinjung method in 2 dimensions</h2>

    <p class="text-gray-300">In this section, we explain how to efficiently enumerate the points in the two-dimensional lattice proposed by Franke and Kleinjung [5].</p>

    <p class="text-gray-300">Let  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  be the two-dimensional lattice generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^2</span>  defined in Section 3.2 for the case of 2 dimension i.e. t=1. Let  <span class="math">\\mathbf{u}^{(0)}=(u_0^{(0)},u_1^{(0)})^{\\mathrm{T}},\\mathbf{u}^{(1)}=(u_0^{(1)},u_1^{(1)})^{\\mathrm{T}}</span>  be the basis of  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span> . Let  <span class="math">\\mathcal{H}_c^2</span>  be the sieve region such that</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{H}_c^2 = \\{(c_0, c_1)^{\\mathrm{T}} \\in \\mathbb{Z}^2 \\mid -I/2 \\le c_0 &lt; I/2, \\ 0 \\le c_1 &lt; J\\},\\</span>$</p>

    <p class="text-gray-300">where  <span class="math">I, J \\in \\mathbb{Z}_{&gt;0}</span>  and I is even.</p>

    <p class="text-gray-300">The Franke-Kleinjung method enumerates the points in sieve region  <span class="math">\\mathcal{H}_c^2</span>  by a special basis  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  of lattice  <span class="math">L_{\\mathfrak{q},\\mathfrak{r}}^2</span> , which has the following good properties (See Figure 1 for an example:  <span class="math">\\mathbf{u}^{(1)} = (27,1)^{\\mathrm{T}}</span>  and  <span class="math">\\mathbf{u}^{(0)} = (-47,2)^{\\mathrm{T}}</span>  with I=64). (1) We can exhaustively compute all the points in  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  by adding vector  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)},</span>  or  <span class="math">\\mathbf{u}^{(0)} + \\mathbf{u}^{(1)}</span>  recursively. (2) The second coordinate of the points in sieve region  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span>  generated by the enumeration algorithm is monotonically increasing. Indeed we have the following theorem. We also show a proof which will be extended to the case of 3 dimensions in the proposed method in Section 5.</p>

    <p class="text-gray-300"><strong>Theorem 1</strong> ((Franke-Kleinjung [5])). We assume that the basis  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)})^{\\mathrm{T}}, \\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)})^{\\mathrm{T}}</span>  of lattice  <span class="math">L_{\\mathfrak{g},\\mathfrak{x}}^2</span>  satisfies the following conditions:</p>

    <p class="text-gray-300">A1:  <span class="math">|u_0^{(0)}| &lt; I</span>  and  <span class="math">|u_0^{(1)}| &lt; I</span> , A2:  <span class="math">|u_0^{(0)} - u_0^{(1)}| \\ge I</span> , A3:  <span class="math">u_1^{(0)} &gt; 0</span>  and  <span class="math">u_1^{(1)} &gt; 0</span> . Let  <span class="math">\\mathbf{p} = (p_0, p_1)^{\\mathrm{T}}</span> ,  <span class="math">\\mathbf{q} = (q_0, q_1)^{\\mathrm{T}}</span>  be points in  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span> . If  <span class="math">q_1 &gt; p_1</span>  holds, then  <span class="math">\\mathbf{q} = \\mathbf{p} + i\\mathbf{u}^{(0)} + j\\mathbf{u}^{(1)}</span>  satisfies  <span class="math">i \\ge 0, j \\ge 0</span>  and  <span class="math">i + j \\ne 0</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> From  <span class="math">\\mathbf{p}, \\mathbf{q} \\in L^2_{\\mathfrak{q},\\mathfrak{r}}</span> , then we have  <span class="math">\\mathbf{q} = \\mathbf{p} + i\\mathbf{u}^{(0)} + j\\mathbf{u}^{(1)}</span> ,  <span class="math">q_0 = p_0 + iu_0^{(0)} + ju_0^{(1)}</span>  and  <span class="math">q_1 = p_1 + iu_1^{(0)} + ju_1^{(1)}</span> .</p>

    <p class="text-gray-300">At first, both i=0 and j=0 can not be satisfied due to  <span class="math">q_1&gt;p_1</span> . If i=0 and  <span class="math">j\\neq 0</span>  hold, then we obtain  <span class="math">0&lt; q_1-p_1=ju_1^{(1)}</span>  and thus j&gt;0 from Condition A3. The assertion of the theorem is derived. Similarly, if  <span class="math">i\\neq 0</span>  and j=0 hold, then the theorem holds.</p>

    <p class="text-gray-300">Next, we assume  <span class="math">i \\neq 0</span>  and  <span class="math">j \\neq 0</span> . We will prove that i &gt; 0 and j &gt; 0 hold under the assumption of  <span class="math">q_1 &gt; p_1</span>  and  <span class="math">\\mathbf{p}, \\mathbf{q} \\in \\mathcal{H}_c^2</span> , i.e.,  <span class="math">-I/2 \\leq p_0 &lt; I/2</span>  and  <span class="math">-I/2 \\leq q_0 &lt; I/2</span> . At first, if i &lt; 0 and j &lt; 0 hold, then we have  <span class="math">iu_1^{(0)} + ju_1^{(1)} &lt; 0</span>  from Condition A3. However, it contradicts from the assumption of  <span class="math">q_1 &gt; p_1</span>  due to  <span class="math">q_1 - p_1 = iu_1^{(0)} + ju_1^{(1)}</span> . Next, we consider the case that i and j have the different sign. Note that if  <span class="math">u_0^{(0)}</span>  and  <span class="math">u_0^{(1)}</span>  satisfy Conditions A1 and A2, then  <span class="math">u_0^{(0)}u_0^{(1)} &lt; 0</span>  holds. From  <span class="math">u_0^{(0)}u_0^{(1)} &lt; 0</span> , we know that  <span class="math">iu_0^{(0)}</span>  and  <span class="math">ju_0^{(1)}</span>  have the same sign and  <span class="math">|u_0^{(0)}| + |u_0^{(1)}| = |u_0^{(0)} - u_0^{(1)}|</span> . Then we obtain  <span class="math">|q_0 - p_0| = |iu_0^{(0)} + ju_0^{(1)}| = |iu_0^{(0)} + |u_0^{(1)}| = |u_0^{(0)} - u_0^{(1)}| \\geq I</span>  from Condition A2. However, it contradicts  <span class="math">|q_0 - p_0| &lt; I</span>  from the assumption of  <span class="math">\\mathbf{p}, \\mathbf{q} \\in \\mathcal{H}_c^2</span> .</p>

    <p class="text-gray-300">In the following, we denote by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK2}}</span>  the basis  <span class="math">(\\mathbf{u}^{(0)},\\mathbf{u}^{(1)})</span>  that satisfies Conditions A1, A2 and A3 in Theorem 1. Franke and Kleinjung showed that the basis that satisfies Conditions A1, A2 and A3 in Theorem 1 can be generated by the continued fraction method shown in Algorithm 1.</p>

    <p class="text-gray-300">From Theorem 1 Franke-Kleinjung proved the following theorem [5]. We also show the proof which is extended to the case of 3-dimensions.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)})^{\\mathrm{T}}, \\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)})^{\\mathrm{T}}</span>  be the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{FK2}</span> . Let  <span class="math">\\mathbf{p} = (p_0, p_1), \\mathbf{q} = (q_0, q_1)</span>  be points in  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span> . If  <span class="math">q_1</span>  is the smallest among all the points whose second coordinate is larger than  <span class="math">p_1</span> , then  <span class="math">\\mathbf{q}</span>  is one of the points  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}, \\mathbf{p} + \\mathbf{u}^{(1)},</span>  or  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)} + \\mathbf{u}^{(1)}</span> .</p>

    <p class="text-gray-300">Proof. From Theorem 1, we know that all the points, whose second coordinate is larger than  <span class="math">p_1</span>  in  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span> , can be obtained by repeatedly adding  <span class="math">\\mathbf{u}^{(0)}</span>  or  <span class="math">\\mathbf{u}^{(1)}</span> . Every time we add point  <span class="math">\\mathbf{u}^{(0)}</span>  or  <span class="math">\\mathbf{v}</span> , then the second coordinate of the resulting point becomes larger from Condition A3. At first note that if  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}</span>  is contained in  <span class="math">\\mathcal{H}_c^2</span> , then  <span class="math">\\mathbf{p} + \\mathbf{u}^{(1)} \\notin \\mathcal{H}_c^2</span>  holds from Condition A2. Therefore, if  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)} \\in \\mathcal{H}_c^2</span>  holds, then the second coordinate of  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}</span>  is the smallest among all points whose second coordinate is larger than  <span class="math">p_1</span>  in  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span> . Similarly, we can prove the case of  <span class="math">\\mathbf{p} + \\mathbf{u}^{(1)} \\in \\mathcal{H}_c^2</span> . Finally, if both  <span class="math">\\mathbf{p} + \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}</span>  are not contained in  <span class="math">\\mathcal{H}_c^2</span> , then  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)} + \\mathbf{u}^{(1)} \\in \\mathcal{H}_c^2</span>  from Condition A2. Therefore either  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}</span> ,  <span class="math">\\mathbf{p} + \\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)} + \\mathbf{u}^{(1)}</span>  is contained in  <span class="math">\\mathcal{H}_c^2 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^2</span> .</p>

    <p class="text-gray-300">From this monotonically increasing property, we can enumerate all the points in  <span class="math">\\mathcal{H}_c^2 \\cap L^2_{\\mathfrak{q},\\mathfrak{r}}</span>  by Algorithm 2.</p>

    <p class="text-gray-300">We stress that the Franke-Kleinjung method for  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^2</span>  is not required in some cases. The Hermite normal form (HNF) of the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^2</span>  in Section 3.2 becomes one of the following:</p>

    <p class="text-gray-300"><span class="math">$\\text{Cases 1}: \\begin{pmatrix} r \\ z \\\\ 0 \\ 1 \\end{pmatrix}, \\ 2: \\begin{pmatrix} r \\ 0 \\\\ 0 \\ 1 \\end{pmatrix}, \\ 3: \\begin{pmatrix} 1 \\ 0 \\\\ 0 \\ r \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">where  <span class="math">z \\in \\mathbb{Z}_{&gt;0}</span> , z &lt; r. The basis is orthogonal in Cases 2 and 3, and thus we can use the line sieve on <strong>c</strong>-space. Therefore we only deal with Case 1 where r &gt; I for the lattices sieve.</p>

    <pre><code class="language-text">Input: bound of the lattice region I, M_{\\mathfrak{q},\\mathfrak{r}}^2 = (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}) = ((u_0^{(0)}, u_1^{(0)})^\\mathrm{T}, (u_0^{(1)}, u_1^{(1)})^\\mathrm{T}) = ((r,0)^\\mathrm{T}, (z,1)^\\mathrm{T}), where r &gt; I and 0 &lt; z &lt; r (Case 1 of HNF in Section 4)

Output: M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK2}} that satisfies Conditions A1, A2 and A3 in Theorem 1

1: \\mathbf{u}^{(1)} \\leftarrow \\mathbf{u}^{(1)} - \\mathbf{u}^{(0)}

2: while |u_0^{(1)}| \\ge I do

3: \\mathbf{u}^{(0)} \\leftarrow \\mathbf{u}^{(0)} + a\\mathbf{u}^{(1)}, \\ a = \\lfloor -u_0^{(0)}/u_0^{(1)} \\rfloor

4: \\mathrm{SWAP}(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)})

5: a \\leftarrow \\lfloor (|u_0^{(0)}| - I)/|u_0^{(1)}| \\rfloor + 1 /* a is the least positive integer s.t. |u_0^{(0)} + au_0^{(1)}| &lt; I */

6: \\mathbf{u}^{(0)} \\leftarrow \\mathbf{u}^{(0)} + a\\mathbf{u}^{(1)}

7: \\mathbf{return} \\ M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK2}} = (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)})
</code></pre>

    <pre><code class="language-text">Input: bound of the lattice region I, M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK2}} = (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}) = ((u_0^{(0)}, u_1^{(0)})^{\\mathrm{T}}, (u_0^{(1)}, u_1^{(1)})^{\\mathrm{T}}), where u_0^{(0)} &lt; 0, point \\mathbf{p} = (p_0, p_1)^{\\mathrm{T}} \\in L_{\\mathfrak{q},\\mathfrak{r}}^2 \\cap \\mathcal{H}_c^2 Output: point \\mathbf{q} = (q_0, q_1) s.t. \\mathbf{q} \\in L_{\\mathfrak{q},\\mathfrak{r}}^2 \\cap \\mathcal{H}_c^2 and q_1 &gt; p_1 and q_1 - p_1 is the least 1: if -I/2 \\le p_0 + u_0^{(0)} then return \\mathbf{p} + \\mathbf{u}^{(0)} 2: if p_0 + u_0^{(1)} &lt; I/2 then return \\mathbf{p} + \\mathbf{u}^{(1)} 3: return \\mathbf{p} + \\mathbf{u}^{(0)} + \\mathbf{u}^{(1)}
</code></pre>

    <p class="text-gray-300">In this section, we extend the Franke-Kleinjung method of 2 dimensions in Section 4 to that of 3 dimensions. First we give a classification of matrix  <span class="math">M_{\\mathfrak{q},\\tau}^3</span>  by Hermite normal form. We then explain the conditions for the proposed basis in 3 dimensions and how to generate such a basis in analogue with Section 4. Finally, we present an enumeration algorithm using the proposed basis of the 3-dimensional lattice.</p>

    <p class="text-gray-300">Let  <span class="math">L^3_{\\mathfrak{q},\\mathfrak{r}}</span>  be the the 3-dimensional lattice generated by the basis  <span class="math">M^3_{\\mathfrak{q},\\mathfrak{r}}</span>  of size  <span class="math">3\\times 3</span>  in Section 3.2 for the case of t=2. We classify the HNF matrix  <span class="math">M^3_{\\mathfrak{q},\\mathfrak{r}}</span>  to exclude some trivial cases. The HNF of matrix  <span class="math">M^3_{\\mathfrak{q},\\mathfrak{r}}</span>  becomes one of the following:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\text{Cases } \\mathbf{1} : \\begin{pmatrix} r \\ z_1 \\ z_2 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 2 : \\begin{pmatrix} r \\ z_1 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 3 : \\begin{pmatrix} r \\ 0 \\ z_2 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 4 : \\begin{pmatrix} r \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\\\ &amp; 5 : \\begin{pmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ r \\ z_2 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 6 : \\begin{pmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ r \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 7 : \\begin{pmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ r \\end{pmatrix}, \\\\ &amp; 8 : \\begin{pmatrix} r \\ 0 \\ z_1 \\\\ 0 \\ r \\ z_2 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 9 : \\begin{pmatrix} r \\ 0 \\ 0 \\\\ 0 \\ r \\ z_2 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 10 : \\begin{pmatrix} r \\ 0 \\ z_1 \\\\ 0 \\ r \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\ 11 : \\begin{pmatrix} r \\ 0 \\ 0 \\\\ 0 \\ r \\ 0 \\\\ 0 \\ 0 \\ 1 \\end{pmatrix}, \\\\ &amp; 12 : \\begin{pmatrix} r \\ z_1 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ r \\end{pmatrix}, \\ 13 : \\begin{pmatrix} r \\ 0 \\ 0 \\\\ 0 \\ 1 \\ 0 \\\\ 0 \\ 0 \\ r \\end{pmatrix}, \\ 14 : \\begin{pmatrix} 1 \\ 0 \\ 0 \\\\ 0 \\ r \\ 0 \\\\ 0 \\ 0 \\ r \\end{pmatrix}. \\end{aligned}</span>$</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. An example of an enumeration of lattice points with the generated basis  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span> by the proposed Franke-Kleinjung method on 3 dimensions</p>

    <p class="text-gray-300">where  <span class="math">z_1, z_2 \\in \\mathbb{Z}_{&gt;0}, z_1, z_2 &lt; r</span> .</p>

    <p class="text-gray-300">The basis is orthogonal in Cases 4, 6, 7, 11, 13 and 14, and thus we can efficiently use the line sieve on c-space. Moreover, Cases 2, 3, 5, 9, 10, and 12 contain an orthogonal subspace spanned by the 2-dimensional basis of the Franke-Kleinjung type which are colored by gray. We use the line sieve on the non-colored vector and the 2-dimensional Franke-Kleinjung method for its orthogonal projection. Consequently, we have to consider an HNF matrix  <span class="math">M_{\\rm g,r}^3</span>  that corresponds to one of the Case 1 and 8 in the following.</p>

    <p class="text-gray-300">In this section we extend the conditions of Theorem 1 used in the Franke-Kleinjung method to the lattice of 3 dimensions, and then present how to generate the proposed basis.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{H}_c^3</span>  be the sieve region in  <span class="math">\\mathbb{Z}^3</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{H}_c^3 = \\{(c_0, c_1, c_2)^{\\mathrm{T}} \\in \\mathbb{Z}^3 \\mid -I/2 \\le c_i &lt; I/2 \\ (i = 0, 1), \\ 0 \\le c_1 &lt; J\\},\\</span>$</p>

    <p class="text-gray-300">where  <span class="math">I, J \\in \\mathbb{Z}_{&gt;0}</span>  is a bound of lattice region and I is even. Our proposed enumeration algorithm can generate all the points in sieve region  <span class="math">\\mathcal{H}_c^3</span>  if we generate an appropriate basis  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)}, u_2^{(0)})^{\\mathrm{T}}, \\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)}, u_2^{(1)})^{\\mathrm{T}} \\text{ and } \\mathbf{u}^{(2)} = (u_0^{(2)}, u_1^{(2)}, u_2^{(2)})^{\\mathrm{T}} \\text{ of lattice } L_{\\mathfrak{q},\\mathfrak{r}}^3 \\text{ with the following properties (See Figure 2 for an example: } \\mathbf{u}^{(0)} = (22, 39, 1)^{\\mathrm{T}}, \\mathbf{u}^{(1)} = (-63, -12, 7)^{\\mathrm{T}}, \\text{ and } \\mathbf{u}^{(2)} = (45, -49, 11)^{\\mathrm{T}} \\text{ with } I = 64</span> ). (1) We can exhaustively compute all the points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span>  by adding the linear combination of  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}, \\mathbf{u}^{(2)}</span>  recursively. (2) The third coordinate of the points in sieve region  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span>  generated by the enumeration algorithm is monotonically increasing. Indeed we can prove the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> We assume that the basis  <span class="math">\\mathbf{u}^{(0)} = (u_0^{(0)}, u_1^{(0)}, u_2^{(0)})^{\\mathrm{T}}, \\ \\mathbf{u}^{(1)} = (u_0^{(1)}, u_1^{(1)}, u_2^{(1)})^{\\mathrm{T}},</span>  <span class="math">\\mathbf{u}^{(2)} = (u_0^{(2)}, u_1^{(2)}, u_2^{(2)})^{\\mathrm{T}}</span>  of lattice  <span class="math">L_{\\mathfrak{g}, \\mathbf{r}}^3</span>  satisfies the following conditions:</p>

    <p class="text-gray-300">B1:  <span class="math">|u_0^{(a)}| &lt; I</span>  and  <span class="math">|u_1^{(a)}| &lt; I</span>  for a = 0, 1, 2,</p>

    <p class="text-gray-300">B2:  <span class="math">|u_0^{(b)} - u_0^{(c)}| \\ge I</span>  or  <span class="math">|u_1^{(b)} - u_1^{(c)}| \\ge I</span>  for all pairwise differences  <span class="math">(b, c) \\in \\{0, 1, 2\\}^2</span> ,</p>

    <p class="text-gray-300">B3:  <span class="math">u_0^{(0)} \\ge 0</span>  and  <span class="math">u_2^{(1)} \\ge 0</span>  and  <span class="math">u_2^{(2)} \\ge 0</span>  and  <span class="math">u_2^{(0)} + u_2^{(1)} + u_2^{(2)} \\ne 0</span> .</p>

    <p class="text-gray-300">B4:  <span class="math">|i_0 u_0^{(0)} + i_1 u_0^{(1)} + i_2 u_0^{(2)}| \\ge I</span>  or  <span class="math">|i_0 u_1^{(0)} + i_1 u_1^{(1)} + i_2 u_1^{(2)}| \\ge I</span> , if one of  <span class="math">i_0, i_1, i_2 \\in \\mathbb{Z}</span>  is</p>

    <p class="text-gray-300"><span class="math">negative \\ and \\ the \\ others \\ are \\ positive \\ or \\ equal \\ to \\ 0.</span></p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{p} = (p_0, p_1, p_2)^{\\mathrm{T}}</span> ,  <span class="math">\\mathbf{q} = (q_0, q_1, q_2)^{\\mathrm{T}}</span>  be points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span>  with  <span class="math">\\mathbf{p} \\neq \\mathbf{q}</span> . If  <span class="math">q_2 \\geq p_2</span>  holds, then  <span class="math">\\mathbf{q} = \\mathbf{p} + j_0 \\mathbf{u}^{(0)} + j_1 \\mathbf{u}^{(1)} + j_2 \\mathbf{u}^{(2)}</span>  satisfies  <span class="math">(j_0 \\geq 0, j_1 \\geq 0, j_2 \\geq 0 \\text{ and } j_0 + j_1 + j_2 \\neq 0)</span>  or  <span class="math">(j_0 \\leq 0, j_1 \\leq 0, j_2 \\leq 0 \\text{ and } j_0 + j_1 + j_2 \\neq 0)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> From  <span class="math">\\mathbf{p}, \\mathbf{q} \\in L^3_{\\mathfrak{q},\\mathfrak{r}}</span> , then we have relation  <span class="math">\\mathbf{q} = \\mathbf{p} + j_0 \\mathbf{u}^{(0)} + j_1 \\mathbf{u}^{(1)} + j_2 \\mathbf{u}^{(2)}</span> ,  <span class="math">q_k = p_k + j_0 u_k^{(0)} + j_1 u_k^{(1)} + j_2 u_k^{(2)}</span>  for  <span class="math">j_0, j_1, j_2 \\in \\mathbb{Z}</span>  and k = 0, 1, 2. Moreover, from  <span class="math">-I/2 \\le p_k &lt; I/2</span>  and  <span class="math">-I/2 \\le q_k &lt; I/2</span>  for k = 0, 1, then we have  <span class="math">|q_k - p_k| &lt; I</span>  for k = 0, 1.</p>

    <p class="text-gray-300">First of the proof, we prove the theorem in the cases of  <span class="math">q_2 &gt; p_2</span> . We first consider the case that some coefficients  <span class="math">j_0, j_1, j_2</span>  are equal to zero. At first  <span class="math">j_0 = j_1 = j_2 = 0</span>  can not be satisfied due to  <span class="math">q_2 &gt; p_2</span> . If  <span class="math">j_0 = 0</span> ,  <span class="math">j_1 = 0</span>  and  <span class="math">j_2 \\neq 0</span>  hold, then we obtain  <span class="math">0 &lt; q_2 - p_2 = j_2 u_2^{(2)}</span>  and thus  <span class="math">j_2 &gt; 0</span>  from Condition B3. The assertion of the theorem is derived. Similarly, two of coefficients  <span class="math">j_0, j_1, j_2</span>  are zero, the theorem holds. If we assume that one of coefficients  <span class="math">j_0, j_1, j_2</span>  is zero. In the case of  <span class="math">j_0 \\neq 0</span> ,  <span class="math">j_1 \\neq 0</span>  and  <span class="math">j_2 = 0</span> . From Conditions B1 and B2. there exists  <span class="math">k \\in \\{0,1\\}</span>  s.t.  <span class="math">u_k^{(0)} u_k^{(1)} &lt; 0</span> . For such k, if  <span class="math">j_0</span>  and  <span class="math">j_1</span>  have different sign, we have  <span class="math">|j_0 u_k^{(0)} - j_1 u_k^{(1)}| &gt; I</span>  in the same manner of Theorem 1. Then, it contradicts  <span class="math">|q_k - p_k| &lt; I</span>  for k = 0, 1. On the other hand, if  <span class="math">j_0 &lt; 0</span>  and  <span class="math">j_1 &lt; 0</span>  holds, we have  <span class="math">j_0 u_2^{(0)} + j_1 u_2^{(1)} \\leq 0</span>  from Condition B3. Then, it contradicts  <span class="math">q_2 &gt; p_2</span> . Similarly, we can prove that the theorem holds in the case of  <span class="math">(j_0 \\neq 0, j_1 = 0, j_2 \\neq 0)</span>  or  <span class="math">(j_0 = 0, j_1 \\neq 0, j_2 \\neq 0)</span> . Next, we consider the case of  <span class="math">j_0 \\neq 0, j_1 \\neq 0</span> , and  <span class="math">j_2 \\neq 0</span> . We will prove that  <span class="math">j_0 &gt; 0, j_1 &gt; 0</span>  and  <span class="math">j_2 &gt; 0</span>  hold under the assumption of Condition B4,  <span class="math">q_2 &gt; p_2</span> , and  <span class="math">p, q \\in \\mathcal{H}_o^2</span> , i.e.,  <span class="math">-I/2 \\leq p_k &lt; I/2</span>  and  <span class="math">-I/2 \\leq q_k &lt; I/2</span>  for k = 0, 1. Recall that Condition B4 assume that  <span class="math">|u_0| \\geq I</span>  or  <span class="math">|u_1| \\geq I</span>  for  <span class="math">(u_0, u_1, u_2)^{\\mathrm{T}} = i_0 \\mathbf{u}^{(0)} + i_1 \\mathbf{u}^{(1)} - i_2 \\mathbf{u}^{(2)}</span>   <span class="math">(i_0, i_1, i_2 \\in \\mathbb{Z}_{&gt;0})</span> . At first, if  <span class="math">j_0 &lt; 0, j_1 &lt; 0</span>  and  <span class="math">j_2 &lt; 0</span>  hold, then we have  <span class="math">j_0 u_2^{(0)} + j_1 u_2^{(1)} + j_2 u_2^{(2)} &lt; 0</span>  from Condition B3. However, it contradicts from the assumption of  <span class="math">q_2 &gt; p_2</span>  due to  <span class="math">q_2 - p_2 = j_0 u_2^{(0)} + j_1 u_2^{(1)} + j_2 u_2^{(2)}</span> . Next, we assume that one of  <span class="math">j_0, j_1, j_2</span>  is negative. Here we show the case of  <span class="math">j_0 &lt; 0, j_1 &gt; 0</span>  and  <span class="math">j_2 &gt; 0</span>  (the other cases can be obtained similarly). From Condition B4, we know that  <span class="math">|j_0 u_0^{(0)} + j_</span></p>

    <p class="text-gray-300">In the following, we prove the case of  <span class="math">q_2=p_2</span> . First, we consider the case that some coefficients  <span class="math">j_0,j_1,j_2</span>  are equal to zero. From  <span class="math">\\mathbf{p}\\neq\\mathbf{q}</span>  and  <span class="math">q_2=p_2</span>  we know that  <span class="math">p_0\\neq q_0</span>  or  <span class="math">p_1\\neq q_1</span> . At first  <span class="math">j_0=j_1=j_2=0</span>  can not be satisfied due to  <span class="math">q_0\\neq p_0</span>  or  <span class="math">q_1\\neq p_1</span> . Second, if two of coefficients  <span class="math">j_0,j_1,j_2</span>  are zero, the theorem holds. Third, if we assume that one of coefficients  <span class="math">j_0,j_1,j_2</span>  is zero. We can prove that the theorem in the same manner of the case of  <span class="math">q_2&gt;p_2</span> . Next, we consider the case of  <span class="math">j_0\\neq 0, j_1\\neq 0</span>  and  <span class="math">j_2\\neq 0</span> . At first we assume that two of  <span class="math">j_0,j_1,j_2</span>  are negative. Here we show the case of  <span class="math">j_0&lt;0,j_1&gt;0</span>  and  <span class="math">j_2&gt;0</span>  (the other cases can be obtained similarly). From Condition B4, we know that  <span class="math">|j_0u_0^{(0)}+j_1u_0^{(1)}+j_2u_0^{(2)}|\\geq I</span>  or  <span class="math">|j_0u_1^{(0)}+j_1u_1^{(1)}+j_2u_1^{(2)}|\\geq I</span>  holds. However, it contradicts  <span class="math">|q_0-p_0|&lt; I</span>  and  <span class="math">|q_1-p_1|&lt; I</span>  from the assumption of  <span class="math">\\mathbf{p},\\mathbf{q}\\in\\mathcal{H}_c^3</span> . Finally, if one of  <span class="math">j_0,j_1,j_2</span>  is negative, then we can show a contradiction using Condition B4 in the same manner.</p>

    <p class="text-gray-300">We propose an algorithm for generating  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  that satisfies Conditions B1, B2, B3 and B4. Algorithm 3 presents a procedure to transform  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  to  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span> . In Algorithm 3, we first reduce  <span class="math">u_0</span>  and  <span class="math">u_1</span> -coordinate of  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  to satisfy Condition B1 as Steps 1-6, and we adjust the basis in Steps 7 and 8 to satisfy Conditions B2 and B3. We deal with whether  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  generated by Algorithm 3 satisfies Condition B4 in Section 6.1.</p>

    <p class="text-gray-300">In Step 1 of Algorithm 3, we use Algorithm 1 with respect to  <span class="math">u_0</span>  and  <span class="math">u_1</span> -coordinate of  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span> , then we have  <span class="math">|u_0^{(0)}|, |u_0^{(1)}|, |u_2^{(2)}| &lt; I</span> . Note that we don't need to care the values  <span class="math">|u_2^{(0)}|</span>  and  <span class="math">|u_2^{(1)}|</span> , since  <span class="math">|u_2^{(0)}| = |u_2^{(1)}| = 0</span> .</p>

    <p class="text-gray-300"><strong>Algorithm 3</strong>: Proposed generation of 3-dimensional basis  <span class="math">M_{\\mathfrak{g},\\mathfrak{r}}^{\\mathrm{FK3}}</span></p>

    <pre><code class="language-text">Input: region bound I, integer matrix M_{\\mathfrak{q},\\mathfrak{r}}^3 = (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}) = ((r,0,0)^{\\mathrm{T}}, (z_1,1,0)^{\\mathrm{T}}, (z_2,0,1)^{\\mathrm{T}}) s.t. r &gt; I, 0 &lt; z_1 &lt; r and 0 &lt; z_2 &lt; r (Case 1 of HNF in Section 5.1).

Output: reduced integer matrix M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}

1: reduce by Algorithm 1 with respect to \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}.

2: \\mathbf{while} \\ |u_1^{(2)}| \\ge I \\ \\mathbf{do}

3: \\mathrm{RADIATE}(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})

4: \\mathbf{if} \\ \\mathrm{sign}(u_1^{(0)}) = \\mathrm{sign}(u_1^{(1)}) \\ \\mathbf{then} \\ \\mathbf{do} \\ \\mathrm{REDUCE1}(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})

5: \\mathbf{else} \\ \\mathbf{do} \\ \\mathrm{REDUCE2}(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})

6: \\mathbf{if} \\ |u_1^{(0)}| &gt; |u_1^{(1)}| \\ \\mathbf{then} \\ \\mathbf{do} \\ \\mathrm{SWAP}(\\mathbf{u}^{(2)}, \\mathbf{u}^{(0)}) \\ \\mathbf{else} \\ \\mathbf{do} \\ \\mathrm{SWAP}(\\mathbf{u}^{(2)}, \\mathbf{u}^{(1)})

7: \\mathbf{if} \\ \\exists a \\in \\{0, 1, 2\\} \\ \\mathrm{s.t.} \\ u_2^{(a)} &lt; 0 \\ \\mathbf{then} \\ \\mathbf{u}^{(a)} \\leftarrow -\\mathbf{u}^{(a)}

8: \\mathrm{ADJUST}(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})

9: \\mathbf{return} \\ M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}} = (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})
</code></pre>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><span class="math">\\overline{\\textbf{Algorithm 4}: \\text{REDUCE1}(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})}</span></h4>

    <pre><code class="language-text">Input: bound of lattice region I, basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} of the lattice generated by M_{\\mathfrak{q},\\mathbf{r}}^3 s.t. \\operatorname{sign}(u_1^{(0)}) = \\operatorname{sign}(u_1^{(1)})

Output: reduced basis \\mathbf{u}^{(2)} s.t. |u_1^{(2)}| &lt; |u_1^{(0)}| or |u_1^{(2)}| &lt; |u_1^{(1)}|

1: (\\mathbf{x}, \\mathbf{y}) \\leftarrow (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}) /* (x_0, x_1, x_2) \\leftarrow (u_0^{(0)}, u_0^{(0)}, u_0^{(0)}), (y_0, y_1, y_2) \\leftarrow (u_0^{(1)}, u_0^{(1)}, u_0^{(1)}) */

2: if x_2 &gt; y_2 then do SWAP(\\mathbf{x}, \\mathbf{y})

3: else if (x_2 = y_2) \\wedge (x_1 &gt; y_1) then do SWAP(\\mathbf{x}, \\mathbf{y})

4: while true do

5: while |u_0^{(2)} + x_0| &lt; I do

6: if (|u_1^{(2)}| &lt; |x_1|) \\vee (|u_1^{(2)}| &lt; I) then return \\mathbf{u}^{(2)}

7: \\mathbf{u}^{(2)} \\leftarrow \\mathbf{u}^{(2)} + \\mathbf{x}

8: if (|u_1^{(1)}| &lt; |y_1|) \\vee (|u_1^{(2)}| &lt; I) then return \\mathbf{u}^{(2)}

9: \\mathbf{u}^{(2)} \\leftarrow \\mathbf{u}^{(2)} + \\mathbf{y}
</code></pre>

    <p class="text-gray-300">In Steps 2-6, we reduce  <span class="math">u_1</span> -coordinate of  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  with keeping the condition of  <span class="math">|u_0^{(a)}| &lt; I</span> , where a = 0, 1 and 2. At first, Step 3 adjusts  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  to reduce  <span class="math">\\mathbf{u}^{(2)}</span>  by adding  <span class="math">\\mathbf{u}^{(0)}</span>  and  <span class="math">\\mathbf{u}^{(1)}</span>  with the subroutine RADIATE. The subroutine RADIATE in Algorithm 6 transforms  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  to satisfy that the angle between  <span class="math">\\mathbf{x}</span>  and  <span class="math">\\mathbf{y}</span>  is less than  <span class="math">\\pi</span> , where  <span class="math">\\mathbf{x}</span>  and  <span class="math">\\mathbf{y}</span>  are any two of  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span> .</p>

    <p class="text-gray-300">Second, we generate  <span class="math">\\mathbf{u}^{(2)}</span>  s.t.  <span class="math">(u_1^{(2)} \\leq u_1^{(0)}) \\vee (u_1^{(2)} \\leq u_1^{(1)}) \\vee (|u_1^{(2)}| &lt; I)</span>  by adding  <span class="math">\\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  in Steps 4 and 5. If  <span class="math">\\mathrm{sign}(u_1^{(0)}) = \\mathrm{sign}(u_1^{(1)})</span>  holds, we use the subroutine REDUCE1 presented in Algorithm 4, otherwise we use REDUCE2 presented in Algorithm 5. In Step 6, we swap  <span class="math">\\mathbf{u}^{(2)}</span>  for  <span class="math">\\mathbf{u}^{(a)}</span>  s.t.  <span class="math">|u_1^{(a)}| = \\max(|u_1^{(0)}|, |u_1^{(1)}|)</span> , where  <span class="math">a \\in \\{0, 1\\}</span> . From Step 6,  <span class="math">|u_1^{(2)}| &gt; |u_1^{(0)}|</span>  and  <span class="math">|u_1^{(2)}| &gt; |u_1^{(1)}|</span>  hold at Step 2.</p>

    <p class="text-gray-300">In the following, we explain the subroutine REDUCE1. In Steps 1-3 of REDUCE1, we select two bases  <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\{\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}\\}</span>  s.t. the elements  <span class="math">x_2</span>  (resp.  <span class="math">x_1</span> ) is less than or equals to  <span class="math">y_2</span>  (resp.  <span class="math">y_1</span> ). In Steps 5-7, we reduce  <span class="math">u_1^{(2)}</span>  by adding  <span class="math">\\mathbf{x}</span>  with keeping  <span class="math">|u_0^{(2)}| &lt; I</span> . If  <span class="math">|u_1^{(2)}| &lt; |x_1|</span>  in Step 6, then  <span class="math">\\mathbf{u}^{(2)}</span>  satisfies  <span class="math">u_1^{(2)} \\le u_1^{(0)}</span>  or  <span class="math">u_1^{(2)} \\le u_1^{(1)}</span> . Moreover, if  <span class="math">|u_1^{(2)}| &lt; I</span>  holds in Step 6, we have  <span class="math">|u_1^{(0)}|, |u_1^{(1)}| &lt; I</span> , since  <span class="math">|u_1^{(2)}|</span>  is the largest in  <span class="math">|u_1^{(0)}|, |u_1^{(1)}|, |u_1^{(2)}|</span>  at beginning of REDUCE1, namely then Condition B1 is satisfied. Therefore, we return  <span class="math">\\mathbf{u}^{(2)}</span>  in Step 6. Similarly, Steps 8-9 reduce  <span class="math">u_1^{(2)}</span>  by adding  <span class="math">\\mathbf{y}</span> .</p>

    <p class="text-gray-300">In the following, we explain the subroutine REDUCE2. At first, we select two bases  <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\{\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}\\}</span>  s.t.  <span class="math">\\operatorname{sign}(x_1) = \\operatorname{sign}(u_1^{(2)})</span>  in Step 1. From  <span class="math">\\operatorname{sign}(x_1) \\neq \\operatorname{sign}(y_1)</span>  and  <span class="math">\\operatorname{sign}(x_1) \\neq \\operatorname{sign}(u_1^{(2)})</span> , we have  <span class="math">\\operatorname{sign}(y_1) = \\operatorname{sign}(u_1^{(2)})</span> . Therefore, we are able to reduce  <span class="math">u_1^{(2)}</span>  by adding</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Algorithm 5: REDUCE2( <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}</span> )</h4>

    <pre><code class="language-text">Input: bound of lattice region I, basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} of the lattice generated by M_{\\mathfrak{a}, \\mathbf{r}}^3 \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}
          s.t. \\mathrm{sign}(u_1^{(0)}) \\neq \\mathrm{sign}(u_1^{(1)})
Output: reduced basis \\mathbf{u}^{(2)} s.t. |u_1^{(2)}| &lt; |u_1^{(0)}| or |u_1^{(2)}| &lt; |u_1^{(1)}|
1: if \\operatorname{sign}(u_1^{(0)}) \\neq \\operatorname{sign}(u_1^{(2)}) then \\mathbf{x} \\leftarrow \\mathbf{u}^{(0)}, \\mathbf{y} \\leftarrow \\mathbf{u}^{(1)} else \\mathbf{x} \\leftarrow \\mathbf{u}^{(1)}, \\mathbf{y} \\leftarrow \\mathbf{u}^{(0)}
  2: while |u_1^{(2)}| &lt; I do
                      \\mathbf{u}^{(2)} \\leftarrow \\mathbf{u}^{(2)} + \\mathbf{x}
  3:
                      while |u_0^{(2)}| \\ge I \\ {\\bf do}
  4:
                      \\begin{array}{c} \\mathbf{u}^{(2)} \\leftarrow \\mathbf{u}^{(2)} + \\mathbf{y} \\\\ \\mathbf{if} \\; (|u_1^{(2)}| &lt; |u_1^{(0)}|) \\vee (|u_1^{(2)}| &lt; |u_1^{(1)}|) \\; \\mathbf{then \\; break} \\end{array}
  5.
</code></pre>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6"><strong>Algorithm 6</strong>: RADIATE( <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}</span> )</h4>

    <pre><code class="language-text">Input: basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} of the lattice generated by M_{\\mathfrak{q},\\mathfrak{r}}^3
Output: basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} s.t. the angle of any two of \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} is less than \\pi
  1: if IS_OPPOSITE(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}) is true then

2: if IS_OPPOSITE(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}) is false then \\mathbf{u}^{(0)} \\leftarrow -\\mathbf{u}^{(0)}
               if IS_OPPOSITE(\\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}, \\mathbf{u}^{(0)}) is true then \\mathbf{u}^{(1)} \\leftarrow -\\mathbf{u}^{(1)} else \\mathbf{u}^{(2)} \\leftarrow -\\mathbf{u}^{(2)}
  5: end if
  6: return \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}
</code></pre>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6"><strong>Algorithm 7</strong>: IS_OPPOSITE( <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}</span> )</h4>

    <pre><code class="language-text">Input: basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} of the lattice generated by M_{\\mathfrak{q},\\mathfrak{r}}^3
Output: true: if the angle between \\mathbf{u}^{(0)} and \\mathbf{u}^{(a)} is less than \\pi for a=1 and 2, false: otherwise.
 1: if u_0^{(0)} = 0 then
         if sign(u_0^{(1)}) \\neq sign(u_0^{(2)}) then return true else return false
 3: g = u_1^{(0)}/u_0^{(0)}
 4: y = gu_0^{(1)} - u_1^{(1)}, z = gu_0^{(2)} - u_1^{(2)}
 5: if sign(y) \\neq sign(z) then return true else return false
</code></pre>

    <p class="text-gray-300">only <strong>x</strong>. In Steps 2-6, we reduce  <span class="math">u_1^{(2)}</span>  by adding <strong>x</strong>. However, we use <strong>y</strong> if  <span class="math">|u_0^{(2)}| \\ge I</span>  holds in Steps 4 and 5 to satisfy  <span class="math">|u_0^{(2)}| &lt; I</span>  again. If  <span class="math">\\mathbf{u}^{(2)}</span>  satisfies the condition in Step 6, the termination condition of REDUCE2 holds. Therefore, we break while loop in Step 6 and return  <span class="math">\\mathbf{u}^{(2)}</span> . Moreover, from the same reason in REDUCE1, if  <span class="math">|u_1^{(2)}| &lt; I</span>  holds in Step 2, we also break the while loop and return  <span class="math">\\mathbf{u}^{(2)}</span> . Therefore, we repeat the procedures in Step 2-6 in Algorithm 3 until  <span class="math">|u_1^{(2)}| &lt; I</span>  is satisfied, then we obtain  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  that satisfy</p>

    <p class="text-gray-300">Finally, Step 7 of Algorithm 3 negates the bases s.t.  <span class="math">u_2</span> -coordinate is negative, and Step 8 adjusts  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span>  and  <span class="math">\\mathbf{u}^{(2)}</span>  to satisfy Conditions B1 and B2.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 The proposed enumeration algorithm</h3>

    <p class="text-gray-300">In this section, we propose an enumeration algorithm which can exhaustively enumerate all</p>

    <p class="text-gray-300">the points in the sieve region  <span class="math">\\mathcal{H}_c^3</span>  using the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  in the previous section. At first, we give an order to all the points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span>  using the property of Theorem 3. Let  <span class="math">\\mathbf{a}, \\mathbf{b}</span>  be two points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span> . From Theorem 3, if the third coordinate of  <span class="math">\\mathbf{a}</span>  is equal to or larger than that of <strong>b</strong>, then we can write  <span class="math">\\mathbf{a} = \\mathbf{b} + j_0 \\mathbf{u}^{(0)} + j_1 \\mathbf{u}^{(1)} + j_2 \\mathbf{u}^{(2)}</span>  for integers  <span class="math">j_0, j_1, j_2</span>  that satisfy  <span class="math">(j_0 \\ge 0, j_1 \\ge 0, j_2 \\ge 0 \\text{ and } j_0 + j_1 + j_2 \\ne 0)</span>  or  <span class="math">(j_0 \\le 0, j_1 \\le 0, j_2 \\le 0)</span></p>

    <h2 id="sec-misc-5" class="text-2xl font-bold">Algorithm 8 : ADJUST <span class="math">(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})</span></h2>

    <pre><code class="language-text">Input: basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} of the lattice generated by M_{\\mathfrak{q},\\mathbf{r}}^3

Output: basis \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)} that satisfies Conditions B1 and B2 in Theorem 3

1: for any two \\mathbf{x}, \\mathbf{y} of \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)} and \\mathbf{u}^{(2)} do

2: \\mathbf{z} \\leftarrow \\mathbf{x} - \\mathbf{y} /* (z_0, z_1, z_2) \\leftarrow (x_0 - y_0, x_1 - y_1, x_2 - y_2) */

3: if (|z_0| &lt; I) \\wedge (|z_1| &lt; I) then

4: if |x_2| \\ge |y_2| then \\mathbf{x} = \\mathbf{z} else \\mathbf{y} = \\mathbf{z}

5: RADIATE(\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})

6: return \\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}
</code></pre>

    <pre><code class="language-text">Input: bound of lattice region I, point \\mathbf{p} = (p_0, p_1, p_2)^{\\mathrm{T}} \\in L^3_{\\mathfrak{q},\\mathfrak{r}} \\cap \\mathcal{H}^3_{\\mathbf{c}}, M^{\\mathrm{FK3}}_{\\mathfrak{q},\\mathfrak{r}} = (\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)})
Output: \\mathbf{q} = (q_0, q_1, q_2)^{\\mathrm{T}} \\in L^3_{\\mathfrak{q}, \\mathfrak{r}} \\cap \\mathcal{H}^3_{\\mathbf{c}}, s.t. q_2 is the smallest under the condition of q_2 &gt; p_1
 1: while true do
               \\mathbf{r} \\leftarrow \\mathbf{p} \\ /^* (r_0, r_1, r_2) \\leftarrow (p_0, p_1, p_2) */
 3:
                while true do
                       \\mathbf{s} \\leftarrow \\mathbf{r} \\ /* (s_0, s_1, s_2) \\leftarrow (r_0, r_1, r_2) */
  4:
                        while true do
 5:
                               \\mathbf{s} \\leftarrow \\mathbf{s} + \\mathbf{u}^{(0)}
 6:
 7:
                               if s \\in \\mathcal{H}_c^3 then return s
                       if I/2 \\le s_0 or I/2 \\le s_1 then break \\mathbf{r} \\leftarrow \\mathbf{r} + \\mathbf{u}^{(1)}
 8:
 g.
10:
                        if I/2 \\le r_0 or I/2 \\le r_1 then break
                \\mathbf{p} \\leftarrow \\mathbf{p} + \\mathbf{u}^{(2)}
11:
</code></pre>

    <p class="text-gray-300">and  <span class="math">j_0+j_1+j_2\\neq 0</span> ). Note that all integers  <span class="math">j_0,j_1,j_2</span>  become zero simultaneously, if and only if  <span class="math">\\mathbf{a}=\\mathbf{b}</span>  holds. Here, we define  <span class="math">\\mathbf{b}\\prec\\mathbf{a}</span> , if  <span class="math">\\mathbf{a}-\\mathbf{b}</span>  is equal to  <span class="math">j_0\\mathbf{u}^{(0)}+j_1\\mathbf{u}^{(1)}+j_2\\mathbf{u}^{(2)}</span>  for some  <span class="math">j_0\\geq 0, j_1\\geq 0, j_2\\geq 0</span> . Then,  <span class="math">\\mathcal{H}^3_c\\cap L^3_{\\mathfrak{q},\\mathfrak{r}}</span>  becomes a totally ordered set by order  <span class="math">\\prec</span> , and we can enumerate the points in  <span class="math">\\mathcal{H}^2_c\\cap L^3_{\\mathfrak{q},\\mathfrak{r}}</span>  by introducing a product order for the pair  <span class="math">(j_0,j_1,j_2)</span>  of  <span class="math">j_0\\mathbf{u}^{(0)}+j_1\\mathbf{u}^{(1)}+j_2\\mathbf{u}^{(2)}</span> . Here we define the product order  <span class="math">(j_0,j_1,j_2)\\leq (j&#x27;_0,j&#x27;_1,j&#x27;_2)</span>  for two pairs  <span class="math">(j_0,j_1,j_2),(j&#x27;_0,j&#x27;_1,j&#x27;_2)\\in \\mathbb{Z}^2_{&gt;0}</span> , if and only if  <span class="math">j_0\\leq j&#x27;_0,j_1\\leq j&#x27;_1</span>  and  <span class="math">j_2\\leq j&#x27;_2</span>  hold. In Algorithm 9, we show an algorithm for exhaustively enumerating all points in  <span class="math">\\mathcal{H}^3_c\\cap L^3_{\\mathfrak{q},\\mathfrak{r}}</span> . Indeed we can prove the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Let  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}</span>  be the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{FK3}</span> . Let  <span class="math">\\mathbf{p} = (p_0, p_1, p_2), \\mathbf{q} = (q_0, q_1, q_2)</span>  be points in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span> . If  <span class="math">q_2</span>  is the smallest among all the points whose third coordinate is equal to or larger than that of  <span class="math">p_2</span> , then  <span class="math">\\mathbf{q}</span>  is computed by Algorithm 9.</p>

    <p class="text-gray-300"><em>Proof.</em> From Theorem 3, we know that all the points, whose third coordinate is is equal to or larger than  <span class="math">p_w</span>  in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span> , can be obtained by repeatedly adding  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(2)}</span> .</p>

    <p class="text-gray-300">Every time we add basis  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)}</span> , or  <span class="math">\\mathbf{u}^{(2)}</span>  to  <span class="math">\\mathbf{p}</span> , then the third coordinate of the resulting point becomes equal to or larger than that of  <span class="math">\\mathbf{p}</span>  from Condition B3. Note that only one of  <span class="math">\\mathbf{p} + \\mathbf{u}^{(0)}, \\mathbf{p} + \\mathbf{u}^{(1)}</span> , and  <span class="math">\\mathbf{p} + \\mathbf{u}^{(2)}</span>  is contained in  <span class="math">\\mathcal{H}_c^3 \\cap L_{\\mathfrak{q},\\mathfrak{r}}^3</span> . Therefore, Step 1 checks if there exists  <span class="math">a \\in \\{0, 1, 2\\}</span>  s.t.  <span class="math">\\mathbf{p} + \\mathbf{u}^{(a)} \\in \\mathcal{H}_c</span> , and we return such a point if exists. In Steps 2-6, we deal with the case of adding more than one basis of  <span class="math">\\mathbf{u}^{(0)}, \\mathbf{u}^{(1)},</span>  or  <span class="math">\\mathbf{u}^{(2)}</span>  to point  <span class="math">\\mathbf{p}</span> . In this step, we search the smallest pair  <span class="math">(i, j, k) \\in \\mathbb{Z}_{&gt;0}^3</span>  in the sense of the above product order that satisfies  <span class="math">\\mathbf{p} + j_0 \\mathbf{u}^{(0)} + j_1 \\mathbf{u}^{(1)} + j_2 \\mathbf{u}^{(2)} \\in \\mathcal{H}_c^3</span> . Such a point satisfies the assertion of the theorem.</p>

    <p class="text-gray-300">From Theorem 5.2, we construct an enumeration algorithm for exhaustively enumerating all the points in  <span class="math">\\mathcal{H}_c^3</span>  with  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  by repeatedly adding  <span class="math">\\mathbf{u}^{(0)},\\mathbf{u}^{(1)},</span>  or  <span class="math">\\mathbf{u}^{(2)}</span> .</p>

    <p class="text-gray-300">Example 1. We show an example of the basis of the proposed algorithm. We choose an extension field  <span class="math">GF(p^n)</span>  of size 303 bits s.t. p = 38486027, n = 12, and choose a polynomial</p>

    <p class="text-gray-300"><span class="math">f_1(X) = X^{12} + X^2 - 1</span> . Additionally, for  <span class="math">f_1</span> , we obtain  <span class="math">f_2</span>  by adding p to  <span class="math">f_1</span>  as  <span class="math">f_2(X) = f_1 + p</span> . We take special- <span class="math">\\mathfrak{q}</span>  as  <span class="math">\\mathfrak{q} = (q, g) = (99989, X + 8368)</span> , and the other prime ideal  <span class="math">\\mathfrak{r} = (r, h) = (89107, X + 54851)</span> . Then, we compute the basis as the HNF matrix of  <span class="math">M_{\\mathfrak{q}}</span> ,  <span class="math">M_{\\mathfrak{r}}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$M_{\\mathfrak{q}} = \\begin{pmatrix} 99989 \\ 8368 &amp; 0 \\\\ 0 &amp; 1 &amp; 8368 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix}, \\quad M_{\\mathfrak{r}} = \\begin{pmatrix} 89107 \\ 54851 &amp; 0 \\\\ 0 &amp; 1 &amp; 54851 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">We obtain the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  and the proposed basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  used for the lattice sieve as follows:</p>

    <p class="text-gray-300"><span class="math">$M_{\\mathfrak{q},\\mathfrak{r}}^3 = \\begin{pmatrix} 89107\\ 27083\\ -50795 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix}, \\quad M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}} = \\begin{pmatrix} 23\\ -57\\ 35 \\\\ 23\\ -10\\ -48 \\\\ 7\\ 28\\ 13 \\end{pmatrix}.</span>$</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Experimental results</h2>

    <p class="text-gray-300">In this section, we show some results of experiments on the number field sieve for solving the discrete logarithm problem using the proposed lattice sieve of 3 dimensions. We focus on the finite fields of extension degree 6 and 12, which are often used in pairing-based cryptography.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Experiment on 3-dimensional lattice sieve</h3>

    <p class="text-gray-300">In the following, we show some data of the proposed 3-dimensional lattice sieve. We implemented the sieve step of the number field sieve for solving the discrete logarithm problem over finite field  <span class="math">GF(p^{12})</span> . The finite field of extension degree n=12 is used for efficient implementation of pairing-based cryptography using BN curves [3].</p>

    <p class="text-gray-300">Table 1. Computational environment in our experiment in Section 6.1</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">CPU</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Intel Core i7-3770 3.40 GHz</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RAM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 GBytes</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Linux (64 bits)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Language</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">C++</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compiler</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">gcc-4.7.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Library</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">gmp-5.0.5</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1 shows the computational environments of our experiment. In order to perform many experiments in this computational resources, we choose a characteristic p=38486027 of 26 bits. In the polynomial selection step, we choose a polynomial  <span class="math">f_1=x^{12}+x^2-1\\in\\mathbb{Z}[X]</span> , which is irreducible in GF(p) and has small coefficients. Then polynomial  <span class="math">f_2</span>  is chosen as  <span class="math">f_2=f_1+p=x^{12}+x^2+38486026</span> .</p>

    <p class="text-gray-300">In our experiment of the 3-dimensional lattice sieve generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  defined in Section 3.2 for the case of t=2, we set the following parameters. We choose 10 special-qs s.t.  <span class="math">\\mathfrak{q}=(q,g)\\in\\mathcal{B}_2</span>  from 99871  <span class="math">\\leq q\\leq</span>  99989. The bound of sieve region is  <span class="math">I=2^k</span>  ( <span class="math">k=7,8,\\ldots,11</span> ), J=I/2. We generate prime ideals  <span class="math">\\mathfrak{r}=(r,h)\\in\\mathcal{B}_2</span>  s.t.  <span class="math">I&lt; r\\leq 85386</span>  and  <span class="math">\\deg h=1</span> . The number of such  <span class="math">\\mathfrak{r}</span>  is about 8000 for one special-q, namely we deal with about 80000 lattices generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  for one fixed I.</p>

    <p class="text-gray-300">80000 lattices generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  for one fixed I.</p>

    <p class="text-gray-300">For chosen special- <span class="math">\\mathfrak{q}</span> , I and  <span class="math">\\mathfrak{r}</span> , we generate the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  by the proposed generation algorithm in Section 5. Table 2 shows some probabilities related to the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  in our experiments. The first column of Table 2 is the number of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  we generated for each bound</p>

    <p class="text-gray-300"><strong>Table 2.</strong> Rate of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  that satisfies Condition B4</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">I</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\sharp M^3_{\\mathfrak{q},\\mathfrak{r}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">B1, B2, B3, B4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">B1, B2, B4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">B1, B2, B3</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84005</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62395 (74%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3724 (4%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18765 (22%)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83865</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61717 (73%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">322 (0%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21918 (26%)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83445</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55746~(66%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2(0%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27681 (33%)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">82645</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 (0%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28425 (34%)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81185</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52446~(64%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0 (0%)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28725 (35%)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">I. The second column is the number of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  that satisfies all conditions in Section 5. The third column is the number of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  that does not satisfies only Condition B3. The fourth column is the number of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  that does not satisfies only Condition B4. The number of the other types of the basis is less than 2% among the total number of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span> . About 74% of the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  fulfill all the conditions for I=128, namely we are able to compute all the points in  <span class="math">\\mathcal{H}_c^3</span>  in the lattice for the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span> . If the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  does not fulfill them, Condition B4 is critical for all sieve bound in the experiment.</p>

    <p class="text-gray-300"><strong>Table 3.</strong> Rate of the points that enumerated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  that don't satisfies Condition B4</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">I</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">rate</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">90%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">98%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99%</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Once the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  does not fulfill all the conditions in Section 5, Algorithm 9 not always enumerate all the points in the sieve region  <span class="math">\\mathcal{H}_c^3</span> . Table 3 shows the percentages of the points generated by Algorithm 9 over the all points in  <span class="math">\\mathcal{H}_c^3</span>  using the same basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span>  in the previous experiment. Here we assume that the number of all points in  <span class="math">\\mathcal{H}_c^3</span>  as  <span class="math">I^2J/r</span> . The proposed enumeration algorithm can enumerate more than 90% of the points in the sieve region using the basis  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^3</span> .</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Experiment on the number field sieve over <span class="math">GF(p^6)</span></h3>

    <p class="text-gray-300">In this section, in order to confirm our 3-dimensional lattice sieve works efficiently, we report an experiment on a sieve step of the number field sieve over  <span class="math">GF(p^6)</span> . The finite field of extension degree r is used for efficient implementation of pairing-based cryptography using MNT curves [15]. Zajac solved the discrete logarithm problem over  <span class="math">GF(p^6)</span>  of 240 bits [22] (Zaj08-exp), which is the current record of JLSV06-NFS over finite fields of extension degree 6. We perform an experiment on the proposed lattice using same parameter in the experiment of Zaj08-exp.</p>

    <p class="text-gray-300">Our experiment uses the computers in Table 4. We deploy the parameters in our experiment as similar as possible those used in Zaj08-exp. Zajac solved the discrete logarithm problem over the extension field whose characteristic p = 1081034284409 of 40 bits, namely the cardinality of  <span class="math">GF(p^6)</span>  is</p>

    <p class="text-gray-300"><span class="math">p^6 = 159601440019707774030607239967717569202591735271545334403617706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063352145041706335214504170633521450417063521450417063521450417063521450417063521450417063521450417063521450417063521450417065041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706041706040417060417060417060417060417060400004000</span></p>

    <p class="text-gray-300">Table 4. The data of computers that we use in the experiment in Section 6.2</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">CPU</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Intel Core i7-3770 3.40 GHz <span class="math">\\times 8</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Intel Xeon E5-2430L 2.00GHz <span class="math">\\times 24</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RAM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 GBytes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 GBytes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Linux (64 bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Language</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">C++</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Compiler</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">gcc-4.7.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Library</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">gmp-5.0.5, openmpi-1.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">of 240 bits. For the extension field, he chose two polynomials</p>

    <p class="text-gray-300"><span class="math">$f_1(X) = x^6 - 2x^5 + x^3 - x + 2,</span>$</p>

    <p class="text-gray-300"><span class="math">f_2(X) = x^6 - 2x^5 + x^3 - x + 1081034284411.</span></p>

    <p class="text-gray-300">Additionally, he also chose smoothness bounds  <span class="math">B_1 = B_2 = 6532326</span>  and 3-dimensional sieve region in a-space  <span class="math">\\mathcal{H}_a</span>  s.t.  <span class="math">-2^{18} \\leq a_0 \\leq 2^{18}</span> ,  <span class="math">-2^{13} \\leq a_1 \\leq 2^{13}</span> ,  <span class="math">1 \\leq a_2 \\leq 1149</span> . In the experiment in Zaj08-exp, he executed 3-dimensional line sieve in  <span class="math">\\mathcal{H}_a</span>  above with elements in factor bases  <span class="math">(q, g) \\in \\mathcal{B}_1 \\cup \\mathcal{B}_2</span>  s.t. deg g = 1.</p>

    <p class="text-gray-300">In our experiment, the same parameter  <span class="math">p, n, f_1, f_2, B_1</span>  and  <span class="math">B_2</span>  were implemented. Instead the <strong>a</strong>-space, our 3-dimensional lattice uses a sieve region over <strong>c</strong>-space  <span class="math">\\mathcal{H}_c^3</span> . Here, we try to chose the sieve region  <span class="math">\\mathcal{H}_c^3</span>  such that the number of hit tuples we can obtain in  <span class="math">\\mathcal{H}_c^3</span>  is larger than  <span class="math">\\sharp \\mathcal{B}_1 + \\sharp \\mathcal{B}_2 + 2n = 893773</span> . In our 3-dimensional lattice sieve, we choose 223595 special- <span class="math">\\mathfrak{q} = (q,g)</span>  from  <span class="math">\\mathcal{B}_2</span>  s.t.  <span class="math">3112117 \\leq q \\leq 6532291</span>  and  <span class="math">\\deg g = 1</span> . We executed our lattice sieve for 10 special- <span class="math">\\mathfrak{q}</span> s that is randomly chosen in  <span class="math">3112117 \\leq q \\leq 6532291</span>  with respect to  <span class="math">\\mathcal{H}_c^3</span>  whose bound of lattice region is  <span class="math">I = 2^k</span>   <span class="math">(k = 4, 5, \\dots 10)</span> . Then, we estimated the number of hit tuples we obtain for all special- <span class="math">\\mathfrak{q}</span> s in  <span class="math">3112117 \\leq q \\leq 6532291</span>  with respect to  <span class="math">I = 2^k</span>   <span class="math">(k = 4, 5, \\dots 10)</span> . From the estimated number of hit tuples for  <span class="math">I = 2^k</span>   <span class="math">(k = 4, 5, \\dots 10)</span> , we chosen  <span class="math">I = 2^7</span>  since k = 7 is the least integer s.t. the estimated number of hit tuples is larger than  <span class="math">\\sharp \\mathcal{B}_1 + \\sharp \\mathcal{B}_2 + 2n = 893773</span> .</p>

    <p class="text-gray-300">For example, in the case of special- <span class="math">\\mathfrak{q}=(6532291,X+1470092)</span>  and  <span class="math">\\mathfrak{r}=(751691,X+268635)</span> , the basis of  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  becomes</p>

    <p class="text-gray-300"><span class="math">$M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}} = \\begin{pmatrix} 230 &amp; -6 &amp; -35 \\\\ -192 &amp; 235 &amp; -42 \\\\ 27 &amp; 19 &amp; 4 \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">Then an example of the hit tuple in the lattice generated by  <span class="math">M_{\\mathfrak{q},\\mathfrak{r}}^{\\mathrm{FK3}}</span>  is  <span class="math">\\mathbf{a} = (-63189, 410, 72)^{\\mathrm{T}}</span> , where the norms of  <span class="math">\\mathbf{a}</span>  are</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} N_1\\left(\\mathbf{a}\\right) &amp;= 62542949671969989956089853213 \\\\ &amp;= 41^2 \\times 2371 \\times 6869 \\times 101863 \\times 4700621 \\times 4771049, \\\\ N_2\\left(\\mathbf{a}\\right) &amp;= 163052524927266549898884794543221597 \\\\ &amp;= 7 \\times 17 \\times 12953 \\times 22271 \\times 116461 \\times 1344457 \\times 4643843 \\times 6532291. \\end{split}</span>$</p>

    <p class="text-gray-300">In the result, the whole running time of the lattice sieve was 50996 seconds, namely about 14 hours, and we got 1041417 hit tuples. Then, we eliminated 103842 duplicate hit tuples. Therefore, we obtained 937575 hit tuples in contrast to 1077984 obtained in Zaj08-exp.</p>

    <p class="text-gray-300">Table 5 shows the experimental data in both our implementation and the previous one in Zaj08-exp. Our experiment deploys about 4 time more CPU cores than Zaj08-exp, but the running time reduces from 3 days to 14 hours.</p>

    <p class="text-gray-300"><strong>Table 5.</strong> Comparison of our experiment with the top record of the number field sieve over GF(<em>p</em> 6 )</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Zajac [22]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ours</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Year</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2008</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2014</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CPU and &#9839;cores Sempron (2.01GHz) &times; 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Core i7 (3.40GHz) &times; 8<br>Xeon (2.00GHz) &times; 24</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Timing of Sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 days</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14 hours</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3-dim. line sieve</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3-dim. lattice sieve</td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>7 Conclusion</strong></h2>

    <p class="text-gray-300">In this paper, we proposed the 3-dimensional lattice sieve as an extension of the Franke-Kleinjung method that is used for the efficient implementation of the number field sieve as an efficient algorithm for enumerating the points in 2-dimensional sieve region.</p>

    <p class="text-gray-300">First, we gave a natural extension of the basis conditions used in the Franke-Kleinjung method to the 3-dimensional case. We proved that the basis that satisfies the conditions is able to exhaustively enumerate all points in the sieve region in 3-dimensional lattice. We then proposed an enumeration algorithm that can trace all the points in 3-dimensional sieve region if such a basis exists. In our experiment of GF(<em>p</em> <sup>12</sup>) of size 303 bits, the proposed algorithm can enumerate more than 90% of all points in the sieve region of the 3-dimensional lattices, even though the basis does not satisfy the above conditions.</p>

    <p class="text-gray-300">Finally, we compared the running time of the proposed 3-dimensional lattice sieve with the current record of GF(<em>p</em> 6 ) of 240 bits by Zajac. In the results, sieve step using our extended 3-dimensional lattice sieve is about as efficient as that of 3-dimensional line sieve by Zajac.</p>

    <p class="text-gray-300">In the future, we try to perform the experiments on solving the DLP using larger <em>p</em> with the proposed lattice sieve, and we estimate the secure key-length used in pairing-based cryptography.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R. Barbulescu, P. Gaudry, A. Joux and E. Thom&acute;e, 'A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic', Cryptology ePrint Archive: Report 2013/400, (2013).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P.S.L.M. Barreto, S. Galbraith, C. O. Eigeartaigh, M. Scott, 'Efficient pairing computation on supersingular abelian varieties', Designs, Codes and Crypt., 42 (2007) 239-271.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P.S.L.M. Barreto and M. Naehrig, 'Pairing-friendly elliptic curves of prime order', SAC 2005, LNCS, Springer, 3897 (2006) 319-331.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>H. Cohen, A course in computational algebraic number theory, Graduate Texts in Math., Springer, 138 (1993).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Franke and T. Kleinjung, 'Continued fractions and lattice sieve', Workshop record of SHARCS, (2005).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>K. Hayasaka, K. Aoki, T. Kobayashi, T. Takagi, 'An experiment of number field sieve for discrete logarithm problem over GF(<em>p</em> <sup>12</sup>)', Buchmann Festschrift, LNCS, Springer, 8260 (2013) 108-120.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>K. Hayasaka, K. Aoki, T. Kobayashi, T. Takagi, 'A Verification of 3-dimensional Lattice Sieve', Computer Security Symposium 2014, CSS2014, 1E3-3 (2014) 135-142, . (in Japanese)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Joux, 'A new index calculus algorithm with complexity <em>L</em>(1<em>/</em>4 + <em>o</em>(1)) in very small characteristic', Cryptology ePrint Archive: Report 2013/095, (2013).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Joux and R. Lercier, 'Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the Gaussian integer method', Math. Comp., 72 (2003) 953-967.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Joux, R. Lercier, N.P. Smart and F. Vercauteren, 'The number field sieve in the medium prime case', CRYPTO '06, LNCS, Springer, 4117 (2006) 326-344.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>T. Kleinjung et al., 'Discrete logarithms in GF(<em>p</em>) 160 digits', email to the NMBRTHRY mailing list, (2007). http://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind0702&amp;L=nmbrthry&amp;T=0&amp; P=194.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>T. Kleinjung, K. Aoki, J. Franke, A.K. Lenstra, E. Thom&acute;e, J.W. Bos, P. Gaudry, A. Kruppa, P.L. Montgomery, D.A. Osvik, H.J.J. te Riele, A. Timofeev and P. Zimmermann, 'Factorization of a 768-bit RSA modulus', CRYPTO '10, LNCS, Springer, 6223 (2010) 333-350.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A.K. Lenstra and H.W. Lenstra, The development of the number field sieve, Lecture Notes in Math., Springer, 1554 (1993).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A.K. Lenstra, H.W. Lenstra and L. Lov&acute;asz, 'Factoring polynomials with rational coefficients', Math. Ann., 261 (1982) 515-534.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Miyaji, M. Nakabayashi and S. Takano, 'New explicit conditions of elliptic curve traces for FR-reduction', In IEICE Trans. on Fund., E84-A (5) (2001) 1234-1243.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>B. Murphy, 'Polynomial selection for the number field sieve integer factorisation algorithm', PhD. thesis, The Australian National University, (1999).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J.M. Pollard, 'The lattice sieve', 43-49 in [13].</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>C. Pomerance and J. Smith, 'Reduction of huge, sparse matrices over finite fields via created catastrophes', Experiment. Math., 1 (1992) 89-94.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>O. Schirokauer, 'Discrete logarithms and local units', Philos. Trans. Roy. Soc. London Ser. A, 345 (1993) 409-424.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>O. Schirokauer, 'Virtual logarithms', J. Algorithms, 57 (2005) 140-147.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>F. Vercauteren, 'Optimal pairings', IEEE Trans. on Info. Theory, 56, (2010) 455-461.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. Zajac, 'Discrete logarithm problem in degree six finite fields', PhD thesis, Slovak University of Technology, (2008).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. Zajac, 'On the use of the lattice sieve in the 3D NFS', Tatra Mt. Math. Publ. 45 (2010) 161-172.</li>
    </ul></li>
    </ul>

    </section>
`;
---

<BaseLayout title="A construction of 3-dimensional lattice sieve for number fie... (2015/1179)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1179
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">The number field sieve over GF(p^n) (JLSV06-NFS)</a></li>
        <li>
          <a href="#sec-3" class="hover:text-white">Sieve in multi-dimensions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Line sieve in multi-dimensions</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Lattice sieve in multi-dimensions</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">The Franke-Kleinjung method in 2 dimensions</a></li>
        <li>
          <a href="#sec-5" class="hover:text-white">Proposed extension of the Franke-Kleinjung method to 3 dimensions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Hermite normal form of M^3_&#123;\mathfrak&#123;a&#125;,\mathfrak&#123;r&#125;&#125;</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">The proposed enumeration algorithm</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Experimental results</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Experiment on 3-dimensional lattice sieve</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Experiment on the number field sieve over GF(p^6)</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="algorithm-1-generation-of-basis-of-franke-kleinjung-method-2015" />
  </article>
</BaseLayout>
