---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/957';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="Caulk+: Table-independent Lookup Arguments (2022/957)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Caulk+: Table-independent lookup arguments
      </h1>
      <p class="text-gray-400 mb-2">
        Jim Posen, Assimakis A. Kattis
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Full Version &middot; eprint 2022/957
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Our Contribution</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">Notation</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Algebraic Group Model</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Real and Ideal Pairing Checks</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Cryptographic Assumptions</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                Vector Commitments</a>
            </li>
            <li>
              <a href="#sec-2.6"
                class="hover:text-white">
                Position-Hiding Linkability</a>
            </li>
            <li>
              <a href="#sec-2.7"
                class="hover:text-white">
                Zero-Knowledge with Precomputation</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Lookup Argument Construction</a>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Linking to Pedersen Commitments</a>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Acknowledgements</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
        <li>
          <a href="#app-a"
            class="hover:text-white">
            Appendix A: Proof of Theorem 1 &ndash;
            Knowledge Soundness</a>
        </li>
        <li>
          <a href="#app-b"
            class="hover:text-white">
            Appendix B: Proof of Theorem 1 &ndash;
            Zero Knowledge</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        The recent work of Caulk [ZBK+22] introduces the
        security notion of <em>position hiding linkability</em> for
        vector commitment schemes, providing a zero-knowledge argument
        that a committed vector&rsquo;s elements comprise a subset of
        some other committed vector. The protocol has very low cost to
        the prover in the case where the size
        <span class="math">m</span> of the subset vector is much
        smaller than the size <span class="math">n</span> of the one
        containing it. The asymptotic prover complexity is
        <span class="math">O(m^2 + m \log n)</span>, where the
        <span class="math">\log n</span> dependence comes from a
        subprotocol showing that the roots of a blinded polynomial are
        all <span class="math">n</span>th roots of unity. In this
        work, we show how to simplify this argument, replacing the
        subprotocol with a polynomial divisibility check and thereby
        reducing the asymptotic prover complexity to
        <span class="math">O(m^2)</span>, removing any dependence on
        <span class="math">n</span>.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> polynomial commitments &middot;
        vector commitments &middot; zero-knowledge
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        The work in [ZBK+22], named Caulk, introduces the
        notion of <em>position-hiding linkability</em> for vector
        commitment schemes. Two efficient schemes for linking to a
        committed <span class="math">n</span>-length vector are
        provided: one for arguing membership of a single committed
        element and one for arguing multimembership of an
        <span class="math">m</span>-length subvector. The two
        protocols use the polynomial commitment scheme of [KZG10], or
        KZG commitment, over appropriately sized subgroups as the
        vector commitment scheme of choice. In particular, an
        <span class="math">n</span>-length vector commitment can be
        constructed as a commitment to the polynomial interpolation of
        the vector elements over an order-<span class="math">n</span>
        multiplicative subgroup of the field.
      </p>
      <p class="text-gray-300">
        The asymptotic prover efficiency for the single-element and
        <span class="math">m</span>-element subvector membership
        arguments are <span class="math">O(\log n)</span> and
        <span class="math">O(m \log n + m^2)</span> respectively.
        Caulk achieves sublinear proving times by precomputing vector
        commitment opening witnesses that take
        <span class="math">O(n)</span> time to compute naively. Since
        the evaluation set over which the vector elements lie is a
        multiplicative subgroup, there is an efficient method to
        aggregate the precomputed witnesses into a batched witness
        [TAB+20]. These elements are blinded with randomly
        sampled elements during the proving phase to provide the
        position-hiding property.
      </p>

      <!-- 1.1 Our Contribution -->

      <h3 id="sec-1.1" class="text-xl font-semibold">
        1.1 Our Contribution
      </h3>
      <p class="text-gray-300">
        We present an improvement to the position-hiding linkability
        arguments of Caulk which reduces the prover complexity to
        <span class="math">O(m^2)</span> for an
        <span class="math">m</span>-element membership proof,
        removing any dependence on the value of
        <span class="math">n</span>. The
        <span class="math">\log n</span> asymptotic factor in Caulk
        comes from a subprotocol for the claim that certain blinded
        evaluation points of the committed polynomial are
        <span class="math">n</span>-th roots of unity. Our
        optimization stems from replacing this with a pairing check
        constraining the evaluation points to be roots of a polynomial
        dividing <span class="math">X^n - 1</span>. While this
        modification requires the prover to precompute and store one
        extra witness element per vector index in addition to the one
        already required in the original scheme, it enjoys improved
        concrete efficiency and a simpler implementation.
      </p>
      <p class="text-gray-300">
        There are two challenges to overcome in constructing this
        protocol. The prover generates a randomized polynomial of the
        form
        <span class="math">Z(X) = r \prod_&#123;i \in I&#125;
          (X - \omega^i)</span>
        with a multiplicative blinding factor
        <span class="math">r</span>, where
        <span class="math">\omega</span> is a primitive
        <span class="math">n</span>-th root of unity and
        <span class="math">I</span> is a non-empty subset of
        <span class="math">[n]</span>. A divisibility check that
        <span class="math">Z(X)H(X) = X^n - 1</span> for some
        quotient polynomial <span class="math">H</span> guarantees
        the claim, except for the condition that
        <span class="math">Z</span> has at least one root. Since
        <span class="math">Z</span> has only a single degree of
        blinding, we must be careful when showing that
        <span class="math">Z</span> has a root so as not to leak any
        information about that root. The other challenge is that
        computing the quotient polynomial <span class="math">H</span>
        can take <span class="math">O(n)</span> time. To circumvent
        this, we leverage even further the ability to precompute and
        store witness elements for pairing checks, which is already a
        core part of the original proof system.
      </p>

      <!-- Figure 1: Comparison table -->

      <div class="my-6">
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Scheme</th>
              <th class="text-left py-2 pr-4">Proof size</th>
              <th class="text-left py-2 pr-4">Prover work</th>
              <th class="text-left py-2 pr-4">Verifier work</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Caulk, lookup table</td>
              <td class="py-2 pr-4">
                <span class="math">14\mathbb&#123;G&#125;_1,
                  1\mathbb&#123;G&#125;_2,
                  4\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(m^2 +
                  m \log n)</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(\log m),
                  4P</span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Caulk, Pedersen link</td>
              <td class="py-2 pr-4">
                <span class="math">6\mathbb&#123;G&#125;_1,
                  2\mathbb&#123;G&#125;_2,
                  4\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(\log n)</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(1), 4P</span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">This work, lookup table</td>
              <td class="py-2 pr-4">
                <span class="math">7\mathbb&#123;G&#125;_1,
                  1\mathbb&#123;G&#125;_2,
                  2\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(m^2)</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(\log m),
                  3P</span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">This work, Pedersen link</td>
              <td class="py-2 pr-4">
                <span class="math">10\mathbb&#123;G&#125;_1,
                  1\mathbb&#123;G&#125;_2,
                  5\mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(1)</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">O_\lambda(1), 3P</span>
              </td>
            </tr>
          </tbody>
        </table>
        <p class="text-xs text-gray-500 mt-2">
          Figure 1: Comparison of this work with prior work
        </p>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <!-- 2.1 Notation -->

      <h3 id="sec-2.1" class="text-xl font-semibold">
        2.1 Notation
      </h3>
      <p class="text-gray-300">
        Let
        <span class="math">\mathbb&#123;G&#125;_1,
          \mathbb&#123;G&#125;_2,
          \mathbb&#123;G&#125;_T</span>
        be cyclic groups of prime order
        <span class="math">p</span>, written with additive notation.
        The finite field
        <span class="math">\mathbb&#123;F&#125;_p</span> with
        <span class="math">p</span> elements will sometimes be
        abbreviated as
        <span class="math">\mathbb&#123;F&#125;</span>. Let
        <span class="math">e : \mathbb&#123;G&#125;_1 \times
          \mathbb&#123;G&#125;_2 \to
          \mathbb&#123;G&#125;_T</span>
        be a pairing: an efficiently computable, non-degenerate
        bilinear map. Let there be generators
        <span class="math">[Georg18]_1, [Georg18]_2, [Georg18]_T</span> of
        <span class="math">\mathbb&#123;G&#125;_1,
          \mathbb&#123;G&#125;_2,
          \mathbb&#123;G&#125;_T</span>,
        respectively, with
        <span class="math">[Georg18]_T = e([Georg18]_1, [Georg18]_2)</span>. For all
        elements
        <span class="math">\alpha \in
          \mathbb&#123;F&#125;</span>
        and
        <span class="math">\gamma \in \&#123;1, 2, T\&#125;</span>,
        the notation
        <span class="math">[\alpha]_\gamma</span> represents the
        element
        <span class="math">\alpha[Georg18]_\gamma \in
          \mathbb&#123;G&#125;_\gamma</span>.
        The set of polynomials over
        <span class="math">\mathbb&#123;F&#125;</span> of degree at
        most <span class="math">d</span> is written as
        <span class="math">\mathbb&#123;F&#125;_&#123;\leq
          d&#125;[X]</span>.
        For any set
        <span class="math">S \subset
          \mathbb&#123;F&#125;</span>,
        <span class="math">Z_S(X) := \prod_&#123;v \in S&#125;
          (X - v) \in \mathbb&#123;F&#125;[X]</span>
        is the monic polynomial of degree
        <span class="math">|S|</span> which vanishes on
        <span class="math">S</span>. The set of powers of a value
        can be written
        <span class="math">x^S := \&#123;x^i\&#125;_&#123;i \in
          S&#125;</span>
        for
        <span class="math">S \subset
          \mathbb&#123;Z&#125;</span>.
      </p>

      <!-- 2.2 Algebraic Group Model -->

      <h3 id="sec-2.2" class="text-xl font-semibold">
        2.2 Algebraic Group Model
      </h3>
      <p class="text-gray-300">
        We analyze security of our protocols in the Algebraic Group
        Model (AGM) [FKL18]. In the AGM, whenever an adversary outputs
        a group element
        <span class="math">\boldsymbol&#123;a&#125; \in
          \mathbb&#123;G&#125;_\gamma</span>
        with
        <span class="math">\gamma \in \&#123;1, 2\&#125;</span>,
        they also output an algebraic representation as a linear
        combination of the
        <span class="math">\mathbb&#123;G&#125;_\gamma</span>
        elements that the adversary has access to from the public
        parameters and structured reference string (SRS).
      </p>

      <!-- 2.3 Real and Ideal Pairing Checks -->

      <h3 id="sec-2.3" class="text-xl font-semibold">
        2.3 Real and Ideal Pairing Checks
      </h3>
      <p class="text-gray-300">
        We borrow the terminology of real and ideal pairing checks
        from [GWC19]. An SRS has degree
        <span class="math">q</span> if its elements equal
        <span class="math">\text&#123;SRS&#125;_i =
          [f(x)]_i</span>
        for uniformly sampled
        <span class="math">x \in_R
          \mathbb&#123;F&#125;</span>
        and some
        <span class="math">f \in
          \mathbb&#123;F&#125;_&#123;&lt;q&#125;[X]</span>,
        where <span class="math">i \in [q]</span>. Let
        <span class="math">f_&#123;i,j&#125;</span> denote the
        corresponding polynomial for the
        <span class="math">j</span>-th element of
        <span class="math">\text&#123;SRS&#125;_i</span>
        and <span class="math">a, b</span> be the vectors in
        <span class="math">\mathbb&#123;F&#125;^q</span> whose
        encodings in
        <span class="math">\mathbb&#123;G&#125;_1,
          \mathbb&#123;G&#125;_2</span>
        are returned by algebraic adversary
        <span class="math">\mathcal&#123;A&#125;</span>. A real
        pairing check is defined as:
      </p>
      <div class="math-block">
        (a \cdot T_1) \cdot (T_2 \cdot b) = 0,
      </div>
      <p class="text-gray-300">
        for some matrices
        <span class="math">T_1, T_2</span> over
        <span class="math">\mathbb&#123;F&#125;</span>. Real pairing
        checks can be efficiently computed from the encoded elements
        and pairing function
        <span class="math">e : \mathbb&#123;G&#125;_1 \times
          \mathbb&#123;G&#125;_2 \to
          \mathbb&#123;G&#125;_T</span>.
      </p>
      <p class="text-gray-300">
        If we operate in the AGM, for each output
        <span class="math">[a_j]_i</span>,
        <span class="math">\mathcal&#123;A&#125;</span> also outputs
        a vector <span class="math">v</span> for which
        <span class="math">a_j = \sum v_\ell f_&#123;i,\ell&#125;(x)
          = R_&#123;i,j&#125;(x)</span>
        for
        <span class="math">R_&#123;i,j&#125;(X) := \sum v_\ell
          f_&#123;i,\ell&#125;(X)</span>.
        For
        <span class="math">i \in \&#123;1,2\&#125;</span>, let
        <span class="math">R_i = (R_&#123;i,j&#125;)_j</span> be a
        vector of polynomials over
        <span class="math">\mathbb&#123;F&#125;</span>. The
        corresponding ideal check then is given by:
      </p>
      <div class="math-block">
        (R_1 \cdot T_1) \cdot (T_2 \cdot R_2) \equiv 0.
      </div>

      <!-- 2.4 Cryptographic Assumptions -->

      <h3 id="sec-2.4" class="text-xl font-semibold">
        2.4 Cryptographic Assumptions
      </h3>
      <p class="text-gray-300">
        We use the formulation of the
        <span class="math">q</span>-DLOG assumption from [GWC19],
        Definition 2.1.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (<span class="math">q</span>-DLOG Assumption)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Fix integer <span class="math">q</span>. The
            <span class="math">q</span>-DLOG assumption states that
            given
          </p>
          <div class="math-block">
            [Georg18]_1, [x]_1, \dots, [x^q]_1, [Georg18]_2, [x]_2, \dots,
            [x^q]_2
          </div>
          <p class="text-sm text-gray-300">
            for uniformly chosen
            <span class="math">x \in
              \mathbb&#123;F&#125;</span>,
            the probability of an efficient
            <span class="math">\mathcal&#123;A&#125;</span> outputting
            <span class="math">x</span> is negligible.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        We also use Lemma 2.2 from [GWC19], which follows from the
        <span class="math">q</span>-DLOG assumption in the AGM.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 1 ([GWC19] Lemma 2.2)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            Assume the <span class="math">q</span>-DLOG for
            <span class="math">(\mathbb&#123;G&#125;_1,
              \mathbb&#123;G&#125;_2)</span>.
            Given an algebraic adversary
            <span class="math">\mathcal&#123;A&#125;</span>
            participating in a protocol with a degree
            <span class="math">q</span> SRS, the probability of any
            real pairing check passing is larger by at most an
            additive negligible factor than the probability the
            corresponding ideal check holds.
          </p>
        </div>
      </div>

      <!-- 2.5 Vector Commitments -->

      <h3 id="sec-2.5" class="text-xl font-semibold">
        2.5 Vector Commitments
      </h3>
      <p class="text-gray-300">
        We recall vector commitment schemes with a trusted setup. Here
        PP denotes the public parameters of the protocol.
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4 space-y-2">
        <li>
          <span class="math">\mathbf&#123;Setup&#125;(\text&#123;PP&#125;)
            \to (\text&#123;SRS&#125;, x)</span>.
          Given the public parameters, perform the trusted setup,
          producing structured reference string SRS and trapdoor
          <span class="math">x</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;Commit&#125;(\text&#123;PP&#125;,
            \text&#123;SRS&#125;, \vec&#123;c&#125;, r)
            \to C</span>.
          Given an input vector
          <span class="math">\vec&#123;c&#125;</span> and randomness
          <span class="math">r</span>, produce a commitment
          <span class="math">C</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;Prove&#125;_&#123;\text&#123;Open&#125;&#125;(\text&#123;PP&#125;,
            \text&#123;SRS&#125;, C, i, c_i,
            \vec&#123;c&#125;, r) \to \pi_i</span>.
          Given a commitment <span class="math">C</span> and claimed
          opening <span class="math">(i, c_i)</span> along with the
          committed vector
          <span class="math">\vec&#123;c&#125;</span> and randomness
          <span class="math">r</span>, produce a proof
          <span class="math">\pi_i</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;Verify&#125;_&#123;\text&#123;Open&#125;&#125;(\text&#123;PP&#125;,
            \text&#123;SRS&#125;, C, i, c_i,
            \pi_i) \to \&#123;0, 1\&#125;</span>.
          Given a commitment <span class="math">C</span> and claimed
          opening <span class="math">(i, c_i)</span>, verify the
          opening proof <span class="math">\pi_i</span>.
        </li>
      </ul>
      <p class="text-gray-300">
        <span class="math">\mathbf&#123;Prove&#125;_&#123;\text&#123;Open&#125;&#125;</span>
        and
        <span class="math">\mathbf&#123;Verify&#125;_&#123;\text&#123;Open&#125;&#125;</span>
        can be generalized to public-coin interactive protocols
        allowing interaction between prover and verifier. We write
        <span class="math">\mathbf&#123;Verify&#125;_&#123;\text&#123;Open&#125;&#125;^&#123;\mathcal&#123;P&#125;&#125;</span>
        for the verification algorithm interacting with a prover
        <span class="math">\mathcal&#123;P&#125;</span>. The
        following security property is associated with vector
        commitments:
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2 (Position Binding)
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            A vector commitment is <em>position binding</em> if for
            all efficient adversaries
            <span class="math">\mathcal&#123;A&#125;</span> the
            following probability is negligible:
          </p>
          <div class="math-block">
            \Pr \left[ \begin&#123;array&#125;&#123;cc&#125;
              c_i \neq c_i' \\
              \text&#123;Verify&#125;_&#123;\text&#123;Open&#125;&#125;^&#123;\mathcal&#123;A&#125;&#125;(\text&#123;PP&#125;,
                \text&#123;SRS&#125;, C, i, c_i, \pi) = 1 \\
              \text&#123;Verify&#125;_&#123;\text&#123;Open&#125;&#125;^&#123;\mathcal&#123;A&#125;&#125;(\text&#123;PP&#125;,
                \text&#123;SRS&#125;, C, i, c_i', \pi') = 1
            \end&#123;array&#125;
            \;\middle|\;
            \begin&#123;array&#125;&#123;c&#125;
              \text&#123;SRS&#125; \leftarrow
                \text&#123;Setup&#125;(\text&#123;PP&#125;) \\
              (C, i, c_i, \pi, c_i', \pi') \leftarrow
                \mathcal&#123;A&#125;(\text&#123;PP&#125;,
                \text&#123;SRS&#125;)
            \end&#123;array&#125; \right].
          </div>
        </div>
      </div>

      <!-- 2.6 Position-Hiding Linkability -->

      <h3 id="sec-2.6" class="text-xl font-semibold">
        2.6 Position-Hiding Linkability
      </h3>
      <p class="text-gray-300">
        We restate the definition of position-hiding linkable vector
        commitments as stated in [ZBK+22], which extends
        the definition of a vector commitment scheme. A vector
        commitment scheme has position-hiding linkability if there is a
        zero-knowledge argument of knowledge for the following witness
        relation:
      </p>
      <div class="math-block">
        \mathcal&#123;R&#125;_&#123;\text&#123;Link&#125;&#125; :=
        \left\&#123; \left(
          \begin&#123;array&#125;&#123;c&#125;
            \text&#123;PP, SRS;&#125; \\
            C, A, n, m; \\
            \vec&#123;c&#125;, r_c,
            \vec&#123;a&#125;, r_a
          \end&#123;array&#125;
        \right)
        \;\middle|\;
        \begin&#123;array&#125;&#123;c&#125;
          \text&#123;Commit&#125;(\vec&#123;c&#125;, r_c) = C \\
          \text&#123;Commit&#125;(\vec&#123;a&#125;, r_a) = A \\
          \forall i \in [m], \exists j \in [n], a_i = c_j
        \end&#123;array&#125;
        \right\&#125;.
      </div>

      <!-- 2.7 Zero-Knowledge with Precomputation -->

      <h3 id="sec-2.7" class="text-xl font-semibold">
        2.7 Zero-Knowledge with Precomputation
      </h3>
      <p class="text-gray-300">
        We use the standard definition of honest-verifier
        zero-knowledge for public-coin interactive protocols:
        informally, that there exists an efficient algorithm
        <span class="math">\mathbf&#123;Simulate&#125;</span> which
        can produce an accepting transcript that is computationally
        indistinguishable from a real one between a prover and an
        honest verifier. In our setting, the prover is allowed to
        precompute advice inputs from the public parameters and SRS to
        reduce its online execution time when given an instance. We
        consider a model where the distinguisher cannot discriminate
        based on timing information between an execution where the
        prover has precomputed advice and one where they have not,
        assuming the precomputation is polynomial-time. In practice, if
        timing information is available the prover will precompute and
        store advice for all instances it may generate proofs for.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. LOOKUP ARGUMENT CONSTRUCTION                              -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Lookup Argument Construction
      </h2>
      <p class="text-gray-300">
        Our protocol is based on the one in section 7 of
        [ZBK+22]. The commitments
        <span class="math">\boldsymbol&#123;c&#125;</span> and
        <span class="math">\boldsymbol&#123;a&#125;</span> are to
        vectors
        <span class="math">\vec&#123;c&#125; \in
          \mathbb&#123;F&#125;^n</span>
        and
        <span class="math">\vec&#123;a&#125; \in
          \mathbb&#123;F&#125;^m</span>
        respectively. Assume both
        <span class="math">n</span> and <span class="math">m</span>
        are powers of two (the vectors can always be padded with
        duplicate elements up to the nearest power of two length). Let
        <span class="math">\mathbb&#123;H&#125;</span> and
        <span class="math">\mathbb&#123;V&#125;</span> be
        multiplicative subgroups of
        <span class="math">\mathbb&#123;F&#125;</span> of size
        <span class="math">n</span> and
        <span class="math">m</span>. The vector commitment scheme
        used is a KZG commitment over a polynomial which evaluates to
        the committed vector over some multiplicative subgroup of
        <span class="math">\mathbb&#123;F&#125;</span>. In
        particular,
        <span class="math">\boldsymbol&#123;c&#125;</span> commits to
        a polynomial <span class="math">C(X)</span> which evaluates
        to <span class="math">\vec&#123;c&#125;</span> over
        <span class="math">\mathbb&#123;H&#125;</span> and
        <span class="math">\boldsymbol&#123;a&#125;</span> commits to
        a polynomial <span class="math">A(X)</span> which evaluates
        to <span class="math">\vec&#123;a&#125;</span> over
        <span class="math">\mathbb&#123;V&#125;</span>. Let
        <span class="math">\omega</span> be a generator of
        <span class="math">\mathbb&#123;H&#125;</span> and
        <span class="math">\nu</span> be a generator of
        <span class="math">\mathbb&#123;V&#125;</span>. The protocol
        is then a zero-knowledge argument for the following relation
        <span class="math">\mathcal&#123;R&#125;_&#123;\text&#123;Link&#125;&#125;^&#123;\text&#123;KZG&#125;&#125;</span>,
        which instantiates
        <span class="math">\mathcal&#123;R&#125;_&#123;\text&#123;Link&#125;&#125;</span>
        with KZG commitments:
      </p>
      <div class="math-block">
        \mathcal&#123;R&#125;_&#123;\text&#123;Link&#125;&#125;^&#123;\text&#123;KZG&#125;&#125; :=
        \left\&#123;
        \begin&#123;pmatrix&#125;
          \&#123;[x^&#123;k-1&#125;]_1, [x^&#123;k-1&#125;]_2\&#125;_&#123;k \in [d]&#125;; \\
          \boldsymbol&#123;c&#125;, \boldsymbol&#123;a&#125;,
            \mathbb&#123;H&#125;, \mathbb&#123;V&#125;, \omega, \mu; \\
          C(X), A(X), I \subset [n]
        \end&#123;pmatrix&#125;
        \;\middle|\;
        \begin&#123;array&#125;&#123;c&#125;
          \boldsymbol&#123;c&#125; = [C(x)]_1 \\
          \boldsymbol&#123;a&#125; = [A(x)]_1 \\
          \forall i \in [m], \exists j \in I,
            A(\mu^i) = C(\omega^j)
        \end&#123;array&#125;
        \right\&#125;.
        \tag&#123;1&#125;
      </div>
      <p class="text-gray-300">
        Let <span class="math">I \subset [n]</span> be the set of
        indices in <span class="math">\vec&#123;c&#125;</span> that
        <span class="math">\vec&#123;a&#125;</span> takes values from
        and <span class="math">u : [m] \to I</span> be a mapping such
        that <span class="math">a_i = c_&#123;u(i)&#125;</span> for
        all <span class="math">i \in [m]</span>. The protocol begins
        with the prover computing polynomials
        <span class="math">Z_I, C_I, U \in
          \mathbb&#123;F&#125;_&#123;\leq m&#125;[X]</span>
        so that the following polynomial identities hold over
        <span class="math">Z_I</span>:
      </p>
      <div class="math-block">
        C(X) - C_I(X) = 0 \mod Z_I, \tag&#123;2&#125;
      </div>
      <div class="math-block">
        Z_&#123;\mathbb&#123;H&#125;&#125; = 0 \mod Z_I,
        \tag&#123;3&#125;
      </div>
      <p class="text-gray-300">
        and the following identities hold over
        <span class="math">Z_&#123;\mathbb&#123;V&#125;&#125;</span>:
      </p>
      <div class="math-block">
        C_I(U(X)) - A(X) = 0 \mod
          Z_&#123;\mathbb&#123;V&#125;&#125;, \tag&#123;4&#125;
      </div>
      <div class="math-block">
        Z_I(U(X)) = 0 \mod Z_&#123;\mathbb&#123;V&#125;&#125;.
        \tag&#123;5&#125;
      </div>
      <p class="text-gray-300">
        Intuitively, <span class="math">Z_I</span> is a low-degree
        polynomial which vanishes on
        <span class="math">\omega^I</span>,
        <span class="math">C_I</span> is a low-degree polynomial
        which agrees with <span class="math">C</span> on
        <span class="math">\omega^I</span>, and
        <span class="math">U</span> maps
        <span class="math">\mathbb&#123;V&#125;</span> to
        <span class="math">\omega^I</span>. Concretely, the prover
        computes the Lagrange polynomials
        <span class="math">\&#123;\tau_i\&#125;_&#123;i \in
          I&#125; \subset
          \mathbb&#123;F&#125;_&#123;&lt;|I|&#125;[X]</span>
        over <span class="math">\omega^I</span> and the Lagrange
        polynomials
        <span class="math">\&#123;\mu_j\&#125;_&#123;j \in
          [m]&#125; \subset
          \mathbb&#123;F&#125;_&#123;&lt; m&#125;[X]</span>
        over <span class="math">\mathbb&#123;V&#125;</span>. They
        then define:
      </p>
      <div class="math-block">
        Z_I(X) = \prod_&#123;i \in I&#125; (X - \omega^i),
      </div>
      <div class="math-block">
        C_I(X) = \sum_&#123;i \in I&#125; c_i \tau_i(X),
      </div>
      <div class="math-block">
        U(X) = \sum_&#123;j \in [m]&#125; u(j) \mu_j(X).
      </div>
      <p class="text-gray-300">
        Now, we could proceed with the standard compilation of
        polynomial IOPs to regular IOPs. However, equations 2 and 3
        involve polynomials with degree up to
        <span class="math">n</span>, so computing a KZG commitment
        opening would take <span class="math">O(n)</span> time. We
        notice that neither equation involves polynomial composition
        and so we can enforce the constraints with real pairing checks
        at the point <span class="math">x</span> from the structured
        reference string SRS. This approach has the benefit that the
        quotient elements for the pairing check can be computed in
        <span class="math">O(m^2)</span> time from precomputed values.
      </p>
      <p class="text-gray-300">
        Define
        <span class="math">W_1, W_2 \in
          \mathbb&#123;F&#125;_&#123;\leq n&#125;[X]</span>
        to be such that
        <span class="math">C - C_I = Z_I W_1</span> and
        <span class="math">Z_&#123;\mathbb&#123;H&#125;&#125;
          = Z_I W_2</span>. The prover will look up precomputed values
        <span class="math">\&#123;[W_1^&#123;(i)&#125;(x)]_2,
          [W_2^&#123;(i)&#125;(x)]_2\&#125;_&#123;i \in
          I&#125;</span>,
        where
        <span class="math">W_1^&#123;(i)&#125;(X) =
          (C(X) - c_i)/(X - \omega^i)</span>,
        <span class="math">W_2^&#123;(i)&#125;(X) =
          Z_&#123;\mathbb&#123;H&#125;&#125;/(X -
          \omega^i)</span>,
        and then compute:
      </p>
      <div class="math-block">
        [W_1(x)]_2 = \sum_&#123;i \in I&#125;
        \frac&#123;[W_1^&#123;(i)&#125;(x)]_2&#125;&#123;\prod_&#123;j
          \in I, i \neq j&#125; (\omega^i -
          \omega^j)&#125;,
      </div>
      <div class="math-block">
        [W_2(x)]_2 = \sum_&#123;i \in I&#125;
        \frac&#123;[W_2^&#123;(i)&#125;(x)]_2&#125;&#123;\prod_&#123;j
          \in I, i \neq j&#125; (\omega^i -
          \omega^j)&#125;.
      </div>
      <p class="text-gray-300">
        After sending these quotient elements for the pairing checks
        corresponding to equations 2 and 3, the verifier will query
        equations 4 and 5 at a challenge point
        <span class="math">\alpha</span>. The prover will provide
        polynomial commitment opening proofs which can be computed in
        <span class="math">O(m \log m)</span> time due to the lower
        degree bound on the polynomials involved.
      </p>
      <p class="text-gray-300">
        The final ingredient is to blind
        <span class="math">Z_I, C_I, U</span> appropriately to
        preserve zero-knowledge. While
        <span class="math">C_I</span> and
        <span class="math">U</span> can be blinded by respectively
        adding multiples of <span class="math">Z_I</span> and
        <span class="math">Z_&#123;\mathbb&#123;V&#125;&#125;</span>,
        <span class="math">Z_I</span> can only be blinded by a single
        multiplicative factor. At first glance, this presents a
        problem because the prover must present the evaluation of
        <span class="math">Z_I</span> at a challenge point during
        the last step of the protocol and there may not be sufficient
        degrees of randomness to blind both the evaluation and
        commitment to <span class="math">Z_I</span> itself.
        Fortunately however, the KZG openings can be batched together
        using verifier-supplied randomness in such a way that
        additional blinding of <span class="math">C_I</span> prevents
        information leakage.
      </p>

      <!-- Figure 2: Interactive Protocol -->

      <div class="my-8 p-6 rounded-lg border border-gray-700"
        style="background: rgba(255,255,255,0.02);">
        <p class="text-sm font-bold text-gray-300 mb-4">
          Figure 2: Interactive Protocol for
          <span class="math">\mathcal&#123;R&#125;_&#123;\text&#123;Link&#125;&#125;^&#123;\text&#123;KZG&#125;&#125;</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Public inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Prime order cyclic groups
            <span class="math">\mathbb&#123;G&#125;_1,
              \mathbb&#123;G&#125;_2,
              \mathbb&#123;G&#125;_T</span>
            with bilinear map <span class="math">e</span> and
            generators
            <span class="math">[Georg18]_1, [Georg18]_2</span>
          </li>
          <li>
            Scalar field
            <span class="math">\mathbb&#123;F&#125;</span>
          </li>
          <li>
            Structured reference string
            <span class="math">[x]_1, \dots,
              [x^&#123;d-1&#125;]_1, [x]_2, \dots,
              [x^&#123;d-1&#125;]_2</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Common inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Multiplicative subgroup
            <span class="math">\mathbb&#123;H&#125; &lt;
              \mathbb&#123;F&#125;^*</span>
            with order <span class="math">n</span> and generator
            <span class="math">\omega</span>
          </li>
          <li>
            Multiplicative subgroup
            <span class="math">\mathbb&#123;V&#125; &lt;
              \mathbb&#123;F&#125;^*</span>
            with order <span class="math">m</span> and generator
            <span class="math">\nu</span>
          </li>
          <li>
            KZG commitment
            <span class="math">\boldsymbol&#123;c&#125;</span> to
            <span class="math">C(X)</span> with evaluation points in
            <span class="math">\mathbb&#123;H&#125;</span>
          </li>
          <li>
            KZG commitment
            <span class="math">\boldsymbol&#123;a&#125;</span> to
            <span class="math">A(X)</span> with evaluation points in
            <span class="math">\mathbb&#123;V&#125;</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Witness inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Set of indices
            <span class="math">I \subset [n]</span>
          </li>
          <li>
            Values
            <span class="math">\&#123;c_i\&#125;_&#123;i \in
              I&#125;</span>
          </li>
          <li>
            Polynomials
            <span class="math">C(X), A(X)</span>
          </li>
          <li>
            Mapping
            <span class="math">u : [m] \to I</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Precomputed inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            <span class="math">[W_1^&#123;(i)&#125;(x)]_2</span>
            for all <span class="math">i \in I</span> where
            <span class="math">W_1^&#123;(i)&#125;(X) =
              (C(X) - c_i)/(X - \omega^i)</span>
          </li>
          <li>
            <span class="math">[W_2^&#123;(i)&#125;(x)]_2</span>
            for all <span class="math">i \in I</span> where
            <span class="math">W_2^&#123;(i)&#125;(X) =
              Z_&#123;\mathbb&#123;H&#125;&#125;(X)/(X -
              \omega^i)</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 1 (Prover):
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Randomly sample blinding factors
            <span class="math">r_1, \dots, r_6</span>
          </li>
          <li>
            Compute the Lagrange basis polynomials
            <span class="math">\&#123;\tau_i(X)\&#125;_&#123;i \in
              [m]&#125;</span>
            over
            <span class="math">\omega^&#123;j&#125;_&#123;j \in
              I&#125;</span>
          </li>
          <li>
            Define
            <span class="math">Z_I'(X) = r_1 \prod_&#123;i \in
              I&#125; (X - \omega^i)</span>
          </li>
          <li>
            Define
            <span class="math">C_I(X) = \sum_&#123;i \in I&#125;
              c_i \tau_i(X)</span>
          </li>
          <li>
            Define blinded
            <span class="math">C_I'(X) = C_I(X) +
              (r_2 + r_3 X + r_4 X^2) Z_I'(X)</span>
          </li>
          <li>
            Define <span class="math">U(X)</span> to be the
            degree <span class="math">m-1</span> interpolation over
            <span class="math">\mathbb&#123;V&#125;</span> with
            <span class="math">U(\nu^i) = \omega^&#123;u(i)&#125;,
              \forall i \in [m]</span>
          </li>
          <li>
            Define blinded
            <span class="math">U'(X) = U(X) +
              (r_5 + r_6 X)
              Z_&#123;\mathbb&#123;V&#125;&#125;(X)</span>
          </li>
          <li>
            Publish
            <span class="math">\boldsymbol&#123;z&#125;_I =
              [Z_I'(x)]_1</span>,
            <span class="math">\boldsymbol&#123;c&#125;_I =
              [C_I'(x)]_1</span>,
            <span class="math">\boldsymbol&#123;u&#125; =
              [U'(x)]_1</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 2 (Verifier):
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Send random challenges
          <span class="math">\chi_1, \chi_2</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 2 (Prover):
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Compute
            <span class="math">[W_1(x) + \chi_2 W_2(x)]_2 =
              \sum_&#123;i \in I&#125;
              \frac&#123;[W_1^&#123;(i)&#125;(x)]_2 + \chi_2
              [W_2^&#123;(i)&#125;(x)]_2&#125;&#123;\prod_&#123;j
              \in I, i \neq j&#125;
              (\omega^i - \omega^j)&#125;</span>
          </li>
          <li>
            Compute
            <span class="math">H(X) = (Z_I'(U'(X)) +
              \chi_1(C_I'(U'(X)) - A(X))) /
              Z_&#123;\mathbb&#123;V&#125;&#125;(X)</span>
          </li>
          <li>
            Publish
            <span class="math">\boldsymbol&#123;w&#125; =
              r_1^&#123;-1&#125;[W_1(x) +
              \chi_2 W_2(x)]_2 -
              [r_2 + r_3 x + r_4 x^2]_2</span>,
            <span class="math">\boldsymbol&#123;h&#125; =
              [H(x)]_1</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 3 (Verifier):
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Send random challenge
          <span class="math">\alpha</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 3 (Prover):
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Output
          <span class="math">v_1, v_2, \pi_1, \pi_2,
            \pi_3</span>
          where:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1 mt-1">
          <li>
            <span class="math">P_1(X) \leftarrow Z_I'(X) +
              \chi_1 C_I'(X)</span>
          </li>
          <li>
            <span class="math">P_2(X) \leftarrow Z_I'(U'(\alpha)) +
              \chi_1(C_I'(U'(\alpha)) - A(X)) -
              Z_&#123;\mathbb&#123;V&#125;&#125;(\alpha)
              H(X)</span>
          </li>
          <li>
            <span class="math">(v_1, \pi_1) \leftarrow
              \text&#123;KZG.Open&#125;(U'(X),
              \alpha)</span>
          </li>
          <li>
            <span class="math">(v_2, \pi_2) \leftarrow
              \text&#123;KZG.Open&#125;(P_1(X),
              v_1)</span>
          </li>
          <li>
            <span class="math">(0, \pi_3) \leftarrow
              \text&#123;KZG.Open&#125;(P_2(X),
              \alpha)</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Verification:
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Compute
          <span class="math">\boldsymbol&#123;p&#125;_1 =
            \boldsymbol&#123;z&#125;_I +
            \chi_1 \boldsymbol&#123;c&#125;_I</span>
          and
          <span class="math">\boldsymbol&#123;p&#125;_2 =
            [v_2]_1 -
            \chi_1 \boldsymbol&#123;a&#125; -
            Z_&#123;\mathbb&#123;V&#125;&#125;(\alpha)
            \boldsymbol&#123;h&#125;</span>
          and verify:
        </p>
        <div class="math-block">
          1 \leftarrow
            \text&#123;KZG.Verify&#125;(\boldsymbol&#123;u&#125;,
            \alpha, v_1, \pi_1)
        </div>
        <div class="math-block">
          1 \leftarrow
            \text&#123;KZG.Verify&#125;(\boldsymbol&#123;p&#125;_1,
            v_1, v_2, \pi_2)
        </div>
        <div class="math-block">
          1 \leftarrow
            \text&#123;KZG.Verify&#125;(\boldsymbol&#123;p&#125;_2,
            \alpha, 0, \pi_3)
        </div>
        <div class="math-block">
          e((\boldsymbol&#123;C&#125; -
            \boldsymbol&#123;c&#125;_I) +
            \chi_2 [x^n - 1]_1, [Georg18]_2) =
          e(\boldsymbol&#123;z&#125;_I,
            \boldsymbol&#123;w&#125;)
        </div>
      </div>

      <p class="text-gray-300">
        Prover complexity is <span class="math">O(m^2)</span>, with
        the limiting steps being polynomial interpolations of
        <span class="math">Z_I</span> and
        <span class="math">C_I</span> in round 1 and the aggregation
        of the precomputed KZG witnesses to produce
        <span class="math">\boldsymbol&#123;w&#125;</span> in
        round 2. The verifier verifies three KZG commitment openings
        and one additional pairing check. Notice that we can drop one
        degree of blinding from <span class="math">U'(X)</span> as
        compared to Caulk because <span class="math">U'(X)</span> is
        not opened as a KZG commitment in the subprotocol to show
        well-formedness. Furthermore, one fewer pairing is required for
        verification because the degree bound check used in the
        subprotocol is eliminated. We can use the same standard
        batching techniques described in section 8 of
        [ZBK+22] to reduce the number of pairing checks
        from 4 to 3 and the number of
        <span class="math">\mathbb&#123;G&#125;_1</span> elements in
        the proof from 8 to 7.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 1
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            The protocol in Figure 2 is a zero-knowledge argument of
            knowledge for the relation in equation (1) with verifier
            complexity
            <span class="math">O_\lambda(1)</span> and prover
            complexity
            <span class="math">O_\lambda(m^2)</span>, granted the
            prover has precomputed KZG witnesses for
            <span class="math">C</span> and
            <span class="math">X^n - 1</span> at all indices in
            <span class="math">I</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> The proof of knowledge soundness for
        Theorem 1 is given in
        <a href="#app-a"
          class="text-blue-400 hover:text-blue-300">Appendix A</a>
        and the proof of zero-knowledge is given in
        <a href="#app-b"
          class="text-blue-400 hover:text-blue-300">Appendix B</a>.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 2
        </div>
        <div class="formal-block-content">
          <p class="text-sm text-gray-300">
            There exists a vector commitment scheme with
            position-hiding linkability, verifier complexity
            <span class="math">O_\lambda(1)</span>, and prover
            complexity
            <span class="math">O_\lambda(m^2)</span>, for
            <span class="math">m</span> the size of the subset and
            <span class="math">n</span> the size of the table. The
            commitment scheme requires a trusted setup and requires
            the prover to precompute and store a constant number of
            elements per linked index that take
            <span class="math">O(n)</span> time to compute each or
            <span class="math">O(n \log n)</span> time to compute as
            a batch.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> The KZG polynomial commitment scheme over
        evaluation domains which are multiplicative subgroups is a
        vector commitment scheme per Section 4.6, &ldquo;KZG as
        Vector Commitment Scheme&rdquo;, of [ZBK+22]. The
        protocol in Figure 2 provides position-hiding linkability with
        the required asymptotic complexity per Theorem 1.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. LINKING TO PEDERSEN COMMITMENTS                           -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Linking to Pedersen Commitments
      </h2>
      <p class="text-gray-300">
        Section 6 of [ZBK+22] presents a specific argument
        for linking a Pedersen commitment to an element in a committed
        vector. In this setting, the SRS contains one additional random
        element
        <span class="math">\boldsymbol&#123;h&#125; \in
          \mathbb&#123;G&#125;_1</span>
        for which the discrete log relations to all other SRS elements
        are unknown. Then we can construct a zero-knowledge argument
        for the witness relation:
      </p>
      <div class="math-block">
        \mathcal&#123;R&#125;_&#123;\text&#123;PC-Link&#125;&#125; :=
        \left\&#123; \left(
          \begin&#123;array&#125;&#123;c&#125;
            \&#123;[x^&#123;k-1&#125;]_1,
              [x^&#123;k-1&#125;]_2\&#125;_&#123;k \in
              [d]&#125;,
            \boldsymbol&#123;h&#125; \; ; \\
            \boldsymbol&#123;c&#125;,
            \boldsymbol&#123;v&#125;,
            \mathbb&#123;H&#125;, \omega \; ; \\
            C(X), j, v, r
          \end&#123;array&#125;
        \right)
        \;\middle|\;
        \begin&#123;array&#125;&#123;c&#125;
          \boldsymbol&#123;c&#125; = [C(x)]_1 \\
          \boldsymbol&#123;v&#125; = [v]_1 +
            r \boldsymbol&#123;h&#125; \\
          v = C(\omega^j)
        \end&#123;array&#125;
        \right\&#125;.
      </div>
      <p class="text-gray-300">
        Care must be taken when modifying the argument from section 6
        of [ZBK+22] to replace the unity subprotocol with a
        divisibility check. The divisibility check does not guarantee
        that <span class="math">Z_I</span> has a root, and if it is a
        constant polynomial then the main pairing check does not
        correspond to a blinded KZG opening. In the generalized
        argument this is not an issue because equation 5 ensures that
        <span class="math">Z_I</span> has a root.
      </p>
      <p class="text-gray-300">
        Instead, we will compose the generalized lookup argument with a
        generalized Schnorr proof to produce an efficient argument for
        the single element case. It is well known that the classic
        Schnorr argument of knowledge of a discrete logarithm can be
        generalized to more complex group homomorphisms from a scalar
        field to a prime order group [Sch91]. In this setting we
        generalize Schnorr&rsquo;s protocol to an argument of
        knowledge of the shared opening to two Pedersen commitments
        with different bases in
        <span class="math">\mathbb&#123;G&#125;_1</span>.
      </p>
      <p class="text-gray-300">
        The prover samples
        <span class="math">k \leftarrow
          \mathbb&#123;F&#125;</span>
        and computes a polynomial
        <span class="math">A(X) = v + k(X - 1)</span>. The
        commitment to <span class="math">A(X)</span> is
        <span class="math">\boldsymbol&#123;a&#125; = v[Georg18]_1 +
          k[x - 1]_1</span>.
        The prover and verifier run the lookup argument as a
        subprotocol with
        <span class="math">\boldsymbol&#123;a&#125;</span> and
        <span class="math">\mathbb&#123;V&#125; =
          \&#123;1\&#125;</span>,
        <span class="math">I = \&#123;i\&#125;</span> (Figure 2).
        Finally they engage in a proof of knowledge of
        <span class="math">v, r, k</span> such that:
      </p>
      <div class="math-block">
        \boldsymbol&#123;v&#125; = v[Georg18]_1 +
          r \boldsymbol&#123;h&#125;,
      </div>
      <div class="math-block">
        \boldsymbol&#123;a&#125; = v[Georg18]_1 + k[x - 1]_1.
      </div>

      <!-- Figure 3: Interactive Protocol for R_PC-Link -->

      <div class="my-8 p-6 rounded-lg border border-gray-700"
        style="background: rgba(255,255,255,0.02);">
        <p class="text-sm font-bold text-gray-300 mb-4">
          Figure 3: Interactive Protocol for
          <span class="math">\mathcal&#123;R&#125;_&#123;\text&#123;PC-Link&#125;&#125;</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Public inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Prime order cyclic groups
            <span class="math">\mathbb&#123;G&#125;_1,
              \mathbb&#123;G&#125;_2,
              \mathbb&#123;G&#125;_T</span>
            with bilinear map <span class="math">e</span> and
            generators
            <span class="math">[Georg18]_1, [Georg18]_2</span>
          </li>
          <li>
            Scalar field
            <span class="math">\mathbb&#123;F&#125;</span>
          </li>
          <li>
            Structured reference string
            <span class="math">[x]_1, \dots,
              [x^&#123;d-1&#125;]_1, [x]_2, \dots,
              [x^&#123;d-1&#125;]_2</span>
          </li>
          <li>
            Independent
            <span class="math">\mathbb&#123;G&#125;_1</span>
            generator
            <span class="math">\boldsymbol&#123;h&#125;</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Common inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Multiplicative subgroup
            <span class="math">\mathbb&#123;H&#125; &lt;
              \mathbb&#123;F&#125;^*</span>
            with order <span class="math">n</span> and generator
            <span class="math">\omega</span>
          </li>
          <li>
            KZG commitment
            <span class="math">\boldsymbol&#123;C&#125;</span> to
            <span class="math">C(X)</span> with evaluation points in
            <span class="math">\mathbb&#123;H&#125;</span>
          </li>
          <li>
            Pedersen commitment
            <span class="math">\boldsymbol&#123;v&#125;</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Witness inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Value <span class="math">v</span>, Pedersen commitment
            randomness <span class="math">r</span>, index
            <span class="math">i</span>
          </li>
          <li>
            Polynomial <span class="math">C(X)</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Precomputed inputs:
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            <span class="math">[W_1^&#123;(i)&#125;(x)]_2</span>
            where
            <span class="math">W_1^&#123;(i)&#125;(X) =
              (C(X) - c_i)/(X - \omega^i)</span>
          </li>
          <li>
            <span class="math">[W_2^&#123;(i)&#125;(x)]_2</span>
            where
            <span class="math">W_2^&#123;(i)&#125;(X) =
              Z_&#123;\mathbb&#123;H&#125;&#125;(X)/(X -
              \omega^i)</span>
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 1 (Prover):
        </p>
        <ul class="list-disc list-inside text-sm text-gray-300 ml-4
          space-y-1">
          <li>
            Randomly sample blinding factors
            <span class="math">k, \hat&#123;v&#125;,
              \hat&#123;r&#125;,
              \hat&#123;k&#125; \leftarrow
              \mathbb&#123;F&#125;</span>
          </li>
          <li>
            Prover outputs
            <span class="math">\boldsymbol&#123;a&#125; =
              [v]_1 + k[x - 1]_1</span>
          </li>
          <li>
            Prover and verifier engage in Link protocol with
            <span class="math">\boldsymbol&#123;c&#125;,
              \boldsymbol&#123;a&#125;,
              A(X) = v + k(X - 1),
              \mathbb&#123;V&#125; = \&#123;1\&#125;,
              I = \&#123;i\&#125;</span>
            (Figure 2)
          </li>
        </ul>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 2 (Prover):
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Output
          <span class="math">\tilde&#123;\boldsymbol&#123;v&#125;&#125;
            = [\hat&#123;v&#125;]_1 +
            \hat&#123;r&#125;
            \boldsymbol&#123;h&#125;</span>,
          <span class="math">\tilde&#123;\boldsymbol&#123;a&#125;&#125;
            = [\hat&#123;v&#125;]_1 +
            \hat&#123;k&#125;[x - 1]_1</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 3 (Verifier):
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Sample random <span class="math">\chi</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Round 3 (Prover):
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Output
          <span class="math">s_v = \hat&#123;v&#125; +
            \chi v</span>,
          <span class="math">s_r = \hat&#123;r&#125; +
            \chi r</span>,
          <span class="math">s_k = \hat&#123;k&#125; +
            \chi k</span>
        </p>

        <p class="text-sm font-semibold text-gray-400 mt-4 mb-2">
          Verification:
        </p>
        <p class="text-sm text-gray-300 ml-4">
          Verify that:
        </p>
        <div class="math-block">
          [s_v]_1 + s_r \boldsymbol&#123;h&#125; =
          \tilde&#123;\boldsymbol&#123;v&#125;&#125; +
          \chi \boldsymbol&#123;v&#125;
        </div>
        <div class="math-block">
          [s_v]_1 + s_k [x - 1]_1 =
          \tilde&#123;\boldsymbol&#123;a&#125;&#125; +
          \chi \boldsymbol&#123;a&#125;
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 5. ACKNOWLEDGEMENTS                                          -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Acknowledgements</h2>
      <p class="text-gray-300">
        We thank Arantxa Zapico for discussions and clarifications on
        the original Caulk protocol. We thank Oana Ciobotaru for
        identifying several mistakes in the presentation, including the
        statement of the verifier complexity. We thank Michal Zajic,
        Janno Siim, Helger Lipmaa, and Roberto Parisella for
        identifying mistakes in the protocol specification which
        violated correctness and zero-knowledge guarantees.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-3 text-sm text-gray-300">
        <li>
          <strong>[FKL18]</strong> Georg Fuchsbauer, Eike Kiltz, and
          Julian Loss. &ldquo;The algebraic group model and its
          applications.&rdquo; In Hovav Shacham and Alexandra
          Boldyreva, editors, <em>Advances in Cryptology &ndash;
          CRYPTO 2018</em>, pages 33&ndash;62, Cham, 2018. Springer
          International Publishing.
        </li>
        <li>
          <strong>[GWC19]</strong> Ariel Gabizon, Zachary J.
          Williamson, and Oana Ciobotaru. &ldquo;Plonk: Permutations
          over Lagrange-bases for oecumenical noninteractive arguments
          of knowledge.&rdquo; Cryptology ePrint Archive, Paper
          2019/953, 2019.
          <a
            href="https://eprint.iacr.org/2019/953"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/953</a>.
          <a href="/papers/plonk-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          <strong>[KZG10]</strong> Aniket Kate, Gregory M. Zaverucha,
          and Ian Goldberg. &ldquo;Constant-size commitments to
          polynomials and their applications.&rdquo; In Masayuki Abe,
          editor, <em>Advances in Cryptology &ndash; ASIACRYPT
          2010</em>, pages 177&ndash;194, Berlin, Heidelberg, 2010.
          Springer Berlin Heidelberg.
        </li>
        <li>
          <strong>[Sch91]</strong> C. P. Schnorr. &ldquo;Efficient
          signature generation by smart cards.&rdquo; <em>J.
          Cryptol.</em>, 4(3):161&ndash;174, Jan 1991.
        </li>
        <li>
          <strong>[TAB+20]</strong> Alin Tomescu, Ittai
          Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, and
          Dmitry Khovratovich. &ldquo;Aggregatable subvector
          commitments for stateless cryptocurrencies.&rdquo; In
          Clemente Galdi and Vladimir Kolesnikov, editors,
          <em>Security and Cryptography for Networks</em>, pages
          45&ndash;64, Cham, 2020. Springer International Publishing.
        </li>
        <li>
          <strong>[ZBK+22]</strong> Arantxa Zapico, Vitalik
          Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu,
          and Mark Simkin. &ldquo;Caulk: Lookup arguments in sublinear
          time.&rdquo; Cryptology ePrint Archive, Paper 2022/621,
          2022.
          <a
            href="https://eprint.iacr.org/2022/621"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2022/621</a>.
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A: Proof of Theorem 1 &ndash; Knowledge Soundness
      </h2>
      <p class="text-gray-300">
        The protocol for position-hiding linking has knowledge
        soundness in the Algebraic Group Model of [FKL18]. Knowledge
        soundness is defined by a game
        <span class="math">\text&#123;Game&#125;_&#123;\text&#123;KS&#125;&#125;</span>
        involving an algebraic adversary
        <span class="math">\mathcal&#123;A&#125;</span> and an
        efficient extractor
        <span class="math">\mathcal&#123;E&#125;</span>. Given an
        SRS, the adversary outputs an instance
        <span class="math">\boldsymbol&#123;c&#125;,
          \boldsymbol&#123;a&#125;, \omega, \mu</span>
        and produces an interactive argument for the verifier. The
        extractor then outputs polynomials
        <span class="math">C, A</span>. The adversary wins if (1) the
        verifier accepts and (2) it is not the case that
        <span class="math">\boldsymbol&#123;c&#125; = [C(x)]_1 \wedge
          \boldsymbol&#123;a&#125; = [A(x)]_1 \wedge \forall i \in
          [m], \exists j \in [n],
          A(\mu^i) = C(\omega^j)</span>.
        The protocol has knowledge soundness if there exists an
        <span class="math">\mathcal&#123;E&#125;</span> so that no
        adversary wins the game with greater than negligible
        probability over the verifier&rsquo;s randomness.
      </p>
      <p class="text-gray-300">
        Because the structured reference string consists of the powers
        of <span class="math">x</span> up to
        <span class="math">x^&#123;d-1&#125;</span> lifted to
        <span class="math">\mathbb&#123;G&#125;_1</span> and
        <span class="math">\mathbb&#123;G&#125;_2</span>, an
        algebraic representation of a group element in either group can
        be interpreted as the coefficients of a polynomial in
        <span class="math">\mathbb&#123;F&#125;_d[X]</span>. The
        adversary outputs
        <span class="math">\boldsymbol&#123;z_I&#125;,
          \boldsymbol&#123;c_I&#125;,
          \boldsymbol&#123;u&#125;,
          \boldsymbol&#123;h&#125; \in
          \mathbb&#123;G&#125;_1</span>,
        <span class="math">\boldsymbol&#123;w&#125; \in
          \mathbb&#123;G&#125;_2</span>
        along with their representations, and so the extractor learns
        the corresponding polynomials
        <span class="math">Z_I', C_I', U', W, H</span>. The real
        pairing check
      </p>
      <div class="math-block">
        e((\boldsymbol&#123;C&#125; -
          \boldsymbol&#123;c_I&#125;) +
          \chi_2[x^n - 1]_1, [1]_2) =
        e(\boldsymbol&#123;z_I&#125;,
          \boldsymbol&#123;w&#125;),
      </div>
      <p class="text-gray-300">
        corresponds to the ideal pairing check
      </p>
      <div class="math-block">
        C - C_I' + \chi_2(X^n - 1) = Z_I' W.
      </div>
      <p class="text-gray-300">
        Consequently by Lemma 1, the above polynomial identity holds
        except with negligible probability. Therefore,
        <span class="math">Z_I' \mid C - C_I' +
          \chi_2(X^n - 1)</span>.
        Since <span class="math">\chi_2</span> is sampled after the
        prover commits to <span class="math">C_I', Z_I'</span>,
        except with probability
        <span class="math">\frac&#123;1&#125;&#123;|\mathbb&#123;F&#125;|&#125;</span>
        it must be that
        <span class="math">Z_I' \mid C - C_I'</span> and
        <span class="math">Z_I' \mid X^n - 1</span>. Let
        <span class="math">I</span> be the set of roots of
        <span class="math">Z_I'</span>. Since
        <span class="math">Z_I' \mid X^n - 1</span>, it follows that
        <span class="math">I \subset
          \mathbb&#123;H&#125;</span>,
        and since
        <span class="math">Z_I' \mid C - C_I'</span>, it follows that
        <span class="math">C(y) = C_I'(y)</span> for all
        <span class="math">y \in I</span>.
      </p>
      <p class="text-gray-300">
        By the knowledge soundness of the KZG polynomial commitment
        scheme and the Schwartz&ndash;Zippel lemma, the following
        polynomial identity holds except with negligible probability
        because the evaluation holds at a random point
        <span class="math">\alpha</span>:
      </p>
      <div class="math-block">
        Z_I'(U'(X)) + \chi_1(C_I'(U'(X)) - A(X)) =
        Z_&#123;\mathbb&#123;V&#125;&#125;(X) H(X).
      </div>
      <p class="text-gray-300">
        Therefore,
        <span class="math">Z_&#123;\mathbb&#123;V&#125;&#125;(X)
          \mid Z_I'(U'(X)) + \chi_1(C_I'(U'(X)) -
          A(X))</span>.
        Since <span class="math">\chi_1</span> is sampled after the
        prover commits to
        <span class="math">Z_I', C_I', U'</span>, except with
        probability
        <span class="math">\frac&#123;1&#125;&#123;|\mathbb&#123;F&#125;|&#125;</span>
        it must be that
        <span class="math">Z_&#123;\mathbb&#123;V&#125;&#125;
          \mid Z_I'(U'(X))</span>
        and
        <span class="math">Z_&#123;\mathbb&#123;V&#125;&#125;
          \mid C_I'(U'(X)) - A(X)</span>.
        Then,
        <span class="math">Z_I'(U'(y)) = 0</span> and
        <span class="math">C_I'(U'(y)) = A(y)</span> for all
        <span class="math">y \in
          \mathbb&#123;V&#125;</span>.
        Furthermore,
        <span class="math">U'(y) \in I</span> for all
        <span class="math">y \in
          \mathbb&#123;V&#125;</span>,
        since <span class="math">I</span> is the set of roots of
        <span class="math">Z_I'</span> by definition. Now, for any
        <span class="math">i \in [m]</span>,
        <span class="math">A(\mu^i) = C_I'(U'(\mu^i))</span>. There
        exists a <span class="math">y \in I</span> with
        <span class="math">U'(\mu^i) = y</span> since
        <span class="math">U'</span> maps
        <span class="math">\mathbb&#123;V&#125;</span> to
        <span class="math">I</span>. For all
        <span class="math">y \in I</span>,
        <span class="math">A(\mu^i) = C_I'(y) = C(y)</span>. Let
        <span class="math">j</span> be such that
        <span class="math">y = \omega^j</span>, which we know to
        exist because
        <span class="math">I \subset
          \mathbb&#123;H&#125;</span>
        and <span class="math">\omega</span> generates
        <span class="math">\mathbb&#123;H&#125;</span>. Then when
        the extractor outputs <span class="math">C, A</span>, it
        holds that for all
        <span class="math">\forall i \in [m], \exists j \in [n],
          A(\mu^i) = C(\omega^j)</span>,
        meaning the adversary loses the game.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B                                                   -->
    <!-- ============================================================ -->

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix B: Proof of Theorem 1 &ndash; Zero Knowledge
      </h2>
      <p class="text-gray-300">
        We describe the
        <span class="math">\mathbf&#123;Simulate&#125;_&#123;\text&#123;Link&#125;&#125;</span>
        algorithm that, given an instance
        <span class="math">\boldsymbol&#123;c&#125;,
          \boldsymbol&#123;a&#125;</span>
        and the trapdoor value <span class="math">x</span> convinces
        an interactive verifier to accept. This is similar to the
        argument in Appendix F of [ZBK+22]. The simulator
        samples
        <span class="math">s_1, \dots, s_8 \leftarrow
          \mathbb&#123;F&#125;</span>
        at random and outputs
        <span class="math">\boldsymbol&#123;z_I&#125; =
          [s_1]_1</span>,
        <span class="math">\boldsymbol&#123;c_I&#125; =
          \boldsymbol&#123;c&#125; - [s_2]_1</span>,
        <span class="math">\boldsymbol&#123;u&#125; =
          [s_3]_1</span>.
        The simulator then receives
        <span class="math">\chi_1, \chi_2</span> and outputs
      </p>
      <div class="math-block">
        \boldsymbol&#123;w&#125; = s_1^&#123;-1&#125;[s_2 +
          \chi_2 Z_&#123;\mathbb&#123;H&#125;&#125;(x)]_2,
        \quad
        \boldsymbol&#123;h&#125; = [s_4]_1.
      </div>
      <p class="text-gray-300">
        As in Appendix F, the simulator receives
        <span class="math">\alpha</span>, outputs
        <span class="math">v_1 = s_5</span>,
        <span class="math">v_2 = s_6</span>, and computes KZG
        evaluation proofs:
      </p>
      <div class="math-block">
        \begin&#123;aligned&#125;
          \pi_1 &amp;= (x - \alpha)^&#123;-1&#125;
            (\boldsymbol&#123;u&#125; - [v_1]_1), \\
          \pi_2 &amp;= (x - v_1)^&#123;-1&#125;
            (\boldsymbol&#123;z_I&#125; +
            \chi_1 \boldsymbol&#123;c_I&#125; -
            [v_2]_1), \\
          \pi_3 &amp;= (x - \alpha)^&#123;-1&#125;
            ([v_2]_1 -
            \chi_1 \boldsymbol&#123;a&#125; -
            Z_&#123;\mathbb&#123;V&#125;&#125;(\alpha)
            \boldsymbol&#123;h&#125;).
        \end&#123;aligned&#125;
      </div>
      <p class="text-gray-300">
        It can be seen that the simulator&rsquo;s outputs satisfy the
        pairing check.
      </p>
      <div class="math-block">
        \begin&#123;aligned&#125;
          &amp; e((\boldsymbol&#123;C&#125; -
            \boldsymbol&#123;c_I&#125;) +
            \chi_2[x^n - 1]_1, [1]_2) \\
          =\;&amp; e([s_2]_1 +
            \chi_2[Z_&#123;\mathbb&#123;H&#125;&#125;(x)]_1,
            [1]_2) \\
          =\;&amp; e([1]_1, [s_2]_2 +
            \chi_2[Z_&#123;\mathbb&#123;H&#125;&#125;(x)]_2) \\
          =\;&amp; e([s_1]_1, s_1^&#123;-1&#125;([s_2]_2 +
            \chi_2[Z_&#123;\mathbb&#123;H&#125;&#125;(x)]_2)) \\
          =\;&amp; e(\boldsymbol&#123;z_I&#125;,
            \boldsymbol&#123;w&#125;)
        \end&#123;aligned&#125;
      </div>
      <p class="text-gray-300">
        We note the distribution of output elements matches a valid
        distribution because:
      </p>
      <ul class="list-disc list-inside text-gray-300 ml-4 space-y-1">
        <li>
          <span class="math">\boldsymbol&#123;z_I&#125;</span> is
          blinded by <span class="math">r_1</span> for the prover
          and <span class="math">s_1</span> for the simulator,
        </li>
        <li>
          <span class="math">\boldsymbol&#123;c_I&#125;</span> is
          blinded by <span class="math">r_2</span> for the prover
          and <span class="math">s_2</span> for the simulator,
        </li>
        <li>
          <span class="math">\boldsymbol&#123;u&#125;</span> is
          blinded by <span class="math">r_5</span> for the prover
          and <span class="math">s_3</span> for the simulator,
        </li>
        <li>
          <span class="math">\boldsymbol&#123;w&#125;</span>
          uniquely satisfies the pairing check,
        </li>
        <li>
          <span class="math">\boldsymbol&#123;h&#125;</span> is
          blinded by <span class="math">r_3</span> for the prover
          and <span class="math">s_4</span> for the simulator,
        </li>
        <li>
          <span class="math">v_1</span> is blinded by
          <span class="math">r_6</span> for the prover and
          <span class="math">s_5</span> for the simulator,
        </li>
        <li>
          <span class="math">v_2</span> is blinded by
          <span class="math">r_4</span> for the prover and
          <span class="math">s_6</span> for the simulator,
        </li>
        <li>
          <span class="math">\pi_1, \pi_2, \pi_3</span> uniquely
          satisfy the KZG openings.
        </li>
      </ul>
    </section>
  </article>
</BaseLayout>
