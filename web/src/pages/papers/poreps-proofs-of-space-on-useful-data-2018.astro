---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/678';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'PoReps: Proofs of Space on Useful Data';
const AUTHORS_HTML = 'Ben Fisch';

const CONTENT = `    <p class="text-gray-300">PoReps: Proofs of Space on Useful Data</p>

    <p class="text-gray-300">Ben Fisch</p>

    <p class="text-gray-300">Stanford University, Protocol Labs</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">A <em>proof-of-replication</em> (PoRep) is an interactive proof system in which a prover defends a publicly verifiable claim that it is dedicating unique resources to storing one or more retrievable replicas of a data file. In this sense a PoRep is both a <em>proof of space</em> (PoS) and a <em>proof of retrievability</em> (PoR). This paper establishes a foundation for PoReps, exploring both their capabilities and their limitations. While PoReps may unconditionally demonstrate possession of data, they fundamentally cannot guarantee that the data is stored redundantly. Furthermore, as PoReps are proofs of space, they <em>must</em> rely either on rational time/space tradeoffs or timing bounds on the online prover’s runtime. We introduce a rational security notion for PoReps called <span class="math">\\epsilon</span>-rational replication based on the notion of an <span class="math">\\epsilon</span>-Nash equilibrium, which captures the property that a server does not gain any significant advantage by storing its data in any other (non-redundant) format. We apply our definitions to formally analyze two recently proposed PoRep constructions based on verifiable delay functions and depth robust graphs. Lastly, we reflect on a notable application of PoReps—its unique suitability as a Nakamoto consensus mechanism that replaces proof-of-work with PoReps on real data, simultaneously incentivizing and subsidizing the cost of file storage.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A <em>proof-of-replication</em> (PoRep) builds on the two prior concepts of proofs-of-retrievability (PoR) <em>[30]</em> and proofs-of-space (PoS) <em>[24]</em>. In the former a <em>prover</em> demonstrates that it can retrieve a file and in the latter the prover demonstrates that it is using some minimum amount of space to store information. Most proofs of space require the prover to use this space to store junk information that is only relevant to the PoS protocol. A PoRep, in essence, embeds a PoR within a PoS. It enables the prover to demonstrate that it is using some minimum amount of space while simultaneously allowing it to actually use that space to store useful information. An additional critical property of a PoRep is that the storage costs required to succeed in the protocol depend only on the <em>size of the data inputs</em> and are otherwise independent of the data inputs. In particular, the cost to succeed in the protocol should not depend on whether or not this data was privately preprocessed (e.g. encrypted by a client) or generated by the server itself. As another special case, if the input to the protocol were <span class="math">k</span> redundant copies of the same file then this would cost the same as running the protocol on <span class="math">k</span> distinct data files. Intuitively, this would achieve the following property: even if a PoRep prover <em>could</em> pass the protocol without storing the data redundantly (e.g. by deduplicating the <span class="math">k</span> copies), there would be no advantage to doing so. In other words, it would be <em>rational</em> for a PoRep prover in this scenario to honestly store <span class="math">k</span> copies of the data.</p>

    <p class="text-gray-300">Consider as a thought exercise a simple composition of a PoR protocol and PoS protocol that would not succeed in achieving these goals. This simple protocol requires the prover to use a total of <span class="math">2N</span> space. The prover uses half of this space to produce a PoS (i.e. it runs a standard PoS protocol that requires it to fill this space with random data) and it uses the other half to actually store some useful data file of size <span class="math">N</span> and produce PoRs of the file. This satisfies both a PoR and a PoS with only <span class="math">2N</span> storage and therefore shows both that the prover is using some minimum <span class="math">\\Omega(N)</span> amount of storage and is able to retrieve the data of interest. However, it fails the “independent cost” criterion. Namely, it is more expensive for the prover to run this protocol on useful data (requiring <span class="math">2N</span> space to store both the useful data and the random data) than to just store the useless random data required for the PoS and provide a PoR for this random data (requiring only <span class="math">N</span> space). Moreover, consider if the prover were asked to store <span class="math">k</span> redundant copies of the same file <span class="math">D</span> and use this protocol to prove that it (a) is using at least <span class="math">kN</span> space to store these copies and (b) is able to retrieve <span class="math">D</span>. Following the protocol honestly requires <span class="math">2kN</span> space: <span class="math">kN</span> space to store the <span class="math">k</span> copies of <span class="math">D</span> and <span class="math">kN</span> space to store the random data required for the PoS. Unfortunately, the most rational strategy would be to store only the random data and a single copy of <span class="math">D</span> as this uses only <span class="math">(k+1)N</span> space and still allows the prover to successfully pass the protocol.</p>

    <p class="text-gray-300">While standard PoRs can provide proofs of data duplication in a private-verifier setting where the client preprocesses its own data before sending it to the server, their security relies on a non-colluding client to privately preprocess the data. One advantage of PoReps over standard PoRs for proofs of data duplication is that multiple clients could contribute data to a single database and would not need to trust any single client to preprocess the data. PoReps could also be used to provide proofs of storage for publicly available data. For example, a consensus server in a massively distributed and open state-replication system such as Bitcoin could provide a PoRep that it is storing a complete history of the state-machine transcript (i.e. in <em>blockchain</em> systems like Bitcoin this is referred to as a “full node” storing the “chain”). Unlike PoRs, PoReps could be used to provide this proof without requiring all the verifiers to send the server their own preprocessed copy of the public transcript (incurring impractical communication).</p>

    <p class="text-gray-300">PoReps provide a publicly verifiable proof of data duplication, secure against adversaries who will not deviate from an <span class="math">\\epsilon</span>-rational honest strategy. The notion of an <span class="math">\\epsilon</span>-equilibrium is used in game theory as a generalization of a Nash equilibrium where players gain at most an <span class="math">\\epsilon</span> advantage from deviating. This solution concept is appropriate for a malicious-but-lazy adversary, or in conjunction with the status-quo-bias assumption: you are on the couch and the TV remote is across the room, so you continue to watch the same channel. This may seem like a strangely weak security property to achieve in a cryptographic protocol. For a very simple reason it is actually the best possible security that PoReps can achieve, at least in the standard model of computation for cryptographic analysis. In short, any prover storing <span class="math">k</span> independent replicas of the file could intentionally <em>correlate</em> these replicas in a way that it can still efficiently retrieve each in its original format. For example, it could encrypt them and store the key.</p>

    <p class="text-gray-300">However, the primary use case of PoReps is probably not a proof of storage system that weakly discourages de-duplication. The properties achieved by PoReps make it uniquely suited</p>

    <p class="text-gray-300">for a Nakamoto consensus mechanism (also known as <em>blockchain</em> consensus) that use PoReps as a <em>useful proof of space</em> in place of Bitcoin’s proof-of-work to achieve sybil-resistance. Briefly, Nakamoto consensus mechanisms and its variants are a special type of state-machine replication process managed by an unpermissioned, asynchronous, and distributed network of consensus participants, with the additional feature that the state-machine itself encodes fungible tokens of value. In particular, a defining characteristic of these consensus mechanisms is their ability to mint new tokens in the state machine in order to reward and incentivize consensus participants (termed <em>miners</em>), taking for granted that these tokens represent real-world assets.</p>

    <p class="text-gray-300">Blockchain systems based on proof-of-space have been proposed <em>[19, 42]</em> and are in active development, pursuing goals including energy efficiency and more egalitarian distribution. PoReps target a different advantage entirely: they simultaneously incentivize useful peer-to-peer data storage. This is the basis of Filecoin <em>[1]</em>. The miners that manage the system’s distributed state-machine are required to produce PoReps in order to append transactions, or equivalently, be elected as temporary consensus leaders, and are rewarded with freshly minted coins in return. Accepting the hypothesis that the miners will be incentivized by these rewards alone to produce PoReps, just as Bitcoin miners produce wasteful proofs-of-work, the rewards–in effect–subsidize the auxiliary <em>useful work</em> accomplished by the PoRep: file storage.</p>

    <p class="text-gray-300">The utility of <span class="math">\\epsilon</span>-rational replication in this context is immediately transparent. It characterizes the <span class="math">\\epsilon</span> cost required to nudge a data replication strategy from a weak equilibrium strategy into a strong one. In other words, it represents the cost that clients must pay (in a stylized model that ignores other market variables) to convince miners to encode their real data inside PoReps rather than “useless” generated data, and therefore the degree to which a system such as Filecoin subsidizes storage costs. PoReps thus sit at an exciting crossroads of economics and cryptography:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><em>PoReps epitomize a cryptographic mechanism that is concerned not solely with the actions and capabilities of an adversary, nor penalties levied for misbehavior, but rather its broader effect on behaviors in an economy.</em></p>
    </blockquote>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Related work</h3>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Proofs of storage</h4>

    <p class="text-gray-300">Cryptographic proofs of storage have been proposed in a variety of flavors throughout the literature. Broadly speaking, proofs of storage are interactive protocols between a server (prover) and client (verifier) with different goals relating to statements about the server’s storage. Proofs-of-retrievability (PoR) <em>[30]</em> demonstrate that the prover can retrieve some specified data known to the verifier. A <em>public-key</em> PoR is outsourceable, meaning that the client can provide a public authentication tag that any verifier can use to verify the server’s proofs. Unless the data itself is incompressible, a PoR does not necessarily prove anything to the verifier about how much space the prover is using in order to retrieve the file. In particular, in the public-key setting the third party verifier does not know whether the client is colluding with the server or not, and therefore a PoR is not a truly publicly verifiable claim of storage. In proofs-of-space (PoS) <em>[24]</em> a time-constrained prover demonstrates that it is storing some incompressible string of <span class="math">\\Omega(N)</span> bits, and therefore using at least <span class="math">\\Omega(N)</span> bits of space. This formulation of PoS is sometimes referred to as a <em>proof of persistent space</em> as opposed to a proof of transient space <em>[46]</em>. Timing assumptions are inherently required in proofs of persistent space due to the efficiency</p>

    <p class="text-gray-300">requirement that the communication between the prover and verifier is required to be compact, as otherwise the prover can store only the communication transcript and recompute the advice. Proofs-of-secure-erasure (PoSE) <em>[44]</em> are protocols similar to a PoS intended to demonstrate that a storage-bound prover has erased all of its storage. An important difference between PoSE and the standard PoS notion is that they involve a private-key verifier who preprocesses data, similar to a PoR proof. They were suggested as a protocol for a memory-bound embedded device to prove to a server that it has erased private data or all prior code before an update, e.g. to ensure that any malware has been erased.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Rationally secure storage protocols</h4>

    <p class="text-gray-300">All of the above proof of storage protocols are unconditionally secure, or at least characterize security in terms of strong time-space lower bounds. However, there are additionally a class of proof of storage protocols that are secure in a weaker <em>rational adversary</em> model. The model considered in all of these works is an adversary that acts to minimize its storage costs. Storage enforcing commitments <em>[28]</em> were a precursor to PoR that require the prover to dedicate a minimum amount of storage in order to pass the protocol for a committed file <span class="math">F</span> (preprocessed by a client with a secret key). Their constructions did not guarantee unconditionally that the prover was actually storing <span class="math">F</span>, and were therefore only secure in an epsilon-rational sense. Hourglass schemes <em>[51]</em> were proposed as a generic method to prove that a server is storing data encoded in a specified format, in particular for the use cases of encryption-at-rest and file watermarking. Similarly, they leave open the possibility that the server is also storing a plaintext or non-watermarked version of the file. It only guarantees that such a server must use twice the storage resources to act maliciously.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Proof of data replication vs PoReps</h4>

    <p class="text-gray-300">A proof of data replication/duplication, specifically in the sense of proving that data is stored in a redundant format, is a special case of hourglass schemes. Proofs of data replication/duplication have been explored primarily in the private-client setting similar to proofs of retrievability <em>[7, 47]</em>. In this setting a client is somehow involved in preprocessing the data and either the client is the verifier or the client outsources its own verification work. The system Mirror <em>[7]</em> is one such example, which proposed a way for the server to replicate the client’s initially preprocessed file without requiring further communication from the client. The main technique in Mirror is a variant on RSA time-lock puzzles, and the security relies on timing assumptions similar to PoS. Several days ago another paper exploring this line of work was posted, which proposed a construction of proof of data replication in the private-client setting without timing assumptions <em>[21]</em>.</p>

    <p class="text-gray-300">The term proof-of-replication (PoRep), which is the focus of our work, was proposed by the Filecoin project <em>[2]</em> in reference to a hybrid of a PoR and PoS that demonstrates in a publicly verifiable way that the prover is using space to store a unique replica of a file, or even several unique replicas of the same file. The main intent of this proposed primitive was to resist the so called “generation attack”, i.e. it should be a publicly verifiable proof of space even when the server may collude with a client. A nearly equivalent concept to proof-of-replication was proposed earlier by Sergio Demian Lerner in 2014 under the name <em>proof of unique blockchain storage</em> <em>[33]</em>. It focussed on the special case where all provers/verifiers in the system know at least one copy of the replicated file. For instance, it was proposed as a mechanism for demonstrating publicly that the Bitcoin blockchain is highly replicated. Lerner proposed using time-asymmetric encodings to apply a slow transformation to a file using a unique identifier as a key. Boneh et. al. generalized this construction using a new primitive called a decodable verifiable delay function</p>

    <p class="text-gray-300">(VDF) <em>[14]</em>. New constructions of PoReps using more traditional tools from proofs of space (i.e. hard-to-pebble graphs) were concurrently proposed in <em>[26, 45]</em>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Tight proofs of space</h4>

    <p class="text-gray-300">As we develop in this work, there is a strong connection between tight proofs of space and PoReps. A tight proof of space is one where any adversarial prover implementing an attack uses only an <span class="math">\\epsilon</span> fraction less space than the honest prover where <span class="math">\\epsilon</span> can be made arbitrarily small. Intuitively, if a PoRep is not a tight proof of space (e.g. <span class="math">\\epsilon=1/2</span>) then there may be some adversary that would be rationally incentivized to deviate from honest behavior and therefore likely destroy the replication format. Pietrzak <em>[45]</em> constructed the first tight PoS, although the proof size is <span class="math">O(1/\\epsilon^{2})</span> and depended on depth robust graphs with rather special properties <em>[6]</em>. Concretely, according to the analysis it requires graphs of degree <span class="math">2,760\\log N</span> just to achieve <span class="math">1/2</span> space gap. The PoRep based on verifiable delay encodings as a moderately hard function <em>[14]</em> is in fact an arbitrarily tight PoS, however it is exceedingly inefficient to generate on large data (scaling quadratically in the data size).</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.2 Contributions and Organization</h3>

    <p class="text-gray-300">This work is a foundational study of PoReps. Primarily, we motivate the goals of PoReps and explore what they are in contrast to other cryptographic primitives. Although many of the related primitives including proofs of retrievability, proofs of space, and proofs of data replication (private-client setting) were formally defined and studied in prior works, this is the first comprehensive formal study of PoReps. While a presentation at BPASE 2018 <em>[26]</em> provided the first basic definitions for PoReps and intuition about both the impossibility of ideal security and how to define <span class="math">\\epsilon</span>-rational replication, we build upon this further and provide a comprehensive model and definitions. In particular, our framework also addresses issues of composable security noted in a recent paper by Fisch and Silas <em>[27]</em>—namely the issue that the prover may be incentivized to deviate from a rational replication strategy if deviating somehow benefits another simultaneous storage mechanism (e.g., perhaps it could use the PoRep data to compress auxiliary data that it is storing).</p>

    <p class="text-gray-300">Relevant background information and preliminary tools are discussed in the Appendix A. While for the most part this is a review, we also present a new formulation of a primitive we call <em>proof of retrievable commitment</em> (PoRC) and a simple generic construction based on vector commitments. This generalizes the simple public proof of retrievability on Merkle commitments that is used ubiquitously, particularly as a subprotocol in proofs of space. Section 2 defines PoReps abstractly and presents our security model for <span class="math">\\epsilon</span>-rational replication (Definition 6). We show that this definition implies that the PoRep is a PoS, although it does not demand it explicitly. Proving that a PoRep construction satisfies the definition also likely requires “knowledge of compression assumptions” <em>[27]</em>. We formulate one such assumption along with a key lemma (Lemma 2) that establishes sufficient criteria for <span class="math">\\epsilon</span>-rational replication, showing that if a PoRep construction satisfies PoRC and PoS in a certain sense then it will also satisfy <span class="math">\\epsilon</span>-rational replication. This greatly simplifies the analysis of candidate PoRep constructions. Section 3 presents in detail the two constructions Basic-VDF-PoRep from VDFs <em>[14]</em> and DRG-PoRep <em>[26]</em> that fuses more traditional techniques in PoS (hard-to-pebble DAGs) with VDFs. Finally, Section 4 applies the model, definitions, and Lemma 2 of Section 2 to formally analyze and prove secure both constructions DRG-PoRep and Basic-VDF-PoRep.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 Introduction</li>

      <li>1.1 Related work</li>

      <li>1.2 Contributions and Organization</li>

      <li>2 Proof-of-Replication</li>

      <li>2.1 Replication Security Model</li>

      <li>2.1.1 Impossibility of ideal replication security</li>

      <li>2.1.2 Rational adversary model</li>

      <li>2.1.3 Security for decentralized storage networks</li>

      <li>3 Constructions</li>

      <li>3.1 Basic PoRep from Verifiable Delay Encodings</li>

      <li>3.1.1 Basic-VDE-PoRep</li>

      <li>3.2 Block Chaining Encodings</li>

      <li>3.3 DRG PoRep</li>

      <li>3.3.1 DRG-PoRep</li>

      <li>4 Formal security analysis</li>

      <li>4.1 Labeling games with VDEs</li>

      <li>4.2 Security claims</li>

      <li>A Preliminaries and Background</li>

      <li>A.1 Compression and Erasure Codes</li>

      <li>A.2 Proofs of Retrievability</li>

      <li>A.3 Vector Commitments</li>

      <li>A.4 Proof of Retrievable Commitment</li>

      <li>A.4.1 PoRC Syntax and Definitions</li>

      <li>A.4.2 PoRC from Vector Commitments</li>

      <li>A.5 Verifiable Delay Encodings</li>

      <li>A.5.1 VDE security</li>

      <li>A.6 Depth Robust Graphs</li>

      <li>A.7 Proofs of Space</li>

      <li>A.8 Graph pebbling games</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">2 Proof-of-Replication</h2>

    <p class="text-gray-300">We begin with defining the syntax for a proof-of-replication (PoRep). A PoRep operates on arbitrary data <span class="math">D\\in\\{0,1\\}^{*}</span> of up to <span class="math">O(\\mathrm{poly}(\\lambda))</span> size for a given security parameter <span class="math">\\lambda</span>. All algorithms are assumed to operate in the RAM model of computation (in particular reading a bit of an input is assumed to be an <span class="math">O(1)</span> operation). Parallel algorithms operate in the PRAM model.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRep.Setup(<span class="math">\\lambda, T</span>) → <span class="math">pp</span> is a one-time setup that takes in a security parameter <span class="math">\\lambda</span>, time parameter <span class="math">T</span>, and outputs public parameters <span class="math">pp</span>. <span class="math">T</span> determines the challenge-response period.⁴</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. PoRep.Preproc(<span class="math">sk, D</span>) → <span class="math">\\tilde{D}</span>, <span class="math">\\tau_D</span> is a preprocessing algorithm that may take a secret key <span class="math">sk</span> along with the data input <span class="math">D</span> and outputs preprocessed data <span class="math">\\tilde{D}</span> along with its data tag <span class="math">\\tau_D</span>, which at least includes the size $N =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of the data. The preprocessor operates in keyless mode when </span>sk = \\bot$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRep.Replicate(<span class="math">id, \\tau_D, \\tilde{D}</span>) → <span class="math">R</span>, aux takes a replica identifier <span class="math">id</span> and the preprocessed data <span class="math">\\tilde{D}</span> along with its tag <span class="math">\\tau_D</span>. It outputs a replica <span class="math">R</span> and (compact) auxiliary information aux which will be an input for the Prove and Verify procedures. (For example, aux could contain a proof about the replication output or a commitment).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRep.Extract(<span class="math">pp, id, \\tau_D, R</span>) → <span class="math">\\tilde{D}</span> on input replica <span class="math">R</span> and identifier <span class="math">id</span> and data tag <span class="math">\\tau_D</span> outputs the data <span class="math">\\tilde{D}</span> (and verifies its consistency with <span class="math">\\tau_D</span>).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRep.Prove(<span class="math">R</span>, aux, <span class="math">id, r</span>) → <span class="math">\\pi</span> on input replica <span class="math">R</span>, auxiliary information aux, replica identifier <span class="math">id</span>, and challenge <span class="math">r</span>, outputs a proof <span class="math">\\pi_{id}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRep.Poll(aux) → <span class="math">r, s</span>: This takes as input the auxiliary replica information aux and outputs a public challenge <span class="math">r</span> along with any private randomness <span class="math">s</span> used to produce this challenge. For public coin constructions <span class="math">s = \\bot</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRep.Verify(<span class="math">id, \\tau_D, r, s, aux, \\pi</span>) → <span class="math">\\{0, 1\\}</span> on input replica identifier <span class="math">id</span>, data tag <span class="math">\\tau_D</span>, public challenge <span class="math">r</span>, private randomness <span class="math">s</span> (used to produce <span class="math">r</span>), auxiliary replication information aux, and proof <span class="math">\\pi</span> it outputs a decision to accept (1) or reject (0) the proof.</li>

    </ol>

    <p class="text-gray-300">PoRep interactive protocol These algorithms are used in an interactive protocol as illustrated in Figure 1. The setup (whether a deterministic, trusted, or transparent public setup, such as one involving a public random source) is run externally and <span class="math">pp</span> is given as an input to all parties. For each file <span class="math">D</span>, a preprocessor (a special party or the prover when operating in keyless mode, but not the verifier) runs <span class="math">(\\tilde{D}, \\tau_D) \\gets \\text{PoRep.Preproc}(sk, D)</span>. The outputs <span class="math">\\tilde{D}, \\tau_D</span> are inputs to the prover and <span class="math">\\tau_D</span> to the verifier.</p>

    <p class="text-gray-300">Transparency, public coin, and public verifiability A PoRep scheme may involve a trusted one-time setup, in which case PoRep.Setup is run by a trusted party⁵ and the output <span class="math">pp</span> is published for all parties to see. A transparent PoRep scheme is one in which the setup does not involve any private information. This trusted setup is an independent, one-time procedure, and the trusted party that runs the setup should have no further involvement in the interactive protocol. The data preprocessor on the other hand may use a secret-key, but it is not trusted. In</p>

    <p class="text-gray-300">⁴An alternative formulation may allow for a variable challenge-response period <span class="math">T</span> that might depend on the size of the data input. Our formulation does not allow this, implying that the online prover PoRep.Prove must run in parallel time less than <span class="math">T</span> (including transmission time of the its proof to the verifier) independent of the data size (up to <span class="math">O(\\text{poly}(\\lambda))</span> in length). Achieving a fixed polling period <span class="math">T</span> for all input data of any reasonable length (i.e. poly(<span class="math">\\lambda</span>)) is important in practice.</p>

    <p class="text-gray-300">⁵As usual, the trusted party can also be replaced with a committee that runs a multi-party computation (MPC) protocol to generate the public parameters</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2.1: The diagram illustrates the interaction between a prover and verifier in a PoRep protocol. The setup and data preprocessing is run externally generating  <span class="math">pp \\gets \\mathsf{PoRep.Setup}(\\lambda, T)</span>  and  <span class="math">\\tilde{D}, \\tau_{D} \\gets \\mathsf{PoRep.Preproc}(sk, D)</span> . The challenge-response protocol is timed, and the verifier rejects any response that is received more than  <span class="math">T</span>  time steps after sending the challenge. This is formally captured by requiring PoRep.Prove to run in parallel time at most  <span class="math">T</span> . The propagation delay on the communication channel between Prover and Verifier is assumed to be nominal in comparison to  <span class="math">T</span> .</p>

    <p class="text-gray-300">particular, the verifier is oblivious to whether the preprocessor colludes with the server or not. As we will discuss next the secret-key preprocessor only has implications for data retrievability, but not for the security of the publicly verifiable data replication (or proof of space). This is an important distinction from the notion of proof of data replication proposed in the system Mirror. A PoRep scheme may be private coin if the private input  <span class="math">r</span>  to PoRep.Poll is non-empty, and it is public coin if  <span class="math">r = s</span> . A public coin PoRep has the additional desirable property that the challenge output by PoRep.Poll could be replaced by a challenge derived from an unpredictable public random beacon <span class="math">^6</span> .</p>

    <p class="text-gray-300">Data preprocessing and data retrievability When the data input is preprocessed using a secret-key the resulting PoRep is a public-coin PoR (among satisfying other properties regarding replication and proof of space that we will discuss further in the following section on the PoRep security model). In this scenario we can imagine the preprocessor is a single client who wants to store (and replicate) data on a server, and generates the data tag  <span class="math">\\tau_{D}</span>  to outsource this verification</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2.2: Space-time diagram of the PoRep protocol. Following a phase of length  <span class="math">t_{\\mathrm{init}}</span>  during which the prover generates a new replica, the verifier repeatedly challenges the prover to produce a PoRep within a challenge time period length  <span class="math">T</span>  in order to verify that the prover is still storing the unique replica of the original data. For this proof system to be sound it is necessary that  <span class="math">t_{\\mathrm{init}} &amp;gt;&amp;gt; T</span> .</p>

    <p class="text-gray-300">work. When the preprocessor runs in keyless mode the resulting PoRep is a PoRC (Section A.4) with respect to the output  <span class="math">\\tau_{D}</span> , which includes a commitment to the data  <span class="math">D</span> . Any (stateful) verifier that is at one point given the opening of the commitment can thereafter use the tag to verify PoReps as standard PoRs. This is particularly useful for a setting in which multiple clients pool their files together and want to receive a single PoRep for the entire dataset, but they do not mutually trust one another to share a private-key. It is also appropriate for a dynamic setting where new clients are made aware of the data stored on the server and wish to verify retrievability without trusting the original client's private-key preprocessing.</p>

    <p class="text-gray-300">Treating data preprocessing in this way as a separate "layer of the stack" allows for a wider variety of constructions appropriate in different settings without impinging on the efficiency of the underlying PoRep protocol itself. In fact, a PoRep protocol that (without preprocessing) satisfies  <span class="math">(\\delta, \\mathcal{C})</span> -PoRC (e.g. for  <span class="math">\\mathcal{C}</span>  partitioning the data into constant size blocks) can immediately be compiled into either a public-key PoR or a PoRC using any number of previous techniques. We highlight the two scenarios:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A client has a data file  <span class="math">D</span>  and uses a randomly generated secret key  <span class="math">sk</span>  to produce  <span class="math">\\tilde{D}, \\tau_{D} \\gets \\text{PoRep.Preproc}(sk, D)</span>  which applies a rate- <span class="math">\\delta</span>  adversarial erasure code [15] to  <span class="math">D</span>  (i.e. one that is resilient to arbitrary adversarial deletions of up to  <span class="math">\\delta</span>  fraction of the blocks in  <span class="math">\\tilde{D}</span> ). The tag  <span class="math">\\tau_{D}</span>  is a commitment to  <span class="math">\\tilde{D}</span> . The adversarial erasure code may involve a secret transformation using  <span class="math">sk</span>  and requires  <span class="math">sk</span>  as well to recover from these errors. The private-key setting enables using more efficient erasure codes that only tolerate random deletions because they can be combined with a secret pseudorandom permutation of the data so that an adversary will only succeed in targeted deletions with up to negligible probability [15, 48]. The client then uses  <span class="math">\\tau_{D}</span>  for verification in the PoRep protocol, which we assume is already a  <span class="math">(\\delta, \\mathcal{C})</span> -PoRC with respect to  <span class="math">\\tau_{D}</span> . Any verifier  <span class="math">\\mathcal{V}</span>  can publicly verify that a  <span class="math">\\delta</span>  fraction of the committed  <span class="math">\\tilde{D}</span>  is retrievable (and indeed there is a public extraction algorithm for a  <span class="math">\\delta</span>  fraction of blocks in  <span class="math">\\tilde{D}</span> ), which is sufficient for the private client to recover  <span class="math">D</span>  using  <span class="math">sk</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A keyless preprocessor transforms the data file <span class="math">D</span> into a single code word of a deterministic rate-<span class="math">\\delta</span> optimal erasure code (e.g., Reed-Solomon) with symbol size equal to the block size in <span class="math">\\mathcal{C}</span>. It outputs <span class="math">\\tau_{D}</span> as a deterministic commitment to <span class="math">\\tilde{D}</span>, which is also a deterministic commitment to <span class="math">D</span>. Due to the resilience of the erasure code (<span class="math">D</span> can be recovered from any <span class="math">\\delta</span> fraction of the symbols in <span class="math">\\tilde{D}</span>), the PoRep <span class="math">(\\delta, \\mathcal{C})</span>-PoRC of <span class="math">\\tilde{D}</span> becomes a PoRC of <span class="math">D</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency</strong> All algorithms must run in time <span class="math">O(\\mathrm{poly}(\\lambda))</span> and with up to at most <span class="math">O(\\mathrm{poly}(\\lambda))</span> parallelism. We don't directly impose further efficiency requirements in the PoRep definition, but implicitly a PoRep scheme cannot be simultaneously correct and secure unless PoRep.Poll and PoRep.Prove have a lower parallel time complexity than PoRep.Replicate on <span class="math">O(\\mathrm{poly}(\\lambda))</span> processors. Otherwise, for correctness to hold the challenge-response period will be long enough for an adversarial prover to rerun the replica generation from scratch. Furthermore, for practical purposes it is highly desirable for PoRep.Prove and PoRep.Verify to run in constant or $O(\\mathrm{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> time, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the length of the data file. Among other benefits, this enables batched proofs and verification of multiple replicas of the same (or distinct) files, which scales sublinearly in the number of replicas/files. Replica generation PoRep.Replicate runs in time greater than </span>\\max(T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, however it is desirable for this runtime to be sublinear in </span>T \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ as the size of the file increases.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Correctness</strong> In a correct PoRep construction, a prover who runs PoRep.Replicate and PoRep.Prove honestly must pass verification with probability 1. In order to pass verification the algorithm PoRep.Prove must run in parallel time at most <span class="math">T</span> as otherwise the verifier will not receive the output within the challenge-response period. In addition, PoRep.Extract must correctly extract the original data from a replica generated with PoRep.Replicate.</p>

    <p class="text-gray-300"><strong>Definition 1 (PoRep correctness).</strong> A PoRep construction is correct if for any security parameter <span class="math">\\lambda</span>, any <span class="math">id</span> and data input <span class="math">D</span>, there exists <span class="math">T_{\\lambda}</span> such that for all <span class="math">T \\geq T_{\\lambda}</span>, <span class="math">pp \\gets \\text{PoRep.Setup}(\\lambda, T)</span>, and <span class="math">(R, \\tau) \\gets \\text{PoRep.Replicate}(pp, id, D)</span> it holds that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr\\left[ \\text{PoRep.Verify}(pp, id, r, s, \\tau, \\pi) = Accept \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (r, s) \\leftarrow \\text{PoRep.Poll}(pp, \\tau) \\\\ \\pi \\leftarrow \\text{PoRep.Prove}(pp, R, id, r) \\end{array} \\right] = 1 \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and <span class="math">\\text{PoRep.Prove}(pp, R, id, r)</span> runs in parallel time at most <span class="math">T_{\\lambda}</span>.</p>

    <p class="text-gray-300">Additionally:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr\\left[ \\tilde{D} = D \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} R \\leftarrow \\text{PoRep.Replicate}(pp, id, D) \\\\ \\tilde{D} \\leftarrow \\text{PoRep.Extract}(pp, id, R) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-11" class="text-2xl font-bold">2.1 Replication Security Model</h2>

    <p class="text-gray-300">An ideal security goal for PoRep protocols, beyond satisfying the standard definition of a PoR, would be to guarantee the following properties, described informally:</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">10</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adverary</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Challenger</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: Apre chooses D = D1, ..., Dk; id = id1, ..., idk; and computes data tags τ = τD1, ..., τDk |   |</p>

    <p class="text-gray-300">|  2: σ, aūx ← Apre(pp, z, id, τ, D) |   |</p>

    <p class="text-gray-300">|   | z, id, aūx = aux1, ..., auxk  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀i ri←PoRep.Poll(auxi)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | τ = r1, ..., rk  |</p>

    <p class="text-gray-300">|  4: z, π ← Aonl(pp, σ, aūx, id, τ) |   |</p>

    <p class="text-gray-300">|   | π = π1, ..., πk  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">bi ← PoRep.Verify(idi, τDi, ri, auxi, πi)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2.3: The diagram illustrates the PoRep security game between an adversary and a challenger. Several inputs come from the environment, which runs the setup  <span class="math">pp \\gets \\mathsf{PoRep.Setup}(\\lambda, T)</span>  and chooses an auxiliary input  <span class="math">z</span>  for the adversary. The adversary is split into two components:  <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span>  and  <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span> . They may share initial static state but cannot communicate during the game. In particular,  <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span>  does not see the input  <span class="math">z</span>  nor  <span class="math">\\vec{D}</span>  chosen by  <span class="math">\\mathcal{A}_{\\mathrm{pre}}(z)</span> . It does obtain the inputs  <span class="math">pp, \\sigma, a\\vec{u}x</span> . This restriction captures the fact that  <span class="math">\\sigma</span>  may encode a function of auxiliary information  <span class="math">z</span>  in addition to the replicas of  <span class="math">\\vec{D}</span> . Moreover,  <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span>  runs in parallel time at most  <span class="math">T_{\\mathrm{onl}}</span>  whereas  <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span>  is only restricted to run in total time  <span class="math">O(poly(\\lambda))</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any prover who simultaneously passes verification in  <span class="math">k</span>  distinct PoRep protocols (under  <span class="math">k</span>  distinct identities) where the input to PoRep.Replicate is a file  <span class="math">D_{i}</span>  in the  <span class="math">i</span> th protocol must be storing  <span class="math">k</span>  independent replicas, one for each  <span class="math">D_{i}</span> , even if several of the files are identical.</li>

      <li>A prover who passes verification in a PoRep protocol where the input to PoRep.Replicate is a file  <span class="math">\\tilde{D} = D\\circ \\dots \\circ D</span>  (consisting of  <span class="math">k</span>  copies of the same file  <span class="math">D</span> ) must be storing  <span class="math">k</span>  independent physical copies of  <span class="math">D</span> .</li>

    </ol>

    <p class="text-gray-300">We will capture these security goals more formally through a game between a PoRep prover (adversary) and a challenger (Figure 2.3). A high level overview of the game is as follows. The prover/adversary is split into two components: a replication adversary and an online adversary whose sequential running time (i.e. parallel time) is bounded by a parameter  <span class="math">T</span> . The replication adversary is allowed to select the data inputs and the number of replicas  <span class="math">k</span> . The replicas do not need to be of all the same files. Specifically, we represent this input as a vector  <span class="math">D = (D_{1},\\dots,D_{k})</span>  of data files  <span class="math">D_{i}</span>  each of size  <span class="math">N</span> , where some (or all) of the files are identical. The adversary also chooses  <span class="math">k</span>  unique distinct identifiers for each file and  <span class="math">k</span>  file tags. The prover can then</p>

    <p class="text-gray-300">compute on the data (as in phase 1 of replication) to produce an advice string <span class="math">\\sigma</span> for the online adversary as well as the auxiliary output <span class="math">a\\vec{u}x</span>, which includes <span class="math">N</span> (the claimed size of each data file component). The online adversary receives a vector of <span class="math">k</span> challenges from the challenger and must output <span class="math">k</span> proofs. The challenger then runs the PoRep verifier on each and outputs the verifier's accept/reject decision.</p>

    <p class="text-gray-300"><strong>k-replication</strong> To capture "storing <span class="math">k</span> independent replicas" we say that <span class="math">\\sigma</span> is a <span class="math">k</span>-replication of a file <span class="math">D</span> if the string <span class="math">\\sigma</span> can be partitioned into <span class="math">k</span> substrings <span class="math">\\sigma_1, \\ldots, \\sigma_k</span> such that each allow full recovery of the file <span class="math">D</span>. Formally:</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> Let <span class="math">\\mathcal{S}</span> be a data source on <span class="math">\\{0,1\\}^n</span>. A string <span class="math">\\sigma</span> is a <span class="math">k</span>-replication of a data sample <span class="math">D = (d_1,\\dots,d_k)\\gets \\mathcal{S}^k</span> if and only if there is a lossless randomized encoding scheme <span class="math">(\\text{enc},\\text{dec})</span> and a partition of <span class="math">\\sigma</span> into <span class="math">k</span> substrings <span class="math">\\sigma_1,\\dots,\\sigma_k</span> such that <span class="math">\\text{enc}(d_i) = \\sigma_i</span> and <span class="math">\\text{dec}(\\sigma_i) = d_i</span> for all <span class="math">i = 1,\\dots,k</span>.</p>

    <p class="text-gray-300">Intuitively, security goal (1) can be captured by requiring that any online adversary in the PoRep game who is not given a <span class="math">k</span>-replication of the data by the preprocessor adversary will fail with overwhelming probability. This would imply that if several provers each provide distinct PoReps of the same file then they are each dedicating unique resources<span class="math">^8</span> to storing the file. It would also imply that a prover who claims in a single proof to be storing multiple replicas of a file cannot physically deduplicate its storage. Unfortunately, this security property is impossible to achieve in a classical model of interactive computation (that does not include timing bounds on communication<span class="math">^9</span>), as we explain next. Instead, we will need to relax the security model to consider rational adversaries and bound the cost savings (measured in storage resources) of adversaries who do not store a <span class="math">k</span>-replication of the data input. The security notion we call <span class="math">\\epsilon</span>-rational replication could be informally interpreted as security against an "honest-but-opportunistic" adversary that will only employ a malicious strategy if they stand to save more than some <span class="math">\\epsilon</span> cost doing so.</p>

    <p class="text-gray-300"><strong>Data tag verification oracle</strong> In order to be as general as possible we don't explicitly require <span class="math">\\tau_{D}</span> to be a commitment to <span class="math">D</span>. Instead, we assume the existence of an oracle <span class="math">\\mathcal{O}_{\\mathrm{check}}</span> that implements a verification procedure on a data/tag pair, perhaps provided additional advice aux, i.e. on input <span class="math">(D,\\tau_{D},\\mathrm{aux})</span> it returns <span class="math">\\mathcal{O}_{\\mathrm{check}}(D,\\tau_{D},\\mathrm{aux})\\to b\\in \\{0,1\\}</span>. A special case is where <span class="math">\\tau_{D}</span> is a commitment to <span class="math">D</span>, aux is the opening hint, and <span class="math">\\mathcal{O}_{\\mathrm{check}}</span> runs the commitment verification. In other scenarios <span class="math">\\mathcal{O}_{\\mathrm{check}}</span> might verify signatures. As discussed previously, we allow for constructions that run in a private-key preprocessor mode and the data inputs/tags are provided by the preprocessor. For instance, they may be data authentication tags like in a more standard PoR scheme.</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> <span class="math">\\text{PoRep-Exp}^{(\\mathcal{A})}(z, pp) = (\\hat{z}, \\hat{b})</span> is the PoRep game experiment (defined in Figure 2.3) with adversary <span class="math">\\mathcal{A} = (\\mathcal{A}_{pre}, \\mathcal{A}_{onl})</span> on inputs <span class="math">z, pp</span> from the environment, represented as a random variable where <span class="math">\\hat{z}</span> is the output of <span class="math">\\mathcal{A}</span> and <span class="math">\\hat{b}</span> is the challenger's output. <span class="math">\\text{Out}_{\\mathcal{A}}(pp, z) = \\hat{z}</span> is</p>

    <p class="text-gray-300"><span class="math">^8</span>The provers may be storing all the replicas on the same hard-drive, hence PoReps alone do not give a meaningful guarantee of fault-tolerant data storage.</p>

    <p class="text-gray-300"><span class="math">^9</span>Consider a model with network communication round trip bounds and distance between parties. Two servers claim to be in two different locations and are each storing a replica of the same file. We could use distance bounding protocols combined with proofs of retrievability to verify the claim [52]</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">the random variable representing the first component of <span class="math">\\mathsf{PoRep-Exp}^{(\\mathcal{A})}(z,pp)</span>, and <span class="math">\\mathsf{Succ}_{\\mathcal{A}}</span> is the probability that <span class="math">\\hat{b}=1</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 4 (Admissible PoRep adversary).</h6>

    <p class="text-gray-300">For any <span class="math">pp\\leftarrow\\mathsf{PoRep}.Setup(\\lambda,T)</span> a PoRep game adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{pre},\\mathcal{A}_{onl})</span> is admissible for the experiment <span class="math">\\mathsf{PoRep-Exp}^{(\\mathcal{A})}(z,pp)</span> if <span class="math">\\mathcal{A}_{pre}</span> runs in <span class="math">O(poly(\\lambda))</span> and <span class="math">\\mathcal{A}_{onl}</span> runs in parallel time at most <span class="math">T</span>. The adversary <span class="math">\\mathcal{A}</span> is <span class="math">\\mu</span>-admissible if additionally <span class="math">\\mathcal{A}_{pre}</span> chooses data inputs <span class="math">\\vec{D}</span> and tags <span class="math">\\vec{\\tau}</span> where for each <span class="math">i</span> there exists <span class="math">\\mathsf{aux}_{i}</span> such that <span class="math">\\mathcal{O}_{check}(D_{i},\\tau_{D_{i}},\\mathsf{aux}_{i})=1</span> and <span class="math">\\mathsf{Succ}_{\\mathcal{A}}\\geq\\mu</span>.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">2.1.1 Impossibility of ideal replication security</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that the PoRep adversary stores the replicas in a string <span class="math">\\sigma</span>. The adversary can then “sabotage” the replication by using say the first <span class="math">\\lambda</span> bits of <span class="math">\\sigma</span> as a key to encrypt the rest, and store the transformed string <span class="math">\\sigma^{\\prime}</span> that includes the <span class="math">\\lambda</span> bit key and ciphertext. Since the adversary can efficiently decode <span class="math">\\sigma</span> from <span class="math">\\sigma^{\\prime}</span> it will still pass the protocol with the same success probability (i.e. it <em>efficiently</em> decodes <span class="math">\\sigma^{\\prime}</span> and retrieves <span class="math">\\sigma</span>, and then follows whatever protocol behavior it would have initially on <span class="math">\\sigma</span>). Indeed, such “scrambling” attacks are impossible to prevent as there is always a trivially fast way to encode/decode one’s state in a way that destroys the <span class="math">k</span>-replication format. We state this formally in the following proposition. Our proof is in the random oracle model for simplicity, although an analogous statement can be proven in the plain model from symmetric key encryption (i.e. PRPs) as long as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\lambda<span class="math"> (this will always be true for </span>\\mathcal{A}<span class="math"> that succeeds on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\lambda$, i.e. causes the challenger to output 1 with non-negligible probability).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proposition 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any admissible adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{pre},\\mathcal{A}_{onl})</span> there exists an admissible adversary <span class="math">\\mathcal{A}^{\\prime}=(\\mathcal{A}^{\\prime}_{pre},\\mathcal{A}^{\\prime}_{onl})</span> (with access to a random oracle <span class="math">H</span>) such that for all <span class="math">pp,z</span> and <span class="math">\\vec{D}=(D_{1},...,D_{k})</span> chosen by <span class="math">\\mathcal{A}_{pre}</span> for any <span class="math">k&gt;1</span> the distributions <span class="math">\\mathsf{PoRep-Exp}^{(\\mathcal{A})}(z,pp)</span> and <span class="math">\\mathsf{PoRep-Exp}^{(\\mathcal{A}^{\\prime})}(z,pp)</span> are identical and for <span class="math">\\sigma,\\sigma^{\\prime}</span> output by <span class="math">\\mathcal{A}_{onl}/\\mathcal{A}^{\\prime}_{onl}</span> respectively (in Figure 2.3, line 3), at most one of <span class="math">\\sigma,\\sigma^{\\prime}</span> is a <span class="math">k</span>-replication of <span class="math">\\vec{D}</span> and yet $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{A}^{\\prime}</span> runs exactly as <span class="math">\\mathcal{A}</span> with the following modifications. <span class="math">\\mathcal{A}^{\\prime}_{\\mathrm{pre}}</span> runs <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span> until Line 2 of the game, obtaining <span class="math">\\sigma,a\\vec{u}x</span>. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> then </span>\\mathcal{A}^{\\prime}_{\\mathrm{pre}}<span class="math"> outputs </span>\\sigma,a\\vec{u}x<span class="math"> and </span>\\mathcal{A}^{\\prime}_{\\mathrm{onl}}<span class="math"> on a 1-bit </span>\\sigma<span class="math"> runs exactly like </span>\\mathcal{A}_{\\mathrm{onl}}<span class="math">. By hypothesis </span>k>1<span class="math">, hence a 1-bit </span>\\sigma<span class="math"> is not a </span>k<span class="math">-replication by definition. In case </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>1<span class="math">, then let </span>\\sigma_{0}<span class="math"> denote the first bit of </span>\\sigma<span class="math">. </span>\\mathcal{A}^{\\prime}_{\\mathrm{pre}}<span class="math"> computes </span>H(\\sigma_{0})=r<span class="math">, truncating the output of </span>H<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> (as </span>\\mathcal{A}_{\\mathrm{pre}}<span class="math"> runs in time </span>O(poly(\\lambda))<span class="math"> we may assume w.l.o.g. that the output of </span>H<span class="math"> is longer than </span>\\sigma<span class="math">) and sets </span>\\sigma^{\\prime}=\\sigma\\oplus 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r<span class="math">. Note that only the first bit of </span>\\sigma^{\\prime}<span class="math"> (i.e. </span>\\sigma_{0}<span class="math">) contains information about </span>\\sigma<span class="math">. All substrings of the remaining </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> bits are uniformly distributed (they have zero mutual information with the remainder of </span>\\sigma<span class="math">). Therefore, assuming that </span>\\sigma<span class="math"> is a k-replication of </span>\\vec{D}<span class="math">, then </span>\\sigma^{\\prime}<span class="math"> is not a </span>k<span class="math">-replication for </span>k>1<span class="math">. Finally, </span>\\mathcal{A}^{\\prime}_{\\mathrm{onl}}<span class="math"> receives </span>\\sigma^{\\prime}<span class="math">, computes </span>r=H(\\sigma_{0})<span class="math"> by reading the first bit of </span>\\sigma^{\\prime}<span class="math">, and then recovers </span>\\sigma=\\sigma^{\\prime}\\oplus 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r<span class="math">. Then </span>\\mathcal{A}^{\\prime}_{\\mathrm{onl}}<span class="math"> uses </span>\\sigma<span class="math"> to run </span>\\mathcal{A}_{\\mathrm{onl}}<span class="math">. The output is identical to </span>\\mathsf{PoRep-Exp}^{(\\mathcal{A})}(z,pp)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">2.1.2 Rational adversary model</h4>

    <p class="text-gray-300">Given the impossibility of achieving PoRep security entirely based on cryptographic guarantees, we turn instead to a framework of modeling attacks based on incentives. A rational adversary model has been used many times before in related works. In fact, it is implicit in proofs of space where security is reasoned via time/space tradeoffs <em>[40]</em> rather than challenge-response timing,</p>

    <p class="text-gray-300">which is necessary in proofs of space that are not parallel sound <em>[3, 46]</em>. It was also invoked to model security in storage enforcing commitments, hourglass schemes, and private-client proof of data replication <em>[7, 28, 51]</em>. The threat model considered in all of these works is an adversary that acts to minimize its costs, measured in storage or work (and combinations of the two).</p>

    <p class="text-gray-300">In our setting, independent from any client setup/preprocessing, any prover that passes <span class="math">k</span> independent PoRep interactive protocols on <span class="math">k</span> data file commitments should not save any costs by running a strategy that does not store a recoverable copy of the file in each protocol, even if this involves storing duplicate copies of the same file. The same holds if the prover passes a single PoRep interactive protocol on a single committed data file that contains redundant data. More precisely, for any successful strategy there is another “well-behaved” and efficiently computable strategy satisfying <span class="math">k</span>-replication that uses no more than a factor <span class="math">1/(1-\\epsilon)</span> more storage, i.e the adversarial strategy saves at most an <span class="math">\\epsilon</span> fraction of the storage by deviating from honest <span class="math">k</span>-replication. Importantly, this “well-behaved” strategy should still retain all the information that the original adversary was storing, which we capture by saying that the new strategy simulates the output distribution of the original adversary in the security game. We call this security notion <span class="math">\\epsilon</span>-rational replication.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Security under composition</h5>

    <p class="text-gray-300">A challenge that arises in both defining and proving <span class="math">\\epsilon</span>-rational replication for PoReps is showing that adversarial strategies do not save costs even in composition with other protocols, in particular in the presence of auxiliary data on the server. While composition is always a security challenge often overlooked, it is especially salient here. One might think it would be sufficient to show that the adversary cannot compress its replicas by encoding them in a different (malicious) format that no longer preserves replication. However, we must also consider that the adversary may be able to use the replica storage to help store other useful information on its hard drive. Suppose, for instance, that the (incompressible) replicas could be used as a seed to compress this auxiliary data, yet in a way that also entangles the seed together with the auxiliary data, destroying the replication format (i.e. a weak compression Definition 11). In this case, the adversary may actually save costs by deviating.</p>

    <p class="text-gray-300">Fisch and Silas <em>[27]</em> showed that proving this is likely impossible without strong knowledge assumptions. Their analysis focussed on the “weak compression attack” described above, where the PoRep storage could be used as a seed to compress auxiliary data in a way that also destroys the replication format. One might hope to prove rational security by showing that any adversary who weakly compresses auxiliary data in this way can be converted to a <em>better</em> adversary that compresses its auxiliary storage just as well without destroying its replicas, i.e. coverts the weak compression to a strong compression (Definition 12) that would save the seed independently in its original format. However, they prove that any black-box reduction of strong compression to weak compression for a given class of sources would yield a universal compression scheme for that class in the random oracle model. In other words, proving this is as hard as constructing a universal compression scheme that works on any source in the class.</p>

    <h5 id="sec-18" class="text-base font-semibold mt-4">“Knowledge-of-compression” assumptions</h5>

    <p class="text-gray-300">In light of their result, Fisch and Silas propose using a “knowledge of compression” assumption. Intuitively, any adversary who knows a way to compress auxiliary data <span class="math">z</span> using an incompressible string <span class="math">s</span> must only be taking advantage of the compressibility of <span class="math">z</span>, hence entangling <span class="math">z</span> together with <span class="math">s</span> should not help. Specifically, the minimal assumption proposed in their paper is that any adversary who can compute a weak compression of <span class="math">z</span> with an independent uniformly sampled seed <span class="math">s</span> can also extract a strong compression of <span class="math">z</span>.</p>

    <p class="text-gray-300">They also remark that some PoS constructions are proven secure by showing that the advice output <span class="math">s</span> directly encodes part of a random oracle's function table, and in this case the minimal assumption suffices to show that any weak compression involving the PoS advice <span class="math">s</span> as a seed can be converted to a strong compression. Unfortunately, this property is not true of PoReps because the underlying PoS advice actually encodes the committed data file <span class="math">D</span>. Therefore, we require a stronger knowledge of compression assumption that applies to any incompressible seed <span class="math">s</span>, even where the incompressibility applies only to strictly time bounded compression schemes.</p>

    <p class="text-gray-300"><strong>Definition 5 (Time bounded incompressibility).</strong> A source <span class="math">\\mathcal{S}</span> is <span class="math">(T_1, T_2)</span>-incompressible to <span class="math">k</span> bits if there does not exist (for any constant <span class="math">\\delta</span>) a <span class="math">\\delta</span>-lossy strong compression scheme <span class="math">(\\text{enc}, \\text{dec})</span> where <span class="math">\\text{enc}</span> runs in parallel time <span class="math">T_1</span> and <span class="math">\\text{dec}</span> runs in parallel time <span class="math">T_2</span> that compresses <span class="math">\\mathcal{S}</span> to <span class="math">k - \\log(1/\\delta)</span> bits.</p>

    <p class="text-gray-300"><strong>Assumption 1 (Knowledge of strong compression).</strong> Let <span class="math">\\mathcal{S}</span> and <span class="math">\\mathcal{X}</span> be any two samplable sources over <span class="math">\\{0,1\\}^n</span> such that <span class="math">\\mathcal{S}</span> is <span class="math">(T_1,T_2)</span>-incompressible to <span class="math">(1 - \\epsilon)n</span> bits for some <span class="math">\\epsilon &amp;lt; 1</span>. For any compression scheme <span class="math">(\\text{enc},\\text{dec})</span> that compresses <span class="math">\\mathcal{S} \\times \\mathcal{X}</span> to <span class="math">m</span> bits where <span class="math">\\text{enc}</span> runs in parallel time <span class="math">T_1</span> or <span class="math">\\text{dec}</span> runs in parallel time <span class="math">T_2</span>, there exists a strong compression scheme <span class="math">(\\text{enc}^<em>, \\text{dec}^</em>)</span> running in parallel time <span class="math">T_1</span> and <span class="math">T_2</span> respectively that compresses <span class="math">\\mathcal{X}</span> to length <span class="math">m - (1 - \\epsilon)n</span> bits sampling seeds from <span class="math">\\mathcal{S}</span>. Moreover, for any algorithm <span class="math">\\mathcal{A}</span> that on inputs <span class="math">\\mathcal{S}</span> and <span class="math">n</span> outputs <span class="math">(\\text{enc},\\text{dec})</span>, there exists an efficient "extractor" which observes <span class="math">\\mathcal{A}</span>'s internal state and outputs <span class="math">(\\text{enc}^<em>, \\text{dec}^</em>)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition of rational replication</strong> We will fix several notations regarding discrete probability distributions before presenting our formal definition of <span class="math">\\epsilon</span>-rational replication. If <span class="math">X</span> is a <span class="math">0/1</span> random variable with probability mass function <span class="math">p_X</span> and <span class="math">Y</span> is a discrete random variable on the same probability space then $p_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y: \\operatorname{Sup}(Y) \\to \\mathbb{R}<span class="math"> is the function </span>p_X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y(w) = Pr[X = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y = w]<span class="math">. If </span>f, g<span class="math"> are two real valued functions on a set </span>\\Omega<span class="math"> then </span>f \\succeq g<span class="math"> if and only if </span>f(w) \\geq g(w)<span class="math"> for all </span>w \\in \\Omega<span class="math">, i.e. </span>f<span class="math"> is an upper bound on </span>g$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, for any two random variables <span class="math">X,Y</span> let <span class="math">X(\\lambda) \\stackrel{\\lambda}{\\approx} Y(\\lambda)</span> denote that the distributions of <span class="math">X</span> and <span class="math">Y</span> are computationally indistinguishable.[11]</p>

    <p class="text-gray-300"><strong>Definition 6 (Rational replication).</strong> A PoRep construction is a <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational replication if for any <span class="math">\\mu</span>-admissible adversary <span class="math">\\mathcal{A} = (\\mathcal{A}_{pre}, \\mathcal{A}_{onl})</span> there exists an admissible adversary <span class="math">\\mathcal{A}&#x27; = (\\mathcal{A}_{pre}&#x27;, \\mathcal{A}_{onl}&#x27;)</span> such that for all <span class="math">pp, z</span> sampled by the environment and <span class="math">\\vec{D} = (D_1, \\dots, D_k)</span> chosen by <span class="math">\\mathcal{A}_{pre}</span>, and for <span class="math">\\sigma, \\sigma&#x27;</span> output by <span class="math">\\mathcal{A}_{onl} / \\mathcal{A}_{onl}&#x27;</span> respectively (in Figure 2.3, line 2) then for all <span class="math">z</span> from the environment and <span class="math">pp \\gets \\text{PoRep.Setup}(\\lambda, T)</span> it holds that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq (1 - \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sigma&#x27;</span> is a <span class="math">k</span>-replication of <span class="math">\\vec{D}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">\\text{Out}_{\\mathcal{A}&#x27;}(pp, z) \\stackrel{\\lambda}{\\approx} \\text{Out}_{\\mathcal{A}}(pp, z)</span> and $\\text{Succ}_{\\mathcal{A}'}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Out}_{\\mathcal{A}'}(pp, z) \\succeq \\text{Succ}_{\\mathcal{A}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Out}_{\\mathcal{A}}(pp, z)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Necessary and sufficient conditions for <span class="math">\\epsilon</span>-rational replication</p>

    <p class="text-gray-300">PoReps satisfying <span class="math">\\epsilon</span>-rational replication are implicitly proofs of space with an <span class="math">\\epsilon</span> space gap. The converse is not necessarily true, i.e. <span class="math">\\epsilon</span>-tight proofs of space are not immediately PoReps satisfying <span class="math">\\epsilon</span>-rational replication. Furthermore, unless <span class="math">\\tau_{D}</span> is binding to <span class="math">D</span> relative to <span class="math">\\mathcal{O}_{\\mathsf{check}}</span>, meaning that for any <span class="math">\\tau_{D}</span> there does not exist (or it is computationally difficult to produce) <span class="math">D^{\\prime}\\neq D</span> and <span class="math">\\mathsf{aux}^{\\prime},\\mathsf{aux}</span> such that <span class="math">\\mathcal{O}_{\\mathsf{check}}(D,\\tau_{D},\\mathsf{aux})=\\mathcal{O}_{\\mathsf{check}}(D^{\\prime},\\tau_{D},\\mathsf{aux}^{\\prime})=1</span>, then it is unclear how a scheme could satisfy our definition (or any meaningful definition of replication security for that matter where the adversary is allowed to choose the data). If <span class="math">\\mathcal{O}_{\\mathsf{check}}</span> is not binding then even rational replication security would likely fail because the adversary could find an alternative data input <span class="math">D^{\\prime}\\neq D</span> consistent with the same tag and run the rest of the protocol successfully on <span class="math">D^{\\prime}</span> as if it were the input. Formally, this would fail our security definition if any adversary that stores a <span class="math">k</span>-replication of the original data input <span class="math">D</span> could not output the same distribution (e.g. the adversary’s output <span class="math">\\hat{z}</span> is some function of <span class="math">z</span> and <span class="math">D^{\\prime}</span>).</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Implicit PoS protocol</h4>

    <p class="text-gray-300">If a PoRep construction satisfies Definition 6 then PoRep.Setup, PoRep.Replicate, PoRep.Prove, and PoRep.Verify implicitly define a secure PoS as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup runs PoRep.Setup(<span class="math">\\lambda,T</span>)</li>

      <li>Initialization The prover runs <span class="math">R,\\mathsf{aux}\\xleftarrow{\\text{\\tiny B}}\\mathsf{PoRep.Replicate}(id,\\tau_{D},\\tilde{D})</span> and outputs <span class="math">\\tau_{D}=\\mathsf{aux}</span> and <span class="math">S=R</span>.</li>

      <li>Execution The verifier’s challenge is <span class="math">r\\leftarrow\\mathsf{PoRep.Poll}(\\mathsf{aux})</span> and the prover responds with the proof <span class="math">\\pi\\leftarrow\\mathsf{PoRep.Prove}(R,\\mathsf{aux},id,r)</span>. The verifier runs <span class="math">\\mathsf{PoRep.Verify}(id,\\tau_{D},r,\\mathsf{aux},\\pi)</span>.</li>

    </ul>

    <p class="text-gray-300">We say that a PoRep scheme is an <span class="math">(s,t,\\mu)</span>-sound PoS if its implicit PoS protocol is an <span class="math">(s,t,\\mu)</span>-sound PoS (see Section A.7, or Definition 23).</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 1 (PoS is necessary).</h6>

    <p class="text-gray-300">If a PoRep is a <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational replication then it is an <span class="math">((1-\\epsilon)kN,T,\\mu)</span>-sound PoS.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose not, i.e. there is some PoS adversary that succeeds in passing verification with probability greater than <span class="math">\\mu</span> using only <span class="math">(1-\\epsilon)kN</span> storage.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\vec{D}</span> be a vector of <span class="math">k</span> identical copies of an incompressible data input <span class="math">D</span>. By incompressible, we mean that for any randomized <span class="math">\\mathsf{enc}/\\mathsf{dec}</span> scheme such that <span class="math">Pr[\\mathsf{enc}(\\mathsf{dec}(D))=D]=\\xi</span> then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{enc}(D)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq N-\\log(1/\\xi)<span class="math"> where </span>N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. It follows that any </span>k<span class="math">-replication of </span>D<span class="math"> must be at least </span>kN<span class="math"> bits long because by definition it can be partitioned into </span>k<span class="math"> substrings each of which are a deterministic encoding of </span>D<span class="math">. Now take the PoS adversary </span>\\mathcal{A}_{PoS}<span class="math"> who is able to pass Execution within time </span>T<span class="math"> with </span>(1-\\epsilon)kN<span class="math"> storage and construct </span>\\mathcal{A}_{PoRep}=(\\mathcal{A}_{\\mathrm{pre}},\\mathcal{A}_{\\mathrm{onl}})<span class="math">. </span>\\mathcal{A}_{\\mathrm{pre}}<span class="math"> simulates the Initialization phase for </span>\\mathcal{A}_{PoS}<span class="math"> to obtain the outputs </span>(\\Phi,S)<span class="math">. It then sets </span>\\mathsf{aux}=\\Phi<span class="math"> and </span>\\sigma=S<span class="math">. Then for each challenge query, </span>\\mathcal{A}_{\\mathrm{onl}}<span class="math"> simulates the Execution phase for </span>\\mathcal{A}_{PoS}<span class="math">, passing it </span>\\Phi<span class="math"> and </span>S<span class="math">. Thus, by assumption </span>\\mathcal{A}_{\\mathrm{onl}}<span class="math"> succeeds (i.e. the challenger outputs </span>\\hat{b}=1<span class="math">) with probability greater than </span>\\mu<span class="math">. In other words, </span>\\mathcal{A}_{PoRep}<span class="math"> is </span>\\mu<span class="math">-admissible. Now, since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(1-\\epsilon)kN<span class="math"> it cannot be a </span>k<span class="math">-replication of </span>D<span class="math"> due to the fact that </span>D<span class="math"> is incompressible and any </span>k<span class="math">-replication of </span>D<span class="math"> must be at least </span>kN<span class="math"> bits long. In fact, if any </span>(\\mathcal{A}_{\\mathrm{pre}}^{\\prime},\\mathcal{A}_{\\mathrm{onl}}^{\\prime})<span class="math"> outputs </span>\\sigma^{\\prime}<span class="math"> where </span>\\sigma^{\\prime}<span class="math"> is a </span>k<span class="math">-replication of </span>D<span class="math"> then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq kN></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(1-\\epsilon)<span class="math">. On the other hand, by the hypothesis that the PoRep is a </span>\\mu<span class="math">-sound </span>\\epsilon<span class="math">-rational replication, there exists some </span>(\\mu-\\mathsf{negl}(\\lambda))<span class="math">-admissible </span>\\mathcal{A}^{\\prime}<span class="math"> that outputs a </span>k<span class="math">-replication </span>\\sigma^{\\prime}<span class="math"> (Condition 3 + Condition 2) such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/(1-\\epsilon)$ (Condition 1). This is a contradiction. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Implicit PoRC protocol</h5>

    <p class="text-gray-300">If the data tag <span class="math">\\tau_{D}</span> is binding to the data input <span class="math">D</span> and <span class="math">\\mathsf{a}\\overline{\\mathsf{u}}\\mathsf{x}</span> is a binding commitment to the replica <span class="math">R</span> then a PoRep may implicitly define a <span class="math">(\\delta,\\mathcal{C})</span>-PoRC protocol of <span class="math">(D,R)</span> with respect to <span class="math">(\\tau_{D},\\mathsf{a}\\mathsf{u}\\mathsf{x})</span> (Section A.4). The cover <span class="math">\\mathcal{C}</span> in this case is the set of pairs of blocks <span class="math">(R_{i},D_{i})</span> such that <span class="math">R</span> is defined to be the correct output of <span class="math">\\mathsf{PoRep.Replicate}(id_{i},\\tau_{D},D)</span>, <span class="math">D_{i}</span> is the <span class="math">i</span>th block of <span class="math">D</span>, and <span class="math">R_{i}</span> is the <span class="math">i</span>th block of <span class="math">R</span>. The setup just runs the PoRep setup and outputs parameters <span class="math">pp</span>. The <span class="math">\\mathsf{PoRC.Prove}</span> and <span class="math">\\mathsf{PoRC.Verify}</span> procedures simply run the PoRep prover and verify procedures.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PoRC.Commit}(pp,D)</span>: Run <span class="math">\\mathsf{PoRep.Preproc}(sk,D)</span> to obtain the data tag <span class="math">\\tau_{D}</span> along with <span class="math">\\tilde{D}</span>. Then run <span class="math">\\mathsf{PoRep.Replicate}(id,\\tau_{D},\\tilde{D})</span> to get <span class="math">(R,\\mathsf{a}\\mathsf{u}\\mathsf{x})</span>. Save the hint <span class="math">\\Lambda=(R,id)</span>. Output the commitment <span class="math">com=(\\tau_{D},\\mathsf{a}\\mathsf{u}\\mathsf{x})</span>.</li>

      <li><span class="math">\\mathsf{PoRC.Open}(pp,com,\\Lambda)</span>: Parse <span class="math">\\Lambda=(R,id)</span> and <span class="math">com=(\\tau_{D},\\mathsf{a}\\mathsf{u}\\mathsf{x})</span>. Next run the extraction procedure <span class="math">\\mathsf{PoRep.Extract}(pp,id,\\tau_{D},R)</span> to obtain <span class="math">D</span>. Query <span class="math">b\\leftarrow\\mathcal{O}_{\\mathsf{check}}(D,\\tau_{D},\\mathsf{a}\\mathsf{u}\\mathsf{x})</span>. If <span class="math">b=0</span> output <span class="math">\\bot</span> otherwise output <span class="math">(D,R)</span>.</li>

      <li><span class="math">\\mathsf{PoRC.Prove}(pp,com,\\Lambda,c)</span>: Parse <span class="math">\\Lambda=(R,id)</span> and <span class="math">com=(\\tau_{D},\\mathsf{a}\\mathsf{u}\\mathsf{x})</span>. Generate the PoRep proof <span class="math">\\pi^{\\prime}</span> as <span class="math">\\mathsf{PoRep.Prove}(R,\\mathsf{a}\\mathsf{u}\\mathsf{x},id,r)</span> output the PoRC proof <span class="math">\\pi=(\\pi^{\\prime},id)</span>.</li>

      <li><span class="math">\\mathsf{PoRC.Verify}(pp,com,c,\\pi)</span>: Parse <span class="math">com=(\\tau_{D},\\mathsf{a}\\mathsf{u}\\mathsf{x})</span> and <span class="math">\\pi=(\\pi^{\\prime},id)</span>. Output the result <span class="math">b</span> of <span class="math">\\mathsf{PoRep.Verify}(id,\\tau_{D},c,\\mathsf{a}\\mathsf{u}\\mathsf{x},\\pi^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">We say that a PoRep scheme is a <span class="math">\\mu</span>-sound <span class="math">\\delta</span>-PoRC if its implicit <span class="math">(\\delta,\\mathcal{C})</span>-PoRC protocol as just described is <span class="math">\\mu</span>-sound (see Definition 18).</p>

    <p class="text-gray-300">The following powerful lemma establishes criteria that along with Assumption 1 are sufficient for <span class="math">\\epsilon</span>-rational replication. This greatly simplifies the analysis for any PoRep construction that is also implicitly a secure public-coin PoRC protocol.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 2 (Sufficient conditions for rational replication).</h6>

    <p class="text-gray-300">Given Assumption 1, if a PoRep construction with setup parameters <span class="math">T,\\lambda</span> satisfies the following conditions for some integer <span class="math">c</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is correct (see Definition 1)</li>

      <li>It is a <span class="math">\\mu</span>-sound <span class="math">(1-\\delta)</span>-PoRC, and the parallel runtime blowup of the extractor is less than a factor <span class="math">c</span>, i.e. it is PRAM strongly <span class="math">\\mu</span>-sound (see Definition 18).</li>

      <li><span class="math">k</span> independent PoReps are a parallel <span class="math">((1-\\epsilon+\\delta)kN,(c+1)T,\\mu)</span>-sound PoS (see Section A.7, or Definition 23).</li>

    </ol>

    <p class="text-gray-300">then the PoRep construction is a <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational-replication.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The outline for the proof is as follows. We consider any <span class="math">\\mu</span>-admissible PoRep adversary <span class="math">\\mathcal{A}=\\mathcal{A}=(\\mathcal{A}_{\\mathrm{pre}},\\mathcal{A}_{\\mathrm{onl}})</span> and construct the “well-behaved” adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{\\mathrm{pre}}^{\\prime},\\mathcal{A}_{\\mathrm{onl}}^{\\prime})</span> that satisfies the three conditions of Definition 6. Since <span class="math">\\mathcal{A}</span> is <span class="math">\\mu</span>-admissible for each <span class="math">i</span> it chooses each <span class="math">D_{i},\\tau_{D_{i}}</span> and outputs <span class="math">\\mathsf{a}\\mathsf{u}\\mathsf{x}_{i}</span> such that <span class="math">\\mathcal{O}_{\\mathrm{check}}(D_{i},\\tau_{D_{i}},\\mathsf{a}\\mathsf{u}\\mathsf{x}_{i})=1</span>. A <span class="math">\\mu</span>-admissible PoRep adversary is also a <span class="math">\\mu</span>-admissible PoRC adversary in the implicit <span class="math">(1-\\delta,\\mathcal{C})</span>-PoRC protocol. Hypothesis (b), that the implicit <span class="math">(1-\\delta,\\mathcal{C})</span>-PoRC protocol is <span class="math">\\mu</span>-sound, by definition means there exists a public extraction algorithm <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> that <span class="math">\\mathcal{A}_{\\mathrm{onl}}^{\\prime}</span> could run with <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span> to extract at least a <span class="math">(1-\\delta)</span> fraction of the correct blocks in each <span class="math">(R_{i},D_{i})</span>, denoted by <span class="math">(R_{i}^{<em>},D_{i}^{</em>})</span>. Let <span class="math">R^{<em>}=(R_{1}^{</em>},...,R_{k}^{<em>})</span> and <span class="math">D^{</em>}=(D_{1}^{<em>},...,D_{k}^{</em>})</span>. <span class="math">\\mathcal{E}_{\\mathcal{A}}</span></p>

    <p class="text-gray-300">runs in time at most <span class="math">c \\cdot t_{\\mathrm{onl}}</span> where <span class="math">t_{\\mathrm{onl}} &amp;lt; T</span> is the runtime of <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span> (by the assumption that <span class="math">\\mathcal{A}</span> is admissible).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show (in Subclaim 1) that <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span>, <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span>, and <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> can be used to construct a lossless compression scheme <span class="math">(\\mathsf{enc},\\mathsf{dec})</span> that encodes <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>'s output <span class="math">R^{<em>}</span> and <span class="math">\\mathcal{A}</span>'s output <span class="math">\\hat{z} = \\mathsf{Out}^{\\mathcal{A}}(pp,z)</span> in <span class="math">\\mathsf{PoRep-Exp}^{(\\mathcal{A}}(pp,z)</span>, where <span class="math">\\mathsf{enc}(R^{</em>},\\hat{z}) = (\\sigma^{*},\\mathsf{aux})</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{negl}(\\lambda)<span class="math"> and </span>\\mathsf{dec}<span class="math"> runs in total time </span>cT<span class="math">. On the other hand, we show (in Subclaim 2) that Hypothesis (c) implies that </span>R^{<em>}<span class="math"> is </span>(\\mathrm{poly}(N),(c + 1)T,\\mu)<span class="math">-incompressible to </span>(1 - \\epsilon)kN<span class="math"> bits. Together with Assumption 1, Subclaim 1 and Subclaim 2 imply that </span>\\mathcal{A}_{\\mathrm{onl}}'<span class="math"> can compute a new strong compression scheme </span>(\\mathsf{enc}^{</em>},\\mathsf{dec}^{<em>})<span class="math"> that uses </span>R^{</em>}<span class="math"> as a seed to encode compress </span>\\hat{z}<span class="math"> to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (1 - \\epsilon)kN \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (1 - \\epsilon)kN + \\mathsf{negl}(\\lambda)<span class="math"> bits. Finally, </span>\\mathcal{A}_{\\mathrm{pre}}'<span class="math"> outputs </span>\\sigma' = R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{enc}^{<em>}(R^{</em>},\\hat{z})<span class="math"> and the same </span>\\mathsf{aux}<span class="math">, and </span>\\mathcal{A}_{\\mathrm{onl}}'<span class="math"> uses </span>\\mathsf{dec}^{*}<span class="math"> to recover </span>\\hat{z}<span class="math">. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (1 - \\epsilon)kN + \\mathsf{negl}(\\lambda) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon kN + \\mathsf{negl}(\\lambda)<span class="math">. </span>\\mathcal{A}_{\\mathrm{onl}}'<span class="math"> finally runs the honest </span>\\mathsf{PoRep.Prove}<span class="math"> so </span>\\mathsf{Succ}_{\\mathcal{A}'} = 1<span class="math"> and </span>\\mathsf{Out}_{\\mathcal{A}'} \\approx \\mathsf{Out}_{\\mathcal{A}}$ are identically distributed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The existence of this <span class="math">\\mathcal{A}&#x27;</span> for any <span class="math">\\mu</span>-admissible adversary <span class="math">\\mathcal{A}</span> shows that the PoRep satisfies <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational replication. It satisfies <span class="math">\\mathsf{Out}^{\\mathcal{A}&#x27;} \\approx \\mathsf{Out}_{\\mathcal{A}}</span> and $\\mathsf{Succ}_{\\mathcal{A}'}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Out}_{\\mathcal{A}'} \\succeq \\mathsf{Succ}_{\\mathcal{A}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Out}_{\\mathcal{A}}<span class="math">. The advice </span>\\sigma'<span class="math"> includes </span>R<span class="math"> and is thus a </span>k<span class="math">-replication of </span>D<span class="math"> (Condition 2) with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon kN +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{negl}(\\lambda) \\leq \\frac{\\epsilon}{1 - \\epsilon}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{negl}(\\lambda) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ (1 - \\epsilon) + \\mathsf{negl}(\\lambda)$ (Condition 1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of Subclaim 1: Let <span class="math">\\mathcal{R}</span> denote the distribution of <span class="math">R^{<em>}</span> extracted by <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> over the randomness of <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>, <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span>, and <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span>. Note that because <span class="math">\\mathcal{A}</span> is <span class="math">\\mu</span>-sound <span class="math">R^{</em>}</span> always contains a <span class="math">1 - \\delta</span> fraction of the blocks of <span class="math">R</span>, where <span class="math">R</span> is the correct output on the input <span class="math">D</span> chosen by <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span> except with at most probability <span class="math">\\mathsf{negl}(\\lambda)</span> (that either the binding of <span class="math">\\mathcal{O}_{\\mathrm{check}}</span> is broken or the extraction fails). Let <span class="math">\\mathcal{Z}</span> denote the distribution of <span class="math">\\hat{z}</span> given the fixed environment inputs <span class="math">z, pp</span>. By simulating the game for <span class="math">\\mathcal{A}</span> and running the extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> we can perfectly sample both of these distributions. The sampled values <span class="math">R^{*}</span> and <span class="math">\\hat{z}</span> are given as input to <span class="math">\\mathsf{enc}</span> along with <span class="math">\\mathsf{aux}</span> and the randomness <span class="math">\\rho</span> used in the sampling. The randomness <span class="math">\\rho</span> and <span class="math">\\mathsf{aux}</span> will be shared by both <span class="math">\\mathsf{enc}</span> and <span class="math">\\mathsf{dec}</span> so we treat this as a seed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{enc}</span> uses <span class="math">\\rho</span> to deterministically rerun <span class="math">\\mathcal{A}_{\\mathrm{pre}}</span> to obtain <span class="math">\\sigma</span> and sets <span class="math">\\mathsf{enc}(\\rho, R^{*}, \\hat{z}) = \\sigma</span>.</li>

      <li><span class="math">\\mathsf{dec}</span> runs <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> with inputs <span class="math">\\sigma</span> and <span class="math">\\mathsf{aux}</span> to extract <span class="math">R^{<em>}</span> from <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span> (in parallel time at most <span class="math">c \\cdot t_{\\mathrm{onl}}</span>) and outputs <span class="math">R^{</em>}</span> while also using <span class="math">\\rho</span> to rerun <span class="math">\\mathcal{A}_{\\mathrm{onl}}</span> on a given challenge vector to obtain <span class="math">\\hat{z}</span>. <span class="math">\\mathsf{dec}</span> outputs <span class="math">R^{<em>}</span> and <span class="math">\\hat{z}</span>. Hence, <span class="math">(\\mathsf{enc}, \\mathsf{dec})</span> is a strong compression scheme on the source <span class="math">\\mathcal{R} \\times \\mathcal{Z}</span> with loss negligible in <span class="math">\\lambda</span>, i.e. <span class="math">Pr[\\mathsf{dec}(\\rho, \\mathsf{enc}(\\rho, R^{</em>}, \\hat{z}) = R^{*}, \\hat{z}] &amp;gt; 1 - \\mathsf{negl}(\\lambda)</span>. Finally, by Fact 1, it can be converted to a lossless compression with a <span class="math">\\mathsf{negl}(\\lambda)</span> increase in output length.</li>

    </ul>

    <p class="text-gray-300">Proof of Subclaim 2: As <span class="math">R</span> is the correct output of PoRep. Replicate and the PoRep construction is a <span class="math">((1 - \\epsilon + \\delta)kN, (c + 1)T, \\mu)</span>-sound PoS, <span class="math">R</span> is <span class="math">(\\mathrm{poly}(N), (c + 1)T, \\mu)</span>-incompressible to <span class="math">(1 - \\epsilon + \\delta)kN</span> bits. Otherwise, for some <span class="math">\\mu&#x27; &amp;gt; \\mu</span> an adversary could compress <span class="math">R</span> during the replication phase to <span class="math">(1 - \\epsilon + \\delta)kN</span> bits and store this <span class="math">\\mu&#x27;</span>-lossy compression as its advice. It could then recover <span class="math">R</span> in the challenge-response phase with probability <span class="math">\\mu&#x27;</span> and run the honest PoRep. Prove in total parallel time less than <span class="math">(c + 1)T</span>. This adversary would break the presumed PoS soundness. Likewise, as <span class="math">R^<em></span> consists of a <span class="math">1 - \\delta</span> fraction of blocks from <span class="math">R</span>, it is <span class="math">(\\mathrm{poly}(N), (c + 1)T, \\mu)</span>-incompressible to <span class="math">(1 - \\epsilon)kN</span> bits, because compressing <span class="math">R^</em></span> to <span class="math">(1 - \\epsilon)kN</span> bits is equivalent to compressing <span class="math">R</span> to <span class="math">(1 - \\epsilon + \\delta)kN</span> bits.</p>

    <p class="text-gray-300">Remark on <span class="math">\\delta</span> loss: Lemma 2 requires that the PoRep has only a <span class="math">\\epsilon - \\delta</span> space gap as PoS in order to prove it satisfies <span class="math">\\epsilon</span>-rational-replication, where <span class="math">\\delta</span> is the loss in the PoRC. The reason this affects</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the proof that the PoRep is <span class="math">\\epsilon</span>-rational-replication is entirely due to the environment auxiliary input <span class="math">z</span> and the need to show that the adversary <span class="math">\\mathcal{A}^{\\prime}</span> can still output the same distribution (including the function of <span class="math">z</span>) as the adversary <span class="math">\\mathcal{A}</span>. (This necessitated constructing <span class="math">\\mathcal{A}^{\\prime}</span> that extracts the replica <span class="math">R</span> from <span class="math">\\mathcal{A}</span>). If this requirement were dropped (or the auxiliary input <span class="math">z</span> is empty) then conditions (a) and (c) suffice without any <span class="math">\\delta</span> loss, i.e. if the PoRep is correct and a <span class="math">(1-\\epsilon)kN,T)</span>-sound PoS then it is <span class="math">\\epsilon</span>-rational secure. The reason is that <span class="math">\\mathcal{A}^{\\prime}</span> could just run the honest replication strategy, where <span class="math">\\sigma^{\\prime}=R</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=kN<span class="math">. Any adversary that causes the challenger to output </span>\\hat{b}=1<span class="math"> must use </span>\\sigma<span class="math"> of size at least </span>(1-\\epsilon)kN$ by the PoS soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">What is missed by simply composing PoR and PoS?</h4>

    <p class="text-gray-300">It is instructive to consider simply combining a proof of retrievability (PoR) with a proof of space (PoS) as a trivial candidate PoRep. For a file <span class="math">D</span> of size <span class="math">N</span>, the honest prover would use <span class="math">N</span> bits of storage to produce a PoS and separately store <span class="math">D</span>. First, this results in at least a factor two <em>space gap</em> (the gap between the honest prover’s total space usage and the lower bound on an adversary’s space). The more criticial issue is that the adversary is clearly incentivized to only use <span class="math">N</span> bits of storage for the PoS and drop the file entirely, provided that it can recover the file from another source. <em>There is explicitly a factor two added cost for storing the file in addition to producing a proof of space.</em> A prover is strongly incentivized to deduplicate its storage. In other words, this protocol fails <span class="math">\\epsilon</span>-rational replication for any <span class="math">\\epsilon&lt;1</span>, nor does it have data-independent costs. Thus we can see that at a minimum our definition requires that PoReps are simultaneously a PoS and PoR without costing the miner any extra space to store the entire file (or some encoding thereof that allows full recovery).</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Space utilization</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There is still a silly way to combine PoS and PoR to achieve <span class="math">\\epsilon</span>-rational replication without imposing another efficiency requirement on the construction that has to do with <em>space utilization</em>. Suppose a <span class="math">PoS</span> of <span class="math">N</span> bits guarantees that the adversary is using at least <span class="math">\\delta N</span> bits (while the honest prover uses <span class="math">N</span> bits). The trivial PoRep construction on a file <span class="math">D</span> of size <span class="math">N</span> would be a <span class="math">\\delta</span>-PoS on <span class="math">m&gt;&gt;N</span> bits (say <span class="math">m\\geq kN</span>) combined with a PoR of D. The naive prover following this protocol uses at least <span class="math">(k+1)N</span> bits, while an adversary must use at least <span class="math">\\delta kN</span> bits. The additional cost to this adversary of storing <span class="math">D</span> is at most <span class="math">N</span> bits, for a total storage of <span class="math">(\\delta k+1)N</span>, which is an <span class="math">\\epsilon=1/(\\delta k)</span> overhead. This can be made arbitrarily small by increasing <span class="math">k</span>. More generally, we can modify any PoRep scheme that is both a PoR and a <span class="math">\\delta</span>-PoS to operate on padded data $D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0^{m}<span class="math"> for </span>m=k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> so that there is only an </span>\\epsilon=1/(\\delta k)<span class="math"> cost to additionally storing the file. However, at the same time, this generic construction utilizes only an </span>\\epsilon<span class="math"> fraction of the prover’s total space for useful storage. Ideally, we would like a construction that utilizes most of the space, independent of </span>\\epsilon<span class="math">. Restricting to PoRep constructions that can be tuned to satisfy </span>\\epsilon<span class="math">-rational replication using </span>O(N)<span class="math"> space even as </span>\\epsilon\\to 0$ excludes these wasteful constructions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Private-verifier setting</h4>

    <p class="text-gray-300">We note that these subtleties in defining proofs of replication are also relevant in the private-verifier setting of proofs of data replication. They were missed in the security model proposed by Mirror <em>[7]</em>, whose definition is in fact satisfied by even the trivial combination of a PoS and PoR. Mirror’s security definition compares the adversary’s storage to the storage of a prover who stores both the original file <span class="math">D</span> and <span class="math">r</span> replicas specified by the protocol. Consider the trivial construction in which each “replica” is simply an independent</p>

    <p class="text-gray-300">proof of space initialization, and the verification procedure involves a PoR of <span class="math">D</span> along with <span class="math">r</span> PoS verifications. Since in this setting the data file is chosen by the verifier/challenger and is assumed to be incompressible, the adversary must use as much space as the honest prover in order to pass verification.¹³</p>

    <h2 id="sec-28" class="text-2xl font-bold">2.1.3 Security for decentralized storage networks</h2>

    <p class="text-gray-300">As we touched upon in the introduction, a primary intended use-case for PoReps is as a protocol that will help both incentivize and monitor file storage in a distributed network of nodes, which are compensated by the network in return for storing client data. Critically, these nodes are not directly compensated by the client. Rather, they are compensated for storing any data as long as the network verifiers (distinct from clients submitting data) can publicly verify they are storing the data. In fact, the network protocol may aggregate data pieces from several clients together and pass that to a storage node.</p>

    <p class="text-gray-300">If clients were to pay storage nodes directly, say by putting a lump sum of money in escrow that the storage node receives in installments for continuing to store the file, then PoReps aren't necessary. The role of network verifiers would be to verify that the storage node is still storing the client's file using a standard proof of retrievability with outsourced verification, and then approve transfer of installment funds from the escrow account to the storage node. The storage node has nothing to gain from colluding with the client. It is only when we want the network itself to incentive storage participation from a source external to the client/node that PoReps actually become relevant.</p>

    <p class="text-gray-300">The main thesis of the Filecoin [1] protocol is that by double using PoReps as a "proof-of-resource" (i.e. in place of proof-of-work) and proof-of-storage both the network and the client simultaneously benefit.¹⁴ The network rewards the storage miners by printing inflationary rewards (similar to mining rewards for Bitcoin proofs-of-work miners), thereby subsidizing the cost of file storage. Notice how this application of PoReps as a "useful" proof-of-storage to mine Filecoin and subsidize storage costs is extremely sensitive to the security property of PoReps. Consider a PoRep such as the naive combination of PoS and PoR, which does not satisfy <span class="math">\\epsilon</span>-replication (for <span class="math">\\epsilon &amp;lt; 1</span>). A miner would actually double its profits in Filecoin mining rewards by deduplicating storage because it could now use the extra storage space to generate twice as many proofs of storage. Moreover, miners could double their Filecoin rewards by producing PoReps for useless files that the prover generates from a small seed instead of storing real client data (called the "generation attack" in [2]. This means that Filecoin miners will charge even more to use their space to store user files, raising rather than subsidizing the cost of storage. More generally, if the PoReps do not have data-independent costs then the Filecoin mining rewards could have adverse effects on storage costs, driving miners to increase the cost of some files while lowering the cost of others.</p>

    <p class="text-gray-300">¹³It satisfies Mirror's definition of <span class="math">\\delta</span>-binding as long as the PoS has at most a <span class="math">1 - \\delta</span> space gap.</p>

    <p class="text-gray-300">¹⁴Decentralized transactional networks that follow the Nakamoto paradigm for consensus, i.e. proof-of-work blockchains, require consensus nodes to produce some form of "proof-of-resource" to ensure Sybil resistance. Depending on its instantiation, this proof-of-resource may also contribute global costs to transacting by adding an expense to transaction processing. Often these systems reduce the local impact of this cost on transaction fees by printing an inflationary reward that goes directly to the consensus node processing the transaction (although the inflation silently taxes the economy). This has the effect of subsidizing the cost of transacting, the same way that governments may use inflation to subsidize food or economic activity to stimulate an increase in GDP. It has been observed that the inflationary reward is more than just a subsidy mechanism, as it is actually critical to the</p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">3 Constructions</p>

    <p class="text-gray-300">In all of the constructions we describe in this report we will skip the description of PoRep.Preproc. The data is preprocessed in one of the modes described, and we start with the preprocessed data <span class="math">\\tilde{D}</span> and data tag <span class="math">\\tau_{D}</span>. We also assume there is an external verification procedure that the verifier may query on any block <span class="math">d_{i}</span> of the file <span class="math">\\tilde{D}</span>, its position <span class="math">i</span>, and <span class="math">\\tau_{D}</span>, which returns a result that we denote by <span class="math">\\mathcal{O}_{\\sf check}(d_{i},i,\\tau_{D})\\to b\\in\\{0,1\\}</span>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Building blocks</h4>

    <p class="text-gray-300">All constructions use a VDE scheme <span class="math">\\{\\sf VDE.Setup,\\sf VDE.Enc,\\sf VDE.Dec\\}</span> with identical input space and code space over <span class="math">\\{0,1\\}^{m}</span> for some <span class="math">m=O(\\lambda)</span> determined by the VDE setup, as well as a hash function <span class="math">H:\\{0,1\\}^{*}\\to\\{0,1\\}^{m}</span> modeled as a random oracle (i.e. mapping strings of arbitrary length to strings of length <span class="math">m</span>).</p>

    <p class="text-gray-300">The construction DRG-PoRep uses DRG.Sample(<span class="math">n,d</span>), which outputs an <span class="math">(\\alpha n,\\beta n,d)</span> depth robust graph with probability <span class="math">1-\\sf negl(n)</span> for <span class="math">d=O(\\log n)</span>. In the Section LABEL:sec:sec:dRog we discuss instantiations of DRG.Sample and how <span class="math">d</span> can be chosen to target different values of the constants <span class="math">0&lt;\\beta&lt;\\alpha&lt;1</span> (both analytically and empirically given our implementation of the best known attacks). In particular, in DRG-PoRep the value of <span class="math">\\alpha</span> must be very small, as this will determine the <span class="math">\\epsilon</span>-rational security of the scheme (in fact <span class="math">\\epsilon=\\alpha</span>).</p>

    <p class="text-gray-300">The latter two constructions also use a vector commitment scheme with algorithms VC.Setup, VC.Com, VC.Open, and VC.Verify.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Security parameters</h4>

    <p class="text-gray-300">Each PoRep scheme will take two security parameters <span class="math">\\lambda,\\kappa</span> as input. The parameter <span class="math">\\lambda</span> determines the overall security level of the construction (e.g. 80-bit, 128-bit, 256-bit), whereas the parameters <span class="math">\\kappa</span> determines the soundness of the “online” proofs generated by PoReP.Prove. Since these are run repeatedly in a challenge-response protocol, we leave open the possibility that certain applications may target a non-negligible online soundness error such as <span class="math">1/1,000</span>, <span class="math">1/100</span> or even <span class="math">1/3</span>. Each challenge-response proof will be subject to this soundness bound independently thus security is amplified against a prover that tries to cheat many times. We will discuss how concrete choices for each of the schemes impact security/efficiency.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">3.1 Basic PoRep from Verifiable Delay Encodings</h3>

    <p class="text-gray-300">A very basic PoRep construction is simply to use the VDE scheme to derive a unique replica <span class="math">R_{id}</span> as a <em>slow encoding</em> of the file <span class="math">F</span> on a given <span class="math">id</span>. This scheme was already sketched in <em>[14]</em>, which generalized a scheme originally proposed by Sergio Demian Lerner <em>[33]</em>, although neither works provided a formal security analysis. During the challenge-response period, the verifier periodically checks that the server has been persistently storing the encoding <span class="math">R_{id}</span> by challenging the server for <span class="math">R_{id}</span> itself. If the delay parameter of the VDE scheme is set appropriately relative to the verifier’s polling period, then a prover that has deleted the replica <span class="math">R_{id}</span> at any point during the polling period will not be able to re-derive the encoding in time to respond to the verifier’s challenge. We also need to ensure that the replicas on two different <span class="math">id</span>s are independent, and cannot be derived from one another more quickly than deriving each from scratch. The</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">relevant security property of a VDE scheme is that on any independent random challenge it is sequentially hard to compute, even given a polynomial number of prior encodings of other points. We can enforce the independence of inputs by using a random oracle <span class="math">H</span> applied to the replica <span class="math">id</span>. Specifically, instead of encoding <span class="math">F</span> directly, we encode <span class="math">F \\oplus H(id)</span>. Recovery of <span class="math">F</span> is still possible as <span class="math">id</span> is known to the decoder. Technically, as <span class="math">F</span> may consist of multiple blocks of length <span class="math">m</span> we will encode each <span class="math">i</span>th block individually XORed with $H(i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">id)<span class="math">. The verifier only needs to challenge for a randomly sampled constant number of the encoded blocks (and check them individually) in order to ensure that no more than an </span>\\epsilon$ fraction have been deleted.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lerner's initial proposal of this protocol used a Pohlig-Hellman cipher as a weak instantiation of the VDE and also focussed on the special use-case of proving unique storage of a copy of a fixed file known to all the verifiers (it was proposed as a way to prove unique storage of a copy of a blockchain). In our case, we need to adapt the protocol to handle data files specified only by their commitment tag <span class="math">\\tau_{D}</span> that may be initially unknown to the verifier. The PoRep needs to still be a PoS in this case. Fundamentally, for this to be secure the slow replica encoding must depend on this tag. Otherwise, the prover can first set the PoRep replica to any arbitrary value and then run the data extraction algorithm on a particular <span class="math">id</span> to find data consistent with this replica. This requires only a simple modification which is to use both <span class="math">id</span> and <span class="math">\\tau_{D}</span> as input to the random oracle <span class="math">H</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">3.1.1 Basic-VDE-PoRep</h2>

    <p class="text-gray-300">PoRep.Setup<span class="math">(\\lambda, T) \\to pp</span> Set <span class="math">\\Delta = 2T</span> and run VDE.Setup<span class="math">(\\Delta, \\lambda) \\to pp_{\\mathrm{vde}}</span>. This specifies the block length <span class="math">m</span>, and provides implicit input parameters to VDE.Enc and VDE.Dec. Lastly the setup specifies an integer <span class="math">\\ell = \\ell(\\lambda)</span> of size <span class="math">O(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoRep.Replicate <span class="math">(id, \\tau_{D}, \\tilde{D}) \\to R, aux</span> Parse <span class="math">\\tilde{D}</span> as a file of <span class="math">N</span> blocks <span class="math">d_{1}, \\ldots, d_{N}</span> each a string in <span class="math">\\{0, 1\\}^{m}</span>. For each <span class="math">i</span> compute $R_{i} = \\text{VDE.Enc}(d_{i} \\oplus H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i))<span class="math">. Output </span>R = (R_{1}, \\ldots, R_{N})<span class="math"> and </span>\\text{aux} = N$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoRep.Extract <span class="math">(id, \\tau_{D}, R) \\to \\tilde{D}</span> Parse <span class="math">R = (R_{1}, \\dots, R_{N})</span> and for each <span class="math">i</span> compute $d_{i} = \\text{VDE.Dec}(R_{i}) \\oplus H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i)<span class="math">. Output </span>\\tilde{D} = (d_{1}, \\dots, d_{N})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">PoRep.Poll <span class="math">(N) \\to r</span> For <span class="math">i = 1</span> to <span class="math">\\ell</span> randomly sample <span class="math">r_i \\stackrel{\\mathrm{~o~}}{{\\leftarrow}} [N]</span>. Output <span class="math">r = (r_1, \\dots, r_\\ell)</span>.</p>

    <p class="text-gray-300">PoRep.Prove <span class="math">(R, N, id, r) \\to \\pi</span> Parse <span class="math">R = (R_1, \\dots, R_N)</span> and <span class="math">r = (r_1, \\dots, r_\\ell)</span>. Output the proof <span class="math">\\pi = (R_{r_1}, \\dots, R_{r_\\ell})</span>.</p>

    <p class="text-gray-300">PoRep.Verify <span class="math">(id, \\tau_{D}, r, N, \\pi) \\to 0/1</span> Parse the proof <span class="math">\\pi = (\\pi_1, \\dots, \\pi_\\ell)</span> as <span class="math">\\ell</span> strings in <span class="math">\\{0, 1\\}^m</span>. For each <span class="math">i = 1</span> to <span class="math">\\ell</span> do:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute $\\hat{d}_i = \\text{VDE.Dec}(\\pi_i) \\oplus H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_i)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query <span class="math">b_i \\gets \\mathcal{O}_{\\mathrm{check}}(\\hat{d}_i, r_i, \\tau_D)</span></li>

    </ol>

    <p class="text-gray-300">If <span class="math">b_i = 1</span> for all <span class="math">i</span> then output 1 (accept), otherwise output 0 (reject).</p>

    <p class="text-gray-300">15The random oracle can be replaced with a collision-resistant hash function if only a pebbling adversary is considered in the security analysis.</p>

    <p class="text-gray-300">VDE instantiation</p>

    <p class="text-gray-300">We can instantiate the basic PoRep construction with the Sloth <em>[32]</em> VDE. With a block size of <span class="math">m=4096</span> and time delay <span class="math">T</span> of 10 minutes the Sloth decode takes approximately 0.15 seconds. For the same target delay with <span class="math">m=512</span> decoding takes approximately 3 seconds. These were measured on a 2.3 GHz Intel Core i7.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Replication time</h5>

    <p class="text-gray-300">For a target polling period of 5 minutes, choosing the block size gives a tradeoff between proof size and initialization time. With a block size of <span class="math">m=4096</span> and time delay <span class="math">T</span> of 10 minutes, replication of files up to 50KB (<span class="math">N=100</span>) takes approximately 1 hour on 16 parallel cores. With block size <span class="math">m=256</span> we can only support files up to 320 bytes for replication under 1 hour. If instead we fix the file size (e.g. up to 50KB) but decrease block size by a factor <span class="math">\\kappa</span>, then we both increase initialization time by a factor <span class="math">\\kappa</span> and decrease proof size by a factor <span class="math">\\kappa</span>.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Proof size</h5>

    <p class="text-gray-300">The proof size is a constant <span class="math">\\ell m</span> bits independent of the file size. To ensure (with soundness error <span class="math">\\delta</span>) that no more than an <span class="math">\\epsilon</span> fraction of the blocks have been deleted the number of queries <span class="math">\\ell</span> should be set to <span class="math">\\ell=\\log(\\delta)/\\log(1-\\epsilon)</span>. For example to detect deletion of 1% of the data blocks with soundness error <span class="math">1/3</span> we would require <span class="math">\\ell\\approx 100</span>, in which case the proof might as well include the entire replica for <span class="math">N&lt;100</span>. To detect deletion of 5% with soundness <span class="math">1/3</span> only requires <span class="math">\\ell\\approx 20</span>. For 80% we can set <span class="math">\\ell\\approx 5</span>.</p>

    <h5 id="sec-35" class="text-base font-semibold mt-4">Correctness and Security</h5>

    <p class="text-gray-300">Correctness is immediate from the construction and correctness of the underlying primitives. The construction’s rational security is optimally tight, i.e. it satisfies <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational-replication for any arbitrary <span class="math">\\epsilon&lt;1</span> and <span class="math">\\mu=\\mathsf{negl}(\\lambda)</span>. We provide the formal analysis in Section 4 (Theorem 1). The construction is also therefore a tight (Lemma 1).</p>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Erasure code preprocessing</h5>

    <p class="text-gray-300">In combination with an optimal rate <span class="math">1-\\epsilon</span> erasure code during preprocessing then it becomes perfectly rational for the prover to store a recoverable encoding of the file because even if it deletes an <span class="math">\\epsilon</span> fraction of the blocks it will still be perfectly recoverable. Likewise, if the prover generates <span class="math">k</span> independent replicas of a file <span class="math">D</span> then because it uses <span class="math">(1-\\epsilon)kN</span> space overall it can store <span class="math">\\epsilon N</span> blocks of each replica so that <span class="math">D</span> is still recoverable from each. Increasing the tolerance of the erasure codes results in an increase in replica size, but may justify reducing the tightness of the PoS/rational-replication security (i.e. reduce <span class="math">\\epsilon</span>). For example, on <span class="math">N=100</span> blocks, setting <span class="math">\\epsilon=0.01</span> and using an erasure code that recovers from 1% deletion results in only a 1% increase in file size but reducing a proof that is equal in size to the original file. On the other hand if <span class="math">\\epsilon=0.20</span> and <span class="math">D</span> is preprocessed with an erasure code that tolerates 20% deletion, then we trade an increase in the replica size by 20% for a proof size of only 6% of the original file size.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">3.2 Block Chaining Encodings</h3>

    <p class="text-gray-300">The Basic-VDE-PoRep is impractical for large file sizes. A 1 GB size file with block size of 512 bytes would take over 13 days to replica on a machine with limited parallelism. Increasing the block size to reduce replication time impacts proof size and is also limited by the message</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3.1: Illustration of PoRep. Replicate in the basic PoRep construction using a VDE.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3.2: Basic-VDE-PoRep in CBC-mode (insecure).</p>

    <p class="text-gray-300">space of the VDE scheme. VDE schemes like Sloth operate on relatively small input spaces as larger input spaces are more susceptible to parallelization attacks. The fundamental issue in the Basic-VDE-PoRep construction is that the VDE is applied individually to each block of the file thus allowing a fully parallel attacker to derive the entire replica within time  <span class="math">T</span>  whereas it takes a non-parallel prover take time  <span class="math">TN</span> . In fact, the prover can re-derive the specific challenged blocks in total time  <span class="math">\\ell T</span>  (or parallel time  <span class="math">T</span>  with only  <span class="math">\\ell</span>  parallelism).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A natural way to reduce the overall replication time while maintaining the sequential hardness is to chain the encodings of each block, similar to encryption in block chaining cipher modes. A simple chaining would modify PoRep. Replicate in the Basic-VDE-PoRep by deriving from each  <span class="math">R_{i}</span>  (encoding of block  <span class="math">d_{i}</span> ) a key  $k_{i} = H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{i})<span class="math">  to be used in the encoding  </span>R_{i+1} = \\mathsf{VDE.Enc}(d_{i+1} \\oplus k_{i})<span class="math">  (of block  </span>d_{i+1}<span class="math"> ) as shown in Figure 3.2. Each  </span>R_{i}<span class="math">  can still be decoded locally given only  </span>R_{i-1}<span class="math">  as  </span>D_{i} = \\mathsf{VDE.Dec}(R_{i} \\oplus k_{i})<span class="math">  where  </span>k_{i} = H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{i-1})<span class="math"> . We would then reduce the time delay  </span>T<span class="math">  for each call to VDE. Enc such that  </span>T \\cdot N$  is equal to the desired replication time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The problem with this basic chaining method is that it has a smooth time/space tradeoff. An adversarial prover can store only each  <span class="math">k</span> th block (reducing overall storage by a factor  <span class="math">k</span> ) and yet it can recompute any individual block with only  <span class="math">k</span>  calls to VDE.Enc. With sufficient parallelism it can re-derive the entire replica in time  <span class="math">kT</span>  instead of  <span class="math">NT</span> , and worse yet it can</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 3.3: Illustration of block dependency DAG configurations in cipher block chaining encodings. On the left is a simple chain (as in the chained Basic-VDE-PoRep) whereas the right depicts a mock depth robust chaining. For each chained encoding, the  <span class="math">i</span> th encoding is derived as  <span class="math">R_{i} \\gets \\mathsf{Enc}(k_{i}, d_{i})</span>  where  $k_{i} = H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">parents(i))<span class="math">  and  </span>parents(i)<span class="math">  denotes the set of encodings on nodes  </span>j<span class="math">  with a directed edge to  </span>i$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">respond to the verifier's  <span class="math">\\ell</span>  random challenges in time  <span class="math">kT</span>  with only  <span class="math">\\ell</span>  parallelism. As a result to ensure the server is storing at least  <span class="math">1 / k</span>  fraction of blocks the replication time must be at least a factor  <span class="math">N / k</span>  longer than the polling period.</p>

    <p class="text-gray-300">Dependency graphs The issue with the simple cipher block chaining method is that the dependency graph of the block encodings is not depth robust (see Section A.6). Let each block of the file represent a node in a graph where a directed edge is placed between the  <span class="math">i</span> th node and the  <span class="math">j</span> th node if the encoding of the  <span class="math">j</span> th block of the file depends on the encoding of the  <span class="math">i</span> th block. The resulting graph is a directed acyclic graph (DAG). By the properties of  <span class="math">H</span>  and VDE.Enc the dependencies are cryptographically enforced: if the  <span class="math">j</span> th block is dependent on the  <span class="math">i</span> th block then the  <span class="math">j</span> th encoding cannot be computed unless the  <span class="math">i</span> th encoding is known except with negligible probability. If the dependency graph is  <span class="math">(\\alpha, \\beta)</span>  depth robust then deleting any  <span class="math">\\alpha N</span>  fraction of the encodings will contain a dependency path of length  <span class="math">\\beta N</span>  inside the deleted subgraph, meaning that it will require at least  <span class="math">\\beta N</span>  sequential calls to VDE.Enc to re-derive the deleted blocks. On the other hand, the dependency graph of the cipher block chained Basic-VDE-PoRep is a line, and as demonstrated by the time/space tradeoff attack described above it is at most  <span class="math">(1 - 1/k, k/N)</span>  depth robust for any  <span class="math">k &amp;lt; N</span>  (as storing only every  <span class="math">k</span> th node partitions the deleted set of nodes into lines of length  <span class="math">k</span> ). More generally we can consider the parallel pebbling complexity of the dependency graph (Section A.8).</p>

    <p class="text-gray-300">The construction DRG-PoRep [26] extends the Basic-VDE-PoRep by chaining block dependencies using a depth robust chaining as described above. As a PoS, it can be viewed as the generic PoS from the graph labeling game (Section A.8) on a depth robust graph, where the random oracle queries are combined with VDE queries to introduce more asymmetry between initializing the PoS and extracting data from it. Using an  <span class="math">(N,\\alpha ,\\beta ,d)</span> -DRG we are able to reduce the time delay  <span class="math">T</span>  for each block encoding as  <span class="math">N</span>  increases, such that the total time  <span class="math">NT</span>  remains the same and the polling period is tuned to  <span class="math">\\beta TN</span> . A prover that deletes more than an  <span class="math">\\alpha</span>  fraction of the block encodings will not be able to respond to challenges correctly (and quickly enough) during the challenge-response period. This achieves  <span class="math">\\alpha</span> -rational replication and replication time that is a factor  <span class="math">1 / \\beta</span>  longer than the polling period. The security can be amplified using stronger DRGs</p>

    <p class="text-gray-300">for smaller <span class="math">\\alpha &amp;gt; 0</span>, at the cost of increasing the degree by <span class="math">O(1 / \\alpha)</span> as well as the replication time relative to polling period.</p>

    <p class="text-gray-300">As in the generic PoS from labeling games, the protocol separates out two kinds of proofs. As a part of the aux output during the replication the prover generates a proof that the depth robust chaining of the encodings were "mostly" correct. Unlike in the Basic-VDE-PoRep where the verifier can completely verify the correctness of a block using VDE.Dec, here the verifier cannot check that all the correct dependencies were enforced as this would not be a compact proof. Here, the prover will first derive the entire encoding (consisting of labels on each node of the graph) and provide the verifier with a compact vector commitment to these labels. The verifier will query for several randomly sampled nodes of the graph and challenge the prover to open the commitment to labels on both this node and the labels on all of its parent nodes. The verifier can then check that the encodings correctly observed the dependency. This convinces the verifier that a constant fraction of the nodes in the graph are correct. Because the graph is <span class="math">(\\alpha, \\beta)</span> depth robust, the (sufficiently large) subgraph of correct nodes is also depth robust. Put another way, the small fraction of incorrect labels do not help the adversary any more than putting several additional initial pebbles on the graph "for free". The proof is made non-interactive using the Fiat-Shamir heuristic.</p>

    <p class="text-gray-300">The second "online" proof is a simple proof of retrievable commitment. The verifier simply challenges for several indices of the prover's vector commitment to the replica block encodings and the prover sends back these openings.</p>

    <h2 id="sec-39" class="text-2xl font-bold">3.3.1 DRG-PoRep</h2>

    <p class="text-gray-300">PoRep.Setup<span class="math">(\\lambda, \\kappa, T) \\to pp</span>: The setup obtains as input security parameters <span class="math">\\lambda, \\kappa</span>, as well as the delay parameter <span class="math">T</span>, sets <span class="math">\\Delta = 2T / (\\beta N - 1)</span> to be the VDE delay parameter and runs <span class="math">pp_{\\mathrm{vde}} \\gets \\mathrm{VDE.Setup}(\\lambda, \\Delta)</span>. This determines a block size <span class="math">m</span> and <span class="math">\\mathcal{M} = \\{0,1\\}^m</span>. The setup then runs <span class="math">pp_{\\mathrm{vc}} \\gets \\mathrm{VC.Setup}(1^\\lambda, N_{max}, \\mathcal{M})</span> where <span class="math">N_{max}</span> is the maximum supported data length<span class="math">^{17}</span>. Finally the setup also defines two integers <span class="math">\\ell_1 = \\ell_1(\\lambda)</span> and <span class="math">\\ell_2 = \\ell_2(\\kappa)</span>. The setup outputs <span class="math">pp = (pp_{\\mathrm{vde}}, pp_{\\mathrm{vc}}, m, \\ell_1, \\ell_2)</span>.</p>

    <p class="text-gray-300">PoRep.Replicate <span class="math">(id, \\tau_{D}, \\tilde{D}) \\to R, aux</span>: The input to the replicate procedure is the preprocessed data file <span class="math">\\tilde{D}</span> consisting of <span class="math">N</span> blocks of size <span class="math">m</span>, along with data tag <span class="math">\\tau_{D}</span> and replica identifier <span class="math">id</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Apply random oracle $H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_D) = \\sigma<span class="math">. Implicitly </span>\\sigma<span class="math"> defines a graph </span>G \\gets \\mathsf{DRG.Sample}(N, \\sigma)$, however the prover does not need to run this function explicitly as it will use the parent function instead.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\tilde{D}</span> as data blocks <span class="math">(d_1, \\dots, d_N)</span>, each <span class="math">d_i \\in \\{0, 1\\}^m</span>. We define the following subroutine DRGEnc that operates on <span class="math">\\vec{d}, m, N</span>, and <span class="math">\\sigma</span> and outputs the replica <span class="math">R</span>.</li>

    </ol>

    <p class="text-gray-300">17Some vector commitments, such as a Merkle commitment, do not require specifying the data length in the setup. In this case <span class="math">N_{max} = \\infty</span>.</p>

    <p class="text-gray-300">26</p>

    <pre><code class="language-latex">DRGEnc  $(\\vec{d},m,N,\\sigma)\\{$  for  $i = 1$  to  $N$  ..  $(v_{1},\\dots,v_{d})\\gets \\mathsf{DRG.Parents}(N,\\sigma ,i)$ $k_{i}\\gets H(\\sigma ||c_{v_{1}}||\\dots ||c_{v_{d}})$ $c_{i}\\gets \\mathsf{VDE.Enc}(pp_{\\mathsf{vde}},k_{i}\\oplus d_{i})$ $R\\gets (c_1,\\ldots ,c_n)$  return  $R\\}$</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute vector commitment  <span class="math">com_{R}, \\tau_{R} \\gets \\mathsf{VC}. \\mathsf{Com}(pp_{\\mathsf{vc}}, R)</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Now use  <span class="math">H</span>  to derive the (non-interactive) a challenge vector  <span class="math">\\rho = (\\rho_{1},\\dots,\\rho_{\\ell_{1}})</span>  by computing  $\\rho_{i} = H(\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">com_{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i)<span class="math"> . Set  </span>C^{\\mathrm{nodes}} = (c_{\\rho_1},\\dots,c_{\\rho_{\\ell_1}})<span class="math"> . For each  </span>i<span class="math">  set  </span>\\mathsf{parents}(\\rho_i)\\gets \\mathsf{DRG.Parents}(N,\\sigma ,\\rho_i)<span class="math">  and set  </span>C^{\\mathrm{parents}}(\\rho_i) = (c_{v_1},\\dots,c_{v_d})<span class="math">  where  </span>\\{v_{1},\\ldots ,v_{d}\\} = \\mathsf{parents}(\\rho_{i})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute vector commitment opening proofs on the indices specified by the challenges:</li>

    </ol>

    <pre><code class="language-latex">$\\Lambda \\gets \\mathsf{VC. Open}(pp_{\\mathsf{vc}},C^{\\mathsf{nodes}},\\rho ,\\tau_R)$
for  $i = 1$  to  $\\ell_1$  ..  $\\Lambda_{i}\\gets \\mathsf{VC. Open}(pp_{\\mathsf{vc}},C^{\\mathsf{parents}}(\\rho_{i}),\\mathsf{parents}(\\rho_{i}),\\tau_{R})$</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">R</span>  and  <span class="math">\\mathsf{aux} = \\mathsf{com}_R, \\sigma, \\rho, C^{\\mathsf{nodes}}, C^{\\mathsf{parents}}(\\rho_1), \\ldots, C^{\\mathsf{parents}}(\\rho_{\\ell_1}), \\Lambda, \\Lambda_1, \\ldots, \\Lambda_{\\ell_1}</span> .</li>

    </ol>

    <p class="text-gray-300">PoRep.Poll  <span class="math">(N)\\to r</span>  : For  <span class="math">i = 1</span>  to  <span class="math">\\ell_2</span>  randomly sample  <span class="math">r_i\\stackrel {\\mathrm{a}}{&amp;lt;}\\mathrm{B}[N]</span>  . Output  <span class="math">r = (r_{1},\\dots,r_{\\ell_{2}})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoRep.Prove  <span class="math">(R, aux, id, r) \\to \\pi</span> : The input is the replica  <span class="math">R = (c_{1}, \\dots, c_{N})</span> ,  <span class="math">id</span> , aux output of replicate (which includes  <span class="math">com_{R}</span> ), a challenge vector  <span class="math">\\vec{r} = (r_{1}, \\dots, r_{\\ell_{2}})</span> . Derive  $\\sigma = H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{D})<span class="math"> . Set  </span>\\vec{c} = (c_{r_{1}}, \\dots, c_{r_{\\ell_{2}}})<span class="math"> . For each  </span>r_{i}<span class="math">  also derive  </span>\\text{parents}(r_{i}) \\gets \\text{DRG.Parents}(N, \\sigma, r_{i})<span class="math"> , set  </span>C^{\\text{parents}}(r_{i})<span class="math">  to be the concatenation of  </span>c_{j}<span class="math">  for all  </span>j \\in \\text{parents}(r_{i})<span class="math">  (ordered by increasing indices), and compute  </span>k_{r_{i}} = H(\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\text{parents}}(r_{i}), i)<span class="math"> . Set  </span>\\vec{k} = (k_{r_{1}}, \\dots, k_{r_{\\ell_{2}}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Compute  <span class="math">\\Lambda \\gets \\mathsf{VC. Open}(pp_{\\mathsf{vc}},com_R,\\vec{c},\\vec{r},\\tau_R)</span> . Output  <span class="math">\\pi = (\\Lambda_{\\mathrm{ret}},\\vec{c},\\vec{k})</span></p>

    <p class="text-gray-300">PoRep.Verify  <span class="math">(id, \\tau_{D}, r, aux, \\pi) \\to b</span>  Parse the input aux as a list of values  <span class="math">com_{R}</span> ,  <span class="math">\\sigma</span> ,  <span class="math">\\rho</span> ,  <span class="math">C^{\\text{nodes}}</span> ,  <span class="math">C^{\\text{parents}}(\\rho_{1}), \\ldots, C^{\\text{parents}}(\\rho_{\\ell_{1}})</span> ,  <span class="math">\\Lambda</span> ,  <span class="math">\\Lambda_{1}, \\ldots, \\Lambda_{\\ell_{1}}</span>  as well as the input  <span class="math">\\pi = \\Lambda_{\\text{ret}}</span> ,  <span class="math">\\vec{c}</span> . Parse  <span class="math">\\pi = (\\Lambda_{\\text{ret}}, \\vec{c}, \\vec{k})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. First verify aux. <span class="math">^{18}</span>  Check  $H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_D) = \\sigma<span class="math">  and  </span>H(\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">com_R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i) = \\rho_i<span class="math">  for each  </span>i = 1<span class="math">  to  </span>\\ell_1<span class="math"> . If any checks fail output 0 and terminate. Next derive  </span>\\text{parents}(\\rho_i) \\gets \\text{DRG.Parents}(N, \\sigma, \\rho_i)<span class="math"> . Run the following verifications on the vector commitment openings  </span>\\Lambda, \\Lambda_1, \\ldots, \\Lambda_{\\ell_1}$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <pre><code class="language-latex">$b_{0}\\gets \\mathsf{VC.Verify}(pp_{\\mathsf{vc}},C^{\\mathsf{nodes}},\\rho ,\\Lambda)$
for  $i = 1$  to  $\\ell_1$  ..  $b_{i}\\gets \\mathsf{VC.Verify}(pp_{\\mathsf{vc}},C^{\\mathsf{parents}}(\\rho_{i}),\\mathsf{parents}(\\rho_{i}),\\Lambda_{i})$</code></pre>

    <p class="text-gray-300">If  <span class="math">b_0 \\wedge b_1 \\wedge \\dots \\wedge b_{\\ell_1} = 0</span>  then output 0 and terminate.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally for each <span class="math">c_{\\rho_i} \\in C^{\\text{nodes}}</span> the key $k_i = H(\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{v_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{v_d})<span class="math"> where </span>\\{v_1, \\dots, v_d\\} = \\text{parents}(\\rho_i)<span class="math"> and compute </span>d_i \\gets \\text{VDE.Dec}(pp_{\\text{vde}}, k_i \\oplus c_{\\rho_i})<span class="math"> and query the check oracle </span>b \\gets \\mathcal{O}_{\\text{check}}(d_i, \\rho_i, \\tau_D)<span class="math">. If </span>b = 0$ output 0 and terminate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Second verify the "online" proof <span class="math">\\pi</span>. First compute <span class="math">b \\gets \\mathsf{VC.Verify}(pp_{\\mathsf{vc}}, \\vec{c}, \\vec{r}, \\Lambda_{\\mathsf{ret}})</span>. Next for each <span class="math">i \\in [\\ell_2]</span> compute <span class="math">d_i \\gets \\mathsf{VDE.Dec}(pp_{\\mathsf{vde}}, k_i \\oplus c_{r_i})</span> and query the oracle <span class="math">b_i&#x27; \\gets \\mathcal{O}_{\\mathsf{check}}(d_i, r_i, \\tau_D)</span>. Output <span class="math">b \\wedge b_1&#x27; \\wedge \\dots \\wedge b_{\\ell_2}&#x27;</span>.</li>

    </ol>

    <p class="text-gray-300">Replication and extraction time The main achievement of the DRG PoRep construction is its scalable replication time, which is now a fixed multiple of the polling period (dependent only on <span class="math">\\alpha, \\beta</span>) and in particular is independent of the number of blocks in the file. The extraction time is also optimal, as any block can be locally decoded by applying the hash function <span class="math">H</span> to <span class="math">d = O(\\log n)</span> labels and making a single call to VDE.Dec, which should take under 1 second.</p>

    <p class="text-gray-300">Batched vector commitment openings In the construction description above we listed the vector commitment openings <span class="math">\\Lambda</span>, <span class="math">\\Lambda_1, \\ldots, \\Lambda_{\\ell_1}</span> for <span class="math">C^{\\mathrm{nodes}}</span> and all <span class="math">C^{\\mathrm{parents}}(\\rho_{\\ell_i})</span> separately inside the parameter aux, and they were verified separately as well. This was done mostly for clarify of presentation. This would be necessary if the vector commitments are instantiated with Merkle commitments. However, one of the major advantages of using vector commitments with batchable openings is that these can all be compressed to a single constant size opening. In this case aux only includes the labels <span class="math">C^{\\mathrm{nodes}}</span> and all <span class="math">C^{\\mathrm{parents}}(\\rho_{\\ell_i})</span> for each <span class="math">i</span> along with a single opening proof <span class="math">\\Lambda</span>.</p>

    <p class="text-gray-300">Vector commitment storage If the prover uses a Merkle tree as its vector commitment then it will either need to additionally store the hashes on internal Merkle nodes or recompute them on the fly. At first glance this may appear to destroy the tightness of the PoS because storing the Merkle tree is certainly not a PoS. However, because the time/space tradeoff in storing this tree is so smooth the honest prover can delete the hashes on nodes on the first <span class="math">k</span> levels of the tree to save a factor <span class="math">2^k</span> space and re-derive all hashes along a Merkle path by reading at most <span class="math">2^k</span> nodes and computing at most <span class="math">2^k</span> hashes. If <span class="math">k = 7</span> this is less than a <span class="math">1\\%</span> overhead in space, and requires at most 128 additional hashes and reads. Furthermore, as remarked in [45] these <span class="math">2^k</span> reads are sequential memory reads, which in practice are inexpensive compared to the random reads for challenge labels.</p>

    <p class="text-gray-300">Relaxing soundness: interaction and time/space tradeoffs The size of <span class="math">\\ell_1</span> is a significant factor in blowing up the size of aux. The reason why in general we need to set <span class="math">\\ell_1</span> to be large is that otherwise the prover can brute force a favorable challenge in the non-interactive proof. There are two ways to improve on this. First, we could get rid of the non-interactive proof in aux and required the verifier to challenge the prover for a fresh aux proof on their first interaction. Second, the non-interactive challenge "grinding" attack ignores the fact that the prover will need to rerun replication many times in expectation. As this is already a memory/sequentially hard computation (taking at least around 10-60 min), we can relax the security model to assume there is some bound on the initial computation that the malicious prover is willing to do in order to save a fraction of space during the online phase. If we can just achieve soundness 1/1000 instead of <span class="math">2^{-80}</span> then even a massively parallelized prover will need to grind in expectation for 3.47 days. For this soundness level we can set <span class="math">\\ell_1 \\approx 100</span>.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">Proof sizes</p>

    <p class="text-gray-300">There are two types of proofs, the “offline” non-interactive proof contained in aux and the “online” proofs output by PoRep.Prove. The proof contained in aux is much larger (although it is only sent once to each verifier, which amortizes the cost). The proof size in aux is <span class="math">\\ell_{1}(d+1)m+L(N,m,\\ell_{1}(d+1))</span> where <span class="math">L(N,m,\\ell_{1}(d+1))</span> is the size of the vector commitment opening proof on a vector of length <span class="math">N</span> of elements of size <span class="math">m</span>. As aux is non-interactive the soundness error needs to be exponentially small, therefore we set <span class="math">\\ell_{1}=\\lambda/-log(1-\\alpha)</span>. For example with <span class="math">\\lambda=80</span> and <span class="math">\\alpha=0.20</span> this is <span class="math">\\ell_{1}=825</span>. However, as described above, in practice we could set <span class="math">\\ell_{1}=100</span> if we are willing to assume a malicious prover will not find it rational to work for 4 days to save a fraction of the space. With <span class="math">d=5</span> and <span class="math">m=128</span> the total proof size is approximately 10 KB, independent of the data input size. Note that the data input size could range up to gigabytes or terabytes.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Compressing proofs with SNARGs</h4>

    <p class="text-gray-300">We can further compress the size of the aux proof by using SNARGs, or any other form of succinct proofs. To maximally compress the proof size, the prover can compute a SNARG over the circuit PoRep.Verify with the proof <span class="math">\\pi</span> as a witness. To optimize the performance of this SNARG it would be important to choose instantiations of vector commitments and slow encodings that minimize the multiplicative complexity of checking inclusion proofs and decoding. If the main cost in the proof size comes from the degree <span class="math">d</span> of the DRGs (see Section LABEL:sec:drg), then we can already substantially decrease the proof size by using SNARGs only to eliminate the parent nodes of each <span class="math">c_{i}</span>. In this case, the SNARG would only prove knowledge of <span class="math">d</span> encodings <span class="math">c_{1},...,c_{d}</span>, their valid inclusion proofs in <span class="math">com_{R}</span> at the appropriate positions, and that <span class="math">k_{i}=H(c_{1},...,c_{d})</span>. We can also replace the hash function <span class="math">H</span> with a suitable <em>key-derivation function</em> (KDF) that minimizes multiplicative complexity. Since the proof of security holds in the random oracle model, it is important that the KDF should retain properties similar to a random oracle. At a minimum it needs to be collision-resistant.</p>

    <p class="text-gray-300">The Jubjub^{19} Pedersen hash over BLS12-381 is an attractive candidate as it achieves a circuit complexity of only 4 multiplication gates per input bit (61,440 gates per Merkle commitment opening with a 32GB file). This can be used to instantiate both Merkle commitments and the function <span class="math">H</span>. If the VDE is instantiated with Sloth++ <em>[14]</em> over the scalar field of BLS12-381, then verification of a 5 min delay involves roughly 6 million multiplication gates. This is due to the fact that Sloth++ iterates a square-root round function 30 million times. However, with a 1GB file the delay <span class="math">T</span> will be reduced drastically, e.g. with <span class="math">\\beta=1/100</span> it will require only 3 iterations of the Sloth++ round function. Furthermore, if a longer delay (on the order of 5 minutes) is necessary then we can instead use a VDE based on inverting permutation polynomials over <span class="math">\\mathbb{F}_{p}</span> described in <em>[14]</em>, which is a nominal added cost in combination with the Merkle inclusion proof. For sequential security this would require tuning the polling period to the time it would take a prover running on an industry standard GPU as the polynomial GCD computations do admit some parallelism. The total circuit size for verifying aux with <span class="math">m=256</span>, <span class="math">N=2^{30}</span>, <span class="math">d=20</span>, and <span class="math">\\ell_{1}=100</span> is approximately 124 million gates, and would take approximately 5 hours to compute on a single-threaded 2.4 GHz Intel E7-8870 CPU <em>[12]</em>. With modest parallelism (e.g. 16 threads) this can easily be reduced to below the raw replication time.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Towards both tight and efficient PoReps</h4>

    <p class="text-gray-300">The DRG-PoRep construction improved significantly on replication time while maintaining terrific extraction efficiency. However, it com</p>

    <p class="text-gray-300">romised on <span class="math">\\epsilon</span>-rational security and the tightness of the proof of space. In order to achieve <span class="math">\\epsilon</span>-arbitrarily small, we required DRG graphs that were robust in <span class="math">\\epsilon</span>-fraction subgraphs. Not only does this degrade the practicality of the DRG construction, it also worsens the gap between polling and replication time, which necessarily increases as <span class="math">O(1/\\epsilon)</span>. Thus it does not really achieve arbitrarily small <span class="math">\\epsilon</span>-rational security in the same sense as Basic-PoRep. Furthermore, by increasing dependencies between blocks, erasure code preprocessing is no longer guaranteed to recover the file from arbitrary deletion of an <span class="math">\\epsilon</span> fraction of the blocks (only the <span class="math">\\epsilon N</span> topologically last blocks).</p>

    <p class="text-gray-300">Pietrzak <em>[45]</em> also proposed using depth robust graphs for proofs of replication and presented a slightly different construction to DRG-PoRep that partially resolves the issues of space-tightness in an elegant way. The construction uses the recent <em>[6]</em> DRGs which are <span class="math">(n,\\alpha,\\beta,O(\\log n/\\epsilon))</span>-depth robust for all <span class="math">(\\alpha,\\beta)</span> such that <span class="math">1-\\alpha+\\beta\\geq 1-\\epsilon</span>. Instead of embedding the data on all nodes of the graph, the construction generates a graph on <span class="math">4n</span> nodes, but only encodes the data on the topologically last <span class="math">n</span> nodes. The replication procedure still generates a labelling of the entire graph upon which the last <span class="math">n</span> block encodings are dependent, but only outputs the labels on the last <span class="math">n</span> nodes. Pietrzak shows that a prover who deletes an <span class="math">\\epsilon^{\\prime}</span> fraction of the labels on the last <span class="math">n</span> nodes will not be able to re-derive them in fewer than <span class="math">n</span> sequential steps. The value <span class="math">\\epsilon^{\\prime}</span> can be made arbitrarily small however <span class="math">\\epsilon&lt;\\epsilon^{\\prime}/4</span>, so the degree of the graph must increase as <span class="math">1/\\epsilon^{\\prime}</span>. Furthermore, although the graphs in <em>[6]</em> achieve asymptotic efficiency and are incredibly intriguing from a theoretical perspective, they still do not have concretely practical degrees (their asymptotic degree starts to kick in on graphs with over a billion nodes).</p>

    <p class="text-gray-300">Pietrzak’s construction did not incorporate delay encodings into the DRG PoRep construction and this could easily be added just as in DRG-PoRep. If only SHA256 is called for each labeling this means that only graphs of a minimum size over 1 billion nodes can achieve a 10 min delay. SHA256 can be intentionally slowed with iterations, but then extraction becomes as inefficient as the replica generation. Hence the main advantage of the VDEs is in lowering the gap between extraction/replication on graphs of smaller size. However, since Pietrzak’s construction only embeds the data on the last level the data extraction is already as inefficient as data replication (the labels on the first <span class="math">3n</span> labels needs to be re-derived before the data can be extracted), hence the VDEs will not help as much.</p>

    <h2 id="sec-42" class="text-2xl font-bold">4 Formal security analysis</h2>

    <p class="text-gray-300">This section applies the framework and definitions of Section 2 to formally analyze the security of the two constructions Basic-VDE-PoRep and DRG-PoRep. The focus of our analysis is on proving <span class="math">\\epsilon</span>-rational-security. In fact, Lemma 2 established sufficiency conditions that greatly simplify proving <span class="math">\\epsilon</span>-rational security. Both constructions are each a <span class="math">\\delta</span>-PoRC of the replica <span class="math">R</span> and data <span class="math">D</span> almost by construction (and PRAM strongly sound as proven in Lemma 3), and the main work left is show that each is a parallel sound proof of space. Both of the constructions can be viewed as PoS variants of the generic graph labeling PoS (with a tweak for incorporating VDEs). Furthermore, due to Pietrzak’s recent result <em>[45]</em>, we can contain our analysis to parallel pebbling games, which translates to unconditional security in the random oracle model with some small loss (Theorem 4). (Before this result graph labeling PoS constructions were still analyzed via pebbling games and the correspondence was taken for granted). There is a small catch in relying on this correspondence in our setting, however, which is that Pietrzak’s analysis applied to pure</p>

    <p class="text-gray-300">random oracle labeling games and did not involve VDEs.</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">4.1 Labeling games with VDEs</h3>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">4.1.1 Pebbling game model</h4>

    <p class="text-gray-300">Pebbling games appropriately model labeling games with collision resistant one-way hash functions informally because of the property that labels on distinct nodes do not repeat with any significant probability and computing new labels cannot be predicted without knowing all the inputs to the labeling function, i.e. all the dependency labels. The independence of labels even holds when there are no dependency edges by incorporating the unique index of the node as the first input. In the labeling games with VDEs that we consider, a collision resistant hash function (or random oracle) is used to first derive a key from all the dependencies of a node. The key is then XORed with a (non-unique) data input, and the result is passed to a VDE to derive the node’s label. Conditioned on fixed data inputs, these “key labels” are uniquely determined, and are derived as the output of collision resistant hash functions just as in usual labeling games.</p>

    <p class="text-gray-300">The important distinction, however, is that the call to the VDE is much more expensive than the call to the hash function to derive the key. The cost of “placing a pebble” is dominated by the VDE time delay. The sequentiality security property of a VDE (Definition 19) says that evaluating the VDE on a point will be hard on a <em>random</em> input, even given an arbitrary polynomially sized table of evaluations on other points. If the hash function used to derive the key labels is modeled as random oracle then the input to each VDE call is an independent uniform random point.</p>

    <p class="text-gray-300">As we are focussed on a parallel adversary, we may assume for the purpose of our analysis that the adversary always calls the VDE to derive the label whenever a key and input is available. In fact, for the purpose of analyzing PoS security of PoRep constructions we may assume that the data inputs are (they are assumed to be available externally in the worst case). This way the underlying pebbling game is largely unchanged, and we can model the VDE and random oracle queries as a single pebbling move that can be made only when there are labels on all the dependencies.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">4.1.2 Committed data inputs</h4>

    <p class="text-gray-300">As we already noted, it is crucial that the auxiliary data inputs are committed (or publicly known) and that the labeling is uniquely dependent on this commitment. Otherwise, the prover can place any arbitrary labels on the nodes and use the VDE decode algorithm to find corresponding data inputs consistent with these labels and the key derived from labels on all neighboring nodes. This allows the prover to circumvent the labeling dependencies of the underlying graph or even the cost of evaluating the VDE. The issue is resolved by using the data commitment <span class="math">\\tau_{D}</span> of all data inputs to sample the random oracle <span class="math">H_{\\sigma}</span>. Intuitively, the pebbling game is still an accurate security model because the adversary must “know” <span class="math">D</span> before labeling the graph using <span class="math">H_{\\sigma}</span>.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">4.1.3 Parallel pebbling vs labeling</h4>

    <p class="text-gray-300">Intuitively, any labeling strategy starting from an initial advice string that simply stores a set of graph labels then this directly translates to a pebbling strategy in the corresponding pebbling game and thus inherits the security of the pebbling game. Moreover, when the labels themselves encode entries in a random oracle’s function table they are incompressible (Fact 2). However, the labeling adversary’s initial advice (equiv. the PoS adversary’s persistent storage) need not encode these labels explicitly.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pietrzak’s unconditional proof of this equivalence in the random oracle model first demonstrates how to translate a certain set <span class="math">F</span> called “fresh” queries (roughly those queries that contain any label which has not yet been received as an output of another query) made by a successful labeling strategy into a successful parallel pebbling strategy that uses $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> initial pebbles. Hence, if the pebbling game is hard without </span>\\Omega(n)<span class="math"> initial pebbles then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Omega(n)<span class="math">. Intuitively, the labeling adverary’s initial advice </span>s<span class="math"> must somehow encode </span>F<span class="math">, and therefore should have at least the same size as </span>F<span class="math"> is incompressible (Fact 2). The next step of the proof demonstrates this formally by showing how to construct an encoding scheme that uses the adversary as a black box to encode these </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> entries in the random oracle’s function table using just </span>\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is not immediately clear that this equivalence still holds when comparing the parallel pebbling game with the VDE cost function to the parallel hardness of the VDE labeling game. Pietrzak proved the equivalence still holds when the auxiliary data inputs are simply XORed with the random oracle “key” outputs, and assuming the commitment <span class="math">\\tau_{D}</span> is extractable (e.g., a commitment that uses the random oracle itself, such as a Merkle commitment, is extractable in the random oracle model). In this case the encoding scheme in the proof works roughly the same way but first extracts the data inputs from the adversary and uses the data to recover the incompressible “keys”. In the constructions we analyze in this paper the “keys” are similarly XORed with the data inputs before they are passed to the VDE. Moreover, the VDE is invertible so the the key labels are still extractable from the output given the data.</p>

    <p class="text-gray-300">However, the security of the construction relies on the cost of querying the VDE, which is significantly greater than querying the random oracle. One way to address this is to use the IDP oracle (Definition 20) to model queries to the VDE separately from queries to the random oracle, and then adapt the analysis of <em>[45]</em> to show that an adversary who wins the labeling storing too little advice either can compress the random permutation table of VDE.Enc or the random function table of <span class="math">H_{\\sigma}</span>. This analysis is beyond the scope of the current document.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">4.2 Security claims</h3>

    <p class="text-gray-300">For the following claims we assume that <span class="math">\\mathcal{O}_{\\text{check}}</span> is perfectly binding on pairs <span class="math">(\\tau_{D},D)</span> such that each <span class="math">\\tau_{D}</span> is a position binding vector commitment to <span class="math">D</span>, i.e. for each <span class="math">\\tau_{D}</span> and <span class="math">i</span> there exists a unique <span class="math">D_{i}</span> such that <span class="math">\\mathcal{O}_{\\text{check}}(\\tau_{D},i,D,\\mathsf{aux})=1</span> for some <span class="math">\\mathsf{aux}</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Claim 1.</h6>

    <p class="text-gray-300">Basic-VDE-PoRep is (PRAM strongly) <span class="math">\\mu</span>-sound <span class="math">(1-\\delta)</span>-PoRC for any <span class="math">\\mu&gt;(1-\\delta)^{\\ell(\\lambda)}+</span> <span class="math">\\mathsf{negl}(\\lambda)</span> and with constant additive extractor blowup.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The implicit PoRC protocol of Basic-VDE-PoRep is just an instantiation of PoRC from vector commitments Section A.4.2. The vector commitment is <span class="math">(\\tau_{D},N)</span> and the opening advice is <span class="math">(R,id)</span>. Each $R_{i}=\\mathsf{VDE.Enc}(d_{i}\\oplus H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i)<span class="math"> where </span>H<span class="math"> is a collision hash function and each output of VDE.Enc is uniquely decodable. VC.Open on </span>\\tau_{D}<span class="math">, an index </span>i\\in[N]<span class="math">, block </span>d_{i}<span class="math">, and the opening advice </span>R_{i}<span class="math"> computes </span>\\mathsf{VDE.Dec}(R_{i})\\oplus H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i)=d_{i}<span class="math"> and then verifies </span>\\mathcal{O}_{\\text{check}}(\\tau_{D},i,D,\\mathsf{aux})=1<span class="math">. This satisfies position binding by the assumption that </span>\\mathcal{O}_{\\text{check}}<span class="math"> is position binding. Moreover, since </span>R_{i}<span class="math"> is uniquely determined from </span>d_{i}<span class="math"> by the properties of VDE and collision resistance of </span>H<span class="math"> the commitment to </span>d_{i}<span class="math"> is also position binding to </span>R_{i}<span class="math">. In the PoRC protocol each challenge in the challenge vector specifies an index </span>i<span class="math"> for the </span>i<span class="math">th pair </span>(R_{i},d_{i})<span class="math">, and the proof value </span>R_{i}$ is an opening of this pair. Therefore the claim follows from Theorem 3. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Claim 2.</h6>

    <p class="text-gray-300">The composition of <span class="math">k</span> instances of Basic-VDE-PoRep on distinct ids <span class="math">id_{1},...,id_{k}</span> is a parallel <span class="math">((1-\\epsilon+\\delta)kN,2T,(1-\\epsilon+\\delta)^{\\ell(\\lambda)})</span>-sound PoS for any <span class="math">1&gt;\\epsilon&gt;\\delta&gt;0</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">The implicit PoS in a single instance of Basic-VDE-PoRep is a graph labeling PoS on a disconnected graph on <span class="math">N</span>, with <span class="math">V_{C}=[N]</span>, and Chal the uniform distribution over <span class="math">[N]</span>. The cost of placing a single pebble is <span class="math">T</span>, i.e. <span class="math">c(N)=\\Delta=2T</span>, i.e. when the VDE delay <span class="math">\\Delta</span> is set to <span class="math">2T</span>. The random black pebbling game on a disconnected graph on <span class="math">N</span> nodes with <span class="math">V_{C}=[N]</span> is <span class="math">(\\gamma,1,\\gamma)</span>-parallel-hard for any <span class="math">\\gamma</span> because the challenge node is unpebbled with probability at least <span class="math">1-\\gamma</span> and it requires 1 move/round to pebble an unpebbled challenge node. Since there are no edge dependencies the adversary cannot place any red pebbles, i.e. <span class="math">\\delta=0</span>. Therefore, Claim 8 can actually be strengthened in this case to say the PoS is parallel <span class="math">(\\gamma N,T,\\gamma^{k})</span>-sound. Composition follows from Claim 9. Setting <span class="math">\\gamma=1-\\epsilon+\\delta</span> gives <span class="math">\\mu=(1-\\epsilon+\\delta)^{k}</span>. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Basic-VDE-PoRep with VDE delay parameter <span class="math">\\Delta=2T</span> is <span class="math">e^{-\\lambda}</span>-sound <span class="math">\\epsilon</span>-rational secure when <span class="math">\\ell(\\lambda)=2\\lambda/\\epsilon</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Claim 1 proves condition (b) of Lemma 2 with extractor blowup factor <span class="math">c\\approx 1</span> and Claim 2 proves condition (c) of Lemma 2. Together with the correctness of the construction for an honest prover, these claims therefore establish that Basic-VDE-PoRep is <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational secure for any <span class="math">\\mu&gt;max((1-\\delta)^{\\ell},(1-\\epsilon+\\delta^{\\ell}))</span> and any <span class="math">\\delta&lt;\\epsilon</span>. The maximum value of <span class="math">\\mu</span> is at <span class="math">\\delta=\\epsilon/2</span>, where <span class="math">\\mu=(1-\\epsilon/2)^{\\ell}</span>. If <span class="math">\\ell=\\frac{2\\lambda}{\\epsilon}</span> then <span class="math">(1-\\frac{\\epsilon}{2})^{\\ell}=(1-\\frac{\\epsilon}{2})^{2\\lambda/\\epsilon}&lt;e^{-\\lambda}</span>. ∎</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Claim 3.</h6>

    <p class="text-gray-300">DRG-PoRep is a (PRAM strongly) <span class="math">\\mu</span>-sound <span class="math">(1-\\delta)</span>-PoRC for any <span class="math">\\mu&gt;(1-\\delta)^{\\ell_{2}(\\kappa)}+\\text{negl}(\\lambda)</span> with constant additive PRAM extractor blowup.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We similarly claim that the implicit PoRC protocol of DRG-PoRep is a PoRC from vector commitments with the security parameter <span class="math">\\ell_{2}(\\kappa)</span> determining the number of challenges. Here the vector commitment explicitly uses a vector commitment scheme <span class="math">\\mathsf{VC}</span> as an abstract primitive. The commitment is <span class="math">(\\tau_{D},com_{R},N)</span> where <span class="math">com_{R}</span> is a vector commitment to the replica <span class="math">R</span> consisting of labels on the DRG nodes. The opening advice for an index <span class="math">i</span> is the label <span class="math">R_{i}=c_{i}</span> on the <span class="math">i</span>th node along with the key <span class="math">k_{i}</span> derived from the parent labels. The opening value <span class="math">d_{i}</span> is then computed as <span class="math">\\mathsf{VDE.Dec}(c_{i}\\oplus k_{i})=d_{i}</span> and the opening to <span class="math">d_{i}</span> is then checked by querying the oracle on <span class="math">\\mathsf{O}_{\\text{check}}(\\tau_{d},i,D,\\mathsf{aux})</span>. Additionally the opening value <span class="math">R_{i}</span> is verified against <span class="math">com_{R}</span> using the <span class="math">\\mathsf{VC}</span> functionality. Correctness is immediate and binding follows from the assumption that <span class="math">\\mathcal{O}_{\\text{check}}</span> is position binding and the security properties of <span class="math">\\mathsf{VC}</span> (i.e. it is also position binding). The opening advice is contained in the “online proof” <span class="math">\\Lambda_{\\text{ret}}</span>. Note that PoRep.Verify also runs a verification procedure on <span class="math">\\mathsf{aux}</span> (this is important for the PoS property), however this is not necessary for the PoRC verification and can be ignored for the purpose of showing that this is a PoRC. Finally the claim follows from Theorem 3. ∎</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Claim 4.</h6>

    <p class="text-gray-300">The composition of <span class="math">k</span> instances of DRG-PoRep on distinct ids <span class="math">id_{1},...,id_{k}</span> is a parallel <span class="math">((1-\\epsilon+\\delta)kN,2T,\\mu)</span>-sound PoS for <span class="math">\\mu=max\\{(1-\\delta)^{\\ell_{1}(\\lambda)},(1-\\epsilon+\\alpha+2\\delta)^{\\ell_{2}(\\lambda)}\\}</span> for any <span class="math">\\delta&gt;0</span> when the graph used is an <span class="math">(N,\\alpha,\\beta)</span> DRG and the delay parameter is <span class="math">\\Delta=2T/(\\beta N-1)</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The implicit PoS protocol of each instance of DRG-PoRep is the generic graph labeling PoS on a <span class="math">(N,\\alpha,\\beta)</span> depth robust graph. By Lemma 4, the graph labeling PoS on a family <span class="math">G(N)</span> of <span class="math">(N,\\alpha,\\beta)</span> depth robust graphs with labeling cost function <span class="math">c(N)</span> is an <span class="math">(\\gamma n,(\\beta N-1)c(N),max\\{(1-\\delta)^{\\ell_{1}},(\\alpha+\\gamma+\\epsilon)^{\\ell_{2}}\\}</span>-parallel-sound PoS for any <span class="math">\\delta&lt;1</span>. Setting <span class="math">\\gamma=1-\\epsilon+\\delta</span> gives <span class="math">\\mu=max((1-\\delta)^{\\ell_{1}(\\lambda)},(1-\\epsilon+2\\delta+\\alpha)^{\\ell_{2}(\\kappa)})</span>. For simplicity we set <span class="math">\\lambda=\\kappa</span> (recall the distinction was to heuristically allow for different levels of security for online vs. offline proofs). Finally, the pebbling cost is</p>

    <p class="text-gray-300"><span class="math">c(N)=2T</span> when the VDE delay parameter <span class="math">\\Delta=2T/(\\beta N-1)</span>. Moreover, this PoS is secure under composition (Lemma 4).</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">DRG-PoRep on an <span class="math">(N,\\alpha,\\beta)</span> DRG and with VDE delay parameter <span class="math">\\Delta=2T/(\\beta N-1)</span> is <span class="math">e^{-\\lambda}</span>-sound <span class="math">\\epsilon</span>-rational secure when <span class="math">\\ell_{1}&lt;\\ell_{2}</span> and <span class="math">\\ell_{1}(\\lambda)=\\lambda/\\delta</span> and <span class="math">\\ell_{2}(\\lambda)=\\lambda/(\\epsilon-\\alpha-2\\delta)</span> for any <span class="math">0&lt;\\delta&lt;(\\epsilon-\\alpha)/2</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Claim 1 proves condition (b) of Lemma 2 with extractor blowup factor <span class="math">c\\approx 1</span> and Claim 2 proves condition (c) of Lemma 2. Together with the correctness of the construction for an honest prover, these claims therefore establish that DRG-PoRep is <span class="math">\\mu</span>-sound <span class="math">\\epsilon</span>-rational secure for any:</p>

    <p class="text-gray-300"><span class="math">\\mu&gt;max\\{(1-\\delta)^{\\ell_{2}},(1-\\delta)^{\\ell_{1}},(1-\\epsilon+\\alpha+2\\delta)^{\\ell_{2}})</span></p>

    <p class="text-gray-300">In general for practicality it is desirable that <span class="math">\\ell_{1}</span> is as small as possible, whereas <span class="math">\\ell_{2}</span> may be larger. Therefore, we may assume that <span class="math">\\ell_{1}&lt;\\ell_{2}</span> and can ignore the <span class="math">(1-\\delta)^{\\ell_{2}}</span> term. Finally, setting <span class="math">\\ell_{1}=\\lambda/\\delta</span> and <span class="math">\\ell_{2}=\\lambda/(\\epsilon-\\alpha-2\\delta)</span> yields <span class="math">(1-\\delta)^{\\ell_{1}}&lt;e^{-\\lambda}</span> and <span class="math">(1-\\epsilon+\\alpha+2\\delta)^{\\ell_{2}}&lt;e^{-\\lambda}</span>.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">The parameter <span class="math">\\delta</span> in Theorem 2 allows one to tune the relative size of <span class="math">\\ell_{1}</span> and <span class="math">\\ell_{2}</span> to maintain the same level of security in the parameter <span class="math">\\lambda</span>. Decreasing <span class="math">\\delta</span> increases <span class="math">\\ell_{1}</span> and decreases <span class="math">\\ell_{2}</span>.</p>

    <h2 id="sec-59" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">Joseph Bonneau, Nicola Grecco, and Juan Benet provided critical input throughout the development of this work and are coauthors on a related systems project prototyping practical implementations of PoReps, including the constructions presented at BPASE 2018 and discussed in further detail in this work. Nicola Grecco also helped run the experimental attacks on DRGs presented in Section LABEL:sec:data. Many others have contributed through helpful comments and conversations, including Dan Boneh, Rafael Pass, Ethan Cecchetti, Benedikt Bünz, and Florian Tramer.</p>

    <h2 id="sec-60" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Filecoin: A decentralized storage network. Protocol Labs, 2017. https://filecoin.io/filecoin.pdf.</li>

      <li>[2] Proof of replication. Protocol Labs, 2017. https://filecoin.io/proof-of-replication.pdf.</li>

      <li>[3] Hamza Abusalah, Joël Alwen, Bram Cohen, Danylo Khilko, Krzysztof Pietrzak, and Leonid Reyzin. Beyond hellman’s time-memory trade-offs with applications to proofs of space. In ASIACRYPT, 2017.</li>

      <li>[4] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In ASIACRYPT, pages 191–219, 2016.</li>

      <li>[5] Joël Alwen, Jeremiah Blocki, and Benjamin Harsha. Practical graphs for optimal side-channel resistant memory-hard functions. In CCS, 2017.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[6] Joël Alwen, Jeremiah Blocki, and Krzysztof Pietrzak. Sustained space complexity. In EUROCRYPT, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[7] Frederik Armknecht, Ludovic Barman, Jens-Matthias Bohli, and Ghassan O. Karame. Mirror: Enabling proofs of data replication. In 25th USENIX Security Symposium, 2016.</li>

      <li>[8] Giuseppe Ateniese, Randal Burns, Reza Curtmola, Joseph Herring, Lea Kissner, Zachary Peterson, and Dawn Song. Provable data possession at untrusted stores. In ACM Conference on Computer and Communications Security, 2007.</li>

      <li>[9] Giuseppe Ateniese, Seny Kamara, and Jonathan Katz. Proofs of storage from homomorphic identification protocols. In Asiacrypt, 2009.</li>

      <li>[10] Niko Baríc and Birgit Pfitzmann. Collision-free accumulators and fail-stop signature schemes without trees. In Advances in Cryptology - EUROCRYPT ’97, International Conference on the Theory and Application of Cryptographic Techniques, Konstanz, Germany, May 11-15, 1997, Proceeding, pages 480–494, 1997.</li>

      <li>[11] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In CRYPTO, 2013.</li>

      <li>[12] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. Snarks for C: verifying program executions succinctly and in zero knowledge. In CRYPTO, 2013.</li>

      <li>[13] Josh Cohen Benaloh and Michael de Mare. One-way accumulators: A decentralized alternative to digital sinatures (extended abstract). In EUROCRYPT, 1993.</li>

      <li>[14] Dan Boneh, Joseph Bonneau, Benedikt Bunz, and Ben Fisch. Verifiable delay functions. 2018. To appear in CRYPTO 2018.</li>

      <li>[15] Kevin D. Bowers, Ari Juels, and Alina Oprea. Proofs of retrievability: theory and implementation. In CCSW’09 Proceedings of the 2009 ACM workshop on Cloud computing security), 2009.</li>

      <li>[16] Jan Camenisch and Anna Lysyanskaya. Dynamic accumulators and application to efficient revocation of anonymous credentials. In CRYPTO, 2002.</li>

      <li>[17] Dario Catalano and Dario Fiore. Vector commitments and their applications. In PKC 2013, 2013.</li>

      <li>[18] F.R.K. Chung. On concentrators, superconcentrators, generalizers, and nonblocking networks. In Bell System Technical Journal, 1979.</li>

      <li>[19] Bram Cohen. Proofs of space and time. Blockchain Protocol Analysis and Security Engineering, 2017. https://cyber.stanford.edu/sites/default/files/bramcohen.pdf.</li>

      <li>[20] Moni Naor Cynthia Dwork and Hoeteck Wee. Pebbling and proofs of work. In CRYPTO, 2005.</li>

      <li>[21] Ivan Damgard, Chaya Ganesh, and Claudio Orlandi. Proofs of replicated storage without timing assumptions. Cryptology ePrint Archive, Report 2018/654, 2018. https://eprint.iacr.org/2018/654.</li>

      <li>[22] Anindya De, Luca Trevisan, and Madhur Tulsiani. Time space tradeoffs for attacks against one-way functions and prgs. In CRYPTO, 2010.</li>

      <li>[23] Yevgeniy Dodis, Salil Vadhan, and Daniel Wichs. Proofs of retrievability via hardness amplification. In Theory of Cryptography Conference (TCC), 2009.</li>

      <li>[24] Stefan Dziembowski, Sebastian Faust, Vladimir Kolmogorov, and Krzysztof Pietrzak. Proofs of space. In CRYPTO, 2015.</li>

      <li>[25] Uriel Fiege, Amos Fiat, and Adi Shamir. Zero-knowledge proofs of identity. In Journal of Cryptology, 1988.</li>

    </ul>

    <p class="text-gray-300">[26] Ben Fisch, Joseph Bonneau, Juan Benet, and Nicola Greco. Proofs of replication using depth robust graphs. In Blockchain Protocol Analysis and Security Engineering 2018, 2018. https://cyber.stanford.edu/bpase2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[27] Ben Fisch and Shashwat Silas. Weak compression and (in)security of rational proofs of storage. Cryptology ePrint Archive, Report 2018/514, 2018. https://eprint.iacr.org/2018/514.</li>

      <li>[28] Philippe Golle, Stanislaw Jarecki, and Ilya Mironov. Cryptographic primitives enforcing communication and storage complexity. In Financial Cryptography, 2002.</li>

      <li>[29] Chethan Kamath Vladimir Kolmogorov Krzysztof Pietrzak Joöel Alwen, Binyi Chen and Stefano Tessaro. On the complexity of scrypt and proofs of space in the parallel random oracle model. In EUROCRYPT, 2016.</li>

      <li>[30] Ari Juels and Burton S Kaliski Jr. Pors: Proofs of retrievability for large files. In Proceedings of the 14th ACM conference on Computer and communications security, pages 584–597. Acm, 2007.</li>

      <li>[31] Arjen K Lenstra and Benjamin Wesolowski. A random zoo: sloth, unicorn, and trx. IACR Cryptology ePrint Archive, 2015, 2015.</li>

      <li>[32] Hendrik W Lenstra Jr. Factoring integers with elliptic curves. Annals of mathematics, pages 649–673, 1987.</li>

      <li>[33] Sergio Demian Lerner. Proof of unique blockchain storage, 2014. https://bitslog.wordpress.com/2014/11/03/proof-of-local-blockchain-storage/.</li>

      <li>[34] Benoît Libert, Somindu C. Ramanna, and Moti Yung. Functional commitment schemes: From polynomial commitments to pairing-based from simple assumptions. In ICALP, 2016.</li>

      <li>[35] Benoît Libert and Moti Yung. Concise mercurial vector commitments and independent zero-knowledge sets with short proofs. In TCC, 2010.</li>

      <li>[36] Mohammad Mahmoody, Tal Moran, and Salil P Vadhan. Time-lock puzzles in the random oracle model. In CRYPTO. Springer, 2011.</li>

      <li>[37] Ueli Maurer. Unifying proofs of knowledge. In CRYPTO, 2009.</li>

      <li>[38] Ueli Maurer, Renato Renner, and Clemens Holenstein. Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology. In TCC, 2004.</li>

      <li>[39] S. Matthew Weinberg Miles Carlsten, Harry Kalodner and Arvind Narayanan. On the instability of bitcoin without the block reward. In ACM CCS, 2016.</li>

      <li>[40] Tal Moran and Ilan Orlov. Rational Proofs of Space-Time. Cryptology ePrint Archive # 2016/035, 2016.</li>

      <li>[41] Salil Vadhan Omer Reingold and Avi Wigderson. Entropy waves, the zig-zag graph product, and new constant-degree expanders and extractors. In FOCS, 2000.</li>

      <li>[42] Sunoo Park, Krzysztof Pietrzak, Albert Kwon, Joël Alwen, Georg Fuchsbauer, and Peter Gai. Spacemint: A cryptocurrency based on proofs of space. Cryptology ePrint Archive, Report 2015/528, 2015. http://eprint.iacr.org/2015/528.</li>

      <li>[43] Ronald L. Graham Paul Erdös and Endre Szemeredi. On sparse graphs with dense long paths. In Computers & Mathematics with Applications, 1975.</li>

      <li>[44] Daniele Perito and Gene Tsudik. Secure code update for embedded devices via proofs of secure erasure. In ESORICS, 2010.</li>

      <li>[45] Krzysztof Pietrzak. Proofs of Catalytic Space. Cryptology ePrint Archive # 2018/194, 2018.</li>

      <li>[46] Ling Ren and Srinivas Devadas. Proof of space from stacked expanders. In TCC, 2016.</li>

      <li>[47] Randal Burns Reza Curtmola, Osama Khan and Giuseppe Ateniese. Mr-pdp: Multiple-</li>

    </ul>

    <p class="text-gray-300">replica provable data possession. In In Distributed Computing Systems, 2008. ICDCS08., 2008.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[48] Hovav Shacham and Brent Waters. Compact proofs of retrievability. In Asiacrypt, 2008.</li>

      <li>[49] Luca Trevisan, Salil Vadhan, and David Zuckerman. Compression of samplable sources. Computational Complexity, 14(3):186–227, 2005.</li>

      <li>[50] Leslie G. Valiant. Graph-theoretic arguments in low-level complexity. In Mathematical Foundations of Computer Science, 1977.</li>

      <li>[51] Marten van Dijk, Ari Juels, Alina Oprea, Ronald L. Rivest, Emil Stefanov, and Nikos Triandopoulos. Hourglass schemes: how to prove that cloud files are encrypted. In ACM CCS, 2012.</li>

      <li>[52] Gaven J. Watson, Reihaneh Safavi-Naini, Mohsen Alimomeni, Michael E. Locasto, and Shivaramakrishnan Narayan. Lost: location based storage. In CCSW, 2012.</li>

    </ul>

    <h2 id="sec-61" class="text-2xl font-bold">Appendix A Preliminaries and Background</h2>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">A.1 Compression and Erasure Codes</h3>

    <p class="text-gray-300">A source <span class="math">\\mathcal{S}</span> over <span class="math">\\{0,1\\}^{n}</span> is a distribution over strings in <span class="math">\\{0,1\\}^{n}</span>. Encoding schemes consist of a pair of algorithms (enc, dec) such that enc maps strings from the support <span class="math">\\mathrm{Sup}(\\mathcal{S})</span> of a source <span class="math">\\mathcal{S}</span> to a code space <span class="math">\\Sigma^{m}</span> over an alphabet <span class="math">\\Sigma</span>, and dec recovers inputs in <span class="math">\\mathrm{Sup}(\\mathcal{S})</span> from codes in <span class="math">\\Sigma^{m}</span>. If <span class="math">\\mathrm{Sup}(\\mathcal{S})=\\{0,1\\}^{n}</span> and the distribution <span class="math">\\mathcal{S}</span> is not relevant to the properties of (enc, dec) then we may just call it an encoding scheme on <span class="math">\\{0,1\\}^{n}</span>. The two types of encoding schemes of interest here are compression and erasure codes, which have opposite goals.</p>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">Erasure codes</h4>

    <p class="text-gray-300">Erasure codes, as the name suggests, can tolerate deletion of a constant fraction of symbols in a code and still recover the encoded data. They are an extreme form of redundant storage.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300">An <span class="math">(r,\\delta)</span> erasure code is an encoding scheme <span class="math">(\\mathsf{enc},\\mathsf{dec})</span> on <span class="math">\\{0,1\\}^{n}</span> to <span class="math">\\Sigma^{n}</span> where <span class="math">n/m=r</span> (called the rate) and for all <span class="math">x\\in\\{0,1\\}^{n}</span> such that <span class="math">\\mathsf{enc}(x)=(w_{1},...,w_{m})</span> the decoding algorithm <span class="math">\\mathsf{dec}</span> can recover <span class="math">x</span> from any <span class="math">(1-\\delta)m</span> symbols in <span class="math">w</span>, i.e. if <span class="math">E\\subset[m]</span> is any <span class="math">\\epsilon m</span> size subset and <span class="math">\\hat{w}=(\\hat{w}_{1},...,\\hat{w}_{m})</span> where <span class="math">\\hat{w}_{i}=\\bot</span> for <span class="math">i\\in E</span> and <span class="math">\\hat{w}_{i}=w_{i}</span> for all <span class="math">i\\not\\in E</span> then <span class="math">\\mathsf{dec}(\\hat{w})=x</span>. A <span class="math">(1-\\delta,\\delta)</span> erasure code is called an optimal rate <span class="math">1-\\delta</span> erasure code.</p>

    <h4 id="sec-65" class="text-lg font-semibold mt-6">Compression schemes</h4>

    <p class="text-gray-300">The goal of compression, in contrast, is to encode the original data source with the smallest possible number of symbols such that the data can still be decoded efficiently (at least with high probability). Often a compression scheme will output codes of variable length depending on the input, however for simplicity the following definitions and facts focus on the special case that all outputs are padded to the same length. Unlike erasure codes, compression schemes are not concerned with structural properties of the code other than its overall length, hence without loss of generality the alphabet is <span class="math">\\Sigma=\\{0,1\\}</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Definition 8 (Compression scheme).</h6>

    <p class="text-gray-300">An <span class="math">(\\mathcal{S},k)</span>-compression scheme for a source <span class="math">\\mathcal{S}</span> over <span class="math">\\{0,1\\}^{n}</span> is an encoding scheme <span class="math">(\\mathsf{enc},\\mathsf{dec})</span> such that <span class="math">\\mathsf{enc}:\\{0,1\\}^{n}\\to\\{0,1\\}^{k}</span> and <span class="math">\\mathsf{dec}(\\mathsf{enc}(s))=s</span> for all <span class="math">s\\in\\mathit{Sup}(\\mathcal{S})</span>.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition 9 (k-Compressible).</h6>

    <p class="text-gray-300">A source <span class="math">\\mathcal{S}</span> is said to be k-compressible (or compressible to <span class="math">k</span> bits) if there exists a <span class="math">(\\mathcal{S},k)</span>-compression and incompressible to <span class="math">k</span> bits otherwise.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By this definition of an <span class="math">(\\mathcal{S},k)</span>-compression scheme it is necessary that <span class="math">k</span> is at least the max entropy of <span class="math">\\mathcal{S}</span>, i.e. $k\\geq\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Sup}(\\mathcal{S})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, because it must uniquely encode every string in the support. A lossy compression scheme compromises on the probability of recovery, but may be able to compress to fewer bits than the max entropy.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 10.</h6>

    <p class="text-gray-300">A <span class="math">\\delta</span>-lossy <span class="math">(\\mathcal{S},k)</span>-compression scheme is an encoding scheme <span class="math">(\\mathsf{enc},\\mathsf{dec})</span> where <span class="math">\\mathsf{enc}:\\{0,1\\}^{n}\\to\\{0,1\\}^{k}</span> and <span class="math">Pr_{s}\\xleftarrow{n}\\mathcal{S}[\\mathsf{dec}(\\mathsf{enc}(s))=s]=1-\\delta</span>. <span class="math">\\mathcal{S}</span> is said to be <span class="math">\\delta</span>-lossy compressible to <span class="math">k</span> bits if and only if such an encoding scheme exists and <span class="math">\\delta</span>-lossy incompressible otherwise.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Randomized compression</h4>

    <p class="text-gray-300">In randomized compression schemes, <span class="math">\\mathsf{enc}</span> and <span class="math">\\mathsf{dec}</span> use an additional entropy source to aid in compression. In the most general case <span class="math">\\mathsf{enc}</span> and <span class="math">\\mathsf{dec}</span> may simply run independent randomized algorithms. More typically, they will share information about a <em>seed</em>, either communicated through the encoding output itself or pre-shared, which we may assume is a uniformly random string <span class="math">\\rho\\xleftarrow{n}\\mathbb{U}_{r}</span> (<span class="math">\\mathbb{U}_{r}</span> denotes the uniform distribution over <span class="math">\\{0,1\\}^{r}</span>). Following the terminology of <em>[27]</em> we distinguish <em>weak</em> and <em>strong</em> randomized compression (similar to weak vs strong randomness extractors). Strong compression stores the seed separately from the compressed data, and is equivalent to compression with shared randomness. Weak compression may entangle the seed and the data in the code in such a way that the decoder can still recover both the data and the seed.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 11 (Weak compression).</h6>

    <p class="text-gray-300">A <span class="math">\\delta</span>-lossy <span class="math">(\\mathcal{S},r,k)</span>-weak compression for a source <span class="math">\\mathcal{S}</span> over <span class="math">\\{0,1\\}^{n}</span> is an encoding scheme <span class="math">(\\mathsf{enc},\\mathsf{dec})</span> such that <span class="math">\\mathsf{enc}:\\{0,1\\}^{r}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{r+k}</span> and <span class="math">Pr_{\\rho}\\xleftarrow{n}\\mathbb{U}_{r,s}\\xleftarrow{n}\\mathcal{S}[\\mathsf{dec}(\\mathsf{enc}(r,s))=(r,s)]=1-\\delta</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Definition 12 (Strong compression).</h6>

    <p class="text-gray-300">A <span class="math">\\delta</span>-lossy <span class="math">(\\mathcal{S},r,k)</span>-strong compression for a source <span class="math">\\mathcal{S}</span> over <span class="math">\\{0,1\\}^{n}</span> is an encoding scheme <span class="math">(\\mathsf{enc},\\mathsf{dec})</span> where <span class="math">\\mathsf{enc}:\\{0,1\\}^{r}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{k}</span> and <span class="math">\\mathsf{dec}:\\{0,1\\}^{r}\\times\\{0,1\\}^{k}\\to\\{0,1\\}^{n}</span> such that <span class="math">Pr_{\\rho}\\xleftarrow{n}\\mathbb{U}_{r,s}\\xleftarrow{n}\\mathcal{S}[\\mathsf{dec}(\\rho,\\mathsf{enc}(\\rho,s))=s]=1-\\delta</span>.</p>

    <p class="text-gray-300">A lossy strong compression scheme can be made lossless for a small decrease in compression <em>[49]</em>. Even strong compression schemes cannot compress a uniformly random data source <em>[22]</em>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Fact 1.</h6>

    <p class="text-gray-300">If there exists a <span class="math">\\delta</span>-lossy <span class="math">(\\mathcal{S},r,k)</span>-strong compression for a source <span class="math">\\mathcal{S}</span> then there exists an <span class="math">(\\mathcal{S},r,k+\\delta(n-k)+1)</span>-strong compression of <span class="math">\\mathcal{S}</span> with no loss.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Fact 2.</h6>

    <p class="text-gray-300">The uniform distribution <span class="math">U_{n}</span> over <span class="math">\\{0,1\\}^{n}</span> is incompressible to <span class="math">n-1</span> bits and <span class="math">\\delta</span>-lossy incompressible to <span class="math">n-\\log(1/\\delta)-1</span>. Likewise, there does not exist a <span class="math">\\delta</span>-lossy <span class="math">(U_{n},r,n-\\log(1/\\delta)-1)</span>-strong compression scheme.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">A.2 Proofs of Retrievability</h3>

    <p class="text-gray-300">A proof-of-retrievability (PoR) is an interactive proof system in which a verifier sends a file <span class="math">F</span> to a prover, retains a compact verification key, and later obtains a compact proof that prover can retrieve <span class="math">F</span> intact. The compactness requirement excludes trivial solutions, such as sending the full file <span class="math">F</span> back to the verifier or requiring the verifier to retain <span class="math">F</span>. They were introduced in <em>[30]</em> and further developed in <em>[15, 23, 48]</em>. The related (weaker) concept of provable-data-possession (PDP) was independently introduced in <em>[8]</em>. Abstractly, these constructions involve two layers of encodings. First an erasure code is applied to the file <span class="math">F</span> to generate <span class="math">\\tilde{F}</span>, which guarantees that <span class="math">F</span> can be decoded from adversarial deletion of an <span class="math">\\epsilon</span> fraction of <span class="math">\\tilde{F}</span>. Next, the</p>

    <p class="text-gray-300">file <span class="math">\\tilde{F}</span> is transformed using a secret-key encoding (essentially a type of authentication code), and the verifier retains the key. The second encoding can be checked through a constant size challenge-response protocol, which the prover will fail if it cannot recover at least a <span class="math">1-\\epsilon</span> fraction of <span class="math">\\tilde{F}</span>. An important security property of PoR is that the verifier can extract and recover the file <span class="math">F</span> through sufficiently many successful challenge-response queries to the prover.</p>

    <p class="text-gray-300">While a standard PoR requires a secret key to verify, there are also constructions that allow for outsourced verification where anyone can verify without knowledge of the secret <em>[30, 48]</em>. We refer to this as a <em>public-key</em> PoR to distinguish it from a <em>private-key</em> PoR that requires a private key for verification. Shacham and Waters <em>[48]</em> construct an efficient public-key PoR (from CDH in bilinear groups) using the homomorphic properties of BLS signatures. Their construction was generalized to rely on a broader class of homomorphic linear authenticators <em>[9]</em>. This property has been described as “public verifiability”, however these proofs still rely on a private-key client to privately preprocess the file. If the prover and client collude then the proof does not demonstrate anything meaningful to a third party observer.</p>

    <p class="text-gray-300">A Merkle commitment (i.e. a Merkle tree over the blocks of the file) can be be used to construct a simple, albeit less efficent, publicly verifiable PoR <em>[30]</em>. The verifier need only retain the Merkle commitment root. To verify that the prover is still storing a <span class="math">(1-\\epsilon)</span> fraction of the committed file blocks it queries for a randomly selected constant number of blocks. The prover then responds with the blocks and Merkle inclusion proofs for each. This public PoR is keyless, which is an important difference from the public PoR of Shacham and Waters. For example, it can be used to give a publicly verifiable proof-of-retrievability of a committed file, where the even the prover itself sets up the commitment. We present this as a standalone primitive and describe a generalized construction using vector commitments.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">A.3 Vector Commitments</h3>

    <p class="text-gray-300">A vector commitment (VC) <em>[17, 35]</em> is a cryptographic commitment to an ordered sequence of <span class="math">m</span> values <span class="math">(x_{1},...,x_{m})</span> that admits succinct openings at specific positions (e.g., prove that <span class="math">x_{i}</span> is the <span class="math">i</span>-th committed message). For security, VCs are required to satisfy <em>position binding</em>, which states that an adversary should not be able to open a commitment to two different values at the same position. Moreover, VCs are required to be <em>concise</em>, i.e. the size of the commitment string and of its openings is independent of the vector length. Usually VCs are also required to be hiding, meaning that opening at several positions does not leak any information about the committed values at other positions. A Merkle tree is an example of a simple vector commitment that is binding and concise but not hiding. The main drawback of Merkle commitments are that proofs are of size <span class="math">\\lambda\\log_{2}m</span> bits where <span class="math">m</span> is the length of the vector and <span class="math">\\lambda</span> is the length of the hash output (e.g. <span class="math">\\lambda=256</span> for collision resistance).</p>

    <p class="text-gray-300">Catalano and Fiore <em>[17]</em> gave several constructions of vector commitments achieving both hiding and constant size openings, one from RSA and the other from CDH over bilinear groups. These were further improved upon in <em>[34]</em>. The main drawback of these constructions are the size of the public parameters, which are linear in the length of the vectors. As noted in <em>[17]</em>, the RSA-based vector commitment can be modified to reduce the size of the public parameters, but at the expense of a significant increase in verification work.</p>

    <p class="text-gray-300">Cryptographic accumulators <em>[10, 13]</em> give constant size commitments to a set of elements with constant size inclusion proofs of a single element, however they do not yield a vector commitment (i.e. commitment to an ordered set) with efficient inclusion proof at a specified index. This is</p>

    <p class="text-gray-300">due the fact that they are not naturally binding to an element at a particular index—the natural idea of prepending an index to each element inserted does not preclude inserting more than one element with the same prepended index.</p>

    <h2 id="sec-76" class="text-2xl font-bold">Vector commitment syntax</h2>

    <p class="text-gray-300">We provide a redacted syntax for vector commitments (omitting functionality for updating commitments) and allowing for batched openings.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VC.Setup(1^λ, n, ℳ) → pp Given security parameter λ, length n of the vector, and message space of vector components ℳ, output public parameters pp, which are implicit inputs to all the following algorithms.</li>

      <li>VC.Com(¬m) → τ, c Given an input ¬m = (m1, ..., mn) output a commitment c and advice τ.</li>

      <li>VC.Open(¬m, c, S, τ) → Λ_S On input ¬m, a vector of indices S, the commitment c, and advice τ output an opening Λ_S that proves m_i is the ith committed element of c for all S[i] (where S[i] denotes the ith element of S).</li>

      <li>VC.Verify(c, m1', ..., mq', S, Λ_S) → 0/1 On input commitment c, a vector S of indices in [n], and an opening proof Λ_S output 1 (accept) if and only if Λ_S is a valid proof that c is a commitment to a vector ¬m such that m_S[j] = m_j' for j ∈ [q]. If S = ∅ then Λ should be a normal opening, i.e. proof that c is a commitment to m s.t. m_i = m_i' for all i (and q = n).</li>

    </ol>

    <h2 id="sec-77" class="text-2xl font-bold">Binding commitments</h2>

    <p class="text-gray-300">The main security property of vector commitments (of interest in the present work) is position binding. The security game augments the standard binding commitment game</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 13.</strong> A vector commitment scheme VC is position binding if for all O(poly(λ, n)-time adversaries ℳ and for all S', S ⊆ [n] with</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q' and i ∈ [q], j ∈ [q'] the following probability is at most negligible in λ:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">Pr \\left[ \\begin{array}{c c} \\text{VC.Verify}(c, \\vec{m}, S, \\Lambda) = 1 \\wedge \\text{VC.Verify}(c, \\vec{m}&#x27;, S&#x27;, \\Lambda&#x27;) = 1 &amp;amp; \\text{pp} \\leftarrow \\text{VC.Setup}(1^{\\lambda}, n, \\mathcal{M}) \\\\ \\wedge S[i] = S&#x27;[j] \\wedge m_i \\neq m_j&#x27; &amp;amp; (c, \\vec{m}, \\vec{m}&#x27;, \\Lambda, \\Lambda&#x27;) \\leftarrow \\mathcal{A}(pp) \\end{array} \\right]</span></div>

    <h2 id="sec-78" class="text-2xl font-bold">A.4 Proof of Retrievable Commitment</h2>

    <p class="text-gray-300">We describe here a primitive that we call a proof of retrievable commitment (PoRC), or alternatively a keyless PoR, which allows a prover to give a compact proof of retrievability for a committed value. Similar to a public PoR, the proof verification algorithm does not take a private key. However, it additionally does not involve any private-key preprocessing of the file. Therefore, unlike public-key PoRs where the verification may only be outsourceable, PoRs are truly publicly verifiable: a PoRC is a standard PoR to any verifier that is first given the opening of the commitment (to a particular file) and retains the commitment as a tag. Indeed the concepts of a PoRC and keyless PoR are roughly equivalent, as any keyless PoR must involve a keyless data extractor, implying that it can be used as a binding commitment scheme (where opening is through extraction).²⁰ A PoRC is also similar to a succinct proof of knowledge (PoK),</p>

    <p class="text-gray-300">²⁰ This has also been referred to as a PoR with public extraction in [48].</p>

    <p class="text-gray-300">or SNARK [11], of a committed value. The difference lies still in the type of extraction, which unlike knowledge extraction does not require reading the prover's internal state.</p>

    <p class="text-gray-300">The notion of a PoRC was already implicit in the literature on proofs of retrievability, a simple example being the PoR from Merkle commitments suggested by [30], although a formal presentation and proof of security was not given therein. We present a more general construction of PoRC from any vector commitment scheme and provide a formal proof of security.²¹</p>

    <h2 id="sec-79" class="text-2xl font-bold">A.4.1 PoRC Syntax and Definitions</h2>

    <p class="text-gray-300">Our syntax for a PoRC with a message space <span class="math">\\mathcal{M} \\subseteq \\{0,1\\}^n</span> is as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRC.Setup <span class="math">(1^{\\lambda}, \\mathcal{M}) \\to pp, \\mathcal{M}</span> on input security parameter <span class="math">\\lambda</span> and message space <span class="math">\\mathcal{M}</span> output public parameters <span class="math">pp</span>.</li>

      <li>PoRC.Commit <span class="math">(pp, m) \\to com, \\Lambda, \\alpha</span> on input <span class="math">pp</span> and a message <span class="math">m \\in \\mathcal{M}</span> outputs a binding commitment <span class="math">com</span> to the message <span class="math">m</span> along with an opening hint <span class="math">\\Lambda</span> and additional advice <span class="math">\\alpha</span> for the prover.</li>

      <li>PoRC.Open <span class="math">(pp, com, \\Lambda) \\to m</span> opens the commitment <span class="math">com</span> to a message <span class="math">m \\in \\mathcal{M} \\cup \\bot</span> given the opening hint <span class="math">\\Lambda</span>. The output is <span class="math">\\bot</span> if and only if <span class="math">\\Lambda</span> is an invalid opening.</li>

      <li>PoRC.Prove <span class="math">(pp, \\alpha, com, c) \\to \\pi</span> is a proof generation algorithm that takes <span class="math">pp</span>, the storage advice <span class="math">\\alpha</span>, the commitment <span class="math">com</span>, a challenge <span class="math">c</span> (from either the verifier or possibly a public source) and outputs a proof <span class="math">\\pi</span>.</li>

      <li>PoRC.Verify <span class="math">(pp, com, c, \\pi) \\to 0/1</span> receives <span class="math">pp</span>, the commitment <span class="math">com</span>, challenge <span class="math">c</span>, and proof <span class="math">\\pi</span> and outputs either 1 (accept) or 0 (reject).</li>

    </ol>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">PoRC protocol</h3>

    <p class="text-gray-300">We define the PoRC interactive protocol between a prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. The PoRC interactive protocol as we define it here is public coin, but could be expanded to allow for private coin protocols as well. First <span class="math">\\mathcal{P}</span> runs PoRC.Commit <span class="math">(pp, m)</span>, sends the output <span class="math">com</span> to the verifier, and stores both the opening hint <span class="math">\\Lambda</span> and additional advice <span class="math">\\alpha</span>. Next <span class="math">\\mathcal{V}</span> samples a random challenge <span class="math">c</span> and sends this to <span class="math">\\mathcal{P}</span>. Finally, <span class="math">\\mathcal{P}</span> runs PoRC.Prove <span class="math">(pp, \\alpha, com, c)</span> and sends the output <span class="math">\\pi</span> to <span class="math">\\mathcal{V}</span>, who runs PoRC.Verify <span class="math">(pp, com, c, \\pi)</span> and outputs its decision <span class="math">0/1</span>. Note that PoRC.Open is not used in the protocol, but its existence (satisfying a message binding property) is necessary for security. Furthermore, a verifier may use PoRC.Open to obtain an opening of the commitment at any point, or alternatively its description (e.g. in order to verify a zero-knowledge proof of some property of the message).</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">Correctness</h3>

    <p class="text-gray-300">For a PoRC to be correct we require the commitment <span class="math">com</span> to be compact, i.e. logarithmic in the length of <span class="math">m</span>. Furthermore, in the PoRC interactive protocol with an honest prover and verifier (for any <span class="math">m \\in \\mathcal{M}</span>) should output 1 (accept) with probability 1. (We omit further formalism as this is standard).</p>

    <p class="text-gray-300">²¹ Our proof is a straightforward coupon collector’s argument, following the same proof technique from [48] and [23]. The reason the proof is non-trivial to begin with arises from the fact that all challenges are given to the prover in parallel (rather than sequentially) to amplify soundness. This is more broadly connected to direct product theorems in hardness amplification. In fact, Lemma 1 follows from a more general and previously known result (Lemma 7 of [23]), however we still include our own analysis in the special setting of PoRC from vector commitments, both for completeness of presentation and the benefit of the reader.</p>

    <p class="text-gray-300">42</p>

    <p class="text-gray-300">Soundness The PoRC soundness property is more subtle and has two components: commitment binding and retrievability. These properties are intertwined as together they say that for any admissible prover (loosely one that is sufficiently successful) there exists an extraction process that extracts a message <span class="math">m</span> unique to the commitment <span class="math">com</span>.</p>

    <p class="text-gray-300">The first requirement is that PoRC.Commit/PoRC.Open is a binding commitment scheme in the standard sense:</p>

    <p class="text-gray-300">Definition 14. A PoRC scheme is binding if for all <span class="math">O(poly(\\lambda))</span> adversaries <span class="math">\\mathcal{A}</span> the probability over <span class="math">pp \\gets \\text{PoRC.Setup}(\\lambda, \\mathcal{M})</span> and <span class="math">(\\Lambda, \\Lambda&#x27;, c^<em>) \\gets \\mathcal{A}(pp)</span> and <span class="math">m \\gets \\text{PoRC.Open}(pp, c^</em>, \\Lambda)</span> and <span class="math">m&#x27; \\gets \\text{PoRC.Open}(pp, c^*, \\Lambda&#x27;)</span> that <span class="math">m&#x27; \\neq m \\neq \\bot</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Next we define retrievability. Intuitively, the desired property is that any adversary who is able to produce a commitment <span class="math">com</span>, open this commitment to a value <span class="math">m</span> (e.g. for a client), and then succeed with non-negligible probability in the PoRC protocol with a public verifier must still be able to retrieve the value <span class="math">m</span>, i.e. there is an extractor that can run the prover on public verifier challenges in order to uniquely extract the same value <span class="math">m</span>. We define a game played between an adversary <span class="math">\\mathcal{A} = (A_1, A_2)</span> and a challenger which essentially just runs the public-coin PoRC protocol. The game is simpler than the PoR games in [23, 48] because of our restriction to a public coin verifier. The game is parametrized by input <span class="math">m \\in \\mathcal{M}</span> and public parameters <span class="math">pp</span> and runs as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A_{1}</span> on input <span class="math">pp</span> and <span class="math">m</span> outputs a message <span class="math">com^{<em>}</span> (adversarial commitment) along with <span class="math">\\alpha^{</em>}, \\Lambda^{<em>}</span>. It passes <span class="math">\\alpha^{</em>}</span> to <span class="math">A_{2}</span> and sends <span class="math">com^{<em>}, \\Lambda^{</em>}</span> to the challenger. The challenger runs <span class="math">m^{<em>} \\gets \\text{PoRC.Open}(pp, com^{</em>}, \\Lambda)</span>. If <span class="math">m^{*} \\neq m</span> then the challenger outputs 0 and terminates the game.</li>

      <li>The challenger samples a challenge <span class="math">c</span> uniformly at random from the domain of challenges and sends this to <span class="math">A_{2}</span>.</li>

      <li><span class="math">A_{2}</span> (running on <span class="math">c</span>, <span class="math">\\alpha^{<em>}</span>, and <span class="math">com^{</em>}</span>) outputs an adversarial proof <span class="math">\\pi^{*}</span>.</li>

      <li>The challenger computes <span class="math">b \\gets \\text{PoRC.Verify}(pp, com^{<em>}, c, \\pi^{</em>})</span> and outputs <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300">For any <span class="math">m \\in \\mathcal{M}</span> we denote the challenger's output in the game as a probability distribution <span class="math">\\text{PoRC-Exp}(\\mathcal{A}, m, pp)</span> over the randomness of <span class="math">\\mathcal{A}</span>, the challenger's queries, and <span class="math">pp \\gets \\text{PoRC.Setup}(\\lambda, \\mathcal{M})</span>.²²</p>

    <p class="text-gray-300">Definition 15. A PoRC adversary <span class="math">\\mathcal{A}</span> is <span class="math">\\epsilon</span>-admissible on input <span class="math">m</span> if and only if <span class="math">A_{1}</span> outputs <span class="math">com^{<em>}</span> such that <span class="math">\\text{PoRC.Open}(pp, com^{</em>}, \\Lambda) \\neq \\bot</span> with probability <span class="math">1 - \\text{negl}(\\lambda)</span> and <span class="math">\\text{PoRC-Exp}(\\mathcal{A}, m, pp) = 1</span> with probability at least <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">We define a PoRC extractor <span class="math">\\mathcal{E}</span> (akin to the extractor in a proof of knowledge) as an oracle algorithm that is given the output <span class="math">com^{*}</span> of the PoRC adversary <span class="math">\\mathcal{A}</span> and simulate the interaction between the challenger and <span class="math">A_{2}</span>. An important modification is that the extractor can rewind <span class="math">A_{2}</span> and reissue fresh challenges (for further formalism on extractor machines that can rewind adversaries see [25, 37]). The key difference between our extractor and a standard knowledge</p>

    <p class="text-gray-300">²²The adversary in the game is non-adaptive, which at first glance may appear to weaken the adversary. Note that the challenger in the game is entirely public-coin. The adversary can simulate any polynomial number of adaptive rounds of the game in his head before engaging in a final real round with the challenger.</p>

    <p class="text-gray-300">extractor is that it cannot read the internal state or inputs of the adversary in the game, only the power to rewind its randomness. More specifically, in each run of the extractor playing the game <span class="math">\\mathsf{PoRC-Exp}(\\mathcal{A},m,pp)</span> with <span class="math">\\mathcal{A}</span>, it first obtains a commitment <span class="math">c^{<em>}</span> and then repeatedly queries <span class="math">A_{2}</span> (possibly rewinding <span class="math">A_{2}</span> at some points), until it finally outputs either a message <span class="math">m^{</em>} \\in \\mathcal{M}</span> or <span class="math">\\bot</span> (indicating failure). Let <span class="math">m^{*} \\leftarrow \\mathcal{E}^{\\mathcal{A}(m)}(pp)</span> denote the output distribution of this experiment.</p>

    <p class="text-gray-300"><strong>Definition 16.</strong> A PoRC is <span class="math">\\epsilon</span>-sound if it is binding and additionally for every <span class="math">\\lambda</span> there exists a PoRC extractor <span class="math">\\mathcal{E}</span> that runs in time <span class="math">\\text{poly}(\\lambda, n, 1/\\epsilon)</span> such that for any <span class="math">m \\in \\mathcal{M}</span> and any adversary <span class="math">\\mathcal{A}</span> that is <span class="math">\\epsilon</span>-admissible on <span class="math">m</span> the probability over <span class="math">pp \\leftarrow \\text{PoRC.Setup}(\\lambda, \\mathcal{M})</span> and <span class="math">m^{<em>} \\leftarrow \\mathcal{E}^{\\mathcal{A}(m)}(pp)</span> that <span class="math">m^{</em>} \\neq m</span> is at most <span class="math">\\text{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Definition 16 captures that any adversary who passes the PoRC protocol with non-negligible probability at least <span class="math">\\epsilon</span> must be able to retrieve the underlying data by running the extractor in time <span class="math">O(1 / \\mathrm{poly}(\\epsilon))</span> with its own code.²³ If on the other hand the adversary does not pass the PoRC with probability at least <span class="math">\\epsilon</span> then the soundness error of the protocol with this adversary is <span class="math">\\epsilon</span> in the standard sense (i.e. it is caught with probability at least <span class="math">1 - \\epsilon</span>).</p>

    <p class="text-gray-300"><strong>Extractor runtime</strong> Extractors always have a larger runtime complexity than the original adversary <span class="math">\\mathcal{A}</span>. Extractors are considered <em>stronger</em> the smaller this overhead. In our case <span class="math">A_{1}</span> first generates a commitment that is then given to <span class="math">A_{1}</span> (we do not count the runtime of <span class="math">A_{1}</span> on <span class="math">pp</span> as part of the extractor's runtime). We say that the extractor has <em>constant blowup</em> if the runtime is only a constant factor larger than <span class="math">A_{2}</span>. It turns out that the parallel runtime of the PoRC extractor will be highly relevant to the security analysis of PoRep schemes. We say the extractor has <em>constant PRAM blowup</em> if the parallel runtime is only a constant factor larger than the parallel runtime of <span class="math">A_{2}</span>.</p>

    <p class="text-gray-300"><strong>Definition 17.</strong> A PoRC is PRAM strongly <span class="math">\\epsilon</span>-sound if it is <span class="math">\\epsilon</span>-sound and additionally the extractor has constant PRAM blowup.</p>

    <p class="text-gray-300"><strong>Partial retrievability</strong> Sometimes proofs of retrievability can be useful even if they only prove partial recovery, e.g. that a constant fraction of the bits of the message can be retrieved. In fact, all known constructions of PoR effectively first prove partial recovery, which is amplified to a proof of full recovery through erasure coding. The proof of partial recovery itself is more efficient because it does not require blowing up the size of the message. Even if partial recovery is not the end goal it is useful to abstract this as a standalone primitive that can be used as a subcomponent of cryptographic protocol (in our case PoReps).</p>

    <p class="text-gray-300">We define a <span class="math">\\delta</span>-PoRC as a proof that a <span class="math">\\delta</span> fraction of a committed message can be retrieved. We generalize this even further to a <span class="math">(\\delta, \\mathcal{C})</span>-PoRC where <span class="math">\\mathcal{C}</span> is any <em>set cover</em> of the committed message <span class="math">m</span>, each set consisting of bit indices of <span class="math">m</span> (assume w.l.o.g. that <span class="math">m</span> is represented as a bit vector). This is useful when it is important to ensure that the missing fraction of bits isn't completely arbitrary, for example that at least a <span class="math">\\delta</span> fraction of complete message blocks are retrievable. A <span class="math">\\delta</span>-PoRC is equivalent to the special case where the set cover consists of disjoint singleton sets, each containing a single bit of the message.</p>

    <p class="text-gray-300">²³Due to the fact that the extraction algorithm is public, this is stronger than standard knowledge extraction, where only the adversary who generated the adversarial code in the first place necessarily can extract the witness. For instance, the interactive adversary in the protocol may have been given obfuscated code that hides the witness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The security game and extractor for a <span class="math">(\\delta, \\mathcal{C})</span>-PoRC is unchanged from the definition of PoRC and only the definition of <span class="math">\\epsilon</span>-soundness needs to be modified. For any pair of equal length messages $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> and index subset </span>S \\subseteq [n]<span class="math"> let </span>m \\equiv_S m'<span class="math"> denote that </span>m_i = m_i'<span class="math"> for all </span>i \\in S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 18.</strong> A <span class="math">(\\delta, \\mathcal{C})</span> PoRC is <span class="math">\\epsilon</span>-sound if it is binding and additionally for some<span class="math">^{24}</span> <span class="math">\\lambda_{\\epsilon, \\delta} \\in O(\\log \\epsilon / \\log \\delta)</span> and every <span class="math">\\lambda &amp;gt; \\lambda_{\\epsilon, \\delta}</span> there exists an extractor <span class="math">\\mathcal{E}</span> that runs in time <span class="math">\\text{poly}(\\lambda, n, 1 / \\epsilon)</span> such that for any <span class="math">m \\in \\mathcal{M}</span> and any adversary <span class="math">\\mathcal{A}</span> that is <span class="math">\\epsilon</span>-admissible on <span class="math">m</span> the probability over <span class="math">pp \\gets \\text{PoRC.Setup}(\\lambda, \\mathcal{M})</span> and <span class="math">m^<em> \\gets \\mathcal{E}^{\\mathcal{A}(m)}(pp)</span> that <span class="math">m \\equiv_S m^</em></span> for at least a <span class="math">\\delta</span> fraction of the sets <span class="math">S \\in \\mathcal{C}</span> is greater than <span class="math">1 - \\text{negl}(\\lambda)</span>. It is PRAM strongly <span class="math">\\epsilon</span>-sound if <span class="math">\\mathcal{E}</span> has constant PRAM blowup.</p>

    <h2 id="sec-82" class="text-2xl font-bold">A.4.2 PoRC from Vector Commitments</h2>

    <p class="text-gray-300">We describe a construction of a <span class="math">(\\delta, \\mathcal{C})</span>-PoRC for blocked messages of a fixed length consisting of <span class="math">n</span> blocks from a message space <span class="math">\\mathcal{M}</span>, and any set cover <span class="math">\\mathcal{C}</span> consisting of unions of at most <span class="math">O(\\log n)</span> blocks. For applications with variable length commitments we can run the setup for each <span class="math">n = 2^k</span> up to a maximum size. The construction also easily generalizes to set covers consisting of sets that are unions of at most <span class="math">O(\\mathrm{polylog}(n))</span> bit indices, regardless of the block size. We use a vector commitment scheme <span class="math">\\mathsf{VC} = (\\mathsf{VC.Setup}, \\mathsf{VC.Com}, \\mathsf{VC.Open}, \\mathsf{VC.Verify})</span> as a black box.</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">Construction VC-PoRC</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PoRC.Setup(<span class="math">1^{\\lambda}</span>): Run VC.Setup(<span class="math">1^{\\lambda}, n, \\mathcal{M}) \\to pp_{vc}</span>. Output <span class="math">pp</span>.</li>

      <li>PoRC.Commit(<span class="math">pp, m</span>): Parse <span class="math">m</span> as a vector <span class="math">\\vec{m} = (m_1, \\dots, m_n)</span> where <span class="math">m_i \\in \\mathcal{M}</span>. Run VC.Com(<span class="math">\\vec{m}</span>) <span class="math">\\to \\tau, \\text{com}</span>, and output <span class="math">\\tau, \\text{com}</span>.</li>

      <li>PoRC.Prove(<span class="math">pp, \\tau, \\text{com}, c</span>): Let <span class="math">\\mathcal{C} = \\{S_1, \\dots, S_k\\}</span> where each <span class="math">S_i \\subset [n]</span>. Parse <span class="math">c</span> as integers <span class="math">c_1, \\dots, c_\\lambda \\in [k]</span>. Let <span class="math">S = \\bigcup_{i=1}^{\\lambda} S_{c_i}</span>. Run VC.Open(<span class="math">\\vec{m}, c, S, \\tau) \\to \\Lambda</span>. Output the proof <span class="math">\\pi</span> consisting of all <span class="math">\\{m_j\\}</span> for <span class="math">j \\in S</span> and <span class="math">\\Lambda</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. PoRC.Verify(<span class="math">pp, \\text{com}, c, \\pi</span>): On <span class="math">c = c_1, \\dots, c_\\lambda \\in [k]</span> define <span class="math">S = \\bigcup_{i=1}^{\\lambda} S_{c_i}</span>. Parse <span class="math">\\pi = (m_1&#x27;, \\dots, m_\\ell&#x27;, \\Lambda)</span> and output 0 (reject) if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq \\ell<span class="math">. Run VC.Verify(</span>\\text{com}, m_1', \\dots, m_\\ell', S, \\Lambda<span class="math">) (given input </span>S$ as a sorted ordered list) and output the result.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof size</strong> Let <span class="math">s(n, k)</span> denote an upper bound on the size of proofs output by VC.Open for vectors of length <span class="math">n</span> over the message space <span class="math">\\mathcal{M}</span> and index subset of size <span class="math">k</span>. Let <span class="math">k_{max}</span> denote the largest set in <span class="math">\\mathcal{C}</span>. The total proof size output by PoRC.Prove is at most $s(n, \\lambda k_{max}) + \\lambda k_{max} \\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which by definition of VC is asymptotically </span>O(\\lambda \\log^2 n)<span class="math">. For instantiations of VC with constant size openings, i.e. </span>s(n, k) \\in O(\\lambda k)<span class="math">, the proof size is </span>O(\\lambda^2 \\log n)<span class="math">. If VC supports batching the size is brought down to </span>O(\\lambda \\log n)<span class="math">, which is the size of the </span>\\lambda$ sampled sets (i.e. the vector commitment opening proof is no longer the bottleneck).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Correctness</strong> As explained above, the proof size is compact, i.e. at most <span class="math">O(\\lambda \\log^2 n)</span>. An honest prover who stores the input message <span class="math">m</span> is able to pass verification by correctness of the vector commitment scheme VC.</p>

    <p class="text-gray-300"><span class="math">^{24}</span>The definition would still be technically equivalent in an asymptotic sense if it read “for every <span class="math">\\lambda</span>” without further requirement, however the rewording helps to clarify that in general we cannot hope the extractor will succeed for <span class="math">\\epsilon \\leq \\delta^{\\lambda}</span>.</p>

    <p class="text-gray-300">44</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-84" class="text-base font-semibold mt-4">Soundness</h5>

    <p class="text-gray-300">We show that there is an extractor <span class="math">\\mathcal{E}</span> such that <span class="math">\\mathcal{E}^{\\mathcal{A}(m)}(pp)</span> outputs the file <span class="math">m</span> with overwhelming probability for any adversary <span class="math">\\mathcal{A}</span> that is <span class="math">\\epsilon</span>-admissible on <span class="math">m</span>, where <span class="math">\\epsilon&gt;\\delta^{\\lambda}</span> is non-negligible.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">VC-PoRC with security parameter <span class="math">\\lambda</span> is an <span class="math">\\epsilon</span>-sound <span class="math">(\\delta,\\mathcal{C})</span>-PoRC for any <span class="math">\\epsilon&gt;0</span> such that <span class="math">\\epsilon-\\delta^{\\lambda}&gt;\\text{negl}(\\lambda)</span>.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We define <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> with <span class="math">\\mathcal{A}=(A_{1},A_{2})</span> is given <span class="math">pp</span> from <span class="math">\\textsf{PoRC}.{\\textsf{Setup}}(1^{\\lambda})</span> (sampled in the game <span class="math">\\textsf{PoRC}\\text{-}\\textsf{Exp}(\\mathcal{A},\\lambda)</span>), and the index set cover <span class="math">\\mathcal{C}=\\{S_{1},...,S_{k}\\}</span> and runs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query <span class="math">A_{1}</span> to get <span class="math">com^{*}</span>. Initialize a round counter <span class="math">r=0</span>. Initialize a set <span class="math">D=\\emptyset</span> and initialize a length <span class="math">n</span> vector <span class="math">\\vec{v}=(0,....,0)</span> of <span class="math">0</span>s.</li>

      <li>Increment the counter <span class="math">r:=r+1</span>. Sample a random challenge vector <span class="math">c=(c_{1},...,c_{\\lambda})\\in[k]^{\\lambda}</span> and query <span class="math">A_{2}</span> on <span class="math">c</span> and record the response <span class="math">\\pi_{c}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Run <span class="math">b\\leftarrow\\textsf{PoRC}.{\\textsf{Verify}}(pp,com^{*},c,\\pi_{c})</span>. If <span class="math">b=0</span> do nothing. If <span class="math">b=1</span>, let <span class="math">S=\\bigcup_{i=1}^{\\lambda}S_{c_{i}}</span> and parse <span class="math">\\pi_{c}=(m^{\\prime}_{1},...,m^{\\prime}_{\\ell},\\Lambda)</span> where $\\ell=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (if </span>\\pi_{c}<span class="math"> could not be parsed this way it would have been rejected). Write </span>S<span class="math"> as a sorted list of its elements and for any </span>j\\in[\\ell]<span class="math"> let </span>S[j]<span class="math"> denote the index at the </span>j<span class="math">th position of the sorted list. If any </span>c_{i}\\not\\in D<span class="math"> (for </span>1\\leq i\\leq\\lambda<span class="math">), then update </span>D:=D\\cup\\{c_{i}\\}<span class="math">. For each </span>j\\in[\\ell]<span class="math"> update </span>v_{S[j]}=m^{\\prime}_{j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The extractor’s goal is to obtain components of <span class="math">m</span> for all indices covered by a <span class="math">\\delta</span> fraction of index sets in <span class="math">\\mathcal{C}</span>. Step 3 runs the adversary on a fresh challenge to open <span class="math">com^{*}</span> on all indices of <span class="math">\\lambda</span> sampled sets from <span class="math">\\mathcal{C}</span>. If the adversary passes the challenge (verification succeeds) in Step 3, then by the security of the commitment scheme the extractor obtains the components of <span class="math">m</span> on all these queried indices. The extractor checks off any newly covered index sets and terminates if it has already covered at least a <span class="math">\\delta</span> fraction. Otherwise it repeats (rewinding the adversary to use the same randomness) until the max round is reached. Finally, note that although in the description of <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> runs for <span class="math">r</span> sequential rounds, observe that all the queries to <span class="math">A_{2}</span> (Step 2) are independent of state and thus can be run in parallel. <span class="math">A_{2}</span> is rewound for each query, therefore querying <span class="math">r</span> copies of <span class="math">A_{2}</span> in parallel achieves the same result. The bookkeeping in Step 3 can be run in parallel on the outputs of all these queries.</p>

    <p class="text-gray-300">Lemma 3 proves that the <span class="math">(\\delta,\\mathcal{C})</span>-PoRC from vector commitments is <span class="math">\\epsilon</span>-sound for any <span class="math">\\epsilon&gt;\\delta^{\\lambda}+\\textsf{negl}(\\lambda)</span>. In light of the above remark, the construction is PRAM strongly <span class="math">\\epsilon</span>-sound with only constant <em>additive</em> PRAM blowup. ∎</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Assuming VC is a position binding vector commitment scheme, then for any <span class="math">\\epsilon</span>-admissible <span class="math">\\mathcal{A}</span> where <span class="math">\\epsilon&gt;\\delta^{\\lambda}</span> is non-negligible, the extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> outputs <span class="math">m^{<em>}</span> such that <span class="math">m^{</em>}\\equiv_{S}m</span> for at least a <span class="math">\\delta</span> fraction of index sets <span class="math">S\\in\\mathcal{C}</span> except with probability <span class="math">2^{-\\lambda}</span>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First recall that an <span class="math">\\epsilon</span>-admissible adversary will cause the challenger to output <span class="math">1</span> in Step 1 except with negligible probability.</p>

    <p class="text-gray-300">From here the proof proceeds in two parts. First, we say that <span class="math">\\mathcal{A}=(A_{1},A_{2})</span> is <em>well-behaved</em> if whenever <span class="math">A_{1}</span> passes Step 1 of the game <span class="math">\\textsf{PoRC}\\text{-}\\textsf{Exp}(\\mathcal{A},\\lambda)</span>) (i.e. presents <span class="math">com^{*}</span> and</p>

    <p class="text-gray-300"><span class="math">m=(m_{1},...,m_{n})</span> to the challenger with opening <span class="math">\\Lambda</span> such that <span class="math">\\mathsf{VC.Verify}(com^{<em>},m_{1},...,m_{n},\\Lambda)=1)</span> and <span class="math">A_{2}</span> responds to some query <span class="math">c</span> with a proof <span class="math">\\pi_{c}</span> such that <span class="math">\\mathsf{PoRC.Verify}(pp,com^{</em>},c,\\pi_{c})=1</span> then <span class="math">\\pi_{c}=(m^{\\prime}_{1},...,m^{\\prime}_{\\ell},\\Lambda^{\\prime})</span> and <span class="math">m^{\\prime}_{j}=m_{S[j]}</span> for all <span class="math">j\\in[\\ell]</span>, where <span class="math">S=\\bigcup_{i=1}^{\\lambda}S_{c_{i}}</span> (the indices covered by the query <span class="math">c</span>). We claim that <span class="math">\\mathcal{A}</span> is well-behaved except with probability <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Indeed if the PoRC verification passes on <span class="math">\\pi_{c}</span> then <span class="math">\\mathsf{VC.Verify}(com^{<em>},m^{\\prime}_{1},...,m^{\\prime}_{\\ell},S,\\Lambda^{\\prime})=1</span>. If <span class="math">m^{\\prime}_{j}\\neq m_{S[j]}</span> on some <span class="math">j</span> then <span class="math">com^{</em>},m^{\\prime},\\Lambda^{\\prime},m,\\Lambda</span> is an opening collision of the vector commitment scheme. If this happens with non-negligible probability (conditioned on <span class="math">A_{1}</span> passing Step 1), then because by hypothesis <span class="math">A_{1}</span> passes Step 1 at least with non-negligible probability <span class="math">\\epsilon</span>, we can use <span class="math">\\mathcal{A}</span> to break the position binding of <span class="math">\\mathsf{VC}</span> with non-negligible probability, a contradiction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the second part we assume that <span class="math">\\mathcal{A}</span> is well-behaved. Queries <span class="math">c</span> for which <span class="math">A_{2}</span> passes verification are “good” queries, and all other queries are “bad” queries. Consider any iteration of the extractor where <span class="math">D\\subset[n]</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\delta k<span class="math">. If the extractor asks a “good” query </span>c=(c_{1},...,c_{\\lambda})<span class="math"> such that </span>c_{w}\\not\\in D<span class="math"> for some </span>w\\in\\lambda<span class="math">, then in Step 3 it adds </span>c_{w}<span class="math"> to </span>D<span class="math"> increasing the size by (at least) 1. Furthermore, because </span>\\mathcal{A}<span class="math"> is well-behaved the extractor updates </span>v_{S[j]}=m^{\\prime}_{j}=m_{S[j]}<span class="math"> for each index </span>S[j],j\\in\\ell<span class="math"> covered by the query. Thus at the end of each round, for any </span>i\\in D<span class="math"> the vector </span>v<span class="math"> is identical to </span>m<span class="math"> on all indices in </span>S_{i}<span class="math">, i.e. </span>v\\equiv_{S_{i}}m<span class="math">. If the extractor asks a “bad” query or a query that does not hit any new sets, i.e. </span>c_{w}\\in D<span class="math"> for all </span>w\\in[\\lambda]<span class="math">, then the size of </span>D<span class="math"> does not increase in this round. The query is “bad” with at most probability </span>1-\\epsilon<span class="math"> and since each </span>c_{w}<span class="math"> is uniformly sampled from </span>[k]<span class="math"> the latter occurs with probability at most </span>\\delta^{\\lambda}<span class="math">. Thus, by a union bound, in each round the size of </span>D<span class="math"> increases by 1 with probability at least </span>1-(1-\\epsilon+\\delta^{\\lambda})=\\epsilon-\\delta^{\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">r</span> denote the total number of rounds, and let <span class="math">X_{i}</span> for <span class="math">1\\leq i\\leq r</span> be an indicator random variable such that <span class="math">X_{i}=1</span> if either $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> increases in the </span>i<span class="math">th round or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\delta k<span class="math"> by the </span>i<span class="math">th round. Above we established that </span>Pr[X_{i}=1]\\geq p=\\epsilon-\\delta^{\\lambda}<span class="math">. The size of </span>D<span class="math"> after </span>r<span class="math"> rounds is at least </span>min(\\sum X_{i},\\delta k)<span class="math">. Thus it suffices to establish that </span>\\sum X_{i}\\geq\\delta k<span class="math"> with probability at least </span>1-2^{-\\lambda}<span class="math">. The variables </span>X_{i}<span class="math"> are not independent so we cannot immediately apply the Chernoff-Hoeffding bound. However due to the fact that </span>Pr[X_{i}]\\geq p<span class="math"> conditioned on any values of </span>X_{1},...,X_{i-1}<span class="math">, if we define independent </span>0/1<span class="math"> variables </span>Z_{1},...,Z_{r}<span class="math"> such that </span>Pr[Z_{i}=1]=p<span class="math"> for all </span>i<span class="math">, then it follows that </span>Pr[\\sum_{i}X_{i}\\leq\\delta k]\\leq Pr[\\sum_{i}Z_{i}\\leq\\delta k]<span class="math">. Finally, setting </span>r\\geq(2\\delta k/p)<span class="math"> and the Chernoff-Hoeffding bound then implies: </span>Pr[\\sum_{i}Z_{i}\\leq\\delta k]\\leq Pr[\\sum_{i}Z_{i}\\leq rp/2]<2e^{-rp^{2}/2}<span class="math">. Finally we can choose </span>r<span class="math"> such that </span>rp^{2}/2\\geq\\lambda+1<span class="math">. Finally, to satisfy both conditions we set </span>r\\geq max(2\\delta k/p,2(\\lambda+1)/p^{2})<span class="math">, e.g. </span>r=2\\delta k(\\lambda+1)/p^{2}=2\\delta k(\\lambda+1)/(\\epsilon-\\delta^{\\lambda})^{2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-89" class="text-xl font-semibold mt-8">A.5 Verifiable Delay Encodings</h3>

    <p class="text-gray-300">A <em>verifiable delay encoding</em> (VDE) is an encoding that is slow to compute yet fast to decode. The encoding requires non-parallelizable sequential work to evaluate and therefore in theory cannot be computed in shorter than some minimum wall-clock time. A VDE is a special case of a <em>verifiable delay function</em> recently introduced in <em>[14]</em>. Practical (heuristic) examples of VDEs include Sloth <em>[31]</em>, MiMC <em>[4]</em>, and a special class of permutation polynomials <em>[14]</em>.</p>

    <p class="text-gray-300">Formally, a VDE is a tuple of three algorithms <span class="math">\\mathsf{VDE}=\\mathsf{VDE.Setup},\\mathsf{VDE.Enc},\\mathsf{VDE.Dec}</span> defined as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{VDE.Setup}(t,\\lambda)\\to pp</span> is given security parameter <span class="math">\\lambda</span> and delay parameter <span class="math">t</span> produce public parameters <span class="math">\\mathbf{pp}</span>. By convention, the public parameters also specify an input space <span class="math">\\mathcal{X}</span> and a code space <span class="math">\\mathcal{Y}</span>. We assume that <span class="math">\\mathcal{X}</span> is efficiently samplable. <span class="math">\\mathsf{VDE.Setup}</span> might need secret randomness, leading to a scheme requiring a trusted setup.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>VDE.Enc <span class="math">(pp, x) \\to y</span> takes an input <span class="math">x \\in \\mathcal{X}</span> and produces an output <span class="math">y \\in \\mathcal{Y}</span>.</li>

      <li>VDE.Dec <span class="math">(pp, y) \\to x</span> takes an input <span class="math">y \\in \\mathcal{Y}</span> and produces an output <span class="math">x \\in \\mathcal{X}</span>.</li>

    </ol>

    <p class="text-gray-300">Correctness For all <span class="math">pp</span> generated by VDE.Setup <span class="math">(\\lambda, t)</span> and all <span class="math">x \\in \\mathcal{X}</span>, algorithm VDE.Enc <span class="math">(pp, x)</span> must run in parallel time <span class="math">t</span> with <span class="math">\\mathrm{poly}(\\log(t), \\lambda)</span> processors, and VDE.Dec <span class="math">(pp, \\mathrm{VDE.Enc}(pp, x)) = x</span> with probability 1.</p>

    <p class="text-gray-300">Parallelism The practical significance of allowing <span class="math">\\mathrm{poly}(\\log(t), \\lambda)</span> parallelism in VDE.Enc is that any implementation must have this much parallelism in order to evaluate within the delay time <span class="math">t</span>. The security property of a VDE will bound the success probability of an adversary running in less than time <span class="math">t</span>. If the construction demands VDE.Enc to use a significant amount of parallelism to complete in a time <span class="math">t</span> for which this sequentiality bound holds (i.e. the adversary cannot gain further speedup) then it may only be useful for applications where the "honest" evaluators have this much parallelism available. Constructions that do not require any parallelism to evaluate VDE.Enc in the optimal number of sequential steps are obviously superior. However, it is unlikely that such constructions exist (without trusted hardware). In fact, it is necessary that <span class="math">\\mathcal{Y} &amp;gt; \\mathrm{poly}(t)</span> (otherwise the output can be guessed and checked quickly using VDE.Dec) and hence the challenge inputs have size <span class="math">\\mathrm{poly}\\log(t)</span>. Therefore, at a minimum we must allow up to <span class="math">\\mathrm{poly}\\log(t)</span> parallelism. In practice, much of this parallelism may already be taken advantage of by the hardware (e.g. word sizes on modern processors and/or SIMD instructions).</p>

    <h2 id="sec-90" class="text-2xl font-bold">A.5.1 VDE security</h2>

    <p class="text-gray-300">The main security property of a VDE is <span class="math">\\sigma</span>-sequentiality, which characterizes that no adversary running in parallel time significantly less than <span class="math">t</span> is able to compute VDE.Enc on a random input in <span class="math">\\mathcal{X}</span>, even given preprocessing advice.²⁵ This captures an unpredictability property given time constraints on the adversary.</p>

    <p class="text-gray-300">Definition 19 (sequentiality). For a function <span class="math">\\sigma(t)</span> a VDE is <span class="math">\\sigma</span>-sequential if for any pair of randomized algorithms <span class="math">\\mathcal{A}_0</span>, which runs in total time <span class="math">O(\\mathrm{poly}(t, \\lambda))</span>, and <span class="math">\\mathcal{A}_1</span>, which runs in parallel time <span class="math">t - \\sigma(t)</span> on at most <span class="math">O(\\mathrm{poly}(t))</span> processors, the following probability distribution over <span class="math">pp \\gets \\text{VDE.Setup}(t, \\lambda)</span> is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">P r \\left[ \\begin{array}{c c} y \\leftarrow \\mathcal {A} _ {1} (\\alpha , \\mathbf {p p}, x) &amp;amp; x \\stackrel {{\\mathrm {a t c}}} {{\\leftarrow}} \\mathcal {X} \\\\ \\wedge y = \\text {V D E . E n c} (x) &amp;amp; \\alpha \\leftarrow \\mathcal {A} _ {0} (\\lambda , \\mathbf {p p}, t) \\end{array} \\right] &amp;lt;   \\text {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">A second (stronger) property concerns the pseudorandomness of the output. Clearly the output of VDE.Enc on an input <span class="math">x</span> is not indistinguishable from random as we can run VDE.Dec to recover the input, however we may want the property that <span class="math">\\mathsf{Encode}(pp,\\cdot)</span> is indistinguishable from a random permutation (if <span class="math">\\mathcal{X} = \\mathcal{Y}</span>) for <span class="math">pp</span> sampled from the setup, similar to modeling block ciphers as an ideal cipher. We formalize the ideal delay encoding object (for the special case of a permutation) as an oracle in the following definition.</p>

    <p class="text-gray-300">²⁵ Asymptotically <span class="math">t</span> must be subexponential in <span class="math">\\lambda</span>. The reason for this is that the adversary needs to be able to run in time at least <span class="math">t</span>, and if <span class="math">t</span> is exponential in <span class="math">\\lambda</span> then the adversary might be able to break the computational security underlying <span class="math">\\sigma</span>-sequentiality. Of course, if <span class="math">\\sigma</span>-sequentiality is somehow achieved unconditionally then this constraint no longer applies.</p>

    <p class="text-gray-300">47</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Definition 20.</h6>

    <p class="text-gray-300">An ideal delay permutation (IDP) is a family of oracles <span class="math">\\{\\mathcal{O}^{(t)}_{{\\sf IDP}}\\}</span> that implement a random permutation <span class="math">\\Pi</span> and respond to two types of queries. On a query <span class="math">(q,0)</span> the oracle <span class="math">\\mathcal{O}^{(t)}_{{\\sf IDP}}</span> internally simulates <span class="math">t</span> sequential queries to <span class="math">\\Pi^{-1}</span> and then outputs <span class="math">\\Pi(q)</span>. On a query <span class="math">(q,1)</span> it outputs <span class="math">\\Pi^{-1}(q)</span>.</p>

    <h4 id="sec-92" class="text-lg font-semibold mt-6">Indifferentiability on random inputs</h4>

    <p class="text-gray-300">One would hope to instantiate an IDP given oracle access to a random permutation <span class="math">\\Pi</span>, <span class="math">\\Pi^{-1}</span>, and any <span class="math">o(1)</span>-sequential <span class="math">\\sf VDE</span>. A first attempt would be the system <span class="math">\\mathcal{C}</span> which first samples <span class="math">pp\\leftarrow\\sf VDE.Setup(t,\\lambda)</span> for sufficiently large <span class="math">\\lambda</span> and then on input <span class="math">(q,0)</span> returns <span class="math">\\iota(q)=\\Pi(\\sf VDE.Enc(pp,\\Pi(q)))</span> and on input <span class="math">(q,1)</span> returns <span class="math">\\iota^{-1}(q)=\\Pi^{-1}(\\sf VDE.Dec(pp,\\Pi^{-1}(q)))</span>. We would further hope to argue that <span class="math">\\mathcal{C}</span> is <em>indifferentiable</em> from <span class="math">\\mathcal{O}^{(t)}_{{\\sf IDP}}</span> in the sense of Maurer et. al. <em>[38]</em>. Unfortunately, due to the fact that <span class="math">\\Pi</span> used in the construction is necessarily available to the adversary as well, the adversary can choose any value (say <span class="math">0</span>) and query for <span class="math">x=\\Pi^{-1}(0)</span>, and then query <span class="math">C</span> on input <span class="math">x</span>. Since <span class="math">\\sf VDE</span> is only necessarily sequential on <em>random</em> inputs the adversary may be able to find an input <span class="math">x</span> in this way that causes <span class="math">C</span> to output <span class="math">\\iota(x)</span> in significantly fewer than <span class="math">t</span> steps, which would enable it to distinguish <span class="math">C</span> from <span class="math">\\mathcal{O}^{(t)}_{{\\sf IDP}}</span>. Nonetheless, it is still possible that indifferentiability is achieved when the distinguisher is restricted to random queries (and for applications that only make random queries this may be good enough).</p>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">A.6 Depth Robust Graphs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An <span class="math">(n,\\alpha,\\beta,d)</span> <em>depth robust graph</em> (DRG) is a directed acyclic graph <span class="math">G=(V,E)</span> on $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> nodes with regular in-degree </span>d<span class="math"> that has the property that any subgraph of at least </span>\\alpha n<span class="math"> nodes contains a path of length at least </span>\\beta n<span class="math">. We define the <em>depth</em> of a node </span>v<span class="math"> in a DRG, denoted </span>depth(v)<span class="math">, as the longest path from some other node </span>w<span class="math"> in the graph to </span>v$. Depth robust graphs thus have the property that any sufficiently large subgraph contains some node of high depth in that subgraph. In fact, we can show that sufficiently large subgraphs contain many nodes of high depth.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-94" class="text-base font-medium mt-4">Claim 5.</h6>

    <p class="text-gray-300">In any <span class="math">(n,\\alpha,\\beta,d)</span> DRG for constants <span class="math">\\alpha,\\beta&lt;1</span>, every subgraph of size <span class="math">(\\alpha+\\delta)n</span> nodes contains at least <span class="math">\\lfloor\\delta n\\rfloor</span> nodes of depth at least <span class="math">\\beta n</span>.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\alpha^{\\prime}=\\alpha+\\delta&lt;1</span>. Consider any subgraph <span class="math">G_{1}</span> of size <span class="math">\\alpha^{\\prime}n</span>. There exists a node <span class="math">v_{1}\\in G_{1}</span> of depth <span class="math">\\beta n</span>. Remove <span class="math">v_{1}</span> from <span class="math">G_{1}</span> to form the subgraph <span class="math">G_{2}</span>. Continue this process, removing a node <span class="math">v_{i}</span> of depth <span class="math">\\beta n</span> from the <span class="math">i</span>th subgraph <span class="math">G_{i}</span>, which can be found as long as $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\alpha^{\\prime}n-i\\geq\\alpha n<span class="math">. This process locates a sequence of distinct nodes </span>v_{1}...,v_{t}<span class="math"> all of depth at least </span>\\beta n<span class="math"> in </span>G_{1}<span class="math">, where </span>t=\\lfloor\\delta n\\rfloor$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For example, if <span class="math">G</span> is a <span class="math">(n,1/2,1/4,d)</span> DRG then at least <span class="math">15\\%</span> of the nodes in any subgraph on <span class="math">50\\%</span> of the nodes have depth at least <span class="math">n/10</span>.</p>

    <p class="text-gray-300">A directed graph has <em>B-bounded outdegree</em> if the outdegree of any node is bounded by some integer <span class="math">B</span>. Not that any DAG with regular in-degree <span class="math">d</span> has average out-degree <span class="math">d</span>, however it may not have bounded outdegree. Intuitively, any DRGs with regular in-degree should have bounded out-degree, as otherwise one could delete many edges by removing only several nodes of high degree, reducing the depth of the remaining subgraph substantially.</p>

    <h5 id="sec-96" class="text-base font-semibold mt-4">Depth robust graph constructions</h5>

    <p class="text-gray-300">A classical construction by Erdős, Graham, and Szemeredi <em>[43]</em> showed how to construct DRGs explicitly from extreme constant-degree bipartite expander graphs. Using their construction, one can obtain an <span class="math">(n,\\alpha,\\beta,c\\log n)</span> DRG on <span class="math">n</span> nodes for particular constants, e.g. <span class="math">\\alpha=0.99</span> and <span class="math">\\beta=0.1</span>, and sufficiently large <span class="math">n</span>. The constant factor <span class="math">c</span> depends on the degree of the bipartite expander graphs used in the iterated construction. While explicit constructions of these graphs exist <em>[41]</em>, they are complex and have either large constant degree or only achieve the requisite expansion properties for a significantly large number of nodes. Mahmoody, Moran, and Vadhan <em>[36]</em> use denser bipartite expander graphs to construct for any <span class="math">\\epsilon&lt;1</span> a DRG family that is <span class="math">(n,\\alpha,\\alpha-\\epsilon,c\\log^{2}n)</span> depth robust for all <span class="math">\\alpha&lt;1</span>. Again, instantiating this construction with explicit expanders will result in graphs that have an impractically large degree. Alwen et. al. <em>[6]</em> recently improved the EGS construction to obtain DRGs for arbitrary <span class="math">\\alpha,\\beta</span> as well and <span class="math">O(\\log n)</span> degree (an asymptotic improvement over MMV), however all of these constructions still require concretely high degree due to their use of bipartite expander graphs with extreme expansion properties.</p>

    <p class="text-gray-300">A probabilistic DRG construction compromises on explicitness, and instead outputs a graph that is a DRG with overwhelming probability. This allows for much more efficient constructions. For example, one can immediately replace the bipartite expander graphs in the MMV/EGS constructions with <em>random bipartite graphs</em>, which are known to have strong expansion properties with high probability. Recently, Alwen et. al. <em>[5]</em> proposed and analyzed a highly efficient probabilistic DRG sampling algorithm that outputs concretely low-degree DRGs on <span class="math">n</span> nodes with with failure probability negligible in <span class="math">n</span>.</p>

    <p class="text-gray-300">Another useful property of the ABH probabilistic DRG construction is that they are <em>locally navigatable</em>. That is, it outputs a graph equipped with an efficient parent function to derive the parents of any node in the graph using polylog time and space. A probabilistic instantiation of MMV with random bipartite graphs would also have this property. This is a critical property that we take advantage of in our construction as it allows our prover and verifier to interactively agree on a freshly sampled DRG with only <span class="math">O(1)</span> communication and <span class="math">O(\\text{polylog}(n))</span> computation/space on the verifier.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Definition 21.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A locally navigatable DRG sampling algorithm for an <span class="math">(n,\\alpha,\\beta,d)</span>-DRG is a pair of deterministic algorithms that share a common <span class="math">s</span>-bit seed <span class="math">\\sigma\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\{0,1\\}^{s}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(n\\log n)$ that operate as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DRG.Sample<span class="math">(n,\\sigma)\\rightarrow G</span> outputs a graph on the node set indexed by integers in <span class="math">[n]</span>.</li>

      <li>DRG.Parents<span class="math">(n,\\sigma,i)\\rightarrow\\mathcal{P}</span> outputs a list <span class="math">\\mathcal{P}\\subseteq[n]</span> of the parents of the node at index <span class="math">i\\in[n]</span> in the graph <span class="math">G_{\\sigma}\\leftarrow DRG.Sample(n,\\sigma)</span>.</li>

    </ol>

    <p class="text-gray-300">DRG.Sample<span class="math">(n,\\sigma)</span> runs in time <span class="math">O(n\\log n)</span> and DRG.Parents<span class="math">(n,\\sigma,i)</span> runs in time <span class="math">O(\\text{polylogn})</span>. Finally the graph <span class="math">G</span> is an <span class="math">(n,\\alpha,\\beta,d)</span>-DRG with probability <span class="math">1-\\text{negl}(n)</span> over <span class="math">\\sigma\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\{0,1\\}^{s}</span>.</p>

    <p class="text-gray-300">In practice, the <span class="math">s</span>-bit size of size <span class="math">O(n\\log n)</span> can be derived pseudorandomly from a much smaller seed of size <span class="math">O(\\lambda)</span> given a strong pseudorandom number generator (PRNG) with security parameter <span class="math">\\lambda</span>, or a random oracle. As <span class="math">n</span> is presumed to be of feasible size, i.e. <span class="math">O(\\text{poly}(\\lambda))</span>, we do not require PRNGs with exponential stretch and thus cryptographic PRGs built from any one-way function suffice.</p>

    <p class="text-gray-300">A.7 Proofs of Space</p>

    <p class="text-gray-300">A proof of space (PoS) <em>[24]</em> is an interactive proof between and prover and verifier that demonstrates the prover is storing an advice string of a minimum size. The framework for proofs of space inherently requires a computational resource bound on the adversary. PoS constructions are built from puzzles that have time/space tradeoffs, and the PoS guarantees that an adversary who has not stored advice of a sufficient length will require computation exceeding this bound in order to pass the interactive proof. If the time/space tradeoff holds in the parallel computation model (i.e. passing the verifier’s challenge with too few bits of advice is sequentially hard) then security can be enforced unconditionally by forcing the prover to respond to the verifier within a time bound.</p>

    <p class="text-gray-300">We present here a slight variant on the PoS definition from <em>[24]</em> that additionally incorporates a data input <span class="math">D</span>. This is a blend of the storage enforcing commitment concept and PoS. The PoS interactive protocol involves two phases and a setup procedure.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup The setup runs on security parameters <span class="math">\\lambda</span> and outputs public parameters <span class="math">pp</span> for the scheme. The public parameters are implicit inputs to the next two protocols.</li>

      <li>Initialization is an interactive protocol between a prover <span class="math">P</span> and verifier <span class="math">V</span> that run on shared input <span class="math">(id,N)</span> and <span class="math">P</span> is additionally given data <span class="math">D</span>. <span class="math">P</span> outputs <span class="math">\\Phi</span> and <span class="math">S</span>, where <span class="math">S</span> is its storage advice and <span class="math">\\Phi</span> is a compact <span class="math">O(\\operatorname{polylog}(N))</span> string given to the verifier.</li>

      <li>Execution is an interactive protocol between <span class="math">P</span> and <span class="math">V</span> where <span class="math">P</span> runs on input <span class="math">S</span> and <span class="math">V</span> runs on input <span class="math">\\Phi</span>. <span class="math">V</span> sends challenges to <span class="math">P</span>, obtains back a proof <span class="math">\\pi</span>, and outputs accept or reject.</li>

    </ul>

    <h4 id="sec-98" class="text-lg font-semibold mt-6">Efficiency, Completeness, and Soundness</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoS protocols are required to have efficient verification, namely the verifier should run in time <span class="math">O(\\operatorname{polylog}(N))</span>. The PoS protocol has perfect completeness if the verifier always outputs accept in interaction with an honest prover with probability 1 over the randomness of both parties. The PoS protocol is <span class="math">(s,t,\\mu)</span>-sound if any adversarial prover <span class="math">P^{*}</span> that runs in time complexity at most <span class="math">t</span> and storage at most <span class="math">s</span> during Execution, where $s=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N<span class="math">, passes verification with probability at most </span>\\mu=\\textsf{negl}(\\lambda)<span class="math">. We may also express that the protocol is <em>parallel</em> </span>(s,t,\\mu)<span class="math">-sound if the time bound </span>t<span class="math"> is in parallel time (e.g. circuit depth, PRAM complexity, or parallel rounds of queries to an oracle). In either case there is no time bound on </span>P<span class="math">’s running time during Initialization, other than </span>O(\\operatorname{poly}(\\lambda))<span class="math"> when the scheme’s security depends on computational assumptions about the setup parameters. We additionally say the PoS is <em>data committing</em> if the output </span>\\Phi<span class="math"> is a binding cryptographic commitment (not necessarily hiding) to the data input </span>D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-99" class="text-lg font-semibold mt-6">Tight security and the space gap</h4>

    <p class="text-gray-300">The <em>space gap</em> in a PoS is the fraction <span class="math">\\epsilon=(N-s)/N</span>. This captures the difference between the (persistent) space utilization of the best possible attack and the honest prover’s storage. A PoS with a tighter lower bound on the adversarial prover’s space (persistent storage) will have a smaller space gap. As the best possible attack is probably not known, a PoS protocol with a larger space gap has a weaker security guarantee. Nearly all known PoS protocols to date have considerably large space gaps.</p>

    <p class="text-gray-300">The original PoS of Dziembowski et. al. <em>[24]</em> leaves a space gap of at least <span class="math">1-\\frac{1}{512}</span>. The construction of Ren and Devadas from stacked bipartite expander graphs made dramatic improvements, but still leaves space gap of at least <span class="math">1/2</span> (and much larger with practical parameters,</p>

    <p class="text-gray-300">e.g. their construction requires at least degree 40 graphs to achieve a space gap of less than <span class="math">2/3</span>). This appears fundamental to the construction, which is also not secure against parallel attacks, rather than a gap in the analysis. The recent proofs of space based on function tables<span class="math">^{26}</span> [3] has an enormous (even asymptotic) space gap of <span class="math">1 - \\frac{1}{64\\log N}</span>.</p>

    <p class="text-gray-300">Most recently, Pietrzak constructed an asymptotically tight PoS relying on a strong property of the EGS depth robust graphs that was also recently proven [6]. This property (which is stronger than normal depth robustness) is that for any arbitrarily small <span class="math">\\epsilon</span> a graph <span class="math">G_{\\epsilon}</span> on <span class="math">N</span> nodes with degree <span class="math">O(\\log N / \\epsilon)</span> can be constructed such that if any <span class="math">\\alpha</span> fraction of nodes are removed the remaining nodes contain a path of length <span class="math">\\beta</span> such that <span class="math">\\alpha + \\beta &amp;lt; 1 - \\epsilon</span>. Using a graph with this property, Pietrzak's PoS then achieves a space gap of <span class="math">4\\epsilon</span>. However, the construction relies on bipartite graphs with extreme expansion called <span class="math">\\delta</span>-local expanders<span class="math">^{27}</span> where <span class="math">\\delta &amp;lt; \\epsilon / 4</span>, and the final graph has degree at least <span class="math">10c_{\\delta} \\log N</span> where <span class="math">c_{\\delta}</span> is the degree of the <span class="math">\\delta</span>-local expander. Concretely, even the best known non-explicit randomized construction of a <span class="math">\\delta</span>-expander (e.g. Chung's expander, which define edges by a random permutation [18]) would require degree greater than 40 for <span class="math">\\epsilon = 1/2</span> and degree greater than 276 for <span class="math">\\epsilon = 1/8</span>. To achieve just an <span class="math">1/2</span> space gap would thus require a graph with degree <span class="math">d = 2,760 \\log N</span>. Even for 10-bit security the proof size would be at least 26MB!<span class="math">^{28}</span></p>

    <h2 id="sec-100" class="text-2xl font-bold">A.8 Graph pebbling games</h2>

    <p class="text-gray-300">Pebbling games are the main analytical tool used in graph-based proofs of space and memory hard functions.</p>

    <p class="text-gray-300"><strong>Black pebbling game</strong> The black pebbling game is a single-player game on a DAG <span class="math">\\mathcal{G} = (V, E)</span>. At the start of the game the player chooses a starting configuration of <span class="math">P_0 \\subseteq V</span> of vertices that contain black pebbles. The game then proceeds in rounds where in each round the player may place a black pebble on a vertex only if all of its parent vertices currently contain pebbles placed in some prior round. In this case we say that the vertex is available. Placing a pebble constitutes a move, whereas placing pebbles on all simultaneously available vertices consumes a round. The adversary may also remove any black pebble at any point. The game stops once the adversary has placed pebbles on all vertices in some target/challenge set <span class="math">V_C \\subseteq V</span>.</p>

    <p class="text-gray-300"><strong>Pebbling complexity</strong> There are different pebbling complexity measures taking into account how many rounds, steps, and/or pebbles are needed to finish the game from any given starting configuration. We say that the pebbling game on graph <span class="math">G</span> with vertex set <span class="math">V</span> and target set <span class="math">V_{C} \\subseteq V</span> is <span class="math">(s, t)</span>-hard if no player can pebble the set <span class="math">V_{C}</span> in <span class="math">t</span> moves (or fewer) starting from <span class="math">s</span> initial pebbles, and is <span class="math">(s, t)</span>-parallel-hard if no player can complete the pebbling in <span class="math">t</span> rounds (or fewer) starting from an initial configuration of at most <span class="math">s</span> pebbles. These are the two measures we are most interested in. If the hardness holds for any subset containing an <span class="math">\\alpha</span> fraction of <span class="math">V_{C}</span> then we write that the pebbling game on <span class="math">(G, V_{C})</span> is <span class="math">(s, t, \\alpha)</span>-(parallel)-hard. From a fixed starting</p>

    <p class="text-gray-300"><span class="math">^{26}</span>These are the proofs of space that are being deployed by Chia Network, https://chia.net/.</p>

    <p class="text-gray-300"><span class="math">^{27}</span>Bipartite <span class="math">\\delta</span>-local expanders require the property that there is an edge between any <span class="math">\\delta</span> fraction of sinks and <span class="math">\\delta</span> fraction of sources.</p>

    <p class="text-gray-300"><span class="math">^{28}</span>The proof size is at least <span class="math">O(\\lambda d)</span>, so even for <span class="math">\\lambda = 10</span> (i.e. 10 bit security) and <span class="math">N = 2^{30}</span> (i.e. a 32GB PoS because each node is a 32 bytes value) the proof size would be at least 26MB. Furthermore, as <span class="math">\\epsilon</span> decreases <span class="math">\\lambda = O(1/\\epsilon)</span> to maintain the same security level. To achieve a space gap of <span class="math">1/10</span> with 10-bit security would require <span class="math">d = 19,310\\log N</span> and <span class="math">\\lambda = 60</span> for a proof size of at least 1GB.</p>

    <p class="text-gray-300">51</p>

    <p class="text-gray-300">configuration <span class="math">P_{0}</span> the number of parallel rounds required to pebble all nodes in the set <span class="math">V_{C}</span> is equal to the maximum number of parallel rounds requires to pebble any individual <span class="math">v\\in V_{C}</span>.</p>

    <p class="text-gray-300">Random pebbling games are also considered, where a challenge node is sampled randomly from <span class="math">V_{C}</span> after the player commits to the initial configuration <span class="math">P_{0}</span> of <span class="math">s</span> vertices, and the hardness measure includes the adversary’s probability of success. The random pebbling game is <span class="math">(s,t,\\epsilon)</span>-(parallel)-hard if from any <span class="math">s</span> fixed initial pebbles the probability that a uniformly sampled challenge node can be pebbled in <span class="math">t</span> or fewer moves (resp. <span class="math">t</span> or fewer rounds) is less than <span class="math">\\epsilon</span>. There is also a general correspondence between the parallel hardness of random and deterministic pebbling games on a given graph.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Claim 6.</h6>

    <p class="text-gray-300">The random pebbling game on a DAG <span class="math">G</span> on <span class="math">n</span> nodes with target set <span class="math">V_{C}</span> is <span class="math">(s,t,\\alpha)</span>-parallel-hard if and only if the deterministic pebbling game on <span class="math">G</span> with target set <span class="math">V_{C}</span> is <span class="math">(s,t,\\alpha)</span>-parallel-hard.</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix any <span class="math">P_{0}</span> of size <span class="math">s</span>. If the random pebbling game on <span class="math">G</span> with target set <span class="math">V_{C}</span> is <span class="math">(s,t,\\alpha)</span>-parallel-hard then less than an <span class="math">\\alpha</span> fraction of the nodes in <span class="math">V_{C}</span> can be pebbled individually in <span class="math">t</span> rounds starting from <span class="math">P_{0}</span>. Therefore, every subset <span class="math">U</span> in <span class="math">V_{C}</span> of size $\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> contains at least one node that cannot be pebbled individually in </span>t<span class="math"> rounds, hence the (deterministic) pebbling game is </span>(s,t,\\alpha)<span class="math">-parallel-hard. Conversely, if </span>G<span class="math"> is </span>(s,t,\\alpha)<span class="math">-parallel-hard then less than an </span>\\alpha<span class="math"> fraction of nodes in </span>V_{C}<span class="math"> can be pebbled individually in </span>r<span class="math"> rounds. Otherwise, these nodes form a subset </span>U<span class="math"> of size </span>\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and they can all be simultaneously pebbled in parallel in </span>t<span class="math"> rounds. This implies that the probability a randomly sampled node from </span>V_{C}<span class="math"> can be pebbled in </span>t<span class="math"> rounds is less than </span>\\alpha$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-103" class="text-base font-medium mt-4">Claim 7.</h6>

    <p class="text-gray-300">A random pebbling game with a single challenge is <span class="math">(s,t,\\alpha)</span>-parallel-hard if and only if the the random pebbling with <span class="math">\\kappa</span> challenges is <span class="math">(s,t,\\alpha^{k})</span>-parallel-hard.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If the random pebbling game is <span class="math">(s,t,\\alpha)</span> hard then by Claim 6 the deterministic pebbling game is <span class="math">(s,r,\\alpha)</span> hard, hence there are at most an <span class="math">\\alpha</span> fraction of the nodes in <span class="math">V_{C}</span> that can be pebbled in <span class="math">r</span> rounds from <span class="math">s</span> initial pebbles. The probability that <span class="math">\\kappa</span> independent random challenges are all nodes from this <span class="math">\\alpha</span> fraction is at most <span class="math">\\alpha^{\\kappa}</span>. Conversely, if the random pebbling game is not <span class="math">(s,t,\\alpha)</span> hard then the adversary can pebble all the <span class="math">\\kappa</span> challenges simultaneously in parallel time <span class="math">t</span> succeeding on each challenge individually with probability greater than <span class="math">\\alpha</span>, hence succeeding on all the challenges with probability greater that <span class="math">\\alpha^{\\kappa}</span>. ∎</p>

    <h4 id="sec-105" class="text-lg font-semibold mt-6">From pebbling to graph labeling</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A labeling game on a degree <span class="math">d</span> DAG <span class="math">\\mathcal{G}</span> is analogous to the pebbling game except that the pebbling rules are “enforced” using a cryptographic hash function <span class="math">H:\\{0,1\\}^{dm}\\rightarrow\\{0,1\\}^{m}</span>, often modeled as a random oracle. The vertices of the graph are indexed in <span class="math">[n]</span> and each <span class="math">i</span>th vertex associated with the label <span class="math">c_{i}</span> where <span class="math">c_{i}=H(i)</span> if <span class="math">i</span> is a source vertex, or otherwise $c_{i}=H(i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ell_{\\text{\\small{parents}}}(i))<span class="math"> where </span>\\ell_{\\text{\\small{parents}}}(i)=\\{c_{v_{1}},...,c_{v_{d}}\\}<span class="math"> if </span>v_{1},...,v_{d}<span class="math"> are the parents of the </span>i<span class="math">th vertex, i.e. the vertices with a directed edge to vertex </span>i<span class="math">. The game ends when the player has computed all the labels on a target/challenge set of vertices </span>V_{C}<span class="math">. A “fresh” labeling of </span>\\mathcal{G}<span class="math"> could be derived by choosing a salt </span>id<span class="math"> for the hash function so that </span>H_{id}(x)=H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)<span class="math">, and the labeling may be associated with the identifier </span>id<span class="math">. The complexity of the labeling game (on a fresh identifier </span>id$) is measured analogously to the pebbling game, but in terms of queries to the hash function instead of pebbles. This includes the number of labels initially stored, the total number of queries, and the total rounds of sequential queries, etc. The labeling game is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(s,r,q,\\epsilon,\\delta)</span>-labeling-hard if no algorithm that stores initial advice of size <span class="math">s</span> and after receiving a uniform random challenge node <span class="math">v\\in[n]</span> makes a total of <span class="math">q</span> queries to <span class="math">H</span> in <span class="math">r</span> sequential rounds can output the correct label on <span class="math">v</span> with probability greater than <span class="math">\\epsilon</span> over the challenge <span class="math">v</span> and <span class="math">\\delta</span> over the random oracle <span class="math">H</span>.</p>

    <h4 id="sec-106" class="text-lg font-semibold mt-6">Random oracle query complexity</h4>

    <p class="text-gray-300">While the pebbling complexity of the underlying graph <span class="math">\\mathcal{G}</span> provides strong intuition about the query complexity of the labeling game, proving this equivalence is highly non-trivial. The “ex post facto” technique of <em>[20]</em> allows one to prove this when the initial configuration of pebbles is empty and the target set <span class="math">V_{C}</span> is chosen deterministically. Progress towards a general correspondence was made in <em>[45, 29]</em>. In particular, Pietrzak <em>[45]</em> showed an equivalence between the parallel hardness of the randomized pebbling game and the parallel hardness of the random oracle labeling game for arbitrary initial configurations <span class="math">S_{0}</span>. Demonstrating (or refuting) an equivalence for the non-parallel hardness of the two games is still open.</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Theorem 4 (Pietrzak <em>[45]</em>).</h6>

    <p class="text-gray-300">If the random pebbling game on a DAG <span class="math">G</span> with <span class="math">n</span> nodes and in-degree <span class="math">d</span> is <span class="math">(s,r,\\epsilon)</span>-parallel-hard then the labeling game on <span class="math">G</span> with a random oracle <span class="math">H:\\{0,1\\}^{md}\\to\\{0,1\\}^{m}</span> is <span class="math">(s^{\\prime},r,\\epsilon,\\delta,q)</span>-labeling-hard with <span class="math">s^{\\prime}=s(m-2(\\log n+\\log q))-\\log(1/\\delta)</span>.</p>

    <h4 id="sec-108" class="text-lg font-semibold mt-6">Generic PoS from graph labeling game</h4>

    <p class="text-gray-300">Most PoS constructions are based on the graph labeling game <em>[45, 46, 24]</em>. Let <span class="math">\\mathcal{G}(\\cdot)</span> be a family of <span class="math">d</span>-in-regular DAGs such that <span class="math">G_{n}\\leftarrow\\mathcal{G}(n)</span> is a d-in-regular DAG on <span class="math">N&gt;n</span> nodes and <span class="math">V_{C}(n)</span> is a subset of <span class="math">n</span> nodes from <span class="math">G_{n}</span>. Let <span class="math">H:\\{0,1\\}^{dm}\\to\\{0,1\\}^{m}</span> be a collision-resistant hash function (or random oracle). Let <span class="math">\\mathsf{Chal}(n)</span> denote a distribution over <span class="math">[N]^{\\lambda}</span>. For each <span class="math">n\\in\\mathbb{N}</span>, the generic PoS based on the labeling game with <span class="math">G_{n}</span> and target set <span class="math">V_{C}(n)</span> is as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Initialization: The prover plays the labeling game on <span class="math">G_{n}</span> using a hash function <span class="math">H</span> salted with the proof identifier <span class="math">id</span>, i.e. $H_{id}=H(id</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot)<span class="math">. While computing the labels on all nodes of </span>\\mathcal{G}<span class="math">, the prover adds these to a vector commitment (e.g. Merkle tree) denoted </span>com<span class="math">. Then it derives </span>\\lambda<span class="math"> non-interactive challenges by sampling a vector </span>\\vec{c}\\xleftarrow{n}\\mathsf{Chal}(n)<span class="math"> using as a seed </span>H_{id}(com)<span class="math">. For each of the challenges </span>c_{1},...,c_{\\lambda}<span class="math">, the prover opens the label on the </span>c_{i}<span class="math">th node of </span>G_{n}<span class="math">, which was committed in </span>com<span class="math">, as well as the labels of all its parent nodes. The labels are added to a list </span>L<span class="math"> with corresponding opening proofs in a list </span>\\Lambda<span class="math"> and the prover outputs the non-interactive proof </span>\\Phi=(com,L,\\Lambda)<span class="math">. A verifier (at any point in time) accepts </span>\\Phi<span class="math"> if it successfully verifies the openings </span>\\Lambda<span class="math"> with respect to </span>com<span class="math"> and also that for each challenge </span>v\\in[N]<span class="math"> with corresponding </span>\\ell_{v}<span class="math"> and purported parent labels </span>\\ell_{1}^{(v)},...,\\ell_{d}^{(v)}<span class="math"> listed in </span>L<span class="math"> that </span>\\ell_{v}=H_{id}(v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ell_{1}^{(v)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ell_{d}^{(v)})<span class="math">. Finally, the prover stores as </span>S<span class="math"> only the </span>n<span class="math"> labels in </span>V_{C}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execution: The verifier selects <span class="math">\\kappa</span> challenge nodes <span class="math">v_{1},...,v_{\\kappa}</span> uniformly at random from <span class="math">V_{C}</span>. The online prover uses its input <span class="math">S</span> to respond with the label on <span class="math">v</span> and an opening of <span class="math">com</span> at the appropriate index.</li>

    </ol>

    <p class="text-gray-300">Roughly, the generic construction is a PoS when the pebbling game on <span class="math">G</span> and <span class="math">V_{C}</span> is “hard” in some pebbling complexity sense. Our security analysis will focus on parallel pebbling complexity as this is a stronger security notion, particularly considering its general correspondence to the parallel hardness of the labeling game in the random oracle model.</p>

    <h5 id="sec-109" class="text-base font-semibold mt-4">Red-black pebbling game</h5>

    <p class="text-gray-300">The soundness of the generic labeling PoS is a bit more nuanced than just the parallel hardness of the black pebbling game on <span class="math">\\mathcal{G}</span> with <span class="math">V_{C}</span>. It is best abstracted through the red-black pebbling game, where red pebbles correspond to incorrect labels that the adversary computes and includes in its commitment during Initialization (i.e. where the adversary cheats). We may assume without loss of generality that whenever the adversary cheats it generates some label that does not require any space to store, essentially placing a “free” pebble on this node. Naturally, by committing to the labels the adversary commits to all these red pebbles during Initialization. The adversary’s choice of red pebble placements is also constrained by the <span class="math">\\lambda</span> non-interactive challenges, which may catch these red pebbles and reveal them to the verifier. The formal description of the red-black pebbling security game for a graph labeling PoS construction with <span class="math">\\mathcal{G}(n)</span>, <span class="math">V_{C}(n)</span>, and <span class="math">\\mathsf{Chal}(n)</span> is as follows.</p>

    <p class="text-gray-300">Red-Black-Pebbles<span class="math">{}^{\\mathcal{A}}(\\mathcal{G},V_{C},\\mathsf{Chal},t)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> outputs a set <span class="math">R\\subseteq[N]</span> (of red pebble indices) and <span class="math">S\\subseteq[N]</span> (of black pebble indices).</li>

      <li>The challenger samples <span class="math">c_{1},...,c_{\\lambda}\\xleftarrow{n}\\mathsf{Chal}(n)</span>. If <span class="math">c_{i}\\in R</span> for some <span class="math">i</span> then <span class="math">\\mathcal{A}</span> immediately loses. The challenger additionally samples <span class="math">v_{1},....,v_{\\kappa}</span> uniformly at random from indices in <span class="math">V_{C}(n)</span> and sends these to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> plays the random (black) pebbling game on <span class="math">\\mathcal{G}(n)</span> with the challenges <span class="math">v_{1},...,v_{\\kappa}</span> and initial pebble configuration <span class="math">P_{0}=R\\cup S</span>. It runs for <span class="math">t</span> parallel rounds and outputs its final pebble configuration <span class="math">P_{t}</span>. <span class="math">\\mathcal{A}</span> wins if <span class="math">P_{t}</span> contains pebbles on all of <span class="math">v_{1},...,v_{\\kappa}</span>.</li>

    </ol>

    <p class="text-gray-300">Although we have been loosely referencing PoS <span class="math">(S,T)</span>-soundness, we now formally define this for the special case of any graph labeling PoS in terms of complexity of Red-Black-Pebbles<span class="math">{}^{\\mathcal{A}}(\\mathcal{G},V_{C},t)</span>. Let <span class="math">c:\\mathbb{N}\\to N</span> denote a cost function <span class="math">c:\\mathbb{N}\\to\\mathbb{N}</span> representing the parallel time cost (e.g. in sequential steps on a PRAM machine) of computing a label on a node of <span class="math">\\mathcal{G}(n)</span> for each <span class="math">n\\in\\mathbb{N}</span>.</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Definition 22.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A graph labeling PoS with <span class="math">\\mathcal{G}(n),V_{C}(n),\\mathsf{Chal}(n)</span> and cost function <span class="math">c(n)</span> is parallel <span class="math">(s,c(n)\\cdot t,\\mu)</span>-sound if and only if the probability that any <span class="math">\\mathcal{A}</span> wins Red-Black-Pebbles<span class="math">{}^{\\mathcal{A}}(\\mathcal{G},V_{C},\\mathsf{Chal},t)</span> is bounded by <span class="math">\\mu</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=s$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-111" class="text-base font-semibold mt-4">Composition</h5>

    <p class="text-gray-300">For the security of several graph labeling games to compose the independent instances of the games must involve either independent labelings or independent hash function. This is the function of <span class="math">id</span> in the generic PoS construction from a graph labeling, which specifies a fresh hash function <span class="math">H_{id}</span>. In the random oracle model this is represented as a freshly sampled random function. When this is the case the composition of <span class="math">k</span> independent games is equivalent to a single game on a large graph containing <span class="math">k</span> distinctly labeled copies of the graph, where the new distribution of <span class="math">\\mathsf{Chal}</span> is a <span class="math">k</span> fold direct product.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Definition 23.</h6>

    <p class="text-gray-300">An <span class="math">(s,c(n)\\cdot t,\\mu)</span>-sound graph labeling PoS with <span class="math">\\mathcal{G}(n),V_{C}(n),\\mathsf{Chal}(n)</span> and cost function <span class="math">c(n)</span> is secure under <span class="math">k</span>-fold composition if and only if the graph labeling PoS with <span class="math">\\mathcal{G}^{<em>}(n),V_{C}^{</em>}(n),\\mathsf{Chal}^{<em>}(n)</span> is <span class="math">(sk,c(n)\\cdot t,\\mu)</span>-sound, where <span class="math">\\mathcal{G}^{</em>}(n)</span> consists of <span class="math">k</span> copies of <span class="math">\\mathcal{G}(n)</span>, <span class="math">V_{C}^{<em>}(n)</span> is the union of the images of <span class="math">V_{C}(n)</span> in each copy, and <span class="math">\\mathsf{Chal}^{</em>}(n)</span> is the direct product distribution <span class="math">\\mathsf{Chal}_{1}(n)\\times\\cdots\\times\\mathsf{Chal}_{k}(n)</span> where each <span class="math">\\mathsf{Chal}_{i}(n)</span> is the distribution <span class="math">\\mathsf{Chal}(n)</span> projected onto the <span class="math">i</span>th copy of the graph.</p>

    <h4 id="sec-113" class="text-lg font-semibold mt-6">Uniform challenges</h4>

    <p class="text-gray-300">In the special case that Chal is the uniform distribution over <span class="math">[N]^{\\lambda}</span> then the hardness of Red-Black-Pebbles<span class="math">{}^{\\mathcal{A}}(\\mathcal{G},V_{C},\\mathsf{Chal},t)</span> is simply implied by the hardness of the random black pebbling game.</p>

    <h6 id="sec-114" class="text-base font-medium mt-4">Claim 8.</h6>

    <p class="text-gray-300">If the random black pebbling game on <span class="math">\\mathcal{G}(n)</span> is <span class="math">((\\gamma+\\delta)n,t,\\mu)</span>-parallel-hard and Chal is the uniform distribution over <span class="math">[N]^{\\lambda}</span> then the graph labeling PoS with <span class="math">\\mathcal{G}(n)</span>, <span class="math">V_{C}(n)</span>, and <span class="math">c(n)</span> is <span class="math">(\\gamma n,c(n)\\cdot t,max((1-\\delta)^{\\lambda},\\mu^{\\kappa}))</span>-sound.</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <span class="math">\\lambda</span> challenges ensure that that <span class="math">\\mathcal{A}</span> wins the game Red-Black-Pebbles<span class="math">{}^{\\mathcal{A}}(\\mathcal{G},V_{C},\\mathsf{Chal},t)</span> with probability at most <span class="math">(1-\\delta)^{\\lambda}</span> if the number of red pebbles (i.e. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) exceeds </span>\\delta N<span class="math">. If </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\delta N<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\gamma N<span class="math">, then the adversary plays the random black pebbling game with </span>\\kappa<span class="math"> challenges and an initial configuration of at most </span>(\\gamma+\\delta)N<span class="math"> pebbles. If the random black pebbling game (with a single challenge) is </span>((\\gamma+\\delta)N,t,\\mu)<span class="math">-parallel-hard then </span>\\mathcal{A}<span class="math"> succeeds in playing this game with </span>\\kappa<span class="math"> simultaneous challenges (Step 3) with probability at most </span>\\mu^{\\kappa}<span class="math"> (by Claim 7). Therefore, if the random black pebbling game is hard then the adversary’s overall success probability is bounded by the maximum of its success probability in the two cases regarding the size of </span>R<span class="math">, i.e. </span>max(\\mu^{\\kappa},(1-\\delta)^{\\lambda})$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this case we can also make a simple claim about the composition of a graph labeling <span class="math">PoS</span> where Chal is the uniform distribution. It follows from a general claim pertaining a graph <span class="math">\\mathcal{G}(n)</span> that is the composition of <span class="math">k</span> subgraphs <span class="math">\\mathcal{G}_{1}(n),...,\\mathcal{G}_{k}(n)</span> which all have the same random black pebbling complexity and Chal samples <span class="math">\\lambda</span> challenges from the uniform distribution on each.</p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Claim 9.</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{G}(n)</span> contains subgraphs <span class="math">\\mathcal{G}_{1}(n),...,\\mathcal{G}_{k}(n)</span> and for each <span class="math">i</span> the random black pebbling game on <span class="math">\\mathcal{G}_{i}(n)</span> is <span class="math">((\\gamma+\\delta)n,t,\\mu)</span>-parallel-hard and <span class="math">\\mathsf{Chal}=\\mathsf{Chal}_{1}\\times\\cdots\\times\\mathsf{Chal}_{k}</span> where <span class="math">\\mathsf{Chal}_{i}</span> is the uniform distribution over the indices of the nodes contained in <span class="math">\\mathcal{G}_{i}</span> then the graph labeling PoS with <span class="math">\\mathcal{G}(n)</span>, <span class="math">V_{C}(n)</span>, and <span class="math">c(n)</span> is <span class="math">(k\\gamma n,c(n)\\cdot t,max((1-\\delta)^{\\lambda},\\mu^{\\kappa}))</span>-sound.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The <span class="math">\\lambda</span> challenges sampled from each <span class="math">\\mathsf{Chal}_{i}</span> ensure that that <span class="math">\\mathcal{A}</span> wins the game Red-Black-Pebbles<span class="math">{}^{\\mathcal{A}}(\\mathcal{G},V_{C},\\mathsf{Chal},t)</span> with probability at most <span class="math">(1-\\delta)^{\\lambda}</span> if the number of red pebbles exceeds <span class="math">\\delta N</span> in <em>any</em> subgraph <span class="math">\\mathcal{G}_{i}</span>. Suppose there are <span class="math">\\gamma_{i}N</span> black pebbles initially on each <span class="math">\\mathcal{G}_{i}</span> and at most <span class="math">\\delta N</span> red pebbles (total of <span class="math">\\sum_{i}\\gamma_{i}</span> initial black pebbles overall. The adversary plays the random black pebbling game with <span class="math">\\kappa</span> challenges on each <span class="math">\\mathcal{G}_{i}</span> with an initial configuration of at most <span class="math">(\\gamma_{i}+\\delta)N</span> pebbles. Since the random black pebbling game on each <span class="math">\\mathcal{G}_{i}</span> is <span class="math">((\\gamma+\\delta)N,t,\\mu)</span>-parallel-hard then <span class="math">\\mathcal{A}</span> succeeds in playing this game with <span class="math">\\kappa</span> simultaneous challenges (Step 3) with probability at most <span class="math">\\mu^{\\kappa}</span> if <span class="math">\\gamma_{i}&lt;\\gamma</span>. The probability <span class="math">\\mathcal{A}</span> succeeds in all the <span class="math">k</span> games is bounded by the minimum of its success probabilities in each, hence its overall success probability is at most <span class="math">\\mu^{\\kappa}</span> if <span class="math">\\gamma_{i}&lt;\\gamma</span> for <em>any</em> <span class="math">i</span>, i.e. if <span class="math">\\sum_{i}\\gamma_{i}&lt;k\\gamma</span>. Therefore, if the total number of initial pebbles is less than <span class="math">k\\gamma</span> then the adversary’s overall success probability is bounded by <span class="math">max(\\mu^{\\kappa},(1-\\delta)^{\\lambda})</span>. ∎</p>

    <h4 id="sec-118" class="text-lg font-semibold mt-6">Pebbling DRGs</h4>

    <p class="text-gray-300">We now state several facts regarding the pebbling complexity of a depth robust graph.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Claim 10.</h6>

    <p class="text-gray-300">If <span class="math">G</span> is a <span class="math">(n,\\alpha,\\beta)</span>-depth-robust DAG then pebbling any <span class="math">\\alpha n</span> initially unpebbled nodes requires at least <span class="math">\\beta n</span> rounds.</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">A subgraph of unpebbled <span class="math">\\alpha n</span> nodes contains a path <span class="math">P</span> of length <span class="math">\\beta n</span>. To pebble the entire set of unpebbled <span class="math">\\alpha n</span> nodes requires sequentially pebbling all the <span class="math">\\beta n</span> nodes along the path <span class="math">P</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Claim 11.</p>

    <p class="text-gray-300">For any <span class="math">\\alpha&lt;\\mu&lt;1</span>, the random black pebbling game on an <span class="math">(n,\\alpha,\\beta)</span>-depth-robust DAG <span class="math">G</span> is <span class="math">((\\mu-\\alpha)n,\\beta n-1,\\mu)</span>-parallel-hard.</p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider any <span class="math">\\mu&gt;\\alpha</span>. If <span class="math">(\\mu-\\alpha)n</span> black pebbles are placed anywhere on the graph then at least <span class="math">(1+\\alpha-\\mu)n</span> nodes are missing pebbles. Any subset of <span class="math">\\mu n</span> nodes of the graph therefore include at least <span class="math">\\alpha n</span> nodes that are missing pebbles. By Claim 10 these subsets require at least <span class="math">\\beta n</span> rounds to pebble. This means that the pebbling game on <span class="math">G</span> is <span class="math">((\\mu-\\alpha)n,\\beta n-1,\\mu)</span>-parallel-hard. The random pebbling game on <span class="math">G</span> is equivalently hard by Claim 6. ∎</p>

    <h4 id="sec-122" class="text-lg font-semibold mt-6">PoS from DRGs</h4>

    <p class="text-gray-300">The claims established thus far imply PoS soundness of the generic graph labeling PoS on a graph <span class="math">G</span> that is <span class="math">(n,\\alpha,\\beta,d)</span> depth robust, with challenge set <span class="math">V_{C}=[n]</span>, and where <span class="math">\\mathsf{Chal}</span> is the uniform distribution over <span class="math">[n]^{\\lambda}</span>. By Claim 8 and Claim 11, this PoS is <span class="math">((\\mu-\\alpha-\\delta)n,c(n)\\cdot(\\beta n-1),max((1-\\delta)^{\\lambda},\\mu^{\\kappa}))</span>-sound for any <span class="math">\\mu&gt;\\alpha+\\delta</span>. In particular, setting <span class="math">\\kappa=\\lambda</span> and <span class="math">\\mu=1-\\delta</span>, the PoS is <span class="math">((1-\\alpha-2\\delta)n,c(n)\\cdot(\\beta n-1),(1-\\delta)^{\\lambda})</span>-sound. As <span class="math">\\delta</span> can be made arbitrarily small for an increase in <span class="math">\\lambda</span>, the space gap of this PoS is approximately <span class="math">\\alpha</span>. Theoretically, there are DRG constructions that achieve arbitrarily small <span class="math">\\alpha</span> which would seem to imply tight space-hardness. However, this space-hardness is not really tight as decreasing <span class="math">\\alpha</span> decreases the space gap but also reduces the time bound <span class="math">t=\\beta n</span>).</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">The graph labeling PoS on a family <span class="math">G(n)</span> of <span class="math">(n,\\alpha,\\beta)</span> depth robust graphs with labeling cost function <span class="math">c(n)</span> is an <span class="math">(s,t,\\mu)</span>-parallel-sound PoS where for any <span class="math">\\delta&lt;1</span>:</p>

    <p class="text-gray-300"><span class="math">s=\\gamma n\\qquad t=c(n)(\\beta n-1)\\qquad\\mu=max((1-\\delta)^{\\lambda},(\\alpha+\\delta+\\gamma)^{\\kappa})</span></p>

    <p class="text-gray-300">The composition of <span class="math">k</span> independent graph labeling PoS protocols on this family of depth robust graphs is a <span class="math">(k\\cdot s,t,\\mu)</span>-parallel-sound PoS.</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">As described above, this follows from Claim 8 and Claim 11, setting <span class="math">\\gamma=\\mu-\\alpha-\\delta</span>. Composition follows from Claim 9 because this is equivalent to a graph labeling PoS on <span class="math">G^{*}(n)</span> that is the concatenation of <span class="math">k</span> copies of <span class="math">G(n)</span> and <span class="math">\\mathsf{Chal}=\\mathsf{Chal}_{1}\\times\\cdots\\mathsf{Chal}_{k}</span> where each <span class="math">\\mathsf{Chal}_{i}</span> is the uniform distribution over <span class="math">[i\\cdot n,(i+1)n)^{\\lambda}</span>. ∎</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="PoReps: Proofs of Space on Useful Data (2018/678)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/678
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
