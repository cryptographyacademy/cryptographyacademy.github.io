---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/454';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Optimized Lattice Basis Reduction In Dimension 2, and Fast Schnorr and EdDSA Signature Verification';
const AUTHORS_HTML = 'Thomas Pornin';

const CONTENT = `    <p class="text-gray-300">Thomas Pornin</p>

    <p class="text-gray-300">NCC Group, thomas.pornin@nccgroup.com</p>

    <p class="text-gray-300">18 April 2020</p>

    <p class="text-gray-300">Abstract. We present an optimization of Lagrange's algorithm for lattice basis reduction in dimension 2. The optimized algorithm is proven to be correct and to always terminate with quadratic complexity; it uses more iterations on average than Lagrange's algorithm, but each iteration is much simpler to implement, and faster. The achieved speed is such that it makes application of the speed-up on ECDSA and EC Schnorr signatures described by Antipa et al[1] worthwhile, even for very fast curves such as Ed25519[3]. We applied this technique to signature verification in Curve9767[12], and reduced verification time by 30 to 33% on both small (ARM Cortex M0+ and M4) and large (Intel Coffee Lake with AVX2) architectures.</p>

    <p class="text-gray-300">Schnorr signatures[13] are an efficient signature algorithm that can be readily applied to most groups where discrete logarithm is a hard problem. Ed25519, defined in [3] and later extended to other curves and standardized under the generic name EdDSA[6], is an application of Schnorr signatures to an Edwards elliptic curve. Weierstraß curves can also be used, e.g. Curve9767[12]. Schnorr signature verification is typically more expensive than signature generation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Most of the cost of signature generation is computing point <span class="math">rB</span>, where <span class="math">B</span> is the conventional generator point for the prime order subgroup, and <span class="math">r</span> is a per-signature secret scalar. Since <span class="math">B</span> is fixed, precomputed tables can be used for many multiples of <span class="math">B</span>, which greatly speeds up the operation.</li>

      <li>Conversely, signature verification relies on verifying the equation <span class="math">b(sB - kA) = bR</span>, where point <span class="math">R</span> and scalar <span class="math">s</span> are part of the signature value, <span class="math">A</span> is the public key, <span class="math">k</span> is computed from the output of a hash function over the message, public key and <span class="math">R</span> point, and <span class="math">b</span> is the cofactor, i.e. the ratio between the curve order and the order of the subgroup generated by <span class="math">B</span> (in practice, <span class="math">b</span> is very small; for Ed25519, <span class="math">b = 8</span>). Points <span class="math">R</span> and <span class="math">A</span> vary, precluding the use of precomputed tables.</li>

    </ul>

    <p class="text-gray-300">A method for improving signature verification performance was described by Antipa et al[1]. The main idea is that the verification equation is equivalent to checking that:</p>

    <div class="my-4 text-center"><span class="math-block">b \\left(\\left(\\delta s\\right) B - \\left(\\delta k\\right) A - \\delta R\\right) = \\text{0}</span></div>

    <p class="text-gray-300">for any value <span class="math">\\delta</span> invertible modulo the subgroup order <span class="math">n</span> (which is prime). The products <span class="math">\\delta s</span> and <span class="math">\\delta k</span> can be computed modulo <span class="math">n</span>. By splitting <span class="math">\\delta s</span> mod <span class="math">n</span> into two halves <span class="math">e_0</span> and <span class="math">e_1</span> (say, of <span class="math">m/2</span></p>

    <p class="text-gray-300">bits each, with the subgroup order <span class="math">n</span> being an <span class="math">m</span>-bit integer), that equation can be rewritten as:</p>

    <p class="text-gray-300"><span class="math">b(e_{0}B+e_{1}2^{m/2}B-(\\delta k\\bmod n)\\mathcal{A}-\\delta R)=\\mathbb{O}</span></p>

    <p class="text-gray-300">When computing a linear combination of curve points, the well-known “Shamir’s trick” (in fact due to Straus<em>[14]</em>) allows mutualizing all the point doublings in a double-and-add algorithm. In the case of <span class="math">sB-k\\mathcal{A}</span>, both <span class="math">s</span> and <span class="math">k</span> have about the same size as <span class="math">n</span> (i.e. about <span class="math">m</span> bits, in our notations), and the double-and-add algorithm will involve about <span class="math">m</span> doublings, and some extra additions. The number of extra additions can be reduced through a number of techniques (windows, sliding windows, NAF recoding…) and the <span class="math">m</span> doublings dominate the algorithm cost.</p>

    <p class="text-gray-300">In our rewritten equation, we have a linear combination of four points, two of which are fixed and thus known in advance (<span class="math">B</span> and <span class="math">2^{m/2}B</span>), and the other two being obtained dynamically (<span class="math">\\mathcal{A}</span> and <span class="math">R</span>). Coefficients <span class="math">e_{0}</span> and <span class="math">e_{1}</span> have size <span class="math">m/2</span> bits (half that of the prime subgroup order <span class="math">n</span>). Efficiency comes from finding a value <span class="math">\\delta</span> which is such that both <span class="math">\\delta</span> and <span class="math">\\delta k</span> mod <span class="math">n</span> are “small”, i.e. about <span class="math">m/2+1</span> bits each. If such a <span class="math">\\delta</span> is found, then there will be only about <span class="math">m/2</span> point doublings instead of <span class="math">m</span>, i.e. halving the cost of the most expensive part of the computation (the number of extra additions remains about the same as in the initial verification equation, since there are now four points instead of two, but with twice as small coefficients).</p>

    <p class="text-gray-300">A method for finding an appropriate <span class="math">\\delta</span> is found in <em>[4]</em>; in a nutshell, it uses an extended Euclidean GCD algorithm, and stops when the intermediate value has shrunk to about half the size of <span class="math">n</span>. This heuristically finds a good <span class="math">\\delta</span> value.</p>

    <p class="text-gray-300">The Ed25519 article (<em>[3]</em>, page 14) explicitly considers the Antipa et al method, and rejects it, on the grounds that the Euclidean GCD algorithm implies a number of divisions, which are cumbersome and expensive to implement, making the cost of the computation of <span class="math">\\delta</span> higher than the savings obtained through reduction of the number of point doublings.</p>

    <p class="text-gray-300">In this note, we describe an alternate algorithm for computing <span class="math">\\delta</span>, which is efficient enough to make the optimization worthwhile, even for fast signature algorithms such as Curve25519. Our algorithm can be viewed as a binary version of Lagrange’s algorithm for reduction of a lattice basis in dimension two; in particular, no division is used, and only two plain integer multiplications are involved, the inner loop consisting only of efficient linear operations (additions, subtractions, and left shifts).</p>

    <p class="text-gray-300">Lagrange’s algorithm, and our new algorithm, are described in section 2. Some implementation notes and speed benchmarks are given in section 3.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Lattice Basis Reduction</h2>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Notations</h3>

    <p class="text-gray-300">We use a bold font to designate vectors, e.g. <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span>. All vectors are in the vector space <span class="math">\\mathbb{R}^{e}</span> for some integer <span class="math">e</span> (in most of the article, we will focus on <span class="math">e=2</span>); moreover, apart from the initial presentation of lattices, all vector coordinates will be integers.</p>

    <p class="text-gray-300">For an integer <span class="math">x</span>, we denote <span class="math">\\mathrm{len}(x)</span> the minimum size of the binary representation of <span class="math">x</span>, using two’s complement for negative values, and excluding the sign bit. If <span class="math">x\\geq 0</span>, then <span class="math">\\mathrm{len}(x)</span> is the smallest integer <span class="math">m\\geq 0</span> such that <span class="math">x&lt;2^{m}</span>. If <span class="math">x&lt;0</span>, then <span class="math">\\mathrm{len}(x)=\\mathrm{len}(-x-1)</span>.</p>

    <p class="text-gray-300">There are other possible definitions for len, depending on whether <span class="math">\\mathrm{len}(2^m)</span> is defined to be <span class="math">m</span> or <span class="math">m + 1</span>, and similarly for <span class="math">\\mathrm{len}(-2^m)</span>. Our definition implies that <span class="math">\\mathrm{len}(2^m) = m + 1</span> but <span class="math">\\mathrm{len}(-2^m) = m</span>, because it maps well to an implementation that uses two's complement for negative values. All four possible combinations actually work in our algorithm.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2.2 Lattices</h2>

    <p class="text-gray-300">We define here lattices and recall some known results. For simpler explanations and proofs, refer to [11].</p>

    <p class="text-gray-300">Let <span class="math">e \\geq 2</span> an integer; we consider the vector space <span class="math">\\mathbb{R}^e</span>. A lattice is a discrete subgroup of <span class="math">\\mathbb{R}^e</span>. It can be shown that any lattice <span class="math">L</span> has a basis consisting of <span class="math">e&#x27;</span> linearly independent vectors <span class="math">(\\mathbf{b}_i)</span> (hence <span class="math">e&#x27; \\leq e</span>), such that:</p>

    <div class="my-4 text-center"><span class="math-block">L = \\left\\{\\sum_{i=1}^{e} x_i \\mathbf{b}_i \\mid (x_1, x_2, \\dots x_{e&#x27;}) \\in \\mathbb{Z}^{e&#x27;} \\right\\}</span></div>

    <p class="text-gray-300">A lattice has, in general, infinitely many bases; however, they all contain the same number <span class="math">e&#x27;</span> of vectors, which is the rank of the lattice. In this paper, we will consider only lattices of maximal rank (i.e. <span class="math">e = e&#x27;</span>), and in particular the case of lattices of rank 2 in a space of dimension <span class="math">e = 2</span> (hereafter called "lattices of dimension 2").</p>

    <p class="text-gray-300">If <span class="math">B</span> is the <span class="math">e \\times e</span> matrix whose column vectors are a basis of <span class="math">L</span>, then the volume of the lattice <span class="math">L</span> is the square root of the determinant of <span class="math">BB^t</span> (where <span class="math">B^t</span> is the transpose of <span class="math">B</span>). It can be shown that this quantity does not depend on which basis is used for a given lattice. It is denoted <span class="math">\\operatorname{vol}(L)</span>.</p>

    <p class="text-gray-300">It shall be noted that if the elements of a lattice basis only have integer coordinates, then all the lattice elements, and therefore all elements of any other basis of the lattice, will have only integer coordinates.</p>

    <p class="text-gray-300">For two vectors <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span>, let <span class="math">\\langle \\mathbf{u}, \\mathbf{v} \\rangle</span> be their inner product; we denote <span class="math">\\mathcal{N}(\\mathbf{u}) = \\langle \\mathbf{u}, \\mathbf{u} \\rangle</span>. <span class="math">\\mathcal{N}(\\mathbf{u})</span> is the square of the Euclidean norm of <span class="math">\\mathbf{u}</span>. A well-known problem is to find a shortest non-zero vector in a lattice. The minimal length of non-zero vectors in a lattice is well-defined, and there is only a finite number of vectors in the lattice whose length is exactly the minimal length<span class="math">^1</span>. When the dimension is large, finding a shortest vector is a hard problem, but in very low dimensions, efficient algorithms are known[11]. Hermite proved[7] in 1850 that there exists a constant <span class="math">\\gamma_e</span> that depends only on the dimension <span class="math">e</span>, such that if <span class="math">\\mathbf{s}</span> is a shortest non-zero vector of a lattice <span class="math">L</span>, <span class="math">\\mathcal{N}(\\mathbf{s}) \\leq \\gamma_e \\mathrm{vol}(L)^{2/e}</span>. Hermite proved that <span class="math">\\gamma_e \\leq (4/3)^{(e-1)/2}</span>, and Minkowski later showed[10] that <span class="math">\\gamma_e \\leq e</span>. The exact value of <span class="math">\\gamma_e</span> is known only for small dimensions; in particular, <span class="math">\\gamma_2 = 2/\\sqrt{3} \\approx 1.16</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Application To Schnorr and EdDSA Signature Verification.</strong> As explained in the introduction, the problem we are trying to solve is, given a prime <span class="math">n</span> and an integer <span class="math">0 \\leq k &amp;lt; n</span>, finding two integers <span class="math">d_0</span> and <span class="math">d_1</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are small, and </span>d_0 = d_1k \\mod n<span class="math"> (note that either or both </span>d_0<span class="math"> and </span>d_1<span class="math"> can be negative). We can rewrite that problem as an instance of finding a short vector in a lattice of dimension two (in the introduction, we used the letter </span>\\hat{\\delta}$ to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^1</span>If <span class="math">\\mathbf{u}</span> is a shortest non-zero vector, then so is <span class="math">-\\mathbf{u}</span>; therefore, the solution is never unique.</p>

    <p class="text-gray-300">designate  <span class="math">d_{1}</span> ; we switch the notation to emphasize the vector interpretation of the problem). Indeed, we define the two vectors:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u} = (n,0)</span> <span class="math">\\mathbf{v} = (k,1)</span></p>

    <p class="text-gray-300">These two vectors are linearly independent, and therefore are the basis for a lattice  <span class="math">L</span>  of dimension two:</p>

    <div class="my-4 text-center"><span class="math-block">L = \\left\\{\\alpha \\mathbf {u} + \\beta \\mathbf {v} \\mid (\\alpha , \\beta) \\in \\mathbb {Z} ^ {2} \\right\\}</span></div>

    <p class="text-gray-300">The volume of this lattice is  <span class="math">\\mathrm{vol}(L) = \\sqrt{n^2} = n</span> .</p>

    <p class="text-gray-300">Any vector  <span class="math">\\mathbf{c} = (c_0, c_1)</span>  in the lattice  <span class="math">L</span>  is such that  <span class="math">c_0 = kc_1 + \\alpha n</span>  for some integer  <span class="math">\\alpha</span> , and, conversely, any pair of integers  <span class="math">(c_0, c_1)</span>  such that  <span class="math">c_0 = kc_1 \\mod n</span>  is part of the lattice (it suffices to set  <span class="math">\\beta = c_1</span>  and  <span class="math">\\alpha = (c_0 - kc_1)/n</span> ). The vector  <span class="math">\\mathbf{d} = (d_0, d_1)</span>  we are looking for is thus an element of the lattice, and we want it to be as short as possible. Hermite's theorem shows that a shortest non-zero vector in that lattice will be such that:</p>

    <div class="my-4 text-center"><span class="math-block">d _ {0} ^ {2} + d _ {1} ^ {2} = N (\\mathbf {d}) \\leq \\gamma_ {2} \\operatorname {v o l} (L) \\approx 1. 1 6 n</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It follows that there must exist a non-zero vector  <span class="math">\\mathbf{d}</span>  in the lattice  <span class="math">L</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  are both at most  </span>\\sqrt{1.16n}<span class="math"> , i.e. about half the size of  </span>n<span class="math"> . In particular, if  </span>n &lt; 2^m<span class="math">  (an  </span>m<span class="math"> -bit integer), then we can always find integers  </span>d_0<span class="math">  and  </span>d_1<span class="math">  of at most  </span>\\lfloor (m + 2) / 2 \\rfloor$  bits each (in absolute value).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-6" class="text-2xl font-bold">2.3 Lagrange's Algorithm</h2>

    <p class="text-gray-300">In 1773, Lagrange described an efficient algorithm to find a shortest vector of a lattice in dimension two[8] (that algorithm was independently rediscovered and published by Gauss in 1801[5], and is sometimes called Gauss's algorithm). The algorithm can be considered to be an extension of the classic Euclidean GCD algorithm. It is described in algorithm 1.</p>

    <p class="text-gray-300"><strong>Algorithm 1</strong> Lagrange's algorithm</p>

    <p class="text-gray-300">Require:  <span class="math">(\\mathbf{u},\\mathbf{v})\\in \\mathbb{Z}^2\\times \\mathbb{Z}^2</span>  a basis for a lattice  <span class="math">L</span>  of dimension two</p>

    <p class="text-gray-300">Ensure: A size-reduced basis of  <span class="math">L</span></p>

    <p class="text-gray-300">1: if  <span class="math">N(\\mathbf{u}) &amp;lt; N(\\mathbf{v})</span>  then 2: swap  <span class="math">\\mathbf{u}</span>  with  <span class="math">\\mathbf{v}</span> 3: repeat 4:  <span class="math">q \\gets \\lfloor \\langle \\mathbf{u}, \\mathbf{v} \\rangle / N(\\mathbf{v}) \\rfloor</span> 5:  <span class="math">\\mathbf{u} \\gets \\mathbf{u} - q\\mathbf{v}</span> 6: swap  <span class="math">\\mathbf{u}</span>  with  <span class="math">\\mathbf{v}</span> 7: until  <span class="math">N(\\mathbf{u}) \\leq N(\\mathbf{v})</span> 8: return  <span class="math">(\\mathbf{v},\\mathbf{u})</span></p>

    <p class="text-gray-300"><span class="math">\\triangleright</span>  Division rounded to a nearest integer.</p>

    <p class="text-gray-300"><span class="math">\\triangleright</span>  v is a shortest non-zero vector in  <span class="math">L</span></p>

    <p class="text-gray-300">Intuitively, Lagrange's algorithm works as follows: given a lattice basis  <span class="math">(\\mathbf{u},\\mathbf{v})</span> , the pair  <span class="math">(\\mathbf{v},\\mathbf{u} - q\\mathbf{v})</span>  is another basis, for any integer  <span class="math">q</span>  (we recognize here a step similar to the Euclidean GCD algorithm). We converge on a short vector by applying that transformation repeatedly,</p>

    <p class="text-gray-300">until it no longer works, i.e. the basis cannot be made any shorter in this way. If we were to allow a non-integral <span class="math">q</span>, then the shortest vector <span class="math">\\mathbf{u}-q\\mathbf{v}</span> would correspond to the orthogonal projection of <span class="math">\\mathbf{u}</span> along the direction of <span class="math">\\mathbf{v}</span>, with value <span class="math">q=\\langle\\mathbf{u},\\mathbf{v}\\rangle/N(\\mathbf{v})</span>, and no further size reduction would be possible once the basis has been made orthogonal. Since <span class="math">q</span> must be an integer (otherwise, the modified basis is no longer a basis for the source lattice <span class="math">L</span>), the algorithm rounds the fraction to a nearest integer, yielding a new basis which is not fully orthogonal, but “more orthogonal” than the previous one.</p>

    <p class="text-gray-300">Beyond this intuitive description, it is not obvious why this algorithm converges on a shortest vector in the lattice, and why the overall complexity is quadratic. Extensive analysis of this algorithm can be found in <em>[11]</em>. Lagrange’s algorithm has the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When the algorithm terminates, <span class="math">\\mathbf{v}</span> is a shortest non-zero vector of the lattice, and <span class="math">\\mathbf{u}</span> is a shortest vector of the lattice among those which are linearly independent with <span class="math">\\mathbf{v}</span>. The basis <span class="math">(\\mathbf{u},\\mathbf{v})</span> is then said to be <em>size-reduced</em>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If, at the beginning of an iteration, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N(\\mathbf{v})/2<span class="math">, then </span>(\\mathbf{u},\\mathbf{v})$ is size-reduced and the algorithm terminates. Conversely, the algorithm does <em>not</em> terminate until the basis is size-reduced.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 1 seems to require the computation of <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle</span> and <span class="math">N(\\mathbf{v})</span> at each iteration, implying multiplications of possibly large integers. However, the successive values of <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle</span>, <span class="math">N(\\mathbf{u})</span> and <span class="math">N(\\mathbf{v})</span> can be computed more efficiently by noting that:</p>

    <p class="text-gray-300"><span class="math">N(\\mathbf{u}-q\\mathbf{v})</span> <span class="math">=N(\\mathbf{u})+q^{2}N(\\mathbf{v})-2q\\langle\\mathbf{u},\\mathbf{v}\\rangle</span> <span class="math">\\langle\\mathbf{v},\\mathbf{u}-q\\mathbf{v}\\rangle</span> <span class="math">=\\langle\\mathbf{u},\\mathbf{v}\\rangle-qN(\\mathbf{v})</span></p>

    <p class="text-gray-300">In algorithm 2, we describe Lagrange’s algorithm again, but with explicit updates that follow these rules. The value <span class="math">N(\\mathbf{u})</span>, <span class="math">N(\\mathbf{v})</span> and <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle</span> are kept in variables <span class="math">N_{n}</span>, <span class="math">N_{v}</span> and <span class="math">p</span>, respectively, which are adjusted with the above formulas whenever <span class="math">\\mathbf{u}</span> or <span class="math">\\mathbf{v}</span> is changed; notably, when <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span> are swapped with each other, <span class="math">N(\\mathbf{u})</span> and <span class="math">N(\\mathbf{v})</span> are swapped accordingly (since <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle=\\langle\\mathbf{v},\\mathbf{u}\\rangle</span>, the variable <span class="math">p</span> does not need to be modified when swapping <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This description shows that all operations in an iteration can be expressed as additions, subtractions, multiplications by <span class="math">q</span>, and Euclidean division (rounded). The values <span class="math">q</span> are usually small, making these operations efficient on average. The overall complexity of the algorithm is $O((\\log\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2})<span class="math">, i.e. quadratic in the norm of the largest vector of the input basis; intuitively, each iteration reduces the norm of the larger vector (</span>\\mathbf{u}<span class="math">) by </span>O(\\log q)<span class="math"> bits, so that larger </span>q$ induce better reduction, and the cumulative cost of all the multiplications is quadratic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In practice, this algorithm is cumbersome to implement, because the value <span class="math">q</span>, while normally small, <em>can</em> be large, requiring the implementation of multiplication and division over large integers. Moreover, even when <span class="math">q</span> is small, multiplication of a big integer by a small <span class="math">q</span> is slower than addition, by a constant factor that depends on the underlying hardware abilities (cost of multiplication relatively to addition) but is not negligible. These characteristics make Lagrange’s algorithm less interesting for application of the method of Antipa <em>et al</em> to signature verification, especially for fast curves.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">|  Algorithm 2 Lagrange's algorithm (with efficient updates of ⟨u, v⟩, N(u) and N(v))  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: (u, v) ∈ Z2 × Z2 a basis for a lattice L of dimension two  |   |</p>

    <p class="text-gray-300">|  Ensure: A size-reduced basis of L  |   |</p>

    <p class="text-gray-300">|  1: Nu ← N(u)  |   |</p>

    <p class="text-gray-300">|  2: Nv ← N(v)  |   |</p>

    <p class="text-gray-300">|  3: p ← ⟨u, v⟩  |   |</p>

    <p class="text-gray-300">|  4: if Nu < Nv then  |   |</p>

    <p class="text-gray-300">|  5: swap u with v  |   |</p>

    <p class="text-gray-300">|  6: swap Nu with Nv  |   |</p>

    <p class="text-gray-300">|  7: repeat  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8: q ← [p/Nv]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Division rounded to a nearest integer.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  9: u ← u - qv |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10: Nu ← Nu + q2Nv - 2qp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The value of Nu is adjusted to N(u) for the new value of u.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  12: swap u with v |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13: swap Nu with Nv</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Swapping u and v does not change the value of ⟨u, v⟩.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  14: until Nu ≤ Nv |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15: return (v, u)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v is a shortest non-zero vector in L.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define in algorithm 3 a variant of Lagrange's algorithm which is much easier to implement, and in practice more efficient, since it uses only additions, subtractions and left shifts in the main loop. The main idea is to force  <span class="math">q</span>  to be a power of two ( <span class="math">q = 2^s</span>  for some integer  <span class="math">s \\geq 0</span> ).</p>

    <p class="text-gray-300">Like in algorithm 2, values of  <span class="math">N(\\mathbf{u})</span> ,  <span class="math">N(\\mathbf{v})</span>  and  <span class="math">\\langle \\mathbf{u}, \\mathbf{v} \\rangle</span>  are cached in variables  <span class="math">N_u</span> ,  <span class="math">N_v</span>  and  <span class="math">p</span> , and updated with explicit operations.</p>

    <p class="text-gray-300">The two main differences with Lagrange's algorithm are the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The quotient  <span class="math">q</span>  is forced to  <span class="math">\\pm 2^s</span>  for some integer  <span class="math">s</span> .</li>

      <li>An iteration does not necessarily reduce  <span class="math">\\mathbf{u}</span>  to a size lower than that of  <span class="math">\\mathbf{v}</span> . Therefore, the swap is made conditional to the actual norms. Consequently, the exit test (on line 8) cannot use a failure to reduce  <span class="math">\\mathbf{u}</span>  to a size lower than  <span class="math">\\mathbf{v}</span> ; instead, the algorithm exits when a size-reduced basis is obtained.</li>

    </ul>

    <p class="text-gray-300">As we will see in section 2.5, in the case of optimizing EdDSA or Schnorr signature verification, where we only need a short vector, not necessarily a shortest vector, the test on line 8 can be replaced with a much cheaper test on the bit length of  <span class="math">N_{v}</span> , bit length which is computed on line 10.</p>

    <p class="text-gray-300">Correctness. Like Lagrange's algorithm, the improved algorithm modifies  <span class="math">(\\mathbf{u},\\mathbf{v})</span>  only by swapping  <span class="math">\\mathbf{u}</span>  with  <span class="math">\\mathbf{v}</span> , and by replacing  <span class="math">\\mathbf{u}</span>  with  <span class="math">\\mathbf{u} - q\\mathbf{v}</span>  for some integer  <span class="math">q</span> ; both operations naturally lead to another basis for the same lattice  <span class="math">L</span> . Moreover, the exit condition is such that the algorithm can only return a size-reduced basis, which implies that its smaller vector  <span class="math">(\\mathbf{v})</span>  is necessarily a shortest non-vector in the lattice. What remains to be proven is that the algorithm always terminates.</p>

    <p class="text-gray-300">Require:  <span class="math">(\\mathbf{u},\\mathbf{v})\\in \\mathbb{Z}^2\\times \\mathbb{Z}^2</span>  a basis for a lattice  <span class="math">L</span>  of dimension two</p>

    <p class="text-gray-300">Ensure: A short non-zero vector of  <span class="math">L</span></p>

    <p class="text-gray-300">1:  <span class="math">N_{u}\\gets N(\\mathbf{u})</span> 2:  <span class="math">N_{v}\\gets N(\\mathbf{v})</span> 3:  <span class="math">p\\gets \\langle \\mathbf{u},\\mathbf{v}\\rangle</span> 4: loop 5: if  <span class="math">N_{u} &amp;lt; N_{v}</span>  then 6: swap  <span class="math">\\mathbf{u}</span>  with  <span class="math">\\mathbf{v}</span> 7: swap  <span class="math">N_{u}</span>  with  <span class="math">N_{v}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8: if  $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N_v$  then This test matches when the basis is size-reduced.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">9: return  <span class="math">(\\mathbf{v},\\mathbf{u})</span> 10:  <span class="math">s\\gets \\max (0,\\mathrm{len}(p) - \\mathrm{len}(N_v))</span> 11: if  <span class="math">p &amp;gt; 0</span>  then 12:  <span class="math">\\mathbf{u}\\gets \\mathbf{u} - 2^{s}\\mathbf{v}</span> 13:  <span class="math">N_{u}\\gets N_{u} + 2^{2s}N_{v} - 2^{s + 1}p</span> 14:  <span class="math">p\\gets p - 2^{s}N_{v}</span> 15: else 16:  <span class="math">\\mathbf{u}\\gets \\mathbf{u} + 2^{s}\\mathbf{v}</span> 17:  <span class="math">N_{u}\\gets N_{u} + 2^{2s}N_{v} + 2^{s + 1}p</span> 18:  <span class="math">p\\gets p + 2^{s}N_{v}</span></p>

    <p class="text-gray-300">Consider the situation when reaching line 8. Define:</p>

    <div class="my-4 text-center"><span class="math-block">a = \\operatorname {l e n} (\\langle \\mathbf {u}, \\mathbf {v} \\rangle)</span></div>

    <div class="my-4 text-center"><span class="math-block">b = \\operatorname {l e n} (N (\\mathbf {v}))</span></div>

    <p class="text-gray-300">Since  <span class="math">N(\\mathbf{v}) &amp;gt; 0</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block">2 ^ {b - 1} \\leq N (\\mathbf {v}) \\leq 2 ^ {b} - 1</span></div>

    <p class="text-gray-300">Note that if  <span class="math">\\langle \\mathbf{u},\\mathbf{v}\\rangle = 0</span> , then the exit test matches and the algorithm exits. Therefore, line 10 may be reached only if  <span class="math">\\langle \\mathbf{u},\\mathbf{v}\\rangle \\neq 0</span> . There are now three possible cases to consider:</p>

    <p class="text-gray-300">Case 1:  <span class="math">a \\geq b</span>  and  <span class="math">\\langle \\mathbf{u}, \\mathbf{v} \\rangle &amp;gt; 0</span></p>

    <p class="text-gray-300">We have:</p>

    <div class="my-4 text-center"><span class="math-block">2 ^ {a - 1} \\leq \\langle \\mathbf {u}, \\mathbf {v} \\rangle \\leq 2 ^ {a} - 1</span></div>

    <p class="text-gray-300">which implies that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2 ^ {a - 1} + 2 ^ {a - b} \\leq \\langle \\mathbf {u}, \\mathbf {v} \\rangle - 2 ^ {s} N (\\mathbf {v}) \\leq 2 ^ {a - 1} - 1</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which means that the bit length of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  at the end of the iteration must be at most  </span>a - 1$ , i.e. at least one bit shorter than its previous value.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 2:  <span class="math">a \\geq b</span>  and  <span class="math">\\langle \\mathbf{u}, \\mathbf{v} \\rangle &amp;lt; 0</span></p>

    <p class="text-gray-300">A similar analysis applies:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2 ^ {a} \\leq \\langle \\mathbf {u}, \\mathbf {v} \\rangle \\leq - 2 ^ {a - 1} - 1</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and therefore:</p>

    <p class="text-gray-300"><span class="math">-2^{a-1}\\leq\\langle\\mathbf{u},\\mathbf{v}\\rangle-2^{t}N(\\mathbf{v})\\leq 2^{a-1}-2^{a-b}-1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which again implies that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ has been shortened by at least one bit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 3: <span class="math">a&lt;b</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We have <span class="math">s=0</span>, and <span class="math">q=1</span> if <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle&gt;0</span>, <span class="math">-1</span> otherwise. We know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>N(\\mathbf{v})/2$, since the exit test on line 8 was not matched. This implies that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle-qN(\\mathbf{v})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><N(\\mathbf{v})/2<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is made strictly lower during this iteration, and the algorithm makes progress; we cannot get forever in this case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can furthermore show that if we reach this case, then the next iteration will either be the last one, or it will match one of the two other cases where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is made shorter by at least one bit. Consider that if Lagrange’s algorithm were invoked on the current basis </span>(\\mathbf{u},\\mathbf{v})<span class="math">, then it would use a value </span>q<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, and the sign of </span>q<span class="math"> would be identical to that of </span>\\langle\\mathbf{u},\\mathbf{v}\\rangle<span class="math">. In that situation, algorithm 3 uses the exact same value of </span>q=\\pm 2^{t}=\\pm 1<span class="math">, and, as such computes the same new basis as Lagrange’s algorithm. However, if Lagrange’s algorithm uses </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> for two consecutive steps, then the second step is the last one and the resulting basis is size-reduced. Correspondingly, if algorithm 3 reaches the case of </span>a<b<span class="math"> in any iteration, then either the next iteration will be in the same case, and that will yield a size-reduced basis and terminate the algorithm; or the next iteration will use one of the two other cases where </span>a\\geq b$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From this analysis, it follows that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> must be reduced by at least one bit for every two iterations, unless the algorithm reaches the exit condition after the second iteration. None of the iterations ever allows </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to grow. Therefore, the total number of iterations cannot be greater than </span>1+2\\lceil\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> (for the vectors </span>\\mathbf{u}<span class="math"> and </span>\\mathbf{v}<span class="math"> originally used as input, and with log denoting the base-2 logarithm). This proves that the algorithm always terminates, and, by construction, returns a size-reduced basis whose smaller vector is a shortest non-zero vector of the lattice </span>L$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Complexity.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The analysis above implies that the number of iterations is necessarily at most $1+2\\lceil\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\rceil<span class="math">. If </span>\\mathbf{u}<span class="math"> is the largest vector of the input </span>(\\mathbf{u},\\mathbf{v})<span class="math"> basis, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{u},\\mathbf{v}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N(\\mathbf{u})<span class="math">; therefore, the number of iterations is at most </span>1+4\\lceil\\log\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil$, i.e. linear in the size of the largest input vector.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Suppose that, at a given iteration, <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle&gt;0</span>, and <span class="math">a\\geq b</span> (where <span class="math">a=\\text{len}(\\langle\\mathbf{u},\\mathbf{v}\\rangle)</span> and <span class="math">b=\\text{len}(N(\\mathbf{v}))</span>, as in the previous analysis). Then:</p>

    <p class="text-gray-300"><span class="math">2^{2s}N(\\mathbf{v})-2^{s+1}\\langle\\mathbf{u},\\mathbf{v}\\rangle</span> <span class="math">\\leq 2^{2(a-b)}2^{b}-2^{a-b+1}2^{a-1}</span> <span class="math">\\leq 0</span></p>

    <p class="text-gray-300">i.e. <span class="math">N(\\mathbf{u})</span> (in variable <span class="math">N_{n}</span> in the algorithm) is updated by adding a value which is negative or zero. Therefore, the size of <span class="math">\\mathbf{u}</span>, the larger vector in the current <span class="math">(\\mathbf{u},\\mathbf{v})</span> basis, cannot be increased. A similar analysis holds when <span class="math">\\langle\\mathbf{u},\\mathbf{v}\\rangle&lt;0</span>. And when <span class="math">a&lt;b</span>, as in the previous analysis, our algorithm follows the same steps as Lagrange’s algorithm, in which the size of the larger vector in the basis cannot be increased either. We can thus conclude that, at all steps of the algorithm:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> can never be greater than the initial norm </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (where </span>\\mathbf{u} = (u_0, u_1)<span class="math"> and </span>\\mathbf{v} = (v_0, v_1)$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, all operations in each iteration, which are linear in the size of the operands, have cost at most $O(\\log \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Since there are </span>O(\\log \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> iterations (at most), the overall complexity of our algorithm is </span>O((\\log \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2)$, i.e. quadratic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It shall be noted that, in practice:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All values (coordinates of <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span>, squared norms <span class="math">N(\\mathbf{u})</span> and <span class="math">N(\\mathbf{v})</span>, inner product <span class="math">\\langle \\mathbf{u}, \\mathbf{v} \\rangle</span>) decrease in size as the algorithm progresses. The size reduction can be leveraged by implementations to reduce cost.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The average number of iterations is lower than $4\\lceil \\log \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math">. We measured over 500 million instances on random inputs in an EdDSA context (</span>\\mathbf{u} = (n,0)<span class="math"> and </span>\\mathbf{v} = (k,1)<span class="math">, with </span>n \\approx 2^{252}<span class="math"> and </span>k<span class="math"> chosen uniformly in </span>0 \\dots n - 1<span class="math">); the average number of iterations was 97.867 with a standard deviation of 6.222. The observed minimum and maximum numbers of iterations were 64 and 135, respectively. It is probable that the upper bound computed above (</span>4 \\times 252 = 1004$) is in fact unreachable in practice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-10" class="text-2xl font-bold">2.5 Application To Schnorr and EdDSA</h2>

    <p class="text-gray-300">When applying algorithm 3 to Schnorr and EdDSA signature verification, a number of extra optimizations are possible. We recall that, in that case, the input <span class="math">(\\mathbf{u},\\mathbf{v})</span> to the algorithm is:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{u} = (n, 0)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{v} = (k, 1)</span></div>

    <p class="text-gray-300">for the curve subgroup order <span class="math">n</span>, and some integer <span class="math">k</span> such that <span class="math">0 \\leq k &amp;lt; n</span>. The volume of the lattice is <span class="math">\\operatorname{vol}(L) = n</span> and a shortest non-zero vector has coordinates not exceeding (in absolute value) <span class="math">\\sqrt{\\gamma_2 n} \\approx \\sqrt{1.16 n}</span>.</p>

    <p class="text-gray-300">Applicable optimizations include the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Since three coordinates of the basis are statically known (only <span class="math">k</span> may change between two invocations of the algorithm), some values can be precomputed, e.g. the initial value of <span class="math">N(\\mathbf{u}) = n^2</span>.</li>

      <li>We do not need a size-reduced basis; we only need one vector. Moreover, there is no crucial need for obtaining a shortest vector, only a short enough vector. We can thus use a looser exit condition based on the current bit length of <span class="math">N(\\mathbf{v})</span>. In particular, that bit length must already be obtained for the computation of <span class="math">s</span>; reusing it makes the exit test extremely cheap.</li>

      <li>We already know the maximum length <span class="math">r</span>, in bits (including the sign bit), of the coordinates of the returned short vector: <span class="math">r = \\lfloor (\\mathrm{len}(n) + 4) / 2 \\rfloor</span>; in practice <span class="math">r = 128</span> for a 252-bit or 253-bit modulus <span class="math">n</span>. Since all operations on <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span> are additions, subtractions and left shifts, i.e. only operations with low-to-high propagation, we can keep the coordinates of <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span> over <span class="math">r</span> bits only, discarding upper bits. We will denote with “<span class="math">(\\mathrm{mod}^+ 2^r)</span>” such computations<span class="math">^2</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">^2</span>A practical implementation can use a larger value <span class="math">r</span> if that is more convenient in a given situation; truncation is allowed but not mandatory.</p>

    <p class="text-gray-300">Algorithm 4 shows these optimizations.</p>

    <p class="text-gray-300">Algorithm 4 Improved algorithm applied to Schnorr and EdDSA signature verification Require: Prime integer  <span class="math">n</span>  ,integer  <span class="math">k</span>  such that  <span class="math">0\\leq k &amp;lt;   n</span> <span class="math">\\triangleright n</span>  is known statically. Ensure: A short non-zero vector  <span class="math">(v_{0},v_{1})</span>  such that  <span class="math">v_{0} = v_{1}k</span>  mod  <span class="math">n</span> 1:  <span class="math">N_{u}\\gets n^{2},N_{v}\\gets k^{2} + 1,p\\gets nk</span> <span class="math">\\triangleright N_u</span>  is known statically. 2:  <span class="math">r\\gets \\lfloor (\\mathrm{len}(n) + 4) / 2\\rfloor ,t\\gets \\mathrm{len}(n) + 1</span> <span class="math">\\triangleright t</span>  is the target length for  <span class="math">N(\\mathbf{v})</span> 3:  <span class="math">(u_0,u_1)\\gets (n,0)</span>  (mod\\<em>2r) 4:  <span class="math">(v_{0},v_{1})\\gets (k,1)</span>  (mod\\</em>2r)  <span class="math">\\triangleright</span>  Coordinates are represented over  <span class="math">r</span>  bits. 5: loop 6: if  <span class="math">N_{u} &amp;lt;   N_{v}</span>  then 7: swap  <span class="math">(u_0,u_1)</span>  with  <span class="math">(v_{0},v_{1})</span> 8: swap  <span class="math">N_{u}</span>  with  <span class="math">N_{v}</span> 9: if len(Nv)  <span class="math">\\leq t</span>  then This test matches when  <span class="math">(v_{0},v_{1})</span>  is short enough. 10: return  <span class="math">(v_{0},v_{1})</span> 11:  <span class="math">s\\gets \\max (0,\\mathrm{len}(p) - \\mathrm{len}(N_v))</span> <span class="math">\\triangleright</span>  len(Nv) was already computed on line 9. 12: if  <span class="math">p &amp;gt; 0</span>  then 13:  <span class="math">(u_0,u_1)\\gets (u_0 - 2^s v_0,u_1 - 2^s v_1)</span>  (mod\\<em>2r) 14:  <span class="math">N_{u}\\gets N_{u} + 2^{2s}N_{v} - 2^{s + 1}p</span> 15:  <span class="math">p\\gets p - 2^s N_v</span> 16: else 17:  <span class="math">(u_0,u_1)\\gets (u_0 + 2^s v_0,u_1 + 2^s v_1)</span>  (mod\\</em>2r) 18:  <span class="math">N_{u}\\gets N_{u} + 2^{2s}N_{v} + 2^{s + 1}p</span> 19:  <span class="math">p\\gets p + 2^s N_v</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As was analyzed,  <span class="math">N_{u}</span>  and  <span class="math">N_{v}</span>  decrease regularly through the algorithm, and thus do not need more bits than the initial value  <span class="math">N_{u} = n^{2}</span> , which is statically known.  <span class="math">N_{u}</span>  and  <span class="math">N_{v}</span>  are always nonnegative, and therefore do not need an extra sign bit. The inner product  <span class="math">p</span> , on the other hand, can become negative. Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N_{u}<span class="math"> , only one more bit than for the representation of  </span>N_{u}$  is sufficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Some extra analysis can help with reducing size. In particular, if working with a 256-bit curve such as P-256 or secp256k1, with a prime order  <span class="math">n</span>  very close to  <span class="math">2^{256}</span> , the analysis above would mean that 513 bits are needed, in all generality, to encode  <span class="math">p</span> , which is inconvenient if, for instance, using 64-bit limbs: this would require an extra ninth limb. However, the following can easily be seen:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The initial value of  <span class="math">p</span>  is known to be nonnegative. Therefore, the first iteration does not formally need to store the sign bit of  <span class="math">p</span> .</li>

      <li>After the first iteration, the value of  <span class="math">p</span>  is necessarily at least one bit shorter (in absolute value) than the initial maximum  <span class="math">n^2</span> , leaving room for a sign bit.</li>

    </ul>

    <p class="text-gray-300">Thus, provided that the first iteration uses a special treatment for the sign of  <span class="math">p</span> , an  <span class="math">m</span> -bit curve can be handled with a storage size of  <span class="math">2m</span>  bits for each of  <span class="math">N_u</span> ,  <span class="math">N_v</span>  and  <span class="math">p</span> .</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">We implemented our improved algorithm (algorithm 4) for faster Schnorr signature verification over Curve9767[12], a prime-order Weierstraß curve well suited to embedded systems. Curve9767 source code is available on:</p>

    <p class="text-gray-300">https://github.com/pornin/curve9767</p>

    <p class="text-gray-300">Several implementations are provided, for different architectures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>src/scalar_ref.c: reference implementation in portable C code.</li>

      <li>src/scalar_cm0.s: optimized assembly for ARM Cortex M0 and M0+ (ARMv6-M architecture).</li>

      <li>src/scalar_cm4.s: optimized assembly for ARM Cortex M4 (ARMv7-M architecture).</li>

      <li>src/scalar_amd64.c: optimized assembly for x86 in 64-bit mode (the 128-bit type __int128 and carry-propagation intrinsics are used).</li>

    </ul>

    <p class="text-gray-300">Curve9767 order is <span class="math">n \\approx 2^{251.82}</span>, i.e. a 252-bit integer. The two short vector coordinates will thus fit over <span class="math">r = 128</span> bits each, including the sign bit. Values <span class="math">\\mathcal{N}_u</span>, <span class="math">\\mathcal{N}_v</span> and <span class="math">p</span> use up to 505 bits each, including the sign bit (as pointed out in section 2.5, <span class="math">\\mathcal{N}_u</span> and <span class="math">\\mathcal{N}_v</span> are always positive, and the extra bit for <span class="math">p</span> is not really needed; thus, 504 bits would be sufficient).</p>

    <p class="text-gray-300"><strong>Integer Representation.</strong> Integer values are represented as sequences of limbs; each limb has size <span class="math">w</span> bits, and is a "digit" in base <span class="math">2^w</span>. Additions and subtractions are performed on a limb-by-limb basis. In the reference portable C code, we use <span class="math">w = 30</span>, so that intermediate values fit in a 32-bit type (uint32_t); thus, <span class="math">\\mathcal{N}_u</span>, <span class="math">\\mathcal{N}_v</span> and <span class="math">p</span> use 17 limbs each, and the vector coordinates <span class="math">u_0</span>, <span class="math">u_1</span>, <span class="math">v_0</span> and <span class="math">v_1</span> use 5 limbs each. In the specialized implementations, we can leverage the carry/borrow flag offered by the CPU (but inaccessible from portable C code); thus, we can use <span class="math">w = 32</span> for the ARM implementations (16 limbs for <span class="math">\\mathcal{N}_u</span>, <span class="math">\\mathcal{N}_v</span> and <span class="math">p</span>, 4 limbs for <span class="math">u_0</span>, <span class="math">u_1</span>, <span class="math">v_0</span> and <span class="math">v_1</span>), and <span class="math">w = 64</span> for the 64-bit x86 implementation (8 limbs for <span class="math">\\mathcal{N}_u</span>, <span class="math">\\mathcal{N}_v</span> and <span class="math">p</span>, 2 limbs for <span class="math">u_0</span>, <span class="math">u_1</span>, <span class="math">v_0</span> and <span class="math">v_1</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\mathcal{N}_u</span>, <span class="math">\\mathcal{N}_v</span> and <span class="math">p</span> decrease over the course of the algorithm, we can switch to code with fewer limbs when these values have become short enough. At each iteration, <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span> are conditionally swapped to ensure that <span class="math">\\mathbf{u}</span> is the larger vector; we can thus use the size of <span class="math">\\mathcal{N}_u</span> to decide when the alternate code with fewer limbs is safe. This strategy is applied in the x86 code, with a switch to 6 limbs then <span class="math">\\mathcal{N}_u &amp;lt; 2^{383}</span> (we know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathcal{N}_u$, but we need an extra sign bit, hence a threshold at 383 instead of 384 bits). In the ARM implementations, the number of limbs is similarly decreased when possible, but always kept even for implementation reasons (the addition, subtraction and shift loops use iterations that process two limbs at a time, to better optimize memory accesses).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Bit Length.</strong> Our algorithm must evaluate the exact bit length of big integers (<span class="math">\\mathcal{N}_v</span> and <span class="math">p</span>). This requires locating the most significant non-zero limb value, then the most significant non-zero bit within that limb value. In all generality, finding the position of the highest non-zero bit in a word of <span class="math">w</span> bits can be done with a dichotomic search, with <span class="math">\\log w</span> steps. This is how we implement it in the reference C code, and in the ARM Cortex M0 implementation. Some</p>

    <p class="text-gray-300">architectures offer dedicated opcodes that can make that operation much faster: on the ARM Cortex M4, we use the clz opcode, which returns the number of leading zeros in a 32-bit word in a single clock cycle; on x86, the lzcnt opcode (_lzcnt_u64() intrinsic function) offers the same service.</p>

    <p class="text-gray-300">Variable Time Processing. Cryptographic implementations that run on physical systems, as opposed to abstract mathematical models of computing machines, may leak information about the values they process through side channels. In particular, side channels based on timing measures can often be efficiently exploited, possibly from remote view points. Implementations that do not have such side channel information leaks are said to be constant-time. In particular, constant-time code should not contain conditional jumps that depend on secret data, or make memory accesses at addresses that depend on secret data. Our lattice basis reduction algorithm is inherently not constant-time: the conditional swap of <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span>, the sign of <span class="math">q</span>, the switch to shorter representations... all use conditional jumps that depend on the reduced value. This is usually considered tolerable for signature verification, because only the public key is used, and it is, by definition, non-secret.</p>

    <p class="text-gray-300">One can imagine contrived scenarios in which a constant-time signature verification algorithm must remain secret: for instance, the signed message is secret but of low entropy (e.g. a human-memorable password), and the second half of the signature (the <span class="math">s</span> value in a signature <span class="math">(R,s)</span>) is somehow conveyed secretly to the verifier along with the signed message. In that case, the attacker cannot obtain enough information to run an offline dictionary attack on the message, but timing-based side channels in the signature verification algorithm can yield such information. Such scenarios are not very plausible, but we nonetheless provide two Schnorr signature verification implementations in the Curve9767 code:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>curve9767_sign_verify() is constant-time and does not use lattice basis reduction.</li>

      <li>curve9767_sign_verify_vartime() is not constant-time; it uses our improved lattice basis reduction algorithm and is faster than the constant-time implementation.</li>

    </ul>

    <p class="text-gray-300">Point Multiplication Algorithms. The constant-time signature verification algorithm uses Straus’s algorithm. The function computes <span class="math">sB - kA</span> with <span class="math">s</span> and <span class="math">k</span> having the same size as the curve order <span class="math">n</span>; two windows are computed with multiples of <span class="math">A</span> and <span class="math">B</span> (multiples of <span class="math">B</span> are precomputed, since <span class="math">B</span> is fixed, but multiple of <span class="math">A</span> must be computed at the start of the function and stored in a temporary stack buffer). For instance, the ARM implementations use 4-bit windows; every four point doublings, a point <span class="math">jA</span> and a point <span class="math">j&#x27;B</span> are added, with <span class="math">-8 \\leq j &amp;lt; 8</span> and <span class="math">-8 \\leq j&#x27; &amp;lt; 8</span>. Since point negation is inexpensive to compute dynamically, only 8 points <span class="math">jA</span> (<span class="math">1 \\leq j \\leq 8</span>) need to be stored in the stack.</p>

    <p class="text-gray-300">When applying the improved lattice basis reduction algorithm, we now have to compute a linear combination of four points, as explained in section 1. Two of these points are fixed <span class="math">(B</span> and <span class="math">2^{m/2}B)</span>, but two are obtained dynamically. Using 4-bit windows would then imply storing twice as many points on the stack (8 points for the <span class="math">A</span> window, and 8 other points for the <span class="math">R</span> window). Since stack space is usually a scarce resource on embedded systems, we leveraged the fact that a variable-time algorithm does need to follow a strict schedule of point additions; instead, we can use a non-adjacent form algorithm such that stored windows only need points <span class="math">jA</span> and <span class="math">jR</span> for odd values of <span class="math">j</span>. Indeed, if the window algorithm would call for adding point <span class="math">6A</span> at some step in the sequence of point doublings, we can add point <span class="math">3A</span> one</p>

    <p class="text-gray-300">doubling earlier. This trick allows for twice smaller windows, thereby reducing stack usage to the same amount as in the constant-time algorithm.</p>

    <p class="text-gray-300">Use of NAF also lowers the average number of point additions (even with a nominally 4-bit window, additions are applied on average once every five doublings), and we could make the windows for <span class="math">B</span> and <span class="math">2^{m/2}B</span> larger, since these use only comparatively cheaper ROM/Flash.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Cofactor.</h4>

    <p class="text-gray-300">As explained in section 1, the signature verification equation is a linear combination of four curve points (<span class="math">B</span>, <span class="math">2^{m/2}B</span>, <span class="math">A</span> and <span class="math">R</span>, with <span class="math">B</span> being the conventional generator, <span class="math">A</span> the public key, and <span class="math">R</span> a point provided as part of the signature); once this linear combination has been computed, it must still be multiplied by the cofactor <span class="math">b</span>. Multiplication by the cofactor is not strictly necessary as per the usual definition of the security of a signature algorithm, but not applying it can induce discrepancies between verifiers about the status of some nominally invalid signature values. Suppose that multiplication by the cofactor <span class="math">b</span> is not used; the usual signature verification is:</p>

    <p class="text-gray-300"><span class="math">sB-kA=R</span></p>

    <p class="text-gray-300">while our modified verification equation is:</p>

    <p class="text-gray-300"><span class="math">e_{0}B+e_{1}2^{m/2}B-(\\delta k\\bmod n)A-\\delta R=\\mathbb{O}</span></p>

    <p class="text-gray-300">If there is on the curve a non-trivial point <span class="math">T</span> of order <span class="math">b</span>, then replacing <span class="math">R</span> with <span class="math">R+T</span> will make the standard verification equation fail, but the second one will still accept the signature if it so happens that the value <span class="math">\\delta</span> (obtained from the lattice basis reduction algorithm) turns out to be a multiple of <span class="math">b</span>.</p>

    <p class="text-gray-300">Edwards curves, as used in EdDSA, always have a cofactor <span class="math">b</span> which is a multiple of 4 (for Ed25519, the cofactor is <span class="math">b=8</span>). A consequence is that an EdDSA signature verification implementation that uses our improved lattice basis reduction algorithm cannot guarantee that a seemingly valid signature would be deemed acceptable by any other standard-compliant implementation. Signature values that exhibit such discrepancies are nominally invalid and cannot be produced by a valid signature generator; moreover, the security model of signatures is still maintained: that kind of signature may exist only if the private key owner really computed a signature over the same message. However, for protocols that require full agreement of all parties about which signature values are valid or not (e.g. consensus protocols in some distributed systems), it is recommended to apply point normalization, i.e. multiplying by the cofactor <span class="math">b</span> systematically.</p>

    <p class="text-gray-300">On Curve9767, this is a non-issue: Curve9767 has a prime order, which means that the cofactor is <span class="math">b=1</span>, and these point normalization issues simply go away. This is one of the reasons why prime order curves are, in all generality, preferable. It is possible to build a prime-order group, amenable to Schnorr signatures, over any Edwards curves with cofactor 4 or 8; this is known as the Ristretto construction<em>[2]</em> and it has relatively small computational overhead over the underlying Edwards curve.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Benchmarks.</h4>

    <p class="text-gray-300">Our implementation of Curve9767 has been benchmarked over three systems:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ARM Cortex-M0+: SAM D20 Xplained Pro board (ATSAMD20J18 microcontroller), clocked at 8 MHz, zero wait state for Flash access. Compiler is GCC-7.3.1, with flags:</li>

      <li>-Os -mthumb -mlong-calls -mcpu=cortex-m0plus</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ARM Cortex-M4: STM32F4 "discovery" board (STM32F407VG-DISC1), clocked at 24 MHz, zero wait state (I-cache and D-cache are enabled, but disabling them does not change timings). Compiler is GCC-7.3.1, with flags:</li>

    </ul>

    <p class="text-gray-300">-0s -mthumb -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-s16</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>x86 (64-bit) with AVX2: Intel i5-8259U (Coffee Lake) at 2.3 GHz (TurboBoost is disabled). Compiler is Clang-9.0.0, with flags:</li>

    </ul>

    <p class="text-gray-300">-03 -mavx2 -mlzcnt</p>

    <p class="text-gray-300">All timings below are in clock cycles. For the ARM implementations, reported times include all opcodes that are part of the function, including the final "ret" (opcodes "bx 1r" or "pop { pc }"); however, the costs of the call opcode itself (b1) and the push/removal of function arguments are not accounted as part of the reported costs. For x86 implementations, the cycle counter has been used (1fence memory barrier, followed by the rdtsc opcode), but the "exact" cost of a function is ill-defined on a system with a deep pipeline with out-of-order execution; reported execution time is the best observed over several executions, with some "warm-up" calls to ensure relevant caches are filled. For functions with a variable execution time, randomized inputs have been used over a few hundred cycles; these values are indicated below with the "≈" sign.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cortex M0+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cortex M4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x86+AVX2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lattice basis reduction (vartime)</td>

            <td class="px-3 py-2 border-b border-gray-700">≈106300</td>

            <td class="px-3 py-2 border-b border-gray-700">≈92010</td>

            <td class="px-3 py-2 border-b border-gray-700">≈15250</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDH: key pair generation</td>

            <td class="px-3 py-2 border-b border-gray-700">1937792</td>

            <td class="px-3 py-2 border-b border-gray-700">887520</td>

            <td class="px-3 py-2 border-b border-gray-700">172660</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDH: compute shared secret</td>

            <td class="px-3 py-2 border-b border-gray-700">4598756</td>

            <td class="px-3 py-2 border-b border-gray-700">2054792</td>

            <td class="px-3 py-2 border-b border-gray-700">392714</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Schnorr signature: generate</td>

            <td class="px-3 py-2 border-b border-gray-700">2054110</td>

            <td class="px-3 py-2 border-b border-gray-700">965850</td>

            <td class="px-3 py-2 border-b border-gray-700">182892</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Schnorr signature: verify</td>

            <td class="px-3 py-2 border-b border-gray-700">5688642</td>

            <td class="px-3 py-2 border-b border-gray-700">2565404</td>

            <td class="px-3 py-2 border-b border-gray-700">543176</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Schnorr signature: verify (vartime)</td>

            <td class="px-3 py-2 border-b border-gray-700">≈3818000</td>

            <td class="px-3 py-2 border-b border-gray-700">≈1779000</td>

            <td class="px-3 py-2 border-b border-gray-700">≈380500</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The table above shows benchmarks not only for the signature verification itself, but also for some other operations which can serve as a basis for comparison:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ECDH, key pair generation: computation of  <span class="math">kB</span> , for a secret scalar  <span class="math">k</span>  and the conventional generator  <span class="math">B</span> .</li>

      <li>ECDH, shared secret computation: computation of  <span class="math">kQ</span> , for a secret scalar  <span class="math">k</span>  and a dynamically received point  <span class="math">Q</span> .</li>

      <li>Schnorr signature generation: computation of  <span class="math">rB</span> , for a secret scalar  <span class="math">r</span>  and the conventional generator  <span class="math">B</span> , and a few extra operations (hashing, and one multiplication and one addition modulo the curve order  <span class="math">n</span> ).</li>

    </ul>

    <p class="text-gray-300">The measured times also include decoding of received points, which involves point decompression (reconstruction of the  <span class="math">y</span>  coordinate of the point, using the curve equation and a square root extraction), but this operation is very fast with Curve9767, because its base field allows for efficient square root routines.</p>

    <p class="text-gray-300">In the case of the ARM Cortex M0+, the savings obtained from the improved signature verification algorithm split roughly as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Halving the number of doublings: about 1.67 million cycles saved.</li>

      <li>Reduction of the number of point additions through NAF: about 302000 cycles saved.</li>

      <li>Lattice basis reduction overhead: about 106300 cycles.</li>

    </ul>

    <p class="text-gray-300">Exactly how much time is saved by halving the number of doublings depends on the used curve, hardware architecture and implementation strategy. For Curve9767, overall savings are about 30 to 33%, compared with the constant-time verification implementation. On a faster curve, the savings may be comparatively lower. On Ed25519, the fastest reported signature verification times[9] are about 110000 cycles; even if only (for instance) 25% of the cost is avoided by the reduction in the number of point doublings, the cost savings would exceed the overhead due to the lattice basis reduction algorithm, since the latter uses only an average of 15250 cycles. Thus, even on that very fast curve, our improved algorithm should make the application of the Antipa et al method worthwhile.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Conclusion</h2>

    <p class="text-gray-300">We presented here a novel variant of Lagrange's algorithm, which allows non-negligible savings in the implementation of Schnorr signature verification. As described by Antipa et al[1], the method also applies to ECDSA, albeit with some extra complications due to the fact that the first half of an ECDSA signature is not the complete curve point <span class="math">R</span>, but only the <span class="math">x</span> coordinate of that point (and furthermore reduced modulo the curve subgroup order).</p>

    <p class="text-gray-300">An open question is how fast a constant-time implementation of the lattice basis reduction algorithm could be. Conditional exchanges, shifts and additions and subtractions can be turned into constant-time code with some overhead; moreover, the total number of iterations in a constant-time implementation must match the worst possible case, and our current analysis yields a worst case which is likely to be wildly exaggerated (more than a thousand iterations, while the worst observed case was 135 iterations). More analysis is needed to tighten this bound.</p>

    <p class="text-gray-300">An application of our method to other curves, in particular Ed25519, should be produced and benchmarked.</p>

    <h2 id="sec-15" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Isis Lovecraft for useful discussions about, and review of drafts of, this article.</p>

    <h2 id="sec-16" class="text-2xl font-bold">References</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Antipa, D. Brown, R. Gallant, R. Lambert, R. Struik and S. Vanstone, Accelerated Verification of ECDSA signatures, Selected Areas in Cryptography - SAC 2005, Lecture Notes in Computer Science, vol 3897, pp. 307-318, 2005.</li>

      <li>T. Arcieri, I. Lovecraft and H. de Valence, The Ristretto Group, https://ristretto.group/</li>

      <li>D. Bernstein, N. Duif, T. Lange, P. Schwabe and B.-Y. Yang, High-speed high-security signatures, Journal of Cryptographic Engineering, vol. 2, issue 2, pp. 77-89, 2012.</li>

      <li>R. Gallant, J. Lambert and S. Vanstone, Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms, Advances in Cryptology - CRYPTO 2001, Lecture Notes in Computer Science, vol. 20139, pp. 190-200, 2001.</li>

      <li>C. F. Gauss, Disquisitiones Arithmeticae, Springer-Verlag, 1801.</li>

      <li>S. Josefsson and I. Liusvaara, Edwards-Curve Digital Signature Algorithm (EdDSA), https://tools.ietf.org/html/rfc8032</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>C. Hermite, Extraits de lettres de M. Ch. Hermite à M. Jacobi sur différents objets de la théorie des nombres (première lettre), Journal für die reine und angewandte Mathematik, vol. 40, pp. 261-277, 1850.</li>

      <li>J.-L. Lagrange, Recherches d'arithmetique, Nouveaux mémoires de l'Académie royale des sciences et belles-lettres de Berlin, pp. 695-795, 1773.</li>

      <li>I. Lovecruft and H. de Valence, Dalek cryptography, https://dalek.rs/</li>

      <li>H. Minkowski, Geometrie der Zahlen, Teubner-Verlag, 1896.</li>

      <li>P. Nguyen and D. Stehlé, Low-Dimensional Lattice Basis Reduction Revisited, Algorithmic Number Theory - ANTS 2004, Lecture Notes in Computer Science, vol 3076, pp. 338-357, 2004.</li>

      <li>T. Pornin, Efficient Elliptic Curve Operations On Microcontrollers With Finite Field Extensions, https://eprint.iacr.org/2020/009</li>

      <li>C.-P. Schnorr, Efficient Identification and Signatures for Smart Cards, Advances in Cryptology - CRYPTO '89, Lecture Notes in Computer Science, vol. 435, pp. 239-252, 1989.</li>

      <li>E. Straus, Addition chains of vectors (problem 5125), American Mathematical Monthly, vol. 70, pp. 806-808, 1964.</li>

    </ol>

    <p class="text-gray-300">16</p>`;
---

<BaseLayout title="Optimized Lattice Basis Reduction In Dimension 2, and Fast S... (2020/454)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/454
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
