---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/788';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Somewhere Statistical Soundness, Post-Quantum Security, and SNARGs';
const AUTHORS_HTML = 'Yael Tauman Kalai, Vinod Vaikuntanathan, Rachel Yun Zhang';

const CONTENT = `    <p class="text-gray-300">Somewhere Statistical Soundness, Post-Quantum Security and SNARGs</p>

    <p class="text-gray-300">Yael Tauman Kalai* Microsoft Research</p>

    <p class="text-gray-300">Vinod Vaikuntanathan† MIT</p>

    <p class="text-gray-300">Rachel Yun Zhang‡ MIT</p>

    <p class="text-gray-300">August 19, 2021</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">The main conceptual contribution of this paper is a unification of two leading paradigms for constructing succinct argument systems, namely Kilian’s protocol and the BMW (Biehl-Meyer-Wetzel) heuristic. We define the notion of a <em>multi-extractable somewhere statistically binding</em> (meSSB) <em>hash family</em>, an extension of the notion of somewhere statistically binding hash functions (Hubacek and Wichs, ITCS 2015), and construct it from LWE. We show that when instantiating Kilian’s protocol with a meSSB hash family, the first two messages are simply an instantiation of the BMW heuristic. Therefore, if we also instantiate it with a PCP for which the BMW heuristic is sound, e.g., a computational non-signaling PCP, then the first two messages of the Kilian protocol is a sound instantiation of the BMW heuristic.</p>

    <p class="text-gray-300">This leads us to two technical results. First, we show how to efficiently convert any succinct non-interactive argument (SNARG) for BatchNP into a SNARG for any language that has a computational non-signaling PCP. Put together with the recent and independent result of Choudhuri, Jain and Jin (Eprint 2021/808) which constructs a SNARG for BatchNP from LWE, we get a SNARG for any language that has a computational non-signaling PCP, including any language in P, but also any language in NTISP (non-deterministic bounded space), from LWE.</p>

    <p class="text-gray-300">Second, we introduce the notion of a somewhere statistically sound (SSS) interactive argument, which is a hybrid between a statistically sound proof and a computationally sound proof (a.k.a. an argument), and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>prove that Kilian’s protocol, instantiated as above, is an SSS argument;</li>

      <li>show that the soundness of SSS arguments can be proved in a straight-line manner, implying that they are also post-quantum sound if the underlying assumption is post-quantum secure; and</li>

      <li>conjecture that constant-round SSS arguments can be soundly converted into non-interactive arguments via the Fiat-Shamir transformation.</li>

    </ul>

    <p class="text-gray-300">*E-mail:yael@microsoft.com †E-mail:vinodv@csail.mit.edu ‡E-mail:rachelyz@mit.edu</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Multi-Extractable Somewhere Statistically Binding (meSSB) Hash Families 2 1.2 Somewhere Statistically Sound (SSS) Interactive Arguments 3 1.2.1 SSS, Straight-Line Soundness and Post-Quantum Security 5 1.2.2 SSS and Fiat-Shamir Friendliness 5 1.2.3 Instantiating an SSS version of Kilian 6 1.3 SNARGs: from BatchNP to P and Beyond 7</p>

    <p class="text-gray-300">2 Preliminaries 8 2.1 Straight-Line Reductions 9 2.2 Probabilistically Checkable Proofs (PCP) 9 2.3 Hash Function Families with Local Opening 11 2.4 Kilian's Protocol. 12 2.5 The BMW Heuristic. 12</p>

    <p class="text-gray-300">3 Somewhere Statistically Binding Hash Functions 13 3.1 Extractable Somewhere Statistically Binding (eSSB) Hash Functions 14 3.2 Multi-Extractable SSB (meSSB) Hash Functions 15 3.3 The BMW Protocol with meSSB Hash Families 17</p>

    <p class="text-gray-300">4 Somewhere Statistically Sound Interactive Arguments 19 4.1 Defining SSS Arguments 19 4.2 SSS implies Straight-Line Soundness 20 4.3 SSS implies Post-Quantum Soundness 20</p>

    <p class="text-gray-300">5 Kilian's Protocol is Somewhere Statistically Sound 21</p>

    <p class="text-gray-300">6 SNARG for Languages with Non-Signaling PCPs 24 6.1 BatchNP 24 6.1.1 SNARGs for BatchNP 24 6.2 SNARG for Languages with a Non-Signaling PCP 25 6.2.1 SNARGs for <span class="math">\\mathcal{L}</span> from SNARGs for BatchNP with Succinct Instances 26 6.2.2 SNARGs for <span class="math">\\mathcal{L}</span> from SNARGs for BatchNP with Low Depth Verifier 30</p>

    <p class="text-gray-300">A Proof of Theorem 3.6 39</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In the past decade, there has been a significant effort to construct efficiently verifiable, succinct, and non-interactive argument systems (also called SNARGs). In our work, we propose two paths towards obtaining SNARGs for P as well as for certain sub-classes of NP. Our approaches are motivated by Kilian’s celebrated work <em>[x10]</em> that converts any PCP into an interactive argument using a tree hash <em>[x13]</em>.</p>

    <p class="text-gray-300">Recall that in Kilian’s protocol, the prover tree-commits to a PCP using a hash key generated by the verifier and sends the resulting commitment to the verifier. The verifier then samples a PCP query at random and sends it to the prover. The prover must then send back answers to the PCP queries along with verification paths for each answer w.r.t. the previously sent commitment.</p>

    <p class="text-gray-300">We take a somewhat anachronistic view and see Kilian’s four-message, public-coin interactive argument as a natural interpolation of the two-message, privately verifiable Biehl-Meyer-Wetzel (BMW) heuristic.</p>

    <p class="text-gray-300">Recall that the BMW heuristic takes any PCP and any (computationally secure) single-sever PIR scheme, and uses them to construct a two-message succinct argument where the verifier sends each PCP query to the prover as a PIR query, and the prover runs the PIR protocol with the database being the PCP proof string, and responds accordingly (see Section 2.5 for more details). The BMW heuristic is not known to be sound in general <em>[DLN^{+}04, x1]</em>; however, it is known to be computationally sound if it is instantiated with a PCP with a special property known as computational non-signaling <em>[x12, x2]</em>. We note that not all NP languages have such a (computational non-signaling) PCP, and such a PCP was constructed only for P <em>[x12, x2]</em> and some sub-classes of NP such as NTISP <em>[BKK^{+}18]</em>. We refer to such PCPs for which the BMW heuristic is computationally sound as BMW-compatible. Note that the BMW heuristic results in a privately verifiable protocol since the verifier needs to run the PIR decoding algorithm on the prover’s message, in a sense decrypting it using a private key.</p>

    <p class="text-gray-300">Constructing two-message publicly verifiable succinct arguments, which in turn give us SNARGs in the common reference string model, appears to be a significantly harder challenge. Indeed, the only construction we have of SNARGs under a post-quantum assumption is restricted to bounded depth computations <em>[x11]</em>. One attempt to constructing a SNARG for all of P was recently made in <em>[x14]</em>, which showed how to convert the BMW heuristic to a publicly verifiable one by relying on a primitive called zero-testable encryption <em>[x15]</em>. In addition, they gave a construction of this primitive under a complexity assumption on groups with bilinear maps. This left open the problem of relying on more standard and ideally post-quantum secure assumptions, a problem which we tackle in this work.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.1 Multi-Extractable Somewhere Statistically Binding (meSSB) Hash Families</p>

    <p class="text-gray-300">As a starting point, consider instantiating Kilian’s protocol with a somewhere statistically binding (SSB) hash function <em>[x13]</em> in place of a generic tree hash. Recall that an SSB hash family is a hash family <span class="math">\\mathcal{H}</span> where each hash key hk is associated with an index <span class="math">i\\in[L]</span>, where <span class="math">L</span> is the length of the input, such that <span class="math">\\textsf{Hash}(\\textsf{hk},x)</span> is statistically binding on <span class="math">x_{i}</span>, and importantly, the key hk hides the index <span class="math">i</span>. In this work we consider extractable SSB (eSSB) hash families, which are SSB hash families with the additional property that one can extract <span class="math">x_{i}</span> from the hash value <span class="math">\\textsf{Hash}(\\textsf{hk},x)</span> given a trapdoor td that is generated together with hk (see Section 2.3, Definition 3.1).</p>

    <p class="text-gray-300">We observe that an eSSB hash family is essentially a (computational) single-server PIR scheme, where the query corresponding to index <span class="math">i</span> is the hash key hk associated with the index <span class="math">i</span>, the database answer corresponding to database <span class="math">x</span> simply runs <span class="math">\\textsf{Hash}(\\textsf{hk},x)</span>, and given the trapdoor td corresponding to hk one can indeed extract <span class="math">x_{i}</span> from <span class="math">\\textsf{Hash}(\\textsf{hk},x)</span>, without revealing the secret index <span class="math">i</span>. Armed with this observation, we note that if we instantiate Kilian’s protocol with an eSSB hash family, the first two messages are quite similar to the BMW heuristic, the difference being that the BMW heuristic uses many PIR queries (as many as the number of PCP queries), whereas an eSSB families support a single PIR query.</p>

    <p class="text-gray-300">To remedy this, we consider the notion of a multi-extractable SSB (meSSB) hash family, where each key hk is associated with several indices <span class="math">i_{1},\\ldots,i_{\\ell}\\in[N]</span>, and is generated with trapdoors <span class="math">\\textsf{td}_{1},\\ldots,\\textsf{td}_{\\ell}</span>, such that one can extract <span class="math">x_{i_{1}},\\ldots,x_{i_{\\ell}}</span> from <span class="math">\\textsf{Hash}(\\textsf{hk},x)</span>. Importantly, since in the BMW heuristic each query is generated using fresh randomness, to match this heuristic, we need to require that for every <span class="math">i\\in[\\ell]</span>, the index <span class="math">i</span> remains hidden, even given the key hk and all the trapdoors <span class="math">\\{\\textsf{td}_{j}\\}_{j\\in[\\ell]\\setminus\\{i\\}}</span>. We note that if we instantiate Kilian’s protocol with a meSSB hash family then the first two messages are precisely the BMW heuristic! This observation is the first conceptual contribution of this work.</p>

    <p class="text-gray-300">This instantiation of Kilian’s protocol with a meSSB hash family can alternatively be thought of as a way of converting the BMW protocol to a publicly verifiable one, albeit at the cost of adding two rounds. In this instantiation, we execute the BMW heuristic, but the verifier never decrypts the PIR answers. Instead, we view the PIR answers as a commitment to the PCP, and we add two messages, where the verifier sends PCP queries in the clear, and the prover decommits to the answers. These additional messages are in lieu of the verifier decrypting the PIR answers by himself.</p>

    <p class="text-gray-300">Starting with this observation, we proceed to offer two paths to convert Kilian’s protocol into a SNARG.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">The Fiat-Shamir Paradigm.</h4>

    <p class="text-gray-300">The first approach, which we elaborate on in Section 1.2, considers applying the Fiat-Shamir paradigm to Kilian’s protocol when instantiated with a meSSB hash family and with a BMW-compatible PCP. At first it may seem that this approach is doomed to fail, in light of the recent negative result of <em>[BBH^{+}19]</em>, which shows that the Fiat-Shamir paradigm is not sound when applied to Kilian’s protocol. However, we argue that this specific instantiation of Kilian’s protocol has a special property, which we refer to as somewhere statistical soundness (SSS), that allows it to evade this specific negative result. We conjecture that SSS protocols are</p>

    <p class="text-gray-300">Fiat-Shamir friendly, meaning that for any SSS protocol there is some choice of hash function using which the application of the Fiat-Shamir paradigm to the protocol is sound. Additionally, we argue that SSS protocols are of independent interest. In particular, we prove that every SSS protocol has a straight-line soundness proof and as a result is post-quantum sound (assuming the underlying assumption is post-quantum secure). We elaborate on this in Section 1.2.</p>

    <h5 id="sec-3" class="text-base font-semibold mt-4">Using SNARGs for BatchNP.</h5>

    <p class="text-gray-300">The second approach we consider is to use a SNARG for BatchNP to convert the first two messages in the above instantiation of Kilian’s protocol for a language <span class="math">L</span> into a SNARG for <span class="math">L</span>. A similar result was shown independently by <em>[x10]</em>. We elaborate on this in Section 1.3.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Somewhere Statistically Sound (SSS) Interactive Arguments</h3>

    <p class="text-gray-300">One noteworthy property of our instantiation of Kilian’s protocol is that due to the soundness of the BMW heuristic, with high probability a cheating prover is statistically committed to incorrect answers on the particular locations specified by the meSSB hash function. Thus, if the verifier’s PCP query points to exactly the locations that are statistically bound by the meSSB hash function, the verifier is guaranteed to reject no matter what the final message of the prover is. We call this <em>somewhere statistical soundness</em> (SSS), in analogy with somewhere statistical binding.</p>

    <p class="text-gray-300">We can extend this to multi-round protocols just as well, however we focus on <span class="math">4</span>-round protocols where, without loss of generality, we assume that the first message is sent by the verifier. Formally, an interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> is said to be SSS if for every legal first message <span class="math">\\beta_{1}</span>, there exists a third message <span class="math">\\beta_{2}=T(\\beta_{1})</span> sent by the verifier such that the following two properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every poly-size <em>deterministic</em> cheating prover <span class="math">\\mathcal{P}^{<em>}</span>, conditioned on the first three messages being <span class="math">(\\beta_{1},\\mathcal{P}^{</em>}(\\beta_{1}),T(\\beta_{1}))</span> the remaining protocol is statistically sound with overwhelming probability over <span class="math">\\beta_{1}</span>. Namely, for any <span class="math">x\\notin L</span> and any (deterministic) poly-size <span class="math">\\mathcal{P}^{<em>}</span>, with overwhelming probability, any (even all powerful) cheating prover cannot convince the verifier to accept <span class="math">x\\notin L</span> except with negligible probability, </em>conditioned on the first three messages being <span class="math">(\\beta_{1},\\mathcal{P}^{*}(\\beta_{1}),T(\\beta_{1}))</span>.</li>

      <li>The pair <span class="math">(\\beta_{1},T(\\beta_{1}))</span> is computationally indistinguishable from a random pair <span class="math">(\\beta_{1},\\beta_{2})</span> of the verifier’s first two messages. We emphasize that this in particular implies that the function <span class="math">T</span> has to be computationally inefficient.</li>

    </ul>

    <p class="text-gray-300">We study the implications of SSS protocols. As we argue below, SSS interactive arguments are of great interest for several reasons.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, we prove that such protocols are post-quantum sound, if the assumption that they rely on is post-quantum secure. We note that in general, interactive protocols that are proven classically secure under post-quantum assumptions are <em>not</em> post-quantum secure. This is because the proof of security often relies on the rewinding technique, which is not generally applicable in the quantum setting due to the fact that quantum states are not clonable <em>[x23, x24]</em>. We show that SSS arguments have a <em>straight-line</em> proof of soundness (i.e., without</li>

    </ol>

    <p class="text-gray-300">rewinding the cheating prover), and are thus immediately post-quantum sound. We elaborate on this in Section 1.2.1.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Second, we prove that Kilian’s protocol, instantiated with a meSSB hash family (for which constructions based on the LWE assumption exist) and a BMW-compatible PCP, is SSS. We elaborate on this in Section 1.2.3. Combined with (1), this provides a rather simple proof of post-quantum soundness of Kilian’s protocol, comprehensible to a “quantum dummy.”</li>

    </ol>

    <p class="text-gray-300">We note that we have constructions of BMW-compatible PCPs only for deterministic languages and for specific classes of non-deterministics languages such as NTISP, and thus our instantiation of Kilian’s protocol is post-quantum sound for only such classes. Proving that the classical Kilian protocol <em>[x10]</em> is post-quantum sound for all of NP was a grand challenge, and was only very recently resolved by Chiesa, Ma, Spooner and Zhandry <em>[x4]</em> using highly non-trivial quantum techniques.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we conjecture that any SSS interactive argument is Fiat-Shamir friendly; meaning that for any SSS interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> there exists a hash family <span class="math">\\mathcal{H}</span> such that applying the Fiat-Shamir paradigm w.r.t. <span class="math">\\mathcal{H}</span> to <span class="math">(\\mathcal{P},\\mathcal{V})</span> results with a sound non-interactive argument. We elaborate on this (and define the Fiat-Shamir paradigm) in Section 1.2.2. We mention that prior to this work, the only interactive argument that was proven to be Fiat-Shamir friendly, in the work of Canetti et al. <em>[x5]</em>, is indeed an SSS argument and was used to construct a (non-succinct) UC NIZK for NP with an adaptive soundness guarantees.</li>

    </ol>

    <p class="text-gray-300">We emphasize that we do not prove that any SSS interactive argument is Fiat-Shamir friendly, only conjecture it. We believe that it is a promising path for obtaining SNARGs based on a standard post-quantum assumption. In particular, we propose constructing an SSS interactive argument for all of NP as a great open problem. We note that it is easier than constructing a (non-adaptive) SNARG for NP, since any such SNARG is in particular SSS (with two additional arbitrary rounds that are ignored by the verdict function). Constructing a non-adaptive SNARG for NP has been a major open problem, and constructing a succinct SSS protocol can be seen as a stepping stone for achieving this goal.</p>

    <p class="text-gray-300">Note that since we prove that our instantiation of Kilian’s protocol is SSS, and since we conjecture that any SSS protocol is Fiat-Shamir friendly, as a special case we conjecture that our instantiation of Kilian’s protocol (with a meSSB hash family and a BMW-compatible PCP) is Fiat-Shamir friendly.</p>

    <p class="text-gray-300">This is in contrast with the recent work <em>[BBH^{+}19]</em> that showed that in general, Kilian’s protocol is not Fiat-Shamir friendly. We remark that it was already suggested in <em>[BBH^{+}19]</em> to use an SSB hash family as one step to evade their impossibility result. We suggest to use a meSSB hash family combined with a BMW-compatible PCP. If sound, this would yield a SNARG for all of P (and some sub-classes of NP, as described above).</p>

    <p class="text-gray-300">1.2.1 SSS, Straight-Line Soundness and Post-Quantum Security</p>

    <p class="text-gray-300">In a nutshell, the reason that any SSS protocol is post-quantum sound is due to the fact that it has <em>straight-line soundness</em>, meaning that any (even quantum) successful cheating prover can be used in a black box and straight-line manner (without rewinding) to break some complexity assumption.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1.1 (Informal).</h6>

    <p class="text-gray-300">Any SSS interactive argument has a straight-line soundness proof.</p>

    <p class="text-gray-300">Loosely speaking, we prove this theorem as follows. Fix any SSS interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> for a language <span class="math">\\mathcal{L}</span>. We construct a (uniform) PPT black-box reduction <span class="math">\\mathcal{R}</span>, that takes as input a pair <span class="math">(\\beta_{1},\\beta_{2})</span>, and distinguishes between the case that <span class="math">\\beta_{2}=T(\\beta_{1})</span> and the case that <span class="math">\\beta_{2}</span> is chosen at random, given black-box and straight-line access to any (even quantum) cheating prover <span class="math">\\mathcal{P}^{*}</span>.</p>

    <p class="text-gray-300">The reduction <span class="math">\\mathcal{R}</span> works as follows: It runs the cheating prover with <span class="math">\\beta_{1}</span>, and then upon receiving <span class="math">\\alpha_{1}=\\mathcal{P}^{<em>}(\\beta_{1})</span>, it sends <span class="math">\\mathcal{P}^{</em>}</span> the challenge <span class="math">\\beta_{2}</span>. The reduction then continues emulating the honest verifier until the end of the protocol. If the transcript is accepting, then <span class="math">\\mathcal{R}</span> outputs <span class="math">1</span> (indicating that <span class="math">\\beta_{2}</span> is random), and otherwise it outputs <span class="math">0</span>. By the assumption that <span class="math">\\mathcal{P}^{*}</span> is convincing with non-negligible probability, if <span class="math">\\beta_{1}</span> and <span class="math">\\beta_{2}</span> are random then the transcript is accepting with non-negligible probability. On the other hand, by the SSS property, if <span class="math">\\beta_{2}=T(\\beta_{1})</span>, then the transcript is accepted with only negligible probability. Thus, the reduction <span class="math">\\mathcal{R}</span> outputs <span class="math">1</span> with probability that is non-negligibly larger in the case that <span class="math">\\beta_{2}</span> is random, as desired.</p>

    <p class="text-gray-300">We note that any interactive argument that has a straight-line soundness proof is immediately post-quantum sound, assuming that the underlying assumption is post-quantum secure. This is the case since the analysis above extends readily to the quantum setting. As mentioned above, this is in contrast to the standard analysis which uses rewinding, and hence often fails in the post-quantum setting.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Claim 1.2 (Informal).</h6>

    <p class="text-gray-300">Any SSS interactive argument where both SSS properties are straight-line reducible from an assumption <span class="math">\\mathsf{A}</span> is also post-quantum sound if assumption <span class="math">\\mathsf{A}</span> holds w.r.t. quantum adversaries.</p>

    <p class="text-gray-300">A formal proof of this Claim appears in Section 4.2 (Theorem 4.4). This property makes SSS arguments particularly appealing, given the major effort by the community to make cryptographic protocols post-quantum secure.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.2.2 SSS and Fiat-Shamir Friendliness</h4>

    <p class="text-gray-300">Another reason why SSS arguments are of interest is that we believe (and conjecture) that such protocols are “Fiat-Shamir friendly.” Recall that the Fiat-Shamir paradigm converts an interactive proof <span class="math">(\\mathcal{P},\\mathcal{V})</span> for a language <span class="math">L</span> to a non-interactive argument <span class="math">(\\mathcal{P}^{\\prime},\\mathcal{V}^{\\prime})</span> for <span class="math">L</span> in the CRS model. The CRS consists of randomly chosen hash functions <span class="math">h_{1},\\ldots,h_{\\ell}</span> from a hash family <span class="math">\\mathcal{H}</span>, where <span class="math">\\ell</span> is the number of rounds in the protocol <span class="math">(\\mathcal{P},\\mathcal{V})</span>. To compute a non-interactive proof for <span class="math">x\\in L</span>, the non-interactive prover <span class="math">\\mathcal{P}^{\\prime}(x)</span> generates a transcript corresponding to <span class="math">(\\mathcal{P},\\mathcal{V})(x)</span>, denoted by <span class="math">(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{\\ell},\\beta_{\\ell})</span>, by emulating <span class="math">\\mathcal{P}(x)</span> and replacing each verifier message <span class="math">\\beta_{i}</span> by <span class="math">\\beta_{i}=h_{i}(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{i-1},\\beta_{i-1},\\alpha_{i})</span>. The verifier <span class="math">\\mathcal{V}^{\\prime}(x)</span> accepts if and only if <span class="math">\\mathcal{V}(x)</span> accepts this transcript and <span class="math">\\beta_{i}=h_{i}(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{i-1},\\beta_{i-1},\\alpha_{i})</span> for every <span class="math">i\\in[\\ell]</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">This paradigm has been extremely influential in practice, and its soundness has been extensively studied. For statistically sound proofs, this paradigm is believed to be sound, at least under strong computational assumptions <em>[x18, x11, x14, CCH^{+}19]</em>. Moreover, for some protocols such as the Goldwasser-Kalai-Rothblum protocol <em>[x12]</em> and several zero-knowledge protocols for NP such as Blum’s Hamiltonicity protocol <em>[x5]</em> and the GMW 3-coloring protocol <em>[x13]</em>, this paradigm is provably sound under the polynomial or sub-exponential hardness of learning with errors (LWE) <em>[CCH^{+}19, x20, x16, x17]</em>, which are standard assumptions.</p>

    <p class="text-gray-300">On the other hand, for computationally sound proofs (known as arguments) the situation is quite grim. There are (contrived) examples of interactive arguments for which the resulting non-interactive argument obtained by applying the Fiat-Shamir paradigm is not sound, no matter which hash family is used <em>[x3, x12]</em>. Moreover, recently it was shown that the Fiat-Shamir paradigm is not sound when applied to the celebrated Kilian’s protocol <em>[BBH^{+}19]</em>.</p>

    <p class="text-gray-300">As a natural interpolation between statistically sound proofs and computationally sound arguments, it is natural to ask whether the hybrid class of all (constant round) SSS interactive arguments is Fiat-Shamir friendly.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Conjecture 1.3.</h6>

    <p class="text-gray-300">Any constant round SSS interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> is <em>Fiat-Shamir friendly</em>.</p>

    <p class="text-gray-300">We note that all known negative results for the Fiat-Shamir paradigm <em>[x3, x12, BBH^{+}19]</em> are for arguments that are <em>not</em> SSS. In particular, these interactive arguments are constructed by adding an additional accepting clause, such that if the prover can predict the verifier’s next message then he can easily convince the verifier to accept this alternative clause (even false statements). This does not harm soundness in the interactive setting since the interactive prover cannot predict the verifier’s next message and hence cannot use this additional clause. On the other hand, when Fiat-Shamir is applied, the prover can, by definition, use the description of the hash function to predict the verifier’s next message, harming the soundness of the non-interactive protocol and thus demonstrating the insecurity of the Fiat-Shamir paradigm.</p>

    <p class="text-gray-300">Crucially, we emphasize that this additional clause makes the resulting argument <em>not</em> SSS, since this additional clause inherently does not have statistical soundness. This is the case because the witness for this additional clause (which is the Fiat-Shamir hash function) can be larger than the communication complexity, and hence to verify this clause we must use a <em>succinct</em> argument. Importantly, we note that even if this clause is SSS the entire protocol is not, since this clause is executed after the first two messages.</p>

    <p class="text-gray-300">We note that Bartusek et al. <em>[BBH^{+}19]</em> give an instantiation of Kilian’s protocol for the trivial (empty) language for which applying the Fiat-Shamir paradigm provably results in a sound protocol. Their instantiation employs an eSSB hash function and a particular PCP for the empty language, and the protocol is in fact SSS. Indeed, our conjecture is a stronger statement, namely that the notion of meSSB is sufficient to apply Fiat-Shamir soundly, assuming the PCP in use makes the BMW heuristic sound.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.2.3 Instantiating an SSS version of Kilian</h4>

    <p class="text-gray-300">We show that Kilian’s protocol instantiated with a meSSB hash family, and a BMW-compatible PCP, is an SSS argument. In particular, we obtain the following corollary.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.4 (Informal).</h6>

    <p class="text-gray-300">Kilian’s protocol is <span class="math">\\mathsf{SSS}</span>, and thus has post-quantum soundness, if we use a <span class="math">\\mathsf{BMW}</span>-compatible <span class="math">\\mathsf{PCP}</span> and if the prover commits to this <span class="math">\\mathsf{PCP}</span> using a post-quantum <span class="math">\\mathsf{meSSB}</span> hash function.</p>

    <p class="text-gray-300">Hubáček and Wichs <em>[x12]</em> constructed an eSSB hash family assuming the hardness of <span class="math">\\mathsf{LWE}</span>. This hash family is post-quantum secure assuming the post-quantum hardness of <span class="math">\\mathsf{LWE}</span>. We note that any eSSB hash family can be easily extended to a <span class="math">\\mathsf{meSSB}</span> hash family.</p>

    <p class="text-gray-300">Moreover, (adaptive) <span class="math">\\mathsf{BMW}</span>-compatible <span class="math">\\mathsf{PCPs}</span> are known for all deterministic languages <em>[x2]</em> and languages in <span class="math">\\mathsf{NTISP}</span> <em>[BKK^{+}18]</em>. For deterministic languages the (adaptive) soundness relies on the polynomial hardness of the underlying <span class="math">\\mathsf{PIR}</span> scheme, whereas for languages in <span class="math">\\mathsf{NTISP}</span> the (adaptive) soundness relies on the sub-exponential hardness of the underlying <span class="math">\\mathsf{PIR}</span> scheme. The query complexity for languages in <span class="math">\\mathsf{DTIME}(t)</span> is <span class="math">\\mathrm{polylog}(t)</span>, and for languages in <span class="math">\\mathsf{NTISP}(t,s)</span> it is <span class="math">s\\cdot\\mathrm{polylog}(t)</span>. These results, together with Theorem 1.4, imply the following corollary.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Corollary 1.5 (Informal).</h6>

    <p class="text-gray-300">There exists an instantiation of Kilian’s protocol that is <span class="math">\\mathsf{SSS}</span>, and thus post-quantum sound, for all deterministic computations assuming the polynomial post-quantum hardness of <span class="math">\\mathsf{LWE}</span>, and for all languages in <span class="math">\\mathsf{NTISP}</span> assuming the sub-exponential post-quantum hardness of <span class="math">\\mathsf{LWE}</span>. For <span class="math">\\mathsf{DTIME}(t)</span> languages the communication complexity grows with <span class="math">\\mathrm{polylog}(t)</span>, and for languages in <span class="math">\\mathsf{NTISP}(t,s)</span> the communication complexity grows with <span class="math">s\\cdot\\mathrm{polylog}(t)</span>.</p>

    <p class="text-gray-300">As mentioned above, we conjecture that this instantiation is Fiat-Shamir friendly, and leave the proof (or refutation) of this conjecture as an important open problem.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.3 SNARGs: from <span class="math">\\mathsf{BatchNP}</span> to <span class="math">\\mathsf{P}</span> and Beyond</h3>

    <p class="text-gray-300">This view of the first two messages of Kilian’s protocol as an instantiation of the <span class="math">\\mathsf{BMW}</span> heuristic leads us to our final contribution: an alternative pathway to getting a <span class="math">\\mathsf{SNARG}</span> for any language that has a <span class="math">\\mathsf{BMW}</span>-compatible <span class="math">\\mathsf{PCP}</span>. Specifically, we show a reduction from constructing a <span class="math">\\mathsf{SNARG}</span> for the class of all languages that have a <span class="math">\\mathsf{BMW}</span>-compatible <span class="math">\\mathsf{PCP}</span> to the simpler goal of constructing a <span class="math">\\mathsf{SNARG}</span> for <span class="math">\\mathsf{BatchNP}</span>.</p>

    <p class="text-gray-300">The starting point is the two-round preamble where the verifier sends the prover the description of a <span class="math">\\mathsf{meSSB}</span> hash function, and the prover replies with a multi-extractable commitment to a <span class="math">\\mathsf{BMW}</span>-compatible <span class="math">\\mathsf{PCP}</span>. The key observation is that the remainder of the protocol can be a proof of the following <span class="math">\\mathsf{BatchNP}</span> statement (which can be communicated in the first two rounds as well): for every possible query set <span class="math">Q</span> generated by the <span class="math">\\mathsf{PCP}</span> verifier, there are values of <span class="math">\\pi_{Q}</span> as well as openings <span class="math">\\mathsf{o}_{Q}</span> such that (a) <span class="math">(\\pi_{Q},\\mathsf{o}_{Q})</span> constitutes a valid opening; and (b) the <span class="math">\\mathsf{PCP}</span> verifier accepts <span class="math">(Q,\\pi_{Q})</span>.</p>

    <p class="text-gray-300">We argue that this 2-message protocol is sound: If the instance being proven is false, then by the soundness of the <span class="math">\\mathsf{BMW}</span>-heuristic the answers that are committed to by the <span class="math">\\mathsf{meSSB}</span> hash function are rejecting, and hence by the <span class="math">\\mathsf{meSSB}</span> binding property, the resulting <span class="math">\\mathsf{BatchNP}</span> statement is false. Therefore, it seems that all we need to instantiate this approach is a <span class="math">\\mathsf{SNARG}</span> for <span class="math">\\mathsf{BatchNP}</span>.</p>

    <p class="text-gray-300">There are several issues that come up in making this idea work. First, if the PCP has negligible soundness error, then the number of possible query sets generated by the verifier is super-polynomially large, meaning that the (honest) prover runtime is super-polynomial. Fortunately, all known PCP constructions (including the ones from <em>[x13, x2, x3]</em>) have the property that each query set can be partitioned into a set of “tests,” where the queries in each test and their corresponding answers can be verified on their own, and importantly, the number of possible tests is polynomial. Therefore, our BatchNP statement should rather be that for every test <span class="math">\\zeta</span> there are values of <span class="math">\\pi_{\\zeta}</span> as well as openings <span class="math">\\mathsf{o}_{\\zeta}</span> such that (a) <span class="math">(\\pi_{\\zeta},\\mathsf{o}_{\\zeta})</span> constitutes a valid opening; and (b) the PCP verifier accepts <span class="math">(\\zeta,\\pi_{\\zeta})</span>. Note that this BatchNP statement is polynomially large.</p>

    <p class="text-gray-300">Secondly, even though we ensured that the number of instances in the BatchNP statement is polynomial, this polynomial, denoted by <span class="math">N</span>, is at least as large as the runtime of the underlying computation. Note that even though the proof length scales only poly-logarithmically with <span class="math">N</span>, the <em>verifier runtime</em> scales at least linearly with <span class="math">N</span> since the verifier needs to at least read the entire statement. To solve this, we observe that in our case, the BatchNP statement actually has a succinct description. Thus, if there are succinct, easy to verify, proofs for succinctly specified BatchNP statements, we are back in business. We note that even if this is not the case, if the verifier’s verdict function can be computed by a circuit that has depth only <span class="math">\\mathrm{polylog}(N)</span> (but size <span class="math">\\mathrm{poly}(N)</span>), then again we are in business since we can use the SNARG for bounded depth computations (from sub-exponential LWE) <em>[x11]</em>, and delegate this computation back to the prover.</p>

    <p class="text-gray-300">Third and finally, note that the BatchNP proof system must have adaptive soundness since the prover gets to choose the BatchNP statement, in particular the hash value, <em>after</em> he receives the CRS/first message of the BatchNP proof. Since the hash value is small in size, this can be easily handled by complexity leveraging. We therefore only require non-adaptive soundness with appropriate security. We elaborate on this in Section 6.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Concurrent Work.</h5>

    <p class="text-gray-300">In a concurrent and independent work, Choudhuri, Jain and Jin <em>[x4]</em> construct SNARGs for BatchNP from LWE. Thus, using their result together with our reduction from Section 1.3, we obtain a SNARG for any language that has a BMW-compatible PCP, from the LWE assumption. In particular, as we elaborate on in Section 6, we obtain a SNARG for any language in DTIME<span class="math">(t)</span> or in NTISP<span class="math">(t,s)</span> with communication complexity <span class="math">\\mathrm{polylog}(t)</span> or <span class="math">\\mathrm{polylog}(s,\\log t)</span>, respectively, from the sub-exponential hardness of LWE. We note that <em>[x4]</em> also showed how to use their SNARG for BatchNP to construct a SNARG for P as well as for RAM computations.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2 Preliminaries</h2>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2.1.</h6>

    <p class="text-gray-300">Two distribution ensembles <span class="math">\\{A_{k}\\}_{k\\in\\mathbb{N}}</span> and <span class="math">\\{B_{k}\\}_{k\\in\\mathbb{N}}</span> are said to be <span class="math">\\Omega</span>-indistinguishable if for every <span class="math">\\mathrm{poly}(\\Omega)</span>-size distinguisher <span class="math">\\mathcal{D}</span> there exists a negligible function <span class="math">\\mu</span> such that for every <span class="math">k\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\lvert\\Pr_{a\\leftarrow A_{k}}[\\mathcal{D}(a)=1]-\\Pr_{b\\leftarrow B_{k}}[\\mathcal{D}(b)=1]\\rvert\\leq\\mu(\\Omega(k)).</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">In this section, we define the notion of straight-line soundness, and more generally straight-line reductions.</p>

    <p class="text-gray-300">Definition 2.2. (Straight-Line Reductions) We say that an interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})(1^{\\kappa})</span> for a language <span class="math">\\mathcal{L} = \\{\\mathcal{L}_n\\}_{n\\in \\mathbb{N}}</span> is (adaptively) <span class="math">\\theta = \\theta (\\kappa)</span>-straight-line sound if there is a PPT black box reduction <span class="math">\\mathcal{R}</span> and a non-interactive <span class="math">\\theta</span>-decisional complexity assumption [GK16], such that <span class="math">\\mathcal{R}</span>, given oracle access to any cheating prover <span class="math">\\mathcal{P}^<em></span> that breaks (adaptive) soundness with probability <span class="math">1 / \\mathrm{poly}(\\theta)</span>, interacts with <span class="math">\\mathcal{P}^</em></span> once (without rewinding) by sending <span class="math">\\mathcal{P}^*</span> a single message for each round, and using the transcript obtained, breaks the assumption.</p>

    <p class="text-gray-300">More generally, we say that a primitive is <span class="math">\\theta = \\theta(\\kappa)</span>-straight-line secure (or <span class="math">\\theta</span>-secure via a straight-line reduction, or its security proof is <span class="math">\\theta</span>-straight line) if there is a PPT black box reduction <span class="math">\\mathcal{R}</span> and a non-interactive <span class="math">\\theta</span>-decisional complexity assumption such that <span class="math">\\mathcal{R}</span>, given oracle access to any size-poly( <span class="math">\\theta</span> ) adversary <span class="math">\\mathcal{A}</span> that breaks the security of the primitive with probability <span class="math">1 / \\mathrm{poly}(\\theta)</span>, interacts with <span class="math">\\mathcal{A}</span> once (without rewinding) and, using the transcript obtained, breaks the assumption.</p>

    <p class="text-gray-300">Definition 2.3 ([GK16]). An assumption is a <span class="math">\\theta</span>-decisional complexity assumption if it is associated with two probabilistic polynomial-time distributions <span class="math">(\\mathcal{D}_0, \\mathcal{D}_1)</span>, such that for any poly( <span class="math">\\theta</span> )-size algorithm <span class="math">\\mathcal{A}</span> there exists a negligible function <span class="math">\\mu</span> such that for any <span class="math">\\kappa \\in \\mathbb{N}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname <em> {P r} _ {x \\leftarrow \\mathcal {D} _ {0} (1 ^ {\\kappa})} [ \\mathcal {A} (x) = 1 ] - \\operatorname </em> {P r} _ {x \\leftarrow \\mathcal {D} _ {1} (1 ^ {\\kappa})} [ \\mathcal {A} (x) = 1 ] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mu (\\theta (\\kappa)).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We first recall the definition of a probabilistically checkable proof (PCP). A PCP for an NP language <span class="math">\\mathcal{L}</span> is a (deterministic) function <span class="math">\\Pi</span> that takes as input a witness <span class="math">w</span> for a statement <span class="math">x \\in L</span>, and converts it into a proof <span class="math">\\pi = \\Pi(x, w)</span> which can be verified by a randomized verifier that reads only a few of its bits.</p>

    <p class="text-gray-300">Definition 2.4 (PCP). A probabilistically checkable proof (PCP) for a language <span class="math">\\mathcal{L}</span> is a triple of algorithms <span class="math">(\\Pi, \\mathcal{Q}_{\\mathrm{PCP}}, \\mathcal{V}_{\\mathrm{PCP}})</span> with the following syntax:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\Pi</span> is a deterministic algorithm that takes as input an instance <span class="math">x \\in \\mathcal{L}</span> (and possibly some additional information, such as a witness), and outputs a proof string <span class="math">\\pi</span>. We will denote the length of the PCP by $L =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Q}_{\\mathrm{PCP}}</span> is a probabilistic query generation algorithm which takes as input a security parameter <span class="math">1^{\\kappa}</span>, and generates a set of queries <span class="math">q_{1}, \\ldots, q_{\\ell} \\in [L]</span>.</li>

      <li><span class="math">\\mathcal{V}_{\\mathrm{PCP}}</span> is a deterministic polynomial-time verification algorithm that takes as input an instance <span class="math">x</span>, a set of queries <span class="math">(q_{1},\\ldots ,q_{\\ell})</span> and a corresponding set of answers <span class="math">(a_{1},\\ldots ,a_{\\ell})</span>, and outputs 0 (reject) or 1 (accept).</li>

    </ul>

    <p class="text-gray-300">8We focus on decisional assumptions for simplicity, and because our reductions are from decisional assumptions.</p>

    <p class="text-gray-300">9It will be clear what the <span class="math">\\theta</span>-decisional complexity assumption is in each context.</p>

    <p class="text-gray-300">We require the following properties to hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Perfect) Completeness: For every <span class="math">x\\in\\mathcal{L}</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{V}_{\\text{PCP}}(x,(q_{1},\\ldots,q_{\\ell}),(\\pi_{q_{1}},\\ldots,\\pi_{q_{\\ell}}))=1]=1\\ ,</span></p>

    <p class="text-gray-300">where <span class="math">\\pi=\\Pi(x)</span>, and where the probability is over <span class="math">(q_{1},\\ldots,q_{\\ell})\\leftarrow\\mathcal{Q}_{\\text{PCP}}(1^{\\kappa})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: For every <span class="math">x\\notin\\mathcal{L}</span>, and for every (possibly malicious) string <span class="math">\\pi^{<em>}\\in\\{0,1\\}^{</em>}</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{V}_{\\text{PCP}}(x,(q_{1},\\ldots,q_{\\ell}),(\\pi_{q_{1}}^{<em>},\\ldots,\\pi_{q_{\\ell}}^{</em>}))=1]\\leq 2^{-\\kappa}\\ ,</span></p>

    <p class="text-gray-300">where the probability is over <span class="math">(q_{1},\\ldots,q_{\\ell})\\leftarrow\\mathcal{Q}_{\\text{PCP}}(1^{\\kappa})</span>.</p>

    <p class="text-gray-300">We will be interested in PCP’s with an additional property, that each query set <span class="math">Q=(q_{1},\\ldots,q_{\\ell})\\in\\mathcal{Q}_{\\text{PCP}}</span> can be partitioned into several <em>tests</em>, such that the verifier’s checks are simply the conjunction of checking each test. This property holds for all PCP’s known to the authors.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a PCP <span class="math">(\\Pi,\\mathcal{Q}_{\\text{PCP}},\\mathcal{V}_{\\text{PCP}})</span> is verified via tests if there is some algorithm <span class="math">\\mathcal{U}_{\\text{PCP}}</span> such that each query set <span class="math">Q=(q_{1},\\ldots,q_{\\ell})\\in\\mathcal{Q}_{\\text{PCP}}(1^{\\kappa})</span> can be partitioned into <span class="math">\\theta</span> <em>tests</em> <span class="math">\\zeta_{1}\\cup\\cdots\\cup\\zeta_{\\theta}</span>, where for every <span class="math">j\\in[\\theta]</span> there exists a set of indices <span class="math">I_{j}\\subseteq[\\ell]</span> such that $\\zeta_{j}=Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I_{j}}<span class="math">, and the PCP verifier accepts a set of answers </span>A=(a_{1},\\ldots,a_{\\ell})<span class="math"> if and only if </span>\\mathcal{U}_{\\text{PCP}}(x,Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I_{j}},A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I_{j}})=1<span class="math"> for every </span>j\\in[\\theta]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-19" class="text-base font-medium mt-4">Remark 2.6.</h6>

    <p class="text-gray-300">We also consider a stronger notion of PCP soundness known as <em>non-signaling soundness</em>, and more specifically <em>computational non-signaling soundness</em>. The precise definition (given in Appendix A) is not needed in order to understand our result: what is important is that computational non-signaling PCPs are BMW-compatible.</p>

    <p class="text-gray-300">Two remarks are in place. First, two flavors of (computational) non-signaling soundness have been considered in the literature: adaptive and non-adaptive; the latter provides non-adaptive soundness of the <em>BMW</em> heuristic, whereas the former provides adaptive soundness. In this work, we will describe the results with adaptive soundness. Second, there is a parameter <span class="math">\\Omega</span> associated with the computational non-signaling soundness, such that for every <span class="math">\\Omega_{1}&lt;\\Omega_{2}</span>, a <span class="math">\\Omega_{2}</span>-computational non-signaling PCP is also a <span class="math">\\Omega_{1}</span>-computational non-signaling PCP. Furthermore, each such PCP is associated with a locality parameter <span class="math">\\ell</span>, which for simplicity can be thought of as the query complexity. We refer the reader to Appendix A for the precise definitions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adaptive computational non-signaling PCP’s have been constructed for several classes of languages. One is the language <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)=\\{\\mathcal{L}_{\\mathcal{U}}(t(n))\\}_{n\\in\\mathbb{N}}</span>, where <span class="math">\\mathrm{poly}(n)\\leq t(n)\\leq\\exp(n)</span>, such that for any (deterministic) Turing machine <span class="math">M</span> and input <span class="math">x</span>, <span class="math">(M,x)\\in\\mathcal{L}_{\\mathcal{U}}(t)</span> if and only if <span class="math">M</span> on input <span class="math">x</span> outputs <span class="math">1</span> within $t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(M,x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time steps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 2.7 (<em>[KRR, BHK]</em>).</h6>

    <p class="text-gray-300">For any <span class="math">\\mathrm{poly}(n)\\leq t(n)\\leq\\exp(n)</span>, there exists an adaptive <span class="math">t</span>-computational non-signaling PCP for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> with locality <span class="math">\\ell=\\kappa\\cdot\\mathrm{polylog}(t)</span>, where the PCP proof has size <span class="math">L(n)=\\mathrm{poly}(t(n))</span> and can be generated in time <span class="math">\\mathrm{poly}(t(n))</span>. Furthermore, <span class="math">\\mathcal{Q}_{\\text{PCP}}(1^{\\kappa})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">runs in time <span class="math">\\mathrm{poly}(\\ell)</span>, and <span class="math">\\mathcal{V}_{\\mathrm{PCP}}</span>, on input <span class="math">(M,x)</span>, <span class="math">(q_{1},\\ldots,q_{\\ell})</span>, and <span class="math">(a_{1},\\ldots,a_{\\ell})</span>, runs in time $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(M,x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathrm{poly}(\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, this PCP is verified via tests, with a total of <span class="math">\\mathrm{poly}(t)</span> many possible tests <span class="math">\\zeta</span> (see Definition 2.5).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Another language with an adaptive computational non-signaling PCP is <span class="math">\\mathsf{NL}_{\\mathcal{U}}(t,s)</span>, the class of problems that can be solved nondeterministically in time <span class="math">t</span> and space <span class="math">s</span>. That is, <span class="math">(M,x)\\in\\mathsf{NL}_{\\mathcal{U}}(t,s)</span> if <span class="math">M</span> is a non-deterministic Turing machine that, on input <span class="math">x</span>, runs in space $s(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(M,x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and outputs </span>1<span class="math"> within </span>t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(M,x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time steps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 2.8 (<em>[BKK^{+}18]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">\\mathrm{poly}(n)\\leq t\\leq\\exp(n)</span> and <span class="math">s=s(n)\\geq\\log t(n)</span>, there is an adaptive <span class="math">2^{s}</span>-computational non-signaling PCP for <span class="math">\\mathsf{NL}_{\\mathcal{U}}(t,s)</span> with locality <span class="math">\\ell=\\kappa\\cdot\\mathrm{poly}(s)</span>. The PCP proof has size <span class="math">L(n)=\\mathrm{poly}(t(n))</span> and can be generated in time <span class="math">t(n)</span>. Furthermore, the query generation algorithm runs in time <span class="math">\\mathrm{poly}(\\ell)</span> and the verifier, on input <span class="math">(M,x),(q_{1},\\ldots,q_{\\ell}),(a_{1},\\ldots,a_{\\ell})</span>, runs in time $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(M,x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathrm{poly}(\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, this PCP is verified via tests. There are a total of <span class="math">\\mathrm{poly}(t)</span> possible tests <span class="math">\\zeta</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.3 Hash Function Families with Local Opening</h3>

    <p class="text-gray-300">In what follows, we assume <span class="math">L\\leq 2^{\\kappa}</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 2.9 (Hash Family).</h6>

    <p class="text-gray-300">A <em>hash family</em> is a pair of <span class="math">\\mathsf{PPT}</span> algorithms <span class="math">(\\mathsf{Gen},\\mathsf{Hash})</span>, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{\\kappa},L)</span> takes as input a security parameter <span class="math">\\kappa</span> in unary and an input length <span class="math">L</span>, and outputs a hash key <span class="math">\\mathsf{hk}\\in\\{0,1\\}^{\\ell_{\\mathsf{hk}}}</span>.</li>

      <li><span class="math">\\mathsf{Hash}(\\mathsf{hk},x)</span> takes as input a hash key <span class="math">\\mathsf{hk}\\in\\{0,1\\}^{\\ell_{\\mathsf{hk}}}</span> and an input <span class="math">x\\in\\{0,1\\}^{L}</span> and outputs an element <span class="math">\\mathsf{rt}\\in\\{0,1\\}^{\\ell_{\\mathsf{hash}}}</span>.</li>

    </ul>

    <p class="text-gray-300">Here, <span class="math">\\ell_{\\mathsf{hk}}=\\ell_{\\mathsf{hk}}(\\kappa)=\\mathrm{poly}(\\kappa)</span> and <span class="math">\\ell_{\\mathsf{hash}}=\\ell_{\\mathsf{hash}}(\\kappa)=\\mathrm{poly}(\\kappa)</span> are parameters associated with the hash family.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 2.10 (Hash Family with Local Opening).</h6>

    <p class="text-gray-300">A <em>hash family with local opening</em> is a hash family <span class="math">(\\mathsf{Gen},\\mathsf{Hash})</span>, along with two additional <span class="math">\\mathsf{PPT}</span> algorithms <span class="math">(\\mathsf{Open},\\mathsf{Verify})</span> with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Open}(\\mathsf{hk},x,j)</span> takes as input a hash key <span class="math">\\mathsf{hk}\\in\\{0,1\\}^{\\ell_{\\mathsf{hk}}}</span>, <span class="math">x\\in\\{0,1\\}^{L}</span>, and an index <span class="math">j\\in[L]</span> and outputs an opening <span class="math">\\mathsf{o}\\in\\{0,1\\}^{\\ell_{\\mathsf{o}}}</span>, where <span class="math">\\ell_{\\mathsf{o}}=\\ell_{\\mathsf{o}}(\\kappa)=\\mathrm{poly}(\\kappa)</span>.</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{hk},\\mathsf{rt},j,u,\\mathsf{o})</span> takes as input a hash key <span class="math">\\mathsf{hk}\\in\\{0,1\\}^{\\ell_{\\mathsf{hk}}}</span>, a hash value <span class="math">\\mathsf{rt}\\in\\{0,1\\}^{\\ell_{\\mathsf{hash}}}</span>, an index <span class="math">j\\in[L]</span>, a value <span class="math">u\\in\\{0,1\\}</span>, and an opening <span class="math">\\mathsf{o}\\in\\{0,1\\}^{\\ell_{\\mathsf{o}}}</span>, and outputs <span class="math">1</span> or <span class="math">0</span> indicating accept or reject, respectively.</li>

    </ul>

    <p class="text-gray-300">These algorithms should satisfy the property:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness of Opening: For every <span class="math">x\\in\\{0,1\\}^{L}</span> and <span class="math">j\\in[L]</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{Verify}(\\mathsf{hk},\\mathsf{Hash}(\\mathsf{hk},x),j,x_{j},\\mathsf{Open}(\\mathsf{hk},x,j))=1]=1,</span></p>

    <p class="text-gray-300">where the probability is over <span class="math">\\mathsf{hk}\\leftarrow\\mathsf{Gen}(1^{\\kappa},L)</span>.</p>

    <p class="text-gray-300">Kilian's transformation uses a hash family with local opening and a PCP scheme to construct a 4-round succinct argument.</p>

    <p class="text-gray-300">For our description of Kilian's protocol, fix any hash family with local opening  <span class="math">\\mathcal{H} = (\\mathrm{Gen},\\mathrm{Hash},\\mathrm{Open},\\mathrm{Verify})</span>  and a PCP scheme  <span class="math">(\\Pi ,\\mathcal{Q}_{\\mathrm{PCP}},\\mathcal{V}_{\\mathrm{PCP}})</span>  for a language  <span class="math">\\mathcal{L}</span> . Denote the length of a PCP proof by  <span class="math">L = L(n)</span> . Kilian's protocol is given in Figure 1.</p>

    <p class="text-gray-300">On input  <span class="math">x</span>  and security parameter  <span class="math">1^{\\kappa}</span> , the 4-message protocol  <span class="math">(\\mathcal{P}_{\\mathrm{Kilian}},\\mathcal{V}_{\\mathrm{Kilian}})</span>  proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First verifier's message:  <span class="math">\\mathcal{V}_{\\mathrm{Kilian}}</span>  samples  <span class="math">\\mathrm{hk} \\gets \\mathrm{Gen}(1^{\\kappa}, L)</span> , and sends  <span class="math">\\mathrm{hk}</span>  to the prover.</li>

      <li>First prover's message:  <span class="math">\\mathcal{P}_{\\mathrm{Kilian}}</span>  computes the PCP proof  <span class="math">\\pi = \\Pi(x)</span> , and its hash value  <span class="math">rt = \\operatorname{Hash}(\\mathsf{hk}, \\pi)</span> . It sends  <span class="math">rt</span>  to the verifier.</li>

      <li>Second verifier's message:  <span class="math">\\mathcal{V}_{\\mathrm{Kilian}}</span>  computes a set of queries  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span> , and sends  <span class="math">(q_{1},\\ldots ,q_{\\ell})</span>  to the prover.</li>

      <li>Second prover's message:  <span class="math">\\mathcal{P}_{\\mathrm{Kilian}}</span>  computes for every  <span class="math">i \\in [\\ell]</span>  the opening  <span class="math">\\mathsf{o}_i = \\mathrm{Open}(\\mathsf{hk}, \\pi, q_i)</span> , and sends  <span class="math">\\{\\pi_{q_i}, \\mathsf{o}_i\\}_{i \\in [\\ell]}</span>  to the verifier.</li>

      <li>Verdict:  <span class="math">\\mathcal{V}_{\\mathrm{Kilian}}</span>  accepts if and only if  <span class="math">\\mathcal{V}_{\\mathrm{PCP}}(x,(q_1,\\ldots ,q_\\ell),(\\pi_{q_1},\\ldots ,\\pi_{q_\\ell})) = 1</span>  and for every  <span class="math">i\\in [\\ell ]</span>  Verify(hk,rt,  <span class="math">q_{i},\\pi_{q_{i}},\\mathsf{o}_{i}) = 1</span></li>

    </ul>

    <p class="text-gray-300">Figure 1: Kilian's Protocol  <span class="math">(\\mathcal{P}_{\\mathrm{Kilian}},\\mathcal{V}_{\\mathrm{Kilian}})</span>  for a Language  <span class="math">\\mathcal{L}</span></p>

    <p class="text-gray-300">The BMW heuristic converts a PCP scheme into a 2-message, succinct, privately verifiable argument. It does this by allowing one to query a PCP proof using a private information retrieval (PIR) scheme, which we define below.</p>

    <p class="text-gray-300">Definition 2.11 ([CGKS95, KO97]). A 1-server private information retrieval (PIR) scheme is a tuple of PPT algorithms (Query, Answer, Reconstruct) with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Query}(1^{\\kappa}, L, q)</span>  takes as input a security parameter  <span class="math">\\kappa</span>  in unary, an input size  <span class="math">L</span> , and an index  <span class="math">q \\in [L]</span> , and outputs a query  <span class="math">\\hat{q}</span>  along with a trapdoor td.</li>

      <li>Answer  <span class="math">(\\hat{q}, x)</span>  takes as input a query  <span class="math">\\hat{q}</span>  and a database  <span class="math">x \\in \\{0, 1\\}^L</span> , and outputs an answer  <span class="math">\\hat{a}</span> .</li>

      <li>Reconstruct  <span class="math">(\\mathrm{td}, \\hat{a})</span>  takes as input a trapdoor td and an answer  <span class="math">\\hat{a}</span> , and outputs a plaintext  <span class="math">a</span> .</li>

    </ul>

    <p class="text-gray-300">These algorithms should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For every  <span class="math">\\kappa, L \\in \\mathbb{N}</span>  and  <span class="math">q \\in [L]</span> ,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}[\\operatorname{Reconstruct}(\\mathsf{td}, \\operatorname{Answer}(\\hat{q}, x)) = x_q] = 1,</span></p>

    <p class="text-gray-300">where the probability is over  <span class="math">(\\hat{q},\\mathsf{td})\\gets \\mathsf{Query}(1^{\\kappa},q,L)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S</span> -Privacy: For any  <span class="math">\\mathrm{poly}(S(\\kappa))</span> -size adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  there exists a negligible function  <span class="math">\\mu</span>  such that for every  <span class="math">\\kappa, L \\in \\mathbb{N}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ b = b ^ {\\prime} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} q _ {0}, q _ {1}, \\text {s t a t e} \\leftarrow \\mathcal {A} _ {1} (1 ^ {\\kappa}, L) \\\\ b \\stackrel {{\\S}} {{\\leftarrow}} \\{0, 1 \\} \\\\ (\\hat {q}, \\mathrm {t d}) \\leftarrow \\operatorname {Q u e r y} (1 ^ {\\kappa}, L, q _ {b}) \\\\ b ^ {\\prime} \\leftarrow \\mathcal {A} _ {2} (\\hat {q}, \\text {s t a t e}) \\end{array} \\right. \\right] = \\frac {1}{2} + \\mu (S (\\kappa)). \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Kushilevitz and Ostrovsky [KO97] constructed the first sublinear-communication single-server PIR scheme and was followed up by several other works [GR05, Lip05, BV11, DGI <span class="math">^{+}</span> 19].</p>

    <p class="text-gray-300">Theorem 2.12 ([BV11, DGI <span class="math">^{+}</span> 19]). For any function  <span class="math">S: \\mathbb{N} \\to \\mathbb{N}</span> , there exists a  <span class="math">S</span> -private 1-server PIR scheme with polylog(L) query complexity for length- <span class="math">L</span>  databases, under the  <span class="math">S</span> -hardness of the LWE, Quadratic Residuosity, or DDH assumptions. Moreover, these schemes are  <span class="math">S</span> -straight-line secure (see Definition 2.2).</p>

    <p class="text-gray-300">Fix any 1-server PIR scheme (Query, Answer, Reconstruct) and any PCP scheme  <span class="math">(\\Pi, \\mathcal{Q}_{\\mathrm{PCP}}, \\mathcal{V}_{\\mathrm{PCP}})</span>  for a language  <span class="math">\\mathcal{L}</span> . The BMW heuristic is a 2-message succinct argument for  <span class="math">\\mathcal{L}</span> , defined in Figure 2.</p>

    <p class="text-gray-300">On input  <span class="math">1^{\\kappa}</span>  and  <span class="math">x</span> , the 2-message protocol  <span class="math">(\\mathcal{P}_{\\mathrm{BMW}}, \\mathcal{V}_{\\mathrm{BMW}})</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier:  <span class="math">\\mathcal{V}_{\\mathrm{BMW}}</span>  computes  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span> . For each  <span class="math">i\\in [\\ell ]</span> , it generates  <span class="math">(\\hat{q}_i,\\mathsf{td}_i)\\gets</span>  Query  <span class="math">(1^{\\kappa},L,q_{i})</span> , where  <span class="math">L</span>  is the length of the PCP. It sends  <span class="math">\\{\\hat{q}_i\\}_{i\\in \\ell}</span>  to the prover.</li>

      <li>Prover:  <span class="math">\\mathcal{P}_{\\mathrm{BMW}}</span>  computes the PCP string  <span class="math">\\pi = \\Pi(x)</span> , and for each  <span class="math">i \\in [\\ell]</span> , it computes  <span class="math">\\hat{a}_i = \\operatorname{Answer}(\\hat{q}_i, \\pi)</span> . It sends  <span class="math">\\{\\hat{a}_i\\}_{i \\in [\\ell]}</span>  to the verifier.</li>

      <li>Verdict:  <span class="math">\\mathcal{V}_{\\mathrm{BMW}}</span>  computes  <span class="math">a_{i} = \\operatorname{Reconstruct}(\\mathsf{td}_{i}, \\hat{a}_{i})</span>  for each  <span class="math">i \\in [\\ell]</span> , and accepts if and only if  <span class="math">V_{\\mathrm{PCP}}(x, (q_{1}, \\ldots, q_{\\ell}), (a_{1}, \\ldots, a_{\\ell})) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 2: The BMW Protocol  <span class="math">(P_{\\mathrm{BMW}}, V_{\\mathrm{BMW}})</span>  for  <span class="math">\\mathcal{L}</span></p>

    <p class="text-gray-300">Central to our paper is the notion of somewhere statistically binding (SSB) hash functions, first defined by Hubáček and Wichs [HW15]. These are hash functions with local openings that have an</p>

    <p class="text-gray-300">additional special property: for any index <span class="math">i^{<em>}</span>, one can generate a hash key that guarantees statistical binding for the position <span class="math">i^{</em>}</span>. Namely, even an unbounded adversary cannot open the bit at position <span class="math">i^{<em>}</span> to two different values. Furthermore, the hash key should be index-hiding, namely, it should hide the index <span class="math">i^{</em>}</span> from all polynomial-time adversaries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We augment this notion in two ways. First, we require that the statistically bound value at position <span class="math">i^{*}</span> can be recovered from the hash output using a trapdoor underlying the hash key. It turns out that the Hubáček-Wichs construction of SSB hash functions from homomorphic encryption already satisfies this property. Secondly, we augment the SSB family so that the hash key guarantees statistical binding for a set of positions <span class="math">I</span> simultaneously. Extractability now requires that there are $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> trapdoors, where </span>\\operatorname{td}_{i}<span class="math"> helps us recover the statistically bound value at the </span>i^{th}<span class="math"> position for any </span>i\\in I$. Finally, the index-hiding property needs to be augmented to hold even given the other trapdoors. We call the resulting notion a multi-extractable SSB (or meSSB) hash function.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We first present the definition of extractable SSB (eSSB) hash functions in Section 3.1 and that of multi-extractable SSB (meSSB) hash functions in Section 3.2. We also show how to construct meSSB hash functions from any eSSB hash function family in a simple way. Finally, in Section 3.3 and Appendix A, we reprove the soundness of the BMW protocol when instantiated with a meSSB hash function.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">3.1 Extractable Somewhere Statistically Binding (eSSB) Hash Functions</h3>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 3.1 (eSSB Hash Family).</h6>

    <p class="text-gray-300">An <span class="math">S=S(\\kappa)</span>-hiding extractable somewhere statistically binding (eSSB) hash family is a hash family with local opening <span class="math">(\\operatorname{Gen},\\operatorname{Hash},\\operatorname{Open},\\operatorname{Verify})</span>, with the following changes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Gen}(1^{\\kappa},L,i)</span> takes as additional input an index <span class="math">i\\in[L]</span> and outputs a hash key <span class="math">\\operatorname{hk}\\in\\{0,1\\}^{\\ell_{\\operatorname{hk}}}</span> as well as a trapdoor <span class="math">\\operatorname{td}\\in\\{0,1\\}^{\\ell_{\\operatorname{td}}}</span>,</li>

    </ul>

    <p class="text-gray-300">An eSSB hash family also has an additional PPT algorithm Invert.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Invert}(\\operatorname{td},\\operatorname{rt})</span> takes as input a trapdoor <span class="math">\\operatorname{td}\\in\\{0,1\\}^{\\ell_{\\operatorname{td}}}</span> and a hash value <span class="math">\\operatorname{rt}\\in\\{0,1\\}^{\\ell_{\\operatorname{hash}}}</span>, and outputs a value <span class="math">u\\in\\{0,1,\\bot\\}</span>.</li>

    </ul>

    <p class="text-gray-300">These algorithms should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S</span>-Index Hiding: For any <span class="math">\\operatorname{poly}(S(\\kappa))</span>-size adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> there exists a negligible function <span class="math">\\mu</span> such that for any <span class="math">L\\leq 2^{\\kappa}</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\left[b=b^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}i_{0},i_{1},\\operatorname{state}\\leftarrow\\mathcal{A}_{1}(1^{\\kappa})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">b\\stackrel{{\\scriptstyle\\$}}{{\\leftarrow}}\\{0,1\\}\\\\ (\\operatorname{hk},\\operatorname{td})\\leftarrow\\operatorname{Gen}(1^{\\kappa},L,i_{b})\\\\ b^{\\prime}\\leftarrow\\mathcal{A}_{2}(\\operatorname{hk},\\operatorname{state})\\end{array}\\right.\\right.=\\frac{1}{2}+\\mu(S(\\kappa)). \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness of Inversion: For any <span class="math">\\kappa\\in\\mathbb{N}</span>, <span class="math">L\\leq 2^{\\kappa}</span>, and any <span class="math">i\\in[L]</span> and <span class="math">x\\in\\{0,1\\}^{L}</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\operatorname{Invert}(\\operatorname{td},\\operatorname{Hash}(\\operatorname{hk},x))=x_{i}]=1,</span></p>

    <p class="text-gray-300">where the probability is over <span class="math">(\\operatorname{hk},\\operatorname{td})\\leftarrow\\operatorname{Gen}(1^{\\kappa},L,i)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere Statistically Binding: For any  <span class="math">\\kappa \\in \\mathbb{N}</span> ,  <span class="math">L \\leq 2^{\\kappa}</span> ,  <span class="math">i \\in [L]</span>  and  <span class="math">\\mathsf{rt} \\in \\{0,1\\}^{\\ell_{\\mathrm{hash}}}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\exists (u, o) \\quad s. t. \\quad u \\neq \\operatorname {I n v e r t} (\\mathrm {t d}, \\mathrm {r t}) \\quad \\wedge \\quad \\operatorname {V e r i f y} (\\mathrm {h k}, \\mathrm {r t}, i, u, o) = 1 \\right] = 0,</span></div>

    <p class="text-gray-300">where the probability is over  <span class="math">(\\mathsf{hk},\\mathsf{td})\\gets \\mathsf{Gen}(1^{\\kappa},L,i)</span></p>

    <p class="text-gray-300">Remark 3.2. We note that our definition of somewhere statistically binding is different and slightly stronger than the original notion given in [HW15], which states that for any  <span class="math">\\kappa \\in \\mathbb{N}</span> ,  <span class="math">L \\in \\mathbb{N}</span> ,  <span class="math">i \\in [L]</span>  and  <span class="math">\\mathsf{rt} \\in \\{0,1\\}^{\\ell_{\\mathrm{hash}}}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\exists (u, o, o ^ {\\prime}) \\quad s. t. \\quad u \\neq u ^ {\\prime} \\quad \\wedge \\quad \\text {V e r i f y} (\\mathsf {h k}, \\mathsf {r t}, i, u, o) = \\text {V e r i f y} (\\mathsf {h k}, \\mathsf {r t}, i, u ^ {\\prime}, o ^ {\\prime}) = 1 \\right] = 0,</span></div>

    <p class="text-gray-300">where the probability is over  <span class="math">\\mathsf{hk} \\gets \\mathsf{Gen}(1^{\\kappa}, L, i)</span> . The difference is that our definition permits "invalid" hash values for which Invert outputs  <span class="math">\\perp</span> , and we require that such hash values have no valid openings. The [HW15] definition simply requires that there is at most one valid opening for every hash value. This distinction, however, is not crucial to the rest of our paper.</p>

    <p class="text-gray-300">Hubáček and Wichs constructed SSB hash functions assuming the existence of a leveled homomorphic encryption scheme, and their construction is an extractable SSB hash function as well. We state the formal theorem below.</p>

    <p class="text-gray-300">Theorem 3.3 ([HW15]). Assuming the sub-exponential hardness of the learning with errors (LWE) problem, there exists a  <span class="math">2^{\\kappa^{<em>}}</span> -hiding eSSB hash family for some  <span class="math">\\epsilon &amp;gt; 0</span> . The  <span class="math">2^{\\kappa^{</em>}}</span> -hiding is via a  <span class="math">2^{\\kappa^{<em>}}</span> -straight-line reduction from the  <span class="math">2^{\\kappa^{</em>}}</span> -hardness of LWE (see Definition 2.2).</p>

    <h2 id="sec-32" class="text-2xl font-bold">3.2 Multi-Extractable SSB (meSSB) Hash Functions</h2>

    <p class="text-gray-300">Definition 3.4. An  <span class="math">S = S(\\kappa)</span> -hiding multi-extractable somewhere statistically binding (meSSB) hash family is a hash family with local opening (Gen, Hash, Open, Verify), where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Gen}(1^{\\kappa}, L, \\ell, I)</span>  takes as additional input  <span class="math">\\ell</span>  locations  <span class="math">I = (i_1, \\ldots, i_\\ell) \\in [L]^\\ell</span>  and outputs a hash key  <span class="math">\\mathsf{hk} \\in \\{0, 1\\}^{\\ell_{\\mathsf{hk}}}</span>  as well as a trapdoor  <span class="math">\\mathsf{td} = (\\mathsf{td}_1, \\ldots, \\mathsf{td}_\\ell) \\in \\{0, 1\\}^{\\ell \\cdot \\ell_{\\mathsf{td}}}</span> ,</li>

    </ul>

    <p class="text-gray-300">along with an additional PPT algorithm Invert which works as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\operatorname{Invert}(J, \\{\\mathsf{td}_j\\}_{j \\in J}, \\mathsf{rt})</span>  takes as input a subset  <span class="math">J \\subseteq [\\ell]</span>  of indices as well as a partial trapdoor  <span class="math">\\{\\mathsf{td}_j\\}_{j \\in J}</span>  and a hash value  <span class="math">\\mathsf{rt} \\in \\{0,1\\}^{\\ell_{\\mathrm{hash}}}</span> , and outputs  $u \\in \\{0,1,\\bot\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When no subset  <span class="math">J</span>  is provided,  <span class="math">\\operatorname{Invert}(\\mathsf{td},\\mathsf{rt})</span>  takes as input a full trapdoor  <span class="math">\\mathsf{td} \\in \\{0,1\\}^{\\ell \\cdot \\ell_{\\mathsf{td}}}</span>  and a hash value  <span class="math">\\mathsf{rt} \\in \\{0,1\\}^{\\ell_{\\mathsf{hash}}}</span>  and outputs  <span class="math">u \\in \\{0,1,\\bot\\}^{\\ell}</span> .</p>

    <p class="text-gray-300">These algorithms should satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S</span> -Index Hiding: For any  <span class="math">\\mathrm{poly}(S(\\kappa))</span> -size adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span> , there exists a negligible function  <span class="math">\\mu</span>  such that for any  <span class="math">L \\leq 2^{\\kappa}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = b ^ {\\prime} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} I ^ {0} := (i _ {1} ^ {0}, \\ldots , i _ {\\ell} ^ {0}), I ^ {1} := (i _ {1} ^ {1}, \\ldots , i _ {\\ell} ^ {1}), \\mathsf {s t a t e} \\gets \\mathcal {A} _ {1} (1 ^ {\\kappa}) \\\\ b \\stackrel {\\S} {\\gets} \\{0, 1 \\} \\\\ (\\mathsf {h k}, \\mathsf {t d} ^ {b}) \\gets \\mathsf {G e n} (1 ^ {\\kappa}, L, \\ell , I ^ {b}) \\\\ b ^ {\\prime} \\gets \\mathcal {A} _ {2} (\\mathsf {h k}, \\{\\mathsf {t d} _ {j} ^ {b} \\} _ {i _ {j} ^ {0} = i _ {j} ^ {1}}, \\mathsf {s t a t e}) \\end{array} \\right. \\right] = \\frac {1}{2} + \\mu (S (\\kappa)).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In words, index-hiding requires that even given the trapdoor information for the overlap of the two ordered sets <span class="math">I^0 = (i_1^0,\\ldots ,i_\\ell^0)</span> and <span class="math">I^{1} = (i_{1}^{1},\\dots ,i_{\\ell}^{1})</span>, the adversary still cannot distinguish whether <span class="math">\\mathsf{hk}</span> is statistically binding on <span class="math">I^0</span> or <span class="math">I^1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness of Inversion: For any <span class="math">\\kappa \\in \\mathbb{N}</span>, <span class="math">L \\leq 2^{\\kappa}</span>, and any <span class="math">I \\in [L]^{\\ell}</span>, <span class="math">J \\subseteq [\\ell]</span>, and <span class="math">x \\in \\{0,1\\}^{L}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {I n v e r t} (J, \\left\\{\\mathrm {t d} _ {j} \\right\\} _ {j \\in J}, \\operatorname {H a s h} (\\mathrm {h k}, x)) = \\left\\{x _ {i _ {j}} \\right\\} _ {j \\in J} \\right] = 1,</span></div>

    <p class="text-gray-300">where the probability is over <span class="math">(\\mathsf{hk},\\mathsf{td})\\gets \\mathsf{Gen}(1^{\\kappa},L,\\ell ,I)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere Statistically Binding: For any <span class="math">\\kappa \\in \\mathbb{N}</span>, <span class="math">L \\leq 2^{\\kappa}</span>, <span class="math">I \\in [L]^{\\ell}</span>, <span class="math">i \\in I</span> and <span class="math">\\mathsf{rt} \\in \\{0,1\\}^{\\ell_{\\mathrm{hash}}}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\exists (u, o) \\text{ s.t. } u \\neq \\operatorname {I n v e r t} ((i), \\{\\mathrm {t d} _ {i} \\}, \\mathrm {r t}) \\wedge \\operatorname {V e r i f y} (\\mathrm {h k}, \\mathrm {r t}, i, u, o) = 1 \\right] = 0,</span></div>

    <p class="text-gray-300">where the probability is over <span class="math">(\\mathsf{hk},\\mathsf{td})\\gets \\mathsf{Gen}(1^{\\kappa},L,\\ell ,I)</span></p>

    <p class="text-gray-300">Multi-extractable SSB (meSSB) hash families can be constructed from extractable SSB (eSSB) families by invoking many independent copies. The formal construction is given in Figure 3.</p>

    <p class="text-gray-300"><strong>Lemma 3.5.</strong> When the number of statistically bound locations <span class="math">\\ell</span> is at most <span class="math">\\mathrm{poly}(S)</span>, the hash family <span class="math">\\mathcal{H}_{\\mathrm{meSSB}}</span> defined in Figure 3 is an <span class="math">S</span>-hiding multi-extractable SSB hash family. Furthermore, its <span class="math">S</span>-hiding is <span class="math">S</span>-straight line reducible from the <span class="math">S</span>-hiding of the underlying eSSB hash family. It also holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\ell_ {\\mathrm {m e S S B}, \\mathrm {h k}} = \\ell \\cdot \\ell_ {\\mathrm {e S S B}, \\mathrm {h k}}, \\ell_ {\\mathrm {m e S S B}, \\mathrm {h a s h}} = \\ell \\cdot \\ell_ {\\mathrm {m e S S B}, \\mathrm {h a s h}}, \\ell_ {\\mathrm {m e S S B}, \\mathrm {t d}} = \\ell \\cdot \\ell_ {\\mathrm {e S S B}, \\mathrm {t d}}, \\text{ and } \\ell_ {\\mathrm {m e S S B}, \\mathrm {o}} = \\ell \\cdot \\ell_ {\\mathrm {m e S S B}, \\mathrm {o}}</span></div>

    <p class="text-gray-300">where <span class="math">\\ell_{\\mathrm{meSSB,hk}},\\ell_{\\mathrm{meSSB,hash}},\\ell_{\\mathrm{meSSB,td}},\\ell_{\\mathrm{meSSB,o}}</span> are the parameters associated with <span class="math">\\mathcal{H}_{\\mathrm{meSSB}}</span> and <span class="math">\\ell_{\\mathrm{eSSB,hk}},\\ell_{\\mathrm{eSSB,hash}},\\ell_{\\mathrm{eSSB,td}},\\ell_{\\mathrm{eSSB,o}}</span> are the parameters associated with <span class="math">\\mathcal{H}_{\\mathrm{eSSB}}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The correctness of inversion and <span class="math">\\ell</span>-somewhere statistically binding properties follow straightforwardly from the corresponding properties of the underlying eSSB hash family (Definition 3.1), so we focus on the <span class="math">S</span>-index hiding property. In particular, we present a straight-line reduction from the <span class="math">S</span>-hiding of the underlying eSSB hash family to the <span class="math">S</span>-hiding of the meSSB hash family.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that there were a size-poly <span class="math">(S)</span>  algorithm <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  such that for <span class="math">(i_1^0, \\ldots, i_\\ell^0), (i_1^1, \\ldots, i_\\ell^1), \\text{state} \\gets \\mathcal{A}_1(1^\\kappa)</span>, <span class="math">\\mathcal{A}_2(\\cdot, \\text{state})</span> can distinguish between <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}</span> generated on index locations <span class="math">\\{i_j^0\\}_{j \\in [\\ell]}</span> and <span class="math">\\{i_j^1\\}_{j \\in [\\ell]}</span> with probability <span class="math">\\delta(S)</span>, where <span class="math">\\delta</span> is a non-negligible function, given partial trapdoor information $\\mathsf{td}_{\\mathsf{meSSB}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{i^0 \\cap i^1}<span class="math">. Fix </span>(i_1^0, \\ldots, i_\\ell^0), (i_1^1, \\ldots, i_\\ell^1)<span class="math"> to be the output of </span>\\mathcal{A}_1<span class="math"> for which </span>\\mathcal{A}_2<span class="math"> has the greatest distinguishing advantage, which is at least </span>\\delta(S)<span class="math">. By a hybrid argument, there is some index </span>j^<em> \\notin i^0 \\cap i^1<span class="math"> for which </span>\\mathcal{A}_2(\\cdot, \\text{state})<span class="math"> can distinguish between </span>\\mathsf{hk}_{\\mathsf{meSSB}}<span class="math"> generated on indices </span>(i_1^0, \\ldots, i_{j^</em> - 1}^0, i_{j^<em>}^1, i_{j^</em> + 1}^1, \\ldots, i_\\ell)<span class="math"> and </span>(i_1^0, \\ldots, i_{j^<em> - 1}^0, i_{j^</em>}^0, i_{j^<em> + 1}^1, \\ldots, i^\\ell)<span class="math"> with probability </span>\\geq \\delta(S)/\\ell<span class="math">. Then, to break the </span>S<span class="math">-hiding of the eSSB hash family, an adversary can distinguish between </span>\\mathsf{hk}_{\\mathsf{eSSB}}^</em><span class="math"> generated by </span>\\mathsf{Gen}_{\\mathsf{eSSB}}(1^\\kappa, L, i_{j^<em>}^0)<span class="math"> and </span>\\mathsf{Gen}_{\\mathsf{eSSB}}(1^\\kappa, L, i_{j^</em>}^1)<span class="math"> by generating </span>(\\mathsf{hk}_{\\mathsf{eSSB}, j}, \\mathsf{td}_{\\mathsf{eSSB}, j}) \\gets \\mathsf{Gen}_{\\mathsf{eSSB}}(1^\\kappa, L, i_j^{b(j)})<span class="math"> for </span>j \\in [j^<em> - 1] \\cup [j^</em> + 1, \\ell]<span class="math">, where </span>b(j) = 1<span class="math"> if </span>j &gt; j^<em><span class="math"> and </span>b(j) = 0<span class="math"> if </span>j &lt; j^</em><span class="math">. Then, she runs </span>\\mathcal{A}_2(\\cdot, \\text{state})<span class="math"> on the meSSB hash key </span>(\\mathsf{hk}_{\\mathsf{eSSB}, 1}, \\ldots, \\mathsf{hk}_{\\mathsf{eSSB}, j^<em> - 1}, \\mathsf{hk}_{\\mathsf{eSSB}}^</em>, \\mathsf{hk}_{\\mathsf{eSSB}, j^* + 1}, \\ldots, \\mathsf{hk}_{\\mathsf{eSSB}, \\ell})<span class="math"> and outputs </span>\\mathcal{A}_2(\\cdot, \\text{state})<span class="math">&#x27;s output. This has a distinguishing advantage of </span>\\geq \\delta(S)/\\ell<span class="math">, which is non-negligible in </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, observe that this reduction is straight-line.</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{H}_{\\mathrm{eSSB}} = (\\mathrm{Gen}_{\\mathrm{eSSB}}, \\mathrm{Hash}_{\\mathrm{eSSB}}, \\mathrm{Open}_{\\mathrm{eSSB}}, \\mathrm{Verify}_{\\mathrm{eSSB}}, \\mathrm{InverteSSB})</span>  be an  <span class="math">S</span> -hiding eSSB hash family. The meSSB hash family</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {H} _ {\\mathrm {m e S S B}} = \\left(\\operatorname {G e n} _ {\\mathrm {m e S S B}}, \\operatorname {H a s h} _ {\\mathrm {m e S S B}}, \\operatorname {O p e n} _ {\\mathrm {m e S S B}}, \\operatorname {V e r i f y} _ {\\mathrm {m e S S B}}, \\operatorname {I n v e r t} _ {\\mathrm {m e S S B}}\\right),</span></div>

    <p class="text-gray-300">is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Gen}_{\\mathrm{meSSB}}(1^{\\kappa},L,\\ell ,I\\coloneqq (i_1,\\ldots ,i_\\ell))</span>  samples a pair  <span class="math">(\\mathsf{hk}_{\\mathsf{eSSB},j},\\mathsf{td}_{\\mathsf{eSSB},j})\\gets \\mathrm{Gen}_{\\mathsf{eSSB}}(1^{\\kappa},L,i_{j})</span>  for every  <span class="math">j\\in [\\ell ]</span>  . It outputs  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}} = (\\mathsf{hk}_{\\mathsf{eSSB},1},\\dots ,\\mathsf{hk}_{\\mathsf{eSSB},\\ell})</span>  and</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {t d} _ {\\mathrm {m e S S B}} = \\left(\\left(i _ {1}, \\mathrm {t d} _ {\\mathrm {e S S B}, 1}\\right), \\dots , \\left(i _ {\\ell}, \\mathrm {t d} _ {\\mathrm {e S S B}, \\ell}\\right)\\right).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hash}_{\\mathrm{meSSB}}(\\mathsf{hk}_{\\mathrm{meSSB}},x)</span>  takes as input a hash key  <span class="math">\\mathsf{hk}_{\\mathrm{meSSB}} = (\\mathsf{hk}_{\\mathrm{eSSB},1},\\dots ,\\mathsf{hk}_{\\mathrm{eSSB},\\ell})</span>  and an input  <span class="math">x\\in \\{0,1\\} ^L</span>  and outputs  <span class="math">\\mathsf{rt} = (\\mathsf{rt}_1,\\ldots ,\\mathsf{rt}_\\ell)</span> , where  <span class="math">\\mathsf{rt}_j = \\mathsf{Hash}_{\\mathrm{eSSB}}(\\mathsf{hk}_{\\mathrm{eSSB},j},x)</span>  for every  <span class="math">j\\in [\\ell ]</span></li>

      <li><span class="math">\\mathrm{Open}_{\\mathrm{meSSB}}(\\mathsf{hk}_{\\mathrm{meSSB}},x,k)</span>  takes as input a hash key  <span class="math">\\mathsf{hk}_{\\mathrm{meSSB}} = (\\mathsf{hk}_{\\mathrm{eSSB},1},\\dots ,\\mathsf{hk}_{\\mathrm{eSSB},\\ell})</span> <span class="math">x\\in \\{0,1\\} ^L</span>  and an index  <span class="math">k\\in [L]</span> , and outputs the opening  <span class="math">\\mathsf{o} = (\\mathsf{o}_1,\\ldots ,\\mathsf{o}_\\ell)</span> , where  <span class="math">\\mathsf{o}_j\\gets \\mathrm{Open}_{\\mathrm{eSSB}}(\\mathsf{hk}_{\\mathrm{eSSB},j},x,k)</span> .</li>

      <li>Verify <span class="math">_{\\text{meSSB}}(\\mathsf{hk}_{\\text{meSSB}}, \\mathsf{rt}, k, u, o)</span>  takes as input a hash key  <span class="math">\\mathsf{hk}_{\\text{meSSB}} = (\\mathsf{hk}_{\\text{eSSB}, 1}, \\ldots, \\mathsf{hk}_{\\text{eSSB}, \\ell})</span> ,  <span class="math">\\mathsf{rt} = (\\mathsf{rt}_1, \\ldots, \\mathsf{rt}_\\ell)</span> ,  <span class="math">k \\in [L]</span> ,  <span class="math">u \\in \\{0, 1\\}</span> , and an opening  <span class="math">\\mathsf{o} = (\\mathsf{o}_1, \\ldots, \\mathsf{o}_\\ell)</span> , and outputs 1 if and only if  <span class="math">\\text{Verify}_{\\text{eSSB}}(\\mathsf{hk}_{\\text{eSSB}, j}, \\mathsf{rt}_j, k, u, \\mathsf{o}_j) = 1 \\forall j \\in [\\ell]</span> .</li>

      <li><span class="math">\\operatorname{Invert}_{\\text{meSSB}}(\\operatorname{td}_{\\text{meSSB}}, \\mathsf{rt})</span>  takes as input the trapdoor  <span class="math">\\operatorname{td}_{\\text{meSSB}} = (\\operatorname{td}_{\\text{eSSB}, 1}, \\dots, \\operatorname{td}_{\\text{eSSB}, \\ell})</span>  and  <span class="math">\\mathsf{rt} = (\\mathsf{rt}_1, \\dots, \\mathsf{rt}_\\ell)</span>  and outputs the  <span class="math">\\ell</span>  values ( <span class="math">\\operatorname{Invert}_{\\text{eSSB}}(\\operatorname{td}_{\\text{eSSB}, 1}, \\mathsf{rt}_1), \\dots, \\operatorname{Invert}_{\\text{eSSB}}(\\operatorname{td}_{\\text{eSSB}, \\ell}, \\mathsf{rt}_\\ell)</span> ).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\operatorname{Invert}_{\\mathrm{meSSB}}(J, \\{\\mathrm{td}_{\\mathrm{meSSB},j}\\}_{j \\in J}, \\mathrm{rt})</span>  proceeds similarly, taking as input  <span class="math">J \\subseteq [\\ell]</span> , the partial trapdoor  <span class="math">\\{\\mathrm{td}_{\\mathrm{meSSB},j}\\}_{j \\in J}</span>  and  <span class="math">\\mathrm{rt} = (\\mathrm{rt}_1, \\dots, \\mathrm{rt}_\\ell)</span>  and outputs the  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  values</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\operatorname {I n v e r t} _ {\\mathrm {e S S B}} \\left(\\mathrm {t d} _ {\\mathrm {e S S B}, j}, \\mathrm {r t} _ {j}\\right) \\right\\} _ {j \\in J}.</span></div>

    <p class="text-gray-300">Figure 3: The meSSB Hash Family (GenmeSSB, HashmeSSB, OpenmeSSB, VerifymeSSB, InvertmeSSB)</p>

    <p class="text-gray-300">Recall that the BMW heuristic is a two message succinct argument, where the verifier queries a PCP via a PCP query consisting of  <span class="math">\\ell</span>  locations by sending  <span class="math">\\ell</span>  parallel independent PIR queries to the prover. The prover computes, under the PIR, the  <span class="math">\\ell</span>  answers and sends them back to the verifier. The verifier then reconstructs the  <span class="math">\\ell</span>  answers and checks them via the PCP verification algorithm.</p>

    <p class="text-gray-300">We note that a eSSB hash family functions as a PIR scheme, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Query}(1^{\\kappa}, L, q)</span>  calls  <span class="math">(\\mathsf{hk}_{\\mathsf{eSSB}}, \\mathsf{td}_{\\mathsf{eSSB}}) \\gets \\operatorname{Gen}_{\\mathsf{eSSB}}(1^{\\kappa}, L, q)</span>  and outputs  <span class="math">(\\hat{q}, \\mathsf{td})</span> , where  <span class="math">\\hat{q} = \\mathsf{hk}_{\\mathsf{eSSB}}</span>  and  <span class="math">\\mathsf{td} = \\mathsf{td}_{\\mathsf{eSSB}}</span> .</li>

      <li>Answer  <span class="math">(\\hat{q}, \\pi)</span>  takes as input  <span class="math">\\hat{q} = \\mathsf{hk}_{\\mathrm{eSSB}}</span>  and  <span class="math">\\pi \\in \\{0,1\\}^L</span>  and produces  <span class="math">\\hat{a} = \\mathsf{rt} = \\mathsf{Hash}_{\\mathrm{eSSB}}(\\mathsf{hk}_{\\mathrm{eSSB}}, \\pi)</span> .</li>

      <li>Reconstruct  <span class="math">(\\mathrm{td},\\hat{a})</span>  takes as input  <span class="math">\\mathrm{td} = \\mathrm{td}_{\\mathrm{eSSB}}</span>  and  <span class="math">\\hat{a} = \\mathrm{rt}</span>  and outputs  <span class="math">\\mathrm{Invert}_{\\mathrm{eSSB}}(\\mathrm{td}_{\\mathrm{eSSB}},\\mathrm{rt})</span> .</li>

    </ul>

    <p class="text-gray-300">Thus, we can run the BMW heuristic with eSSB hash functions in place of the PIRs. In fact, the notion of these <span class="math">\\ell</span> parallel eSSB hash functions is captured by our notion of a meSSB hash function, and thus we can run the BMW heuristic with a single meSSB hash function (binding on the <span class="math">\\ell</span> locations of a PCP query) instead of the <span class="math">\\ell</span> parallel PIR queries. Indeed, as we formally state below, the BMW heuristic is sound when instantiated with a meSSB hash family and a computationally non-signaling PCP.</p>

    <p class="text-gray-300">Let <span class="math">(\\text{Gen}_{\\text{meSSB}},\\text{Hash}_{\\text{meSSB}},\\text{Open}_{\\text{meSSB}},\\text{Verify}_{\\text{meSSB}},\\text{Open}_{\\text{meSSB}})</span> be a meSSB hash family. On input <span class="math">1^{\\kappa}</span> and <span class="math">x</span>, the 2 message protocol <span class="math">(\\mathcal{P}_{\\text{BMW}},\\mathcal{V}_{\\text{BMW}})</span> proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier: <span class="math">\\mathcal{V}_{\\text{BMW}}</span> computes <span class="math">(q_{1},\\ldots,q_{\\ell})\\leftarrow\\mathcal{Q}_{\\text{PCP}}(1^{\\kappa})</span>. He computes <span class="math">(\\text{hk}_{\\text{meSSB}},\\text{td}_{\\text{meSSB}})\\leftarrow\\text{Gen}_{\\text{meSSB}}(1^{\\kappa},L,(q_{1},\\ldots,q_{\\ell}))</span> and sends <span class="math">\\text{hk}_{\\text{meSSB}}</span> to the prover.</li>

      <li>Prover: <span class="math">\\mathcal{P}_{\\text{BMW}}</span> computes the PCP string <span class="math">\\pi=\\Pi(x)</span>, and sends <span class="math">x</span> and <span class="math">\\text{rt}\\leftarrow\\text{Hash}_{\\text{meSSB}}(\\text{hk}_{\\text{meSSB}},\\pi)</span> to the verifier.</li>

      <li>Verdict: <span class="math">\\mathcal{V}_{\\text{BMW}}</span> computes <span class="math">(a_{1},\\ldots,a_{\\ell})\\leftarrow\\text{Invert}_{\\text{meSSB}}([\\ell],\\text{td}_{\\text{meSSB}},\\text{rt})</span> and accepts if and only if <span class="math">\\mathcal{V}_{\\text{PCP}}(x,(q_{1},\\ldots,q_{\\ell}),(a_{1},\\ldots,a_{\\ell}))=1</span>.</li>

    </ul>

    <p class="text-gray-300">Figure 4: BMW Heuristic with a meSSB Hash Function</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 3.6.</h6>

    <p class="text-gray-300">Let <span class="math">(\\Pi,\\mathcal{Q}_{\\text{nsPCP}},\\mathcal{V}_{\\text{nsPCP}})</span> be a PCP for a language <span class="math">\\mathcal{L}</span> with adaptive <span class="math">\\Omega(n)</span>-computational non-signaling soundness and locality <span class="math">\\ell</span>. Assume that the meSSB hash family is <span class="math">\\Omega^{\\prime}</span>-hiding, where <span class="math">\\Omega^{\\prime}=\\Omega^{\\prime}(\\kappa)</span> is such that <span class="math">\\Omega^{\\prime}(\\kappa)=\\Omega(n)</span> and <span class="math">2^{-\\kappa}=\\text{negl}(\\Omega^{\\prime})</span>. Then, for any <span class="math">\\text{poly}(\\Omega^{\\prime}(\\kappa))</span>-size cheating prover <span class="math">\\mathcal{P}^{*}</span>, there is a negligible function <span class="math">\\mu</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathcal{V}_{\\text{BMW}}(x,\\text{rt},\\text{td}_{\\text{meSSB}},(q_{1},\\ldots,q_{\\ell}))=1\\ \\wedge\\ x\\notin\\mathcal{L}\\right]\\leq\\mu(\\Omega^{\\prime}),</span></p>

    <p class="text-gray-300">where <span class="math">(x,\\text{rt})\\leftarrow\\mathcal{P}^{*}(\\text{hk}_{\\text{meSSB}})</span> and where the probability is over <span class="math">(q_{1},\\ldots,q_{\\ell})\\leftarrow Q_{\\text{PCP}}(1^{\\kappa})</span> and <span class="math">(\\text{hk}_{\\text{meSSB}},\\text{td}_{\\text{meSSB}})\\leftarrow\\text{Gen}_{\\text{meSSB}}(1^{k},L,(q_{1},\\ldots,q_{\\ell})</span>. In other words,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathcal{V}_{\\text{nsPCP}}(x,Q,\\text{Invert}_{\\text{meSSB}}(\\text{td}_{\\text{meSSB}},\\text{rt}))=1\\ \\wedge\\ x\\notin\\mathcal{L}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}Q\\leftarrow\\mathcal{Q}_{\\text{nsPCP}}(1^{\\kappa},L)\\cr(\\text{hk}_{\\text{meSSB}},\\text{td}_{\\text{meSSB}})\\leftarrow\\text{Gen}_{\\text{meSSB}}(1^{\\kappa},L,Q)\\cr(x,\\text{rt})\\leftarrow\\mathcal{P}^{*}(\\text{hk}_{\\text{meSSB}})\\end{matrix}\\right.\\right]\\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=\\text{negl}(\\Omega^{\\prime}).</span> (1)</p>

    <p class="text-gray-300">Moreover, this is proven via a <span class="math">\\Omega^{\\prime}</span>-straight-line reduction (Definition 2.2).</p>

    <p class="text-gray-300">For the sake of completeness, we prove Theorem 3.6 in Appendix A.</p>

    <p class="text-gray-300">4 Somewhere Statistically Sound Interactive Arguments</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.1 Defining <span class="math">\\SSS</span> Arguments</h3>

    <p class="text-gray-300">Let <span class="math">\\kappa</span> denote a security parameter.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">An interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})(1^{\\kappa})</span> for a language <span class="math">\\mathcal{L}=\\{\\mathcal{L}_{n}\\}_{n\\in\\mathbb{N}}</span> is <em>statistically sound</em> if for every (potentially computationally unbounded) cheating prover <span class="math">\\mathcal{P}^{*}</span> there exists a negligible function <span class="math">\\mu</span> such that for every <span class="math">x\\not\\in\\mathcal{L}</span>, the soundness error is negligible. That is,</p>

    <p class="text-gray-300"><span class="math">\\Pr[(\\mathcal{P}^{*},\\mathcal{V})(1^{\\kappa},x)=1]\\leq\\mu(\\kappa).</span></p>

    <p class="text-gray-300">We will sometimes parameterize the soundness error and will call a protocol <span class="math">\\theta</span>-statistically sound if its soundness error is at most <span class="math">\\theta(\\kappa)</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">An interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})(1^{\\kappa})</span> for a language <span class="math">\\mathcal{L}=\\{\\mathcal{L}_{n}\\}_{n\\in\\mathbb{N}}</span> is <span class="math">\\theta=\\theta(\\kappa)</span>-somewhere statistically sound (<span class="math">\\SSS</span>) with respect to a <span class="math">\\theta</span>-decisional complexity assumption <span class="math">\\mathsf{A}</span> if for every first verifier message <span class="math">\\beta_{1}</span>, there exists a second verifier message <span class="math">T(\\beta_{1})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Adaptive) <span class="math">\\theta</span>-Somewhere Statistically Soundness: For every <span class="math">\\mathrm{poly}(\\theta)</span>-size (cheating) prover <span class="math">\\mathcal{P}^{<em>}</span> that generates an instance <span class="math">x</span>, conditioned on the first three messages being <span class="math">(\\beta_{1},\\mathcal{P}^{</em>}(\\beta_{1}),T(\\beta_{1}))</span>, the remaining protocol is <span class="math">\\theta</span>-statistically sound with overwhelming probability <span class="math">1-\\mathrm{negl}(\\theta)</span> over <span class="math">\\beta_{1}</span>, assuming <span class="math">\\mathsf{A}</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, this condition holds in a <span class="math">\\theta</span>-straight-line manner; i.e., there is a black box reduction <span class="math">\\mathcal{R}</span> such that <span class="math">\\mathcal{R}</span>, given oracle access to a cheating prover <span class="math">\\mathcal{P}^{<em>}</span> that gives <span class="math">x</span> for which the protocol beginning with <span class="math">(\\beta_{1},\\mathcal{P}^{</em>}(\\beta_{1}),T(\\beta_{1}))</span> is not <span class="math">\\theta</span>-statistically sound with overwhelming probability <span class="math">1-\\mathrm{negl}(\\theta)</span>, simulates the protocol with the prover by sending a message for every round once (without rewinding), where the messages for the first two verifier rounds are <span class="math">\\beta_{1}</span> and <span class="math">T(\\beta_{1})</span>, and uses the resulting transcript and instance to break the underlying assumption <span class="math">\\mathsf{A}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\theta</span>-Computational Indistinguishability: For any <span class="math">\\mathrm{poly}(\\theta)</span>-size distinguisher <span class="math">\\mathcal{D}</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{\\beta_{1}}[\\mathcal{D}(\\beta_{1},T(\\beta_{1}))=1]-\\Pr_{\\beta_{1},\\beta_{2}}[\\mathcal{D}(\\beta_{1},\\beta_{2})=1]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{negl}(\\theta).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, this indistinguishability is <span class="math">\\theta</span>-straight line, with respect to assumption <span class="math">\\mathsf{A}</span>.</p>

    <p class="text-gray-300">We remark that this is a strong definition: our cheating prover proceeds in two stages, a stage-<span class="math">1</span> <span class="math">\\mathcal{P}_{1}^{<em>}</span> which is computationally bounded and produces the instance and the second message; and a stage-<span class="math">2</span> <span class="math">\\mathcal{P}_{2}^{</em>}</span> who produces the rest of the transcript, and has no computational limitations. How could one possibly use a cheating prover <span class="math">(\\mathcal{P}_{1}^{<em>},\\mathcal{P}_{2}^{</em>})</span> to break a computational assumption when <span class="math">\\mathcal{P}_{2}^{<em>}</span> is unbounded? While this seems mysterious at first sight, we remark that similar situations arise in other places, e.g., in the proof of the </em>[x12]* protocol. Indeed, we will use similar ideas in our reduction.</p>

    <p class="text-gray-300">4.2 <span class="math">\\mathsf{SSS}</span> implies Straight-Line Soundness</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 4.3.</h6>

    <p class="text-gray-300">Any <span class="math">\\theta</span>-<span class="math">\\mathsf{SSS}</span> interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> w.r.t. a <span class="math">\\theta</span>-decisional complexity assumption <span class="math">\\mathsf{A}</span> is <span class="math">\\theta</span>-straight-line sound.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove straight-line soundness, we will define a straight-line reduction from the adaptie <span class="math">\\theta</span>-somewhere statistically sound and <span class="math">\\theta</span>-computational indistinguishability assumptions to the <span class="math">\\theta</span>-soundness of <span class="math">(\\mathcal{P},\\mathcal{V})</span>. Then, combining with the fact that there is a straight-line reduction from some <span class="math">\\theta</span>-decisional complexity assumption <span class="math">\\mathsf{A}</span> to the adaptive <span class="math">\\theta</span>-somewhere statistically sound and <span class="math">\\theta</span>-computational indistinguishability properties, we obtain that there is a <span class="math">\\theta</span>-straight-line reduction from <span class="math">\\mathsf{A}</span> to the adaptive <span class="math">\\theta</span>-soundness of <span class="math">(\\mathcal{P},\\mathcal{V})</span>.</p>

    <p class="text-gray-300">Suppose that there is a <span class="math">\\mathrm{poly}(\\theta)</span>-size cheating prover <span class="math">\\mathcal{P}^{<em>}</span> such that <span class="math">\\Pr[(\\mathcal{P}^{</em>},\\mathcal{V})(1^{\\kappa},x)=1:x\\leftarrow\\mathcal{P}^{<em>}(1^{\\kappa})]=\\delta(\\theta)</span>, where <span class="math">\\delta</span> is a non-negligible function. Now, given <span class="math">(\\beta_{1},\\beta_{2})</span>, in which either <span class="math">\\beta_{2}=T(\\beta_{1})</span> or <span class="math">\\beta_{2}</span> is random, reduction <span class="math">\\mathcal{R}</span> simulates an interaction of <span class="math">\\mathcal{V}</span> with <span class="math">\\mathcal{P}^{</em>}</span> using the first two verifier messages <span class="math">\\beta_{1}</span> and <span class="math">\\beta_{2}</span>. If the resulting transcript for instance <span class="math">x</span> produced by <span class="math">\\mathcal{P}^{*}</span> is accepting, <span class="math">\\mathcal{R}</span> outputs <span class="math">1</span>. Otherwise, it outputs <span class="math">0</span>.</p>

    <p class="text-gray-300">Note that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\beta_{1},\\beta_{2}}[(\\mathcal{P}^{<em>},\\mathcal{V})(1^{\\kappa},x)=1:x\\leftarrow\\mathcal{P}^{</em>}(1^{\\kappa})]=\\delta(\\theta),</span></p>

    <p class="text-gray-300">so the distinguishing advantage of the reduction is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta(\\theta)-\\Pr_{\\beta_{1}}[(\\mathcal{P}^{*},\\mathcal{V})(1^{\\kappa},x)=1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ x\\leftarrow\\mathcal{P}^{*}(1^{\\kappa}),\\beta_{2}=T(\\beta_{1})],$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which under the <span class="math">\\theta</span>-somewhere statistically sound assumption is <span class="math">\\delta(\\theta)-\\mathrm{negl}(\\theta)</span>, which is non-negligible in <span class="math">\\theta</span>. This means that the <span class="math">\\theta</span>-somewhere statistically sound and <span class="math">\\theta</span>-computationally indistinguishability properties cannot simultaneously hold. ∎</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">4.3 <span class="math">\\mathsf{SSS}</span> implies Post-Quantum Soundness</h3>

    <p class="text-gray-300">Finally, we prove that the importance of a <span class="math">\\theta</span>-straight-line sound argument is that if the underlying <span class="math">\\theta</span>-decisional complexity assumption is <span class="math">\\theta</span>-post-quantum secure, then the argument is sound against <span class="math">\\mathrm{poly}(\\theta)</span>-size quantum provers, with overwhelming probability in <span class="math">\\theta</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 4.4.</h6>

    <p class="text-gray-300">Any argument <span class="math">(\\mathcal{P},\\mathcal{V})</span> that is <span class="math">\\theta</span>-straight-line sound w.r.t. a <span class="math">\\theta</span>-decisional complexity assumption <span class="math">\\mathsf{A}</span>, is also post-quantum sound assuming <span class="math">\\mathsf{A}</span> holds w.r.t. quantum adversaries.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix any <span class="math">\\mathrm{poly}(\\theta)</span>-size cheating quantum prover <span class="math">\\mathcal{P}^{*}</span> that for infinitely many <span class="math">\\kappa\\in\\mathbb{N}</span>, produces a rejecting instance and convinces <span class="math">\\mathcal{V}</span> of this rejecting instance with probability <span class="math">1/\\mathrm{poly}(\\theta(\\kappa))</span>. By the <span class="math">\\theta</span>-straight-line soundness, there exists a <span class="math">\\mathsf{PPT}</span> black-box reduction <span class="math">\\mathcal{R}</span> that given oracle access to any classical cheating prover <span class="math">\\mathcal{P}^{<strong>}</span> that breaks soundness with probability <span class="math">1/\\mathrm{poly}(\\theta)</span>, interacts with <span class="math">\\mathcal{P}^{</strong>}</span> once (without rewinding) by sending <span class="math">\\mathcal{P}^{**}</span> a single message for each round, and using the transcript and instance obtained, breaks assumption <span class="math">\\mathsf{A}</span>.</p>

    <p class="text-gray-300">We next argue that <span class="math">\\mathcal{R}</span> successfully breaks <span class="math">\\mathsf{A}</span> even given oracle access to the quantum adversary <span class="math">\\mathcal{P}^{<em>}</span>. This follows from the following observations. First, observe that <span class="math">\\mathcal{R}</span> interacts with <span class="math">\\mathcal{P}^{</em>}</span> using completely classical messages. Secondly, <span class="math">\\mathcal{P}^{*}</span> can be simulated exactly by an unbounded classical</p>

    <p class="text-gray-300">adversary  <span class="math">\\mathcal{P}^{<strong>}</span> , which therefore also generates an accepting transcript with probability  <span class="math">1 / \\mathrm{poly}(\\theta)</span> . Finally, since the reduction is straight-line, it cannot distinguish between having oracle access to  <span class="math">\\mathcal{P}^<em></span>  and having oracle access to  <span class="math">\\mathcal{P}^{</strong>}</span> . Put together, since the reduction with oracle access to  <span class="math">\\mathcal{P}^{**}</span>  breaks A, it also breaks A given (non-rewinding) oracle access to  <span class="math">\\mathcal{P}^</em></span> .</p>

    <p class="text-gray-300">We instantiate Kilian's protocol with two ingredients: an adaptive  <span class="math">\\Omega(n)</span> -computational non-signaling PCP  <span class="math">(\\Pi, \\mathcal{Q}_{\\mathrm{nsPCP}}, \\mathcal{V}_{\\mathrm{nsPCP}})</span>  for a language  <span class="math">\\mathcal{L}</span> , and a meSSB hash family  <span class="math">(\\mathrm{Gen}_{\\mathrm{meSSB}}, \\mathrm{Hash}_{\\mathrm{meSSB}}, \\mathrm{Open}_{\\mathrm{meSSB}}, \\mathrm{Verify}_{\\mathrm{meSSB}}, \\mathrm{Invert}_{\\mathrm{meSSB}})</span> . The resulting protocol is described in Figure 5.</p>

    <p class="text-gray-300">Let  <span class="math">\\epsilon \\in (0,1)</span>  be a small constant, and let  <span class="math">\\kappa = \\kappa(n) = (\\log \\Omega(n))^{1/\\epsilon}</span> . On input  <span class="math">x</span> , the 4-message protocol  <span class="math">(\\mathcal{P}_{\\mathrm{nsKilian}}, \\mathcal{V}_{\\mathrm{nsKilian}})</span>  proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First verifier's message:  <span class="math">\\mathcal{V}_{\\mathrm{nsKilian}}</span>  samples  <span class="math">Q \\gets \\mathcal{Q}_{\\mathrm{nsPCP}}(1^{\\kappa})</span>  and  <span class="math">(\\mathsf{hk}_{\\mathrm{meSSB}}, \\mathsf{td}_{\\mathrm{meSSB}}) \\gets \\mathrm{Gen}_{\\mathrm{meSSB}}(1^{\\kappa}, L, Q)</span> , and sends  <span class="math">\\mathsf{hk}_{\\mathrm{meSSB}}</span>  to the prover.</li>

      <li>First prover's message:  <span class="math">\\mathcal{P}_{\\mathrm{nsKilian}}</span>  computes the PCP proof  <span class="math">\\pi = \\Pi(x)</span>  and its hash value  <span class="math">r_t = \\operatorname{Hash}_{\\mathrm{meSSB}}(\\mathsf{hk}_{\\mathrm{meSSB}}, \\pi)</span> . It sends  <span class="math">r_t</span>  to the verifier.</li>

      <li>Second verifier's message:  <span class="math">\\mathcal{V}_{\\mathrm{nsKilian}}</span>  computes a set of queries  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{nsPCP}}(1^{\\kappa})</span> , and sends  <span class="math">(q_{1},\\ldots ,q_{\\ell})</span>  to the prover.</li>

      <li>Second prover's message:  <span class="math">\\mathcal{P}_{\\mathrm{nsKilian}}</span>  computes for every  <span class="math">i \\in [\\ell]</span>  the opening  <span class="math">\\mathsf{o}_i = \\mathrm{Open}_{\\mathrm{meSSB}}(\\mathsf{hk}_{\\mathrm{meSSB}}, \\pi, q_i)</span> , and sends  <span class="math">\\{\\pi_{q_i}, \\mathsf{o}_i\\}_{i \\in [\\ell]}</span>  to the verifier.</li>

      <li>Verdict:  <span class="math">\\mathcal{V}_{\\mathrm{nsKilian}}</span>  accepts if and only if  <span class="math">\\mathcal{V}_{\\mathrm{nsPCP}}(x,(q_1,\\ldots ,q_\\ell),(\\pi_{q_1},\\ldots ,\\pi_{q_\\ell})) = 1</span>  and for every  <span class="math">i\\in [\\ell ]</span> ,  <span class="math">\\mathrm{Verify}_{\\mathrm{meSSB}}(\\mathrm{hk}_{\\mathrm{meSSB}},\\mathrm{rt},q_i,\\pi_{q_i},\\mathrm{o}_i) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 5: The Protocol  <span class="math">(\\mathcal{P}_{\\mathrm{nsKilian}},\\mathcal{V}_{\\mathrm{nsKilian}})</span>  for  <span class="math">\\mathcal{L}</span></p>

    <p class="text-gray-300">With these ingredients, and setting  <span class="math">\\kappa</span>  to be  <span class="math">(\\log \\Omega (n))^{1 / \\epsilon}</span>  such that  <span class="math">2^{\\kappa^{\\epsilon}} = \\Omega</span> , the resulting Kilian's protocol is a  <span class="math">2^{\\kappa^{\\epsilon}}</span> -SSS argument assuming the meSSB hash family is  <span class="math">2^{\\kappa^{\\epsilon}}</span> -hiding, as we show below. Since  <span class="math">2^{\\kappa^{\\epsilon}} = \\Omega (n)</span> , in an abuse of notation we say that the protocol is  <span class="math">\\Omega (n)</span> -SSS.</p>

    <p class="text-gray-300">Lemma 5.1.  <span class="math">(\\mathcal{P}_{\\mathrm{nsKilian}},\\mathcal{V}_{\\mathrm{nsKilian}})</span>  is a  <span class="math">\\Omega</span>  -SSS interactive argument assuming the meSSB hash family is  <span class="math">2^{\\kappa^{\\epsilon}}</span>  -hiding.</p>

    <p class="text-gray-300">Proof. For  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{td}_{\\mathsf{meSSB}})\\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa},L,Q)</span> , define  <span class="math">T(\\mathsf{hk}_{\\mathsf{meSSB}}) = Q</span> . We will show that  <span class="math">(\\mathcal{P}_{\\mathsf{nsKilian}},\\mathcal{V}_{\\mathsf{nsKilian}})</span>  satisfies the properties in Definition 4.2. We will use the fact that  <span class="math">2^{\\kappa^{\\epsilon}} = 2^{((\\log \\Omega)^{1 / \\epsilon})^{\\epsilon}} = \\Omega</span> . In particular, a  <span class="math">2^{\\kappa^{\\epsilon}}</span> -hiding meSSB hash family is in fact  <span class="math">\\Omega (n)</span> -hiding.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Adaptive  <span class="math">\\Omega</span> -Somewhere Statistically Sound: The adaptive  <span class="math">\\Omega</span> -somewhere statistically</li>

    </ul>

    <p class="text-gray-300">sound property of Definition 4.2 <span class="math">^{10}</span>  follows from the fact that for every poly  <span class="math">(\\Omega)</span> -size  <span class="math">\\mathcal{P}^<em> = (\\mathcal{P}_1^</em>, \\mathcal{P}_2^*)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} x \\notin \\mathcal {L} \\wedge \\exists \\{a _ {j}, \\mathsf {o} _ {j} \\} _ {j \\in [ \\ell ]} &amp;amp; Q \\leftarrow \\mathcal {Q} _ {\\mathrm {n s P C P}} (1 ^ {\\kappa}) \\\\ \\text {s . t .} \\mathcal {V} _ {\\mathrm {n s P C P}} (x, Q, (a _ {1}, \\ldots , a _ {\\ell})) = 1 &amp;amp; (\\mathsf {h k} _ {\\mathrm {m e S S B}}, \\mathsf {t d} _ {\\mathrm {m e S S B}}) \\leftarrow \\mathsf {G e n} _ {\\mathrm {m e S S B}} (1 ^ {\\kappa}, L, Q) \\\\ \\wedge \\mathsf {V e r i f y} _ {\\mathrm {m e S S B}} (\\mathsf {h k} _ {\\mathrm {m e S S B}}, \\mathsf {r t}, q _ {j}, a _ {j}, \\mathsf {o} _ {j}) = 1 \\forall j \\in [ \\ell ] &amp;amp; (x, \\mathsf {r t}, \\mathsf {s t a t e}) \\leftarrow \\mathcal {P} _ {1} ^ {*} (\\mathsf {h k} _ {\\mathrm {m e S S B}}) \\end{array} \\right] \\\\ \\leq \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathrm {n s P C P}} (x, Q, \\text {I n v e r t} _ {\\mathrm {m e S S B}} (\\mathrm {t d} _ {\\mathrm {m e S S B}}, \\mathrm {r t})) = 1 &amp;amp; Q \\leftarrow \\mathcal {Q} _ {\\mathrm {n s P C P}} (1 ^ {\\kappa}) \\\\ \\wedge x \\notin \\mathcal {L} &amp;amp; (\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\mathrm {t d} _ {\\mathrm {m e S S B}}) \\leftarrow \\operatorname {G e n} _ {\\mathrm {m e S S B}} (1 ^ {\\kappa}, L, Q) \\\\ &amp;amp; (x, \\mathrm {r t}, \\text {s t a t e}) \\leftarrow \\mathcal {P} _ {1} ^ {*} (\\mathrm {h k} _ {\\mathrm {m e S S B}}) \\end{array} \\right] \\\\ = \\operatorname {n e g l} (\\Omega), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where the last equality follows from Theorem 3.6 and the fact that the meSSB hash family is  <span class="math">2^{\\kappa^{<em>}}</span> -hiding (which is  <span class="math">\\Omega(n)</span> -hiding, as argued above). Furthermore, Corollary 3.6 gives that the reduction from the  <span class="math">2^{\\kappa^{</em>}}</span> -hiding of the meSSB hash family to the  <span class="math">\\Omega</span> -somewhere statistical soundness is  <span class="math">2^{\\kappa^{*}}</span> -straight-line.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computational Indistinguishability: In the formatted case, the pair  <span class="math">(\\beta_{1}, T(\\beta_{1}))</span>  is a pair  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}}, Q)</span>  where  <span class="math">Q \\gets \\mathcal{Q}_{\\mathsf{nsPCP}}(1^{\\kappa})</span>  and  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}}, \\mathsf{td}_{\\mathsf{meSSB}}) \\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa}, L, Q)</span> . Meanwhile, in the random case, the pair  <span class="math">(\\beta_{1}, \\beta_{2})</span>  is a pair  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}}^{\\prime}, Q)</span>  where  <span class="math">Q, Q^{\\prime} \\gets \\mathcal{Q}_{\\mathsf{nsPCP}}(1^{\\kappa})</span>  and  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}}^{\\prime}, \\mathsf{td}_{\\mathsf{meSSB}}^{\\prime}) \\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa}, L, Q^{\\prime})</span> . The  <span class="math">\\Omega</span> -indistinguishability of these two pairs follows from the  <span class="math">\\Omega(n)</span> -index hiding property of the meSSB hash family via a  <span class="math">2^{\\kappa^{*}}</span> -straight-line reduction: The reduction picks  <span class="math">Q \\gets \\mathcal{Q}_{\\mathsf{nsPCP}}(1^{\\kappa})</span>  at random. Then, to distinguish between  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}} \\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa}, L, Q)</span>  and  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}} \\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa}, L, Q^{\\prime})</span>  for an independent  <span class="math">Q^{\\prime} \\gets \\mathcal{Q}_{\\mathsf{nsPCP}}(1^{\\kappa})</span> , it feeds the pair  <span class="math">(Q, \\mathsf{hk}_{\\mathsf{meSSB}})</span>  to the distinguisher, and answers according to its response (without needing to use  <span class="math">\\{\\mathsf{td}_{\\mathsf{meSSB}, j}\\}_{Q_j = Q_j&#x27;}</span> ).</li>

    </ul>

    <p class="text-gray-300">It follows from Theorem 4.3 that our instantiation of Kilian's protocol is  <span class="math">2^{\\kappa^{*}}</span> -straight-line sound.</p>

    <p class="text-gray-300">Theorem 5.2. The protocol given in Figure 5 satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For any  <span class="math">x \\in \\mathcal{L}</span>  and  <span class="math">\\epsilon &amp;gt; 0</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\left(\\mathcal {P} _ {\\mathrm {n s K i l i a n}}, \\mathcal {V} _ {\\mathrm {n s K i l i a n}}\\right) (x) = 1 \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: Assuming that the meSSB hash family is  <span class="math">2^{\\kappa^{<em>}}</span> -hiding, the argument  <span class="math">(\\mathcal{P}_{\\mathrm{nsKilian}}^{</em>}, \\mathcal{V}_{\\mathrm{nsKilian}}^{<em>})</span>  for  <span class="math">\\mathcal{L}</span>  is  <span class="math">2^{\\kappa^{</em>}}</span> -straight-line adaptively sound. In particular, for any poly  <span class="math">(\\Omega(n))</span> -size cheating prover  <span class="math">\\mathcal{P}_{\\mathrm{nsKilian}}^{*}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\left(\\mathcal {P} _ {\\mathrm {n s K i l i a n}} ^ {*}, \\mathcal {V} _ {\\mathrm {n s K i l i a n}}\\right) \\left(1 ^ {\\kappa}\\right) = 1 \\right] = \\operatorname {n e g l} (\\Omega (n)).</span></div>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness is straightforward, and <span class="math">2^{\\kappa^{s}}</span>-straight-line soundness follows immediately from Theorem 4.3 and Lemma 5.1. ∎</p>

    <p class="text-gray-300">Recall that the eSSB hash family from Theorem 3.3 is sub-exponentially straight-line hiding assuming the sub-exponential hardness of LWE. Using this particular eSSB hash family in the construction of the meSSB hash family given in Figure 3 and using that the resulting meSSB hash family is <span class="math">2^{\\kappa^{s}}</span>-straight-line reducible from the <span class="math">2^{\\kappa^{s}}</span>-hiding of the underlying eSSB hash family, we obtain a meSSB hash family that is <span class="math">2^{\\kappa^{s}}</span>-straight-line reducible from the sub-exponential hardness of LWE. Combining this with the adaptive computational non-signaling PCPs given in Theorems 2.7 and 2.8, we obtain the following corollaries:</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Corollary 5.3.</h6>

    <p class="text-gray-300">For any <span class="math">\\operatorname{poly}(n)\\leq t\\leq\\exp(n)</span>, assuming the sub-exponential hardness of LWE, there is <span class="math">\\epsilon&gt;0</span> such that Kilian’s protocol <span class="math">(\\mathcal{P}_{\\text{nsKilian}},\\mathcal{V}_{\\text{nsKilian}})</span>, instantiated with the adaptive <span class="math">t</span>-computational non-signaling PCP for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> from Theorem 2.7 and the meSSB hash family from Figure 5 with underlying eSSB hash family given in Theorem 3.3, is <span class="math">2^{\\kappa^{s}}</span>-straight-line (adaptive) sound. In particular, assuming the sub-exponential quantum hardness of LWE, this protocol is (adaptive) post-quantum secure against size-<span class="math">\\operatorname{poly}(t)</span> quantum provers, except with probability negligible in <span class="math">t</span>.</p>

    <p class="text-gray-300">Furthermore, the prover runs in time <span class="math">\\operatorname{poly}(t)</span>, the verifier runs in time <span class="math">n\\cdot\\operatorname{polylog}(t)</span>, and the communication complexity is <span class="math">\\operatorname{polylog}(t)</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It remains to analyze the complexity of the protocol. The complexity claims follow from the following points:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Theorem 2.7, the size of the PCP proof is <span class="math">\\operatorname{poly}(t)</span>, so <span class="math">\\mathcal{P}_{\\text{nsKilian}}</span> can compute the hash and openings in time <span class="math">\\operatorname{poly}(t)</span>.</li>

      <li>The size of a single eSSB hash and opening is <span class="math">\\operatorname{poly}(\\kappa)=\\operatorname{polylog}(t)</span>, and the number of such eSSB hashes and openings is <span class="math">\\ell=\\kappa\\cdot\\operatorname{polylog}(t)=\\operatorname{polylog}(t)</span>, for a total communication complexity of <span class="math">\\operatorname{polylog}(t)</span>.</li>

      <li>The verifier can check that all the answers and openings are consistent with rt in time <span class="math">\\operatorname{polylog}(t)</span>. He also runs <span class="math">\\mathcal{V}_{\\text{nsPCP}}</span>, which takes time <span class="math">n\\cdot\\operatorname{poly}(\\ell)=n\\cdot\\operatorname{polylog}(t)</span>, for a total verifier runtime of <span class="math">n\\cdot\\operatorname{polylog}(t)</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Corollary 5.4.</h6>

    <p class="text-gray-300">For any <span class="math">\\operatorname{poly}(n)\\leq t\\leq\\exp(n)</span> and <span class="math">s=s(n)\\geq\\log t(n)</span>, assuming the sub-exponential hardness of LWE, there is <span class="math">\\epsilon&gt;0</span> such that Kilian’s protocol <span class="math">(\\mathcal{P}_{\\text{nsKilian}},\\mathcal{V}_{\\text{nsKilian}})</span>, instantiated with the adaptive <span class="math">2^{s}</span>-computational non-signaling PCP for <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span> from Theorem 2.8 and the meSSB hash family from Figure 5 with underlying eSSB hash family given in Theorem 3.3, is <span class="math">2^{\\kappa^{s}}</span>-straight-line (adaptively) sound. In particular, assuming the sub-exponential quantum hardness of LWE, this protocol is (adaptive) post-quantum secure against size-<span class="math">\\operatorname{poly}(2^{s})</span> (and thus <span class="math">\\operatorname{poly}(t)</span>) quantum provers, except with probability negligible in <span class="math">2^{s}</span>.</p>

    <p class="text-gray-300">Furthermore, the honest prover runs in time <span class="math">\\operatorname{poly}(t)</span>, the verifier runs in time <span class="math">n\\cdot\\operatorname{poly}(s)</span>, and the communication complexity is <span class="math">\\operatorname{poly}(s)</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">We analyze the complexity claims.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Theorem 2.8, the size of the PCP proof is <span class="math">\\mathrm{poly}(t)</span>, so <span class="math">\\mathcal{P}_{\\mathsf{nsKilian}}</span> can compute the hash and openings in time <span class="math">\\mathrm{poly}(t)</span>.</li>

      <li>The size of a single eSSB hash and opening is <span class="math">\\mathrm{poly}(\\kappa)=\\mathrm{polylog}(2^{s})=\\mathrm{poly}(s)</span>, and the number of such eSSB hashes and openings is <span class="math">\\ell=\\kappa\\cdot\\mathrm{poly}(s)=\\mathrm{poly}(s)</span>, for a total communication complexity of <span class="math">\\mathrm{poly}(s)</span>.</li>

      <li>The verifier can check that all the answers and openings are consistent with rt in time <span class="math">\\mathrm{poly}(s)</span>. He also runs <span class="math">\\mathcal{V}_{\\mathsf{nsPCP}}</span>, which takes time <span class="math">n\\cdot\\mathrm{poly}(\\ell)=n\\cdot\\mathrm{poly}(s)</span>, for a total verifier runtime of <span class="math">n\\cdot\\mathrm{poly}(s)</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-50" class="text-2xl font-bold">6 SNARG for Languages with Non-Signaling PCPs</h2>

    <p class="text-gray-300">In this section, we construct SNARGs for languages with a (computational) non-signaling PCP, assuming the existence of a SNARG for BatchNP. This includes <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> for every <span class="math">\\mathrm{poly}(n)\\leq t\\leq\\exp(n)</span>, and <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span> for <span class="math">\\mathrm{poly}(n)\\leq t\\leq\\exp(n)</span> and <span class="math">s=s(n)\\geq\\log t(n)</span>.</p>

    <p class="text-gray-300">We begin by defining BatchNP and SNARGs for BatchNP.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">6.1 BatchNP</h3>

    <p class="text-gray-300">For an NP relation R with corresponding language L, define</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{R}^{\\otimes N}=\\{((x_{1},\\ldots,x_{N}),(w_{1},\\ldots,w_{N}))\\ :\\ (x_{i},w_{i})\\in\\mathsf{R}\\ \\forall i\\in[N]\\ \\land\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\cdots=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{L}^{\\otimes N}=\\{(x_{1},\\ldots,x_{N})\\ :\\ x_{i}\\in\\mathsf{L}\\ \\forall i\\in[N]\\ \\land\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\cdots=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The class BatchNP consists of languages <span class="math">\\mathsf{L}^{\\otimes N}</span> for <span class="math">\\mathsf{L}\\in\\mathsf{NP}</span>.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">6.1.1 SNARGs for BatchNP</h4>

    <p class="text-gray-300">Our SNARG for <span class="math">\\mathcal{L}</span> relies on the existence of a SNARG for BatchNP, which we define below. We will be interested in the case where <span class="math">N</span> is much larger than <span class="math">m</span>, the size of a single instance <span class="math">x_{i}</span>. We will consider two definitions. First, we consider a definition where the verifier is super-efficient (runs in time <span class="math">\\mathrm{poly}(m,\\log N)</span>). Note that the size of a BatchNP instance is already <span class="math">N\\cdot m</span>, so in this case we will consider only BatchNP instances that have succinct descriptions. Second, we will consider a definition where the verifier is efficient (but not necessarily super-efficient), i.e. runs in time <span class="math">\\mathrm{poly}(m,N)</span>, but the communication is succinct (size <span class="math">\\mathrm{poly}(m,\\log N)</span>). In this setting, the verifier reads the full instance.</p>

    <p class="text-gray-300">To define SNARGs for BatchNP where the verifier is super-efficient, we first have to define succinct descriptions.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 6.1.</h6>

    <p class="text-gray-300">(Succinct Description of a Tuple) A tuple <span class="math">S\\in(\\{0,1\\}^{m})^{N}</span> of size <span class="math">N</span> has a <em>succinct description</em> if there exists a short string <span class="math">\\langle S\\rangle\\in\\{0,1\\}^{\\mathrm{poly}(m,\\log N)}</span> and a uniform <em>PPT</em> Turing machine <span class="math">B</span> that on input <span class="math">\\langle S\\rangle</span> and <span class="math">i\\in[N]</span>, outputs the <span class="math">i</span>’th element of <span class="math">S</span>.</p>

    <p class="text-gray-300">For notation, we let <span class="math">B(\\langle S\\rangle)</span> denote the set <span class="math">S</span>, i.e. <span class="math">B(\\langle S\\rangle)=\\{B(\\langle S\\rangle,i)\\}_{i\\in[N]}</span>.</p>

    <p class="text-gray-300">We next define SNARGs for BatchNP, both where the verifier reads the full BatchNP instance and where the instances have succinct descriptions.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 6.2.</h6>

    <p class="text-gray-300">(SNARG for <em>BatchNP</em> (with Succinct Instances)) A <em>SNARG for a language <span class="math">\\mathsf{L}^{\\otimes N}\\in\\mathrm{BatchNP}</span> with corresponding relation <span class="math">\\mathsf{R}^{\\otimes N}</span> (where the instance has a succinct description) is a tuple of </em>PPT* algorithms <span class="math">(\\mathsf{Setup}_{\\mathsf{L}^{\\otimes N}},\\mathcal{P}_{\\mathsf{L}^{\\otimes N}},\\mathcal{V}_{\\mathsf{L}^{\\otimes N}})</span> with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}_{\\mathsf{L}^{\\otimes N}}(1^{\\lambda},1^{m},N)</span> takes as input a security parameter <span class="math">\\lambda</span> and <span class="math">\\mathsf{NP}</span> instance size <span class="math">m</span> in unary, as well as a batch size <span class="math">N</span> (in binary), and outputs a common reference string <span class="math">\\mathsf{crs}</span>.</li>

      <li><span class="math">\\mathcal{P}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},X,W)</span> takes as input a <span class="math">\\mathsf{crs}\\in\\{0,1\\}^{\\mathrm{poly}(\\lambda,m,\\log N)}</span>, an instance <span class="math">X=(x_{1},\\ldots,x_{N})\\in\\{0,1\\}^{N\\times m}</span>, and a witness <span class="math">W=(w_{1},\\ldots,w_{N})</span>, and outputs a short proof <span class="math">\\sigma\\in\\{0,1\\}^{\\ell_{\\mathsf{L}^{\\otimes N}}}</span>, where <span class="math">\\ell_{\\mathsf{L}^{\\otimes N}}=\\mathrm{poly}(\\lambda,m,\\log N)</span>.</li>

      <li><span class="math">\\mathcal{V}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},X,\\sigma)</span> (resp. <span class="math">\\mathcal{V}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},\\langle X\\rangle,\\sigma)</span>) takes as input the <span class="math">\\mathsf{crs}\\in\\{0,1\\}^{\\mathrm{poly}(\\lambda,m,\\log N)}</span>, <span class="math">X=(x_{1},\\ldots,x_{N})\\in\\{0,1\\}^{N\\times m}</span> (resp. a short description <span class="math">\\langle X\\rangle\\in\\{0,1\\}^{\\mathrm{poly}(\\lambda,m,\\log N)}</span> of the instance <span class="math">X</span>), and <span class="math">\\sigma\\in\\{0,1\\}^{\\ell_{\\mathsf{L}^{\\otimes N}}}</span>, and outputs <span class="math">1</span> or <span class="math">0</span> indicating accept or reject.</li>

    </ul>

    <p class="text-gray-300">These algorithms should satisfy the following completeness property:</p>

    <p class="text-gray-300">If <span class="math">(X,W)\\in\\mathsf{R}^{\\otimes N}</span>, then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathcal{V}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},X,\\sigma)=1\\ \\text{(resp. }\\mathcal{V}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},\\langle X\\rangle,\\sigma)=1)\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\genfrac{}{}{0.0pt}{\\mathsf{crs}\\leftarrow\\mathsf{Setup}_{\\mathsf{L}^{\\otimes N}}(1^{\\lambda},1^{m},N)}{\\sigma\\leftarrow\\mathcal{P}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},X,W)}\\right]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 6.3 (<span class="math">\\Sigma</span>-Soundness).</h6>

    <p class="text-gray-300">A SNARG <span class="math">(\\mathsf{Setup}_{\\mathsf{L}^{\\otimes N}},\\mathcal{P}_{\\mathsf{L}^{\\otimes N}},\\mathcal{V}_{\\mathsf{L}^{\\otimes N}})</span> for <span class="math">\\mathsf{L}^{\\otimes N}\\in\\mathrm{BatchNP}</span> is said to be <span class="math">\\Sigma</span>-sound if for every cheating prover <span class="math">\\mathcal{P}_{\\mathsf{L}^{\\otimes N}}^{*}</span> running in time <span class="math">\\mathrm{poly}(\\Sigma(\\lambda,m,N))</span>, there exists a negligible function <span class="math">\\mu</span> such that for any <span class="math">\\lambda,m,N</span> and <span class="math">X\\notin\\mathsf{L}^{\\otimes N}</span> where each instance is of size <span class="math">m</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathcal{V}_{\\mathsf{L}^{\\otimes N}}(\\mathsf{crs},X,\\sigma)=1\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\genfrac{}{}{0.0pt}{\\mathsf{crs}\\leftarrow\\mathsf{Setup}_{\\mathsf{L}^{\\otimes N}}(1^{\\lambda},1^{m},N)}{\\sigma\\leftarrow\\mathcal{P}_{\\mathsf{L}^{\\otimes N}}^{*}(\\mathsf{crs})}\\right]=\\mathrm{negl}(\\Sigma(\\lambda,m,N)).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 6.4 (<em>[CJJ21]</em>).</h6>

    <p class="text-gray-300">Assuming the sub-exponential hardness of <span class="math">\\mathsf{LWE}</span>, there is some <span class="math">\\epsilon&gt;0</span> for which there exist <span class="math">2^{\\lambda^{*}}</span>-sound SNARGs for languages in <span class="math">\\mathrm{BatchNP}</span> with succinct instances.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">6.2 SNARG for Languages with a Non-Signaling <span class="math">\\mathsf{PCP}</span></h3>

    <p class="text-gray-300">Suppose we have an adaptive <span class="math">\\Omega</span>-computational non-signaling <span class="math">\\mathsf{PCP}</span> (<span class="math">\\Pi,\\mathcal{Q}_{\\mathsf{nsPCP}},\\mathcal{V}_{\\mathsf{nsPCP}}</span>) that is verifiable via tests (Definition 2.5) for a language <span class="math">\\mathcal{L}</span>. Let <span class="math">L</span> be the size of the <span class="math">\\mathsf{PCP}</span> and <span class="math">\\ell</span> be the locality. Let <span class="math">N</span> be the number of possible tests <span class="math">\\zeta</span> (see Theorem 2.7), and let <span class="math">\\tau</span> be the size of each test (where</p>

    <p class="text-gray-300">we pad tests that are not long enough), so that each test <span class="math">\\zeta</span> can be written as <span class="math">(\\zeta_{1},\\ldots,\\zeta_{\\tau})</span> with <span class="math">\\zeta_{i}\\in[L]</span>. Let <span class="math">\\mathcal{U}_{\\mathsf{nsPCP}}</span> be the Turing machine that checks each test, as in Definition 2.5.</p>

    <p class="text-gray-300">At a high level, our SNARG for <span class="math">\\mathcal{L}</span> works as follows: The honest prover first runs the BMW protocol on an adaptive computational non-signaling PCP with a meSSB hash function to produce a short commitment rt to the entire PCP. She then provides a short proof via the BatchNP SNARG that <em>all</em> possible verifier tests have accepting answers and openings. This final task is precisely a BatchNP statement: the claim that a given verifier test has accepting answers and openings is an NP statement, with witness the answers and openings; now the claim that <em>all possible</em> verifier tests have accepting answers and openings is a BatchNP statement.</p>

    <p class="text-gray-300">We define the BatchNP language we will be concerned with, as well as the succinct description of the instances. Fix an meSSB hash family</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{Gen}_{\\mathsf{meSSB}},\\mathsf{Hash}_{\\mathsf{meSSB}},\\mathsf{Open}_{\\mathsf{meSSB}},\\mathsf{Verify}_{\\mathsf{meSSB}},\\mathsf{Invert}_{\\mathsf{meSSB}})</span></p>

    <p class="text-gray-300">(see Construction 3).</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be the NP relation where <span class="math">(y,w)\\in\\mathcal{R}</span> if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">y=(\\zeta,x,\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{rt})\\in[L]^{\\tau}\\times\\{0,1\\}^{n}\\times\\{0,1\\}^{\\ell_{\\mathsf{meSSB},\\mathsf{hk}}}\\times\\{0,1\\}^{\\ell_{\\mathsf{meSSB},\\mathsf{hash}}}</span>;</li>

      <li><span class="math">w=((u_{1},\\ldots,u_{\\tau}),(\\mathsf{o}_{1},\\ldots,\\mathsf{o}_{\\tau}))\\in\\{0,1\\}^{\\tau}\\times\\{0,1\\}^{\\tau\\cdot\\ell_{\\mathsf{meSSB},\\mathsf{o}}}</span>;</li>

      <li><span class="math">\\mathcal{U}_{\\mathsf{nsPCP}}(x,\\zeta,(u_{1},\\ldots,u_{\\tau}))=1</span>; and</li>

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{meSSB}}(\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{rt},\\zeta_{i},u_{i},\\mathsf{o}_{\\mathsf{meSSB},i})=1\\ \\forall i\\in[\\tau]</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathcal{M}</span> be the corresponding language. Notice that the size of an instance is</p>

    <p class="text-gray-300"><span class="math">m=\\tau\\cdot\\log L+n+\\ell_{\\mathsf{meSSB},\\mathsf{hk}}+\\ell_{\\mathsf{meSSB},\\mathsf{hash}}.</span> (2)</p>

    <p class="text-gray-300">We are interested in the BatchNP language <span class="math">\\mathcal{M}^{\\otimes N}</span>.</p>

    <p class="text-gray-300">Let <span class="math">B</span> be a poly-time Turing machine that takes as input <span class="math">\\langle Y\\rangle</span>, which is a succinct description of an element in <span class="math">\\mathcal{M}^{\\otimes N}</span>, and an index <span class="math">j\\in[N]</span>, and outputs the <span class="math">j</span>’th NP statement defined by <span class="math">\\langle Y\\rangle</span>. More specifically, <span class="math">\\langle Y\\rangle=(x,\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{rt})</span>, and <span class="math">B(\\langle Y\\rangle,j)=(\\zeta_{j},\\langle Y\\rangle)</span>, where <span class="math">\\zeta_{j}</span> is the <span class="math">j</span>’th possible test (enumerating them in some order). We let <span class="math">Y</span> denote the <span class="math">\\mathcal{M}^{\\otimes N}</span> instance corresponding to <span class="math">\\langle Y\\rangle</span>.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">6.2.1 SNARGs for <span class="math">\\mathcal{L}</span> from SNARGs for BatchNP with Succinct Instances</h4>

    <p class="text-gray-300">We first construct SNARGs for <span class="math">\\mathcal{L}</span> from SNARGs for BatchNP, assuming that the BatchNP SNARG verifier is super-efficient when the BatchNP instance admits a succinct description. This is indeed the case: our BatchNP instance is determined by the output of the hash on the PCP and thus can be described succinctly.</p>

    <p class="text-gray-300">In what follows, let <span class="math">(\\mathsf{Setup}_{\\mathcal{M}^{\\otimes N}},\\mathcal{P}_{\\mathcal{M}^{\\otimes N}},\\mathcal{V}_{\\mathcal{M}^{\\otimes N}})</span> be a SNARG for <span class="math">\\mathcal{M}^{\\otimes N}</span> with succinct instances, as in Definition 6.2.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 6.5.</h6>

    <p class="text-gray-300">The algorithms <span class="math">(\\mathsf{Setup}_{\\mathcal{L}},\\mathcal{P}_{\\mathcal{L}},\\mathcal{V}_{\\mathcal{L}})</span> defined in Figure 6 satisfy the following properties:</p>

    <p class="text-gray-300">For  <span class="math">\\epsilon &amp;gt; 0</span>  and  <span class="math">\\Omega(\\cdot)</span> , define  <span class="math">\\kappa = (\\log \\Omega)^{1/\\epsilon}</span>  and let  <span class="math">\\lambda</span>  be such that  <span class="math">\\Sigma(\\lambda, m, N) = 2^{\\ell_{\\mathrm{meSSB,hash}}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}_{\\mathcal{L}}(1^{\\kappa}, 1^{\\lambda})</span>  takes as input  <span class="math">\\kappa</span>  and  <span class="math">\\lambda</span>  in unary. It samples</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">Q = \\left(q _ {1}, \\dots , q _ {\\ell}\\right) \\leftarrow \\mathcal {Q} _ {\\mathrm {n s P C P}} \\left(1 ^ {\\kappa}\\right), \\text {a n d} \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\mathrm {t d} _ {\\mathrm {m e S S B}}\\right) \\leftarrow \\operatorname {G e n} _ {\\mathrm {m e S S B}} \\left(1 ^ {\\kappa}, L, Q\\right).</span></div>

    <p class="text-gray-300">It also samples</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {M} ^ {\\otimes N}} \\left(1 ^ {\\lambda}, 1 ^ {m}, N\\right),</span></div>

    <p class="text-gray-300">and outputs  <span class="math">\\mathrm{crs} = (\\mathrm{hk}_{\\mathrm{meSSB}},\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{\\mathcal{L}}</span>  takes as input the  <span class="math">\\mathrm{crs} = (\\mathrm{hk}_{\\mathrm{meSSB}}, \\mathrm{crs}_{\\mathcal{M}^{\\otimes N}})</span>  and an instance  <span class="math">x</span> . It computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi \\leftarrow \\Pi (x) \\text {a n d} \\mathrm {r t} = \\operatorname {H a s h} _ {\\mathrm {m e S S B}} \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\pi\\right).</span></div>

    <p class="text-gray-300">It then computes  <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}} \\gets \\mathcal{P}_{\\mathcal{M}^{\\otimes N}}(\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}}, Y, W)</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">Y = \\left\\{\\left(\\zeta_ {j}, x, \\mathrm {h k} _ {\\mathrm {m e S S B}}, \\mathrm {r t}\\right) \\right\\} _ {j \\in [ N ]}</span></div>

    <p class="text-gray-300">(i.e.  <span class="math">\\langle Y\\rangle = (x,\\mathsf{hk}_{\\mathrm{meSSB}},\\mathsf{rt}))</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">W = \\left\\{\\left(\\left(\\pi_ {\\zeta_ {j, 1}}, \\dots , \\pi_ {\\zeta_ {j, \\tau}}\\right), \\left(\\mathrm {o} _ {\\zeta_ {j, 1}}, \\dots , \\mathrm {o} _ {\\zeta_ {j, \\tau}}\\right)\\right) \\right\\} _ {j \\in [ N ]},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{o}_q = \\mathsf{Open}_{\\mathsf{meSSB}}(\\mathsf{hk}_{\\mathsf{meSSB}},\\pi ,q)</span> . It outputs  <span class="math">\\sigma = (\\mathsf{rt},\\sigma_{\\mathcal{M}^{\\otimes N}})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}_{\\mathcal{L}}</span>  takes as input  <span class="math">\\mathrm{crs} = (\\mathrm{hk}_{\\mathrm{meSSB}}, \\mathrm{crs}_{\\mathcal{M}^{\\otimes N}})</span> , instance  <span class="math">x</span> , and  <span class="math">\\sigma = (\\mathrm{rt}, \\sigma_{\\mathcal{M}^{\\otimes N}})</span> . It runs and outputs the result of  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}(\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}}, \\langle Y \\rangle, \\sigma_{\\mathcal{M}^{\\otimes N}})</span> , where  <span class="math">\\langle Y \\rangle = (x, \\mathrm{hk}_{\\mathrm{meSSB}}, \\mathrm{rt})</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 6: SNARG  <span class="math">(\\mathsf{Setup}_{\\mathcal{L}},\\mathcal{P}_{\\mathcal{L}},\\mathcal{V}_{\\mathcal{L}})(x)</span>  for  <span class="math">\\mathcal{L}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For every  <span class="math">x \\in \\mathcal{L}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\sigma \\leftarrow \\mathcal {P} _ {\\mathcal {L}} (\\operatorname {c r s}, x) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: Assuming that</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the meSSB hash family is  <span class="math">2^{n^{\\epsilon}}</span> -hiding,</li>

      <li>the PCP is adaptive  <span class="math">n \\leq \\Omega = \\Omega(n)</span> -computational non-signaling and is verified via tests, and that there are  <span class="math">N \\leq \\mathrm{poly}(\\Omega)</span>  possible tests,</li>

      <li>the BatchNP SNARG is  <span class="math">\\Sigma</span> -sound, such that  <span class="math">\\lambda</span>  (defined in Figure 6) is  <span class="math">\\leq \\Omega</span> ,</li>

    </ul>

    <p class="text-gray-300">then for any  <span class="math">\\mathrm{poly}(\\Omega)</span> -size  <span class="math">\\mathcal{P}^*</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ x, \\sigma \\leftarrow \\mathcal {P} _ {\\mathcal {L}} (\\operatorname {c r s}) \\end{array} \\right. \\right] = \\operatorname {n e g l} (\\Omega).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Correctness is straightforward. We now focus on proving soundness.</p>

    <p class="text-gray-300">Suppose for the sake of contradiction that there is a poly  <span class="math">(\\Omega)</span> -size prover  <span class="math">\\mathcal{P}^*</span>  for which there is non-negligible  <span class="math">\\delta</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ x, \\sigma \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right. \\right] = \\delta (\\Omega).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This is equal to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta (\\Omega) = \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} &amp;amp; \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\wedge \\mathcal {V} _ {\\operatorname {n s P C P}} (x, Q, \\operatorname {I n v e r t} _ {\\operatorname {m e S S B}} (\\operatorname {t d} _ {\\operatorname {m e S S B}}, \\operatorname {r t})) = 1 &amp;amp; x, \\sigma = (\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right] \\\\ + \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} &amp;amp; \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\wedge \\mathcal {V} _ {\\operatorname {n s P C P}} (x, Q, \\operatorname {I n v e r t} _ {\\operatorname {m e S S B}} (\\operatorname {t d} _ {\\operatorname {m e S S B}}, \\operatorname {r t})) = 0 &amp;amp; x, \\sigma = (\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right] \\\\ \\leq \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathsf {n s P C P}} (x, Q, \\mathsf {I n v e r t} _ {\\mathsf {m e S S B}} (\\mathsf {t d} _ {\\mathsf {m e S S B}}, \\mathsf {r t})) = 1 &amp;amp; \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\wedge x \\notin \\mathcal {L} &amp;amp; x, \\sigma = (\\mathsf {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {c r s}) \\end{array} \\right] \\\\ + \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} &amp;amp; \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\wedge \\mathcal {V} _ {\\operatorname {n s P C P}} (x, Q, \\operatorname {I n v e r t} _ {\\operatorname {m e S S B}} (\\operatorname {t d} _ {\\operatorname {m e S S B}}, \\operatorname {r t})) = 0 &amp;amp; x, \\sigma = (\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right]. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By Theorem 3.6 and the fact that a  <span class="math">2^{\\kappa^{\\ell}} = 2^{((\\log \\Omega)^{1 / \\epsilon})^{\\ell}}</span> -hiding meSSB hash family is  <span class="math">\\Omega(n)</span> -hiding, the first term above is  <span class="math">\\mathrm{negl}(\\Omega)</span> . In the above and what follows,  <span class="math">Q</span>  denotes the  <span class="math">\\ell</span>  locations the meSSB hash family are binding on (used to generate  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}</span> ), and  <span class="math">\\mathsf{td}_{\\mathsf{meSSB}}</span>  is the trapdoor generated alongside  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}</span> .</p>

    <p class="text-gray-300">Therefore, the above implies that there exists  <span class="math">\\delta&#x27;(\\Omega) = \\delta(\\Omega) - \\mathrm{negl}(\\Omega)</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\delta^ {\\prime} (\\Omega) \\leq \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} &amp;amp; \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\wedge \\mathcal {V} _ {\\operatorname {n s P C P}} (x, Q, \\operatorname {I n v e r t} _ {\\operatorname {m e S S B}} (\\operatorname {t d} _ {\\operatorname {m e S S B}}, \\operatorname {r t})) = 0 &amp;amp; x, \\sigma = (\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right] \\\\ = \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} (\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) = 1 &amp;amp; \\operatorname {c r s} = (\\operatorname {h k} _ {\\operatorname {m e S S B}}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\wedge Y \\notin \\mathcal {M} ^ {\\otimes N} &amp;amp; x, \\sigma = (\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right], \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\langle Y\\rangle</span>  denotes  <span class="math">(x,\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{rt})</span> , and the equality follows from the facts that  <span class="math">\\nu_{\\mathcal{L}}</span>  simply runs  <span class="math">\\nu_{\\mathcal{M}^{\\otimes N}}</span> , and that  <span class="math">\\nu_{\\mathsf{nsPCP}}(x,Q,\\mathsf{Invert}_{\\mathsf{meSSB}}(\\mathsf{td}_{\\mathsf{meSSB}},\\mathsf{rt})) = 0</span>  implies that  <span class="math">Y\\notin \\mathcal{M}^{\\otimes N}</span> , since there is at least one test  <span class="math">\\zeta \\subseteq Q</span>  for which  $\\mathcal{U}_{\\mathsf{nsPCP}}(\\zeta ,\\mathsf{Invert}_{\\mathsf{meSSB}}(\\mathsf{td}_{\\mathsf{meSSB}},\\mathsf{rt})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\zeta}) = 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We will use  <span class="math">\\mathcal{P}^<em></span>  to break the  <span class="math">\\Sigma</span> -security of the  <span class="math">\\mathcal{M}^{\\otimes N}</span>  SNARG as follows. By an averaging argument, there is some  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}^</em></span>  for which  <span class="math">\\mathcal{P}^<em>(\\mathsf{crs})</span>  outputs  <span class="math">(x, \\mathsf{rt}, \\sigma_{\\mathcal{M}^{\\otimes N}})</span>  with  <span class="math">x \\notin \\mathcal{L}</span> ,  <span class="math">Y \\notin \\mathcal{M}^{\\otimes N}</span> , and  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}(\\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}\\langle Y\\rangle, \\sigma_{\\mathcal{M}^{\\otimes N}}) = 1</span>  with probability  <span class="math">\\geq \\delta&#x27;(\\Omega)</span>  conditioned on  <span class="math">\\mathsf{crs} = (\\mathsf{hk}_{\\mathsf{meSSB}}^</em>, \\mathsf{crs}_{\\mathcal{M}^{\\otimes N}})</span>  for some  <span class="math">\\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}</span> . Furthermore, there is some  <span class="math">x^<em></span>  and  <span class="math">\\mathsf{rt}^</em></span>  for which, with probability  <span class="math">\\geq \\frac{\\delta&#x27;(\\Omega)}{2^{n + \\ell_{\\mathsf{meSSB},\\mathsf{hash}}}}</span> , this occurs and the  <span class="math">x</span>  and  <span class="math">\\mathsf{rt}</span>  output by  <span class="math">\\mathcal{P}^<em></span>  are equal to  <span class="math">x^</em></span>  and  <span class="math">\\mathsf{rt}^<em></span> . In particular, for  <span class="math">Y^\\sharp</span>  defined by  <span class="math">\\langle Y^</em>\\rangle = (x^<em>, \\mathsf{hk}_{\\mathsf{meSSB}}^</em>, \\mathsf{rt}^<em>)</span> , we have that  <span class="math">Y^</em> \\notin \\mathcal{M}^{\\otimes N}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} (\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y ^ {*} \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) = 1 &amp;amp; \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {M} ^ {\\otimes N}} (1 ^ {\\lambda}, 1 ^ {m}, N) \\\\ \\wedge (x, \\operatorname {r t}) = (x ^ {*}, \\operatorname {r t} ^ {*}) &amp;amp; \\begin{array}{c} \\operatorname {c r s} := (\\operatorname {h k} _ {\\operatorname {m e S S B}} ^ {*}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}) \\\\ x, \\sigma = (\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\end{array} \\right] \\\\ \\geq \\frac {\\delta^ {\\prime} (\\Omega)}{2 ^ {n + \\ell_ {\\mathrm {m e S S B , h a s h}}}} \\geq \\delta^ {\\prime \\prime} (\\Sigma (\\lambda , m, N)), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\delta^{\\prime\\prime}</span> is a non-negligible function; such <span class="math">\\delta^{\\prime\\prime}</span> exists since we assumed that</p>

    <p class="text-gray-300"><span class="math">\\Sigma(\\lambda,m,N)\\geq 2^{\\ell_{\\mathsf{meSSB},\\mathsf{hash}}}\\geq 2^{\\mathrm{poly}(\\kappa)}=2^{\\mathrm{polylog}(\\Omega)}\\geq\\Omega\\geq n.</span></p>

    <p class="text-gray-300">We next construct a cheating prover <span class="math">\\mathcal{P}^{<strong>}</span> for the <span class="math">\\mathcal{M}^{\\otimes N}</span> SNARG that breaks the <span class="math">\\Sigma</span>-soundness condition w.r.t. <span class="math">Y^{<em>}\\not\\in\\mathcal{M}^{\\otimes N}</span>, as follows. The cheating prover <span class="math">\\mathcal{P}^{</strong>}</span> takes as input <span class="math">\\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}\\leftarrow\\mathrm{Setup}_{\\mathcal{M}^{\\otimes N}}(1^{\\kappa},1^{m},N)</span>, runs <span class="math">\\mathcal{P}^{</em>}</span> on inputs <span class="math">\\mathsf{crs}=(\\mathsf{hk}_{\\mathsf{meSSB}}^{<em>},\\mathsf{crs}_{\\mathcal{M}^{\\otimes N}})</span>, to get <span class="math">x</span> and <span class="math">(\\mathsf{rt},\\sigma_{\\mathcal{M}^{\\otimes N}})</span>. When the Merkle root <span class="math">\\mathsf{rt}</span> that <span class="math">\\mathcal{P}^{</em>}</span> output is equal to <span class="math">\\mathsf{rt}^{<em>}</span> and <span class="math">x</span> is equal to <span class="math">x^{</em>}</span>, he outputs <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}}</span>, which fools <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span> with probability non-negligible in <span class="math">\\Sigma(\\lambda,m,n)</span>. Furthermore, <span class="math">\\mathcal{P}^{**}</span> runs in time <span class="math">\\mathrm{poly}(\\Omega)\\geq\\mathrm{poly}(\\lambda,m,N)</span>, since <span class="math">N\\leq\\mathrm{poly}(\\Omega)</span> and <span class="math">\\lambda\\leq\\Omega</span> by assumption. This contradicts the <span class="math">\\Sigma</span>-security of the <span class="math">\\mathcal{M}^{\\otimes N}</span> SNARG. ∎</p>

    <p class="text-gray-300">Piecing together the following ingredients:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a <span class="math">2^{\\kappa^{*}}</span>-hiding <span class="math">\\mathsf{meSSB}</span> hash family, which exists for some <span class="math">\\epsilon&gt;0</span> assuming sub-exponential LWE (by Theorem 3.3 and Theorem 3.5),</li>

      <li>the adaptive <span class="math">t</span>- or <span class="math">2^{s}</span>-computational non-signaling PCPs with <span class="math">N=\\mathrm{poly}(t)</span> tests for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> and <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span> given in Theorems 2.7 and 2.8, respectively,</li>

      <li>the <span class="math">2^{\\lambda^{<em>}}</span>-secure SNARG for <span class="math">\\mathcal{M}^{\\otimes N}</span> given in Theorem 2.8 which exists for some <span class="math">\\epsilon&gt;0</span> assuming sub-exponential LWE, which means we may take <span class="math">\\lambda=(\\ell_{\\mathsf{meSSB},\\mathsf{hash}})^{1/\\epsilon}</span> (which equals <span class="math">\\mathrm{polylog}(t)</span> and <span class="math">\\mathrm{poly}(s)</span> in the case of <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> and <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span>) to satisfy <span class="math">\\Sigma(\\lambda,m,N)=2^{\\lambda^{</em>}}=2^{\\ell_{\\mathsf{meSSB},\\mathsf{hash}}}</span>,</li>

    </ul>

    <p class="text-gray-300">and taking <span class="math">\\epsilon&gt;0</span> to be such that a <span class="math">2^{\\kappa^{<em>}}</span>-hiding <span class="math">\\mathsf{meSSB}</span> hash family and a <span class="math">2^{\\lambda^{</em>}}</span>-secure SNARG for <span class="math">\\mathcal{M}^{\\otimes N}</span> simultaneously exist assuming sub-exponential LWE, we have the following corollaries:</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Corollary 6.6.</h6>

    <p class="text-gray-300">Let <span class="math">t=t(n)</span> be such that <span class="math">\\mathrm{poly}(n)\\leq t(n)\\leq\\exp(n)</span>. Then, assuming sub-exponential LWE, there is a non-interactive argument for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> that is adaptively sound except with probability <span class="math">\\mathrm{negl}(t)</span> against <span class="math">\\mathrm{poly}(t)</span>-size cheating provers, where the honest prover runs in time <span class="math">\\mathrm{poly}(t)</span>, the verifier runs in time <span class="math">\\mathrm{poly}(n,\\log t)</span>, and the communication complexity is <span class="math">\\mathrm{poly}(n,\\log t)</span>.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The SNARG for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> is precisely that given in Figure 6 with the adaptive <span class="math">t</span>-computational non-signaling PCP for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> such that <span class="math">N=\\mathrm{poly}(t)</span>, which exists by Theorem 2.7, and setting <span class="math">\\epsilon&gt;0</span> such that a <span class="math">2^{\\kappa^{<em>}}</span>-hiding SSB hash family and a <span class="math">2^{\\kappa^{</em>}}</span>-secure <span class="math">\\mathcal{M}^{\\otimes N}</span> SNARG exist assuming sub-exponential LWE. In this protocol, note that the prover first hashes the PCP, which takes time <span class="math">\\mathrm{poly}(t)</span> (Theorem 2.7), and then emulates the prover from the <span class="math">\\mathcal{M}^{\\otimes N}</span> SNARG, which definitionally runs in time <span class="math">\\mathrm{poly}(\\lambda,m,N)=\\mathrm{poly}(t)</span> (Definition 6.2). Note that <span class="math">m=\\tau\\cdot\\log L+n+\\ell_{\\mathsf{meSSB},\\mathsf{hk}}+\\ell_{\\mathsf{meSSB},\\mathsf{hash}}=\\mathrm{poly}(n,\\kappa,\\log L)=\\mathrm{poly}(n,\\log t)</span>. The proof string <span class="math">\\sigma</span> thus satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rt}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{\\mathcal{M}^{\\otimes N}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\kappa)+\\mathrm{poly}(\\lambda,m,\\log N)=\\mathrm{poly}(n,\\log t)<span class="math">. The verifier simply emulates </span>\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}<span class="math">, which runs in time </span>\\mathrm{poly}(\\lambda,m,\\log N)=\\mathrm{poly}(n,\\log t)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-63" class="text-base font-medium mt-4">Corollary 6.7.</h6>

    <p class="text-gray-300">Let <span class="math">t=t(n)</span> be such that <span class="math">\\mathrm{poly}(n)\\leq t(n)\\leq\\exp(n)</span> and let <span class="math">s=s(n)\\geq\\log t(n)</span>. Assuming sub-exponential LWE, there is a non-interactive argument for <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span> that is adaptively sound except with probability <span class="math">\\mathrm{negl}(2^{s})</span> against <span class="math">\\mathrm{poly}(2^{s})</span>-size cheating provers, where the honest prover runs in time <span class="math">\\mathrm{poly}(t)</span>, the verifier runs in time <span class="math">\\mathrm{poly}(n,s)</span>, and the communication complexity is <span class="math">\\mathrm{poly}(n,s)</span>.</p>

    <p class="text-gray-300">roof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The SNARG for <span class="math">\\mathsf{NTISP}(t,s)</span> is that given in Figure 6, instantiated with an adaptive <span class="math">2^{s}</span>-computational non-signaling PCP for <span class="math">\\mathsf{NTISP}(t,s)</span> with <span class="math">N=\\mathrm{poly}(t)</span> as given in Theorem 2.8, and <span class="math">\\epsilon&gt;0</span> such that a <span class="math">2^{\\kappa^{e}}</span>-hiding SSB hash family a <span class="math">2^{\\kappa^{e}}</span>-secure <span class="math">\\mathcal{M}^{\\otimes N}</span> SNARG exist assuming sub-exponential <span class="math">\\mathsf{LWE}</span>. We analyze the runtimes. First, the prover runs in time <span class="math">\\mathrm{poly}(t)</span>, since the PCP generated is of size <span class="math">\\mathrm{poly}(t)</span>, and the SNARG for <span class="math">\\mathcal{M}^{\\otimes N}</span> can also be generated in time <span class="math">\\mathrm{poly}(t)</span>. Since <span class="math">m=\\tau\\cdot\\log L+n+\\ell_{\\mathsf{meSSB},\\mathsf{hk}}+\\ell_{\\mathsf{meSSB},\\mathsf{hash}})=\\mathrm{poly}(n,\\kappa,\\log L)=\\mathrm{poly}(n,s,\\log t)=\\mathrm{poly}(n,s)</span>, the proof string <span class="math">\\sigma</span> satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rt}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{\\mathcal{M}^{\\otimes N}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\kappa)+\\mathrm{poly}(\\lambda,m,\\log N)=\\mathrm{poly}(n,s,\\log t)=\\mathrm{poly}(n,s)<span class="math">. Finally, the verifier emulates </span>\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}<span class="math">, which runs in time </span>\\mathrm{poly}(\\lambda,m,\\log N)=\\mathrm{poly}(n,s,\\log t)=\\mathrm{poly}(n,s)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">6.2.2 SNARGs for <span class="math">\\mathcal{L}</span> from SNARGs for <span class="math">\\mathsf{BatchNP}</span> with Low Depth Verifier</h4>

    <p class="text-gray-300">In this section, we show that the assumption that the <span class="math">\\mathsf{BatchNP}</span> SNARG verifier is super-efficient and takes as input succinct descriptions of <span class="math">\\mathsf{BatchNP}</span> instances is not needed: in the case where the <span class="math">\\mathsf{BatchNP}</span> SNARG verifier takes as input the full instance <span class="math">Y</span> and runs in time polynomial in <span class="math">N</span>, we can simply <em>delegate</em> these verifier checks back to the prover assuming that the checks are computable by a low depth circuit.</p>

    <p class="text-gray-300">For this delegation of the verifier checks, we will use the SNARG for bounded depth computations constructed by <em>[JKKZ21]</em>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Theorem 6.8 (<em>[JKKZ21]</em>).</h6>

    <p class="text-gray-300">(SNARG for Size-<span class="math">S</span>, Depth-<span class="math">D</span> Circuits) Assuming the sub-exponential hardness of <span class="math">\\mathsf{LWE}</span>, there is some <span class="math">\\epsilon&gt;0</span> such that for any log-space uniform circuit <span class="math">C</span> of size <span class="math">S</span> and depth <span class="math">D</span>, there are <span class="math">\\mathsf{PPT}</span> algorithms <span class="math">(\\mathsf{Setup}_{\\mathsf{JKKZ}},\\mathcal{P}_{\\mathsf{JKKZ}},\\mathcal{V}_{\\mathsf{JKKZ}})</span> with syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}_{\\mathsf{JKKZ}}(1^{\\eta},S,1^{D})</span> takes as input a security parameter <span class="math">\\eta</span> in unary, the size <span class="math">S</span> of the circuit in binary, and the depth <span class="math">D</span> of the circuit in unary. It outputs a string <span class="math">\\mathsf{crs}</span>.</li>

      <li><span class="math">\\mathcal{P}_{\\mathsf{JKKZ}}(\\mathsf{crs},C,x)</span> takes as input the <span class="math">\\mathsf{crs}</span>, circuit <span class="math">C</span> of size <span class="math">S</span> and depth <span class="math">D</span>, and input <span class="math">x</span>. She runs in time <span class="math">\\mathrm{poly}(\\eta,S)</span> and outputs a proof <span class="math">\\sigma</span> of size <span class="math">D\\cdot\\mathrm{poly}(\\eta,\\log S)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{V}_{\\mathsf{JKKZ}}(\\mathsf{crs},\\langle C\\rangle,x,\\sigma)</span> takes as input the <span class="math">\\mathsf{crs}</span>, a <span class="math">\\log S</span> size description of the circuit <span class="math">C</span>, the input <span class="math">x</span>, and a short proof <span class="math">\\sigma\\in\\{0,1\\}^{D\\cdot\\mathrm{poly}(\\eta,\\log S)}</span>. He runs in time $(D+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot\\mathrm{poly}(\\eta,\\log S)<span class="math"> and outputs either </span>0<span class="math"> or </span>1$ indicating reject or accept.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These algorithms satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For <span class="math">C,x</span> such that <span class="math">C(x)=1</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathcal{V}_{\\mathsf{JKKZ}}(\\mathsf{crs},\\langle C\\rangle,x,\\sigma)=1\\begin{vmatrix}\\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{\\eta},S,1^{D})\\\\ \\sigma\\leftarrow\\mathcal{P}_{\\mathsf{JKKZ}}(\\mathsf{crs},C,x)\\end{vmatrix}=1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">2^{\\eta^{e}}</span>-Soundness: For <span class="math">C,x</span> such that <span class="math">C(x)\\neq 1</span>, for any <span class="math">\\mathrm{poly}(2^{\\eta^{e}})</span>-size <span class="math">\\mathcal{P}^{*}</span>, and for <span class="math">\\eta\\geq\\mathrm{polylog}(S)</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathcal{V}_{\\mathsf{JKKZ}}(\\mathsf{crs},\\langle C\\rangle,x,\\sigma)=1\\begin{vmatrix}\\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{\\eta},S,1^{D})\\\\ \\sigma\\leftarrow\\mathcal{P}^{*}(\\mathsf{crs})\\end{vmatrix}=\\mathrm{negl}(2^{\\eta^{e}}).</span></p>

    <p class="text-gray-300">Fix a SNARG  <span class="math">(\\mathsf{Setup}_{\\mathcal{M}^{\\otimes N}},\\mathcal{P}_{\\mathcal{M}^{\\otimes N}},\\mathcal{V}_{\\mathcal{M}^{\\otimes N}})</span>  for  <span class="math">\\mathcal{M}^{\\otimes N}</span>  as in Definition 6.2, where  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span>  takes as input the full instance  <span class="math">X</span>  rather than just a description. Suppose that the circuit  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span>  has size  <span class="math">S = \\mathrm{poly}(\\lambda ,m,N)</span>  and depth  <span class="math">D</span> . Let  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}^{\\prime}</span>  denote the algorithm that takes as input  <span class="math">(\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}},\\langle Y\\rangle ,\\sigma_{\\mathcal{M}^{\\otimes N}})</span> , computes  <span class="math">Y = B(\\langle Y\\rangle)</span> , and then runs  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}(\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}},Y,\\sigma_{\\mathcal{M}^{\\otimes N}})</span> . Denote by  <span class="math">S(B)</span>  and  <span class="math">D(B)</span>  the size and depth respectively of a circuit computing  <span class="math">B(\\cdot ,\\cdot)</span> , as defined in Definition 6.1. Note that the circuit computing  <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}^{\\prime}</span>  has size  <span class="math">S^{\\prime} = S + N\\cdot S(B) = S + N\\cdot \\mathrm{poly}(m,\\log N)</span>  and depth  <span class="math">D^{\\prime} = D + D(B) = D + \\mathrm{poly}(m,\\log N)</span> . Let  <span class="math">(\\mathsf{Setup}_{\\mathsf{JKKZ}},\\mathcal{P}_{\\mathsf{JKKZ}},\\mathcal{V}_{\\mathsf{JKKZ}})</span>  be the SNARG for circuits of size  <span class="math">S^{\\prime}</span>  and depth  <span class="math">D^{\\prime}</span>  given in Theorem 6.8.</p>

    <p class="text-gray-300">Our SNARG for  <span class="math">\\mathcal{L}</span>  is described in Figure 7.</p>

    <p class="text-gray-300">For  <span class="math">\\epsilon &amp;gt; 0</span> , define  <span class="math">\\kappa = (\\log \\Omega)^{1 / \\epsilon}</span>  and let  <span class="math">\\lambda</span>  be such that  <span class="math">\\Sigma(\\lambda, m, N) \\geq 2^{\\ell_{\\mathrm{meSSB,hash}}}</span> . Let  <span class="math">\\eta = (\\ell_{\\mathrm{meSSB,hash}} + \\ell_{\\mathcal{M}^{\\otimes N}})^{1 / \\epsilon}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}_{\\mathcal{L}}(1^{\\kappa}, 1^{\\lambda})</span>  takes as input  <span class="math">\\kappa</span>  and  <span class="math">\\lambda</span>  in unary. It samples</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">Q = \\left(q _ {1}, \\dots , q _ {\\ell}\\right) \\leftarrow Q _ {\\mathrm {n s P C P}} \\left(1 ^ {\\kappa}\\right), \\text {a n d} \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\mathrm {t d} _ {\\mathrm {m e S S B}}\\right) \\leftarrow \\operatorname {G e n} _ {\\mathrm {m e S S B}} \\left(1 ^ {\\kappa}, L, Q\\right).</span></div>

    <p class="text-gray-300">It also samples</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {M} ^ {\\otimes N}} \\left(1 ^ {\\lambda}, 1 ^ {m}, N\\right)</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r s} _ {\\mathrm {J K K Z}} \\leftarrow \\operatorname {S e t u p} _ {\\mathrm {J K K Z}} \\left(1 ^ {\\eta}, S, 1 ^ {D}\\right),</span></div>

    <p class="text-gray-300">and outputs  <span class="math">\\mathrm{crs} = (\\mathrm{hk}_{\\mathrm{meSSB}},\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}},\\mathrm{crs}_{\\mathrm{JKKZ}})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{\\mathcal{L}}</span>  takes as input the  <span class="math">\\mathrm{crs} = (\\mathrm{hk}_{\\mathrm{meSSB}}, \\mathrm{crs}_{\\mathcal{M}^{\\otimes N}}, \\mathrm{crs}_{\\mathrm{JKKZ}})</span>  and an instance  <span class="math">x</span> . It computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi \\leftarrow \\Pi (x) \\text {a n d} \\mathrm {r t} = \\operatorname {H a s h} _ {\\mathrm {m e S S B}} \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\pi\\right).</span></div>

    <p class="text-gray-300">It then computes  <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}} \\gets \\mathcal{P}_{\\mathcal{M}^{\\otimes N}}(\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}}, Y, W)</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">Y = \\left\\{\\left(\\zeta_ {j}, x, \\mathrm {h k} _ {\\mathrm {m e S S B}}, \\mathrm {r t}\\right) \\right\\} _ {j \\in [ N ]}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">W = \\left\\{\\left(\\left(\\pi_ {\\zeta_ {j, 1}}, \\dots , \\pi_ {\\zeta_ {j, \\tau}}\\right), \\left(\\mathrm {o} _ {\\zeta_ {j, 1}}, \\dots , \\mathrm {o} _ {\\zeta_ {j, \\tau}}\\right)\\right) \\right\\} _ {j \\in [ N ]},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{o}_q = \\mathsf{Open}_{\\mathsf{meSSB}}(\\mathsf{hk}_{\\mathsf{meSSB}},\\pi ,q)</span> . Finally, it computes</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {\\mathrm {J K K Z}} \\leftarrow \\mathcal {P} _ {\\mathrm {J K K Z}} \\left(\\operatorname {c r s} _ {\\mathrm {J K K Z}}, \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime}, \\left(\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}}\\right)\\right).</span></div>

    <p class="text-gray-300">It outputs  <span class="math">\\sigma = (\\mathsf{rt},\\sigma_{\\mathcal{M}^{\\otimes N}},\\sigma_{\\mathsf{JKKZ}})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}_{\\mathcal{L}}</span>  takes as input  <span class="math">\\mathrm{crs} = (\\mathrm{hk}_{\\mathrm{meSSB}}, \\mathrm{crs}_{\\mathcal{M}^{\\otimes N}}, \\mathrm{crs}_{\\mathrm{JKKZ}})</span> , instance  <span class="math">x</span> , and  <span class="math">\\sigma = (\\mathrm{rt}, \\sigma_{\\mathcal{M}^{\\otimes N}}, \\sigma_{\\mathrm{JKKZ}})</span> . It runs and outputs the result of  <span class="math">\\mathcal{V}_{\\mathrm{JKKZ}}(\\mathrm{crs}_{\\mathrm{JKKZ}}, \\langle \\mathcal{V}_{\\mathcal{M}^{\\otimes N}}&#x27; \\rangle, (\\mathrm{crs}_{\\mathcal{M}^{\\otimes N}}, \\langle Y \\rangle, \\sigma_{\\mathcal{M}^{\\otimes N}}), \\sigma_{\\mathrm{JKKZ}})</span> , where  <span class="math">\\langle Y \\rangle = (x, \\mathrm{hk}_{\\mathrm{meSSB}}, \\mathrm{rt})</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 7: SNARG  <span class="math">(\\mathsf{Setup}_{\\mathcal{L}},\\mathcal{P}_{\\mathcal{L}},\\mathcal{V}_{\\mathcal{L}})(x)</span>  for  <span class="math">\\mathcal{L}</span></p>

    <p class="text-gray-300">Theorem 6.9. The algorithms  <span class="math">(\\mathsf{Setup}_{\\mathcal{L}},\\mathcal{P}_{\\mathcal{L}},\\mathcal{V}_{\\mathcal{L}})</span>  defined in Figure 7 satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: For every  <span class="math">x \\in \\mathcal{L}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ \\sigma \\leftarrow \\mathcal {P} _ {\\mathcal {L}} (\\operatorname {c r s}, x) \\end{array} \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: Assuming that:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the meSSB hash family is  <span class="math">2^{\\kappa^{\\epsilon}}</span> -hiding,</li>

      <li>the PCP is adaptive  <span class="math">n \\leq \\Omega</span> -computational non-signaling and verified via tests, of which there are  <span class="math">N \\leq \\mathrm{poly}(\\Omega)</span> ,</li>

      <li>the  <span class="math">\\mathcal{M}^{\\otimes N}</span>  SNARG is  <span class="math">\\Sigma</span> -sound, such that  <span class="math">\\lambda</span>  (defined in Figure 7) is  <span class="math">\\leq \\Omega</span> ,</li>

      <li><span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span>  is a log-space uniform circuit of depth  <span class="math">D</span> ,</li>

      <li><span class="math">(\\mathsf{Setup}_{\\mathsf{JKKZ}}, \\mathcal{P}_{\\mathsf{JKKZ}}, \\mathcal{V}_{\\mathsf{JKKZ}})</span>  has  <span class="math">2^{\\eta^{\\epsilon}}</span> -soundness,</li>

    </ul>

    <p class="text-gray-300">then for any  <span class="math">\\mathrm{poly}(\\Omega)</span> -size  <span class="math">\\mathcal{P}^*</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ x, \\sigma \\leftarrow \\mathcal {P} _ {\\mathcal {L}} (\\operatorname {c r s}) \\end{array} \\right. \\right] = \\operatorname {n e g l} (\\Omega).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Correctness is straightforward. We focus on proving soundness. Suppose for the sake of contradiction that there is a poly  <span class="math">(\\Omega)</span> -size prover  <span class="math">\\mathcal{P}^*</span>  and a non-negligible  <span class="math">\\delta</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} _ {\\mathcal {L}} (\\operatorname {c r s}, x, \\sigma)) = 1 \\wedge x \\notin \\mathcal {L} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\operatorname {c r s} \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ x, \\sigma \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right. \\right] = \\delta (\\Omega).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As in the proof of Theorem 6.5, this implies that there is non-negligible  <span class="math">\\delta^\\prime</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta^{\\prime}(\\Omega)\\leq \\Pr \\left[ \\begin{array}{c}\\mathcal{V}_{\\mathcal{L}}(\\mathsf{crs},x,\\sigma)) = 1\\wedge x\\notin \\mathcal{L}\\\\ \\wedge \\mathcal{V}_{\\mathsf{nsPCP}}(x,Q,\\mathsf{Invert}_{\\mathsf{meSSB}}(\\mathsf{td}_{\\mathsf{meSSB}},\\mathsf{rt})) = 0 \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c}\\mathsf{crs}\\leftarrow \\mathsf{Setup}_{\\mathcal{L}}(1^{\\kappa},1^{\\lambda})\\\\ x,\\sigma = (\\mathsf{rt},\\sigma_{\\mathcal{M}^{\\otimes N}},\\sigma_{\\mathsf{JKKZ}})\\leftarrow \\mathcal{P}^{*}(\\mathsf{crs})\\end{array}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the fact that  <span class="math">\\mathcal{V}_{\\mathcal{L}}</span>  simply runs  <span class="math">\\mathcal{V}_{\\mathsf{JKKZ}}</span> , and that  <span class="math">\\mathcal{V}_{\\mathsf{nsPCP}}(x,Q,\\mathsf{Invert}_{\\mathsf{meSSB}}(\\mathsf{td}_{\\mathsf{meSSB}},\\mathsf{rt})) = 0</span>  implies that  <span class="math">Y\\notin \\mathcal{M}^{\\otimes N}</span> , where  <span class="math">\\langle Y\\rangle</span>  denotes  <span class="math">(x,\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{rt})</span> , since there is at least one test  <span class="math">\\zeta \\subseteq Q</span>  for which  $\\mathcal{U}_{\\mathsf{nsPCP}}(\\zeta ,\\mathsf{Invert}_{\\mathsf{meSSB}}(\\mathsf{td}_{\\mathsf{meSSB}},\\mathsf{rt})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\zeta}) = 0$ , we obtain that this is equal to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Pr \\left[ \\mathcal {V} _ {\\mathsf {J K K Z}} \\left( \\begin{array}{c} \\mathsf {c r s} _ {\\mathsf {J K K Z}}, \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime}, \\\\ (\\mathsf {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}}), \\\\ \\sigma_ {\\mathsf {J K K Z}} \\end{array} \\right) = 1 \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {c r s} = (\\mathsf {h k} _ {\\mathsf {m e S S B}}, \\mathsf {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\mathsf {c r s} _ {\\mathsf {J K K Z}}) \\leftarrow \\mathsf {S e t u p} _ {\\mathcal {L}} (1 ^ {\\kappa}, 1 ^ {\\lambda}) \\\\ x, \\sigma = (\\mathsf {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}, \\sigma_ {\\mathsf {J K K Z}}) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {c r s}) \\end{array} \\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We can split this into whether <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}}</span> is an accepting proof for <span class="math">Y \\in \\mathcal{M}^{\\otimes N}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp;\\leq \\Pr \\left[ \\begin{array}{c} \\mathcal {V} _ {\\mathrm {J K K Z}} \\left(\\left(\\underset {\\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}} {\\operatorname {c r s} _ {\\mathrm {J K K Z}}, \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime}}, \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}}\\right), \\\\ \\sigma_ {\\mathrm {J K K Z}}\\right) = 1 \\\\ \\wedge \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime} \\left(\\underset {\\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}} {\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}}\\right) = 0 \\end{array} \\right] &amp;amp; \\begin{array}{c} \\operatorname {c r s} = \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\operatorname {c r s} _ {\\mathrm {J K K Z}}\\right) \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} \\left(1 ^ {\\kappa}, 1 ^ {\\lambda}\\right) \\\\ x, \\sigma = \\left(\\mathrm {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}, \\sigma_ {\\mathrm {J K K Z}}\\right) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\tag {3} \\\\ &amp;amp;+ \\Pr \\left[ \\begin{array}{c} \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime} \\left(\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}}\\right) = 1 \\\\ \\wedge Y \\notin \\mathcal {M} ^ {\\otimes N} \\end{array} \\right] &amp;amp; \\begin{array}{c} \\operatorname {c r s} = \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\operatorname {c r s} _ {\\mathrm {J K K Z}}\\right) \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} \\left(1 ^ {\\kappa}, 1 ^ {\\lambda}\\right) \\\\ x, \\sigma = \\left(\\mathrm {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}, \\sigma_ {\\mathrm {J K K Z}}\\right) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\tag {4} \\end{aligned}</span></div>

    <p class="text-gray-300">To get a contradiction we argue that both terms of this sum are negligible in <span class="math">\\Omega</span>. The term (4) is <span class="math">\\mathrm{negl}(\\Omega)</span> for precisely the same reason as in the proof of Theorem 6.5: we can otherwise break the <span class="math">\\Sigma</span>-soundness of the <span class="math">\\mathcal{M}^{\\otimes N}</span> SNARG by finding an accepting proof <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}}</span> for some instance <span class="math">Y^{<em>} = (x^{</em>},\\mathsf{hk}_{\\mathsf{meSSB}}^{<em>},\\mathsf{rt}_{\\mathsf{meSSB}}^{</em>})</span> with probability <span class="math">\\frac{\\Delta(\\Omega)}{2^{n + \\ell_{\\mathsf{meSSB}},\\mathsf{hash}}} = \\Delta^{\\prime}(\\Sigma (\\lambda ,m,N))</span>, where <span class="math">\\Delta</span> and <span class="math">\\Delta^\\prime</span> are non-negligible functions.</p>

    <p class="text-gray-300">As for the term (3), suppose that it is equal to <span class="math">\\Delta(\\Omega)</span>, for some non-negligible <span class="math">\\Delta</span>. By an averaging argument, there is some <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}^<em></span> and <span class="math">\\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}^</em></span> for which (3) <span class="math">\\geq \\Delta(\\Omega)</span>, conditioned on <span class="math">\\mathsf{crs} = (\\mathsf{hk}_{\\mathsf{meSSB}}^<em>, \\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}^</em>, \\mathsf{crs}_{\\mathsf{JKKZ}})</span> . Next, conditioning on crs being of the form <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}}^<em>, \\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}^</em>, \\mathsf{crs}_{\\mathsf{JKKZ}})</span>, there is some <span class="math">x^<em>, \\mathsf{rt}^</em>, \\sigma_{\\mathcal{M}^{\\otimes N}}^<em></span> for which, with probability <span class="math">\\geq \\frac{\\Delta(\\Omega)}{2^{n + \\ell_{\\mathsf{meSSB}},\\mathsf{hash} + \\ell_{\\mathcal{M}^{\\otimes N}}}}</span>, the conditions of (3) hold and <span class="math">\\mathcal{P}^</em></span> outputs <span class="math">x</span> and <span class="math">\\sigma = (\\mathsf{rt}, \\sigma_{\\mathcal{M}^{\\otimes N}}, \\sigma_{\\mathsf{JKKZ}})</span> with <span class="math">x = x^<em>, \\mathsf{rt} = \\mathsf{rt}^</em>, \\sigma_{\\mathcal{M}^{\\otimes N}} = \\sigma_{\\mathcal{M}^{\\otimes N}}^<em></span>. That is, letting <span class="math">\\langle Y^</em> \\rangle = (x^<em>, \\mathsf{hk}_{\\mathsf{meSSB}}^</em>, \\mathsf{rt}^*)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp;\\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathrm {J K K Z}} \\left(\\left(\\underset {\\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}} {\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y ^ {*} \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}}\\right), &amp;amp; \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\langle Y ^ {*} \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}\\right) = 1 \\\\ \\sigma_ {\\mathrm {J K K Z}} &amp;amp; \\sigma_ {\\mathrm {J K K Z}} \\end{array} \\right] \\\\ &amp;amp; \\wedge \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime} \\left(\\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}} ^ {*}, \\langle Y ^ {*} \\rangle , \\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}\\right) = 0 \\\\ &amp;amp; \\wedge (x, \\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) = (x ^ {*}, \\operatorname {r t} ^ {*}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}) \\end{array} \\left\\lfloor \\begin{array}{l} \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}} \\left(1 ^ {\\eta}, S, 1 ^ {D}\\right) \\\\ \\operatorname {c r s} := \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}} ^ {*}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}} ^ {*}, \\operatorname {c r s} _ {\\mathrm {J K K Z}}\\right) \\\\ x, \\sigma = (\\mathrm {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}, \\sigma_ {\\mathrm {J K K Z}}) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right\\rfloor \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\frac {\\Delta (\\Omega)}{2 ^ {n + \\ell_ {\\mathrm {m e S S B , h a s h}} + \\ell_ {\\mathcal {M} ^ {\\otimes N}}},</span></div>

    <p class="text-gray-300">where <span class="math">\\ell_{\\mathcal{M}^{\\otimes N}} = \\mathrm{poly}(\\lambda, m, \\log N)</span> is the length of <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}}</span>.</p>

    <p class="text-gray-300">Letting <span class="math">Z^{<em>}</span> denote <span class="math">(\\mathsf{crs}_{\\mathcal{M}^{\\otimes N}}^{</em>},\\langle Y^{<em>}\\rangle ,\\sigma_{\\mathcal{M}^{\\otimes N}}^{</em>})</span>, so that <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}^{\\prime}(Z^{*}) = 0</span>, this implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp;\\Pr \\left[ \\mathcal {V} _ {\\mathrm {J K K Z}} \\left(\\operatorname {c r s} _ {\\mathrm {J K K Z}}, \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime}, Z ^ {*}, \\sigma_ {\\mathrm {J K K Z}}\\right) = 1 \\right. &amp;amp; \\begin{array}{c} \\operatorname {c r s} = \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\operatorname {c r s} _ {\\mathrm {J K K Z}}\\right) \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} \\left(1 ^ {\\kappa}, 1 ^ {\\lambda}\\right) \\\\ x, \\sigma = \\left(\\mathrm {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}, \\sigma_ {\\mathrm {J K K Z}}\\right) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\\\ &amp;amp; \\geq \\Pr \\left[ \\begin{array}{c c} \\mathcal {V} _ {\\mathrm {J K K Z}} \\left(\\operatorname {c r s} _ {\\mathrm {J K K Z}}, \\mathcal {V} _ {\\mathcal {M} ^ {\\otimes N}} ^ {\\prime}, Z ^ {*}, \\sigma_ {\\mathrm {J K K Z}}\\right) = 1 &amp;amp; \\operatorname {c r s} = \\left(\\mathrm {h k} _ {\\mathrm {m e S S B}}, \\operatorname {c r s} _ {\\mathcal {M} ^ {\\otimes N}}, \\operatorname {c r s} _ {\\mathrm {J K K Z}}\\right) \\leftarrow \\operatorname {S e t u p} _ {\\mathcal {L}} \\left(1 ^ {\\kappa}, 1 ^ {\\lambda}\\right) \\\\ \\wedge (x, \\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}) = \\left(x ^ {*}, \\operatorname {r t} ^ {*}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}} ^ {*}\\right) &amp;amp; x, \\sigma = \\left(\\operatorname {r t}, \\sigma_ {\\mathcal {M} ^ {\\otimes N}}, \\sigma_ {\\mathrm {J K K Z}}\\right) \\leftarrow \\mathcal {P} ^ {*} (\\operatorname {c r s}) \\end{array} \\right] \\\\ &amp;amp; \\geq \\frac {\\Delta (\\Omega)}{2 ^ {n + \\ell_ {\\mathrm {m e S S B , h a s h}} + \\ell_ {\\mathcal {M} ^ {\\otimes N}}}} = \\Delta^ {\\prime} (2 ^ {\\eta^ {\\epsilon}}), \\end{aligned}</span></div>

    <p class="text-gray-300">where <span class="math">\\Delta&#x27;</span> is a non-negligible function (it exists because <span class="math">\\eta</span> is defined such that <span class="math">2^{\\eta^{\\epsilon}} = 2^{\\ell_{\\mathrm{meSSB},\\mathrm{hash}} + \\ell_{\\mathcal{M}^{\\otimes N}}} &amp;gt; \\Omega \\geq n</span>). This then contradicts the <span class="math">2^{\\eta^{\\epsilon}}</span>-soundness of the JKKZ SNARG, as <span class="math">\\mathcal{P}^{<em>}(\\mathrm{crs},x)</span> outputs <span class="math">\\sigma_{\\mathrm{JKKZ}}</span> for which <span class="math">\\mathcal{V}_{\\mathrm{JKKZ}}(\\mathrm{crs}_{\\mathrm{JKKZ}},\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}^{\\prime},Z^{</em>},\\sigma_{\\mathrm{JKKZ}}) = 1</span> with probability non-negligible in <span class="math">2^{\\eta^{\\epsilon}}</span>.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Assuming sub-exponential LWE, there is some <span class="math">\\epsilon &amp;gt; 0</span> such that both the following hold: a <span class="math">2^{\\kappa^{\\epsilon}}</span>-hiding meSSB hash family exists and <span class="math">(\\mathrm{Setup}_{\\mathrm{JKKZ}}, \\mathcal{P}_{\\mathrm{JKKZ}}, \\mathcal{V}_{\\mathrm{JKKZ}})</span> has <span class="math">2^{\\eta^{\\epsilon}}</span>-soundness. Assuming this, and using the adaptive computational non-signaling PCPs for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> and <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span> from Theorems 2.7 and 2.8, we get the following corollaries:</p>

    <p class="text-gray-300">Corollary 6.10. For any <span class="math">\\mathrm{poly}(n) \\leq t(n) \\leq \\exp(n)</span>, there exists a non-interactive argument for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> that is adaptively sound against <span class="math">\\mathrm{poly}(t)</span>-size cheating provers, assuming that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>LWE is sub-exponentially hard,</li>

      <li>there is a <span class="math">\\Sigma</span>-sound SNARG for <span class="math">\\mathcal{M}^{\\otimes N}</span>,</li>

      <li>the <span class="math">\\mathcal{M}^{\\otimes N}</span> verifier <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span> is a log-space uniform circuit of depth <span class="math">D</span>.</li>

    </ul>

    <p class="text-gray-300">The prover runs in time <span class="math">\\mathrm{poly}(t)</span>, the verifier runs in time <span class="math">D \\cdot \\mathrm{poly}(n, \\lambda, \\log t)</span>, and the communication complexity is <span class="math">D \\cdot \\mathrm{poly}(n, \\lambda, \\log t)</span>.</p>

    <p class="text-gray-300">Proof. The non-interactive argument for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> is that given in Figure 6.9, with <span class="math">\\epsilon</span> corresponding to the LWE assumption, and an adaptive <span class="math">t</span>-computational non-signaling PCP for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> that is verified via <span class="math">N = \\mathrm{poly}(t)</span> tests, as given in Theorem 2.7.</p>

    <p class="text-gray-300">To analyze the runtimes, we first compute some sizes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\ell_{\\mathrm{meSSB},\\mathrm{hash}} = \\kappa \\cdot \\mathrm{polylog}(t) \\cdot \\mathrm{poly}(\\kappa) = \\mathrm{polylog}(t)</span>,</li>

      <li><span class="math">\\ell_{\\mathcal{M}^{\\otimes N}} = \\mathrm{poly}(\\lambda, m, \\log N) = \\mathrm{poly}(n, \\lambda, \\log t)</span>,</li>

      <li><span class="math">S = \\mathrm{poly}(t)</span> since <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span> runs in time <span class="math">S = \\mathrm{poly}(\\lambda, m, N) = \\mathrm{poly}(t)</span>.</li>

    </ul>

    <p class="text-gray-300">Thus, <span class="math">\\eta = (\\ell_{\\mathrm{meSSB},\\mathrm{hash}} + \\ell_{\\mathcal{M}^{\\otimes N}})^{1 / \\epsilon} = \\mathrm{poly}(n,\\lambda ,\\log t)</span>. Now, we analyze the runtimes and complexities.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover has to do three things: compute the PCP <span class="math">\\pi</span>, which takes time <span class="math">\\mathrm{poly}(t)</span>; compute <span class="math">Y</span> and <span class="math">W</span>, and compute <span class="math">\\sigma_{\\mathcal{M}^{\\otimes N}}</span>, which together takes time <span class="math">\\mathrm{poly}(\\lambda, m, N) = \\mathrm{poly}(t)</span>; and finally compute <span class="math">\\sigma_{\\mathrm{JKKZ}}</span>, which takes time <span class="math">\\mathrm{poly}(\\eta, S&#x27;) = \\mathrm{poly}(\\mathrm{poly}(n, \\log t), S + N \\cdot \\mathrm{poly}(m, \\log N)) = \\mathrm{poly}(t)</span>. This gives a total prover runtime of <span class="math">\\mathrm{poly}(t)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The proof string <span class="math">\\sigma</span> has length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{rt}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{\\mathcal{M}^{\\otimes N}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{\\mathrm{JKKZ}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\kappa) + \\mathrm{poly}(\\lambda, m, \\log N) + D \\cdot \\mathrm{poly}(\\eta, \\log S) = D \\cdot \\mathrm{poly}(n, \\lambda, \\log t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Corollary 6.11.</h6>

    <p class="text-gray-300">For <span class="math">\\mathrm{poly}(n)\\leq t\\leq\\exp(n)</span> and <span class="math">s=s(n)\\geq\\log t(n)</span>, there exists a non-interactive argument for <span class="math">\\mathsf{N}\\mathcal{L}_{\\mathcal{U}}(t,s)</span> that is adaptively sound against <span class="math">\\mathrm{poly}(2^{s})</span>-size cheating provers with probability <span class="math">1-\\mathrm{negl}(2^{s})</span>, assuming that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{LWE}</span> is sub-exponentially hard,</li>

      <li>there is a <span class="math">\\Sigma</span>-sound SNARG for <span class="math">\\mathcal{M}^{\\otimes N}</span>,</li>

      <li>the <span class="math">\\mathcal{M}^{\\otimes N}</span> verifier <span class="math">\\mathcal{V}_{\\mathcal{M}^{\\otimes N}}</span> is a log-space uniform circuit of depth <span class="math">D</span>.</li>

    </ul>

    <p class="text-gray-300">The honest prover runs in time <span class="math">\\mathrm{poly}(t)</span>, the verifier runs in time <span class="math">D\\cdot\\mathrm{poly}(n,\\lambda,s)</span>, and the communication complexity is <span class="math">D\\cdot\\mathrm{poly}(n,\\lambda,s)</span>.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The non-interactive argument for <span class="math">\\mathcal{L}_{\\mathcal{U}}(t)</span> is that given in Figure 7, with <span class="math">\\epsilon&gt;0</span> corresponding to the <span class="math">\\mathsf{LWE}</span> assumption and an adaptive <span class="math">2^{s}</span>-computational non-signaling <span class="math">\\mathsf{PCP}</span> that is verified via <span class="math">N=\\mathrm{poly}(t)</span> tests as given in Theorem 2.8. The runtime analysis is analogous to the proof of Corollary 6.10, except <span class="math">\\kappa=\\mathrm{poly}(\\log 2^{s})=\\mathrm{poly}(s)</span>, which gives that <span class="math">\\eta=\\mathrm{poly}(n,\\lambda,s)</span>. This gives the claimed runtimes. ∎</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Acknowledgements.</h4>

    <p class="text-gray-300">We thank the anonymous TCC 2021 reviewers for their detailed and insightful comments.</p>

    <h2 id="sec-70" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Bar01] Boaz Barak. How to go beyond the black-box simulation barrier. In FOCS, pages 106–115, 2001.</li>

      <li>[BBH^{+}19] James Bartusek, Liron Bronfman, Justin Holmgren, Fermi Ma, and Ron D. Rothblum. On the (in)security of kilian-based snargs. In Dennis Hofheinz and Alon Rosen, editors, Theory of Cryptography - 17th International Conference, TCC 2019, Nuremberg, Germany, December 1-5, 2019, Proceedings, Part II, volume 11892 of Lecture Notes in Computer Science, pages 522–551. Springer, 2019.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, May 5-8, 1991, New Orleans, Louisiana, USA, pages 21–31, 1991.</li>

      <li>[BHK17] Zvika Brakerski, Justin Holmgren, and Yael Tauman Kalai. Non-interactive delegation and batch NP verification from standard computational assumptions. In Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2017, Montreal, QC, Canada, June 19-23, 2017, pages 474–482, 2017.</li>

      <li>[BK18] Zvika Brakerski and Yael Tauman Kalai. Monotone batch np-delegation with applications to access control. IACR Cryptology ePrint Archive, 2018:375, 2018.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BKK^{+}18] Saikrishna Badrinarayanan, Yael Tauman Kalai, Dakshita Khurana, Amit Sahai, and Daniel Wichs. Succinct delegation for low-space non-deterministic computation. In Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2018, Los Angeles, CA, USA, June 25-29, 2018, pages 709–721, 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Blu86] Manuel Blum. How to prove a theorem so no one else can claim it. In Proceedings of the International Congress of Mathematicians, pages 1444–1451, 1986.</li>

      <li>[BV11] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) lwe. In FOCS, pages 97–106, 2011.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, June 23-26, 2019, pages 1082–1090. ACM, 2019.</li>

      <li>[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D. Rothblum. Fiat-shamir and correlation intractability from strong kdm-secure encryption. In Advances in Cryptology - EUROCRYPT 2018 - 37th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part I, pages 91–122, 2018.</li>

      <li>[CGKS95] Benny Chor, Oded Goldreich, Eyal Kushilevitz, and Madhu Sudan. Private information retrieval. In 36th Annual Symposium on Foundations of Computer Science, Milwaukee, Wisconsin, USA, 23-25 October 1995, pages 41–50, 1995.</li>

      <li>[CJJ21] Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. SNARGs for P from LWE. IACR Cryptol. ePrint Arch., 2021.</li>

      <li>[CMSZ21] Alessandro Chiesa, Fermi Ma, Nicholas Spooner, and Mark Zhandry. Post-quantum succinct arguments. IACR Cryptol. ePrint Arch., 2021:334, 2021.</li>

      <li>[CSW20] Ran Canetti, Pratik Sarkar, and Xiao Wang. Triply adaptive UC NIZK. IACR Cryptol. ePrint Arch., 2020:1212, 2020.</li>

      <li>[DGI^{+}19] Nico Döttling, Sanjam Garg, Yuval Ishai, Giulio Malavolta, Tamer Mour, and Rafail Ostrovsky. Trapdoor hash functions and their applications. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part III, volume 11694 of Lecture Notes in Computer Science, pages 3–32. Springer, 2019.</li>

      <li>[DHRW16] Yevgeniy Dodis, Shai Halevi, Ron D. Rothblum, and Daniel Wichs. Spooky encryption and its applications. In Advances in Cryptology - CRYPTO 2016 - 36th Annual</li>

    </ul>

    <p class="text-gray-300">International Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part III, pages 93–122, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DLN^{+}04] Cynthia Dwork, Michael Langberg, Moni Naor, Kobbi Nissim, and Omer Reingold. Succinct proofs for NP and spooky interactions. Unpublished manuscript, 2004. http://www.cs.bgu.ac.il/~kobbi/papers/spooky_sub_crypto.pdf.</li>

      <li>[GK03] Shafi Goldwasser and Yael Tauman Kalai. On the (in)security of the fiat-shamir paradigm. In FOCS, pages 102–, 2003.</li>

      <li>[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In Éva Tardos, editor, 46th IEEE Symposium on Foundations of Computer Science (FOCS), pages 553–562. IEEE Computer Society, 2005.</li>

      <li>[GK16] Shafi Goldwasser and Yael Tauman Kalai. Cryptographic assumptions: A position paper. In Theory of Cryptography - 13th International Conference, TCC 2016-A, Tel Aviv, Israel, January 10-13, 2016, Proceedings, Part I, pages 505–522, 2016.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In STOC, pages 113–122, 2008.</li>

      <li>[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity, or all languages in np have zero-knowledge proof systems. Journal of the ACM, 38(1):691–729, 1991.</li>

      <li>[GR05] Craig Gentry and Zulfikar Ramzan. Single-database private information retrieval with constant communication rate. In Luís Caires, Giuseppe F. Italiano, Luís Monteiro, Catuscia Palamidessi, and Moti Yung, editors, Automata, Languages and Programming, 32nd International Colloquium, ICALP 2005, Lisbon, Portugal, July 11-15, 2005, Proceedings, volume 3580 of Lecture Notes in Computer Science, pages 803–815. Springer, 2005.</li>

      <li>[HL18] Justin Holmgren and Alex Lombardi. Cryptographic hashing from strong one-way functions (or: One-way product functions and their applications). In Mikkel Thorup, editor, 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, October 7-9, 2018, pages 850–858. IEEE Computer Society, 2018.</li>

      <li>[HLR21] Justin Holmgren, Alex Lombardi, and Ron D. Rothblum. Fiat-shamir via list-recoverable codes (or: Parallel repetition of gmw is not zero-knowledge). Cryptology ePrint Archive, Report 2021/286, 2021. https://eprint.iacr.org/2021/286.</li>

      <li>[HW15] Pavel Hubácek and Daniel Wichs. On the communication complexity of secure function evaluation with long output. In Tim Roughgarden, editor, Proceedings of the 2015 Conference on Innovations in Theoretical Computer Science, ITCS 2015, Rehovot, Israel, January 11-13, 2015, pages 163–172. ACM, 2015.</li>

    </ul>

    <p class="text-gray-300">[JKKZ20] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Zhang. Snargs for bounded depth computations and PPAD hardness from sub-exponential LWE. IACR Cryptol. ePrint Arch., 2020:980, 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JKKZ21] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Zhang. Snargs for bounded depth computations and PPAD hardness from sub-exponential LWE. 2021.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In STOC, pages 723–732, 1992.</li>

      <li>[KO97] Eyal Kushilevitz and Rafail Ostrovsky. Replication is not needed: Single database, computationally-private information retrieval. In FOCS, pages 364–373, 1997.</li>

      <li>[KPY19] Yael Tauman Kalai, Omer Paneth, and Lisa Yang. How to delegate computations publicly. In Moses Charikar and Edith Cohen, editors, Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, June 23-26, 2019, pages 1115–1124. ACM, 2019.</li>

      <li>[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for bounded space. In Symposium on Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013, pages 565–574, 2013.</li>

      <li>[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. How to delegate computations: the power of no-signaling proofs. In STOC, pages 485–494. ACM, 2014.</li>

      <li>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum. From obfuscation to the security of fiat-shamir for proofs. In Jonathan Katz and Hovav Shacham, editors, Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part II, volume 10402 of Lecture Notes in Computer Science, pages 224–251. Springer, 2017.</li>

      <li>[Lip05] Helger Lipmaa. An oblivious transfer protocol with log-squared communication. In Jianying Zhou, Javier López, Robert H. Deng, and Feng Bao, editors, Information Security, 8th International Conference, ISC 2005, Singapore, September 20-23, 2005, Proceedings, volume 3650 of Lecture Notes in Computer Science, pages 314–328. Springer, 2005.</li>

      <li>[Mer87] Ralph C. Merkle. A digital signature based on a conventional encryption function. In CRYPTO, volume 293 of Lecture Notes in Computer Science, pages 369–378. Springer, 1987.</li>

      <li>[PR17] Omer Paneth and Guy N. Rothblum. On zero-testable homomorphic encryption and publicly verifiable non-interactive arguments. In Theory of Cryptography - 15th International Conference, TCC 2017, Baltimore, MD, USA, November 12-15, 2017, Proceedings, Part II, pages 283–315, 2017.</li>

    </ul>

    <p class="text-gray-300">[PS19] Chris Peikert and Sina Shiehian. Noninteractive zero knowledge for NP from (plain) learning with errors. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology - CRYPTO 2019, Proceedings, Part I, volume 11692 of Lecture Notes in Computer Science, pages 89-114. Springer, 2019. 6 [Unr12] Dominique Unruh. Quantum proofs of knowledge. In David Pointcheval and Thomas Johansson, editors, Advances in Cryptology - EUROCRYPT 2012 - 31st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cambridge, UK, April 15-19, 2012. Proceedings, volume 7237 of Lecture Notes in Computer Science, pages 135-152. Springer, 2012. 3 [Wat09] John Watrous. Zero-knowledge against quantum attacks. SIAM J. Comput., 39(1):25-58, 2009. 3</p>

    <h2 id="sec-71" class="text-2xl font-bold">A Proof of Theorem 3.6</h2>

    <p class="text-gray-300">Theorem 3.6 shows the adaptive soundness of the BMW heuristic when applied to an adaptive computational non-signaling PCP and a meSSB hash family. The proof is nearly identical to that in [KRR13, BHK17] using an (adaptive) computational non-signaling PCP and a private information retrieval (PIR) scheme, and is provided here for completeness.</p>

    <p class="text-gray-300">We first define the notion of an adaptive computational non-signaling PCP. For any ordered set <span class="math">U = (u_{1},\\ldots ,u_{\\ell})</span> and <span class="math">J\\subseteq [\\ell ]</span>, we let <span class="math">U_{J} = (u_{j})_{j\\in J}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition A.1 (Computational Non-Signaling Distributions).</strong> A family of distributions $\\{\\mathcal{D}_Q\\}_{Q\\subset [L],</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\ell}<span class="math"> is </span>\\Omega<span class="math">-computational non-signaling with locality </span>\\ell<span class="math"> if, for any </span>q_{1},\\ldots ,q_{\\ell}\\in [L]<span class="math"> and </span>q_1^{\\prime},\\ldots ,q_\\ell^{\\prime}\\in [L]<span class="math">, letting </span>J = \\{j\\in [\\ell ]:q_j = q_j'\\}<span class="math">, the following two distributions are </span>\\Omega$-indistinguishable (see Definition 2.1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D_J</span> where <span class="math">D = (d_1, \\ldots, d_\\ell) \\gets \\mathcal{D}_{(q_1, \\ldots, q_\\ell)}</span>,</li>

      <li><span class="math">D_J&#x27;</span> where <span class="math">D&#x27; = (d_1&#x27;, \\ldots, d_\\ell&#x27;) \\gets \\mathcal{D}_{(q_1&#x27;, \\ldots, q_\\ell&#x27;)}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition A.2 (Adaptive Computational Non-Signaling PCP).</strong> An adaptive <span class="math">\\Omega</span>-computational non-signaling PCP with locality <span class="math">\\ell</span> is a PCP <span class="math">(\\Pi, \\mathcal{Q}_{\\mathrm{PCP}}, \\mathcal{V}_{\\mathrm{PCP}})</span> where soundness holds against adaptive cheating provers mounting an <span class="math">\\Omega</span>-non-signaling attack with locality <span class="math">\\ell</span>. That is, for every <span class="math">\\Omega</span>-computational non-signaling distribution $\\{\\mathcal{A}_S\\}_{S \\subset [L],</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell}<span class="math"> with locality </span>\\ell$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {V} _ {\\mathrm {P C P}} (Q, x, A) = 1 \\quad \\wedge \\quad x \\notin \\mathcal {L} \\right] \\leq 2 ^ {- \\kappa},</span></div>

    <p class="text-gray-300">where the probability is over <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span> and <span class="math">(x,A) = (x,a_{1},\\dots ,a_{\\ell})\\gets \\mathcal{A}_{Q}</span>, where <span class="math">Q = (0,q_{1},\\dots ,q_{\\ell})</span>.</p>

    <p class="text-gray-300">Let <span class="math">(\\mathrm{Gen}_{\\mathrm{meSSB}},\\mathrm{Hash}_{\\mathrm{meSSB}},\\mathrm{Open}_{\\mathrm{meSSB}},\\mathrm{Verify}_{\\mathrm{meSSB}},\\mathrm{Open}_{\\mathrm{meSSB}})</span> be a meSSB hash family. We restate Theorem 3.6 below.</p>

    <p class="text-gray-300"><span class="math">^{11}</span>The works of [KRR13, BHK17] consider unordered sets. The analysis is nearly identical, however.</p>

    <p class="text-gray-300"><span class="math">^{12}</span>We add the dummy 0 query because <span class="math">x</span> is chosen adaptively depending on the PCP queries, and we think of it as the answer corresponding to this dummy query.</p>

    <p class="text-gray-300">On input  <span class="math">x</span>  and  <span class="math">1^{\\kappa}</span> , the 2 message protocol  <span class="math">(\\mathcal{P}_{\\mathrm{BMW}},\\mathcal{V}_{\\mathrm{BMW}})</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier:  <span class="math">\\mathcal{V}_{\\mathrm{BMW}}</span>  computes PCP queries  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span> . He computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(h k _ {m e S S B}, t d _ {m e S S B}\\right) \\leftarrow G e n _ {m e S S B} \\left(1 ^ {\\kappa}, L, \\ell , \\left(q _ {1}, \\dots , q _ {\\ell}\\right)\\right)</span></div>

    <p class="text-gray-300">and sends  <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}</span>  to the prover.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover:  <span class="math">\\mathcal{P}_{\\mathrm{BMW}}</span>  computes the PCP string  <span class="math">\\pi = \\Pi(x)</span> , and sends  <span class="math">\\mathsf{rt} \\gets \\mathsf{Hash}_{\\mathrm{meSSB}}(\\mathsf{hk}_{\\mathrm{meSSB}}, \\pi)</span>  to the verifier.</li>

      <li>Verdict:  <span class="math">\\mathcal{V}_{\\mathrm{BMW}}</span>  computes  <span class="math">(a_{1},\\ldots ,a_{\\ell})\\gets \\mathrm{Invert}_{\\mathrm{meSSB}}([\\ell ],\\mathrm{td}_{\\mathrm{meSSB}},\\mathrm{rt})</span>  and accepts if and only if  <span class="math">\\mathcal{V}_{\\mathrm{PCP}}(x,(q_1,\\dots ,q_\\ell),(a_1,\\dots ,a_\\ell)) = 1.</span></li>

    </ul>

    <p class="text-gray-300">Theorem A.3 (Theorem 3.6, restated). Let  <span class="math">(\\Pi, \\mathcal{Q}_{\\mathrm{nsPCP}}, \\mathcal{V}_{\\mathrm{nsPCP}})</span>  be a PCP for a language  <span class="math">\\mathcal{L}</span>  with adaptive  <span class="math">\\Omega(n)</span> -computational non-signaling soundness and locality  <span class="math">\\ell</span> . Assume that the meSSB hash family is  <span class="math">\\Omega&#x27;</span> -hiding, where  <span class="math">\\Omega&#x27; = \\Omega&#x27;(\\kappa)</span>  is such that  <span class="math">\\Omega&#x27;(\\kappa) = \\Omega(n)</span>  and  <span class="math">2^{-\\kappa} = \\mathrm{negl}(\\Omega&#x27;)</span> . Then, for any poly  <span class="math">(\\Omega&#x27;(\\kappa))</span> -size cheating prover  <span class="math">\\mathcal{P}^*</span>  there is a negligible function  <span class="math">\\mu</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {V} _ {\\mathrm {B M W}} (x, \\mathrm {r t}, \\mathrm {t d} _ {\\mathrm {m e S S B}}, (q _ {1}, \\dots , q _ {\\ell})) = 1 \\wedge x \\notin \\mathcal {L} \\right] \\leq \\mu (\\Omega^ {\\prime}),</span></div>

    <p class="text-gray-300">where  <span class="math">(x,\\mathsf{rt}) = \\mathcal{P}^{*}(\\mathsf{hk}_{\\mathsf{meSSB}})</span>  and where the probability is over  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span>  and  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{td}_{\\mathsf{meSSB}})\\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa},L,\\ell ,(q_{1},\\ldots ,q_{\\ell}))</span> . Furthermore, the scheme is  <span class="math">\\Omega^{\\prime}</span> -straightline sound.</p>

    <p class="text-gray-300">Proof. Suppose otherwise, that there is a poly  <span class="math">(\\Omega&#x27;(\\kappa))</span> -size cheating prover  <span class="math">\\mathcal{P}^*</span>  and a non-negligible function  <span class="math">\\delta</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {V} _ {\\mathrm {B M W}} (x, \\mathrm {r t}, \\mathrm {t d} _ {\\mathrm {m e S S B}}, (q _ {1}, \\dots , q _ {\\ell})) = 1 \\wedge x \\notin \\mathcal {L} \\right] \\geq \\delta (\\Omega^ {\\prime}),</span></div>

    <p class="text-gray-300">where  <span class="math">(x,\\mathsf{rt}) = \\mathcal{P}^{*}(\\mathsf{hk}_{\\mathsf{meSSB}})</span>  and where the probability is over  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span>  and  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{td}_{\\mathsf{meSSB}})\\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa},L,\\ell ,(q_{1},\\ldots ,q_{\\ell}))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will use  <span class="math">\\mathcal{P}^*</span>  to construct an adaptive  <span class="math">\\Omega</span> -computational non-signaling strategy  $\\{\\mathcal{A}_Q\\}_{Q \\subset [L],</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\ell}$  such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {V} _ {\\mathrm {P C P}} (Q, x, A) = 1 \\quad \\wedge \\quad x \\notin \\mathcal {L} \\right] \\geq \\delta \\left(\\Omega^ {\\prime}\\right), \\tag {5}</span></div>

    <p class="text-gray-300">where the probability is over  <span class="math">(q_{1},\\ldots ,q_{\\ell})\\gets \\mathcal{Q}_{\\mathrm{PCP}}(1^{\\kappa})</span>  and  <span class="math">(x,A) = (x,a_1,\\dots ,a_\\ell)\\gets \\mathcal{A}_Q</span> , where  <span class="math">Q = (0,q_{1},\\ldots ,q_{\\ell})</span> . This would contradict the  <span class="math">\\Omega</span> -computational non-signaling soundness of the PCP.</p>

    <p class="text-gray-300">Fix any  <span class="math">q_1, \\ldots, q_\\ell \\in [L]</span>  and let  <span class="math">Q = (0, q_1, \\ldots, q_\\ell)</span> . The distribution  <span class="math">\\mathcal{A}_Q</span>  is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{td}_{\\mathsf{meSSB}})\\gets \\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa},L,\\ell ,(q_{1},\\ldots ,q_{\\ell}))</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(x,\\mathsf{rt})=\\mathcal{P}^{*}(\\mathsf{hk}_{\\mathsf{meSSB}})</span>.</li>

      <li>Compute <span class="math">A=(a_{1},\\ldots,a_{\\ell})=\\mathsf{Invert}_{\\mathsf{meSSB}}([\\ell],\\mathsf{td}_{\\mathsf{meSSB}},\\mathsf{rt})</span>.</li>

      <li>Output <span class="math">(x,A)</span>.</li>

    </ol>

    <p class="text-gray-300">Our contradiction assumption immediately implies that Equation (5) holds. Thus it remains to argue that <span class="math">\\{\\mathcal{A}_{Q}\\}</span> is a collection of <span class="math">\\Omega</span>-computationally non-signaling distributions.</p>

    <p class="text-gray-300">Fix any <span class="math">q_{1},\\ldots,q_{\\ell}\\in[L]</span> and <span class="math">q_{1}^{\\prime},\\ldots,q_{\\ell}^{\\prime}\\in[L]</span>, and let <span class="math">J=\\{j\\in[\\ell]:\\ q_{j}=q_{j}^{\\prime}\\}</span>. Let</p>

    <p class="text-gray-300"><span class="math">Q=(0,q_{1},\\ldots,q_{\\ell})\\quad\\text{and}\\quad Q^{\\prime}=(0,q_{1}^{\\prime},\\ldots,q_{\\ell}^{\\prime}),</span></p>

    <p class="text-gray-300">let</p>

    <p class="text-gray-300"><span class="math">(x,a_{1},\\ldots,a_{\\ell})\\leftarrow\\mathcal{A}_{Q}\\quad\\text{and}\\quad(x^{\\prime},a_{1}^{\\prime},\\ldots,a_{\\ell}^{\\prime})\\leftarrow\\mathcal{A}_{Q^{\\prime}},</span></p>

    <p class="text-gray-300">and let</p>

    <p class="text-gray-300"><span class="math">A_{J}=(a_{j})_{j\\in J}\\quad\\text{and}\\quad A_{J}^{\\prime}=(a_{j}^{\\prime})_{j\\in J}.</span></p>

    <p class="text-gray-300">We need to prove that the distributions <span class="math">(x,A_{J})</span> and <span class="math">(x^{\\prime},A_{J}^{\\prime})</span> are <span class="math">\\Omega</span>-indistinguishable.</p>

    <p class="text-gray-300">Suppose otherwise, that there exists <span class="math">q_{1},\\ldots,q_{\\ell}\\in[L]</span>, <span class="math">q_{1}^{\\prime},\\ldots,q_{\\ell}^{\\prime}\\in[L]</span> such that the corresponding distributions <span class="math">(x,A_{J})</span> and <span class="math">(x^{\\prime},A_{J}^{\\prime})</span> (as defined above) are not <span class="math">\\Omega</span>-indistinguishable. Namely, there exists a <span class="math">\\mathrm{poly}(\\Omega)</span>-size distinguisher <span class="math">D</span> and a non-negligible function <span class="math">\\epsilon</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[D(x,A_{J})=1]-\\Pr[D(x^{\\prime},A_{J}^{\\prime})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\epsilon(\\Omega).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will use this to break the <span class="math">\\Omega^{\\prime}</span>-index hiding of the <span class="math">\\mathsf{meSSB}</span> hash. An adversary for the <span class="math">\\Omega^{\\prime}</span>-hiding of the <span class="math">\\mathsf{meSSB}</span> hash picks the two sets of indices <span class="math">i^{0}=(q_{1},\\ldots,q_{\\ell})</span> and <span class="math">i^{1}=(q_{1}^{\\prime},\\ldots,q_{\\ell}^{\\prime})</span>. Then, given <span class="math">\\mathsf{hk}_{\\mathsf{meSSB}}</span> generated by <span class="math">(\\mathsf{hk}_{\\mathsf{meSSB}},\\mathsf{td}_{\\mathsf{meSSB}})\\leftarrow\\mathsf{Gen}_{\\mathsf{meSSB}}(1^{\\kappa},L,\\ell,i^{(b)})</span> and trapdoor information $\\mathsf{td}_{\\mathsf{meSSB}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}$, does the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(x,\\mathsf{rt})=\\mathcal{P}^{*}(\\mathsf{hk}_{\\mathsf{meSSB}})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Compute $A_{J}^{\\prime\\prime}=\\mathsf{Invert}_{\\mathsf{meSSB}}(J,\\mathsf{td}_{\\mathsf{meSSB}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J},\\mathsf{rt})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">D(x,A_{J}^{\\prime\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">Note that the distinguishing advantage of this adversary is the same as the distinguishing advantage of the <span class="math">D</span>, which is <span class="math">\\epsilon(\\Omega)</span>. This contradicts the <span class="math">\\Omega</span>-hiding of the <span class="math">\\mathsf{meSSB}</span> hash family. ∎</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Somewhere Statistical Soundness, Post-Quantum Security, and ... (2021/788)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/788
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
