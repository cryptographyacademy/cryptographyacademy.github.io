---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1533';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over (F_p)^n';
const AUTHORS_HTML = 'Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom, Markus Schofnegger';

const CONTENT = `    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over <span class="math">\\mathbb{F}_{p}^{n}</span> Preimage Attack on Full Grendel</p>

    <p class="text-gray-300">Lorenzo Grassi^{1}, Dmitry Khovratovich^{2}, Sondre Rønjom^{3} and Markus Schofnegger^{4}</p>

    <p class="text-gray-300">^{1} Digital Security Group, Radboud University, The Netherlands ^{2} Dusk Network, Luxembourg ^{3} University of Bergen, Norway ^{4} IAIK, Graz University of Technology, Austria l.grassi@cs.ru.nl khovratovich@gmail.com sondre.ronjom@uib.no markus.schofnegger@tugraz.at</p>

    <p class="text-gray-300">Abstract. Motivated by modern cryptographic use cases such as multi-party computation (MPC), homomorphic encryption (HE), and zero-knowledge (ZK) protocols, several symmetric schemes that are efficient in these scenarios have recently been proposed in the literature. Some of these schemes are instantiated with low-degree nonlinear functions, for example low-degree power maps (e.g., MiMC, HadesMiMC, Poseidon) or the Toffoli gate (e.g., Ciminion). Others (e.g., Rescue, Vision, Grendel) are instead instantiated via high-degree functions which are easy to evaluate in the target application. A recent example for the latter case is the hash function Grendel, whose nonlinear layer is constructed using the Legendre symbol.</p>

    <p class="text-gray-300">In this paper, we analyze high-degree functions such as the Legendre symbol or the modulo-2 operation as building blocks for the nonlinear layer of a cryptographic scheme over <span class="math">\\mathbb{F}_{p}^{n}</span>. Our focus regards the security analysis rather than the efficiency in the mentioned use cases. For this purpose, we present several new invertible functions that make use of the Legendre symbol or of the modulo-2 operation.</p>

    <p class="text-gray-300">Even though these functions often provide strong statistical properties and ensure a high degree after a few rounds, the main problem regards their small number of possible outputs, that is, only three for the Legendre symbol and only two for the modulo-2 operation. By fixing them, it is possible to reduce the overall degree of the function significantly. We exploit this behavior by describing the first preimage attack on full Grendel, and we verify it in practice.</p>

    <p class="text-gray-300">Keywords: Legendre Symbol <span class="math">\\,\\cdot\\,</span> Modulo-2 Operator <span class="math">\\,\\cdot\\,</span> Grendel <span class="math">\\,\\cdot\\,</span> Preimage Attack</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Recently, modern cryptographic applications such as multi-party computation (MPC), homomorphic encryption (HE), and zero-knowledge (ZK) protocols have motivated the design of specific cryptographic schemes. These are often defined over large prime fields <span class="math">\\mathbb{F}_{p}</span> with the aim to increase efficiency in the above-mentioned use cases. Examples of these schemes include MiMC <em>[AGR^{+}16]</em>, GMiMC <em>[AGP^{+}19]</em>, HadesMiMC/Poseidon <em>[GLR^{+}20, GKR^{+}21]</em>, Masta <em>[HKC^{+}20]</em>, Pasta <em>[DGH^{+}21]</em>, Ciminion <em>[DGGK21]</em>, and Neptune <em>[GOPS21]</em>, all of which use low-degree non-linear functions as power maps <span class="math">x\\mapsto x^{d}</span>.</p>

    <p class="text-gray-300">However, it is also possible to achieve efficiency with high-degree functions. For example, the cost of some of the ZK protocols is the cost of proving/verifying a given statement <span class="math">y=F(x)</span> for a certain function over <span class="math">\\mathbb{F}^{n}</span>. In such a case, instead of showing <span class="math">y=F(x)</span> directly, it is also possible to prove an <em>equivalent</em> relation <span class="math">G(x,y)=c</span> for a constant <span class="math">c</span>. In some cases, proving/verifying this second relation may be more efficient than proving/verifying <span class="math">y=F(x)</span>. This approach is used in Friday and Jarvis <em>[x1]</em>, <em>Rescue</em>/<em>Vision</em> <em>[AAB^{+}20]</em>, and more recently in <em>Grendel</em> <em>[x28]</em>. In the first two, the function <span class="math">F</span> is defined either as <span class="math">F(x)=1/x</span> (hence, <span class="math">G(x,y)=x\\cdot y</span>) or as <span class="math">F(x)=x^{1/d}</span> for a small <span class="math">d\\ll p</span> (hence, <span class="math">G(x,y)=y^{d}-x</span>). In <em>Grendel</em>, <span class="math">F</span> is defined via the Legendre symbol, which is a function from <span class="math">\\mathbb{F}_{p}</span> to <span class="math">\\{-1,0,1\\}</span> and which returns <span class="math">\\pm 1</span> if the input is a (nonzero) quadratic residue or not (and zero otherwise). Besides being potentially efficient in ZK protocols <em>[x28]</em>, the Legendre symbol as a PRF is competitive both in MPC applications as shown in <em>[GRR^{+}16]</em> and in digital signature schemes as shown in <em>[x5]</em>.</p>

    <p class="text-gray-300">In this paper, we analyze the advantages and disadvantages of using the Legendre symbol and the modulo-2 operation in the design of symmetric schemes over <span class="math">\\mathbb{F}_{p}^{n}</span>. We emphasize that we focus on the security aspect of the symmetric schemes rather than their efficiency in MPC, FHE, or ZK applications. As a first contribution, we propose several invertible nonlinear layers over <span class="math">\\mathbb{F}_{p}^{n}</span> for <span class="math">n\\geq 1</span> constructed either via the Legendre symbol or the modulo-2 operation, together with a detailed analysis of their statistical and algebraic properties. Secondly, we propose an attack strategy against a scheme instantiated via any of these nonlinear layers. We use this strategy to present a preimage attack on a sponge hash function instantiated with the full <em>Grendel</em> permutation.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 The Legendre Symbol and the Modulo-2 Operation</h3>

    <p class="text-gray-300">Several works have been presented in the literature asserting that the Legendre symbol exhibits high pseudo-randomness. In 1997, Mauduit and Sárközy <em>[x26]</em> introduced several metrics to measure the pseudo-randomness of binary sequences, concluding that “<em>Legendre symbol sequences are the most natural candidate for pseudo-randomness</em>”. The high linear complexity of Legendre symbol sequences has been confirmed later on by Ding et al. <em>[x11]</em>. Tóth <em>[x31]</em> and Gyarmati et al. <em>[x14]</em> introduced new pseudo-randomness measures (avalanche effect and cross-correlation) and asserted high values of those in Legendre symbol sequences. The modulo operator is also used for similar cryptographic purposes, e.g., in the construction of pseudo-random number generators. Well-known examples include the Lehmer pseudo-random number generator <em>[x20]</em> (whose formula is <span class="math">x_{i}=\\alpha\\cdot x_{i-1}\\mod m</span>, where the modulus <span class="math">m</span> is a power of a prime number, <span class="math">\\alpha</span> is a primitive root modulo <span class="math">m</span>, and the seed <span class="math">x_{0}</span> is coprime to <span class="math">m</span>) and the Blum–Blum–Shub pseudo-random number generator <em>[x4]</em> (whose formula is <span class="math">x_{i}=x_{i-1}^{2}\\mod m</span>, where <span class="math">m=p\\cdot q</span> for two large primes <span class="math">p,q</span>).</p>

    <p class="text-gray-300">In the case of a cryptographic symmetric scheme, the Legendre symbol may be used as <em>part of an invertible S-box over <span class="math">\\mathbb{F}_{p}^{n}</span></em>, that is, it can be used in order to build a high-degree invertible nonlinear permutation over <span class="math">\\mathbb{F}_{p}^{n}</span>, as pointed out in <em>[x28]</em>. As we are going to show in Sections 3 and 4, a similar argument holds for the modulo-2 operation. The invertible functions constructed either via the Legendre symbol or the modulo-2 operator that exist in the literature and/or that we found are listed in Tables 1 and 2.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Related Work <em>[x23, x28]</em> (and More).</h4>

    <p class="text-gray-300">Let <span class="math">L_{p}(\\cdot):\\mathbb{F}_{p}\\to\\{-1,0,1\\}</span> be the Legendre symbol defined as <span class="math">L_{p}(x):=x^{\\frac{p-1}{2}}\\mod p</span>. Two examples of invertible maps constructed via the Legendre symbol proposed in the literature are</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the map <span class="math">x\\mapsto x\\cdot(L_{p}(x)+\\alpha)</span> <em>[x23]</em>, which is invertible if <span class="math">L_{p}(\\alpha^{2}-1)=1</span>, and</li>

      <li>the map <span class="math">x\\mapsto x^{d}\\cdot L_{p}(x)</span> <em>[x28]</em>, which is invertible if <span class="math">\\gcd(d+(p-1)/2,p-1)=1</span>.</li>

    </ul>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">Table 1: Summary of the proposed invertible functions  <span class="math">F</span>  over  <span class="math">{\\mathbb{F}}_{p}</span>  and their statistical and algebraic properties. Note that algebraic properties refer to their polynomial representation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conditions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p·DPmax</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree Density</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ref.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xd·(α+Lp(x))</td>

            <td class="px-3 py-2 border-b border-gray-700">gcd(d,p-1)=1, Lp(α2-1)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">if d=1: [E/2] if d≥3: 4·d</td>

            <td class="px-3 py-2 border-b border-gray-700">(p-1)/2+d sparse</td>

            <td class="px-3 py-2 border-b border-gray-700">[Sha12], Section 3.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xd·Lp(x)</td>

            <td class="px-3 py-2 border-b border-gray-700">gcd(d+2-1/2, p-1)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">if d=1: [E/2] if d≥2: 4·d</td>

            <td class="px-3 py-2 border-b border-gray-700">(p-1)/2+d sparse</td>

            <td class="px-3 py-2 border-b border-gray-700">[Sze21], Section 3.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xd*(1+Lp(x))+xd-(1-Lp(x))</td>

            <td class="px-3 py-2 border-b border-gray-700">gcd(d+,p-1)=1, gcd(d-,p-1)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">4·max{d+,d-}</td>

            <td class="px-3 py-2 border-b border-gray-700">(p-1)/2+max{d+,d-} sparse</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α(x mod 2)·x2</td>

            <td class="px-3 py-2 border-b border-gray-700">Lp(α)=-1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">max(p-2) dense</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4.2.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-1)x·x2</td>

            <td class="px-3 py-2 border-b border-gray-700">p=3 mod 4</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">max(p-2) dense</td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-1)x2·xd</td>

            <td class="px-3 py-2 border-b border-gray-700">gcd(d,p-1)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">if d=1: [E/2] if d≥3: 4·d-2</td>

            <td class="px-3 py-2 border-b border-gray-700">max(p-2) dense</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4.2.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As our first contribution, we generalize the first function to  <span class="math">x \\mapsto x^{d&#x27;} \\cdot (L_p(x) + \\alpha)</span>  for  <span class="math">\\gcd(d&#x27;, p - 1) = 1</span> , and we analyze the values of  <span class="math">d</span>  that satisfy the condition for the second one for each  <span class="math">p</span> . We show that when  <span class="math">d&#x27;, d \\geq 2</span> , both of these two functions have good differential and linear properties [BS90, Mat93]. By the definition of the Legendre symbol, they are of high degree (respectively,  <span class="math">d&#x27; + (p - 1)/2</span>  and  <span class="math">d + (p - 1)/2</span> ), but their algebraic representation is sparse.</p>

    <p class="text-gray-300">Besides that, we prove that  <span class="math">x \\mapsto x^{d_{+}} \\cdot (1 + L_{p}(x)) + x^{d_{-}} \\cdot (1 - L_{p}(x))</span>  is invertible if  <span class="math">\\gcd(d_{+}, p - 1) = \\gcd(d_{-}, p - 1) = 1</span> , but we point out that this is vulnerable to e.g. side-channel attacks.</p>

    <p class="text-gray-300">Modulo-2 Operator. Secondly, in Section 4.2 we propose new invertible functions that are built via the modulo-2 operation. While no quadratic map  <span class="math">x \\mapsto x^2</span>  is invertible over  <span class="math">\\mathbb{F}_p</span>  ( <span class="math">x^2 = (-x)^2</span>  for each  <span class="math">x \\in \\mathbb{F}_p</span> ), in Section 4.2 we show how to slightly modify it via the modulo-2 operation in order to construct a permutation over  <span class="math">\\mathbb{F}_p</span> . In particular, given a nonquadratic residue  <span class="math">\\alpha \\in \\mathbb{F}_p</span>  (i.e.,  <span class="math">\\alpha \\neq \\beta^2</span>  for each  <span class="math">\\beta \\in \\mathbb{F}_p</span> ), we show that  <span class="math">x \\mapsto \\alpha^x \\mod 2 \\cdot x^2</span>  is a permutation over  <span class="math">\\mathbb{F}_p</span> . For example, if  <span class="math">p = 3 \\mod 4</span> , then  <span class="math">x \\mapsto (-1)^x \\mod 2 \\cdot x^2 \\equiv (-1)^x \\cdot x^2</span>  is a permutation over  <span class="math">\\mathbb{F}_p</span> . Similar to the previous functions based on the Legendre symbol, this map has good statistical properties. It also has a high degree and its algebraic representation is dense.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Local Maps and the Legendre Symbol. In Section 4.3, we present other invertible nonlinear layers over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n\\geq 2</span>  defined via a local map. Let  <span class="math">1 &amp;lt; m\\leq n</span>  and let  <span class="math">F:\\mathbb{F}_p^m\\to \\mathbb{F}_p</span>  be a local map. Let  <span class="math">\\mathcal{S}_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  be defined as  $\\mathcal{S}_F(x_0,x_1,\\ldots ,x_{n - 1}) = y_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n - 1}$ , where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">y _ {i} := F \\left(x _ {i}, x _ {i + 1}, \\dots , x _ {i + m - 1}\\right),</span></div>

    <p class="text-gray-300">where the index is taken modulo  <span class="math">n</span> . A well-known example of an invertible function  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_2^n</span>  for odd  <span class="math">n</span>  is the  <span class="math">\\chi</span> -function [Wol85, DGV92, Dae95], whose local map is  <span class="math">F(x_0, x_1, x_2) = x_1 \\cdot x_2 + x_0 + x_2</span> . In this paper, we focus on the prime case, and we show how to construct  <span class="math">F</span>  via the Legendre symbol such that  <span class="math">S_F</span>  is invertible.</p>

    <p class="text-gray-300">Invertible functions over  <span class="math">\\mathbb{F}_p^n</span>  constructed via the Legendre symbol or the modulo-2 operation are promising components for the nonlinear layer of a symmetric scheme over  <span class="math">\\mathbb{F}_p^n</span> . Indeed, since they have good statistical (both linear and differential) properties, by combining</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <p class="text-gray-300">Table 2: List of functions  <span class="math">F:\\mathbb{F}_p^2\\to \\mathbb{F}_p</span>  for which the corresponding function  <span class="math">S_F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  for  <span class="math">n\\geq 2</span>  defined as in Definition 5 is invertible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(x0,x1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conditions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ref.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x0d·(Lp(x1) + α)</td>

            <td class="px-3 py-2 border-b border-gray-700">gcd(d,p-1)=1, Lp(α2-1)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">Lemma 9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(-1)x02·x1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Lemma 10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x0·(x1·(1+Lp(x1))+(1-Lp(x1))</td>

            <td class="px-3 py-2 border-b border-gray-700">n=2·n'+1≥3 odd, p=3 mod 4</td>

            <td class="px-3 py-2 border-b border-gray-700">Proposition 8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x0·(1+x12-x1p-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">gcd(2n-(-1)n,p-1)=1</td>

            <td class="px-3 py-2 border-b border-gray-700">Proposition 9</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">them with a good linear layer (e.g., by using an invertible matrix with a high branch number [DR01, DR02]), it may be possible to ensure security against statistical attacks after only a few rounds. In a similar way, it is possible to achieve a maximum-degree and dense polynomial description of the scheme after a few rounds (in the case of the modulo-2 operation, one round seems to be sufficient for that). We also refer to [Sze21, Sections 2-3] for a detailed analysis of this.</p>

    <p class="text-gray-300">At the same time, a potential problem arises in the case of large prime numbers  <span class="math">p \\gg 3</span> . This is related to the fact that the output space of both the Legendre symbol and of the modulo-2 operation has a much smaller size than the input space. In particular, the output space of the Legendre symbol contains only three elements (one of which occurs with low probability) and the output space of the modulo-2 operation contains only two elements. Hence, by fixing all Legendre symbols or modulo-2 operations, the algebraic representation of the scheme may be of low degree.</p>

    <p class="text-gray-300">In Section 5, we exploit this strategy in order to set up preimage attacks on a sponge hash function instantiated with the full Grendel permutation. Grendel is a SHARK-like scheme  <span class="math">\\left[\\mathrm{RDP}^{+}96\\right]</span>  defined over  <span class="math">\\mathbb{F}_p^n</span> . Its nonlinear layer is defined as the concatenation of invertible maps  <span class="math">x \\mapsto x^d \\cdot L_p(x)</span>  for  <span class="math">d \\geq 2</span> , and its linear layer is defined as the multiplication by an MDS matrix. Given a hash value  <span class="math">y \\in \\mathbb{F}_p^h</span> , our attack works as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We try all possible Legendre symbols, and we construct the system of equations that link the input of the sponge hash function to the given output.</li>

      <li>We solve this system by a root-finding technique.</li>

      <li>We determine if the solution found satisfies the Legendre symbols fixed in the first step. If this is not the case, we repeat the procedure.</li>

    </ol>

    <p class="text-gray-300">Using our new insights, we further estimate the new minimum number of rounds for security, and show that in some cases the original number of rounds must be increased significantly. We practically verified the attack and make the code available online.</p>

    <p class="text-gray-300">As a result, while the Legendre symbol and the modulo-2 operation have good properties for invertible cryptographic schemes, special attention must be paid to the fact that they return a small number of outputs compared to the size of the input space. As we concretely show in this paper, this is a vulnerability that can be exploited in attacks.</p>

    <p class="text-gray-300">We recall related work in the literature, focusing on the security analysis of the Legendre symbol used as a PRF and other Gröbner basis and/or factorization attacks recently proposed for MPC-/HE-/ZK-friendly schemes.</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Security Analysis of the Legendre Symbol PRF.</h4>

    <p class="text-gray-300">Several works have been proposed in the literature regarding the security of the PRF <span class="math">x\\mapsto L^{k}_{p}(x):=L_{p}(x+k)</span>, where <span class="math">k</span> is a secret key. In <em>[x13]</em>, Khovratovich proposed a birthday bound attack that exploits the property <span class="math">L^{k}_{p}(x)=L^{k+\\delta}_{p}(x-\\delta)</span> for any <span class="math">\\delta\\in\\mathbb{F}_{p}</span>. This attack has later been improved by Beullens et al. <em>[x1]</em> and Kaluderovic et al. <em>[x12]</em>. More recently, Seres et al. <em>[x20]</em> show that key-recovery attacks against the Legendre PRF are equivalent to solving a specific family of multivariate quadratic equation systems over a prime field.</p>

    <p class="text-gray-300">In the quantum setting, Frixons and Schrottenloher <em>[x9]</em> investigated the quantum security of the Legendre PRF without quantum random access to an oracle. While they presented two new attacks in this setting, both of them remain impractical for key recovery. To the best of our knowledge, if the oracle can only be queried classically, no efficient quantum algorithm is known.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Factorization and Gröbner Basis Attacks.</h4>

    <p class="text-gray-300">Algebraic attacks are usually the most powerful ones for MPC-/HE-/ZK-friendly schemes, since these schemes usually present a simple algebraic structure. Here we recall some attacks proposed in the literature that are based on these techniques.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In <em>[ACG^{+}19]</em>, Albrecht et al. present a security analysis of STARK-friendly designs based on Gröbner basis attacks. They propose preimage attacks on the Friday hash function and key-recovery attacks on full Jarvis.</li>

      <li>In <em>[BCD^{+}20]</em>, Beyne et al. set up a preimage attack on a sponge hash function instantiated with full Poseidon via Gröbner bases for a particular class of instances using weak linear layers.</li>

      <li>In <em>[x16]</em>, Roy et al. set up collision and (second) preimage attacks on a sponge hash function instantiated with (reduced-round) members of the GMiMC family via a factorization technique.</li>

      <li>In <em>[EGL^{+}20]</em>, Eichlseder et al. propose a distinguisher on almost full MiMC over <span class="math">\\mathbb{F}_{2^{n}}</span> based on an improved estimation of the degree growth. They also exploit this distinguisher to obtain a key-recovery attack via a factorization technique.</li>

    </ul>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime number (unless specified otherwise, we always assume <span class="math">p\\geq 3</span>). Let <span class="math">\\mathbb{F}_{p}</span> denote the field of integer numbers modulo <span class="math">p</span>. We use small letters to denote either parameters, indices, or variables, and greek letters to denote fixed elements in <span class="math">\\mathbb{F}_{p}</span>. Given <span class="math">x\\in\\mathbb{F}_{p}^{n}</span>, we denote by <span class="math">x_{i}</span> its <span class="math">i</span>-th component for each <span class="math">i\\in\\{0,1,\\ldots,n-1\\}</span>, that is, <span class="math">x=(x_{0},x_{1},\\ldots,x_{n-1})</span> or <span class="math">x=x_{0}\\mid\\mid x_{1}\\mid\\mid\\cdots\\mid\\mid x_{n-1}</span>, where <span class="math">\\cdot\\mid\\mid\\cdot</span> denotes concatenation. We use capital letters to denote round numbers and functions from <span class="math">\\mathbb{F}_{p}^{m}</span> to <span class="math">\\mathbb{F}_{p}</span> for <span class="math">m\\geq 1</span> (e.g., <span class="math">F:\\mathbb{F}_{p}^{m}\\to\\mathbb{F}_{p}</span>) and the calligraphic font to denote functions over <span class="math">\\mathbb{F}_{p}^{n}</span> for <span class="math">n&amp;gt;1</span> (e.g., <span class="math">\\mathcal{S}:\\mathbb{F}_{p}^{n}\\to\\mathbb{F}_{p}^{n}</span>).</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 The Legendre Symbol and the Hash Function <em>Grendel</em></h3>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">2.1.1 The Legendre Symbol</h4>

    <p class="text-gray-300">First we recall the definition of the Legendre symbol and some of its properties.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">p\\geq 3</span> be a prime. An integer <span class="math">\\alpha</span> is a quadratic residue modulo <span class="math">p</span> if it is congruent to a perfect square modulo <span class="math">p</span>, and a quadratic non-residue modulo <span class="math">p</span> otherwise.</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <p class="text-gray-300">Definition 2. The Legendre symbol <span class="math">L_{p}(\\cdot)</span> is a function <span class="math">L_{p}:\\mathbb{F}_{p}\\to \\{-1,0,1\\}</span> defined as <span class="math">L_{p}(x)\\coloneqq x^{\\frac{p - 1}{2}}\\mod p\\in \\{-1,0,1\\}</span>, or equivalently <span class="math">L_{p}(0) = 0</span> and</p>

    <div class="my-4 text-center"><span class="math-block">L _ {p} (x) := \\left\\{ \\begin{array}{l l} 1 &amp;amp; \\text {if } x \\text{ is a nonzero quadratic residue modulo } p, \\\\ - 1 &amp;amp; \\text {if } x \\text{ is a quadratic non-residue modulo } p. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Proposition 1 ([Nag51]). Let <span class="math">p, q \\geq 3</span> be two prime integers. The Legendre symbol has the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x = y \\mod p</span>, then <span class="math">L_{p}(x) = L_{p}(y)</span>.</li>

      <li><span class="math">L_{p}(x\\cdot y) = L_{p}(x)\\cdot L_{p}(y)</span></li>

      <li><span class="math">L_{p}(q)\\cdot L_{q}(p) = (-1)^{\\frac{p - 1}{2}\\cdot \\frac{q - 1}{2}}</span></li>

      <li>If <span class="math">p = 3 \\mod 4</span>, then <span class="math">\\pm x^{\\frac{p + 1}{2}}</span> are the square roots of the quadratic residue <span class="math">x</span>.</li>

    </ol>

    <p class="text-gray-300">Moreover, particular identities include the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_{p}(-1) = 1</span> if <span class="math">p = 1 \\mod 4</span>, while <span class="math">L_{p}(-1) = -1</span> if <span class="math">p = 3 \\mod 4</span>.</li>

      <li><span class="math">L_{p}(-3) = 1</span> if <span class="math">p = 1 \\mod 3</span>, while <span class="math">L_{p}(-3) = -1</span> if <span class="math">p = 2 \\mod 3</span>.</li>

      <li><span class="math">L_{p}(2) = 1</span> if <span class="math">p = 1,7 \\mod 8</span>, while <span class="math">L_{p}(2) = -1</span> if <span class="math">p = 3,5 \\mod 8</span>.</li>

    </ul>

    <h2 id="sec-13" class="text-2xl font-bold">2.1.2 The Hash Function Grendel</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A sponge hash function [BDPA08] is an iterated construction for building a function with inputs and outputs of variable length, based on a function or permutation operating on a state with a fixed size. Let <span class="math">\\mathcal{P}</span> be a permutation over <span class="math">\\mathbb{F}^n</span> (for a certain field <span class="math">\\mathbb{F}</span>), and let <span class="math">n = r + c</span>, where <span class="math">c</span> denotes the capacity and <span class="math">r</span> the rate. For a security level of <span class="math">\\kappa</span> bits, <span class="math">c</span> and <span class="math">r</span> must satisfy $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^c \\geq 2^{2 \\cdot \\kappa}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^r \\geq 2^\\kappa<span class="math">. An input message </span>m \\in \\mathbb{F}^*<span class="math"> is first injectively padded and split into </span>m_0, m_1, \\ldots, m_\\mu<span class="math">, where </span>m_i \\in \\mathbb{F}^r<span class="math">. Then, the message blocks are compressed sequentially into an </span>n$-element state, i.e.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">h _ {i + 1} = \\mathcal {P} \\left(h _ {i} + \\left(m _ {i} \\mid \\mid 0 ^ {c}\\right)\\right) \\quad \\text {for } i = 0, \\dots , \\mu ,</span></div>

    <p class="text-gray-300">where <span class="math">h_0 = IV \\in \\mathbb{F}^n</span> is an initial value. After the absorption of the last message block, the output is of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {T} _ {r} \\left(h _ {\\mu + 1}\\right) \\mid \\mid \\mathcal {T} _ {r} \\left(h _ {\\mu + 2}\\right) \\mid \\mid \\mathcal {T} _ {r} \\left(h _ {\\mu + 3}\\right) \\mid \\mid \\dots ,</span></div>

    <p class="text-gray-300">where <span class="math">h_{i + 1} = \\mathcal{P}(h_i)</span> for <span class="math">i\\geq \\mu +1</span>, and where <span class="math">\\mathcal{T}_r(x) = x_0\\mid x_1\\mid \\dots \\mid x_{r - 1}</span> is the truncation operation. A sponge hash function with a fixed-size output is shown in Fig. 1.</p>

    <p class="text-gray-300">Let <span class="math">p \\geq 3</span> be a prime number, and let <span class="math">n \\geq 2</span> be an integer. The permutation Grendel [Sze21] defined over <span class="math">\\mathbb{F}_p^n</span> resembles a SHARK-like one, using independent S-boxes as its nonlinear layer and an MDS matrix as its linear layer. The main feature of Grendel regards its nonlinear layer, which is defined as <span class="math">S(x_0, x_1, \\ldots, x_{n-1}) = S(x_0) \\parallel S(x_1) \\parallel \\dots \\parallel S(x_{n-1})</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">S (x) = x ^ {d} \\cdot L _ {p} (x).</span></div>

    <p class="text-gray-300">Here, <span class="math">L_{p}:\\mathbb{F}_{p}\\to \\{-1,0,1\\}</span> is the Legendre symbol and <span class="math">d\\geq 2</span> is the smallest integer which satisfies <span class="math">\\gcd ((2d + p - 1) / 2,p - 1) = 1</span>. The round function of Grendel is shown in Fig. 2. As we will prove in Corollary 2,</p>

    <p class="text-gray-300">(1) if <span class="math">p = 3 \\mod 4</span>, then <span class="math">d = 2</span>, and</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A sponge hash function with a two-element output, where  <span class="math">\\oplus</span>  denotes the element-wise addition of two vectors in  <span class="math">\\mathbb{F}^r</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: The round function of Grendel over  <span class="math">\\mathbb{F}_p^n</span> , where  <span class="math">n = 3</span>  and  <span class="math">c_{i}</span>  are round constants.</p>

    <p class="text-gray-300">(2) if  <span class="math">p = 1 \\mod 4</span> , then  <span class="math">d \\geq 3</span>  is the smallest integer that satisfies  <span class="math">\\gcd(d, p - 1) = 1</span> .</p>

    <p class="text-gray-300">For a security of  <span class="math">\\kappa</span>  bits (where  <span class="math">p^n \\geq 2^{3\\kappa}</span> , since  <span class="math">p^c \\geq 2^{2\\kappa}</span>  and  <span class="math">p^r \\geq 2^\\kappa</span> ), the number of rounds  <span class="math">R \\geq 1</span>  of Grendel is defined as</p>

    <div class="my-4 text-center"><span class="math-block">R = \\max \\left\\{\\left\\lceil \\frac {2 . 5 \\cdot \\kappa}{\\log_ {2} (p) - \\log_ {2} (d) - 1} \\right\\rceil , R ^ {\\prime} \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">R^{\\prime}\\geq 1</span>  is the smallest positive integer that satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\max  \\left\\{\\left( \\begin{array}{c} 2 R ^ {\\prime} n - 2 c + \\frac {1 + \\left(R ^ {\\prime} n - c\\right) (d + 3)}{8} \\\\ 2 R ^ {\\prime} n - 2 c \\end{array} \\right); 2 ^ {R ^ {\\prime} n - c} \\times \\left( \\begin{array}{c} R ^ {\\prime} n - c + \\frac {1 + \\left(R ^ {\\prime} n - c\\right) (d - 1)}{9} \\\\ R ^ {\\prime} n - c \\end{array} \\right) ^ {2} \\right\\} \\geq 2 ^ {1. 2 5 \\kappa}. \\tag {1}</span></div>

    <p class="text-gray-300">These complexities are derived from various attack vectors analyzed in the original paper, and we refer to [Sze21, Table 1] and [Sze21, Section 5.7] for more details.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2.2 Overview of Differential/Linear and Algebraic Cryptanalysis</h2>

    <p class="text-gray-300">Apart from presenting invertible nonlinear functions over  <span class="math">\\mathbb{F}_p^n</span>  using the Legendre symbol or the modulo-2 operation, we also analyze their differential, linear, and algebraic properties. Here we recall the concepts of maximum differential probability useful in the context of differential cryptanalysis, and the main weaknesses exploited in algebraic attacks. Linear cryptanalysis is recalled in Appendix A.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Differential Cryptanalysis.</h4>

    <p class="text-gray-300">Given pairs of inputs with fixed input differences, differential cryptanalysis <em>[x1, x2]</em> is based on the probability distribution of the corresponding output differences produced by the cryptographic primitive.</p>

    <p class="text-gray-300">Let <span class="math">\\Delta_{I},\\Delta_{O}\\in\\mathbb{F}_{p}^{n}</span> be respectively the input and the output differences through a function <span class="math">\\mathcal{F}</span> over <span class="math">\\mathbb{F}_{p}^{n}</span>. The differential probability (DP) of having a certain output difference <span class="math">\\Delta_{O}</span> given a particular input difference <span class="math">\\Delta_{I}</span> is equal to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{Prob}_{\\mathcal{F}}(\\Delta_{I}\\to\\Delta_{O})=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x\\in\\mathbb{F}_{p}^{n}\\mid\\mathcal{F}(x+\\Delta_{I})-\\mathcal{F}(x)=\\Delta_{O}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p^{n}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For iterated schemes, a cryptanalyst searches for ordered sequences of differences over any number of rounds that are called differential characteristics/trails. Assuming independent rounds, the DP of a differential trail is the product of the DPs of its one-round differences.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{P}</span> be a permutation over <span class="math">\\mathbb{F}_{p^{n}}\\equiv\\mathbb{F}_{p}^{n}</span>. Its maximum differential probability is defined as <span class="math">\\mathrm{DP}_{\\max}=\\max_{\\Delta_{I},\\Delta_{O}\\in\\mathbb{F}_{p}^{n}\\setminus\\{0\\}}\\mathrm{Prob}_{\\mathcal{P}}(\\Delta_{I}\\to\\Delta_{O})</span>.</p>

    <p class="text-gray-300"><em>Remark.</em> In the following, we will use <span class="math">\\mathrm{DP}_{\\max}(x\\mapsto x^{d})\\leq(d-1)/p</span>. However, we point out that this is just an upper bound. For example, consider the case <span class="math">d=-1</span>, which corresponds to <span class="math">d=p-2</span>. By the previous assumption, we get <span class="math">\\mathrm{DP}_{\\max}(x\\mapsto x^{-1})=(p-2)/p</span>, while <span class="math">\\mathrm{DP}_{\\max}(x\\mapsto x^{-1})=4/p</span>. As another example, assume that <span class="math">d=1/d^{\\prime}</span> where <span class="math">d^{\\prime}\\ll d</span>. In such a case, <span class="math">\\mathrm{DP}_{\\max}(x\\mapsto x^{1/d^{\\prime}})=\\mathrm{DP}_{\\max}(x\\mapsto x^{d^{\\prime}})=(d^{\\prime}-1)/p</span>, which is much smaller than <span class="math">(d-1)/p</span>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Algebraic Attacks.</h4>

    <p class="text-gray-300">Algebraic attacks exploit the algebraic description of the attacked cryptographic schemes in terms of polynomials. Examples of algebraic attacks include the interpolation attack <em>[x10]</em>, the higher-order differential attack <em>[x11, x12]</em>, the factorization/GCD attacks, and Gröbner basis attacks <em>[x3, x18]</em>, among others.</p>

    <p class="text-gray-300">In the case of an interpolation attack, the attacker constructs the polynomial describing the scheme. This polynomial can be used for a key-recovery attack or in a forgery attack. The cost of constructing the polynomial depends on the number of its monomials, and this number depends both on the degree and the density of the polynomial. Knowing the maximum degree of the scheme allows to set up a zero-sum distinguisher, used in a higher-order differential attack. In the case of the factorization/GCD attacks and Gröbner basis attacks, the attacker solves a system of equations describing the scheme in order to find the secret key in the case of a cipher or a preimage or collision in the case of a hash function. The cost of the attack depends on several factors, including the number of equations, the number of variables, and the degrees and the density of the equations.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.3 Solving Algebraic Equations</h3>

    <p class="text-gray-300">In the following, we present the details of the algebraic techniques that we consider in our attacks on <em>Grendel</em>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">2.3.1 Univariate Factorization and Root Finding</h4>

    <p class="text-gray-300">Polynomial factorization can be used to solve a single univariate equation. More formally, setting a polynomial <span class="math">F(x)\\in\\mathbb{F}_{p}[x]</span> to zero, with factorization we are able to solve this polynomial for <span class="math">x</span>. This problem is well-studied in literature, and has an estimated complexity in <span class="math">\\mathcal{O}(D^{3}n^{2}+Dn^{3})</span> for a polynomial <span class="math">F(x)\\in\\mathbb{F}_{p^{n}}[x]</span> of degree <span class="math">D</span> <em>[x13]</em>. This algorithm is based on matrix and vector operations. The hidden constant is relatively small and thus the estimate can mostly be used directly.</p>

    <p class="text-gray-300">While a full factorization can yield all roots of a polynomial, this will not be needed for our purposes. In our case, one root is sufficient for setting up the attack. In order to find</p>

    <p class="text-gray-300">it, it is sufficient to compute the GCD between <span class="math">F(x)</span> and <span class="math">x^{p}-x</span>. Considering a polynomial <span class="math">F(x)\\in\\mathbb{F}_{p}[x]</span>, <span class="math">(x-x^{\\star})</span> divides <span class="math">\\gcd(F(x),x^{p}-x)</span> for an existing root <span class="math">x^{\\star}</span> of <span class="math">F</span> with probability <span class="math">1</span>, since <span class="math">x^{p}-x=0</span> for all <span class="math">x\\in\\mathbb{F}_{p}</span> (indeed, <span class="math">x\\cdot(x^{p-1}-1)=0</span>, since either <span class="math">x=0</span> or <span class="math">x^{p-1}=1</span> due to Fermat’s little theorem). We expect <span class="math">\\deg(\\gcd(F(x),x^{p}-x))\\ll\\deg(F(x))</span>, and a final more efficient (low-degree) factorization of <span class="math">\\gcd(F(x),x^{p}-x)</span> is sufficient to recover the solution <span class="math">x^{\\star}</span>.</p>

    <p class="text-gray-300">The complexity of computing GCDs is an element of <span class="math">\\mathcal{O}(D\\log^{2}D)</span>, and hence this method may be more efficient than the straight-forward factorization approach with degree-<span class="math">D</span> polynomials. However, <span class="math">x^{p}-x</span> is of high degree. To avoid this, observe that</p>

    <p class="text-gray-300"><span class="math">\\gcd(F(x),x^{p}-X)=\\gcd((x^{p}\\mod F(x))-X,F(x)),</span></p>

    <p class="text-gray-300">since</p>

    <p class="text-gray-300"><span class="math">\\gcd(F(x),G(x))=\\gcd(a_{1}\\cdot F(x)+b_{1}\\cdot G(x),a_{2}\\cdot F(x)+b_{2}\\cdot G(x)),</span></p>

    <p class="text-gray-300">where <span class="math">a_{1}\\cdot b_{2}\\neq a_{2}\\cdot b_{1}</span>. Hence, the degree of <span class="math">(x^{p}\\mod F(x))-x</span> is much lower than that of <span class="math">x^{p}-x</span> if <span class="math">\\deg(F)\\ll p</span>.</p>

    <p class="text-gray-300">This root-finding approach using GCD computations is given in <em>[x10]</em>, and the final complexity of the algorithm is estimated by</p>

    <p class="text-gray-300"><span class="math">D\\cdot\\left(\\log_{2}(D)\\right)^{2}\\cdot\\left(\\log_{2}(D)+\\log_{2}(p)\\right)\\cdot(1+63.43\\cdot\\log_{2}(\\log_{2}(D)))\\,,</span> (2)</p>

    <p class="text-gray-300">which includes the complexity for (1st) polynomial multiplication resulting from repeated squaring to obtain <span class="math">x^{p}\\mod F(x)</span>, (2nd) GCD computations, and (3rd) the complexity for equal-degree factorization into low-degree factors. We note that this algorithm was also used in a recent attack <em>[x13]</em>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">2.3.2 Gröbner Bases</h4>

    <p class="text-gray-300">We will use Gröbner basis computations in cases where the number of equations and variables is greater than one. A Gröbner basis attack consists of three steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, the attacker sets up the equation system and computes a Gröbner basis for it.</li>

      <li>Secondly, they perform a change of term ordering for the basis (e.g., choosing a term order which makes it easier to eliminate variables and find the solutions).</li>

      <li>Finally, the attacker finds the solutions of the system obtained in the second step.</li>

    </ol>

    <p class="text-gray-300">The cost of computing a Gröbner basis for an input system of <span class="math">n_{e}</span> equations in <span class="math">n_{v}</span> unknowns is estimated to be an element of</p>

    <p class="text-gray-300">\\[ \\mathcal{O}\\left(\\begin{pmatrix}D_{\\text{reg}}+n_{v}\\\\ n_{v}\\end{pmatrix}^{\\omega}\\right), \\] (3)</p>

    <p class="text-gray-300">where <span class="math">2&lt;\\omega\\leq 3</span> is the linear algebra constant representing the cost of matrix multiplication <em>[x2]</em>. The constants hidden by <span class="math">\\mathcal{O}(\\cdot)</span> are relatively small <em>[ACG^{+}19]</em>, and hence we use Eq. (3) directly. In this representation, <span class="math">D_{\\text{reg}}</span> is the degree of regularity, which for regular sequences <em>[x3]</em> (that is, <span class="math">n_{v}=n_{e}</span>) can be estimated by <span class="math">1+\\sum_{i=1}^{n_{e}}\\deg(f_{i})-1</span>.</p>

    <p class="text-gray-300">For performance reasons, the Gröbner Basis is typically computed in the degrevlex term order, which is a monomial ordering, and by using algorithms such as <em>[x7]</em>. However, eliminating variables and finding the final solutions is in general more efficient for e.g. the lex term order <em>[x16]</em>, which is why the second step usually consists of converting the Gröbner basis to a different monomial ordering. This can be done by algorithms such as FGLM <em>[x6]</em>. After that, the final step in the attack consists of solving the system, which is done by first finding a solution to (one of) the univariate equation(s) in the system.</p>

    <p class="text-gray-300">In our analysis, we will focus on the first step, i.e., the process of computing a Gröbner basis. For a more detailed description and analysis of the other steps involved in a Gröbner basis attack, we refer to <em>[ACG^{+}19, Section 3.3]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <h2 id="sec-22" class="text-2xl font-bold">3.1 Hermite’s Criterion and Invertible Maps over <span class="math">\\mathbb{F}_{p^n} \\equiv \\mathbb{F}_p^n</span></h2>

    <p class="text-gray-300">Let <span class="math">p \\geq 2</span> be a prime number and let <span class="math">n \\geq 1</span>. Given a nonlinear polynomial function <span class="math">F(x) = \\sum_{i=0}^{d} \\alpha_i \\cdot x^i</span> over <span class="math">\\mathbb{F}_{p^n}</span> of degree <span class="math">d \\geq 2</span>, Hermite’s criterion provides a necessary and sufficient condition for <span class="math">F</span> to be a permutation.</p>

    <p class="text-gray-300">Theorem 1 (Hermite’s Criterion [MP13]). Let <span class="math">q = p^n</span> for a prime <span class="math">p \\geq 2</span> and a positive integer <span class="math">n</span>. A polynomial <span class="math">F \\in \\mathbb{F}_q[x]</span> is a permutation polynomial (PP) of <span class="math">\\mathbb{F}_q</span> if and only if</p>

    <p class="text-gray-300">(1) the reduction of <span class="math">(F(x))^{q - 1} \\mod (x^q - x)</span> is a monic polynomial of degree <span class="math">q - 1</span>, and (2) for each integer <span class="math">t</span> with <span class="math">1 \\leq t \\leq q - 2</span> and <span class="math">t \\neq 0 \\mod p</span>, the reduction of <span class="math">(F(x))^t \\mod (x^q - x)</span> has degree <span class="math">\\leq q - 2</span>.</p>

    <p class="text-gray-300">Applying the previous criteria on a generic function over <span class="math">\\mathbb{F}_q</span>, in order to establish if it is a PP or not, is in general computationally demanding.</p>

    <p class="text-gray-300">Power Maps and Dickson Polynomials. For certain classes of polynomials, including the power maps <span class="math">x \\mapsto x^d</span> and the Dickson polynomials, this question is easy to answer.</p>

    <p class="text-gray-300">Theorem 2 ([MP13, Section 8]). Let <span class="math">q = p^r</span> for a prime <span class="math">p \\geq 2</span> and a positive integer <span class="math">r</span>, and let <span class="math">F: \\mathbb{F}_q \\to \\mathbb{F}_q</span>. Then <span class="math">F(x) = x^d</span>, where <span class="math">d</span> is a positive integer, is a PP if and only if <span class="math">\\gcd(d, q - 1) = 1</span>.</p>

    <p class="text-gray-300">Dickson polynomials generalize power maps. Let <span class="math">q = p^r</span> for a prime <span class="math">p \\geq 3</span> and a positive integer <span class="math">r</span>. The Dickson polynomial <span class="math">\\mathcal{D}_{d,\\alpha}(x)</span> of degree <span class="math">d</span> over <span class="math">\\mathbb{F}_q</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{D}_{d,\\alpha}(x) := \\sum_{j=0}^{\\lfloor d/2 \\rfloor} \\frac{d}{d - j} \\cdot \\binom{d - j}{j} \\cdot (-\\alpha)^j \\cdot x^{d - 2j}</span></div>

    <p class="text-gray-300">for a fixed <span class="math">\\alpha \\in \\mathbb{F}_q</span>. Note that a Dickson polynomial <span class="math">\\mathcal{D}_{d,\\alpha}</span> is invertible if <span class="math">\\gcd(d, p^2 - 1) = 1</span>.</p>

    <p class="text-gray-300">Invertible Functions Over <span class="math">\\mathbb{F}_{p^n}</span> via Linearized Polynomials. Another class of permutations over <span class="math">\\mathbb{F}_{p^n}</span> is the class of linearized polynomials.</p>

    <p class="text-gray-300">Definition 4. A linearized polynomial <span class="math">\\mathcal{L}(x)</span> is a polynomial of the form <span class="math">\\mathcal{L}(x) := \\sum_{i=0}^{d} \\lambda_i \\cdot x^{p^i}</span> for some fixed <span class="math">\\lambda_0, \\lambda_1, \\ldots, \\lambda_d \\in \\mathbb{F}_{p^n}</span> and for a fixed <span class="math">d \\leq n-1</span>.</p>

    <p class="text-gray-300">The trace function <span class="math">\\operatorname{Tr}(x) = \\sum_{i=0}^{n-1} x^{p^i}</span> is an example of a linearized polynomial.</p>

    <p class="text-gray-300">Proposition 2 ([MP13]). Let <span class="math">p \\geq 3</span> be a prime integer number. The linearized polynomial <span class="math">\\mathcal{L}(x) = \\sum_{i=0}^{n-1} \\lambda_i \\cdot x^{p^n} \\in \\mathbb{F}_{p^n}[x]</span> is a PP of <span class="math">\\mathbb{F}_{p^n}[x]</span> if and only if <span class="math">\\det(M) \\neq 0</span>, where <span class="math">M_{i,j} := (\\lambda_{(i-j) \\mod n})^{p^j}</span> for <span class="math">i, j \\in \\{0,1,\\ldots,n-1\\}</span>.</p>

    <p class="text-gray-300">Since linearized polynomials are linear, they satisfy <span class="math">\\mathcal{L}(x + y) = \\mathcal{L}(x) + \\mathcal{L}(y)</span> for each <span class="math">x, y \\in \\mathbb{F}_{p^n}</span>. They can be used as a starting point to construct nonlinear permutations over <span class="math">\\mathbb{F}_{p^n}</span>. Concrete examples are given by Tu et al. [TZLH15] and by Li, Helleseth and Tang [LHT13], who studied the class of permutation polynomials on <span class="math">\\mathbb{F}_{p^n}</span> of the form <span class="math">\\left(x^{p^l} - x + \\delta\\right)^s + \\mathcal{L}(x)</span>, for <span class="math">l, s \\in \\mathbb{N}</span> and for fixed <span class="math">\\delta \\in \\mathbb{F}_{p^n}</span>. They proved that <span class="math">\\left(x^{p^l} - x + \\delta\\right)^{\\frac{p^n + 1}{2}} + x^{p^l} + x</span> is a PP over <span class="math">\\mathbb{F}_{p^n}</span> for each <span class="math">\\delta \\in \\mathbb{F}_{p^n}</span>.</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <h2 id="sec-23" class="text-2xl font-bold">3.2 The Permutation <span class="math">x \\mapsto x^d \\cdot (L_p(x) + \\alpha)</span> over <span class="math">\\mathbb{F}_p</span></h2>

    <p class="text-gray-300"><strong>Theorem 3 ( [Sha12])</strong>. Given a prime number <span class="math">p \\geq 3</span>, let <span class="math">\\alpha \\in \\mathbb{F}_p \\setminus \\{\\pm 1\\}</span> be such that <span class="math">L_p(\\alpha^2 - 1) = 1</span>. The function <span class="math">F(x) = x \\cdot (L_p(x) + \\alpha)</span> over <span class="math">\\mathbb{F}_p</span> is a permutation.</p>

    <p class="text-gray-300">Here we show a variant of this function that is still a permutation.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Given a prime number <span class="math">p \\geq 3</span>, let <span class="math">\\alpha \\in \\mathbb{F}_p \\setminus \\{\\pm 1\\}</span> be such that <span class="math">L_p(\\alpha^2 - 1) = 1</span> and let <span class="math">d \\geq 1</span> be such that <span class="math">\\gcd(d, p - 1) = 1</span>. The function</p>

    <div class="my-4 text-center"><span class="math-block">F(x) = x^d \\cdot (L_p(x) + \\alpha) \\equiv x^{d + (p - 1)/2} + \\alpha \\cdot x^d</span></div>

    <p class="text-gray-300">over <span class="math">\\mathbb{F}_p</span> is a permutation.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Given <span class="math">y = F(x)</span>, <span class="math">x = 0</span> if and only if <span class="math">y = 0</span>. Assuming <span class="math">x, y \\neq 0</span>, note that</p>

    <div class="my-4 text-center"><span class="math-block">L_p(y) = L_p(x^d) \\cdot L_p(L_p(x) + \\alpha) = L_p(x) \\cdot L_p(L_p(x) + \\alpha) = L_p(x) \\cdot L_p(\\alpha \\pm 1),</span></div>

    <p class="text-gray-300">where <span class="math">L_p(x^d) = (L_p(x))^d = L_p(x)</span> due to Proposition 1 and since <span class="math">d</span> is an odd integer (note that <span class="math">\\gcd(d, p - 1) = 1</span>, where <span class="math">p - 1</span> is even). Since <span class="math">L_p(\\alpha - 1) = L_p(\\alpha + 1)</span>, <span class="math">L_p(x) = L_p(y) / L_p(\\alpha \\pm 1)</span>, and due to Theorem 2 we have that <span class="math">x = \\left( \\frac{y \\cdot L_p(\\alpha \\pm 1)}{\\alpha \\cdot L_p(\\alpha \\pm 1) + L_p(y)} \\right)^{1/d}</span>. <span class="math">\\square</span></p>

    <p class="text-gray-300">By noting that <span class="math">L_p(1) = L_p(-1)</span> for <span class="math">p = 1 \\mod 4</span> (i.e., by setting <span class="math">\\alpha = 0</span> in the previous proposition), we get the following corollary.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Let <span class="math">p \\geq 3</span> be a prime, and let <span class="math">d \\geq 1</span> be such that <span class="math">\\gcd(d, p - 1) = 1</span>. If <span class="math">p = 1 \\mod 4</span>, then <span class="math">x \\mapsto x^d \\cdot L_p(x)</span> is a permutation.</p>

    <p class="text-gray-300"><strong>Differential Property.</strong> Before going on, we study the differential properties of the permutation just proposed. The linear ones can be found in Appendix A.1.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let <span class="math">p \\geq 3</span> be a prime and let <span class="math">F(x) = x \\cdot (L_p(x) + \\alpha)</span>. For <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p \\mid F(x + \\Delta_I) - F(x) = \\Delta_O\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\begin{cases}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2 &amp; \\text{if } \\Delta_O \\neq (\\pm 1 + \\alpha) \\cdot \\Delta_I, \\\\ \\frac{p + 1}{2} &amp; \\text{if } \\Delta_O = (\\pm 1 + \\alpha) \\cdot \\Delta_I \\text{ and } p = 1 \\mod 4, \\\\ \\frac{p - 1}{2} &amp; \\text{if } \\Delta_O = (\\pm 1 + \\alpha) \\cdot \\Delta_I \\text{ and } p = 3 \\mod 4. \\end{cases} $$</p>

    <p class="text-gray-300"><strong>Proof.</strong> For each fixed <span class="math">(\\Delta_I, \\Delta_O) \\in \\mathbb{F}_p^2 \\setminus \\{(0,0)\\}</span>, we analyze the number of solutions <span class="math">x</span> of</p>

    <div class="my-4 text-center"><span class="math-block">(x + \\Delta_I) \\cdot (L_p(x + \\Delta_I) + \\alpha) - x \\cdot (L_p(x) + \\alpha) = \\Delta_O. \\tag{4}</span></div>

    <p class="text-gray-300">We separately analyze the cases</p>

    <p class="text-gray-300">(a) <span class="math">L_p(x + \\Delta_I) = 0</span> or <span class="math">L_p(x) = 0</span>, and (b) <span class="math">L_p(x + \\Delta_I) = \\pm 1</span> and <span class="math">L_p(x) = \\pm 1</span>.</p>

    <p class="text-gray-300">Let us first focus on <span class="math">L_p(x + \\Delta_I) = 0</span> or <span class="math">L_p(x) = 0</span>. Clearly, <span class="math">L_p(x + \\Delta_I) = 0</span> if and only if <span class="math">x = -\\Delta_I</span>, which implies <span class="math">\\Delta_I \\cdot (L_p(-\\Delta_I) + \\alpha) = \\Delta_O</span>. If this equality is satisfied, then <span class="math">x = -\\Delta_I</span> is a solution. A similar result holds for <span class="math">L_p(x) = 0</span> (i.e., <span class="math">x = 0</span>), which implies <span class="math">\\Delta_I \\cdot (L_p(\\Delta_I) + \\alpha) = \\Delta_O</span>. Again, if this equality is satisfied, then <span class="math">x = 0</span> is a solution. Note that <span class="math">\\Delta_I \\cdot (L_p(-\\Delta_I) + \\alpha) = \\Delta_O</span> and <span class="math">\\Delta_I \\cdot (L_p(\\Delta_I) + \\alpha) = \\Delta_O</span> can hold simultaneously if <span class="math">L_p(-\\Delta_I) = L_p(\\Delta_I)</span>, and then</p>

    <div class="my-4 text-center"><span class="math-block">L_p(-\\Delta_I) \\cdot L_p(\\Delta_I) = 1 \\Longrightarrow L_p(-\\Delta_I^2) = L_p(-1) = 1 \\Longrightarrow p = 1 \\mod 4.</span></div>

    <p class="text-gray-300">We now consider the case <span class="math">L_p(x + \\Delta_I) = \\pm 1</span> and <span class="math">L_p(x) = \\pm 1</span>. We analyze the case <span class="math">L_p(x + \\Delta_I) = -L_p(x)</span> and the case <span class="math">L_p(x + \\Delta_I) = L_p(x)</span> separately.</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">L_{p}(x + \\Delta_{I}) = -L_{p}(x) = \\omega \\in \\{-1, + 1\\}</span>, then Eq. (4) reduces to</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">2 \\omega \\cdot x + \\Delta_ {I} \\cdot (\\omega + \\alpha) = \\Delta_ {O} \\quad \\Longrightarrow \\quad x = \\frac {\\Delta_ {O} - \\Delta_ {I} \\cdot (\\omega + \\alpha)}{2 \\cdot \\omega}.</span></div>

    <p class="text-gray-300">This is a valid solution if <span class="math">L_{p}\\left(\\frac{\\Delta_{O} - \\Delta_{I}\\cdot(\\omega + \\alpha)}{2\\cdot\\omega} +\\Delta_{I}\\right) = -L_{p}\\left(\\frac{\\Delta_{O} - \\Delta_{I}\\cdot(\\omega + \\alpha)}{2\\cdot\\omega}\\right) = \\omega</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">L_{p}(x + \\Delta_{I}) = L_{p}(x) = \\omega \\in \\{-1, + 1\\}</span>, then Eq. (4) reduces to <span class="math">\\Delta_I\\cdot (\\omega +\\alpha) = \\Delta_O</span>, which is satisfied independently of <span class="math">x</span>.</li>

    </ol>

    <p class="text-gray-300">To summarize,</p>

    <p class="text-gray-300">(1) in the first case <span class="math">L_{p}(x + \\Delta_{I}) = -L_{p}(x)</span>, the number of possible solutions is at most two, and (1) in the second case <span class="math">L_{p}(x + \\Delta_{I}) = L_{p}(x)</span>, the number of possible solutions is at most equal to the number of solutions of <span class="math">L_{p}(x + \\Delta_{I}) = L_{p}(x)</span>.</p>

    <p class="text-gray-300">Focusing on the second case and assuming <span class="math">\\Delta_I\\cdot (\\pm 1 + \\alpha) = \\Delta_O</span>, we look for the number of solutions of <span class="math">L_{p}(x + \\Delta_{I}) = L_{p}(x)</span>. First of all, the number of <span class="math">x</span> which satisfy <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I})</span> is equal to the number of <span class="math">x^{\\prime}</span> which satisfy <span class="math">L_{p}(x^{\\prime}) = L_{p}(x^{\\prime} + 1)</span>, where <span class="math">x^{\\prime} = x / \\Delta_{I}</span>. By [GU82, Corollary 1.9], we have the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">p = 1 \\mod 4</span>, the number of <span class="math">x&#x27;</span> which satisfy <span class="math">L_p(x&#x27;) = L_p(x&#x27; + 1) = 1</span> is <span class="math">\\frac{p - 5}{4}</span>, while the number of <span class="math">x&#x27;</span> which satisfy <span class="math">L_p(x&#x27;) = L_p(x&#x27; + 1) = -1</span> is <span class="math">\\frac{p - 1}{4}</span>.</li>

      <li>If <span class="math">p = 3 \\mod 4</span>, the number of <span class="math">x&#x27;</span> which satisfy <span class="math">L_p(x&#x27;) = L_p(x&#x27; + 1) = \\pm 1</span> is <span class="math">\\frac{p - 3}{4}</span>.</li>

    </ul>

    <p class="text-gray-300">In the first case, two additional solutions can be <span class="math">x = 0</span> and <span class="math">x = -\\Delta_I</span>, while in the second case one additional solution can be <span class="math">x = 0</span> or <span class="math">x = -\\Delta_I</span> (see before). The final result follows immediately by adding it.</p>

    <p class="text-gray-300">Lemma 2. Let <span class="math">p \\geq 3</span> be a prime and let <span class="math">d \\geq 3</span> be such that <span class="math">\\gcd(d, p - 1) = 1</span>. Let <span class="math">F(x) = x^d \\cdot (L_p(x) + \\alpha)</span>, where <span class="math">L_p(\\alpha^2 - 1) = 1</span>. For each <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb {F} _ {p} \\mid F (x + \\Delta_ {I}) - F (x) = \\Delta_ {O} \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4 \\cdot d.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Since <span class="math">F(x + \\Delta_I) - F(x) = \\Delta_O</span> corresponds to <span class="math">(x + \\Delta_I)^d \\cdot (\\alpha + L_p(x + \\Delta_I)) - x^d \\cdot (\\alpha + L_p(x)) = \\Delta_O</span>, we have the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">L_{p}(x) = 0</span>, the equation is satisfied if <span class="math">\\Delta_I^d \\cdot (\\alpha + L_p(\\Delta_I)) = \\Delta_O</span>. In a similar way, if <span class="math">L_{p}(x + \\Delta_{I}) = 0</span>, then the equality is satisfied if <span class="math">(\\Delta_I)^d \\cdot (\\alpha + L_p(-\\Delta_I)) = \\Delta_O</span>. As before, the two cases can hold simultaneously if <span class="math">p = 1 \\mod 4</span>.</li>

      <li>If <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I})</span>, the equation has degree <span class="math">d - 1</span>, and it admits at most <span class="math">d - 1</span> solutions for the case <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I}) = 1</span> and at most <span class="math">d - 1</span> for the case <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I}) = -1</span>.</li>

      <li>If <span class="math">L_{p}(x) = -L_{p}(x + \\Delta_{I}) \\in \\{-1, 1\\}</span>, the equation has degree <span class="math">d</span>, and it admits at most <span class="math">d</span> solutions for the case <span class="math">L_{p}(x) = -L_{p}(x + \\Delta_{I}) = 1</span> and at most <span class="math">d</span> for the case <span class="math">L_{p}(x) = -L_{p}(x + \\Delta_{I}) = -1</span>.</li>

    </ul>

    <p class="text-gray-300">It follows that its <span class="math">\\mathrm{DP}_{\\mathrm{max}}</span> is equal to <span class="math">(2 + 2\\cdot (d - 1) + 2\\cdot d) / p = (4d) / p</span></p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">The previous bound is not tight in general. Indeed, if <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I}) = 1</span>, we count the solutions <span class="math">x</span> of <span class="math">(x + \\Delta_I)^d\\cdot (\\alpha +1) - x^d\\cdot (\\alpha +1) = \\Delta_O</span> without determining if they satisfy the condition <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I}) = 1</span>. Since <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I}) = 1</span> is satisfied with a probability of <span class="math">50\\%</span>, we expect that in general the previous bound is not very precise (but sufficient for many use cases with <span class="math">p\\gg 3</span> and small <span class="math">d</span>).</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <h2 id="sec-24" class="text-2xl font-bold">3.3 Grendel's Nonlinear S-Box <span class="math">x \\mapsto x^d \\cdot L_p(x)</span></h2>

    <p class="text-gray-300"><strong>Proposition 4 ( [Sze21])</strong>. Let <span class="math">p \\geq 3</span> be a prime and <span class="math">d \\geq 1</span> be an integer such that <span class="math">\\gcd(d + (p - 1)/2, p - 1) = 1</span>. The map <span class="math">x \\mapsto x^d \\cdot L_p(x) = x^{d + (p - 1)/2}</span> is invertible over <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300">The proof is based on the Hermite's criterion, that is, a function <span class="math">x \\mapsto x^{d&#x27;}</span> is invertible if <span class="math">\\gcd(d&#x27;, p - 1) = 1</span>. Corollary 2 follows immediately.</p>

    <p class="text-gray-300"><strong>Corollary 2.</strong> Let <span class="math">p \\geq 3</span> be a prime integer. The function <span class="math">x \\mapsto x^d \\cdot L_p(x) = x^{d + (p - 1)/2}</span> is a permutation over <span class="math">\\mathbb{F}_p</span> if <span class="math">d = 1</span> and <span class="math">p = 1 \\mod 4</span> or if <span class="math">d = 2</span> and <span class="math">p = 3 \\mod 4</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> If <span class="math">p = 1 \\mod 4</span> and <span class="math">d = 1</span>, then the result follows from Corollary 1.</p>

    <p class="text-gray-300">Otherwise, if <span class="math">p = 3 \\mod 4</span> and <span class="math">d = 2</span>, then <span class="math">\\gcd(2 + (p - 1)/2, p - 1) = 1</span> as shown in [Sze21, Section 3]. Hence, <span class="math">x \\mapsto x^2 \\cdot L_p(x)</span> is invertible due to Hermite's criterion.</p>

    <p class="text-gray-300">Moreover, let <span class="math">d&#x27; \\geq 1</span> be such that <span class="math">\\gcd(d&#x27;, p - 1) = 1</span>. The function <span class="math">x \\mapsto x^{d \\cdot d&#x27;} \\cdot L_p(x)</span> is a permutation over <span class="math">\\mathbb{F}_p</span> if <span class="math">p = 1 \\mod 4</span> and <span class="math">d = 1</span> or if <span class="math">p = 3 \\mod 4</span> and <span class="math">d = 2</span>. The result follows immediately since <span class="math">d&#x27;</span> is an odd integer and <span class="math">(\\pm 1)^{d&#x27;} = \\pm 1</span>.</p>

    <p class="text-gray-300"><strong>Differential Property.</strong> The differential and linear properties of <span class="math">x \\mapsto x^d \\cdot L_p(x)</span> are similar to the ones of the function <span class="math">x \\mapsto x^d \\cdot (L_p(x) + \\alpha)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">p \\geq 3</span> be a prime number such that <span class="math">p = 3 \\mod 4</span>. Let <span class="math">d&#x27; \\geq 1</span> be such <span class="math">\\gcd(d&#x27;, p - 1) = 1</span>, and let <span class="math">d := 2 \\cdot d&#x27;</span>. The maximum differential probability of <span class="math">F(x) = x^d \\cdot L_p(x)</span> is <span class="math">(4 \\cdot d)/p</span>.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Let <span class="math">p \\geq 3</span> be a prime number such that <span class="math">p = 1 \\mod 4</span>. Let <span class="math">d \\geq 1</span> be such <span class="math">\\gcd(d, p - 1) = 1</span>, and let <span class="math">F(x) = x^d \\cdot L_p(x)</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb {F} _ {p} \\mid F (x + \\Delta_ {I}) - F (x) = \\Delta_ {O} \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left\\{ \\begin{array}{l l} \\frac {p + 1}{2} &amp; \\text{if } d = 1, \\\\ 4 \\cdot d &amp; \\text{otherwise.} \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The results follow from the previous analysis for the case <span class="math">F(x) = x^{d} \\cdot (L_{p}(x) + \\alpha)</span>. For completeness, we note that in order to study the differential properties of <span class="math">F(x) = x^{d} \\cdot L_{p}(x)</span>, in [Sze21] it is proposed to use the square operation in order to cancel the Legendre symbol that depends both on the input <span class="math">x</span> and on the input difference <span class="math">\\Delta_I</span>, since</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(x + \\Delta_ {I}\\right) ^ {d} \\cdot L _ {p} (x + \\Delta_ {I}) = x ^ {d} \\cdot L _ {p} (x) + \\Delta_ {O} \\\\ \\Longrightarrow \\left(x + \\Delta_ {I}\\right) ^ {2 d} = x ^ {2 d} + \\Delta_ {O} ^ {2} + 2 \\Delta_ {O} \\cdot L _ {p} (x) \\cdot x ^ {d}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In this way, assuming <span class="math">d \\geq 2</span> and <span class="math">x \\neq -\\Delta_I</span> (for which <span class="math">L_p(x + \\Delta_I) = 0 \\neq 1</span>), we get an equation of degree <span class="math">2d - 1</span>, which can have at most <span class="math">2d - 1</span> solutions. Since there are two nonzero values for <span class="math">L_p(x)</span>, we get again <span class="math">2 \\cdot (2d - 1) + 2 = 4d</span> solutions (one more solution could be <span class="math">x = 0</span>). However, half of these solutions are "false" solutions, i.e., they are not solutions of the original differential equation.</p>

    <h2 id="sec-25" class="text-2xl font-bold">4 New Permutations over <span class="math">\\mathbb{F}_p^n</span> via the Legendre Symbol and the Modulo-2 Operation</h2>

    <h2 id="sec-26" class="text-2xl font-bold">4.1 <span class="math">F(x) = x^{d_{+}} \\cdot (1 + L_{p}(x)) + x^{d_{-}} \\cdot (1 - L_{p}(x))</span></h2>

    <p class="text-gray-300"><strong>Proposition 5.</strong> Let <span class="math">p \\geq 3</span> be a prime integer. Let <span class="math">d_{+}, d_{-} \\geq 1</span> be integers such that <span class="math">\\gcd(d_{+}, p - 1) = \\gcd(d_{-}, p - 1) = 1</span>. Then, the function</p>

    <div class="my-4 text-center"><span class="math-block">F (x) = \\frac {x ^ {d _ {+}} \\cdot (1 + L _ {p} (x)) + x ^ {d _ {-}} \\cdot (1 - L _ {p} (x))}{2} = \\left\\{ \\begin{array}{l l} x ^ {d _ {+}} &amp;amp; \\text{if } L _ {p} (x) = 1, \\\\ x ^ {d _ {-}} &amp;amp; \\text{otherwise} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <p class="text-gray-300">is invertible over <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300">Proof. If <span class="math">d_{+} = d_{-} = d</span>, this is obvious, since it reduces to <span class="math">x \\mapsto x^{d}</span>. Assume <span class="math">d_{+} \\neq d_{-}</span>. Given <span class="math">2y = x^{d_{-}} \\cdot (1 - L_{p}(x)) + x^{d_{+}} \\cdot (1 + L_{p}(x))</span>, its inverse is</p>

    <div class="my-4 text-center"><span class="math-block">x = \\left\\{ \\begin{array}{l l} 0 &amp;amp; \\text{if } L_{p}(y) = y = 0, \\\\ y^{1/d_{-}} &amp;amp; \\text{if } L_{p}(y) = -1, \\\\ y^{1/d_{+}} &amp;amp; \\text{if } L_{p}(y) = 1, \\end{array} \\right. \\quad \\Longrightarrow \\quad 2x = (1 - L_{p}(y)) \\cdot y^{1/d_{-}} + (1 + L_{p}(y)) \\cdot y^{1/d_{+}},</span></div>

    <p class="text-gray-300">where note that <span class="math">L_{p}(x) = L_{p}(y)</span>. Indeed, <span class="math">x = 0</span> implies <span class="math">y = L_{p}(y) = 0</span> (and vice versa). If <span class="math">x, y \\neq 0</span> and <span class="math">L_{p}(x) = 1</span> (analogous for <span class="math">L_{p}(x) = -1</span>), then <span class="math">y = x^{d_{+}}</span>, which implies <span class="math">L_{p}(y) = L_{p}(x^{d_{+}}) = L_{p}(x)^{d_{+}} = L_{p}(x)</span> since <span class="math">d_{+}</span> is odd (similarly for <span class="math">x \\neq 0</span> and <span class="math">L_{p}(x) = -1</span>).</p>

    <p class="text-gray-300">Regarding its differential properties, it is not hard to see that its maximum differential probability is <span class="math">4 \\cdot \\max \\{d_{+}, d_{-}\\} / p</span>. Its linear properties are studied in Appendix A.2.</p>

    <p class="text-gray-300">Lemma 5. Let <span class="math">p \\geq 3</span> be a prime and let <span class="math">F(x) = \\frac{x^{d_{+}} \\cdot (1 + L_{p}(x)) + x^{d_{-}} \\cdot (1 - L_{p}(x))}{2}</span>, where <span class="math">d_{+} \\neq d_{-}</span>. For <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb{F}_{p} \\mid F(x + \\Delta_{I}) - F(x) = \\Delta_{O} \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4 \\cdot \\max \\{d_{+}, d_{-} \\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. First of all, if <span class="math">x = L_{p}(x) = 0</span>, then the equality <span class="math">F(x + \\Delta_{I}) - F(x) = \\Delta_{O}</span> is satisfied if and only if <span class="math">F(\\Delta_{I}) = \\Delta_{O}</span> (analogous for <span class="math">x = -\\Delta_{I}</span>).</p>

    <p class="text-gray-300">Let us consider <span class="math">x \\in \\mathbb{F}_p \\setminus \\{0, -\\Delta_I\\}</span>. The equality <span class="math">F(x + \\Delta_I) - F(x) = \\Delta_O</span> then corresponds to</p>

    <div class="my-4 text-center"><span class="math-block">(x + \\Delta_{I})^{d&#x27;} - x^{d&#x27;&#x27;} = \\Delta_{O},</span></div>

    <p class="text-gray-300">where <span class="math">d&#x27;, d&#x27;&#x27; \\in \\{d_{+}, d_{-}\\}</span> depending on <span class="math">L_{p}(x + \\Delta_{I}), L_{p}(x)</span>. As before,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">L_{p}(x) = L_{p}(x + \\Delta_{I}) \\in \\{-1, 1\\}</span>, the equation has degree either <span class="math">d_{+} - 1</span> or <span class="math">d_{-} - 1</span>, and it admits at most <span class="math">\\max \\{d_{+}, d_{-}\\} - 1</span> solutions, and</li>

      <li>if <span class="math">L_{p}(x) = -L_{p}(x + \\Delta_{I}) \\in \\{-1, 1\\}</span>, the equation has degree either <span class="math">d_{+}</span> or <span class="math">d_{-}</span>, and it admits at most <span class="math">\\max \\{d_{+}, d_{-}\\}</span> solutions.</li>

    </ul>

    <p class="text-gray-300">It follows that its maximum differential probability is equal to <span class="math">(2 + 2 \\cdot (\\max \\{d_{+}, d_{-}\\} - 1) + 2 \\cdot \\max \\{d_{+}, d_{-}\\}) / p = (4 \\cdot \\max \\{d_{+}, d_{-}\\}) / p</span>.</p>

    <p class="text-gray-300">Multiplicative Complexity and Side-Channel Attacks. Even though the function just given is invertible, it has some undesirable properties for cryptographic purposes. Depending on the value of <span class="math">x</span>, the number of multiplications required to compute <span class="math">x \\mapsto x^{d_{+}} \\cdot (1 + L_{p}(x)) + x^{d_{-}} \\cdot (1 - L_{p}(x))</span> varies. Besides making cost estimations difficult (i.e., the scheme can either be efficient or expensive), this may allow to set up side-channel attacks [Koc96,KJJ99] (i.e., attacks exploiting the leakage of information from a physical cryptosystem). For this reason, we do not encourage its use.</p>

    <h2 id="sec-27" class="text-2xl font-bold">4.2 Permutations over <span class="math">\\mathbb{F}_p</span> via the Modulo-2 Operation</h2>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.2.1 <span class="math">F(x) = \\alpha^{(x \\mod 2)} \\cdot x^2</span></h3>

    <p class="text-gray-300">As we have seen before, the quadratic power function <span class="math">x \\mapsto x^2</span> is never a PP over <span class="math">\\mathbb{F}_p</span> for <span class="math">p \\geq 3</span>. Here we present a variant of this function that is a permutation, and that is defined via the modulo-2 operation.</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">Theorem 4. Let <span class="math">p \\geq 3</span> be a prime number. Let <span class="math">\\alpha \\in \\mathbb{F}_p</span> be a quadratic non-residue modulo <span class="math">p</span>, as defined in Definition 1. The function <span class="math">F</span>, defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x) = \\alpha^{(x \\mod 2)} \\cdot x^2 = \\begin{cases} x^2 &amp;amp; \\text{if } x = 0 \\mod 2, \\\\ \\alpha \\cdot x^2 &amp;amp; \\text{if } x = 1 \\mod 2, \\end{cases}</span></div>

    <p class="text-gray-300">is a permutation over <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300">The function also admits an equivalent representation via <span class="math">x \\mapsto (-1)^x</span> instead of the modulo-2 operation, that is,</p>

    <div class="my-4 text-center"><span class="math-block">F(x) = \\left(\\frac{\\alpha \\cdot (1 - (-1)^x) + 1 + (-1)^x}{2}\\right) \\cdot x^2.</span></div>

    <p class="text-gray-300">Proof. We prove that the function is injective (that is, <span class="math">F(x) = F(y)</span> implies <span class="math">x = y</span>). Then, since it is defined over a finite field, it follows that the function is invertible.</p>

    <p class="text-gray-300">First of all, note that there is no <span class="math">x, y \\in \\mathbb{F}_p \\setminus \\{0\\}</span> such that <span class="math">\\alpha \\cdot x^2 = y^2</span>. Indeed, <span class="math">\\alpha \\cdot x^2</span> is a quadratic non-residue modulo <span class="math">p</span> (since <span class="math">L_p(\\alpha \\cdot x^2) = L_p(\\alpha) \\cdot L_p(x^2) = L_p(\\alpha) = -1</span>), while <span class="math">y^2</span> is a quadratic residue modulo <span class="math">p</span>. It follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(x \\mod 2)} \\cdot x^2 = \\alpha^{(y \\mod 2)} \\cdot y^2 \\quad \\Longrightarrow \\quad x \\mod 2 = y \\mod 2.</span></div>

    <p class="text-gray-300">Hence, only two scenarios can occur, either <span class="math">x^2 = y^2</span> or <span class="math">\\alpha \\cdot x^2 = \\alpha \\cdot y^2</span>. In both cases, the only solutions are <span class="math">x = \\pm y</span>. Note that</p>

    <div class="my-4 text-center"><span class="math-block">x = 0 \\mod 2 \\quad \\text{if and only if} \\quad -x = 1 \\mod 2,</span></div>

    <p class="text-gray-300">since <span class="math">-x = p - x</span>, where <span class="math">p</span> is odd. In conclusion, <span class="math">F(x) = F(y)</span> implies <span class="math">x = y</span> (<span class="math">x = -y</span> is not possible since the condition <span class="math">x \\mod 2 = y \\mod 2</span> is not satisfied).</p>

    <p class="text-gray-300">Before going on, we study the case <span class="math">\\alpha = -1</span> in more detail.</p>

    <p class="text-gray-300">Corollary 3. Let <span class="math">p \\geq 3</span> be a prime number such that <span class="math">p = 3 \\mod 4</span>. The function <span class="math">F(x) = (-1)^x \\cdot x^2</span> is a permutation over <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300">Proof. This is a direct application of Theorem 4, where <span class="math">-1</span> is a quadratic non-residue modulo <span class="math">p</span> if and only if <span class="math">p = 3 \\mod 4</span> (see Proposition 1) and where <span class="math">(-1)^x = (-1)^{(x \\mod 2)}</span>, since <span class="math">(x \\mod 2) \\mod (p - 1) = (x \\mod (p - 1)) \\mod 2</span> for each <span class="math">x \\in \\{0, 1, 2, \\ldots, p - 1\\}</span> (remember that the exponent is modulo <span class="math">p - 1</span>).</p>

    <p class="text-gray-300">Differential Property. Here we study the differential properties of the permutation just proposed. The linear ones can be found in Appendix A.3.</p>

    <p class="text-gray-300">Lemma 6. Let <span class="math">p \\geq 3</span> be a prime number, and let <span class="math">\\alpha \\in \\mathbb{F}_p</span> be such that <span class="math">L_p(\\alpha) = -1</span>. Let <span class="math">F(x) = (\\alpha)^{x \\mod 2} \\cdot x^2</span>. For each <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb{F}_p \\mid F(x + \\Delta_I) - F(x) = \\Delta_O \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 6.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Given <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>, we analyze the number of solutions <span class="math">x</span> of</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{((x + \\Delta_I) \\mod 2)} \\cdot (x + \\Delta_I)^2 - \\alpha^{(x \\mod 2)} \\cdot x^2 = \\Delta_O</span></div>

    <p class="text-gray-300">by separately studying the cases <span class="math">\\alpha^{((x + \\Delta_I) \\mod 2)} = \\alpha^{(x \\mod 2)}</span> and <span class="math">\\alpha^{((x + \\Delta_I) \\mod 2)} \\neq \\alpha^{(x \\mod 2)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\alpha^{((x + \\Delta_I) \\mod 2)} = \\alpha^{(x \\mod 2)}</span>, the equation admits at most two solutions, i.e.,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in \\{0, 1\\}: \\quad x = \\frac{\\Delta_O - \\Delta_I^2 \\cdot (\\alpha)^k}{2 \\Delta_I \\cdot (\\alpha)^k}.</span></div>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\alpha^{((x + \\Delta_I) \\mod 2)} \\neq \\alpha^{(x \\mod 2)}</span>, the equation admits at most four solutions, i.e., at most two for <span class="math">(\\alpha - 1) \\cdot x^2 + 2\\alpha \\cdot \\Delta_I \\cdot x + \\alpha \\cdot \\Delta_I^2 = \\Delta_O</span> and at most two for <span class="math">(1 - \\alpha) \\cdot x^2 + 2\\Delta_I \\cdot x + \\Delta_I^2 = \\Delta_O</span>.</li>

    </ul>

    <p class="text-gray-300">Hence, the total number of solutions is at most six.</p>

    <p class="text-gray-300"><strong>Algebraic Property.</strong> Regarding the algebraic properties, we first prove the following.</p>

    <p class="text-gray-300"><strong>Proposition 6.</strong> Let <span class="math">p \\geq 3</span> be a prime number, and let <span class="math">\\alpha \\in \\mathbb{F}_p</span> be such that <span class="math">L_p(\\alpha) = -1</span>. There exist <span class="math">\\varphi_1, \\varphi_3, \\ldots, \\varphi_{p-2} \\in \\mathbb{F}_p</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha^{(x \\mod 2)} \\cdot x^2 = \\frac{1 + \\alpha}{2} \\cdot x^2 + \\sum_{i=0}^{(p-3)/2} \\varphi_{2i+1} \\cdot x^{2i+1}.</span></div>

    <p class="text-gray-300">Moreover, <span class="math">\\sum_{i=0}^{(p-3)/2} \\varphi_{2i+1} = \\frac{\\alpha - 1}{2}</span>.</p>

    <p class="text-gray-300">Note that if <span class="math">\\alpha = -1</span>, then <span class="math">\\frac{1 + \\alpha}{2} = 0</span>. It follows that <span class="math">F(x) = (-1)^x \\cdot x^2</span> (for <span class="math">p = 3 \\mod 4</span>) is an odd function.</p>

    <p class="text-gray-300"><strong>Proof.</strong> In order to prove the result, it is sufficient to show that <span class="math">F(x) - \\frac{1 + \\alpha}{2} \\cdot x^2 = \\alpha^{(x \\mod 2)} \\cdot x^2 - \\frac{1 + \\alpha}{2} \\cdot x^2</span> is an odd function. We recall that a function <span class="math">G</span> is odd if and only if <span class="math">G(-x) = -\\tilde{G}(x)</span> for each <span class="math">x \\in \\mathbb{F}_p</span>. In our case, the equality</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F(-x) - \\frac{1 + \\alpha}{2} \\cdot (-x)^2 = \\left(\\alpha^{(-x \\mod 2)} - \\frac{1 + \\alpha}{2}\\right) \\cdot (-x)^2 \\\\ = - \\left(\\alpha^{(x \\mod 2)} - \\frac{1 + \\alpha}{2}\\right) \\cdot x^2 = - \\left(F(x) - \\frac{1 + \\alpha}{2} \\cdot x^2\\right) \\end{array}</span></div>

    <p class="text-gray-300">is always satisfied since <span class="math">x \\mod 2 = 0</span> if and only if <span class="math">-x \\mod 2 = 1</span>. Hence, <span class="math">1 - \\frac{1 + \\alpha}{2} = \\frac{1 - \\alpha}{2} = -\\frac{\\alpha - 1}{2} = -\\alpha + \\frac{1 + \\alpha}{2}</span>. Finally, <span class="math">\\sum_{i=0}^{(p-3)/2} \\varphi_{2i+1} = F(1) - \\frac{1 + \\alpha}{2} = \\frac{\\alpha - 1}{2}</span>.</p>

    <p class="text-gray-300">By practical experiments, we found that <span class="math">F(x) = \\alpha^{(x \\mod 2)} \\cdot x^2</span> (where <span class="math">L_p(\\alpha) = -1</span>) and its inverse are functions of maximum degree. For their density, we found the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fig. 3 for <span class="math">\\alpha = -1</span> (hence, <span class="math">p = 3 \\mod 4</span>): <span class="math">F(x) = (-1)^x \\cdot x^2</span> is an odd function, as expected.</li>

      <li>Fig. 4 for <span class="math">\\alpha = 2</span> (hence, <span class="math">p = 3,5 \\mod 8</span>) and Fig. 5 for <span class="math">\\alpha = -3</span> (hence, <span class="math">p = 2 \\mod 3</span>): We found that <span class="math">F(x)</span> is of the form <span class="math">\\varphi_2 \\cdot x^2 + \\sum_{i \\geq 0} \\varphi_{2i+1} \\cdot x^{2i+1}</span>, as expected.</li>

    </ul>

    <h2 id="sec-29" class="text-2xl font-bold">4.2.2 <span class="math">F(x) = x \\cdot (1 - 2 \\cdot (x^2 \\mod 2))</span></h2>

    <p class="text-gray-300">A function based on the modulo-2 operation that is always invertible for each <span class="math">p</span> is <span class="math">F(x) = x \\cdot (1 - 2 \\cdot (x^2 \\mod 2))</span>.</p>

    <p class="text-gray-300"><strong>Proposition 7.</strong> Let <span class="math">p \\geq 3</span> be a prime number. The function</p>

    <div class="my-4 text-center"><span class="math-block">F(x) = x \\cdot (1 - 2 \\cdot (x^2 \\mod 2)) \\equiv (-1)^{x^2} \\cdot x</span></div>

    <p class="text-gray-300">is invertible over <span class="math">\\mathbb{F}_p</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Note that <span class="math">1 - 2 \\cdot (x^2 \\mod 2) \\in \\{-1,1\\}</span> for each <span class="math">x \\in \\mathbb{F}_p</span>. Hence, given <span class="math">y = F(x) = x \\cdot (1 - 2 \\cdot (x^2 \\mod 2))</span>, note that <span class="math">y^2 = x^2</span>. Thus, <span class="math">x = y \\cdot (1 - 2 \\cdot (y^2 \\mod 2))</span>.</p>

    <p class="text-gray-300"><strong>Corollary 4.</strong> Let <span class="math">p \\geq 3</span> be a prime, and let <span class="math">d \\geq 1</span> such that <span class="math">\\gcd(d, p - 1) = 1</span>. Then <span class="math">F(x) = (-1)^{x^2} \\cdot x^d</span> is invertible.</p>

    <p class="text-gray-300">Observe that <span class="math">d</span> is odd and <span class="math">(-1)^{x^2} \\cdot x^d = ((-1)^{x^2} \\cdot x)^d</span>, since <span class="math">(\\pm 1)^d = \\pm 1</span> for each odd <span class="math">d</span>.</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Comparison of the number of monomials for a generic odd function and for  <span class="math">F(x) = (-1)^{x} \\cdot x^{2}</span>  for several values of  <span class="math">p</span> .</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Comparison of the number of monomials for a generic function (with zero constant) and for  <span class="math">F(x) = 2^{(x \\mod 2)} \\cdot x^2</span>  for several values of  <span class="math">p</span> .</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: Comparison of the number of monomials for a generic function (with zero-constant) and for  <span class="math">F(x) = (-3)^{(x \\mod 2)} \\cdot x^2</span>  for several values of  <span class="math">p</span> .</p>

    <p class="text-gray-300">Differential Property. Here we study the differential properties of the permutation just proposed. The linear ones can be found in Appendix A.4.</p>

    <p class="text-gray-300">Lemma 7. Let  <span class="math">p \\geq 3</span>  be a prime number and let  <span class="math">F(x) = (-1)^{x^2} \\cdot x</span> . For each  <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb {F} _ {p} \\mid F (x + \\Delta_ {I}) - F (x) = \\Delta_ {O} \\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left\\{ \\begin{array}{l l} 0 &amp; \\text {if} \\Delta_ {I} ^ {2} = 0 \\mod 2 \\text {and} \\Delta_ {I} \\neq \\pm \\Delta_ {O}, \\\\ \\frac {p + 1}{2} &amp; \\text {if} \\Delta_ {I} ^ {2} = 0 \\mod 2 \\text {and} \\Delta_ {I} = \\pm \\Delta_ {O}, \\\\ 2 &amp; \\text {otherwise}. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <p class="text-gray-300">Proof. Given <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>, we analyze the number of solutions <span class="math">x</span> of <span class="math">(-1)^{(x + \\Delta_I)^2} \\cdot (x + \\Delta_I) - (-1)^{x^2} \\cdot x = \\Delta_O</span>, that is,</p>

    <div class="my-4 text-center"><span class="math-block">x \\cdot ((-1)^{\\Delta_I^2} - 1) = (-1)^{x^2} \\cdot \\Delta_O - (-1)^{\\Delta_I^2} \\cdot \\Delta_I.</span></div>

    <p class="text-gray-300">Let us consider the cases <span class="math">\\Delta_I^2 = 1 \\mod 2</span> and <span class="math">\\Delta_I^2 = 0 \\mod 2</span> separately.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\Delta_I^2 = 1 \\mod 2</span>, we have <span class="math">x = -\\frac{(-1)^{x^2} \\cdot \\Delta_O + \\Delta_I}{2}</span>, which admits at most two possible solutions, that is, <span class="math">-\\frac{\\Delta_I \\pm \\Delta_O}{2}</span>.</li>

      <li>If <span class="math">\\Delta_I^2 = 0 \\mod 2</span>, we have <span class="math">(-1)^{x^2} \\cdot \\Delta_O = \\Delta_I</span>, which admits a solution if and only if <span class="math">\\Delta_I = \\pm \\Delta_O</span>. In this case, there are at most <span class="math">(p + 1)/2</span> solutions (since <span class="math">x^2</span> can take at most <span class="math">(p + 1)/2</span> different values).</li>

    </ul>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Lemma 8. Let <span class="math">p \\geq 3</span> be a prime number and let <span class="math">d \\geq 3</span> be such that <span class="math">\\gcd(d, p - 1) = 1</span>. Let <span class="math">F(x) = (-1)^{x^2} \\cdot x^d</span>. For each <span class="math">\\Delta_I, \\Delta_O \\in \\mathbb{F}_p \\setminus \\{0\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb{F}_p \\mid F(x + \\Delta_I) - F(x) = \\Delta_O \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 4d - 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. We are looking for the number of solutions of <span class="math">(-1)^{(x + \\Delta_I)^2} \\cdot (x + \\Delta_I)^d - (-1)^{x^2} \\cdot x^d = \\Delta_O</span>. Hence,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(-1)^{(x + \\Delta_I)^2} = (-1)^{x^2}</span>, we have at most <span class="math">2(d - 1)</span> solutions, that is, <span class="math">d - 1</span> for the case <span class="math">(-1)^{x^2} = 1</span> and <span class="math">d - 1</span> for the case <span class="math">(-1)^{x^2} = -1</span>,</li>

      <li>otherwise, we have at most <span class="math">2d</span> solutions.</li>

    </ul>

    <p class="text-gray-300">As a result, the total number of solutions is at most <span class="math">4d - 2</span>.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Algebraic Property (Case: <span class="math">d = 1</span>). Regarding the algebraic properties, we first point out that the function <span class="math">F(x) = (-1)^{x^2} \\cdot x</span> (and its inverse) is an odd function. Indeed, <span class="math">F(-x) = (-1)^{(-x)^2} \\cdot (-x) = -(-1)^{x^2} \\cdot x = -F(x)</span>. By practical experiments (see Fig. 6), it turns out that both this function and its inverse are of maximum degree, but they are dense only for some values of <span class="math">p</span>. In particular, if <span class="math">p = 3 \\mod 4</span> (for which <span class="math">L_p(-1) = -1</span>), the algebraic representation of <span class="math">F(x) = (-1)^{x^2} \\cdot x</span> is dense. Vice versa, if <span class="math">p = 1 \\mod 4</span> (for which <span class="math">L_p(-1) = 1</span>), we found that</p>

    <div class="my-4 text-center"><span class="math-block">(-1)^{x^2} \\cdot x = \\sum_{i=0}^{(p-5)/4} \\gamma_{4 \\cdot i+3} \\cdot x^{4 \\cdot i+3} \\tag{5}</span></div>

    <p class="text-gray-300">for certain <span class="math">\\gamma_3, \\gamma_7, \\ldots, \\gamma_{p-2} \\in \\mathbb{F}_p</span>, that is, the monomials with exponents <span class="math">4 \\cdot i + 1</span> do not appear. For example, the function <span class="math">F(x) = (-1)^{x^2} \\cdot x</span> is equal to <span class="math">-x^{(p+1)/2} \\equiv -x \\cdot L_p(x)</span> for <span class="math">p \\in \\{5, 13\\}</span>. We leave the problem to formally prove Eq. (5) for future work.</p>

    <h2 id="sec-30" class="text-2xl font-bold">4.3 Nonlinear Layer over <span class="math">\\mathbb{F}_p^n</span> via a Local Map</h2>

    <p class="text-gray-300">A nonlinear function <span class="math">\\mathcal{F}</span> over <span class="math">\\mathbb{F}_p^n</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{F}(x_0, x_1, \\dots, x_{n-1}) = y_0 \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_1 \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{n-1}, \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">y_i = F_i(x_0, x_1, \\dots, x_{n-1})</span></div>

    <p class="text-gray-300">for <span class="math">n</span> (potentially different) nonlinear functions <span class="math">F_i: \\mathbb{F}_p^n \\to \\mathbb{F}_p</span> for <span class="math">i \\in \\{0, 1, \\dots, n-1\\}</span>. Here, we limit ourselves to focus on the case in which the functions <span class="math">F_i</span> are defined as <span class="math">F_i(\\cdot) = F \\circ \\mathcal{T}(\\cdot, i)</span>, where</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: Comparison of the number of monomials for a generic odd function and for  <span class="math">F(x) = (-1)^{x^2} \\cdot x</span>  for several values of  <span class="math">p</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">F</span>  is a local map of the form  <span class="math">F:\\mathbb{F}_p^m\\to \\mathbb{F}_p</span>  for a certain  <span class="math">m</span>  of the form  <span class="math">2\\leq m\\leq n</span></li>

      <li><span class="math">\\mathcal{T}(\\cdot, i)</span>  is a translation function  <span class="math">\\mathcal{T}: \\mathbb{F}_p^n \\times \\{0, 1, \\ldots, n - 1\\} \\to \\mathbb{F}_p^m</span>  defined as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {T} (x, i) = x _ {i} \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {i + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {i + m - 1},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the indices are computed modulo  <span class="math">n</span> .</p>

    <p class="text-gray-300">We describe it more formally in the following.</p>

    <p class="text-gray-300">Definition 5. Let  <span class="math">p \\geq 3</span>  be a prime integer. Let  <span class="math">1 \\leq m \\leq n</span>  and let  <span class="math">F: \\mathbb{F}_p^m \\to \\mathbb{F}_p</span>  be a nonlinear function. The function  <span class="math">S</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {F} \\left(x _ {0}, x _ {1}, \\dots , x _ {n - 1}\\right) := y _ {0} \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y _ {1} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y _ {n - 1}, \\right. \\tag {6}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">y _ {i} = F \\left(x _ {i}, x _ {i + 1}, \\dots , x _ {i + m - 1}\\right) \\tag {7}</span></div>

    <p class="text-gray-300">for each  <span class="math">i\\in \\{0,1,\\ldots ,n - 1\\}</span> , where the subindices are taken modulo  <span class="math">n</span> .</p>

    <p class="text-gray-300">As already mentioned in the introduction, probably one of the most well-known examples of invertible functions of this form over  <span class="math">\\mathbb{F}_2^n</span>  (for odd  <span class="math">n</span> ) is the  <span class="math">\\chi</span> -function [Wol85, DGV92, Dae95], whose local map is  <span class="math">F(x_0, x_1, x_2) = x_1 \\cdot x_2 + x_0 + x_2</span> .</p>

    <p class="text-gray-300">Examples: Generalization of  <span class="math">F(x) = x^{d} \\cdot (L_{p}(x) + \\alpha)</span>  and of  <span class="math">F(x) = (-1)^{x^2} \\cdot x^d</span> .</p>

    <p class="text-gray-300">Lemma 9. Given a prime number  <span class="math">p \\geq 3</span> , let  <span class="math">d \\geq 1</span>  be such that  <span class="math">\\gcd(d, p - 1) = 1</span> . Let  <span class="math">\\alpha \\in \\mathbb{F}_p \\setminus \\{\\pm 1\\}</span>  such that  <span class="math">L_p(\\alpha^2 - 1) = 1</span> . Let  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  be defined as  <span class="math">F(x_0, x_1) = x_0^d \\cdot (\\alpha + L_p(x_1))</span> . The function  <span class="math">S</span>  over  <span class="math">\\mathbb{F}_p^n</span>  defined as in Definition 5 is invertible.</p>

    <p class="text-gray-300">Proof. The proof is equivalent to the one given for Proposition 3. Given  <span class="math">y_{i} = F(x_{i},x_{i + 1})</span> , we get  <span class="math">L_{p}(y_{i}) = L_{p}(x_{i})\\cdot L_{p}(\\alpha \\pm 1)</span> , or equivalently  <span class="math">L_{p}(x_{i}) = \\frac{L_{p}(y_{i})}{L_{p}(\\alpha\\pm 1)}</span> , which implies  <span class="math">x_{i} = \\frac{y_{i}\\cdot L_{p}(\\alpha\\pm 1)}{L_{p}(\\alpha\\pm 1)\\cdot\\alpha + L_{p}(y_{i + 1})}</span> .</p>

    <p class="text-gray-300">In a similar way, we get the following.</p>

    <p class="text-gray-300">Lemma 10. Given a prime number  <span class="math">p \\geq 3</span>  and  <span class="math">d \\geq 1</span>  such that  <span class="math">\\gcd(d, p - 1) = 1</span> , let  <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span>  be defined as  <span class="math">F(x_0, x_1) = (-1)^{x_0^2} \\cdot x_1^d</span> . The function  <span class="math">S</span>  over  <span class="math">\\mathbb{F}_p^n</span>  defined as in Definition 5 is invertible.</p>

    <p class="text-gray-300">The proof is similar to the one given for Proposition 7.</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <h2 id="sec-31" class="text-2xl font-bold">4.3.1 <span class="math">F(x_0, x_1) = x_0 \\cdot (x_1 \\cdot (1 + L_p(x_1)) + (1 - L_p(x_1)))</span></h2>

    <p class="text-gray-300"><strong>Proposition 8.</strong> Let <span class="math">p \\geq 3</span> be a prime number such that <span class="math">p = 3 \\mod 4</span>. Let <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span> be defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1) = x_0 \\cdot \\big(x_1 \\cdot (1 + L_p(x_1)) + (1 - L_p(x_1)\\big) = \\begin{cases} 2 \\cdot x_0 &amp;amp; \\text{if } L_p(x_1) = -1, \\\\ x_0 &amp;amp; \\text{if } x_1 = 0, \\\\ 2 \\cdot x_0 \\cdot x_1 &amp;amp; \\text{if } L_p(x_1) = 1. \\end{cases}</span></div>

    <p class="text-gray-300">The function <span class="math">\\mathcal{S}</span> over <span class="math">\\mathbb{F}_p^n</span> defined as in Definition 5 is invertible for each odd <span class="math">n \\geq 3</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Given <span class="math">\\mathcal{S}(x) = y</span>, we recursively construct the inverse <span class="math">x \\in \\mathbb{F}_p^n</span>. First, note that <span class="math">\\mathcal{S}(x) = 0 \\in \\mathbb{F}_p^n</span> if and only if <span class="math">x = 0 \\in \\mathbb{F}_p^n</span>, since <span class="math">F(x_0, x_1) = 0</span> if and only if <span class="math">x_0 = 0</span>. We consider the following two cases separately:</p>

    <p class="text-gray-300">(1) <span class="math">\\exists i \\in \\{0, 1, \\ldots, n-1\\}</span> such that <span class="math">y_i = 0</span>, and (2) <span class="math">y_i \\neq 0</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>.</p>

    <p class="text-gray-300">Given <span class="math">y_i = 0</span>, one can immediately deduce that <span class="math">x_i = 0</span> due to the argument just provided. By working recursively for each <span class="math">j &amp;lt; i</span>,</p>

    <div class="my-4 text-center"><span class="math-block">x_j = \\begin{cases} y_j &amp;amp; \\text{if } x_{j+1} = y_{j+1} = 0, \\\\ \\dfrac{y_j}{x_{j+1} \\cdot (1 + L_p(x_{j+1})) + (1 - L_p(x_{j+1}))} &amp;amp; \\text{otherwise}, \\end{cases} \\tag{8}</span></div>

    <p class="text-gray-300">where all subindices are taken modulo <span class="math">n</span>.</p>

    <p class="text-gray-300">In the second case, assume that <span class="math">y_i \\neq 0</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>. Note that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{0, 1, \\ldots, n-1\\} : \\quad L_p(x_i) = (L_p(2))^{-1} \\cdot L_p(y_i) = L_p(2) \\cdot L_p(y_i) = L_p(2 \\cdot y_i),</span></div>

    <p class="text-gray-300">where <span class="math">(L_p(z))^{-1} = L_p(z)</span> for each <span class="math">z \\neq 0</span>. Indeed, since <span class="math">x_i \\neq 0</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">L_p(x_{i+1}) = -1</span>, then <span class="math">y_i = 2 \\cdot x_i</span>, which implies <span class="math">L_p(x_i) = (L_p(2))^{-1} \\cdot L_p(y_i)</span>, and</li>

      <li>if <span class="math">L_p(x_{i+1}) = 1</span>, then <span class="math">y_i = 2 \\cdot x_i \\cdot x_{i+1}</span>, which implies <span class="math">L_p(x_i) = (L_p(2))^{-1} \\cdot L_p(y_i) \\cdot (L_p(x_{i+1}))^{-1} = L_p(x_i) = (L_p(2))^{-1} \\cdot L_p(y_i)</span>.</li>

    </ul>

    <p class="text-gray-300">This means that</p>

    <div class="my-4 text-center"><span class="math-block">y_i = x_i \\cdot (x_{i+1} \\cdot (1 + L_p(2 \\cdot y_{i+1})) + (1 - L_p(2 \\cdot y_{i+1})).</span></div>

    <p class="text-gray-300">Again, we have to consider two cases:</p>

    <p class="text-gray-300">(2.a) <span class="math">\\exists i \\in \\{0,1,\\ldots,n-1\\}</span> such that <span class="math">L_p(2 \\cdot y_{i+1}) = -1</span>, and (2.b) <span class="math">L_p(2 \\cdot y_i) = 1</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>.</p>

    <p class="text-gray-300">In the first case, if there exists <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span> such that <span class="math">L_p(2 \\cdot y_{i+1}) = -1</span>, then <span class="math">x_i = y_i / 2</span>. Given <span class="math">x_{i-1}</span>, it is then possible to find all <span class="math">x_j</span> working recursively as in Eq. (8).</p>

    <p class="text-gray-300">Vice versa, assume that <span class="math">L_p(2 \\cdot y_i) = 1</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>. In such a case, we have that <span class="math">y_i = 2 \\cdot x_i \\cdot x_{i+1}</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>. Working recursively with <span class="math">x_i = \\frac{y_i}{2 \\cdot x_{i+1}}</span> and since <span class="math">n</span> is odd, we have that</p>

    <div class="my-4 text-center"><span class="math-block">x_0^2 = \\frac{1}{2} \\cdot \\prod_{j=0}^{n-1} y_i^{(-1)^i} \\quad \\Longrightarrow \\quad x_0 = \\sigma \\cdot \\left(\\frac{1}{2} \\cdot \\prod_{j=0}^{n-1} y_i^{(-1)^i}\\right)^{(p+1)/4},</span></div>

    <p class="text-gray-300">where <span class="math">\\sigma \\in \\{-1, +1\\}</span>. Note that <span class="math">z^{(p+1)/4}</span> is the square root of the quadratic residue <span class="math">z</span> modulo <span class="math">p</span> since <span class="math">p = 3 \\mod 4</span> (see Proposition 1 for details). The value of <span class="math">\\sigma</span> must satisfy <span class="math">L_p(x_0) = L_p(2 \\cdot y_0) = 1</span> (since we are in the case in which <span class="math">L_p(2 \\cdot y_i) = 1</span> for each <span class="math">i \\in \\{0, 1, \\ldots, n-1\\}</span>). Note that <span class="math">L_p(-z) = -L_p(z)</span> for each <span class="math">z \\in \\mathbb{F}_p</span> since <span class="math">p = 3 \\mod 4</span>, which means that <span class="math">\\sigma</span> is uniquely defined. Finally, given <span class="math">x_0</span>, it is then possible to find all <span class="math">x_j</span> working recursively as before.</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <h2 id="sec-32" class="text-2xl font-bold">4.3.2 <span class="math">F(x_0, x_1) = x_0 \\cdot (1 + x_1^2 - x_1^{p-1})</span></h2>

    <p class="text-gray-300"><strong>Proposition 9.</strong> Let <span class="math">p \\geq 3</span> be a prime number. Let <span class="math">F: \\mathbb{F}_p^2 \\to \\mathbb{F}_p</span> be defined as</p>

    <div class="my-4 text-center"><span class="math-block">F(x_0, x_1) = x_0 \\cdot (1 + x_1^2 - x_1^{p-1}) = \\begin{cases} x_0 &amp;amp; \\text{if } x_1 = 0, \\\\ x_0 \\cdot x_1^2 &amp;amp; \\text{otherwise}. \\end{cases}</span></div>

    <p class="text-gray-300">The function <span class="math">\\mathcal{S}</span> over <span class="math">\\mathbb{F}_p^n</span> defined as in Definition 5 is invertible for each <span class="math">n \\geq 2</span> such that <span class="math">\\gcd(2^n - (-1)^n, p - 1) = 1</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\left(L_p(x_1)\\right)^2 = x_1^{p-1}</span> for each <span class="math">x_1 \\in \\mathbb{F}_p</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> First of all, note that <span class="math">\\mathcal{S}(x) = 0 \\in \\mathbb{F}_p^n</span> if and only if <span class="math">x = 0 \\in \\mathbb{F}_p^n</span>. Given <span class="math">y \\in \\mathbb{F}_p^3</span>, we show how to compute <span class="math">x \\in \\mathbb{F}_p^3</span> s.t. <span class="math">\\mathcal{S}(x) = y</span>. For doing this, we consider the two following cases separately:</p>

    <p class="text-gray-300">(1) <span class="math">\\exists i \\in \\{0, 1, \\ldots, n-1\\}</span> such that <span class="math">y_i = 0</span>, and (2) <span class="math">y_i \\neq 0</span> for each <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span>.</p>

    <p class="text-gray-300">In the first case, assume that there exists <span class="math">i \\in \\{0, 1, \\ldots, n-1\\}</span> such that <span class="math">y_i = 0</span>. By definition of <span class="math">F</span>, it follows that <span class="math">x_i = 0</span> and that <span class="math">x_{i-1} = y_{i-1}</span>. Working recursively for each <span class="math">j &amp;lt; i</span>, we have <span class="math">x_j = y_j / (1 + x_{j+1}^2 - x_{j+1}^{p-1})</span>, where the subindices are taken modulo <span class="math">n</span>.</p>

    <p class="text-gray-300">In the second case, let us consider the cases when <span class="math">n</span> is even and when <span class="math">n</span> is odd separately. Given <span class="math">n = 2n&#x27; + 1</span> odd, by simple computation, note that</p>

    <div class="my-4 text-center"><span class="math-block">x_i^{2^{n} + 1} = \\frac{y_i \\cdot y_{i+2}^4 \\cdot y_{i+4}^{16} \\cdot \\ldots \\cdot y_{i+n-1}^{2^{n-1}}}{y_{i+1}^2 \\cdot y_{i+3}^8 \\cdot y_{i+5}^{32} \\cdot \\ldots \\cdot y_{i+n-2}^{2^{n-2}}} = \\prod_{j=0}^{n-1} (y_{i+j})^{(-2)^j},</span></div>

    <p class="text-gray-300">since <span class="math">y_i = x_i \\cdot x_{i+1}^2</span> for each <span class="math">i \\in \\{0, 1, \\ldots, n-1\\}</span>, where the subindices are again taken modulo <span class="math">n</span>. If <span class="math">x \\mapsto x^{2^n + 1}</span> is a permutation, then it is possible to find <span class="math">x_i</span>. Given <span class="math">x_i</span>, it is possible to find <span class="math">x_j</span> for each <span class="math">j</span> as before.</p>

    <p class="text-gray-300">Working in a similar way for <span class="math">n = 2n&#x27;</span> even, the function is invertible if <span class="math">x \\mapsto x^{2^n - 1}</span> is a permutation. It follows that the function is invertible if <span class="math">\\gcd(2^n - (-1)^n, p - 1) = 1</span>.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5 Preimage Attack on Full Grendel</h2>

    <p class="text-gray-300">In this section, we present a preimage attack on a sponge hash function instantiated with the full Grendel permutation and a new Gröbner basis analysis based on the same ideas. The code for the practical verification of the proposed attack is available online.<span class="math">^1</span></p>

    <h2 id="sec-34" class="text-2xl font-bold">5.1 High-Level Idea of the Attack</h2>

    <p class="text-gray-300"><strong>Security Analysis given in [Sze21].</strong> We first start by recalling the security analysis given in [Sze21]. One advantage of using a function based on the Legendre symbol is that the corresponding scheme reaches its maximum degree after only a small number of rounds, which, together with density, helps against interpolation attacks. The main algebraic attack then becomes the Gröbner basis one recalled in Section 2.3.2. In [Sze21], it is proposed to set up the equation system to solve in two different ways, namely</p>

    <p class="text-gray-300">(1) working at round level without guessing the Legendre symbols, or (2) first guessing the Legendre symbols and then working at round level.</p>

    <p class="text-gray-300"><span class="math">^1</span>https://github.com/mschof/grendel-analysis</p>

    <p class="text-gray-300">Regarding the first strategy, it is proposed to rewrite <span class="math">x\\mapsto y=x\\cdot L_{p}(x)</span> as</p>

    <p class="text-gray-300"><span class="math">(\\psi-1)\\cdot y=(x-z^{2})-(\\psi\\cdot x-z^{2})\\qquad\\text{ and }\\qquad(x-z^{2})\\cdot(\\psi\\cdot x-z^{2})=0,</span></p>

    <p class="text-gray-300">where <span class="math">z</span> represents the inverse of a square root of <span class="math">\\psi\\cdot x</span> and is introduced as a helper variable. We refer to <em>[x27, Section 5.4]</em> for more details.</p>

    <p class="text-gray-300">In the second strategy, the attacker simply guesses all the Legendre symbols of the scheme. For each guess, they solve the corresponding system of equations and then determine if the guesses are correct using the obtained solution. The complexity of this attack hence increases by factor of around <span class="math">2</span> for each Legendre symbol, since guessing it correctly has a probability of around <span class="math">1/2</span>. Moreover, since the S-boxes in <em>Grendel</em> after guessing all Legendre symbols are of low degree, it is not strictly necessary to introduce intermediate variables in each round in order to reduce the degree growth. Indeed, the attacker can avoid adding any intermediate variables and instead solve a higher-degree system of equations, which we focus on in the next section. As we are going to show, this approach can outperform the original analysis given in <em>[x27]</em>, and it can even break the full scheme including the security margin.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Our Attack Strategy.</h4>

    <p class="text-gray-300">Based on the strategy just presented, we are going to show a preimage attack on a sponge hash function instantiated with full <em>Grendel</em>. Let <span class="math">\\kappa</span> be the security level, and let <span class="math">p</span> be the prime that defines the field. We limit ourselves to focus on the case in which <span class="math">p\\geq 2^{\\kappa}</span>. As we have seen in Section 2.1.2, this implies that <span class="math">r\\geq 1</span> is allowed, and that the hash function can output a single element from <span class="math">\\mathbb{F}_{p}</span>. This is an often used scenario in practice, since <span class="math">p</span> is usually large.</p>

    <p class="text-gray-300">Hence, given <span class="math">h\\in\\mathbb{F}_{p}</span>, we are looking for a preimage. If <span class="math">r\\geq 2</span>, we first fix <span class="math">r-1</span> input elements. In contrast to the analysis given in the original paper, we will not introduce any intermediate variables. Instead, we will fix all Legendre symbols and work with polynomials of degree <span class="math">d^{R}</span>, where <span class="math">R</span> is the number of attacked rounds. In short, the attack for an <span class="math">R</span>-round construction consists of three steps, namely</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>iterating over all possible sets of Legendre symbols,</li>

      <li>solving the resulting univariate equation to find a preimage, and</li>

      <li>determining if the solution is a valid one.</li>

    </ol>

    <p class="text-gray-300">For the second step, we use a root-finding approach to solve the single univariate polynomial. We point out that the capacity <span class="math">c</span> does not play any role in the attack. A pseudo code is given in Algorithm 1. The particular steps will now be explained in detail.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.2 Details and Cost of the Attack</h3>

    <p class="text-gray-300">In the following, we provide the details of the attack, and we estimate its cost.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">5.2.1 Computing Legendre Symbols</h4>

    <p class="text-gray-300">The probability of a Legendre symbol being <span class="math">\\pm 1</span> is <span class="math">(p-1)/(2p)\\approx 1/2</span>, while the probability of it being <span class="math">0</span> is <span class="math">1/p</span>. Hence, the probability that <span class="math">l</span> symbols are different from zero is <span class="math">(1-(1/p))^{l}</span>, which is greater than <span class="math">99.99\\%</span> even for a large number of rounds if <span class="math">p\\approx 2^{32}</span>. However, we still conservatively acknowledge this by adding an additional factor of <span class="math">2</span> to the attack complexity.</p>

    <p class="text-gray-300">From now on, we assume to be in the case in which the Legendre symbol can only be <span class="math">1</span> or <span class="math">-1</span>. Hence, with a probability of <span class="math">1</span> we will find the correct set of <span class="math">l</span> Legendre symbols after exhaustively trying all <span class="math">2^{l}</span> different possibilities. In our attack,</p>

    <p class="text-gray-300"><span class="math">l=nR-(n-1)=n(R-1)+1,</span></p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 1: Finding a preimage for a sponge hash function instantiated with R-round Grendel over Fp. For simplicity and w.l.o.g., IV = 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 ∈ Fp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Data: Hash output h ∈ Fp.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Result: Preimage x*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v ∈ Fp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1 Generate random v ∈ Fp-1.  |   |</p>

    <p class="text-gray-300">|  2 L ← ∅.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3 while</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< 2n(R-1)+2 do</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  4 Fix all the Legendre symbols λ∉L for R-round Grendel (only 1 or -1).  |   |</p>

    <p class="text-gray-300">|  5 L ← L ∪ λ.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6 Symbolically compute F(x) = [Grendel(x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0)]0 ∈ Fp[x] using λ.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7 Find a root x* of F(x) - h.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 if Grendel(x*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0) satisfies all fixed Legendre symbols λ then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  10 return No solution found, try with different v.  |   |</p>

    <p class="text-gray-300">where  <span class="math">n - 1</span>  Legendre symbols in the first round can be computed deterministically, since there is no linear layer before the first application of the S-boxes. As a result, the number of times we have to repeat the attack until the correct set of Legendre symbols is found is</p>

    <div class="my-4 text-center"><span class="math-block">2 \\cdot 2 ^ {l} = 2 \\cdot 2 ^ {n (R - 1) + 1} = 2 ^ {n (R - 1) + 2}. \\tag {9}</span></div>

    <p class="text-gray-300">Before going on, we point out that this approach also works for other variations, such as the modulo-2 operation presented in Section 4.2.</p>

    <h2 id="sec-38" class="text-2xl font-bold">5.2.2 Finding the Preimage</h2>

    <p class="text-gray-300">We focus on the case in which the number of hash output elements is 1, which occurs to be the case if  <span class="math">p \\geq 2^n</span> . Note that since the final hash value consists of a single element, we also have only one squeezing step in the sponge. Fixing all Legendre symbols, we only have a single unknown (the input variable) and a single equation of degree at most  <span class="math">d^R</span>  in the end. W.l.o.g., we assume  <span class="math">IV = 0 \\parallel \\dots \\parallel 0 \\in \\mathbb{F}_p^n</span>  for the sponge initialization vector. The polynomial equation is then given by</p>

    <div class="my-4 text-center"><span class="math-block">F (x) = \\left[ \\operatorname {G r e n d e l} \\left(x \\mid v \\mid 0 \\mid \\dots \\mid 0\\right) \\right] _ {0} - h \\quad \\in \\mathbb {F} _ {p} [ x ], \\tag {10}</span></div>

    <p class="text-gray-300">where  <span class="math">x</span>  is the unknown variable,  <span class="math">v \\in \\mathbb{F}_p^{r-1}</span>  is chosen randomly and fixed, and  <span class="math">h \\in \\mathbb{F}_p</span>  is the hash output we want to find a preimage for. Our equation system hence consists of only one univariate equation, and we can apply a root-finding algorithm to this equation in order to solve for  <span class="math">x</span> . We point out that a similar approach was also shown in [RAS20] when attacking GMiMCHash, a sponge hash function built using the symmetric primitive GMiMC [AGP+19].</p>

    <h2 id="sec-39" class="text-2xl font-bold">5.2.3 Complexity of Finding the Roots and Verifying the Solution</h2>

    <p class="text-gray-300">We apply a root-finding algorithm to the polynomial  <span class="math">F</span>  given in Eq. (10). The complexity of this step is estimated in Eq. (2), where in our case  <span class="math">D = d^{R}</span> . In the first round,  <span class="math">n - 1</span>  Legendre symbols can be computed deterministically. Moreover, after finding the roots, we practically verify whether the given solution is a valid one. For this purpose, we take the solution found and we determine if the given instance is a valid one (i.e., if all computed Legendre symbols match the fixed ones for this trial). Note that we can abort the verification step as soon as we find an inconsistency between the computed symbol using our solution and the fixed one, which then makes the trial invalid. Since we have to</p>

    <p class="text-gray-300">compute only the first Legendre symbol in each instance with a probability of 50%, only the first two with a probability of 25%, etc., the average number of Legendre symbols we expect to compute for each trial before finding an inconsistency is well approximated by</p>

    <p class="text-gray-300"><span class="math">1+\\sum_{i\\geq 1}\\frac{i}{2^{i}}=1+\\frac{2^{-1}}{(1-2^{-1})^{2}}=3.</span></p>

    <p class="text-gray-300">The complexity of computing a Legendre symbol <em>[x1]</em> is estimated as</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(u\\cdot(\\log_{2}(u))^{2}\\cdot\\log_{2}(\\log_{2}(u))\\right),</span> (11)</p>

    <p class="text-gray-300">for <span class="math">u=\\log_{2}(p)</span> and a small hidden constant. Consequently, this instance can be attacked if</p>

    <p class="text-gray-300"><span class="math">(C_{\\mathrm{R}}+3\\cdot C_{\\mathrm{V}})\\cdot\\left(2^{n(R-1)+2}\\right)\\leq 2^{\\kappa},</span> (12)</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>assuming the <span class="math">n-1</span> Legendre symbols of the fixed part in the first round to be known, <span class="math">2^{n(R-1)+2}</span> is the number of times we have to repeat the attack when targeting a success probability over 99% (see Eq. (9)),</li>

      <li>the cost of the factorization step is</li>

    </ul>

    <p class="text-gray-300"><span class="math">C_{\\mathrm{R}}=D\\cdot(\\log_{2}(D))^{2}\\cdot\\log_{2}(D\\cdot p)\\cdot(1+63.43\\log_{2}(\\log_{2}(D)))</span></p>

    <p class="text-gray-300">from Eq. (2), and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the cost of computing a Legendre symbol is</li>

    </ul>

    <p class="text-gray-300"><span class="math">C_{\\mathrm{V}}=u\\cdot(\\log_{2}(u))^{2}\\cdot\\log_{2}(\\log_{2}(u))</span></p>

    <p class="text-gray-300">from Eq. (11), where <span class="math">u=\\log_{2}(p)</span>. As we have seen, on average 3 Legendre symbols are computed.</p>

    <p class="text-gray-300">We emphasize that the complexity of the root-finding algorithm does not change when increasing <span class="math">n</span>. Indeed, only the number of Legendre symbols to be tried is larger. As shown in Table 3 for <span class="math">p\\approx 2^{256}</span> and <span class="math">\\kappa=128</span>, this attack breaks more rounds than the approaches given in <em>[x28, Table 1]</em>. Similar attacks can be set up for other values of <span class="math">p</span> and <span class="math">\\kappa</span>.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">5.2.4 Practical Verification</h4>

    <p class="text-gray-300">We practically implemented and verified the preimage attack on <em>Grendel</em> in Sage. As expected, we could observe that the probability of having a zero at the output of the Legendre symbol is negligibly low, especially when using larger primes and with the low number of Legendre symbols involved. Moreover, a solution is found in around half of the attempts (i.e., we may have to choose different random values <span class="math">v\\in\\mathbb{F}_{p}^{r-1}</span> for some preimages), which results in a high success probability when repeating the attack a couple of times, as suggested by our complexity estimate.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.3 Restoring Security and Final Considerations</h3>

    <p class="text-gray-300">Avoiding the attack shown in the previous section is not sufficient in order to argue security. Indeed, if <span class="math">p&lt;2^{\\kappa}</span>, the number of output elements has to be greater than 1. Consequently, finding a preimage is done with an equation system of <span class="math">n_{e}\\geq 2</span> equations in <span class="math">n_{v}=n_{e}</span> variables. While the previous approach is not applicable any more, a Gröbner basis approach might.</p>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">Table 3: Number of attacked rounds of <em>Grendel</em> when considering the univariate root-finding approach. Bold numbers indicate that the attack breaks the full-round versions of <em>Grendel</em> considering the round numbers proposed in the original paper [Sze21]. In this table, <span class="math">\\kappa=128</span> and <span class="math">p\\approx 2^{256}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instance (d,n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R</span> [Sze21]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attacked <span class="math">R</span> Eq. (12)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,12)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,12)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,12)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 7: The values for <span class="math">D_{\\mathrm{reg}}</span> in practice, where <span class="math">d\\in\\{3,5\\}</span>, <span class="math">n_{v}\\in\\{2,3\\}</span>, and <span class="math">n=n_{v}+1</span>. We did not encounter any differences for <span class="math">n&amp;gt;n_{v}+1</span> in these tests.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">5.3.1 Gröbner Basis Attack</h4>

    <p class="text-gray-300">Here we focus on the complexity of computing the Gröbner basis in order to find the minimum number of rounds of <em>Grendel</em> which avoids this attack. Note that from a designer’s point of view, it is sufficient to argue that the complexity of computing the basis is prohibitively high.</p>

    <p class="text-gray-300">In contrast to the original analysis given in [Sze21], here we evaluate the complexity of building a Gröbner basis without introducing any intermediate variables. In other words, we do the same as in the root-finding approach before, with the exception of having more than a single input variable and more than a single output equation.</p>

    <p class="text-gray-300">For our purpose, assume an equation system with <span class="math">n_{e}</span> equations in <span class="math">n_{v}</span> unknown variables. From Section 2.3.2 we have an estimated degree of regularity of <span class="math">1+n_{e}\\cdot(d^{R}-1)</span>. Our practical tests regarding the actual degrees reached in the computation are given in Fig. 7, and they suggest that this bound is reasonable, with the actual degree being</p>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{est}}=n_{v}\\cdot d^{R}-d\\cdot(n_{v}-1)</span></p>

    <p class="text-gray-300">in our tests. Using this estimation, we obtain</p>

    <p class="text-gray-300"><span class="math">2\\cdot 2^{n(R-1)+n_{v}}\\cdot\\binom{D_{\\mathrm{est}}+n_{v}}{n_{v}}^{2}=2\\cdot 2^{n(R-1)+n_{v}}\\cdot\\binom{n_{v}\\cdot(d^{R}+1)-d\\cdot(n_{v}-1)}{n_{v}}^{2}</span> (13)</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <p class="text-gray-300">Table 4: Adjusted round numbers for Grendel for  <span class="math">\\kappa = 128</span>  and  <span class="math">p \\approx 2^{256}</span>  considering our new attacks. We also list the recommended number of rounds from the original paper [Sze21], together with the incremental percentage.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instance (d,n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R from [Sze21] (with security margin)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">New minimum R (with security margin)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">34 (+21.43%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">28 (+33.33%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">16 (+45.45%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(2,12)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">12 (+71.43%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">30 (+36.36%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">25 (+56.25%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">15 (+87.50%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(3,12)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">11 (+83.33%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,3)</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">26 (+62.50%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,4)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">22 (+83.33%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,8)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">14 (+133.33%)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(5,12)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">11 (+175.00%)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for the cost of the Gröbner basis computation, including the cost of iterating over all possible Legendre symbols ( <span class="math">n_v</span>  Legendre symbols are known in the first round). Note that we set  <span class="math">\\omega = 2</span>  (optimistic from an attacker's point of view). We emphasize that for some instances (especially with increasing  <span class="math">n</span> ), this Gröbner basis strategy is more efficient than the strategies proposed in the original paper [Sze21].</p>

    <p class="text-gray-300">In order to restore the security of Grendel with respect to the attacks presented in this section, the recommended number of rounds must be adjusted for some parameters. For this purpose, we adopt the method used in the original paper [Sze21]. In particular, we first evaluate the security of each known attack (including our new ones) and we then ensure that the estimated complexity is larger than or equal to  <span class="math">2^{1.25\\kappa}</span>  for a security of  <span class="math">\\kappa</span>  bits, where 1.25 is chosen as the security margin. Further, we use only the complexity of the Gröbner basis computation as the estimate for the multivariate attack (i.e., the complexity given in Eq. (13)), as is also done in [Sze21].</p>

    <p class="text-gray-300">Following our attacks, in addition to the inequalities given in [Sze21, Table 1], the number of rounds of each Grendel instance must satisfy</p>

    <div class="my-4 text-center"><span class="math-block">R \\geq \\max \\left\\{\\left\\lceil \\frac {2 . 5 \\cdot \\kappa}{\\log_ {2} (p) - \\log_ {2} (d) - 1} \\right\\rceil , R ^ {\\prime}, R ^ {\\prime \\prime} \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">R&#x27; \\geq 1</span>  is the smallest positive integer that satisfies Eq. (1), while  <span class="math">R&#x27;&#x27; \\geq 1</span>  is the smallest positive integer that satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 2 ^ {n (R ^ {\\prime \\prime} - 1) + 1} \\cdot \\max  \\left\\{2 ^ {n _ {v} - t + 1} \\cdot \\binom {n _ {v} \\cdot (d ^ {R ^ {\\prime \\prime}} + 1) - d \\cdot (n _ {v} - 1)} {n _ {v}} ^ {2}; \\right. \\\\ d ^ {R ^ {\\prime \\prime}} \\cdot \\left(\\log_ {2} \\left(d ^ {R ^ {\\prime \\prime}}\\right)\\right) ^ {2} \\cdot \\log_ {2} \\left(d ^ {R ^ {\\prime \\prime}} \\cdot p\\right) \\cdot \\left(1 + 6 3. 4 3 \\cdot \\log_ {2} \\left(\\log_ {2} \\left(d ^ {R ^ {\\prime \\prime}}\\right)\\right)\\right) \\Bigg \\} \\geq 2 ^ {1. 2 5 \\kappa} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">for a security level of  <span class="math">\\kappa</span>  bits, where  <span class="math">n_v</span>  denotes the number of elements in the hash output. The updated round numbers for various instances are given in Table 4, where we also list the recommended number of rounds from the original paper. Note that we omit the factor</p>

    <p class="text-gray-300">6 in Eq. (12) and Eq. (13) (we assume an attacker finds a solution immediately), we also omit the complexity of verifying a solution, and we use <span class="math">\\omega=2</span> in Eq. (3) (pessimistic from the designer’s point of view).</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">5.3.3 Attack on <em>Grendel</em> instantiated with <span class="math">d=1</span></h4>

    <p class="text-gray-300">Finally, even though <span class="math">d\\geq 2</span> in <em>Grendel</em>, we study the case <span class="math">d=1</span> from an algebraic point of view (we recall that <em>Grendel</em> would be invertible for <span class="math">d=1</span> if <span class="math">p=1\\mod 4</span>). Indeed, the only nonlinear component in the description would then be the Legendre symbol. If we fix all of them, as we did before, the construction is affine, and for a single element in the hash output the challenge would then be to solve a single affine equation. Since the cost of this would be negligible, the modified construction can be attacked if</p>

    <p class="text-gray-300"><span class="math">2^{n(R-1)+2}&lt;2^{\\kappa}\\qquad\\implies\\qquad R&lt;\\frac{\\kappa-2-\\log_{2}(3)}{n}+1.</span></p>

    <p class="text-gray-300">The situation is only slightly different when considering <span class="math">r\\geq 2</span> and multiple hash outputs. Indeed, for <span class="math">n_{e}</span> outputs we have <span class="math">n_{e}</span> linear equations in <span class="math">n_{v}=r</span> input variables. The solving complexity is then in <span class="math">\\mathcal{O}(n_{e}{}^{\\omega})</span>, and for an attack <span class="math">n_{e}{}^{\\omega}\\cdot 2\\cdot 2^{n(R-1)+n_{v}}&lt;2^{\\kappa}</span>, where pessimistically <span class="math">\\omega=3</span>.</p>

    <h5 id="sec-45" class="text-base font-semibold mt-4">Acknowledgments.</h5>

    <p class="text-gray-300">We thank the anonymous reviewers for their valuable comments. The authors also thank Subhadeep Banik for shepherding the final version of the paper. Lorenzo Grassi is supported by the European Research Council under the ERC advanced grant agreement under grant ERC-2017-ADG Nr. 788980 ESCADA.</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AAB^{+}20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. IACR Transactions on Symmetric Cryptology, 2020(3):1–45, 2020.</li>

      <li>[ACG^{+}19] Martin R. Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, and Markus Schofnegger. Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC. In ASIACRYPT 2019, volume 11923 of LNCS, pages 371–397, 2019.</li>

      <li>[AD18] Tomer Ashur and Siemen Dhooghe. MARVELlous: a STARK-Friendly Family of Cryptographic Primitives. IACR Cryptol. ePrint Arch., page 1098, 2018.</li>

      <li>[AGP^{+}19] Martin R. Albrecht, Lorenzo Grassi, Léo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel Structures for MPC, and More. In ESORICS (2), volume 11736 of LNCS, pages 151–171. Springer, 2019.</li>

      <li>[AGR^{+}16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In ASIACRYPT 2016, volume 10031 of LNCS, pages 191–219, 2016.</li>

      <li>[BBS86] Lenore Blum, Manuel Blum, and Mike Shub. A Simple Unpredictable Pseudo-Random Number Generator. SIAM J. Comput., 15(2):364–383, 1986.</li>

      <li>[BBUV20] Ward Beullens, Tim Beyne, Aleksei Udovenko, and Giuseppe Vitto. Cryptanalysis of the Legendre PRF and Generalizations. IACR Trans. Symmetric Cryptol., 2020(1):313–330, 2020.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCD^{+}20] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Gaëtan Leurent, María Naya-Plasencia, Léo Perrin, Yu Sasaki, Yosuke Todo, and Friedrich Wiemer. Out of Oddity - New Cryptanalytic Techniques Against Symmetric Primitives Optimized for Integrity Proof Systems. In CRYPTO 2020, volume 12172 of LNCS, pages 299–328, 2020.</li>

      <li>[BDPA08] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. On the Indifferentiability of the Sponge Construction. In EUROCRYPT 2008, volume 4965 of LNCS, pages 181–197, 2008.</li>

      <li>[BdSG20] Ward Beullens and Cyprien Delpech de Saint Guilhem. LegRoast: Efficient Post-quantum Signatures from the Legendre PRF. In Post-Quantum Cryptography - PQCrypto 2020, volume 12100 of LNCS, pages 130–150, 2020.</li>

      <li>[BFP12] Luk Bettale, Jean-Charles Faugère, and Ludovic Perret. Solving polynomial systems over finite fields: improved analysis of the hybrid approach. In ISSAC, pages 67–74. ACM, 2012.</li>

      <li>[BFSY05] M Bardet, JC Faugere, B Salvy, and BY Yang. Asymptotic behaviour of the index of regularity of quadratic semi-regular polynomial systems. In The Effective Methods in Algebraic Geometry Conference (MEGA), pages 1–14, 2005.</li>

      <li>[BS90] Eli Biham and Adi Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In CRYPTO 1990, volume 537 of LNCS, pages 2–21, 1990.</li>

      <li>[BS93] Eli Biham and Adi Shamir. Differential Cryptanalysis of the Data Encryption Standard. Springer, 1993.</li>

      <li>[BSV07] Thomas Baignères, Jacques Stern, and Serge Vaudenay. Linear Cryptanalysis of Non Binary Ciphers. In Selected Areas in Cryptography – SAC 2007, volume 4876 of LNCS, pages 184–211. Springer, 2007.</li>

      <li>[Buc76] Bruno Buchberger. A theoretical basis for the reduction of polynomials to canonical forms. SIGSAM Bull., 10(3):19–29, 1976.</li>

      <li>[BZ10] Richard P. Brent and Paul Zimmermann. An <em>O</em>(<em>M</em>(<em>n</em>) log<em>n</em>) Algorithm for the Jacobi Symbol. In ANTS, volume 6197 of LNCS, pages 83–95. Springer, 2010.</li>

      <li>[Dae95] Joan Daemen. Cipher and hash function design, strategies based on linear and differential cryptanalysis, PhD Thesis. K.U.Leuven, 1995. https://cs.ru.nl/-joan/.</li>

      <li>[DGGK21] Christoph Dobraunig, Lorenzo Grassi, Anna Guinet, and Daniël Kuijsters. Ciminion: Symmetric Encryption Based on Toffoli-Gates over Large Finite Fields. In EUROCRYPT (2), volume 12697 of LNCS, pages 3–34. Springer, 2021.</li>

      <li>[DGH^{+}21] Christoph Dobraunig, Lorenzo Grassi, Lukas Helminger, Christian Rechberger, Markus Schofnegger, and Roman Walch. Pasta: A Case for Hybrid Homomorphic Encryption. IACR Cryptol. ePrint Arch., page 731, 2021.</li>

      <li>[DGV92] Joan Daemen, René Govaerts, and Joos Vandewalle. A Hardware Design Model for Cryptographic Algorithms. In ESORICS 1992, volume 648 of LNCS, pages 419–434, 1992.</li>

      <li>[DHS98] Cunsheng Ding, Tor Helleseth, and Weijuan Shan. On the Linear Complexity of Legendre Sequences. IEEE Trans. Inf. Theory, 44(3):1276–1278, 1998.</li>

    </ul>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DR01] Joan Daemen and Vincent Rijmen. The Wide Trail Design Strategy. In Cryptography and Coding, 8th IMA International Conference, volume 2260 of LNCS, pages 222–238, 2001.</li>

      <li>[DR02] Joan Daemen and Vincent Rijmen. Security of a wide trail design. In Progress in Cryptology - INDOCRYPT 2002, volume 2551 of LNCS, pages 1–11, 2002.</li>

      <li>[EGL^{+}20] Maria Eichlseder, Lorenzo Grassi, Reinhard Lüftenegger, Morten Øygarden, Christian Rechberger, Markus Schofnegger, and Qingju Wang. An Algebraic Attack on Ciphers with Low-Degree Round Functions: Application to Full MiMC. In ASIACRYPT 2020, volume 12491 of LNCS, pages 477–506, 2020.</li>

      <li>[Fau02] Jean Charles Faugère. A New Efficient Algorithm for Computing GröBner Bases without Reduction to Zero (F5). In Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation, ISSAC 2002, page 75–83. Association for Computing Machinery, 2002.</li>

      <li>[FGLM93] Jean-Charles Faugère, Patrizia M. Gianni, Daniel Lazard, and Teo Mora. Efficient computation of zero-dimensional gröbner bases by change of ordering. J. Symb. Comput., 16(4):329–344, 1993.</li>

      <li>[FS21] Paul Frixons and André Schrottenloher. Quantum Security of the Legendre PRF. MathCrypto, 1(1):1–18, 2021.</li>

      <li>[Gen07] Giulio Genovese. Improving the algorithms of Berlekamp and Niederreiter for factoring polynomials over finite fields. J. Symb. Comput., 42(1-2):159–177, 2007.</li>

      <li>[GKR^{+}21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In USENIX Security Symposium, pages 519–535. USENIX Association, 2021.</li>

      <li>[GLR^{+}20] Lorenzo Grassi, Reinhard Lüftenegger, Christian Rechberger, Dragos Rotaru, and Markus Schofnegger. On a Generalization of Substitution-Permutation Networks: The HADES Design Strategy. In EUROCRYPT 2020, volume 12106 of LNCS, pages 674–704, 2020.</li>

      <li>[GMS14] Katalin Gyarmati, Christian Mauduit, and András Sárközy. The cross-correlation measure for families of binary sequences. In Applied Algebra and Number Theory, number Theory, pages 126–143. 2014.</li>

      <li>[GOPS21] Lorenzo Grassi, Silvia Onofri, Marco Pedicini, and Luca Sozzi. Invertible Quadratic Non-Linear Layers for MPC-/FHE-/ZK-Friendly Schemes over <span class="math">\\mathbb{F}_{p}^{n}</span>. Cryptology ePrint Archive, Report 2021/1695, 2021. https://ia.cr/2021/1695.</li>

      <li>[GRR^{+}16] Lorenzo Grassi, Christian Rechberger, Dragos Rotaru, Peter Scholl, and Nigel P. Smart. MPC-Friendly Symmetric Key Primitives. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 430–443. ACM, 2016.</li>

      <li>[GU82] L. Guerra and E. Ughi. On the distribution of Legendre symbols in Galois fields. Discrete Mathematics, 42(2-3):197–208, 1982.</li>

      <li>[HKC^{+}20] Jincheol Ha, Seongkwang Kim, Wonseok Choi, Jooyoung Lee, Dukjae Moon, Hyojin Yoon, and Jihoon Cho. Masta: An HE-Friendly Cipher Using Modular Arithmetic. IEEE Access, 8:194741–194751, 2020.</li>

    </ul>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JK97] Thomas Jakobsen and Lars R. Knudsen. The Interpolation Attack on Block Ciphers. In FSE 1997, volume 1267 of LNCS, pages 28–40, 1997.</li>

      <li>[Kho19] Dmitry Khovratovich. Key recovery attacks on the Legendre PRFs within the birthday bound. Cryptology ePrint Archive, Report 2019/862, 2019. https://ia.cr/2019/862.</li>

      <li>[KJJ99] Paul C. Kocher, Joshua Jaffe, and Benjamin Jun. Differential Power Analysis. In Advances in Cryptology - CRYPTO 1999, volume 1666 of LNCS, pages 388–397, 1999.</li>

      <li>[KKK20] Novak Kaluderović, Thorsten Kleinjung, and Dusan Kostic. Improved key recovery on the Legendre PRF. ANTS XIV: Proceedings of the Fourteenth Algorithmic Number Theory Symposium, 4(1):267–282, 2020.</li>

      <li>[Knu94] Lars R. Knudsen. Truncated and Higher Order Differentials. In FSE 1994, volume 1008 of LNCS, pages 196–211, 1994.</li>

      <li>[Koc96] Paul C. Kocher. Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems. In Advances in Cryptology - CRYPTO 1996, volume 1109 of LNCS, pages 104–113, 1996.</li>

      <li>[Lai94] X. Lai. Higher order derivatives and differential cryptanalysis. Communications and Cryptography: Two Sides of One Tapestry, 1994.</li>

      <li>[Leh54] D. H. Lehmer. Random number generation on the BRL highspeed computing machines. Math. Rev., 15:559, 1954.</li>

      <li>[LHT13] Nian Li, Tor Helleseth, and Xiaohu Tang. Further results on a class of permutation polynomials over finite fields. Finite Fields Their Appl., 22:16–23, 2013.</li>

      <li>[Mat93] Mitsuru Matsui. Linear Cryptanalysis Method for DES Cipher. In Advances in Cryptology - EUROCRYPT 1993, volume 765 of LNCS, pages 386–397, 1993.</li>

      <li>[MP13] Gary L. Mullen and Daniel Panario. Handbook of Finite Fields. Chapman &amp; Hall/CRC, 1st edition, 2013.</li>

      <li>[MS97] Christian Mauduit and András Sárközy. On finite pseudorandom binary sequences I: Measure of pseudorandomness, the Legendre symbol. Acta Arithmetica, 82(4):365–377, 1997.</li>

      <li>[Nag51] T. Nagell. Euler’s Criterion and Legendre’s Symbol. Introduction to Number Theory, 1951.</li>

      <li>[RAS20] Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer. Interpolation Cryptanalysis of Unbalanced Feistel Networks with Low Degree Round Functions. In SAC, volume 12804 of LNCS, pages 273–300. Springer, 2020.</li>

      <li>[RDP^{+}96] Vincent Rijmen, Joan Daemen, Bart Preneel, Antoon Bosselaers, and Erik De Win. The Cipher SHARK. In Fast Software Encryption - FSE 1996, volume 1039 of LNCS, pages 99–111, 1996.</li>

      <li>[Sha12] Christopher J. Shallue. Permutation Polynomials of Finite Fields. arXiv, ePrint: 1211.6044, 2012.</li>

    </ul>

    <p class="text-gray-300">The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over \\mathbb{F}_p^n</p>

    <p class="text-gray-300">[SHB21] István András Seres, Máté Horváth, and Péter Burcsi. The Legendre Pseudorandom Function as a Multivariate Quadratic Cryptosystem: Security and Applications. Cryptology ePrint Archive, Report 2021/182, 2021. https://ia.cr/2021/182. [SS21] Jan Ferdinand Sauer and Alan Szepieniec. SoK: Gröbner Basis Algorithms for Arithmetization Oriented Ciphers. Cryptology ePrint Archive, Report 2021/870, 2021. https://ia.cr/2021/870. [Sze21] Alan Szepieniec. On the Use of the Legendre Symbol in Symmetric Cipher Design. IACR Cryptol. ePrint Arch., page 984, 2021. [Tra00] Quoc-Nam Tran. A Fast Algorithm for Gröbner Basis Conversion and its Applications. J. Symb. Comput., 30(4):451-467, 2000. [TZLH15] Ziran Tu, Xiangyong Zeng, Chunlei Li, and Tor Helleseth. Permutation polynomials of the form  <span class="math">(x^{p^m} - x + \\delta)^s + L(x)</span>  over the finite field  <span class="math">\\mathbb{F}_{p^{2m}}</span>  of odd characteristic. Finite Fields Their Appl., 34:20-35, 2015. [Tó07] Viktória Tóth. Collision and avalanche effect in families of pseudorandom binary sequences. Periodica Mathematica Hungarica, 55(2):185-196, 2007. [vzGG13] Joachim von zur Gathen and Jürgen Gerhard. Modern Computer Algebra (3. ed.). Cambridge University Press, 2013. [Wol85] Stephen Wolfram. Cryptography with Cellular Automata. In CRYPTO 1985, volume 218 of LNCS, pages 429-432, 1985.</p>

    <p class="text-gray-300">Preliminaries. Linear cryptanalysis [Mat93, BSV07] exploits large correlations (in absolute value) between linear combinations of input elements and linear combinations of output elements of a permutation. While differential cryptanalysis is a chosen (plaintext, ciphertext) approach, linear cryptanalysis is a known (plaintext, ciphertext) one.</p>

    <p class="text-gray-300">For each  <span class="math">x, y \\in \\mathbb{F}_p^n</span> , let  <span class="math">\\langle x, y \\rangle = \\sum_{j=0}^{n-1} x_j \\cdot y_j</span> . Let  <span class="math">\\Psi, \\Phi \\in \\mathbb{F}_p^n</span>  be the input and the output masks. The bias  <span class="math">\\varepsilon_F(\\Psi, \\Phi)</span>  of a function  <span class="math">F</span>  over  <span class="math">\\mathbb{F}_p^n</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon_ {F} (\\Psi , \\Phi , \\Omega) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {P r o b} \\left(\\langle \\Psi , x \\rangle + \\langle \\Phi , \\mathcal {F} (x) \\rangle = \\Omega\\right) - \\frac {1}{p} \\right</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for  <span class="math">x \\in \\mathbb{F}_p^n</span>  and a constant  <span class="math">\\Omega \\in \\mathbb{F}_p^n</span> . In order to make linear cryptanalysis successful, the attacker has to choose  <span class="math">\\Psi</span>  and  <span class="math">\\Phi</span>  in order to make  <span class="math">\\varepsilon_F(\\Psi, \\Phi)</span>  as large as possible, since such a linear approximation can then be used as a distinguishing property.</p>

    <p class="text-gray-300">Remark: In the following, we limit ourselves to  <span class="math">\\Omega = 0</span> . However, the analysis can easily be generalized for  <span class="math">\\Omega \\neq 0</span>  (which corresponds to an affine approximation).</p>

    <p class="text-gray-300">Lemma 11. Let  <span class="math">p \\geq 3</span>  be a prime and let  <span class="math">F(x) = x \\cdot (L_p(x) + \\alpha)</span> . For each  <span class="math">\\Psi, \\Phi \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb {F} _ {p} \\mid \\Psi \\cdot x = \\Phi \\cdot F (x) \\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left\\{ \\begin{array}{l l} 1 &amp; \\text{if } \\Psi \\neq \\Phi \\cdot (\\alpha \\pm 1), \\\\ (p + 1) / 2 &amp; \\text{otherwise}. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. The equality  <span class="math">\\Psi \\cdot x = \\Phi \\cdot x \\cdot (L_p(x) + \\alpha)</span>  is satisfied by  <span class="math">x = 0</span> . If  <span class="math">x \\neq 0</span> , it becomes  <span class="math">L_p(x) = -\\frac{\\Psi}{\\Phi} + \\alpha</span> , which</p>

    <p class="text-gray-300">Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom and Markus Schofnegger</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>does not have any solution if  <span class="math">\\Psi \\neq \\Phi \\cdot (\\alpha \\pm 1)</span>  and  <span class="math">\\Psi \\neq \\Phi \\cdot \\alpha</span> ,</li>

      <li>admits 0 as solution if  <span class="math">\\Psi = \\Phi \\cdot \\alpha</span>  (note: solution already included),</li>

      <li>admits  <span class="math">(p - 1) / 2</span>  nonzero solutions if  <span class="math">\\Psi = \\Phi \\cdot (\\alpha \\pm 1)</span> .</li>

    </ul>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Lemma 12. Let  <span class="math">p \\geq 3</span>  be a prime and let  <span class="math">d \\geq 3</span>  be such that  <span class="math">\\gcd(d, p - 1) = 1</span> . Let  <span class="math">F(x) = x^d \\cdot (L_p(x) + \\alpha)</span> . For each  <span class="math">\\Psi, \\Phi \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb {F} _ {p} \\mid \\Psi \\cdot x = \\Phi \\cdot F (x) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 d - 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. The equality  <span class="math">\\Psi \\cdot x = \\Phi \\cdot x^d \\cdot (L_p(x) + \\alpha)</span>  is satisfied by  <span class="math">x = 0</span> . If  <span class="math">x \\neq 0</span> , it becomes  <span class="math">\\Phi \\cdot x^{d-1} \\cdot (L_p(x) + \\alpha) - \\Psi = 0</span> . For each value of  <span class="math">L_p(x) \\in \\{-1,1\\}</span> , this equation admits at most  <span class="math">d-1</span>  solutions, for a total of  <span class="math">2 \\cdot (d-1) + 1 = 2d-1</span> .</p>

    <p class="text-gray-300">Lemma 13. Let  <span class="math">p \\geq 3</span>  be a prime number, and let  <span class="math">d_{+}, d_{-} \\geq 1</span>  be two integers such that  <span class="math">\\gcd(d_{+}, p - 1) = \\gcd(d_{-}, p - 1) = 1</span> . Let  <span class="math">F(x) = x^{d_{+}} \\cdot (1 + L_{p}(x)) + x^{d_{-}} \\cdot (1 - L_{p}(x))</span> . For each  <span class="math">\\Psi, \\Phi \\in \\mathbb{F}_{p} \\setminus \\{0\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb {F} _ {p} \\mid \\Psi \\cdot x = \\Phi \\cdot F (x) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot \\max  \\left\\{d _ {+}, d _ {-} \\right\\} - 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. The equality  <span class="math">\\Psi \\cdot x = \\Phi \\cdot \\left(x^{d_{+}}\\cdot (1 + L_{p}(x)) + x^{d_{-}}\\cdot (1 - L_{p}(x))\\right)</span>  is satisfied by  <span class="math">x = 0</span>  If  <span class="math">x\\neq 0</span>  , it becomes  <span class="math">\\Psi \\cdot x = \\Phi \\cdot \\left(x^{d_{+} - 1}\\cdot (1 + L_{p}(x)) + x^{d_{-} - 1}\\cdot (1 - L_{p}(x))\\right)</span>  . For each value of  <span class="math">L_{p}(x)\\in \\{-1,1\\}</span>  , this equation admits at most  <span class="math">\\max \\{d_+,d_-\\} -1</span>  solutions, for a total of  <span class="math">2\\cdot (\\max \\{d_{+},d_{-}\\} -1) + 1 = 2\\cdot \\max \\{d_{+},d_{-}\\} -1.</span></p>

    <p class="text-gray-300">Lemma 14. Let  <span class="math">p \\geq 3</span>  be a prime number such that  <span class="math">p = 3 \\mod 4</span> . Let  <span class="math">F(x) = \\alpha^{(x \\mod 2)} \\cdot x^2</span> , where  <span class="math">L_p(\\alpha) = -1</span> . For each  <span class="math">\\Psi, \\Phi \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{x \\in \\mathbb {F} _ {p} \\mid \\Psi \\cdot x = \\Phi \\cdot F (x) \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Clearly, 0 is a solution of  <span class="math">\\Psi \\cdot x = \\Phi \\cdot \\alpha^{(x \\mod 2)} \\cdot x^2</span> . If  <span class="math">x \\neq 0</span> , the solutions of this equation can be  <span class="math">x \\in \\left\\{\\frac{\\Psi}{\\Phi}, \\frac{\\alpha \\cdot \\Psi}{\\Phi}\\right\\}</span> .</p>

    <p class="text-gray-300">Lemma 15. Let  <span class="math">p \\geq 3</span>  be a prime number, and let  <span class="math">d \\geq 1</span>  be such that  <span class="math">\\gcd(d, p - 1) = 1</span> . Let  <span class="math">F(x) = (-1)^{x^2} \\cdot x^d</span> . For each  <span class="math">\\Psi, \\Phi \\in \\mathbb{F}_p \\setminus \\{0\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb {F} _ {p} \\mid \\Psi \\cdot x = \\Phi \\cdot F (x) \\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left\\{ \\begin{array}{l l} 1 &amp; \\text {if } d = 1 \\text{ and } \\Psi \\neq \\pm \\Phi , \\\\ (p + 1) / 2 &amp; \\text {if } d = 1 \\text{ and } \\Psi = \\pm \\Phi , \\\\ 2 d - 1 &amp; \\text {if } d \\geq 3. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Clearly, 0 is a solution of  <span class="math">\\Psi \\cdot x = \\Phi \\cdot (-1)^{x^2} \\cdot x^d</span> . For  <span class="math">x \\neq 0</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">d = 1</span> , then the equation reduces to  <span class="math">\\Psi = \\Phi \\cdot (-1)^{x^2}</span> , which does not admit any solution if  <span class="math">\\Psi \\neq \\pm \\Phi</span> , and which admits at most  <span class="math">(p - 1)/2</span>  solutions otherwise,</li>

      <li>if  <span class="math">d \\geq 3</span> , then the equation admits at most  <span class="math">d - 1</span>  solutions for each value of  <span class="math">(-1)^{x^2} \\in \\{-1, 1\\}</span> .</li>

    </ul>

    <p class="text-gray-300">□</p>`;
---

<BaseLayout title="The Legendre Symbol and the Modulo-2 Operator in Symmetric S... (2021/1533)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1533
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
