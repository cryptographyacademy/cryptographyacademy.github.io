---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/481';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved Security Bounds for Key-Alternating Ciphers via Hellinger Distance';
const AUTHORS_HTML = 'John Steinberger';

const CONTENT = `    <p class="text-gray-300">John Steinberger Institute of Theoretical Computer Science, Tsinghua University jpsteinb@gmail.com</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A <span class="math">t</span>-round <em>key alternating cipher</em> can be viewed as an abstraction of AES. It defines a cipher <span class="math">E</span> from <span class="math">t</span> fixed public permutations <span class="math">P_{1},\\ldots,P_{t}:\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> and a key $k=k_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{t}\\in\\{0,1\\}^{n(t+1)}<span class="math"> by setting </span>E_{k}(x)=k_{t}\\oplus P_{t}(k_{t-1}\\oplus P_{t-1}(\\cdots k_{1}\\oplus P_{1}(k_{0}\\oplus x)\\cdots))<span class="math">. The indistinguishability of </span>E_{k}<span class="math"> from a random truly random permutation by an adversary who also has oracle access to the (public) random permutations </span>P_{1},\\ldots,P_{t}<span class="math"> was investigated for </span>t=2<span class="math"> by Even and Mansour <em>[5]</em> and, much later, by Bogdanov et al. <em>[1]</em>. The former proved indistinguishability up to </span>2^{n/2}<span class="math"> queries for </span>t=1<span class="math"> while the latter proved indistinguishability up to </span>2^{2n/3}<span class="math"> queries for </span>t\\geq 2<span class="math"> (ignoring low-order terms). Our contribution is to improve the analysis of Bogdanov et al. by showing security up to </span>2^{3n/4}<span class="math"> queries for </span>t\\geq 3<span class="math">. Given that security cannot exceed </span>2^{\\frac{n}{2+1}n}<span class="math"> queries, this is in particular achieves a tight bound for the case </span>t=3<span class="math">, whereas, previously, tight bounds had only been achieved for </span>t=1<span class="math"> (by Even and Mansour) and for </span>t=2$ (by Bogdanov et al.). Our main technique is an improved analysis of the elegant <em>sample distinguishability</em> game introduced by Bogdanov et al. <em>[1]</em>. More specifically, we succeed in eliminating adaptivity by considering the <em>Hellinger advantage</em> of an adversary, a notion that we introduce here. To our knowledge, our result constitutes the first time Hellinger distance (a standard measure of “distance” between random variables, and a cousin of statistical distance) is used in a cryptographic indistinguishability proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-3" class="text-2xl font-bold">Introduction</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given <span class="math">t</span> permutations <span class="math">P_{1}</span>, <span class="math">\\ldots</span>, <span class="math">P_{t}:\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> the <span class="math">t</span>-round <em>key-alternating cipher</em> based on <span class="math">P_{1},\\ldots,P_{t}</span> is a blockcipher <span class="math">E:\\{0,1\\}^{(t+1)n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{n}</span> of keyspace <span class="math">\\{0,1\\}^{(t+1)n}</span> and message space <span class="math">\\{0,1\\}^{n}</span>, where for a key $k=k_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{t}\\in\\{0,1\\}^{(t+1)n}<span class="math"> and a message </span>x\\in\\{0,1\\}^{n}$ we set</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">E(k,x)=k_{t}\\oplus P_{t}(k_{t-1}\\oplus P_{t-1}(\\cdots P_{1}(k_{0}\\oplus x)\\cdots)).</span> (1)</p>

    <p class="text-gray-300">(See Figure 1.) Plainly, <span class="math">E(k,\\cdot)</span> is a permutation of <span class="math">\\{0,1\\}^{n}</span> for each fixed <span class="math">k\\in\\{0,1\\}^{(t+1)n}</span>; we let <span class="math">E^{-1}(k,\\cdot)</span> denote the inverse permutation. The <span class="math">P_{i}</span>’s are called the <em>round permutations</em> of <span class="math">E</span> and <span class="math">t</span> is the <em>number of rounds</em> of <span class="math">E</span>. Thus <span class="math">t</span> and the permutations <span class="math">P_{1},\\ldots,P_{t}</span> are parameters determining <span class="math">E</span>.</p>

    <p class="text-gray-300">Key-alternating ciphers were first proposed (for values of <span class="math">t</span> greater than 1) by the designers of AES <em>[3, 4]</em>, the Advanced Encryption Standard. Indeed, AES-128 itself can be viewed as a particular instantiation of the key-alternating cipher paradigm in which the round permutations <span class="math">P_{1},\\ldots,P_{t}</span> equal a single permutation <span class="math">P</span> (the Rijndael round function, in this case), in which <span class="math">t=10</span>, and in which only a subset of the <span class="math">\\{0,1\\}^{(t+1)n}=\\{0,1\\}^{11n}</span> possible keys are used (more precisely, the <span class="math">11n</span> bits of key are derived pseudorandomly from a seed of <span class="math">n</span> bits, making the key space <span class="math">\\{0,1\\}^{n}=\\{0,1\\}^{128}</span>). However, for <span class="math">t=1</span> the design was proposed much earlier by Even and Mansour as a means of constructing a blockcipher from a fixed permutation <em>[5]</em>.</p>

    <p class="text-gray-300">Even and Mansour accompanied their proposal with “provable security” guarantees by showing that, for <span class="math">t=1</span>, an adversary needs roughly <span class="math">2^{n/2}</span> queries to distinguish <span class="math">E(k,\\cdot)</span> for a random key <span class="math">k</span> (<span class="math">k</span> being</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A  <span class="math">t</span> -round key alternating cipher.</p>

    <p class="text-gray-300">hidden from the adversary) from a true random permutation, in a model where the adversary is given oracle access to  <span class="math">E(k,\\cdot)</span> ,  <span class="math">E^{-1}(k,\\cdot)</span>  as well as to  <span class="math">P_{1}</span> ,  <span class="math">P_{1}^{-1}</span> , where  <span class="math">P_{1}</span>  is modeled as a random permutation (in the dummy world, the adversary is given oracle access to two independent random permutations and their inverses). Their bound was matched by Daemen [2], who showed a  <span class="math">2^{n/2}</span> -query distinguishing attack for  <span class="math">t = 1</span> .</p>

    <p class="text-gray-300">For  <span class="math">t &amp;gt; 1</span> , we can generalize the Even-Mansour indistinguishability experiment by giving the adversary oracle access to  <span class="math">P_{1},\\ldots ,P_{t}</span>  and their inverses and to  <span class="math">E(k,\\cdot)</span> ,  <span class="math">E^{-1}(k,\\cdot)</span>  in the real world (for a randomly chosen, hidden  <span class="math">k\\in \\{0,1\\}^{(t + 1)n}</span> ), and to a tuple of  <span class="math">t + 1</span>  independent random permutations and their inverses in the "ideal" or "dummy" world (see Figure 2). In this case, Daemen's attack can be easily generalized to an attack of query complexity  <span class="math">2^{\\frac{t}{t + 1} n}</span> , as pointed out by Bogdanov et al. [1], but the security analysis of Even and Mansour does not similarly generalize to a security bound of  <span class="math">2^{\\frac{t}{t + 1} n}</span>  (though security of  <span class="math">2^{n / 2}</span>  queries still holds, and is easy to prove in a black-box fashion from the Even-Mansour result).</p>

    <p class="text-gray-300">Despite the advent of AES, further provable security improvements on key-alternating ciphers for  <span class="math">t &amp;gt; 1</span>  had to wait for the afore-mentioned paper of Bogdanov et al. [1], who showed (in the same model as Even and Mansour) security of  <span class="math">2^{\\frac{3}{3}n}</span>  queries for  <span class="math">t \\geq 2</span>  (modulo lower-order terms). This bound is tight for  <span class="math">t = 2</span> , as it matches the  <span class="math">2^{\\frac{1}{t+1}n}</span> -query attack, but is not sharp for  <span class="math">t &amp;gt; 2</span> —e.g., the best known attack for  <span class="math">t = 3</span>  has cost  <span class="math">2^{\\frac{3}{4}n}</span> , whereas the best known security bound remains  <span class="math">2^{\\frac{3}{3}n}</span> . In this paper we further this line of work by showing that key-alternating ciphers enjoy security of  <span class="math">2^{\\frac{3}{4}n}</span>  queries for  <span class="math">t \\geq 3</span> . In a nutshell, the Even-Mansour bound is tight for  <span class="math">t = 1</span> , the Bogdanov et al. bound is tight for  <span class="math">t = 2</span> , and our bound is tight for  <span class="math">t = 3</span> . It remains an open problem to prove tight bounds for  <span class="math">t \\geq 4</span>  (though, we emphasize, our bound also improves the previous best of  <span class="math">2^{\\frac{3}{4}n}</span>  up to  <span class="math">2^{\\frac{3}{4}n}</span>  for  <span class="math">t \\geq 4</span> ).</p>

    <p class="text-gray-300">Our proof follows closely the method of Bogdanov et al. [1]. Essentially, our improvement follows by replacing a certain "loose" statistical distance triangle inequality in [1] by a sharper inequality based on Hellinger distance (a variant of statistical distance). In fact, this technique more generally gives a much improved (and, in a cryptographic sense, sharp) analysis of the elegant sample distinguishability game introduced by Bogdanov et al. The modified sample distinguishability analysis that we present is also interesting because we show (loosely speaking) that the "statistical" advantage of an adaptive adversary can be upper bounded by the "Hellinger" advantage of a non-adaptive adversary. It thus presents a new, interesting instance of the paradigm common in cryptographic proofs that seeks to replace an adaptive adversary by a non-adaptive adversary in order to upper bound advantage [8,9,12-14].</p>

    <p class="text-gray-300">Our work has two main parts: (i) an improved (generic) analysis of sample distinguishability based on the technical concept of Hellinger distance, and (ii) an application of the previous analysis to the sample distinguishability game defined by Bogdanov et al., where the main hurdle is to upper bound the relevant Hellinger distance (whereas Bogdanov et al. only upper bounded statistical distance).</p>

    <p class="text-gray-300">In the paper's first part we (re-)introduce sample distinguishability, Hellinger distance, and their interconnection. This part contains the improved Hellinger-distance-based upper bound for sample distinguishability that is of independent interest from the paper's main result. In the paper's second</p>

    <p class="text-gray-300">part we give more detailed definitions for key-alternating ciphers and the security experiment. We then recall the outline of Bogdanov et al.’s security analysis for key-alternating ciphers and “plug in” our improved sample distinguishability bound to this proof, thus obtaining the improvement from <span class="math">2^{\\frac{2}{3}n}</span> to <span class="math">2^{\\frac{2}{4}n}</span> queries for <span class="math">t\\geq 3</span> rounds.</p>

    <p class="text-gray-300">To the best of our knowledge, this paper represents the first application of Hellinger distance in cryptography, or to indistinguishability in general.</p>

    <p class="text-gray-300">A notational preliminary. The statistical distance <span class="math">\\Delta(X,Y)</span> (more accurately known, also, as the total variation distance) between two random variables <span class="math">X</span>, <span class="math">Y</span> of range <span class="math">S</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y):=\\max_{T\\subseteq S}(\\Pr[X\\in T]-\\Pr[Y\\in T])=\\sum_{s\\in S}\\frac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X=s]-\\Pr[Y=s]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is well-known (and easily proved) that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta(X,Y)=\\sup_{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[D(X)=1]-\\Pr[D(Y)=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the <span class="math">\\sup</span> is taken over all (probabilistic or deterministic—it doesn’t matter) distinguishers <span class="math">D:S\\to\\{0,1\\}</span>, and where <span class="math">\\Pr[D(X)=1]</span>, <span class="math">\\Pr[D(Y)=1]</span> are the probabilities that <span class="math">D</span> outputs <span class="math">1</span> when given a sample of <span class="math">X</span> and <span class="math">Y</span>, respectively, these probabilities being computed over the randomness in <span class="math">X</span> and <span class="math">Y</span> and over <span class="math">D</span>’s coins, if any.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Sample Distinguishability and Hellinger Distance</h2>

    <p class="text-gray-300">We start by recalling the elegant sample distinguishability game originally introduced as a mid-level abstraction in the proof of Bogdanov et al.</p>

    <p class="text-gray-300">Bogdanov et al. consider a family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span> of pairs of random variables indexed by some finite set <span class="math">A</span>. For each <span class="math">\\alpha\\in A</span>, <span class="math">X_{\\alpha}</span> and <span class="math">Y_{\\alpha}</span> take values in some finite set <span class="math">S_{\\alpha}</span> (one can assume, for conceptual simplicity and without loss of generality, that all <span class="math">S_{\\alpha}</span>’s are equal, say <span class="math">S_{\\alpha}=S</span> for all <span class="math">\\alpha</span> where <span class="math">S</span> is some sufficiently large finite set).</p>

    <p class="text-gray-300">The notation <span class="math">D^{(X_{\\alpha})_{\\alpha\\in A}}</span> indicates that a distinguisher <span class="math">D</span> is given oracle access to a family of random variables indexed by the set <span class="math">A</span>, in this case the family <span class="math">(X_{\\alpha})_{\\alpha\\in A}</span>. More precisely, this means <span class="math">D</span>’s query sequence has the form <span class="math">\\alpha_{1},\\ldots,\\alpha_{q}</span> where each <span class="math">\\alpha_{i}</span> is in <span class="math">A</span>, query <span class="math">\\alpha_{i}</span> being answered by a sample from <span class="math">X_{\\alpha_{i}}</span>. <span class="math">D</span> may repeat queries to the same <span class="math">\\alpha\\in A</span>, in which case a “fresh” sample of <span class="math">X_{\\alpha}</span> is returned each time to <span class="math">D</span>. All samples returned to <span class="math">D</span> are independent (including, thus, samples from repeated queries to the same <span class="math">\\alpha\\in A</span>). In general, <span class="math">D</span> can be adaptive.</p>

    <p class="text-gray-300"><span class="math">D</span>’s sample distinguishability advantage with respect to the family of pairs <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta_{D}^{\\sf samp}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[D^{(X_{\\alpha})_{\\alpha\\in A}}=1]-\\Pr[D^{(Y_{\\alpha})_{\\alpha\\in A}}=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">D^{(X_{\\alpha})_{\\alpha\\in A}}=1</span> indicates the event that <span class="math">D</span> outputs <span class="math">1</span> after interacting with its oracle. The <span class="math">q</span>-query sample distinguishability of the family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span> is defined as</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\sf samp}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})=\\sup_{D}\\Delta_{D}^{\\sf samp}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})</span></p>

    <p class="text-gray-300">where the <span class="math">\\sup</span> is taken over all distinguishers <span class="math">D</span> making at most <span class="math">q</span> queries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It might seem, given the independence of the various samples, that adaptivity cannot help the distinguisher. However, as Bogdanov et al. point out, this intuition is mistaken. Bodganov et al. give a somewhat hard-to-follow example with <span class="math">q=2</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math"> and </span>\\max_{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=3<span class="math"> that shows an adaptive adversary can have better advantage than a non-adaptive one. A much simpler and more intuitive example was provided to us by Liu Tianren <em>[15]</em>. In this example </span>q=2<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=3<span class="math">, and </span>\\max_{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math">. We put, more precisely, </span>A=\\{1,2,3\\}<span class="math"> and </span>S_{\\alpha}=\\{0,1\\}<span class="math"> for all </span>\\alpha\\in A=\\{1,2,3\\}<span class="math">; the pairs </span>(X_{1},Y_{1})<span class="math">, </span>(X_{2},Y_{2})<span class="math">, </span>(X_{3},Y_{3})$ are given by the probability tables</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Delta(X_{1},Y_{1})=1/3</span> <span class="math">\\Delta(X_{2},Y_{2})=1/4</span> <span class="math">\\Delta(X_{3},Y_{3})=1/4</span></p>

    <p class="text-gray-300">Here the optimal distinguisher is an adaptive distinguisher <span class="math">D</span> that first queries <span class="math">1</span>, then queries <span class="math">2</span> if the answer to the first query is <span class="math">0</span>, and otherwise queries <span class="math">3</span> if the answer to the first query is <span class="math">1</span>. One can check, then, that <span class="math">\\Delta_{D}^{\\sf samp}=\\frac{1}{2}</span>. On the other hand, one can also verify that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">D</span> non-adaptively queries <span class="math">(1,1)</span>, <span class="math">\\Delta_{D}^{\\sf samp}=1/3</span></li>

      <li>if <span class="math">D</span> non-adaptively queries <span class="math">(1,2)</span>, <span class="math">\\Delta_{D}^{\\sf samp}=5/12</span> (and similarly if <span class="math">D</span> non-adaptively queries <span class="math">(1,3)</span>)</li>

      <li>if <span class="math">D</span> non-adaptively queries <span class="math">(2,3)</span>, <span class="math">\\Delta_{D}^{\\sf samp}=1/4</span> (and similarly if <span class="math">D</span> non-adaptively queries <span class="math">(3,2)</span>)</li>

      <li>if <span class="math">D</span> non-adaptively queries <span class="math">(2,2)</span>, <span class="math">\\Delta_{D}^{\\sf samp}=7/16</span> (and similarly if <span class="math">D</span> non-adaptively queries <span class="math">(3,3)</span>). Thus, the advantage of the best adaptive distinguisher is <span class="math">\\frac{1}{2}</span> whereas the advantage of the best non-adaptive distinguisher is <span class="math">\\frac{7}{16}</span>.</li>

    </ul>

    <p class="text-gray-300">We define separately the <em>non-adaptive</em> sample distinguishibality of a family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span> as</p>

    <p class="text-gray-300"><span class="math">\\Delta_{\\sf non}^{\\sf samp}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})=\\sup_{D}\\Delta_{D}^{\\sf samp}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})</span></p>

    <p class="text-gray-300">where the sup, this time, is taken over all non-adaptive distinguishers <span class="math">D</span> making at most <span class="math">q</span> queries (a non-adaptive distinguisher is defined as a distinguisher that announces its sequence of queries <span class="math">(\\alpha_{1},\\ldots,\\alpha_{q})\\in A^{q}</span> at the start of the game, before receiving any query answers). We will prove, among others, that</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\sf samp}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\sqrt{2\\Delta_{\\sf non}^{\\sf samp}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})}</span> (2)</p>

    <p class="text-gray-300">for any family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span>. Thus, while adaptivity helps for sample distinguishability, it helps “at most quadratically”. In practice, it seems, the (potentially) quadratic discrepancy between the adaptive and non-adaptive sample distinguishability advantages makes little difference for cryptographic applications (due to the fact that there is typically little difference, e.g., between the number of non-adaptive queries necessary for reaching distinguishing advantage <span class="math">0.5</span> and the number necessary for reaching distinguishing advantage <span class="math">0.5^{2}/\\sqrt{2}</span>).</p>

    <p class="text-gray-300">We will prove (2) using Hellinger distance. Coincidentally, Hellinger distance is also the appropriate tool for upper bounding <span class="math">\\Delta_{\\sf non}^{\\sf samp}</span>—thus Hellinger distance will turn out to be “twice useful” in this paper.</p>

    <p class="text-gray-300">Given random variables <span class="math">X</span> and <span class="math">Y</span> of finite range <span class="math">S</span>, the <em>Hellinger distance</em> <span class="math">h(X,Y)</span> between <span class="math">X</span> and <span class="math">Y</span> is defined via</p>

    <p class="text-gray-300"><span class="math">h^{2}(X,Y)</span> <span class="math">:=</span> <span class="math">\\frac{1}{2}\\sum_{s\\in S}(\\sqrt{\\Pr[X=s]}-\\sqrt{\\Pr[Y=s]})^{2}</span> <span class="math">=</span> <span class="math">1-\\sum_{s\\in S}\\sqrt{\\Pr[X=s]\\Pr[Y=s]}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">where the second equality is easily verified by elementary algebra. (Thus, we emphasize, <span class="math">h(X,Y)</span> is the positive square root of the above quantities.) We note already that</p>

    <p class="text-gray-300"><span class="math">1-h^{2}(X,Y)=\\sum_{s\\in S}\\sqrt{\\Pr[X=s]\\Pr[Y=s]}</span></p>

    <p class="text-gray-300">has a fairly simple expression, which will play a role later on.</p>

    <p class="text-gray-300">Hellinger distance can be used to upper bound statistical distance and vice-versa. One has, to be precise,</p>

    <p class="text-gray-300"><span class="math">h^{2}(X,Y)\\leq\\Delta(X,Y)\\leq\\sqrt{2}h(X,Y).</span> (3)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(The first inequality follows directly from the fact that $(\\sqrt{a}-\\sqrt{b})^{2}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a-b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all real numbers </span>a,b\\geq 0$; the second inequality can be proved from Cauchy-Schwarz.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A product distribution is a random variable of the form <span class="math">X=(X_{i})_{i=1}^{n}</span> where the <span class="math">X_{i}</span>’s are (fully) independent. One can note that if <span class="math">X=(X_{i})_{i=1}^{n}</span>, <span class="math">X=(Y_{i})_{i=1}^{n}</span> are product distributions where <span class="math">X_{i}</span> and <span class="math">Y_{i}</span> have finite range <span class="math">S_{i}</span>, then</p>

    <p class="text-gray-300"><span class="math">1-h^{2}(X,Y)</span> <span class="math">=</span> <span class="math">\\sum_{(s_{1},\\ldots,s_{n})\\in S_{1}\\times\\cdots\\times S_{n}}\\sqrt{\\Pr[X=(s_{1},\\ldots,s_{n})]\\Pr[Y=(s_{1},\\ldots,s_{n})]}</span> <span class="math">=</span> <span class="math">\\sum_{(s_{1},\\ldots,s_{n})\\in S_{1}\\times\\cdots\\times S_{n}}\\sqrt{\\Pr[X_{1}=s_{1}]\\cdots\\Pr[X_{n}=s_{n}]\\Pr[Y_{1}=s_{1}]\\cdots\\Pr[Y_{n}=s_{n}]}</span> <span class="math">=</span> <span class="math">\\left(\\sum_{s_{1}\\in S_{1}}\\sqrt{\\Pr[X_{1}=s_{1}]\\Pr[Y_{1}=s_{1}]}\\right)\\cdots\\left(\\sum_{s_{n}\\in S_{n}}\\sqrt{\\Pr[X_{n}=s_{n}]\\Pr[Y_{n}=s_{n}]}\\right)</span> <span class="math">=</span> <span class="math">\\prod_{i=1}^{n}(1-h^{2}(X_{i},Y_{i}))</span> <span class="math">\\geq</span> <span class="math">1-\\sum_{i=1}^{n}h^{2}(X_{i},Y_{i})</span></p>

    <p class="text-gray-300">so, in particular,</p>

    <p class="text-gray-300"><span class="math">h^{2}(X,Y)\\leq\\sum_{i=1}^{n}h^{2}(X_{i},Y_{i})\\leq n\\max_{i}h^{2}(X_{i},Y_{i})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">h(X,Y)\\leq\\sqrt{\\sum_{i=1}^{n}h^{2}(X_{i},Y_{i})}\\leq\\sqrt{n}\\max_{i}h(X_{i},Y_{i}).</span> (4)</p>

    <p class="text-gray-300">We note that statistical distance admits the similar inequalities</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq\\sum_{i=1}^{n}\\Delta(X_{i},Y_{i})\\leq n\\max_{i}\\Delta(X_{i},Y_{i})</span> (5)</p>

    <p class="text-gray-300">but the first inequality is typically fairly loose. Usually, the inequality</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq\\sqrt{2}h(X,Y)\\leq\\sqrt{n}\\max_{i}h(X_{i},Y_{i})</span> (6)</p>

    <p class="text-gray-300">obtained by combining (3) and (4) gives a better upper bound on <span class="math">\\Delta(X,Y)</span>. (On a very simplified level, our paper’s improvement boils down to the difference between (6) and (5).) We next illustrate these</p>

    <p class="text-gray-300">concepts with an example.</p>

    <p class="text-gray-300">Example. Let <span class="math">X=(X_{i})_{i=1}^{n}</span>, <span class="math">Y=(Y_{i})_{i=1}^{n}</span> be product distributions where <span class="math">X_{1},\\ldots,X_{n}</span> are identically distributed, and so for <span class="math">Y_{1},\\ldots,Y_{n}</span>, these distributions being given by</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{i}=1]=\\frac{1}{2}+\\varepsilon\\qquad</span> <span class="math">\\Pr[X_{i}=0]=\\frac{1}{2}-\\varepsilon</span> <span class="math">\\Pr[Y_{i}=1]=\\frac{1}{2}-\\varepsilon\\qquad</span> <span class="math">\\Pr[Y_{i}=0]=\\frac{1}{2}+\\varepsilon</span></p>

    <p class="text-gray-300">for some small <span class="math">\\varepsilon</span>. Thus, <span class="math">X</span> represents <span class="math">n</span> independent samples of a coin with a <span class="math">+\\varepsilon</span> bias towards <span class="math">1</span>, whereas <span class="math">Y</span> represents <span class="math">n</span> independent samples of a coin with a <span class="math">+\\varepsilon</span> bias towards <span class="math">0</span>. One can show with a Chernoff bound that <span class="math">n=O(1/\\varepsilon^{2})</span> samples are sufficient to distinguish <span class="math">X</span> and <span class="math">Y</span>; that is,</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)=\\Delta^{\\mathsf{samp}}(n,(X_{1},Y_{1}))=\\Omega(1)</span></p>

    <p class="text-gray-300">for <span class="math">n=O(1/\\varepsilon^{2})</span>. (Here we write simply <span class="math">(X_{1},Y_{1})</span> for the family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span> whose only member is the pair <span class="math">(X_{1},Y_{1})</span>.) Also, (5) gives</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq n\\Delta(X_{1},Y_{1})=2n\\varepsilon</span></p>

    <p class="text-gray-300">which shows that <span class="math">n=O(1/\\varepsilon)</span> samples are necessary to distinguish <span class="math">X</span> and <span class="math">Y</span>—but <span class="math">O(1/\\varepsilon)</span> is a far cry from <span class="math">O(1/\\varepsilon^{2})</span>. On the other hand, (6) gives</p>

    <p class="text-gray-300"><span class="math">\\Delta(X,Y)\\leq\\sqrt{n}h(X_{1},Y_{1})=\\sqrt{n}O(\\varepsilon)</span></p>

    <p class="text-gray-300">which, indeed, shows that <span class="math">n=O(1/\\varepsilon^{2})</span> samples are necessary to distinguish the biased coins. (We skip the straightforward computation showing that <span class="math">h(X_{1},Y_{1})=O(\\varepsilon)</span>.) In this case, therefore, (6) gives a substantially better upper bound on <span class="math">\\Delta(X,Y)</span> than (5).</p>

    <p class="text-gray-300">As one of our paper’s main results, we will prove that</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\sqrt{2q}\\max_{\\alpha\\in A}h(X_{\\alpha},Y_{\\alpha})</span> (7)</p>

    <p class="text-gray-300">for any family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span>, and any <span class="math">q\\in\\mathbb{N}</span>. Note that (7) generalizes (6) since, obviously, <span class="math">\\Delta(X,Y)\\leq\\Delta^{\\mathsf{samp}}(n,(X_{i},Y_{i})_{i\\in[n]})</span> for product distributions <span class="math">X=(X_{i})_{i=1}^{n}</span>, <span class="math">Y=(Y_{i})_{i=1}^{n}</span>. We continue with, as our main goal, a proof of (7).</p>

    <p class="text-gray-300">By a standard argument</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})=\\sup_{D}\\Delta_{D}^{\\mathsf{samp}}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})</span></p>

    <p class="text-gray-300">with the <span class="math">\\sup</span> taken over all deterministic (adaptive) distinguishers <span class="math">D</span> making at most <span class="math">q</span> queries. Thus we can restrict our attention to deterministic distinguishers.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The “query strategy” of a deterministic <span class="math">q</span>-query distinguisher <span class="math">D</span> for a family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span> can be encoded as a tree of depth <span class="math">q</span>. Each non-leaf node of the tree is labeled by a query <span class="math">\\alpha\\in A</span> where, e.g., the root of the tree is labeled by <span class="math">D</span>’s first query. For a node labeled <span class="math">\\alpha</span>, there are $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> children for that node, each child corresponding to some element of </span>S_{\\alpha}<span class="math">, where </span>S_{\\alpha}<span class="math"> (we recall) is the range of </span>X_{\\alpha}<span class="math"> and </span>Y_{\\alpha}<span class="math">. When </span>D<span class="math"> makes its queries, it follows the tree downward from the root to a leaf according to the answers it receives from its oracle. Finally, each leaf is labeled with a decision: </span>0<span class="math"> or </span>1<span class="math">. Such a labeled tree fully describes a deterministic, adaptive distinguisher </span>D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Take now some arbitrary (deterministic, adaptive, <span class="math">q</span>-query) <span class="math">D</span>, let <span class="math">T</span> be the tree associated to <span class="math">D</span>, and let <span class="math">r</span> be the root of <span class="math">T</span>. We write <span class="math">T_{v}</span> for the subtree of <span class="math">T</span> rooted at <span class="math">v\\in V(T)</span> and write <span class="math">\\mathrm{lf}(T_{v})</span> for the set of leaves of <span class="math">T_{v}</span>. Thus <span class="math">T=T_{r}</span>. For <span class="math">\\ell\\in\\mathrm{lf}(T_{v})</span> we write <span class="math">P_{X}(v\\to\\ell)</span> for the probability that leaf</p>

    <p class="text-gray-300"><span class="math">\\ell</span> is reached if queries start at <span class="math">v</span> and the oracle is <span class="math">(X_{\\alpha})_{\\alpha\\in A}</span>. <span class="math">P_{Y}(v\\to\\ell)</span> is similarly defined. We also define <span class="math">P_{X}(\\ell\\to\\ell)=P_{Y}(\\ell\\to\\ell)=1</span> for any leaf <span class="math">\\ell</span>. We let <span class="math">L_{X}^{T}</span>, <span class="math">L_{Y}^{T}</span> be random variables of range <span class="math">\\operatorname{lf}(T)</span>, such that <span class="math">\\Pr[L_{X}^{T}=\\ell]=P_{X}(r\\to\\ell)</span> and <span class="math">\\Pr[L_{Y}^{T}=\\ell]=P_{Y}(r\\to\\ell)</span>. In other words, <span class="math">L_{X}^{T}</span> is distributed according to the probability that <span class="math">D</span> lands at a given leaf when the oracle is <span class="math">(X_{\\alpha})_{\\alpha\\in A}</span>, and likewise with <span class="math">L_{Y}^{T}</span> and <span class="math">(Y_{\\alpha})_{\\alpha\\in A}</span>. It is easy to see, then, that <span class="math">\\Delta_{D}^{\\mathsf{samp}}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\Delta(L_{X}^{T},L_{Y}^{T})</span> (and, moreover, <span class="math">\\Delta_{D}^{\\mathsf{samp}}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})=\\Delta(L_{X}^{T},L_{Y}^{T})</span> if <span class="math">D</span> labels the leaves intelligently, e.g., if leaf <span class="math">\\ell</span> has label <span class="math">1</span> if and only if <span class="math">\\Pr[L_{X}^{T}=\\ell]\\geq\\Pr[L_{Y}^{T}=\\ell]</span>). In particular, by (3),</p>

    <p class="text-gray-300"><span class="math">\\Delta_{D}^{\\mathsf{samp}}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\Delta(L_{X}^{T},L_{Y}^{T})\\leq\\sqrt{2}h(L_{X}^{T},L_{Y}^{T}).</span> (8)</p>

    <p class="text-gray-300">Say a tree <span class="math">T^{\\prime}</span> is non-adaptive if all the nodes at a given level of the tree have the same label. Obviously, the tree associated to a non-adaptive adversary (viewed as a special case of an adaptive adversary) is a non-adaptive tree. We will show:</p>

    <p class="text-gray-300"><span class="math">\\exists\\text{ non-adaptive }T^{\\prime}\\text{ of depth }q\\text{ s.t.}\\forall\\text{ adaptive }T\\text{ of depth }q,\\&gt;h(L_{X}^{T},L_{Y}^{T})\\leq h(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})</span> (9)</p>

    <p class="text-gray-300">In other words, adaptivity does not help for maximizing the Hellinger distance between the probability distributions on the leaves (even though it does help for maximizing the statistical distance between the distributions on the leaves).</p>

    <p class="text-gray-300">For convenience, we define</p>

    <p class="text-gray-300"><span class="math">H(T)</span> <span class="math">=</span> <span class="math">1-h^{2}(L_{X}^{T},L_{Y}^{T})</span> <span class="math">=</span> <span class="math">\\sum_{\\ell\\in\\operatorname{lf}(T)}\\sqrt{\\Pr[L_{X}^{T}=\\ell]\\Pr[L_{Y}^{T}=\\ell]}</span></p>

    <p class="text-gray-300">for a tree <span class="math">T</span>. Then (9) is equivalent to</p>

    <p class="text-gray-300"><span class="math">\\exists\\text{ non-adaptive }T^{\\prime}\\text{ of depth }q\\text{ s.t.}\\forall\\text{ adaptive }T\\text{ of depth }q,\\&gt;H(L_{X}^{T},L_{Y}^{T})\\geq H(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}}).</span> (10)</p>

    <p class="text-gray-300">We prove (10) by induction on <span class="math">q</span>. When <span class="math">q=1</span> the result is obvious, since it suffices to define <span class="math">T^{\\prime}</span> to be the depth-<span class="math">1</span> tree whose root is labeled by the element <span class="math">\\beta\\in A</span> that maximizes <span class="math">h(X_{\\beta},Y_{\\beta})</span> (i.e., that minimizes <span class="math">H(X_{\\beta},Y_{\\beta})</span>). The fact that <span class="math">A</span> is finite guarantees the existence of such a <span class="math">\\beta</span>.</p>

    <p class="text-gray-300">For the induction step, assume that (10) has been established for <span class="math">q\\leq t</span>, and let <span class="math">T^{\\prime}_{t}</span> be the tree <span class="math">T^{\\prime}</span> satisfying (10) for <span class="math">q=t</span>. Let <span class="math">T</span> be an arbitrary tree of depth <span class="math">t+1</span>. Let <span class="math">T(v)</span> denote the subtree of <span class="math">T</span> rooted at <span class="math">v\\in V(T)</span> (thus, for example, <span class="math">T=T(r)</span> where <span class="math">r</span> is the root of <span class="math">T</span>). Let the root <span class="math">r</span> of <span class="math">T</span> have label <span class="math">\\alpha_{r}\\in A</span>, where <span class="math">X_{\\alpha_{r}}</span>, <span class="math">Y_{\\alpha_{r}}</span> have range <span class="math">S_{\\alpha_{r}}</span>, and assume that <span class="math">r</span>’s children in <span class="math">T</span> are <span class="math">\\{v_{s}:s\\in S_{\\alpha_{r}}\\}</span>. Then</p>

    <p class="text-gray-300"><span class="math">H(T)</span> <span class="math">=</span> <span class="math">H(L_{X}^{T},L_{Y}^{T})</span> <span class="math">=</span> <span class="math">\\sum_{\\ell\\in\\operatorname{lf}(T)}\\sqrt{\\Pr[L_{X}^{T}=\\ell]\\Pr[L_{Y}^{T}=\\ell]}</span> <span class="math">=</span> <span class="math">\\sum_{s\\in S_{\\alpha_{r}}}\\sum_{\\ell\\in\\operatorname{lf}(T(v_{s}))}\\sqrt{\\Pr[X_{\\alpha_{r}}=v_{s}]\\Pr[L_{X}^{T(v_{s})}=\\ell]\\Pr[Y_{\\alpha_{r}}=v_{s}]\\Pr[L_{Y}^{T(v_{s})}=\\ell]}</span> <span class="math">=</span> <span class="math">\\sum_{s\\in S_{\\alpha_{r}}}\\sqrt{\\Pr[X_{\\alpha_{r}}=v_{s}]\\Pr[Y_{\\alpha_{r}}=v_{s}]}\\sum_{\\ell\\in\\operatorname{lf}(T(v_{s}))}\\sqrt{\\Pr[L_{X}^{T(v_{s})}=\\ell]\\Pr[L_{Y}^{T(v_{s})}=\\ell]}</span> <span class="math">=</span> <span class="math">\\sum_{s\\in S_{\\alpha_{r}}}\\sqrt{\\Pr[X_{\\alpha_{r}}=v_{s}]\\Pr[Y_{\\alpha_{r}}=v_{s}]}H(T(v_{s}))</span> <span class="math">\\geq</span> <span class="math">\\sum_{s\\in S_{\\alpha_{r}}}\\sqrt{\\Pr[X_{\\alpha_{r}}=v_{s}]\\Pr[Y_{\\alpha_{r}}=v_{s}]}H(T^{\\prime})</span></p>

    <p class="text-gray-300">w</p>

    <p class="text-gray-300"><span class="math">H(T^{\\prime}_{t})\\sum_{s\\in S_{\\alpha_{r}}}\\sqrt{\\Pr[X_{\\alpha_{r}}=v_{s}]\\Pr[Y_{\\alpha_{r}}=v_{s}]}</span> <span class="math">=</span> <span class="math">H(T^{\\prime}_{t})H(X_{\\alpha_{r}},Y_{\\alpha_{r}}).</span></p>

    <p class="text-gray-300">On the other hand, if we define <span class="math">T^{\\prime}_{t+1}</span> to be the non-adaptive tree whose root is labeled by the element <span class="math">\\beta\\in A</span> that minimizes <span class="math">H(X_{\\beta},Y_{\\beta})</span> and whose first-level subtrees are each equal to <span class="math">T^{\\prime}_{t}</span>, then</p>

    <p class="text-gray-300"><span class="math">H(T^{\\prime}_{t+1})=H(T^{\\prime}_{t})H(X_{\\beta},Y_{\\beta})\\leq H(T^{\\prime}_{t})H(X_{\\alpha_{r}},Y_{\\alpha_{r}})</span></p>

    <p class="text-gray-300">so that <span class="math">H(T^{\\prime}_{t+1})\\leq H(T)</span>, as desired. This establishes (10) and (9).</p>

    <p class="text-gray-300">Now let <span class="math">T^{\\prime}</span> be the non-adaptive tree of depth <span class="math">q</span> whose existence is guaranteed by (9) and let <span class="math">D^{\\prime}</span> be the non-adaptive adversary associated to <span class="math">T^{\\prime}</span>, where we label the leaves of <span class="math">T^{\\prime}</span> such that <span class="math">\\ell\\in\\textrm{lf}(T^{\\prime})</span> has label <span class="math">1</span> if and only if <span class="math">\\Pr[L_{X}^{T^{\\prime}}=\\ell]\\geq\\Pr[L_{Y}^{T^{\\prime}}=\\ell]</span>. Then <span class="math">\\Delta^{\\mathsf{samp}}_{D^{\\prime}}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})=\\Delta(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})</span> and for any <span class="math">q</span>-query adaptive distinguisher <span class="math">D</span> with tree <span class="math">T</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}_{D}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\Delta(L_{X}^{T},L_{Y}^{T})\\leq\\sqrt{2}h(L_{X}^{T},L_{Y}^{T})\\leq\\sqrt{2}h(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})\\leq\\sqrt{2q}\\max_{\\alpha\\in A}h(X_{\\alpha},Y_{\\alpha})</span> (11)</p>

    <p class="text-gray-300">where: (i) the second inequality follows by (3), (ii) the third inequality follows by the choice of <span class="math">T^{\\prime}</span>, (iii) the fourth inequality follows by (6) because <span class="math">h(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})=h(X,Y)</span> where <span class="math">X</span>, <span class="math">Y</span> are the product distributions <span class="math">(X_{\\alpha_{i}})_{i=1}^{q}</span>, <span class="math">(Y_{\\alpha_{i}})_{i=1}^{q}</span>, where <span class="math">\\alpha_{i}</span> is the label on the <span class="math">i</span>-th level of <span class="math">T^{\\prime}</span>. Thus we have proved (7), which we record as a lemma:</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">For any family <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A}</span>, <span class="math">A</span> finite, we have</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\sqrt{2q}\\max_{\\alpha\\in A}h(X_{\\alpha},Y_{\\alpha})</span></p>

    <p class="text-gray-300">for all <span class="math">q\\in\\mathbb{N}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(One can observe that the case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=q=1$ of Lemma 1 is equivalent to the right-hand inequality in (3).)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the sequence of inequalities in (11) can be used to directly relate the adaptive and non-adaptive sample distinguishability advantages. More exactly, since</p>

    <p class="text-gray-300"><span class="math">\\sqrt{2}h(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})\\leq\\sqrt{2\\Delta(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})}=\\sqrt{2\\Delta^{\\mathsf{samp}}_{D^{\\prime}}((X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})}=\\sqrt{2\\Delta^{\\mathsf{samp}}_{\\mathsf{non}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})}</span></p>

    <p class="text-gray-300">with <span class="math">T^{\\prime}</span> and <span class="math">D^{\\prime}</span> as in (11), and since <span class="math">D</span> is an arbitrary <span class="math">q</span>-query distinguisher, we find</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})\\leq\\sqrt{2}h(L_{X}^{T^{\\prime}},L_{Y}^{T^{\\prime}})\\leq\\sqrt{2\\Delta^{\\mathsf{samp}}_{\\mathsf{non}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A})}</span></p>

    <p class="text-gray-300">which proves (2). We point out that we do not know the extent to which (2) is sharp. Indeed, it remains an interesting open problem to either find some sequence of examples showing that (2) is sharp (up to a possible constant factor), or else to display an even closer relationship between adaptive and non-adaptive sample distinguishabilities. In all events, however, we shall have no further use for (2), our main tool being Lemma 1.</p>

    <p class="text-gray-300">We finally note, parenthetically, that sample distinguishability is loosely related to the notion of <em>free-start distinguishability</em> defined by Gazl and Maurer <em>[7]</em>. More precisely, sample distinguishability can be seen as taking the idea of free-start indistinguishability to its logical extreme, whereby the distinguisher is “repeatedly given a free start” at each query. (In fact, this establishes a general connection between sample indistinguishability and general indistinguishability.)</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: The two worlds for the Even-Mansour security experiment. In World 1 the distinguisher  <span class="math">D</span>  has oracle access to random permutations  <span class="math">P_{1},\\ldots ,P_{t}</span>  and the key-alternating cipher  <span class="math">E_{k}</span>  (cf. Eq. (1)) for a random key  <span class="math">k</span> . In World 2,  <span class="math">D</span>  has oracle access to  <span class="math">t + 1</span>  independent random permutations. In either world  <span class="math">D</span>  also has oracle access to the inverse of each permutation.</p>

    <p class="text-gray-300">We define the PRP security of a  <span class="math">t</span> -round key-alternating cipher  <span class="math">E</span>  (cf. (1)) against a distinguisher (or "adversary")  <span class="math">D</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {E, t} ^ {\\mathrm {P R P}} (D) = \\Pr [ k = k _ {0} \\dots k _ {t} \\longleftarrow \\{0, 1 \\} ^ {t (n + 1)}; D ^ {E _ {k}, P _ {1}, \\dots , P _ {t}} = 1 ] - \\Pr [ D ^ {Q, P _ {1}, \\dots , P _ {t}} = 1 ]</span></div>

    <p class="text-gray-300">where in each experiment  <span class="math">Q</span> ,  <span class="math">P_{1},\\ldots ,P_{t}</span>  are independent uniform random permutations, where  <span class="math">D</span>  is also allowed to query the inverse of each of its oracles (see Figure 2), and where  <span class="math">k = k_{0}\\dots k_{t}</span>  is selected uniformly at random (and hidden from  <span class="math">D</span> ). We further define</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {E, t} ^ {\\mathrm {P R P}} (q) = \\max _ {D} \\mathbf {A d v} _ {E, t} ^ {\\mathrm {P R P}} (D)</span></div>

    <p class="text-gray-300">where the maximum is taken over all adversaries  <span class="math">D</span>  making at most  <span class="math">q</span>  queries. (The notation  <span class="math">\\mathbf{Adv}_{E,t}^{\\mathrm{PRP}}(\\cdot)</span>  is thus overloaded.) We also note that, besides  <span class="math">t</span> ,  <span class="math">n</span>  is a parameter on which  <span class="math">E</span>  (and hence  <span class="math">\\mathbf{Adv}_{E,t}^{\\mathrm{PRP}}(q)</span> ) depends (and naturally enough, since  <span class="math">n</span>  is the "security parameter").</p>

    <p class="text-gray-300">Our main result is the following:</p>

    <p class="text-gray-300">Theorem 1 Let  <span class="math">N = 2^n</span>  and let  <span class="math">q = N^{\\frac{t}{t + 1}} / Z</span>  for some  <span class="math">Z \\geq 1</span> . Then, for any  <span class="math">t \\geq 1</span>  and assuming  <span class="math">q &amp;lt; \\min(N / 100, N / 5t)</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {A} \\boldsymbol {d v} _ {E, t} ^ {\\mathrm {P R P}} (q) \\leq \\frac {3 q ^ {2} t}{N ^ {1 . 5}} + \\frac {t + 1}{Z ^ {t}}.</span></div>

    <p class="text-gray-300">The above theorem is void for  <span class="math">q &amp;gt; N^{\\frac{t}{t + 1}}</span>  since  <span class="math">Z \\geq 1</span> . Thus, the provable security achieved is always at most  <span class="math">N^{\\frac{t}{t + 1}}</span>  queries. On the other hand, the term  <span class="math">3q^{2}t / N^{1.5}</span>  also caps security at  <span class="math">q = N^{\\frac{3}{4}}</span> . Thus, roughly, Theorem 1 implies indistinguishability of the Even-Mansour cipher up to</p>

    <div class="my-4 text-center"><span class="math-block">q \\approx \\min (2 ^ {\\frac {3}{4} n}, 2 ^ {\\frac {t}{t + 1} n})</span></div>

    <p class="text-gray-300">queries, which is sharp for  <span class="math">t \\leq 3</span> . We shall keep  <span class="math">N = 2^n</span>  for the remainder of the article.</p>

    <p class="text-gray-300">For a large part, our proof follows the outline of Bogdanov et al. [1]. As in [1], instead of giving  <span class="math">D</span>  oracle access to the tuple of oracles</p>

    <div class="my-4 text-center"><span class="math-block">E _ {k}, P _ {1}, \\dots , P _ {t}</span></div>

    <p class="text-gray-300">in "world 1", we give it oracle access to the oracles</p>

    <div class="my-4 text-center"><span class="math-block">E _ {k} ^ {- 1}, P _ {1}, \\ldots , P _ {t}</span></div>

    <p class="text-gray-300">(since the inverses can be queried, this is clearly a cosmetic change—moreover the corresponding change has no effect in world 2, since <span class="math">Q</span> is anyway a uniform random permutation). We also rename <span class="math">E_{k}^{-1}</span> as <span class="math">P_{0}</span> so that, in “world 1”, <span class="math">D</span>’s oracles become a <span class="math">(t+1)</span>-tuple</p>

    <p class="text-gray-300"><span class="math">P_{0},P_{1},\\ldots,P_{t}</span></p>

    <p class="text-gray-300">with the property that</p>

    <p class="text-gray-300"><span class="math">P_{t}(P_{t-1}(\\cdots P_{2}(P_{1}(P_{0}(\\cdot)\\oplus k_{0})\\oplus k_{1})\\oplus k_{2}\\cdots)\\oplus k_{t-1})\\oplus k_{t}=id.</span> (12)</p>

    <p class="text-gray-300">We can indeed think of <span class="math">D</span>’s <span class="math">t+1</span> oracles <span class="math">P_{0},\\ldots,P_{t}</span> as being constructed as follows in world 1: first the key <span class="math">k_{0}\\cdots k_{t}</span> is sampled, after which permutations <span class="math">P_{0},\\ldots,P_{t}</span> are sampled uniformly at random from all <span class="math">(t+1)</span>-tuples <span class="math">(P_{0},\\ldots,P_{t})</span> satisfying (12). (In turn, one way of implementing the latter sampling is to sample <span class="math">t</span> of the <span class="math">t+1</span> permutations <span class="math">P_{0},\\ldots,P_{t}</span> uniformly and independently at random, and to define the remaining <span class="math">(t+1)</span>-th permutation via (12).)</p>

    <p class="text-gray-300">Following <em>[1]</em>, we formally implement the interface of oracles <span class="math">(P_{0},\\ldots,P_{t})</span> in world 1 via an oracle <span class="math">O(N,t)</span> taking <span class="math">k_{0},\\ldots,k_{t}</span> as implicit parameters. This oracle uses lazy sampling to define <span class="math">P_{0},\\ldots,P_{t}</span>. Originally the <span class="math">P_{i}</span>’s are undefined at all points. Subsequently, when the adversary makes a query <span class="math">P_{i}(x)</span> (the case of a backward query <span class="math">P_{i}^{-1}(x)</span> is similarly handled) the oracle <span class="math">O(N,t)</span> defines <span class="math">P_{i}(x)</span> according to the following procedure:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathcal{P}=\\mathcal{P}(P_{0},\\ldots,P_{t})</span> be the set of all <span class="math">(t+1)</span>-tuples of permutations <span class="math">(\\overline{P}_{0},\\ldots,\\overline{P}_{t})</span> such that <span class="math">\\overline{P}_{i}</span> extends the currently defined portion of <span class="math">P_{i}</span>, and such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\overline{P}_{t}(\\cdots\\overline{P}_{2}(\\overline{P}_{1}(\\overline{P}_{0}(\\cdot)\\oplus k_{0})\\oplus k_{1})\\cdots\\oplus k_{t-1})\\oplus k_{t}=id.</span> (13)</p>

    <p class="text-gray-300">Then <span class="math">O(N,t)</span> samples uniformly at random an element <span class="math">(\\overline{P}_{0},\\ldots,\\overline{P}_{t})</span> from <span class="math">\\mathcal{P}</span>. The oracle sets <span class="math">P_{i}(x)=\\overline{P}_{i}(x)</span> and returns this value.</p>

    <p class="text-gray-300">After the above, the oracle “forgets” about <span class="math">\\overline{P}_{0},\\ldots,\\overline{P}_{t}</span>, and samples these afresh at the next query. It is clear that this lazy sampling process gives the same distribution as sampling the tuple <span class="math">(P_{0},\\ldots,P_{t})</span> at the start of the game.</p>

    <p class="text-gray-300">In view of applying a hybrid argument, Bogdanov et al. also define a second oracle <span class="math">\\tilde{O}(N,t)</span>. This oracle also defines the permutations <span class="math">P_{0},\\ldots,P_{t}</span> via lazy sampling, and also takes the key <span class="math">k_{0}\\cdots k_{t}</span> as an implicit input, but this time the lazy sampling process is a bit different.</p>

    <p class="text-gray-300">We say that a sequence of partially defined permutations <span class="math">P_{0},\\ldots,P_{t}</span> is <em>consistent</em> if <span class="math">\\mathcal{P}(P_{0},\\ldots,P_{t})\\neq\\emptyset</span>, with <span class="math">\\mathcal{P}(\\cdot)</span> defined as in the description of <span class="math">O(N,t)</span> above. Initially, <span class="math">\\tilde{O}(N,t)</span> sets the permutations <span class="math">P_{0},\\ldots,P_{t}</span> to be undefined everywhere. Upon receiving a forward query <span class="math">P_{i}(x)</span>, <span class="math">\\tilde{O}(N,t)</span> uses the following lazy sampling procedure:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">U\\subseteq\\{0,1\\}^{n}</span> be the set of values <span class="math">y</span> such that defining <span class="math">P_{i}(x)=y</span> maintains the consistency of <span class="math">P_{0},\\ldots,P_{t}</span>, besides maintaining the fact that <span class="math">P_{i}</span> is a permutation. Then <span class="math">\\tilde{O}(N,t)</span> samples a value <span class="math">y</span> uniformly from <span class="math">U</span>, sets <span class="math">P_{i}(x)=y</span>, and returns <span class="math">y</span>.</li>

    </ul>

    <p class="text-gray-300">Inverse queries are similarly treated. While it may not be immediately apparent that <span class="math">\\tilde{O}(N,t)</span>’s answers are distributed any differently from <span class="math">O(N,t)</span>’s, small examples can be constructed to show that, indeed, these two oracles are statistically non-equivalent.</p>

    <p class="text-gray-300">Theorem 1 is, via a hybrid argument, the direct consequence of the following two propositions:</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Proposition 1</h6>

    <p class="text-gray-300">Let <span class="math">q&lt;\\min(N/100,N/5t)</span>. With <span class="math">O(N,t)</span> and <span class="math">\\tilde{O}(N,t)</span> defined as above,</p>

    <p class="text-gray-300"><span class="math">\\Pr[k_{0},\\ldots,k_{t}\\leftarrow\\{0,1\\}^{n};D^{O(N,t)}=1]-\\Pr[k_{0},\\ldots,k_{t}\\leftarrow\\{0,1\\}^{n};D^{\\tilde{O}(N,t)}=1]\\leq\\frac{3q^{2}t}{N^{1.5}}</span></p>

    <p class="text-gray-300">for every distinguisher <span class="math">D</span> making at most <span class="math">q</span> queries.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Proposition 2</h6>

    <p class="text-gray-300">Let <span class="math">q=N^{\\frac{t}{t+1}}/Z</span> for some <span class="math">Z\\geq 1</span> be such that <span class="math">q&lt;N/3</span>. With <span class="math">\\tilde{O}(N,t)</span> defined as above,</p>

    <p class="text-gray-300"><span class="math">\\Pr[k_{0},\\ldots,k_{t}\\leftarrow\\{0,1\\}^{n};D^{\\tilde{O}(N,t)}=1]-\\Pr[D^{Q_{0},\\ldots,Q_{t}}=1]\\leq\\frac{t+1}{Z^{t+1}}.</span></p>

    <p class="text-gray-300">for every distinguisher <span class="math">D</span> making at most <span class="math">q</span> queries, where <span class="math">Q_{0},\\ldots,Q_{t}</span> are independent random permutations.</p>

    <p class="text-gray-300">Proposition 2 is proved in <em>[1]</em>. A weaker form of Proposition 1 is also proved in <em>[1]</em>, with a bound of <span class="math">4.3q^{3}t/N^{2}</span> instead of <span class="math">3q^{2}t/N^{1.5}</span>. The rest of the paper is devoted to the proof of Proposition 1.</p>

    <p class="text-gray-300">We use a sample distinguishability game to prove Proposition 1. This is the same sample distinguishability game used by Bogdanov et al. for the proof of “their” version of Proposition 1. Only the game’s analysis will be different.</p>

    <p class="text-gray-300">In view of defining this game, Bogdanov et al. first note that the adversary <span class="math">D</span> can only have better advantage at distinguishing <span class="math">O(N,t)</span> from <span class="math">\\tilde{O}(N,t)</span> if we tell <span class="math">D</span> the keys <span class="math">k_{0},\\ldots,k_{t}</span> (indeed, <span class="math">D</span> is free to disregard this information). Nextly, they observe that one can further reduce to the case in which <span class="math">k_{0}=\\ldots=k_{t}=0^{n}</span> (<em>[1]</em> Proposition 4). (In the latter case, moreover, <span class="math">D</span> obviously does not need to be “told” <span class="math">k_{0},\\ldots,k_{t}</span>.) Letting</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{O\\tilde{O};0^{n}}_{N,t}(D)=\\Pr[k_{0}=\\cdots=k_{t}=0^{n};D^{O(N,t)}=1]-\\Pr[k_{0}=\\cdots=k_{t}=0^{n};D^{\\tilde{O}(N,t)}=1].</span></p>

    <p class="text-gray-300">denote the advantage of an adversary <span class="math">D</span> at distinguishing <span class="math">O(N,t)</span> and <span class="math">\\tilde{O}(N,t)</span> implemented with zero keys, it thus suffices to prove</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{O\\tilde{O};0^{n}}_{N,t}(q)\\leq\\frac{3q^{2}t}{N^{1.5}}</span> (14)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{Adv}^{O\\tilde{O};0^{n}}_{N,t}(q)</span> is defined as the sup of <span class="math">\\mathbf{Adv}^{O\\tilde{O};0^{n}}_{N,t}(D)</span> taken over all <span class="math">q</span>-query distinguishers <span class="math">D</span>.</p>

    <p class="text-gray-300">When the keys are zero, <span class="math">O(N,t)</span> and <span class="math">\\tilde{O}(N,t)</span> offer, essentially, two slightly different methods of lazy sampling permutations <span class="math">P_{0},\\ldots,P_{t}</span> subject to the constraint</p>

    <p class="text-gray-300"><span class="math">P_{t}(\\cdots P_{1}(P_{0}(\\cdot))\\cdots)=id.</span> (15)</p>

    <p class="text-gray-300">Moreover, the oracles <span class="math">O(N,t)</span> and <span class="math">\\tilde{O}(N,t)</span> maintain no “internal” data structures between queries that are hidden from the distinguisher. (Indeed, the only data structures that <span class="math">O(N,t)</span> and <span class="math">\\tilde{O}(N,t)</span> remember between queries are the tables <span class="math">P_{0},\\ldots,P_{t}</span>, and the state of these tables is known to the distinguisher <span class="math">D</span> who has made the queries to fill them.) More precisely, if we let <span class="math">\\ell_{i}</span> be the number of points at which <span class="math">P_{i}</span> (or <span class="math">P_{i}^{-1}</span>) is defined before <span class="math">D</span>’s <span class="math">i</span>-th query, then <span class="math">\\ell_{0}+\\cdots+\\ell_{t}=i-1</span> when <span class="math">D</span> makes its <span class="math">i</span>-th query, assuming (wlog) that <span class="math">D</span> has made no redundant queries. We can imagine further strengthening <span class="math">D</span> by giving <span class="math">D</span> the ability to reset the state of the data structures <span class="math">P_{0},\\ldots,P_{t}</span> arbitrarily between queries, subject to the constraint (say) that each <span class="math">P_{i}</span> is defined at at most <span class="math">q</span> points. Giving this added power to <span class="math">D</span> brings us to a sample distinguishability game <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}}</span> in which in which the index set <span class="math">A_{0}</span> corresponds to all possible partial settings of the permutations <span class="math">P_{0},\\ldots,P_{t}</span> available to <span class="math">D</span> and in which the <span class="math">X</span>-world and <span class="math">Y</span>-world correspond to <span class="math">O(N,t)</span> and <span class="math">\\tilde{O}(N,t)</span>, respectively. (We write <span class="math">A_{0}</span> instead of <span class="math">A</span> in order to distinguish this specific sample distinguishability from the generic sample distinguishability game discussed in Section 1.)</p>

    <p class="text-gray-300">We now make a number of definitions to describe the above sample distinguishability game <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}}</span> more formally. In particular, we will encode the (partially defined) permutations <span class="math">P_{0},\\ldots,P_{t}</span> as matchings, to remain consistent with the terminology of <em>[1]</em>. The following few definitions, indeed, are more or less all cut-and-pasted from <em>[1]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">V_{0},\\ldots,V_{t},V_{t+1}</span> be vertex sets with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N<span class="math"> and where we identify </span>V_{t+1}<span class="math"> with </span>V_{0}<span class="math">. A sequence of matchings </span>\\overline{M}=(\\overline{M}_{0},\\ldots,\\overline{M}_{t+1})<span class="math"> where </span>\\overline{M}_{i}<span class="math"> is a perfect matching between </span>V_{i}<span class="math"> and </span>V_{i+1}$ is called circular</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">if every path starting at a vertex <span class="math">v\\in V_{0}</span> following the edges in <span class="math">\\overline{M}_{0},\\ldots,\\overline{M}_{t}</span> ends at the same vertex <span class="math">v\\in V_{t+1}=V_{0}</span>. In other words, circularity is the matching equivalent of (15).</p>

    <p class="text-gray-300">Given a sequence <span class="math">M=(M_{0},\\ldots,M_{t})</span> where each <span class="math">M_{i}</span> is a partial matching between <span class="math">V_{i}</span> and <span class="math">V_{i+1}</span>, we let</p>

    <p class="text-gray-300"><span class="math">\\mathcal{M}(M)</span></p>

    <p class="text-gray-300">be the set of all circular sequences <span class="math">\\overline{M}</span> extending <span class="math">M</span>, i.e. the set of all sequences <span class="math">\\overline{M}=(\\overline{M}_{0},\\ldots,\\overline{M}_{t})</span> such that <span class="math">\\overline{M}_{i}</span> extends <span class="math">M_{i}</span> for each <span class="math">i</span> and such that <span class="math">\\overline{M}</span> is circular. We say <span class="math">M</span> is <em>consistent</em> if <span class="math">\\mathcal{M}(M)\\neq\\emptyset</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A <em><span class="math">q</span>-configuration</em> is a pair <span class="math">(v_{0},M)</span> such that (i) <span class="math">M=(M_{0},\\ldots,M_{t})</span> is a consistent sequence of partial matchings such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q<span class="math"> for all </span>i<span class="math">, (ii) </span>v_{0}\\in V_{0}<span class="math"> is nonadjacent to </span>M_{0}<span class="math">. The index set </span>A_{0}<span class="math"> of the sample distinguishability game will be the set of all </span>q$-configurations. That is,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">A_{0}=\\{(v_{0},M):(v_{0},M)\\text{ is a </span>q<span class="math">-configuration}\\}.</span></p>

    <p class="text-gray-300">We next describe the distributions <span class="math">X_{\\alpha}</span> and <span class="math">Y_{\\alpha}</span>. Let <span class="math">\\alpha=(v_{0},M)\\in A_{0}</span> be a <span class="math">q</span>-configuration, <span class="math">M=(M_{0},\\ldots,M_{t})</span>. For any vertex <span class="math">u\\in V_{1}</span> nonadjacent to <span class="math">M_{0}</span>, we write <span class="math">M\\cup\\{(v_{0},u)\\}</span> for the sequence of partial matchings <span class="math">(M_{0}\\cup\\{(v_{0},u)\\},M_{1},\\ldots,M_{t})</span>. Let <span class="math">U\\subseteq V_{1}</span> be the set of vertices <span class="math">u</span> such that <span class="math">M\\cup\\{(v_{0},u)\\}</span> is consistent. We define</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{\\alpha}=u]:=\\frac{\\mathcal{M}(M\\cup\\{(v_{0},u)\\})}{\\mathcal{M}(M)}.</span></p>

    <p class="text-gray-300">We note that <span class="math">X_{\\alpha}</span> is a probability distribution on <span class="math">U</span>, and that <span class="math">X_{\\alpha}</span> is equidistributed to <span class="math">O(N,t)</span> queried at <span class="math">P_{0}(v_{0})</span> with keys <span class="math">k_{0}=\\ldots=k_{t}=0^{n}</span> and with <span class="math">P_{0},\\ldots,P_{t}</span> defined such that <span class="math">P_{i}(x)=y\\iff(x,y)\\in M_{i}</span>. As for <span class="math">Y_{\\alpha}</span>, it is simply the uniform distribution on <span class="math">U</span>. Thus <span class="math">Y_{\\alpha}</span> is equidistributed to <span class="math">\\tilde{O}(N,t)</span> under the same correspondence. This completes the description of the sample distinguishability game <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}}</span> (parameterized by <span class="math">N</span> and <span class="math">t</span>).</p>

    <p class="text-gray-300">We note the restriction of the sample distinguishability game to queries of the form <span class="math">P_{0}(\\cdot)</span> is without loss of generality, by symmetry considerations and because the distinguisher can “set up” the matchings as it wants. Thus</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{N,t}^{O\\tilde{O};0^{n}}(q)\\leq\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}})</span></p>

    <p class="text-gray-300">since the sample distinguishability game only gives more power to the distinguisher and, in particular, it suffices to show</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}})\\leq\\frac{3q^{2}t}{N^{1.5}}\\text{ when }q&lt;N/100</span> (16)</p>

    <p class="text-gray-300">in order to prove Proposition 1. To prove (16) we combine Lemma 1 with a rather technical analysis upper bounding <span class="math">\\max_{\\alpha\\in A_{0}}h(X_{\\alpha},Y_{\\alpha})</span>. The latter analysis has two basic components: a combinatorial characterization of the “shape” of the distribution <span class="math">X_{\\alpha}</span> (recall <span class="math">Y_{\\alpha}</span> is uniform), and, secondly, an upper bound on <span class="math">h(X_{\\alpha},Y_{\\alpha})</span> based on this combinatorial characterization. These two components correspond, in that order, to the following two propositions:</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Proposition 3</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">q&lt;N/3</span>, let <span class="math">(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}}</span> be the sample distinguishability game described above, and let <span class="math">\\alpha=(v_{0},M)\\in A_{0}</span> be a <span class="math">q</span>-configuration. Let <span class="math">\\rho=2.05qt/N</span>. Let <span class="math">U\\subseteq V_{1}</span> be the support of <span class="math">Y_{\\alpha}</span>. Then either $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> and </span>h(X_{\\alpha},Y_{\\alpha})=\\Delta(X_{\\alpha},Y_{\\alpha})=0<span class="math">, or else </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq N-2q<span class="math"> and there exists a set </span>R\\subseteq U<span class="math"> such that (i) </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq N-2q<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U\\backslash R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q<span class="math">, (ii) </span>\\Pr[X_{\\alpha}=u]=\\Pr[X_{\\alpha}=v]<span class="math"> for all </span>u<span class="math">, </span>v\\in R$. Moreover,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\Pr[X_{\\alpha}=u]}{\\Pr[X_{\\alpha}=v]}\\geq 1-\\rho</span></p>

    <p class="text-gray-300">for all <span class="math">u,v\\in U</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proposition 4</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">X</span>, <span class="math">Y</span> be random variables of range <span class="math">U</span> such that <span class="math">Y</span> is uniform on <span class="math">U</span> and such that there exists a set <span class="math">R\\subseteq U</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2<span class="math">, such that </span>\\Pr[X=u]=\\Pr[X=v]<span class="math"> for all </span>u,v\\in R$ and such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\Pr[X=u]}{\\Pr[X=v]}\\geq 1-\\varepsilon</span></p>

    <p class="text-gray-300">for all <span class="math">u,v\\in U</span>, for some <span class="math">\\varepsilon\\leq\\frac{1}{2}</span>. Then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$h^{2}(X,Y)\\leq\\varepsilon^{2}\\Big{(}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Big{)}^{2}+\\frac{\\varepsilon^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">T=U\\backslash R</span>.</p>

    <p class="text-gray-300">Proposition 3 is proved by Bogdanov et al. and, more exactly, is established as an intermediate result within the proof of their Lemma 2 <em>[1]</em>. (As a means of giving some intuition, however, we note the set <span class="math">R</span> corresponds to the set of vertices in <span class="math">V_{1}</span> are neither adjacent to an edge of <span class="math">M_{1}</span> or of <span class="math">M_{2}</span>—there are, naturally, at least <span class="math">N-2q</span> such vertices.)</p>

    <p class="text-gray-300">Before proving Proposition 4 (which amounts to a fairly straightforward computation) we show how (16), and hence Proposition 1, can be obtained as a corollary of Propositions 3 and 4:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Proposition 1. Let <span class="math">U</span> and <span class="math">R</span> be as guaranteed by Proposition 3 (for some given <span class="math">\\alpha\\in A_{0}</span>). Since <span class="math">q&lt;N/100</span> we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq N-2q\\geq\\frac{98}{100}N<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N<span class="math">, so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2<span class="math">. Moreover since </span>q<N/5t<span class="math"> we have </span>\\rho=2.05qt/N\\leq\\frac{1}{2}<span class="math">. We can therefore apply Proposition 4 with </span>\\varepsilon=\\rho=2.05qt/N<span class="math">; we find, since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq N-2q<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U\\backslash R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">h^{2}(X_{\\alpha},Y_{\\alpha})\\leq\\rho^{2}\\Big{(}\\frac{q}{N-2q}\\Big{)}^{2}+\\frac{\\rho^{2}q}{2(N-q)}\\leq\\frac{\\rho^{2}q}{(N-q)}</span></p>

    <p class="text-gray-300">where we used <span class="math">q&lt;N/100</span> in the second inequality. Thus, by Lemma 1,</p>

    <p class="text-gray-300"><span class="math">\\Delta^{\\mathsf{samp}}(q,(X_{\\alpha},Y_{\\alpha})_{\\alpha\\in A_{0}})\\leq\\sqrt{2q}\\max_{\\alpha\\in A_{0}}h(X_{\\alpha},Y_{\\alpha})\\leq\\frac{\\rho q}{\\sqrt{N-q}}\\leq\\frac{3q^{2}t}{N^{1.5}}</span></p>

    <p class="text-gray-300">again using <span class="math">q&lt;N/100</span>. <span class="math">\\Box</span></p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Corollary 1</h6>

    <p class="text-gray-300">Theorem 1.</p>

    <p class="text-gray-300">We finish, finally, with the (prosaic) proof of Proposition 4:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Proposition 4. Since <span class="math">\\varepsilon\\leq\\frac{1}{2}</span>, <span class="math">(1-\\varepsilon)^{-1}\\leq 1+2\\varepsilon</span>. By an averaging argument, there exists some <span class="math">u_{0},u_{0}^{\\prime}\\in U</span> such that $\\Pr[X=u_{0}]\\leq 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\Pr[X=u_{0}^{\\prime}]\\geq 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Therefore</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[X=u]\\in[(1-\\varepsilon)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,(1+2\\varepsilon)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for all <span class="math">u\\in U</span>. In particular,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1-\\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\Pr[X\\in T]\\leq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1+2\\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(recall <span class="math">T=U\\backslash R</span>) implying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$1-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1-\\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\geq\\Pr[X\\in R]\\geq 1-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1+2\\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $p_{R}=\\Pr[X\\in R]/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By definition, then </span>p_{R}=\\Pr[X=u]<span class="math"> for all </span>u\\in R$. We have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">p_{R}</span> <span class="math">\\geq</span> $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left(1-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1+2\\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left(1 - \\frac{(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)(1 + 2\\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\left(\\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">- 2\\varepsilon(</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">)}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">} - 2\\varepsilon \\left(\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">} - \\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) \\tag{17}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_R \\leq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left(1 - \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1 - \\varepsilon)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We also note that $p_R \\geq \\frac{1}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, as can be seen from (17) and from the fact that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By concavity, <span class="math">\\sqrt{x}</span> is upper bounded by its tangent line approximation at <span class="math">x = b</span>; namely,</p>

    <div class="my-4 text-center"><span class="math-block">\\sqrt{b + h} \\leq \\sqrt{b} + \\frac{1}{2} h b^{-\\frac{1}{2}}</span></div>

    <p class="text-gray-300">for all <span class="math">b \\geq 0</span> and all <span class="math">h \\in [-b, \\infty)</span>. Thus</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{p_R} - \\sqrt{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\leq \\sqrt{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\varepsilon \\left(\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)} - \\sqrt{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac{1}{2} \\varepsilon \\left(\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">} - \\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) \\sqrt{</td>

            <td class="px-3 py-2 border-b border-gray-700">U)}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and (using $p_R \\geq \\frac{1}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} - \\sqrt{p_R} = \\sqrt{p_R + \\left(\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - p_R\\right)} - \\sqrt{p_R} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\frac{1}{2} \\left(\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">} - p_R\\right) \\sqrt{2</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\varepsilon \\left(\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">} - \\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) \\sqrt{2</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Therefore</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} - \\sqrt{p_R} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon \\left(\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\sqrt{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\sqrt {\\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} - \\sqrt {p _ {R}}\\right) ^ {2} \\leq 2 \\varepsilon^ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {2} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac {2 \\varepsilon^ {2}}{</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\left(\\frac {</td>

            <td class="px-3 py-2 border-b border-gray-700">T</td>

            <td class="px-3 py-2 border-b border-gray-700">}{</td>

            <td class="px-3 py-2 border-b border-gray-700">R</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\right) ^ {2}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Therefore</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {u \\in R} (\\sqrt {\\Pr [ X = u ]} - \\sqrt {\\Pr [ Y = u ]}) ^ {2} \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {2 \\varepsilon^ {2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left(\\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {2} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(using  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, let  <span class="math">u \\in T</span> . Then</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt {\\Pr [ X = u ]} - \\sqrt {\\Pr [ Y = u ]} \\leq \\sqrt {(1 + 2 \\varepsilon) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\sqrt {1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">= \\varepsilon / \\sqrt {</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Also,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt {\\Pr [ Y = u ]} - \\sqrt {\\Pr [ X = u ]} \\leq \\sqrt {1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\sqrt {(1 - \\varepsilon) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\sqrt {(1 - \\varepsilon) /</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">} + \\frac {1}{2} (\\varepsilon /</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">) \\sqrt {</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">/ (1 - \\varepsilon)} - \\sqrt {(1 - \\varepsilon) /</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\varepsilon / \\sqrt {2</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">(using  <span class="math">1 / (1 - \\varepsilon)\\leq 2</span>  ). Therefore</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {u \\in T} (\\sqrt {\\Pr [ X = u ]} - \\sqrt {\\Pr [ Y = u ]}) ^ {2} \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\varepsilon^ {2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Altogether, therefore, we find that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h ^ {2} (X, Y) = \\frac {1}{2} \\sum_ {u \\in U} (\\sqrt {\\Pr [ X = u ]} - \\sqrt {\\Pr [ Y = u ]}) ^ {2} \\leq \\varepsilon^ {2} \\left(\\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) ^ {2} + \\frac {\\varepsilon^ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">[1] Andrey Bogdanov, Lars R. Knudsen, Gregor Leander, Francois-Xavier Standaert, John Steinberger and Elmar Tischhauser: Key-Alternating Ciphers in a Provable Setting: Encryption Using a Small Number of Public Permutations. EUROCRYPT 2012, LNCS 7237, pp., Springer-Verlag, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] Joan Daemen: Limitations of the Even-Mansour Construction. ASIACRYPT 1991, LNCS 739, pp. 495-498, Springer-Verlag, 1991.</li>

      <li>[3] Joan Daemen and Vincent Rijmen: The Design of Rijndael. Springer-Verlag, 2002.</li>

      <li>[4] Joan Daemen and Vincent Rijmen: The Wide Trail Design Strategy. IMA Int. Conf., LNCS 2260, pp. 222-238, Springer-Verlag, 2001.</li>

      <li>[5] Shimon Even and Yishay Mansour: A Construction of a Cipher From a Single Pseudorandom Permutation. ASIACRYPT 1991, LNCS 739, pp. 210–224, Springer-Verlag, 1993.</li>

      <li>[6] Shimon Even and Yishay Mansour: A Construction of a Cipher from a Single Pseudorandom Permutation. J. Cryptology, vol. 10, num. 3, pp. 151-162, 1997.</li>

      <li>[7] Peter Gai and Ueli Maurer: Free-Start Distinguishing: Combining Two Types of Indistinguishability Amplification. The 4th International Conference on Information Theoretic Security - ICITS 2009, LNCS 5973, pp. 28–44, 2010.</li>

      <li>[8] Michael Luby and Charles Rackoff: How to Construct Pseudorandom Permutations from Pseudorandom Functions. SIAM J. Comput., vol. 17, num. 2, pp. 373-386, 1988.</li>

      <li>[9] Ben Morris, Phillip Rogaway and Till Stegers: How to Encipher Messages on a Small Domain: Deterministic Encryption and the Thorp Shuffle. CRYPTO 2009. LNCS 5677, Springer, pp. 286-302, 2009.How to Encipher Messages on a Small Domain: Deterministic Encryption and the Thorp Shuffle. CRYPTO 2009, LNCS 5677, Springer, pp. 286-302, 2009.</li>

      <li>[10] Mitsuru Matsui: New Structure of Block Ciphers with Provable Security against Differential and Linear Cryptanalysis. FSE 1996, LNCS 1039, pp. 205-218, Springer-Verlag, 1996.</li>

      <li>[11] Mitsuru Matsui: New Block Encryption Algorithm MISTY. FSE 1997, LNCS 1267, pp. 54-68, Springer-Verlag, 1997.</li>

      <li>[12] Ueli Maurer: Indistinguishability of Random Systems. Advances in Cryptology – EUROCRYPT 2002, LNCS 2332, pp. 110–132, May 2002.</li>

      <li>[13] Ueli Maurer and Krzysztof Pietrzak: Composition of Random Systems: When Two Weak Make One Strong. TCC 2004, LNCS 2951, pp. 410–427, Feb 2004.</li>

      <li>[14] Ueli Maurer, Krzysztof Pietrzak and Renato Renner: Indistinguishability Amplification. CRYPTO 2007, LNCS 4622, pp. 130–149, 2007.</li>

      <li>[15] Liu Tianren, personal communication.</li>

      <li>[16] Serge Vaudenay: Decorrelation: A Theory for Block Cipher Security. J. Cryptology, vol. 16, num. 14, pp. 249-286, 2003.</li>

    </ul>`;
---

<BaseLayout title="Improved Security Bounds for Key-Alternating Ciphers via Hel... (2012/481)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/481
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
