---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/257';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'LatticeFold: A Lattice-based Folding Scheme and its Applications to Succinct Proof Systems';
const AUTHORS_HTML = 'Dan Boneh, Binyi Chen';

const CONTENT = `    <p class="text-gray-300">Dan Boneh and Binyi Chen</p>

    <p class="text-gray-300">Stanford University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Folding is a recent technique for building efficient recursive SNARKs. Several elegant folding protocols have been proposed, such as Nova, Supernova, Hypernova, Protostar, and others. However, all of them rely on an additively homomorphic commitment scheme based on discrete log, and are therefore not post-quantum secure and require a large (256-bit) field. In this work we present LatticeFold, the first lattice-based folding protocol based on the Module SIS problem. This folding protocol naturally leads to an efficient recursive lattice-based SNARK and an efficient PCD scheme. LatticeFold supports folding low-degree relations, such as R1CS, as well as high-degree relations, such as CCS. The key challenge is to construct a secure folding protocol that works with the Ajtai commitment scheme. The difficulty is ensuring that extracted witnesses are low norm through many rounds of folding. We present a novel technique using the sumcheck protocol to ensure that extracted witnesses are always low norm no matter how many rounds of folding are used. Since LatticeFold can operate over a small (64-bit) field, our evaluation of the final proof system suggests that it is as performant as Hypernova, while providing plausible post-quantum security. Moreover, LatticeFold operates over the same module structure used by fully homomorphic encryption (FHE) and lattice signatures schemes, and can therefore benefit from software optimizations and custom hardware designed to accelerate these lattice schemes.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1 Introduction 3 1.1 Additional related work 7</p>

    <p class="text-gray-300">2 Preliminaries 8 2.1 Sampling Sets 11 2.2 Module SIS 12 2.3 The Ajtai Compact Commitment 13 2.4 Sum-Checks and Multilinear Extensions over Rings 13 2.5 Reduction of Knowledge 14</p>

    <p class="text-gray-300">3 A Folding Scheme for Ajtai Commitment Openings 16 3.1 The Relation for Commitment Openings 17 3.2 A Generic Framework for Folding 18 3.2.1 Expansion: the reduction from <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B \\times \\mathcal{R}_{\\mathrm{cm}}^B</span> to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B \\times \\mathcal{R}_{\\mathrm{eval}}^B</span> 20 3.2.2 Decomposition: The reduction from <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^B)^2</span> to <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^b)^{2k}</span> 20 3.2.3 Folding: The reduction from <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^b)^{2k}</span> to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> 25 3.3 Supporting Small Prime Modulus 39</p>

    <p class="text-gray-300">4 A Lattice-based Folding Scheme for CCS 40 4.1 Lattice-based Committed CCS 41 4.2 A Generic Folding Scheme for CCS 42 4.2.1 Linearization: The reduction from <span class="math">\\mathcal{R}_{\\mathrm{cmccs}}^B</span> to <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> 43 4.2.2 Decomposition: The reduction from <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^B)^2</span> to <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^{2k}</span> 45 4.2.3 Folding: The reduction from <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^{2k}</span> to <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> 46 4.3 An Optimized Folding Scheme for CCS 48 4.3.1 Batch Folding: The reduction from <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k} \\times (\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span> to <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> 49</p>

    <p class="text-gray-300">5 Performance Estimates 52 6 Discussion of an Alternative Approach 55 7 Conclusion, open problems, and future work 56</p>

    <p class="text-gray-300">A Multilinear Evaluation Mapping Lemma 66 B Deferred Proofs 67 B.1 Proof of Lemma 4.1 67 B.2 Proof of Lemma 4.2 69 B.3 Proof of Theorem 4.2 71 B.4 Proof of Lemma 4.3 74</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In recent years we have seen tremendous progress in the design of succinct non-interactive arguments of knowledge (SNARKs). They have become an important enabling technology for scaling blockchains, bridging between chains <em>[x21]</em>, authenticating media <em>[x18, x11, x13]</em>, verifiable delay functions <em>[x3]</em>, and much more. Some SNARKs are monolithic and generate the entire proof at once, while others break the task of constructing a proof into small steps and prove each step separately. The latter approach is called incrementally verifiable computation (IVC) <em>[x22]</em> or proof carrying data (PCD) <em>[x6]</em>. This approach eliminates the high memory needs of a monolithic SNARK. It can also provide more opportunities for parallelizing the prover.</p>

    <p class="text-gray-300">Historically, IVC and PCD were built from a recursive SNARK <em>[x22, x2]</em>. However, this requires embedding the SNARK verifier inside the statement being proved at every step, and this introduces a considerable overhead. A new approach called accumulation or folding was recently introduced in Halo <em>[x4]</em> and further developed in <em>[x5, x7, x8]</em> and Nova <em>[x16]</em>. The idea is to “fold” the SNARK verification work at every step into the SNARK verification of all previous steps. The final folded statement is verified at the end of the computation. The benefit is that now the recursive statement being proved at every step only needs to ensure that folding was performed correctly, which is far simpler than running a full SNARK verifier. Since folding was introduced, many elegant ideas appeared to further optimize this technique <em>[x15, x16, x4, x19, x17, x20, x21]</em>.</p>

    <p class="text-gray-300">To explain folding in more detail we find it convenient to use the language of reductions of knowledge introduced by Kothapalli and Parno <em>[x14]</em> (see Section 2.5 for details). Let <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> be two instance-witness relations. A reduction of knowledge from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> is a protocol <span class="math">\\Pi</span> between a prover and verifier. The verifier takes as input an instance <span class="math">\\vx_{1}</span> for <span class="math">\\mathcal{R}_{1}</span>, interacts with the prover, and outputs an instance <span class="math">\\vx_{2}</span> for <span class="math">\\vx_{2}</span>, then it is possible to extract from the prover a witnesses <span class="math">\\vx_{1}</span> for <span class="math">\\vx_{1}</span>. Hence, knowledge of a valid witness for <span class="math">\\vx_{2}</span> proves knowledge of a valid witness for <span class="math">\\vx_{1}</span>.</p>

    <p class="text-gray-300">A folding scheme is a reduction of knowledge from a product relation <span class="math">\\mathcal{R}_{\\textsf{acc}}\\times\\mathcal{R}_{\\textsf{comp}}</span> to <span class="math">\\mathcal{R}_{\\textsf{acc}}</span>. That is, two instances <span class="math">(\\vx_{\\textsf{acc}},\\vx_{\\textsf{comp}})</span> are folded to a single instance <span class="math">\\vx_{\\textsf{acc}}^{\\prime}</span> of <span class="math">\\mathcal{R}_{\\textsf{acc}}</span>. By repeatedly folding in this way, the prover can accumulate many steps of a computation into a single instance of an accumulation relation <span class="math">\\mathcal{R}_{\\textsf{acc}}</span>. Eventually, the prover proves knowledge of a witness for the final <span class="math">\\mathcal{R}_{\\textsf{acc}}</span> instance, and this proves knowledge of a valid witness for every step of the computation. When <span class="math">\\mathcal{R}_{\\textsf{acc}}</span> and <span class="math">\\mathcal{R}_{\\textsf{comp}}</span> are different, this type of folding is sometimes called multi-folding <em>[x16]</em>. The relation <span class="math">\\mathcal{R}_{\\textsf{acc}}</span> is typically a simple extension of <span class="math">\\mathcal{R}_{\\textsf{comp}}</span>.</p>

    <p class="text-gray-300">The Hypernova system <em>[x16]</em>, for example, is a folding scheme for proving validity of a multi-step computation where the computation step relation <span class="math">\\mathcal{R}_{\\textsf{comp}}</span> is expressed as a customizable constraint system (CCS) <em>[x23]</em>. CCS supports high-degree gates and</p>

    <p class="text-gray-300">generalizes the Plonkish, R1CS, and AIR formats for a computation trace. By repeatedly folding, Hypernova enables the prover to accumulate many CCS steps into a single instance of a closely related relation <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>.</p>

    <p class="text-gray-300">The folding schemes discussed above make use of an additively homomorphic commitment scheme based on discrete log to commit to the various witnesses. The commitments are part of the instances <span class="math">\\mathsf{z}_{\\mathsf{acc}}</span> and <span class="math">\\mathsf{z}_{\\mathsf{comp}}</span>. Due to the reliance on discrete log, the derived SNARKs are unsound in the presence of a large fault-tolerant quantum computer. Moreover, committing to a long vector with a discrete log commitment scheme, such as Pedersen, leads to significant work for the prover.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our contributions.</h4>

    <p class="text-gray-300">We construct LatticeFold, the first lattice-based folding scheme, whose security depends on the Module Short Integer Solution (MSIS) problem <em>[x13, x15, x14]</em>. This problem is believed to be post-quantum secure. A key component of LatticeFold is a new batched proof-of-knowledge protocol for short pre-images of linear maps (See Section 3), which may be of independent interest.</p>

    <p class="text-gray-300">A natural starting point for a lattice-based folding scheme is to replace the discrete-log commitment in existing folding schemes with the Ajtai commitment scheme <em>[x1]</em>, which is additively homomorphic. We describe the scheme as it operates in a module <span class="math">\\mathcal{R}^{m}</span> defined over a suitable number ring <span class="math">\\mathcal{R}</span>. As usual, for a prime <span class="math">q</span> we let <span class="math">\\mathcal{R}_{q}:=\\mathcal{R}/q\\mathcal{R}</span>. The Ajtai commitment scheme works as follows (see Section 2.3):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The public parameters contain a random matrix <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{\\kappa\\times m}</span> where <span class="math">\\kappa&lt;m</span>,</li>

      <li>The commitment to a vector <span class="math">\\vec{\\mathbf{x}}\\in\\mathcal{R}^{m}</span> is <span class="math">\\mathsf{cm}:=\\mathbf{A}\\vec{\\mathbf{x}}\\in\\mathcal{R}_{q}^{\\kappa}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the Module SIS (MSIS) problem is hard, then the commitment is binding for the set of vectors <span class="math">\\vec{\\mathbf{x}}\\in\\mathcal{R}^{m}</span> whose norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> is at most some bound </span>B<span class="math">. Throughout the paper we always use the </span>L_{\\infty}<span class="math"> norm on </span>\\mathcal{R}^{m}$, as defined in Section 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">But one immediately runs into trouble. Folding two witnesses into one is done by taking a random linear combination of the two witnesses, using verifier randomness. Consequently, the norm of the committed vector in the folded instance increases the more times we fold. Eventually the norm exceeds the norm bound <span class="math">B</span>, at which point the commitment scheme is no longer binding. One can try to avoid norm growth by using a folding tree <em>[x20]</em>, so that the folding depth is logarithmic in the size of the computation. However, long folding chains are required in applications, such as PCD, and Ajtai commitments are simply not compatible with that. The challenge is to use Ajtai commitments while controlling the norm growth as folding takes place.</p>

    <p class="text-gray-300">Our approach to keeping the witness norm below <span class="math">B</span> is to break the folding protocol into three steps: expansion, decomposition, and folding. The first step has to do with the mechanics of folding; it expands the given instance <span class="math">\\mathsf{z}_{\\mathsf{comp}}</span> of <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span> to an instance of <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>. The second, and more important step, decomposes a committed witness <span class="math">\\vec{\\mathbf{f}}\\in\\mathcal{R}^{m}</span> of bounded norm <span class="math">B</span> into a tuple of vectors <span class="math">\\vec{\\mathbf{f}}_{0},\\ldots,\\vec{\\mathbf{f}}_{k-1}\\in\\mathcal{R}^{m}</span> of lower norm <span class="math">b:=\\lceil B^{1/k}\\rceil</span>. This decomposition works by writing every entry of <span class="math">\\vec{\\mathbf{f}}</span> in base <span class="math">b</span>, so that the original <span class="math">\\vec{\\mathbf{f}}</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\vec{\\mathbf{f}}=\\vec{\\mathbf{f}}_{0}+b\\cdot\\vec{\\mathbf{f}}_{1}+\\ldots+b^{k-1}\\cdot\\vec{\\mathbf{f}}_{k-1}</span>, and each of the <span class="math">k</span> vectors has norm less than <span class="math">b</span>. When folding two committed witnesses of bounded norm <span class="math">B</span>, this decomposition leaves us with <span class="math">2k</span> vectors of lower bounded norm <span class="math">b</span>. Our third step, called folding, now folds all <span class="math">2k</span> vectors into a single witness for the accumulator relation <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>. The folding is done by computing a random linear combination of the <span class="math">2k</span> vectors using a random vector of weights <span class="math">\\vec{\\rho}</span> sampled as <span class="math">\\vec{\\rho}\\stackrel{{\\scriptstyle\\scriptscriptstyle L}}{{\\leftarrow}}\\mathcal{C}^{2k}_{\\mathsf{small}}</span>. Here <span class="math">\\mathcal{C}_{\\mathsf{small}}\\subseteq\\mathcal{R}_{q}</span> contains only ring elements of low norm so that the final folded witness <span class="math">\\vec{\\mathbf{f}}^{\\prime}:=\\sum_{i=1}^{2k}\\rho_{i}\\vec{\\mathbf{f}}_{i}</span> has norm at most <span class="math">B</span>. This gives a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{acc}}\\times\\mathcal{R}_{\\mathsf{comp}}</span> to <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span> where the final committed witness satisfies the same norm bound as the original committed witnesses. There is no norm growth.</p>

    <p class="text-gray-300">Unfortunately, this decomposition approach is insufficient: given a witness for the folded instance <span class="math">\\mathsf{z}^{\\prime}_{\\mathsf{acc}}</span> of <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span> we cannot extract low-norm witnesses for the two instances <span class="math">(\\mathsf{z}_{\\mathsf{acc}},\\mathsf{z}_{\\mathsf{comp}})</span> that we started with. The problem is that the extractor uses the inverses of elements <span class="math">c_{1}-c_{2}\\in\\mathcal{R}_{q}</span> where <span class="math">c_{1},c_{2}\\in\\mathcal{C}_{\\mathsf{small}}</span>. This forces us to ensure that <span class="math">\\mathcal{C}_{\\mathsf{small}}</span> is a strong sampling set, meaning that for all <span class="math">c_{1},c_{2}\\in\\mathcal{C}_{\\mathsf{small}}</span>, the difference <span class="math">c_{1}-c_{2}</span> is invertible in <span class="math">\\mathcal{R}_{q}</span>. The ring <span class="math">\\mathcal{R}_{q}</span> contains an exponential size strong sampling set (Lemma 2.3), and therefore the challenge space is sufficiently large. However, the norm of <span class="math">1/(c_{1}-c_{2})</span> in <span class="math">\\mathcal{R}_{q}</span> can be large, and consequently the extractor might end up extracting a high norm witness, which is invalid. One way to solve this problem (e.g., as in <em>[x1]</em>) is to ensure that these inverses always have small norm. However, as noted in <em>[x1]</em>, that severely limits the size of the challenge set <span class="math">\\mathcal{C}_{\\mathsf{small}}</span> and harms the soundness of the folding protocol. In comparison, we highlight that our protocol incurs no slack in witness extraction and avoids using subtractive sets <em>[x1]</em>.</p>

    <p class="text-gray-300">Our core idea is to enhance the folding protocol, and have the prover convince the verifier that it has <span class="math">2k</span> valid witnesses whose norm is less than <span class="math">b</span>. This is sufficient to extract low norm witnesses from the prover. Roughly speaking, the prover can convince the verifier that a vector <span class="math">\\vec{\\mathbf{f}}\\in\\mathcal{R}^{m}</span> has norm less than <span class="math">b</span>, by proving that every component <span class="math">u</span> of <span class="math">\\vec{\\mathbf{f}}</span> is in the set <span class="math">[-b,b]</span>. This is done by proving that <span class="math">g(u)=0</span>, where <span class="math">g(X)</span> is the polynomial <span class="math">g(X):=X\\prod_{i\\in[b]}(X-i)(X+i)</span>. The set of zeroes of this polynomial <span class="math">g</span> is exactly the set <span class="math">[-b,b]</span>, and therefore <span class="math">g(u)=0</span> if and only if <span class="math">u</span> is in <span class="math">[-b,b]</span>. By encoding the components of <span class="math">\\vec{\\mathbf{f}}</span> as the evaluations of a function <span class="math">h</span> on the Boolean hypercube <span class="math">\\{0,1\\}^{\\ell}</span>, the prover can use the sumcheck protocol <em>[x14]</em> on the <span class="math">\\ell</span>-variate polynomial <span class="math">g(h(\\cdot))</span> to convince the verifier that <span class="math">\\vec{\\mathbf{f}}</span> has norm less than <span class="math">b</span>. In other words, the sumcheck protocol is the key tool that enables to prove that <span class="math">\\vec{\\mathbf{f}}</span> has bounded norm. The complete details are provided in Section 3.</p>

    <p class="text-gray-300">We note that choosing the norm bound <span class="math">b</span> is an interesting optimization problem. On the one hand, a small value of <span class="math">b</span> results in a decomposition of <span class="math">\\vec{\\mathbf{f}}</span> into many fragments, and this will slow down the folding process because more witnesses need to be folded. On the other hand, choosing a small <span class="math">b</span> reduces the degree of the polynomial <span class="math">g(X)</span> in the norm bound test, making that test faster. The optimal <span class="math">b</span> needs to balance these two effects to minimize the overall running time. We calculate optimal values in our evaluation section.</p>

    <p class="text-gray-300">Finally, we point out that our techniques are generic, and can be used to build folding schemes from any binding commitment that requires norm bounds on the committed vector.</p>

    <p class="text-gray-300">Here we use Ajtai commitments, but other schemes can also be used.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Paper organization.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We begin in Section 3 by using the techniques outlined above to construct a folding scheme for the relation <span class="math">\\mathcal{R}^{B}_{\\mathsf{cm}}</span> that captures the fact that the prover has an opening <span class="math">\\vec{\\mathbf{x}}\\in\\mathcal{R}^{m}</span> to an Ajtai commitment <span class="math">\\mathsf{cm}\\in\\mathcal{R}^{\\kappa}_{q}</span>, where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B<span class="math">. This folding scheme leads to a batched proof-of-knowledge protocol for short pre-images of linear maps. It also demonstrates all the essential tools needed to build a folding-based IVC and PCD from the MSIS assumption. However, a relation such as </span>\\mathcal{R}^{B}_{\\mathsf{cm}}<span class="math"> that proves knowledge of a committed value is not enough to implement an IVC or PCD. One would also need to incorporate into </span>\\mathcal{R}^{B}_{\\mathsf{cm}}<span class="math"> a computation checking relation, such as verifying a witness for an R1CS relation. We do so in Section 4 by extending </span>\\mathcal{R}^{B}_{\\mathsf{cm}}$ to include such a check.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As an optimization of our folding schemes, we show in Section 3.3 how to adapt the folding scheme for <span class="math">\\mathcal{R}^{B}_{\\mathsf{cm}}</span> to support relations defined over a small modulus <span class="math">q</span>, say on the order of <span class="math">2^{64}</span>. This makes arithmetic faster since <span class="math">\\mathbb{Z}_{q}</span> now fits into the native 64-bit registers of a CPU or GPU. Moreover, a small modulus is advantageous for encoding computations that operate on binary values, since a small <span class="math">q</span> reduces the encoding overhead. The problem is that a small <span class="math">q</span> limits the size of the challenge space and harms soundness. We show that with a suitable use of extensions fields we can enlarge the challenge space while supporting relations over a small modulus.</p>

    <p class="text-gray-300">Next, in Section 4 we generalize our basic folding technique to support circuits with high degree gates. In particular we show how to fold a customizable constraint system (CCS) relation <em>[x22]</em>. This generalization adds an additional sumcheck step before decomposition to linearize the high degree relation. This is needed to avoid cross terms that would arise if decomposition were applied to a relation involving high degree gates. Hypernova <em>[x13]</em> uses a similar approach to avoid cross terms. In Section 4.3, we present an optimized scheme that batch the sumchecks from both the linearization and folding steps into one, further improving efficiency.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Evaluation.</h4>

    <p class="text-gray-300">In Section 5 we provide a concrete evaluation of the resulting system. A recent implementation by Nethermind <em>[x10]</em> suggests that LatticeFold’s performance is comparable with Hypernova, a pre-quantum system.</p>

    <p class="text-gray-300">One reason LatticeFold performs well is that all the vectors that it uses lie in a single ring: the domain and range of the Ajtai commitment is the same ring <span class="math">\\mathcal{R}_{q}</span>. In contrast, for Pedersen commitments the domain is <span class="math">\\mathbb{Z}_{q}</span> while the range is some other cyclic group. This forces Hypernova to implement elliptic curve scalar multiplications and non-native field arithmetic in the relation, which increases the folding complexity. Furthermore, LatticeFold uses a small 64-bit field, whereas Hypernova uses a 256-bit field due to the use of Pedersen commitments. However, Ajtai commitments adds additional complexity as explained earlier.</p>

    <p class="text-gray-300">Finally, we note that LatticeFold is especially well suited for computations that make</p>

    <p class="text-gray-300">use of operations in the ring <span class="math">\\mathcal{R}_{q}</span>. For example, suppose that the RELU function in a deep neural net (DNN) can be replaced by a similar function that can be expressed as a simple circuit using <span class="math">\\mathcal{R}_{q}</span> operations. Then LatticeFold would be especially well suited for proving correct inference using the resulting DNN. The point is that a ring operation is a richer building block than simple arithmetic, and that can simplify some SNARK circuits.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.1 Additional related work</h3>

    <p class="text-gray-300">Hypernova <em>[x13]</em> and Protostar <em>[x1]</em> are two folding schemes that supports CCS relations. In Section 5 we compare the performance of LatticeFold to both schemes. ProtoGalaxy <em>[x10]</em> is a further optimization of Protostar. The linearization step (from Section 4.2.1) that reduces a high-degree relation to a linear relation is inspired by Hypernova. However, fully adapting the folding techniques from Hypernova to the lattice setting incurs challenges. First, we need to guarantee that witness norms never go out of range after folding and prove that all intermediate witnesses have small norms. This is why we introduce the decomposition and the range proof techniques. Second, we need to adapt everything from a field to a ring in which not all elements are invertible. Finally, with decomposition, the random combination step must fold <em>more than</em> two witnesses into one using <em>independent</em> and <em>small-norm</em> challenges. This makes the security analysis significantly harder.</p>

    <p class="text-gray-300">Several post-quantum SNARKs were constructed from hash-based Merkle commitments. Some examples include Stark <em>[x3]</em>, Ligero <em>[x1]</em>, Aurora <em>[x2]</em>, Brakedown <em>[x11]</em>, BaseFold <em>[x20]</em>, and Blaze <em>[x4]</em>. Their proof sizes scale sublinearly with the witness size, but in practice they produce relatively large proofs, and require a significant amount of memory when proving a large statement. In recent years, several elegant lattice-based proof systems with sublinear proof size were constructed <em>[x1, x2, x1, x1]</em>. However, these systems are not competitive with the hash based systems listed above. Other post-quantum proof systems, such as <em>[x12, x15]</em>, perform well for small statements, but their proof size is linear in the size of the witness.</p>

    <p class="text-gray-300">LaBRADOR <em>[x5]</em> is an elegant succinct lattice-based proof system, with a linear time verifier. LaBRADOR is a recursive proof system based on the MSIS assumption. Thanks to the use of recursion, the resulting proofs are shorter than those obtained from the hash-based systems. LaBRADOR faces many of the same challenges as in this paper, but the proposed solutions are quite different. For example, LaBRADOR uses the method of random projection to prove a norm bound on a committed vector. We explain in Section 6 why this approach would not lead to an efficient folding scheme in our settings. Instead, our approach to proving a norm bound on a committed vector is based on the sumcheck protocol.</p>

    <p class="text-gray-300">Concurrent to LatticeFold, Greyhound <em>[x14]</em> built upon LaBRADOR and proposed a new polynomial commitment scheme (PCS) with square-root verification time, however, with similar reasons as LaBRADOR, it is not clear how to extend it to folding.</p>

    <p class="text-gray-300">Cini et al. <em>[x10]</em> recently introduced a new lattice-based PCS from Bulletproof/FRI-like techniques <em>[x1, x2]</em>. Their approach achieves better control over witness norm/slack blowup than previous works. However, their scheme incurs norm blowup/slack at each step, limiting it to supporting only a logarithmic number of folding steps. In contrast, our construction (i) provides folding for general NP statements, and (ii) supports <em>polynomially</em> many folding steps for NP statements, as needed for PCD/IVC. It is unclear how to extend the PCS techniques from <em>[x10]</em> to construct PCD/IVC.</p>

    <p class="text-gray-300">Recently Bünz et al. <em>[x1, x2]</em> introduced an alternative approach to constructing folding schemes <em>purely from hashing</em>. Additionally, they introduced a new compiling technique to build efficient PCD/SNARKs from any folding schemes, which can be applied to LatticeFold as well. Compared to LatticeFold, the complexity of the recursive folding verifier is higher in their scheme because of the need to perform more hash operations. Moreover, in LatticeFold, the time and memory to compute the commitments scales with the number of <em>non-zero</em> entries in the committed witness, whereas in the hash-based scheme, it is always proportional to the witness length. This makes LatticeFold advantageous for sparse witnesses.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Subsequent work.</h4>

    <p class="text-gray-300">A number of subsequent works have built on LatticeFold after it was first posted. LatticeFold+ <em>[x3]</em> improves the performance of LatticeFold by designing a more efficient range proof. Neo <em>[x24]</em> suggests a better approach for embedding field elements into the cyclotomic polynomial ring used in LatticeFold. Lova <em>[x12, x13]</em> replaces the module-based Ajtai commitments and the <span class="math">\\ell_{\\infty}</span>-norm used in LatticeFold, with integer-based Ajtai commitments and the <span class="math">\\ell_{2}</span>-norm. Finally, Klooß et al. <em>[x16, x17]</em> suggest another approach to <span class="math">\\ell_{2}</span>-norm range proofs that can apply to LatticeFold.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">Let <span class="math">\\lambda</span> denote the security parameter. For <span class="math">n\\in\\mathbb{N}</span> let <span class="math">[n]</span> be the set <span class="math">\\{1,2,\\ldots,n\\}</span>; for <span class="math">l,r\\in\\mathbb{N}</span> let <span class="math">[l,r)</span> denote the set <span class="math">\\{l,l+1,\\ldots r-1\\}</span>. A function <span class="math">f(\\lambda)</span> is <span class="math">\\mathsf{poly}(\\lambda)</span> if there exists a <span class="math">c\\in\\mathbb{N}</span> such that <span class="math">f(\\lambda)=O(\\lambda^{c})</span>. If <span class="math">f(\\lambda)=o(\\lambda^{-c})</span> for all <span class="math">c\\in\\mathbb{N}</span>, we say <span class="math">f(\\lambda)</span> is in <span class="math">\\mathsf{negl}(\\lambda)</span> and is negligible. A probability that is <span class="math">1-\\mathsf{negl}(\\lambda)</span> is overwhelming. A vector is always a column vector by default. For vectors <span class="math">\\vec{u},\\vec{v}</span> of the same dimension we let <span class="math">\\langle\\vec{u},\\vec{v}\\rangle</span> denote the inner product of <span class="math">\\vec{u}</span> and <span class="math">\\vec{v}</span>. Throughout the paper when we refer to a ring we will always mean a commutative ring. For a ring <span class="math">\\bar{\\mathcal{R}}</span>, we use <span class="math">\\bar{\\mathcal{R}}[X_{1},\\ldots,X_{\\mu}]</span> to denote the set of <span class="math">\\mu</span>-variate polynomials over <span class="math">\\bar{\\mathcal{R}}</span>, and use <span class="math">\\bar{\\mathcal{R}}^{\\leq d}[X_{1},\\ldots,X_{\\mu}]</span> to denote the set of polynomials where the degree of each variable is at most <span class="math">d</span>.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Modules and module homomorphisms.</h4>

    <p class="text-gray-300">Let <span class="math">\\bar{\\mathcal{R}}</span> be an arbitrary ring. An <span class="math">\\bar{\\mathcal{R}}</span>-module <span class="math">M</span> can be understood as a “vector space” over ring <span class="math">\\bar{\\mathcal{R}}</span>, that is, it allows to be scaled by elments in <span class="math">\\bar{\\mathcal{R}}</span>. More precisely, <span class="math">M</span> has an identity element <span class="math">1</span> and for all <span class="math">r,s\\in\\bar{\\mathcal{R}}</span> and</p>

    <p class="text-gray-300"><span class="math">x, y \\in M</span>, we have (i) <span class="math">r \\cdot (x + y) = r \\cdot x + r \\cdot y</span> (ii) <span class="math">(r + s) \\cdot x = r \\cdot x + s \\cdot x</span>, (iii) <span class="math">(rs) \\cdot x = r \\cdot (s \\cdot x)</span>, and (iv) <span class="math">1 \\cdot x = x</span>. Moreover, <span class="math">M</span> is commutative, i.e., <span class="math">r \\cdot x = x \\cdot r</span>. An <span class="math">\\bar{\\mathcal{R}}</span>-module homomorphism <span class="math">\\phi : M \\to N</span> between <span class="math">\\bar{\\mathcal{R}}</span>-modules <span class="math">M</span> and <span class="math">N</span> is a function that preserves additions and scalar multiplications. More precisely, for every <span class="math">x, y \\in M</span> and <span class="math">r \\in \\bar{\\mathcal{R}}</span> we have (i) <span class="math">\\phi(x + y) = \\phi(x) + \\phi(y)</span>, and (ii) <span class="math">\\phi(r \\cdot x) = r \\cdot \\phi(x)</span>.</p>

    <p class="text-gray-300"><strong>Cyclotomic rings.</strong> Let <span class="math">\\mathcal{R} \\coloneqq \\mathbb{Z}[X] / (X^d + 1)</span> where <span class="math">d</span> is a power of two. Let <span class="math">t \\in \\mathbb{N}</span> be a divisor of <span class="math">d</span> and <span class="math">q</span> be a prime such that <span class="math">q \\equiv 1 + 2t \\pmod{4t}</span>. Therefore <span class="math">\\mathbb{Z}_q</span> has <span class="math">t</span> primitive <span class="math">2t</span>-th root of unity <span class="math">\\{\\zeta_j\\}_{j \\in [t]}</span> such that <span class="math">X^d + 1 \\equiv \\prod_{j=1}^{t} (X^{d/t} - \\zeta_j) \\pmod{q}</span>, where <span class="math">(X^{d/t} - \\zeta_j)</span> is <em>irreducible</em> for all <span class="math">j \\in [t]</span>. By the Chinese Remainder Theorem, <span class="math">\\mathcal{R}_q \\coloneqq \\mathcal{R} / q\\mathcal{R} = \\mathbb{Z}_q[X] / (X^d + 1)</span> can be split to the product of <span class="math">t</span> quotient rings, that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_q \\cong \\prod_{j=1}^{t} \\mathbb{Z}_q[X] / (X^{d/t} - \\zeta_j) \\cong \\mathbb{F}_{q^{d/t}}^t.</span></div>

    <p class="text-gray-300">For a polynomial <span class="math">f \\in \\mathcal{R}_q</span>, the <strong>Number Theoretic Transform (NTT)</strong> of <span class="math">f</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NTT}(f) := \\left[ \\hat{f}_1, \\dots, \\hat{f}_t \\right]^\\top \\in \\mathbb{F}_{q^{d/t}}^t</span></div>

    <p class="text-gray-300">where <span class="math">\\hat{f}_j \\coloneqq f \\bmod (X^{d/t} - \\zeta_j)</span>. In the special case where <span class="math">t = d</span>, the prime <span class="math">q</span> splits completely in <span class="math">\\mathcal{R}</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_q \\cong \\prod_{j=1}^{d} \\mathbb{Z}_q[X] / (X - \\zeta_j) \\cong \\mathbb{Z}_q^d. \\tag{1}</span></div>

    <p class="text-gray-300"><strong>Coefficient embedding.</strong> For an element <span class="math">\\mathbf{a} = \\sum_{i=1}^{d} a_i X^{i-1} \\in \\mathcal{R}_q</span>, we use <span class="math">\\mathsf{Coef}(\\mathbf{a}) := [a_1, \\ldots, a_d]^\\top \\in \\mathbb{Z}_q^d</span> to denote the coefficient vector of <span class="math">\\mathbf{a}</span> and denote <span class="math">\\mathsf{Coef}_i(\\mathbf{a}) := a_i</span> for every <span class="math">i \\in [d]</span>. For a vector <span class="math">\\vec{\\mathbf{a}} := [\\mathbf{a}_1, \\ldots, \\mathbf{a}_m]^\\top \\in \\mathcal{R}_q^m</span>, we use <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{a}})</span> to denote the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Coef}(\\vec{\\mathbf{a}}) := \\begin{bmatrix} \\operatorname{Coef}_1(\\mathbf{a}_1) &amp;amp; \\dots &amp;amp; \\operatorname{Coef}_d(\\mathbf{a}_1) \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\operatorname{Coef}_1(\\mathbf{a}_m) &amp;amp; \\dots &amp;amp; \\operatorname{Coef}_d(\\mathbf{a}_m) \\end{bmatrix} \\in \\mathbb{Z}_q^{m \\times d} \\tag{2}</span></div>

    <p class="text-gray-300">and <span class="math">\\mathsf{FCoef}(\\vec{\\mathbf{a}}) \\in \\mathbb{Z}_q^{dm}</span> denotes the concatenation of <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{a}})</span>'s row vectors. For every <span class="math">i \\in [d]</span>, we define <span class="math">\\mathsf{Coef}_i(\\vec{\\mathbf{a}}) := [\\mathsf{Coef}_i(\\mathbf{a}_1), \\ldots, \\mathsf{Coef}_i(\\mathbf{a}_m)]^\\top \\in \\mathbb{Z}_q^m</span> as the <span class="math">i</span>-th column of <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{a}})</span>. Define <span class="math">\\mathsf{Rot}(\\mathbf{a}) := (\\mathsf{Coef}(\\mathbf{a}), \\mathsf{Coef}(X \\cdot \\mathbf{a}), \\ldots, \\mathsf{Coef}(X^{d-1} \\cdot \\mathbf{a})) \\in \\mathbb{Z}_q^{d \\times d}</span>. We observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Coef}(\\mathbf{a} \\cdot \\mathbf{b}) = \\operatorname{Rot}(\\mathbf{a}) \\times \\operatorname{Coef}(\\mathbf{b}) \\tag{3}</span></div>

    <p class="text-gray-300">for every <span class="math">\\mathbf{a}, \\mathbf{b} \\in \\mathcal{R}_q</span>. More generally, for a matrix <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{\\kappa \\times m}</span>, we define the rotation matrix <span class="math">\\mathrm{Rot}(\\mathbf{A})</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Rot}(\\mathbf{A}) := \\begin{bmatrix} \\operatorname{Rot}(\\mathbf{A}_{1,1}) &amp;amp; \\dots &amp;amp; \\operatorname{Rot}(\\mathbf{A}_{1,m}) \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\operatorname{Rot}(\\mathbf{A}_{\\kappa,1}) &amp;amp; \\dots &amp;amp; \\operatorname{Rot}(\\mathbf{A}_{\\kappa,m}) \\end{bmatrix} \\in \\mathbb{Z}_q^{\\kappa d \\times md}. \\tag{4}</span></div>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{FCoef}(\\mathbf{A}\\vec{\\mathbf{f}}) = \\mathsf{Rot}(\\mathbf{A}) \\times \\mathsf{FCoef}(\\vec{\\mathbf{f}})</span> for any <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{\\kappa \\times m}</span> and <span class="math">\\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m</span>.</p>

    <p class="text-gray-300">Fix a ring <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span>, given <span class="math">\\mathbf{a} \\in \\mathcal{R}_q</span> and the coefficient embeddings of ring elements <span class="math">\\mathbf{b}_1, \\ldots, \\mathbf{b}_\\tau</span>, the following lemma shows that the coefficient embeddings of <span class="math">\\mathbf{a} \\cdot \\mathbf{b}_1, \\ldots, \\mathbf{a} \\cdot \\mathbf{b}_\\tau</span> can be obtained through straightforward linear operations.</p>

    <p class="text-gray-300"><strong>Lemma 2.1.</strong> Let <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span> for some <span class="math">\\tau \\in \\mathbb{N}</span> where <span class="math">\\tau \\mid d</span>. Given <span class="math">\\mathbf{a} \\in \\mathcal{R}_q</span> and <span class="math">\\vec{B} := [B_1, \\ldots, B_d]^\\top \\in \\mathbb{F}_{q^\\tau}^d</span>, we define function <span class="math">\\mathrm{RotSum}: \\mathcal{R}_q \\times \\mathbb{F}_{q^\\tau}^d \\to \\mathbb{F}_{q^\\tau}^d</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{RotSum}(\\mathbf{a}, \\vec{B}) := \\sum_{i=1}^d B_i \\cdot \\operatorname{Coef}(X^{i-1}\\mathbf{a}), \\tag{5}</span></div>

    <p class="text-gray-300">where <span class="math">\\cdot : \\mathbb{F}_{q^\\tau} \\times \\mathbb{Z}_q^d \\to \\mathbb{F}_{q^\\tau}^d</span> denotes scalar multiplication between <span class="math">\\mathbb{F}_{q^\\tau}</span> and <span class="math">\\mathbb{Z}_q^d</span>. Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">a \\in \\mathbb{Z}_q</span> and <span class="math">\\mathbf{b} \\in \\mathcal{R}_q</span>, we have that <span class="math">\\operatorname{Coef}(a \\cdot \\mathbf{b}) = a \\cdot \\operatorname{Coef}(\\mathbf{b})</span>.</li>

      <li>For every <span class="math">\\mathbf{a}, \\mathbf{b} \\in \\mathcal{R}_q</span> (where <span class="math">\\operatorname{Coef}(\\mathbf{b}) \\in \\mathbb{Z}_q^d \\subseteq \\mathbb{F}_{q^\\tau}^d</span>), we have that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{RotSum}(\\mathbf{a}, \\operatorname{Coef}(\\mathbf{b})) = \\operatorname{Coef}(\\mathbf{a} \\cdot \\mathbf{b}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\mathbf{a}, \\mathbf{b}_1, \\ldots, \\mathbf{b}_\\tau \\in \\mathcal{R}_q</span>, define</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\vec{B} := \\sum_{j=1}^\\tau \\operatorname{Coef}(\\mathbf{b}_j) \\cdot Y^{j-1} = [\\vec{B}_1, \\dots, \\vec{B}_d]^\\top \\in \\mathbb{F}_{q^\\tau}^d</span></div>

    <p class="text-gray-300">where <span class="math">\\vec{B}_i := \\sum_{j=1}^\\tau \\operatorname{Coef}_i(\\mathbf{b}_j) \\cdot Y^{j-1} \\in \\mathbb{F}_{q^\\tau}</span> for every <span class="math">i \\in [d]</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{RotSum}(\\mathbf{a}, \\vec{B}) = \\sum_{j=1}^\\tau \\operatorname{Coef}(\\mathbf{a} \\cdot \\mathbf{b}_j) \\cdot Y^{j-1} \\in \\mathbb{F}_{q^\\tau}^d.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> The 1st claim is clear as <span class="math">\\mathcal{R}_q</span> is a <span class="math">\\mathbb{Z}_q</span>-module. The 2nd claim holds because</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{RotSum}(\\mathbf{a}, \\operatorname{Coef}(\\mathbf{b})) = \\operatorname{Rot}(\\mathbf{a}) \\times \\operatorname{Coef}(\\mathbf{b}) = \\operatorname{Coef}(\\mathbf{a} \\cdot \\mathbf{b})</span></div>

    <p class="text-gray-300">by definition of <span class="math">\\mathrm{Rot}(\\mathbf{a})</span> and by Eq. (3).</p>

    <p class="text-gray-300">Next, we prove the last claim. For every <span class="math">i \\in [d]</span>, note that <span class="math">\\vec{B}_i = \\sum_{j=1}^{\\tau} \\operatorname{Coef}_i(\\mathbf{b}_j) \\cdot Y^{j-1} \\in \\mathbb{F}_{q^\\tau}</span> and the <span class="math">i</span>-th column of <span class="math">\\operatorname{Rot}(\\mathbf{a})</span> is <span class="math">[\\operatorname{Rot}(\\mathbf{a})]_i = \\operatorname{Coef}(X^{i-1}\\mathbf{a}) \\in \\mathbb{Z}_q^d</span>. Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname{RotSum}(\\mathbf{a}, \\vec{B}) &amp;amp;:= \\sum_{i=1}^{d} \\left(\\sum_{j=1}^{\\tau} \\operatorname{Coef}_i(\\mathbf{b}_j) \\cdot Y^{j-1}\\right) \\cdot [\\operatorname{Rot}(\\mathbf{a})]_i = \\sum_{j=1}^{\\tau} \\left(\\sum_{i=1}^{d} \\operatorname{Coef}_i(\\mathbf{b}_j) \\cdot [\\operatorname{Rot}(\\mathbf{a})]_i\\right) \\cdot Y^{j-1} \\\\ &amp;amp;= \\sum_{j=1}^{\\tau} \\operatorname{RotSum}(\\mathbf{a}, \\operatorname{Coef}(\\mathbf{b}_j)) \\cdot Y^{j-1} = \\sum_{j=1}^{\\tau} \\operatorname{Coef}(\\mathbf{a} \\cdot \\mathbf{b}_j) \\cdot Y^{j-1}. \\end{aligned}</span></div>

    <p class="text-gray-300">The 1st and the 3rd equality is by definition of <span class="math">\\operatorname{RotSum}</span>; the last equality follows by the 2nd claim of the lemma.</p>

    <p class="text-gray-300">Norms. Let <span class="math">\\mathcal{R} \\coloneqq \\mathbb{Z}[X] / (X^d + 1)</span>. For a polynomial <span class="math">f \\coloneqq \\sum_{i=0}^{d-1} f_i X^i \\in \\mathcal{R}</span>, the <span class="math">\\ell_2</span>-norm and <span class="math">\\ell_{\\infty}</span>-norm of <span class="math">f</span> are</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 := \\left(\\sum_{i=0}^{d-1} f_i^2\\right)^{\\frac{1}{2}}, \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} := \\max_{i=0}^{d-1} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For a vector of polynomials <span class="math">\\vec{\\mathbf{f}} := (f_1, \\ldots, f_k) \\in \\mathcal{R}^k</span>, its <span class="math">\\ell_2</span>-norm and <span class="math">\\ell_{\\infty}</span>-norm are</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 := \\left(\\sum_{i=1}^{k} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2^2\\right)^{\\frac{1}{2}}, \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} := \\max_{i=1}^{k} (\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{dk} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> for all </span>\\vec{\\mathbf{f}} \\in \\mathcal{R}^k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark 2.1 (Norms of <span class="math">\\mathcal{R}_q</span>-elements).</strong> Let <span class="math">\\mathcal{R}_q \\coloneqq \\mathcal{R} / q\\mathcal{R}</span>. For a vector <span class="math">\\vec{\\mathbf{f}} \\coloneqq (f_1, \\ldots, f_k) \\in \\mathcal{R}_q^k</span>, we abuse the notation $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> to indicate the norm of </span>\\vec{\\mathbf{f}}<span class="math"> after lifting to </span>\\mathcal{R}^k<span class="math">. The lifting works by mapping the </span>\\mathbb{Z}_q<span class="math">-coefficients of </span>\\vec{\\mathbf{f}}<span class="math"> to the interval </span>(-q/2, q/2] \\subseteq \\mathbb{Z}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-12" class="text-2xl font-bold">2.1 Sampling Sets</h2>

    <p class="text-gray-300">We review the definition of sampling sets from [CCKP19].</p>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> For an arbitrary ring <span class="math">\\mathcal{R}</span>, a subset <span class="math">\\mathcal{C}</span> of <span class="math">\\mathcal{R}</span> is a sampling set if the difference of any two distinct elements in <span class="math">\\mathcal{C}</span> is not a zero divisor. <span class="math">\\mathcal{C}</span> is further a strong sampling set if the difference is also invertible.</p>

    <p class="text-gray-300">Example: Set <span class="math">\\bar{\\mathcal{R}} := \\mathcal{R}_q</span> where <span class="math">q</span> is a prime. Then <span class="math">\\mathbb{Z}_q \\subseteq \\mathcal{R}_q</span> is a strong sampling set as the difference of any two distinct elements in this set is invertible in <span class="math">\\mathcal{R}_q</span>.</p>

    <p class="text-gray-300">11</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sometimes we need a strong sampling set <span class="math">\\mathcal{C}_{\\mathsf{small}}\\subseteq\\mathcal{R}_{q}</span> such that for every <span class="math">\\rho\\in\\mathcal{C}_{\\mathsf{small}}</span> and any <span class="math">\\hat{\\mathbf{v}}\\in\\mathcal{R}</span>, the norm of <span class="math">\\rho\\hat{\\mathbf{v}}</span> will not increase much compared to $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\mathbf{v}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">. To quantify this property, we define the expansion factor of </span>\\mathcal{C}_{\\mathsf{small}}\\subseteq\\mathcal{R}_{q}$ as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}:=\\sup_{\\rho\\in\\mathcal{C}_{\\mathsf{small}},\\hat{\\mathbf{v}}\\in\\mathcal{R}}\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho\\times\\hat{\\mathbf{v}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\mathbf{v}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}\\,.$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, the multiplication <span class="math">\\rho\\times\\hat{\\mathbf{v}}</span> is performed over the ring <span class="math">\\mathcal{R}</span> where we lift <span class="math">\\rho\\in\\mathcal{R}_{q}</span> to <span class="math">\\mathcal{R}</span> as in Remark 2.1. The lemma below shows that a set with small norm elements has small expansion factors.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Lemma 2.2 (Prop. 2 of <em>[x1]</em>).</h6>

    <p class="text-gray-300">In <span class="math">\\mathcal{R}:=\\mathbb{Z}[X]/(X^{d}+1)</span>, for all <span class="math">\\mathbf{u},\\hat{\\mathbf{v}}\\in\\mathcal{R}</span>, we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\hat{\\mathbf{v}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\mathbf{v}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}\\leq d\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{u}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following lemma shows that an element in <span class="math">\\mathcal{R}_{q}</span> is invertible if its norm (after lifting to <span class="math">\\mathcal{R}</span>) is small. Combining with Lemma 2.2, it implies that we can find large strong sampling sets in <span class="math">\\mathcal{R}_{q}</span> with small expansion factors. This is because the difference between any two distinct small elements (with norm less than <span class="math">q/4</span>) remains small (as there is no modulus overflow) and is therefore invertible.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 2.3 (Corollary 1.2 of <em>[x18]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">d\\geq t&gt;1</span> be a power-of-two and <span class="math">q\\equiv 1+2t\\pmod{4t}</span> be a prime. Then every <span class="math">\\mathbf{y}\\in\\mathcal{R}_{q}:=\\mathbb{Z}_{q}[X]/(X^{d}+1)</span> where $0<\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<\\frac{q^{1/t}}{\\sqrt{t}}<span class="math"> is invertible. Here </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> denotes </span>\\mathbf{y}<span class="math">’s norm after lifting to </span>\\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.2 Module SIS</h3>

    <p class="text-gray-300">We recall the Module Short Integer Solution (MSIS) problem <em>[x15, x16, x17]</em>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 2.2 (Module SIS).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}:=\\mathbb{Z}[X]/(X^{d}+1)</span> and <span class="math">\\mathcal{R}_{q}:=\\mathcal{R}/q\\mathcal{R}</span>. Given a random matrix <span class="math">\\mathbf{A}\\leftarrow\\ast\\mathcal{R}_{q}^{\\kappa\\times m}</span>, the goal of the <span class="math">\\mathsf{MSIS}^{q}_{\\kappa,m,B_{\\mathsf{SIS}}}</span> problem is to find a non-zero <span class="math">\\vec{\\mathbf{x}}\\in\\mathcal{R}^{m}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<B_{\\mathsf{SIS}}<span class="math"> and </span>\\mathbf{A}\\vec{\\mathbf{x}}=\\vec{\\mathbf{0}}<span class="math"> over </span>\\mathcal{R}_{q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The MSIS-algorithm from Micciancio and Regev <em>[x19]</em> can output an MSIS solution with <span class="math">\\ell_{2}</span>-norm <span class="math">B_{\\mathsf{SIS}}\\approx\\min(q,2^{2\\sqrt{\\log_{2}(\\delta)d\\kappa\\log q}})</span> where <span class="math">\\delta</span> is the root Hermite factor of the lattice reduction algorithm. In practice, setting <span class="math">\\delta\\approx 1.0045</span> and letting <span class="math">q/2&gt;2^{2\\sqrt{\\log_{2}(\\delta)d\\kappa\\log q}}</span> is believed to lead to an MSIS problem that has 128 bits of security <em>[x6, x1]</em>. We will focus on the <span class="math">\\ell_{\\infty}</span>-norm. Thus we also review a variant of the MSIS problem that replaces the <span class="math">\\ell_{2}</span>-norm with <span class="math">\\ell_{\\infty}</span>-norm. It is clear that <span class="math">\\mathsf{MSIS}^{\\infty,q}_{\\kappa,m,B}</span> is at least as hard as <span class="math">\\mathsf{MSIS}^{q}_{\\kappa,m,\\sqrt{dm}B}</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 2.3 (Module SIS with <span class="math">\\ell_{\\infty}</span>-norms <em>[x2]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}:=\\mathbb{Z}[X]/(X^{d}+1)</span> and <span class="math">\\mathcal{R}_{q}:=\\mathcal{R}/q\\mathcal{R}</span>. On input <span class="math">\\mathbf{A}\\leftarrow\\ast\\mathcal{R}_{q}^{\\kappa\\times m}</span>, the goal of the <span class="math">\\mathsf{MSIS}^{\\infty,q}_{\\kappa,m,B}</span> problem is to find a non-zero <span class="math">\\vec{\\mathbf{x}}\\in\\mathcal{R}^{m}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B<span class="math"> and </span>\\mathbf{A}\\vec{\\mathbf{x}}=\\vec{\\mathbf{0}}<span class="math"> over </span>\\mathcal{R}_{q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.3 The Ajtai Compact Commitment</p>

    <p class="text-gray-300">A commitment scheme CM consists of a setup algorithm Setup that generates a public parameter pp; and a deterministic commit algorithm Commit that takes as input pp, a message <span class="math">\\vec{\\mathbf{x}}</span> and randomness <span class="math">r</span>, and outputs a commitment cm. We say that CM is compact if the commitment cm is shorter than the committed message <span class="math">\\vec{\\mathbf{x}}</span>. We say CM is binding if it is hard to find a commitment cm and two different openings <span class="math">(\\vec{\\mathbf{x}}_{1},r_{1})</span>, <span class="math">(\\vec{\\mathbf{x}}_{2},r_{2})</span> such that <span class="math">\\mathsf{cm} = \\mathsf{Commit}(\\mathsf{pp},\\vec{\\mathbf{x}}_{1},r_{1}) = \\mathsf{Commit}(\\mathsf{pp},\\vec{\\mathbf{x}}_{2},r_{2})</span>. We say that CM is hiding if cm is statistically independent of <span class="math">\\vec{\\mathbf{x}}</span> over the choice of randomness <span class="math">r</span>.</p>

    <p class="text-gray-300">We review a variant of the Ajtai commitment scheme [Ajt96; PR06; LM06] whereas the messages are ring elements with small norms. For brevity, we present the construction (i.e., the Ajtai collision resistant hash function) that achieves only the binding property. It can be extended to support hiding by appending a small random vector to the message [KTX08].</p>

    <p class="text-gray-300"><strong>Construction 2.1 (Ajtai Compact Commitments).</strong> Let <span class="math">\\mathcal{R} \\coloneqq \\mathbb{Z}[X] / (X^d + 1)</span> and <span class="math">\\mathcal{R}_q \\coloneqq \\mathcal{R} / q\\mathcal{R}</span> where <span class="math">q \\in \\mathbb{N}</span> is a prime. The commitment <span class="math">\\mathsf{CM}_{\\kappa, m, B}</span> works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Setup}(\\kappa, m) \\to \\mathbf{A}</span>: sample a random matrix <span class="math">\\mathbf{A} \\leftarrow \\mathbb{R}_q^{\\kappa \\times m}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\operatorname{Commit}(\\mathbf{A}, \\vec{\\mathbf{x}}) \\to \\mathsf{cm}</span>: given <span class="math">\\vec{\\mathbf{x}} \\in \\mathcal{R}^m</span> as input, where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math">, and no randomness, output </span>\\mathsf{cm} := \\mathbf{A} \\vec{\\mathbf{x}} \\mod q \\in \\mathcal{R}_q^\\kappa$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is clear that <span class="math">\\mathsf{CM}_{\\kappa, m, B}</span> satisfies the binding property for inputs $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math"> assuming that the MSIS problem </span>\\mathsf{MSIS}_{\\kappa, m, 2B}^{\\infty, q}<span class="math"> is hard. Suppose not, that is, an adversary can open a commitment cm to two different openings </span>\\vec{\\mathbf{x}}_1<span class="math">, </span>\\vec{\\mathbf{x}}_2<span class="math"> (with </span>\\ell_{\\infty}<span class="math">-norm less than </span>B<span class="math">), then </span>\\vec{\\mathbf{x}}_1 - \\vec{\\mathbf{x}}_2 \\neq 0<span class="math"> is a solution to the </span>\\mathsf{MSIS}_{\\kappa, m, 2B}^{\\infty, q}<span class="math"> problem where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}_1 - \\vec{\\mathbf{x}}_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; 2B$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The analysis of our protocol also needs a relaxed notion of the binding property [ALS20; ACK21]. Let <span class="math">\\mathcal{C} \\subset \\mathcal{R}_q</span> be a strong sampling set with expansion factor <span class="math">T</span>. We say that the pair <span class="math">(\\Delta, \\vec{\\mathbf{x}}) \\in (\\mathcal{C} - \\mathcal{C}) \\times \\mathcal{R}^m</span> is a <span class="math">B</span>-weak opening of cm if <span class="math">\\Delta \\cdot \\mathsf{cm} = \\mathbf{A}\\vec{\\mathbf{x}}\\bmod q</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math">. We say that the commitment scheme is </span>B<span class="math">-relaxed binding if it is infeasible to find two </span>B<span class="math">-weak openings </span>(\\Delta_1, \\vec{\\mathbf{x}}_1)<span class="math">, </span>(\\Delta_2, \\vec{\\mathbf{x}}_2)<span class="math"> for the same commitment cm such that </span>\\Delta_1\\vec{\\mathbf{x}}_2 \\neq \\Delta_2\\vec{\\mathbf{x}}_1<span class="math">. It is clear that the Ajtai commitment is </span>B<span class="math">-relaxed binding if </span>\\mathsf{MSIS}_{\\kappa, m, 4TB}^{\\infty, q}<span class="math"> is hard. Suppose not, i.e., for cm, we can find two weak openings </span>(\\Delta_1 := (\\rho_1 - \\rho_1'), \\vec{\\mathbf{x}}_1)<span class="math">, </span>(\\Delta_2 := (\\rho_2 - \\rho_2'), \\vec{\\mathbf{x}}_2)<span class="math"> where </span>\\rho_1, \\rho_1', \\rho_2, \\rho_2' \\in \\mathcal{C}<span class="math">, </span>\\Delta_1\\vec{\\mathbf{x}}_2 \\neq \\Delta_2\\vec{\\mathbf{x}}_1<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math">. Then </span>(\\rho_2 - \\rho_2') \\cdot \\vec{\\mathbf{x}}_1 - (\\rho_1 - \\rho_1') \\cdot \\vec{\\mathbf{x}}_2 \\neq 0<span class="math"> is a solution to </span>\\mathsf{MSIS}_{\\kappa, m, 4TB}^{\\infty, q}<span class="math"> with norm at most </span>4TB$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-18" class="text-2xl font-bold">2.4 Sum-Checks and Multilinear Extensions over Rings</h2>

    <p class="text-gray-300"><strong>Generalized Schwartz-Zippel Lemma.</strong> We recall a generalization of the Schwartz-Zippel lemma to the commutative ring setting, where each challenge is picked from a sampling set.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.4 (Generalized Schwartz-Zippel [BCPS18]).</strong> Let <span class="math">f \\in \\bar{\\mathcal{R}}^{\\leq d}[X_1, \\ldots, X_\\mu]</span> be a <span class="math">\\mu</span>-variate nonzero polynomial over a ring <span class="math">\\bar{\\mathcal{R}}</span> with per-variable degree at most <span class="math">d</span>. Let <span class="math">\\mathcal{C} \\subseteq \\bar{\\mathcal{R}}</span> be a sampling set. Then we have $\\operatorname{Pr}_{\\vec{\\mathbf{r}} \\leftarrow \\mathcal{C}^{\\mu}}[f(\\vec{\\mathbf{r}}) = 0] \\leq \\frac{d\\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">Sum-check over rings.</p>

    <p class="text-gray-300">Given Lemma 2.4, the famous sum-check protocol <em>[x10]</em> can be naturally extended to work over a ring <span class="math">\\bar{\\mathcal{R}}</span> with the modification that the challenges are sampled from a <em>strong</em> sampling set.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 2.5 (Generalized Sum-Check <em>[x4]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">f\\in\\bar{\\mathcal{R}}^{\\leq d}[X_{1},\\ldots,X_{\\mu}]</span> be a <span class="math">\\mu</span>-variate polynomial over a ring <span class="math">\\bar{\\mathcal{R}}</span> with per-variable degree at most <span class="math">d</span>. Let <span class="math">\\mathcal{C}\\subseteq\\bar{\\mathcal{R}}</span> be a strong sampling set. The protocol below for checking <span class="math">s=\\sum_{\\vec{\\mathbf{b}}\\in\\{0,1\\}^{\\mu}}f(\\vec{\\mathbf{b}})</span> has soundness error $\\frac{\\mu d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the <span class="math">i</span>-th (<span class="math">1\\leq i\\leq\\mu</span>) round,</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving the challenges <span class="math">\\mathbf{r}_{1},\\ldots,\\mathbf{r}_{i-1}</span> from the previous rounds, the prover sends the univariate polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">h_{i}(X):=\\sum_{\\vec{\\mathbf{b}}\\in\\{0,1\\}^{\\mu-i}}f(\\mathbf{r}_{1},\\ldots,\\mathbf{r}_{i-1},X,\\vec{\\mathbf{b}})\\quad\\in\\bar{\\mathcal{R}}[X]\\,.</span></p>

    <p class="text-gray-300">More specifically, it sends <span class="math">d+1</span> evaluations of <span class="math">h_{i}</span> at <span class="math">d+1</span> points in <span class="math">\\mathcal{C}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote <span class="math">h_{0}(\\mathbf{r}_{0}):=s</span> for notational convenience. The verifier checks that <span class="math">h_{i}(0)+h_{i}(1)\\stackrel{{\\scriptstyle?}}{{=}}h_{i-1}(\\mathbf{r}_{i-1})</span> and sends a random challenge <span class="math">\\mathbf{r}_{i}\\stackrel{{\\scriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle\\scriptscriptstyle}}f(\\mathbf{r}_{1},\\ldots,\\mathbf{r}_{i-1},X,\\vec{\\mathbf{b}})</span> if <span class="math">d+1</span> evaluations sent by the prover, as the differences of distinct evaluation points are invertible.)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that <span class="math">h_{\\mu}(\\mathbf{r}_{i})\\stackrel{{\\scriptstyle?}}{{=}}f(\\mathbf{r}_{1},\\ldots,\\mathbf{r}_{\\mu})</span>.</li>

    </ol>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">See the proof of Theorem 2 in <em>[x4]</em>. ∎</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Multilinear extensions over rings.</h4>

    <p class="text-gray-300">We define the multilinear extensions over rings.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 2.4 (Multilinear Extensions over Rings).</h6>

    <p class="text-gray-300">Let <span class="math">\\bar{\\mathcal{R}}</span> be an arbitrary ring with zero <span class="math">0</span> and identity <span class="math">1</span>. Given a function <span class="math">f:\\{0,1\\}^{\\mu}\\to\\bar{\\mathcal{R}}</span>, we define the multilinear extension <span class="math">\\mathsf{mle}\\left[f\\right]\\in\\bar{\\mathcal{R}}^{\\leq 1}[X_{1},\\ldots,X_{\\mu}]</span> of <span class="math">f</span> as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{X}}">f\\right</a>:=\\sum_{\\vec{\\mathbf{b}}\\in\\{0,1\\}^{\\mu}}f(\\vec{\\mathbf{b}})\\cdot eq(\\vec{\\mathbf{b}},\\vec{\\mathbf{X}})</span></p>

    <p class="text-gray-300">where <span class="math">eq(\\vec{\\mathbf{b}},\\vec{\\mathbf{X}})</span> is defined as <span class="math">eq(\\vec{\\mathbf{b}},\\vec{\\mathbf{X}}):=\\prod_{i=1}^{\\mu}\\big{[}(1-\\vec{\\mathbf{b}}_{i})(1-\\vec{\\mathbf{X}}_{i})+\\vec{\\mathbf{b}}_{i}\\vec{\\mathbf{X}}_{i}\\big{]}</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.5 Reduction of Knowledge</h3>

    <p class="text-gray-300">Intuitively, a reduction-of-knowledge protocol <span class="math">\\Pi</span> (from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span>) allows a prover to convince a verifier on input <span class="math">\\varkappa_{1}</span> to obtain an output <span class="math">\\varkappa_{2}</span>, such that from anyone who knows a witness <span class="math">\\varkappa_{2}</span> where <span class="math">(\\varkappa_{2},\\varkappa_{2})\\in\\mathcal{R}_{2}</span>, one can extract a witness <span class="math">\\varkappa_{1}</span> where <span class="math">(\\varkappa_{1},\\varkappa_{1})\\in\\mathcal{R}_{1}</span>. We adapt the definition from <em>[x11]</em>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Definition 2.5 (Reduction of knowledge [KP23]). Consider ternary relations <span class="math">\\mathcal{R}_1</span> and <span class="math">\\mathcal{R}_2</span> consisting of public parameters, statement and witness tuples. Let <span class="math">\\langle \\mathsf{P},\\mathsf{V}\\rangle</span> denote an interactive protocol between a prover <span class="math">\\mathsf{P}</span> and a verifier <span class="math">\\mathsf{V}</span>. A reduction of knowledge protocol <span class="math">\\Pi</span> from relation <span class="math">\\mathcal{R}_1</span> to <span class="math">\\mathcal{R}_2</span> consists of the following PPT algorithms/protocols:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup <span class="math">(1^{\\lambda}) \\to \\mathsf{pp}</span>: on input security parameter <span class="math">\\lambda</span> outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{x}_1,\\mathbb{w}_1),\\mathsf{V}(\\mathsf{pp},\\mathbb{x}_1)\\rangle \\to (\\mathbb{x}_2,\\mathbb{w}_2)</span>: on input public parameters <span class="math">\\mathsf{pp}</span> and a shared instance <span class="math">\\mathbb{x}_1</span> for <span class="math">\\mathcal{R}_1</span>, the prover <span class="math">\\mathsf{P}</span> (which also has a witness <span class="math">\\mathbb{w}_1</span> for <span class="math">\\mathcal{R}_1</span>) and the verifier <span class="math">\\mathsf{V}</span> run an interactive protocol. At the end of the protocol, the verifier outputs an instance <span class="math">\\mathbb{x}_2</span> for <span class="math">\\mathcal{R}_2</span> or <span class="math">\\mathbb{x}_2 := \\bot</span>; and the prover additionally outputs a witness <span class="math">\\mathbb{w}_2</span> for <span class="math">\\mathcal{R}_2</span>. We let <span class="math">(\\mathbb{x}_2,\\mathbb{w}_2)</span> denote the output of the interaction.</li>

    </ul>

    <p class="text-gray-300">The protocol satisfies the following properties:</p>

    <p class="text-gray-300"><strong>Completeness.</strong> For every PPT adversary <span class="math">\\mathcal{A}</span> that adaptively chooses an instance-witness pair <span class="math">(\\mathbb{x}_1, \\mathbb{w}_1) \\gets \\mathcal{A}(\\mathsf{pp})</span> for <span class="math">\\mathcal{R}_1</span> after observing the public parameter <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>. If <span class="math">(\\mathsf{pp}, \\mathbb{x}_1, \\mathbb{w}_1)</span> is in <span class="math">\\mathcal{R}_1</span>, then the output <span class="math">(\\mathbb{x}_2, \\mathbb{w}_2)</span> of the execution <span class="math">\\langle \\mathsf{P}(\\mathsf{pp}, \\mathbb{x}_1, \\mathbb{w}_1), \\mathsf{V}(\\mathsf{pp}, \\mathbb{x}_1) \\rangle</span> is also in <span class="math">\\mathcal{R}_2</span>.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> We say that the protocol is knowledge sound with knowledge error <span class="math">\\kappa(\\lambda)</span>, if there exists an expected polynomial time extractor <span class="math">\\mathsf{Ext}</span> such that for any expected polynomial time adversary <span class="math">(\\mathcal{A}, \\mathsf{P}^*)</span>, if</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda}) \\\\ (\\mathsf{pp}, \\mathbb{x}_2, \\mathbb{w}_2) \\in \\mathcal{R}_2 &amp;amp; (\\mathbb{x}_1, \\mathsf{st}) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ &amp;amp; (\\mathbb{x}_2, \\mathbb{w}_2) \\leftarrow \\langle \\mathsf{P}^*(\\mathsf{pp}, \\mathbb{x}_1, \\mathsf{st}), \\mathsf{V}(\\mathsf{pp}, \\mathbb{x}_1) \\rangle \\end{array} \\right] = \\epsilon(\\lambda) &amp;gt; \\kappa(\\lambda)</span></div>

    <p class="text-gray-300">where <span class="math">\\epsilon(\\lambda) \\geq \\frac{1}{\\mathrm{poly}(\\lambda)}</span>, then with probability at least <span class="math">\\epsilon(\\lambda) - \\kappa(\\lambda)</span>, the extractor <span class="math">\\mathsf{Ext}^{\\mathcal{A},\\mathsf{P}^*}</span> outputs a witness <span class="math">\\mathbb{w}_1</span> such that <span class="math">(\\mathsf{pp}, \\mathbb{x}_1, \\mathbb{w}_1) \\in \\mathcal{R}_1</span>.</p>

    <p class="text-gray-300"><strong>Public reducibility.</strong> There is a deterministic poly-time algorithm <span class="math">f</span> such that for any PPT adversary <span class="math">\\mathcal{A}</span> and expected poly-time adversary <span class="math">\\mathsf{P}^*</span>, given</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda}), \\quad (\\mathbb{x}_1, \\mathsf{st}) \\leftarrow \\mathcal{A}(\\mathsf{pp}), \\quad \\text{and} \\quad (\\mathbb{x}_2, \\mathbb{w}_2) \\leftarrow \\langle \\mathsf{P}^*(\\mathsf{pp}, \\mathbb{x}_1, \\mathsf{st}), \\mathsf{V}(\\mathsf{pp}, \\mathbb{x}_1) \\rangle</span></div>

    <p class="text-gray-300">with transcript <span class="math">\\mathsf{tr}</span>, we have that <span class="math">f(\\mathsf{pp}, \\mathbb{x}_1, \\mathsf{tr}) = \\mathbb{x}_2</span>.</p>

    <p class="text-gray-300"><span class="math">\\Pi</span> is public-coin if the verifier only sends uniformly random challenges in each round. Note that a public-coin protocol can be made non-interactive via the Fiat-Shamir transformation.</p>

    <p class="text-gray-300">As noted by [KP23], the reduction of knowledge protocols can be composed.</p>

    <p class="text-gray-300">1In standard definitions, the requirement for <span class="math">\\epsilon(\\lambda)</span> to be non-negligible is typically omitted. Our constructions also meet the stronger standard definition, though possibly with a slightly weaker bound.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 2.1 (Sequential Composition, Theorem 5 of <em>[x10]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}_{1}</span>, <span class="math">\\mathcal{R}_{2}</span>, <span class="math">\\mathcal{R}_{3}</span> be three ternary relations. Given a reduction of knowledge <span class="math">\\Pi_{1}</span> from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> and a reduction of knowledge <span class="math">\\Pi_{2}</span> from <span class="math">\\mathcal{R}_{2}</span> to <span class="math">\\mathcal{R}_{3}</span>, the composed protocol <span class="math">\\Pi_{2}\\circ\\Pi_{1}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{3}</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 2.2 (Parallel Composition, Theorem 6 of <em>[x10]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}_{1},\\mathcal{R}_{2},\\mathcal{R}_{3},\\mathcal{R}_{4}</span> be ternary relations. Given a reduction of knowledge <span class="math">\\Pi_{1}</span> from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> and a reduction of knowledge <span class="math">\\Pi_{2}</span> from <span class="math">\\mathcal{R}_{3}</span> to <span class="math">\\mathcal{R}_{4}</span>, the protocol <span class="math">\\Pi_{1}\\times\\Pi_{2}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{1}\\times\\mathcal{R}_{3}</span> to <span class="math">\\mathcal{R}_{2}\\times\\mathcal{R}_{4}</span>, where <span class="math">\\Pi_{1}\\times\\Pi_{2}</span> denotes the protocol that runs <span class="math">\\Pi_{1}</span> and <span class="math">\\Pi_{2}</span> in parallel.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Remark 2.2.</h6>

    <p class="text-gray-300">The knowledge soundness defined in Definition 2.5 should hold for expected polynomial-time adversaries and extractors. This requirements is necessary for proof of composition theorems. Looking ahead, this implies that the MSIS hardness assumption in Definition 2.3 must also hold for expected poly-time adversaries. This is without loss of generality because the MSIS assumption is falsifiable. As shown in <em>[x13]</em> (Appendix A), if a falsifiable assumption holds for strict PPT adversaries (i.e., probabilistic adversaries that always run in polynomial time), it also holds for expected poly-time adversaries.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 2.3 (Folding schemes as reductions of knowledge).</h6>

    <p class="text-gray-300">We note that the folding schemes introduced in Hypernova <em>[x12]</em> is a special case of reduction of knowledge, where for a computation relation <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span> and its expanded accumulation relaton <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>, the goal is to reduce the relation <span class="math">\\mathcal{R}_{\\mathsf{acc}}\\times\\mathcal{R}_{\\mathsf{comp}}</span> to the relation <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>.</p>

    <h2 id="sec-28" class="text-2xl font-bold">3 A Folding Scheme for Ajtai Commitment Openings</h2>

    <p class="text-gray-300">In this section, we develop a folding scheme for the Ajtai commitment opening relation. In Section 3.1, we define an algebraic relation <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{B}</span> that captures the commitment opening relation, and then extend it to a relation <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}</span> suitable for folding. In Section 3.2, we construct a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}\\times\\mathcal{R}_{\\mathsf{cm}}^{B}</span> to <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}</span>, leading to a folding scheme for the Ajtai commitment opening relation. In Section 3.3, we describe an optimization that allows the selection of a small prime modulus <span class="math">q</span> for improved efficiency.</p>

    <p class="text-gray-300">Designing a folding scheme for the relation <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{B}</span> is the core challenge in constructing a IVC/PCD scheme based on Ajtai commitments. This folding scheme also leads to a batch proof-of-knowledge for short pre-images of linear maps: it allows us to fold <span class="math">k</span> statements (each of size <span class="math">n</span>) into a single statement using a binary folding tree. This reduces the verifier complexity to <span class="math">\\tilde{O}(k+n)</span> instead of complexity <span class="math">\\Theta(kn)</span> if knowledge of each pre-image was proved on its own.</p>

    <p class="text-gray-300">This folding scheme for <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{B}</span>, by itself, is insufficient for an IVC/PCD. The relation <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{B}</span> needs to be augmented to facilitate the verification of a local computation step, either expressed as a R1CS statement or, more generally, a CCS statement. We come back to this in Section 4 where we build an extended relation <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^{B}</span> in Eq. (33) that is adequate for use in IVC/PCD.</p>

    <p class="text-gray-300">3.1 The Relation for Commitment Openings</p>

    <p class="text-gray-300">In this section, we reformulate the Ajtai commitment opening relation for efficient folding. The core idea, inspired and adapted from <em>[x1]</em>, is to interpret the norm bound constraint as a Hadamard product over rings.</p>

    <p class="text-gray-300">Recall that <span class="math">\\mathcal{R}_{q}:=\\mathcal{R}/q\\mathcal{R}</span> where <span class="math">\\mathcal{R}:=\\mathbb{Z}[X]/(X^{d}+1)</span> and <span class="math">q</span> is a prime. Given <span class="math">\\mathsf{pp}:=(\\kappa,m,B,\\mathbf{A})</span> where <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{\\kappa\\times m}</span> and <span class="math">B&lt;q/2</span> is the norm bound, the relation <span class="math">\\mathcal{R}_{\\mathsf{MSIS}^{\\infty}}^{B}</span> for Ajtai commitment openings (Section 2.3) is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}_{\\mathsf{MSIS}^{\\infty}}^{B}:=\\left\\{(\\mathsf{pp},\\ \\mathsf{cm}\\in\\mathcal{R}_{q}^{\\kappa};\\ \\vec{\\mathbf{x}}\\in\\mathcal{R}^{m})\\ :\\ (\\mathsf{cm}=\\mathbf{A}\\vec{\\mathbf{x}}\\ \\text{mod}\\ q)\\wedge\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">B&lt;q/2</span>, we can uniquely represent <span class="math">\\vec{\\mathbf{x}}</span> as a vector in <span class="math">\\mathcal{R}_{q}^{m}</span> and denote $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> as the norm after lifting </span>\\vec{\\mathbf{x}}<span class="math"> to </span>\\mathcal{R}^{m}<span class="math"> (See Remark 2.1). Then we rewrite </span>\\mathcal{R}_{\\mathsf{MSIS}^{\\infty}}^{B}$ as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}_{\\mathsf{MSIS}^{\\infty}}^{B}:=\\left\\{(\\mathsf{pp},\\ \\mathsf{cm}\\in\\mathcal{R}_{q}^{\\kappa};\\ \\vec{\\mathbf{x}}\\in\\mathcal{R}_{q}^{m})\\ :\\ (\\mathsf{cm}=\\mathbf{A}\\vec{\\mathbf{x}})\\wedge\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us define an equivalent relation <span class="math">\\mathcal{R}_{\\mathsf{SIS}^{\\infty}}^{B}</span> over <span class="math">\\mathbb{Z}_{q}</span>. Let <span class="math">\\bar{\\mathbf{A}}:=\\mathsf{Rot}(\\mathbf{A})</span> be the rotation matrix of <span class="math">\\mathbf{A}</span> (as in Eq. (4)) and denote by <span class="math">\\vec{x}:=\\mathsf{FCoef}(\\vec{\\mathbf{x}})\\in\\mathbb{Z}_{q}^{md}</span> the row concatenation of <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{x}})\\in\\mathbb{Z}_{q}^{m\\times d}</span>. Then the coefficient embedding of <span class="math">\\mathsf{cm}=\\mathbf{A}\\vec{\\mathbf{x}}</span> is exactly <span class="math">\\vec{\\mathsf{cm}}=\\bar{\\mathbf{A}}\\vec{x}</span>. Thus we can define the instance-witness relation <span class="math">\\mathcal{R}_{\\mathsf{SIS}^{\\infty}}^{B}</span> as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}_{\\mathsf{SIS}^{\\infty}}^{B}:=\\left\\{(\\mathsf{pp},\\ \\vec{\\mathsf{cm}}\\in\\mathbb{Z}_{q}^{\\kappa d};\\ \\vec{x}\\in\\mathbb{Z}_{q}^{md})\\ :\\ (\\vec{\\mathsf{cm}}=\\bar{\\mathbf{A}}\\vec{x})\\wedge\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Equivalently, we write $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B<q/2<span class="math"> as a Hadamard product relation </span>\\mathcal{R}_{\\mathsf{SISProd}}^{B}<span class="math"> over </span>\\mathbb{Z}_{q}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\mathsf{SISProd}}^{B}:=\\left\\{(\\mathsf{pp},\\ \\vec{\\mathsf{cm}}\\in\\mathbb{Z}_{q}^{\\kappa d};\\ \\vec{x}\\in\\mathbb{Z}_{q}^{md})\\ :\\ \\begin{array}[]{l}(\\vec{\\mathsf{cm}}=\\bar{\\mathbf{A}}\\vec{x})\\wedge\\\\ \\left(\\vec{x}\\circ\\left[\\bigcirc_{i=1}^{B-1}(\\vec{x}-\\vec{i})\\circ(\\vec{x}+\\vec{i})\\right]=\\vec{0}\\right)\\end{array}\\right\\} \\] (7)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\vec{i}\\in\\mathbb{Z}_{q}^{md}</span> is <span class="math">i</span> multiplied by the identity vector <span class="math">I_{md}:=(1,\\ldots,1)\\in\\mathbb{Z}_{q}^{md}</span>. Clearly the Hadamard product in (7) is zero if and only if $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B$, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The final step involves replacing the Hadamard product relation over <span class="math">\\mathbb{Z}_{q}</span> with a Hadamard product relation over <span class="math">\\mathcal{R}_{q}</span>. For brevity, we assume that <span class="math">q\\equiv 1\\ \\text{mod}\\ 2d</span> as in Eq. (1). In Section 3.3 we will explain how to generalize to other primes. Note that <span class="math">q\\equiv 1\\ \\text{mod}\\ 2d</span> implies that <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{Z}_{q}^{d}</span>.</p>

    <p class="text-gray-300">There are two ways to interpret <span class="math">\\vec{x}\\in\\mathbb{Z}_{q}^{md}</span>. We alternatively view <span class="math">\\vec{x}\\in\\mathbb{Z}_{q}^{m\\times d}</span> as an <span class="math">m</span>-by-<span class="math">d</span> <span class="math">\\mathbb{Z}_{q}</span>-matrix in its natural form. First, <span class="math">\\vec{x}</span> can be the coefficient embeddings of some <span class="math">\\vec{\\mathbf{f}}\\in\\mathcal{R}_{q}^{m}</span>, so that <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{f}})=\\vec{x}</span>. Alternatively, it can be understood as the NTT representations of some <span class="math">\\hat{\\mathbf{f}}\\in\\mathcal{R}_{q}^{m}</span>, that is, <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}})=\\mathsf{Coef}(\\vec{\\mathbf{f}})=\\vec{x}</span>. Moreover, the <em>Hadamard product</em> between the NTT slots of two ring elements can map to the <em>multiplication</em> of the two ring elements. In other words, <span class="math">\\vec{x}\\circ\\vec{x}=\\mathsf{NTT}(\\hat{\\mathbf{f}})\\circ\\mathsf{NTT}(\\hat{\\mathbf{f}})=\\mathsf{NTT}(\\hat{\\mathbf{f}}\\circ\\hat{\\mathbf{f}})</span>, which maps to <span class="math">\\hat{\\mathbf{f}}\\circ\\hat{\\mathbf{f}}</span> via the NTT</p>

    <p class="text-gray-300">isomorphism. Here <span class="math">\\vec{x} \\circ \\vec{x}</span> is a Hadamard product over <span class="math">\\mathbb{Z}_q</span>, while <span class="math">\\hat{\\mathbf{f}} \\circ \\hat{\\mathbf{f}}</span> is over <span class="math">\\mathcal{R}_q</span>. Thus, we can rewrite <span class="math">\\mathcal{R}_{\\mathrm{SSProd}}^B</span> from (7) as the following instance-witness relation <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> over <span class="math">\\mathcal{R}_q</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{cm}}^B := \\left\\{(\\mathsf{pp}, \\mathsf{cm} \\in \\mathcal{R}_q^{\\kappa}; \\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m) : \\begin{array}{l} (\\mathsf{cm} = \\mathbf{A} \\vec{\\mathbf{f}}) \\wedge \\\\ \\left(\\hat{\\mathbf{f}} \\circ \\left[ \\bigcirc_{i=1}^{B-1} (\\hat{\\mathbf{f}} - \\hat{i}) \\circ (\\hat{\\mathbf{f}} + \\hat{i}) \\right] = \\hat{0}\\right) \\end{array} \\right\\}. \\tag{8}</span></div>

    <p class="text-gray-300">Here <span class="math">\\hat{i} \\in \\mathcal{R}_q^m</span> is the ring vector such that <span class="math">\\vec{i} = \\mathsf{NTT}(\\hat{i})</span> where <span class="math">\\vec{i} \\in \\mathbb{Z}_q^{m \\times d}</span> is the element <span class="math">i \\in \\mathbb{Z}_q</span> copied <span class="math">md</span> times. Note that each element in <span class="math">\\hat{i}</span> is the constant polynomial <span class="math">i \\in \\mathbb{Z}_q</span>, so that <span class="math">\\hat{i}</span> is in <span class="math">\\mathbb{Z}_q^m</span>.</p>

    <p class="text-gray-300">Proving knowledge of a witness <span class="math">\\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m</span> for the <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> statement <span class="math">(\\mathsf{pp}, \\mathsf{cm})</span> proves knowledge of a low-norm opening of the Ajtai commitment <span class="math">\\mathsf{cm} \\in \\mathcal{R}_q^\\kappa</span>.</p>

    <p class="text-gray-300"><strong>The expanded relation.</strong> To construct a folding scheme for <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span>, we augment <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> to a new relation <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> with an evaluation statement. Looking ahead, in our folding scheme, the verifier runs a sum-check to reduce the norm bound constraint in <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> to an evaluation statement. Thus, it is necessary to incorporate such an evaluation statement into the accumulated relation. For simplicity, we assume that <span class="math">m</span> is a power of two. The relation <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> is defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{eval}}^B := \\left\\{ \\left( \\mathsf{pp}, \\mathsf{z} := (\\vec{\\mathbf{r}}, \\hat{\\mathbf{v}}, \\mathsf{cm}) \\in \\mathcal{R}_q^{\\log m} \\times \\mathcal{R}_q \\times \\mathcal{R}_q^{\\kappa}; \\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m \\right) : \\begin{array}{l} (\\mathsf{pp}, \\mathsf{cm}; \\vec{\\mathbf{f}}) \\in \\mathcal{R}_{\\mathrm{cm}}^B \\\\ \\wedge \\mathsf{mle} \\left[ \\hat{\\mathbf{f}} \\right] (\\vec{\\mathbf{r}}) = \\hat{\\mathbf{v}} \\end{array} \\right\\}, \\tag{9}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{mle}\\left[\\hat{\\mathbf{f}}\\right] \\in \\mathcal{R}_q^{\\leq 1}[X_1, \\ldots, X_{\\log m}]</span> is the multilinear extension (Definition 2.4) of <span class="math">\\hat{\\mathbf{f}} \\in \\mathcal{R}_q^m</span>. Recall that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NTT}(\\hat{\\mathbf{f}}) = \\begin{bmatrix} \\mathsf{NTT}(\\hat{\\mathbf{f}}_1)^\\top \\\\ \\vdots \\\\ \\mathsf{NTT}(\\hat{\\mathbf{f}}_m)^\\top \\end{bmatrix} = \\begin{bmatrix} \\mathsf{Coef}(\\vec{\\mathbf{f}}_1)^\\top \\\\ \\vdots \\\\ \\mathsf{Coef}(\\vec{\\mathbf{f}}_m)^\\top \\end{bmatrix} = \\mathsf{Coef}(\\vec{\\mathbf{f}}) \\in \\mathbb{Z}_q^{m \\times d}.</span></div>

    <h2 id="sec-29" class="text-2xl font-bold">3.2 A Generic Framework for Folding</h2>

    <p class="text-gray-300">In this section, we describe a folding scheme for <span class="math">\\mathcal{R}_{\\mathrm{acc}} := \\mathcal{R}_{\\mathrm{eval}}^B</span> and <span class="math">\\mathcal{R}_{\\mathrm{comp}} := \\mathcal{R}_{\\mathrm{cm}}^B</span>, or equivalently, a reduction of knowledge (Definition 2.5) from <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B \\times \\mathcal{R}_{\\mathrm{cm}}^B</span> to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>. This gives us a folding scheme for the Ajtai commitment opening relation. Our construction is highly modular and generic, and consists of three steps.</p>

    <p class="text-gray-300"><strong>Step 1: Expansion.</strong> First, the relation <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B \\times \\mathcal{R}_{\\mathrm{cm}}^B</span> is reduced to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B \\times \\mathcal{R}_{\\mathrm{eval}}^B</span> via a reduction of knowledge <span class="math">\\Pi_{\\mathrm{cm}}</span> from <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> shown in Figure 1.</p>

    <p class="text-gray-300">Step 2: Decomposition. Next, using a decomposition protocol <span class="math">\\Pi_{\\mathsf{dec}}</span> shown in Figure 2, we reduce the relation <span class="math">\\mathcal{R}_{\\mathsf{eval}}^B \\times \\mathcal{R}_{\\mathsf{eval}}^B</span> to</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathcal {R} _ {\\mathsf {e v a l}} ^ {b}) ^ {2 k} := \\underbrace {\\mathcal {R} _ {\\mathsf {e v a l}} ^ {b} \\times \\cdots \\times \\mathcal {R} _ {\\mathsf {e v a l}} ^ {b}} _ {2 k}</span></div>

    <p class="text-gray-300">where <span class="math">b &amp;lt; B</span> is a norm bound smaller than <span class="math">B</span> such that exists an integer <span class="math">k &amp;gt; 1</span> for which <span class="math">b^{k} = B</span>. Here <span class="math">b</span> and <span class="math">k</span> are parameters that can be chosen dynamically depending on the relation being proved. We describe an optimization for choosing <span class="math">b</span> and <span class="math">k</span> in Remark 5.1.</p>

    <p class="text-gray-300">Step 3: Folding. Finally, we reduce the relation <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^b)^{2k}</span> back to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> using a folding protocol <span class="math">\\Pi_{\\mathrm{fold}}</span> shown in Figure 3.</p>

    <p class="text-gray-300">By the composition theorems for reductions of knowledge (Theorem 2.1, Theorem 2.2), the composed protocol <span class="math">\\Pi_{\\mathsf{mfold}} \\coloneqq \\Pi_{\\mathsf{fold}} \\circ \\Pi_{\\mathsf{dec}} \\circ \\Pi_{\\mathsf{cm}}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{eval}}^B \\times \\mathcal{R}_{\\mathsf{cm}}^B</span> to <span class="math">\\mathcal{R}_{\\mathsf{eval}}^B</span> as desired. We state the result in Theorem 3.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.1. Let <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span> for some <span class="math">\\tau \\in \\mathbb{N}</span> where <span class="math">\\tau \\mid d</span> and <span class="math">1/q^\\tau</span> is in <span class="math">\\mathrm{negl}(\\lambda)</span>. Let <span class="math">\\mathcal{C}_{\\mathrm{small}} \\subseteq \\mathcal{R}_q</span> be a strong sampling set for which $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is in </span>\\mathrm{negl}(\\lambda)<span class="math">, and the expansion factor </span>T := \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}} \\leq c<span class="math"> (Definition 6) for some </span>c \\in \\mathbb{N}<span class="math">. Let </span>\\mathcal{C}<span class="math"> be the strong sampling set as in Eq. (31). Let </span>\\mathsf{pp} := (\\kappa, m, \\mathbf{A}, B &lt; q/2)<span class="math"> be public parameters such that </span>\\mathsf{MSIS}_{\\kappa, m, 8TB}^{\\infty, q}<span class="math"> is hard. Set </span>b, k<span class="math"> such that </span>2kc(b - 1) &lt; B<span class="math"> and </span>b^k = B<span class="math">. Let </span>\\Pi_{\\mathsf{cm}}, \\Pi_{\\mathsf{dec}}, \\Pi_{\\mathsf{fold}}<span class="math"> be the protocols specified in Figure 1, Figure 2 and Figure 3, respectively. Then the composed protocol </span>\\Pi_{\\mathsf{mfold}} := \\Pi_{\\mathsf{fold}} \\circ \\Pi_{\\mathsf{dec}} \\circ \\Pi_{\\mathsf{cm}}<span class="math"> is a public-coin reduction of knowledge from </span>\\mathcal{R}_{\\mathsf{eval}}^B \\times \\mathcal{R}_{\\mathsf{cm}}^B<span class="math"> to </span>\\mathcal{R}_{\\mathsf{eval}}^B$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The protocol is public-coin as <span class="math">\\Pi_{\\mathsf{cm}}</span> and <span class="math">\\Pi_{\\mathsf{dec}}</span> are non-interactive and <span class="math">\\Pi_{\\mathsf{fold}}</span> is public-coin. For the case where <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span>, the Theorem follows from Lemma 3.1, Lemma 3.3, Theorem 3.2 and the knowledge composition theorems (Theorem 2.1 and Theorem 2.2). The proof for the general case where <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span> naturally follows from the argument in Section 3.3.</p>

    <p class="text-gray-300">Setup and notation. Before describing the protocols <span class="math">\\Pi_{\\mathsf{cm}}, \\Pi_{\\mathsf{dec}}, \\Pi_{\\mathsf{fold}}</span>, let us recall the common setup. <span class="math">\\mathcal{R}_q</span> is the ring <span class="math">\\mathcal{R}_q \\coloneqq \\mathcal{R} / q\\mathcal{R}</span> where <span class="math">\\mathcal{R} \\coloneqq \\mathbb{Z}[X] / (X^d + 1)</span> and <span class="math">q</span> is a prime. Note that <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span> for some <span class="math">\\tau \\in \\mathbb{N}</span> where <span class="math">\\tau \\mid d</span>. The public parameter is <span class="math">\\mathsf{pp} \\coloneqq (\\kappa, m, B, \\mathbf{A})</span> where <span class="math">B &amp;lt; q/2</span>, <span class="math">m</span> is a power-of-two, and <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{\\kappa \\times m}</span> is the sampled MSIS matrix. For a vector <span class="math">\\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m</span>, we use <span class="math">\\hat{\\mathbf{f}} \\coloneqq (\\hat{\\mathbf{f}}_1, \\dots, \\hat{\\mathbf{f}}_\\tau) \\in \\mathcal{R}_q^{m \\times \\tau}</span> to denote the ring vector such that <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}}) \\coloneqq (\\mathsf{NTT}(\\hat{\\mathbf{f}}_1), \\dots, \\mathsf{NTT}(\\hat{\\mathbf{f}}_\\tau)) \\in \\mathbb{F}_{q^\\tau}^{m \\times d}</span> equals the coefficient embedding matrix of <span class="math">\\vec{\\mathbf{f}}</span>, that is, <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{f}}) \\in \\mathbb{Z}_q^{m \\times d}</span> as in Eq. (2).</p>

    <p class="text-gray-300">In what follows, for ease of exposition, we assume that the prime <span class="math">q</span> satisfies <span class="math">q \\equiv 1 \\mod 2d</span> so that <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span> and <span class="math">\\tau = 1</span>. In Section 3.3, we generalize to arbitrary prime modulus.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">By the parallel composition theorem (Theorem 2.2), in order to reduce from  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B\\times \\mathcal{R}_{\\mathrm{cm}}^B</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B\\times \\mathcal{R}_{\\mathrm{eval}}^B</span> , it suffices to reduce  <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span>  (Eq. (8)) to  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>  (Eq. (9)). We describe the protocol  <span class="math">\\Pi_{\\mathrm{cm}}</span>  in Figure 1.</p>

    <p class="text-gray-300">Input:  <span class="math">(\\mathbb{X};\\mathbb{W})\\coloneqq (\\mathsf{cm}\\in \\mathcal{R}_q^{\\kappa};\\vec{\\mathbf{f}}\\in \\mathcal{R}_q^m)</span></p>

    <p class="text-gray-300">Output:  <span class="math">(\\mathbb{X}_o;\\mathbb{W}_o)\\coloneqq ((0^{\\log m},\\hat{\\mathbf{v}}\\in \\mathcal{R}_q,\\mathsf{cm});\\vec{\\mathbf{f}})</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{X};\\mathbb{W}),\\mathsf{V}(\\mathsf{pp},\\mathbb{X})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}\\to \\mathsf{V}:\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  the evaluation  <span class="math">\\hat{\\mathbf{v}}\\coloneqq \\mathsf{mle}\\left<a href="0^{\\log m}">\\hat{\\mathbf{f}}\\right</a></span></li>

      <li><span class="math">\\mathsf{V}</span>  outputs  <span class="math">\\mathbb{X}_o\\coloneqq (0^{\\log m},\\hat{\\mathbf{v}},\\mathsf{cm})</span>  . P outputs  <span class="math">\\mathbb{W}_o\\coloneqq \\vec{\\mathbf{f}}</span></li>

    </ol>

    <p class="text-gray-300">Figure 1: The protocol  <span class="math">\\Pi_{\\mathbf{cm}}</span>  that reduces  <span class="math">\\mathcal{R}_{\\mathbf{cm}}^B</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> .</p>

    <p class="text-gray-300">Lemma 3.1.  <span class="math">\\Pi_{\\mathbf{cm}}</span>  is a reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathbf{cm}}^B</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>  for any  <span class="math">B \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Proof. Public reducibility: Given instance  <span class="math">\\mathbb{X} = \\mathsf{cm}</span>  and transcript  <span class="math">\\hat{\\mathbf{v}}</span> , one can output  <span class="math">\\mathbb{X}_o = ((0^{\\log m},\\hat{\\mathbf{v}},\\mathsf{cm}))</span> .</p>

    <p class="text-gray-300">Completeness: Given  <span class="math">(\\mathsf{pp},\\mathsf{cm};\\vec{\\mathbf{f}})\\in \\mathcal{R}_{\\mathsf{cm}}^B</span> , the honest prover can compute and send  <span class="math">\\hat{\\mathbf{v}} := \\overline{\\mathsf{mle}\\left<a href="0^{\\log m}">\\hat{\\mathbf{f}}\\right</a>}</span>  such that  <span class="math">((0^{\\log m},\\hat{\\mathbf{v}},\\mathsf{cm});\\vec{\\mathbf{f}})\\in \\mathcal{R}_{\\mathsf{eval}}^B</span> . The honest verifier will output instance  <span class="math">(0^{\\log m},\\hat{\\mathbf{v}},\\mathsf{cm})</span>  and the honest prover will output  <span class="math">\\vec{\\mathbf{f}}</span> .</p>

    <p class="text-gray-300">Knowledge soundness: By definition of  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>  (Eq. (9)), given any  <span class="math">((\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},\\mathsf{cm});\\vec{\\mathbf{f}})\\in \\mathcal{R}_{\\mathrm{eval}}^B</span> , we can extract witness  <span class="math">(\\mathsf{cm};\\vec{\\mathbf{f}})</span>  that is in the relation  <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> .</p>

    <p class="text-gray-300">Intuitively, the decomposition step splits the two witness vectors, each with a norm less than  <span class="math">B</span> , into  <span class="math">2k</span>  witness vectors with a much smaller norm  <span class="math">b</span> . (Typically,  <span class="math">b</span>  is only 2 or 4 in practice.) This allows them to be folded back later (in the folding step) into a vector with a norm less than  <span class="math">B</span> .</p>

    <p class="text-gray-300">By Theorem 2.2, it suffices to construct a protocol  <span class="math">\\Pi_{\\mathrm{dec}}^<em></span>  that reduces  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^b)^k</span> , and the reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B \\times \\mathcal{R}_{\\mathrm{eval}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^b)^{2k}</span>  is  <span class="math">\\Pi_{\\mathrm{dec}} := \\Pi_{\\mathrm{dec}}^</em> \\times \\Pi_{\\mathrm{dec}}^<em></span>  that runs two instances of  <span class="math">\\Pi_{\\mathrm{dec}}^</em></span>  in parallel.</p>

    <p class="text-gray-300">More generally, we construct a reduction of knowledge from a relation  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{hom}}^b)^k</span> . Let  <span class="math">\\mathcal{L}</span>  be an  <span class="math">\\mathcal{R}_q</span> -module homomorphism from  <span class="math">\\mathcal{R}_q^m</span>  to an  <span class="math">\\mathcal{R}_q</span> -module  <span class="math">\\mathcal{V}</span> . We treat  <span class="math">\\mathcal{L}</span>  as a part of the public parameter  <span class="math">\\mathfrak{pp} := (\\mathcal{R}_q, m, B &amp;lt; q/2, \\mathcal{L})</span> . Here  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span>  is a generalization of</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>  from (9) defined as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\text {h o m}} ^ {B} := \\left\\{\\left(\\mathfrak {p p}, \\mathbb {x} := \\left(\\vec {\\mathbf {r}} \\in \\mathcal {R} _ {q} ^ {\\log m}, \\hat {\\mathbf {v}} \\in \\mathcal {R} _ {q}, y \\in \\mathcal {Y}\\right); \\vec {\\mathbf {f}} \\in \\mathcal {R} _ {q} ^ {m}\\right): \\begin{array}{c} y = \\mathcal {L} (\\vec {\\mathbf {f}}) \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   B \\\\ \\wedge \\operatorname {m l e} [ \\hat {\\mathbf {f}} ] (\\vec {\\mathbf {r}}) = \\hat {\\mathbf {v}} \\end{array} \\right\\}, \\tag {10}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Clearly,  <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span>  from (9) is a special case of  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span>  where  <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}})\\coloneqq \\mathbf{A}\\vec{\\mathbf{f}}</span>  and  <span class="math">\\mathcal{V}\\coloneqq \\mathcal{R}_q^\\kappa</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a positive integer  <span class="math">B &amp;lt; q / 2</span> , choose  <span class="math">b, k</span>  such that  <span class="math">b^{k} = B</span> . For notational convenience, for an  <span class="math">m</span> -vector  <span class="math">\\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m</span>  where  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math"> , we use  </span>\\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})<span class="math">  to denote the algorithm that decomposes  </span>\\vec{\\mathbf{f}}<span class="math">  into an  </span>m \\times k<span class="math">  matrix  </span>\\vec{\\mathbf{F}} := (\\vec{\\mathbf{f}}_0, \\dots, \\vec{\\mathbf{f}}_{k-1}) \\in \\mathcal{R}_q^{m \\times k}<span class="math"> , such that the coefficients of each  </span>\\mathcal{R}_q<span class="math"> -element in  </span>\\vec{\\mathbf{F}}<span class="math">  has absolute value less than  </span>b$  and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\vec {\\mathbf {f}} = \\vec {\\mathbf {F}} \\cdot \\left[ 1, b, b ^ {2}, \\dots , b ^ {k - 1} \\right] ^ {\\top} = \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\vec {\\mathbf {f}} _ {i}. \\tag {11}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For example, for  <span class="math">k = 2</span>  and  <span class="math">m = 1</span> , assume that  <span class="math">b \\coloneqq \\sqrt{B}</span>  is an integer. Given a polynomial  <span class="math">f = a_0 + a_1X \\in \\mathcal{R}_q</span>  where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; B<span class="math"> , we decompose it to  </span>\\mathsf{split}_{b,k}(f) = (f_0, f_1) = (c_0 + c_1X, d_0 + d_1X)<span class="math"> , where  </span>c_i \\coloneqq a_i \\mod b<span class="math">  and  </span>d_i \\coloneqq \\lfloor a_i / b \\rfloor<span class="math">  for  </span>i \\in \\{0,1\\}<span class="math"> . Then  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; b<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; b<span class="math"> , and  </span>f = f_0 + bf_1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input:  <span class="math">\\mathbb{x} := (\\vec{\\mathbf{r}} \\in \\mathcal{R}_q^{\\log m}, \\hat{\\mathbf{v}} \\in \\mathcal{R}_q, y \\in \\mathcal{Y})</span>  and  <span class="math">\\mathbb{w} := \\vec{\\mathbf{f}} \\in \\mathcal{R}_q^m</span></p>

    <p class="text-gray-300">Output:  <span class="math">[\\mathbb{x}_i = (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i),\\mathbb{w}_i = \\vec{\\mathbf{f}}_i]_{i = 0}^{k - 1}</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{x};\\mathbb{w}),\\mathsf{V}(\\mathsf{pp},\\mathbb{x})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V}</span> : Let  <span class="math">\\vec{\\mathbf{F}} := (\\vec{\\mathbf{f}}_0, \\dots, \\vec{\\mathbf{f}}_{k-1}) := \\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})</span> .  <span class="math">\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  the values  <span class="math">[y_i, \\hat{\\mathbf{v}}_i]_{i=0}^{k-1}</span>  where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">y _ {i} := \\mathcal {L} (\\vec {\\mathbf {f}} _ {i}), \\quad \\hat {\\mathbf {v}} _ {i} := \\operatorname {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}})</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V checks that  <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot y_i \\stackrel{?}{=} y</span> , and  <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot \\hat{\\mathbf{v}}_i \\stackrel{?}{=} \\hat{\\mathbf{v}}</span> .</li>

      <li>V outputs  <span class="math">[\\mathbb{x}_i\\coloneqq (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i)]_{i = 0}^{k - 1}</span>  P outputs  <span class="math">[\\mathbb{w}_i\\coloneqq \\vec{\\mathbf{f}}_i]_{i = 0}^{k - 1}</span></li>

    </ol>

    <p class="text-gray-300">Figure 2: The protocol  <span class="math">\\Pi_{\\mathrm{dec}}^{*}</span>  that reduces  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{hom}}^b)^k</span> .</p>

    <p class="text-gray-300">With this notation in place, we describe the protocol  <span class="math">\\Pi_{\\mathrm{dec}}^{<em>}</span>  in Figure 2. Before proving that  <span class="math">\\Pi_{\\mathrm{dec}}^{</em>}</span>  is a reduction of knowledge, we state a useful lemma. Informally, it states that a linear combination of instance-witness pairs will be in the relation if every individual instance-witness pair is in the relation. It's important to note that the combiners  <span class="math">[\\rho_i]_{i=1}^{\\ell}</span>  can be arbitrary elements in  <span class="math">\\mathcal{R}_q</span> . This generalization extends beyond the decomposition case where the combiners  <span class="math">b_i</span>  are in  <span class="math">\\mathbb{Z}_q \\subseteq \\mathcal{R}_q</span> . Looking ahead, this generalization is useful later in the folding protocol (Figure 3).</p>

    <p class="text-gray-300">Lemma 3.2. Fix a power-of-two <span class="math">m \\in \\mathbb{N}</span>, let <span class="math">\\vec{\\mathbf{r}} \\in \\mathbb{Z}_q^{\\log m}</span> be a vector and let <span class="math">\\mathcal{L}: \\mathcal{R}_q^m \\to \\mathcal{V}</span> be an <span class="math">\\mathcal{R}_q</span>-module homomorphism. Fix <span class="math">\\ell \\in \\mathbb{N}</span>. For any <span class="math">[\\rho_i]_{i=1}^\\ell \\in \\mathcal{R}_q^\\ell</span> and <span class="math">[\\hat{\\mathbf{v}}_i, y_i; \\vec{\\mathbf{f}}_i]_{i=1}^\\ell</span> such that <span class="math">y_i = \\mathcal{L}(\\vec{\\mathbf{f}}_i)</span> and <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}">\\hat{\\mathbf{f}}_i\\right</a> = \\hat{\\mathbf{v}}_i</span> for all <span class="math">i \\in [\\ell]</span>. Set <span class="math">\\hat{\\mathbf{v}}_o, y_o, \\vec{\\mathbf{f}}_o</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {N T T} (\\hat {\\mathbf {v}} _ {o}) = \\sum_ {i = 1} ^ {\\ell} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\mathsf {N T T} (\\hat {\\mathbf {v}} _ {i})\\right), \\quad y _ {o} := \\sum_ {i = 1} ^ {\\ell} \\rho_ {i} \\cdot y _ {i}, \\quad \\vec {\\mathbf {f}} _ {o} := \\sum_ {i = 1} ^ {\\ell} \\rho_ {i} \\cdot \\vec {\\mathbf {f}} _ {i},</span></div>

    <p class="text-gray-300">where <span class="math">\\operatorname{RotSum}</span> is defined in Lemma 2.1. Then <span class="math">y_{o} = \\mathcal{L}(\\vec{\\mathbf{f}}_{o})</span> and <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}">\\hat{\\mathbf{f}}_o\\right</a> = \\hat{\\mathbf{v}}_o</span>.</p>

    <p class="text-gray-300">Proof. First,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} (\\vec {\\mathbf {f}} _ {o}) = \\mathcal {L} \\left(\\sum_ {i = 1} ^ {\\ell} \\rho_ {i} \\cdot \\vec {\\mathbf {f}} _ {i}\\right) = \\sum_ {i = 1} ^ {\\ell} \\rho_ {i} \\cdot \\mathcal {L} (\\vec {\\mathbf {f}} _ {i}) = \\sum_ {i = 1} ^ {\\ell} \\rho_ {i} \\cdot y _ {i} = y _ {o}</span></div>

    <p class="text-gray-300">where the 2nd equality holds by the homomorphic property of <span class="math">\\mathcal{L}</span>.</p>

    <p class="text-gray-300">For ease of exposition, we define <span class="math">\\bar{\\mathbf{v}}_o,\\bar{\\mathbf{v}}_1,\\ldots ,\\bar{\\mathbf{v}}_\\ell \\in \\mathcal{R}_q</span> as the values such that <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{v}}_o) = \\mathsf{Coef}(\\bar{\\mathbf{v}}_o)</span> and <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{v}}_i) = \\mathsf{Coef}(\\bar{\\mathbf{v}}_i)</span> for all <span class="math">i\\in [\\ell ]</span>. We have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {C o e f} \\left(\\bar {\\mathbf {v}} _ {o}\\right) = \\operatorname {N T T} \\left(\\hat {\\mathbf {v}} _ {o}\\right) = \\sum_ {i = 1} ^ {\\ell} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\operatorname {N T T} \\left(\\hat {\\mathbf {v}} _ {i}\\right)\\right) \\\\ = \\sum_ {i = 1} ^ {\\ell} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\operatorname {C o e f} \\left(\\bar {\\mathbf {v}} _ {i}\\right)\\right) = \\sum_ {i = 1} ^ {\\ell} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\left\\langle \\operatorname {C o e f} \\left(\\vec {\\mathbf {f}} _ {i}\\right), \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle\\right) \\\\ = \\sum_ {i = 1} ^ {\\ell} \\left\\langle \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\operatorname {C o e f} \\left(\\vec {\\mathbf {f}} _ {i}\\right)\\right), \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle = \\sum_ {i = 1} ^ {\\ell} \\left\\langle \\operatorname {C o e f} \\left(\\rho_ {i} \\cdot \\vec {\\mathbf {f}} _ {i}\\right), \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle \\\\ = \\left\\langle \\operatorname {C o e f} \\left(\\sum_ {i = 1} ^ {\\ell} \\rho_ {i} \\cdot \\vec {\\mathbf {f}} _ {i}\\right), \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle = \\left\\langle \\operatorname {C o e f} (\\vec {\\mathbf {f}} _ {o}), \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle , \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where the 4th equality holds because</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o e f} \\left(\\bar {\\mathbf {v}} _ {i}\\right) = \\operatorname {N T T} \\left(\\hat {\\mathbf {v}} _ {i}\\right) = \\operatorname {m l e} \\left[ \\operatorname {C o e f} \\left(\\vec {\\mathbf {f}} _ {i}\\right) \\right] [ \\vec {\\mathbf {r}} ] = \\left\\langle \\operatorname {C o e f} \\left(\\vec {\\mathbf {f}} _ {i}\\right), \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle</span></div>

    <p class="text-gray-300">by Lemma A.1 and the facts that <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}">\\hat{\\mathbf{f}}_i\\right</a> = \\hat{\\mathbf{v}}_i</span>, <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}}_i) = \\mathsf{Coef}(\\vec{\\mathbf{f}}_i)</span> and <span class="math">\\mathsf{NTT}(\\vec{\\mathbf{r}}) = (\\vec{\\mathbf{r}},\\dots ,\\vec{\\mathbf{r}})</span>. The 5th equality holds by rearranging the terms and by the property of inner products; the 6th equality holds because <span class="math">\\operatorname{RotSum}(\\mathbf{a},\\operatorname{Coef}(\\mathbf{b})) = \\operatorname{Coef}(\\mathbf{a}\\cdot \\mathbf{b})</span> for any <span class="math">\\mathbf{a},\\mathbf{b}\\in \\mathcal{R}_q</span> (2nd claim in Lemma 2.1); the 7th equality is by additivity of inner products and coefficient embedding. Therefore, by Lemma A.1, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\mathbf {v}} _ {o} = \\mathsf {N T T} ^ {- 1} (\\mathsf {C o e f} (\\bar {\\mathbf {v}} _ {o})) = \\mathsf {N T T} ^ {- 1} \\left(\\left\\langle \\mathsf {C o e f} (\\vec {\\mathbf {f}} _ {o}), \\mathsf {t e n s o r} (\\vec {\\mathbf {r}}) \\right\\rangle\\right) = \\mathsf {m l e} \\left[ \\hat {\\mathbf {f}} _ {o} \\right] (\\vec {\\mathbf {r}})</span></div>

    <p class="text-gray-300">as required.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">Remark 3.1 (Supporting general  <span class="math">\\vec{\\mathbf{r}}</span> .) Lemma 3.2 requires  <span class="math">\\vec{\\mathbf{r}}</span>  to be in  <span class="math">\\mathbb{Z}_q^{\\log m}</span> . However, with a minor modification, the proof naturally extends to the case where  <span class="math">\\vec{\\mathbf{r}}</span>  is in  <span class="math">\\mathcal{C}^{\\log m}</span>  where  <span class="math">\\mathcal{C}</span>  is defined as in Eq. (31). This is useful in the folding protocol (Figure 3) to support small modulus  <span class="math">q</span>  while preserving negligible sumcheck soundness error. We defer the details to Section 3.3.</p>

    <p class="text-gray-300">Next we show that  <span class="math">\\Pi_{\\mathrm{dec}}^{*}</span>  is a reduction of knowledge.</p>

    <p class="text-gray-300">Lemma 3.3. Fix  <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span> . For any  <span class="math">B &amp;lt; q/2</span>  and any  <span class="math">b, k</span>  such that  <span class="math">b^k = B</span> ,  <span class="math">\\Pi_{\\mathrm{dec}}^*</span>  is a reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{hom}}^b)^k</span> .</p>

    <p class="text-gray-300">The proof follows from Lemma 3.4 and Lemma 3.5. Again, we emphasize that the proof naturally extends to the case where  <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^r}^{d/r}</span> . More details are deferred to Section 3.3.</p>

    <p class="text-gray-300">Lemma 3.4.  <span class="math">\\Pi_{\\mathrm{dec}}^{*}</span>  satisfies public reducibility and completeness.</p>

    <p class="text-gray-300">Proof. Public reducibility: Given instance  <span class="math">\\mathbb{X} = (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y)</span>  and transcript  <span class="math">[y_i,\\hat{\\mathbf{v}}_i]_{i = 0}^{k - 1}</span> , output  <span class="math">[\\mathbb{X}_i\\coloneqq (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i)]_{i = 0}^{k - 1}</span>  if the verifier checks pass and  <span class="math">\\perp</span>  otherwise.</p>

    <p class="text-gray-300">Completeness: Let  <span class="math">(\\mathbb{X} = (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y);\\mathbb{W}\\coloneqq \\vec{\\mathbf{f}})\\gets \\mathcal{A}(\\mathsf{pp})</span>  denote adversary  <span class="math">\\mathcal{A}</span> 's chosen input for  <span class="math">\\mathcal{R}_1\\coloneqq \\mathcal{R}_{\\mathrm{hom}}^B</span>  where  <span class="math">\\mathsf{pp}\\coloneqq (\\mathcal{R}_q,m,B &amp;lt; q / 2,\\mathcal{L})\\gets \\mathsf{Setup}(1^\\lambda)</span>  is the public parameter. WLOG we assume that  <span class="math">(\\mathsf{pp},\\mathbb{X};\\mathbb{W})</span>  is in  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span> . The protocol execution  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{X},\\mathbb{W}),\\mathsf{V}(\\mathsf{pp},\\mathbb{X})\\rangle</span>  proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>  computes  <span class="math">\\vec{\\mathbf{f}} := (\\vec{\\mathbf{f}}_0, \\dots, \\vec{\\mathbf{f}}_{k-1}) \\gets \\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})</span> , and sends  <span class="math">y_i = \\mathcal{L}(\\vec{\\mathbf{f}}_i)</span> ,  <span class="math">\\hat{\\mathbf{v}}_i = \\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}">\\hat{\\mathbf{f}}_i\\right</a></span>  for every  <span class="math">i \\in [0, k)</span> .</li>

      <li><span class="math">\\mathsf{V}</span>  checks that  <span class="math">y \\stackrel{?}{=} \\sum_{i=0}^{k-1} b^i \\cdot y_i</span>  and  <span class="math">\\hat{\\mathbf{v}} \\stackrel{?}{=} \\sum_{i=0}^{k-1} b^i \\cdot \\hat{\\mathbf{v}}_i</span> . It outputs  <span class="math">\\perp</span>  and halts if the check fails.</li>

      <li><span class="math">\\mathsf{P}</span>  outputs  <span class="math">[\\vec{\\mathbf{f}}_i]_{i = 0}^{k - 1}</span> .  <span class="math">\\mathsf{V}</span>  accepts and outputs  <span class="math">[\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i]_{i = 0}^{k - 1}</span> .</li>

    </ol>

    <p class="text-gray-300">We show that  <span class="math">\\mathsf{V}</span>  accepts in the honest execution. First,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot y _ {i} = \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\mathcal {L} (\\vec {\\mathbf {f}} _ {i}) = \\mathcal {L} \\left(\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\vec {\\mathbf {f}} _ {i}\\right) = y</span></div>

    <p class="text-gray-300">where the 1st equality is by definition of  <span class="math">y_{i}</span> ; the 2nd equality follows from the properties of the  <span class="math">\\mathcal{R}_q</span> -module homomorphism  <span class="math">\\mathcal{L}</span> ; the last equality holds because  <span class="math">\\vec{\\mathbf{f}} = \\sum_{i=0}^{k-1} b^i \\cdot \\vec{\\mathbf{f}}_i</span>  as in Eq. (11) and  <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}}) = y</span>  by the assumption that  <span class="math">(\\mathsf{pp} := (\\mathcal{R}_q, m, B &amp;lt; q/2, \\mathcal{L}), \\mathbb{X}; \\mathbb{W}) \\in \\mathcal{R}_{\\mathrm{hom}}^B</span> .</p>

    <p class="text-gray-300">Similarly, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\hat {\\mathbf {v}} _ {i} = \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\mathsf {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}}) = \\mathsf {m l e} \\left[ \\hat {\\mathbf {f}} \\right] (\\vec {\\mathbf {r}}) = \\hat {\\mathbf {v}}.</span></div>

    <p class="text-gray-300">The 1st equality is by definition of <span class="math">\\hat{\\mathbf{v}}_i</span>; the 2nd equality holds because (i) the map <span class="math">g_{\\vec{\\mathbf{r}}}(f) := f(\\vec{\\mathbf{r}})</span> satisfies that <span class="math">g_{\\vec{\\mathbf{r}}}(a \\cdot f_1 + b \\cdot f_2) = a \\cdot g_{\\vec{\\mathbf{r}}}(f_1) + b \\cdot g_{\\vec{\\mathbf{r}}}(f_2)</span> for any multilinear polynomials <span class="math">f_1, f_2</span> and <span class="math">a, b \\in \\mathbb{Z}_q</span>; and (ii) <span class="math">\\hat{\\mathbf{f}} = \\sum_{i=0}^{k-1} b^i \\cdot \\hat{\\mathbf{f}}_i</span> given that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {N T T} (\\hat {\\mathbf {f}}) = \\mathsf {C o e f} (\\vec {\\mathbf {f}}) = \\mathsf {C o e f} \\left(\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\vec {\\mathbf {f}} _ {i}\\right) = \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\mathsf {C o e f} \\left(\\vec {\\mathbf {f}} _ {i}\\right) = \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\mathsf {N T T} (\\hat {\\mathbf {f}} _ {i}) = \\mathsf {N T T} \\left(\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\hat {\\mathbf {f}} _ {i}\\right).</span></div>

    <p class="text-gray-300">The last equality holds because <span class="math">(\\mathsf{pp},\\mathsf{z};\\mathsf{w})\\in \\mathcal{R}_{\\mathsf{hom}}^B</span> by assumption. Thus, <span class="math">\\mathsf{V}</span> accepts in the honest execution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we show that <span class="math">(\\mathsf{pp},[(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i);\\vec{\\mathbf{f}}_i]_{i = 0}^{k - 1})</span> is in <span class="math">\\mathcal{R}_2\\coloneqq (\\mathcal{R}_{\\mathsf{hom}}^b)^k</span>. For every <span class="math">i\\in [0,k)</span>, recall that <span class="math">y_{i} = \\mathcal{L}(\\vec{\\mathbf{f}}_{i})</span> and <span class="math">\\hat{\\mathbf{v}}_i = \\mathsf{mle}\\left[\\hat{\\mathbf{f}}_i\\right]</span> ( <span class="math">\\vec{\\mathbf{r}}</span> ). Moreover, by definition of <span class="math">\\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})</span> (Eq. (11)), we have that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &lt; b<span class="math">. Therefore, </span>(\\mathsf{pp},(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i);\\vec{\\mathbf{f}}_i)\\in \\mathcal{R}_{\\mathsf{hom}}^b$ and completeness holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 3.5. <span class="math">\\Pi_{\\mathrm{dec}}^{*}</span> satisfies knowledge soundness.</p>

    <p class="text-gray-300">Proof. Let <span class="math">(\\mathbb{Z} := (\\vec{\\mathbf{r}}, \\hat{\\mathbf{v}}, y); \\text{state}) \\gets \\mathcal{A}(\\mathsf{pp})</span> denote adversary <span class="math">\\mathcal{A}</span>'s chosen input instance for <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{hom}}^B</span>, where <span class="math">\\mathsf{pp} := (\\mathcal{R}_q, m, B &amp;lt; q/2, \\mathcal{L}) \\gets \\mathsf{Setup}(1^\\lambda)</span> is the public parameter. The extractor <span class="math">\\mathsf{Ext}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the protocol <span class="math">\\langle \\mathsf{P}^{<em>}(\\mathsf{pp},\\mathsf{z},\\mathsf{state}),\\mathsf{V}(\\mathsf{pp},\\mathsf{z})\\rangle</span> where <span class="math">\\mathsf{P}^</em></span> is the malicious prover.</li>

      <li>Output <span class="math">\\perp</span> if <span class="math">\\mathsf{V}</span> rejects. Otherwise let <span class="math">(\\mathsf{z}_o,\\mathsf{w}_o)\\coloneqq [(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i);\\vec{\\mathbf{f}}_i]_{i = 0}^{k - 1}</span> be the protocol output. (Note that <span class="math">\\vec{\\mathbf{r}}</span> is the same with that in the input instance <span class="math">\\mathsf{z}</span> to pass the verification check.) The extractor outputs witness</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\omega := \\vec {\\mathbf {f}} := \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\vec {\\mathbf {f}} _ {i}. \\tag {12}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we show that if <span class="math">\\mathsf{V}</span> accepts and the output satisfies that <span class="math">(\\mathsf{pp},\\mathsf{z}_o,\\mathsf{w}_o)</span> is in <span class="math">\\mathcal{R}_2\\coloneqq (\\mathcal{R}_{\\mathsf{hom}}^b)^k</span>, then the extracted witness <span class="math">\\vec{\\mathbf{f}}</span> satisfies that <span class="math">(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y;\\vec{\\mathbf{f}})\\in \\mathcal{R}_1\\coloneqq \\mathcal{R}_{\\mathsf{hom}}^B</span>. Since <span class="math">\\mathsf{V}</span> accepts, we have that <span class="math">y = \\sum_{i = 0}^{2k - 1}b^{i}\\cdot y_{i}</span> and <span class="math">\\hat{\\mathbf{v}} = \\sum_{i = 0}^{2k - 1}b^{i}\\cdot \\hat{\\mathbf{v}}_{i}</span>. Recall that <span class="math">y_{i} = \\mathcal{L}(\\vec{\\mathbf{f}}_{i})</span> and <span class="math">\\hat{\\mathbf{v}}_i = \\mathsf{mle}\\left[\\hat{\\mathbf{f}}_i\\right]</span> ( <span class="math">\\vec{\\mathbf{r}}</span> ) for all <span class="math">i\\in [0,k)</span> by assumption, thus by Lemma 3.2, we have that <span class="math">y = \\mathcal{L}(\\vec{\\mathbf{f}})</span> and <span class="math">\\hat{\\mathbf{v}} = \\mathsf{mle}\\left[\\hat{\\mathbf{f}}\\right]</span> ( <span class="math">\\vec{\\mathbf{r}}</span> ). Moreover, note that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &lt; b<span class="math"> for all </span>i\\in [0,k)<span class="math"> because </span>(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i;\\vec{\\mathbf{f}}_i)<span class="math"> is in </span>\\mathcal{R}_{\\mathsf{hom}}^b<span class="math"> by assumption. Since </span>b^{k} = B &lt; q / 2<span class="math"> and </span>\\vec{\\mathbf{f}} = \\sum_{i = 0}^{k - 1}b^{i}\\cdot \\vec{\\mathbf{f}}_{i}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\vec {\\mathbf {f}} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {f}} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot (b - 1) &lt;   b ^ {k} = B.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In summary, <span class="math">y = \\mathcal{L}(\\vec{\\mathbf{f}})</span>, <span class="math">\\hat{\\mathbf{v}} = \\mathsf{mle}\\left[\\hat{\\mathbf{f}}\\right]</span> ( <span class="math">\\vec{\\mathbf{r}}</span> ) and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math"> and thus </span>(\\vec{\\mathbf{r}}, \\hat{\\mathbf{v}}, y; \\vec{\\mathbf{f}}) \\in \\mathcal{R}_{\\mathsf{hom}}^{B}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3.2.3 Folding: The reduction from <span class="math">(\\mathcal{R}_{\\mathsf{eval}}^{b})^{2k}</span> to <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now describe the core protocol <span class="math">\\Pi_{\\mathsf{fold}}</span> that folds <span class="math">2k</span> instance-witness pairs of <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{b}</span> from (9) into a single instance-witness pair in <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}</span>. More generally, the protocol is a reduction of knowledge from <span class="math">(\\mathcal{R}_{\\mathsf{hom}}^{b})^{2k}</span> from (10) to <span class="math">\\mathcal{R}_{\\mathsf{hom}}^{B}</span> with a further restriction that the public parameter, the <em>sampled</em> homomorphism <span class="math">\\mathcal{L}</span>, is relaxed binding as in Section 2.3. This relaxed binding property, defined for bound <span class="math">2B</span> and the challenge space <span class="math">\\mathcal{C}_{\\mathsf{small}}</span>, ensures the hardness of finding two distinct weak openings for a commitment <span class="math">\\mathsf{cm}</span>. Recall that a <span class="math">2B</span>-weak opening <span class="math">(\\rho\\in\\mathcal{C}_{\\mathsf{small}}-\\mathcal{C}_{\\mathsf{small}},\\vec{\\mathbf{x}})</span> of <span class="math">\\mathsf{cm}</span> satisfies that <span class="math">\\rho\\cdot\\mathsf{cm}=\\mathbf{A}\\vec{\\mathbf{x}}\\bmod q</span> with the norm constraint $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<2B<span class="math">. Thus, </span>\\mathcal{R}_{\\mathsf{eval}}^{B}<span class="math"> from (9) is a special case of </span>\\mathcal{R}_{\\mathsf{hom}}^{B}<span class="math"> where the sampled homomorphism </span>\\mathcal{L}<span class="math"> is given by </span>\\mathcal{L}(\\vec{\\mathbf{f}}):=\\mathbf{A}\\vec{\\mathbf{f}}<span class="math">, and the </span>2B<span class="math">-relaxed binding property follows from the hardness of </span>\\mathsf{MSIS}^{\\infty,q}_{\\kappa,m,8TB}<span class="math"> where </span>T=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}<span class="math"> is the expansion factor of </span>\\mathcal{C}_{\\mathsf{small}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our protocol folds the <span class="math">2k</span> witness vectors (with norm less than <span class="math">b</span>) into a witness vector of norm less than <span class="math">B</span> (where <span class="math">b&lt;B&lt;q/2</span>), using <em>small</em> random scalars <span class="math">[\\rho_{i}]_{i=1}^{2k}</span> sampled from a strong sampling set <span class="math">\\mathcal{C}_{\\mathsf{small}}\\subseteq\\mathcal{R}_{q}</span>. Additionally and crucially, <span class="math">\\Pi_{\\mathsf{fold}}</span> runs a sum-check protocol to enable extractions of the <span class="math">2k</span> witness vectors with small norms. The sum-check is for a polynomial <span class="math">g(\\vec{\\mathbf{x}}):=\\sum_{i=1}^{2k}(\\alpha_{i}g_{1,i}(\\vec{\\mathbf{x}})+\\mu_{i}g_{2,i}(\\vec{\\mathbf{x}}))</span> with random scalars <span class="math">[\\alpha_{i},\\mu_{i}]_{i=1}^{2k}</span>. Informally, we can understand it as a batch of <span class="math">4k</span> separate sum-checks for polynomials <span class="math">[g_{1,i},g_{2,i}]_{i=1}^{2k}</span>, respectively. The sum-check for <span class="math">g_{1,i}</span> (defined in Eq. (15)) is used to verify that the evaluation statement <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{i}">\\hat{\\mathbf{f}}_{i}\\right</a>=\\hat{\\mathbf{v}}_{i}</span> holds for all <span class="math">i\\in[2k]</span>. For every <span class="math">i\\in[2k]</span>, the sum-check for <span class="math">g_{2,i}</span> (defined in Eq. (16)) is used to verify that</p>

    <p class="text-gray-300"><span class="math">\\prod_{j=-(b-1)}^{b-1}\\left(\\mathsf{mle}\\left<a href="\\vec{\\mathbf{x}}">\\hat{\\mathbf{f}}_{i}\\right</a>-j\\right)=0\\quad\\text{for all }\\vec{\\mathbf{x}}\\in\\{0,1\\}^{\\log m}</span></p>

    <p class="text-gray-300">This is the same as the Hadamard product check (the norm bound check)</p>

    <p class="text-gray-300"><span class="math">\\hat{\\mathbf{f}}_{i}\\circ\\left[\\bigcirc_{j=1}^{b-1}(\\hat{\\mathbf{f}}_{i}-\\hat{j})\\circ(\\hat{\\mathbf{f}}_{i}+\\hat{j})\\right]=\\hat{0},</span></p>

    <p class="text-gray-300">in the relation <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{b}</span> from (8).</p>

    <p class="text-gray-300">We describe the protocol <span class="math">\\Pi_{\\mathsf{fold}}</span> in Figure 3. We now see why the relation <span class="math">\\mathcal{R}_{\\mathsf{cm}}^{B}</span> from (8) had to be expanded to the related <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}</span> from (9). Protocol <span class="math">\\Pi_{\\mathsf{fold}}</span> reduces the claimed properties about the <span class="math">2k</span> input instances to verifying that <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{o}">\\hat{\\mathbf{f}}_{o}\\right</a>=\\hat{\\mathbf{v}}_{o}</span>, where <span class="math">(\\vec{\\mathbf{r}}_{o},\\hat{\\mathbf{v}}_{o})</span> is part of the output folded instance. Adding this evaluation check to the relation <span class="math">\\mathcal{R}_{\\mathsf{eval}}^{B}</span> forces the prover to output a folded statement that satisfies this equality. The verifier cannot check this relation itself as part of <span class="math">\\Pi_{\\mathsf{fold}}</span> because it does not have access to <span class="math">\\vec{\\mathbf{f}}_{o}</span>.</p>

    <p class="text-gray-300">The following lemma shows that the protocol <span class="math">\\Pi_{\\mathsf{fold}}</span> in Figure 3 is a reduction of knowledge from <span class="math">(\\mathcal{R}_{\\mathsf{hom}}^{b})^{2k}</span> to <span class="math">\\mathcal{R}_{\\mathsf{hom}}^{B}</span> assuming that <span class="math">\\mathcal{L}</span> is a relaxed binding.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters: Strong sampling sets  <span class="math">\\mathcal{C},\\mathcal{C}_{\\mathrm{small}}\\subseteq \\mathcal{R}_q</span>  where  <span class="math">\\mathcal{C}</span>  is defined as in Eq. (31) and  <span class="math">\\mathcal{C}_{\\mathrm{small}}</span>  has expansion factor  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}}\\leq c\\in \\mathbb{N}$  as in (6).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input:  <span class="math">[\\mathbb{X}_i\\coloneqq (\\vec{\\mathbf{r}}_i,\\hat{\\mathbf{v}}_i,y_i)\\in \\mathcal{R}_q^{\\log m}\\times \\mathcal{R}_q\\times \\mathcal{Y}]_{i = 1}^{2k}</span>  and  <span class="math">[\\mathbb{W}_i\\coloneqq \\vec{\\mathbf{f}}_i\\in \\mathcal{R}_q^m ]_{i = 1}^{2k}</span></p>

    <p class="text-gray-300">Output:  <span class="math">\\mathbb{X}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o)</span> <span class="math">\\mathbb{W}_o\\coloneqq \\vec{\\mathbf{f}}_o</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{X};\\mathbb{W}),\\mathsf{V}(\\mathsf{pp},\\mathbb{X})\\rangle</span>  where  <span class="math">\\mathbb{X} = [\\mathbb{X}_i]_{i = 1}^{2k}</span>  and  <span class="math">\\mathbb{W} = [\\mathbb{W}_i]_{i = 1}^{2k}</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}:\\mathsf{V}</span>  sends  <span class="math">\\mathsf{P}</span>  challenges  <span class="math">[\\alpha_i,\\mu_i]_{i = 1}^{2k}\\stackrel {\\circ}{\\leftarrow}(\\mathcal{C}\\times \\mathcal{C})^{2k}</span>  and  <span class="math">\\vec{\\beta}\\stackrel {\\circ}{\\leftarrow}\\mathcal{C}^{\\log m}</span></li>

      <li><span class="math">\\mathsf{V}\\leftrightarrow \\mathsf{P}:\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  run a sum-check protocol for the claim</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} g (\\vec {\\mathbf {b}}) = \\sum_ {i = 1} ^ {2 k} \\alpha_ {i} \\hat {\\mathbf {v}} _ {i}, \\tag {13}</span></div>

    <p class="text-gray-300">where the polynomial  <span class="math">g(\\vec{\\mathbf{x}})\\in \\mathcal{R}_q^{\\leq 2b}[X_1,\\ldots ,X_{\\log m}]</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">g (\\vec {\\mathbf {x}}) := g _ {\\text {e v a l}} (\\vec {\\mathbf {x}}) + g _ {\\text {n o r m}} (\\vec {\\mathbf {x}}), \\tag {14}</span></div>

    <div class="my-4 text-center"><span class="math-block">g _ {\\text {e v a l}} (\\vec {\\mathbf {x}}) := \\sum_ {i = 1} ^ {2 k} \\alpha_ {i} \\cdot g _ {1, i} (\\vec {\\mathbf {x}}) \\quad \\text {w h e r e} \\quad g _ {1, i} (\\vec {\\mathbf {x}}) := e q (\\vec {\\mathbf {r}} _ {i}, \\vec {\\mathbf {x}}) \\cdot \\operatorname {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {x}}), \\tag {15}</span></div>

    <div class="my-4 text-center"><span class="math-block">g _ {\\text {n o r m}} (\\vec {\\mathbf {x}}) := \\sum_ {i = 1} ^ {2 k} \\mu_ {i} \\cdot g _ {2, i} (\\vec {\\mathbf {x}}) \\quad \\text {w h e r e} \\quad g _ {2, i} (\\vec {\\mathbf {x}}) := e q (\\vec {\\beta}, \\vec {\\mathbf {x}}) \\cdot \\prod_ {j = - (b - 1)} ^ {b - 1} \\left(\\operatorname {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {x}}) - j\\right) \\tag {16}</span></div>

    <p class="text-gray-300">The sumcheck protocol reduces checking (13) to checking the evaluation claim  <span class="math">g(\\vec{\\mathbf{r}}_o) \\stackrel{?}{=} s</span> , where  <span class="math">s \\in \\mathcal{R}_q</span>  and  <span class="math">\\vec{\\mathbf{r}}_o \\stackrel{\\circ}{\\leftarrow} \\mathcal{C}^{\\log m}</span>  is a sum-check challenge sampled by  <span class="math">V</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}\\to \\mathsf{V}:\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  values  <span class="math">\\left<a href="\\vec{\\mathbf{r}}_{o}">\\theta_{i}\\coloneqq \\mathsf{mle}\\left[\\hat{\\mathbf{f}}_{i}\\right</a>\\right]_{i = 1}^{2k}</span></li>

      <li>V computes  <span class="math">[\\mathbf{e}_i\\coloneqq eq(\\vec{\\mathbf{r}}_i,\\vec{\\mathbf{r}}_o)]_{i = 1}^{2k}</span>  and  <span class="math">\\mathbf{e}^{\\star}\\coloneqq eq(\\vec{\\beta},\\vec{\\mathbf{r}}_o)</span>  and checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">s \\stackrel {?} {=} \\sum_ {i = 1} ^ {2 k} \\left[ \\alpha_ {i} \\mathbf {e} _ {i} \\theta_ {i} + \\mu_ {i} \\mathbf {e} ^ {\\star} \\cdot \\prod_ {j = 1 - b} ^ {b - 1} (\\theta_ {i} - j) \\right].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}:\\mathsf{V}</span>  sends  <span class="math">\\mathsf{P}</span>  random challenge  <span class="math">[\\rho_i]_{i = 1}^{2k}\\stackrel {\\circ}{\\leftarrow}\\mathcal{C}_{\\mathrm{small}}^{2k}</span> .</li>

      <li>V outputs  <span class="math">\\mathbb{X}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o)</span>  where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {N T T} \\left(\\hat {\\mathbf {v}} _ {o}\\right) = \\sum_ {i = 1} ^ {2 k} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\operatorname {N T T} \\left(\\theta_ {i}\\right)\\right), \\quad y _ {o} := \\sum_ {i = 1} ^ {2 k} \\rho_ {i} y _ {i}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P further outputs  <span class="math">\\mathbb{W}_o\\coloneqq \\vec{\\mathbf{f}}_o = \\sum_{i = 1}^{2k}\\rho_i\\cdot \\vec{\\mathbf{f}}_i</span></li>

    </ol>

    <p class="text-gray-300">Figure 3: The protocol \\Pi_{\\text{fold}}  that reduces (\\mathcal{R}_{\\text{hom}}^b)^{2k}  to \\mathcal{R}_{\\text{hom}}^B .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3.2. Let <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span> for some <span class="math">\\tau \\in \\mathbb{N}</span> where <span class="math">\\tau \\mid d</span> and <span class="math">1/q^\\tau</span> is in <span class="math">\\mathrm{negl}(\\lambda)</span>. Let <span class="math">\\mathcal{C}_{\\mathrm{small}} \\subseteq \\mathcal{R}_q</span> be a strong sampling set for which $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is in </span>\\mathrm{negl}(\\lambda)<span class="math">, and the expansion factor </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}} \\leq c<span class="math"> (Definition 6) for some </span>c \\in \\mathbb{N}<span class="math">. Let </span>\\mathcal{C}<span class="math"> be the strong sampling set as in Eq. (31). Let </span>\\mathsf{pp} := (m, B &lt; q/2, \\mathcal{L})<span class="math"> be the public parameters where the sampled </span>\\mathcal{R}_q<span class="math">-module homomorphism </span>\\mathcal{L}: \\mathcal{R}_q^m \\to \\mathcal{Y}<span class="math"> is a </span>2B<span class="math">-relaxed binding (Section 2.3) for challenge space </span>\\mathcal{C}_{\\mathrm{small}}<span class="math">. For any </span>b, k<span class="math"> where </span>2kc(b-1) &lt; B<span class="math">, the protocol </span>\\Pi_{\\mathrm{fold}}<span class="math"> is a reduction of knowledge from </span>(\\mathcal{R}_{\\mathrm{hom}}^b)^{2k}<span class="math"> to </span>\\mathcal{R}_{\\mathrm{hom}}^B$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 3.2. <span class="math">\\Pi_{\\mathrm{fold}}</span> (Figure 3) uses two different sampling sets <span class="math">\\mathcal{C}</span>, <span class="math">\\mathcal{C}_{\\mathrm{small}}</span> where <span class="math">\\mathcal{C}</span> is for sumcheck and <span class="math">\\mathcal{C}_{\\mathrm{small}}</span> is for folding. We set <span class="math">\\mathcal{C}</span> as in Eq. (31) for two reasons:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sumcheck efficiency: By Eq. (31), for every <span class="math">\\mathbf{a}_i \\in \\mathcal{C}</span>, <span class="math">\\mathsf{NTT}(\\mathbf{a}_i) = (i, \\ldots, i)</span> where <span class="math">i \\in \\mathbb{F}_{q^\\tau}</span> is the embedding of <span class="math">\\mathbf{a}_i</span> in <span class="math">\\mathbb{F}_{q^\\tau}</span>. So <span class="math">\\mathcal{C}</span> lets us treat the sumcheck over <span class="math">\\mathcal{R}_q</span> as <span class="math">d / \\tau</span> parallel sumchecks over <span class="math">\\mathbb{F}_{q^\\tau}</span> that share the same sumcheck challenge vector over <span class="math">\\mathbb{F}_{q^\\tau}^{\\log m}</span>, and no NTT transformation is needed when running the sumcheck. Note that the removal of the NTT transform also improves the circuit size of the sumcheck verifier.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: As discussed in Remark 3.1 and Section 3.3, Lemma 3.2 still holds when <span class="math">\\mathcal{C}</span> is set as in Eq. (31). This is essential for the folding protocol to support small modulus <span class="math">q</span>.</li>

    </ol>

    <p class="text-gray-300">For the special case <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span>, the proof follows from Lemma 3.6 and Theorem 3.3 below. As discussed in Section 3.3, with a minor modification to the protocol, the proof naturally extends to the case where <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span>.</p>

    <p class="text-gray-300">Lemma 3.6. <span class="math">\\Pi_{\\mathrm{fold}}</span> satisfies public reducibility and completeness.</p>

    <p class="text-gray-300">Proof. Public reducibility: Given input instances <span class="math">[\\vec{\\mathbf{r}}_i, \\hat{\\mathbf{v}}_i, y_i]_{i=1}^{2k}</span> and the transcript that includes the challenge <span class="math">\\vec{\\mathbf{r}}_o</span>, evaluations <span class="math">[\\theta_i]_{i=1}^{2k}</span> and folding challenges <span class="math">[\\rho_i]_{i=1}^{2k}</span>. The algorithm outputs <span class="math">\\mathbf{z}_o := (\\vec{\\mathbf{r}}_o, \\hat{\\mathbf{v}}_o, y_o := \\sum_{i=1}^{2k} \\rho_i \\cdot y_i)</span> where <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{v}}_o) = \\sum_{i=1}^{2k} \\mathsf{RotSum}(\\rho_i, \\mathsf{NTT}(\\theta_i))</span> if the verification passes. Otherwise, it outputs <span class="math">\\perp</span>.</p>

    <p class="text-gray-300">Completeness: Let <span class="math">(\\mathbf{z}, \\mathbf{w}) := [\\mathbf{z}_i = (\\vec{\\mathbf{r}}_i, \\hat{\\mathbf{v}}_i, y_i), \\mathbf{w}_i = \\vec{\\mathbf{f}}_i]_{i=1}^{2k} \\gets \\mathcal{A}(\\mathsf{pp})</span> denote adversary <span class="math">\\mathcal{A}</span>'s chosen input for <span class="math">\\mathcal{R}_1 := (\\mathcal{R}_{\\mathrm{hom}}^b)^{2k}</span>, where <span class="math">\\mathsf{pp} := (\\mathcal{R}_q, m, B &amp;lt; q/2, \\mathcal{L}) \\gets \\mathsf{Setup}(1^\\lambda)</span> is the public parameter. WLOG we assume that <span class="math">(\\mathsf{pp}, \\mathbf{z}_i, \\mathbf{w}_i) \\in \\mathcal{R}_{\\mathrm{hom}}^b</span> for all <span class="math">i \\in [2k]</span>. The protocol <span class="math">\\langle \\mathsf{P}(\\mathsf{pp}, \\mathbf{z}, \\mathbf{w}), \\mathsf{V}(\\mathsf{pp}, \\mathbf{z}) \\rangle</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> honestly run the sum-check and <span class="math">\\mathsf{P}</span> sends the correct evaluations <span class="math"><a href="\\vec{\\mathbf{r}}_o">\\theta_i := \\mathsf{mle}\\left[\\hat{\\mathbf{f}}_i\\right</a>]_{i=1}^{2k}</span>.</li>

      <li><span class="math">\\mathsf{V}</span> outputs <span class="math">\\perp</span> and halts if the check at Step 4 fails.</li>

    </ol>

    <p class="text-gray-300">27</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, let <span class="math">[\\rho_i]_{i=1}^{2k}</span> be verifier's last folding challenges. <span class="math">\\mathsf{P}</span> outputs <span class="math">\\mathsf{w}_o := \\vec{\\mathbf{f}}_o := \\sum_{i=1}^{2k} \\rho_i \\cdot \\vec{\\mathbf{f}}_i</span> and <span class="math">\\mathsf{V}</span> outputs <span class="math">\\mathsf{z}_o := (\\vec{\\mathbf{r}}_o, \\hat{\\mathbf{v}}_o, y_o)</span> where <span class="math">\\vec{\\mathbf{r}}_o</span> is <span class="math">\\mathsf{V}</span>'s sum-check challenges and <span class="math">(\\hat{\\mathbf{v}}_o, y_o)</span> are defined such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {N T T} (\\hat {\\mathbf {v}} _ {o}) = \\sum_ {i = 1} ^ {2 k} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\mathsf {N T T} \\left(\\theta_ {i}\\right)\\right), \\quad y _ {o} := \\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot y _ {i}.</span></div>

    <p class="text-gray-300">We first show that <span class="math">\\mathsf{V}</span> accepts, i.e., the check at Step 4 passes. This follows by definition of the polynomial <span class="math">g</span> (Eq. (14)) and by definition of <span class="math">\\mathsf{P}</span>'s sent evaluations.</p>

    <p class="text-gray-300">It remains to argue that the protocol output <span class="math">(\\mathsf{z}_o, \\mathsf{w}_o)</span> satisfies that <span class="math">(\\mathsf{pp}, \\mathsf{z}_o, \\mathsf{w}_o) \\in \\mathcal{R}_2 \\coloneqq \\mathcal{R}_{\\mathsf{hom}}^B</span> (Eq. (10)). First, because <span class="math">(\\mathsf{pp}, \\mathsf{z}_i, \\mathsf{w}_i) \\in \\mathcal{R}_{\\mathsf{hom}}^b</span> for all <span class="math">i \\in [2k]</span>, by Lemma 3.2, it holds that <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}}_o) = y_o</span> and <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_o">\\hat{\\mathbf{f}}_o\\right</a> = \\hat{\\mathbf{v}}_o</span>. Moreover,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {f}} _ {o} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot \\vec {\\mathbf {f}} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 1} ^ {2 k} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_ {i} \\cdot \\vec {\\mathbf {f}} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 1} ^ {2 k} c \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {f}} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\sum_ {i = 1} ^ {2 k} c \\cdot (b - 1) &lt; B.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first inequality holds because for any <span class="math">a, b \\in \\mathcal{R}_q^m</span> where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B &lt; q/2<span class="math">, we have that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a + b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">. (The norm </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> for an element </span>a<span class="math"> in </span>\\mathcal{R}_q<span class="math"> is defined in Remark 2.1.) The 2nd inequality holds as </span>\\rho_i \\in \\mathcal{C}_{\\mathrm{small}}<span class="math"> and </span>\\mathcal{C}_{\\mathrm{small}}<span class="math"> has expansion factor at most </span>c<span class="math">; the 3rd inequality holds because </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; b<span class="math"> for all </span>i \\in [2k]<span class="math"> by the assumption that </span>(\\mathsf{pp}, \\mathsf{z}_i; \\vec{\\mathbf{f}}_i) \\in \\mathcal{R}_{\\mathrm{hom}}^b<span class="math">; the last inequality holds as </span>2kc(b - 1) &lt; B &lt; q/2<span class="math"> by the premise of Theorem 3.2. Thus </span>(\\mathsf{pp}, \\mathsf{z}_o, \\mathsf{w}_o)<span class="math"> is in </span>\\mathcal{R}_{\\mathrm{hom}}^B$ from (10) as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 3.3. Let <span class="math">\\mathsf{pp} \\coloneqq (\\mathcal{R}_q \\cong \\mathbb{Z}_q^d, m, B &amp;lt; q/2, \\mathcal{L}) \\gets \\mathsf{Setup}(1^\\lambda)</span> denote the public parameters and let <span class="math">\\mathcal{C}</span>, <span class="math">\\mathcal{C}_{\\mathrm{small}} \\subseteq \\mathcal{R}_q</span> be the strong sampling sets defined in Theorem 3.2. Assume that the <span class="math">\\mathcal{R}_q</span>-module homomorphism <span class="math">\\mathcal{L}: \\mathcal{R}_q^m \\to \\mathcal{Y}</span> is <span class="math">2B</span>-relaxed binding for challenge space <span class="math">\\mathcal{C}_{\\mathrm{small}}</span> with binding error <span class="math">\\epsilon_{\\mathrm{bind}}</span>. There exists an extractor <span class="math">\\mathsf{Ext}</span> such that for any expected polynomial time adversary <span class="math">(\\mathcal{A}, \\mathsf{P}^<em>)</span> with success probability <span class="math">\\epsilon_{\\mathrm{fold}}(\\mathcal{A}, \\mathsf{P}^</em>) = 1 / \\mathrm{poly}(\\lambda)</span>, the extractor <span class="math">\\mathsf{Ext}^{\\mathcal{A}, \\mathsf{P}^<em>}</span> outputs valid witnesses (for input instances) in relation <span class="math">(\\mathcal{R}_{\\mathrm{hom}}^b)^{2k}</span> with probability at least <span class="math">\\epsilon_{\\mathrm{fold}}(\\mathcal{A}, \\mathsf{P}^</em>) - \\kappa(\\lambda)</span> where</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\kappa (\\lambda) := \\frac {2 k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C} _ {\\text {s m a l l}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\epsilon_ {\\text {b i n d}} + \\frac {(2 b + 1) \\log m + 4 k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The expected running time of <span class="math">\\mathsf{Ext}^{\\mathcal{A},\\mathsf{P}^*}</span> is at most</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T _ {\\text {e x t}} := \\left(1 + \\frac {1}{\\epsilon_ {\\text {f o l d}} (\\mathcal {A} , \\mathsf {P} ^ {*}) - \\frac {2 k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C} _ {\\text {s m a l l}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right) \\cdot (1 + 2 k) = \\operatorname {p o l y} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. As noted by Remark 1 of [AF22], it is without loss of generality to assume that <span class="math">(\\mathcal{A},\\mathsf{P}^{<em>})</span> are deterministic algorithms. For ease of notation, we assume that <span class="math">\\mathsf{P}^</em></span> outputs <span class="math">\\perp</span></p>

    <p class="text-gray-300">when it fails the verification or its output is not a valid witness for the output instance. We can always transform a prover to satisfy this requirement without affecting the success probability. To simplify the notation in the proof we introduce the following symbols:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>set <span class="math">k^{*}:=2k</span>,</li>

      <li>the folding challenge space is denoted <span class="math">\\mathcal{S}:=\\mathcal{C}^{k^{*}}_{\\text{small}}</span>,</li>

      <li>the remaining challenge space is denoted <span class="math">\\Psi:=\\mathcal{C}^{2k^{*}+2\\log m}</span>.</li>

    </ul>

    <p class="text-gray-300">Let us first give some intuition for the extraction strategy. Adversary <span class="math">\\mathcal{A}</span> begins by generating some <span class="math">k^{<em>}</span> instances <span class="math">\\mathbb{z}_{i}=(\\vec{\\mathbf{r}}_{i},\\hat{\\mathbf{v}}_{i},\\mathbf{y}_{i})</span> for <span class="math">i\\in[k^{</em>}]</span>. The prover <span class="math">\\mathsf{P}^{<em>}</span> then takes as input a sequence of random challenges from the verifier. These challenges define a folded statement <span class="math">\\mathbb{z}_{o}=(\\vec{\\mathbf{r}}_{o},\\hat{\\mathbf{v}}_{o},\\mathbf{y}_{o})</span> and <span class="math">\\mathsf{P}^{</em>}</span> outputs a valid witness <span class="math">\\vec{\\mathbf{f}}</span> for <span class="math">\\mathbb{z}_{o}</span> with non-negligible probability. Our extractor needs to use such a <span class="math">\\mathsf{P}^{<em>}</span> to output valid witnesses <span class="math">\\vec{\\mathbf{f}}_{i}</span> for <span class="math">\\mathbb{z}_{i}=(\\vec{\\mathbf{r}}_{i},\\hat{\\mathbf{v}}_{i},\\mathbf{y}_{i})</span> for all <span class="math">i\\in[k^{</em>}]</span>. Let us see how to extract <span class="math">\\vec{\\mathbf{f}}_{1}</span>; the other witnesses are extracted similarly. The high level approach to extract <span class="math">\\vec{\\mathbf{f}}_{1}</span> is to sample two related folding challenge vectors</p>

    <p class="text-gray-300"><span class="math">c_{0}:=(\\rho_{1},\\rho_{2},\\ldots,\\rho_{k^{<em>}})\\quad\\text{and}\\quad c_{1}:=(\\rho_{1}^{\\prime},\\rho_{2},\\ldots,\\rho_{k^{</em>}})\\quad\\text{from }\\mathcal{S}:=\\mathcal{C}^{k^{*}}_{\\text{small}}</span></p>

    <p class="text-gray-300">with <span class="math">\\rho_{1}\\neq\\rho_{1}^{\\prime}</span>. Then run <span class="math">\\mathsf{P}^{<em>}</span> once on <span class="math">c_{0}</span> and once on <span class="math">c_{1}</span>. All other random challenges from the verifier are the same on both runs. We show that with non-negligible probability, the prover <span class="math">\\mathsf{P}^{</em>}</span> will return two valid witness <span class="math">\\vec{\\mathbf{w}}_{0}</span> and <span class="math">\\vec{\\mathbf{w}}_{1}</span>. If <span class="math">\\mathsf{P}^{*}</span> were honest then</p>

    <p class="text-gray-300"><span class="math">\\vec{\\mathbf{w}}_{0}=\\rho_{1}\\vec{\\mathbf{f}}_{1}+\\sum_{i=2}^{k^{<em>}}\\rho_{i}\\vec{\\mathbf{f}}_{i}\\qquad\\text{and}\\qquad\\vec{\\mathbf{w}}_{1}=\\rho_{1}^{\\prime}\\vec{\\mathbf{f}}_{1}+\\sum_{i=2}^{k^{</em>}}\\rho_{i}\\vec{\\mathbf{f}}_{i}</span></p>

    <p class="text-gray-300">from which it follows that <span class="math">(\\vec{\\mathbf{w}}_{0}-\\vec{\\mathbf{w}}_{1})=(\\rho_{1}-\\rho_{1}^{\\prime})\\vec{\\mathbf{f}}_{1}</span>. We can now calculate <span class="math">\\vec{\\mathbf{f}}_{1}</span> because <span class="math">\\rho_{1}-\\rho_{1}^{\\prime}</span> is invertible in <span class="math">\\mathcal{R}_{q}</span> (since <span class="math">\\mathcal{C}_{\\text{small}}</span> is a strong sampling set). However, <span class="math">\\mathsf{P}^{*}</span> can be malicious. Fortunately, our analysis will show that a slightly enhanced strategy will either extract a valid witness <span class="math">\\vec{\\mathbf{f}}_{1}</span> for <span class="math">\\mathbb{z}_{1}</span> with non-negligible probability, or break the <span class="math">2B</span>-relaxed binding property of <span class="math">\\mathcal{L}</span>. In particular, in Claim 3.7 below we show that the sumcheck in protocol <span class="math">\\Pi_{\\text{fold}}</span>, combined with the relaxed binding property of <span class="math">\\mathcal{L}</span>, ensures that the extracted witnesses <span class="math">\\vec{\\mathbf{f}}_{i}</span> have norm at most <span class="math">b</span> and that the evaluations of <span class="math">\\mathsf{mle}\\left[\\tilde{\\mathbf{f}}_{i}\\right]</span> at <span class="math">\\vec{\\mathbf{r}}_{i}</span> are correct.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">The Extractor.</h4>

    <p class="text-gray-300">We describe the complete extractor <span class="math">\\mathsf{Ext}^{\\mathcal{A},\\mathsf{P}^{<em>}}</span> in Figure 4. The extractor invokes two sub-procedures. The algorithm <span class="math">\\mathsf{IG}^{\\mathcal{A}}</span> samples the input instances. The algorithm <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{</em>}}(\\mathsf{inst},\\psi)</span>, given randomness <span class="math">\\psi:=([\\alpha_{i},\\mu_{i}]_{i=1}^{k^{<em>}},\\vec{\\beta},\\vec{\\mathbf{r}}_{o})</span>, tries to recover weak openings to the input instances in <span class="math">\\mathsf{inst}</span> by rewinding <span class="math">\\mathsf{P}^{</em>}</span> multiple times. We emphasize that each run of <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{<em>}}(\\mathsf{inst},\\psi)</span> and <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{</em>}}(\\mathsf{inst},\\psi^{\\prime})</span> uses fresh internal randomness for challenges <span class="math">(c_{0},c_{1},\\ldots,c_{k^{*}})</span>.</p>

    <p class="text-gray-300">Let <span class="math">[\\mathbb{z}_{i}:=(\\vec{\\mathbf{r}}_{i},\\hat{\\mathbf{v}}_{i},\\mathbf{y}_{i})]_{i=1}^{k^{*}}</span> denote the input instances. For any list of length-<span class="math">m</span> ring</p>

    <p class="text-gray-300">SubProcedure  <span class="math">\\mathsf{IG}^A (1^\\lambda)</span>  // sample as instance</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(1^{\\lambda})</span></li>

      <li>Return inst := ([z_i]k_i=1, state) ← A(pp)</li>

    </ol>

    <p class="text-gray-300">SubProcedure SubExtP*(inst,  <span class="math">\\psi \\in \\Psi</span>  ): // attempt to extract a witness for inst</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{0}:= (\\rho_{1},\\ldots ,\\rho_{k^{*}})\\stackrel {\\circ}{\\leftarrow}\\mathcal{S}</span></li>

      <li><span class="math">\\vec{\\mathbf{w}}_0\\gets \\mathsf{P}^* (\\mathsf{inst},c_0,\\psi)</span></li>

      <li>If  <span class="math">\\vec{\\mathbf{w}}_0 = \\bot</span>  return (open,out) := (⊥,⊥)</li>

      <li>For  <span class="math">i = 1,\\dots ,k^{<em>}</span>  .. Do: // loop until a good folding randomness  <span class="math">\\rho_i^\\prime</span>  is found (a)  <span class="math">\\rho_i^\\prime \\stackrel {\\circ}{\\leftarrow}\\mathcal{C}_{\\mathrm{small}}\\setminus \\{\\rho_i\\}</span>  without replacement (b)  <span class="math">c_{i}\\coloneqq (\\rho_{1},\\ldots ,\\rho_{i - 1},\\rho_{i}^{\\prime},\\rho_{i + 1},\\ldots ,\\rho_{k^{</em>}})</span>  (c)  <span class="math">\\vec{\\mathbf{w}}_i\\gets \\mathsf{P}^* (\\mathsf{inst},c_i,\\psi)</span>  Repeat until  <span class="math">\\vec{\\mathbf{w}}_i\\neq \\bot</span>  ; return (⊥,⊥) if all  <span class="math">\\rho_i^\\prime</span>  have been tried</li>

      <li>For  <span class="math">i = 1,\\dots ,k^{*}</span>  : set open  <span class="math">\\mathbf{\\Pi}_i\\coloneqq (\\rho_i - \\rho_i&#x27;,\\vec{\\mathbf{w}}_0 - \\vec{\\mathbf{w}}_i)</span>  and  <span class="math">\\vec{\\mathbf{f}}_i\\coloneqq (\\rho_i - \\rho_i&#x27;)^{-1}(\\vec{\\mathbf{w}}_0 - \\vec{\\mathbf{w}}_i)</span></li>

      <li>Return open := [open  <span class="math">\\mathbf{\\Pi}_{i=1}^{k^{*}}</span>  and out := [f]k]i=1</li>

    </ol>

    <p class="text-gray-300">The extractor ExtA,P*(1A):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inst  <span class="math">\\leftarrow</span>  IG(A(1A))</li>

      <li>Do: // loop until a good tuple of challenges  <span class="math">\\psi</span>  is found (a)  <span class="math">\\psi := ([\\alpha_i,\\mu_i]_{i=1}^{k^<em>},\\vec{\\beta},\\vec{\\mathbf{r}}_o)\\stackrel {\\circ}{\\leftarrow}\\Psi</span>  // sample fresh challenges (b) (open1,out1)  <span class="math">\\leftarrow</span>  SubExtP</em>(inst,  <span class="math">\\psi</span>  ) // attempt to extract a witness using  <span class="math">\\psi</span>  Repeat until out1  <span class="math">\\neq \\bot</span></li>

      <li><span class="math">\\psi^{\\prime}\\coloneqq ([\\alpha_{i}^{\\prime},\\mu_{i}^{\\prime}]_{i = 1}^{k^{*}},\\vec{\\beta}^{\\prime},\\vec{\\mathbf{r}}_{o}^{\\prime})\\stackrel {\\circ}{\\leftarrow}\\Psi</span>  // sample fresh challenges</li>

      <li>(open2,out2)  <span class="math">\\leftarrow</span>  SubExtP*(inst,  <span class="math">\\psi^{\\prime}</span>  ), abort if out2 =  <span class="math">\\bot</span>  or out1  <span class="math">\\neq</span>  out2</li>

      <li>Parse out1 = out2 = [f]k]i=1</li>

      <li>Abort if  <span class="math">\\Phi_{\\mathrm{valid}}([z_i,\\vec{\\mathbf{f}}_i]_{i = 1}^{k^*}) = 0</span>  , where [z_i]k] are the input instances in inst</li>

      <li>Return [f]k]i=1</li>

    </ol>

    <p class="text-gray-300">Figure 4: The extractor for  <span class="math">\\Pi_{\\mathrm{fold}}</span>  using the validity predicate  <span class="math">\\Phi_{\\mathrm{valid}}</span>  from (18).</p>

    <p class="text-gray-300">vectors <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^<em>} \\in (\\mathcal{R}_q^m)^{k^</em>}</span>, and <span class="math">i \\in [k^*]</span>, define the multilinear polynomial</p>

    <div class="my-4 text-center"><span class="math-block">p_i(\\vec{\\mathbf{x}}):= \\sum_{\\vec{\\mathbf{b}} \\in \\{0,1\\}^{\\log m}} eq(\\vec{\\mathbf{x}}, \\vec{\\mathbf{b}}) \\cdot \\prod_{j=1-b}^{b-1} \\left( \\mathsf{mle} \\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{b}}) - j \\right). \\tag{17}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">p_i(\\vec{\\mathbf{x}}) = 0</span> implies that <span class="math">\\prod_{j=1-b}^{b-1} \\left( \\mathsf{mle} \\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{b}}) - j \\right) = 0</span> for every <span class="math">\\vec{\\mathbf{b}} \\in \\{0,1\\}^{\\log m}</span>, which in turn implies $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}}_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; b<span class="math"> from the discussion in Section 3.1. The predicate </span>\\Phi_{\\mathrm{valid}}([\\mathbf{z}_i, \\vec{\\mathbf{f}}_i]_{i=1}^{k^*})$ is true if and only if</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [k^*] : \\left( \\mathsf{mle} \\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{r}}_i) = \\hat{\\mathbf{v}}_i \\right) \\wedge \\left( \\mathcal{L}(\\vec{\\mathbf{f}}_i) = \\mathbf{y}_i \\right) \\wedge \\left( p_i(\\vec{\\mathbf{x}}) = 0 \\right). \\tag{18}</span></div>

    <p class="text-gray-300">Hence, <span class="math">\\Phi_{\\mathrm{valid}}([\\mathbf{z}_i,\\vec{\\mathbf{f}}_i]_{i = 1}^{k^<em>}) = 1</span> if and only if <span class="math">[\\vec{\\mathbf{f}}_i]_{i = 1}^{k^</em>}</span> are valid witnesses for <span class="math">[\\mathbf{z}_i]_{i = 1}^{k^<em>}</span>, that is, <span class="math">[\\mathbf{z}_i,\\vec{\\mathbf{f}}_i]_{i = 1}^{k^</em>} \\in (\\mathcal{R}_{\\mathrm{hom}}^b)^{k^*}</span>. Thus, given the check at Step 6, the extractor always outputs a valid witness if it does not abort.</p>

    <p class="text-gray-300"><strong>Running time.</strong> We adapt the proof of Lemma 7.1 in [FMN23] to analyze the expected running time of the extractor. We first analyze the expected running time of each execution of <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^<em>}</span>. Fix any input <span class="math">(\\mathsf{inst}, \\psi)</span>, we denote by <span class="math">C_0 := (\\Sigma_1, \\dots, \\Sigma_{k^</em>})</span> the random variable for the folding challenges <span class="math">c_0 := (\\rho_1, \\dots, \\rho_{k^<em>})</span>. We define event <span class="math">\\Gamma := (\\mathsf{P}^</em>(\\mathsf{inst}, C_0, \\psi) \\neq \\bot)</span>.</p>

    <p class="text-gray-300">Let <span class="math">T</span> be the number of calls to <span class="math">\\mathsf{P}^<em></span> in <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^</em>}(\\mathsf{inst}, \\psi)</span>. For <span class="math">i \\in [k^<em>]</span>, let <span class="math">T_i</span> be the number of calls to <span class="math">\\mathsf{P}^</em></span> made during the <span class="math">i</span>-th iteration of the loop. We have <span class="math">\\mathbb{E}[T] = 1 + \\sum_{i=1}^{k^*} \\mathbb{E}[T_i]</span> by linearity of expectation.</p>

    <p class="text-gray-300">Define the random variable</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_i := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ x \\in \\mathcal{C}_{\\text{small}} : \\mathsf{P}^*(\\mathsf{inst}, C(x), \\psi) \\neq \\bot \\right\\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tag{19}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">C(x) := (\\Sigma_1, \\dots, \\Sigma_{i-1}, x, \\Sigma_{i+1}, \\dots, \\Sigma_{k^*})</span>. Let $N :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\text{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{E}[T_i] = \\sum_{j=0}^{N} \\mathbb{E}[T_i \\mid X_i = j] \\cdot \\Pr[X_i = j].</span></div>

    <p class="text-gray-300">Also note that <span class="math">T_i = 0</span> when <span class="math">\\Gamma = 0</span>, thus for any <span class="math">j \\geq 0</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{E}[T_i \\mid X_i = j] = \\Pr[\\Gamma = 1 \\mid X_i = j] \\cdot \\mathbb{E}[T_i \\mid (\\Gamma = 1) \\wedge X_i = j]</span></div>

    <p class="text-gray-300">where <span class="math">\\operatorname*{Pr}[\\Gamma = 1\\mid X_i = j] = j / N</span> and <span class="math">\\mathbb{E}[T_i\\mid (\\Gamma = 1)\\wedge X_i = j]</span> is the expectation of a negative hypergeometric distribution, that is, challenges <span class="math">\\rho_i&#x27;</span> are drawn without replacement from a set of size <span class="math">N - 1</span> that contains <span class="math">j - 1</span> correct responses. Hence, <span class="math">\\mathbb{E}[T_i\\mid (\\Gamma = 1)\\wedge X_i = j]\\leq N / j</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and therefore $\\mathbb{E}[T_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_i = j] \\leq j / N \\cdot (N / j) = 1<span class="math">. In sum, for all </span>i \\in [k^*]<span class="math">, we have that </span>\\mathbb{E}[T_i] \\leq \\sum_{j=0}^{N} 1 \\cdot \\operatorname{Pr}[X_i = j] = 1$, and therefore</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ T ] = 1 + \\sum_ {i = 1} ^ {k ^ {*}} \\mathbb {E} [ T _ {i} ] \\leq 1 + k ^ {*}.</span></div>

    <p class="text-gray-300">Next, we analyze the success probability of each independent run of SubExt<span class="math">^{\\mathsf{P}^<em>}</span>. Since <span class="math">\\mathcal{A}</span>, <span class="math">\\mathsf{P}^</em></span> are deterministic, we have that the event <span class="math">\\Gamma \\coloneqq (\\mathsf{P}^<em>(\\mathrm{inst}, C_0, \\psi) \\neq \\bot)</span> happens with probability <span class="math">\\epsilon_{\\mathrm{fold}}(\\mathcal{A}, \\mathsf{P}^</em>)</span> over the randomness of <span class="math">\\psi</span> and <span class="math">C_0</span>. Define <span class="math">E</span> as the event that a fresh call of SubExt<span class="math">^{\\mathsf{P}^*}(\\mathrm{inst}, \\psi)</span> does not return <span class="math">\\bot</span>. We have that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr [ E ] = \\Pr [ \\Gamma = 1 \\wedge (\\wedge_{i = 1}^{k ^ {<em>}} X _ {i} \\geq 2) ] \\tag {20} \\\\ = \\Pr [ \\Gamma = 1 ] - \\Pr [ \\Gamma = 1 \\wedge (\\vee_{i = 1}^{k ^ {</em>}} X _ {i} = 1) ] \\\\ \\geq \\Pr [ \\Gamma = 1 ] - \\sum_ {i = 1} ^ {k ^ {*}} \\Pr [ \\Gamma = 1 \\wedge X _ {i} = 1 ] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\Pr [ \\Gamma = 1 ] - \\frac {k ^ {*}}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C} _ {\\text {s m a l l}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In sum, the expected number of calls to <span class="math">\\mathsf{P}^<em></span> in the extractor is at most $(\\mathbb{E}[T] / \\operatorname</em>{Pr}[E]) + E[T] = \\left(1 + 1 / \\left(\\epsilon_{\\mathrm{fold}}(\\mathcal{A},\\mathsf{P}^{*}) - \\frac{2k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\right)\\cdot (1 + 2k) = \\mathrm{poly}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Success probability.</strong> Towards analyzing the extractor's success probability, we define the following events.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">E_{\\mathrm{ext}}</span>: the extractor recovers the witnesses <span class="math">\\mathsf{out}_1, \\mathsf{out}_2 \\neq \\bot</span>, and, <span class="math">\\mathsf{out}_1 = \\mathsf{out}_2</span>.</li>

      <li><span class="math">E_{\\mathrm{valid}}</span>: <span class="math">E_{\\mathrm{ext}}</span> occurs and the extracted witness is valid, i.e., <span class="math">\\Phi_{\\mathrm{valid}}([\\mathbb{z}_i,\\vec{\\mathbf{f}}_i]_{i = 1}^{k^<em>} = 1</span> for the input instances <span class="math">[\\mathbb{z}_i]_{i = 1}^{k^</em>}</span> and the interpolated witness <span class="math">[\\vec{\\mathbf{f}}_i]_{i = 1}^{k^*}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">E_{\\mathrm{ext}} \\wedge E_{\\mathrm{valid}}</span> implies that the extractor returns a valid witness for the input instances. Moreover,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ E _ {\\text {e x t}} \\wedge E _ {\\text {v a l i d}} \\right] = \\Pr \\left[ E _ {\\text {e x t}} \\right] - \\Pr \\left[ E _ {\\text {e x t}} \\wedge \\overline {{E _ {\\text {v a l i d}}}} \\right],</span></div>

    <p class="text-gray-300">thus it suffices to lower-bound <span class="math">\\operatorname<em>{Pr}[E_{\\mathrm{ext}}]</span> and upper-bound <span class="math">\\operatorname</em>{Pr}[E_{\\mathrm{ext}} \\wedge \\overline{E_{\\mathrm{valid}}}]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 1.</strong> $\\operatorname<em>{Pr}[E_{\\mathrm{ext}}] \\geq \\epsilon_{\\mathrm{fold}}(\\mathcal{A}, \\mathsf{P}^</em>) - \\frac{k^*}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} - \\epsilon_{\\mathrm{bind}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We define <span class="math">E^{\\prime}_{\\mathsf{ext}}</span> as the event that the last call of <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{*}}</span>, on input <span class="math">(\\mathsf{inst},\\psi^{\\prime})</span>, does not return <span class="math">\\bot</span>. By Eq. (20), we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[E^{\\prime}_{\\mathsf{ext}}]\\geq\\epsilon_{\\mathsf{fold}}(\\mathcal{A},\\mathsf{P}^{<em>})-\\frac{k^{</em>}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">because (i) <span class="math">\\mathcal{A}</span> is deterministic, and (ii) <span class="math">\\psi^{\\prime}</span> and the randomness in <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{*}}(\\mathsf{inst},\\psi^{\\prime})</span> are freshly sampled.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">E^{\\prime}_{\\mathsf{ext}}</span> occurs. Let <span class="math">(\\mathsf{open}_{1},\\mathsf{out}_{1})</span>, <span class="math">(\\mathsf{open}_{2},\\mathsf{out}_{2})</span> be the output of <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{<em>}}(\\mathsf{inst},\\psi)</span> and <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{</em>}}(\\mathsf{inst},\\psi^{\\prime})</span> respectively. We next show that <span class="math">\\mathsf{out}_{1}=\\mathsf{out}_{2}</span> (and thus <span class="math">E_{\\mathsf{ext}}</span> holds) with high probability. For every <span class="math">i\\in[k^{<em>}]</span>, let <span class="math">\\mathsf{open}_{1,i}:=(\\Delta,\\vec{\\mathbf{w}})</span> and <span class="math">\\mathsf{open}_{2,i}:=(\\Delta^{\\prime},\\vec{\\mathbf{w}}^{\\prime})</span>. Recall the assumption that <span class="math">\\mathsf{P}^{</em>}</span> produces an output only when the witness is valid for the folded instance. Therefore, the <em>interpolated</em> witnesses <span class="math">\\vec{\\mathbf{w}}</span>, <span class="math">\\vec{\\mathbf{w}}^{\\prime}</span> output by <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{<em>}}</span> must satisfy that <span class="math">\\mathcal{L}(\\vec{\\mathbf{w}})=\\Delta y_{i}</span> and <span class="math">\\mathcal{L}(\\vec{\\mathbf{w}}^{\\prime})=\\Delta^{\\prime}y_{i}</span>. Suppose for contradiction that <span class="math">\\mathsf{out}_{1,i}=\\Delta^{-1}\\vec{\\mathbf{w}}\\neq(\\Delta^{\\prime})^{-1}\\vec{\\mathbf{w}}^{\\prime}=\\mathsf{out}_{2,i}</span>, then <span class="math">\\Delta^{\\prime}\\vec{\\mathbf{w}}\\neq\\Delta\\vec{\\mathbf{w}}^{\\prime}</span>, and <span class="math">(\\mathsf{open}_{1,i},\\mathsf{open}_{2,i})</span> is a pair of </em>distinct <span class="math">2B</span>-weak* openings that breaks the <span class="math">2B</span>-relaxed binding property of <span class="math">\\mathcal{L}</span>. Specifically, <span class="math">\\mathcal{L}(\\vec{\\mathbf{w}})=\\Delta y_{i}</span> and <span class="math">\\mathcal{L}(\\vec{\\mathbf{w}}^{\\prime})=\\Delta^{\\prime}y_{i}</span>; $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<2B<span class="math"> because </span>\\vec{\\mathbf{w}}<span class="math"> and </span>\\vec{\\mathbf{w}}^{\\prime}<span class="math"> are the subtractions of two vectors with norm less than </span>B<span class="math">; and </span>\\Delta<span class="math">, </span>\\Delta^{\\prime}<span class="math"> are non-zero differences in the set </span>\\mathcal{C}_{\\mathsf{small}}<span class="math">. Moreover, the extractor is an expected polynomial time algorithm. Thus, by the relaxed binding property of </span>\\mathcal{L}$, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr\\left[E^{\\prime}_{\\mathsf{ext}}\\wedge(\\mathsf{out}_{1}\\neq\\mathsf{out}_{2})\\right]\\leq\\epsilon_{\\mathsf{bind}}\\,.</span></p>

    <p class="text-gray-300">Therefore, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[E_{\\mathsf{ext}}]</span> <span class="math">=\\Pr[E^{\\prime}_{\\mathsf{ext}}]-\\Pr\\left[E^{\\prime}_{\\mathsf{ext}}\\wedge(\\mathsf{out}_{1}\\neq\\mathsf{out}_{2})\\right]</span> <span class="math">\\geq\\Pr[E^{\\prime}_{\\mathsf{ext}}]-\\epsilon_{\\mathsf{bind}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\geq\\epsilon_{\\mathsf{fold}}(\\mathcal{A},\\mathsf{P}^{<em>})-\\frac{k^{</em>}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\epsilon_{\\mathsf{bind}}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which completes the proof. ∎</p>

    <p class="text-gray-300">Next, we upper-bound the probability of <span class="math">E_{\\mathsf{ext}}\\wedge\\overline{E_{\\mathsf{valid}}}</span> – the event that extractor recovers witnesses <span class="math">\\mathsf{out}_{1}=\\mathsf{out}_{2}</span> but the extracted witness is invalid.</p>

    <p class="text-gray-300">We first reduce <span class="math">\\Pr[E_{\\mathsf{ext}}\\wedge\\overline{E_{\\mathsf{valid}}}]</span> to the probability of a different event that is easier to analyze. Let <span class="math">\\mathsf{inst}</span> denote <span class="math">\\mathcal{A}</span>’s output that includes the input instances <span class="math">[\\mathsf{z}_{i}:=(\\vec{\\mathbf{r}}_{i},\\hat{\\mathbf{v}}_{i},y_{i})]_{i=1}^{k^{<em>}}</span>. Let <span class="math">\\psi^{\\prime}:=([\\alpha^{\\prime}_{i},\\mu^{\\prime}]_{i=1}^{k^{</em>}},\\vec{\\beta}^{\\prime},\\vec{\\mathbf{r}}^{\\prime}_{o})</span> be the last sampled randomness. We consider the sub-extraction call <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{<em>}}(\\mathsf{inst},\\psi^{\\prime})</span>: Let <span class="math">c_{0}:=(\\rho_{1},\\ldots,\\rho_{k^{</em>}})</span> denote the initial folding challenge, and let <span class="math">[\\theta^{\\prime}_{i}]_{i=1}^{k^{<em>}}</span> denote the claimed evaluations in the transcript of <span class="math">\\mathsf{P}^{</em>}(\\mathsf{inst},c_{0},\\psi^{\\prime})</span>. Let <span class="math">[\\vec{\\mathbf{t}}]_{i=1}^{k^{<em>}}</span> denote the interpolated vectors when <span class="math">E_{\\mathsf{ext}}</span> occurs, and let <span class="math">[p_{i}(\\vec{\\mathbf{x}})]_{i=1}^{k^{</em>}}</span> be the corresponding</p>

    <p class="text-gray-300">polynomials specified in Eq. (17). Define events <span class="math">E_{\\mathsf{hom}}</span>, <span class="math">E_{\\mathsf{eval}}</span>, <span class="math">E_{\\mathsf{bad}}</span> as</p>

    <p class="text-gray-300"><span class="math">E_{\\mathsf{hom}}</span> <span class="math">:=E_{\\mathsf{ext}}\\wedge(\\forall i\\in[k^{<em>}]\\ :\\ \\mathcal{L}(\\vec{\\mathbf{f}}_{i})=y_{i})\\,,</span> (21) <span class="math">E_{\\mathsf{eval}}</span> <span class="math">:=E_{\\mathsf{ext}}\\wedge(\\forall i\\in[k^{</em>}]\\ :\\ \\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{o}^{\\prime}">\\hat{\\mathbf{f}}_{i}\\right</a>=\\theta_{i}^{\\prime})\\,,</span> (22) <span class="math">E_{\\mathsf{bad}}</span> <span class="math">:=E_{\\mathsf{ext}}\\wedge(\\exists i\\in[k^{*}]\\ :\\ \\left(\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{i}">\\hat{\\mathbf{f}}_{i}\\right</a>\\neq\\hat{\\mathbf{v}}_{i}\\right)\\vee(p_{i}(\\vec{\\mathbf{x}})\\neq 0))\\,.</span> (23)</p>

    <p class="text-gray-300">Informally, <span class="math">E_{\\mathsf{eval}}</span> implies that the reduced evaluation claim holds after running the sumcheck; <span class="math">E_{\\mathsf{bad}}</span> implies that the extracted witness is invalid.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Claim 2.</h6>

    <p class="text-gray-300"><span class="math">\\Pr[E_{\\mathsf{ext}}\\wedge\\overline{E_{\\mathsf{valid}}}]=\\Pr[E_{\\mathsf{eval}}\\wedge E_{\\mathsf{bad}}]</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume that <span class="math">E_{\\mathsf{ext}}\\implies(E_{\\mathsf{hom}}\\wedge E_{\\mathsf{eval}})</span> holds (which we will prove later), we argue that <span class="math">E_{\\mathsf{ext}}\\wedge\\overline{E_{\\mathsf{valid}}}</span> occurs if and only if <span class="math">E_{\\mathsf{eval}}\\wedge E_{\\mathsf{bad}}</span> occurs.</p>

    <p class="text-gray-300">We recall the definitions of <span class="math">E_{\\mathsf{ext}}</span>, <span class="math">E_{\\mathsf{valid}}</span>, <span class="math">E_{\\mathsf{hom}}</span> (Eq. (21)), <span class="math">E_{\\mathsf{eval}}</span> (Eq. (22)) and <span class="math">E_{\\mathsf{bad}}</span> (Eq. (23)). Informally, <span class="math">E_{\\mathsf{ext}}</span> means that the witnesses <span class="math">\\mathsf{out}_{1}</span>, <span class="math">\\mathsf{out}_{2}\\neq\\bot</span> recovered by the extractor are the same. <span class="math">E_{\\mathsf{valid}}</span> means that the recovered witness is valid. <span class="math">E_{\\mathsf{hom}}</span> means that the interpolated witness satisfies the homomorphism relation, i.e., <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}}_{i})=y_{i}</span> for every <span class="math">i\\in[k^{<em>}]</span>. <span class="math">E_{\\mathsf{eval}}</span> means that the reduced evaluation checks (after sumcheck) pass for the interpolated witness, i.e., <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{o}^{\\prime}">\\hat{\\mathbf{f}}_{i}\\right</a>=\\theta_{i}^{\\prime}</span> for every <span class="math">i\\in[k^{</em>}]</span>. Finally, <span class="math">E_{\\mathsf{bad}}</span> means that the input evaluation claims or the norm constraint do not hold for the interpolated witness.</p>

    <p class="text-gray-300">Suppose <span class="math">E_{\\mathsf{ext}}\\wedge\\overline{E_{\\mathsf{valid}}}</span> occurs. By the assumption that <span class="math">E_{\\mathsf{ext}}\\implies(E_{\\mathsf{hom}}\\wedge E_{\\mathsf{eval}})</span> holds, <span class="math">E_{\\mathsf{eval}}</span> and <span class="math">E_{\\mathsf{hom}}</span> must also occur. Moreover, if <span class="math">E_{\\mathsf{hom}}</span> occurs while <span class="math">E_{\\mathsf{valid}}</span> does not, it must be the case that <span class="math">E_{\\mathsf{bad}}</span> occurs. Therefore, <span class="math">E_{\\mathsf{eval}}\\wedge E_{\\mathsf{bad}}</span> will occur.</p>

    <p class="text-gray-300">Conversely, suppose <span class="math">E_{\\mathsf{eval}}\\wedge E_{\\mathsf{bad}}</span> occurs. Then <span class="math">E_{\\mathsf{ext}}</span> certainly occurs. However, <span class="math">E_{\\mathsf{valid}}</span> cannot occur because <span class="math">E_{\\mathsf{bad}}</span> occurs, and thus <span class="math">E_{\\mathsf{ext}}\\wedge\\overline{E_{\\mathsf{valid}}}</span> occurs.</p>

    <p class="text-gray-300">Now it suffices to show that <span class="math">E_{\\mathsf{ext}}\\implies(E_{\\mathsf{hom}}\\wedge E_{\\mathsf{eval}})</span>. Suppose <span class="math">E_{\\mathsf{ext}}</span> occurs. Let <span class="math">[c_{i},\\vec{\\mathbf{w}}_{i}]_{i=0}^{k^{<em>}}</span> denote the tuples collected in <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^{</em>}}(\\mathsf{inst},\\psi^{\\prime})</span> where <span class="math">c_{0}:=(\\rho_{1},\\ldots,\\rho_{k^{*}})</span> and</p>

    <p class="text-gray-300"><span class="math">c_{i}:=(\\rho_{1},\\ldots,\\rho_{i-1},\\rho_{i}^{\\prime},\\rho_{i+1},\\ldots,\\rho_{k^{*}})\\,.</span></p>

    <p class="text-gray-300">For every <span class="math">i\\in[k^{*}]</span>, since <span class="math">\\vec{\\mathbf{w}}_{0},\\vec{\\mathbf{w}}_{i}\\neq\\bot</span> are valid witnesses, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}(\\vec{\\mathbf{w}}_{0})</span> <span class="math">=\\rho_{1}y_{1}+\\cdots+\\rho_{i-1}y_{i-1}+\\rho_{i}y_{i}+\\rho_{i+1}y_{i+1}+\\cdots+\\rho_{k^{<em>}}y_{k^{</em>}}\\,,</span> <span class="math">\\mathcal{L}(\\vec{\\mathbf{w}}_{i})</span> <span class="math">=\\rho_{1}y_{1}+\\cdots+\\rho_{i-1}y_{i-1}+\\rho_{i}^{\\prime}y_{i}+\\rho_{i+1}y_{i+1}+\\cdots+\\rho_{k^{<em>}}y_{k^{</em>}}\\,,</span></p>

    <p class="text-gray-300">thus</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}(\\vec{\\mathbf{f}}_{i})</span> <span class="math">=\\mathcal{L}((\\vec{\\mathbf{w}}_{0}-\\vec{\\mathbf{w}}_{i})\\cdot(\\rho_{i}-\\rho_{i}^{\\prime})^{-1})</span> <span class="math">=(\\rho_{i}-\\rho_{i}^{\\prime})^{-1}\\cdot\\mathcal{L}(\\vec{\\mathbf{w}}_{0}-\\vec{\\mathbf{w}}_{i})</span> <span class="math">=(\\rho_{i}-\\rho_{i}^{\\prime})^{-1}\\cdot(\\mathcal{L}(\\vec{\\mathbf{w}}_{0})-\\mathcal{L}(\\vec{\\mathbf{w}}_{i}))</span> <span class="math">=(\\rho_{i}-\\rho_{i}^{\\prime})^{-1}\\cdot(\\rho_{i}-\\rho_{i}^{\\prime})\\cdot y_{i}=y_{i}\\,,</span></p>

    <p class="text-gray-300">which implies that <span class="math">E_{\\mathsf{hom}}</span> occurs.</p>

    <p class="text-gray-300">Similarly, since the prover <span class="math">\\mathsf{P}^<em></span> needs to output <span class="math">[\\theta_j&#x27;]_{j=1}^{k^</em>}</span> before receiving the folding challenges, the claimed evaluations <span class="math">\\{\\theta_j&#x27;\\}</span> in the executions of <span class="math">\\mathsf{P}^<em>(\\mathsf{inst}, c_0, \\psi&#x27;)</span> and <span class="math">\\mathsf{P}^</em>(\\mathsf{inst}, c_i, \\psi&#x27;)</span> are the same. Define</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\mathbf{v}}_o^{(0)} := \\mathsf{mle}\\left[\\hat{\\mathbf{w}}_0\\right]\\left(\\vec{\\mathbf{r}}_o&#x27;\\right), \\qquad \\hat{\\mathbf{v}}_o^{(i)} := \\mathsf{mle}\\left[\\hat{\\mathbf{w}}_i\\right]\\left(\\vec{\\mathbf{r}}_o&#x27;\\right).</span></div>

    <p class="text-gray-300">Note that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(0)}) := \\mathsf{mle}\\left[\\mathsf{Coef}(\\vec{\\mathbf{w}}_0)\\right]\\left(\\vec{\\mathbf{r}}_o&#x27;\\right), \\qquad \\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(i)}) := \\mathsf{mle}\\left[\\mathsf{Coef}(\\vec{\\mathbf{w}}_i)\\right]\\left(\\vec{\\mathbf{r}}_o&#x27;\\right).</span></div>

    <p class="text-gray-300">Since <span class="math">\\mathsf{P}^*</span> outputs valid witnesses for the output instances, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(0)}) = \\sum_{j=1}^{k^*} \\mathsf{RotSum}(\\rho_j, \\mathsf{NTT}(\\theta_j&#x27;)) \\, , \\\\ \\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(i)}) = \\sum_{j \\in [k^*], j \\neq i} \\mathsf{RotSum}(\\rho_j, \\mathsf{NTT}(\\theta_j&#x27;)) + \\mathsf{RotSum}(\\rho_i&#x27;, \\mathsf{NTT}(\\theta_i&#x27;)) \\, , \\end{array}</span></div>

    <p class="text-gray-300">which implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(0)} - \\hat{\\mathbf{v}}_o^{(i)}) = \\mathsf{RotSum}(\\rho_i, \\mathsf{NTT}(\\theta_i&#x27;)) - \\mathsf{RotSum}(\\rho_i&#x27;, \\mathsf{NTT}(\\theta_i&#x27;)) \\,. \\tag{24}</span></div>

    <p class="text-gray-300">Let <span class="math">\\Delta_o</span>, <span class="math">\\bar{\\theta}_i&#x27;</span> be the values such that <span class="math">\\mathsf{Coef}(\\Delta_o) = \\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(0)} - \\hat{\\mathbf{v}}_o^{(i)})</span> and <span class="math">\\mathsf{Coef}(\\bar{\\theta}_i&#x27;) = \\mathsf{NTT}(\\theta_i&#x27;)</span>. By Lemma 2.1, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{RotSum}(\\rho_i, \\mathsf{NTT}(\\theta_i&#x27;)) = \\mathsf{Coef}(\\rho_i \\cdot \\bar{\\theta}_i&#x27;) \\, , \\qquad \\mathsf{RotSum}(\\rho_i&#x27;, \\mathsf{NTT}(\\theta_i&#x27;)) = \\mathsf{Coef}(\\rho_i&#x27; \\cdot \\bar{\\theta}_i&#x27;).</span></div>

    <p class="text-gray-300">Then by Eq. (24), we have that <span class="math">\\mathsf{Coef}(\\Delta_o) = \\mathsf{Coef}((\\rho_i - \\rho_i&#x27;) \\cdot \\bar{\\theta}_i&#x27;)</span> and thus <span class="math">\\mathsf{Coef}((\\rho_i - \\rho_i&#x27;)^{-1} \\cdot \\Delta_o) = \\mathsf{Coef}(\\bar{\\theta}_i&#x27;)</span>. By definition of <span class="math">\\vec{\\mathbf{f}}_i</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{mle}\\left[\\mathsf{Coef}(\\vec{\\mathbf{f}}_i)\\right](\\vec{\\mathbf{r}}_o&#x27;) = \\mathsf{mle}\\left[\\mathsf{Coef}((\\vec{\\mathbf{w}}_0 - \\vec{\\mathbf{w}}_i) \\cdot (\\rho_i - \\rho_i&#x27;)^{-1})\\right](\\vec{\\mathbf{r}}_o&#x27;) \\\\ = (\\rho_i - \\rho_i&#x27;)^{-1} \\cdot \\mathsf{mle}\\left[\\mathsf{Coef}(\\vec{\\mathbf{w}}_0 - \\vec{\\mathbf{w}}_i)\\right](\\vec{\\mathbf{r}}_o&#x27;) \\\\ = (\\rho_i - \\rho_i&#x27;)^{-1} \\cdot (\\mathsf{mle}\\left[\\mathsf{Coef}(\\vec{\\mathbf{w}}_0)\\right](\\vec{\\mathbf{r}}_o&#x27;) - \\mathsf{mle}\\left[\\mathsf{Coef}(\\vec{\\mathbf{w}}_i)\\right](\\vec{\\mathbf{r}}_o&#x27;)) \\\\ = (\\rho_i - \\rho_i&#x27;)^{-1} \\cdot (\\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(0)}) - \\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(i)})) \\\\ = (\\rho_i - \\rho_i&#x27;)^{-1} \\cdot \\mathsf{NTT}(\\hat{\\mathbf{v}}_o^{(0)} - \\hat{\\mathbf{v}}_o^{(i)}) \\\\ = (\\rho_i - \\rho_i&#x27;)^{-1} \\cdot \\mathsf{Coef}(\\Delta_o) \\\\ = \\mathsf{Coef}((\\rho_i - \\rho_i&#x27;)^{-1} \\cdot \\Delta_o) \\\\ = \\mathsf{Coef}(\\bar{\\theta}_i&#x27;) = \\mathsf{NTT}(\\theta_i&#x27;). \\end{array}</span></div>

    <p class="text-gray-300">By Lemma A.1 and because <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}}_i) = \\mathsf{Coef}(\\vec{\\mathbf{f}}_i)</span>, this implies that <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_o&#x27;">\\hat{\\mathbf{f}}_i\\right</a> = \\theta_i&#x27;</span>. Therefore, <span class="math">E_{\\mathrm{eval}}</span> occurs, which finishes the proof.</p>

    <p class="text-gray-300">Therefore, to analyze <span class="math">\\operatorname{Pr}[E_{\\mathrm{ext}} \\wedge \\overline{E_{\\mathrm{valid}}}]</span>, it suffices to analyze the probability of <span class="math">E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.7.</strong> $\\operatorname{Pr}[E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}] \\leq \\frac{(2b + 1) \\log m + 2k^*}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">[\\mathbf{z}_i := (\\vec{\\mathbf{r}}_i, \\hat{\\mathbf{v}}_i, \\mathbf{y}_i)]_{i=1}^{k^<em>}</span> and <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^</em>}</span> denote the input instances and the extracted witness vectors, respectively. For every <span class="math">i \\in [k^<em>]</span>, let <span class="math">p_i(\\vec{\\mathbf{x}})</span> denote the multilinear polynomial specified in Eq. (17), with respect to <span class="math">\\vec{\\mathbf{f}}_i</span>. Let <span class="math">\\psi&#x27; := ([\\alpha_i&#x27;, \\mu_i&#x27;]_{i=1}^{k^</em>}, \\vec{\\beta}&#x27;, \\vec{\\mathbf{r}}_o&#x27;)</span> be the input randomness used in the last call <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^*}(\\mathsf{inst}, \\psi&#x27;)</span>, namely on line 4 of the extractor. Define polynomial <span class="math">h</span> as</p>

    <div class="my-4 text-center"><span class="math-block">h \\left(\\left[ X _ {i}, Y _ {i} \\right] _ {i = 1} ^ {k ^ {*}}\\right) := \\sum_ {i = 1} ^ {k ^ {*}} \\left(\\hat {\\mathbf {v}} _ {i} - \\operatorname {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}} _ {i})\\right) \\cdot X _ {i} + \\sum_ {i = 1} ^ {k ^ {*}} p _ {i} (\\vec {\\beta}) \\cdot Y _ {i}. \\tag {25}</span></div>

    <p class="text-gray-300">We define the following events:</p>

    <div class="my-4 text-center"><span class="math-block">E _ {1} := E _ {\\text {e x t}} \\wedge (\\exists i \\in [ k ^ {*} ]: p _ {i} (\\vec {\\mathbf {x}}) \\neq 0) \\wedge \\left(p _ {i} (\\vec {\\beta}) = 0 \\forall i \\in [ k ^ {*} ]\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">E _ {2} := E _ {\\text {e x t}} \\wedge \\left(h \\left(\\left[ \\alpha_ {i} ^ {\\prime}, \\mu_ {i} ^ {\\prime} \\right] _ {i = 1} ^ {k ^ {*}}\\right) = 0\\right) \\wedge \\left(\\exists i \\in [ k ^ {*} ]: \\left(\\mathsf {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}} _ {i}) \\neq \\hat {\\mathbf {v}} _ {i}\\right) \\vee \\left(p _ {i} (\\vec {\\beta}) \\neq 0\\right)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">E _ {3} := E _ {\\text {e v a l}} \\wedge \\left(h \\left(\\left[ \\alpha_ {i} ^ {\\prime}, \\mu_ {i} ^ {\\prime} \\right] _ {i = 1} ^ {k ^ {*}}\\right) \\neq 0\\right)</span></div>

    <p class="text-gray-300">Intuitively, we "split" the event <span class="math">E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}</span> into three parts <span class="math">E_1, E_2, E_3</span>, so that we can reduce <span class="math">\\operatorname<em>{Pr}[E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}]</span> to the probability of breaking sumcheck soundness. In particular, <span class="math">E_3</span> implies that the reduced evaluation claim holds (i.e., <span class="math">E_{\\mathrm{eval}}</span> holds), while the sumcheck claim is false (i.e., <span class="math">h([\\alpha_i&#x27;, \\mu_i&#x27;]_{i=1}^{k^</em>}) \\neq 0</span>).</p>

    <p class="text-gray-300">We first show that <span class="math">(E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}) \\Rightarrow (E_1 \\vee E_2 \\vee E_3)</span>. Note that <span class="math">E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}</span> implies that <span class="math">E_{\\mathrm{ext}}</span> occurs and <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^*}</span> are well-defined. Moreover, if <span class="math">E_1</span> doesn't occur, then <span class="math">\\overline{E_1} \\wedge E_{\\mathrm{bad}}</span> occurs, that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\exists i \\in [ k ^ {*} ]: \\left(\\mathsf {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}} _ {i}) \\neq \\hat {\\mathbf {v}} _ {i}\\right) \\vee (p _ {i} (\\vec {\\beta}) \\neq 0),</span></div>

    <p class="text-gray-300">which implies that <span class="math">E_2 \\vee E_3</span> occurs. Thus, <span class="math">(E_{\\mathrm{eval}} \\wedge E_{\\mathrm{bad}}) \\Rightarrow (E_1 \\vee E_2 \\vee E_3)</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ E _ {\\text {e v a l}} \\wedge E _ {\\text {b a d}} \\right] \\leq \\Pr \\left[ E _ {1} \\vee E _ {2} \\vee E _ {3} \\right] \\leq \\Pr \\left[ E _ {1} \\right] + \\Pr \\left[ E _ {2} \\right] + \\Pr \\left[ E _ {3} \\right]. \\tag {26}</span></div>

    <p class="text-gray-300">Now, it suffices to bound the probabilities <span class="math">\\operatorname<em>{Pr}[E_1],\\operatorname</em>{Pr}[E_2],\\operatorname*{Pr}[E_3]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 3.</strong> $\\operatorname*{Pr}[E_1] \\leq \\log m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Consider a mental experiment <span class="math">\\mathsf{Exp}_1</span> that simulates <span class="math">\\mathsf{Ext}^{A,\\mathsf{P}^*}</span> until Step 3. <span class="math">\\mathsf{Exp}_1</span> outputs 1 if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\exists i \\in [ k ^ {*} ]: p _ {i} (\\vec {\\mathbf {x}}) \\neq 0\\right) \\wedge \\left(p _ {i} (\\vec {\\beta}) = 0 \\forall i \\in [ k ^ {*} ]\\right)</span></div>

    <p class="text-gray-300">where <span class="math">[p_i(\\vec{\\mathbf{x}})]_{i=1}^{k^<em>}</span> are derived from <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^</em>}</span> output by <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^<em>}(\\mathsf{inst}, \\psi)</span>. It is clear that <span class="math">\\operatorname</em>{Pr}[\\mathsf{Exp}_1 = 1] \\geq \\operatorname<em>{Pr}[E_1]</span>. Moreover, let <span class="math">i^</em> \\in [k^<em>]</span> be the first index such that <span class="math">p_{i^</em>}(\\vec{\\mathbf{x}}) \\neq 0</span>. Since</p>

    <p class="text-gray-300">36</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^<em>}</span> in <span class="math">\\mathsf{Exp}_1</span> is independent of <span class="math">\\psi&#x27;</span>, by the Generalized Schwartz Lemma (Lemma 2.4), the probability that <span class="math">p_{i^</em>}(\\vec{\\beta&#x27;}) = 0</span> is at most $\\frac{\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (over the randomness </span>\\vec{\\beta'}<span class="math">). Thus </span>\\operatorname<em>{Pr}[E_1] \\leq \\operatorname</em>{Pr}[\\mathsf{Exp}_1 = 1] \\leq \\frac{\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 4. $\\operatorname<em>{Pr}[E_2] \\leq 2k^</em> /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Consider a mental experiment <span class="math">\\mathsf{Exp}_2</span> that that simulates <span class="math">\\mathsf{Ext}^{A,\\mathsf{P}^*}</span> until Step 3. <span class="math">\\mathsf{Exp}_2</span> outputs 1 if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\left(h \\left(\\left[ \\alpha_ {i} ^ {\\prime}, \\mu_ {i} ^ {\\prime} \\right] _ {i = 1} ^ {k ^ {*}}\\right) = 0\\right) \\wedge \\left(\\exists i \\in [ k ^ {*} ]: \\left(\\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}} _ {i}) \\neq \\hat {\\mathbf {v}} _ {i}\\right) \\vee (p _ {i} (\\vec {\\beta} ^ {\\prime}) \\neq 0)\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">h</span> is specified in Eq. (25), and <span class="math">[p_i(\\vec{\\mathbf{x}})]_{i=1}^{k^<em>}</span> are defined given the witness <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^</em>}</span> derived from <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^<em>}(\\mathsf{inst}, \\psi)</span>. It is clear that <span class="math">\\operatorname</em>{Pr}[\\mathsf{Exp}_2 = 1] \\geq \\operatorname<em>{Pr}[E_2]</span>. Moreover, since <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^</em>}</span> in <span class="math">\\mathsf{Exp}_2</span> is independent of <span class="math">\\psi&#x27;</span>, by the Generalized Schwartz Lemma (Lemma 2.4), the probability that <span class="math">h([\\alpha_i&#x27;, \\mu_i&#x27;]_{i=1}^{k^<em>}) = 0</span> is at most $\\frac{2k^</em>}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (over the choice of </span>[\\alpha_i', \\mu_i']_{i=1}^{k^<em>}<span class="math">). Thus </span>\\operatorname</em>{Pr}[E_2] \\leq \\operatorname<em>{Pr}[\\mathsf{Exp}_2 = 1] \\leq \\frac{2k^</em>}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 5. $\\operatorname*{Pr}[E_3] \\leq 2b\\log m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Consider a mental experiment <span class="math">\\mathsf{Exp}_3</span> that simulates <span class="math">\\mathsf{Ext}^{A,\\mathsf{P}^<em>}</span> until Step 3. Additionally, it simulates <span class="math">\\mathsf{P}^</em>(\\mathsf{inst}, \\bot, \\psi&#x27;)</span> to obtain claimed evaluations <span class="math">\\{\\theta_j&#x27;\\}</span> in the partial transcript without providing folding challenges. <span class="math">\\mathsf{Exp}_3</span> outputs 1 if and only if the verification at Step 4 passes and</p>

    <div class="my-4 text-center"><span class="math-block">\\left(h \\left(\\left[ \\alpha_ {i} ^ {\\prime}, \\mu_ {i} ^ {\\prime} \\right] _ {i = 1} ^ {k ^ {*}}\\right) \\neq 0\\right) \\wedge \\left(\\forall i \\in [ k ^ {*} ]: \\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] \\left(\\vec {\\mathbf {r}} _ {o} ^ {\\prime}\\right) = \\theta_ {i} ^ {\\prime}\\right),</span></div>

    <p class="text-gray-300">where <span class="math">h</span> is specified in Eq. (25) and <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^<em>}</span> are obtained from <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^</em>}(\\mathsf{inst}, \\psi)</span>.</p>

    <p class="text-gray-300">We show that <span class="math">\\operatorname<em>{Pr}[\\mathsf{Exp}_3 = 1] \\geq \\operatorname</em>{Pr}[E_3]</span>. Recall that <span class="math">E_3</span> implies that <span class="math">E_{\\mathrm{ext}}</span> occurs, which implies that <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^<em>}</span> computed from <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^</em>}(\\mathsf{inst}, \\psi)</span> is identical to that from <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^<em>}(\\mathsf{inst}, \\psi&#x27;)</span>. Moreover, <span class="math">E_3</span> implies that <span class="math">E_{\\mathrm{eval}}</span> occurs, i.e., the evaluation check in the execution <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^</em>}(\\mathsf{inst}, \\psi&#x27;)</span> passes. Since the witness <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{k^<em>}</span> extracted from <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^</em>}(\\mathsf{inst}, \\psi&#x27;)</span> is the same as that from <span class="math">\\mathsf{SubExt}^{\\mathsf{P}^<em>}(\\mathsf{inst}, \\psi)</span>, we have that <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_o&#x27;">\\tilde{\\mathbf{f}}_i\\right</a> = \\theta_i&#x27;</span> for all <span class="math">i \\in [k^</em>]</span>. Therefore, with the same randomness, if <span class="math">E_3</span> happens, then <span class="math">\\mathsf{Exp}_3</span> will output 1. Thus <span class="math">\\operatorname<em>{Pr}[\\mathsf{Exp}_3 = 1] \\geq \\operatorname</em>{Pr}[E_3]</span>.</p>

    <p class="text-gray-300">Now, it suffices to bound <span class="math">\\operatorname<em>{Pr}[\\mathsf{Exp}_3 = 1]</span>. For every <span class="math">i\\in [k^</em> ]</span>, we define <span class="math">p_i(\\vec{\\mathbf{x}})</span> from <span class="math">\\vec{\\mathbf{f}}_i</span> according to Eq. (17). We can rewrite <span class="math">p_i(\\vec{\\beta}&#x27;)</span> as</p>

    <div class="my-4 text-center"><span class="math-block">p _ {i} \\left(\\vec {\\beta} ^ {\\prime}\\right) = \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} e q \\left(\\vec {\\beta} ^ {\\prime}, \\vec {\\mathbf {b}}\\right) \\cdot \\prod_ {j = 1 - b} ^ {b - 1} \\left(\\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {b}}) - j\\right) = \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} g _ {2, i} (\\vec {\\mathbf {b}}), \\tag {27}</span></div>

    <p class="text-gray-300">where <span class="math">g_{2,i}</span> is specified in Eq. (16). Similarly, we can rewrite <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_i">\\tilde{\\mathbf{f}}_i\\right</a></span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}} _ {i}) = \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} e q (\\vec {\\mathbf {r}} _ {i}, \\vec {\\mathbf {b}}) \\cdot \\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {b}}) = \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} g _ {1, i} (\\vec {\\mathbf {b}}), \\tag {28}</span></div>

    <p class="text-gray-300">where <span class="math">g_{1,i}</span> is specified in Eq. (15). Recall that <span class="math">g</span> in Eq. (14) is defined as</p>

    <p class="text-gray-300"><span class="math">g(\\vec{\\mathbf{b}}):=\\sum_{i=1}^{k^{*}}\\left[\\alpha_{i}^{\\prime}g_{1,i}(\\vec{\\mathbf{b}})+\\mu_{i}^{\\prime}g_{2,i}(\\vec{\\mathbf{b}})\\right]\\,.</span></p>

    <p class="text-gray-300">By plugging-in Eq. (27) and Eq. (28), we have that</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\vec{\\mathbf{b}}\\in\\{0,1\\}^{\\log m}}g(\\vec{\\mathbf{b}})=\\sum_{i=1}^{k^{<em>}}\\alpha_{i}^{\\prime}\\cdot\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{i}">\\hat{\\mathbf{f}}_{i}\\right</a>+\\sum_{i=1}^{k^{</em>}}\\mu_{i}^{\\prime}\\cdot p_{i}(\\vec{\\beta}^{\\prime})\\,.</span> (29)</p>

    <p class="text-gray-300">Therefore, the sumcheck statement</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\vec{\\mathbf{b}}\\in\\{0,1\\}^{\\log m}}g(\\vec{\\mathbf{b}})=\\sum_{i=1}^{k^{*}}\\alpha_{i}\\hat{\\mathbf{v}}_{i}</span></p>

    <p class="text-gray-300">holds if and only if <span class="math">h([\\alpha_{i}^{\\prime},\\mu_{i}^{\\prime}]_{i=1}^{k^{<em>}})=0</span>. Recall that <span class="math">\\mathsf{Exp}_{3}=1</span> implies that <span class="math">h([\\alpha_{i}^{\\prime},\\mu_{i}^{\\prime}]_{i=1}^{k^{</em>}})\\neq 0</span>, i.e., the sumcheck statement does not hold. Meanwhile, note that the random evaluation statement for <span class="math">g</span> holds because</p>

    <p class="text-gray-300"><span class="math">\\forall i\\in[k^{*}]~{}:~{}\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{o}^{\\prime}">\\hat{\\mathbf{f}}_{i}\\right</a>=\\theta_{i}^{\\prime}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and the verification at Step 4 passes. By the Generalized Sum-Check Theorem (Lemma 2.5), $\\Pr[E_{3}]\\leq\\Pr[\\mathsf{Exp}_{3}]\\leq 2b\\log m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (over the randomness of </span>\\vec{\\mathbf{r}}_{o}^{\\prime}$). ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In summary, we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[E_{\\mathsf{eval}}\\wedge E_{\\mathsf{bad}}]\\leq\\Pr[E_{1}]+\\Pr[E_{2}]+\\Pr[E_{3}]\\leq\\frac{\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{2k^{*}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{2b\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which finishes the proof of Lemma 3.7. ∎</p>

    <p class="text-gray-300">Thus, the success probability of the extractor is at least</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[E_{\\mathsf{ext}}\\wedge E_{\\mathsf{valid}}]\\geq\\epsilon_{\\mathsf{fold}}(\\mathcal{A},\\mathsf{P}^{<em>})-\\frac{k^{</em>}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\epsilon_{\\mathsf{bind}}-\\frac{(2b+1)\\log m+2k^{*}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which finishes the proof of Theorem 3.3. ∎</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 3.3.</h6>

    <p class="text-gray-300">Theorem 3.3 is applicable only when <span class="math">\\Pi_{\\mathsf{fold}}</span> is instantiated as an interactive protocol. In practice, <span class="math">\\Pi_{\\mathsf{fold}}</span> can be converted into a non-interactive protocol using the Fiat-Shamir transform. The knowledge analysis of the Fiat-Shamir transformed version of <span class="math">\\Pi_{\\mathsf{fold}}</span> is left as future work.</p>

    <p class="text-gray-300">39</p>

    <h2 id="sec-37" class="text-2xl font-bold">3.3 Supporting Small Prime Modulus</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the protocol <span class="math">\\Pi_{\\mathrm{fold}}</span> (Figure 3), if <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span>, the size of the strong sampling set <span class="math">\\mathcal{C} \\coloneqq \\mathbb{Z}_q</span> is only <span class="math">q</span>. This is the best we can hope for: Assume for contradiction that exists <span class="math">\\mathcal{C}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; q<span class="math">, by the pigeonhole principle, there exist two elements </span>\\mathbf{a}, \\mathbf{b}<span class="math"> in </span>\\mathcal{C} \\subseteq \\mathcal{R}_q \\cong \\mathbb{Z}_q^d<span class="math"> that share the same value at the 1st slot of their NTT representation. Hence the 1st slot of </span>\\mathsf{NTT}(\\mathbf{a} - \\mathbf{b})<span class="math"> is zero, and </span>\\mathbf{a} - \\mathbf{b}<span class="math"> is a zero-divisor as </span>\\mathbf{c} \\cdot (\\mathbf{a} - \\mathbf{b}) = 0<span class="math"> for the element </span>\\mathbf{c} \\neq 0<span class="math"> whose NTT representation is </span>(1, 0, \\dots, 0)<span class="math">. This contradicts with the fact that </span>\\mathcal{C}$ is a sampling set.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To achieve 128-bit security, we need to use at least a 128-bit prime modulus in <span class="math">\\Pi_{\\mathrm{fold}}</span>. In practice, however, it would be significantly more efficient to use a smaller modulus, say a 32-bit prime, which is a good fit for GPUs that operate on 32-bit data types, or for CPUs that operate on 32 or 64-bit integer types.</p>

    <p class="text-gray-300">In this section, we describe an optimization that extends <span class="math">\\Pi_{\\mathrm{fold}}</span> to support a small prime modulus <span class="math">q</span>. The key idea is to use <span class="math">q</span> where <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^t</span> for some <span class="math">\\tau &amp;gt; 1</span> such that <span class="math">q^\\tau \\approx 2^{128}</span>. Here <span class="math">\\mathbb{F}_{q^\\tau}</span> is an extension field of <span class="math">\\mathbb{F}_q</span>. We note, however, that <span class="math">q</span> cannot be too small since we must preserve the hardness of the MSIS problem.</p>

    <p class="text-gray-300">Let <span class="math">t \\in \\mathbb{N}</span> be a divisor of <span class="math">d</span> and denote <span class="math">\\tau \\coloneqq d / t</span>. Let <span class="math">q</span> be a prime such that <span class="math">q \\equiv 1 + 2t \\pmod{4t}</span> and <span class="math">q^{\\tau} \\approx 2^{128}</span>. Recall from Section 2 that we have <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^t</span> via the NTT isomorphism. Thus we can rewrite the commitment opening relation <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span> (Eq. (8)) as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {c m}} ^ {\\tau , B} := \\left\\{\\left(\\mathsf {p p}, \\mathsf {c m} \\in \\mathcal {R} _ {q} ^ {\\kappa}; \\vec {\\mathbf {f}} \\in \\mathcal {R} _ {q} ^ {m}\\right): \\begin{array}{c} (\\mathsf {c m} = \\mathbf {A} \\vec {\\mathbf {f}}) \\wedge \\\\ \\forall j \\in [ \\tau ]: \\\\ \\left(\\hat {\\mathbf {f}} _ {j} \\circ \\left[ \\bigcirc_ {i = 1} ^ {B - 1} (\\hat {\\mathbf {f}} _ {j} - \\hat {i}) \\circ (\\hat {\\mathbf {f}} _ {j} + \\hat {i}) \\right] = \\hat {0}\\right) \\end{array} \\right\\},</span></div>

    <p class="text-gray-300">here <span class="math">\\hat{\\mathbf{f}}\\coloneqq (\\hat{\\mathbf{f}}_1,\\dots ,\\hat{\\mathbf{f}}_\\tau)\\in \\mathcal{R}_q^{m\\times \\tau}</span> is the vector such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {N T T} (\\hat {\\mathbf {f}}) := \\left(\\mathsf {N T T} \\left(\\hat {\\mathbf {f}} _ {1}\\right), \\dots , \\mathsf {N T T} \\left(\\hat {\\mathbf {f}} _ {\\tau}\\right)\\right) \\in \\mathbb {F} _ {q ^ {\\tau}} ^ {m \\times d}</span></div>

    <p class="text-gray-300">equals the coefficient embedding matrix of <span class="math">\\vec{\\mathbf{f}}</span> (which is in <span class="math">\\mathbb{Z}_q^{m\\times d}</span>), that is, <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}}) = \\mathsf{Coef}(\\vec{\\mathbf{f}})</span>. Given <span class="math">\\mathcal{R}_{\\mathrm{cm}}^{\\tau ,B}</span>, we can similarly generalize the expanded commitment opening relation <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> (Eq. (9)) to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^{\\tau ,B}</span> defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {e v a l}} ^ {\\tau , B} := \\left\\{\\left(\\mathsf {p p}, \\left(\\vec {\\mathbf {r}}, \\left[ \\hat {\\mathbf {v}} _ {j} \\right] _ {j = 1} ^ {\\tau}, \\mathsf {c m}\\right) \\in \\mathcal {R} _ {q} ^ {\\log m} \\times \\mathcal {R} _ {q} ^ {\\tau} \\times \\mathcal {R} _ {q} ^ {\\kappa}; \\vec {\\mathbf {f}} \\in \\mathcal {R} _ {q} ^ {m}\\right): \\begin{array}{c} \\left(\\mathsf {p p}, \\mathsf {c m}; \\vec {\\mathbf {f}}\\right) \\in \\mathcal {R} _ {\\mathsf {c m}} ^ {B} \\wedge \\\\ \\left(\\forall j \\in [ \\tau ]: \\mathsf {m l e} \\left[ \\hat {\\mathbf {f}} _ {j} \\right] (\\vec {\\mathbf {r}}) = \\hat {\\mathbf {v}} _ {j}\\right) \\end{array} \\right\\}, \\tag {30}</span></div>

    <p class="text-gray-300">The reduction of knowledge from <span class="math">(\\mathcal{R}_{\\mathrm{eval}}^{\\tau ,b})^{2k}</span> to <span class="math">\\mathcal{R}_{\\mathrm{eval}}^{\\tau ,B}</span> is almost identical to <span class="math">\\Pi_{\\mathrm{fold}}</span> (Figure 3) except for 2 modifications below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We define the challenge space <span class="math">\\mathcal{C} \\subseteq \\mathcal{R}_q</span> as the set of elements whose NTT representation equals <span class="math">i</span> multiplying the identity vector <span class="math">I_t := (1, \\ldots, 1) \\in \\mathbb{F}_{q^\\tau}^t</span> (where <span class="math">i</span> is enumerated over <span class="math">\\mathbb{F}_{q^\\tau}</span>), that is,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {C} := \\left\\{\\mathbf {a} _ {i} \\in \\mathcal {R} _ {q}: \\mathrm {N T T} \\left(\\mathbf {a} _ {i}\\right) = i \\cdot I _ {t} \\right\\} _ {i \\in \\mathbb {F} _ {q ^ {\\tau}}}. \\tag {31}</span></div>

    <p class="text-gray-300">This ensures that <span class="math">\\mathcal{C}</span> is a strong sampling set with size <span class="math">q^{\\tau} \\approx 2^{128}</span>, because the difference of any two distinct elements in <span class="math">\\mathcal{C}</span> maps to <span class="math">a \\cdot I_t</span> for some <span class="math">a</span> in <span class="math">\\mathbb{F}_{q^{\\tau}}^{\\times}</span> through the NTT isomorphism, which has inverse <span class="math">a^{-1} \\cdot I_t</span>. Thus we can achieve 128-bit security even if <span class="math">q</span> is significantly smaller than <span class="math">2^{128}</span> (given <span class="math">\\tau</span> is large enough so that <span class="math">q^{\\tau} \\approx 2^{128}</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We argue that all proofs in Section 3.2 will still be valid. Let <span class="math">[\\rho_i]_{i=1}^{2k}</span> be the last folding challenges (in Figure 3). For every <span class="math">i \\in [2k]</span>, let <span class="math">\\Theta_i := [\\theta_{i,j}]_{j=1}^{\\tau} \\in \\mathcal{R}_q^\\tau</span> where <span class="math">\\{\\theta_{i,j} \\in \\mathcal{R}_q\\}</span> are the claimed evaluations in the protocol execution. We denote by <span class="math">\\mathsf{NTT}(\\Theta_i) := (\\mathsf{NTT}(\\theta_{i,1}), \\ldots, \\mathsf{NTT}(\\theta_{i,\\tau})) \\in \\mathbb{F}_{q^\\tau}^d</span>. The folding verifier computes <span class="math">\\hat{V}_o := [\\hat{\\mathbf{v}}_{o,j}]_{j=1}^{\\tau} \\in \\mathcal{R}_q^\\tau</span> such that <span class="math">\\mathsf{NTT}(\\hat{V}_o) \\in \\mathbb{F}_{q^\\tau}^d</span> satisfies that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NTT}(\\hat{V}_o) = \\sum_{i=1}^{2k} \\operatorname{RotSum}(\\rho_i, \\mathsf{NTT}(\\Theta_i)) \\tag{32}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{RotSum}</span> is defined in Lemma 2.1. Therefore, by Lemma A.1, we can extend Lemma 3.2 to the case where <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span> and the folding verifier can still verify the folding proof. Moreover, by the 3rd claim in Lemma 2.1, we can extend Eq. (24) to a more general setting where <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span>. In this setting, the single linear equation (over <span class="math">\\mathcal{R}_q</span>) in Eq. (24) is extended to <span class="math">\\tau</span> linear equations. Given this extension, all proofs in Section 3.2 naturally follow.</p>

    <p class="text-gray-300">In this section, we construct a folding scheme for customizable constraint systems (CCS) as introduced in [STW23a]. CCS is a generalization of Rank-1 Constraint Systems (R1CS) that supports high-degree custom gates, enabling better expressiveness and applicability. As discussed at the beginning of Section 3, this folding scheme enables us to build IVC/PCD from Ajtai commitments. Our approach is highly modular and generic. We begin by adapting the definition of customizable constraint systems [STW23a] to the ring setting.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 4.1 (CCS over rings).</strong> Let <span class="math">\\mathsf{pp} := (n_r, n_c, t, n_s, \\deg, \\ell_{\\mathsf{in}})</span> be the integer public parameters² and let <span class="math">\\bar{\\mathcal{R}}</span> be an arbitrary ring. Let <span class="math">\\mathbb{I}</span> be an index that consists of (i) <span class="math">t</span> matrices <span class="math">M_1, \\ldots, M_t \\in \\bar{\\mathcal{R}}^{n_r \\times n_c}</span> with <span class="math">O(n_r + n_c)</span> non-zero entries; (ii) <span class="math">n_s</span> multisets <span class="math">S_1, \\ldots, S_{n_s} \\subseteq [t]</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\deg<span class="math"> for all </span>i \\in [n_s]<span class="math">; and (iii) </span>n_s<span class="math"> scalars </span>c_1, \\ldots, c_{n_s} \\in \\bar{\\mathcal{R}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote by <span class="math">\\mathsf{pp}_{\\mathsf{ccs}} := (\\mathsf{pp}, \\mathbb{I})</span> the index-specific parameters. Given a tuple <span class="math">(\\mathsf{pp}_{\\mathsf{ccs}}, \\mathbb{x} \\in \\bar{\\mathcal{R}}^{\\ell_{\\mathsf{in}}}; \\mathbb{w} \\in \\bar{\\mathcal{R}}^{n_c - \\ell_{\\mathsf{in}} - 1})</span> and let <span class="math">\\vec{\\mathbf{x}} := (\\mathbb{x}, 1, \\mathbb{w}) \\in \\bar{\\mathcal{R}}^{n_c}</span>. We say <span class="math">(\\mathsf{pp}_{\\mathsf{ccs}}, \\mathbb{x}; \\mathbb{w})</span> is in the relation <span class="math">\\mathcal{R}_{\\mathsf{ccs}}</span> (over ring <span class="math">\\bar{\\mathcal{R}}</span>) if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{n_s} c_i \\cdot \\bigcirc_{j \\in S_i} (M_j \\cdot \\vec{\\mathbf{x}}) = 0^{n_r} \\tag{33}</span></div>

    <p class="text-gray-300">²Informally, <span class="math">n_r</span> denotes the number of constraints, <span class="math">n_c</span> denotes the extended witness size and <span class="math">\\deg</span> is the custom gate degree.</p>

    <p class="text-gray-300">Here <span class="math">\\bigcirc</span> denotes the Hadamard product between vectors. And 0 (and 1) is the additive (and multiplicative) identity in <span class="math">\\bar{\\mathcal{R}}</span> respectively.</p>

    <p class="text-gray-300"><strong>Remark 4.1 (Packing multiple CCS field constraints).</strong> If the ring <span class="math">\\bar{\\mathcal{R}}</span> is isomorphic to <span class="math">\\mathbb{F}^k</span> for a field <span class="math">\\mathbb{F}</span>, we can pack <span class="math">k</span> instance-witness pairs for the CCS relation over <span class="math">\\mathbb{F}</span> into a single instance-witness pair for the CCS relation over <span class="math">\\bar{\\mathcal{R}}</span>. More precisely, a set of <span class="math">k</span> tuples <span class="math">((\\mathsf{pp},\\mathbb{I}_i),\\mathbb{z}_i,\\mathbb{w}_i)_{i=1}^k</span>, are all in the relation <span class="math">\\mathcal{R}_{\\mathsf{ccs}}</span> over <span class="math">\\mathbb{F}</span> if and only if the transformed tuple <span class="math">((\\mathsf{pp},\\mathbb{I}^<em>),\\mathbb{z}^</em>,\\mathbb{w}^<em>)</span> is in the relation <span class="math">\\mathcal{R}_{\\mathsf{ccs}}</span> over <span class="math">\\bar{\\mathcal{R}}</span>. Each entry <span class="math">\\mathbf{e} \\in \\bar{\\mathcal{R}}</span> in <span class="math">(\\mathbb{I}^</em>,\\mathbb{z}^<em>,\\mathbb{w}^</em>)</span> is set such that <span class="math">\\mathsf{NTT}(\\mathbf{e}) = (e_1,\\ldots ,e_k)</span>, where <span class="math">e_i \\in \\mathbb{F}</span> is the corresponding entry in <span class="math">(\\mathbb{I}_i,\\mathbb{z}_i,\\mathbb{w}_i)</span> for <span class="math">1 \\leq i \\leq k</span>.</p>

    <h2 id="sec-39" class="text-2xl font-bold">4.1 Lattice-based Committed CCS</h2>

    <p class="text-gray-300">Next, we introduce the lattice-based committed CCS relation <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> that extends the commitment opening relation <span class="math">\\mathcal{R}_{\\mathsf{cm}}^B</span> in Eq. (8) to the CCS setting. A folding scheme for <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> would allow us to build an IVC/PCD scheme.</p>

    <p class="text-gray-300">Intuitively, a witness of the committed CCS relation consists of a pair <span class="math">(\\vec{\\mathbf{f}},\\vec{\\mathbf{w}})</span>, and the relation checks that (i) <span class="math">\\vec{\\mathbf{w}}</span> is a valid witness for the CCS instance <span class="math">\\mathbb{z}_{\\mathrm{ccs}}</span>, (ii) <span class="math">\\vec{\\mathbf{f}}</span> is a low-norm opening of the Ajtai commitment <span class="math">\\mathsf{cm}</span>, and (iii) <span class="math">\\vec{\\mathbf{f}}</span> is the gadget decomposition of the witness <span class="math">\\vec{\\mathbf{w}}</span>, meaning <span class="math">\\vec{\\mathbf{w}} = \\mathbf{G} \\times \\vec{\\mathbf{f}}</span> for the gadget <span class="math">\\mathbf{G}</span>. We formally define the relation below.</p>

    <p class="text-gray-300"><strong>Definition 4.2 (Lattice-based committed CCS relation).</strong> Let <span class="math">\\mathcal{R}_q\\coloneqq \\mathbb{Z}_q[X] / (X^d +1)</span> where <span class="math">q</span> is a prime and <span class="math">d</span> is a power of two. Let <span class="math">\\mathsf{pp}\\coloneqq (\\mathsf{pp}_{\\mathsf{cm}},\\mathsf{pp}_{\\mathsf{ccs}})</span> be the public parameters where <span class="math">\\mathsf{pp}_{\\mathsf{cm}} = (\\kappa ,m,B &amp;lt; q / 2,\\mathbf{A})</span> is the public parameter for <span class="math">\\mathcal{R}_{\\mathsf{cm}}^B</span> (Eq. (8)) and <span class="math">\\mathsf{pp}_{\\mathsf{ccs}} = (n_r,n_c,t,n_s,\\deg ,\\ell_{\\mathsf{in}},\\mathbb{I})</span> (defined in Definition 4.1) is for <span class="math">\\mathcal{R}_{\\mathsf{ccs}}</span> (over <span class="math">\\mathcal{R}_q</span>).</p>

    <p class="text-gray-300">Set <span class="math">\\ell := m / n_c \\in \\mathbb{N}</span> such that <span class="math">B^\\ell \\geq q / 2</span>. Let <span class="math">\\mathbf{G} := \\mathbf{I}_{n_c} \\otimes [1, B, \\ldots, B^{\\ell - 1}] \\in \\mathbb{Z}_q^{n_c \\times m}</span> be the gadget matrix. The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{cmccs}}^B</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {c m c c s}} ^ {B} := \\left\\{ \\begin{array}{c} \\left(\\mathsf {p p}, \\mathbb {z} := (\\mathsf {c m} \\in \\mathcal {R} _ {q} ^ {\\kappa}, \\mathbb {z} _ {\\mathsf {c c s}} \\in \\mathcal {R} _ {q} ^ {\\ell_ {\\mathsf {i n}}}); \\mathbb {w} := (\\vec {\\mathbf {f}} \\in \\mathcal {R} _ {q} ^ {m}, \\mathbb {w} _ {\\mathsf {c c s}} \\in \\mathcal {R} _ {q} ^ {n - \\ell_ {\\mathsf {i n}} - 1})\\right) \\text {s . t .} \\\\ \\left(\\mathsf {p p} _ {\\mathsf {c m}}, \\mathsf {c m}; \\vec {\\mathbf {f}}\\right) \\in \\mathcal {R} _ {\\mathsf {c m}} ^ {B} \\wedge \\left(\\mathsf {p p} _ {\\mathsf {c c s}}, \\mathbb {z} _ {\\mathsf {c c s}}; \\mathbb {w} _ {\\mathsf {c c s}}\\right) \\in \\mathcal {R} _ {\\mathsf {c c s}} \\wedge \\left(\\mathbf {z} _ {\\mathsf {c c s}} = \\mathbf {G} \\times \\vec {\\mathbf {f}}\\right) \\end{array} \\right\\}, \\tag {33}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{z}_{\\mathrm{ccs}} := (\\mathbb{z}_{\\mathrm{ccs}}, 1, \\mathbb{w}_{\\mathrm{ccs}}) \\in \\mathcal{R}_q^{n_c}</span>.</p>

    <p class="text-gray-300"><strong>Remark 4.2.</strong> The constraint <span class="math">\\mathbf{z}_{\\mathrm{ccs}} = \\mathbf{G} \\times \\vec{\\mathbf{f}}</span> is used to capture that <span class="math">\\vec{\\mathbf{f}}</span> is the "base- <span class="math">B</span> " representation of the original witness <span class="math">\\mathbf{z}_{\\mathrm{ccs}}</span> in CCS. Crucially, consider a witness <span class="math">(\\vec{\\mathbf{f}}, \\mathbb{w}_{\\mathrm{ccs}})</span> for instance <span class="math">(\\mathsf{cm}, \\mathbb{z}_{\\mathrm{ccs}})</span>. We know that <span class="math">\\vec{\\mathbf{f}}</span> is a low-norm opening for the Ajtai binding commitment cm given that <span class="math">(\\mathsf{cm}, \\vec{\\mathbf{f}})</span> is in <span class="math">\\mathcal{R}_{\\mathsf{cm}}^B</span>. This implies that <span class="math">\\mathbb{w}_{\\mathrm{ccs}}</span> is also bound to cm because the equation <span class="math">(\\mathbb{z}_{\\mathrm{ccs}}, 1, \\mathbb{w}_{\\mathrm{ccs}}) = \\mathbf{G} \\times \\vec{\\mathbf{f}}</span> holds.</p>

    <p class="text-gray-300"><strong>Remark 4.3.</strong> We set <span class="math">(\\mathbb{z}_{\\mathrm{ccs}},1,\\mathbb{w}_{\\mathrm{ccs}}) = \\mathbf{G}\\times \\vec{\\mathbf{f}}</span> only for ease of exposition. Note that the integrity of <span class="math">\\mathbb{z}_{\\mathrm{ccs}}</span> is already guaranteed by the verifier checks. Thus it suffices to decompose <span class="math">\\mathbb{w}_{\\mathrm{ccs}}</span> to <span class="math">\\vec{\\mathbf{f}}</span> and check the statement <span class="math">\\mathbb{w}_{\\mathrm{ccs}} = \\mathbf{G}\\times \\vec{\\mathbf{f}}</span>.</p>

    <p class="text-gray-300">41</p>

    <p class="text-gray-300">The expanded relation. Similar to the paradigm in Section 3.1, to construct a folding scheme for <span class="math">\\mathcal{R}_{\\mathsf{comp}} := \\mathcal{R}_{\\mathsf{cmccs}}^B</span>, we introduce a new relation <span class="math">\\mathcal{R}_{\\mathsf{acc}} := \\mathcal{R}_{\\mathsf{evalccs}}^B</span> that augments <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> with a multilinear evaluation statement. Note that in <span class="math">\\mathcal{R}_{\\mathsf{evalccs}}^B</span>, we replace the high-degree custom gate relation <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> with a linearized relation <span class="math">\\mathcal{R}_{\\mathsf{lccs}}</span>. Like the linearization framework from Hypernova [KS23b], this adjustment is necessary because our folding scheme runs sum-checks to reduce the norm constraints and the high-degree custom gate constraints in <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> into linearized statements. Hence, we must modify the accumulated relation accordingly. Notably, <span class="math">\\mathcal{R}_{\\mathsf{evalccs}}^B</span> extends <span class="math">\\mathcal{R}_{\\mathsf{eval}}^B</span> from Eq. (9).</p>

    <p class="text-gray-300">Definition 4.3 (Lattice-based linearized CCS relation). Let <span class="math">\\mathsf{pp} := (\\mathsf{pp}_{\\mathsf{cm}}, \\mathsf{pp}_{\\mathsf{ccs}})</span> be the public parameters in Definition 4.2 where <span class="math">\\ell := m / n_c \\in \\mathbb{N}</span> and <span class="math">B^\\ell \\geq q / 2</span>. Without loss of generality, we assume that the number of rows <span class="math">n_r</span> in CCS matrices equals to the committed witness length <span class="math">m</span>.</p>

    <p class="text-gray-300">We define the linearized CCS relation <span class="math">\\mathcal{R}_{\\mathrm{lccs}}</span> as the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p p} _ {\\mathsf {c c s}}, \\mathbb {x} := (\\vec {\\mathbf {r}} \\in \\mathcal {R} _ {q} ^ {\\log m}, [ \\mathbf {u} _ {j} ] _ {j = 1} ^ {t} \\in \\mathcal {R} _ {q} ^ {t}, \\mathbb {x} _ {\\mathsf {c c s}} \\in \\mathcal {R} _ {q} ^ {\\ell_ {m}}, \\mathbf {h} \\in \\mathcal {R} _ {q}\\right); \\mathbb {w} := \\mathbb {w} _ {\\mathsf {c c s}} \\in \\mathcal {R} _ {q} ^ {n _ {c} - \\ell_ {m} - 1})</span></div>

    <p class="text-gray-300">such that for all <span class="math">j \\in [t]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} _ {j} = \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log n _ {c}}} \\operatorname {m l e} [ M _ {j} ] (\\vec {\\mathbf {r}}, \\vec {\\mathbf {b}}) \\cdot \\operatorname {m l e} [ \\mathbf {z} _ {\\mathrm {c c s}} ] (\\vec {\\mathbf {b}}). \\tag {34}</span></div>

    <p class="text-gray-300">Here <span class="math">\\mathsf{mle}[M_j] \\in \\mathcal{R}_q^{\\leq 1}[X_1, \\ldots, X_{\\log n_r + \\log n_c}]</span> and <span class="math">\\mathsf{mle}[\\mathbf{z}_{\\mathrm{ccs}}] \\in \\mathcal{R}_q^{\\leq 1}[X_1, \\ldots, X_{\\log n_c}]</span> are the multilinear extensions of matrix <span class="math">M_j \\in \\mathcal{R}_q^{n_r \\times n_c}</span> and <span class="math">\\mathbf{z}_{\\mathrm{ccs}} := (\\mathbb{w}_{\\mathrm{ccs}}, \\mathbf{h}, \\mathbb{x}_{\\mathrm{ccs}}) \\in \\mathcal{R}_q^{n_c}</span> respectively. <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {e v a l c c s}} ^ {B} := \\left\\{ \\begin{array}{c} \\left(\\mathsf {p p}, \\mathbb {x} := (\\vec {\\mathbf {r}}, \\mathsf {c m}, \\hat {\\mathbf {v}}, [ \\mathbf {u} _ {j} ] _ {j = 1} ^ {t}, \\mathbb {x} _ {\\mathsf {c c s}}, \\mathbf {h}); \\right. \\\\ \\left. \\quad \\mathbb {w} := (\\vec {\\mathbf {f}} \\in \\mathcal {R} _ {q} ^ {m}, \\mathbb {w} _ {\\mathsf {c c s}})\\right) \\text {s . t .} \\\\ \\left(\\mathbf {z} _ {\\mathsf {c c s}} = \\mathbf {G} \\vec {\\mathbf {f}}\\right) \\wedge \\left(\\mathsf {p p} _ {\\mathsf {c m}}, (\\mathsf {c m}, \\vec {\\mathbf {r}}, \\hat {\\mathbf {v}}); \\vec {\\mathbf {f}}\\right) \\in \\mathcal {R} _ {\\text {e v a l}} ^ {B} \\\\ \\wedge \\left(\\mathsf {p p} _ {\\mathsf {c c s}}, (\\vec {\\mathbf {r}}, [ \\mathbf {u} _ {j} ] _ {j = 1} ^ {t}, \\mathbb {x} _ {\\mathsf {c c s}}, \\mathbf {h}); \\mathbb {w} _ {\\mathsf {c c s}}\\right) \\in \\mathcal {R} _ {\\mathsf {l c c s}} \\end{array} \\right\\}, \\tag {35}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{G} \\coloneqq \\mathbf{I}_{n_c} \\otimes [1, B, \\ldots, B^{\\ell - 1}] \\in \\mathbb{Z}_q^{n_c \\times m}</span> and <span class="math">\\mathcal{R}_{\\mathrm{eval}}^B</span> is defined in Eq. (9).</p>

    <h2 id="sec-40" class="text-2xl font-bold">4.2 A Generic Folding Scheme for CCS</h2>

    <p class="text-gray-300">In this section, we construct a folding scheme for <span class="math">\\mathcal{R}_{\\mathrm{acc}} \\coloneqq \\mathcal{R}_{\\mathrm{evalccs}}^B</span> and <span class="math">\\mathcal{R}_{\\mathrm{comp}} \\coloneqq \\mathcal{R}_{\\mathrm{cmccs}}^B</span>, or equivalently, a reduction of knowledge (Definition 2.5) from <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B \\times \\mathcal{R}_{\\mathrm{cmccs}}^B</span> to <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>. The scheme is presented for modularity and illustration purposes. In Section 4.3, we introduce an optimized version with better efficiency.</p>

    <p class="text-gray-300">Similar to the strategy in Section 3.2, the construction consists of three steps.</p>

    <p class="text-gray-300">42</p>

    <p class="text-gray-300">1: Linearization. First, we reduce the relation <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{cmccs}}</span> to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span> via a protocol <span class="math">\\Pi_{\\mathsf{ccs}}</span> (Figure 5) that reduces <span class="math">\\mathcal{R}^{B}_{\\mathsf{cmccs}}</span> to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span>. The protocol <span class="math">\\Pi_{\\mathsf{ccs}}</span> runs a sum-check to reduce the high-degree custom gates check to a degree-1 check (e.g., a multilinear evaluation check). Similar to the expansion step in Section 3.2, the linearization step reduces to a linear relation with evaluation-like statements. 2: Decomposition. Next, using a protocol <span class="math">\\Pi_{\\mathsf{ccsdec}}</span> (Figure 6), we reduce the relation <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span> to a relation</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{R}^{b}_{\\mathsf{evalccs}})^{2k}:=\\underbrace{\\mathcal{R}^{b}_{\\mathsf{evalccs}}\\times\\cdots\\times\\mathcal{R}^{b}_{\\mathsf{evalccs}}}_{2k}</span></p>

    <p class="text-gray-300">where <span class="math">b,k</span> are chosen such that <span class="math">b^{k}=B</span>. We note that <span class="math">\\Pi_{\\mathsf{ccsdec}}</span> is an adaptation to <span class="math">\\Pi_{\\mathsf{dec}}</span> (Figure 2) with similar analysis. 3: Folding. Finally, we reduce <span class="math">(\\mathcal{R}^{b}_{\\mathsf{evalccs}})^{2k}</span> back to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span> using a protocol <span class="math">\\Pi_{\\mathsf{ccsfold}}</span> (Figure 7). Note that <span class="math">\\Pi_{\\mathsf{ccsfold}}</span> is an adaptation to <span class="math">\\Pi_{\\mathsf{fold}}</span> (Figure 3) with similar analysis.</p>

    <p class="text-gray-300">By the composition theorems for reductions of knowledge (Theorem 2.1, Theorem 2.2), the composed protocol <span class="math">\\Pi_{\\mathsf{mccsfold}}:=\\Pi_{\\mathsf{ccsfold}}\\circ\\Pi_{\\mathsf{ccsdec}}\\circ\\Pi_{\\mathsf{ccs}}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{cmccs}}</span> to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span> as desired. We formally state the result in Theorem 4.1.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Theorem 4.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{F}_{q^{\\tau}}^{d/\\tau}</span> for some <span class="math">\\tau\\in\\mathbb{N}</span> where <span class="math">\\tau\\mid d</span> and <span class="math">1/q^{\\tau}</span> is in <span class="math">\\mathsf{negl}(\\lambda)</span>. Let <span class="math">\\mathcal{C}_{\\mathsf{small}}\\subseteq\\mathcal{R}_{q}</span> be a strong sampling set for which $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is in </span>\\mathsf{negl}(\\lambda)<span class="math">, and the expansion factor </span>T:=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}\\leq c<span class="math"> (Definition 6) for some </span>c\\in\\mathbb{N}<span class="math">. Let </span>\\mathcal{C}<span class="math"> be the strong sampling set as in Eq. (31). Let </span>\\mathsf{pp}_{\\mathsf{cm}}:=(\\kappa,m,\\mathbf{A},B<q/2)<span class="math"> and </span>\\mathsf{pp}_{\\mathsf{ccs}}:=(n_{r}:=m,n_{c},t,n_{s},\\mathsf{deg},\\ell_{\\mathsf{in}},[M_{j}]_{j=1}^{t},[S_{i},c_{i}]_{i=1}^{n_{s}})<span class="math"> be the public parameters such that </span>B^{m/n_{c}}\\geq q/2<span class="math"> and </span>\\mathsf{MSIS}^{\\infty,q}_{\\kappa,m,\\mathsf{STB}}<span class="math"> is hard. Set </span>b,k<span class="math"> such that </span>2kc(b-1)<B<span class="math"> and </span>b^{k}=B<span class="math">. Let </span>\\Pi_{\\mathsf{ccs}}<span class="math">, </span>\\Pi_{\\mathsf{ccsdec}}<span class="math">, </span>\\Pi_{\\mathsf{ccsfold}}<span class="math"> be the protocols in Figure 5, Figure 6 and Figure 7, respectively. The composed protocol </span>\\Pi_{\\mathsf{mccsfold}}:=\\Pi_{\\mathsf{ccsfold}}\\circ\\Pi_{\\mathsf{ccsdec}}\\circ\\Pi_{\\mathsf{ccs}}<span class="math"> is a public-coin reduction of knowledge from relation </span>\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{cmccs}}<span class="math"> to </span>\\mathcal{R}^{B}_{\\mathsf{evalccs}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The protocol is public-coin as the three subprotocols are all public-coin. For the case where <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{Z}_{q}^{d}</span>, the Theorem follows from Lemma 4.1, Lemma 4.2, Theorem 4.2 and the knowledge composition theorems (Theorem 2.1 and Theorem 2.2). For the case where <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{F}_{q^{\\tau}}^{d/\\tau}</span>, the same optimization in Section 3.3 can be used to extend Theorem 4.1 to support small modulus <span class="math">q</span>. ∎</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">4.2.1 Linearization: The reduction from <span class="math">\\mathcal{R}^{B}_{\\mathsf{cmccs}}</span> to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span></h4>

    <p class="text-gray-300">By Theorem 2.2, to reduce from <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{cmccs}}</span> to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}\\times\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span>, it suffices to construct a protocol that reduces <span class="math">\\mathcal{R}^{B}_{\\mathsf{cmccs}}</span> (Eq. (33)) to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span> (Eq. (35)). We describe the</p>

    <p class="text-gray-300">Parameters: A strong sampling set  <span class="math">\\mathcal{C} \\coloneqq \\mathbb{Z}_q \\subseteq \\mathcal{R}_q</span>  (Definition 2.1)</p>

    <p class="text-gray-300">Input:  <span class="math">\\mathbb{X} := (\\mathsf{cm},\\mathbb{X}_{\\mathsf{ccs}})\\in \\mathcal{R}_q^\\kappa \\times \\mathcal{R}_q^{\\ell_{\\mathrm{in}}}</span>  and  <span class="math">\\mathbb{W} := (\\vec{\\mathbf{f}},\\mathbb{W}_{\\mathsf{ccs}})\\in \\mathcal{R}_q^m\\times \\mathcal{R}_q^{n_c - \\ell_{\\mathrm{in}} - 1}</span></p>

    <p class="text-gray-300">Output:  <span class="math">\\mathbb{X}_o\\coloneqq (\\vec{\\mathbf{r}}_o\\in \\mathcal{R}_q^{\\log m},\\hat{\\mathbf{v}}\\in \\mathcal{R}_q,\\mathsf{cm},[\\mathbf{u}_j\\in \\mathcal{R}_q]_{j = 1}^t,\\mathbb{X}_{\\mathsf{ccs}},1)</span>  and  <span class="math">\\mathbb{W}_o\\coloneqq (\\vec{\\mathbf{f}},\\mathbb{W}_{\\mathsf{ccs}})</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{X};\\mathbb{W}),\\mathsf{V}(\\mathsf{pp},\\mathbb{X})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}</span>  : V sends P a random vector  <span class="math">\\vec{\\beta}\\gets \\mathcal{C}^{\\log m}</span></li>

      <li><span class="math">\\mathsf{P} \\leftrightarrow \\mathsf{V}</span> : Let  <span class="math">\\mathbf{z}_{\\mathrm{ccs}} := (\\mathbb{x}_{\\mathrm{ccs}}, 1, \\mathbb{w}_{\\mathrm{ccs}})</span>  and let  <span class="math">\\deg</span>  denote the CCS gate degree, define the polynomial  <span class="math">g \\in \\mathcal{R}_q^{\\leq \\deg + 1}[X_1, \\ldots, X_{\\log m}]</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g (\\vec {\\mathbf {x}}) := e q (\\vec {\\beta}, \\vec {\\mathbf {x}}) \\cdot \\left(\\sum_ {i = 1} ^ {n _ {s}} c _ {i} \\cdot \\left[ \\prod_ {j \\in S _ {i}} \\left(\\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log n _ {c}}} \\mathsf {m l e} [ M _ {j} ] (\\vec {\\mathbf {x}}, \\vec {\\mathbf {b}}) \\cdot \\mathsf {m l e} [ \\mathbf {z} _ {\\mathsf {c c s}} ] (\\vec {\\mathbf {b}})\\right) \\right]\\right).</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  run a sum-check protocol for the claim  <span class="math">\\sum_{\\vec{\\mathbf{b}}\\in \\{0,1\\}^{\\log m}}g(\\vec{\\mathbf{b}}) = 0</span></p>

    <p class="text-gray-300">Let  <span class="math">\\vec{\\mathbf{r}}_o \\gets \\mathcal{C}^{\\log m}</span>  be the sum-check challenge vector. The protocol reduces to a random evaluation check  <span class="math">g(\\vec{\\mathbf{r}}_o) \\stackrel{?}{=} s</span>  for some  <span class="math">s \\in \\mathcal{R}_q</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V}</span> :  <span class="math">\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  the values  <span class="math">(\\hat{\\mathbf{v}}, [\\mathbf{u}_j]_{j=1}^t)</span>  where  <span class="math">\\hat{\\mathbf{v}} := \\mathsf{mle}\\left[\\tilde{\\mathbf{f}}\\right]</span>  and for every  <span class="math">j \\in [t]</span> ,  <span class="math">\\mathbf{u}_j</span>  is computed as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} _ {j} := \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log n _ {c}}} \\mathsf {m l e} [ M _ {j} ] (\\vec {\\mathbf {r}} _ {o}, \\vec {\\mathbf {b}}) \\cdot \\mathsf {m l e} [ \\mathbf {z} _ {\\mathsf {c c s}} ] (\\vec {\\mathbf {b}}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V computes  <span class="math">\\mathbf{e} := eq(\\vec{\\beta}, \\vec{\\mathbf{r}}_o)</span>  and checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {e} \\cdot \\left(\\sum_ {i = 1} ^ {n _ {s}} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\mathbf {u} _ {j}\\right) \\stackrel {?} {=} s.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V outputs  <span class="math">\\mathbb{X}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}},\\mathsf{cm},[\\mathbf{u}_j]_{j = 1}^t,\\mathbb{X}_{\\mathsf{ccs}},1)</span> . P outputs  <span class="math">\\mathbb{W}_o\\coloneqq (\\vec{\\mathbf{f}},\\mathbb{W}_{\\mathsf{ccs}})</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 5: The protocol  <span class="math">\\Pi_{\\mathrm{ccs}}</span>  that reduces  <span class="math">\\mathcal{R}_{\\mathrm{cmccs}}^B</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> .</p>

    <p class="text-gray-300">protocol  <span class="math">\\Pi_{\\mathrm{ccs}}</span>  in Figure 5. The protocol is inspired by the linearization technique from Hypernova [KS23b]. Intuitively, it runs a sum-check to reduce the high-degree CCS relation to a multilinear evaluation relation that has degree 1.</p>

    <p class="text-gray-300">Lemma 4.1.  <span class="math">\\Pi_{\\mathrm{ccs}}</span>  is a reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathrm{cmccs}}^B</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>  for any bound  <span class="math">B \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Proof. We defer the proof to Appendix B.1.</p>

    <p class="text-gray-300">Next, we describe the decomposition step that splits the witnesses and reduces the norms. By Theorem 2.2, it suffices to construct a protocol  <span class="math">\\Pi_{\\mathrm{ccsdec}}^<em></span>  that reduces  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span> , and the reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B \\times \\mathcal{R}_{\\mathrm{evalccs}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^{2k}</span>  is  <span class="math">\\Pi_{\\mathrm{ccsdec}} := \\Pi_{\\mathrm{ccsdec}}^</em> \\times \\Pi_{\\mathrm{ccsdec}}^<em></span>  that runs two instances of  <span class="math">\\Pi_{\\mathrm{ccsdec}}^</em></span>  in parallel.</p>

    <p class="text-gray-300">More generally, we construct a reduction of knowledge from a relation  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{ccshom}}^b)^k</span> . Here  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  is a generalization of  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>  (Definition 35) where we generalize Ajtai commitments and gadget matrix multiplications to arbitrary  <span class="math">\\mathcal{R}_q</span> -module homomorphisms. Let  <span class="math">\\mathcal{U} \\coloneqq \\mathcal{R}_q^t</span>  for some  <span class="math">t \\in \\mathbb{N}</span> . Let  <span class="math">\\overline{M} \\in \\mathcal{U}^{(n + n_{\\mathrm{in}}) \\times m}</span>  denote a matrix over module  <span class="math">\\mathcal{U}</span> . Let  <span class="math">\\mathcal{L}: \\mathcal{R}_q^m \\to \\mathcal{Y}</span>  and  <span class="math">\\mathcal{L}_w: \\mathcal{R}_q^m \\to \\mathcal{R}_q^{n + n_{\\mathrm{in}}}</span>  denote some  <span class="math">\\mathcal{R}_q</span> -module homomorphisms. We define the relation  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {c c s h o m}} ^ {B} := \\left\\{ \\begin{array}{c} \\mathrm {p p} := (\\mathcal {L}, \\mathcal {L} _ {w}, \\overline {{M}}), \\\\ \\mathbb {x} := (\\vec {\\mathbf {r}} \\in \\mathcal {R} _ {q} ^ {\\log m}, \\hat {\\mathbf {v}} \\in \\mathcal {R} _ {q}, \\mathbf {u} \\in \\mathcal {U}, y \\in \\mathcal {Y}, \\mathbb {x} _ {w} \\in \\mathcal {R} _ {q} ^ {n _ {\\mathrm {i n}}}); \\\\ \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\mathrm {s . t .} \\\\ (\\mathcal {L}, (\\vec {\\mathbf {r}}, \\hat {\\mathbf {v}}, y); \\vec {\\mathbf {f}}) \\in \\mathcal {R} _ {\\mathrm {h o m}} ^ {B} \\wedge \\\\ (\\mathbf {z} = \\mathcal {L} _ {w} (\\vec {\\mathbf {f}})) \\wedge (\\mathbf {u} = \\left\\langle \\overline {{M}} \\times \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}), \\mathbf {z} \\right\\rangle) \\end{array} \\right\\}, \\tag {36}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B</span>  is defined in Eq. (10),  $\\mathbf{z} \\coloneqq (\\mathbb{x}_w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}) \\in \\mathcal{R}_q^{n_{\\mathrm{in}} + n}$  and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {t e n s o r} (\\vec {\\mathbf {r}}) := \\bigotimes_ {i = 1} ^ {\\log m} \\left(\\vec {\\mathbf {r}} _ {i}, 1 - \\vec {\\mathbf {r}} _ {i}\\right) \\in \\mathcal {R} _ {q} ^ {m} \\tag {37}</span></div>

    <p class="text-gray-300">is the tensor product of  <span class="math">\\{(\\vec{\\mathbf{r}}_i,1 - \\vec{\\mathbf{r}}_i)\\}_{i = 1}^{\\log m}</span> .</p>

    <p class="text-gray-300">Remark 4.4.  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>  is a special case of  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  where  <span class="math">\\mathcal{R}_{\\mathrm{hom}}^B \\coloneqq \\mathcal{R}_{\\mathrm{eval}}^B</span> ;  <span class="math">\\mathcal{L}_w(\\vec{\\mathbf{f}}) \\coloneqq \\mathbf{G}\\vec{\\mathbf{f}}</span>  (where  <span class="math">\\mathbf{G}</span>  is the gadget matrix);  <span class="math">\\mathcal{U} \\coloneqq \\mathcal{R}_q^t</span> ;  <span class="math">\\mathbb{x}_w \\coloneqq (\\mathbb{x}_{\\mathrm{ccs}}, \\mathbf{h})</span> ; and  <span class="math">\\overline{M} \\coloneqq (M_1, \\ldots, M_t)</span> , i.e., each entry  <span class="math">(\\mathbf{e}_1, \\ldots, \\mathbf{e}_t) \\in \\mathcal{U}</span>  of  <span class="math">\\overline{M}</span>  maps to the entries  <span class="math">(\\mathbf{e}_i)_{i=1}^t</span>  in matrices  <span class="math">M_1, \\ldots, M_t</span>  respectively.</p>

    <p class="text-gray-300">We describe the protocol  <span class="math">\\Pi_{\\mathrm{ccsdec}}^<em></span>  in Figure 6. The differences from  <span class="math">\\Pi_{\\mathrm{dec}}^</em></span>  (Figure 2) are highlighted in red, which are for computing the  <span class="math">\\mathbf{u}</span> -values and the CCS instances.</p>

    <p class="text-gray-300">Lemma 4.2. Fix  <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span> . For any  <span class="math">B &amp;lt; q/2</span>  and any  <span class="math">b, k</span>  such that  <span class="math">b^k = B</span> ,  <span class="math">\\Pi_{\\mathrm{ccsdec}}^*</span>  is a reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{ccshom}}^b)^k</span> .</p>

    <p class="text-gray-300">Proof. The proof is similar to that for Lemma 3.3. We defer the proof to Appendix B.2.</p>

    <p class="text-gray-300">Input:  <span class="math">\\mathbf{x} := (\\vec{\\mathbf{r}}, \\hat{\\mathbf{v}}, y, \\mathbf{u}, \\mathbf{z}_w)</span>  and  <span class="math">\\mathbf{w} := (\\vec{\\mathbf{f}}, \\vec{\\mathbf{w}})</span></p>

    <p class="text-gray-300">Output:  <span class="math">[\\mathbf{z}_i = (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i,\\mathbf{u}_i,\\mathbf{z}_{w,i}),\\mathbf{w}_i = (\\vec{\\mathbf{f}}_i,\\vec{\\mathbf{w}}_i)]_{i = 0}^{k - 1}</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathsf{x};\\mathsf{w}),\\mathsf{V}(\\mathsf{pp},\\mathsf{x})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P computes  <span class="math">(\\vec{\\mathbf{f}}_0, \\ldots, \\vec{\\mathbf{f}}_{k-1}) \\gets \\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})</span>  (Eq. (11)).</li>

      <li><span class="math">\\mathsf{P}\\to \\mathsf{V}:\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  the values  <span class="math">[y_i,\\hat{\\mathbf{v}}_i,\\mathbf{u}_i,\\mathbf{z}_{w,i}]_{i = 0}^{k - 1}</span>  where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">y _ {i} := \\mathcal {L} (\\vec {\\mathbf {f}} _ {i}), \\quad \\hat {\\mathbf {v}} _ {i} := \\operatorname {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}}),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} _ {i} := \\left\\langle \\overline {{M}} \\times \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}), \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {i}) \\right\\rangle , \\quad \\mathbf {z} _ {w, i} := \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {i}) [ 1, n _ {\\mathrm {i n}} ]</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V checks that  <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot [y_i, \\hat{\\mathbf{v}}_i, \\mathbf{u}_i, \\mathbf{z}_{w,i}] \\stackrel{?}{=} [y, \\hat{\\mathbf{v}}, \\mathbf{u}, \\mathbf{z}_w]</span> .</li>

      <li>V outputs  <span class="math">[\\mathbf{z}_i = (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i,\\mathbf{u}_i,\\mathbf{z}_{w,i})]_{i = 0}^{k - 1}</span> . P outputs  <span class="math">[\\mathbf{w}_i = (\\vec{\\mathbf{f}}_i,\\mathcal{L}_w(\\vec{\\mathbf{f}}_i))]_{i = 0}^{k - 1}</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 6: The protocol  <span class="math">\\Pi_{\\mathrm{ccsdec}}^*</span>  that reduces  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{ccshom}}^b)^k</span> .</p>

    <p class="text-gray-300">Finally, we describe the core protocol  <span class="math">\\Pi_{\\mathrm{ccsfold}}</span>  that folds  <span class="math">2k</span>  instance-witness pairs of  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^b</span>  into a single instance-witness pair in  <span class="math">\\mathcal{R}_{\\mathrm{acc}} := \\mathcal{R}_{\\mathrm{evalccs}}^B</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similar to the treatment in Section 3.2.3, in the following, we assume that the homomorphism  <span class="math">\\mathcal{L}</span>  in the public parameter is  <span class="math">2B</span> -relaxed binding (Section 2.3) for challenge space  <span class="math">\\mathcal{C}_{\\mathrm{small}}</span> . For example,  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>  is a special case of  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span>  by Remark 4.4 and the homomorphism  <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}}) \\coloneqq \\mathbf{A}\\vec{\\mathbf{f}}</span>  is  <span class="math">2B</span> -relaxed binding given the hardness of  <span class="math">\\mathsf{MSIS}_{\\kappa,m,8TB}^{\\infty,q}</span>  where  $T = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe the protocol  <span class="math">\\Pi_{\\mathrm{ccsfold}}</span>  in Figure 7, which reduces from  <span class="math">(\\mathcal{R}_{\\mathrm{ccshom}}^b)^{2k}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span> . The approach is similar to that in Section 3.2.3, where we fold the witnesses using small random scalars from a strong sampling set, and run sum-check to enable extractions of small-norm witnesses. For brevity, we assume that  <span class="math">\\mathcal{U} \\coloneqq \\mathcal{R}_q</span> , hence  <span class="math">t = 1</span>  and the matrix  <span class="math">\\overline{M} = M_1 \\in \\mathcal{R}_q^{(n + n_{\\mathrm{in}}) \\times m}</span> . The protocol naturally extends to the case when  <span class="math">\\mathcal{U} \\coloneqq \\mathcal{R}_q^t</span>  for  <span class="math">t &amp;gt; 1</span> : we set  <span class="math">\\{\\mathbf{u}_i, \\eta_i\\}</span>  to be elements over  <span class="math">\\mathcal{R}_q^t</span> , sample challenges  <span class="math">\\{\\zeta_i\\}</span>  over  <span class="math">\\mathcal{C}^t</span>  and replace the multiplications between  <span class="math">\\zeta_i</span>  and  <span class="math">\\mathbf{u}_i</span>  (and  <span class="math">\\eta_i</span> ) with inner product operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4.2. Let  <span class="math">\\mathcal{R}_q \\cong \\mathbb{Z}_q^d</span> . Let  <span class="math">\\mathcal{C}</span> ,  <span class="math">\\mathcal{C}_{\\mathrm{small}}</span>  be strong sampling sets where  $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{negl}(\\lambda)<span class="math">  and  </span>\\mathcal{C}_{\\mathrm{small}}<span class="math">  has expansion factor at most  </span>c<span class="math">  (Definition 6). Let  </span>\\mathsf{pp} := (m, n, n_{\\mathrm{in}}, B, \\mathcal{L}, \\mathcal{L}_w)<span class="math">  be the public parameter where the homomorphism  </span>\\mathcal{L}<span class="math">  is  </span>2B<span class="math"> -relaxed binding (Section 2.3) for challenge space  </span>\\mathcal{C}_{\\mathrm{small}}<span class="math"> . For any  </span>b, k<span class="math">  such that  </span>2kc(b - 1) &lt; B<span class="math"> ,  </span>\\Pi_{\\mathrm{ccsfold}}<span class="math">  is a reduction of knowledge from  </span>(\\mathcal{R}_{\\mathrm{ccshom}}^b)^{2k}<span class="math">  to  </span>\\mathcal{R}_{\\mathrm{ccshom}}^B$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The proof is similar to that for Theorem 3.2. We defer the proof to Appendix B.3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters:  <span class="math">c \\in \\mathbb{N}</span> ,  <span class="math">\\mathcal{C} \\coloneqq \\mathbb{Z}_q \\subseteq \\mathcal{R}_q</span>  and a strong sampling set  <span class="math">\\mathcal{C}_{\\mathrm{small}}</span>  with  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}} \\leq c$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input:  <span class="math">\\mathbf{x} := [\\mathbf{x}_i := (\\vec{\\mathbf{r}}_i, \\hat{\\mathbf{v}}_i, y_i, \\mathbf{u}_i, \\mathbf{x}_{w,i})]_{i=1}^{2k}</span>  and  <span class="math">\\mathbf{w} := [\\mathbf{w}_i := (\\vec{\\mathbf{f}}_i, \\vec{\\mathbf{w}}_i)]_{i=1}^{2k}</span> .</p>

    <p class="text-gray-300">Output:  <span class="math">\\mathbf{x}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o,\\mathbf{u}_o,\\mathbf{x}_{w,o})</span> <span class="math">\\mathbf{w}_o\\coloneqq (\\vec{\\mathbf{f}}_o,\\vec{\\mathbf{w}}_o)</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathsf{x};\\mathsf{w}),\\mathsf{V}(\\mathsf{pp},\\mathsf{x})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}:\\mathsf{V}</span>  sends  <span class="math">\\mathsf{P}[\\alpha_i,\\mu_i,\\zeta_i]_{i = 1}^{2k}\\epsilon^{\\frac{\\varsigma}{2}}(C\\times C\\times C)^{2k}</span>  and  <span class="math">\\vec{\\beta}\\in \\mathcal{C}^{\\log m}</span></li>

      <li><span class="math">\\mathsf{V}\\leftrightarrow \\mathsf{P}:\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  run a sum-check protocol for the claim</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} g (\\vec {\\mathbf {b}}) = \\sum_ {i = 1} ^ {2 k} \\left(\\alpha_ {i} \\hat {\\mathbf {v}} _ {i} + \\zeta_ {i} \\mathbf {u} _ {i}\\right).</span></div>

    <p class="text-gray-300">Here the polynomial  <span class="math">g(\\vec{\\mathbf{x}}) \\in \\mathcal{R}_q^{\\leq 2b}[X_1, \\ldots, X_{\\log m}]</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">g (\\vec {\\mathbf {x}}) := \\sum_ {i = 1} ^ {2 k} \\left[ \\alpha_ {i} g _ {1, i} (\\vec {\\mathbf {x}}) + \\mu_ {i} g _ {2, i} (\\vec {\\mathbf {x}}) + \\zeta_ {i} g _ {3, i} (\\vec {\\mathbf {x}}) \\right], \\tag {38}</span></div>

    <p class="text-gray-300">where for all  <span class="math">i\\in [2k]</span></p>

    <div class="my-4 text-center"><span class="math-block">g _ {1, i} (\\vec {\\mathbf {x}}) := e q (\\vec {\\mathbf {r}} _ {i}, \\vec {\\mathbf {x}}) \\cdot \\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {x}}), \\quad g _ {2, i} (\\vec {\\mathbf {x}}) := e q (\\vec {\\beta}, \\vec {\\mathbf {x}}) \\cdot \\prod_ {j = - (b - 1)} ^ {b - 1} \\left(\\mathsf {m l e} \\left[ \\tilde {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {x}}) - j\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">g _ {3, i} (\\vec {\\mathbf {x}}) := e q (\\vec {\\mathbf {r}} _ {i}, \\vec {\\mathbf {x}}) \\cdot \\left(\\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log (n + n _ {\\mathrm {i n}})}} \\mathsf {m l e} [ M _ {1} ] (\\vec {\\mathbf {x}}, \\vec {\\mathbf {b}}) \\cdot \\mathsf {m l e} [ \\mathbf {z} _ {i} ] (\\vec {\\mathbf {b}})\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here  $\\mathbf{z}_i \\coloneqq (\\mathbf{z}_{w,i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_i)<span class="math">  for all  </span>i \\in [2k]<span class="math"> . The protocol reduces to check the evaluation claim  </span>g(\\vec{\\mathbf{r}}_o) \\stackrel{?}{=} s<span class="math">  where  </span>\\vec{\\mathbf{r}}_o \\in \\mathcal{C}^{\\log m}<span class="math">  is the sum-check challenge sampled by  </span>\\mathsf{V}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}\\to \\mathsf{V}:\\mathsf{P}</span>  sends  <span class="math">\\mathsf{V}</span>  values  <span class="math">\\left<a href="\\vec{\\mathbf{r}}_{o}">\\theta_{i}\\coloneqq \\mathsf{mle}\\left[\\tilde{\\mathbf{f}}_{i}\\right</a>,\\eta_{i}\\right]_{i = 1}^{2k}</span> , where for all  <span class="math">i\\in [2k]</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\eta_ {i} := \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log (n + n _ {\\mathrm {i n}})}} \\mathsf {m l e} [ M _ {1} ] (\\vec {\\mathbf {r}} _ {o}, \\vec {\\mathbf {b}}) \\cdot \\mathsf {m l e} [ \\mathbf {z} _ {i} ] (\\vec {\\mathbf {b}}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V computes  <span class="math">[\\mathbf{e}_i\\coloneqq eq(\\vec{\\mathbf{r}}_i,\\vec{\\mathbf{r}}_o)]_{i = 1}^{2k}</span>  and  <span class="math">\\mathbf{e}^* \\coloneqq eq(\\vec{\\beta},\\vec{\\mathbf{r}}_o)</span>  and checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">s \\stackrel {?} {=} \\sum_ {i = 1} ^ {2 k} \\left[ \\alpha_ {i} \\mathbf {e} _ {i} \\theta_ {i} + \\mu_ {i} \\mathbf {e} ^ {*} \\cdot \\prod_ {j = 1 - b} ^ {b - 1} (\\theta_ {i} - j) + \\zeta_ {i} \\mathbf {e} _ {i} \\eta_ {i} \\right].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}:\\mathsf{V}</span>  sends  <span class="math">\\mathsf{P}</span>  random challenges  <span class="math">[\\rho_i]_{i = 1}^{2k}\\in \\mathcal{C}_{\\mathrm{small}}^{2k}</span> .</li>

      <li>V output  <span class="math">\\mathbf{x}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o,\\mathbf{u}_o,\\mathbf{x}_{w,o})</span>  where  <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{v}}_o) = \\sum_{i = 1}^{2k}\\mathsf{RotSum}(\\rho_i,\\mathsf{NTT}(\\theta_i))</span>  and  <span class="math">[y_o,\\mathbf{u}_o,\\mathbf{x}_{w,o}]\\coloneqq \\sum_{i = 1}^{2k}\\rho_i\\cdot [y_i,\\eta_i,\\mathbf{x}_{w,i}]</span></li>

      <li>P outputs  <span class="math">\\vec{\\mathbf{f}}_o = \\sum_{i=1}^{2k} \\rho_i \\cdot \\vec{\\mathbf{f}}_i</span>  and  <span class="math">\\vec{\\mathbf{w}}_o := \\mathcal{C}_{\\mathrm{sw}}(\\vec{\\mathbf{f}}_o)[n_{\\mathrm{in}} + 1, n_{\\mathrm{in}} + n]</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 7: The protocol  <span class="math">\\Pi_{\\mathrm{ccsfold}}</span>  that reduces  <span class="math">(\\mathcal{R}_{\\mathrm{ccshom}}^b)^{2k}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{ccshom}}^B</span> . The  <span class="math">\\mathcal{R}_q</span> -module  <span class="math">\\mathcal{U}</span>  is set to  <span class="math">\\mathcal{U} \\coloneqq \\mathcal{R}_q</span>  for brevity.</p>

    <p class="text-gray-300">4.3 An Optimized Folding Scheme for CCS</p>

    <p class="text-gray-300">Recall that the folding scheme in Section 4.2 requires two sequential sumcheck executions. The first sumcheck is in the linearization protocol <span class="math">\\Pi_{\\mathsf{ccs}}</span> (Figure 5) that reduces <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> to <span class="math">\\mathcal{R}_{\\mathsf{evalccs}}^B</span>; the second sumcheck is in the folding protocol <span class="math">\\Pi_{\\mathsf{ccsfold}}</span> (Figure 7) that reduces <span class="math">(\\mathcal{R}_{\\mathsf{evalccs}}^b)^{2k}</span> to <span class="math">\\mathcal{R}_{\\mathsf{evalccs}}^B</span>. Note that a decomposition protocol (Figure 6) for witness norm deduction is executed in the middle, thus it is unclear how to batch the two sumchecks into one given that the witnesses of the two sumchecks are quite different.</p>

    <p class="text-gray-300">Fortunately, with a simple trick, we build a folding scheme for CCS that executes sumcheck only once. If the CCS gate degree <span class="math">\\mathsf{deg}</span> and the range parameter <span class="math">b</span> are set such that <span class="math">\\mathsf{deg} \\approx 2b</span>, both the prover time and verifier complexity can be improved by a factor of two. Moreover, the prover saves the computation of an Ajtai commitment to the witness.</p>

    <p class="text-gray-300">The core observation is that we can decompose the witness before running the linearization protocol. Recall that in the committed CCS relation <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> in Definition 4.2, the instance consists of a CCS public input <span class="math">\\mathbf{z}_{\\omega}</span> and a commitment <span class="math">\\mathsf{cm}</span>, and the witness is a pair of vectors <span class="math">(\\vec{\\mathbf{f}},\\vec{\\mathbf{w}})</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathbf{z}_{\\mathsf{ccs}},\\vec{\\mathbf{w}})</span> is in the CCS relation,</li>

      <li><span class="math">\\vec{\\mathbf{f}}</span> is an opening of <span class="math">\\mathsf{cm}</span> with norm less than <span class="math">B</span>, and</li>

      <li><span class="math">\\vec{\\mathbf{w}} = \\mathbf{G} \\times \\vec{\\mathbf{f}}</span> where <span class="math">\\mathbf{G}</span> is the gadget matrix.</li>

    </ul>

    <p class="text-gray-300">Instead of transforming the CCS relation to <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span>, we consider a variant of <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> called <em>splitted committed CCS relations</em>. Set parameter <span class="math">b, k \\in \\mathbb{N}</span> such that <span class="math">b^k = B</span>. The instance now consists of <span class="math">k</span> vectors <span class="math">[\\mathbf{z}_{\\omega,i}]_{i=1}^k</span> and <span class="math">k</span> commitments <span class="math">[\\mathsf{cm}_i]_{i=1}^k</span>, the witness is <span class="math">([\\vec{\\mathbf{f}}_i]_{i=1}^k, \\vec{\\mathbf{w}})</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathbf{z}_{\\mathsf{ccs}} := \\sum_{i=1}^{k} b^{i-1} \\cdot \\mathbf{z}_{\\omega,i}, \\vec{\\mathbf{w}})</span> is in the CCS relation,</li>

      <li>For every <span class="math">i \\in [k]</span>, <span class="math">\\vec{\\mathbf{f}}_i</span> is an opening of <span class="math">\\mathsf{cm}</span> with norm less than <span class="math">b</span>, and</li>

      <li><span class="math">\\vec{\\mathbf{w}} = \\mathbf{G} \\times \\vec{\\mathbf{f}}</span> where <span class="math">\\mathbf{G}</span> is the gadget matrix and <span class="math">\\vec{\\mathbf{f}} := \\sum_{i=1}^{k} b^{i-1} \\vec{\\mathbf{f}}_i</span>.</li>

    </ul>

    <p class="text-gray-300">We provide the formal definition below.</p>

    <p class="text-gray-300"><strong>Definition 4.4 (Splitted committed CCS relation).</strong> Let <span class="math">\\mathcal{R}_q \\coloneqq \\mathbb{Z}_q[X] / (X^d + 1)</span>, <span class="math">\\mathsf{pp} \\coloneqq (\\mathsf{pp}_{\\mathsf{cm}}, \\mathsf{pp}_{\\mathsf{ccs}})</span> be the parameters defined in Definition 4.2 where <span class="math">\\mathsf{pp}_{\\mathsf{cm}} = (\\kappa, m, B &amp;lt; q/2, \\mathbf{A})</span> and <span class="math">\\mathsf{pp}_{\\mathsf{ccs}} = (n_r, n_c, t, n_s, \\mathsf{deg}, \\ell_{\\mathsf{in}}, \\mathbb{I})</span>. Set <span class="math">\\ell \\coloneqq m / n_c \\in \\mathbb{N}</span> where <span class="math">B^\\ell \\geq q/2</span>. Let <span class="math">\\mathbf{G} \\coloneqq \\mathbf{I}_{n_c} \\otimes [1, B, \\ldots, B^{\\ell-1}] \\in \\mathbb{Z}_q^{n_c \\times m}</span> and set <span class="math">b, k \\in \\mathbb{N}</span> such that <span class="math">b^k = B</span>. The indexed relation <span class="math">\\mathcal{R}_{\\mathsf{splitccs}}^{b,k}</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {s p l i t c c s}} ^ {b, k} := \\left\\{ \\begin{array}{c} \\left(\\mathrm {p p}, \\mathrm {z} := \\left[ \\mathrm {c m} _ {i}, \\mathrm {z} _ {\\mathrm {c c s}, i} \\right] _ {i = 1} ^ {k}; \\mathrm {w} := \\left(\\mathrm {w} _ {\\mathrm {c c s}}, \\left[ \\vec {\\mathrm {f}} _ {i} \\right] _ {i = 1} ^ {k}\\right)\\right) \\text {s . t .} \\\\ \\forall i \\in [ k ]: (\\mathrm {p p} _ {\\mathrm {c m}}, \\mathrm {c m} _ {i}; \\vec {\\mathrm {f}} _ {i}) \\in \\mathcal {R} _ {\\mathrm {c m}} ^ {b} \\wedge \\\\ \\mathrm {z} _ {\\mathrm {c c s}} := \\left(\\mathrm {z} _ {\\mathrm {c c s}} := \\sum_ {i = 1} ^ {k} b ^ {i - 1} \\cdot \\mathrm {z} _ {\\mathrm {c c s}, i}, 1, \\mathrm {w} _ {\\mathrm {c c s}}\\right) = \\mathbf {G} \\times \\left(\\sum_ {i = 1} ^ {k} b ^ {i - 1} \\cdot \\vec {\\mathrm {f}} _ {i}\\right) \\\\ \\wedge (\\mathrm {p p} _ {\\mathrm {c c s}}, \\mathrm {z} _ {\\mathrm {c c s}}; \\mathrm {w} _ {\\mathrm {c c s}}) \\in \\mathcal {R} _ {\\mathrm {c c s}} \\end{array} \\right\\}. \\tag {39}</span></div>

    <p class="text-gray-300">Set <span class="math">b, k \\in \\mathbb{N}</span> such that <span class="math">b^{k} = B</span>. It is clear that if <span class="math">([\\mathbf{z}_{\\omega,i}, \\mathbf{cm}_{i}]_{i=1}^{k}, ([\\vec{\\mathbf{f}}_{i}]_{i=1}^{k}, \\vec{\\mathbf{w}}))</span> is in the splitted committed CCS relation <span class="math">\\mathcal{R}_{\\mathsf{splitccs}}^{b,k}</span>, then <span class="math">([\\mathbf{z}_{\\omega}, \\mathbf{cm}], (\\vec{\\mathbf{f}}, \\vec{\\mathbf{w}}))</span> is in relation <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^{B}</span>, where</p>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300"><span class="math">[\\mathbb{Z}_{\\mathrm{ccs}},\\mathsf{cm}]\\coloneqq \\sum_{i = 1}^{k}b^{i - 1}\\cdot [\\mathbb{Z}_{\\mathrm{w},i},\\mathsf{cm}_i]</span>  and  <span class="math">\\vec{\\mathbf{f}}\\coloneqq \\sum_{i = 1}^{k}b^{i - 1}\\vec{\\mathbf{f}}_i</span>  . Hence, there is a straightforward reduction from  <span class="math">\\mathcal{R}_{\\mathrm{cmccs}}^B</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k}</span>  . Therefore, to build a folding scheme for CCS, it suffices to set  <span class="math">\\mathcal{R}_{\\mathrm{comp}}\\coloneqq \\mathcal{R}_{\\mathrm{splitccs}}^{b,k}</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{acc}}\\coloneqq \\mathcal{R}_{\\mathrm{evalccs}}^B</span>  and construct a reduction of knowledge from  <span class="math">\\mathcal{R}_{\\mathrm{comp}}\\times \\mathcal{R}_{\\mathrm{acc}}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{acc}}</span>  . The construction consists of two steps.</p>

    <p class="text-gray-300">Step 1: Decomposition. Run protocol  <span class="math">\\Pi_{\\mathrm{ccsdec}}^*</span>  (Figure 6), to reduce  <span class="math">\\mathcal{R}_{\\mathrm{acc}} \\coloneqq \\mathcal{R}_{\\mathrm{evalccs}}^B</span>  to</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathcal {R} _ {\\text {e v a l c c s}} ^ {b}\\right) ^ {k} := \\underbrace {\\mathcal {R} _ {\\text {e v a l c c s}} ^ {b} \\times \\cdots \\times \\mathcal {R} _ {\\text {e v a l c c s}} ^ {b}} _ {k}.</span></div>

    <p class="text-gray-300">Step 2: Batch Folding. Reduce  <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k} \\times (\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span>  back to  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span>  by running the protocol  <span class="math">\\Pi_{\\mathrm{batch}}</span>  below.</p>

    <p class="text-gray-300">Using the techniques from previous sections, we can perceive all of the following statements (underlying  <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k}</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^b</span> ) as sumcheck statements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The multilinear evaluation statements underlying  <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span></li>

      <li>The linearized CCS statements (i.e.  <span class="math">\\mathcal{R}_{\\mathrm{lccs}}</span>  from Definition 4.3) underlying  <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span> ;</li>

      <li>The range proof statements (with norm  <span class="math">b</span> ) underlying  <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k}</span>  and  <span class="math">(\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span> ;</li>

      <li>The high-degree CCS gate-check (i.e. Definition 4.1) underlying  <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k}</span> .</li>

    </ul>

    <p class="text-gray-300">Intuitively, the protocol  <span class="math">\\Pi_{\\mathrm{batch}}</span>  runs a sumcheck protocol to reduce all statements above into a folded statement in  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> . We formally describe the protocol below. To make the notation consistent with the folding protocol  <span class="math">\\Pi_{\\mathrm{ccsfold}}</span>  (Figure 7), we denote  <span class="math">\\mathcal{L}</span>  and  <span class="math">\\mathcal{L}_w</span>  as the module homomorphisms  <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}})\\coloneqq \\mathbf{A}\\vec{\\mathbf{f}}</span>  and  <span class="math">\\mathcal{L}_w(\\vec{\\mathbf{f}})\\coloneqq \\mathbf{G}\\vec{\\mathbf{f}}</span>  (where  <span class="math">\\mathbf{G}</span>  is the gadget matrix), and we set  <span class="math">n_{\\mathrm{in}}\\coloneqq \\ell_{\\mathrm{in}} + 1</span>  and  <span class="math">n\\coloneqq n_c</span> .</p>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\mathrm{batch}}</span>  that reduces  <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k} \\times (\\mathcal{R}_{\\mathrm{evalccs}}^b)^k</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{evalccs}}^B</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters:  <span class="math">c \\in \\mathbb{N}</span> , strong sampling sets <span class="math">^4</span> <span class="math">\\mathcal{C} \\coloneqq \\mathbb{Z}_q \\subseteq \\mathcal{R}_q</span>  and  <span class="math">\\mathcal{C}_{\\mathrm{small}}</span>  with  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}} \\leq c$  Input:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\bullet \\mathbb{Z}:= \\left([ \\mathbb{Z}_i:= (\\vec{\\mathbf{r}}_i,\\hat{\\mathbf{v}}_i,y_i,[\\mathbf{u}_i^j ]_{j = 1}^t,\\mathbb{Z}_{w,i})]_{i = 1}^k,\\mathbb{Z}&#x27;\\coloneqq [\\mathbb{Z}_{\\mathsf{ccs},i},y_i&#x27;]_{i = 1}^k\\right)</span>  and <span class="math">\\bullet \\mathbb{W}:= \\left([\\mathbb{W}_i:= (\\vec{\\mathbf{f}}_i,\\vec{\\mathbf{w}}_i)]_{i = 1}^k,\\mathbb{W}&#x27;\\coloneqq (\\mathbb{W}_{\\mathrm{ccs}},[\\vec{\\mathbf{f}}_i&#x27;]_{i = 1}^k)\\right)</span></p>

    <p class="text-gray-300">Output:  <span class="math">\\mathbb{Z}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o,[\\mathbf{u}_o^j ]_{j = 1}^t,\\mathbb{Z}_{w,o})</span> <span class="math">\\mathbb{W}_o\\coloneqq (\\vec{\\mathbf{f}}_o,\\vec{\\mathbf{w}}_o)</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbb{Z};\\mathbb{W}),\\mathsf{V}(\\mathsf{pp},\\mathbb{Z})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}:\\mathsf{V}</span>  sends  <span class="math">\\mathsf{P}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\vec {\\beta} \\stackrel {{\\ddagger}} {{\\leftarrow}} \\mathcal {C} ^ {\\log m}, \\quad \\gamma \\stackrel {{\\ddagger}} {{\\leftarrow}} \\mathcal {C}, \\quad [ \\alpha_ {i}, \\mu_ {i}, \\mu_ {i} ^ {\\prime} ] _ {i = 1} ^ {k} \\stackrel {{\\ddagger}} {{\\leftarrow}} (\\mathcal {C} \\times \\mathcal {C} \\times \\mathcal {C}) ^ {k}, \\quad [ \\zeta_ {i} ^ {j} \\stackrel {{\\ddagger}} {{\\leftarrow}} \\mathcal {C} ] _ {i \\in [ k ], j \\in [ t ]}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V \\leftrightarrow P : P</span> and <span class="math">V</span> run a sum-check protocol for the claim</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{b} \\in \\{0,1\\}^{\\log m}} g(\\vec{b}) = \\sum_{i=1}^{k} \\alpha_i \\hat{\\mathbf{v}}_i + \\sum_{i=1}^{k} \\sum_{j=1}^{t} \\zeta_i^j \\mathbf{u}_i^j.</span></div>

    <p class="text-gray-300">Let <span class="math">d := \\max(2b, \\deg + 1)</span>. The polynomial <span class="math">g(\\vec{\\mathbf{x}}) \\in \\mathcal{R}_q^{\\leq d}[X_1, \\ldots, X_{\\log m}]</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">g(\\vec{\\mathbf{x}}) := \\gamma g_{\\mathrm{ccs}}&#x27;(\\vec{\\mathbf{x}}) + \\sum_{i=1}^{k} \\left[ \\alpha_i g_{\\mathrm{eval}}^i(\\vec{\\mathbf{x}}) + \\mu_i g_{\\mathrm{rg}}^i(\\vec{\\mathbf{x}}) \\right] + \\sum_{i=1}^{k} \\sum_{j=1}^{t} \\zeta_i^j g_{\\mathrm{lccs}}^{i,j}(\\vec{\\mathbf{x}}) + \\sum_{i=1}^{k} \\mu_i&#x27; g_{\\mathrm{rg}}&#x27;^i(\\vec{\\mathbf{x}}). \\tag{40}</span></div>

    <p class="text-gray-300">Set <span class="math">\\mathbf{z}_{\\mathrm{ccs}} := \\sum_{i=1}^{k} b^{i-1} \\mathbf{z}_{\\mathrm{ccs},i}</span> and let <span class="math">\\mathbf{z}_{\\mathrm{ccs}} := (\\mathbf{z}_{\\mathrm{ccs}}, 1, \\mathbf{w}_{\\mathrm{ccs}})</span>. The polynomial <span class="math">g_{\\mathrm{ccs}}&#x27;</span> is</p>

    <div class="my-4 text-center"><span class="math-block">g_{\\mathrm{ccs}}&#x27;(\\vec{\\mathbf{x}}) := eq(\\vec{\\beta}, \\vec{\\mathbf{x}}) \\cdot \\left( \\sum_{i=1}^{n_s} c_i \\cdot \\left[ \\prod_{j \\in S_i} \\left( \\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log n + n_{\\mathrm{in}}}} \\operatorname{mle}[M_j] (\\vec{\\mathbf{x}}, \\vec{\\mathbf{y}}) \\cdot \\operatorname{mle}[\\mathbf{z}_{\\mathrm{ccs}}] (\\vec{\\mathbf{y}}) \\right) \\right] \\right). \\tag{41}</span></div>

    <p class="text-gray-300">For all <span class="math">i \\in [k]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">g_{\\mathrm{eval}}^i(\\vec{\\mathbf{x}}) := eq(\\vec{\\mathbf{r}}_i, \\vec{\\mathbf{x}}) \\cdot \\operatorname{mle}\\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{x}}),</span></div>

    <div class="my-4 text-center"><span class="math-block">g_{\\mathrm{rg}}^i(\\vec{\\mathbf{x}}) := eq(\\vec{\\beta}, \\vec{\\mathbf{x}}) \\cdot \\prod_{j = - (b - 1)}^{b - 1} \\left( \\operatorname{mle}\\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{x}}) - j \\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">g_{\\mathrm{rg}}&#x27;^i(\\vec{\\mathbf{x}}) := eq(\\vec{\\beta}, \\vec{\\mathbf{x}}) \\cdot \\prod_{j = - (b - 1)}^{b - 1} \\left( \\operatorname{mle}\\left[ \\hat{\\mathbf{f}}_i&#x27; \\right] (\\vec{\\mathbf{x}}) - j \\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For all <span class="math">i \\in [k], j \\in [t]</span>, denote $\\mathbf{z}_i := (\\mathbf{z}_{w,i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_i) = \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">g_{\\mathrm{lccs}}^{i,j}(\\vec{\\mathbf{x}}) := eq(\\vec{\\mathbf{r}}_i, \\vec{\\mathbf{x}}) \\cdot \\left( \\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log (n + n_{\\mathrm{in}})}} \\operatorname{mle}[M_j] (\\vec{\\mathbf{x}}, \\vec{\\mathbf{y}}) \\cdot \\operatorname{mle}[\\mathbf{z}_i] (\\vec{\\mathbf{y}}) \\right).</span></div>

    <p class="text-gray-300">The protocol reduces to check the evaluation claim <span class="math">g(\\vec{\\mathbf{r}}_o) \\stackrel{?}{=} s</span> where <span class="math">\\vec{\\mathbf{r}}_o \\stackrel{s}{\\leftarrow} \\mathcal{C}^{\\log m}</span> is the sum-check challenge sampled by <span class="math">\\mathsf{V}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V} : \\mathsf{P}</span> sends <span class="math">\\mathsf{V}</span> values</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\theta_i := \\operatorname{mle}\\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{r}}_o); \\theta_i&#x27; := \\operatorname{mle}\\left[ \\hat{\\mathbf{f}}_i&#x27; \\right] (\\vec{\\mathbf{r}}_o) \\right]_{i=1}^k;</span></div>

    <p class="text-gray-300">For all <span class="math">i \\in [k], j \\in [t]</span>, denote by <span class="math">\\mathbf{z}_i := \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)</span> and <span class="math">\\mathbf{z}_i&#x27; := \\mathcal{L}_w(\\vec{\\mathbf{f}}_i&#x27;)</span>. <span class="math">\\mathsf{P}</span> sends <span class="math">\\mathsf{V}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\eta^{i,j} := \\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log (n + n_{\\mathrm{in}})}} \\operatorname{mle}[M_j] (\\vec{\\mathbf{r}}_o, \\vec{\\mathbf{y}}) \\cdot \\operatorname{mle}[\\mathbf{z}_i] (\\vec{\\mathbf{y}}),</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\eta_ {*} ^ {i, j} := \\sum_ {\\vec {y} \\in \\{0, 1 \\} ^ {\\log (n + n _ {\\mathrm {i n}})}} \\operatorname {m l e} \\left[ M _ {j} \\right] (\\vec {\\mathbf {r}} _ {o}, \\vec {y}) \\cdot \\operatorname {m l e} \\left[ \\mathbf {z} _ {i} ^ {\\prime} \\right] (\\vec {y}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span>  computes  <span class="math">[\\mathbf{e}_i\\coloneqq eq(\\vec{\\mathbf{r}}_i,\\vec{\\mathbf{r}}_o)]_{i = 1}^k</span>  and  <span class="math">\\mathbf{e}^{*}\\coloneqq eq(\\vec{\\beta},\\vec{\\mathbf{r}}_{o})</span>  and checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} s \\stackrel {?} {=} \\sum_ {i = 1} ^ {k} \\left[ \\alpha_ {i} \\mathbf {e} _ {i} \\theta_ {i} + \\mu_ {i} \\mathbf {e} ^ {*} \\prod_ {j = 1 - b} ^ {b - 1} (\\theta_ {i} - j) \\right] + \\sum_ {i = 1} ^ {k} \\sum_ {j = 1} ^ {t} \\zeta_ {i} ^ {j} \\mathbf {e} _ {i} \\eta^ {i, j} \\\\ + \\sum_ {i = 1} ^ {k} \\mu_ {i} ^ {\\prime} \\mathbf {e} ^ {*} \\prod_ {j = 1 - b} ^ {b - 1} \\left(\\theta_ {i} ^ {\\prime} - j\\right) + \\gamma \\mathbf {e} ^ {*} \\left(\\sum_ {i = 1} ^ {n _ {s}} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\left(\\sum_ {\\ell = 1} ^ {k} \\eta_ {*} ^ {\\ell , j} b ^ {\\ell - 1}\\right)\\right) \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V} \\to \\mathsf{P}: \\mathsf{V}</span>  sends  <span class="math">\\mathsf{P}</span>  random challenges  <span class="math">[\\rho_i]_{i=1}^k \\stackrel{\\mathrm{i}}{\\leftarrow} \\mathcal{C}_{\\mathrm{small}}^k</span>  and  <span class="math">[\\rho_i&#x27;]_{i=1}^k \\stackrel{\\mathrm{i}}{\\leftarrow} \\mathcal{C}_{\\mathrm{small}}^k</span> .</li>

      <li>V output  <span class="math">\\mathbf{z}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o,[\\mathbf{u}_o^j ]_{j = 1}^t,\\mathbf{z}_{w,o})</span>  where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf {N T T} (\\hat {\\mathbf {v}} _ {o}) = \\sum_ {i = 1} ^ {k} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\mathsf {N T T} \\left(\\theta_ {i}\\right)\\right) + \\sum_ {i = 1} ^ {k} \\operatorname {R o t S u m} \\left(\\rho_ {i} ^ {\\prime}, \\mathsf {N T T} \\left(\\theta_ {i} ^ {\\prime}\\right)\\right) \\\\ y _ {o} = \\sum_ {i = 1} ^ {k} \\rho_ {i} \\cdot y _ {i} + \\sum_ {i = 1} ^ {k} \\rho_ {i} ^ {\\prime} \\cdot y _ {i} ^ {\\prime} \\\\ \\forall j \\in [ t ]: u _ {o} ^ {j} = \\sum_ {i = 1} ^ {k} \\rho_ {i} \\eta^ {i, j} + \\sum_ {i = 1} ^ {k} \\rho_ {i} ^ {\\prime} \\eta_ {*} ^ {i, j} \\\\ \\mathbf {z} _ {w, o} = \\sum_ {i = 1} ^ {k} \\rho_ {i} \\mathbf {z} _ {w, i} + \\rho_ {1} ^ {\\prime} \\cdot [ \\mathbf {z} _ {\\mathrm {c c s}, 1}, 1 ] + \\sum_ {i = 2} ^ {k} \\rho_ {i} ^ {\\prime} \\cdot [ \\mathbf {z} _ {\\mathrm {c c s}, i}, 0 ]. \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P outputs  <span class="math">\\vec{\\mathbf{f}}_o = \\sum_{i=1}^k \\rho_i \\cdot \\vec{\\mathbf{f}}_i + \\sum_{i=1}^k \\rho_i&#x27; \\cdot \\vec{\\mathbf{f}}_i&#x27;</span>  and  <span class="math">\\vec{\\mathbf{w}}_o := \\mathcal{L}_w(\\vec{\\mathbf{f}}_o)[n_{\\mathrm{in}} + 1, n_{\\mathrm{in}} + n]</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 4.3. Let  <span class="math">\\mathcal{R}_q\\coloneqq \\mathbb{Z}_q[X] / (X^d +1)\\cong \\mathbb{Z}_q^d</span> <span class="math">\\mathsf{pp}\\coloneqq (\\mathsf{pp}_{\\mathsf{cm}},\\mathsf{pp}_{\\mathsf{ccs}})</span>  be the parameters defined in Definition 4.2 where  <span class="math">\\mathsf{pp}_{\\mathsf{cm}} = (\\kappa ,m,B &amp;lt; q / 2,\\mathbf{A})</span>  and  <span class="math">\\mathsf{pp}_{\\mathsf{ccs}} = (n_r = m,n_c,t,n_s,\\mathsf{deg},\\ell_{\\mathsf{in}},\\mathbb{I})</span>  such that  <span class="math">B^{m / n_c}\\geq q / 2</span>  . Let  <span class="math">\\mathcal{C}</span> <span class="math">\\mathcal{C}_{\\mathrm{small}}</span>  be strong sampling sets where  $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=<span class="math">  negl(λ) and  </span>\\mathcal{C}_{\\mathrm{small}}<span class="math">  has expansion factor  </span>T\\coloneqq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}}\\leq c<span class="math">  (Definition 6). Assume that  </span>\\mathsf{MSIS}_{\\kappa ,m,8TB}^{\\infty ,q}<span class="math">  is hard. For any  </span>b,k<span class="math">  such that  </span>2kc(b - 1) &lt;   B<span class="math">  and  </span>b^{k} = B<span class="math"> </span>\\Pi_{\\mathrm{batch}}<span class="math">  is a reduction of knowledge from  </span>\\mathcal{R}_{\\mathrm{splitccs}}^{b,k}\\times (\\mathcal{R}_{\\mathrm{evalccs}}^{b})^{k}<span class="math">  to  </span>\\mathcal{R}_{\\mathrm{evalccs}}^{B}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. We defer the proof to Appendix B.4.</p>

    <p class="text-gray-300">By Lemma 4.3 and Lemma 4.2 and the knowledge composition theorem (Theorem 2.1), we obtain the theorem below.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 4.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}_{q}</span>, <span class="math">\\mathcal{C}</span>, <span class="math">\\mathcal{C}_{\\mathsf{small}}</span>, <span class="math">\\mathsf{pp}_{\\mathsf{cm}}=(\\kappa,m,B,\\mathbf{A})</span>, <span class="math">\\mathsf{pp}_{\\mathsf{ccs}}=(n_{r},n_{c},t,n_{s},\\mathsf{deg},\\ell_{\\mathsf{in}},\\mathbb{I})</span>, and <span class="math">b</span>, <span class="math">k</span> be defined as in Lemma 4.3. <span class="math">\\Pi_{\\mathsf{batch}}\\circ\\Pi_{\\mathsf{ccsdec}}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}^{b,k}_{\\mathsf{splitccs}}\\times\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span> to <span class="math">\\mathcal{R}^{B}_{\\mathsf{evalccs}}</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Remark 4.5 (Supporting small prime modulus).</h6>

    <p class="text-gray-300">The optimization in Section 3.3 can be used to extend Theorem 4.3 to support small modulus <span class="math">q</span>, i.e., Theorem 4.3 still holds when <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{F}_{q^{\\tau}}^{d/\\tau}</span> for any <span class="math">\\tau\\in\\mathbb{N}</span> that divides <span class="math">d</span>.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">IVC proof compression.</h4>

    <p class="text-gray-300">In the final step of IVC/PCD, the final IVC verifier needs to check witnesses for two statements, one in <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span> and one in <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>. A naive approach is letting the prover send the statement witnesses, and the verifier checks the statements in the clear. We can further improve the verifier complexity by generating another SNARK (e.g., Stark or LaBRADOR) that proves the correctness of the two final statements. Then the verifier only needs to check the SNARK proof.</p>

    <p class="text-gray-300">However, in the optimized folding scheme for CCS, the statement in <span class="math">\\mathcal{R}_{\\mathsf{comp}}:=\\mathcal{R}^{b,k}_{\\mathsf{splitccs}}</span> is more expensive to prove, as it involves checking the openings of <span class="math">k</span> (rather than 1) commitments. Fortunately, we observe that in the last IVC step, there is no need to translate the online IVC statement into a <em>committed</em> CCS relation statement, because the <em>committed</em> CCS relation is only helpful when you need to <em>fold</em> the statement further. Instead, it is sufficient to translate the IVC statement as a CCS relation statement. The SNARK only needs to prove the IVC statement (plus the statement in the accumulated relation <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>) without checking additional commitment openings inside the SNARK circuit.</p>

    <p class="text-gray-300">Alternatively, one can also fold the last two statements, one in <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span> and one in <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>, into a statement in <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>, so the SNARK only needs to prove a single statement in <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span> (plus the folding verification logic). There is no need to prove any logic related to <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span>. Additionally, we can make the final SNARK proof zero knowledge, thereby hiding secret information.</p>

    <h2 id="sec-50" class="text-2xl font-bold">5 Performance Estimates</h2>

    <p class="text-gray-300">We specify the complexity of the folding schemes in Table 1. For CCS relations, we consider the optimized folding scheme in Section 4.3. Recall that <span class="math">\\tau</span> denote the extension field degree such that <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{F}_{q^{\\tau}}</span>, <span class="math">\\kappa</span> is the rank of the MSIS matrix. <span class="math">(n_{r},n_{c},t,n_{s},\\mathsf{deg},\\ell_{\\mathsf{in}})</span> is the parameter where <span class="math">n_{r}</span>, <span class="math">n_{c}</span> are the number of rows and columns of the CCS matrices, <span class="math">t</span> is the number of matrices in the CCS relation, <span class="math">n_{s}</span> is the number of sub-gates per CCS constraint, and <span class="math">\\ell_{\\mathsf{in}}</span> is the public input length.</p>

    <p class="text-gray-300">Each instance consists of <span class="math">\\tau+\\kappa+t+\\ell_{\\mathsf{in}}+1</span> <span class="math">\\mathcal{R}_{q}</span>-elements for the values <span class="math">[\\hat{\\mathbf{v}}_{i}]_{i=1}^{\\tau}</span>, <span class="math">[\\mathbf{u}_{j}]_{j=1}^{t}</span>, commitment <span class="math">\\mathsf{cm}\\in\\mathcal{R}_{q}^{\\kappa}</span> and public input <span class="math">\\mathsf{z}_{w}</span>; additionally it takes <span class="math">\\log m</span> field elements for the challenge vector <span class="math">\\mathbf{\\bar{r}}</span> in the strong sampling set <span class="math">\\mathcal{C}\\cong\\mathbb{F}_{q^{\\tau}}</span>.</p>

    <p class="text-gray-300">Recall that <span class="math">b,k</span> are the parameters such that <span class="math">b^{k}</span> equals the norm bound <span class="math">B</span>. The prover takes <span class="math">O(mk(\\kappa+t))</span> <span class="math">\\mathcal{R}_{q}</span> multiplications to compute the commitments and <span class="math">\\mathbf{u}</span>-values for the</p>

    <p class="text-gray-300">decomposed witness (Figure 6); and it takes  <span class="math">O(mD\\log^2 D)</span> <span class="math">\\mathcal{R}_q</span>  multiplications to run the sum-check in protocol  <span class="math">\\Pi_{\\mathrm{batch}}</span>  (Section 4.3.1), where  <span class="math">D \\coloneqq \\max(2b, \\deg)</span> .</p>

    <p class="text-gray-300">We split the verifier into three phases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It takes  <span class="math">k \\cdot (\\kappa + \\tau + t + \\ell_{\\mathrm{in}} + 1) \\mathcal{R}_q</span>  multiplications to check the correctness of decomposition in Figure 6;</li>

      <li>It takes  <span class="math">n_s \\deg + k(\\tau + t + 4b\\tau) \\mathcal{R}_q</span>  multiplications to check the high-degree random evaluation claims and takes  <span class="math">2D \\log m \\mathcal{R}_q</span>  multiplications to run the sumcheck verifiers in Figure 5. Additionally, it takes  <span class="math">2(k + 1) \\log m</span>  field multiplications to compute the  <span class="math">k + 1</span>  of eq values.</li>

      <li>It  <span class="math">2k \\cdot (\\kappa + \\tau + t + \\ell_{\\mathrm{in}} + 1) \\mathcal{R}_q</span>  multiplications to fold the decomposed instances in  <span class="math">\\Pi_{\\mathrm{batch}}</span>  (Section 4.3.1).</li>

      <li>Besides, the Fiat-Shamir transform takes  <span class="math">\\approx 2k\\kappa</span>  hashes to absorb the inputs and the decomposed commitments, and it takes  <span class="math">\\approx 2k\\log m</span>  hashes to compute the sumcheck verifier challenges.</li>

    </ul>

    <p class="text-gray-300">To highlight its practicality, we consider the following example instantiation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Relation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ajtai</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CCS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Instance</td>

            <td class="px-3 py-2 border-b border-gray-700">Rq: τ + κ Fqτ: log m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Rq: τ + κ + t + ℓin + 1 Fqτ: log m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover</td>

            <td class="px-3 py-2 border-b border-gray-700">Rq-mul: O(mkκ) + O(mb log2(b))</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Rq-mul: O(mk(κ + t)) + O(mD log2(D))</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier</td>

            <td class="px-3 py-2 border-b border-gray-700">Rq-mul: 4k · (κ + τ) 4kbτ + 4b log m F-mul: (4k + 2) log m H: ≈ 2kκ + 2b log m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Rq-mul: 3k · (κ + τ + t + ℓin + 1) + ns deg + k(τ + t + 4bτ) + 2D log m F-mul: (2k + 2) log m H: ≈ 2kκ + D log m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: The complexity of our folding schemes.  <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span>  for some  <span class="math">\\tau, d \\in \\mathbb{N}</span>  where  <span class="math">\\tau \\mid d</span> .  <span class="math">\\kappa</span>  is the number of  <span class="math">\\mathcal{R}_q</span> -elements in the Ajtai commitment;  <span class="math">(t, n_s, \\ell_{\\mathrm{in}}, \\deg)</span>  are the CCS parameters in Definition 4.1. Let  <span class="math">B</span>  be the norm bound of the committed witness and  <span class="math">b, k</span>  are the parameters such that  <span class="math">b^k = B</span>  and  <span class="math">D := \\max(2b, \\deg)</span> .  <span class="math">\\mathcal{R}_q</span> -mul and  <span class="math">\\mathbb{F}</span> -mul denote multiplications over  <span class="math">\\mathcal{R}_q \\cong \\mathbb{F}_{q^\\tau}^{d/\\tau}</span>  and  <span class="math">\\mathbb{F}_{q^\\tau}</span>  respectively;  <span class="math">\\mathsf{H}</span>  denotes a hash from  <span class="math">\\mathcal{R}_q^2</span>  to  <span class="math">\\mathcal{R}_q</span> .</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Instantiation.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We set <span class="math">\\kappa:=16</span>, <span class="math">d:=64</span> and use a <span class="math">64</span>-bit prime <span class="math">q</span> such that <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{F}_{q^{4}}^{d/4}</span>. Assign the last challenge set <span class="math">\\mathcal{C}_{\\mathsf{small}}</span> as the set of elements in <span class="math">\\mathcal{R}_{q}</span> with coefficients <span class="math">-1</span>, <span class="math">0</span>, <span class="math">1</span> or <span class="math">2</span>. Since <span class="math">d=64</span>, we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=4^{64}=2^{128}<span class="math">. Moreover, </span>\\mathcal{C}_{\\mathsf{small}}<span class="math"> is a strong sampling set, because the difference of any two distinct elements has infinite norm at most </span>3<\\frac{q^{1/16}}{\\sqrt{16}}=4<span class="math"> and thus is invertible by Lemma 2.3. By Lemma 2.2, </span>\\mathcal{C}_{\\mathsf{small}}<span class="math"> has expansion factor at most </span>2d=128<span class="math">. By the MSIS hardness bound in Section 2.2, we can achieve </span>128$-bit security if</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$0.5\\cdot(\\log m+\\log d)+\\log(8\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}\\cdot B)\\approx 2\\sqrt{\\log_{2}(1.0045)d\\kappa\\log q}\\,,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which holds if <span class="math">\\log B\\leq 29-0.5\\cdot\\log m</span>.</p>

    <p class="text-gray-300">For simplicity, we set the CCS parameters <span class="math">(t,n_{s},\\ell_{\\mathsf{in}})</span> where <span class="math">\\ell_{\\mathsf{in}}=0</span>, <span class="math">t=n_{s}=1</span>. Assume that the number of CCS constraints (over <span class="math">\\mathcal{R}_{q}</span>) in the IVC/PCD recursive circuit is <span class="math">m\\leq 2^{26}</span>. We set <span class="math">B:=2^{16}</span> so that <span class="math">\\log B\\leq 29-0.5\\cdot\\log m\\leq 16</span>. We emphasize that by Remark 4.1, <span class="math">m</span> constraints over <span class="math">\\mathcal{R}_{q}</span> can be used to pack <span class="math">md/4=16m</span> constraints over <span class="math">\\mathbb{F}_{q^{4}}</span>, so an upper bound <span class="math">m\\leq 2^{26}</span> leads to an upper bound <span class="math">2^{30}</span> on the number of constraints over <span class="math">\\mathbb{F}_{q^{4}}</span>, which is more than enough.</p>

    <p class="text-gray-300">Let’s see the concrete instance size, prover cost and verifier circuit size. We set <span class="math">b:=2</span> and <span class="math">k:=16</span> so that <span class="math">b^{k}=2^{16}=B</span> and <span class="math">2kc(b-1)=2\\cdot 16\\cdot 128\\cdot 1&lt;B=2^{16}</span> as required in Theorem 4.2.</p>

    <p class="text-gray-300">The instance size is <span class="math">\\tau+\\kappa+t+\\ell_{\\mathsf{in}}+1=22</span> <span class="math">\\mathcal{R}_{q}</span>-elements and <span class="math">\\log m</span> <span class="math">\\mathbb{F}_{q^{\\tau}}</span>-elements. E.g., for <span class="math">m:=2^{26}</span>, this is <span class="math">\\approx 12</span>KB. The recursive folding verifier takes</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx(1648+(2D+2)\\cdot\\log m)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(2k\\kappa+D\\log m)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CCS constraints. Here $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of constraints for a single </span>\\mathcal{R}_{q}<span class="math"> multiplication, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of constraints for simulating a two-to-one hash. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math"> as it takes at most one contraint to simulate an </span>\\mathcal{R}_{q}<span class="math"> multiplication; by <em>[x1]</em>, we can set </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 100<span class="math">. The number of constraints is dominated by the Fiat-Shamir circuit, which takes </span>\\approx 50$K constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Remark 5.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">After fixing the parameter <span class="math">b</span>, instead of setting <span class="math">k</span> such that <span class="math">b^{k}=B</span>, we can set <span class="math">k^{<em>}</span> as the minimal integer such that $b^{k^{</em>}}\\geq 2k^{*}(b-1)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}<span class="math"> where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}<span class="math"> is the expansion factor of </span>\\mathcal{C}_{\\mathsf{small}}<span class="math">. In each folding step, we decompose the folded witness to </span>k^{<em>}\\leq k<span class="math"> parts, leading to an efficiency improvement. This works because after each folding step, the norm of the folded witness is always less than </span>2k^{</em>}(b-1)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathsf{small}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}\\leq b^{k^{<em>}}<span class="math">. This also indicates that we can use different decomposition factors </span>k^{</em>},k<span class="math"> for relations </span>\\mathcal{R}_{\\mathsf{acc}}<span class="math"> and </span>\\mathcal{R}_{\\mathsf{comp}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-53" class="text-base font-medium mt-4">Remark 5.2 (Supporting non-power-of-two cyclotomic rings).</h6>

    <p class="text-gray-300">Our current analysis requires <span class="math">\\mathcal{R}:=\\mathbb{Z}[X]/(X^{d}+1)</span> to be a cyclotomic ring where <span class="math">d</span> is a power-of-two. We conjecture that the scheme remains secure when using a non-power-of-two cyclotomic ring and leave the formal analysis for future work.</p>

    <p class="text-gray-300">6 Discussion of an Alternative Approach</p>

    <p class="text-gray-300">In this section we discuss another technique for proving a norm bound on a committed vector, called <em>random projection</em>. We explain why this approach, which may at first seem appealing, does not seem to work in the context of folding.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose we aim to fold <span class="math">2k</span> instance-witness pairs <span class="math">[\\vx_{i},\\vw_{i}]_{i=1}^{2k}</span> of an Ajtai commitment-based relation (e.g., <span class="math">\\mathcal{R}_{\\text{eval}}^{b}</span> from Eq. (9)) to a single instance-witness pair <span class="math">(\\vx_{o},\\vw_{o})</span> in a related relation (e.g., <span class="math">\\mathcal{R}_{\\text{eval}}^{B}</span> where <span class="math">B&gt;b</span>). To extract knowledge of <span class="math">[\\vw_{i}]_{i=1}^{2k}</span> (with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vw_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b<span class="math"> for all </span>i\\in[2k]<span class="math">) from a folding prover </span>\\Pp^{*}<span class="math"> that outputs correct witness in </span>\\mathcal{R}_{\\text{eval}}^{B}<span class="math">, the most naive approach is to have the prover directly transmit </span>[\\vw_{i}]_{i=1}^{2k}<span class="math"> and let the verifier check that </span>[\\vw_{i}]_{i=1}^{2k}<span class="math"> have small norms and are consistent with the folded instance. This certainly does not work as the verifier has complexity linear to the witness size while constructing a IVC/PCD requires folding verifiers to be sublinear. Alternatively, the prover could generate a proof demonstrating that each element of </span>[\\vw_{i}]_{i=1}^{2k}<span class="math"> has a small norm, but this method is excessively costly due to the requirement for </span>\\Theta(m)<span class="math"> range-check circuits, where </span>m$ is the witness length.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To circumvent these challenges, a natural idea is to leverage the random projection technique from LaBRADOR <em>[x1]</em>: The verifier samples and sends a random matrix <span class="math">\\Pi\\in\\Z_{q}^{\\lambda d\\times md}</span> with small norms, where <span class="math">\\lambda</span> is the security parameter and <span class="math">m</span> is the size of <span class="math">\\vec{\\vw}:=[\\vw_{i}]_{i=1}^{2k}</span>. Subsequently, the prover sends <span class="math">\\vec{\\vw}:=\\Pi\\vec{\\vw}\\in\\Z_{q}^{\\lambda d}</span> and the verifier checks that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\vw}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> is small and </span>\\vec{\\vw}<span class="math"> is computed honestly. Notably, the size of </span>\\vec{\\vw}<span class="math"> is independent of the witness size. Additionally, if </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\vw}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> has a small norm, by the Johnson-Lindenstrauss Lemma <em>[x23, x10, x1]</em>, the original witnesses also have small norms with high probability (over the random choice of </span>\\Pi$). Nonetheless, several challenges arise in the context of folding schemes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First, the size of the matrix <span class="math">\\Pi</span> is large, making it impractical for the verifier to generate <span class="math">\\Pi</span> itself. A potential solution involves having the verifier generate a short random seed <span class="math">s</span>, which the prover then uses to generate <span class="math">\\Pi</span> and subsequently proves the correctness of <span class="math">\\Pi</span>’s generation. However, this approach introduces significant complexity in terms of circuit size, as simulating PRG computations in circuits for a large output is prohibitively expensive.</p>

    <p class="text-gray-300">Second, how does the verifier check that <span class="math">\\vec{\\vw}</span> was computed honestly? It’s impractical for the verifier to directly receive <span class="math">\\vec{\\vw}</span> and verify its correctness, as this would result in a linear-sized verifier. An alternative approach could be to have the prover generate another instance-witness pair <span class="math">(\\vx^{\\prime},\\vw^{\\prime})</span> for proving <span class="math">\\vec{\\vw}=\\Pi\\vec{\\vw}</span> and then fold it together with the original instances. However, this leads to a chicken-and-egg problem: how do we check that the committed witness in <span class="math">\\vw^{\\prime}</span> has a small norm? The most viable solution appears to involve the prover computing a post-quantum secure SNARK <span class="math">\\pi</span> for proving that <span class="math">\\vec{\\vw}=\\Pi\\vec{\\vw}</span> and <span class="math">\\Pi=\\PRG(s)</span> (where <span class="math">s</span> is the short random seed), with the verifier subsequently verifying the correctness of <span class="math">\\pi</span>. Concretely, this solution is inefficient due to the high complexity of the SNARK verifier circuit. Furthermore, since we can already construct IVC/PCD directly</p>

    <p class="text-gray-300">from SNARKs <em>[x1, x2]</em>, employing folding in conjunction with SNARKs serves little purpose.</p>

    <p class="text-gray-300">Even if we manage to overcome the aforementioned challenges, we still encounter an inherent obstacle: the random projection idea cannot guarantee <em>perfect completeness</em>: Even if the prover is honest and provides input witnesses with genuinely small norms, there remains a small probability that the random projection <span class="math">\\vec{\\mathbf{v}}=\\Pi\\vec{\\mathbf{w}}</span> would yield large norms, resulting in rejection by the verifier. We note that perfect completeness is essential for constructing an IVC/PCD <em>[x3]</em>, and it appears inherently difficult to construct a folding scheme that achieves perfect completeness using the random projection approach.</p>

    <h2 id="sec-54" class="text-2xl font-bold">7 Conclusion, open problems, and future work</h2>

    <p class="text-gray-300">We presented LatticeFold, the first lattice folding scheme based on the Module SIS problem. Our folding protocol ensures that the witnesses extracted from a folded statement always satisfy the required norm bounds. This is done by requiring the prover to prove that its starting witnesses are all low norm. This proof is done efficiently using the sumcheck protocol.</p>

    <p class="text-gray-300">There are many directions for future work. First, it is not difficult to extend the scheme to support the Lasso <em>[x17, x18]</em> lookup argument. This is because the sumcheck used by Lasso is compatible with the sumchecks in LatticeFold. Second, it remains to implement LatticeFold and experiment with its real-world performance. We estimate that LatticeFold is competitive with the best pre-quantum folding schemes. It is likely to be the most performant folding system for computations using high-degree CCS. LatticeFold could be an example where (plausible) post-quantum security leads to better performance.</p>

    <p class="text-gray-300">Finally, it would be interesting to explore the performance of LatticeFold using other lattice-based additively homomorphic commitments schemes, for example, ones based on SIS rather MSIS. In addition, recall that much of the work in the design of LatticeFold is due to the fact that the Ajtai commitment scheme <em>[x1]</em> is binding only when the committed vector is low norm. If we had a lattice-based linearly homomorphic commitment that was binding for arbitrary vectors, irrespective of their norm, then one could more directly use that commitment scheme in the Hypernova <em>[x12]</em> or Protostar <em>[x4]</em> systems. Such commitment schemes exist (e.g., <em>[x1]</em>), however they are not succinct: the commitment string is quite long. Using them would result in a SNARK with poor prover performance and long proofs. Designing a <em>succinct</em> lattice-based linearly homomorphic commitment scheme for committing to vectors of arbitrary norm is an interesting area for further research.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">Acknowledgments.</h4>

    <p class="text-gray-300">We thank the anonymous CRYPTO reviewers and Wilson Nguyen for their valuable feedback, and Srinath Setty for bringing up the question of batching all Sumchecks. This work was funded by NSF, DARPA, the Simons Foundation, UBRI, and</p>

    <p class="text-gray-300">NTT Research. Opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACK21] Thomas Attema, Ronald Cramer, and Lisa Kohl. “A Compressed <span class="math">\\Sigma</span>-Protocol Theory for Lattices”. In: CRYPTO 2021, Part II. Ed. by Tal Malkin and Chris Peikert. Vol. 12826. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 549–579. doi: 10.1007/978-3-030-84245-1_19.</li>

      <li>[AF22] Thomas Attema and Serge Fehr. “Parallel Repetition of <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-Special-Sound Multi-round Interactive Proofs”. In: CRYPTO 2022, Part I. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13507. LNCS. Springer, Cham, Aug. 2022, pp. 415–443. doi: 10.1007/978-3-031-15802-5_15.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: ACM CCS 2017. Ed. by Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu. ACM Press, 2017, pp. 2087–2104. doi: 10.1145/3133956.3134104.</li>

      <li>[Ajt96] Miklós Ajtai. “Generating Hard Instances of Lattice Problems (Extended Abstract)”. In: 28th ACM STOC. ACM Press, May 1996, pp. 99–108. doi: 10.1145/237814.237838.</li>

      <li>[AL21] Martin R. Albrecht and Russell W. F. Lai. “Subtractive Sets over Cyclotomic Rings - Limits of Schnorr-Like Arguments over Lattices”. In: CRYPTO 2021, Part II. Ed. by Tal Malkin and Chris Peikert. Vol. 12826. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 519–548. doi: 10.1007/978-3-030-84245-1_18.</li>

      <li>[Alb+22] Martin R. Albrecht, Valerio Cini, Russell W. F. Lai, Giulio Malavolta, and Sri Aravinda Krishnan Thyagarajan. “Lattice-Based SNARKs: Publicly Verifiable, Preprocessing, and Recursively Composable - (Extended Abstract)”. In: CRYPTO 2022, Part II. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13508. LNCS. Springer, Cham, Aug. 2022, pp. 102–132. doi: 10.1007/978-3-031-15979-4_4.</li>

      <li>[ALS20] Thomas Attema, Vadim Lyubashevsky, and Gregor Seiler. “Practical Product Proofs for Lattice Commitments”. In: CRYPTO 2020, Part II. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12171. LNCS. Springer, Cham, Aug. 2020, pp. 470–499. doi: 10.1007/978-3-030-56880-1_17.</li>

      <li>[APS15] Martin R Albrecht, Rachel Player, and Sam Scott. “On the concrete hardness of learning with errors”. In: Journal of Mathematical Cryptology 9.3 (2015), pp. 169–203.</li>

    </ul>

    <p class="text-gray-300">[Bau+18a] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. “Sub-linear Lattice-Based Zero-Knowledge Arguments for Arithmetic Circuits”. In: CRYPTO 2018, Part II. Ed. by Hovav Shacham and Alexandra Boldyreva. Vol. 10992. LNCS. Springer, Cham, Aug. 2018, pp. 669–699. doi: 10.1007/978-3-319-96881-0_23.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Bau+18b] Carsten Baum, Ivan Damgård, Vadim Lyubashevsky, Sabine Oechsner, and Chris Peikert. “More Efficient Commitments from Structured Lattice Assumptions”. In: SCN 18. Ed. by Dario Catalano and Roberto De Prisco. Vol. 11035. LNCS. Springer, Cham, Sept. 2018, pp. 368–385. doi: 10.1007/978-3-319-98113-0_20.</li>

      <li>[Bau+23] Carsten Baum, Lennart Braun, Cyprien Delpech de Saint Guilhem, Michael Klooß, Emmanuela Orsini, Lawrence Roy, and Peter Scholl. “Publicly Verifiable Zero-Knowledge and Post-Quantum Signatures from VOLE-in-the-Head”. In: CRYPTO 2023, Part V. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14085. LNCS. Springer, Cham, Aug. 2023, pp. 581–615. doi: 10.1007/978-3-031-38554-4_19.</li>

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. “Verifiable Delay Functions”. In: CRYPTO 2018, Part I. Ed. by Hovav Shacham and Alexandra Boldyreva. Vol. 10991. LNCS. Springer, Cham, Aug. 2018, pp. 757–788. doi: 10.1007/978-3-319-96884-1_25.</li>

      <li>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Fast Reed-Solomon Interactive Oracle Proofs of Proximity”. In: ICALP 2018. Ed. by Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella. Vol. 107. LIPIcs. Schloss Dagstuhl, July 2018, 14:1–14:17. doi: 10.4230/LIPIcs.ICALP.2018.14.</li>

      <li>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046. 2018. url: https://eprint.iacr.org/2018/046.</li>

      <li>[BC23] Benedikt Bünz and Binyi Chen. “Protostar: Generic efficient accumulation/folding for special sound protocols”. In: Cryptology ePrint Archive (2023).</li>

      <li>[BC25] Dan Boneh and Binyi Chen. LatticeFold+: Faster, Simpler, Shorter Lattice-Based Folding for Succinct Proof Systems. Cryptology ePrint Archive, Report 2025/247. 2025. url: https://eprint.iacr.org/2025/247.</li>

    </ul>

    <p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. “Recursive composition and bootstrapping for SNARKS and proof-carrying data”. In: <em>45th ACM STOC</em>. Ed. by Dan Boneh, Tim Roughgarden, and Joan Feigenbaum. ACM Press, June 2013, pp. 111–120. doi: 10.1145/2488608.2488623.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. “Recursive Proof Composition from Accumulation Schemes”. In: <em>TCC 2020, Part II</em>. Ed. by Rafael Pass and Krzysztof Pietrzak. Vol. 12551. LNCS. Springer, Cham, Nov. 2020, pp. 1–18. doi: 10.1007/978-3-030-64378-2_1.</li>

      <li>[BCPS18] Anurag Bishnoi, Pete L Clark, Aditya Potukuchi, and John R Schmitt. “On zeros of a polynomial in a finite grid”. In: <em>Combinatorics, Probability and Computing</em> 27.3 (2018), pp. 310–333.</li>

      <li>[BCS23] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. “Lattice-Based Succinct Arguments for NP with Polylogarithmic-Time Verification”. In: <em>CRYPTO 2023, Part II</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14082. LNCS. Springer, Cham, Aug. 2023, pp. 227–251. doi: 10.1007/978-3-031-38545-2_8.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: <em>CRYPTO 2014, Part II</em>. Ed. by Juan A. Garay and Rosario Gennaro. Vol. 8617. LNCS. Springer, Berlin, Heidelberg, Aug. 2014, pp. 276–294. doi: 10.1007/978-3-662-44381-1_16.</li>

      <li>[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. “Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments”. In: <em>CRYPTO 2021, Part I</em>. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 649–680. doi: 10.1007/978-3-030-84242-0_23.</li>

      <li>[Ben+19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: <em>EUROCRYPT 2019, Part I</em>. Ed. by Yuval Ishai and Vincent Rijmen. Vol. 11476. LNCS. Springer, Cham, May 2019, pp. 103–128. doi: 10.1007/978-3-030-17653-2_4.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. <em>Halo: Recursive Proof Composition without a Trusted Setup</em>. Cryptology ePrint Archive, Report 2019/1021. 2019. url: https://eprint.iacr.org/2019/1021.</li>

    </ul>

    <p class="text-gray-300">[BLNS20] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. “A Non-PCP Approach to Succinct Quantum-Safe Zero-Knowledge”. In: CRYPTO 2020, Part II. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12171. LNCS. Springer, Cham, Aug. 2020, pp. 441–469. doi: 10.1007/978-3-030-56880-1_16.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BLS19] Jonathan Bootle, Vadim Lyubashevsky, and Gregor Seiler. “Algebraic Techniques for Short(er) Exact Lattice-Based Zero-Knowledge Proofs”. In: CRYPTO 2019, Part I. Ed. by Alexandra Boldyreva and Daniele Micciancio. Vol. 11692. LNCS. Springer, Cham, Aug. 2019, pp. 176–202. doi: 10.1007/978-3-030-26948-7_7.</li>

      <li>[BMNW24a] Benedikt Bünz, Pratyush Mishra, Wilson Nguyen, and William Wang. Accumulation without Homomorphism. Cryptology ePrint Archive, Report 2024/474. 2024. url: https://eprint.iacr.org/2024/474.</li>

      <li>[BMNW24b] Benedikt Bünz, Pratyush Mishra, Wilson Nguyen, and William Wang. Arc: Accumulation for Reed–Solomon Codes. Cryptology ePrint Archive, Report 2024/1731. 2024. url: https://eprint.iacr.org/2024/1731.</li>

      <li>[Bou+23] Clémence Bouvier, Pierre Briaud, Pyrros Chaidos, Léo Perrin, Robin Salen, Vesselin Velichkov, and Danny Willems. “New Design Techniques for Efficient Arithmetization-Oriented Hash Functions: Anemoi Permutations and Jive Compression Mode”. In: CRYPTO 2023, Part III. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14083. LNCS. Springer, Cham, Aug. 2023, pp. 507–539. doi: 10.1007/978-3-031-38548-3_17.</li>

      <li>[Bre+24] Martijn Brehm, Binyi Chen, Ben Fisch, Nicolas Resch, Ron D. Rothblum, and Hadas Zeilberger. Blaze: Fast SNARKs from Interleaved RAA Codes. Cryptology ePrint Archive, Report 2024/1609. 2024. url: https://eprint.iacr.org/2024/1609.</li>

      <li>[BS23] Ward Beullens and Gregor Seiler. “LaBRADOR: Compact Proofs for R1CS from Module-SIS”. In: CRYPTO 2023, Part V. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14085. LNCS. Springer, Cham, Aug. 2023, pp. 518–548. doi: 10.1007/978-3-031-38554-4_17.</li>

      <li>[Bün+18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: 2018 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2018, pp. 315–334. doi: 10.1109/SP.2018.00020.</li>

    </ul>

    <p class="text-gray-300">[Bün+21] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 681–710. doi: 10.1007/978-3-030-84242-0_24.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CCKP19] Shuo Chen, Jung Hee Cheon, Dongwoo Kim, and Daejun Park. Verifiable Computing for Approximate Computation. Cryptology ePrint Archive, Report 2019/762. 2019. url: https://eprint.iacr.org/2019/762.</li>

      <li>[CMNW24] Valerio Cini, Giulio Malavolta, Ngoc Khanh Nguyen, and Hoeteck Wee. Polynomial Commitments from Lattices: Post-Quantum Security, Fast Verification and Transparent Setup. Cryptology ePrint Archive, Paper 2024/281. https://eprint.iacr.org/2024/281. 2024. url: https://eprint.iacr.org/2024/281.</li>

      <li>[CT10] Alessandro Chiesa and Eran Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: ICS 2010. Ed. by Andrew Chi-Chih Yao. Tsinghua University Press, Jan. 2010, pp. 310–331.</li>

      <li>[DB22] Trisha Datta and Dan Boneh. Using ZK Proofs to Fight Disinformation. link. 2022.</li>

      <li>[EG23] Liam Eagen and Ariel Gabizon. ProtoGalaxy: Efficient ProtoStar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106. https://eprint.iacr.org/2023/1106. 2023. url: https://eprint.iacr.org/2023/1106.</li>

      <li>[ENS20] Muhammed F. Esgin, Ngoc Khanh Nguyen, and Gregor Seiler. “Practical Exact Proofs from Lattices: New Techniques to Exploit Fully-Splitting Rings”. In: ASIACRYPT 2020, Part II. Ed. by Shiho Moriai and Huaxiong Wang. Vol. 12492. LNCS. Springer, Cham, Dec. 2020, pp. 259–288. doi: 10.1007/978-3-030-64834-3_9.</li>

      <li>[Esg+19] Muhammed F. Esgin, Ron Steinfeld, Amin Sakzad, Joseph K. Liu, and Dongxi Liu. “Short Lattice-Based One-out-of-Many Proofs and Applications to Ring Signatures”. In: ACNS 19International Conference on Applied Cryptography and Network Security. Ed. by Robert H. Deng, Valérie Gauthier-Umaña, Martín Ochoa, and Moti Yung. Vol. 11464. LNCS. Springer, Cham, June 2019, pp. 67–88. doi: 10.1007/978-3-030-21568-2_4.</li>

      <li>[FKNP24a] Giacomo Fenzi, Christian Knabenhans, Ngoc Khanh Nguyen, and Duc Tu Pham. Lova: Lattice-Based Folding Scheme from Unstructured Lattices. Cryptology ePrint Archive, Report 2024/1964. 2024. url: https://eprint.iacr.org/2024/1964.</li>

    </ul>

    <p class="text-gray-300">[FKNP24b] Giacomo Fenzi, Christian Knabenhans, Ngoc Khanh Nguyen, and Duc Tu Pham. “Lova: Lattice-Based Folding Scheme from Unstructured Lattices”. In: ASIACRYPT 2024, Part IV. Ed. by Kai-Min Chung and Yu Sasaki. Vol. 15487. LNCS. Springer, Singapore, Dec. 2024, pp. 303–326. doi: 10.1007/978-981-96-0894-2_10.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[FMN23] Giacomo Fenzi, Hossein Moghaddas, and Ngoc Khanh Nguyen. Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency. Cryptology ePrint Archive, Paper 2023/846. https://eprint.iacr.org/2023/846. 2023. url: https://eprint.iacr.org/2023/846.</li>

      <li>[Gar24] Albert Garreta. Implementing LatticeFold: Advancing Post-Quantum Folding. ZKProof 7. link. 2024.</li>

      <li>[GHL22] Craig Gentry, Shai Halevi, and Vadim Lyubashevsky. “Practical Non-interactive Publicly Verifiable Secret Sharing with Thousands of Parties”. In: EUROCRYPT 2022, Part I. Ed. by Orr Dunkelman and Stefan Dziembowski. Vol. 13275. LNCS. Springer, Cham, 2022, pp. 458–487. doi: 10.1007/978-3-031-06944-4_16.</li>

      <li>[Gol+23] Alexander Golovnev, Jonathan Lee, Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. “Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS”. In: CRYPTO 2023, Part II. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14082. LNCS. Springer, Cham, Aug. 2023, pp. 193–226. doi: 10.1007/978-3-031-38545-2_7.</li>

      <li>[KHSS22] Daniel Kang, Tatsunori Hashimoto, Ion Stoica, and Yi Sun. ZK-IMG: Attested Images via Zero-Knowledge Proofs to Fight Disinformation. 2022. eprint: 2211.04775.</li>

      <li>[KLNO24a] Michael Klooß, Russell W. F. Lai, Ngoc Khanh Nguyen, and Michał Osadnik. RoK, Paper, SISsors – Toolkit for Lattice-based Succinct Arguments. Cryptology ePrint Archive, Report 2024/1972. 2024. url: https://eprint.iacr.org/2024/1972.</li>

      <li>[KLNO24b] Michael Klooß, Russell W. F. Lai, Ngoc Khanh Nguyen, and Michal Osadnik. “RoK, Paper, SISsors Toolkit for Lattice-Based Succinct Arguments - (Extended Abstract)”. In: ASIACRYPT 2024, Part V. Ed. by Kai-Min Chung and Yu Sasaki. Vol. 15488. LNCS. Springer, Singapore, Dec. 2024, pp. 203–235. doi: 10.1007/978-981-96-0935-2_7.</li>

      <li>[KP23] Abhiram Kothapalli and Bryan Parno. “Algebraic Reductions of Knowledge”. In: CRYPTO 2023, Part IV. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14084. LNCS. Springer, Cham, Aug. 2023, pp. 669–701. doi: 10.1007/978-3-031-38551-3_21.</li>

    </ul>

    <p class="text-gray-300">[KS22] Abhiram Kothapalli and Srinath Setty. SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive, Report 2022/1758. 2022. URL: https://eprint.iacr.org/2022/1758.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KS23a] Abhiram Kothapalli and Srinath Setty. “CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves”. In: Cryptology ePrint Archive (2023).</li>

      <li>[KS23b] Abhiram Kothapalli and Srinath Setty. “HyperNova: Recursive arguments for customizable constraint systems”. In: Cryptology ePrint Archive (2023).</li>

      <li>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: CRYPTO 2022, Part IV. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13510. LNCS. Springer, Cham, Aug. 2022, pp. 359–388. doi: 10.1007/978-3-031-15985-5_13.</li>

      <li>[KTX08] Akinori Kawachi, Keisuke Tanaka, and Keita Xagawa. “Concurrently Secure Identification Schemes Based on the Worst-Case Hardness of Lattice Problems”. In: ASIACRYPT 2008. Ed. by Josef Pieprzyk. Vol. 5350. LNCS. Springer, Berlin, Heidelberg, Dec. 2008, pp. 372–389. doi: 10.1007/978-3-540-89255-7_23.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. “Algebraic methods for interactive proof systems”. In: Journal of the ACM (JACM) 39.4 (1992), pp. 859–868.</li>

      <li>[LM06] Vadim Lyubashevsky and Daniele Micciancio. “Generalized Compact Knapsacks Are Collision Resistant”. In: ICALP 2006, Part II. Ed. by Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener. Vol. 4052. LNCS. Springer, Berlin, Heidelberg, July 2006, pp. 144–155. doi: 10.1007/11787006_13.</li>

      <li>[LNP22] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Maxime Plançon. “Lattice-Based Zero-Knowledge Proofs and Applications: Shorter, Simpler, and More General”. In: CRYPTO 2022, Part II. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13508. LNCS. Springer, Cham, Aug. 2022, pp. 71–101. doi: 10.1007/978-3-031-15979-4_3.</li>

      <li>[LPS24] Helger Lipmaa, Roberto Parisella, and Janno Siim. “Constant-Size zk-SNARKs in ROM from Falsifiable Assumptions”. In: Cryptology ePrint Archive (2024).</li>

      <li>[LS15] Adeline Langlois and Damien Stehlé. “Worst-case to average-case reductions for module lattices”. In: DCC 75.3 (2015), pp. 565–599. doi: 10.1007/s10623-014-9938-4.</li>

    </ul>

    <p class="text-gray-300">[LS18] Vadim Lyubashevsky and Gregor Seiler. “Short, Invertible Elements in Partially Splitting Cyclotomic Rings and Applications to Lattice-Based Zero-Knowledge Proofs”. In: EUROCRYPT 2018, Part I. Ed. by Jesper Buus Nielsen and Vincent Rijmen. Vol. 10820. LNCS. Springer, Cham, 2018, pp. 204–224. doi: 10.1007/978-3-319-78381-9_8.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Moh23] Nicolas Mohnblatt. Sangria: a folding scheme for PLONK. link. 2023.</li>

      <li>[MR09] Daniele Micciancio and Oded Regev. “Lattice-based cryptography”. In: Post-quantum cryptography. Springer, 2009, pp. 147–191.</li>

      <li>[NBS23] Wilson Nguyen, Dan Boneh, and Srinath Setty. Revisiting the Nova Proof System on a Cycle of Curves. Cryptology ePrint Archive, Paper 2023/969. https://eprint.iacr.org/2023/969. 2023. url: https://eprint.iacr.org/2023/969.</li>

      <li>[NS24] Ngoc Khanh Nguyen and Gregor Seiler. “Greyhound: Fast Polynomial Commitments from Lattices”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 243–275. doi: 10.1007/978-3-031-68403-6_8.</li>

      <li>[NS25] Wilson Nguyen and Srinath Setty. Neo: Lattice-based folding scheme for CCS over small fields and pay-per-bit commitments. Cryptology ePrint Archive, Report 2025/294. 2025. url: https://eprint.iacr.org/2025/294.</li>

      <li>[NT16] Assa Naveh and Eran Tromer. “PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations”. In: 2016 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2016, pp. 255–271. doi: 10.1109/SP.2016.23.</li>

      <li>[PR06] Chris Peikert and Alon Rosen. “Efficient Collision-Resistant Hashing from Worst-Case Assumptions on Cyclic Lattices”. In: TCC 2006. Ed. by Shai Halevi and Tal Rabin. Vol. 3876. LNCS. Springer, Berlin, Heidelberg, Mar. 2006, pp. 145–166. doi: 10.1007/11681878_8.</li>

      <li>[RZ22] Carla Ràfols and Alexandros Zacharakis. Folding Schemes with Selective Verification. Cryptology ePrint Archive, Report 2022/1576. 2022. url: https://eprint.iacr.org/2022/1576.</li>

      <li>[ST23] Srinath Setty and Justin Thaler. BabySpartan: Lasso-based SNARK for non-uniform computation. Cryptology ePrint Archive, Paper 2023/1799. https://eprint.iacr.org/2023/1799. 2023. url: https://eprint.iacr.org/2023/1799.</li>

      <li>[STW23a] Srinath Setty, Justin Thaler, and Riad Wahby. “Customizable constraint systems for succinct arguments”. In: Cryptology ePrint Archive (2023).</li>

    </ul>

    <p class="text-gray-300">[STW23b] Srinath Setty, Justin Thaler, and Riad Wahby. Unlocking the lookup singularity with Lasso. Cryptology ePrint Archive, Paper 2023/1216. https://eprint.iacr.org/2023/1216. 2023. URL: https://eprint.iacr.org/2023/1216.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: TCC 2008. Ed. by Ran Canetti. Vol. 4948. LNCS. Springer, Berlin, Heidelberg, Mar. 2008, pp. 1–18. doi: 10.1007/978-3-540-78524-8_1.</li>

      <li>[WL84] B Johnson William and Joram Lindenstrauss. “Extensions of Lipschitz mapping into Hilbert space”. In: Contemporary mathematics 26.189-206 (1984), p. 323.</li>

      <li>[Xie+22] Tiancheng Xie, Jiaheng Zhang, Zerui Cheng, Fan Zhang, Yupeng Zhang, Yongzheng Jia, Dan Boneh, and Dawn Song. “zkBridge: Trustless Cross-chain Bridges Made Practical”. In: ACM CCS 2022. Ed. by Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi. ACM Press, Nov. 2022, pp. 3003–3017. doi: 10.1145/3548606.3560652.</li>

      <li>[ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch. “BaseFold: Efficient Field-Agnostic Polynomial Commitment Schemes from Foldable Codes”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 138–169. doi: 10.1007/978-3-031-68403-6_5.</li>

    </ul>

    <h2 id="sec-56" class="text-2xl font-bold">Appendix A Multilinear Evaluation Mapping Lemma</h2>

    <p class="text-gray-300">We derive a lemma from the fact that every ring homomorphism <span class="math">\\phi:R\\to S</span> induces a natural homomorphism <span class="math">\\phi^{\\prime}:R[X]\\to S[X]</span> over the polynomial rings. In the special case where <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{Z}_{q}^{d}</span>, consider a vector <span class="math">\\vec{\\mathbf{f}}\\in\\mathcal{R}_{q}^{m}</span> and a vector <span class="math">\\hat{\\mathbf{f}}\\in\\mathcal{R}_{q}^{m}</span> such that <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}})=\\mathsf{Coef}(\\vec{\\mathbf{f}})</span>. Let <span class="math">f_{1},\\ldots,f_{d}</span> be the multilinear extensions of the columns of <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{f}})\\in\\mathbb{Z}_{q}^{m\\times d}</span>. The lemma asserts that a multilinear evaluation of <span class="math">\\mathsf{mle}\\left[\\hat{\\mathbf{f}}\\right]</span> can be mapped to the evaluations of <span class="math">f_{1},\\ldots,f_{d}</span> (over <span class="math">\\mathbb{Z}_{q}</span>) through the NTT isomorphism. This lemma helps maintain the invariant of the evaluation statement <span class="math">\\hat{\\mathbf{v}}=\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}">\\hat{\\mathbf{f}}\\right</a></span> after folding the witness <span class="math">\\vec{\\mathbf{f}}</span>, even if the evaluation point <span class="math">\\vec{\\mathbf{r}}\\in\\mathcal{R}_{q}^{\\log m}</span> changes after the folding.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma A.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}_{q}\\cong\\mathbb{F}_{q^{\\tau}}^{d/\\tau}</span> for some <span class="math">\\tau\\in\\mathbb{N}</span> where <span class="math">\\tau\\mid d</span>. Let <span class="math">m\\in\\mathbb{N}</span> be a power of two. For any <span class="math">\\vec{\\mathbf{f}}\\in\\mathcal{R}_{q}^{m}</span>, let <span class="math">\\hat{\\mathbf{f}}:=(\\hat{\\mathbf{f}}_{1},\\ldots,\\hat{\\mathbf{f}}_{\\tau})\\in\\mathcal{R}_{q}^{m\\times\\tau}</span> denote the vector such that <span class="math">\\mathsf{NTT}(\\hat{\\mathbf{f}})=\\mathsf{Coef}(\\vec{\\mathbf{f}})\\in\\mathbb{Z}_{q}^{m\\times d}</span>. Let <span class="math">\\vec{\\mathbf{r}}\\in\\mathcal{R}_{q}^{\\log m}</span> and denote <span class="math">(\\vec{\\mathbf{r}}_{1}^{<em>},\\ldots,\\vec{\\mathbf{r}}_{d/\\tau}^{</em>})\\in(\\mathbb{F}_{q^{\\tau}}^{\\log m})^{d/\\tau}</span> the columns of</p>

    <p class="text-gray-300"><span class="math">\\mathsf{NTT}(\\vec{\\mathbf{r}})</span>. For every <span class="math">i \\in [\\tau]</span>, we have that <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}">\\hat{\\mathbf{f}}_i\\right</a> \\in \\mathcal{R}_q</span> is mapped to</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf{mle} \\left[ \\mathsf{Coef}_{1 + (i - 1) \\cdot d / \\tau}(\\vec{\\mathbf{f}}) \\right] (\\vec{\\mathbf{r}}_1^*), \\dots, \\mathsf{mle} \\left[ \\mathsf{Coef}_{i \\cdot d / \\tau}(\\vec{\\mathbf{f}}) \\right] (\\vec{\\mathbf{r}}_{d / \\tau}^*)\\right) \\in \\mathbb{F}_{q^{\\tau}}^{d / \\tau}</span></div>

    <p class="text-gray-300">by the NTT isomorphism. Recall that <span class="math">\\mathsf{mle}[\\cdot]</span> denotes multilinear extensions (Definition 2.4) and <span class="math">\\mathsf{Coef}_j(\\vec{\\mathbf{f}}) \\in \\mathbb{Z}_q^m</span> is the <span class="math">j</span>th <span class="math">(1 \\leq j \\leq d)</span> column of <span class="math">\\mathsf{Coef}(\\vec{\\mathbf{f}})</span>.</p>

    <p class="text-gray-300">Proof. By definition of <span class="math">\\hat{\\mathbf{f}}</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NTT}(\\hat{\\mathbf{f}}) = \\left[ \\mathsf{NTT}(\\hat{\\mathbf{f}}_1), \\dots, \\mathsf{NTT}(\\hat{\\mathbf{f}}_\\tau) \\right] = \\left[ \\mathsf{Coef}_1(\\vec{\\mathbf{f}}), \\dots, \\mathsf{Coef}_d(\\vec{\\mathbf{f}}) \\right]. \\tag{42}</span></div>

    <p class="text-gray-300">Also observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf{mle} \\left[ \\hat{\\mathbf{f}}_1 \\right] (\\vec{\\mathbf{r}}), \\dots, \\mathsf{mle} \\left[ \\hat{\\mathbf{f}}_\\tau \\right] (\\vec{\\mathbf{r}})\\right) = \\left(\\left\\langle \\hat{\\mathbf{f}}_j, \\bigotimes_{i = 1}^{\\log m} (\\vec{\\mathbf{r}}_i, 1 - \\vec{\\mathbf{r}}_i) \\right\\rangle\\right)_{j = 1}^{\\tau} \\tag{43}</span></div>

    <p class="text-gray-300">where <span class="math">\\bigotimes</span> denotes tensor product over <span class="math">\\mathcal{R}_q</span>. By the Chinese Remainder Theorem, the NTT map is an isomorphism, and the lemma follows from the properties of an isomorphism.</p>

    <h2 id="sec-58" class="text-2xl font-bold">B Deferred Proofs</h2>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">B.1 Proof of Lemma 4.1</h3>

    <p class="text-gray-300">Proof. Public reducibility: Given input instance <span class="math">\\mathbf{z} = (\\mathsf{cm}, \\mathbf{z}_{\\mathsf{ccs}})</span> and transcript that includes <span class="math">(\\vec{\\mathbf{r}}_o, \\hat{\\mathbf{v}}, [\\vec{\\mathbf{u}}_j]_{j=1}^t)</span>, the algorithm <span class="math">f</span> outputs <span class="math">\\mathbf{z}_o = (\\vec{\\mathbf{r}}_o, \\hat{\\mathbf{v}}, \\mathsf{cm}, [\\mathbf{u}_j]_{j=1}^t, \\mathbf{z}_{\\mathsf{ccs}}, 1)</span> if the verifier check passes; and <span class="math">\\perp</span> otherwise.</p>

    <p class="text-gray-300">Completeness: Let <span class="math">(\\mathbf{z};\\mathbf{w})\\coloneqq \\left((\\mathsf{cm},\\mathbf{z}_{\\mathsf{ccs}});(\\vec{\\mathbf{f}},\\mathbf{w}_{\\mathsf{ccs}})\\right)\\gets \\mathcal{A}(\\mathsf{pp})</span> denotes adversary <span class="math">\\mathcal{A}</span>'s output for <span class="math">\\mathcal{R}_1\\coloneqq \\mathcal{R}_{\\mathsf{cmccs}}^B</span>, where <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(1^{\\lambda})</span> is the public parameter. WLOG, we assume that <span class="math">(\\mathsf{pp},\\mathbf{z};\\mathbf{w})\\in \\mathcal{R}_{\\mathsf{cmccs}}^B</span> (where <span class="math">\\mathcal{R}_{\\mathsf{cmccs}}^B</span> is specified in Definition 4.2). The protocol <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbf{z},\\mathbf{w}),\\mathsf{V}(\\mathsf{pp},\\mathbf{z})\\rangle</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>After running the sum-check and receiving the challenge vector <span class="math">\\vec{\\mathbf{r}}_o\\in \\mathcal{C}^{\\log m}</span>, <span class="math">\\mathsf{P}</span> sends <span class="math">\\mathsf{V}</span> the value <span class="math">\\hat{\\mathbf{v}}\\coloneqq \\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_o">\\hat{\\mathbf{f}}\\right</a></span>. Moreover, let <span class="math">\\mathbf{z}_{\\mathrm{ccs}}\\coloneqq (\\mathbf{z}_{\\mathrm{ccs}},1,\\mathbf{w}_{\\mathrm{ccs}})</span>, for every <span class="math">j\\in [t]</span>, <span class="math">\\mathsf{P}</span> sends <span class="math">\\mathbf{u}_j\\coloneqq \\sum_{\\vec{\\mathbf{b}}\\in \\{0,1\\}^{\\log n_c}}\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_o,\\vec{\\mathbf{b}}">M_j\\right</a>\\cdot \\mathsf{mle}\\left<a href="\\vec{\\mathbf{b}}">\\mathbf{z}_{\\mathrm{ccs}}\\right</a></span>.</li>

      <li><span class="math">\\mathsf{V}</span> outputs <span class="math">\\perp</span> and halts if the check at Step 4 fails.</li>

      <li><span class="math">\\mathsf{P}</span> outputs <span class="math">\\mathsf{w}_o\\coloneqq \\mathsf{w} = (\\vec{\\mathbf{f}},\\mathsf{w}_{\\mathsf{ccs}})</span>. <span class="math">\\mathsf{V}</span> outputs <span class="math">\\mathbf{z}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}},\\mathsf{cm},[\\mathbf{u}_j]_{j = 1}^t,\\mathbf{z}_{\\mathsf{ccs}},1)</span>.</li>

    </ol>

    <p class="text-gray-300">First, by definitions of <span class="math">[\\mathbf{u}_j]_{j=1}^t</span>, we have that <span class="math">\\mathsf{V}</span> passes the check at Step 4 and accepts.</p>

    <p class="text-gray-300">Next we argue that the protocol's output <span class="math">(\\mathsf{pp}, \\mathsf{z}_o; \\mathsf{w}_o)</span> is in the relation <span class="math">\\mathcal{R}_2 \\coloneqq \\mathcal{R}_{\\text{evalccs}}^B</span> (Eq. (35)) and completeness holds. It suffices to check that <span class="math">\\mathbf{z}_{\\mathrm{ccs}} = \\mathbf{G}\\vec{\\mathbf{f}}</span> and certain statements are in <span class="math">\\mathcal{R}_{\\text{eval}}^B</span> and <span class="math">\\mathcal{R}_{\\mathrm{lccs}}</span> respectively. We argue them one by one:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{z}_{\\mathrm{ccs}} = \\mathbf{G}\\vec{\\mathbf{f}}</span> because <span class="math">(\\mathsf{pp},\\mathsf{z};\\mathsf{w})\\in \\mathcal{R}_{\\mathsf{cmccs}}^B</span> by assumption.</li>

      <li><span class="math">(\\mathsf{pp}, (\\vec{\\mathbf{r}}_o, \\hat{\\mathbf{v}}, \\mathsf{cm}); \\vec{\\mathbf{f}})</span> is in <span class="math">\\mathcal{R}_{\\text{eval}}^B</span> because (i) <span class="math">\\hat{\\mathbf{v}} = \\mathsf{mle}\\left[\\vec{\\mathbf{f}}\\right] (\\vec{\\mathbf{r}}_o)</span> and (ii) <span class="math">(\\mathsf{pp}, \\mathsf{cm}, \\vec{\\mathbf{f}})</span> is in <span class="math">\\mathcal{R}_{\\mathsf{cm}}^B</span> by the assumption that <span class="math">(\\mathsf{pp}, \\mathsf{z}; \\mathsf{w})</span> is in <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{cmccs}}^B</span>.</li>

      <li><span class="math">(\\mathsf{pp}_{\\mathrm{ccs}}, (\\vec{\\mathbf{r}}_o, [\\mathbf{u}_j]_{j=1}^t, \\mathbf{z}_{\\mathrm{ccs}}, \\mathbf{h}); \\mathbf{w}_{\\mathrm{ccs}})</span> is in <span class="math">\\mathcal{R}_{\\mathrm{lccs}}</span> by the assignments of <span class="math">[\\mathbf{u}_j]_{j=1}^t</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Knowledge soundness:</strong> Let <span class="math">(\\mathbf{z} := (\\mathsf{cm}, \\mathbf{z}_{\\mathrm{ccs}}), \\mathsf{state}) \\gets \\mathcal{A}(\\mathsf{pp})</span> denote adversary <span class="math">\\mathcal{A}</span>'s chosen input for <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{cmccs}}^B</span>, where <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^\\lambda)</span> is the public parameter. The extractor <span class="math">\\mathsf{Ext}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the protocol <span class="math">\\langle \\mathsf{P}^{<em>}(\\mathsf{pp},\\mathsf{z},\\mathsf{state}),\\mathsf{V}(\\mathsf{pp},\\mathsf{z})\\rangle</span> where <span class="math">\\mathsf{P}^</em></span> is the malicious prover.</li>

      <li>Abort and output <span class="math">\\perp</span> if <span class="math">\\mathsf{V}</span> rejects.</li>

      <li>Otherwise, let <span class="math">(\\mathsf{z}_o,\\mathsf{w}_o)</span> be the protocol output where <span class="math">\\mathsf{z}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}},\\mathsf{cm},[\\mathbf{u}_j]_{j = 1}^t,\\mathsf{z}_{\\mathrm{ccs}},1)</span> and <span class="math">\\mathsf{w}_o\\coloneqq (\\vec{\\mathbf{f}},\\mathsf{w}_{\\mathrm{ccs}})</span>. Abort and output <span class="math">\\perp</span> if <span class="math">(\\mathsf{pp},\\mathsf{z}_o,\\mathsf{w}_o)\\notin \\mathcal{R}_{\\mathrm{evalccs}}^B</span> (Eq. (35)).</li>

      <li>Otherwise, if <span class="math">(\\mathsf{pp}, \\mathsf{z}_o, \\mathsf{w}_o) \\in \\mathcal{R}_{\\text{evalccs}}^B</span>, the extractor outputs <span class="math">\\mathsf{w} := (\\vec{\\mathbf{f}}, \\mathsf{w}_{\\mathrm{ccs}})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">E_{\\mathrm{bad}}</span> denote the bad event that (i) <span class="math">\\mathsf{V}</span> accepts and the protocol's output <span class="math">(\\mathsf{z}_o, \\mathsf{w}_o)</span> satisfies that <span class="math">(\\mathsf{pp}, \\mathsf{z}_o, \\mathsf{w}_o) \\in \\mathcal{R}_2 := \\mathcal{R}_{\\text{evalccs}}^B</span> but (ii) <span class="math">(\\mathsf{pp}, \\mathsf{z}; \\mathsf{w})</span> is not in <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{cmccs}}^B</span> (Eq. (33)). To prove knowledge soundness, it suffices to argue that $\\operatorname*{Pr}[E_{\\mathrm{bad}}] \\leq \\frac{(2b + 1)\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that if <span class="math">(\\mathsf{pp}, \\mathsf{z}_o, \\mathsf{w}_o)</span> is in <span class="math">\\mathcal{R}_2 \\coloneqq \\mathcal{R}_{\\text{evalccs}}^B</span> (Eq. (35)), the following hold: (i) <span class="math">(\\mathbf{z}_{\\mathrm{ccs}} = \\mathbf{G}\\vec{\\mathbf{f}})</span>, (ii) <span class="math">(\\mathsf{pp}, \\mathsf{cm}; \\vec{\\mathbf{f}})</span> is in <span class="math">\\mathcal{R}_{\\mathrm{cm}}^B</span>, and (iii) <span class="math">(\\mathsf{pp}_{\\mathrm{ccs}}, (\\vec{\\mathbf{r}}_o, [\\mathbf{u}]_{i=1}^t, \\mathsf{z}_{\\mathrm{ccs}}, 1); \\mathsf{w}_{\\mathrm{ccs}})</span> is in <span class="math">\\mathcal{R}_{\\mathrm{lccs}}</span> (Eq. (34)). From (i) and (ii), the sumcheck polynomial <span class="math">g</span> is fixed before sampling <span class="math">\\vec{\\mathbf{r}}_o</span>, as the witness <span class="math">\\mathbf{z}_{\\mathrm{ccs}}</span> is bound to <span class="math">\\mathsf{cm}</span>. Additionally, from (iii) and because the verifier check at Step 4 passes, the sum-check random evaluation <span class="math">g(\\vec{\\mathbf{r}}_o) \\stackrel{?}{=} s</span> passes. Therefore, if <span class="math">\\sum_{\\vec{\\mathbf{b}} \\in \\{0,1\\}^{\\log m}} g(\\vec{\\mathbf{b}}) \\neq 0</span>, by sumcheck soundness, the probability that <span class="math">(\\mathsf{pp}, \\mathsf{z}_o, \\mathsf{w}_o) \\in \\mathcal{R}_{\\text{evalccs}}^B</span> is at most $\\frac{2b\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ (over the sum-check challenges).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next we argue that if <span class="math">(\\mathsf{pp}_{\\mathrm{ccs}},\\mathsf{z}_{\\mathrm{ccs}};\\mathsf{w}_{\\mathrm{ccs}})\\notin \\mathcal{R}_{\\mathrm{ccs}}</span>, then <span class="math">\\sum_{\\vec{\\mathbf{b}}\\in \\{0,1\\}^{\\log m}}g(\\vec{\\mathbf{b}})\\neq 0</span> with high probability. Define multilinear polynomial <span class="math">p(\\vec{\\mathbf{x}})</span> as</p>

    <div class="my-4 text-center"><span class="math-block">p (\\vec {\\mathbf {x}}) := \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} e q (\\vec {\\mathbf {x}}, \\vec {\\mathbf {b}}) \\cdot \\left(\\sum_ {i = 1} ^ {n _ {x}} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\left(\\sum_ {\\vec {\\mathbf {y}} \\in \\{0, 1 \\} ^ {\\log n _ {c}}} \\mathsf {m l e} [ M _ {j} ] (\\vec {\\mathbf {b}}, \\vec {\\mathbf {y}}) \\cdot \\mathsf {m l e} [ \\mathbf {z} _ {\\mathrm {c c s}} ] (\\vec {\\mathbf {y}})\\right)\\right).</span></div>

    <p class="text-gray-300">By definition of <span class="math">g</span>, it's clear that <span class="math">\\sum_{\\vec{\\mathbf{b}} \\in \\{0,1\\}^{\\log m}} g(\\vec{\\mathbf{b}}) = 0</span> if and only if <span class="math">p(\\vec{\\beta}) = 0</span>. Moreover, <span class="math">(\\mathsf{pp}_{\\mathrm{ccs}}, \\mathsf{z}_{\\mathrm{ccs}}; \\mathsf{w}_{\\mathrm{ccs}}) \\notin \\mathcal{R}_{\\mathrm{ccs}}</span> (Definition 4.1) implies that <span class="math">p(\\vec{\\mathbf{x}}) \\neq 0</span> for some <span class="math">\\vec{\\mathbf{x}} \\in \\{0,1\\}^{\\log m}</span> and</p>

    <p class="text-gray-300">68</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">p(\\vec{\\mathbf{x}})</span> is not a zero polynomial. Since <span class="math">\\vec{\\beta} \\leftarrow \\mathcal{C}^{\\log m}</span> is uniformly chosen from the sampling set <span class="math">\\mathcal{C}</span> (Defn 2.1), by the Generalized Schwartz-Zippel Lemma (Lemma 2.4), the probability that <span class="math">p(\\vec{\\mathbf{x}}) \\neq 0</span> while <span class="math">p(\\vec{\\beta}) = 0</span> is at most $\\log m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In summary, the probability that <span class="math">E_{\\mathrm{bad}}</span> occurs is at most $\\frac{\\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{2b \\log m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, which finishes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-60" class="text-2xl font-bold">B.2 Proof of Lemma 4.2</h2>

    <p class="text-gray-300"><strong>Proof.</strong> <em>Public reducibility:</em> Given instance <span class="math">\\mathbf{z} = (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y,\\mathbf{u},\\mathbf{z}_w)</span> and transcript <span class="math">[\\hat{\\mathbf{v}}_i,y_i,\\mathbf{u}_i,\\mathbf{z}_{w,i}]_{i=0}^{k-1}</span>, one outputs <span class="math">[\\mathbf{z}_i := (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i,\\mathbf{u}_i,\\mathbf{z}_{w,i})]_{i=0}^{k-1}</span> if the verifier checks pass; otherwise it outputs <span class="math">\\perp</span>.</p>

    <p class="text-gray-300"><em>Completeness:</em> Let <span class="math">(\\mathbf{z},\\mathbf{w}) := \\left((\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y,\\mathbf{u},\\mathbf{z}_w),(\\vec{\\mathbf{f}},\\vec{\\mathbf{w}})\\right) \\leftarrow \\mathcal{A}(\\mathsf{pp})</span> denote adversary <span class="math">\\mathcal{A}</span>'s chosen instance-witness pair for <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{ccshom}}^B</span> (Eq. (36)), where <span class="math">\\mathsf{pp} := (\\mathcal{L},\\mathcal{L}_w,\\overline{M}) \\leftarrow \\mathsf{Setup}(1^\\lambda)</span> is the public parameter. WLOG we assume that <span class="math">(\\mathsf{pp},\\mathbf{z};\\mathbf{w})</span> is in <span class="math">\\mathcal{R}_{\\mathsf{ccshom}}^B</span>. The protocol <span class="math">\\langle \\mathsf{P}(\\mathsf{pp},\\mathbf{z},\\mathbf{w}),\\mathsf{V}(\\mathsf{pp},\\mathbf{z})\\rangle</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span> computes <span class="math">\\vec{\\mathbf{F}} := (\\vec{\\mathbf{f}}_0, \\dots, \\vec{\\mathbf{f}}_{k-1}) := \\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})</span> (Eq. (11)) and sends <span class="math">\\mathsf{V}</span> values</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">y _ {i} := \\mathcal {L} (\\vec {\\mathbf {f}} _ {i}), \\quad \\hat {\\mathbf {v}} _ {i} := \\operatorname {m l e} \\left[ \\hat {\\mathbf {f}} _ {i} \\right] (\\vec {\\mathbf {r}}),</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {u} _ {i} := \\left\\langle \\overline {{M}} \\times \\operatorname {t e n s o r} (\\vec {\\mathbf {r}}), \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {i}) \\right\\rangle , \\quad \\left(\\mathbf {z} _ {w, i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}} _ {i}\\right) := \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {i}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for every <span class="math">i\\in [0,k)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> outputs <span class="math">\\perp</span> and halts if the check <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot [y_i, \\hat{\\mathbf{v}}_i, \\mathbf{u}_i, \\mathbf{z}_{w,i}] \\stackrel{?}{=} [y, \\hat{\\mathbf{v}}, \\mathbf{u}, \\mathbf{z}_w]</span> fails.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span> outputs <span class="math">[\\vec{\\mathbf{f}}_i,\\vec{\\mathbf{w}}_i]_{i = 0}^{k - 1}</span>. <span class="math">\\mathsf{V}</span> outputs <span class="math">[\\mathbf{z}_i\\coloneqq (\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i,\\mathbf{u}_i,\\mathbf{z}_{w,i})]_{i = 0}^{k - 1}</span>.</li>

    </ol>

    <p class="text-gray-300">We first show that if <span class="math">\\mathsf{V}</span> accepts, then the protocol's output satisfies that for all <span class="math">i\\in [0,k)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p p}, \\left(\\vec {\\mathbf {r}}, \\hat {\\mathbf {v}} _ {i}, y _ {i}, \\mathbf {u} _ {i}, \\mathbf {z} _ {w, i}\\right); \\left(\\vec {\\mathbf {f}} _ {i}, \\vec {\\mathbf {w}} _ {i}\\right)\\right) \\in \\mathcal {R} _ {\\mathsf {c c s h o m}} ^ {b}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This follows given how <span class="math">[y_i, \\hat{\\mathbf{v}}_i, \\mathbf{u}_i, \\mathbf{z}_{w,i}]_{i=0}^{k-1}</span> are computed, and because $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{f}}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; b<span class="math"> for all </span>i \\in [0,k)<span class="math"> by the property of the algorithm </span>\\mathsf{split}_{b,k}(\\vec{\\mathbf{f}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It remains to argue that <span class="math">\\mathsf{V}</span> will accept, that is, the check <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot [y_i, \\hat{\\mathbf{v}}_i, \\mathbf{u}_i, \\mathbf{z}_{w,i}] \\stackrel{?}{=} [y, \\hat{\\mathbf{v}}, \\mathbf{u}, \\mathbf{z}_w]</span> passes. By Lemma 3.4, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot y _ {i} = y, \\qquad \\sum_ {i = 0} ^ {k - 1} b ^ {i} \\cdot \\hat {\\mathbf {v}} _ {i} = \\hat {\\mathbf {v}}.</span></div>

    <p class="text-gray-300">Since <span class="math">\\mathcal{L}_w</span> is an <span class="math">\\mathcal{R}_q</span>-module homomorphism, by the same argument for proving <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot y_i = y</span>, it also holds that <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot \\mathbb{z}_{w,i} = \\mathbb{z}_w</span>. Finally, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{i=0}^{k-1} b^i \\cdot \\mathbf{u}_i &amp;amp;= \\sum_{i=0}^{k-1} b^i \\cdot \\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\mathcal{L}_w(\\vec{\\mathbf{f}}_i) \\right\\rangle = \\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\sum_{i=0}^{k-1} b^i \\cdot \\mathcal{L}_w(\\vec{\\mathbf{f}}_i) \\right\\rangle \\\\ &amp;amp;= \\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\mathcal{L}_w\\left(\\sum_{i=0}^{k-1} b^i \\cdot \\vec{\\mathbf{f}}_i\\right) \\right\\rangle = \\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\mathcal{L}_w(\\vec{\\mathbf{f}}) \\right\\rangle = \\mathbf{u}. \\end{aligned}</span></div>

    <p class="text-gray-300">The 1st equality is by definition of <span class="math">[\\mathbf{u}_i]_{i=0}^{k-1}</span>; the 2nd equality is by the property of inner products; the 3rd equality holds because <span class="math">\\mathcal{L}_w</span> is an <span class="math">\\mathcal{R}_q</span>-module homomorphism; the 4th equality is by definition of decomposition (Eq. (11)); the last equality holds because <span class="math">(\\mathsf{pp}, \\mathbb{z}; \\mathbb{w})</span> is in <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{ccshom}}^B</span> (Eq. (36)) by assumption, whereas <span class="math">\\mathcal{R}_{\\mathsf{ccshom}}^B</span> checks that <span class="math">\\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\mathcal{L}_w(\\vec{\\mathbf{f}}) \\right\\rangle = \\mathbf{u}</span>. Therefore, <span class="math">\\mathsf{V}</span> will accept and thus completeness holds.</p>

    <p class="text-gray-300"><strong>Knowledge soundness:</strong> Let <span class="math">(\\mathbb{z} := (\\hat{\\mathbf{v}}, y, \\mathbf{u}, \\mathbb{z}_w), \\text{state}) \\leftarrow \\mathcal{A}(\\mathsf{pp})</span> denote adversary <span class="math">\\mathcal{A}</span>'s chosen input instance for <span class="math">\\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{ccshom}}^B</span>, where <span class="math">\\mathsf{pp} := (\\mathcal{L}, \\mathcal{L}_w, \\overline{M}) \\leftarrow \\mathsf{Setup}(1^\\lambda)</span> is the public parameter. The extractor <span class="math">\\mathsf{Ext}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the protocol <span class="math">\\langle \\mathsf{P}^{<em>}(\\mathsf{pp},\\mathbb{z},\\mathsf{state}),\\mathsf{V}(\\mathsf{pp},\\mathbb{z})\\rangle</span> where <span class="math">\\mathsf{P}^</em></span> is the malicious prover.</li>

      <li>Output <span class="math">\\perp</span> if <span class="math">\\mathsf{V}</span> rejects. Otherwise let <span class="math">(\\mathbb{z}_o, \\mathbb{w}_o) := [(\\vec{\\mathbf{r}}, \\hat{\\mathbf{v}}_i, y_i, \\mathbf{u}_i, \\mathbb{z}_{w,i}); (\\vec{\\mathbf{f}}_i, \\vec{\\mathbf{w}}_i)]_{i=0}^{k-1}</span> be the protocol output (note that <span class="math">\\vec{\\mathbf{r}}</span> is the same as that in the input instance <span class="math">\\mathbb{z}</span> to pass the verification check). The extractor outputs witness <span class="math">\\mathbb{w} := (\\vec{\\mathbf{f}}, \\vec{\\mathbf{w}})</span> where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\vec{\\mathbf{f}} := \\sum_{i=0}^{k-1} b^i \\cdot \\vec{\\mathbf{f}}_i, \\quad \\vec{\\mathbf{w}} := \\sum_{i=0}^{k-1} b^i \\cdot \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)[n_{\\mathrm{in}} + 1, n_{\\mathrm{in}} + n]. \\tag{44}</span></div>

    <p class="text-gray-300">To prove knowledge soundness, it suffices to show that if <span class="math">\\mathsf{V}</span> accepts and the output <span class="math">(\\mathbb{z}_o, \\mathbb{w}_o)</span> satisfies that <span class="math">(\\mathsf{pp}, \\mathbb{z}_o, \\mathbb{w}_o) \\in \\mathcal{R}_2 := (\\mathcal{R}_{\\mathsf{ccshom}}^b)^k</span>, then the extracted witness <span class="math">\\mathbb{w}</span> satisfies that <span class="math">(\\mathsf{pp}, \\mathbb{z}, \\mathbb{w}) \\in \\mathcal{R}_1 := \\mathcal{R}_{\\mathsf{ccshom}}^B</span>.</p>

    <p class="text-gray-300">By Lemma 3.5, we have that <span class="math">(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y;\\vec{\\mathbf{f}}) \\in \\mathcal{R}_{\\mathsf{hom}}^B</span> if <span class="math">[(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_i,y_i);\\vec{\\mathbf{f}}_i]_{i=0}^{k-1}</span> is in <span class="math">(\\mathcal{R}_{\\mathsf{hom}}^b)^k</span>. By definition of <span class="math">\\mathcal{R}_{\\mathsf{ccshom}}^B</span> (Eq. (36)), it remains to argue that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_i := (\\mathbb{z}_{w,i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_i) = \\mathcal{L}_w(\\vec{\\mathbf{f}}_i) \\quad \\forall i \\in [0, k) \\quad \\Longrightarrow \\quad \\mathbf{z} := (\\mathbb{z}_w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}) = \\mathcal{L}_w(\\vec{\\mathbf{f}}); \\tag{45}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{u}_i = \\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\mathbf{z}_i \\right\\rangle \\quad \\forall i \\in [0, k) \\quad \\Longrightarrow \\quad \\mathbf{u} = \\left\\langle \\overline{M} \\times \\operatorname{tensor}(\\vec{\\mathbf{r}}), \\mathbf{z} \\right\\rangle. \\tag{46}</span></div>

    <p class="text-gray-300">We first prove Eq. (45). By the verifier check <span class="math">\\sum_{i=0}^{k-1} b^i \\cdot \\mathbb{z}_{w,i} = \\mathbb{z}_w</span> and by Eq. (44), we have that <span class="math">\\mathbf{z} = \\sum_{i=0}^{k-1} b^i \\cdot \\mathbf{z}_i</span>. Since <span class="math">\\mathcal{L}_w</span> is an <span class="math">\\mathcal{R}_q</span>-module homomorphism, Eq. (45) holds by the same argument as in Lemma 3.2 for proving <span class="math">y = \\mathcal{L}(\\vec{\\mathbf{f}})</span> (where we replace <span class="math">y, \\mathcal{L}</span> with <span class="math">\\mathbf{z}, \\mathcal{L}_w</span> respectively).</p>

    <p class="text-gray-300">Similarly, Eq. (46) holds because</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}=\\sum_{i=0}^{k-1}b^{i}\\cdot\\mathbf{u}_{i}=\\sum_{i=0}^{k-1}b^{i}\\cdot\\left\\langle\\overline{M}\\times\\texttt{tensor}(\\vec{\\mathbf{r}}),\\mathbf{z}_{i}\\right\\rangle=\\left\\langle\\overline{M}\\times\\texttt{tensor}(\\vec{\\mathbf{r}}),\\sum_{i=0}^{k-1}b^{i}\\cdot\\mathbf{z}_{i}\\right\\rangle=\\left\\langle\\overline{M}\\times\\texttt{tensor}(\\vec{\\mathbf{r}}),\\mathbf{z}\\right\\rangle</span></p>

    <p class="text-gray-300">where the 1st equality is by the verifier check; the 2nd equality follows from the premise in Eq. (46); the 3rd equality follows from the linearly homomorphic property of inner products; the last equality holds as we’ve proved previously that <span class="math">\\mathbf{z}=\\sum_{i=0}^{k-1}b^{i}\\cdot\\mathbf{z}_{i}</span>.</p>

    <p class="text-gray-300">In summary, <span class="math">(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y;\\vec{\\mathbf{f}})</span> is in <span class="math">\\mathcal{R}^{B}_{\\mathsf{hom}}</span> and Eq. (45), Eq. (46) hold true. Therefore, conditioned on that <span class="math">(\\mathsf{pp},[(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}}_{i},y_{i},\\mathbf{u}_{i},\\mathbf{z}_{w,i});(\\vec{\\mathbf{f}}_{i},\\vec{\\mathbf{w}}_{i})]_{i=0}^{k})</span> is in <span class="math">\\mathcal{R}_{2}:=(\\mathcal{R}^{b}_{\\mathsf{ccshom}})^{k}</span>, the extracted witness <span class="math">(\\vec{\\mathbf{f}},\\vec{\\mathbf{w}})</span> will satisfy that <span class="math">(\\mathsf{pp},(\\vec{\\mathbf{r}},\\hat{\\mathbf{v}},y,\\mathbf{u},\\mathbf{z}_{w});(\\vec{\\mathbf{f}},\\vec{\\mathbf{w}}))</span> is in <span class="math">\\mathcal{R}_{1}:=\\mathcal{R}^{B}_{\\mathsf{ccshom}}</span>, which completes the proof. ∎</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">B.3 Proof of Theorem 4.2</h3>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><em>Public reducibility:</em> Given input instances <span class="math">[\\vec{\\mathbf{r}}_{i},\\hat{\\mathbf{v}}_{i},y_{i},\\mathbf{u}_{i},\\mathbf{z}_{w,i}]_{i=1}^{2k}</span> and the transcript that includes challenges <span class="math">\\vec{\\mathbf{r}}_{o}</span>, evaluations <span class="math">[\\theta_{i}]_{i=1}^{2k}</span>, values <span class="math">[\\eta_{i}]_{i=1}^{2k}</span>, and folding challenges <span class="math">[\\rho_{i}]_{i=1}^{2k}</span>. The algorithm <span class="math">f</span> outputs <span class="math">\\mathbf{z}_{o}:=(\\vec{\\mathbf{r}}_{o},\\hat{\\mathbf{v}}_{o},y_{o},\\mathbf{u}_{o},\\mathbf{z}_{w,o})</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{NTT}(\\hat{\\mathbf{v}}_{o})=\\sum_{i=1}^{2k}\\mathsf{RotSum}(\\rho_{i},\\mathsf{NTT}(\\theta_{i}))\\,,\\quad[y_{o},\\mathbf{u}_{o},\\mathbf{z}_{w,o}]:=\\sum_{i=1}^{2k}\\rho_{i}\\cdot[y_{i},\\eta_{i},\\mathbf{z}_{w,i}]</span></p>

    <p class="text-gray-300">if the verifier checks pass; and output <span class="math">\\perp</span> otherwise. (RotSum defined in Lemma 2.1.)</p>

    <p class="text-gray-300"><em>Completeness:</em> Let</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{z},\\mathbb{w}):=[\\mathbf{z}_{i}=(\\vec{\\mathbf{r}}_{i},\\hat{\\mathbf{v}}_{i},y_{i},\\mathbf{u}_{i},\\mathbf{z}_{w,i}),\\mathbb{w}_{i}=(\\vec{\\mathbf{f}}_{i},\\vec{\\mathbf{w}}_{i})]_{i=1}^{2k}\\leftarrow\\mathcal{A}(\\mathsf{pp})</span></p>

    <p class="text-gray-300">denote adversary <span class="math">\\mathcal{A}</span>’s chosen instance-witness pair for <span class="math">\\mathcal{R}_{1}:=(\\mathcal{R}^{b}_{\\mathsf{hom}})^{2k}</span>, where <span class="math">\\mathsf{pp}:=(\\mathcal{L},\\mathcal{L}_{w},\\overline{M}=M_{1})\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span> is the public parameter. WLOG we assume that <span class="math">(\\mathsf{pp},\\mathbf{z},\\mathbb{w})</span> is in <span class="math">\\mathcal{R}_{1}:=(\\mathcal{R}^{b}_{\\mathsf{ccshom}})^{2k}</span>. The protocol <span class="math">\\left\\langle\\mathsf{P}(\\mathsf{pp},\\mathbf{z},\\mathbb{w}),\\mathsf{V}(\\mathsf{pp},\\mathbf{z})\\right\\rangle</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> honestly run the sum-check and <span class="math">\\mathsf{P}</span> sends values <span class="math">[\\theta_{i},\\eta_{i}]_{i=1}^{2k}</span> honestly such that for every <span class="math">i\\in[2k]</span>,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\eta_{i}:=\\left\\langle\\overline{M}\\times\\texttt{tensor}(\\vec{\\mathbf{r}}_{o}),(\\mathbf{z}_{w,i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_{i})\\right\\rangle\\,,\\qquad\\theta_{i}:=\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_{o}">\\hat{\\mathbf{f}}_{i}\\right</a>\\,.$ (47)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here <span class="math">\\mathsf{tensor}(\\cdot)</span> is defined in Eq. (37) and <span class="math">\\vec{\\mathbf{r}}_{o}</span> is the sum-check challenge vector.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> outputs <span class="math">\\perp</span> and halts if the check at Step 4 fails.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, let <span class="math">[\\rho_i]_{i=1}^{2k}</span> be verifier's last folding challenges. Set <span class="math">(\\hat{\\mathbf{v}}_o, y_o, \\mathbf{u}_o, \\mathbf{z}_{w,o}, \\vec{\\mathbf{f}}_o, \\vec{\\mathbf{w}}_o)</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {N T T} (\\hat {\\mathbf {v}} _ {o}) = \\sum_ {i = 1} ^ {2 k} \\operatorname {R o t S u m} \\left(\\rho_ {i}, \\mathsf {N T T} \\left(\\theta_ {i}\\right)\\right)</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left[ y _ {o}, \\mathbf {u} _ {o}, \\vec {\\mathbf {f}} _ {o}, \\left(\\mathbf {z} _ {w, o} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}} _ {o}\\right) \\right] := \\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot \\left[ y _ {i}, \\eta_ {i}, \\vec {\\mathbf {f}} _ {i}, \\left(\\mathbf {z} _ {w, i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}} _ {i}\\right) \\right]. \\tag {48}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span> outputs <span class="math">\\mathsf{w}_o\\coloneqq (\\vec{\\mathbf{f}}_o,\\vec{\\mathbf{w}}_o)</span>. <span class="math">\\mathsf{V}</span> outputs <span class="math">\\mathbf{z}_o\\coloneqq (\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o,\\mathbf{u}_o,\\mathbf{z}_{w,o})</span>.</li>

    </ol>

    <p class="text-gray-300">First, we show that <span class="math">\\mathsf{V}</span> accepts, meaning the verifier check at Step 4 will pass. This follows from the definition of polynomial <span class="math">g</span> (Eq. (38)) and the definitions of <span class="math">(\\eta_i,\\theta_i)_{i = 1}^{2k}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It remains to argue that the protocol output <span class="math">(\\mathbf{z}_o,\\mathbf{w}_o)</span> satisfies that <span class="math">(\\mathsf{pp}:= (\\mathcal{L},\\mathcal{L}_w,\\overline{M}),\\mathbf{z}_o;\\mathbf{w}_o)\\in \\mathcal{R}_2\\coloneqq \\mathcal{R}_{\\mathrm{ccshom}}^B</span> (Eq. (36)). First, by Lemma 3.6, we have that <span class="math">(\\mathcal{L},(\\vec{\\mathbf{r}}_o,\\hat{\\mathbf{v}}_o,y_o);\\vec{\\mathbf{f}}_o)\\in \\mathcal{R}_{\\mathrm{hom}}^B</span>. Let $\\mathbf{z}_o\\coloneqq (\\mathbf{z}_{w,o}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_o)<span class="math">. It remains to prove that (i) </span>\\mathbf{z}_o = \\mathcal{L}_w(\\vec{\\mathbf{f}}_o)<span class="math"> and (ii) </span>\\mathbf{u}_o = \\left\\langle \\overline{M}\\times \\mathrm{tensor}(\\vec{\\mathbf{r}}_o),\\mathbf{z}_o\\right\\rangle$. Note that (i) holds true because</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {z} _ {o} := \\left(\\mathbf {z} _ {w, o} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}} _ {o}\\right) = \\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot \\left(\\mathbf {z} _ {w, i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}} _ {i}\\right) = \\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {i}) = \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {o}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The 1st equality follows from Eq. (48); the 2nd equality holds because $\\mathcal{L}_w(\\vec{\\mathbf{f}}_i) = (\\mathbf{z}_{w,i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_i)<span class="math"> for all </span>i\\in [2k]<span class="math">, given the premise that </span>(\\mathsf{pp},\\mathbf{z},\\mathsf{w})\\in (\\mathcal{R}_{\\mathrm{ccshom}}^b)^{2k}<span class="math">; the last equality holds due to the fact that </span>\\vec{\\mathbf{f}}_o = \\sum_{i = 1}^{2k}\\rho_i\\cdot \\vec{\\mathbf{f}}_i<span class="math"> and by the homomorphic property of </span>\\mathcal{L}_w$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similarly, (ii) holds true because</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {u} _ {o} = \\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot \\eta_ {i} = \\sum_ {i = 1} ^ {2 k} \\rho_ {i} \\cdot \\left\\langle \\overline {{M}} \\times \\operatorname {t e n s o r} (\\vec {\\mathbf {r}} _ {o}), (\\mathbf {z} _ {w, i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {\\mathbf {w}} _ {i}) \\right\\rangle = \\left\\langle \\overline {{M}} \\times \\operatorname {t e n s o r} (\\vec {\\mathbf {r}} _ {o}), \\mathbf {z} _ {o} \\right\\rangle .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The 1st equality is by the definition of <span class="math">\\mathbf{u}_o</span>; the 2nd equality follows from the definition of <span class="math">\\eta_i</span> in Eq. (47); the last equality holds given the assignment of $\\mathbf{z}_o \\coloneqq (\\mathbf{z}_{w,o}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_o)$ in Eq. (48) and the homomorphic property of inner products.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In sum, <span class="math">(\\mathsf{pp},\\mathbf{z}_o,\\mathbf{w}_o)</span> is in <span class="math">\\mathcal{R}_2\\coloneqq \\mathcal{R}_{\\mathrm{ccshom}}^B</span> (Eq. (36)) and the completeness holds.</p>

    <p class="text-gray-300"><strong>Knowledge soundness:</strong> The extractor <span class="math">\\mathsf{Ext}^{A,\\mathsf{P}^<em>}</span> and the running time analysis are almost identical to the proof of Theorem 3.3. The only difference is that the extractor <span class="math">\\mathsf{Ext}^{A,\\mathsf{P}^</em>}</span>, besides outputting <span class="math">[\\vec{\\mathbf{f}}_i]_{i=1}^{2k}</span>, also outputs <span class="math">[\\vec{\\mathbf{w}}_i := \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)[n_{\\mathrm{in}} + 1, n_{\\mathrm{in}} + n]_{i=1}^{2k}</span>.</p>

    <p class="text-gray-300">Let <span class="math">E_{\\mathrm{ext}}</span> denote the event defined in the proof of Theorem 3.3, indicating that the extractor recovers two identical witnesses <span class="math">\\mathrm{out}_1, \\mathrm{out}_2 \\neq \\bot</span> using two good sets of randomness <span class="math">\\psi</span> and <span class="math">\\psi&#x27;</span>. To argue the success probability of extraction, we replace the events <span class="math">E_{\\mathrm{hom}}</span></p>

    <p class="text-gray-300">(Eq. (21)) and <span class="math">E_{\\mathrm{eval}}</span> (Eq. (22)) with <span class="math">E_{\\mathrm{hom}}^<em></span> and <span class="math">E_{\\mathrm{eval}}^</em></span> defined as follows.</p>

    <div class="my-4 text-center"><span class="math-block">E_{\\mathrm{hom}}^* := E_{\\mathrm{ext}} \\wedge \\left(\\forall i \\in [2k] : \\left(\\mathcal{L}(\\vec{\\mathbf{f}}_i) = y_i\\right) \\wedge \\left(\\left(\\mathbf{z}_{w,i} \\mid \\vec{\\mathbf{w}}_i\\right) = \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)\\right)\\right), \\tag{49}</span></div>

    <div class="my-4 text-center"><span class="math-block">E_{\\mathrm{eval}}^* := E_{\\mathrm{ext}} \\wedge \\left(\\forall i \\in [2k] : \\left(\\mathsf{mle}\\left[\\hat{\\mathbf{f}}_i\\right]\\left(\\vec{\\mathbf{r}}_o&#x27;\\right) = \\theta_i&#x27;\\right) \\wedge \\left(\\eta_i&#x27; = \\langle \\overline{M} \\cdot \\operatorname{tensor}(\\vec{\\mathbf{r}}_o&#x27;), (\\mathbf{z}_{w,i} \\mid \\vec{\\mathbf{w}}_i) \\rangle\\right)\\right). \\tag{50}</span></div>

    <p class="text-gray-300">Moreover, we redefine the event <span class="math">E_{\\mathrm{bad}}</span> (Eq. (23)) as <span class="math">E_{\\mathrm{bad}}^<em></span> such that <span class="math">E_{\\mathrm{bad}}^</em></span> holds if and only if <span class="math">E_{\\mathrm{ext}} = 1</span> and there exists <span class="math">i \\in [2k]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{u}_i \\neq \\left\\langle \\overline{M} \\cdot \\operatorname{tensor}(\\vec{\\mathbf{r}}_i), (\\mathbf{z}_{w,i} \\mid \\vec{\\mathbf{w}}_i) \\right\\rangle \\quad \\text{or} \\quad \\mathsf{mle}\\left[\\hat{\\mathbf{f}}_i\\right] (\\vec{\\mathbf{r}}_i) \\neq \\hat{\\mathbf{v}}_i \\quad \\text{or} \\quad p_i(\\vec{\\mathbf{x}}) \\neq 0. \\tag{51}</span></div>

    <p class="text-gray-300">To reuse the proof of Theorem 3.3, it suffices to prove the following claims.</p>

    <p class="text-gray-300"><strong>Claim 6.</strong> If <span class="math">E_{\\mathrm{ext}}</span> occurs, then <span class="math">E_{\\mathrm{hom}}^<em> \\wedge E_{\\mathrm{eval}}^</em></span> occurs. That is, for all <span class="math">i \\in [2k]</span>, we have that (i) <span class="math">\\mathcal{L}(\\vec{\\mathbf{f}}_i) = y_i</span>, (ii) <span class="math">\\mathsf{mle}\\left<a href="\\vec{\\mathbf{r}}_o&#x27;">\\hat{\\mathbf{f}}_i\\right</a> = \\theta_i&#x27;</span>, (iii) <span class="math">(\\mathbf{z}_{w,i} \\mid \\vec{\\mathbf{w}}_i) = \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)</span>, and (iv) <span class="math">\\eta_i&#x27; = \\langle \\overline{M} \\cdot \\operatorname{tensor}(\\vec{\\mathbf{r}}_o&#x27;), (\\mathbf{z}_{w,i} \\mid \\vec{\\mathbf{w}}_i) \\rangle</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The equations (i), (ii) hold given the proof of Claim 2. To prove (iii), since <span class="math">\\vec{\\mathbf{w}}_i = \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)[n_{\\mathrm{in}} + 1, n_{\\mathrm{in}} + n]</span> by definition, it suffices to show that <span class="math">\\mathbf{z}_{w,i} = \\mathcal{L}_w(\\vec{\\mathbf{f}}_i)[1, n_{\\mathrm{in}}]</span>. Then (iii) follows by replacing <span class="math">\\mathcal{L}</span>, <span class="math">y_i</span> with <span class="math">\\mathcal{L}_w(\\cdot)[1, n_{\\mathrm{in}}]</span>, <span class="math">\\mathbf{z}_{w,i}</span> everywhere respectively and reusing the argument for (i).</p>

    <p class="text-gray-300">To argue (iv), we observe that the map <span class="math">\\phi(\\cdot) \\coloneqq \\left\\langle \\overline{M} \\cdot \\operatorname{tensor}(\\vec{\\mathbf{r}}_o&#x27;), (\\cdot) \\right\\rangle</span>, and the map <span class="math">\\mathcal{L}_w</span> are both <span class="math">\\mathcal{R}_q</span>-module homomorphisms; thus, the composition <span class="math">\\Phi \\coloneqq \\phi \\circ \\mathcal{L}_w</span> is also an <span class="math">\\mathcal{R}_q</span>-module homomorphism. Note that if (iii) holds, then (iv) also holds if <span class="math">\\eta_i&#x27; = \\Phi(\\vec{\\mathbf{f}}_i)</span>, which follows by replacing <span class="math">\\mathcal{L}</span>, <span class="math">y_i</span> with <span class="math">\\Phi</span>, <span class="math">\\eta_i&#x27;</span> everywhere respectively and reusing the argument for (i).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 7.</strong> $\\operatorname{Pr}[E_{\\mathrm{eval}}^<em> \\wedge E_{\\mathrm{bad}}^</em>] \\leq \\frac{(2b + 1)\\log m + 6k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> The proof is similar to that of Claim 3.7. The difference is that we redefine the polynomial <span class="math">h</span> in Eq. (25) to</p>

    <div class="my-4 text-center"><span class="math-block">h([X_i, Y_i, Z_i]_{i=1}^{2k}) := \\sum_{i=1}^{2k} \\left(\\hat{\\mathbf{v}}_i - \\mathsf{mle}\\left[\\hat{\\mathbf{f}}_i\\right](\\vec{\\mathbf{r}}_i)\\right) \\cdot X_i + \\sum_{i=1}^{2k} p_i(\\vec{\\beta}) \\cdot Y_i + \\sum_{i=1}^{2k} \\left(\\langle \\overline{M} \\cdot \\operatorname{tensor}(\\vec{\\mathbf{r}}_i), \\mathbf{z}_i \\rangle - \\mathbf{u}_i\\right) \\cdot Z_i.</span></div>

    <p class="text-gray-300">Note that the sumcheck statement holds if and only if <span class="math">h([\\alpha_i, \\mu_i, \\zeta_i]_{i=1}^{2k}) = 0</span>. This follows from the fact that for all <span class="math">i \\in [2k]</span>, let <span class="math">\\mathbf{z}_i \\coloneqq (\\mathbf{z}_{w,i} \\mid \\vec{\\mathbf{w}}_i)</span>, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{\\vec{\\mathbf{b}} \\in \\{0,1\\}^{\\log m}} g_{3,i}(\\vec{\\mathbf{b}}) &amp;amp;= \\sum_{\\vec{\\mathbf{b}} \\in \\{0,1\\}^{\\log m}} eq(\\vec{\\mathbf{r}}_i, \\vec{\\mathbf{b}}) \\cdot \\left(\\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log(n_{\\mathrm{in}}+n)}} \\mathsf{mle}\\left[\\overline{M}\\right](\\vec{\\mathbf{b}}, \\vec{\\mathbf{y}}) \\cdot \\mathsf{mle}\\left[\\mathbf{z}_i\\right](\\vec{\\mathbf{y}})\\right) \\\\ &amp;amp;= \\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log(n_{\\mathrm{in}}+n)}} \\mathsf{mle}\\left[\\overline{M}\\right](\\vec{\\mathbf{r}}_i, \\vec{\\mathbf{y}}) \\cdot \\mathsf{mle}\\left[\\mathbf{z}_i\\right](\\vec{\\mathbf{y}}) \\\\ &amp;amp;= \\left\\langle \\overline{M} \\cdot \\operatorname{tensor}(\\vec{\\mathbf{r}}_i), \\mathbf{z}_i \\right\\rangle. \\end{aligned}</span></div>

    <p class="text-gray-300">Therefore, we can redefine the events <span class="math">E_2</span> and <span class="math">E_3</span> in the proof of Claim 3.7 as</p>

    <div class="my-4 text-center"><span class="math-block">E_2 := E_{\\text{ext}} \\wedge (h([\\alpha_i&#x27;, \\mu_i&#x27;, \\zeta_i&#x27;], \\beta_{i=1}) = 0) \\wedge</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\exists i \\in [2k] : \\left(\\mathsf{mle} \\left[ \\hat{\\mathbf{f}}_i \\right] (\\vec{\\mathbf{r}}_i) \\neq \\hat{\\mathbf{v}}_i\\right) \\vee (p_i(\\vec{\\beta}') \\neq 0) \\vee \\left(\\mathbf{u}_i \\neq \\langle \\overline{M} \\cdot \\mathsf{tensor}(\\vec{\\mathbf{r}}_i), (\\mathbf{z}_{w,i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\mathbf{w}}_i) \\rangle\\right)\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">E_3 := E_{\\text{eval}}^* \\wedge (h([\\alpha_i&#x27;, \\mu_i&#x27;, \\zeta_i&#x27;], \\beta_{i=1}) \\neq 0)</span></div>

    <p class="text-gray-300">and the same argument used in the proof of Claim 3.7 can be applied here.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">□</p>

    <h2 id="sec-63" class="text-2xl font-bold">B.4 Proof of Lemma 4.3</h2>

    <p class="text-gray-300"><strong>Proof.</strong> <em>Public reducibility:</em> Given instances <span class="math">([\\mathbf{z}_i]_{i=1}^k, \\mathbf{z}&#x27;)</span>, transcripts that includes <span class="math">[\\theta_i, \\theta_i&#x27;, \\rho_i, \\rho_i&#x27;]_{i=1}^k</span>, <span class="math">[\\eta^{i,j}, \\eta_{\\star}^{i,j}]_{i \\in [k], j \\in [t]}</span> and sumcheck challenge <span class="math">\\vec{\\mathbf{r}}_o</span>, if the folding verifier accepts, the algorithm outputs the folded instance according to Step 6 of <span class="math">\\Pi_{\\mathrm{batch}}</span>, and outputs <span class="math">\\perp</span> otherwise.</p>

    <p class="text-gray-300"><strong>Completeness:</strong> Given adversarily chosen statements that are in the corresponding relations, we need to argue that the verifier will accept in an honest execution and the folded statement is in the output relation. The argument for latter is identical to that in the proof of Theorem 4.2. The argument for the verification check at Step 4 is also similar, but we need to further show that for all <span class="math">j \\in [t]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\ell=1}^{k} b^{\\ell-1} \\eta_{\\star}^{\\ell,j} = \\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log(n + n_{\\mathrm{in}})}} \\mathsf{mle} \\left[ M_j \\right] (\\vec{\\mathbf{r}}_o, \\vec{\\mathbf{y}}) \\cdot \\mathsf{mle} \\left[ \\mathbf{z}_{\\mathrm{ccs}} \\right] (\\vec{\\mathbf{y}}), \\tag{52}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{z}_{\\mathrm{ccs}} := (\\mathbf{z}_{\\mathrm{ccs}}, 1, \\mathbf{w}_{\\mathrm{ccs}})</span>. This follows from the facts below. First, for all <span class="math">i \\in [k]</span>, let <span class="math">\\vec{\\mathbf{f}}_i&#x27;</span> denote the <span class="math">i</span>-th low-norm witness vector in <span class="math">\\mathbf{z}&#x27;</span>. For all <span class="math">j \\in [t]</span>, by definition we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\eta_{\\star}^{i,j} = \\sum_{\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log(n + n_{\\mathrm{in}})}} \\mathsf{mle} \\left[ M_j \\right] (\\vec{\\mathbf{r}}_o, \\vec{\\mathbf{y}}) \\cdot \\mathsf{mle} \\left[ \\mathcal{L}_w(\\vec{\\mathbf{f}}_i&#x27;) \\right] (\\vec{\\mathbf{y}}).</span></div>

    <p class="text-gray-300">Moreover, for all <span class="math">\\vec{\\mathbf{y}} \\in \\{0,1\\}^{\\log(n + n_{\\mathrm{in}})}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\ell=1}^{k} b^{\\ell-1} \\mathsf{mle} \\left[ \\mathcal{L}_w(\\vec{\\mathbf{f}}_i&#x27;) \\right] (\\vec{\\mathbf{y}}) = \\mathsf{mle} \\left[ \\sum_{\\ell=1}^{k} b^{\\ell-1} \\mathcal{L}_w(\\vec{\\mathbf{f}}_i&#x27;) \\right] (\\vec{\\mathbf{y}}) = \\mathsf{mle} \\left[ \\mathcal{L}_w \\left( \\sum_{\\ell=1}^{k} b^{\\ell-1} \\vec{\\mathbf{f}}_i&#x27; \\right) \\right] (\\vec{\\mathbf{y}}) = \\mathsf{mle} \\left[ \\mathbf{z}_{\\mathrm{ccs}} \\right] (\\vec{\\mathbf{y}}).</span></div>

    <p class="text-gray-300">Therefore, Eq. (52) holds and completeness follows.</p>

    <p class="text-gray-300"><strong>Knowledge soundness:</strong> The extractor <span class="math">\\mathsf{Ext}^{A,P^*}</span> and the running time analysis are identical to the proof of Theorem 4.2. The main difference lies in the analysis of the success probability. Here we need to further argue that the extracted witness for relation <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{b,k}</span> satisfies the</p>

    <p class="text-gray-300">CCS relation (i.e., <span class="math">(\\mathsf{pp}_{\\mathsf{ccs}},\\mathsf{z}_{\\mathsf{ccs}};\\mathsf{w}_{\\mathsf{ccs}})\\in \\mathcal{R}_{\\mathsf{ccs}}</span>). To show this, let <span class="math">z_{\\mathsf{ccs}}:=(\\mathsf{z}_{\\mathsf{ccs}},1,\\mathsf{w}_{\\mathsf{ccs}})</span>, we define the multilinear polynomial <span class="math">q(\\vec{\\mathbf{x}})</span> the same way as we did in the proof of Lemma 4.1,</p>

    <div class="my-4 text-center"><span class="math-block">q (\\vec {\\mathbf {x}}) := \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} e q (\\vec {\\mathbf {x}}, \\vec {\\mathbf {b}}) \\cdot \\left(\\sum_ {i = 1} ^ {n _ {s}} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\left(\\sum_ {\\vec {\\mathbf {y}} \\in \\{0, 1 \\} ^ {\\log n + n _ {\\mathrm {i n}}}} \\mathsf {m l e} [ M _ {j} ] (\\vec {\\mathbf {b}}, \\vec {\\mathbf {y}}) \\cdot \\mathsf {m l e} [ \\mathbf {z} _ {\\mathsf {c c s}} ] (\\vec {\\mathbf {y}})\\right)\\right).</span></div>

    <p class="text-gray-300">Recall that <span class="math">(\\mathsf{pp}_{\\mathsf{ccs}},\\mathsf{z}_{\\mathsf{ccs}};\\mathsf{w}_{\\mathsf{ccs}})\\in \\mathcal{R}_{\\mathsf{ccs}}</span> if and only if the multilinear polynomial <span class="math">q(\\vec{\\mathbf{x}})</span> is a zero polynomial. Similar to the proof of Theorem 4.2, we need to define the bad event <span class="math">E_{\\mathrm{bad}}^{<em>}</span> and prove that <span class="math">E_{\\mathrm{bad}}^{</em>}</span> happens with small probability. Here the definition of <span class="math">E_{\\mathrm{bad}}^{<em>}</span> is almost identical to that in Eq. (51) except that we add that <span class="math">E_{\\mathrm{bad}}^{</em>}</span> also holds true if <span class="math">q(\\vec{\\mathbf{x}})\\neq 0</span>.</p>

    <p class="text-gray-300">Next, similar to Claim 7, we have to provide an upper-bound on the probability that the evaluation check passes while the bad event happens, that is, <span class="math">\\operatorname<em>{Pr}[E_{\\mathrm{eval}}^</em> \\wedge E_{\\mathrm{bad}}^<em>]</span>. Here, <span class="math">E_{\\mathrm{eval}}^</em></span> is similarly defined as in Eq. (50) except that we add the following predicate: for all <span class="math">i \\in [k]</span>, let <span class="math">\\vec{\\mathbf{f}}_i^j</span> denote the <span class="math">i</span>-th low-norm extracted witness for <span class="math">\\mathcal{R}_{\\mathrm{splitccs}}^{k,k}</span>, then for all <span class="math">j \\in [t]</span>, check</p>

    <div class="my-4 text-center"><span class="math-block">\\eta_ {*} ^ {i, j} = \\sum_ {\\vec {\\mathbf {y}} \\in \\{0, 1 \\} ^ {\\log (n + n _ {\\mathrm {i n}})}} \\mathsf {m l e} [ M _ {j} ] (\\vec {\\mathbf {r}} _ {o}, \\vec {\\mathbf {y}}) \\cdot \\mathsf {m l e} [ \\mathcal {L} _ {w} (\\vec {\\mathbf {f}} _ {i} ^ {j}) ] (\\vec {\\mathbf {y}}).</span></div>

    <p class="text-gray-300">Note that we can obtain an analogous claim as in Claim 6 with exactly the same proof.</p>

    <p class="text-gray-300">Finally, we use the same technique in the proof of Claim 7 to bound the probability <span class="math">\\operatorname<em>{Pr}[E_{\\mathrm{eval}}^</em> \\wedge E_{\\mathrm{bad}}^*]</span>. A key observation is that <span class="math">q(\\vec{\\beta})</span> can be understood as a sumcheck statement, that is,</p>

    <div class="my-4 text-center"><span class="math-block">q (\\vec {\\beta}) = \\sum_ {\\vec {\\mathbf {b}} \\in \\{0, 1 \\} ^ {\\log m}} g _ {\\mathrm {c c s}} ^ {\\prime} (\\vec {\\mathbf {b}})</span></div>

    <p class="text-gray-300">where <span class="math">g_{\\mathrm{ccs}}&#x27;(\\vec{\\mathbf{x}})</span> is defined in Eq. (41). Therefore, by analogously defining the polynomial <span class="math">h</span> and adding the term <span class="math">q(\\vec{\\beta}) \\cdot W</span> inside <span class="math">h</span> (where <span class="math">W</span> is a formal variable), we can go through exactly the same route as in the proof of Claim 7 to argue that <span class="math">\\operatorname<em>{Pr}[E_{\\mathrm{eval}}^</em> \\wedge E_{\\mathrm{bad}}^*]</span> is small.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">75</p>`;
---

<BaseLayout title="LatticeFold: A Lattice-based Folding Scheme and its Applicat... (2024/257)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/257
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
