---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1229';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Transparent SNARKs from DARK Compilers';
const AUTHORS_HTML = 'Benedikt Bünz, Ben Fisch, Alan Szepieniec';

const CONTENT = `    <p class="text-gray-300">Benedikt Bünz^{1} benedikt@cs.stanford.edu Ben Fisch^{1} benafisch@gmail.com Alan Szepieniec^{2} alan@nervos.org ^{1Stanford University ^{2}Nervos Foundation</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We construct a new polynomial commitment scheme for univariate and multivariate polynomials over finite fields, with logarithmic size evaluation proofs and verification time, measured in the number of coefficients of the polynomial. The underlying technique is a <em>Diophantine Argument of Knowledge</em> (DARK), leveraging integer representations of polynomials and groups of unknown order. Security is shown from the strong RSA and the adaptive root assumptions. Moreover, the scheme does not require a trusted setup if instantiated with class groups. We apply this new cryptographic compiler to a restricted class of algebraic linear IOPs, which we call <em>Polynomial IOPs</em>, to obtain doubly-efficient public-coin interactive arguments of knowledge for any NP relation with succinct communication. With linear preprocessing, the online verifier’s work is logarithmic in the circuit complexity of the relation.</p>

    <p class="text-gray-300">There are many existing examples of Polynomial IOPs (PIOPs) dating back to the first PCP (BFLS, STOC’91). We present a generic compilation of any PIOP using our DARK polynomial commitment scheme. In particular, compiling the PIOP from PLONK (GWC, ePrint’19), an improvement on Sonic (MBKM, CCS’19), yields a public-coin interactive argument with quasi-linear preprocessing, quasi-linear (online) prover time, logarithmic communication, and logarithmic (online) verification time in the circuit size. Applying the Fiat-Shamir transform results in a SNARK, which we call Supersonic.</p>

    <p class="text-gray-300">Supersonic is also concretely efficient with 10KB proofs and under 100ms verification time for circuits with 1 million gates (estimated for 120-bit security). Most importantly, this SNARK is <em>transparent</em>: it does not require a trusted setup. We obtain zk-SNARKs by applying a hiding variant of our polynomial commitment scheme with zero-knowledge evaluations. Supersonic is the first complete zk-SNARK system that has both a practical prover time as well as asymptotically <em>logarithmic</em> proof size and verification time. This version of the paper includes a new security proof. The original proof had a significant gap that was discovered by Block et al. (CRYPTO 2021). The new security proof closes the gap and shows that the original protocol with a slightly adjusted parameter is still secure. Towards this goal, we introduce the notion of almost-special-sound protocols which likely has broader applications.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Since the landmark discoveries of <em>interactive proofs</em> (IPs) <em>[x10]</em> and <em>probabilistically checkable proofs</em> (PCPs) <em>[x5, ALM^{+}92]</em> in the 90s, there has been tremendous development in the area of proof systems whereby a prover establishes the correct performance of an arbitrary computation in a way that can be verified much more efficiently than performing the computation itself. Such proof systems are <em>succinct</em> if they also have a low communication cost between the prover and the verifier, <em>i.e.</em>, the transcript of the protocol is much smaller than a witness to the computation. There are also <em>zero knowledge</em> variants of these efficient proof systems, beginning with ZK-IPs <em>[BGG^{+}88]</em> and ZK-PCPs <em>[x16]</em>, in which the computation may involve secret information and the prover demonstrates correct performance without leaking the secrets. As a toy example, one could prove that a chess position is winning for white without actually revealing the winning moves themselves. General purpose zero-knowledge proofs <em>[x11]</em> can be very expensive in terms of proof size</p>

    <p class="text-gray-300">and verification time even for computations that would be easy to perform given the secret inputs (e.g., by proving that one decrypted a file properly without leaking the key or the plaintext). The same techniques that are used to build efficient proof systems for expensive computations are also useful for making zero-knowledge proofs more practical.</p>

    <p class="text-gray-300">In recent years, there has been a surge of industry interest in verifiable outsourced computation <em>[x20]</em> (such as trustless cloud computing) as well as zero-knowledge proofs. In particular, blockchains use efficient zero-knowledge proofs as a solution for balancing privacy and publicly-verifiable integrity: examples include anonymous transactions in ZCash <em>[BCG^{+}14, x18]</em> and verifying Ethereum smart contracts over private inputs <em>[x11]</em>. In these applications, zero-knowledge proofs are posted to the blockchain ledger as a part of transactions and nodes must verify many proofs in the span of a short period of time. Therefore, succinctness and fast verification are necessary properties for the deployment of such proof systems. Verifiable computation is also being explored as a scaling solution for blockhain transactions <em>[x3]</em>, and even as a way to entirely eliminate the need for maintaining historical blockchain data <em>[x14]</em>.</p>

    <p class="text-gray-300">Following this pragmatic interest, there has also been a surge of research focused on obtaining proof systems with better concrete efficiency characteristics: succinctness (the proof size is sublinear in the original computation length <span class="math">T</span>), non-interactivity (the proof is a single message), prover-scalability (proof generation time scales linearly or quasi-linearly in <span class="math">T</span>), and verifier-scalability (verification time is sublinear in <span class="math">T</span>). Proof systems that achieve all of these properties for general NP statements are called SNARGs (“succinct non-interactive arguments”). The proof is called an argument when it is only sound assuming the prover is computationally bounded, i.e., computationally sound as opposed to statistically sound. Succinct statistically sound proofs are unlikely to exist <em>[x10, x17]</em>.</p>

    <p class="text-gray-300">Currently, there are numerous constructions that achieve different tradeoffs between proof size, proof time, and verification time, but also under different trust models as well as cryptographic assumptions. Some constructions also achieve better efficiency by relying on a preprocessing model in which a one-time expensive setup procedure is performed in order to generate a compact verification key VK, which is later used to verify proof instances efficiently. Somewhat unfortunately, the best performing proof systems to date (considering proof size and verification time) require a trusted preprocessing. These are the pairing-based SNARKs extending from GGPR <em>[x8, SBV^{+}13, BCI^{+}13, BCG^{+}13, x12]</em>, which have been implemented in numerous libraries <em>[BCG^{+}13, x4]</em>, and even deployed in live systems such as the ZCash <em>[x18]</em> cryptocurrency. The trusted setup can be performed via multi-party computation (MPC) by a committee of parties, such that trust in only one of the parties is sufficient. This has been done on two occasions for the ZCash blockchain, involving elaborate “ceremonies” to engender public trust in the process <em>[x19]</em>.</p>

    <p class="text-gray-300">A proof system is called transparent if it does not involve any trusted setup. Recent progress has yielded transparent proof systems for special types of computations: zk-STARKs <em>[x2]</em> generate zero-knowledge proofs of size <span class="math">O(\\log^{2}T)</span> for a uniform computation, and the GKR protocol produces interactive proofs with communication <span class="math">O(d\\log T)</span> for computations expressed as low-depth circuits of total size <span class="math">T</span> and depth <span class="math">d</span> <em>[x13]</em>. In both cases, non-interactivity can be achieved in the random oracle model with the Fiat-Shamir heuristic <em>[x11, CCH^{+}19]</em>. These transparent proof systems perform significantly worse than SNARKs based on preprocessing. For computations expressed as an arithmetic circuit of 1-million gates, STARKs <em>[x2]</em> report a proof size of 600KB, whereas preprocessing SNARKs achieve 200 bytes <em>[x12]</em>. Bulletproofs <em>[BBB^{+}18, BCC^{+}16a]</em> is a transparent zero-knowledge proof system whose proofs are much smaller than those of STARK, but these proofs have a verification time that scales linearly in the size of the circuit; for an arithmetic circuit of one million gates the verification time is close to 1 minute, more than 1,000 times more expensive than verifying a STARK proof for the same computation.</p>

    <p class="text-gray-300">Another thread of research has produced proof systems that remove trust from the circuit preprocessing step, and instead have a universal (trusted) setup: a one-time trusted setup that can be reused for any computation <em>[x16, XZZ^{+}19, x15]</em>. All of these systems build SNARKs by combining an underlying reduction of circuit satisfiability to probabilistic testing of polynomials (with degree at most linear in the circuit size) together with polynomial commitment schemes. In a polynomial commitment scheme, a prover commits to a <span class="math">\\mu</span>-vari</p>

    <p class="text-gray-300">polynomial <span class="math">f</span> over <span class="math">\\mathbb{F}</span> of total degree at most <span class="math">d</span> with a message that is much smaller than sending all the coefficients of <span class="math">f</span>. The prover can later produce a non-interactive argument that <span class="math">f(z)=y</span> for arbitrary <span class="math">z\\in\\mathbb{F}^{p}</span> and <span class="math">y\\in\\mathbb{F}</span>. The trusted portion of the universal SNARK is entirely confined to the polynomial commitment scheme’s setup. These constructions use variants of the Kate <em>et al.</em> commitment scheme for univariate polynomials <em>[x10]</em>, which requires a trusted setup.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Summary of Contributions</h3>

    <p class="text-gray-300">Following the observations of the recent universal SNARK constructions <em>[x12, MBKM19, XZZ^{+}19]</em>, SNARKs can be built from polynomial commitment schemes where all the trust is confined to the setup of the commitment scheme. The main technical contribution of our work is thus a new polynomial commitment scheme without trusted setup (<em>i.e.</em>, a transparent polynomial commitment scheme), which we can use to construct transparent SNARKs. The observation that transparent polynomial commitments imply transparent SNARKs was also implicit in the recent works that build transparent SNARKs from multi-round classical PCPs, and specifically interactive oracle proofs of proximity (IOPPs) <em>[x2]</em>. As a secondary contribution, we present a framework that unifies all existing approaches to constructing SNARKs from polynomial commitments using the language of <em>interactive oracle proofs</em> (IOPs) <em>[x21, x3]</em>. We view polynomial commitment schemes as a compiler for <em>Polynomial IOPs</em>, and re-characterize the results of prior works as providing a variety of Polynomial IOPs for NP.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">New polynomial commitment scheme</h5>

    <p class="text-gray-300">We construct a new polynomial commitment scheme for <span class="math">\\mu</span>-multivariate polynomials of total degree <span class="math">d</span> with optional zero-knowledge arguments of knowledge for correct evaluation that have <span class="math">O(\\mu\\log d)</span> size proofs and are verifiable in <span class="math">O(\\mu\\log d)</span> time. The commitment scheme requires a group of unknown order: two candidate instantiations are RSA groups and class groups of an imaginary quadratic order. Using RSA groups, we can apply the scheme to obtain universal preprocessing SNARKs with <em>constant-size</em> setup parameters, as opposed to the linear-size parameters from previous attempts. Using class groups, we can remove the trusted setup from trusted-setup SNARKs altogether, thereby making them <em>transparent</em>. Our polynomial commitment scheme leverages the power of integer commitments and <em>Diophantine Arguments of Knowledge</em> <em>[x14]</em>; accordingly, we classify this tool (and others of its kind) as a <em>DARK</em> proof system.</p>

    <h5 id="sec-6" class="text-base font-semibold mt-4">Polynomial IOP formalism</h5>

    <p class="text-gray-300">All SNARK constructions can be viewed as combining an underlying information-theoretic statistically-sound protocol with a “cryptographic compiler” that transforms the underlying protocol into a succinct argument at the cost of computational soundness. We define a <em>Polynomial IOP</em> as a refinement of algebraic linear IOPs <em>[x11, BCI^{+}13, BBC^{+}19]</em>, where in each round of interaction the prover provides the verifier with oracle access to a multivariate polynomial function of bounded degree. The verifier may then query this oracle to evaluate the polynomial on arbitrary points of its choice. The existing universal and transparent SNARK constructions provide a variety of statistically-sound Polynomial IOPs for circuit satisfiability (or RAM programs, in the case of STARKs); these are then cryptographically compiled using some form of a polynomial commitment, typically using Merkle trees or pairing groups.</p>

    <p class="text-gray-300">The linear PCPs underlying GGPR and its successors (<em>i.e.</em>, based on QAPs and R1CS) can also be transformed into Polynomial IOPs. This transformation helps highlight the fundamental paradigm shift between constructions of non-transparent non-universal SNARKs that combine linear PCPs and <em>linear-only encodings</em> versus the more recent ones based on polynomial commitments: given the lack of efficient <em>linear function</em> commitment schemes, the compilation of linear PCPs <em>necessarily</em> involves a trusted preprocessing step that preselects the verifier’s linear PCP queries, and hides them inside a linear-only encoding. This linear-only encoding forces the prover to homomorphically output an (encoded) linear tranformation of the query, upon which the verifer performs several homomorphic checks (<em>e.g.</em>,</p>

    <p class="text-gray-300">using pairings). The shift towards Polynomial IOPs, which can be compiled more directly with efficient polynomial commitments, avoids the involvement of a trusted party to place hidden queries in the preprocessing. The only potential need for non-transparent setup is in the instantiation of polynomial commitment itself.</p>

    <p class="text-gray-300">The precise definition of Polynomial IOPs as a central and standalone notion raises the question about its exact relation to other IOP notions. We present a univariate Polynomial IOP for extracting an indicated coefficient of a polynomial. Furthermore, we present a univariate Polynomial IOP for proving that the inner product between the coefficient vectors of two polynomials equals a given value. This proof system is of independent interest. Together with an offline pre-processing phase during which the correctness of a multivariate polynomial is ascertained, these two tools enable us to show that <em>any</em> algebraic linear IOP can be realized with a multivariate Polynomial IOP.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Polynomial IOP compiler</h4>

    <p class="text-gray-300">We present a generic compilation of any public-coin Polynomial IOP into a doubly-efficient public-coin interactive argument of knowledge using an abstract polynomial commitment scheme. We prove that if the commitment scheme’s evaluation protocol has witness-extended emulation, then the compiled interactive argument has this knowledge property as well. If the commitment scheme is hiding and the evaluation is honest-verifier zero knowledge (HVZK), then the compiled interactive argument is HVZK as well. Finally, public-coin interactive arguments may be cryptographically compiled into SNARKs using the Fiat-Shamir transform.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">New SNARK without Trusted Setup</h4>

    <p class="text-gray-300">The main practical outcome of this work is a new transparent proof system (Supersonic) for computations represented as arbitrary arithmetic circuits, obtained by cryptographically compiling the Polynomial IOPs underlying Sonic <em>[x11]</em>, PLONK <em>[x10]</em>, and Marlin<em>[CHM^{+}19]</em> using the DARK polynomial commitment scheme. Supersonic improves the proof size by an order of magnitude over STARKs without compromising on verification time. For one million gates, Supersonic’s proofs are just 7.8KB and take around 75ms to verify. Using the notation <span class="math">O_{\\lambda}(\\cdot)</span> to hide multiplicative factors dependent on the security parameter <span class="math">\\lambda</span>, STARKs have size and verification complexity <span class="math">O_{\\lambda}(\\log^{2}T)</span> whereas Supersonic has size and verification complexity <span class="math">O_{\\lambda}(\\log T)</span>. (The additional multiplicative factors dependent on <span class="math">\\lambda</span> are actually better for Supersonic as well.) As a caveat, while the prover time in Supersonic is asymptotically on par with STARKs (<em>i.e.</em>, quasi-linear in <span class="math">T</span>), the concrete efficiency is much worse due to the use of heavy-weight “crypto operations” over 1200 bit class group elements in contrast to the light-weight FFTs and hash functions in STARKs. Furthermore, Supersonic is not quantum-secure due to its reliance on groups of unknown order, whereas STARKs are a candidate quantum-secure SNARK.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">New Security Proof (Added June 2022)</h4>

    <p class="text-gray-300">The original security proof in the version of the paper published at EUROCRYPT 2020<em>[x2]</em> had a significant gap which was discovered by <em>[BHR^{+}21]</em>. It implicitly assumed that the prover could only encode integer polynomials. While the protocol does ensure that the last message is an integer, i.e. a constant degree integer polynomial, this isn’t necessarily guaranteed in the prior rounds. The prover could possibly start by committing to a polynomial with rational coefficients, i.e. <span class="math">f(X)=\\frac{g(X)}{N}\\in\\mathbb{Q}[X]</span> for <span class="math">g(X)\\in\\mathbb{Z}[X]</span> and <span class="math">N\\in\\mathbb{Z}</span>. In each step of the protocol, the prover computes a random linear combination of two halves of the polynomial. It is possible that for some random challenge this random linear combination of two rational polynomials results in an integer polynomial. This would break the assumption that was made in the flawed security proof. The extractor described in the EUROCRYPT version extracted a rational polynomial, not an integer one.</p>

    <p class="text-gray-300">It is easy to show (see Lemma 10) that the polynomial commitment is still binding, for polynomials with rational coefficients. Unfortunately, the binding property only holds if the rational polynomial has <em>bounded</em> coefficients, i.e. bounded numerators and denominators. Using the old extractor we would get extremely loose bounds which then translate to superquadratic prover and setup times. However, taking the view of the adversary, it does not seem likely that the prover could start with a polynomial with a very large denominator and end up with an integer in the last round with high probability. Taking a closer look at the protocol, in a convincing proof the final prover message is an integer equivalent to <span class="math">\\tilde{f}(\\alpha_{1},\\ldots,\\alpha_{\\mu})=\\frac{\\tilde{g}(\\alpha_{1},\\ldots\\alpha_{\\mu})}{N}</span> where <span class="math">\\tilde{f}</span> and <span class="math">\\tilde{g}</span> are multi-linear polynomials with the same</p>

    <p class="text-gray-300">coefficients as <span class="math">f</span> and <span class="math">g</span> respectively and <span class="math">\\alpha_{1},\\ldots,\\alpha_{\\mu}</span> are the verifier’s random challenges. This, however, implies that <span class="math">\\tilde{g}(\\alpha_{1},\\ldots,\\alpha_{\\mu})\\equiv 0\\bmod N</span>. The probability of this event over random challenges can be bounded with an analysis akin to the famous Schwartz-Zippel lemma, but generalized for composite <span class="math">N</span>. In a separate paper <em>[x1]</em> we carefully analyze this probability and show that if <span class="math">N</span> is too large, this probability is negligible. This in turn implies bounds on <span class="math">f</span>. This insight gives confidence that DARK might be sound but it does not directly yield a security proof.</p>

    <p class="text-gray-300">Critically, DARK is not special-sound, meaning there isn’t an extractor that can compute a witness from any forking transcript tree. But on the other hand, DARK has a special structure that we can still exploit. First, in DARK every message is a commitment. Given a transcript tree, if the messages below the <span class="math">i+1</span>th level have all been opened to polynomials that have bounded norm, then it is possible to extract openings of the commitments at the <span class="math">i</span>th level. The problem is that the norm grows, and the extracted opening at level <span class="math">i</span> are no longer guaranteed to be small enough to continue to level <span class="math">i-1</span>. We can call these two bounds: if all openings below level <span class="math">i</span> satisfy bound A, then we can extract a polynomial at level <span class="math">i</span> that satisfies bound B. However, there are two other key properties that ultimately allow us to get around this issue. (a) Given openings to the last <span class="math">\\mu-i</span> commitments in a DARK transcript to rational polynomials, if the <span class="math">i</span>th commitment satisfies bound B then “rerunning the protocol” as the prover using the same round challenges starting from the <span class="math">i</span>th opened commitment should either recover the same openings of the last <span class="math">\\mu-i</span> commitments or break the commitment scheme by giving an opening of one of these commitments to a distinct message. (b) If the <span class="math">i</span>th opened message does NOT satisfy the bound A, then if we were to rerun the honest protocol on this message as above on uniformly <em>random</em> round challenges then the probability it gives a valid transcript is negligible. The probability analysis relies on the Composite Schwartz Zippel Lemma <em>[x1]</em>.</p>

    <p class="text-gray-300">We generalize this to the notion of Almost Special Sound(ASS) protocols and replace the bounds A and B with arbitrary predicates A and B. We prove (Theorem 7) that all protocols with this ASS structure are knowledge sound, just like special sound protocols, where the knowledge error is dependent on the probability that a random completion of a transcript starting from a message that fails predicate A results in a valid transcript. Intuitively, this captures the fact that once the adversary has a message that fails the desired extraction predicate it will fail with overwhelming probability over fresh challenges to complete the proof transcript successfully. We also show that if the commitment scheme is computationally unique, i.e. it is hard for a prover to produce two commitments to the same message, then the Fiat-Shamir transform of ASS protocols is secure (Theorem 8) We provide the proof as a self-contained document in the appendix.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Arguments based on hidden order groups</h5>

    <p class="text-gray-300">Fujisaki and Okamoto <em>[x10]</em> proposed homomorphic integer commitment schemes based on the RSA group. They also provide protocols to prove that a list of committed integers satisfy modular polynomial equations as opening a commitment bit by bit. Damgård and Fujisaki <em>[x11]</em> patched the soundness proof of that protocol and were the first to suggest using class groups of an imaginary quadratic order as a candidate group of unknown order. Lipmaa drew the link between zero-knowledge proofs constructed from integer commitment schemes and Diophantine complexity <em>[x16]</em>, coining the term Diophantine Arguments of Knowledge. Recently, Couteau et al. study protocols derived from integer commitments specifically in the RSA group to reduce the security assumptions needed; in the process they develop proofs for polynomial evaluation modulo a prime <span class="math">\\pi</span> that is not initially known to the verifier, in addition to a proof showing that an integer <span class="math">X</span> lies in the range <span class="math">[a,b]</span> by showing that <span class="math">1+4(X-a)(b-X)</span> decomposes as the sum of 3 squares <em>[x7]</em>.</p>

    <p class="text-gray-300">Pietrzak <em>[x22]</em> developed an efficient proof of repeated squaring, i.e., proving that <span class="math">x^{2^{T}}=y</span> with <span class="math">O(\\log T)</span> proof size and verification time in order to build a conceptually simple verifiable delay function <em>[x3]</em> based on the RSW time-lock puzzle <em>[x23]</em>. Wesolowski <em>[x25]</em> improves on this result by proposing a single-round protocol to prove correct repeated squaring in groups of unknown order with a constant size proof. Boneh et al. <em>[x4]</em> observe that this protocol generalizes to arbitrary exponents (PoE) and develop</p>

    <p class="text-gray-300">a proof of knowledge of an integer exponent (PoKE), as well as a zero-knowledge variant. They use both PoE and PoKE to construct efficient accumulators and vector commitment schemes.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Transparent polynomial commitments</h4>

    <p class="text-gray-300">Whaby et al. constructed a transparent polynomial commitment scheme <em>[WTs^{+}18]</em> for multilinear polynomials by combining a matrix commitment of Bootle et al. <em>[BCC^{+}16b]</em> with the inner-product argument of Bünz et al. <em>[BBB^{+}18]</em>. For polynomials of degree <span class="math">d</span> it has commitments of size <span class="math">O(\\sqrt{d})</span> and evaluation arguments with <span class="math">O(\\sqrt{d})</span> communication. Zhang et al. <em>[x10]</em> and Kattis et al. <em>[x11]</em> recently and independently showed how to build a polynomial commitment from FRI (Fast Reed Solomon IOPP) <em>[x1, x2]</em> The commitment is transparent, has <span class="math">O(\\lambda)</span> size commitments and evaluation arguments with <span class="math">O(\\log^{2}d)</span> communication.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Polynomial IOP formalism</h4>

    <p class="text-gray-300">In concurrent work Chiesa et al. <em>[CHM^{+}19]</em> introduce an information theoretic framework called algebraic holographic proofs (AHP). They also show that with a polynomial commitment scheme an AHP can be compiled to a preprocessing SNARK. The AHP framework is essentially equivalent to our Polynomial IOP framework. In other concurrent work, Chiesa, Ojha, and Spooner show interesting connections between algebraic holographic proofs and recursive proof composition. In the same work, the authors develop an AHP-based transparent SNARK called Fractal <em>[x3]</em>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2 Technical Overview</h2>

    <p class="text-gray-300">This technical overview provides an informal description of our key technical contribution: a polynomial commitment scheme with logarithmic evaluation proofs and verification time. The commitment scheme relies on four separate tools.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">1. Integer encoding of polynomials</h4>

    <p class="text-gray-300">Given a univariate polynomial <span class="math">f(X)\\in\\mathbb{Z}_{p}[X]</span> the prover first encodes the polynomial as an integer. Interpreting the coefficients of <span class="math">\\hat{f}(X)</span> as integers in <span class="math">[0,p)</span>, define <span class="math">\\hat{f}(X)</span> to be the <em>integer</em> polynomial with these coefficients. The prover computes <span class="math">\\hat{f}(q)\\in\\mathbb{Z}</span> for some large integer <span class="math">q\\geq p</span>. This is an injective map from polynomials with bounded coefficients to integers and is also decodable: the coefficients of <span class="math">f(q)</span> can be recovered from the base-<span class="math">q</span> expansion of <span class="math">\\hat{f}(q)</span>. For example, suppose that <span class="math">f(X)=2X^{3}+3X^{2}+4X+1\\in\\mathbb{Z}_{5}[X]</span> and <span class="math">q=10</span>. Then the integer <span class="math">\\hat{f}(10)=2341</span> encodes the polynomial <span class="math">f(X)</span> because its coefficients appear in the decimal expansion of <span class="math">\\hat{f}(10)</span>.</p>

    <p class="text-gray-300">Note that this encoding is also additively homomorphic, assuming that <span class="math">q</span> is sufficiently large. For example, let <span class="math">g(X)=4X^{3}+1X^{2}+3</span> such that <span class="math">\\hat{g}(10)=4103</span>. Then <span class="math">\\hat{f}(10)+\\hat{g}(10)=6444=(\\hat{g}+\\hat{f})(10)</span>. The more homomorphic operations we want to permit, the larger <span class="math">q</span> needs to be. The encoding additionally permits multiplication by polynomials <span class="math">(\\hat{f}(q)\\cdot q^{k}</span> is equal to the encoding of <span class="math">f(X)\\cdot X^{k})</span>.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">2. Succint integer commitments</h4>

    <p class="text-gray-300">The integer <span class="math">x\\leftarrow\\hat{f}(q)\\in\\mathbb{Z}</span> encoding a degree <span class="math">d</span> polynomial <span class="math">f(X)</span> lies between <span class="math">q^{d}</span> and <span class="math">q^{d+1}</span>; in other words, its size is <span class="math">(d+1)\\log_{2}q</span> bits. The prover commits to <span class="math">x</span> using a <em>succinct</em> integer commitment scheme that is additively homomorphic. Specifically, we use scalar multiplication in an additive group <span class="math">(\\mathbb{G},+)</span> of unknown order: the commitment is the single group element <span class="math">x\\cdot\\mathbb{G}</span> for a base element <span class="math">\\mathbb{G}\\in\\mathbb{G}</span> specified in the setup. (Note that if the order <span class="math">n</span> of <span class="math">\\mathbb{G}</span> is known then this is not an integer commitment; <span class="math">x\\cdot\\mathbb{G}</span> could be opened to any integer <span class="math">x^{\\prime}\\equiv x\\bmod n</span>.)</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">3. Evaluation protocol</h4>

    <p class="text-gray-300">The evaluation protocol is an interactive argument to convince a verifier that <span class="math">\\mathbb{C}</span> is an integer commitment to <span class="math">\\hat{f}(q)</span> such that <span class="math">f(z)=y</span> at a provided point <span class="math">z\\in\\mathbb{Z}_{p}</span>. The protocol must be <em>evaluation binding</em>: it should be infeasible for the prover to succeed in arguing that <span class="math">f(z)=y</span> and <span class="math">f(z)=y^{\\prime}</span> for <span class="math">y\\neq y^{\\prime}</span>. The protocol should also be an <em>argument of knowledge</em>, which informally means that any prover who succeeds at any point <span class="math">x</span> must “know” the coefficients of the committed <span class="math">f</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">As a warmup, we first describe how a prover can efficiently convince a verifier that <span class="math">\\mathsf{C}</span> is a commitment to an integer polynomial of degree at most <span class="math">d</span> with bounded coefficients. Assume for now that <span class="math">d=2^{k}-1</span>. The protocol uses a recursive divide-and-combine strategy. In each step we split <span class="math">f(X)</span> into two degree <span class="math">d^{\\prime}=\\lfloor\\frac{d}{2}\\rfloor</span> polynomials <span class="math">f_{L}(X)</span> and <span class="math">f_{R}(X)</span>. The left half <span class="math">f_{L}(X)</span> contains the first <span class="math">d^{\\prime}+1</span> coefficients of <span class="math">f(X)</span> and the right half <span class="math">f_{R}(X)</span> the second, such that <span class="math">f(X)=f_{L}(X)+X^{d^{\\prime}+1}f_{R}(X)</span>. The prover now commits to <span class="math">f_{L}</span> and <span class="math">f_{R}</span> by computing <span class="math">\\mathsf{C}_{L}\\leftarrow\\hat{f}_{L}(q)\\cdot\\mathsf{G}</span> and <span class="math">\\mathsf{C}_{R}\\leftarrow\\hat{f}_{R}(q)\\cdot\\mathsf{G}</span>. The verifier checks the consistency of these commitments by testing <span class="math">\\mathsf{C}_{L}+q^{d^{\\prime}+1}\\cdot\\mathsf{C}_{R}=\\mathsf{C}</span>. The verifier then samples random <span class="math">\\alpha\\in\\mathbb{Z}_{p}</span> and computes <span class="math">\\mathsf{C}^{\\prime}\\leftarrow\\mathsf{C}_{L}+\\alpha\\cdot\\mathsf{C}_{R}</span>, which is an integer commitment to <span class="math">\\hat{f}_{L}(q)+\\alpha\\cdot\\hat{f}_{R}(q)</span>. The prover and verifier recurse on the statement that <span class="math">\\mathsf{C}^{\\prime}</span> is a commitment to a polynomial of degree at most <span class="math">d^{\\prime}</span>, thus halving the “size” of the statement. After <span class="math">\\log_{2}(d+1)</span> rounds, the commitment <span class="math">\\mathsf{C}^{\\prime}</span> exchanged between prover and verifier is a commitment to a polynomial of degree <span class="math">0</span>, <em>i.e.</em>, to a scalar <span class="math">c\\in\\mathbb{Z}_{p}</span>. So <span class="math">\\mathsf{C}^{\\prime}</span> is of the form <span class="math">\\hat{c}\\cdot\\mathsf{G}</span> where <span class="math">\\hat{c}</span> is some integer congruent to <span class="math">c</span> modulo <span class="math">p</span>. The prover sends <span class="math">\\hat{c}</span> to the verifier directly. The verifier checks that <span class="math">\\mathsf{G}^{\\hat{c}}=\\mathsf{C}^{\\prime}</span> and also that <span class="math">\\hat{c}&lt;q</span>.</p>

    <p class="text-gray-300">To also show that <span class="math">f(z)=y</span> at a provided point <span class="math">z</span>, the prover additionally sends <span class="math">y_{L}=f_{L}(z)\\bmod p</span> and <span class="math">y_{R}=f_{R}(z)\\bmod p</span> in each round. The verifier checks consistency with the claim, <em>i.e.</em>, that <span class="math">y_{L}+z^{d^{\\prime}+1}y_{R}=y</span>, and also computes <span class="math">y^{\\prime}\\leftarrow y_{L}+\\alpha\\cdot y_{R}\\bmod p</span> to proceed to the next round. (The recursive claim is that <span class="math">\\mathsf{C}^{\\prime}</span> commits to <span class="math">f^{\\prime}</span> such that <span class="math">f^{\\prime}(z)=y^{\\prime}\\bmod p</span>.) In the final round of recursion, the value of the constant polynomial in <span class="math">z</span> is the constant itself. So in addition to testing <span class="math">\\mathsf{C}=\\hat{c}\\cdot\\mathsf{G}</span> and <span class="math">\\hat{c}&lt;q</span>, the verifier also checks that <span class="math">\\hat{c}\\equiv y\\bmod p</span>.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">4. Outsourcing large scalar multiplications for efficiency</h4>

    <p class="text-gray-300">The evaluation protocol requires communicating only 2 group elements and 2 field elements per round. However, the verifier needs to check that <span class="math">\\mathsf{C}_{L}+q^{d^{\\prime}+1}\\cdot\\mathsf{C}_{R}=\\mathsf{C}</span>, and naïvely performing the scalar multiplication requires <span class="math">\\Omega(d\\cdot\\log q)</span> work. To reduce this workload, we employ a recent technique for proofs of exponentiation (PoE) in groups of unknown order due to Wesolowski <em>[x23]</em> in which the prover computes this scalar multiplication (also referred to as exponentiation when using a multiplicative group) and the verifier verifies it in essentially constant time. This outsourcing reduces the total verifier time (<em>i.e.</em>, of the entire protocol) to a quantity that is logarithmic in <span class="math">d</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3 Preliminaries (Assumptions and Commitments)</h2>

    <p class="text-gray-300">We present the preliminaries on the computational assumptions in groups of unknown orders and our definitions. The preliminaries on proof systems are found in the new security proof in Appendix A.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.1 Assumptions</h3>

    <p class="text-gray-300">The cryptographic compilers make extensive use of groups of unknown order, <em>i.e.</em>, groups for which the order cannot be computed efficiently. Concretely, we require groups for which two specific hardness assumptions hold. The binding property of the polynomial commitment and the evaluation protocol, rely on the most basic assumption in groups of unknown order. The assumption states that it is hard to compute the order of random group elements. This assumption is implied by the famous RSA Assumption <em>[x20]</em> which states that it is hard to take <em>random</em> roots (technically scalar divisions) of <em>random</em> elements. Secondly, our proofs of exponentiation which are used to make the verifier efficient, rely on the much newer Adaptive Root Assumption <em>[x23]</em> which is the dual of the Strong RSA Assumption and states that it is hard to take <em>random</em> roots of <em>arbitrary</em> group elements. The assumption, is also used to show that the commitment scheme is <em>computationally unique</em>, that is given a message an adversary can only output a single valid commitment to the message. Both of these assumptions hold in generic groups of unknown order <em>[x10, x3]</em>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Assumption 1 (Random Order Assumption).</h6>

    <p class="text-gray-300">The random order assumption states that an efficient adversary cannot compute a multiple of the order of a given random group element.</p>

    <p class="text-gray-300">Specifically, it holds for <span class="math">GGen</span> if for any probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathbb{G}, N \\leftarrow GGen(\\lambda) \\\\ a \\cdot \\mathsf{G} = 0: \\quad \\mathsf{G}, \\stackrel{\\$}{\\leftarrow} \\mathbb{G} \\\\ a \\in \\mathbb{Z} \\leftarrow \\mathcal{A}(\\mathbb{G}, N, \\mathsf{G}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) .</span></div>

    <p class="text-gray-300"><strong>Assumption 2</strong> (RSA assumption, [RSA78, CPP17]). The RSA assumption states that an efficient adversary cannot compute a random root (co-prime with the order of the group) for a given random group element. Specifically, it holds for <span class="math">GGen</span> if for any probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathbb{G}, N \\leftarrow GGen(\\lambda) \\\\ \\ell \\cdot \\mathsf{U} = \\mathsf{G}: \\quad \\mathsf{G} \\stackrel{\\$}{\\leftarrow} \\mathbb{G}, \\ell \\stackrel{\\$}{\\leftarrow} [N] \\\\ \\mathsf{U} \\in \\mathbb{G} \\leftarrow \\mathcal{A}(\\mathbb{G}, \\mathsf{G}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) .</span></div>

    <p class="text-gray-300"><strong>Assumption 3</strong> (Adaptive Root Assumption). The Adaptive Root Assumption holds for <span class="math">GGen</span> if there is no efficient adversary <span class="math">(\\mathcal{A}_0, \\mathcal{A}_1)</span> that succeeds in the following task. First, <span class="math">\\mathcal{A}_0</span> outputs an element <span class="math">\\mathsf{W} \\in \\mathbb{G}</span> and some <span class="math">\\mathsf{st}</span>. Then, a random prime <span class="math">\\ell</span> in <span class="math">\\mathsf{Primes}(\\lambda)</span> is chosen and <span class="math">\\mathcal{A}_1(\\ell, \\mathsf{st})</span> outputs <span class="math">\\mathsf{W}^{1/\\ell} \\in \\mathbb{G}</span>. For all efficient <span class="math">(\\mathcal{A}_0, \\mathcal{A}_1)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathbb{G} \\stackrel{\\$}{\\leftarrow} GGen(\\lambda) \\\\ \\ell \\cdot \\mathsf{U} = \\mathsf{W} \\neq 1: &amp;amp; (\\mathsf{W}, \\mathsf{st}) \\stackrel{\\$}{\\leftarrow} \\mathcal{A}_0(\\mathbb{G}) \\\\ &amp;amp; \\ell \\stackrel{\\$}{\\leftarrow} \\mathsf{Primes}(\\lambda) \\\\ &amp;amp; \\mathsf{U} \\leftarrow \\mathcal{A}_1(\\ell, w, \\mathsf{st}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda).</span></div>

    <p class="text-gray-300"><strong>Lemma 1.</strong> The RSA Assumption for <span class="math">GGen</span> implies the Random Order Assumption</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Given an efficient adversary <span class="math">\\mathcal{A}_{\\mathrm{Order}}</span> for the random order assumption that succeeds with non-negligible probability <span class="math">\\epsilon</span> we will construct an efficient adversary <span class="math">\\mathcal{A}_{\\mathrm{RSA}}</span> for the RSA assumption. On input <span class="math">\\mathbb{G}, \\mathbb{G}, \\ell</span> to <span class="math">\\mathcal{A}_{\\mathrm{RSA}}</span> we will forward <span class="math">\\mathbb{G}, \\mathbb{G}</span> to <span class="math">\\mathcal{A}_{\\mathrm{Order}}</span>. <span class="math">\\mathcal{A}_{\\mathrm{Order}}</span> outputs <span class="math">a</span> such that <span class="math">a \\cdot \\mathbb{G} = 0</span> with non-negligible probability <span class="math">\\epsilon</span>. <span class="math">\\mathcal{A}_{\\mathrm{RSA}}</span> computes <span class="math">a&#x27; \\leftarrow \\frac{a}{\\gcd(a, \\ell^k)}</span> for <span class="math">k = \\lceil \\log_{\\ell}(a) \\rceil</span>. The probability that <span class="math">\\ell</span> is not co-prime to the order of <span class="math">\\mathbb{G}</span> is bounded by $\\frac{\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Primes}(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> which is negligible in </span>\\lambda<span class="math">. Otherwise </span>\\ell<span class="math"> is co-prime with the order of </span>\\mathbb{G}<span class="math"> and </span>a<span class="math"> is a multiple of the order of </span>\\mathbb{G}<span class="math"> we have that </span>a'<span class="math"> is still a multiple of the order of </span>\\mathbb{G}<span class="math">. Now </span>\\mathcal{A}_{\\mathrm{RSA}}<span class="math"> computes </span>w \\leftarrow \\ell^{-1} \\bmod a'<span class="math"> and outputs </span>\\mathsf{U} \\leftarrow w \\cdot \\mathbb{G}<span class="math">. Now we have </span>\\ell \\cdot \\mathsf{U} = \\mathbb{G}<span class="math"> so </span>\\mathcal{A}_{\\mathrm{RSA}}<span class="math"> succeeds with probability </span>\\epsilon - \\mathsf{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 2.</strong> The Adaptive Root Assumption for <span class="math">GGen</span> implies the Random Order Assumption</p>

    <p class="text-gray-300"><strong>Proof.</strong> Given an efficient adversary <span class="math">\\mathcal{A}_{\\mathrm{Order}}</span> for the random order assumption we will construct an efficient adversary <span class="math">\\mathcal{A}_{\\mathrm{AR}} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> for the Adaptive Root assumption. On input <span class="math">\\mathbb{G}</span> to <span class="math">\\mathcal{A}_0</span> we will sample a random group element <span class="math">\\mathbb{G}</span> from <span class="math">\\mathbb{G}</span> and forward it to <span class="math">\\mathcal{A}_{\\mathrm{Order}}</span>. <span class="math">\\mathcal{A}_{\\mathrm{Order}}</span> outputs <span class="math">a</span> such that <span class="math">a \\cdot \\mathbb{G} = 0</span> with non-negligible probability <span class="math">\\epsilon</span>. And we set the output of <span class="math">\\mathcal{A}_0</span> to be <span class="math">(\\mathbb{G}, a)</span>. The adaptive root game then samples a random prime <span class="math">\\ell</span>. <span class="math">\\mathcal{A}_1</span> on input <span class="math">(a, g, \\ell)</span> computes <span class="math">a&#x27; \\leftarrow \\frac{a}{\\gcd(a, \\ell^k)}</span> for <span class="math">k = \\lceil \\log_{\\ell}(a) \\rceil</span>. Note that since <span class="math">\\ell</span> is co-prime to the order of <span class="math">\\mathbb{G}</span> and thus also the order of <span class="math">\\mathbb{G}</span> and <span class="math">a</span> is a multiple of the order of <span class="math">\\mathbb{G}</span> we have that <span class="math">a&#x27;</span> is still a multiple of the order of <span class="math">\\mathbb{G}</span>. If we don't abort then we compute <span class="math">\\ell^{-1} \\bmod a</span> and <span class="math">\\mathsf{U} = \\ell^{-1} \\cdot \\mathbb{G}</span>. Finally <span class="math">A_1</span> outputs <span class="math">\\mathsf{U}</span>, which by construction is such that <span class="math">\\ell \\cdot \\mathsf{U} = \\mathbb{G}</span>.</p>

    <p class="text-gray-300"><strong>Groups of unknown order.</strong> We consider two candidate groups of unknown order. Both have their own upsides and downsides.</p>

    <p class="text-gray-300"><strong>RSA Group.</strong> In the multiplicative group <span class="math">\\mathbb{Z}_n^<em></span> of integers modulo a product <span class="math">n = p \\cdot q</span> of large primes <span class="math">p</span> and <span class="math">q</span>, computing the order of the group is as hard as factoring <span class="math">n</span>. The Adaptive Root Assumption does not hold for <span class="math">\\mathbb{Z}_n^</em></span> because <span class="math">-1 \\in \\mathbb{Z}_n^<em></span> can be easily computed and has order two. This can be resolved though by working instead in the quotient group <span class="math">\\mathbb{Z}_n^</em> / \\{x \\mid x^2 = 1\\} \\cong \\mathrm{QR}_n</span>. The downside of using an RSA group, or more precisely, the group of quadratic residues modulo an RSA modulus, is that this modulus cannot be generated in a publicly verifiable way without exposing the order, and thus requires a trusted setup.</p>

    <p class="text-gray-300"><strong>Class Group.</strong> The class group of an imaginary quadratic order is defined as the quotient group of fractional ideals by principal ideals of an order of a number field <span class="math">\\mathbb{Q}(\\sqrt{\\Delta})</span>, with ideal</p>

    <p class="text-gray-300">multiplication. A class group <span class="math">\\mathcal{C}\\ell(\\Delta)</span> is fully defined by its discriminant <span class="math">\\Delta</span>, which needs to satisfy only public constraints such as <span class="math">\\Delta \\equiv 1 \\bmod 4</span> and <span class="math">-\\Delta</span> must be prime. As a result, <span class="math">\\Delta</span> can be generated from public coins, thus obviating the need for a trusted setup. A group element can be represented by two integers strictly smaller (in absolute value) than <span class="math">-\\Delta</span>, which in turn is on the same order of magnitude as RSA group elements for a similar security level. We refer the reader to Buchmann and Hamdy's survey [BH01] and Straka's accessible blog post [Str19] for more details.</p>

    <p class="text-gray-300">Working in <span class="math">\\mathcal{C}\\ell(\\Delta)</span> does present an important difficulty: there is an efficient algorithm due to Gauss to compute square roots of arbitrary elements [BS96], and by repetition, arbitrary power of two roots. Despite this, the random order and the adaptive root assumption still hold in class groups. Computing power of two roots does not directly enable one to compute the order of a random element or compute random (large prime) roots of a chosen element. The new security proof only relies on the random order assumption for extraction and the adaptive root assumption for the PoEs. It, therefore, holds even for adversaries that can compute square (or other small) roots of elements.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3.2 Commitment Schemes</h2>

    <p class="text-gray-300">In defining the syntax of the various protocols, we use the following convention with respect to public values (known to both the prover and the verifier) and secret ones (known only to the prover). In any list of arguments or returned tuple <span class="math">(a,b,c;d,e)</span> those variables listed before the semicolon are public, and those variables listed after it are secret. When there is no secret information, the semicolon is omitted.</p>

    <p class="text-gray-300"><strong>Definition 1 (Commitment scheme).</strong> A commitment scheme <span class="math">\\Gamma</span> is a tuple <span class="math">\\Gamma = (\\text{Setup}, \\text{Commit}, \\text{Open})</span> of PPT algorithms where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Setup}(1^{\\lambda}) \\to \\mathsf{pp}</span> generates public parameters <span class="math">\\mathsf{pp}</span>;</li>

      <li><span class="math">\\text{Commit}(\\mathsf{pp}; x) \\to (C; r)</span> takes a secret message <span class="math">x</span> and outputs a public commitment <span class="math">C</span> and (optionally) a secret opening hint <span class="math">r</span> (which might or might not be the randomness used in the computation).</li>

      <li><span class="math">\\text{Open}(\\mathsf{pp}, C, x, r) \\to b \\in \\{0, 1\\}</span> verifies the opening of commitment <span class="math">C</span> to the message <span class="math">x</span> provided with the opening hint <span class="math">r</span>.</li>

    </ul>

    <p class="text-gray-300">A commitment scheme <span class="math">\\Gamma</span> is <strong>binding</strong> if for all PPT adversaries <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} &amp;amp; \\mathsf{pp} \\leftarrow \\text{Setup}(1^{\\lambda}) \\\\ b_0 = b_1 \\neq 0 \\wedge x_0 \\neq x_1 : &amp;amp; (C, x_0, x_1, r_0, r_1) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ &amp;amp; b_0 \\leftarrow \\text{Open}(\\mathsf{pp}, C, x_0, r_0) \\\\ &amp;amp; b_1 \\leftarrow \\text{Open}(\\mathsf{pp}, C, x_1, r_1) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda)</span></div>

    <p class="text-gray-300">We now extend the syntax to polynomial commitment schemes. The following definition generalizes that of Kate et. al. [KZG10] to allow interactive evaluation proofs. It also stipulates that the polynomial's degree be an argument to the protocol, contrary to Kate et al. where the degree is known and fixed.</p>

    <p class="text-gray-300"><strong>Definition 2. (Polynomial commitment)</strong> A polynomial commitment scheme is a tuple of protocols <span class="math">\\Gamma = (\\text{Setup}, \\text{Commit}, \\text{Open}, \\text{Eval})</span> where <span class="math">(\\text{Setup}, \\text{Commit}, \\text{Open})</span> is a binding commitment scheme for a message space <span class="math">R[X]</span> of polynomials over some ring <span class="math">R</span>, and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{Eval}(\\mathsf{pp}, C, z, y, d, \\mu; f(X)) \\to b \\in \\{0, 1\\}</span> is an interactive public-coin protocol between a PPT prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. Both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> have as input a commitment <span class="math">C</span>, points <span class="math">z, y \\in R</span>, and a degree <span class="math">d</span>. The prover additionally knows the opening of <span class="math">C</span> to a secret polynomial <span class="math">f(X) \\in R[X]</span> with <span class="math">\\deg(f(X)) \\leq d</span>. The protocol convinces the verifier that <span class="math">f(z) = y</span>. In a multivariate extension of polynomial commitments, the input <span class="math">\\mu &amp;gt; 1</span> indicates the number of variables in the committed polynomial and <span class="math">z \\in R^{\\mu}</span>.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme is <strong>correct</strong> if an honest committer can successfully convince the verifier of any evaluation. Specifically, if the prover is honest then for all polynomials <span class="math">f(X) \\in R[X]</span> and all points <span class="math">z \\in R</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} &amp;amp; \\mathsf{pp} \\leftarrow \\text{Setup}(1^{\\lambda}) \\\\ &amp;amp; (C; r) \\leftarrow \\text{Commit}(\\mathsf{pp}, f(X)) \\\\ b = 1 : &amp;amp; y \\leftarrow f(z) \\\\ &amp;amp; d \\leftarrow \\deg(f(X)) \\\\ &amp;amp; b \\leftarrow \\text{Eval}(\\mathsf{pp}, c, z, y, d; f(X), r) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">A polynomial commitment scheme is evaluation binding if no efficient adversary can convince the verifier that the committed polynomial <span class="math">f(X)</span> evaluates to different values <span class="math">y_0 \\neq y_1 \\in R</span> in the same point <span class="math">z \\in R</span>. However, our applications require a stronger property called knowledge soundness.</p>

    <p class="text-gray-300"><strong>Knowledge soundness</strong> Any successful prover in the Eval protocol must know a polynomial <span class="math">f(X)</span> such that <span class="math">f(z) = y</span> and <span class="math">C</span> is a commitment to <span class="math">f(X)</span>. More formally, since Eval is a public-coin interactive argument we define this knowledge property as a special case of witness-extended emulation (Definition 8).</p>

    <p class="text-gray-300">Define the following NP relation given <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {E v a l}} (\\mathsf {p p}) = \\left\\{\\langle (C, z, y, d), (f (X), r) \\rangle : \\begin{array}{l} f \\in R [ X ] \\text { and } \\deg (f (X)) \\leq d \\text { and } f (z) = y \\\\ \\text { and } \\mathsf {O p e n} (\\mathsf {p p}, C, f (X), r) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">The correctness definition above implies that if <span class="math">\\Gamma = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> is correct then Eval is a correct interactive argument for <span class="math">\\mathcal{R}_{\\mathrm{Eval}}(\\mathsf{pp})</span>, with overwhelming probability over the randomness of Setup. We say that <span class="math">\\Gamma</span> has witness-extended emulation if Eval has witness-extended emulation as an interactive argument for <span class="math">\\mathcal{R}_{\\mathrm{Eval}}(\\mathsf{pp})</span>.</p>

    <p class="text-gray-300">It is easy to see that witness-extended emulation implies evaluation binding when the Setup, Commit, and Open part of <span class="math">\\Gamma</span> form a binding commitment scheme. If the adversary succeeds in Eval on both <span class="math">(C,z,y_0,d_0)</span> and <span class="math">(C,z,y_1,d_1)</span> for <span class="math">y_0\\neq y_1</span> or <span class="math">d_0\\neq d_1</span> then the emulator obtains two distinct witnesses <span class="math">f(X)\\neq f^{\\prime}(X)</span> such that <span class="math">C</span> is a valid commitment to both. This would contradict the binding property of the commitment scheme.</p>

    <h2 id="sec-23" class="text-2xl font-bold">3.3 Proofs of Exponentiation</h2>

    <p class="text-gray-300">Wesolowski [Wes19] introduced a simple yet powerful proof of correct exponentiation ("PoE") in groups of unknown order. A prover can efficiently convince a verifier that a large scalar multiplication in such a group was done correctly. For instance, the prover wishes to convince the verifier that <span class="math">\\mathsf{W} = \\mathsf{U}^x</span> for known group elements <span class="math">\\mathsf{U},\\mathsf{W}\\in \\mathbb{G}</span> and exponent <span class="math">x\\in \\mathbb{Z}</span>, and the verifier wants to verify this with much less work than performing the scalar multiplication. To do this, the verifier samples a large enough prime <span class="math">\\ell</span> at random and the prover provides him with <span class="math">\\mathsf{Q}\\gets \\mathsf{U}^q</span> where <span class="math">q = \\lfloor \\frac{x}{\\ell}\\rfloor</span>. The verifier then simply computes the remainder <span class="math">r\\gets (x\\bmod \\ell)</span> and checks that <span class="math">\\mathsf{Q}^{\\ell}\\mathsf{U}^{r} = \\mathsf{W}</span>. The protocol is an argument for the relation <span class="math">\\mathcal{R}_{\\mathrm{PoE}} = \\{\\langle (\\mathsf{U},\\mathsf{W},x),\\varnothing \\rangle : \\mathsf{U}^x = \\mathsf{W}\\}</span>. The proof verification uses just <span class="math">O(\\lambda)</span> group operations. When <span class="math">x</span> is <span class="math">x = q^{d}</span> the verifier can compute <span class="math">r\\gets x\\bmod \\ell</span> using just <span class="math">\\log (d)</span> <span class="math">\\ell</span>-bit multiplications.</p>

    <p class="text-gray-300"><strong>PoE(U,W,x):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> samples <span class="math">\\ell \\stackrel{\\</span>}{\\leftarrow} \\mathrm{Primes}(\\lambda)<span class="math"> and sends </span>\\ell<span class="math"> to </span>\\mathcal{P}$</li>

      <li><span class="math">\\mathcal{P}</span> computes quotient <span class="math">q</span> and remainder <span class="math">r</span> such that <span class="math">x = q\\ell + r</span> and <span class="math">r \\in \\{0, \\dots, \\ell - 1\\}</span></li>

      <li><span class="math">\\mathcal{P}</span> computes <span class="math">\\mathsf{Q} \\gets q \\cdot \\mathsf{U}</span> and sends it to <span class="math">\\mathcal{V}</span></li>

      <li><span class="math">\\mathcal{V}</span> computes <span class="math">r\\gets (x\\mod \\ell)</span> and checks that <span class="math">\\ell \\cdot \\mathsf{Q} + r\\cdot \\mathsf{U} = \\mathsf{W}</span></li>

      <li>if check passes then return 1 else return 0</li>

    </ol>

    <p class="text-gray-300"><strong>Lemma 3</strong> (PoE soundness [Wes19]). PoE is an argument system for relation <span class="math">\\mathcal{R}_{\\mathrm{PoE}}</span> with negligible soundness error, assuming the Adaptive Root Assumption (Assumption 3) holds for GGen.</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> (PoE random oracle soundness [Wes19]). The Fiat-Shamir transform of PoE, replacing the verifier message <span class="math">\\ell</span> with <span class="math">\\ell \\gets \\mathsf{H}(u,w,x)</span> and <span class="math">\\mathsf{H}</span> is an argument system for relation <span class="math">\\mathcal{R}_{\\mathrm{PoE}}</span> with negligible soundness error, assuming that <span class="math">\\mathsf{H}</span> is modeled as a random oracle and that the Adaptive Root Assumption (Assumption 3) holds for GGen.</p>

    <h2 id="sec-24" class="text-2xl font-bold">4 Polynomial Commitments from Groups of Unknown Order</h2>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.1 Information-Theoretic Abstraction</h3>

    <p class="text-gray-300">Before we present our concrete polynomial commitment scheme based on groups of unknown order, we present the underlying information theoretic protocol that abstracts the concrete</p>

    <p class="text-gray-300">cryptographic instantiations. The purpose of this abstraction is two-fold: first, it provides an intuitive stepping stone from which presenting and studying the concrete cryptographic protocol is easier; and second, it opens the door to alternative cryptographic instantiations that provide the same interface but based on alternative hardness assumptions.</p>

    <p class="text-gray-300">Let <span class="math">[\\ast]:\\mathbb{Z}_{p}[X]\\to\\mathbb{S}</span> be a homomorphic commitment function that sends polynomials over a prime field to elements of some set <span class="math">\\mathbb{S}</span>. Moreover, let <span class="math">\\mathbb{S}</span> be equipped with operations <span class="math"><em>+</em>:\\mathbb{S}\\times\\mathbb{S}\\to\\mathbb{S}</span> and <span class="math"><em>\\cdot</em>:\\mathbb{Z}_{p}[X]\\times\\mathbb{S}\\to\\mathbb{S}</span> that accommodate two homomorphisms for <span class="math">[\\ast]</span>:</p>

    <p class="text-gray-300"><span class="math">\\bullet</span> a <em>linear homomorphism</em>: <span class="math">a\\cdot[\\![f(X)]\\!]+b\\cdot[\\![g(X)]\\!]=[\\![af(X)+bg(X)]\\!]</span></p>

    <p class="text-gray-300"><span class="math">\\bullet</span> a <em>monomial homomorphism</em>: <span class="math">X^{d}\\cdot[\\![f(X)]\\!]=[\\![X^{d}f(X)]\\!]</span>.</p>

    <p class="text-gray-300">For now, assume both prover and verifier have oracle access to the function <span class="math">[\\!\\!]<em>\\!]</span> and to the operations <span class="math"></em>\\cdot<em></span> and <span class="math"></em>+*</span>. (Later on, we will instantiate this commitment function using groups of unknown order and an encoding of polynomials as integers.)</p>

    <p class="text-gray-300">The core idea of the evaluation protocol is to reduce the statement that is being proved from one about a polynomial <span class="math">f(X)</span> of degree <span class="math">d</span> and its evaluation <span class="math">y=f(z)</span>, to one about a polynomial <span class="math">f^{\\prime}(X)</span> of degree <span class="math">d^{\\prime}=\\lfloor\\frac{d}{2}\\rfloor</span> and its evaluation <span class="math">y^{\\prime}=f^{\\prime}(z)</span>. For simplicity, assume that <span class="math">d+1</span> is a power of <span class="math">2</span>. The prover splits <span class="math">f(X)</span> into <span class="math">f_{L}(X)</span> and <span class="math">f_{R}(X)</span> such that <span class="math">f(X)=f_{L}(X)+X^{d^{\\prime}+1}f_{R}(X)</span> and such that both halves have degree at most <span class="math">d^{\\prime}</span>. The prover obtains a random challenge <span class="math">\\alpha\\in\\mathbb{Z}_{p}</span> from the verifier and proceeds to prove that <span class="math">f^{\\prime}(X)=f_{L}(X)+\\alpha\\cdot f_{R}(X)</span> has degree <span class="math">d^{\\prime}</span> and that <span class="math">f^{\\prime}(z)=y^{\\prime}=y_{L}+\\alpha y_{R}</span> with <span class="math">y_{L}=f_{L}(z)</span> and <span class="math">y_{R}=f_{R}(z)</span>.</p>

    <p class="text-gray-300">The proof repeats this reduction by using <span class="math">f^{\\prime}(X),z,y^{\\prime}</span> and <span class="math">d^{\\prime}</span> as the input to the next recursion step. In the final step, <span class="math">f(X)=f</span> is a constant and the verifier checks that <span class="math">f=y</span>.</p>

    <p class="text-gray-300">The commitment function binds the prover to one particular polynomial for every commitment held by the verifier. In particular, at the start of every recursion step, the verifier is in possession of a commitment <span class="math">[\\![f(X)]\\!]</span> to <span class="math">f(X)</span>. The prover provides commitments <span class="math">[\\![f_{L}(X)]\\!]</span> and <span class="math">[\\![f_{R}(X)]\\!]</span>, and the verifier checks their soundness homomorphically by testing <span class="math">[\\![f(X)]\\!]=[\\![f_{L}(X)]\\!]+X^{d^{\\prime}+1}.[\\![f_{R}(X)]\\!]</span>. From these commitments, the verifier can also compute the commitment to <span class="math">f^{\\prime}(X)</span> homomorphically, via <span class="math">[\\![f^{\\prime}(X)]\\!]=[\\![f_{L}(X)]\\!]+\\alpha\\cdot[\\![f_{R}(X)]\\!]</span>. In the last step, the verifier checks that the constant polynomial <span class="math">f</span> matches the commitment by computing <span class="math">[\\![f]\\!]</span> outright.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.2 Integer Polynomial Encoding</h3>

    <p class="text-gray-300">We propose using integer commitments in a group of unknown order as a concrete instantiation of the homomorphic commitment scheme required for the abstract protocol presented in Section 4.1. At the heart of our protocol is thus an encoding of integer polynomials with bounded coefficients as integers, which also has homomorphic properties. Any commitment scheme which is homomorphic over integer polynomials is automatically homomorphic over <span class="math">\\mathbb{Z}_{p}[X]</span> polynomials as well (by reducing integer polynomials modulo <span class="math">p</span>). Polynomials over <span class="math">\\mathbb{Z}_{p}[X]</span> can be lifted to integer polynomials in a canonical way by choosing representatives in <span class="math">[0,p)</span>. Therefore, from here on we will focus on building a homomorphic integer encoding of integer polynomials, and how to combine this with a homomorphic integer commitment scheme.</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Strawman encoding</h5>

    <p class="text-gray-300">In order to encode integer polynomials over an odd prime field <span class="math">\\mathbb{F}_{p}</span>, we first lift them to the ring of polynomials over the integers by choosing representatives in <span class="math">[0,p)</span>. In the technical overview (Section 2) we noted that a polynomial <span class="math">f\\in\\mathbb{Z}[X]</span> with positive coefficients bounded by <span class="math">q</span> can be encoded as the integer <span class="math">f(q)</span>. The coefficients of <span class="math">f</span> can be recovered via the base <span class="math">q</span> decomposition of <span class="math">f(q)</span>. This encoding is an injective mapping from polynomials in <span class="math">\\mathbb{Z}[X]</span> of degree at most <span class="math">d</span> with positive coefficients less than <span class="math">q</span> to the set <span class="math">[0,q^{d+1})</span>. The encoding is also <em>partially</em> homomorphic. If <span class="math">f</span> is encoded as <span class="math">f(q)</span> and <span class="math">g</span> is encoded as <span class="math">g(q)</span> where coefficients of both <span class="math">g,f</span> are less than <span class="math">q/2</span>, then the base-<span class="math">q</span> decomposition of <span class="math">f(q)+g(q)</span> gives back the polynomial <span class="math">f+g</span>. By choosing a sufficiently large <span class="math">q\\gg p</span> it is possible to perform several levels of homomorphic operations on encodings.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">What goes wrong?</h5>

    <p class="text-gray-300">Unfortunately, this simple encoding scheme does not quite work yet for the protocol outlined in Section 2. The homomorphic consistency checks ensure that if <span class="math">[\\![f_{L}(X)]\\!]</span> is a homomorphic integer commitment to the encoding of <span class="math">f_{L}\\in\\mathbb{Z}[X]</span>, <span class="math">[\\![f_{R}(X)]\\!]</span> is a homomorphic integer commitment to the encoding of <span class="math">f_{R}\\in\\mathbb{Z}[X]</span>, and both <span class="math">f_{L},f_{R}</span> are polynomials with <span class="math">q/2</span>-bounded integer coefficients, then <span class="math">[\\![f(X)]\\!]</span> is an integer commitment</p>

    <p class="text-gray-300">to the encoding of <span class="math">f_{L} + X^{d^{\\prime}}f_{R}</span>. (Moreover, if <span class="math">f_{L}(z) = y_{L} \\bmod p</span> and <span class="math">f_{R}(z) = y_{R} \\bmod p</span> then <span class="math">f(z) = y_{L} + z^{d^{\\prime}}y_{R} \\bmod p</span>).</p>

    <p class="text-gray-300">However, the validity of <span class="math">\\llbracket f_L(X)\\rrbracket</span> and <span class="math">\\llbracket f_R(X)\\rrbracket</span> are never checked directly. The verifier only sees the opening of the commitment at the bottom level of recursion. If the intermediate encodings use integer polynomials with coefficients larger than <span class="math">q/2</span>, or even rational coefficients the homomorphism is not necessarily preserved. Furthermore, even if <span class="math">\\llbracket f(X)\\rrbracket</span> is a commitment to <span class="math">f^{<em>}(q)</span> with positive <span class="math">q</span>-bounded coefficients, an adversarial prover could find an integer polynomial <span class="math">g^{</em>}</span> that does not have positive <span class="math">q</span>-bounded coefficients such that <span class="math">g^{<em>}(q) = f^{</em>}(q)</span> and <span class="math">g^{<em>} \\not\\equiv f^{</em>} \\bmod p</span> (i.e., <span class="math">g^{<em>}</span> with coefficients greater than <span class="math">q</span> or negative coefficients). The prover could then commit to <span class="math">g_{L}^{</em>}(q)</span> and <span class="math">g_{R}^{<em>}(q)</span>, and recurse on <span class="math">g_{L}^{</em>}(q) + \\alpha g_{R}^{<em>}(q)</span> instead of <span class="math">f_{L}^{</em>}(q) + \\alpha f_{R}^{<em>}(q)</span>. This would be non-binding. (For example <span class="math">f^{</em>}(X) = q - 1</span> and <span class="math">g^{<em>}(X) = X - 1</span>, or <span class="math">f^{</em>}(X) = q + 1</span> and <span class="math">g^{*}(X) = X + 1</span>).</p>

    <p class="text-gray-300"><strong>Inferring coefficient bounds</strong> So what can the verifier infer from the opened commitment <span class="math">\\llbracket f^{\\prime}\\rrbracket</span> at the bottom level of recursion? The opened commitment is an integer <span class="math">f^{\\prime} = f_{L} + \\alpha f_{R}</span>. From <span class="math">f^{\\prime}</span>, the verifier can infer a bound's coefficients of the polynomial <span class="math">f(X) = f_{L} + Xf_{R}</span>, given that <span class="math">f_{L}</span> and <span class="math">f_{R}</span> were already committed in the second to last round. The bound holds with overwhelming probability over the randomness of <span class="math">\\alpha \\in [0,2^{\\lambda})</span>. This is reasoned as follows: if <span class="math">f_0^\\prime \\gets f_L + \\alpha_0f_R</span> and <span class="math">f_1^\\prime \\gets f_L + \\alpha_1f_R</span> but <span class="math">f_{L}</span> and <span class="math">f_{R}</span> are not bounded rational polynomials, then there is a negligibly small probability that <span class="math">f^{\\prime}</span> would have passed the bound check.</p>

    <p class="text-gray-300"><strong>What about negative coefficients?</strong> As shown above, the verifier can infer a bound on the absolute values of <span class="math">f_{L}</span> and <span class="math">f_{R}</span>, but still cannot infer that <span class="math">f_{L}</span> and <span class="math">f_{R}</span> are both positive integers. Moreover, if <span class="math">f_{R} &amp;gt; 0</span> and <span class="math">f_{L} &amp;lt; 0</span>, then it is still possible that <span class="math">f_{L} + qf_{R} &amp;gt; 0</span>, and thus that there is a distinct <span class="math">g \\neq f</span> with <span class="math">q</span>-bounded positive coefficients such that <span class="math">g(q) = f(q)</span>. For example, say <span class="math">f_{R} = q/2</span> and <span class="math">f_{L} = -1</span> then <span class="math">f_{L} + qf_{R} = q^{2}/2 - 1</span>, and <span class="math">f_{L} + \\alpha f_{R} = q/2 - \\alpha &amp;gt; 0</span> for every <span class="math">\\alpha \\in [0,2^{\\lambda})</span>. Yet, also <span class="math">q^{2}/2 - 1 = g(q)</span> for <span class="math">g(X) = (q/2 - 1)X + q - 1</span>.</p>

    <p class="text-gray-300">It turns out that we also can't ensure that <span class="math">f_{L}</span> and <span class="math">f_{R}</span> but only that they are bounded rational polynomials. We show that the same encoding works even for rational polynomials in Appendix A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Ensuring injectivity</strong> How can we ensure the encoding scheme is injective over polynomials with either positive/negative coefficients bounded in absolute value? Fortunately, it is a fact that if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; q / 2<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; q / 2<span class="math"> then at least one coefficient of </span>g<span class="math"> must be larger than </span>q / 2<span class="math">. In other words, if the prover had committed instead to </span>f_{L}^{<em>}<span class="math"> and </span>f_{R}^{</em>}<span class="math"> such that </span>g(X) = f_{L}^{<em>} + Xf_{R}^{</em>}<span class="math"> then the verifier could reject the opening of </span>\\hat{f}_L^<em> +\\alpha \\hat{f}_R^</em>$ with overwhelming probability based on its size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More generally, for every integer <span class="math">z</span> in the range <span class="math">B = (-\\frac{q^{d + 1}}{z}, \\frac{q^{d + 1}}{2})</span> there is a unique degree (at most) <span class="math">d</span> integer polynomial <span class="math">h(X)</span> with coefficients whose absolute values are bounded by <span class="math">q/2</span> such that <span class="math">h(q) = z</span>. We prove this elementary fact below and show how the coefficients of <span class="math">h</span> can be recovered efficiently from <span class="math">z</span> (Fact 1). If the prover is committed to <span class="math">h(q)</span> at level <span class="math">i</span> of the protocol, there is a unique pair of integers polynomial <span class="math">h_L</span> and <span class="math">h_R</span> with coefficients of absolute value bounded by <span class="math">q/2</span> such that <span class="math">h_L(q) + q^{\\frac{q - 1}{2}}h_R(q) = h(q)</span>, and if the prover recurses on any other <span class="math">h_L^<em></span> and <span class="math">h_R^</em></span> with larger coefficients then the verifier's bound check at the bottom level of recursion will fail with overwhelming probability.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Final encoding scheme</strong> Let $\\mathbb{Z}(b) \\coloneqq \\{x \\in \\mathbb{Z} :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq b\\}<span class="math"> denote the set of integers with absolute value less than or equal to </span>b<span class="math">. Define </span>\\mathbb{Z}(b)[X] \\coloneqq \\{f \\in \\mathbb{Z}[X] :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq b\\}<span class="math">, the set of integer polynomials with coefficients from </span>\\mathbb{Z}(b)<span class="math">. (For a polynomial </span>g \\in \\mathbb{Z}[X]<span class="math"> the norm </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> is the maximum over the absolute values of all individual coefficients of </span>g$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Encoding.</strong> For any integer <span class="math">q</span>, the function <span class="math">\\mathsf{Enc} : \\mathbb{Z}(b)[X] \\to \\mathbb{Z}</span> maps <span class="math">h(X) \\mapsto h(q)</span>. A polynomial <span class="math">f(X) \\in \\mathbb{Z}_p[X]</span> is first mapped to <span class="math">\\mathbb{Z}(p - 1)[X]</span> by replacing each coefficient of <span class="math">f</span> with its unique integer representative from <span class="math">[0, p)</span> of the same equivalence class modulo <span class="math">p</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <strong>Decoding.</strong> Decoding works as follows. Define the partial sum <span class="math">S_{k} \\coloneqq \\sum_{i=0}^{k} f_{i} q^{i}</span> with <span class="math">S_{-1} \\coloneqq 0</span>. Assuming $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; q / 2<span class="math"> for all </span>i<span class="math">, observe that for any partial sum </span>S_{k}<span class="math"> we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\frac{q^{k+1}}{2}<span class="math">. Therefore, when </span>S_{k} &lt; 0<span class="math"> then </span>S_{k} \\bmod q^{k+1} &gt; q^{k+1} / 2<span class="math"> and when </span>S_{k} \\geq 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then  <span class="math">S_{k} \\mod q^{k + 1} &amp;lt; q^{k + 1} / 2</span> . This leads to a decoding strategy for recovering  <span class="math">S_{k}</span>  from  <span class="math">y \\in \\mathbb{Z}</span> . The decode algorithm sets  <span class="math">S_{k}</span>  to  <span class="math">y \\mod q^{k + 1}</span>  if this value is less than  <span class="math">q^{k + 1} / 2</span>  and to  <span class="math">q^{k + 1} - (y \\mod q^{k + 1})</span>  otherwise. Two consecutive partial sums yield a coefficient of  <span class="math">f(X)</span> :  <span class="math">f_{k} = \\frac{S_{k} - S_{k - 1}}{q^{k}} \\in \\mathbb{Z}(b)</span> . These operations give rise to the following algorithm.</p>

    <p class="text-gray-300">|  Dec(y ∈ Z):  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2.</td>

            <td class="px-3 py-2 border-b border-gray-700">Sk-1← (y mod qk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3.</td>

            <td class="px-3 py-2 border-b border-gray-700">if Sk-1 > qk/2 then Sk-1← qk - Sk-1 end if</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4.</td>

            <td class="px-3 py-2 border-b border-gray-700">Sk← (y mod qk+1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5.</td>

            <td class="px-3 py-2 border-b border-gray-700">if Sk > qk+1/2 then Sk← qk+1 - Sk end if</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6.</td>

            <td class="px-3 py-2 border-b border-gray-700">fk← (Sk - Sk-1)/qk</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7.</td>

            <td class="px-3 py-2 border-b border-gray-700">return f(X) = ∑k=0 [logq(</td>

            <td class="px-3 py-2 border-b border-gray-700">y</td>

            <td class="px-3 py-2 border-b border-gray-700">)] fkXk</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fact 1. Let  <span class="math">q</span>  be an odd integer. For any  <span class="math">z</span>  in the range  <span class="math">B = \\left(-\\frac{q^{d + 1}}{2},\\frac{q^{d + 1}}{2}\\right)</span>  there is a unique degree (at most)  <span class="math">d</span>  integer polynomial  <span class="math">h(X)</span>  in  <span class="math">\\mathbb{Z}(\\frac{q - 1}{2})[X]</span>  such that  <span class="math">h(q) = z</span> .</p>

    <p class="text-gray-300">Proof. Given any degree (at most)  <span class="math">d</span>  integer polynomial  <span class="math">f \\in \\mathbb{Z}\\left(\\frac{q - 1}{2}\\right)</span> , by construction we see that  <span class="math">\\operatorname{Dec}(\\operatorname{Enc}(f)) = f</span> . Therefore,  <span class="math">\\operatorname{Enc}</span>  is an injective map from degree (at most)  <span class="math">d</span>  polynomials in  <span class="math">\\mathbb{Z}\\left(\\frac{q - 1}{2}\\right)[X]</span>  to  <span class="math">B</span> . Furthermore, the cardinality of both the domain and range of this map is  <span class="math">q^{d + 1}</span> . This shows that the map is surjective. In conclusion, the map is bijective.</p>

    <p class="text-gray-300">We now instantiate the abstract homomorphic commitment function  <span class="math">\\llbracket *\\rrbracket</span> . To this end we sample a group of unknown order  <span class="math">\\mathbb{G}</span> , and sample a random element  <span class="math">\\mathsf{G}</span>  from this group. Lift the field polynomial  <span class="math">f(X)\\in \\mathbb{Z}_p[X]</span>  to an integer polynomial with bounded coefficients, i.e.,  <span class="math">\\hat{f} (X)\\in \\mathbb{Z}(p - 1)[X]</span>  such that  <span class="math">\\hat{f} (X)\\bmod p = f(x)</span> . We encode  <span class="math">\\hat{f} (X)</span>  as an integer by evaluating it at a "large enough" integer  <span class="math">q</span> . Finally, we use scalar multiplication in  <span class="math">\\mathbb{G}</span>  to commit to the integer. Therefore,  <span class="math">\\llbracket f(X)\\rrbracket</span> , corresponds to  <span class="math">\\hat{f} (q)\\cdot \\mathsf{G}</span> . This commitment function inherits the homomorphic properties of the integer encoding for a limited number of additions and multiplications-by-constant. The monomial homomorphism for  <span class="math">X^d</span>  is achieved by raising the group element to the power  <span class="math">q^{d}</span> . To maintain consistency between the prover's witness polynomials and the verifier's commitments, the prover operates on polynomials with integer coefficients  <span class="math">\\hat{f} (X),\\hat{g} (X)</span> , etc., without ever reducing them modulo  <span class="math">p</span> .</p>

    <p class="text-gray-300">The Setup, Commit and Open functionalities are presented formally below. Note that the scheme is parameterized by  <span class="math">p</span>  and  <span class="math">q</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda})</span> : Sample  <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} GGen(\\lambda)</span>  and  <span class="math">\\mathbb{G} \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> . Return  <span class="math">\\mathfrak{pp} = (\\lambda, \\mathbb{G}, \\mathbb{G}, q)</span> .</li>

      <li>Commit  <span class="math">(\\mathfrak{pp}; f(X) \\in \\mathbb{Z}_p[X])</span> : Compute  <span class="math">\\mathsf{C} \\gets \\hat{f}(q) \\cdot \\mathsf{G}</span>  and return  <span class="math">(\\mathsf{C}; f(X), \\hat{f}(X))</span> .</li>

      <li>Open  <span class="math">(\\mathfrak{pp}, \\mathsf{C}, f(X), \\hat{f}(X))</span> : Check that  <span class="math">\\hat{f}(X) \\in \\mathbb{Z}(q/2)[X]</span>  and  <span class="math">\\hat{f}(q) \\cdot \\mathsf{G} = \\mathsf{C}</span>  and  <span class="math">f(X) = \\hat{f}(X) \\bmod p</span> .</li>

    </ul>

    <p class="text-gray-300">Evaluation protocol Using the cryptographic compilation of the information theoretic protocol we get an Eval protocol with logarithmic communication. In every round, however, the verifier needs to check consistency between  <span class="math">\\llbracket f_L(X)\\rrbracket</span> ,  <span class="math">\\llbracket f_R(X)\\rrbracket</span>  and  <span class="math">\\llbracket f(X)\\rrbracket</span> . This is done by checking that  <span class="math">\\mathsf{C}_L + q^{d&#x27; + 1} \\cdot \\mathsf{C}_R = \\mathsf{C}</span> . This naive check is highly inefficient as the exponent  <span class="math">q^{d&#x27; + 1}</span>  has  <span class="math">O(d)</span>  bits. To resolve this inefficiency, we utilize a proof of exponentiation (PoE) [Pie19, Wes19] to outsource the computation to the prover. The PoE protocol is an argument that a large scalar multiplication in a group of unknown order was performed correctly. Wesolowski's PoE [Wes19] is public coin, has constant communication and verification time, and is thus particularly well-suited here.</p>

    <p class="text-gray-300">We now specify subtleties that were previously glossed over. Instead of presenting a protocol for univariate degree  <span class="math">d</span>  polynomials we present one for  <span class="math">\\mu</span> -linear polynomials. This is more general as for any univariate polynomial  <span class="math">f(X)</span>  there exists a  <span class="math">\\mu = \\lceil \\log_2(d + 1) \\rceil</span> -linear polynomial  <span class="math">\\hat{f}</span>  with the same coefficients such that  <span class="math">\\hat{f}(X, X^2, \\ldots, X^{2^{(\\mu - 1)}}) = f(X)</span> . By the</p>

    <p class="text-gray-300">same argument, we can use a multi-linear polynomial commitment and evaluation scheme for arbitrary multivariate polynomials where the degree in each variable is a power of 2. For non-power-of-2 multivariate polynomials, it is possible to round up to the next power of 2 and prove correctness using a PoE proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The coefficients of  <span class="math">f(X_{1},\\ldots ,x_{\\mu})</span>  grow by a factor of  <span class="math">2^{\\lambda}</span>  in every recursion step, but eventually, the transmitted constant  <span class="math">f</span>  has to be tested against some bound because if it is too large it should be rejected. However, the function interface provides no option to specify the allowable size of coefficients. We therefore define and use a subroutine EvalB, which takes an additional argument  <span class="math">b</span>  and which proves, in addition to what Eval proves, that all coefficients  <span class="math">f_{i}</span>  of  <span class="math">f(X_{1},\\dots ,X_{\\mu})</span>  satisfy  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq b<span class="math"> . Importantly,  </span>b<span class="math">  grows by a factor for  </span>2^{\\lambda}<span class="math"> , the challenge space, in every recursion step. This subroutine is also useful if commitments were homomorphically combined prior to the execution of EvalB. The growth of these coefficients determines a lower bound on  </span>q<span class="math"> :  </span>q<span class="math">  needs to be significantly larger than  </span>b$  for security. Exactly which factor constitutes "significantly" is determined by the knowledge-soundness proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the final round we check that the constant  <span class="math">f</span>  satisfies  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq b<span class="math">  and the protocol&#x27;s correctness is guaranteed if  </span>b = (p - 1) \\cdot 2^{\\lambda \\mu}<span class="math"> , where  </span>\\mu = \\log(d + 1)<span class="math">  are the number of rounds. However,  </span>q<span class="math">  needs to be even larger than this value in order for extraction to work (and hence, for the proof of witness-extended emulation to go through). The precise value of  </span>q<span class="math">  depends on the number of rounds  </span>\\mu<span class="math"> , and is defined in Theorem 1 and is  </span>2^{O(\\mu \\lambda)}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now present the full, formal Eval protocol below.</p>

    <p class="text-gray-300">Eval(pp, C ∈ G,  <span class="math">\\vec{z} \\in \\mathbb{Z}_p^\\mu</span> ,  <span class="math">y \\in \\mathbb{Z}_p</span> ;  <span class="math">f(X_1, \\ldots, X_\\mu) \\in \\mathbb{Z}_p[X_1, \\ldots, X_\\mu]</span> ); //  <span class="math">f</span>  is  <span class="math">\\mu</span> -linear</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\hat{f}(X_1, \\ldots, X_\\mu) \\in \\mathbb{Z}(p)[X_1, \\ldots, X_\\mu]</span>  such that  <span class="math">\\hat{f} \\bmod p \\equiv f</span></li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run EvalB(pp, C,  <span class="math">\\vec{z}, y, \\mu, p - 1; f, \\hat{f}</span> )</li>

    </ol>

    <p class="text-gray-300">EvalB(pp, C ∈ G,  <span class="math">\\vec{z} \\in \\mathbb{Z}_p^\\mu</span> ,  <span class="math">y \\in \\mathbb{Z}_p</span> ,  <span class="math">\\mu \\in \\mathbb{N}</span> ,  <span class="math">b \\in \\mathbb{Z}</span> ;  <span class="math">f \\in \\mathbb{Z}_p[X_1, \\ldots, X_\\mu]</span> ,  <span class="math">\\hat{f} \\in \\mathbb{Z}(b)[X_1, \\ldots, X_\\mu]</span> )</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\mu = 0</span> :</li>

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\hat{f} \\in \\mathbb{Z}</span>  to the verifier. //  <span class="math">\\hat{f}</span>  is a constant</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.  <span class="math">\\mathcal{V}</span>  checks that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq b$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">\\hat{f} \\equiv y \\bmod p</span></li>

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">\\hat{f} \\cdot \\mathsf{G} = \\mathsf{C}</span></li>

      <li><span class="math">\\mathcal{V}</span>  outputs 1 if all checks pass, 0 otherwise.</li>

      <li>else :</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  compute  <span class="math">\\mu^{\\prime}\\gets \\mu -1</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\hat{f}_L(X_1,\\ldots ,X_\\mu &#x27;)</span>  and  <span class="math">\\hat{f}_R(X_1,\\dots ,X_\\mu &#x27;)</span>  such that  <span class="math">\\hat{f} = \\hat{f}_L + X_\\mu \\hat{f}_R</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">f_{L}, f_{R}</span>  analogously for  <span class="math">f</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">y_{L} \\gets f_{L}(z_{1},\\ldots,z_{\\mu}^{\\prime}) \\bmod p</span>  and  <span class="math">y_{R} \\gets f_{R}(z_{1},\\ldots,z_{\\mu}^{\\prime}) \\bmod p</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\mathsf{C}_L\\gets \\hat{f}_L(q,q^2,\\ldots ,q^{(2^{\\mu &#x27; - 1})})\\cdot \\mathsf{G}</span>  and  <span class="math">\\mathsf{C}_R\\gets \\hat{f}_R(q,q^2,\\ldots ,q^{(2^{\\mu &#x27; - 1})})\\cdot \\mathsf{G}</span></li>

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">y_{L}, y_{R}, \\mathsf{C}_{L}, \\mathsf{C}_{R}</span>  to  <span class="math">\\mathcal{V}</span> . // See Section 4.5 for an optimization</li>

      <li><span class="math">\\mathcal{V}</span>  checks that  <span class="math">y = y_{L} + z_{\\mu} \\cdot y_{R} \\bmod p</span> , outputs 0 if check fails.</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run  <span class="math">\\mathsf{PoE}(\\mathsf{C}_R,\\mathsf{C} - \\mathsf{C}_L,q^{(2\\mu &#x27;}))\\quad / / \\quad</span>  Showing that  <span class="math">C_L + q^{(2\\mu &#x27;)}\\cdot C_R = C</span></li>

      <li><span class="math">\\mathcal{V}</span>  samples  <span class="math">\\alpha \\stackrel{\\</span>}{\\leftarrow} [0,2^{\\lambda})<span class="math">  and sends it to  </span>\\mathcal{P}$</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  compute  <span class="math">y^\\prime \\gets y_L + \\alpha \\cdot y_R\\bmod p</span> <span class="math">\\mathsf{C}^{\\prime}\\gets \\mathsf{C}_{L} + \\alpha \\cdot \\mathsf{C}_{R},b^{\\prime}\\gets b\\cdot 2^{\\lambda}</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">f^{\\prime}\\gets f_{L} + \\alpha \\cdot f_{R}\\in \\mathbb{Z}_{p}[X_{1},\\ldots ,X_{\\mu^{\\prime}}]</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\hat{f}^{\\prime}\\gets \\hat{f}_{L} + \\alpha \\cdot \\hat{f}_{R}\\in \\mathbb{Z}[X_{1},\\ldots ,X_{\\mu^{\\prime}}]\\quad / / \\quad \\hat{f}^{\\prime}</span>  and  <span class="math">f^{\\prime}</span>  are  <span class="math">\\mu^{\\prime}</span> -linear</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run EvalB(pp,  <span class="math">C^{\\prime},\\vec{z}^{\\prime} = (z_{1},\\ldots ,z_{\\mu}^{\\prime}),y^{\\prime},\\mu^{\\prime},b^{\\prime};f^{\\prime},\\hat{f}^{\\prime})</span></li>

    </ol>

    <p class="text-gray-300">The new security analysis is in a self-contained document in the appendix. We, briefly, restate the main lemmas and theorems but refer the reader to the appendix for more details.</p>

    <p class="text-gray-300">We show in Lemma 10 that the DARK polynomial commitment scheme is binding.</p>

    <p class="text-gray-300">Lemma 5. The polynomial commitment scheme is correct for  <span class="math">\\mu</span> -linear polynomials in  <span class="math">\\mathbb{Z}_p[X]</span> .</p>

    <p class="text-gray-300">The proof of this lemma is in Appendix C.2. Next is the main security theorem, which states that the evaluation protocol has witness-extended emulation.</p>

    <p class="text-gray-300">Theorem 1. Let  <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda} = 8\\mu^2 + \\log_2(2\\mu)\\lambda</span> . Let  <span class="math">\\mathsf{EBL}_{\\mu, \\lambda} = \\lambda \\cdot \\mu</span>  and  <span class="math">\\mathsf{CB}_{p, \\mu, \\lambda} = \\lambda \\cdot \\mu + \\log_2 p</span> . Let  <span class="math">\\mathsf{com}</span>  be the DARK commitment scheme as described in Lemma 10. There exists a pair</p>

    <p class="text-gray-300">of predicates <span class="math">\\phi</span> such that the <span class="math">\\mu</span>-round DARK polynomial commitment evaluation protocol Evaf with <span class="math">\\lambda</span>-bit challenges, a group of unknown order GGen, and <span class="math">\\log q\\geq 4(\\lambda+1+\\mathsf{CSZ}_{\\mu,\\lambda})+\\mathsf{EBL}_{\\mu,\\lambda}+\\mathsf{CB}_{p,\\mu,\\lambda}+1</span> is <span class="math">(2^{(\\mu)},\\frac{3\\rho}{2^{4}},\\mathsf{com},\\phi)</span>-almost-special-sound.</p>

    <p class="text-gray-300">As a corollary, under the adaptive root assumption for GGen, the DARK polynomial commitment scheme with the same parameters has witness-extended-emulation (Definition 8).</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.5 Optimizations</h3>

    <p class="text-gray-300">We present several ideas for optimizing the performance of the Eval protocol.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Precomputation.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover has to compute powers of <span class="math">\\mathsf{G}</span> as large as <span class="math">q^{2^{\\mu}-1}</span>. While this can be done in quasi-linear time, this expense can be shifted to a preprocessing phase in which all elements <span class="math">\\mathsf{G}^{q^{r}},i\\in\\{1,\\ldots,2^{\\mu}-1\\}</span> are computed. Since for coefficient $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq-\\frac{p-1}{2}<span class="math"> this allows the computation of </span>\\mathsf{G}^{f(q)}<span class="math"> in </span>O(\\lambda 2^{\\mu})<span class="math"> group operations as opposed to </span>O(\\lambda 2^{\\mu}\\mu)<span class="math">. In addition to reducing the prover’s workload, this optimization enables parallelizing it. The computation of the </span>\\mathsf{PoE}<span class="math"> proofs can similarly be parallelized. The prover can express each </span>Q<span class="math"> as a power of </span>\\mathsf{G}<span class="math"> which enables pre-computation of powers of </span>\\mathsf{G}$ and parallelism as described by Boneh et al. <em>[x1]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The pre-computation also enables the use of multi-scalar multiplication techniques <em>[x22]</em>. Boneh et al. <em>[x1]</em> and Wesolowski <em>[x24]</em> showed how to use these techniques to reduce the complexity of the <span class="math">\\mathsf{PoE}</span> prover. The largest <span class="math">\\mathsf{PoE}</span> exponent <span class="math">q^{2^{\\mu-1}}</span> has <span class="math">O(\\lambda 2^{\\mu}\\mu)</span> bits. Multi-scalar multiplication can therefore reduce the prover work to <span class="math">O(\\lambda 2^{\\mu})</span> instead of <span class="math">O(\\lambda 2^{\\mu}\\mu)</span>. For univariate polynomials of degree <span class="math">d</span> this translates to prover work that is <span class="math">O(\\lambda d)</span>.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Two group elements per round.</h4>

    <p class="text-gray-300">In each round the verifier has a value <span class="math">\\mathsf{C}</span> and receives <span class="math">\\mathsf{C}_{L}</span> and <span class="math">\\mathsf{C}_{R}</span> such that <span class="math">\\mathsf{C}_{L}+q^{2^{\\mu^{\\prime}-1}}\\cdot\\mathsf{C}_{R}=\\mathsf{C}</span>. This is redundant. It suffices that the verifier sends <span class="math">\\mathsf{C}_{R}</span>. The verifier could now compute <span class="math">\\mathsf{C}_{L}\\leftarrow\\mathsf{C}-q^{2^{\\mu^{\\prime}-1}}\\mathsf{C}_{R}</span>, but this is expensive as it involves an scalar multiplication by <span class="math">q^{d}</span>. Instead, the verifier infers <span class="math">q^{2^{\\mu^{\\prime}-1}}\\cdot\\mathsf{C}_{R}</span> from the <span class="math">\\mathsf{PoE}</span>: the prover’s message is <span class="math">\\mathsf{Q}</span> and the verifier can directly compute <span class="math">q^{2^{\\mu^{\\prime}-1}}\\cdot\\mathsf{C}_{R}\\leftarrow\\ell\\cdot\\mathsf{Q}+r\\cdot\\mathsf{C}_{R}</span> for a challenge <span class="math">\\ell</span> and <span class="math">r\\leftarrow q^{2^{\\mu^{\\prime}-1}}\\bmod\\ell</span>. From this the verifier infers <span class="math">\\mathsf{C}_{L}\\leftarrow\\mathsf{C}-q^{2^{\\mu^{\\prime}-1}}\\cdot\\mathsf{C}_{R}</span>. The security of <span class="math">\\mathsf{PoE}</span> does not require that <span class="math">q^{d^{\\prime}+1}\\cdot\\mathsf{C}_{R}</span> be sent before the challenge <span class="math">\\ell</span> as it is uniquely defined by <span class="math">\\mathsf{C}_{R}</span> and <span class="math">q^{2^{\\mu^{\\prime}-1}}</span>. The same optimization can be applied to the non-interactive variant of the protocol.</p>

    <p class="text-gray-300">Similarly the verifier can infer <span class="math">y_{L}</span> as <span class="math">y_{L}\\leftarrow y-z^{2^{\\mu^{\\prime}-1}}y_{R}</span>. This reduces the communication to two group elements per round and 1 field element. Additionally the prover sends <span class="math">f</span> which has roughly the size of <span class="math">\\mu</span> field elements, which increases the total communication to roughly <span class="math">2\\mu</span> elements in <span class="math">\\mathbb{G}</span> and <span class="math">2\\mu</span> elements in <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Evaluation at multiple points</h4>

    <p class="text-gray-300">The protocol and the security proof extend naturally to the evaluation in a vector of points <span class="math">\\boldsymbol{z}</span> resulting in a vector of values <span class="math">\\boldsymbol{y}</span>, where both are members of <span class="math">\\mathbb{Z}_{p}^{k}</span>. The prover still sends <span class="math">\\mathsf{C}_{L}\\in\\mathbb{G}</span> and <span class="math">\\mathsf{C}_{R}\\in\\mathbb{G}</span> in each round and additionally <span class="math">\\boldsymbol{y}_{L},\\boldsymbol{y}_{R}\\in\\mathbb{Z}_{p}^{k}</span>. In the final round the prover only sends a single integer <span class="math">f</span> such that <span class="math">\\mathsf{G}^{f}=\\mathsf{C}</span> and <span class="math">f\\bmod p=y</span>.</p>

    <p class="text-gray-300">This is significantly more efficient than independent executions of the protocol as the encoding of group elements is usually much larger than the encoding of elements in <span class="math">\\mathbb{Z}_{p}</span>. Using the optimization above, the marginal cost with respect to <span class="math">k</span> of the protocol is a single element in <span class="math">\\mathbb{Z}_{p}</span>. If <span class="math">\\lambda=\\lceil\\log_{2}(p)\\rceil</span> is 120, then this means evaluating the polynomial at an additional point increases the proof size by only <span class="math">15\\mu</span> bytes.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Joining Evals.</h4>

    <p class="text-gray-300">In many applications such as compiling polynomial IOPs to SNARKs (see Section 5) multiple polynomial commitments need to be evaluated at the same point <span class="math">z</span>. This can be done efficiently by taking a random linear combination of the polynomials and evaluating that combination at <span class="math">z</span>. The prover simply sends the evaluations of the individual polynomials and then a single evaluation proof for the combined polynomials. The communication cost for evaluating <span class="math">m</span> polynomials at 1 point is still linear in <span class="math">m</span> but only because the evaluation of each polynomial at the point is being sent. The size of the eval</p>

    <p class="text-gray-300">proof, however, is independent of  <span class="math">m</span> . Taking a random linear combination does increase the bound on  <span class="math">q</span>  slightly, as shown in Theorem 2 which is presented below.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathsf {J E}} (\\mathsf {p p}) = \\left\\{\\langle (\\mathsf {C} _ {1}, \\mathsf {C} _ {2}, z, y _ {1}, y _ {2}, d), (\\hat {f} _ {1}, \\hat {f} _ {2}) \\rangle : \\begin{array}{l} \\mathsf {C} _ {1}, \\mathsf {C} _ {2} \\in \\mathbb {G} \\\\ z, y _ {1}, y _ {2} \\in \\mathbb {Z} _ {p} \\\\ f _ {1}, f _ {2} \\in \\mathbb {Z} (b) [ \\vec {X} = (X _ {1}, \\ldots , X _ {\\mu}) ] \\\\ (\\mathsf {C} _ {1}, \\vec {z}, y _ {1}, \\mu) \\in \\mathcal {R} _ {\\mathsf {E v a l}} (\\mathsf {p p}) \\\\ (\\mathsf {C} _ {2}, \\vec {z}, y _ {2}, \\mu) \\in \\mathcal {R} _ {\\mathsf {E v a l}} (\\mathsf {p p}) \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">JoinedEval(pp, C1, C2, z̅ ∈ Zp, y1 ∈ Zp, y2 ∈ Zp, μ; f1 ∈ Z(b)[X], f2 ∈ Z(b)[X]):</p>

    <p class="text-gray-300">Statement:  <span class="math">(\\mathsf{pp},\\mathsf{C}_1,\\mathsf{C}_2,z,y_1,y_2,b,d)\\in \\mathcal{R}_{\\mathsf{JE}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  samples  <span class="math">\\alpha \\stackrel{\\mathrm{S}}{\\leftarrow} [0,2^{\\lambda})</span>  and sends it to  <span class="math">\\mathcal{P}</span></li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  compute  <span class="math">y^\\prime \\gets y_1 + \\alpha \\cdot y_2</span>  mod  <span class="math">p</span></li>

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\hat{f}^{\\prime}(\\vec{X},Y)\\gets \\hat{f}_1(\\vec{X}) + Y\\hat{f}_2(\\vec{X})</span>  and  <span class="math">f^{\\prime} = \\hat{f}^{\\prime}</span>  mod  <span class="math">p</span></li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run EvalB(pp,  <span class="math">C_1 + q^{2^\\mu}C_2</span> ,  <span class="math">(\\vec{z},\\alpha),y&#x27;,\\mu +1;f&#x27;,\\hat{f}&#x27;)^a</span></li>

    </ol>

    <p class="text-gray-300">aThe prover and verifier don't actually need to compute  <span class="math">\\mathsf{C}_1 + q^{2^\\mu}C_2</span>  as the next prover message can be computed directly from  <span class="math">\\mathsf{C}_1</span>  and  <span class="math">\\mathsf{C}_2</span></p>

    <p class="text-gray-300">Theorem 2. Let  <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda}, \\mathsf{EBL}_{\\mu, \\lambda}</span>  and  <span class="math">\\mathsf{CB}_{p, \\mu, \\lambda}</span>  be defined as in theorem 1. Let  <span class="math">\\log q \\geq 4(\\lambda + 1 + \\mathsf{CSZ}_{\\mu + 1, \\lambda}) + \\mathsf{EBL}_{\\mu + 1, \\lambda} + \\mathsf{CB}_{p, \\mu + 1, \\lambda} + 1</span> . Under the adaptive root assumption for  <span class="math">GGen</span> , the JoinedEval protocol has witness-extended-emulation (Definition 8) for the relation  <span class="math">\\mathcal{R}_{\\mathsf{JE}}</span> .</p>

    <p class="text-gray-300">Proof. Security directly follows from Theorem 1 as  <span class="math">C_1, C_2</span>  is a binding virtual commitment to the  <span class="math">\\mu + 1</span> -linear polynomial  <span class="math">f_1 + Y \\cdot f_2</span> . That is,  <span class="math">C = C_1 + q^{2^\\mu} \\cdot C_2</span>  can be computed from  <span class="math">C_1, C_2</span>  thus if  <span class="math">C</span>  is a binding commitment then so is  <span class="math">(C_1, C_2)</span> . We will show that the protocol has 2-special soundness using the extractor on the  <span class="math">\\mu + 1</span> -linear evaluation protocol. Using two executions with challenges  <span class="math">\\alpha</span>  and  <span class="math">\\alpha&#x27;</span>  we call the DARK extractor. This returns a witness polynomials  <span class="math">f, f&#x27; \\in \\mathbb{Z}_p</span>  such that  <span class="math">f(\\vec{z}, \\alpha) = y_L + \\alpha y_R</span>  and  <span class="math">f(\\vec{z}, \\alpha&#x27;) = y_L + \\alpha&#x27; y_R</span> . If  <span class="math">f \\neq f&#x27;</span>  the we have a break of the binding property of the commitment scheme as  <span class="math">C_L + q^{2^\\mu} C_R</span>  is both a commitment to  <span class="math">f</span>  and to  <span class="math">f&#x27;</span> . Otherwise we get that  <span class="math">(\\alpha - \\alpha&#x27;)^{-1}(f(\\vec{z}, \\alpha) - f(\\vec{z}, \\alpha&#x27;)) = f_R(\\vec{z}) = y_R</span>  and  <span class="math">(\\alpha&#x27; - \\alpha)^{-1}(\\alpha&#x27; f(\\vec{z}, \\alpha) - \\alpha f(\\vec{z}, \\alpha&#x27;)) = f_L(\\vec{z}) = y_L</span> .</p>

    <p class="text-gray-300">We can additionally combine this optimization with the previous optimization of evaluating a single polynomial at different points. This allows us to evaluate  <span class="math">m</span>  polynomials at  <span class="math">k</span>  points with very little overhead. The prover groups the polynomials by evaluation points and first takes linear combinations of the polynomials with the same evaluation point and computes  <span class="math">y_{1}</span>  to  <span class="math">y_{k}</span>  using the same linear combinations. Then it takes another combination of the joined polynomials. In each round of the Eval protocol the prover sends  <span class="math">y_{L,1}</span>  through  <span class="math">y_{L,k}</span> , i.e. one field element per evaluation point and computes  <span class="math">y_{R,1}</span>  through  <span class="math">y_{R,k}</span> . In the final step the prover sends  <span class="math">f</span>  and the verifier can check whether the final  <span class="math">y</span>  values are all equal to  <span class="math">f \\mod p</span> . This enables an Eval proof of  <span class="math">m</span> ,  <span class="math">\\mu</span> -linear polynomials at  <span class="math">k</span>  points using only  <span class="math">2\\mu</span>  group elements and  <span class="math">(1 + k)\\mu</span>  field elements.</p>

    <p class="text-gray-300">Evaluating the polynomial over multiple fields The polynomial commitment scheme is highly flexible. For example, it does not specify a prime field  <span class="math">\\mathbb{Z}_p</span> . It instead commits to an integer polynomial with bounded coefficients. That integer polynomial can be evaluated modulo arbitrary primes which are exponential in the security parameter  <span class="math">\\lambda</span>  as the soundness error is proportional to its inverse. Note that  <span class="math">q</span>  also needs large enough such that the scheme is secure for the given prime  <span class="math">p</span>  and linearity  <span class="math">\\mu</span>  (see Theorem 1). The second condition, however, can be relaxed. A careful analysis shows that as long as  <span class="math">p</span>  is exponential in  <span class="math">\\lambda</span>  and  <span class="math">q</span>  is sufficiently large, the scheme is secure. So as long as  <span class="math">\\log q \\geq 4(\\lambda + 1 + \\mathsf{CSZ}_{\\mu,\\lambda}) + \\mathsf{EBL}_{\\mu,\\lambda} + \\mathsf{CB}_{b,\\mu,\\lambda} + 1</span>  one can evaluate  <span class="math">\\mu</span> -linear polynomial with coefficients bounded by  <span class="math">b</span>  over any exponential prime field.</p>

    <p class="text-gray-300">Additionally, the proof elements  <span class="math">\\mathsf{C}_L</span> ,  <span class="math">\\mathsf{C}_R \\in \\mathbb{G}</span>  are independent of the field over which the polynomial is evaluated. This means that it is possible to evaluate a committed polynomial  <span class="math">f(X) \\in \\mathbb{Z}(b)</span>  over two separate fields  <span class="math">\\mathbb{Z}_p</span>  and  <span class="math">\\mathbb{Z}_{p&#x27;}</span>  in parallel using only  <span class="math">2\\mu</span>  group elements and sending the evaluations  <span class="math">y</span>  modulo  <span class="math">p \\cdot p&#x27;</span> . The verifier performs all operations on  <span class="math">y</span>  modulo  <span class="math">p \\cdot p&#x27;</span>  as well.</p>

    <p class="text-gray-300">This property can be used to efficiently evaluate the polynomial modulo a large integer  <span class="math">m</span>  by choosing multiple  <span class="math">\\lambda</span>  bit primes  <span class="math">p_1, \\ldots, p_k</span>  such that  <span class="math">\\prod_{i=1}^{k} p_i \\geq m</span>  and using the Chinese Remainder Theorem to simulate the evaluation modulo  <span class="math">m</span> .</p>

    <p class="text-gray-300">The polynomial commitment scheme has logarithmic proof size and verifier time in the degree  <span class="math">d</span>  of the committed polynomial. It has highly batchable proofs and it is possible to evaluate  <span class="math">n</span>  degree  <span class="math">d</span>  polynomials at  <span class="math">k</span>  points using only  <span class="math">2\\log_2(d + 1)</span>  group elements and  <span class="math">(k + 1)\\log_2(d + 1)</span>  field elements (see Section 4.5). Note that this means the proof size is independent of  <span class="math">n</span>  and linear in  <span class="math">k</span>  but with a small constant  <span class="math">(15\\log(d)</span>  bytes). We describe the performance of our scheme for different settings for uni- and multivariate instantiations in Table 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit(f(X))</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λd log(d))G</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit(f(X))</td>

            <td class="px-3 py-2 border-b border-gray-700">d G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λd/ log(d))G</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f(z) = y ∈ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log(d)d)G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log(d))G</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(d)G + 2 log(d)Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f(z) = y ∈ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">d G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λd)G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log(d))G</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(d)G + 2 log(d)Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f(z) = y ∈ Zp^k</td>

            <td class="px-3 py-2 border-b border-gray-700">d G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λd)G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log(d))G</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(d)G + (k+1) log(d)Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f(z) = y, g(z) = y' ∈ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">d G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λd)G</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log(d))G</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(d)G + 2 log(d)Zp</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1:  <span class="math">\\mathbb{G}</span>  denotes the size of a group element for communication and a single group operation for computation.  <span class="math">\\mathbb{Z}_p</span>  denotes the size of a field element, i.e.,  <span class="math">\\lambda</span>  bits.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the size of the public parameters (which is greater than one  </span>\\mathbb{G}<span class="math">  when preprocessing is used), and  </span>d$  the degree of the polynomial. Rows 3-6 are for Eval proofs of different statements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The polynomial commitment by Kate et al. [KZG10] has evaluation proofs that consist of only a single element in a bilinear group and verifying an evaluation requires only a single pairing computation. However, this asymptotically optimal performance comes at the cost of a trusted setup procedure that outputs a structured reference string whose size is linear in the degree of the polynomial. Our DARK polynomial commitment scheme requires no trusted setup but pays for this reduced trust requirement with a proof size and verification work that scale logarithmically in the degree of the polynomial.</p>

    <p class="text-gray-300">In the multivariate setting, our scheme is logarithmic in the total number of coefficients:  <span class="math">\\mu \\log (d)</span>  for a  <span class="math">\\mu</span> -variate polynomial of degree  <span class="math">d</span>  in each variable. The multivariate extension of Kate et al.'s commitment scheme [ZGK+17] evaluation proofs consist of  <span class="math">\\mu</span>  group elements.</p>

    <p class="text-gray-300">Bulletproofs [BCC+16b, BBB+18] is a proof system based on prime order groups in which the discrete logarithm is hard. As a core component it relies on an inner product argument which can be used as a polynomial commitment (see [WTs+18]). The polynomial commitment has logarithmic evaluation proofs with great constants. Unfortunately, the verifier time is linear in the size of the polynomial, i.e.  <span class="math">(d + 1)^{\\mu}</span>  for a  <span class="math">\\mu</span> -variate degree  <span class="math">d</span>  polynomial. The more general version of the commitment [BCC+16b] can also give evaluation proofs with square root verifier time and square root proof size.</p>

    <p class="text-gray-300">The FRI protocol [BBHR18] is an efficient interactive oracle proof (IOP) that a committed oracle is close to a Reed-Solomon codeword, meaning that the prover commits to large sequences of field elements and the verifier queries only a few specific elements rather than reading the entire sequence. The abstract functionality is cryptographically compiled with a Merkle tree, which results in constant-size commitments and element queries that are logarithmic in the length of the codeword, i.e., the size of the oracle. FRI has been used in</p>

    <p class="text-gray-300">multiple recent zero-knowledge proof systems such as STARK [BBHR19], Aurora  <span class="math">\\left[\\mathrm{BCR}^{+}19\\right]</span> , and Fractal [COS19].</p>

    <p class="text-gray-300">Since this oracle is a Reed-Solomon codeword, it represents the evaluations of a low-degree polynomial  <span class="math">f</span>  on an evaluation set  <span class="math">S \\subset \\mathbb{F}</span> . In order to be used as a polynomial commitment scheme, the protocol needs to permit querying the polynomial outside of the evaluation set. DEEP-FRI [BGKS19] shows that this is possible and two recent works [ZXZS19, KPV19] makes the connection explicit by building a polynomial commitment scheme from FRI. This FRI-based polynomial commitment scheme have evaluation proofs of size and verifier time  <span class="math">O(\\lambda \\log^2(d))</span>  where  <span class="math">\\lambda</span>  is the security parameter and  <span class="math">d = \\deg(f)</span> . To date, no extension to multivariate polynomials exists for FRI. The commitment relies only on symmetric cryptography and is plausibly quantum resistant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Table 2 we give a comparison between different polynomial commitment schemes in the literature. In particular, we evaluate the size of the reference string (  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  ), the prover and verifier time, as well as the size of the evaluation proof  </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  . Column 2 indicates whether the setup is transparent, i.e., whether the reference string is structured. The symbol  </span>\\mathbb{G}_U<span class="math">  denotes a group of unknown order,  </span>\\mathbb{G}_B<span class="math">  a group with a bilinear map (pairing), and  </span>\\mathbb{G}_P<span class="math">  a group with prime (and known) order. Furthermore, MUL refers to scalar multiplications of a  </span>\\lambda$  bit number in these groups, and H is either the size of a hash output, or the time it takes to compute a hash, depending on context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that even when precise factors are given, the numbers should be interpreted as estimates. For example we chose to not display smaller order terms. Note also that the prover time for the group based schemes could be brought down by a log factor when using multi-scalar multiplication techniques.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DARK (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dμμ log(d)) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">3μ log(d) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">2μ log(d) GU</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Based on Pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">dμG_B</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dμ) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">μ Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">μ G_B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCC+16b, √]</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">√dμG_P</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dμ) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√dμ)MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√dμ) G_P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">2dμG_P</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dμ) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dμ)MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">2μ log(d) G_P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI-based (μ = 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λd) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log2(d)) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log2(d)) H</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison table between different polynomial commitment schemes for an  <span class="math">\\mu</span> -variate polynomial of degree  <span class="math">d</span> .</p>

    <p class="text-gray-300">An interactive oracle proof (IOP) [BCS16, RRR16] is a multi-round interactive PCP: in each round of an IOP the verifier sends a message to the prover and the prover responds with a polynomial length proof, which the verifier can query via random access. A  <span class="math">t</span> -round  <span class="math">\\ell</span> -query IOP has  <span class="math">t</span>  rounds of interaction in which the verifier makes exactly  <span class="math">\\ell</span>  queries in each round. Linear IOPs [BBC+19] are defined analogously except that in each round the prover sends a linear PCP [IKO07], in which the prover sends a single proof vector  <span class="math">\\pi \\in \\mathbb{F}^m</span>  and the verifier makes linear queries to  <span class="math">\\pi</span> . Specifically, the PCP gives the verifier access to an oracle that receives queries of the form  <span class="math">\\mathbf{q} \\in \\mathbb{F}^m</span>  and returns the inner product  <span class="math">\\langle \\pi, \\mathbf{q} \\rangle</span> .</p>

    <p class="text-gray-300">Bitansky et al.  <span class="math">\\mathrm{[BCI^{+}13]}</span>  defined a linear PCP to be of degree  <span class="math">(d_{Q},d_{V})</span>  if there is an explicit circuit of degree  <span class="math">d_{Q}</span>  that derives the query vector from the verifier's random coins, and an explicit circuit of degree  <span class="math">d_V</span>  that computes the verifier's decision from the query responses. In a multi-query PCP,  <span class="math">d_{Q}</span>  refers to the maximum degree over all the independent circuits computing each query. Bitansky et al. called the linear PCP algebraic for a security parameter  <span class="math">\\lambda</span>  if it has degree  <span class="math">(\\mathsf{poly}(\\lambda),\\mathsf{poly}(\\lambda))</span> . The popular linear PCP based on Quadratic Arithmetic Programs (QAPs) implicit in the GGPR protocol [GGPR13] and follow-up works is an algebraic linear PCP with  <span class="math">d_{Q}\\in O(m)</span>  and  <span class="math">d_V = 2</span> , where  <span class="math">m</span>  is the size of the witness.</p>

    <p class="text-gray-300">For the purposes of the present work, we are only interested in the algebraic nature of the query circuit and not the verifier's decision circuit. Of particular interest are linear PCPs</p>

    <p class="text-gray-300">where each query-and-response interaction corresponds to the evaluation of a fixed <span class="math">\\mu</span>-variate degree <span class="math">d</span> polynomial at a query point in <span class="math">\\mathbb{F}^{\\mu}</span>. This description is equivalent to saying that the PCP is a vector of length <span class="math">m = \\binom{d + \\mu}{\\mu}</span> and the query circuit is the vector of all <span class="math">\\mu</span>-variate monomials of degree at most <span class="math">d</span> (in some canonical order) evaluated at a point in <span class="math">\\mathbb{F}^{\\mu}</span>. We call this a <span class="math">(\\mu, d)</span> Polynomial PCP and define Polynomial IOPs analogously. As we will explain, we are interested in Polynomial PCPs where <span class="math">\\mu \\ll m</span> because we can cryptographically compile them into succinct arguments using polynomial commitments, in the same way that Merkle trees are used to compile classical (point) IOPs.</p>

    <p class="text-gray-300">In general, evaluating the query circuit for a linear PCP requires <span class="math">\\Omega(m)</span> work. However, a general "bootstrapping" technique can reduce the work for the verifier: the prover expands the verifier's random coins into a full query vector, and then provides the verifier with a second PCP demonstrating that this expansion was computed correctly. It may also help to allow the verifier to perform <span class="math">O(m)</span> work in a one-time preprocessing stage (for instance, to check the correctness of a PCP oracle), enabling it to perform sublinear "online" work when verifying arbitrary PCPs later. We call this a preprocessing IOP. In fact, we will see that any <span class="math">t</span>-round <span class="math">(\\mu, d)</span> algebraic linear IOP can be transformed into a <span class="math">(t + 1)</span>-round Polynomial IOP in which the verifier preprocesses <span class="math">(\\mu, d)</span> Polynomial PCPs, at most one for each distinct query.</p>

    <p class="text-gray-300">We recall the formal definition of public-coin linear IOPs as well as an algebraic linear IOPs. Since we are not interested in the algebraic nature of the decision algorithm, we omit specifying the decision polynomial. From here onwards we use algebraic linear IOP as shorthand for algebraic query linear IOP.</p>

    <p class="text-gray-300"><strong>Definition 3 (Public-coin linear IOP).</strong> Let <span class="math">\\mathcal{R}</span> be a binary relation and <span class="math">\\mathbb{F}</span> a finite field. A <span class="math">t</span>-round <span class="math">\\ell</span>-query public-coin linear IOP for <span class="math">\\mathcal{R}</span> over <span class="math">\\mathbb{F}</span> with soundness error <span class="math">\\epsilon</span> and knowledge error <span class="math">\\delta</span> and query length <span class="math">\\mathbf{m} = (m_1, \\dots, m_t)</span> consists of two stateful PPT algorithms, the prover <span class="math">\\mathcal{P}</span>, and the verifier <span class="math">\\mathcal{V} = (\\mathcal{Q}, \\mathcal{D})</span>, where the verifier consists in turn of a public deterministic query generator <span class="math">\\mathcal{Q}</span> and a decision algorithm <span class="math">\\mathcal{D}</span>, that satisfy the following requirements:</p>

    <p class="text-gray-300"><strong>Protocol syntax.</strong> For each <span class="math">i</span>th round there is a prover state <span class="math">\\mathfrak{st}_i^{\\mathcal{P}}</span> and a verifier state <span class="math">\\mathfrak{st}_i^{\\mathcal{V}}</span>. For any common input <span class="math">x</span> and <span class="math">\\mathcal{R}</span> witness <span class="math">w</span>, at round 0 the states are <span class="math">\\mathfrak{st}_0^{\\mathcal{P}} = (x, w)</span> and <span class="math">\\mathfrak{st}_0^{\\mathcal{V}} = x</span>. In the <span class="math">i</span>th round (starting at <span class="math">i = 1</span>) the prover outputs a single proof oracle <span class="math">\\mathcal{P}(\\mathfrak{st}_{i-1}^{\\mathcal{P}}) \\to \\pi_i \\in \\mathbb{F}^{m_i}</span>. The verifier samples public random coins <span class="math">coins_i \\stackrel{\\</span>}{\\leftarrow} \\{0, 1\\}^*<span class="math"> and the query generator computes a query matrix from the verifier state and these coins: </span>\\mathcal{Q}(\\mathfrak{st}_{i-1}^{\\mathcal{V}}, coins_i) \\to \\mathbf{Q}_i \\in \\mathbb{F}^{m_i \\times \\ell}<span class="math">. The verifier obtains the linear oracle response vector </span>\\pi_i^\\top \\mathbf{Q}_i = \\mathbf{a}_i \\in \\mathbb{F}^{1 \\times \\ell}<span class="math">. The updated prover state is </span>\\mathfrak{st}_i^{\\mathcal{P}} \\gets (\\mathfrak{st}_{i-1}^{\\mathcal{P}}, \\mathbf{Q}_i)<span class="math"> and verifier state is </span>\\mathfrak{st}_i^{\\mathcal{V}} \\gets (\\mathfrak{st}_{i-1}^{\\mathcal{V}}, coins_i, \\mathbf{a}_i)<span class="math">. Finally, </span>\\mathcal{D}(\\mathfrak{st}_i^{\\mathcal{V}})$ returns 1 or 0.</p>

    <p class="text-gray-300">(Querying prior round oracles: The syntax can be naturally extended so that in the <span class="math">i</span>th round the verifier may query any oracle, whether sent in the <span class="math">i</span>th round or earlier.)</p>

    <p class="text-gray-300"><strong>Argument of Knowledge.</strong> As a proof system, <span class="math">(\\mathcal{P}, \\mathcal{V})</span> satisfies perfect completeness, soundness with respect to the relation <span class="math">\\mathcal{R}</span> and with soundness error <span class="math">\\epsilon</span>, and witness-extended emulation with respect <span class="math">\\mathcal{R}</span> with knowledge error <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">Furthermore, a linear IOP is <strong>stateless</strong> if for each <span class="math">i \\in [t]</span>, <span class="math">\\mathcal{Q}(\\mathfrak{st}_{i-1}^{\\mathcal{V}}, coins_i) = \\mathcal{Q}(i, coins_i)</span>. It has <strong>algebraic queries</strong> if, additionally, for each <span class="math">i \\in [t]</span>, the map <span class="math">coins_i \\xrightarrow{\\mathcal{Q}(i,-)} \\mathbf{Q}_i \\in \\mathbb{F}^{m_i \\times \\ell}</span> decomposes into two maps, <span class="math">coins_i \\xrightarrow{\\mathcal{Q}_0(i,-)} \\Sigma_i \\xrightarrow{\\mathcal{Q}_1(i,-)} \\mathbf{Q}_i</span>, where <span class="math">\\Sigma_i \\in \\mathbb{F}^{\\mu_i \\times \\ell}</span> is a matrix of <span class="math">\\mu_i &amp;lt; m_i</span> rows and <span class="math">\\ell</span> and <span class="math">\\mathcal{Q}_1(i,-)</span> is described by <span class="math">\\ell</span> <span class="math">\\mu_i</span>-variate polynomial functions of degree at most <span class="math">d = \\mathsf{poly}(\\lambda): \\vec{p}_1, \\ldots, \\vec{p}_{\\ell}: \\mathbb{F}^{\\mu_i} \\to \\mathbb{F}^{m_i}</span> such that for all <span class="math">k \\in [\\ell]</span>, <span class="math">\\vec{p}_k(\\sigma_{i,k}) = \\mathbf{q}_{i,k}</span>, where <span class="math">\\sigma_{i,k}</span> and <span class="math">\\mathbf{q}_{i,k}</span> denote the <span class="math">k</span>th column of <span class="math">\\Sigma_i</span> and <span class="math">\\mathbf{Q}_i</span>, respectively.</p>

    <p class="text-gray-300"><strong>Definition 4 (HVZK for public-coin linear IOPs).</strong> Let <span class="math">\\mathsf{View}_{(\\mathcal{P}(x,w),\\mathcal{V}(x))}(\\mathcal{V})</span> denote the view of the verifier in the <span class="math">t</span>-round <span class="math">\\ell</span>-query interactive protocol described in Definition 3 on inputs <span class="math">(x,w)</span> with prover algorithm <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>, consisting of all public-coin challenges and oracle outputs (this view is equivalent to the final state <span class="math">\\mathfrak{st}_t^{\\mathcal{V}}</span>). The interactive protocol has <span class="math">\\delta</span>-statistical honest-verifier zero-knowledge if there exists a probabilistic polynomial time algorithm <span class="math">\\mathcal{S}</span> such that for every <span class="math">(x,w) \\in \\mathcal{R}</span>, the distribution <span class="math">\\mathcal{S}(x)</span> is <span class="math">\\delta</span>-close to</p>

    <p class="text-gray-300">7The prover may also output more than one proof oracle per round, however this doesn't add any power since two proof oracles of the same size may be viewed as a single (concatenated) oracle of twice the length.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{View}_{\\langle\\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle}(\\mathcal{V})</span> (as distributions over the randomness of <span class="math">\\mathcal{P}</span> and random public-coin challenges).</p>

    <p class="text-gray-300">We note that the separation into two maps <span class="math">coins_{i}\\xmapsto{\\mathcal{Q}_{0}(i,\\cdot)}\\mathbf{\\Sigma}_{i}\\xmapsto{\\mathcal{Q}_{1}(i,\\cdot)}\\mathbf{Q}_{i}</span> subtly relaxes the definition of Bitansky et al., which instead requires that <span class="math">\\mathbf{Q}_{i}</span> be determined via <span class="math">\\vec{p}_{1},\\ldots,\\vec{p}_{\\ell}</span> evaluated at a random <span class="math">\\boldsymbol{r}\\xleftarrow{\\S}\\mathbb{F}^{\\mu_{i}}</span>. The Bitansky et al. definition corresponds to the special case that <span class="math">\\mathcal{Q}_{0}(i,\\cdot)</span> samples a random element of <span class="math">\\mathbb{F}^{\\mu_{i}}</span> based on <span class="math">coins_{i}</span>. The point is that <span class="math">\\mathcal{Q}_{0}</span> can also do other computations that do not necessarily sample <span class="math">\\boldsymbol{r}</span> uniformly, or even output a matrix rather than a vector. The separation into two steps is only meaningful when <span class="math">\\mu_{i}</span> is smaller than <span class="math">m_{i}</span>. The significance to SNARK constructions is that the query can be represented compactly as <span class="math">\\mathbf{\\Sigma}_{i}</span>, and the prover will take advantage of the algebraic map <span class="math">\\mathcal{Q}_{1}(i,\\cdot)</span> to demonstrate that <span class="math">\\mathbf{\\Sigma}_{i}</span> was expanded correctly into <span class="math">\\mathbf{Q}_{i}</span> and applied to the proof oracle <span class="math">\\pi_{i}</span>. We first present a standalone definition of Polynomial IOPs, and then explain how it is a special case of Algebraic Linear IOPs.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Definition 5 (Public coin Polynomial IOP).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a binary relation and <span class="math">\\mathbb{F}</span> a finite field. Let <span class="math">\\mathbf{X}=(X_{1},\\ldots,X_{\\mu})</span> be a vector of <span class="math">\\mu</span> indeterminates. A <span class="math">(\\mu,d)</span> Polynomial IOP for <span class="math">\\mathcal{R}</span> over <span class="math">\\mathbb{F}</span> with soundness error <span class="math">\\epsilon</span> and knowledge error <span class="math">\\delta</span> consists of two stateful PPT algorithms, the <em>prover</em> <span class="math">\\mathcal{P}</span>, and the <em>verifier</em> <span class="math">\\mathcal{V}</span>, that satisfy the following requirements:</p>

    <p class="text-gray-300">Protocol syntax. For each <span class="math">i</span>th round there is a prover state <span class="math">\\mathfrak{st}_{i}^{\\mathcal{P}}</span> and a verifier state <span class="math">\\mathfrak{st}_{i}^{\\mathcal{V}}</span>. For any common input <span class="math">x</span> and <span class="math">\\mathcal{R}</span> witness <span class="math">w</span>, at round <span class="math">0</span> the states are <span class="math">\\mathfrak{st}_{0}^{\\mathcal{P}}=(x,w)</span> and <span class="math">\\mathfrak{st}_{0}^{\\mathcal{V}}=x</span>. In the <span class="math">i</span>th round (starting at <span class="math">i=1</span>) the prover outputs a single proof oracle <span class="math">\\mathcal{P}(\\mathfrak{st}_{i-1}^{\\mathcal{P}})\\to\\pi_{i}</span>, which is a polynomial <span class="math">\\pi_{i}(\\mathbf{X})\\in\\mathbb{F}[\\mathbf{X}]</span>. The verifier deterministically computes the query matrix <span class="math">\\mathbf{\\Sigma}_{i}\\in\\mathbb{F}^{\\mu\\times\\ell}</span> from its state and a string of public random bits <span class="math">coins_{i}\\xleftarrow{\\S}\\{0,1\\}^{*}</span>, i.e, <span class="math">\\mathcal{V}(\\mathfrak{st}_{i-1}^{\\mathcal{V}},coins_{i})\\to\\mathbf{\\Sigma}_{i}</span>. This query matrix is interpreted as a list of <span class="math">\\ell</span> points in <span class="math">\\mathbb{F}^{\\mu}</span> denoted <span class="math">(\\boldsymbol{\\sigma}_{i,1},\\ldots,\\boldsymbol{\\sigma}_{i,\\ell})</span>. The oracle <span class="math">\\pi_{i}</span> is queried on all points in this list, producing the response vector <span class="math">(\\pi_{i}(\\boldsymbol{\\sigma}_{i,1}),\\ldots,\\pi_{\\ell}(\\boldsymbol{\\sigma}_{i,\\ell}))=\\mathbf{a}_{i}\\in\\mathbb{F}^{1\\times\\ell}</span>. The updated prover state is <span class="math">\\mathfrak{st}_{i}^{\\mathcal{P}}\\leftarrow(\\mathfrak{st}_{i-1}^{\\mathcal{P}},\\mathbf{\\Sigma}_{i})</span> and verifier state is <span class="math">\\mathfrak{st}_{i}^{\\mathcal{V}}\\leftarrow(\\mathfrak{st}_{i-1}^{\\mathcal{V}},\\mathbf{\\Sigma}_{i},\\mathbf{a}_{i})</span>. Finally, <span class="math">\\mathcal{V}(\\mathfrak{st}_{i}^{\\mathcal{V}})</span> returns <span class="math">1</span> or <span class="math">0</span>.</p>

    <p class="text-gray-300">(<em>Extensions: multiple and prior round oracles; various arity.</em> The syntax can be naturally extended such that multiple oracles are sent in the <span class="math">i</span>th round; that the verifier may query oracles sent in the <span class="math">i</span>th round or earlier; or that some of the oracles are polynomials in fewer variables than <span class="math">\\mu</span>.)</p>

    <p class="text-gray-300">Argument of Knowledge. As a proof system, <span class="math">(\\mathcal{P},\\mathcal{V})</span> satisfies perfect completeness, soundness with respect to the relation <span class="math">\\mathcal{R}</span> and with soundness error <span class="math">\\epsilon</span>, and witness-extended emulation with respect <span class="math">\\mathcal{R}</span> with knowledge error <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">Furthermore, a Polynomial IOP is stateless if for each <span class="math">i\\in[t]</span>, <span class="math">\\mathcal{V}(\\mathfrak{st}_{i-1}^{\\mathcal{V}},coins_{i})=\\mathcal{V}(i,coins_{i})</span>.</p>

    <p class="text-gray-300">Polynomial IOPs as a subclass of Algebraic Linear IOPs In a Polynomial IOP, the two-step map <span class="math">coins_{i}\\xmapsto{\\mathcal{V}(i,\\cdot)}\\left(\\boldsymbol{\\sigma}_{i,1},\\ldots,\\boldsymbol{\\sigma}_{i,\\ell}\\right)\\xmapsto{\\mathbf{M}}\\left(\\mathbf{q}_{i,1},\\ldots,\\mathbf{q}_{i,\\ell}\\right)</span> is a special case of the two-step map <span class="math">coins_{i}\\xmapsto{\\mathcal{Q}_{0}(i,\\cdot)}\\mathbf{\\Sigma}_{i}\\xmapsto{\\mathcal{Q}_{1}(i,\\cdot)}\\mathbf{Q}_{i}</span> in an algebraic linear IOP. Here <span class="math">\\mathbf{M}:\\mathbb{F}^{\\mu}\\to\\mathbb{F}^{m}</span> represents the vector of monomials of degree at most <span class="math">d</span> (in some canonical order) and the map associated with <span class="math">\\mathbf{M}</span> is evaluation. Note that there are <span class="math">m=\\binom{\\mu+d}{d}</span> such monomials. Furthermore, for any <span class="math">\\mathbf{q}_{i,k}</span>, the inner product <span class="math">\\boldsymbol{\\pi}_{i}^{\\mathrm{T}}\\mathbf{q}_{i,k}</span> corresponds to the evaluation at <span class="math">\\boldsymbol{\\sigma}_{i,k}</span> of the polynomial <span class="math">\\pi_{i}(\\mathbf{X})\\in\\mathbb{F}[\\mathbf{X}]</span>, whose coefficient vector (in the same canonical monomial order) is equal to <span class="math">\\boldsymbol{\\pi}_{i}</span>.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">5.2 Polynomial IOP Reductions</h3>

    <p class="text-gray-300">In this section we show that one can construct any algebraic linear IOP from a (multivariate) Polynomial IOP. This construction rests on two tools for univariate Polynomial IOPs that we cover first:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coefficient queries. The verifier verifies that an indicated coefficient of a polynomial oracle has a given value.</li>

      <li>Inner products. The verifier verifies that the inner product of the coefficient vectors of two polynomial oracles equals a given value.</li>

    </ul>

    <p class="text-gray-300">5.2.1 Coefficient queries</p>

    <p class="text-gray-300">The following is a <span class="math">(1,d)</span>-Polynomial IOP for the statement <span class="math">f_{i}=a</span> with respect to a polynomial <span class="math">f(X)=\\sum_{j=0}^{d}f_{j}X^{j}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Prover</em>: Split <span class="math">f(X)</span> about the term <span class="math">X^{i}</span> into <span class="math">f_{L}(X)</span> (of degree at most <span class="math">i-1</span>) and <span class="math">f_{R}(X)</span> (of degree at most <span class="math">d-i-1</span>) such that <span class="math">f(X)=f_{L}(X)+aX^{i}+X^{i+1}f_{R}(X)</span>. Send polynomials <span class="math">f_{L}(X)</span> and <span class="math">f_{R}(X)</span>.</li>

      <li><em>Verifier</em>: Sample uniform random <span class="math">\\beta\\overset{\\</span>}{\\leftarrow}\\mathbb{F}_{p}<span class="math"> and query for </span>y_{L}\\leftarrow f_{L}(\\beta)<span class="math">, </span>y_{R}\\leftarrow f_{R}(\\beta)<span class="math">, and </span>y\\leftarrow f(\\beta)<span class="math">. Check that </span>y=y_{L}+a\\beta^{i}+\\beta^{i+1}y_{R}\\bmod p<span class="math"> and return </span>0<span class="math"> (abort) if not. Otherwise output </span>1$ (accept).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier only accepts given proof oracles for polynomials <span class="math">f</span>, <span class="math">f_{L}</span>, and <span class="math">f_{R}</span> in <span class="math">\\mathbb{F}_{p}[X]</span> of degree at most <span class="math">d</span>, <span class="math">i-1</span> and <span class="math">d-i-1</span> such that <span class="math">f(\\beta)=f_{L}(\\beta)+a\\beta^{i}+\\beta^{i+1}f_{R}(\\beta)</span> for random <span class="math">\\beta\\overset{\\</span>}{\\leftarrow}\\mathbb{F}<span class="math">. Via the Schwartz-Zippel lemma, if </span>f(X)\\neq f_{L}(X)+aX^{i}+X^{i+1}f_{R}(X)<span class="math"> then the verifier would accept with probability at most </span>d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, because the highest degree term in this equation is </span>X^{i+1}f_{R}(X)<span class="math"> and its degree is at most </span>d<span class="math">. This implies that </span>a<span class="math"> is the </span>i<span class="math">th coefficient of </span>f$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that this description assumes that the verifier is assured that the proof oracles for <span class="math">f_{L}</span> and <span class="math">f_{R}</span> have degrees <span class="math">i-1</span> and <span class="math">d-i-1</span>, respectively. If no such assurance is given, then <span class="math">f_{L}(X)</span> should be shifted by <span class="math">d-i+1</span> digits. In particular, the proof oracle should <span class="math">f_{L}^{<em>}(X)=X^{d-i+1}f_{L}(X)</span>, in which case the verifier obtains the evaluation <span class="math">y_{L}^{</em>}=y_{L}\\beta^{d-i+1}</span> along with an assurance that <span class="math">f_{L}^{<em>}(X)</span> has degree at most <span class="math">d</span>. The verifier then tests <span class="math">y=(\\beta^{d-i+1})^{-1}y_{L}^{</em>}+a\\beta^{i}+\\beta^{i+1}y_{R}</span>. This test admits false positives with probability at most $2d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">5.2.2 Inner product</h4>

    <p class="text-gray-300">The following is an IOP where the prover first sends two degree <span class="math">d</span> univariate polynomial oracles <span class="math">f,g</span> and proves to the verifier that <span class="math">\\langle\\mathbf{f},\\mathbf{g}^{r}\\rangle=a</span> where <span class="math">\\mathbf{f},\\mathbf{g}</span> denote the coefficient vectors of <span class="math">f,g</span> respectively and <span class="math">\\mathbf{g}^{r}</span> is the reverse of <span class="math">\\mathbf{g}</span>. This argument is sufficient for our application to transforming algebraic linear IOPs into Polynomial IOPs. It is also possible to prove the inner product <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle</span> by combining this IOP together with another one that probes the relation <span class="math">g(X)=X^{d}g^{r}(X^{-1})</span> in a random point <span class="math">z\\overset{\\</span>}{\\leftarrow}\\mathbb{F}\\backslash\\{0\\}<span class="math">, and thereby shows that </span>\\mathbf{g}<span class="math"> and </span>\\mathbf{g}^{r}$ have the same coefficients only reversed. We omit this more elaborate construction as it is not needed for any of our applications.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Prover</em>: Sends proof oracles for <span class="math">f(X)</span>, <span class="math">g(X)</span>, and the degree <span class="math">2d</span> polynomial product <span class="math">h(X)=f(X)\\cdot g(X)</span> to the verifier.</li>

      <li><em>Verifier</em>: Chooses <span class="math">\\beta\\overset{\\</span>}{\\leftarrow}\\mathbb{F}<span class="math"> and queries for </span>y_{1}\\leftarrow f(\\beta)<span class="math">, </span>y_{2}\\leftarrow g(\\beta)<span class="math">, and </span>y_{3}\\leftarrow h(\\beta)<span class="math">. Check that </span>y_{1}y_{2}=y_{3}<span class="math"> and return </span>0$ (abort) if not.</li>

      <li>Prover and verifier engage in the <span class="math">1</span> round IOP (Section 5.2.1) for proving that the <span class="math">d</span>th coefficient (<em>i.e.</em>, on term <span class="math">X^{d}</span>) of <span class="math">h(X)</span> is equal to <span class="math">a</span>. (Note that the proof oracles for this subprotocol can all be sent in the first round, so this does not add an additional round).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Via Schwartz-Zippel, if <span class="math">h(X)\\neq f(X)\\cdot g(X)</span> then the verifier’s check <span class="math">y_{1}y_{2}=y_{3}</span> at the random point <span class="math">\\beta</span> fails with probability at least $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2d)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Observe that the middle coefficient of </span>h(X)<span class="math"> is equal to </span>\\sum_{i=0}^{d}f_{i}g_{d-i}=\\sum_{i=0}^{d}f_{i}g_{i}^{r}=\\langle\\mathbf{f},\\mathbf{g}^{r}\\rangle=a$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">Reducing algebraic linear IOPs to Polynomial IOPs</h4>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Any public-coin <span class="math">t</span>-round stateless algebraic linear IOP can be implemented with a <span class="math">t+1</span>-round Polynomial IOP with preprocessing. Suppose the original <span class="math">\\ell</span>-query IOP is <span class="math">(\\mu,d)</span> algebraic with query length <span class="math">(m_{1},...,m_{t})</span> then the resulting Polynomial IOP has for each <span class="math">i\\in[t]</span>: <span class="math">2\\ell</span> degree <span class="math">m_{i}</span> univariate polynomial oracles, <span class="math">\\ell</span> pre-processed multivariate oracles of degree <span class="math">d</span> and <span class="math">\\mu+1</span> variables, <span class="math">\\ell</span> degree <span class="math">2m_{i}</span> univariate polynomial oracles and <span class="math">2\\ell</span> degree <span class="math">2m_{i}</span> univariate polynomial oracles. There is exactly one query to each oracle on a random point in <span class="math">\\mathbb{F}</span>. The soundness loss of the transformation is <span class="math">\\mathsf{negl}(\\lambda)</span> for a sufficiently large field (<em>i.e.</em>, whose cardinality is exponential in <span class="math">\\lambda</span>).</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">By definition of a <span class="math">(\\mu, d)</span> algebraic linear IOP, in each <span class="math">i</span>th round of the IOP there are <span class="math">\\ell</span> query generation functions <span class="math">\\vec{p}_{i,1}, \\ldots, \\vec{p}_{i,\\ell}: \\mathbb{F}^{\\mu} \\to \\mathbb{F}^{m_i}</span>, where each <span class="math">\\vec{p}_{i,k}</span> is a vector whose <span class="math">j</span>th component is a <span class="math">\\mu</span>-variate degree-<span class="math">d</span> polynomial <span class="math">p_{i,k,j}</span>. These polynomials are applied to a seed matrix <span class="math">\\sigma_{i,k} \\in \\mathbb{F}^{\\mu}</span> (which is identifiable with or derived from the verifier's <span class="math">i</span>th round public-coin randomness <span class="math">\\text{coins}_i</span>); this evaluation produces <span class="math">\\vec{p}_{i,k}(\\sigma_{i,k}) = \\mathbf{q}_{i,k} \\in \\mathbb{F}^{m_i}</span> for all <span class="math">k \\in [\\ell]</span>. The vectors <span class="math">\\mathbf{q}_{i,k}</span> are the columns of the query matrix <span class="math">\\mathbf{Q}_i \\in \\mathbb{F}^{m_i \\times \\ell}</span>.</p>

    <h2 id="sec-49" class="text-2xl font-bold">Preprocessed oracles</h2>

    <p class="text-gray-300">For each round <span class="math">i</span> of the original algebraic linear IOP, the prover and verifier preprocess <span class="math">(\\mu + 1)</span>-variate degree-<span class="math">d</span> polynomial oracles. For each <span class="math">k \\in [\\ell]</span>, the vector of polynomials <span class="math">\\vec{p}_{i,k} = (p_{i,k,1}, \\ldots, p_{i,k,m_i}) \\in (\\mathbb{F}[\\mathbf{X}])^{m_i}</span> with <span class="math">\\mathbf{X} = (X_1, \\ldots, X_\\mu)</span> is encoded as a single polynomial in <span class="math">\\mu + 1</span> variables as follows. Introduce a new indeterminate <span class="math">Z</span>, and then define <span class="math">\\tilde{P}_{i,k}(\\mathbf{X}, Z) := \\sum_{j=1}^{m_i} p_{i,k,j}(\\mathbf{X}) Z^j \\in \\mathbb{F}[\\mathbf{X}, Z]</span>. The prover and verifier establish the oracle <span class="math">\\tilde{P}_{i,k}</span>, meaning that the verifier queries this oracle on enough points to be reassured that it is correct everywhere.</p>

    <h2 id="sec-50" class="text-2xl font-bold">The transformed IOP</h2>

    <p class="text-gray-300">The original algebraic linear IOP is modified as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wherever the original IOP prover sends an oracle <span class="math">\\pi_i</span> of length <span class="math">m_i</span>, the new prover sends a degree <span class="math">m_i - 1</span> univariate polynomial oracle <span class="math">f_{\\pi_i}</span> whose coefficient vector is the reverse of <span class="math">\\pi_i</span>.</li>

      <li>Wherever the original IOP verifier makes <span class="math">\\ell</span> queries within a round to a particular proof oracle <span class="math">\\pi_i</span>, where queries are defined by query matrix <span class="math">\\mathbf{Q}_i \\in \\mathbb{F}^{m_i \\times \\ell}</span>, consisting of column query vectors <span class="math">(\\mathbf{q}_{i,1}, \\ldots, \\mathbf{q}_{i,\\ell})</span>, the new prover and verifier engage in the following interactive subprotocol for each <span class="math">k \\in [\\ell]</span> in order to replace the <span class="math">k</span>th linear query <span class="math">\\langle \\pi_i, \\mathbf{q}_{i,k} \\rangle</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier: Run the original IOP verifier to get the public coin seed matrix <span class="math">\\Sigma_i</span> and send it to the prover.</li>

      <li>Prover: Derive the query matrix <span class="math">\\mathbf{Q}_i</span> from <span class="math">\\Sigma_i</span> using the polynomials <span class="math">\\vec{p}_{i,1}, \\ldots, \\vec{p}_{i,\\ell}</span>. Send an oracle for the polynomial <span class="math">F_{i,k}</span> whose coefficient vector is <span class="math">\\mathbf{q}_{i,k}</span>.</li>

      <li>Verifier: Sample uniform random <span class="math">\\beta \\stackrel{\\mathrm{k}}{\\leftarrow} \\mathbb{F}</span> and query both <span class="math">F_{i,k}</span> and <span class="math">\\tilde{P}_{i,k}</span> (the <span class="math">k</span>th preprocessed oracle for round <span class="math">i</span>) at <span class="math">\\beta</span> in order to check that <span class="math">F_{i,k}(\\beta) = \\tilde{P}_{i,k}(\\sigma_{i,k}, \\beta)</span>. If the check fails, abort and output 0.</li>

      <li>Prover: Compute <span class="math">a_{i,k} = \\langle \\pi, \\mathbf{q}_{i,k} \\rangle</span> and send <span class="math">a_{i,k}</span> to the verifier.</li>

      <li>The prover and verifier run the inner product Polynomial IOP from Section 5.2.2 on the oracles <span class="math">F_{i,k}</span> and <span class="math">f_{\\pi_i}</span> to convince the verifier that <span class="math">a_{i,k} = \\langle \\mathbf{q}_{i,k}, \\pi_i \\rangle</span>. If the inner product subprotocol fails the verifier aborts and outputs 0.</li>

    </ul>

    <p class="text-gray-300">If all substeps succeed, then the verifier obtains correct output of each oracle query; in other words, the responses are identical in the new and original IOP. These outputs are passed to the original verifier decision algorithm, which outputs 0 or 1.</p>

    <h2 id="sec-51" class="text-2xl font-bold">Soundness and completeness</h2>

    <p class="text-gray-300">If the prover is honest then the verifier receives the same exact query-response pairs <span class="math">(\\mathbf{q}_{i,k}, a_{i,k})</span> as the original IOP verifier and runs the same decision algorithm, and therefore the protocol inherits the completeness of the original IOP. As for soundness, an adversary who sends a polynomial oracle <span class="math">F_{i,k}^{<em>}</span> whose coefficient vector is not <span class="math">\\mathbf{q}_{i,k}</span>, fails with overwhelming likelihood. To see this, note that since <span class="math">\\mathbf{q}_{i,k} = \\vec{p}_{i,k}(\\sigma_k)</span>, the check that <span class="math">F_{i,k}(\\beta) = \\tilde{P}_{i,k}(\\sigma_{i,k}, \\beta)</span> at a random <span class="math">\\beta</span> fails with overwhelming probability by the Schwartz-Zippel lemma. Similarly, an adversary who provides an incorrect <span class="math">a_{i,k}^{</em>} \\neq \\langle \\pi_i, \\mathbf{q}_{i,k} \\rangle</span> fails the inner-product IOP with overwhelming probability. Therefore, if the original IOP soundness error is <span class="math">\\epsilon</span> then by a union bound the new soundness error is <span class="math">\\epsilon + \\mathrm{negl}(\\lambda)</span>. A similar composition argument follows for knowledge extraction.</p>

    <h2 id="sec-52" class="text-2xl font-bold">Round complexity</h2>

    <p class="text-gray-300">The prover and verifier can first simulate the <span class="math">t</span>-round original IOP on the verifier's public-coin challenges, proceeding as if all queries were answered honestly. Wherever the original IOP prover would send an oracle for the vector <span class="math">\\pi_i</span> the prover sends <span class="math">f_{\\pi_i}</span>. Then, after the verifier has sent its final public coin challenge from the original IOP, there is one more round in which the prover sends all <span class="math">F_{i,k}</span> for the <span class="math">k</span>th query vector in the <span class="math">i</span>th round and all the purported answers <span class="math">a_{i,k}</span> to the <span class="math">k</span>th query in the <span class="math">i</span>th round. The prover and verifier engage in the protocol above to prove that these answers are correct. The</p>

    <p class="text-gray-300">inner product subprotocol for each <span class="math">F_{i,k}</span> with <span class="math">f_{\\pi_{i}}</span> can be done in parallel with the check that <span class="math">F_{i,k}(\\beta)=\\tilde{P}_{i,k}(\\bm{\\sigma}_{i,k},\\beta)</span>. Therefore, there is only one extra round. ∎</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">5.3 Compiling Polynomial IOPs</h3>

    <p class="text-gray-300">Let <span class="math">\\Gamma=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> be a multivariate polynomial commitment scheme. Given any <span class="math">t</span>-round Polynomial IOP for <span class="math">\\mathcal{R}</span> over <span class="math">\\mathbb{F}</span>, we construct an interactive protocol <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> as follows. For clarity in our explanation, <span class="math">\\Pi</span> consists of <em><span class="math">t</span> outer rounds</em> corresponding to the original IOP rounds and <em>subrounds</em> where subprotocols may add additional rounds of interaction between outer rounds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}</span>: <span class="math">\\mathrm{Run}\\ \\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span></li>

      <li>In any round where the IOP prover sends a <span class="math">(\\mu,d)</span> polynomial proof oracle <span class="math">\\bm{\\pi}:\\mathbb{F}^{\\mu}\\to\\mathbb{F}</span>, in the corresponding <em>outer round</em> of <span class="math">\\Pi</span>, <span class="math">\\mathcal{P}</span> sends the commitment <span class="math">c_{\\bm{\\pi}}\\leftarrow\\mathsf{Commit}(\\mathsf{pp};\\bm{\\pi})</span></li>

      <li>In any round where the IOP verifier makes an <em>evaluation</em> query <span class="math">\\mathbf{z}</span> to a <span class="math">(\\mu,d)</span> polynomial proof oracle <span class="math">\\bm{\\pi}</span>, in the corresponding <em>outer round</em> of <span class="math">\\Pi</span>, insert an interactive execution of <span class="math">\\mathsf{Eval}(\\mathsf{pp},c_{\\pi},\\mathbf{z},y,\\mu,d;\\bm{\\pi})</span> between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>, where <span class="math">\\bm{\\pi}(\\mathbf{z})=y</span>.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">\\mathcal{V}</span> does not abort in any of these subprotocols, then it receives a simulated IOP transcript of oracle queries and responses. It runs the IOP verifier decision algorithm on this transcript and outputs the result.</p>

    <h5 id="sec-54" class="text-base font-semibold mt-4">Optimization: delayed evaluation</h5>

    <p class="text-gray-300">As an optimization to reduce round-complexity and enable batching techniques, all invocations of <span class="math">\\mathsf{Eval}</span> can be delayed until the final round, and heuristically could be run in parallel. Delaying the evaluations until the final round does not affect our analysis. However, our analysis does not consider parallel execution of the <span class="math">\\mathsf{Eval}</span> subprotocols. We assume the protocol transcript contains an isolated copy of each <span class="math">\\mathsf{Eval}</span> instance and does not interleave messages or re-use randomness.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">If the polynomial commitment scheme <span class="math">\\Gamma</span> has witness-extended emulation, and if the <span class="math">t</span>-round Polynomial IOP for <span class="math">\\mathcal{R}</span> has negligible knowledge error, then <span class="math">\\Pi</span> is a public-coin interactive argument for <span class="math">\\mathcal{R}</span> that has witness-extended emulation. The compilation also preserves HVZK if <span class="math">\\Gamma</span> is hiding and <span class="math">\\mathsf{Eval}</span> is HVZK.</p>

    <p class="text-gray-300">The full proof is provided in Appendix E. HVZK is shown by a straightforward composition of the simulators for <span class="math">\\mathsf{Eval}</span> and the original IOP simulator. The emulator <span class="math">E</span> works as follows. Given the IP adversary <span class="math">P^{\\prime}</span>, <span class="math">E</span> simulates an IOP adversary <span class="math">P^{\\prime}_{O}</span> by using the <span class="math">\\mathsf{Eval}</span> emulator <span class="math">E_{\\mathsf{Eval}}</span> to extract proof oracles (<em>i.e.</em>, polynomials) from any commitment that <span class="math">P^{\\prime}</span> sends and subsequently opens at an evaluation point. We argue that <span class="math">P^{\\prime}_{O}</span> is successful whenever <span class="math">P^{\\prime}</span> is successful, with negligible loss. (The only events that cause <span class="math">P^{\\prime}_{O}</span> to fail when <span class="math">P^{\\prime}</span> succeeds is if <span class="math">E_{\\mathsf{Eval}}</span> fails to extract from a successful <span class="math">\\mathsf{Eval}</span> or <span class="math">P^{\\prime}</span> succesfully opens a commitment inconsistently with an extracted polynomial). <span class="math">E</span> then runs the IOP knowledge extractor with <span class="math">P^{\\prime}_{O}</span> to extract a witness for the input.</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">5.4 Concrete Instantiations</h3>

    <p class="text-gray-300">We consider examples of Polynomial IOPs to which this compiler can be applied: <span class="math">\\mathsf{STARK}</span> <em>[x1]</em>; <span class="math">\\mathsf{Sonic}</span> <em>[x12]</em> and its improvements <span class="math">\\mathsf{PLONK}</span> <em>[x10]</em> and <span class="math">\\mathsf{Marlin}</span> <em>[CHM^{+}19]</em>; <span class="math">\\mathsf{Spartan}</span> <em>[x23]</em>, and the popular QAP of Gennaro <em>et al.</em> <em>[x11]</em>. For the purpose of the following discussion, we refer to the complexity of an NP relation <span class="math">\\mathcal{R}</span> in various forms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{R}</span> has <em>arithmetic complexity</em> <span class="math">n</span> if the function computing <span class="math">\\mathcal{R}(x,w)</span> can be expressed as 2-fan-in arithmetic circuit with a total of <span class="math">n</span> gates.</li>

      <li><span class="math">\\mathcal{R}</span> has <em>multiplicative complexity</em> <span class="math">n</span> if the function computing <span class="math">\\mathcal{R}(x,w)</span> can be expressed an arithmetic circuit with a total of <span class="math">n</span> multiplication gates, where each multiplication gate has 2 inputs.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{R}</span> has <em>R1CS complexity</em> <span class="math">n</span> if the function computing <span class="math">\\mathcal{R}(x,w)</span> can be expressed as an R1CS instance <span class="math">(A,B,C,v,w)</span> where <span class="math">A,B,C\\in\\mathbb{F}^{m\\times(\\ell+1)}</span>, <span class="math">(v,w)\\in\\mathbb{F}^{\\ell}</span>, and <span class="math">n</span> is the maximum number of non-zero entries in either <span class="math">A</span>, <span class="math">B</span>, or <span class="math">C</span>.</li>

    </ul>

    <p class="text-gray-300">Theorem 5 provides the main theoretical result of this work, tying together the new DARK polynomial commitment scheme (Theorem 1), the compilation of HVZK Polynomial IOPs into zk-SNARKs with preprocessing using polynomial commitments (Theorem 4), and a concrete univariate Polynomial IOP introduced in Sonic <em>[x11]</em> (Theorem 5.4.1) or follow-up works.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">5.4.1 Sonic</h4>

    <p class="text-gray-300">Sonic is a zk-SNARK system that has a universal trusted setup, which produces a Structured Reference String (SRS) of <span class="math">n</span> group elements that can be used to prove any statement represented as an arithmetic circuit with at most <span class="math">n</span> gates. The SRS can also be updated without re-doing the initial setup, for instance, to enable proving larger circuits, or to increase the distribution of trust. The result in Sonic was not presented using the language of IOPs. Furthermore, the result also relied on a special construction of polynomial commitments (a modification of Kate <em>et al.</em> <em>[x10]</em>) that forces the prover to commit to a Laurent polynomial with no constant term. Given our generic reduction from coefficient queries to evaluation queries (Section 5.2.1), we re-characterize the main theorem of Sonic as follows:</p>

    <p class="text-gray-300"><em>[x11]</em>’s Theorem (Sonic Bivariate). <em>There exists a 2-round HVZK Polynomial IOP with preprocessing for any NP relation <span class="math">\\mathcal{R}</span> (with multiplicative complexity <span class="math">n</span>) that makes 1 query to a bivariate polynomial oracle of degree <span class="math">n</span> on each variable, and 6 queries to degree <span class="math">n</span> univariate polynomial oracles. The preprocessing verifier does <span class="math">O(n)</span> work to check the single bivariate oracle.</em></p>

    <p class="text-gray-300">The number of univariate queries increased from the original 3 in Sonic (with special commitments) to 6 with our generic coefficient query technique. If we were to compile the bivariate query directly using our multivariate commitment scheme this would result in <span class="math">O(n^{2})</span> prover time (a bivariate polynomial with degree <span class="math">n</span> on each variable is converted to a univariate polynomial of degree roughly <span class="math">n^{2}</span>). However, Sonic also provides a way to replace the bivariate polynomial with several degree <span class="math">n</span> univariate polynomials and more rounds of communication.</p>

    <p class="text-gray-300"><em>[x11]</em>’s Theorem (Sonic Univariate). <em>There is a 5-round HVZK Polynomial IOP with preprocessing for any NP relation <span class="math">\\mathcal{R}</span> (with multiplicative complexity <span class="math">n</span>) that makes <span class="math">39</span> queries overall to <span class="math">27</span> univariate degree <span class="math">2n</span> polynomial oracles. The total number of distinct query points is <span class="math">12</span>. The preprocessing verifier does <span class="math">O(n)</span> work to check <span class="math">12</span> of the univariate degree <span class="math">2n</span> polynomials.</em></p>

    <p class="text-gray-300">The recent proof systems PLONK and Marlin improve on Sonic by constructing a different Polynomial IOP. They achieve the following:</p>

    <p class="text-gray-300"><em>[x9]</em>’s Theorem (PLONK). <em>There is a 3-round HVZK Polynomial IOP with preprocessing for any NP relation <span class="math">\\mathcal{R}</span> (with arithmetic complexity <span class="math">n</span>) that makes <span class="math">12</span> queries overall to <span class="math">12</span> univariate degree <span class="math">n</span> polynomial oracles. The total number of distinct query points is <span class="math">2</span>. The preprocessing verifier does <span class="math">O(n)</span> work to check <span class="math">7</span> of the univariate degree <span class="math">n</span> polynomials.</em></p>

    <p class="text-gray-300"><em>[CHM^{+}19]</em>’s Theorem (Marlin). <em>There exists a 4-round HVZK Polynomial IOP with preprocessing for any NP relation <span class="math">\\mathcal{R}</span> (with R1CS complexity <span class="math">n</span>) that makes <span class="math">20</span> queries at <span class="math">3</span> distinct query points to <span class="math">19</span> univariate degree polynomial oracles of maximum degree <span class="math">6n</span>. The preprocessing verifier does <span class="math">O(n)</span> work to check <span class="math">9</span> univariate degree <span class="math">n</span> polynomials.</em></p>

    <p class="text-gray-300">Combining the Sonic Polynomial IOP with the new transparent polynomial compiler of Section 4 gives the following result. Similar results are obtained by using PLONK or Marlin instead.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Theorem 5 (New Transparent zk-SNARK).</h6>

    <p class="text-gray-300">There exists an <span class="math">O(\\log n)</span>-round public-coin interactive argument of knowledge for any NP relation of arithmetic complexity <span class="math">n</span> that has <span class="math">O(\\log n)</span> communication, <span class="math">O(\\log n)</span> “online” verification, quasilinear prover time, and a preprocessing step that is verifiable in quasilinear time. The argument of knowledge has witness-extended emulation assuming it is instantiated with a group <span class="math">\\mathbb{G}</span> for which the Strong RSA Assumption, and the Adaptive Root Assumption hold.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We apply the univariate polynomial commitment scheme from Section 4 to the 5-round Sonic Univariate Polynomial IOP. Denote this commitment scheme by <span class="math">\\Gamma=(\\textsf{Setup},\\textsf{Commit},\\textsf{Open},\\textsf{Eval})</span></p>

    <p class="text-gray-300">The preprocessing requires running Commit on 12 univariate degree <span class="math">n</span> polynomials, which involves a quasilinear number of group operations in the group of unknown order <span class="math">\\mathbb{G}</span> determined by Setup. The prover sends a constant number of proof oracles of degree <span class="math">2n</span> to the verifier, which also takes a quasilinear number of group operations. Finally, the 39 queries are replaced with at most 39 invocations of Eval, which adds <span class="math">O(\\log n)</span> rounds and has <span class="math">O(\\log n)</span> communication. By Theorem 1 (<span class="math">\\Gamma</span> has witness extended emulation) and Theorem 4, the compiled interactive argument has witness-extended emulation. ∎</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">5.4.2 STARK</h4>

    <p class="text-gray-300">The STARK proof system <em>[x1]</em> builds an IOP for uniform computations, specified by a program <span class="math">P</span> and timebound <span class="math">T</span> on the running time of <span class="math">P</span>. The IOP itself is then compiled into a concrete proof system using FRI <em>[x1]</em> and Merkle trees. The STARK IOP can be cast as a univariate Polynomial IOP.</p>

    <p class="text-gray-300">The IOP construction begins with an <em>algebraic intermediate representation</em> (AIR) of the program <span class="math">P</span>. We present a simplified version of the original STARK AIR language for the purpose of illustrating how to recast the STARK IOP as a Polynomial IOP. The original AIR is more complex for efficiency reasons.</p>

    <p class="text-gray-300">The AIR represents a computation as an algebraic execution trace of the program <span class="math">P</span> for <span class="math">T</span> timesteps. The AIR views the program as a system of <span class="math">n</span> registers and a transition function. At every timestep each register holds an element of the finite field <span class="math">\\mathbb{F}</span>. Given a vector <span class="math">\\mathbf{w}_{i}\\in\\mathbb{F}^{n}</span> representing the states of the registers at timestep <span class="math">i</span>, the transition function determines the vector <span class="math">\\mathbf{w}_{i+1}\\in\\mathbb{F}^{n}</span> representing the state of the registers at timestep <span class="math">i+1</span>. The AIR represents the transition function as a system of constraints given by a vector of <span class="math">2n</span>-variate polynomials <span class="math">\\bm{\\mathcal{P}}</span>, and furthermore specifies a vector <span class="math">\\bm{\\mathcal{B}}</span> of tuples <span class="math">([T],[n],\\mathbb{F})</span> representing “boundary conditions” of the form <span class="math">\\mathbf{w}_{i}[j]=\\alpha</span> for the value of the <span class="math">j</span>th register at timestep <span class="math">i</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 6.</h6>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{\\textsf{AIR}}</span> is the set of all instance-witness pairs <span class="math">((\\mathbb{F},T,n,\\bm{\\mathcal{P}},\\bm{\\mathcal{B}}),W)</span> satisfying the following description:</p>

    <p class="text-gray-300">Instance. An instance is a tuple <span class="math">(\\mathbb{F},T,n,\\bm{\\mathcal{P}},\\bm{\\mathcal{B}})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span> is a finite field.</li>

      <li><span class="math">T\\in\\mathbb{N}</span> is the number of time steps.</li>

      <li><span class="math">n</span> is the number of registers.</li>

      <li><span class="math">\\bm{\\mathcal{P}}:\\mathbb{F}^{2n}\\to\\mathbb{F}^{k}</span> is a polynomial vector function whose <span class="math">k</span> components <span class="math">(\\mathcal{P}_{1},...,\\mathcal{P}_{k})</span> are each <span class="math">2n</span>-variate polynomials of degree at most <span class="math">\\mathsf{d}</span> called the “state transition constraints”. On input <span class="math">\\mathbf{z}\\in\\mathbb{F}^{2n}</span>: <span class="math">\\bm{\\mathcal{P}}(\\mathbf{z})=(\\mathcal{P}_{1}(\\mathbf{z}),...,\\mathcal{P}_{k}(\\mathbf{z}))\\in\\mathbb{F}^{k}</span>.</li>

      <li><span class="math">\\bm{\\mathcal{B}}\\in([T]\\times[n]\\times\\mathbb{F})^{\\ell}</span> are <span class="math">\\ell</span> tuples, called the “boundary conditions”.</li>

    </ul>

    <p class="text-gray-300">Witness. A witness is a table <span class="math">W\\in\\mathbb{F}^{T\\times n}</span> where each row <span class="math">i\\in[T]</span> represents the full state of the system at time <span class="math">i</span>, and each column <span class="math">j\\in[n]</span> tracks the value of register <span class="math">j</span> across time. A witness <span class="math">W</span> is a valid witness for the instance <span class="math">x=(\\mathbb{F},T,n,\\bm{\\mathcal{P}},\\bm{\\mathcal{B}})</span> if and only if the following conditions are satisfied:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>State transition consistency: <span class="math">\\bm{\\mathcal{P}}(W[i,1],\\ldots,W[i,n],W[i+1,1],\\ldots,W[i+1,n])=\\mathbf{0}</span> for all <span class="math">i\\in[T-1]</span>.</li>

      <li>Boundary condition satisfaction: <span class="math">W[i,j]=\\alpha</span> for every tuple <span class="math">(i,j,\\alpha)\\in\\bm{\\mathcal{B}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The language <span class="math">\\mathcal{L}_{\\textsf{AIR}}</span> is defined as $\\mathcal{L}_{\\textsf{AIR}}=\\{x=(\\mathbb{F},T,n,\\bm{\\mathcal{P}},\\bm{\\mathcal{B}})\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\exists W\\,(x,W)\\in\\mathcal{R}_{\\textsf{AIR}}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>[x1]</em>’s Theorem (Stark). *There is a 2-round univariate Polynomial IOP for <span class="math">\\mathcal{R}_{\\textsf{AIR}}</span> with preprocessing that makes <span class="math">k+n+2</span> queries to <span class="math">n+2</span> polynomials of degree at most <span class="math">T</span>. The prover has complexity <span class="math">\\tilde{O}(nT)</span> and the verifier has complexity <span class="math">O(n\\log T)</span>. The preprocessing verifier does <span class="math">O(T)</span> work.</p>

    <p class="text-gray-300">STARK Polynomial IOP</p>

    <p class="text-gray-300">We sketch how this Polynomial IOP is constructed, omitting many details (see the STARK paper <em>[x1]</em> for further details).</p>

    <p class="text-gray-300">Let <span class="math">g</span> be a generator of <span class="math">\\mathbb{F}^{\\times}</span>. The preprocessing consists of computing the nonzero polynomial <span class="math">z(X)=\\prod_{i=1}^{T-1}(X-g^{i})</span> which satisfies <span class="math">z(g^{i})=z(g^{2})=\\cdots=z(g^{T-1})=0</span>. The online interaction is as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover computing the <span class="math">n</span> polynomials <span class="math">w_{j}(X)</span> of degree at most <span class="math">T-1</span> such that <span class="math">w_{j}(g^{i})=w[i,j]</span>, and sends <span class="math">n</span> polynomial oracles to the verifier, one for each <span class="math">w_{j}(X)</span>.</li>

      <li>The verifier sends a random weight vector <span class="math">\\bm{\\beta}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}^{\\&amp;}</span>.</li>

      <li>The prover computes <span class="math">f(X)=\\bm{\\beta}^{\\mathsf{T}}\\bm{\\mathcal{P}}(w_{1}(X),\\ldots,w_{n}(X),w_{1}(g\\cdot X),\\ldots,w_{n}(g\\cdot X))</span>. The prover sends <span class="math">q(X)=f(X)/z(X)</span> to the verifier.</li>

    </ol>

    <p class="text-gray-300">Note that for a valid witness, <span class="math">f(g^{1})=f(g^{2})=\\cdots=f(g^{T-1})=0</span>, so <span class="math">z(X)</span> divides <span class="math">f(X)</span>. Note further that <span class="math">q(X)</span> has degree at most <span class="math">\\mathsf{d}</span>. The verifier’s queries to the proof oracles it received from the prover are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all boundary constraints of the form <span class="math">(i,j,\\alpha)</span> the verifies queries for <span class="math">w_{j}(g^{i})</span>, and if <span class="math">w_{j}(g^{i})\\neq\\alpha</span> then the verifier aborts and rejects.</li>

      <li>For a random point <span class="math">h\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span>, the verifier queries for <span class="math">u_{j}\\leftarrow w_{j}(h)</span> and <span class="math">v_{j}\\leftarrow w_{j}(gh)</span> for all <span class="math">j\\in[n]</span>, as well as for <span class="math">q(h)</span> and <span class="math">z(h)</span>. Finally it checks that <span class="math">\\bm{\\beta}^{\\mathsf{T}}\\bm{\\mathcal{P}}(u_{1},\\ldots,u_{n},v_{1},\\ldots,v_{n})=q(h)\\cdot z(h)</span>, and if not it aborts and rejects.</li>

    </ul>

    <p class="text-gray-300">If <span class="math">g</span> instead can be chosen as an element of order <span class="math">T-1</span> in <span class="math">\\mathbb{F}</span>, then the preprocessing phase can be omitted. In this case <span class="math">z(X)=X^{T-1}-1</span> and it can be evaluated by the verifier locally in <span class="math">O(\\log T)</span> time.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">5.4.3 Spartan</h4>

    <p class="text-gray-300">Spartan <em>[x12]</em> transforms an arbitrary circuit satisfaction problem into a Polynomial IOP based on an arithmetization technique developed by Blumberg et al. <em>[x4]</em>, which improved on the classical techniques of Babai, Fortnow, and Lund <em>[x3]</em>. Specifically, satisfiability of a 2-fan-in arithmetic circuit on <span class="math">n</span> gates can be transformed into the expression:</p>

    <p class="text-gray-300"><span class="math">\\sum_{x,y,z\\in\\{0,1\\}^{\\log n}}G(x,y,z)=0</span> (1)</p>

    <p class="text-gray-300">for a multilinear polynomial <span class="math">G</span> on <span class="math">3\\log n</span> variables over <span class="math">\\mathbb{F}</span>. Furthermore, <span class="math">G</span> decomposes into the form:</p>

    <p class="text-gray-300"><span class="math">G(x,y,z)=A(x,y,z)F(x)+B(x,y,z)F(y)+C(x,y,z)F(y)F(z)</span></p>

    <p class="text-gray-300">where <span class="math">A,B,C</span>, and <span class="math">F</span> are all multilinear polynomials. The polynomials <span class="math">A,B,C</span> are derived from the arithmetic circuit defining the relation <span class="math">\\mathcal{R}</span> and are input-independent. <span class="math">F</span> is degree 1 with <span class="math">\\log n</span> variables and is derived from a particular <span class="math">(x,w)\\in\\mathcal{R}</span>. The classical LFKN sum-check protocol is applied in order to prove Expression 1 in a <span class="math">3\\log n</span> round Polynomial IOP, where the prover’s oracle consist of <span class="math">Z</span> and the low-degree polynomials sent in the sumcheck. Since the extra low-degree polynomials are constant size they can be read entirely by the verifier in constant time rather than via oracle access, and hence we ignore them in the total oracle count. The verifier must also evaluate <span class="math">A,B,C</span> locally, which come from the multilinear extension of the circuit. This can be done in <span class="math">O(\\log n)</span> time for certain circuits with a succinct representation. The main result in Spartan can be summarized in our framework as follows:</p>

    <p class="text-gray-300"><em>[x12]</em>’s Theorem (Spartan). There exists a <span class="math">3\\log n</span> round Polynomial IOP for any NP relation <span class="math">\\mathcal{R}</span> computed by any circuit with arithmetic complexity <span class="math">n</span>, which makes three queries to a <span class="math">\\log n</span>-linear polynomial oracle.</p>

    <p class="text-gray-300">Applying our multivariate compiler to the Spartan Polynomial IOP we obtain an <span class="math">O(\\log n)</span>-round public-coin interactive argument of knowledge for circuits size <span class="math">n</span>, where the verifier’s work is dependent on the succinctness of the circuit representation (i.e., the complexity of evaluating the multilinear extension of the circuit). The communication of our multi-linear PC is linear in the number of variables. With only three queries overall, the communication is just <span class="math">6\\log n</span> group elements and <span class="math">6\\log n</span> field elements.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.4.4 Quadratic Arithmetic Programs</p>

    <p class="text-gray-300">Quadratic Arithmetic Programs (QAPs) can be expressed as linear PCPs <em>[BCI^{+}13, BCG^{+}13]</em>. We review here how to express QAPs as a one round public-coin <span class="math">(1,n)</span> algebraic IOP. (This captures the satisfiability of any circuit with multiplicative complexity <span class="math">n</span>, which is first translated to a system of quadratic equations over degree <span class="math">n</span> polynomials.) Each linear query is computed by a vector of degree <span class="math">n</span> univariate polynomials evaluated at a random point chosen by the public-coin verifier.</p>

    <p class="text-gray-300">For illustration, we will use the description of the QAP language due to Ben-Sasson et al. <em>[BCG^{+}13, §E.1]</em>. This language is defined by length <span class="math">m+1</span> polynomial vectors <span class="math">A(X)</span>, <span class="math">B(X)</span>, <span class="math">C(X)\\in(\\mathbb{F}[X])^{m+1}</span> such that the <span class="math">i</span>th components <span class="math">A_{i}(X)</span>, <span class="math">B_{i}(X)</span>, <span class="math">C_{i}(X)</span> are all degree-<span class="math">(n-1)</span> polynomials over <span class="math">\\mathbb{F}_{p}[X]</span> for <span class="math">i\\in[0,m-1]</span>, and <span class="math">A_{m}=B_{m}=C_{m}</span> is the degree-<span class="math">n</span> polynomial <span class="math">Z(X)</span> that vanishes on a specified set of <span class="math">n</span> distinct points in <span class="math">\\mathbb{F}_{p}</span>. There is a length-<span class="math">(m-1)</span> witness vector <span class="math">\\mathbf{w}</span> whose first <span class="math">\\ell</span> components are equal to the instance <span class="math">\\mathbf{x}\\in\\mathbb{F}^{\\ell}</span>, and a degree-<span class="math">n</span> “quotient” polynomial <span class="math">H(X)</span>, such that the following constraint equation is satisfied:</p>

    <p class="text-gray-300">\\[ \\begin{split}[(1,\\mathbf{w}^{\\top},\\delta_{1})A(X)]\\cdot[(1,\\mathbf{w}^{\\top},\\delta_{2})B(X)]-(1,\\mathbf{w}^{\\top},\\delta_{3})C(X)=H(X)\\cdot Z(X)\\\\ \\text{ and }(1,\\mathbf{w}^{\\top})(1,X,...,X^{\\ell},\\mathbf{0}^{m-\\ell-1})=(1,\\mathbf{x}^{\\top})(1,X,...,X^{\\ell})\\end{split} \\] (2)</p>

    <p class="text-gray-300">The deltas <span class="math">\\delta_{1},\\delta_{2},\\delta_{3}\\in\\mathbb{F}</span> are used as randomizers for zero-knowledge.</p>

    <h5 id="sec-63" class="text-base font-semibold mt-4">QAP algebraic linear PCP</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Equation 2 is turned into a set of linear queries by evaluating the polynomials at a random point in <span class="math">\\mathbb{F}</span>. Satisfaction in this random point implies satisfaction of the polynomial equation with error at most $2n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by the Schwartz-Zippel lemma. Translated to an algebraic IOP, the prover sends a proof oracle </span>\\bm{\\pi}_{w}<span class="math"> containing the vector </span>(1,\\mathbf{w},\\delta_{1},\\delta_{2},\\delta_{3})<span class="math"> as well as a proof oracle </span>\\bm{\\pi}_{h}<span class="math"> containing the coefficient vector of </span>H(X)<span class="math">. A common proof oracle </span>\\bm{\\pi}_{z}<span class="math"> is jointly established containing the coefficient vector of </span>Z(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\alpha\\in\\mathbb{F}</span> be a random point. The verifier makes four queries to <span class="math">\\bm{\\pi}_{w}</span>, computed by the polynomial vectors <span class="math">A(X),B(X),C(X)</span> and <span class="math">D(X)=(1,X,...,X^{\\ell},\\mathbf{0}^{m-\\ell-1})^{\\top}</span>, evaluated in <span class="math">\\alpha</span>. The verifier makes one query each to <span class="math">\\bm{\\pi}_{h}</span> and <span class="math">\\bm{\\pi}_{z}</span>, which is the evaluation of <span class="math">H(\\alpha)</span> and <span class="math">Z(\\alpha)</span> respectively. The verifier obtains query responses <span class="math">y_{a},y_{b},y_{c},y_{d},y_{h},y_{z}</span> and checks that <span class="math">y_{a}\\cdot y_{b}-y_{c}=y_{h}y_{z}</span> and <span class="math">y_{d}=\\langle(1,\\mathbf{w}^{\\top}),D(\\alpha)\\rangle</span>.</p>

    <h5 id="sec-64" class="text-base font-semibold mt-4">QAP Polynomial IOP</h5>

    <p class="text-gray-300">Following the compilation in Theorem 3 (Section 5.2.2), the QAP algebraic linear PCP can be transformed into a 2-round Polynomial IOP. For simplicity, assume <span class="math">m+3&lt;n</span>, where <span class="math">m-1</span> is the length of the witness and <span class="math">n</span> is the multiplicative complexity of the circuit. The preprocessing establishes three bivariate degree-<span class="math">n</span> polynomials (i.e., encoding <span class="math">A(X),B(X),C(X)</span>) and two univariate degree-<span class="math">n</span> polynomials (i.e., encoding <span class="math">Z(X)</span> and <span class="math">D(X)</span>). In the 2-round online phase the prover sends a degree-<span class="math">n</span> univariate oracle for the witness vector <span class="math">(1,\\mathbf{w},\\delta_{1},\\delta_{2},\\delta_{3})</span>, a degree-<span class="math">n</span> univariate oracle for <span class="math">H(X)</span>, four degree-<span class="math">n</span> univariate oracles encoding linear PCP queries, four degree-<span class="math">2n</span> univariate oracles encoding polynomial products, and eight degree-<span class="math">2n</span> univariate oracles for opening inner products. The total number of polynomial oracle evaluation queries is 3 bivariate degree-<span class="math">n</span>, 8 univariate degree-<span class="math">2n</span>, and 7 univariate degree-<span class="math">n</span>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Theorem 6 (QAP Polynomial IOP).</h6>

    <p class="text-gray-300">There exists a 2-round Polynomial IOP with preprocessing for any NP relation <span class="math">\\mathcal{R}</span> (with multiplicative complexity <span class="math">n</span>) that makes 7 queries to univariate degree-<span class="math">n</span> oracles, 8 queries to univariate degree-<span class="math">2n</span> oracles, and 3 queries to bivariate degree-<span class="math">n</span> oracles.</p>

    <p class="text-gray-300">While theoretically intriguing, compiling the QAP-based IOP with our polynomial commitments of Section 4 is less practical than compiling the Sonic IOP. While the QAP Polynomial IOP has only 15 univariate queries (compared to Sonic’s 39 queries to polynomials of twice the degree), the 3 bivariate polynomial oracles take quadratic time to preprocess and open. Unfortunately, our polynomial commitment scheme does not take advantage of the sparsity of these bivariate polynomials. Furthermore, ignoring prover time complexity, the size of the bivariate Eval proofs are twice as large as univariate Eval proofs.</p>

    <h2 id="sec-66" class="text-2xl font-bold">6 Evaluation</h2>

    <p class="text-gray-300">We now evaluate Supersonic, the trustless-setup SNARK built on the Polynomial IOPs underlying Sonic <em>[x10]</em>, PLONK <em>[x7]</em>, and Marlin <em>[CHM^{+}19]</em>, and compiled using</p>

    <p class="text-gray-300">our DARK polynomial commitment scheme. As explained in Section 4.5, the commitment scheme has several batching properties that can be put to good use here. It is possible to evaluate  <span class="math">k</span>  polynomials of degree at most  <span class="math">d</span>  using only 2 group elements and  <span class="math">(k + 1)</span>  field elements. To take advantage of this we delay the evaluation until the last step of the protocol (see Section 5.3). We present the proof size for both the compilation of Sonic, PLONK and Marlin in Table 3. We use 1600 bits as the size of class group elements and  <span class="math">\\lambda = 120</span> . The security of 1600 bit class groups is believed to be equivalent to 3048bit RSA groups and have 120 bits of security [BH01, BJS10]. This leads to proof sizes of 16.5KB for Sonic, 10.1KB using PLONK and 12.3KB using Marlin for circuits with  <span class="math">n = 2^{20}</span>  (one million) gates. Using 3048-bit RSA groups the proof sizes become 18.4KB for the compilation of PLONK. If 100 bits of security suffice then a 1200 bit class group can be used and the compiled PLONK proofs are 7.8KB for the same setting. In a 2048-bit RSA group this becomes 12.7KB.</p>

    <p class="text-gray-300">The comparison between the Polynomial IOPs is slightly misleading because for Sonic  <span class="math">n</span>  is the number of multiplication gates whereas for PLONK it is the sum of multiplication and addition gates. For Marlin it is the number of non-zero entries in the R1CS description of the circuit. A more careful analysis is therefore necessary, but this shows that there are Polynomial IOPs that can be compiled using the DARK polynomial commitment scheme to SNARKs of roughly 10 kilobytes in size. These numbers stand in contrast to STARKs which achieve proofs of 600KB for computation of similar complexity [BBHR19]. We compare Supersonic to different other proof systems in Table 4. Supersonic is the only proof system with efficient verifier time, small proof sizes that does not require a trusted setup.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Polynomial IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Polynomials</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Eval points</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SNARK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">concrete size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sonic [MBKM19]</td>

            <td class="px-3 py-2 border-b border-gray-700">12 in pp + 15</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">(15 + 2 log2(n))G + (12 + 13 log2(n))Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">15.3 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLONK [GWC19]</td>

            <td class="px-3 py-2 border-b border-gray-700">7 in pp + 7</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">(7 + 2 log2(n))G + (2 + 3 log2(n))Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">10.1 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin [CHM+19]</td>

            <td class="px-3 py-2 border-b border-gray-700">9 in pp + 10</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">(10 + 2 log2(6n))G + (3 + 4 log2(6n))Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">12.3 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 3: Proof size for Supersonic. Column 2 says how many polynomials are committed to in the SRS (offline oracles) and how many are sent by the prover (online oracles). Column 3 states the number of distinct evaluation points. The proof size calculation uses  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{Z}_p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 120<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1600<span class="math">  for  </span>n = 2^{20}$  gates.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Prover and Verifier cost We use the notation  <span class="math">O_{\\lambda}(\\cdot)</span>  to denote asymptotic complexity for a fixed security parameter  <span class="math">\\lambda</span> , i.e. how the prover and verifier costs scale as a function of variables other than  <span class="math">\\lambda</span> . The main cost for the Supersonic prover consists of computing the commitments to the polynomial oracles and producing the single combined Eval proof. This proof requires calculating the commitments to the polynomials  <span class="math">f_{L}(q)</span>  and  <span class="math">f_{R}(q)</span>  in each round and performing the  <span class="math">\\mathsf{PoE}(\\mathsf{C}_R, \\mathsf{C} - \\mathsf{C}_L, q^{d&#x27; + 1})</span> . Using precomputation, i.e., computing  <span class="math">\\mathsf{G}^{q&#x27;}</span>  for all  <span class="math">i</span>  and using multi-scalar multiplication, the commitments can be computed in  <span class="math">O_{\\lambda}\\left(\\frac{d}{\\log(d)}\\right)</span>  group operations. The same techniques can be used to reduce the number of group operations for the PoEs to  <span class="math">O_{\\lambda}(d)</span> . The total number of group operations is therefore linear in the maximum degree of the polynomial oracles and the number of online oracles. Interestingly, the number of offline oracles hardly impacts the prover time and proof size.</p>

    <p class="text-gray-300">The verifier time is dominated by the group operations for scalar multiplications in various places in the single combined Eval protocol. It consists of 3  <span class="math">\\lambda</span> -bit scalar multiplications in each round: 1 for combining  <span class="math">\\mathsf{C}_L</span>  and  <span class="math">\\mathsf{C}_R</span>  and two for verifying the PoE. In the final round, the verifier does another  <span class="math">\\lambda \\log_2(d + 1)</span> -bit scalar multiplication to open the commitment but this could also be outsourced to the prover using yet another PoE. The total verifier time, therefore, consists of roughly a scalar multiplication with  <span class="math">3\\lambda \\log_2(d + 1)</span>  group operations. Using  <span class="math">10\\mu s</span>  per group operation, this gives us for  <span class="math">\\lambda = 120</span>  and  <span class="math">n = 2^{20}</span>  a verification time of around 72ms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transp.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n = 220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Supersonic</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log(n)) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">3 log(n) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(n) GU</td>

            <td class="px-3 py-2 border-b border-gray-700">10.1KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLONK [GWC19]</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">2n GB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">1 Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) GB</td>

            <td class="px-3 py-2 border-b border-gray-700">720b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 [Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">no</td>

            <td class="px-3 py-2 border-b border-gray-700">2n GB</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">1 Pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) GB</td>

            <td class="px-3 py-2 border-b border-gray-700">192b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BP [BBB+18]</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">2n GP</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) MUL</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log(n) GP</td>

            <td class="px-3 py-2 border-b border-gray-700">1.7KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">STARK</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λT) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log2(T)) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log2(T)) H</td>

            <td class="px-3 py-2 border-b border-gray-700">600 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Virgo[ZXZS19]</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λn) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log2(n)) H</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log2(n)) H</td>

            <td class="px-3 py-2 border-b border-gray-700">271 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Comparison table between different succinct arguments. In column order, we compare by transparent setup, CRS size, prover and verifier time, asymptotic proof size, and concrete proof for an NP relation with arithmetic complexity  <span class="math">2^{20}</span> . Even when precise factors are given the numbers should be seen as estimates. For example, we chose to not display smaller order terms. The symbol  <span class="math">\\mathbb{G}_U</span>  denotes an element in a group of unknown order,  <span class="math">\\mathbb{G}_B</span>  one in a group with a bilinear map (pairing),  <span class="math">\\mathbb{G}_P</span>  one in a prime order group with known order. Furthermore, MUL refers to scalar multiplication of  <span class="math">\\lambda</span> -bit numbers in these groups, and  <span class="math">\\mathsf{H}</span>  is either the size of a hash output or the time it takes to compute a hash. The prover time for the group based schemes can be brought down by a log factor when using multi-scalar-multiplication techniques.</p>

    <p class="text-gray-300">In this work, we presented the DARK compiler: a polynomial commitment scheme from falsifiable assumptions in groups of unknown order with evaluation proofs that can be verified in logarithmic time. We also presented Polynomial IOPs, a unifying information-theoretical framework underlying the information-theoretic foundation of several recent SNARK constructions. Polynomial IOPs can be compiled into a concrete SNARK using a polynomial commitment scheme and the Fiat-Shamir transform. We showed that applying the DARK compiler to recent Polynomial IOPs yields the first trustless SNARKs (i.e., with a transparent untrusted setup) that have practical proof sizes and verification times. In particular, this is the first trustless/transparent SNARK construction that has asymptotically logarithmic verification time (ignoring the  <span class="math">\\lambda</span> -dependent factors, which are comparable to  <span class="math">\\lambda</span> -dependent factors in prior works). Finally, unlike all known SNARKs in bilinear groups, the construction does not require knowledge of exponent assumptions. Several important open questions remain:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Our polynomial commitment scheme has prover time linear in the total number of coefficients, even for zero coefficients. Consequently for a sparse bivariate polynomial of degree  <span class="math">d</span>  in each variable the prover time is quadratic in  <span class="math">d</span> . A sparse polynomial commitment scheme would directly enable an efficient compilation of simple information theoretic protocols such as QAPs.</li>

      <li>Assymptotically, Supersonic's prover time is on par with pairing-based SNARK constructions, however, a concrete implementation and performance comparison remains open.</li>

      <li>This work further motivates the study of class groups and groups of unknown order. In particular we rely on a recently introduced Adaptive Root Assumption.</li>

      <li>Our polynomial commitment scheme uses a simple underlying information theoretic protocol that could be compiled using a (partially) homomorphic commitment scheme over polynomials, or even another type of integer homomorphic commitment scheme. This leaves open whether there are different ways of instantiating our DARK compiler under different cryptographic assumptions.</li>

    </ul>

    <p class="text-gray-300">We thank Dan Boneh for helpful discussions and comments. We thank Katerina Sotiraki for helping point out an error in the multivariate description. This work was partially supported by NSF, SGF, ONR, the Simons Foundation, the Nervos Foundation.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFK21] Thomas Attema, Serge Fehr, and Michael Klooß. Fiat-shamir transformation of multi-round interactive proofs. Cryptology ePrint Archive, Report 2021/1377, 2021. https://eprint.iacr.org/2021/1377.</li>

      <li>[ALM^{+}92] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. Proof verification and hardness of approximation problems. In 33rd FOCS, pages 14–23. IEEE Computer Society Press, October 1992.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. Verifiable delay functions. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part I, volume 10991 of LNCS, pages 757–788. Springer, Heidelberg, August 2018.</li>

      <li>[BBC^{+}19] Dan Boneh, Elette Boyle, Henry Corrigan-Gibbs, Niv Gilboa, and Yuval Ishai. Zero-knowledge proofs on secret-shared data via fully linear PCPs. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 67–97. Springer, Heidelberg, August 2019.</li>

      <li>[BBF19] Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching techniques for accumulators with applications to IOPs and stateless blockchains. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 561–586. Springer, Heidelberg, August 2019.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl, July 2018.</li>

      <li>[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 701–732. Springer, Heidelberg, August 2019.</li>

      <li>[BCC^{+}16a] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. Cryptology ePrint Archive, Report 2016/263, 2016. https://eprint.iacr.org/2016/263.</li>

      <li>[BCC^{+}16b] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>[BCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for C: Verifying program executions succinctly and in zero knowledge. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 90–108. Springer, Heidelberg, August 2013.</li>

      <li>[BCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, pages 459–474. IEEE Computer Society Press, May 2014.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, Heidelberg, March 2013.</li>

      <li>[BCR^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 51–60. Springer, Heidelberg, October / November 2016.</li>

      <li>[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Halo infinite: Proof-carrying data from additive polynomial commitments. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 649–680, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>[BF22] Benedikt Bünz and Ben Fisch. Schwartz-zippel for multilinear polynomials mod N. Cryptology ePrint Archive, Report 2022/458, 2022. https://eprint.iacr.org/2022/458.</li>

      <li>[BFL91] László Babai, Lance Fortnow, and Carsten Lund. Non-deterministic exponential time has two-prover interactive protocols. Computational Complexity, 1:3–40, 1991.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In 23rd ACM STOC, pages 21–31. ACM Press, May 1991.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BG93] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 390–420. Springer, Heidelberg, August 1993.</li>

      <li>[BGG^{+}88] Michael Ben-Or, Oded Goldreich, Shafi Goldwasser, Johan Håstad, Joe Kilian, Silvio Micali, and Phillip Rogaway. Everything provable is provable in zero-knowledge. In Shafi Goldwasser, editor, CRYPTO’88, volume 403 of LNCS, pages 37–56. Springer, Heidelberg, August 1988.</li>

      <li>[BGKS19] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: sampling outside the box improves soundness. IACR Cryptology ePrint Archive, 2019:336, 2019.</li>

      <li>[BH01] Johannes Buchmann and Safuat Hamdy. A survey on iq cryptography. In Public-Key Cryptography and Computational Number Theory, pages 1–15, 2001.</li>

      <li>[BHR^{+}21] Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. Time- and space-efficient arguments from groups of unknown order. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part IV, volume 12828 of LNCS, pages 123–152, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>[BJS10] Jean-François Biasse, Michael J. Jacobson Jr., and Alan K. Silvester. Security estimates for quadratic field based cryptosystems. CoRR, abs/1004.5512, 2010.</li>

      <li>[Bow16] Sean Bowe. Bellman zk-snarks library, 2016. https://github.com/zkcrypto/bellman.</li>

      <li>[BS96] Wieb Bosma and Peter Stevenhagen. On the computation of quadratic 2-class groups. In Journal de Theorie des Nombres, 1996.</li>

      <li>[BSGKS19] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. Deep-fri: Sampling outside the box improves soundness. 26:44, 2019.</li>

      <li>[BTVW14] Andrew J. Blumberg, Justin Thaler, Victor Vu, and Michael Walfish. Verifiable computation using multiple provers. Cryptology ePrint Archive, Report 2014/846, 2014. https://eprint.iacr.org/2014/846.</li>

      <li>[But16] Vitalik Buterin. Zk rollup, 2016. https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 1082–1090. ACM Press, June 2019.</li>

      <li>[CHM^{+}19] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zksnarks with universal and updatable srs. Cryptology ePrint Archive, Report 2019/1047, 2019. https://eprint.iacr.org/2019/1047.</li>

      <li>[COS19] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography, 2019.</li>

      <li>[CPP17] Geoffroy Couteau, Thomas Peters, and David Pointcheval. Removing the strong RSA assumption from arguments over the integers. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 321–350. Springer, Heidelberg, April / May 2017.</li>

      <li>[DF02] Ivan Damgård and Eiichiro Fujisaki. A statistically-hiding integer commitment scheme based on groups with hidden order. In Yuliang Zheng, editor, ASIACRYPT 2002, volume 2501 of LNCS, pages 125–142. Springer, Heidelberg, December 2002.</li>

      <li>[DK02] Ivan Damgård and Maciej Koprowski. Generic lower bounds for root extraction and signature schemes in general groups. In Lars R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 256–271. Springer, Heidelberg, April / May 2002.</li>

      <li>[Ebe] Jacob Eberhardt. Zokrates. https://zokrates.github.io/.</li>

      <li>[FO97] Eiichiro Fujisaki and Tatsuaki Okamoto. Statistical zero knowledge protocols to prove modular polynomial relations. In Burton S. Kaliski Jr., editor, CRYPTO’97, volume 1294 of LNCS, pages 16–30. Springer, Heidelberg, August 1997.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</li>

      <li>[GI08] Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 379–396. Springer, Heidelberg, April 2008.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 113–122. ACM Press, May 2008.</li>

    </ul>

    <p class="text-gray-300">[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In 17th ACM STOC, pages 291–304. ACM Press, May 1985.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity. Journal of the ACM, 38(3), 1991.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[GVW02] Oded Goldreich, Salil Vadhan, and Avi Wigderson. On interactive proofs with a laconic prover. volume 11(1/2), pages 1–53, 2002.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[HBHW19] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. Zcash Protocol Specification, 2019.</li>

      <li>[IKO07] Yuval Ishai, Eyal Kushilevitz, and Rafael Ostrovsky. Efficeint arguments without short pcps. 2007.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>[KPV19] Assimakis Kattis, Konstantin Panarin, and Alexander Vlasov. RedShift: Transparent SNARKs from list polynomial commitment IOPs. Cryptology ePrint Archive, Report 2019/1400, 2019. https://eprint.iacr.org/2019/1400.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</li>

      <li>[Lab18] O(1) Labs. Coda protocol, 2018. https://codaprotocol.com/.</li>

      <li>[Lin01] Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. In Joe Kilian, editor, CRYPTO 2001, volume 2139 of LNCS, pages 171–189. Springer, Heidelberg, August 2001.</li>

      <li>[Lip03] Helger Lipmaa. On diophantine complexity and statistical zero-knowledge arguments. In Chi-Sung Laih, editor, ASIACRYPT 2003, volume 2894 of LNCS, pages 398–415. Springer, Heidelberg, November / December 2003.</li>

      <li>[LM19] Russell W. F. Lai and Giulio Malavolta. Subvector commitments with application to succinct arguments. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 530–560. Springer, Heidelberg, August 2019.</li>

      <li>[LRY16] Benoît Libert, Somindu C. Ramanna, and Moti Yung. Functional commitment schemes: From polynomial commitments to pairing-based accumulators from simple assumptions. In Ioannis Chatzigiannakis, Michael Mitzenmacher, Yuval Rabani, and Davide Sangiorgi, editors, ICALP 2016, volume 55 of LIPIcs, pages 30:1–30:14. Schloss Dagstuhl, July 2016.</li>

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updatable structured reference strings. Cryptology ePrint Archive, Report 2019/099, 2019. https://eprint.iacr.org/2019/099.</li>

      <li>[Pie19] Krzysztof Pietrzak. Simple verifiable delay functions. In 10th Innovations in Theoretical Computer Science Conference, ITCS 2019, January 10-12, 2019, San Diego, California, USA, pages 60:1–60:15, 2019.</li>

      <li>[Pip80] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on Computing, 9:230–250, 1980.</li>

      <li>[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In Daniel Wichs and Yishay Mansour, editors, 48th ACM STOC, pages 49–62. ACM Press, June 2016.</li>

      <li>[RSA78] Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. A method for obtaining digital signatures and public-key cryptosystems. Communications of the Association for Computing Machinery, 21(2):120–126, 1978.</li>

      <li>[RSW96] Ron Rivest, Adi Shamir, and David Wagner. Time-lock puzzles and timed-release crypto. In MIT Technical report, 1996.</li>

      <li>[SBV^{+}13] S. Setty, B. Braun, V. Vu, A. J. Blumberg, B. Parno, and M. Walfish. Resolving the conflict between generality and plausibility in verified computation. 2013.</li>

      <li>[Set19] Srinath Setty. Spartan: Efficient and general-purpose zksnarks without trusted setup. Cryptology ePrint Archive, Report 2019/550, 2019. https://eprint.iacr.org/2019/550.</li>

      <li>[Str19] Michael Straka. Class groups for cryptographic accumulators. 2019.</li>

      <li>[WB15] Michael Walfish and Andrew J. Blumberg. Verifying computations without reexecuting them: From theoretical possibility to near practicality. Communications of the ACM, 58(2), 2015.</li>

    </ul>

    <p class="text-gray-300">[Wee05] Hoeteck Wee. On round-efficient argument systems. In Luís Caires, Giuseppe F. Italiano, Luís Monteiro, Catuscia Palamidessi, and Moti Yung, editors, ICALP 2005, volume 3580 of LNCS, pages 140–152. Springer, Heidelberg, July 2005.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Wes19] Benjamin Wesolowski. Efficient verifiable delay functions. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part III, volume 11478 of LNCS, pages 379–407. Springer, Heidelberg, May 2019.</li>

      <li>[Wik21] Douglas Wikström. Special soundness in the random oracle model. Cryptology ePrint Archive, Report 2021/1265, 2021. https://eprint.iacr.org/2021/1265.</li>

      <li>[Wil16] Z. Wilcox. The design of the ceremony, 2016. https://z.cash/blog/the-design-of-the-ceremony.html.</li>

      <li>[WTs^{+}18] Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926–943. IEEE Computer Society Press, May 2018.</li>

      <li>[XZZ^{+}19] Tiacheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. Cryptology ePrint Archive, Report 2019/317, 2019. https://eprint.iacr.org/2019/317.</li>

      <li>[Zca] Zcash. https://z.cash.</li>

      <li>[ZGK^{+}17] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In 2017 IEEE Symposium on Security and Privacy, pages 863–880. IEEE Computer Society Press, May 2017.</li>

      <li>[ZXZS19] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn Song. Transparent polynomial delegation and its applications to zero knowledge proof. Cryptology ePrint Archive, Report 2019/1482, 2019. https://eprint.iacr.org/2019/1482.</li>

    </ul>

    <p class="text-gray-300">New Security Proof and Almost-Special-Soundness (Added June 2022)</p>

    <p class="text-gray-300">Although DARK does not satisfy special soundness, it does satisfy a property that we will call almost-special-sound, which turns out to be sufficient (i.e., using our new forking lemma we can prove that such protocols are knowledge sound). Almost-special-soundness is a weaker property than special soundness, as all protocols that satisfy special soundness also satisfy almost-special-soundness.</p>

    <h2 id="sec-69" class="text-2xl font-bold">Appendix A Preliminaries and Notations</h2>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">A.1 Integer Polynomials</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">f</span> is a multivariate polynomial, then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> denotes the maximum over the absolute values of all coefficients of </span>f$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 6 (Evaluation Bound).</h6>

    <p class="text-gray-300">For any <span class="math">\\mu</span>-linear integer polynomial <span class="math">f</span> and <span class="math">m\\geq 2</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbb{P}_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\mathbf{x})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{1}{m^{\\mu}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}]\\leq\\frac{3\\mu}{m}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">f^{(0)}:=f</span>. Given a vector <span class="math">\\mathbf{x}=(x_{1},..,x_{\\mu})</span>, for each <span class="math">j\\in[1,\\mu]</span> define <span class="math">f_{\\mathbf{x}}^{(j)}</span> to be the <span class="math">\\mu-j</span>-variate partial evaluation <span class="math">f_{\\mathbf{x}}^{(j)}:=f(x_{1},...,x_{j},X_{j+1},...,X_{\\mu})</span>. Then we can rewrite the lemma statement as:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P_{\\mathbf{x}\\leftarrow[0,m)^{\\mu}}[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(\\mu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\frac{1}{m^{\\mu}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}]\\leq\\frac{3\\mu}{m}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will bound the probability for random <span class="math">\\mathbf{x}</span> that there exists any <span class="math">j</span> for which $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If no such </span>j<span class="math"> exists, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{(\\mu)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{m^{\\mu}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">j</span>, we can write <span class="math">f_{\\mathbf{x}}^{(j)}=g(X_{j+1},...,X_{\\mu})+x_{j}\\cdot h(X_{j+1},...,X_{\\mu})</span> where <span class="math">g,h</span> are <span class="math">\\mu-j</span> variate multilinear integer polynomials and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> because the coefficients of </span>g<span class="math"> and </span>h<span class="math"> are a partition of the coefficients of </span>f_{\\mathbf{x}}^{(j-1)}<span class="math">. Suppose now that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, i.e. that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ and consider two cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 1: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For any integer </span>\\Delta\\neq 0$, using the triangle inequality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+(x_{j}+\\Delta)h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}h+\\Delta h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>{(1-\\frac{1}{m})\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The last part of the inequality holds because <span class="math">1-\\frac{1}{m}\\geq\\frac{1}{m}</span> for any <span class="math">m\\geq 2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case2: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Using the triangle inequality,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{1}{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This implies, for <span class="math">m\\geq 2</span>, that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ because:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>{(1-\\frac{1}{m})\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\implies</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{m-1}{x_{j}\\cdot m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{1}{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The last step uses that <span class="math">x_{j}\\in[1,m)</span>. For <span class="math">x_{j}=0</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Finally, for any integer </span>\\Delta$, by the triangle inequality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+(x_{j}+\\Delta)\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+x_{j}\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2<span class="math"> this implies that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g+(x_{j}+\\Delta)\\cdot h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In both cases, we conclude that for any choice of <span class="math">(x_{1},...,x_{j-1})</span> for the first <span class="math">j-1</span> components of the random <span class="math">\\mathbf{x}</span>, which define <span class="math">g</span> and <span class="math">h</span>, there are at most three choices of <span class="math">x_{j}</span> such that the event $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{1}{m}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{\\mathbf{x}}^{(j-1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> holds true (i.e., if true for </span>x_{j}<span class="math">, then it is also true for at most </span>x_{j}+1<span class="math"> and </span>x_{j}-1<span class="math">). Thus this event occurs with probability at most </span>\\frac{3}{m}<span class="math">. Finally, by a union bound over </span>j<span class="math">, the probability this event occurs for some index </span>j<span class="math"> is at most </span>\\frac{3\\mu}{m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Lemma 7 (Multilinear Composite Schwartz-Zippel [BF22]). For all  <span class="math">m \\geq 2</span> , any  <span class="math">\\mu</span> -linear integer polynomial  <span class="math">f</span> , and  <span class="math">N \\in \\mathbb{Z}</span>  coprime to  <span class="math">f</span> , if either  <span class="math">\\mu = 1</span>  and  <span class="math">\\log_2 N \\geq \\lambda</span>  or  <span class="math">\\mu \\geq 2</span>  and  <span class="math">\\log_2 N \\geq 8\\mu^2 + \\log_2(2\\mu) \\cdot \\lambda</span>  then:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {x \\leftarrow [ 0, m) ^ {p}} [ f (x) \\equiv 0 \\bmod N ] \\leq \\frac {1}{2 ^ {\\lambda}} + \\frac {\\mu}{m}</span></div>

    <p class="text-gray-300">[BF22] also provide an algorithm for computing tighter values for the MCSZ for concrete parameters for  <span class="math">\\mu</span>  and  <span class="math">\\lambda</span> . We present a range of values for different  <span class="math">\\mu</span>  and  <span class="math">\\lambda = 120</span> .</p>

    <p class="text-gray-300">Lemma 8 (Concrete MCSZ for 120-bit security [BF22]).</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {x \\leftarrow [ 0, m) ^ {p}} [ f (x) \\equiv 0 \\bmod N ] \\leq 2 ^ {- 1 2 0} + \\frac {\\mu}{m}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">μ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 120</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">μ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 120</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">μ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ = 120</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">301</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">429</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">315</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">437</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">175</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">331</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">197</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">344</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">464</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">354</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">472</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">366</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">481</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">244</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">381</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">492</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">260</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">391</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">506</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">277</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">407</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">516</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">289</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">527</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fact 2. Let  <span class="math">q \\in \\mathbb{Z}</span>  be any positive integer. For any integer  <span class="math">E \\in \\mathbb{Z}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{q^{d + 2} - q}{2(q - 1)}<span class="math">  there exists a unique degree  </span>d<span class="math">  integer polynomial  </span>f \\in \\mathbb{Z}[X]<span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq q / 2<span class="math">  such that  </span>f(q) = E$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We extend the integer encoding from Section 4.2 to rational multi-linear polynomials.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 9 (Rational Encoding of multi-linear polynomials). Let  <span class="math">q \\in \\mathbb{Z}</span>  be any positive integer. Let  <span class="math">\\vec{q} = [q^{2^{i-1}}]_{i=1}^{\\mu} \\in \\mathbb{Z}^{\\mu}</span> . Consider any  <span class="math">\\beta_d, \\beta_n \\in \\mathbb{N}</span>  such that  <span class="math">\\beta_d \\cdot \\beta_n \\leq \\frac{q}{2}</span> . Let  $Z = \\{z \\in \\mathbb{Z} :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_d\\}<span class="math"> , let  </span>\\mathcal{F} = \\{f \\in \\mathbb{Z}[X_1, \\ldots, X_\\mu] :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq \\beta_n\\}<span class="math">  be a  </span>\\mu<span class="math"> -linear polynomial, and let  </span>\\mathcal{H} = \\{f / z \\in \\mathbb{Q}[X_1, \\ldots, X_\\mu] : f \\in \\mathcal{F} \\wedge z \\in Z\\}<span class="math"> . Then for any  </span>h_1, h_2 \\in \\mathcal{H}<span class="math"> , if  </span>h_1(\\vec{q}) = h_2(\\vec{q})<span class="math">  then  </span>h_1 = h_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  <span class="math">h_1 = \\frac{f_1}{f_2}</span>  and  <span class="math">h_2 = \\frac{f_2}{z_2}</span> . If  <span class="math">h_1(\\vec{q}) = h_2(\\vec{q})</span>  then  <span class="math">z_1 f_2(\\vec{q}) = z_2 f_1(\\vec{q})</span> . Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_2 \\cdot f_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta_d \\cdot \\beta_n \\leq \\frac{q}{2}<span class="math">  and likewise  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_1 \\cdot f_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\frac{q}{2}<span class="math"> . Note that there exist a unique univariate degree  </span>2^{\\mu} - 1<span class="math">  polynomial  </span>\\tilde{f}_1<span class="math">  that has the same coefficients as  </span>f_1<span class="math">  such that for all  </span>q<span class="math"> </span>f_1(\\vec{q}) = \\tilde{f}_1(q)<span class="math"> . Let  </span>f_2<span class="math">  be the univariate degree  </span>2^{\\mu} - 1<span class="math">  polynomial with the same coefficients as  </span>\\tilde{f}_2<span class="math"> . It then follows from Fact 2 that if  </span>z_1 f_2(\\vec{q}) = z_1 \\tilde{f}_2(q) = z_2 \\tilde{f}_1(q) = z_2 f_1(\\vec{q})<span class="math">  then  </span>z_1 f_2 = z_2 f_1<span class="math"> , or equivalently,  </span>h_1 = h_2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We restate the DARK commitment scheme as a commitment scheme to  <span class="math">\\mu</span> -linear polynomials with bounded rational coefficients. If  <span class="math">f</span>  is a  <span class="math">\\mu</span> -linear polynomial then it can represent a degree  <span class="math">2^{\\mu - 1}</span>  univariate polynomial  <span class="math">\\tilde{f}</span>  with the same coefficients, as  <span class="math">\\tilde{f}(z) = f(z, z^2, \\ldots, z^{2^{\\mu - 1}})</span> . While the honest prover will commit to the integer representation of a polynomial defined over a prime field, this representation is useful in the security proof. The extractor will extract bounded rational polynomials instead of integer ones. Fortunately, we can show that given sufficiently large parameters, the commitment scheme is still binding.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given the security parameter  <span class="math">\\lambda</span> , the commitment scheme setup selects a group  <span class="math">\\mathbb{G}</span>  for which the random order assumption holds (with  <span class="math">\\lambda</span> -bit security) and a random generator  <span class="math">\\mathsf{G} \\in \\mathbb{G}</span> . A parameter  <span class="math">q \\in \\mathbb{N}</span>  determines a commitment message space  $\\mathcal{M} = \\{f(X_1, \\ldots, X_\\mu) :</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq q/2 \\land \\forall i \\deg_{X_i}(f_i) \\leq 1\\}<span class="math"> . The commitment to  </span>f(X_1, \\ldots, X_\\mu) \\in \\mathcal{M}<span class="math">  is  </span>f(\\vec{q}) \\cdot \\mathsf{G}<span class="math">  for  </span>\\vec{q} = (q, q^2, \\ldots, q^{2^{\\mu - 1}})<span class="math"> . Commitments are binding over  </span>\\mathcal{M}<span class="math">  because if  </span>f(\\vec{q}) \\cdot \\mathsf{G} = f'(\\vec{q}) \\cdot \\mathsf{G}$  then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(f&#x27;(\\vec{q}) - f(\\vec{q}))\\mathsf{G} = 0</span>. This breaks the order assumption for <span class="math">\\mathbb{G}</span> unless <span class="math">f&#x27;(\\vec{q}) = f(\\vec{q})</span>, in which case <span class="math">f&#x27; = f</span> by Fact 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we expand the valid openings of the commitment scheme to include rational polynomials of the form <span class="math">f / z</span>, where <span class="math">f \\in \\mathbb{Z}[X]</span>, <span class="math">z \\in \\mathbb{Z}</span>, so that <span class="math">(f, D)</span> is an opening of <span class="math">\\mathbb{C}</span> to <span class="math">f / z</span> iff <span class="math">z \\cdot \\mathbb{C} = f(\\vec{q}) \\cdot \\mathbb{G}</span>, then the scheme is binding over the message space $\\mathcal{M}(\\beta_n, \\beta_d) = \\{f(X) / z : f \\in \\mathbb{Z}[X], z \\in \\mathbb{Z}, \\gcd(f, z) = 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta_n,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_d\\}<span class="math"> so long as </span>\\beta_n \\cdot \\beta_d \\leq \\frac{q}{2}<span class="math">. Openings to rationals are equivalent to what has been previously described as relaxed openings, whereby </span>\\mathbb{C}<span class="math"> is opened to </span>f<span class="math"> by opening </span>z \\cdot \\mathbb{C}<span class="math"> to </span>z \\cdot f<span class="math"> for </span>z \\in \\mathbb{Z}$ [BDFG21].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 10 (DARK commitment Security). The commitment scheme (Setup, Commit, Vf) to integer <span class="math">\\mu</span>-linear polynomials:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup <span class="math">(\\lambda, \\beta_n \\in \\mathbb{Z}, \\beta_d \\in \\mathbb{Z})</span>: sample <span class="math">\\mathbb{G} \\gets GGen(\\lambda), \\mathsf{G} \\gets \\mathbb{G}</span>, return <span class="math">\\mathsf{pp} := (\\mathbb{G}, \\mathsf{G}, q = 2\\beta_n\\beta_d)</span></li>

      <li>Commit <span class="math">(pp, f \\in \\mathcal{M}(\\beta_n, \\beta_d))</span> : return <span class="math">f(\\vec{q}) \\cdot \\mathsf{G}</span> for <span class="math">\\vec{q} = (q, q^2, \\ldots, q^{\\mu - 1}) \\in \\mathbb{Z}^\\mu</span></li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{pp}, C \\in \\mathbb{G}, h = f / N \\in \\mathcal{M}(\\beta_n, \\beta_d))</span>: return <span class="math">\\mathbf{1}[N \\cdot \\mathsf{C} = f(\\vec{q}) \\cdot \\mathsf{G}]</span></li>

    </ul>

    <p class="text-gray-300">is binding over the rational polynomial set <span class="math">\\mathcal{M}(\\beta_n, \\beta_d)</span> under the random order assumption (1), i.e. for any polynomial time adversary <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">P \\left[ \\begin{array}{c c} \\operatorname {O p e n} (\\mathsf {p p}, C, h) = \\operatorname {O p e n} (\\mathsf {p p}, C, h ^ {\\prime}) = 1 &amp;amp; (h, h ^ {\\prime}, C) \\in \\mathcal {M} (\\beta_ {n}, \\beta_ {d}) ^ {2} \\times \\mathbb {G} \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ h \\neq h ^ {\\prime} &amp;amp; \\mathsf {p p} \\leftarrow \\operatorname {S e t u p} (\\lambda , \\beta_ {n}, \\beta_ {d}) \\end{array} \\right] &amp;lt;   \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Proof. To see why this is binding over <span class="math">\\mathcal{M}(\\beta_n, \\beta_h)</span>, suppose that both <span class="math">h = \\frac{f}{N}</span> and <span class="math">h&#x27; = \\frac{f&#x27;}{N&#x27;}</span> are valid openings of a commitment <span class="math">\\mathbb{C}</span> to distinct rational polynomials <span class="math">h, h&#x27; \\in \\mathcal{M}(\\beta_n, \\beta_d)</span>. This implies that <span class="math">N \\cdot \\mathbb{C} = f(\\vec{q}) \\cdot \\mathbb{G}</span> and <span class="math">z&#x27; \\cdot \\mathbb{C} = f&#x27;(\\vec{q}) \\cdot \\mathbb{G}</span>. Hence, <span class="math">v = z \\cdot f&#x27;(\\vec{q}) - z&#x27; \\cdot f(\\vec{q})</span> is a multiple of the order of <span class="math">\\mathbb{G}</span>, i.e. <span class="math">v \\cdot \\mathbb{G} = 0</span>. Moreover, by Lemma 9, <span class="math">h(\\vec{q}) \\neq h&#x27;(\\vec{q})</span>, which implies <span class="math">v \\neq 0</span>. This breaks the random order assumption for <span class="math">\\mathbb{G}</span>. It is important to note that the openings <span class="math">(f, z)</span> and <span class="math">(f&#x27;, z&#x27;)</span> need not be co-prime elements of bounded norm; it suffices that <span class="math">h = f / z</span> and <span class="math">h&#x27; = f&#x27; / z&#x27;</span> have bounded norm numerators and denominators in reduced fraction form, i.e. <span class="math">h, h&#x27; \\in \\mathcal{M}(\\beta_n, \\beta_d)</span>.</p>

    <h2 id="sec-74" class="text-2xl font-bold">A.3 IP Transcript Trees</h2>

    <p class="text-gray-300">Let <span class="math">(P,V)</span> be a <span class="math">\\mu</span>-round public coin interactive protocol. A <span class="math">\\mu</span>-round public-coin protocol <span class="math">(P,V)</span> consists of <span class="math">\\mu</span>-rounds of messages between the prover and verifier, where in each round the prover sends a message to the verifier and the verifier responds with <span class="math">x \\gets \\mathcal{X}</span> sampled uniformly from the challenge space <span class="math">\\mathcal{X}</span>. At the end of the protocol, the verifier outputs either accept or reject. By convention, the protocol starts with the prover's first message and ends with the prover's last message. A transcript thus contains <span class="math">\\mu + 1</span> prover messages and <span class="math">\\mu</span> challenges. We will denote transcripts by a <span class="math">\\mu \\times 2</span> matrix <span class="math">A</span> such that <span class="math">A(0,0)</span> is the protocol input <span class="math">x</span>, <span class="math">A(0,1)</span> is the prover's first message, and for all <span class="math">i \\geq 1</span>, <span class="math">A(i,0)</span> is the verifier's <span class="math">i</span>th round challenge and <span class="math">A(i,1)</span> is the prover's <span class="math">i</span>th round response. We restrict our attention to protocols in which the verifier's decision is a deterministic function <span class="math">D_V</span> of the transcript, which is true of the DARK protocol, but is also without loss of generality. An accepting transcript is an array <span class="math">A</span> such that <span class="math">D_V(A) = \\text{accept}</span>.</p>

    <p class="text-gray-300">A <span class="math">k</span>-ary transcript tree for <span class="math">(P,V)</span> is a labelling of a <span class="math">\\mu</span>-depth <span class="math">k</span>-ary tree such that the labels on every root-to-leaf path forms an accepting <span class="math">(P,V)</span> transcript. It will be convenient to order the nodes of the tree according to a depth-first reverse topological sort (aka post-order tree traversal). This is a topological sorting of the tree with directed edges flowing from leaves to root which places left subtrees before right subtrees. This ordering associates each node with an index in <span class="math">[1,N]</span> where <span class="math">N = \\text{size}(\\mu, k) = \\frac{k^{\\mu + 1} - 1}{k - 1}</span>.</p>

    <p class="text-gray-300">A post-order labelling of the tree is a function <span class="math">L: [1, N] \\to \\mathcal{X} \\times \\mathcal{M}</span> where <span class="math">\\mathcal{X}</span> is the verifier's challenge set and <span class="math">\\mathcal{M}</span> is the space of prover messages. We can think of the first component (i.e., the verifier challenge) as a label on the node's incoming edge and the second component (i.e., prover's response) as a label on the node itself. The root has no incoming edge, but the root label's first component is the protocol input. For any root-to-leaf path of nodes with indices <span class="math">\\{v_0, \\dots, v_\\mu\\}</span> the labelling <span class="math">L</span> defines the matrix <span class="math">A</span> such that <span class="math">L(v_i) = (A(i, 0), A(i, 1))</span> and <span class="math">A</span> is an accepting transcript. Given a label <span class="math">L(v)</span> for <span class="math">v &amp;lt; N</span> (non-roots) we will use the notation <span class="math">L(v)_0</span> to denote the first component of the label containing the verifier's challenge</p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: IP transcript tree for  <span class="math">\\mu = k = 3</span> . Nodes and edges are labeled using post-order labeling. We also indicate  <span class="math">v^{*}</span>  for every node.</p>

    <p class="text-gray-300">and  <span class="math">L(v)_1</span>  the second component containing the prover's response. Finally, we define a  <span class="math">k</span> -ary forking transcript tree to be a  <span class="math">k</span> -ary transcript tree in which the challenge labels on all edges sharing a common parent are distinct.</p>

    <p class="text-gray-300">We may refer to the level of a node in the tree. The root of a tree is always at level 0 and the leaves of a depth  <span class="math">\\mu</span>  tree are at level  <span class="math">\\mu</span> . The height of node at level  <span class="math">\\ell</span>  within a  <span class="math">\\mu</span> -depth tree is  <span class="math">\\mu - \\ell</span> . For each  <span class="math">v \\in [1, N]</span>  let  <span class="math">v^{<em>}</span>  denote the largest index  <span class="math">v^{</em>} &amp;lt; v</span>  such that the node at index  <span class="math">v^{<em>}</span>  does not belong to the subtree extending from  <span class="math">v</span> . Note that for nodes on the leftmost path of the tree  <span class="math">v^{</em>}</span>  does not exist so we denote it by  <span class="math">\\perp</span> . For each  <span class="math">v \\in [1, N]</span>  let  <span class="math">L_{v} : [1, v] \\to \\mathcal{X} \\times \\mathcal{M}</span>  denote the restriction of  <span class="math">L</span>  to the subset  <span class="math">[1, v^{<em>}]</span> . Similarly, for any  <span class="math">S \\subseteq [1, N]</span>  let  <span class="math">L_{S} : S \\to \\mathcal{X} \\times \\mathcal{M}</span>  denote the restriction of the labelling  <span class="math">L</span>  to the subset of node indices  <span class="math">S</span> . For any  <span class="math">v \\in [1, N]</span>  let  <span class="math">S_{v} \\subseteq [1, N]</span>  denote the indices of all nodes in the subtree rooted at node  <span class="math">v</span> .  <span class="math">L_{S_{v}}</span>  thus denotes the labelling of the subtree  <span class="math">S_{v}</span> . Note that  <span class="math">L_{v^{</em>}}</span>  is not the same as  <span class="math">L_{S_{v^{*}}}</span> .</p>

    <p class="text-gray-300">The standard forking lemma for  <span class="math">\\mu</span> -round public coin interactive protocols characterizes the efficiency of generating a  <span class="math">k</span> -ary  <span class="math">\\mu</span> -depth transcript tree for which the challenges labeling the children within the tree fork, i.e. are distinct. More precisely, the forking lemma says that given any adversarial prover  <span class="math">\\mathcal{A}</span>  that may deviate from the honest protocol but causes the verifier to accept with probability  <span class="math">\\epsilon</span> , there is a tree generation algorithm that has only black-box access to  <span class="math">\\mathcal{A}</span> , runs in time  <span class="math">t \\in O\\left(\\frac{\\lambda}{s} \\cdot k^{\\mu} \\cdot (\\mu + t_{V})\\right)</span> , where  <span class="math">t_{V}</span>  is the running time of the verifier's decision algorithm, and succeeds with probability  <span class="math">1 - t \\cdot \\mathrm{negl}(\\lambda)</span>  in producing a transcript tree with the forking property.</p>

    <p class="text-gray-300">Our path predicate forking lemma generalizes the property of the transcript tree that can be generated by considering arbitrary predicates on partial labelings of the tree. In the standard forking lemma, the predicate would simply be that new challenges are distinct from previous challenges. The lemma considers predicates for each node  <span class="math">v \\in [1, N]</span>  at level  <span class="math">\\ell_v</span>  of the form  <span class="math">\\pi_v : (\\mathcal{X} \\times \\mathcal{M})^{[1, v^<em>]} \\times \\mathcal{X}^{\\mu - \\ell_v} \\to \\{0, 1\\}</span> , i.e. each predicate  <span class="math">\\pi_v</span>  takes as input a labelling function  <span class="math">L_{v^</em>}</span>  for the partial set of nodes  <span class="math">[1, v^<em>]</span>  and a vector of challenges  <span class="math">\\mathbf{x} \\in \\mathcal{X}^{\\mu - \\ell_v}</span> . The vector of challenges will represent the leftmost path down the tree starting from  <span class="math">v</span> , which by definition is independent of the partial labeling  <span class="math">L_{v^</em>}</span> . We denote the indices of the leftmost path from  <span class="math">v</span>  to the leaves as  <span class="math">\\text{lpath}_v</span>  and the challenge labels along this path assigned by  <span class="math">L</span>  as  <span class="math">L(\\text{lpath}_v)_0</span> . For example in Figure 1 the predicate  <span class="math">\\pi_{\\mathbf{x}}</span>  for node 8 would take as input the subtree spanned by 4 and the challenge  <span class="math">L(5)_0</span> . The lemma says that if  <span class="math">\\pi_v(L_{v^*}, \\mathbf{x}) = 1</span>  with overwhelming probability  <span class="math">1 - \\text{negl}(\\lambda)</span>  for any post-order labeling  <span class="math">L : [1, N] \\to \\mathcal{X} \\times \\mathcal{M}</span>  of the  <span class="math">k</span> -ary  <span class="math">\\mu</span> -depth tree, any node  <span class="math">v</span>  in the tree, and  <span class="math">\\mathbf{x}</span>  sampled randomly, then the transcript</p>

    <p class="text-gray-300">generation algorithm produces a transcript tree represented by some post-order labeling <span class="math">L</span> for which <span class="math">\\pi_{v}(L_{v^{<em>}},L(\\mathsf{lpath}_{v})_{0})=1</span> for all <span class="math">v</span> in the tree. In fact, the lemma is even more general as it has a weaker requirement that <span class="math">\\pi_{v}(L_{v^{</em>}}^{<em>},\\mathbf{x})=1</span> with overwhelming probability conditioned on <span class="math">\\pi_{u}(L_{u^{</em>}}^{<em>},L(\\mathsf{lpath}_{u})_{0})=1</span> for all <span class="math">u\\leq v^{</em>}</span>. The standard forking lemma is a special case where <span class="math">\\pi_{v}</span> checks that the challenge label on <span class="math">v</span> is distinct from the challenge labels on any of its left siblings. The challenge label <span class="math">L(v)_{0}</span> on <span class="math">v</span> is the first component of <span class="math">L(\\mathsf{lpath}_{v})_{0}</span> and the challenge labels on the left sibling(s) of <span class="math">v</span>, assuming <span class="math">v</span> is not the first child, are included in <span class="math">L_{v^{*}}</span>.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">Proof Overview</h4>

    <p class="text-gray-300">We will begin with a high level overview of the proof. The algorithm is exactly the same as the recursive tree generation algorithm for the standard forking lemma. The difference is only in the analysis. The standard forking lemma considers predicates <span class="math">\\pi_{v}(L_{v^{<em>}},x)</span> that are functions only of the challenges assigned by <span class="math">L_{v^{</em>}}</span> to left sibling nodes of <span class="math">v</span> and a single (fresh) <span class="math">x\\in\\mathcal{X}</span> rather than a vector, and are independently true with overwhelming probability.</p>

    <p class="text-gray-300">Just as in the standard forking lemma, the analysis is a simple union bound. First, the tree generation algorithm is transformed to a Monte Carlo algorithm that runs for <span class="math">t\\in\\mathsf{poly}(\\lambda)</span> steps and succeeds with overwhelming probability. The standard forking lemma is based on the observation that a <span class="math">t</span>-step algorithm makes at most <span class="math">t</span> samples from <span class="math">\\mathcal{X}</span> and thus the predicates hold true for all sampled challenges with probability at least <span class="math">1-t\\cdot\\mathsf{negl}(\\lambda)</span>. In our case, the analysis is very similar. Let <span class="math">L</span> denote the labelling returned by the Monte Carlo tree generation algorithm. We begin with the observation that this tree generation algorithm constructs the labelling in depth-first post-order. In particular, when the transcript tree generation algorithm visits a node <span class="math">v</span> at heigh <span class="math">h_{v}</span> it has already derived a partial labelling <span class="math">L_{v^{<em>}}</span>. It samples a random vector <span class="math">\\mathbf{x}\\in\\mathcal{X}^{h_{v}}</span> and attempts to derive a valid transcript for <span class="math">\\mathsf{lpath}_{v}</span> using this challenge vector <span class="math">\\mathbf{x}</span>. If it succeeds then it sets <span class="math">L(\\mathsf{lpath}_{v})_{0}=\\mathbf{x}</span>, otherwise the entire vector <span class="math">\\mathbf{x}</span> is discarded and it tries again starting from <span class="math">v</span>. Suppose there exists some <span class="math">v</span> such that <span class="math">\\pi_{v}(L_{v^{</em>}},L(\\mathsf{lpath}_{v})_{0})=0</span> and let <span class="math">v</span> be the lowest index node with this property. This would imply that there occurred an event where the algorithm had already constructed <span class="math">L_{v^{<em>}}</span> satisfying <span class="math">\\pi_{u}(L_{u^{</em>}},L(\\mathsf{lpath}_{u})_{0})=1</span> for all <span class="math">u\\leq v^{<em>}</span> and then sampled <span class="math">\\mathbf{x}\\leftarrow\\mathcal{X}^{h_{v}}</span>, setting <span class="math">L(\\mathsf{lpath}_{v})_{0}=\\mathbf{x}</span>, such that <span class="math">\\pi_{v}(L_{v^{</em>}},\\mathbf{x})=0</span>. However, by hypothesis this event occurs with probability <span class="math">\\mathsf{negl}(\\lambda)</span> over random <span class="math">\\mathbf{x}</span>. Since the algorithm runs for only <span class="math">t\\in\\mathsf{poly}(\\lambda)</span> steps, an event of this kind occurs with probability at most <span class="math">t\\cdot\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Thus, we obtain a Monte Carlo algorithm that returns a transcript tree where all the predicates are satisfied with overwhelming probability.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Lemma 11 (Path Predicate Forking Lemma).</h6>

    <p class="text-gray-300">Let <span class="math">(P,V)</span> be a <span class="math">\\mu</span>-round public-coin protocol with prover message space <span class="math">\\mathcal{M}</span> and verifier challenge space <span class="math">\\mathcal{X}</span>. For each node <span class="math">v\\in[1,N]</span> of a <span class="math">\\mu</span>-depth <span class="math">k</span>-ary balanced tree on <span class="math">N=\\mathsf{size}(\\mu,k)</span> nodes, let <span class="math">h_{v}</span> denote the height of <span class="math">v</span>. Let <span class="math">\\{\\pi_{v}:v\\in[1,N]\\}</span> denote a set of predicates, where <span class="math">\\pi_{v}(L_{v^{<em>}},\\mathbf{x})</span> is a function of the partial labelling <span class="math">L_{v^{</em>}}</span> and challenge vector <span class="math">\\mathbf{x}\\in\\mathcal{X}^{h_{v}}</span>, with the property that for any post-order labelling function <span class="math">L:[1,N]\\to\\mathcal{X}\\times\\mathcal{M}</span> and any <span class="math">v\\in[1,N]</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Pr_{\\mathbf{x}\\leftarrow\\mathcal{X}^{h_{v}}}[\\pi_{v}(L_{v^{*}},\\mathbf{x})=1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\forall_{u\\leq v^{<em>}}\\pi_{u}(L_{u^{</em>}},L(\\mathsf{lpath}_{u})_{0})=1]\\geq 1-\\delta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">t_{V}</span> denote the worst-case running time of the verifier’s decision algorithm <span class="math">D_{V}</span>. There is an algorithm <span class="math">\\mathsf{Tree}^{\\mathcal{A}}(\\mathsf{z})</span> that, given a security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and oracle access to an adversarial prover <span class="math">\\mathcal{A}</span> that causes <span class="math">V</span> to accept with probability <span class="math">\\epsilon</span> on public input <span class="math">\\mathsf{z}</span>, runs in time at most <span class="math">t=2\\lambda\\cdot\\frac{k^{\\mu}}{\\epsilon}\\cdot(\\mu+t_{V})</span> and with probability at least <span class="math">1-t\\cdot\\delta-2^{-\\lambda}</span> outputs a <span class="math">k</span>-ary transcript tree with post-order labeling <span class="math">L:[1,N]\\to\\mathcal{X}\\times\\mathcal{M}</span> such that <span class="math">\\pi_{v}(L_{v^{*}},L(\\mathsf{lpath}_{v})_{0})=1</span> for all <span class="math">v\\in[1,N]</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will first describe a Las Vegas tree-finding algorithm that runs in expected polynomial time as we can then transform it to a Monte Carlo algorithm with a finite runtime and overwhelming success probability.</p>

    <h4 id="sec-79" class="text-lg font-semibold mt-6">Tree finding algorithm</h4>

    <p class="text-gray-300">The tree-finding algorithm <span class="math">\\mathsf{Tree}(k,\\mathsf{z})</span> begins by sampling a random tape <span class="math">\\sigma</span> for the adversary. Let <span class="math">A(\\sigma)</span> denote the <em>deterministic</em> adversary with fixed random tape <span class="math">\\sigma</span>. For all <span class="math">i\\in[0,\\mu]</span> define <span class="math">T_{i}(\\sigma,k,\\mathsf{z},x_{1},...,x_{i})</span> as follows:</p>

    <p class="text-gray-300">Algorithm <span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=\\mu</span>: Simulate the protocol with <span class="math">\\mathcal{A}(\\sigma)</span> as the prover and fixing the verifier’s challenges <span class="math">\\mu</span> ordered challenges to the values <span class="math">x_{1},...,x_{\\mu}</span>. If the verifier outputs <span class="math">1</span> during this simulation then return the protocol transcript <span class="math">tr</span>, and otherwise return fail.</li>

      <li>Else if <span class="math">0\\leq i&lt;\\mu</span>: Sample <span class="math">x_{i+1}\\leftarrow\\mathcal{X}</span> and run <span class="math">T_{i}(\\sigma,k,y,x_{1},...,x_{i+1})</span>. This either returns fail or a transcript tree denoted tree. If it returns fail, then output fail. Otherwise, save the pair <span class="math">(x_{i+1},\\textsf{tree})</span>. If <span class="math">i&lt;\\mu-1</span> then tree is a tree of accepting transcripts that share a common prefix for the first <span class="math">i+1</span> rounds, which includes the challenges <span class="math">x_{1},...,x_{i+1}</span>. If <span class="math">i+1=\\mu</span> then tree is a single accepting transcript. Repeat this process as many times as needed, each time sampling a fresh <span class="math">x^{\\prime}_{i+1}</span>, running <span class="math">T_{i}(\\sigma,y,x_{1},...,x^{\\prime}_{i+1})</span>, ignoring the runs that fail, saving the succesful challenge/tree pairs until <span class="math">k</span> pairs have been recorded. Together the transcripts in all <span class="math">k</span> recorded trees form one larger tree of accepting transcripts that share a commmon prefix <span class="math">\\textsf{tr}_{\\textsf{pre}}</span> for the first <span class="math">i</span> rounds of messages with fixed challenges <span class="math">x_{1},...,x_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">Tree<span class="math">(k,\\mathbf{z})</span> repeatedly samples <span class="math">\\sigma</span> and runs <span class="math">T_{0}(\\sigma,k,\\mathbf{z})</span> until it outputs a tree of accepting transcripts.</p>

    <p class="text-gray-300">We now analyze the expected runtime of <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> and success probability of returning an <span class="math">k</span>-ary tree of accepting transcripts given that <span class="math">\\mathcal{A}</span> succeeds with probability <span class="math">\\epsilon</span>. <span class="math">T_{0}(\\sigma,k,\\mathbf{z})</span> returns fail iff the first iteration of each subroutine <span class="math">T_{i}</span> returns fail for <span class="math">i=1</span> to <span class="math">\\mu</span>. The probability this happens is equal to the probability that <span class="math">T_{\\mu}(\\sigma,y,x_{1},...,x_{\\mu})</span> outputs fail for a uniformly distributed challenge tuple <span class="math">(x_{1},...,x_{\\mu})</span>. This is equal to the failure probability of <span class="math">\\mathcal{A}(\\sigma)</span>, i.e. <span class="math">1-\\epsilon</span>. Thus, <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> calls <span class="math">T_{0}</span> in expectation <span class="math">1/\\epsilon</span> times. Letting <span class="math">t_{0}</span> be a random variable for the runtime of <span class="math">T_{0}(\\sigma,\\mathbf{z})</span> over random <span class="math">\\sigma</span>, the expected runtime of <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> is <span class="math">t_{0}/\\epsilon</span>.</p>

    <p class="text-gray-300">It remains to analyze the expected runtime <span class="math">\\mathbb{E}[t_{0}]</span> of <span class="math">T_{0}(\\sigma,\\mathbf{z})</span>. Each call to <span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span> for <span class="math">i\\in[1,\\mu]</span> that occurs in the execution trace of <span class="math">T_{0}(\\sigma,k,\\mathbf{z})</span> is on i.i.d. uniformly distributed challenges <span class="math">x_{1},...,x_{i}</span>. Let <span class="math">t_{i}</span> be a random variable denoting the runtime of <span class="math">T_{i}(\\sigma,k,\\mathbf{z},x_{1},...,x_{i})</span> over a uniformly distributed <span class="math">\\sigma</span>. We omit the time to sample a random challenge from the runtime analysis as this will only affect the runtime up to a constant factor. Since <span class="math">T_{\\mu}(\\sigma,k,\\mathbf{z},\\mathbf{x}_{\\mu})</span> makes <span class="math">\\mu</span> calls to the oracle <span class="math">\\mathcal{A}</span> and one call to the verifier’s decision algorithm <span class="math">D_{V}</span> its runtime is at most <span class="math">\\mu+t_{V}</span>, where <span class="math">t_{V}</span> is the worst case running time of <span class="math">D_{V}</span>.</p>

    <p class="text-gray-300">For <span class="math">i&lt;\\mu</span>, <span class="math">T_{i}(\\sigma,k,y,\\mathbf{x}_{i})</span> outputs fail iff the first call to each <span class="math">T_{j}</span> subroutine for <span class="math">j\\in[i+1,\\mu]</span> returns fail, in which case the runtime is <span class="math">t_{\\mathcal{A}}</span>. The probability <span class="math">T_{i}(\\sigma,k,\\mathbf{z},\\mathbf{x}_{i})</span> outputs fail for random <span class="math">\\sigma</span> and <span class="math">\\mathbf{x}_{i}</span> is again equal to the failure probability of <span class="math">\\mathcal{A}(\\sigma)</span>, i.e. <span class="math">1-\\epsilon</span>. If it does not output fail, then in expectation it runs an additional <span class="math">(k-1)/\\epsilon</span> iterations of <span class="math">T_{i+1}(\\sigma,k,\\mathbf{z},\\mathbf{x}_{i},x_{i+1})</span> sampling a fresh <span class="math">x_{i+1}</span> for each iteration. Thus, the expected runtime <span class="math">\\mathbb{E}(t_{i})</span> is:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[(1-\\epsilon)\\cdot t_{\\mathcal{A}}+(k-1)\\cdot t_{i+1}]\\leq\\mathbb{E}[t_{i+1}\\cdot k]</span></p>

    <p class="text-gray-300">This recurrence relation shows:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[t_{0}]\\leq\\mathbb{E}[t_{\\mu}\\cdot k^{\\mu}]</span></p>

    <p class="text-gray-300">Thus, we have shown that the expected runtime of <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> is <span class="math">\\mathbb{E}[t]\\leq\\frac{k^{\\mu}}{\\epsilon}\\cdot(\\mu+t_{V})</span>.</p>

    <p class="text-gray-300">By standard techniques, the Las Vegas algorithm <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> may be transformed to a Monte Carlo algorithm that runs for <span class="math">2\\lambda\\cdot\\mathbb{E}[t]</span>) steps and succeeds except with probability <span class="math">1-2^{-\\lambda}</span>.</p>

    <h4 id="sec-80" class="text-lg font-semibold mt-6">Transcript tree property analysis</h4>

    <p class="text-gray-300">The transcript tree labels returned by <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> are computed in depth-first post-order by the Monte Carlo tree generation algorithm. Let <span class="math">L</span> denote this post-order labeling. Consider any node <span class="math">v</span> that is labeled with challenge <span class="math">L(v)_{0}=x</span> in the tree. Let <span class="math">i</span> denote the level of <span class="math">v</span> within the tree and let <span class="math">\\mathbf{x}=(x_{1},..,x_{i-1},x,x_{i+1},...,x_{\\mu})</span> denote the vector of challenge labels assigned to the path starting from the root to <span class="math">v</span> and following the left-most path down the tree from <span class="math">v</span>. During the execution of <span class="math">\\textsf{Tree}(k,\\mathbf{z})</span> the following event occurred: immediately after <span class="math">x</span> was sampled as a candidate label for <span class="math">v</span>, the</p>

    <p class="text-gray-300">challenges <span class="math">x_{i+1},...,x_{\\mu}</span> were sampled uniformly and independently such that <span class="math">\\mathcal{A}(\\sigma,k,\\mathsf{z},\\mathbf{x})</span> succeeded (i.e., produced a valid transcript). If this event had not occurred (i.e., <span class="math">\\mathcal{A}(\\sigma,k,\\mathsf{z},\\mathbf{x})</span> failed) then <span class="math">x</span> would have been discarded and the process would have been repeated.</p>

    <p class="text-gray-300">In other words, when the transcript tree generation algorithm visits a node <span class="math">v</span> it has already derived a partial labelling <span class="math">L_{v^{<em>}}</span> for <span class="math">[1,v^{</em>}]</span> where <span class="math">v^{<em>}\\leq v</span> is not in any subtree extending from <span class="math">v</span>. It samples a random vector <span class="math">\\mathbf{x}\\in\\mathcal{X}^{h_{v}}</span> and attempts to derive a valid transcript for <span class="math">\\mathsf{lpath}_{v}</span> using this challenge vector <span class="math">\\mathbf{x}</span>. If it succeeds then it sets <span class="math">L(\\mathsf{lpath}_{v})_{0}=\\mathbf{x}</span>, otherwise the entire vector <span class="math">\\mathbf{x}</span> is discarded and it tries again starting from <span class="math">v</span>. Suppose there exists some <span class="math">v</span> such that <span class="math">\\pi_{v}(L_{v^{</em>}},L(\\mathsf{lpath}_{v})_{0})=0</span> and let <span class="math">v</span> be the lowest index node with this property. This would imply that there occurred an event where the algorithm had already partially constructed <span class="math">L</span> such that <span class="math">\\pi_{u}(L_{u^{<em>}},L(\\mathsf{lpath}_{u})_{0})=1</span> for all <span class="math">u\\leq v^{</em>}</span> and then subsequently sampled <span class="math">\\mathbf{x}\\leftarrow\\mathcal{X}^{h_{v}}</span>, setting <span class="math">L(\\mathsf{lpath}_{v})_{0}=\\mathbf{x}</span>, such that <span class="math">\\pi_{v}(L_{v^{*}},\\mathsf{x})=0</span>. However, by hypothesis this event occurs with probability <span class="math">\\delta</span> over random <span class="math">\\mathbf{x}</span>. The algorithm runs for at most <span class="math">t=\\frac{2\\lambda}{V}k^{\\mu}\\cdot(\\mu+t_{V})</span> steps in total, hence by a union bound the probability that an event of this kind occurs at all is at most <span class="math">t\\cdot\\delta</span>.</p>

    <p class="text-gray-300">Thus, we obtain a Monte Carlo extraction algorithm that returns a transcript tree where all the predicates are satisfied with overwhelming probability (for appropriate setting of the parameters). More precisely, for any security parameter <span class="math">\\lambda\\in\\mathbb{N}</span> and for <span class="math">t=\\frac{2\\lambda}{V}\\cdot k^{\\mu}\\cdot(\\mu+t_{V})</span> the extraction algorithm runs in time at most <span class="math">t</span> and (by a union bound) succeeds in returning a transcript tree labeling <span class="math">L</span> where, for all <span class="math">v</span>, <span class="math">\\pi_{v}(L_{v^{*}},L(\\mathsf{lpath}_{v})_{0})=1</span> with probability at least <span class="math">1-t\\cdot\\delta-2^{-\\lambda}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">A.5 Knowledge Soundness</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An NP relation <span class="math">\\mathcal{R}</span> is a subset of strings <span class="math">x,w\\in\\{0,1\\}^{*}</span> such that there is a decision algorithm to decide <span class="math">(x,w)\\in\\mathcal{R}</span> that runs in time polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The language of </span>\\mathcal{R}<span class="math">, denoted </span>\\mathcal{L}_{R}<span class="math">, is the set </span>\\{x\\in\\{0,1\\}^{<em>}:\\exists w\\in\\{0,1\\}^{</em>}\\text{ s.t. }(x,w)\\in\\mathcal{R}\\}<span class="math">. The string </span>w<span class="math"> is called the <em>witness</em> and </span>x<span class="math"> the <em>instance</em>. An interactive proof of knowledge for an NP relation </span>\\mathcal{R}<span class="math"> is a special kind of two-party interactive protocol between a prover denoted </span>\\mathcal{P}<span class="math"> and a verifier denoted </span>\\mathcal{V}<span class="math">, where </span>\\mathcal{P}<span class="math"> has a private input </span>w<span class="math"> and both parties have a common public input </span>x<span class="math"> such that </span>(x,w)\\in\\mathcal{R}<span class="math">. Informally, the protocol is <em>complete</em> if </span>\\mathcal{P}(x,w)<span class="math"> always causes </span>\\mathcal{V}(x)<span class="math"> to output </span>1<span class="math"> for any </span>(x,w)\\in\\mathcal{R}<span class="math">. The protocol is <em>knowledge sound</em> if there exists an extraction algorithm </span>\\mathcal{E}<span class="math"> called the <em>extractor</em> such that for every </span>x<span class="math"> and adversarial prover </span>\\mathcal{A}<span class="math"> that causes </span>\\mathcal{V}(x)<span class="math"> to output </span>1<span class="math"> with non-negligible probability, </span>\\mathcal{E}<span class="math"> outputs </span>w<span class="math"> such that </span>(x,w)\\in\\mathcal{R}<span class="math"> with overwhelming probability given access to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-82" class="text-base font-medium mt-4">Definition 7 (Interactive Proof of Knowledge).</h6>

    <p class="text-gray-300">An interactive protocol <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> between a prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> is a proof of knowledge for a relation <span class="math">\\mathcal{R}</span> with knowledge error <span class="math">\\delta:\\mathbb{N}\\rightarrow[0,1]</span> if the following properties hold, where on common input <span class="math">x</span> and prover witness <span class="math">w</span> the output of the verifier is denoted by the random variable <span class="math">\\langle\\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: for all <span class="math">(x,w)\\in\\mathcal{R}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\ \\langle\\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle=1\\right]=1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-Knowledge Soundness: There exists a polynomial <span class="math">\\mathsf{poly}(\\cdot)</span> and a probabilistic oracle machine <span class="math">\\mathcal{E}</span> called the <em>extractor</em> such that given oracle access to any adversarial interactive prover algorithm <span class="math">\\mathcal{A}</span> and any input <span class="math">x\\in\\mathcal{L}_{R}</span> the following holds: if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbb{P}\\left[\\langle\\mathcal{A}(x),\\mathcal{V}(x)\\rangle=1\\right]=\\epsilon(x)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then <span class="math">\\mathcal{E}^{\\mathcal{A}}(x)</span> with oracle access to <span class="math">\\mathcal{A}</span> runs in time $\\frac{\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}<span class="math"> and outputs </span>w<span class="math"> such that </span>(x,w)\\in R<span class="math"> with probability at least </span>1-\\frac{\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An interactive proof is “knowledge sound”, or simply a “proof of knowledge”, if has negligible knowledge error <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Remark 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 7 places no restriction on the runtime of the adversary, however, it does not guarantee extraction from an adversary that succeeds with sufficiently small <span class="math">\\epsilon(x)</span> such that $\\epsilon(x)\\leq\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For </span>\\mathcal{R}<span class="math"> in NP, this definition of knowledge soundness implies the alternative formulation of Bellare and Goldreich <em>[x1]</em>, which says that the protocol has knowledge error </span>\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> if there exists an extractor that succeeds in expected time </span>\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math">. An extractor which succeeds with probability </span>p=1-\\frac{\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}<span class="math"> in </span>t=\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)}<span class="math"> steps can run repeatedly (for </span>t<span class="math"> steps per iteration) on fresh randomness until it obtains a witness for the relation, which it can verify efficiently. It will succeed in an expected </span>\\frac{t}{p}=\\frac{\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> steps. Finally, this has been shown to imply another equivalent formulation which requires the extractor to run in </span>O(\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> steps and succeed with probability </span>\\frac{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}<span class="math"> for some polynomial </span>q<span class="math">. It is easy to see this implies the former because such an extractor can be repeated, succeeding in expected time </span>\\frac{q\\cdot\\textsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x)-\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-84" class="text-lg font-semibold mt-6">Interactive arguments</h4>

    <p class="text-gray-300">Knowledge soundness holds against unbounded provers. The DARK protocol does not satisfy knowledge soundness because it relies on the computational binding property of cryptographic commitments. Interactive proofs that are only secure against computationally bounded adversaries are called <em>interactive arguments</em>. Adapting Definition 7 for arguments is more subtle than simply restricting the runtime of the adversary. The issue comes from the fact that the knowledge soundness definition quantifies the success of the extractor over all inputs <span class="math">x</span>. For example, there could exist an input <span class="math">x</span> that encodes the factorization of an RSA modulus which allows the adversarial prover to break the binding property of commitments that are based on the difficulty of factoring. For this input, the adversarial prover could succeed while the extractor would fail. This particular problem is fixed by requiring the adversary to generate the input <span class="math">x</span>. If the trapdoor is exponentially hard to compute the polynomial time adversary will not be able to embed the trapdoor in <span class="math">x</span> with non-negligible probability. (See Damgård and Fujisaki <em>[x10]</em> for a broader discussion of these issues).</p>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">Witness-extended emulation</h4>

    <p class="text-gray-300">A property called witness-extended emulation <em>[x20]</em> strengthens the knowledge-soundness definition so that the extractor outputs not only a witness but also a simulated transcript of the messages between the prover and verifier. This property is helpful for composability. In particular, if the interactive proof is used as a sub-protocol within a larger protocol, it may be necessary in the security analysis to construct a simulator that needs to both obtain the adversary’s witness as well as simulate its view in the subprotocol. Fortunately, Lindell <em>[x20]</em> proved that every knowledge sound protocol also satisfies witness-extended emulation. Groth and Ishai <em>[x16]</em> further adapt the definition of witness-extended emulation for interactive arguments with setup (i.e., SRS model). This is the definition we will use in the present work.</p>

    <p class="text-gray-300">Before presenting the definition we will introduce some useful notations. In the SRS model, there is a setup algorithm <span class="math">\\mathsf{Setup}</span> that generates public parameters <span class="math">\\mathsf{pp}</span> that are common inputs to the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. The setup, which may or may not require a trusted party to sample trapdoor secrets, typically generates these parameters based on a security parameter <span class="math">\\lambda</span> necessary for computational security. Without loss of generality, the length of <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda)</span> is at least <span class="math">\\lambda</span> bits. For any prover algorithm <span class="math">\\mathcal{P}^{<em>}</span> interacting with a verifier algorithm <span class="math">\\mathcal{V}</span>, which may deviate arbitrarily from the honest prover algorithm <span class="math">\\mathcal{P}</span>, let <span class="math">\\mathsf{Record}(\\mathcal{P}^{</em>},\\mathsf{pp},x,\\mathsf{st})</span> denote the message transcript between <span class="math">\\mathcal{P}^{<em>}</span> and <span class="math">\\mathcal{V}</span> on shared inputs <span class="math">x</span> and <span class="math">\\mathsf{pp}</span> and initial prover state <span class="math">\\mathsf{st}</span>. For <span class="math">\\mathsf{tr}\\leftarrow\\mathsf{Record}(\\mathcal{P}^{</em>},\\mathsf{pp},x,\\mathsf{st})</span> let <span class="math">V_{\\mathsf{check}}(\\mathsf{tr})</span> denote the verifier’s decision algorithm to accept or reject the transcript. Furthermore, let <span class="math">\\mathcal{E}^{\\mathsf{Record}(\\mathcal{P}^{*},\\mathsf{pp},x,\\mathsf{st})}</span> denote a machine <span class="math">\\mathcal{E}</span> with a transcript oracle for this interaction that can be rewound to any round and run again on fresh verifier randomness.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition 8 (Witness-extended emulation <em>[x16, x20]</em>).</h6>

    <p class="text-gray-300">An interactive proof in the SRS model <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> satisfies witness-extended emulation for relation <span class="math">\\mathcal{R}</span> if for every deterministic polynomial time <span class="math">\\mathcal{P}^{*}</span> there exists an expected polynomial time emulator <span class="math">\\mathcal{E}</span> such that for any non-uniform adversary <span class="math">\\mathcal{A}</span> and distinguisher <span class="math">\\mathcal{D}</span> that runs in time <span class="math">\\mathsf{poly}(\\lambda)</span> the</p>

    <p class="text-gray-300">following condition holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ \\mathcal {D} (\\mathsf {t r}) = 1: &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; \\mathsf {t r} \\leftarrow \\mathsf {R e c o r d} (\\mathcal {P} ^ {*}, \\mathsf {p p}, x, \\mathsf {s t}) \\end{array} \\right] \\approx_ {\\lambda}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {D} (\\mathsf {t r}) = 1 \\text {a n d} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ V _ {\\mathsf {c h e c k}} (\\mathsf {t r}) = 1 \\Rightarrow (x, w) \\in \\mathcal {R}: &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {t r}, w) \\leftarrow \\mathcal {E} ^ {\\mathsf {R e c o r d} (\\mathcal {P} ^ {*}, \\mathsf {p p}, x, \\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right]</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">X\\approx_{\\lambda}Y</span>  denotes that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X - Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 12 (Lindell [Lin01]). Any proof of knowledge for relation  <span class="math">\\mathcal{R}</span>  also satisfies witness-extended emulation for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Lemma 13. Let  <span class="math">\\mathcal{R}</span>  denote any NP relation. Given a commitment scheme  <span class="math">\\mathsf{com} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span>  for any  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(\\lambda)</span>  let  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span>  denote the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} ^ {\\prime} (\\mathsf {p p}) = \\left\\{\\left(\\mathbf {x}, \\mathbf {w}\\right): \\mathcal {R} (\\mathbf {x}, \\mathbf {w}) = 1 \\vee [ \\mathbf {w} = (C, \\sigma_ {1}, \\sigma_ {2}) \\wedge \\sigma_ {1} \\neq \\sigma_ {2} \\wedge \\operatorname {O p e n} (\\mathsf {p p}, C, \\sigma_ {1}) = \\operatorname {O p e n} (\\mathsf {p p}, C, \\sigma_ {2}) = 1 ] \\right\\}</span></div>

    <p class="text-gray-300">Let  <span class="math">\\Pi(\\mathsf{pp})</span>  denote the interactive protocol between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  parameterized by the setup parameter  <span class="math">\\mathsf{pp}</span> . If for all  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda)</span>  the protocol  <span class="math">\\Pi(\\mathsf{pp})</span>  is a proof of knowledge (Definition 7) for  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span>  then the tuple  <span class="math">(\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span>  as an interactive proof with setup satisfies witness-extended emulation (Definition 8) for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Proof. By Lemma 12 a knowledge sound interactive proof for  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span>  also satisfies witness-extended emulation for  <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span> . It remains to show that this implies witness-extended emulation for  <span class="math">\\mathcal{R}</span> . It suffices to show that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {D} (\\mathsf {t r}) = 1 \\text {a n d} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ V _ {\\mathsf {c h e c k}} (\\mathsf {t r}) = 1 \\Rightarrow (x, w) \\in \\mathcal {R}: &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {t r}, w) \\leftarrow \\mathcal {E} ^ {\\mathsf {R e c o r d} (\\mathcal {P} ^ {*}, \\mathsf {p p}, x, \\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right] \\approx_ {\\lambda}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathcal {D} (\\mathsf {t r}) = 1 \\text {a n d} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ V _ {\\mathsf {c h e c k}} (\\mathsf {t r}) \\Rightarrow (x, w) \\in \\mathcal {R} ^ {\\prime} (\\mathsf {p p}) &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; (\\mathsf {t r}, w) \\leftarrow \\mathcal {E} ^ {\\mathsf {R e c o r d} (\\mathcal {P} ^ {*}, \\mathsf {p p}, x, \\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right]</span></div>

    <p class="text-gray-300">The difference between these two probabilities is bounded by the probability, over the distribution on the right side of the equation, that  <span class="math">(\\mathbf{x},\\mathbf{w})\\in \\mathcal{R}&#x27;(\\mathsf{pp})</span>  but  <span class="math">(\\mathbf{x},\\mathbf{w})\\notin \\mathcal{R}</span> . This event implies that  <span class="math">\\mathbf{w}</span>  encodes a break to the commitment scheme with parameters  <span class="math">\\mathsf{pp}</span> . Since  <span class="math">\\mathcal{A}</span> ,  <span class="math">P^{<em>}</span> , Setup and  <span class="math">\\mathcal{E}</span>  all run in time poly  <span class="math">(\\lambda)</span>  this occurs with probability at most  <span class="math">\\mathrm{negl}(\\lambda)</span>  over randomly sampled  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(\\lambda)</span>  by the computational binding property of the commitment scheme. More precisely, supposing that the difference between these two probabilities is  <span class="math">\\epsilon (\\lambda)</span> , then we can use  <span class="math">\\mathcal{A}</span> ,  <span class="math">P^{</em>}</span> , and  <span class="math">\\mathcal{E}</span>  to construct an algorithm  <span class="math">\\mathcal{A}&#x27;</span>  which on input  <span class="math">\\mathsf{pp}\\gets \\mathsf{Setup}(\\lambda)</span>  simulates  <span class="math">(x,\\mathsf{st})\\gets \\mathcal{A}(\\mathsf{pp})</span>  and  <span class="math">(\\mathsf{tr},w)\\gets \\mathcal{E}^{\\mathrm{Record}(\\mathcal{P}^{*},\\mathsf{pp},x,\\mathsf{st})}(\\mathsf{pp},x)</span>  returning  <span class="math">w</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ w = (C, \\sigma_ {1}, \\sigma_ {2}) \\wedge \\sigma_ {1} \\neq \\sigma_ {2} \\wedge \\mathsf {V f} _ {\\mathsf {p p}} (C, \\sigma_ {1}) = \\mathsf {V f} _ {\\mathsf {p p}} (C, \\sigma_ {2}) = 1: \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ w \\leftarrow \\mathcal {A} ^ {\\prime} (\\mathsf {p p}) \\end{array} \\right] = \\epsilon (\\lambda)</span></div>

    <p class="text-gray-300">If  <span class="math">\\epsilon (\\lambda)</span>  is non-negligible this contradicts the binding property of the commitment scheme.</p>

    <p class="text-gray-300">Zero knowledge We recall the definition of honest verifier zero-knowledge (HVZK) for interactive proofs. HVZK only considers simulating the view of a verifier that follows the protocol honestly. The Fiat-Shamir transform compiles public-coin proofs that have HVZK into non-interactive proofs that have statistical zero-knowledge (for malicious verifiers).</p>

    <p class="text-gray-300">Definition 9 (HVZK for interactive arguments). Let  <span class="math">\\mathsf{View}_{(\\mathcal{P}(x,w),\\mathcal{V}(x))}</span>  denote the view of the verifier in an interactive protocol on common input  <span class="math">x</span>  and prover witness input  <span class="math">w</span> . The interactive protocol has  <span class="math">\\delta</span> -statistical honest verifier zero-knowledge if there exists a probabilistic polynomial time algorithm  <span class="math">\\mathcal{S}</span>  such that for every  <span class="math">(x,w)\\in \\mathcal{R}</span> , the distribution  <span class="math">\\mathcal{S}(x)</span>  is  <span class="math">\\delta</span> -close to  <span class="math">\\mathsf{View}_{(\\mathcal{P}(x,w),\\mathcal{V}(x))}</span>  (as distributions over the randomness of  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> ).</p>

    <p class="text-gray-300">B Almost-Special-Soundness Theorems</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Definition 10 (Almost-Special-Soundness).</h6>

    <p class="text-gray-300">A <span class="math">\\mu</span>-round public-coin interactive proof for a relation <span class="math">\\mathcal{R}</span> with challenge space of size <span class="math">2^{\\lambda}</span> is <span class="math">(k^{(\\mu)},\\delta(\\cdot),\\mathsf{com},\\phi)</span>-almost-special-sound if it satisfies the following conditions with respect to some commitment scheme <span class="math">\\mathsf{com}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> with message space <span class="math">\\mathcal{M}</span> and opening space <span class="math">\\mathcal{W}</span>, a pair of predicates <span class="math">\\phi=(\\phi_{a},\\phi_{b})</span> where <span class="math">\\phi_{a},\\phi_{b}:[\\mu]\\times\\mathcal{M}\\to\\{0,1\\}</span>, and a negligible function <span class="math">\\delta:\\mathbb{N}\\to\\mathbb{R}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The setup for the interactive proof includes generation of the public parameters for the commitment scheme <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{com}.\\mathsf{Setup}(\\lambda)</span>.</li>

      <li>In any accepting transcript, the prover’s <span class="math">i</span>th round message for <span class="math">i\\in[1,\\mu)</span> is a valid commitment <span class="math">\\mathcal{C}_{i}</span> for the scheme <span class="math">\\mathsf{com}</span>, and the final prover message is a commitment <span class="math">\\mathcal{C}_{\\mu}</span> together with a valid opening <span class="math">(m_{\\mu},o_{\\mu})</span> such that <span class="math">\\mathsf{com}.\\mathsf{Open}(\\mathsf{pp},C_{\\mu},m_{\\mu},o_{\\mu})=1</span> and <span class="math">\\phi_{a}(\\mu,m_{\\mu})=1</span>.</li>

      <li>There is a <span class="math">poly(\\lambda)</span> time algorithm <span class="math">\\mathsf{Extract}(i,\\nu,C_{\\nu},\\mathsf{openSubtree})\\to(m,o)</span> where <span class="math">i\\in[1,\\mu]</span> and <span class="math">\\mathsf{openSubtree}</span> is a list of openings for the commitments on all internal nodes (excluding the root and leaves) of a <span class="math">k</span>-ary depth <span class="math">\\mu-i</span> subtree of a transcript tree rooted at a node <span class="math">\\nu</span> on the <span class="math">i</span>th level with commitment label <span class="math">C_{\\nu}</span>. If the challenge labels on the first two children of any node in the subtree are distinct, and the openings for all internal (non-root) nodes of the subtree satisfy predicate <span class="math">\\phi_{a}</span> (i.e., for any <span class="math">j&gt;i</span> and node <span class="math">u</span> on the <span class="math">j</span>th level of the transcript tree that is a member of this subtree, its opening <span class="math">(m_{u},o_{u})</span> in <span class="math">\\mathsf{openSubtree}</span> satisfies <span class="math">\\phi_{a}(j,m_{u})=1</span>) then the algorithm returns a valid opening <span class="math">(m,o)</span> for <span class="math">c_{\\nu}</span> such that <span class="math">\\phi_{b}(i,m)=1</span>.</li>

      <li><span class="math">\\mathsf{Extract}(0,x,\\mathsf{openTree})\\to w</span> takes as inputs openings for the commitments on all nodes in an entire transcript tree satisfying predicate <span class="math">\\phi_{a}</span> (same condition as above for subtrees) and returns a witness <span class="math">\\mathsf{w}</span> for the public input <span class="math">\\mathsf{x}</span> such that <span class="math">\\mathcal{R}(\\mathsf{x},\\mathsf{w})=1</span>.</li>

      <li><span class="math">\\mathsf{Extend}(i,m,\\alpha_{1},..,\\alpha_{\\mu-i})</span> is a deterministic <span class="math">\\mathsf{poly}(\\lambda)</span>-time algorithm that is given an index <span class="math">i\\in[\\mu-1]</span>, a message <span class="math">m</span> in the message space of the commitment scheme <span class="math">\\mathsf{com}</span>, <span class="math">\\mu-i</span> challenges from <span class="math">\\mathcal{X}</span>, and outputs <span class="math">\\mu-i</span> messages <span class="math">m^{\\prime}_{1},...,m^{\\prime}_{\\mu-i}</span> in the message space of the commitment scheme.</li>

      <li>For any <span class="math">i\\in[\\mu-1]</span> and <span class="math">m</span> where <span class="math">\\phi_{a}(i,m)=0</span>, the probability over <span class="math">\\alpha_{i},...,\\alpha_{\\mu}</span> sampled uniformly i.i.d. from <span class="math">\\mathcal{X}</span> that the last message <span class="math">m^{\\prime}_{\\mu-i}</span> in the list returned by <span class="math">\\mathsf{Extend}(i,m)</span> satisfies <span class="math">\\phi_{a}(\\mu,m^{\\prime}_{\\mu-i})=1</span> is bounded by <span class="math">\\delta(\\lambda)</span>.</li>

      <li><span class="math">\\mathsf{Break}(i,m,\\alpha_{1},...,\\alpha_{\\mu},C_{0},...,C_{\\mu},(m_{i},o_{i}),...,(m_{\\mu},o_{\\mu}))</span> first runs <span class="math">\\mathsf{Extend}(i,m,\\alpha_{i},..,\\alpha_{\\mu})</span>, which returns messages <span class="math">m^{\\prime}_{1},...,m^{\\prime}_{\\mu-i}</span>. If either <span class="math">\\phi_{b}(i,m_{i})=0</span> or <span class="math">\\forall_{j}</span> <span class="math">m^{\\prime}_{j}=m_{i+j-1}</span> then it outputs <span class="math">\\bot</span>. Otherwise it outputs an attempted opening <span class="math">(m^{\\prime},o^{\\prime})</span> of <span class="math">C_{j}</span> for some index <span class="math">j\\geq i</span> where <span class="math">m^{\\prime}\\neq m_{j}</span>.</li>

      <li>For any <span class="math">i\\in[\\mu-1]</span>, given a valid (accepting) transcript with commitments <span class="math">\\mathbf{C}=(C_{0},...,C_{\\mu})</span>, round challenges <span class="math">\\mathbf{r}=(\\alpha_{1},...,\\alpha_{\\mu})</span>, and openings <span class="math">\\mathsf{open}=((m_{i},o_{i}),...,(m_{\\mu},o_{\\mu}))</span> to the last <span class="math">\\mu-i+1</span> commitments, where <span class="math">\\phi_{b}(i,m_{i})=1</span> and <span class="math">\\phi_{a}(j,m_{j})=1</span> for all <span class="math">j\\in[i+1,\\mu]</span>, either <span class="math">\\mathsf{Extend}(i,m_{i},\\alpha_{i+1},...,\\alpha_{\\mu})</span> returns <span class="math">m_{i+1},...,m_{\\mu}</span> or <span class="math">\\mathsf{Break}(i,m_{i},\\mathbf{r},\\mathbf{C},\\mathsf{open})</span> returns an opening <span class="math">(m^{\\prime},o^{\\prime})</span> of some <span class="math">C_{j}</span> to a conflicting message <span class="math">m^{\\prime}\\neq m_{j}\\in\\mathcal{M}</span>, which breaks the binding of the commitment scheme over <span class="math">\\mathcal{M}</span>.</li>

    </ol>

    <p class="text-gray-300">Short-hand notation: An interactive proof is <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-sound if it is <span class="math">(k^{(\\mu)},\\delta,\\mathsf{com},\\phi)</span>-almost-special-sound for some commitment scheme <span class="math">\\mathsf{com}</span> and some predicate pair <span class="math">\\phi</span>. We may omit <span class="math">\\delta</span> and simply write <span class="math">k^{(\\mu)}</span>-almost-special-soundness if this holds for some negligible function <span class="math">\\delta:\\mathbb{N}\\to\\mathbb{R}</span>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Any special sound protocol satisfies almost-special-soundness as 3) essentially captures the special soundness definition. More precisely a <span class="math">k^{(\\mu)}</span>-special sound satisfies <span class="math">k^{(\\mu)}</span>-almost-special-soundness by setting the commitment scheme to be trivial (i.e., identity function) and the <span class="math">i</span>th round commitment <span class="math">C_{i}</span> to the prover’s <span class="math">i</span>th round message and setting the predicates <span class="math">\\phi_{a}=1,\\phi_{b}=0</span> to be trivial as well (i.e., always return 1 and 0 respectively). The algorithm <span class="math">\\mathsf{Extend}</span> can output an arbitrary set of messages because the condition on the algorithm is vacuously true as <span class="math">\\phi_{a}(i,m)\\neq 0</span> for any <span class="math">(i,m)</span>. The algorithm <span class="math">\\mathsf{Extract}(i,\\nu,C_{\\nu},\\ast)</span> is</p>

    <p class="text-gray-300">trivial because <span class="math">C_{\\nu}</span> is the message itself. The algorithm <span class="math">\\mathsf{Break}</span> is also trivial as <span class="math">\\phi_{\\mathsf{b}}</span> is always <span class="math">0</span>. The algorithm <span class="math">\\mathsf{Extract}(0,x,openTree)\\to w</span> exists by the definition of <span class="math">k^{(\\mu)}</span>-special soundness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 7. If a <span class="math">\\mu</span>-round interactive proof for a relation <span class="math">\\mathcal{R}</span> with <span class="math">\\lambda</span>-bit challenges, $\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, and verifier decision algorithm runtime </span>t_{V}\\in\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda)<span class="math"> on input </span>\\mathsf{x}\\in\\mathcal{L}_{\\mathcal{R}}<span class="math"> and parameters </span>\\mathsf{pp}\\leftarrow\\mathsf{com.Setup}(\\lambda)<span class="math"> is </span>(k^{(\\mu)},\\delta,\\mathsf{com},\\phi)<span class="math">-almost-special-sound then for </span>\\delta^{\\prime}(\\lambda)=2\\lambda(k+1)^{\\mu}(\\mu+t_{V})\\cdot\\max(\\delta(\\lambda),k\\cdot 2^{-\\lambda})+2^{-\\lambda}<span class="math"> it is </span>\\delta^{\\prime}$-knowledge sound for the modified relation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{R}^{\\prime}(\\mathsf{pp})=\\{(\\mathsf{x},\\mathsf{w}):\\mathcal{R}(\\mathsf{x},\\mathsf{w})=1\\ \\ \\vee\\ \\mathsf{w}\\in\\mathcal{L}_{\\mathsf{break}}(\\mathsf{pp})\\}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\mathsf{break}}(\\mathsf{pp})=\\{(\\mathcal{C},\\sigma_{1},\\sigma_{2}):\\sigma_{1}\\neq\\sigma_{2}\\ \\wedge\\ \\mathsf{Open}(\\mathsf{pp},\\mathcal{C},\\sigma_{1})=\\mathsf{Open}(\\mathsf{pp},\\mathcal{C},\\sigma_{2})=1\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 3. <span class="math">\\delta^{\\prime}(\\lambda)</span> is a negligible function if <span class="math">\\delta(\\lambda)</span> is negligible, assuming <span class="math">k\\in O(1)</span>, $\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, </span>t_{V}\\in\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda)<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Lemma 13, this theorem has the following corollary:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 1. An interactive proof with <span class="math">\\lambda</span>-bit challenges that is <span class="math">k^{(\\mu)}</span>-almost-special-sound for a relation <span class="math">\\mathcal{R}</span> and has at most $\\mu\\in O(\\log(\\lambda+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> rounds on any instance </span>\\mathsf{x}\\in\\mathcal{L}_{\\mathcal{R}}<span class="math"> has witness-extended emulation for </span>\\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose we have a protocol that is <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-sound with challenge space <span class="math">\\mathcal{X}</span> of size <span class="math">2^{\\lambda}</span> for some negligible function <span class="math">\\delta:\\mathbb{N}\\to\\mathbb{R}</span>. We will make use of algorithms <span class="math">\\mathsf{Extract}</span>, <span class="math">\\mathsf{Extend}</span>, and <span class="math">\\mathsf{Break}</span> and their properties that are guaranteed to exist by the definition of almost-special-soundness (Definition 10).</p>

    <p class="text-gray-300">For any node <span class="math">\\nu</span> of a <span class="math">(k+1)</span>-ary transcript tree let <span class="math">S_{\\nu}^{<em>}</span> denote the </em>left <span class="math">k</span>-ary subtree rooted* at <span class="math">\\nu</span> defined by a breadth first search from <span class="math">\\nu</span> that visits only the first <span class="math">k</span> children of each node reached (i.e., prunes the rightmost branch from each node of the complete <span class="math">(k+1)</span>-ary subtree <span class="math">S_{\\nu}</span>).</p>

    <p class="text-gray-300">In Definition 11, we define an algorithm <span class="math">\\mathsf{TreeExtract}(\\ell_{\\nu},\\nu,\\mathcal{C}_{\\nu},L_{S_{\\nu}})</span> that operates on a labeled subtree of a <span class="math">(k+1)</span>-ary transcript tree that has depth <span class="math">\\mu</span>, where <span class="math">\\ell_{\\nu}</span> is the level of <span class="math">\\nu</span>, <span class="math">\\mathcal{C}_{\\nu}=L(\\nu)_{1}</span> is the commitment label on <span class="math">\\nu</span> and <span class="math">L_{S_{\\nu}}</span> is a labeling of the <span class="math">(k+1)</span>-ary subtree <span class="math">S_{\\nu}</span> rooted at <span class="math">\\nu</span>. If <span class="math">\\mathsf{TreeExtract}(\\ell_{\\nu},\\nu,\\mathcal{C}_{\\nu},L_{S_{\\nu}})</span> succeeds it returns <span class="math">\\mathsf{openSubtree}</span>, which contains openings of all the commitment labels <span class="math">L</span> assigned to nodes in <span class="math">S_{\\nu}</span> including the label <span class="math">\\mathcal{C}_{\\nu}</span> on node <span class="math">\\nu</span>. Otherwise it returns <span class="math">\\bot</span>. The <span class="math">\\mathsf{TreeExtract}</span> algorithm is not guaranteed to succeed. In particular, the internal calls to <span class="math">\\mathsf{Extract}</span> are only guaranteed to succeed when the openings of subtrees satisfy predicate <span class="math">\\phi_{\\mathsf{a}}</span> and the challenge labels are distinct within the pruned subtrees <span class="math">S_{\\nu}^{<em>}</span>. Definition 11 also defines <span class="math">\\mathsf{TreeExtract}^{</em>}(\\ell_{\\nu},\\mathcal{C}_{\\nu},L_{S_{\\nu}^{<em>}})</span>, an algorithm that only extracts openings of the commitments in <span class="math">L_{S_{\\nu}^{</em>}}</span> and returns an opening of <span class="math">C_{\\nu}</span>. This runs similarly to <span class="math">\\mathsf{TreeExtract}</span>, but it is only a function of nodes present in the left <span class="math">k</span>-ary subtree <span class="math">S_{\\nu}^{<em>}</span>. While it is possible that <span class="math">\\mathsf{TreeExtract}</span> fails and <span class="math">\\mathsf{TreeExtract}^{</em>}</span> succeeds, they will always output the same opening of <span class="math">C_{\\nu}</span> in the event that both succeed.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{size}(k,\\mu)=\\frac{k^{\\mu+1}-1}{k-1}</span>, which is the number of nodes is a <span class="math">k</span>-ary depth <span class="math">\\mu</span> tree. Given any <span class="math">\\mu</span>-round protocol that satisfies <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-soundness, setting <span class="math">N=\\mathsf{size}(k+1,\\mu)</span> we will define a collection of predicates <span class="math">\\{\\pi_{\\nu}:\\nu\\in[1,N]\\}</span> for the nodes of a <span class="math">k</span>-ary transcript tree with post-order labeling <span class="math">L</span>, such that each <span class="math">\\pi_{\\nu}</span> is a function of the partial labeling <span class="math">L_{\\nu^{<em>}}</span> and a <span class="math">\\mu-\\ell_{\\nu}</span>-length challenge vector <span class="math">\\mathbf{r}\\in\\mathcal{X}^{\\mu-\\ell_{\\nu}}</span>, where <span class="math">\\ell_{\\nu}</span> is the level of node <span class="math">\\nu</span> in the tree. Recall that <span class="math">\\nu^{</em>}&lt;\\nu</span> is the node of highest index smaller than <span class="math">\\nu</span> that is not a member of the subtree of <span class="math">\\nu</span>, and <span class="math">L_{\\nu^{<em>}}</span> are the labels of all nodes numbered <span class="math">[1,\\nu^{</em>}]</span>. Let <span class="math">\\omega</span> denote the parent node of <span class="math">\\nu</span>. The predicate <span class="math">\\pi_{\\nu}(L_{\\nu^{*}},\\mathbf{r})</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\nu</span> has no left-sibling, then <span class="math">\\pi_{\\nu}</span> always returns <span class="math">1</span>.</li>

      <li>If <span class="math">\\nu</span> has <span class="math">0&lt;i&lt;k</span> left-siblings (i.e., it is neither the first nor last child) then <span class="math">\\pi_{\\nu}(L_{\\nu^{<em>}},\\mathbf{r})=1</span> iff the challenge label <span class="math">L(\\nu)_{\\mathsf{0}}</span> assigned to <span class="math">\\nu</span> is distinct from the challenge labels assigned to its <span class="math">i</span> left-siblings. Note that if <span class="math">\\nu^{\\prime}</span> is a left-sibling of <span class="math">\\nu</span> then <span class="math">\\nu^{\\prime}\\in[1,\\nu^{</em>}]</span> so <span class="math">L(\\nu^{\\prime})</span> is included in the input <span class="math">L_{\\nu^{*}}</span> to <span class="math">\\pi_{\\nu}</span>.</li>

      <li>If <span class="math">\\nu</span> has no right-sibling (i.e., is rightmost child) then let <span class="math">\\mathcal{C}_{\\omega}=L(\\omega)_{1}</span> denote the commitment label on <span class="math">\\omega</span>, let <span class="math">(m_{\\omega},\\mathsf{o}_{\\omega})</span> denote the opening of <span class="math">\\mathcal{C}_{\\omega}</span> returned by <span class="math">\\mathsf{TreeExtract}^{<em>}(\\ell_{\\omega},\\omega,\\mathcal{C}_{\\omega},L_{S_{\\omega}^{</em>}})</span></li>

    </ul>

    <p class="text-gray-300">if successful, let <span class="math">m&#x27;</span> denote the last message in the output list of <span class="math">\\mathsf{Extend}(\\ell_{\\omega}, m_{\\omega}, \\mathbf{r})</span> and finally:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_{\\nu}(L_{\\nu^{*}}, \\mathbf{r}) = \\begin{cases} 1 &amp;amp; \\text{if } \\mathsf{TreeExtract}^{*}(\\ell_{\\omega}, \\omega, \\mathcal{C}_{\\omega}, L_{S_{\\omega}^{*}}) = \\bot \\\\ 1 &amp;amp; \\text{if } \\phi_{a}(\\ell_{\\omega}, m_{\\omega}) = 1 \\\\ 1 &amp;amp; \\text{if } \\phi_{a}(\\ell_{\\omega}, m_{\\omega}) = 0 \\wedge \\phi_{a}(\\mu, m&#x27;) = 0 \\\\ 0 \\text{ otherwise} \\end{cases}</span></div>

    <p class="text-gray-300">As remarked above, while TreeExtract operates on the entire <span class="math">(k + 1)</span>-ary subtree of labels rooted at <span class="math">\\omega</span>, the algorithm TreeExtract<em> takes as input only the labeling of the right <span class="math">k</span>-ary subtree <span class="math">S_{\\omega}^{</em>}</span> and <span class="math">L_{S_{\\omega}^{<em>}} \\subseteq L_{\\nu^{</em>}}</span>. By the definition of <span class="math">(k^{(\\mu)}, \\delta)</span>-almost-special-soundness (Definition 10, pt. 5), for any <span class="math">\\nu \\in [0, N)</span> that has no right-sibling and any <span class="math">L_{\\nu^{*}}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P}_{\\mathbf{r} \\star \\sim \\mathcal{X}^{\\mu - \\ell_{\\nu}}} \\left[ \\pi_{v}(L_{v^{*}}, \\mathbf{r}) = 1 \\right] \\geq 1 - \\delta(\\lambda)</span></div>

    <p class="text-gray-300">If <span class="math">\\nu</span> has <span class="math">0 &amp;lt; i &amp;lt; k</span> left-siblings then by a union bound:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P}_{\\mathbf{r} \\star \\sim \\mathcal{X}^{\\mu - \\ell_{\\nu}}} \\left[ \\pi_{v}(L_{v^{*}}, \\mathbf{r}) = 1 \\right] \\geq 1 - \\frac{i}{2^{\\lambda}}</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Ipath}(\\nu)_0</span> denote the challenge labels <span class="math">L(\\cdot)_0</span> along the leftmost branch from <span class="math">\\nu</span> to a leaf starting with the label <span class="math">L(\\nu)_0</span> on <span class="math">\\nu</span>. By Lemma 11 (Path Predicate Forking Lemma) there is an algorithm <span class="math">\\mathsf{Tree}^{\\mathcal{A}}(\\mathbf{z})</span> that, given a security parameter <span class="math">\\lambda \\in \\mathbb{N}</span>, an input <span class="math">\\mathbf{x} \\in \\mathcal{L}_{\\mathcal{R}}</span>, and oracle access to an adversarial prover <span class="math">\\mathcal{A}</span> that causes <span class="math">V</span> to accept on input <span class="math">\\mathbf{x}</span> with probability <span class="math">\\epsilon</span>, runs in time at most <span class="math">t = 2\\lambda \\cdot \\frac{(k + 1)^{\\mu}}{\\epsilon} \\cdot (\\mu + t_V)</span>, where <span class="math">t_V</span> is the worst-case running time of verifier's decision algorithm, and returns with probability at least <span class="math">1 - t \\cdot \\max(\\delta(\\lambda), \\frac{k}{2^{\\lambda}}) - 2^{-\\lambda}</span> a <span class="math">(k + 1)</span>-ary transcript tree with post-order labelling <span class="math">L: [1, N] \\to \\mathcal{X} \\times \\mathcal{M}</span> such that <span class="math">\\pi_v(L_{v^*}, L(\\mathsf{Ipath}_v)_0) = 1</span> for all <span class="math">v \\in [1, N]</span>.</p>

    <p class="text-gray-300">In particular, <span class="math">L</span> defines a <span class="math">(k + 1)</span>-ary transcript tree with the properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenge labels on the first <span class="math">k</span> children of any node are distinct, i.e., if <span class="math">\\omega</span> has children <span class="math">\\nu_{1}, \\ldots, \\nu_{k+1}</span> ordered from left-to-right, then for any <span class="math">i, j \\in [1, k]</span> if <span class="math">i \\neq j</span> then <span class="math">L_{0}(\\nu_{i}) \\neq L_{0}(\\nu_{j})</span>.</li>

      <li>If <span class="math">\\nu</span> is the <span class="math">(k + 1)</span>th child of <span class="math">\\omega</span> and running <span class="math">\\mathsf{TreeExtract}(\\ell_{\\omega}, \\omega, \\mathcal{C}_{\\omega}, L_{S_{\\omega}^{*}})</span> at level <span class="math">\\ell_{\\omega}</span> returns an opening of <span class="math">\\mathcal{C}_{\\omega}</span> to <span class="math">m_{\\omega}</span> such that <span class="math">\\phi_{a}(\\ell_{\\omega}, m_{\\omega}) \\neq 1</span>, then the final output of <span class="math">\\mathsf{Extend}(\\ell_{\\omega}, m_{\\omega}, \\mathsf{Ipath}(\\nu)_0)</span> is a message <span class="math">m&#x27;</span> such that <span class="math">\\phi_{a}(\\mu, m&#x27;) \\neq 1</span>.</li>

    </ol>

    <p class="text-gray-300">By Lemma 14 there is a deterministic extraction algorithm that takes any <span class="math">L</span> with the above properties and computes a witness <span class="math">\\mathsf{w}</span> such that <span class="math">(\\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}&#x27;</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In conclusion, for any adversarial prover that succeeds on input <span class="math">x</span> with probability <span class="math">\\epsilon(x)</span>, there is a probabilistic extractor that runs in time at most <span class="math">t = 2\\lambda \\frac{(k + 1)^{\\mu}}{\\epsilon(x)} (\\mu + t_V)</span> and with probability at least <span class="math">1 - t \\cdot \\max(\\delta(\\lambda), \\frac{k}{2^{\\lambda}}) - 2^{-\\lambda}</span> returns a witness for <span class="math">\\mathcal{R}&#x27;</span>. Since $t \\in \\frac{\\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\lambda)}{\\epsilon(x)}<span class="math"> assuming </span>\\mu \\in O(\\log(\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> and </span>t_V \\in \\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\lambda)<span class="math">, this satisfies the definition of </span>\\delta'<span class="math">-knowledge soundness with </span>\\delta'(\\lambda) = 2\\lambda (k + 1)^{\\mu} (\\mu + t_V) \\cdot \\max(\\delta(\\lambda), k \\cdot 2^{-\\lambda}) + 2^{-\\lambda}<span class="math">, which is a negligible function of </span>\\lambda<span class="math"> as long as </span>\\delta(\\lambda)$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Definition 11 (Tree Extractor). We define an algorithm <span class="math">\\mathsf{TreeExtract}(k, \\ell, \\nu, \\mathcal{C}_{\\nu}, L_{S_{\\nu}})</span> that operates on a labeled subtree of a <span class="math">(k + 1)</span>-ary transcript tree that has depth <span class="math">\\mu</span>, where <span class="math">\\ell_{\\nu}</span> is the level of <span class="math">\\nu</span>, <span class="math">\\mathcal{C}_{\\nu} = L(\\nu)_1</span> is the commitment label on <span class="math">\\nu</span> and <span class="math">L_{S_{\\nu}}</span> is a labeling of the <span class="math">(k + 1)</span>-ary subtree <span class="math">S_{\\nu}</span> rooted at <span class="math">\\nu</span>. If <span class="math">\\mathsf{TreeExtract}(\\ell_{\\nu}, \\nu, \\mathcal{C}_{\\nu}, L_{S_{\\nu}})</span> succeeds it returns openSubtree, which contains openings of all the commitment labels <span class="math">L</span> assigned to nodes in <span class="math">S_{\\nu}</span> including the label <span class="math">\\mathcal{C}_{\\nu}</span> on node <span class="math">\\nu</span>. Otherwise it returns <span class="math">\\bot</span>. The algorithms run as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all leaf nodes <span class="math">\\nu</span>, return the opening of <span class="math">\\mathcal{C}_{\\nu}</span>, which is included in the label on <span class="math">\\nu</span>.</li>

      <li>For each node <span class="math">\\omega \\in S_{\\nu}</span> on the second to last level with label <span class="math">\\mathcal{C}_{\\omega} = L(\\omega)_1</span>, set openLeaves to include the first <span class="math">k</span> opened leaves of <span class="math">\\omega</span>, and run Extract <span class="math">(\\mu - 1, \\omega, \\mathcal{C}_{\\omega}, \\text{openLeaves})</span> to get an opening of <span class="math">\\mathcal{C}_{\\omega}</span>.</li>

    </ul>

    <p class="text-gray-300">45</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Continue iteratively: once openings for all commitment labels of all subtrees rooted at the <span class="math">i</span>th level have been computed, for each node <span class="math">\\omega</span> on the <span class="math">(i+1)</span>st level with label <span class="math">\\mathcal{C}_{\\omega} = L(\\omega)_1</span> run Extract<span class="math">(i,\\omega, \\mathcal{C}_{\\omega}, \\text{openSubtree}_{\\omega}^<em>)</span> on the commitment label openings openSubtree of the left <span class="math">k</span>-ary subtree <span class="math">S_{\\omega}^</em></span> (excluding node <span class="math">\\omega</span>), which were computed in prior iterations.</li>

    </ul>

    <p class="text-gray-300">Finally, TreeExtract<span class="math">^<em>(\\ell_{\\nu}, \\mathcal{C}_{\\nu}, L_{S_{\\omega}^</em>})</span> denotes the algorithm that only extracts openings of the commitments in <span class="math">L_{S_{\\omega}^<em>}</span> and returns an opening of <span class="math">\\mathcal{C}_{\\nu}</span>. This runs exactly like TreeExtract except that it only iterates over nodes that are present in the left <span class="math">k</span>-ary subtree <span class="math">S_{\\nu}^</em></span>.</p>

    <p class="text-gray-300">The TreeExtract algorithm is not guaranteed to succeed. In particular, the internal calls to Extract are only guaranteed to succeed when the openings of subtrees satisfy predicate <span class="math">\\phi_{\\mathrm{a}}</span> and the challenge labels are distinct within the pruned subtrees <span class="math">S_{\\nu}^{<em>}</span>. By convention, if any internal step fails then TreeExtract outputs <span class="math">\\perp</span>. While it is possible that TreeExtract fails and TreeExtract</em> succeeds, it is easy to see that they output the same opening of <span class="math">C_{\\nu}</span> assuming both succeed. Furthermore, while TreeExtract operates on <span class="math">(k + 1)</span>-ary transcript tree, the internal calls to Extract run on <span class="math">k</span>-ary transcript trees because it is defined for a protocol that is <span class="math">(k^{(\\mu)},\\delta)</span>-almost-special-sound. The reason we always pass the labeling/opening of the left <span class="math">k</span>-ary subtree (as opposed to an arbitrary <span class="math">k</span>-ary subtree) to Extract is to ensure that the opening of <span class="math">\\mathcal{C}_{\\nu}</span> included in the output of TreeExtract<span class="math">(\\ell_{\\nu},\\mathcal{C}_{\\nu},L_{S_{\\nu}})</span> is a function of only the labels on the left <span class="math">k</span>-ary subtree <span class="math">S_{\\nu}^{*}</span>, and in particular is computed independently from any of the labels in the (rightmost) subtree rooted at the <span class="math">(k + 1)</span>th (rightmost) child of <span class="math">\\nu</span>. This fact is used in the proof of Theorem 7.</p>

    <p class="text-gray-300"><strong>Definition 12 (Predicate Special Soundness).</strong> Let <span class="math">\\rho</span> denote any binary predicate that takes as input any <span class="math">k</span>-ary <span class="math">\\mu</span>-depth transcript tree. A <span class="math">\\mu</span>-round public coin interactive proof for a relation <span class="math">\\mathcal{R}</span> with <span class="math">\\lambda</span>-bit challenges is <span class="math">(k^{(\\mu)},\\rho)</span>-special sound if there exists a deterministic extraction algorithm <span class="math">\\mathcal{E}</span> that takes as input an instance <span class="math">\\mathbf{x} \\in \\mathcal{L}_{\\mathcal{R}}</span>, any <span class="math">k</span>-ary forking transcript tree rooted at <span class="math">\\mathbf{x}</span> with labelling <span class="math">L</span> such that <span class="math">\\rho(L) = 1</span>, and returns a witness <span class="math">\\mathbf{w}</span> such that <span class="math">(\\mathbf{x},\\mathbf{w}) \\in \\mathcal{R}</span> in time <span class="math">\\mathrm{poly}(\\lambda, k^{\\mu})</span>.</p>

    <p class="text-gray-300">Setting <span class="math">\\rho = 1</span>, i.e. the trivial predicate that is always true, recovers the standard definition of <span class="math">k^{(\\mu)}</span>-special soundness. Recall that we defined a <em>forking</em> transcript tree (Section A.3) as a transcript tree in which the challenge labels on edges that share the same parent node are distinct.[14]</p>

    <p class="text-gray-300"><strong>Lemma 14.</strong> Let <span class="math">\\Pi(\\mathsf{pp})</span> denote a <span class="math">(k^{(\\mu)},\\delta, \\mathsf{com}, \\phi)</span>-almost-special-sound protocol for a relation <span class="math">\\mathcal{R}</span> and any <span class="math">\\delta \\in [0,1]</span>, parametrized by <span class="math">\\mathsf{pp} \\gets \\mathsf{com.Setup}(\\lambda)</span>. Define the binary predicate <span class="math">\\rho</span> as a function of a <span class="math">(k + 1)</span>-ary <span class="math">\\mu</span>-depth forking transcript tree given by labelling <span class="math">L</span>, which uses the algorithms TreeExtract from Definition 11 and Extend from Definition 10 and returns 1 iff the following condition holds:</p>

    <p class="text-gray-300">For any node <span class="math">\\omega</span> with <span class="math">(k + 1)\\mathrm{st}</span> child <span class="math">\\nu</span>, if the result of running TreeExtract<span class="math">(\\ell_{\\omega}, \\omega, \\mathcal{C}_{\\omega}, L_{S_{\\omega}^*})</span> at level <span class="math">\\ell_{\\omega}</span> returns an opening of <span class="math">\\mathcal{C}_{\\omega}</span> to <span class="math">m_{\\omega}</span> such that <span class="math">\\phi_{a}(\\ell_{\\omega}, m_{\\omega}) \\neq 1</span>, then the final output of Extend<span class="math">(\\ell_{\\omega}, m_{\\omega}, \\mathsf{path}(\\nu)_0)</span> is a message <span class="math">m&#x27;</span> such that <span class="math">\\phi_{a}(\\mu, m&#x27;) \\neq 1</span>.</p>

    <p class="text-gray-300"><span class="math">\\Pi(\\mathsf{pp})</span> is <span class="math">((k + 1)^{(\\mu)},\\rho)</span>-special sound for the relation <span class="math">\\mathcal{R}&#x27;(\\mathsf{pp})</span> defined in Theorem 7.</p>

    <p class="text-gray-300"><strong>Remark 4.</strong> The value of <span class="math">\\delta</span> does not affect <span class="math">((k + 1)^{\\mu},\\rho)</span>-special soundness. The value of <span class="math">\\delta</span> affects the runtime of the extraction algorithm that is able to generate a transcript tree satisfying the predicate <span class="math">\\rho</span> (in Theorem 7).</p>

    <p class="text-gray-300"><strong>Proof.</strong> We will argue that, assuming the <span class="math">(k + 1)</span>-ary forking transcript tree has property <span class="math">\\rho</span>, for any <span class="math">\\omega \\in [1,N]</span>, either TreeExtract<span class="math">(\\ell_{\\omega},\\omega ,\\mathcal{C}_{\\omega},L_{S_{\\omega}})</span> returns a subtree openSubtree of openings of the commitment labels in <span class="math">L_{S_{\\omega}}</span> satisfying <span class="math">\\phi_{\\mathrm{a}}</span> (i.e., each opening of a label <span class="math">C_{\\omega}</span> to <span class="math">m_{\\omega}</span> for a node <span class="math">\\omega</span> on level <span class="math">\\ell_{\\omega}</span> satisfies <span class="math">\\phi_{\\mathrm{a}}(\\ell_{\\omega},m_{\\omega}) = 1</span>) or else there is an efficient algorithm that uses openSubtree and <span class="math">L</span> to break the commitment scheme.</p>

    <p class="text-gray-300">[14] We could have defined predicate special soundness in an even more general way such that the forking property of the tree is not required, yet can be encapsulated in the predicate. However, this would not be useful for our present work and less convenient for notational purposes.</p>

    <p class="text-gray-300">Step 1: Suppose that <span class="math">\\omega</span> is a node of highest level <span class="math">\\ell_{\\omega}</span> for which this fails, i.e. the output of TreeExtract satisfies <span class="math">\\phi_{a}</span> for any node of higher level than <span class="math">\\ell_{\\omega}</span>. This means that all the openings of internal (non-root) nodes of the subtree <span class="math">L_{S_{\\omega}}</span> computed while running TreeExtract on <span class="math">\\omega</span> satisfy <span class="math">\\phi_{a}</span>. Furthermore, <span class="math">L</span> has the property that all labels on the first <span class="math">k</span> siblings are distinct.</p>

    <p class="text-gray-300">Step 2: By the definition of almost-special-soundness and the hypothesis in Step 1, the algorithm TreeExtract<span class="math">(\\ell_{\\omega},\\omega,\\mathcal{C}_{\\omega},L_{S_{\\omega}})</span> succeeds in returning openSubtree consisting of the openings of <span class="math">L_{S_{\\omega}}</span> such that the openings of all internal (non-root) nodes satisfy <span class="math">\\phi_{a}</span>, and the opening <span class="math">(m_{\\omega},o_{\\omega})</span> of the subtree root <span class="math">\\omega</span> satisfies <span class="math">\\phi_{b}(\\ell_{\\omega},m_{\\omega})=1</span>. The opening <span class="math">(m_{\\omega},o_{\\omega})</span> is also identical to the output of TreeExtract<span class="math">{}^{<em>}(\\ell_{\\omega},\\omega,\\mathcal{C}_{\\omega},L_{S_{\\omega}^{</em>}})</span>.</p>

    <p class="text-gray-300">Step 3: Let <span class="math">\\nu</span> denote the rightmost child of <span class="math">\\omega</span>. By hypothesis, if <span class="math">\\phi_{a}(\\ell_{\\omega},m_{\\omega})=0</span> then the final output of Extend<span class="math">(\\ell_{\\omega},m_{\\omega},\\mathsf{ipath}(\\nu))</span> is a message <span class="math">m^{\\prime}</span> such that <span class="math">\\phi_{a}(\\mu,m^{\\prime})=0</span>. However, this implies that <span class="math">m^{\\prime}</span> must be distinct from the label <span class="math">L</span> assigns to the leaf node of the rightmost branch extending from <span class="math">\\nu</span>. Let <span class="math">v_{1},...,v_{\\mu}</span> denote the nodes along the root-to-leaf path passing through node <span class="math">\\omega</span> and ending with its leftmost branch so that <span class="math">\\mathsf{Ipath}(\\nu)=(L(v_{\\ell_{\\nu}})_{0},...,L(v_{\\mu})_{0})</span>. For each <span class="math">i\\in[1,\\mu]</span> let <span class="math">\\hat{C}_{i}=L(v_{i})_{1}</span> and <span class="math">\\hat{\\mathbf{C}}=(\\hat{C}_{1},...,\\hat{C}_{\\mu})</span>. Finally, since <span class="math">\\phi_{b}(\\ell_{\\omega},m_{\\omega})=1</span> and openSubtree contains openings <span class="math">(m_{\\ell_{\\nu}},o_{\\ell_{\\nu}}),...(m_{\\mu},o_{\\mu})</span> of the commitments <span class="math">\\hat{C}_{\\ell_{\\nu}},...\\hat{C}_{\\mu}</span> that all satisfy predicate <span class="math">\\phi_{a}(i,m_{i})=1</span>, if <span class="math">m^{\\prime}\\neq m_{\\mu}</span> then by the definition of almost-special-soundness this implies that <span class="math">\\mathsf{Break}(\\ell_{\\omega},m_{\\omega},\\mathsf{rpath}(\\nu),\\hat{\\mathbf{C}},(m_{\\ell_{\\nu}},o_{\\ell_{\\nu}}),...(m_{\\mu},o_{\\mu}))</span> outputs a conflicting opening of some commitment label in <span class="math">\\hat{\\mathbf{C}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}_{1}=L(1)_{1}</span>, the transcript tree root. The extractor runs TreeExtract<span class="math">(0,1,\\mathcal{C}_{1},L_{S_{1}})</span>, which returns openTree. If every opening in openTree satisfies predicate <span class="math">\\phi_{a}</span> then it runs Extract<span class="math">(0,\\mathsf{x},\\mathsf{openTree})</span> to obtain witness <span class="math">\\mathsf{w}</span> satisfying <span class="math">R(\\mathsf{x},\\mathsf{w})=1</span>. Otherwise, it uses the Break algorithm (as described in the previous step) to output conflicting openings of a commitment, which is a witness for <span class="math">R^{\\prime}(\\mathsf{pp})</span>.</p>

    <p class="text-gray-300"><span class="math">\\Box</span></p>

    <h2 id="sec-90" class="text-2xl font-bold">Appendix C DARK is Almost-Special-Sound</h2>

    <h3 id="sec-91" class="text-xl font-semibold mt-8">C.1 Correctness</h3>

    <h6 id="sec-92" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">The polynomial commitment scheme is correct for <span class="math">\\mu</span>-linear polynomials in <span class="math">\\mathbb{Z}_{p}[X]</span>.</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to ensure correctness we must ensure that <span class="math">b&lt;q/2</span> and that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq b<span class="math">. To show this we show that in each recursion step the honest prover’s witness polynomial has coefficients bounded by </span>b<span class="math"> and is </span>\\mu<span class="math">-linear. We argue inductively that for each recursive call of EvalB the following constraints on the inputs are satisfied: </span>f(X_{1}\\ldots,X_{\\mu})<span class="math"> is </span>\\mu<span class="math">-linear. </span>\\mathsf{C}<span class="math"> encodes the polynomial, i.e., </span>\\mathsf{C}=\\mathsf{G}^{f(\\vec{q})}<span class="math"> and </span>f(X)\\in\\mathbb{Z}(b)<span class="math">. Also </span>f(z_{1},\\ldots,z_{\\mu})=y\\bmod p$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Initially, during the execution of Eval, the prover maps the coefficients of a polynomial <span class="math">\\tilde{f}(X_{1},\\ldots,X_{\\mu})\\in\\mathbb{Z}_{p}</span> to a <span class="math">\\mu</span>-linear integer polynomial <span class="math">f(X_{1},\\ldots,X_{\\mu})</span> with coefficients in <span class="math">\\mathbb{Z}(p-1)</span> such that <span class="math">\\mathsf{C}=\\mathsf{G}^{f(\\vec{q})}</span>. Additionally <span class="math">f(z_{1},\\ldots,z_{\\mu})\\bmod p=\\tilde{f}(z_{1},\\ldots,z_{\\mu})=y</span>.</p>

    <p class="text-gray-300">If <span class="math">f</span> is <span class="math">\\mu</span>-linear then in round <span class="math">i</span> of the protocol the <span class="math">\\mathcal{P}</span> can compute <span class="math">i-1</span> linear polynomials <span class="math">f_{L}</span> and <span class="math">f_{R}</span> such that <span class="math">f_{L}(X_{1},\\ldots,X_{i-1})+X_{i}f_{R}(X_{1},\\ldots,X_{i-1})=f(X_{1},\\ldots,X_{i})</span>. Consequently <span class="math">f(z_{1},\\ldots,z_{i})\\bmod p=f_{L}(z_{1},\\ldots,z_{i-1})+z_{i}f_{R}(z_{1},\\ldots,z_{i-1})\\bmod p=y_{L}+z_{i}y_{R}\\bmod p=y</span>. The PoE protocol has perfect correctness so <span class="math">\\mathsf{G}^{f_{L}(q)+q^{\\frac{2+1}{2}}f_{R}(X)}=\\mathsf{C}</span>. Finally <span class="math">f^{\\prime}=f_{L}+\\alpha\\cdot f_{R}\\in\\mathbb{Z}(2^{\\lambda}\\cdot b)</span> is an <span class="math">i-1</span>-linear polynomial with coefficients bounded in absolute value by <span class="math">(2^{\\lambda}-1)\\cdot b+b=2^{\\lambda}b</span>, as <span class="math">\\alpha\\in[0,2^{\\lambda})</span>. This is precisely the value of <span class="math">b^{\\prime}</span> the input to the next call of EvalB. The value <span class="math">y^{\\prime}</span> is also correct: <span class="math">f^{\\prime}(z_{1},\\ldots,z_{i-1})\\bmod p=f_{L}(z_{1},\\ldots,z_{i-1})+\\alpha\\cdot f_{R}(z_{1},\\ldots,z_{i-1})\\bmod p=y_{L}+\\alpha\\cdot y_{R}\\bmod p=y^{\\prime}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the final round, the prover sends <span class="math">f</span>, and the verifier checks that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><b<span class="math"> which is true by construction. </span>\\Box$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">C.2 Soundness</h3>

    <p class="text-gray-300">Security of PoE substitutions We first begin by showing that we can safely replace all of the PoE evaluations with direct verification checks. Concretely, under the Adaptive Root Assumption, the Eval protocol is as secure as the protocol Eval^{′} in which all PoEs are replaced by direct checks. We show that the witness-extended emulation for Eval^{′} implies the same</p>

    <p class="text-gray-300">property for Eval. This is useful because we will later show how to can build an extractor for Eval', thereby showing that the same witness-extended emulation property extends to Eval.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Let <span class="math">\\mathsf{Eval}&#x27;</span> be the protocol that is identical to Eval but in line 15 of EvalB <span class="math">\\mathcal{V}</span> directly checks <span class="math">\\mathsf{C}_L + q^{(2^{\\mu -1})} \\cdot \\mathsf{C}_R = \\mathsf{C}</span> instead of using a PoE. If the Adaptive Root Assumption holds for GGen, and <span class="math">\\mathsf{Eval}&#x27;</span> has witness-extended emulation for <span class="math">O(\\log (\\lambda))</span>-linear polynomials, then so does Eval.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We show that if an extractor <span class="math">E&#x27;</span>, as defined in Definition 8, exists for the protocol <span class="math">\\mathsf{Eval}&#x27;</span> then we can construct an extractor <span class="math">E</span> for the protocol Eval. Specifically, <span class="math">E</span> simulates <span class="math">E&#x27;</span> and presents it with a <span class="math">\\mathsf{Record}&#x27;(\\dots)</span> oracle, while extracting the witness from its own <span class="math">\\mathsf{Record}(\\dots)</span> oracle.</p>

    <p class="text-gray-300">Whenever <span class="math">E&#x27;</span> queries the <span class="math">\\mathsf{Record}&#x27;</span> oracle, <span class="math">E</span> queries its Record oracle and relays the response after dropping those portions of the transcript that correspond to the PoE proofs. Whenever <span class="math">E&#x27;</span> rewinds its prover, so does <span class="math">E</span> rewind its prover. When <span class="math">E&#x27;</span> terminates by outputting a transcript-and-witness pair <span class="math">(\\mathsf{tr}&#x27;, f)</span>, <span class="math">E</span> adds PoEs into this transcript to obtain <span class="math">\\mathsf{tr}</span> and outputs <span class="math">(\\mathsf{tr}, f)</span>.</p>

    <p class="text-gray-300">For each PPT adversary <span class="math">(\\mathcal{A}, P^{*})</span>, <span class="math">E</span> will receive a polynomial number of transcripts from its Record oracle. Any transcript <span class="math">\\mathsf{tr}</span> of Eval such that <span class="math">\\mathcal{A}(\\mathsf{tr}) = 1</span> and <span class="math">\\mathsf{tr}</span> is accepting contains exactly <span class="math">\\mu</span> PoEs transcripts. So in total <span class="math">E</span> sees only a polynomial number of PoE transcripts generated by a probabilistic polynomial-time prover and verifier. By Lemma 3 under the Adaptive Root Assumption, the probability that a polynomial time adversary can break the soundness of PoE, i.e., convince a verifier on an instance <span class="math">(C_R, C - C_L, q^{(2^{\\mu -1})}) \\notin \\mathcal{R}_{\\mathsf{PoE}}</span>, is negligible. Consequently, the probability that the adversary can break PoE on any of the polynomial number of executions of PoE is still negligible.</p>

    <p class="text-gray-300">This means that with overwhelming probability all transcripts are equivalent to having the verifier directly check <span class="math">(C_R, C - C_L, q^{(2^{\\mu -1})}) \\in \\mathcal{R}_{\\mathsf{PoE}}</span>. By assumption, the witness-candidate <span class="math">f</span> that <span class="math">E&#x27;</span> outputs is a valid witness if the transcript <span class="math">\\mathsf{tr}&#x27;</span> that <span class="math">E&#x27;</span> also outputs is accepting. The addition of honest PoE transcripts to <span class="math">\\mathsf{tr}&#x27;</span> preserves the transcript's validity. So <span class="math">\\mathsf{tr}</span> is an accepting transcript for Eval if and only if <span class="math">\\mathsf{tr}&#x27;</span> is an accepting transcript for Eval'. Therefore, <span class="math">E&#x27;</span> outputs a valid witness <span class="math">f(X)</span> whenever <span class="math">E</span> outputs a valid witness. This suffices to show that Eval has witness-extended emulation if Eval' has, and if the Adaptive Root Assumption holds for GGen.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda} = 8\\mu^2 + \\log_2(2\\mu)\\lambda</span>. Let <span class="math">\\mathsf{EBL}_{\\mu, \\lambda} = \\lambda \\cdot \\mu</span> and <span class="math">\\mathsf{CB}_{p, \\mu, \\lambda} = \\lambda \\cdot \\mu + \\log_2 p</span>. Let <span class="math">\\mathsf{com}</span> be the DARK commitment scheme as described in Lemma 10. There exists a pair of predicates <span class="math">\\phi</span> such that the <span class="math">\\mu</span>-round DARK polynomial commitment evaluation protocol Eval with <span class="math">\\lambda</span>-bit challenges, a group of unknown order GGen, and <span class="math">\\log q \\geq 4(\\lambda + 1 + \\mathsf{CSZ}_{\\mu, \\lambda}) + \\mathsf{EBL}_{\\mu, \\lambda} + \\mathsf{CB}_{p, \\mu, \\lambda} + 1</span> is <span class="math">(2^{(\\mu)}, \\frac{3\\mu}{2^2}, \\mathsf{com}, \\phi)</span>-almost-special-sound.</p>

    <p class="text-gray-300">As a corollary, under the adaptive root assumption for GGen, the DARK polynomial commitment scheme with the same parameters has witness-extended-emulation (Definition 8).</p>

    <p class="text-gray-300"><strong>Remark 5.</strong> <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda}</span> is derived from the Multilinear Composite Schwartz Zippel Lemma (lemma 7). <span class="math">\\mathsf{EBL}_{\\mu, \\lambda}</span> is derived from the Evaluation Bound Lemma (lemma 6) and CB refers to the final round check bound in the DARK protocol. We can also substitute any value for <span class="math">\\mathsf{CSZ}_{\\mu, \\lambda}</span> using the table of concrete bounds in Lemma 8 for fixed 120-bit security in place of the analytical bound from Lemma 7).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> For any <span class="math">\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}} \\in \\mathbb{R}</span>, let $\\mathcal{M}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}}) = \\{f / N \\in \\mathbb{Q}[X] : \\gcd(f, N) = 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta_{\\mathfrak{n}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_{\\mathfrak{d}}\\}<span class="math">. In the relation </span>R(\\mathsf{x}, \\mathsf{w})<span class="math"> for the DARK evaluation protocol, the input </span>\\mathsf{x} = (C, \\vec{z} = (z_1, \\ldots, z_\\mu), y)<span class="math"> consists of a DARK commitment </span>C<span class="math">, an evaluation point </span>\\vec{z} \\in \\mathbb{Z}^{\\mu}<span class="math"> and a claimed evaluation </span>y \\in \\mathbb{Z}<span class="math">, while the witness </span>\\mathsf{w}<span class="math"> is an opening of </span>C<span class="math"> to a rational </span>\\mu<span class="math">-linear polynomial </span>h<span class="math"> such that </span>h(\\vec{z}) = y \\bmod p<span class="math">. For any parameters </span>\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}}<span class="math"> such that </span>\\beta_{\\mathfrak{n}} \\cdot \\beta_{\\mathfrak{d}} \\leq \\frac{q}{2}<span class="math"> this is binding to rational polynomials in </span>\\mathcal{M}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})<span class="math">. Setup parameters include </span>p<span class="math"> and </span>q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For reasons that will become clear we will set:</p>

    <div class="my-4 text-center"><span class="math-block">\\log q = 4 (\\lambda + 1 + \\mathsf {C S Z} _ {\\mu , \\lambda}) + \\mathsf {E B L} _ {\\mu , \\lambda} + \\mathsf {C B} _ {p, \\mu , \\lambda} + 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\log_ {2} \\beta_ {\\mathfrak {n}} = \\frac {1}{2} (\\mathsf {E B L} _ {\\mu , \\lambda} + \\mathsf {C B} _ {p, \\mu , \\lambda} + \\log_ {2} q - 1) \\qquad \\log_ {2} \\beta_ {\\mathfrak {d}} = \\frac {1}{2} (\\log_ {2} q - 1 - \\mathsf {E B L} _ {\\mu , \\lambda} - \\mathsf {C B} _ {p, \\mu , \\lambda})</span></div>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Extraction tree for DARK with  <span class="math">\\mu = 2</span> . The green nodes are the instances for each node and the red nodes are the computed witnesses. The extraction procedure uses the first two children of every node to compute a witness. The predicate  <span class="math">\\phi_{a}</span>  is defined and holds for the rightmost path extending from any node (e.g. for the root the path through nodes 12 and 11). The labeling is incomplete for space reasons but the leftmost path (13,4,1) is fully labeled. The node ids are in post-order and indicate the extraction order.</p>

    <p class="text-gray-300">so that  <span class="math">\\log_2(\\beta_{\\mathfrak{n}}\\cdot \\beta_{\\mathfrak{d}}) = \\log_2q - 1</span>  as desired.</p>

    <p class="text-gray-300">We begin by defining  <span class="math">\\mathsf{com} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span>  and predicates  <span class="math">\\phi_{a}</span>  and  <span class="math">\\phi_{b}</span>  for DARK special-soundness (Definition 10).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitment setup  <span class="math">\\mathsf{com.Setup}(\\lambda, \\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span>  runs the setup procedure for the DARK commitment scheme, which samples a group  <span class="math">\\mathbb{G} \\gets \\mathsf{GGen}(\\lambda)</span> , a generator  <span class="math">\\mathsf{G} \\gets \\mathbb{G}</span> , sets  <span class="math">q = 2\\beta_{\\mathfrak{n}}\\beta_{\\mathfrak{d}}</span> , and returns  <span class="math">\\mathsf{pp} = (\\mathbb{G}, \\mathsf{G}, q)</span> .</li>

      <li>The commitments of  <span class="math">\\mathsf{com}</span>  are pairs  <span class="math">\\mathcal{C} = ((C_L, y_L), (C_R, y_R)</span>  where  <span class="math">C_L, C_R</span>  are DARK commitments and  <span class="math">y_L, y_R \\in \\mathbb{Q}</span> . Recall that  <span class="math">(f, N) \\in \\mathbb{Z}[X_1, \\ldots, X_\\mu] \\times \\mathbb{Z}</span>  is an opening of a DARK commitment  <span class="math">C</span>  to the  <span class="math">\\mu</span> -linear rational polynomial  <span class="math">h = f / N</span>  provided that  <span class="math">f(q, \\ldots, q^{\\mu - 1}) \\cdot \\mathsf{G} = N \\cdot C</span> , where  <span class="math">q</span>  is a parameter of the DARK commitment scheme. This is binding to rational polynomials in the set  <span class="math">\\mathcal{M}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span> .</li>

    </ul>

    <p class="text-gray-300">We define a valid opening of  <span class="math">\\mathcal{C} = ((C_L, y_L), (C_R, y_R))</span>  to a rational  <span class="math">\\mu</span> -linear polynomial  <span class="math">h \\in \\mathbb{Q}[X_1, \\ldots, X_\\mu]</span>  as a pair  <span class="math">(f, N) \\in \\mathbb{Z}[X_1, \\ldots, X_\\mu] \\times \\mathbb{Z}</span>  where  <span class="math">f = f_L + X_\\mu f_R</span>  for  <span class="math">f_L, f_R \\in \\mathbb{Z}[X_1, \\ldots, X_{\\mu-1}]</span>  such that  <span class="math">(f_L, N)</span>  and  <span class="math">(f_R, N)</span>  are valid openings of the DARK commitments  <span class="math">C_L</span>  and  <span class="math">C_R</span>  respectively, provided that  <span class="math">N \\cdot h = f</span> ,  <span class="math">f_L(\\vec{z}) = N \\cdot y_L \\bmod p</span> ,  <span class="math">f_R(\\vec{z}) = N \\cdot y_R \\bmod p</span> . This also implies that  <span class="math">(f, N)</span>  is a valid opening of the homomorphically derived DARK commitment  <span class="math">C = C_L + q^{2^{\\mu-1}} C_R</span>  to  <span class="math">h</span>  and  <span class="math">h(z_1, \\ldots, z_\\mu) = y_L + z_\\mu g_R \\bmod p</span> , i.e.  <span class="math">N \\cdot C = f(q, \\ldots, q^{2^{\\mu-1}}) \\cdot G</span>  and  <span class="math">h \\in \\mathcal{M}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span> .</p>

    <p class="text-gray-300">Additionally, a rational number is also considered a valid (trivial) commitment to itself. In the DARK protocol the prover's messages are commitments of the first kind for all but its last message, which is a single integer.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We define the numerator bounds  <span class="math">B_0 \\geq \\dots \\geq B_\\mu \\in \\mathbb{N}</span>  and denominator bounds  <span class="math">D_0 \\geq \\dots \\geq D_\\mu</span>  such that  <span class="math">\\log B_\\mu = \\mathsf{CB}_{p,\\mu,\\lambda}</span>  is the verification bound on the prover's final integer message in the DARK protocol,  <span class="math">D_\\mu = 1</span>  (i.e., prover's final message is an integer),  <span class="math">\\log D_i = \\mathsf{CSZ}_{\\mu - i,\\lambda}</span>  and  <span class="math">\\log B_i = \\mathsf{CSZ}_{\\mu - i,\\lambda} + \\mathsf{EBL}_{\\mu - i,\\lambda} + \\mathsf{CB}_{p,\\mu,\\lambda}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For  <span class="math">i \\in [\\mu - 1]</span>  and any  <span class="math">h \\in \\mathbb{Q}[X_1, \\ldots, X_{\\mu - i}]</span> , we define  <span class="math">\\phi_a(i, h) = 1</span>  if and only if  <span class="math">h</span>  is  <span class="math">\\mu - i</span>  linear and  <span class="math">h \\in \\mathcal{M}(B_i, D_i)</span> . In particular,  <span class="math">\\phi_a(\\mu, h) = 1</span>  iff  <span class="math">h \\in \\mathbb{Z}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B_\\mu$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [\\mu - 1]</span> and an opening <span class="math">h \\in \\mathbb{Q}[X_1, \\ldots, X_{\\mu - i}]</span> define <span class="math">\\phi_b(i, h) = 1</span> if and only if <span class="math">h</span> is <span class="math">\\mu - i</span> linear and <span class="math">h \\in \\mathcal{M}(2^{\\lambda + 1}B_iD_i, 2^{\\lambda + 1}D_i^2)</span>.</li>

    </ul>

    <p class="text-gray-300">By setting <span class="math">q</span> sufficiently large so that <span class="math">\\log q \\geq 4(\\lambda + 1 + \\mathsf{CSZ}_{\\mu, \\lambda}) + \\mathsf{EBL}_{\\mu, \\lambda} + \\mathsf{CB}_{p, \\mu, \\lambda} + 1</span>, for any <span class="math">i \\in [\\mu]</span>, <span class="math">\\phi_b(i, h) = 1</span> implies that <span class="math">2^{\\lambda + 1} \\cdot h \\in \\mathcal{M}(\\beta_{\\mathfrak{n}}, \\beta_{\\mathfrak{d}})</span>. To see this, the log of the numerator bound on <span class="math">2^{\\lambda + 1}h</span> is:</p>

    <div class="my-4 text-center"><span class="math-block">2 (\\lambda + 1) + \\log (B _ {0} D _ {0}) = 2 (\\lambda + \\mathsf {C S Z} _ {\\mu , \\lambda} + 1) + \\mathsf {E B L} _ {\\mu , \\lambda} + \\mathsf {C B} _ {p, \\mu , \\lambda} \\leq \\frac {1}{2} (\\log q - 1 + \\mathsf {E B L} _ {\\mu , \\lambda} + \\mathsf {C B} _ {p, \\mu , \\lambda}) = \\log \\beta_ {\\mathfrak {n}}</span></div>

    <p class="text-gray-300">And the log of the denominator bound on <span class="math">2^{\\lambda + 1}h</span> is:</p>

    <div class="my-4 text-center"><span class="math-block">2 (\\lambda + 1 + \\mathsf {C S Z} _ {\\mu , \\lambda}) \\leq \\frac {1}{2} (\\log q - 1 - \\mathsf {E B L} _ {\\mu , \\lambda} - \\mathsf {C B} _ {p, \\mu , \\lambda}) = \\log \\beta_ {\\mathsf {d}}</span></div>

    <p class="text-gray-300">Next, we define the algorithms Extract and Extend.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract <span class="math">(i,\\nu,C_{\\nu},\\text{openSubtree})</span> for <span class="math">i &amp;lt; \\mu</span> operates as follows. Let <span class="math">\\mathcal{C}_{\\nu} = (C_L,C_R)</span>. The node <span class="math">\\nu</span> has two children. Let <span class="math">\\alpha_{1}</span> denote the label on the edge to the first child and <span class="math">\\alpha_{2}</span> the label on the edge to the second child. For <span class="math">j\\in \\{1,2\\}</span>, let <span class="math">\\mathcal{C}_j = ((C_{j,L},y_{j,L}),(C_{j,R},y_{j,R}))</span> denote the commitment label of the <span class="math">i</span>th child with openings <span class="math">(f_j,N_j)</span> to <span class="math">h_j = f_j / N_j</span> where for <span class="math">i &amp;lt; \\mu -1</span> <span class="math">f_{j} = f_{j,L} + X_{\\mu -i - 1}f_{j,R}</span>, and <span class="math">h_j(z) = y_{j,L} + z_{\\mu -i - 1}\\cdot y_{j,R}\\bmod p</span>. Set <span class="math">N = (\\alpha_{2} - \\alpha_{1})N_{1}N_{2}</span>, <span class="math">f_{L} = \\alpha_{2}N_{2}f_{1} - \\alpha_{1}N_{1}f_{2}</span>, and <span class="math">f_{R} = N_{1}f_{2} - N_{2}f_{1}</span>. Set <span class="math">f = f_{L} + X_{\\mu -i}\\cdot f_{R}</span>. Return <span class="math">(f,N)</span> as the opening for <span class="math">C_\\nu</span> to <span class="math">h = f / N</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extract(0, (C, z, y), openTree) simply returns the opening <span class="math">(f,N)</span> for the root level commitment <span class="math">((C_L,y_L),(C_R,y_R))</span> to <span class="math">h = f / N</span>, which satisfies <span class="math">N\\cdot C = f(q)\\cdot \\mathsf{G}</span> and <span class="math">h(z) = y</span>, since in a valid transcript tree <span class="math">C = C_{L} + q^{2^{\\mu -1}}C_{R}</span> and <span class="math">y_{L} + z_{\\mu}\\cdot y_{R} = y</span>. Furthermore, if <span class="math">\\phi_a(0,h) = 1</span> then <span class="math">h\\in \\mathcal{M}(B_0,D_0)\\subset \\mathcal{M}(\\beta_{\\mathfrak{n}},\\beta_{\\mathfrak{d}})</span>, and hence <span class="math">\\mathsf{w} = (f,N)</span> is a witness for <span class="math">\\mathsf{x} = (C,z,y)</span> such that <span class="math">R(\\mathsf{x},\\mathsf{w}) = 1</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extend <span class="math">(i, h, \\alpha_{i+1}, \\dots, \\alpha_{\\mu})</span> on <span class="math">h \\in \\mathbb{Q}[X_1, \\dots, X_{\\mu-i}]</span> returns <span class="math">\\perp</span> if <span class="math">h</span> is not <span class="math">\\mu-i</span> linear, and otherwise sets <span class="math">h_i := h</span> and runs the following iterative algorithm: for <span class="math">j = i</span> to <span class="math">\\mu-1</span> set <span class="math">h_{j+1} := h_{j,L} + \\alpha_{j+1} \\cdot h_{j,R}</span> where, treating each <span class="math">h_j</span> as a <span class="math">\\mu-j</span> linear polynomial (padding with zero coefficients), <span class="math">h_{j,L}</span> and <span class="math">h_{j,R}</span> are each <span class="math">\\mu-j-1</span> linear consisting of the left/right coefficients (i.e. the constant and linear part of <span class="math">X_{\\mu-j}</span>) of <span class="math">h_j</span>, i.e. <span class="math">h_j = h_{j,L} + X_{\\mu-j} \\cdot h_{j,R}</span>; return <span class="math">h_i, \\dots, h_\\mu</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Notes:</strong> The runtime is <span class="math">O(\\lambda \\cdot 2^{\\mu - i})</span>.</p>

    <p class="text-gray-300">If <span class="math">h_i = h_{i,L} + X_{\\mu - i} \\cdot h_{i,R} \\in \\mathbb{Z}[X_1, \\ldots, X_{\\mu - i}]</span> is the prover's committed polynomial in the <span class="math">i</span>th round of the (honest) interactive DARK protocol and <span class="math">\\alpha_{i+1}, \\ldots, \\alpha_\\mu</span> are the last <span class="math">\\mu - i</span> round challenges then <span class="math">h_\\mu</span> is the last prover's message sent to the verifier in the interactive DARK protocol. Then <span class="math">h_\\mu = h_i(\\alpha_\\mu, \\ldots, \\alpha_{i+1})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Break <span class="math">(i, h, \\alpha_1, \\dots, \\alpha_\\mu, C_0, \\dots, C_\\mu, (f_i, N_i), \\dots, (f_\\mu, N_\\mu))</span> first runs Extend <span class="math">(i, h, \\alpha_i, \\dots, \\alpha_\\mu)</span>, which returns rational polynomials <span class="math">h_{i+1}&#x27;, \\dots, h_\\mu&#x27;</span>. If <span class="math">\\forall_{j \\geq i} h_j&#x27; = f_j / N_j</span> then it outputs <span class="math">\\perp</span>. Otherwise, let <span class="math">j \\in [i, \\mu)</span> be the first index where <span class="math">h_{j+1}&#x27; \\neq f_{j+1} / N_{j+1}</span> and output <span class="math">(N_j, f_{j,L} + \\alpha_{j+1} \\cdot f_{j,R})</span>, where <span class="math">f_{j,L}</span> and <span class="math">f_{j,R}</span> are the left/right halves of <span class="math">f_j</span>, as the attempted opening for <span class="math">C_{j+1}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Subclaim 1.</strong> For <span class="math">i \\in [\\mu - 1]</span>, if all openings of commitments on children of <span class="math">\\nu</span> in openSubtree satisfy <span class="math">\\phi_a(i + 1, *) = 1</span> then the tuple <span class="math">(f_L, f_R, N)</span> returned by Extract <span class="math">(i, \\nu, \\mathcal{C}_{\\nu}, \\text{openSubtree})</span> is a valid opening for <span class="math">\\mathcal{C}_{\\nu}</span> to a rational polynomial <span class="math">h</span> that satisfies <span class="math">\\phi_b(i, h) = 1</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We will show why this is a correct opening for <span class="math">\\mathcal{C}_{\\nu}</span> and bound its norm. Based on the properties of a valid transcript tree, <span class="math">\\forall_{j \\in \\{1,2\\}} C_L + \\alpha_j C_R = C_{j,L} + q^{2^{\\mu - i - 2}} C_{j,R}</span> and <span class="math">y_L + \\alpha_j y_R = y_{j,L} + z_{\\mu - i12} y_{j,R}</span>. Furthermore, <span class="math">\\forall_{j \\in \\{1,2\\}} N_j \\cdot (C_L + \\alpha_j C_R) = f_j(q)</span> and <span class="math">h_j(z) = N_j^{-1} f_j(z) = y_L + \\alpha_j y_R \\bmod p</span> by the assumption that <span class="math">(f_j, N_j)</span> are valid openings to the two children commitments <span class="math">\\mathcal{C}_j</span>. Let <span class="math">L_q(\\cdot): \\mathbb{Z}[X]^2 \\to \\mathbb{Z}^2</span> denote the linear operator corresponding to</p>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">component-wise evaluation of each polynomial at  <span class="math">\\vec{q}</span> . Using linear algebra, the following holds true if  <span class="math">\\alpha_{1} \\neq \\alpha_{2}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left[ \\begin{array}{c c} N _ {1} &amp;amp; 0 \\\\ 0 &amp;amp; N _ {2} \\end{array} \\right] \\left[ \\begin{array}{c c} 1 &amp;amp; \\alpha_ {1} \\\\ 1 &amp;amp; \\alpha_ {2} \\end{array} \\right] \\left[ \\begin{array}{c} C _ {L} \\\\ C _ {R} \\end{array} \\right] = L _ {q} \\left(\\left[ \\begin{array}{c} f _ {1} \\\\ f _ {2} \\end{array} \\right]\\right) \\cdot \\mathsf {G} \\\\ (\\alpha_ {2} - \\alpha_ {1}) N _ {1} N _ {2} \\left[ \\begin{array}{c} C _ {L} \\\\ C _ {R} \\end{array} \\right] = L _ {q} \\left( \\begin{array}{c c} \\left[ \\begin{array}{c c} \\alpha_ {2} N _ {2} &amp;amp; - \\alpha_ {2} N _ {1} \\\\ - N _ {2} &amp;amp; N _ {1} \\end{array} \\right] &amp;amp; \\left[ \\begin{array}{c} f _ {1} \\\\ f _ {2} \\end{array} \\right] \\end{array} \\right) \\cdot \\mathsf {G} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left[ \\begin{array}{c c} N _ {1} &amp;amp; 0 \\\\ 0 &amp;amp; N _ {2} \\end{array} \\right] \\left[ \\begin{array}{c c} 1 &amp;amp; \\alpha_ {1} \\\\ 1 &amp;amp; \\alpha_ {2} \\end{array} \\right] \\left[ \\begin{array}{c} y _ {L} \\\\ y _ {R} \\end{array} \\right] = L _ {z} \\left(\\left[ \\begin{array}{c} f _ {1} \\\\ f _ {2} \\end{array} \\right]\\right) \\bmod p \\\\ (\\alpha_ {2} - \\alpha_ {1}) N _ {1} N _ {2} \\left[ \\begin{array}{c} y _ {L} \\\\ y _ {R} \\end{array} \\right] = L _ {z} \\left( \\left[ \\begin{array}{c c} \\alpha_ {2} N _ {2} &amp;amp; - \\alpha_ {2} N _ {1} \\\\ - N _ {2} &amp;amp; N _ {1} \\end{array} \\right] \\left[ \\begin{array}{c} f _ {1} \\\\ f _ {2} \\end{array} \\right]\\right) \\bmod p \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This shows that  <span class="math">N \\cdot C_L = f_L(q) \\cdot \\mathsf{G}</span> ,  <span class="math">N \\cdot C_R = f_R(\\vec{q}) \\cdot \\mathsf{G}</span> ,  <span class="math">N \\cdot y_L = f_L(\\vec{z}) \\bmod p</span> , and  <span class="math">N \\cdot y_R = f_R(\\vec{z}) \\bmod p</span> . Furthermore, if  <span class="math">f_1</span>  and  <span class="math">f_2</span>  are  <span class="math">\\mu - i</span>  linear, then so are  <span class="math">f_L</span>  and  <span class="math">f_R</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  $\\forall_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq B_{i}<span class="math">  and  </span>\\forall_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B_{i}<span class="math"> , then  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\lambda +1}D_{i}^{2}<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2^{\\lambda +1}B_{i}D_{i}<span class="math"> . Thus, if the openings of the children at level  </span>i + 1<span class="math">  satisfy  </span>\\phi_{a}(i + 1,f_{j} / N_{j}) = 1<span class="math">  for  </span>j\\in \\{1,2\\}<span class="math"> , then  </span>\\phi_b(i,f / N) = 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Subclaim 2 (Key <em>New</em> Subclaim). For any  <span class="math">i \\in [\\mu]</span>  and  <span class="math">h \\in \\mathbb{Q}[X_1, \\ldots, X_{\\mu - i}]</span> , if  <span class="math">\\phi_a(i, h) = 0</span>  then the probability over uniform i.i.d.  <span class="math">\\alpha_{i + 1}, \\ldots, \\alpha_\\mu</span>  that  <span class="math">h_\\mu</span>  returned by  <span class="math">\\text{Extend}(i, h, \\alpha_{i + 1}, \\ldots, \\alpha_\\mu)</span>  satisfies  <span class="math">\\phi_a(\\mu, h_\\mu) = 1</span>  is at most  <span class="math">\\frac{3(\\mu - i)}{2^\\lambda}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">f / N = h</span>  for  <span class="math">\\gcd(f, N) = 1</span>  denote the reduced form of  <span class="math">h \\in \\mathbb{Q}[X_1, \\ldots, X_{\\mu - i}]</span> . If  <span class="math">\\phi_a(i, h) = 0</span>  then either  <span class="math">N &amp;gt; D_i</span>  or  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &gt; B_i<span class="math">  while  </span>\\phi_a(\\mu, h_\\mu) = 1<span class="math">  implies  </span>h_\\mu \\in \\mathbb{Z}<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B_\\mu$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">\\mu&#x27; = \\mu - i</span> . Observe that  <span class="math">h_\\mu = \\frac{1}{N} \\cdot f(\\alpha_\\mu, \\dots, \\alpha_{i+1})</span> .</p>

    <p class="text-gray-300">Case 1  <span class="math">N &amp;gt; D_{i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; D_{i}<span class="math">  then since  </span>\\log D_{i} = \\mathsf{CSZ}_{\\mu - i}<span class="math"> , the probability that  </span>h_{\\mu} \\in \\mathbb{Z}$  is:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {P} _ {(\\alpha_ {i + 1}, \\dots , \\alpha_ {\\mu}) \\leftarrow</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0, 2 ^ {\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {\\mu - i}} [ f (\\alpha_ {\\mu}, \\dots , \\alpha_ {i + 1}) \\equiv 0 \\bmod N ] \\leq \\frac {\\mu - i + 1}{2 ^ {\\lambda}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">by the Multilinear Composite Schwartz-Zippel Lemma (Lemma 7).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 2  $N \\leq D_i \\land</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &gt; B_i$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case if  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq B_{\\mu}<span class="math">  then  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\alpha_{\\mu}, \\dots, \\alpha_{i+1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq N \\cdot B_{\\mu} \\leq \\mathsf{CSZ}_{\\mu - i, \\lambda} \\cdot B_{\\mu}<span class="math"> . Furthermore, the fact that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &gt; B_i<span class="math">  and  </span>\\log B_i = \\mathsf{CSZ}_{\\mu - i, \\lambda} + \\mathsf{EBL}_{\\mu - i, \\lambda} + \\log B_{\\mu}$  imply:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log \\left(\\mathrm {C S Z} _ {\\mu - i, \\lambda} \\cdot B _ {\\mu}\\right) \\leq \\log B _ {i} - \\mathrm {E B L} _ {\\mu - i, \\lambda} &lt;   \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} - \\mathrm {E B L} _ {\\mu - i, \\lambda}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Hence by the Evaluation Bound Lemma (Lemma 6):</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {P} [ h _ {\\mu} \\leq B _ {\\mu} ] \\leq \\mathbb {P} [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f (\\alpha_ {\\mu}, \\dots , \\alpha_ {i + 1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq D _ {i} \\cdot B _ {\\mu} ] \\leq \\mathbb {P} [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f (\\alpha_ {\\mu}, \\dots , \\alpha_ {i + 1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {1}{2 ^ {\\mathsf {E B L} _ {\\mu - i , \\lambda}}} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} ] \\leq \\frac {3 (\\mu - i)}{2 ^ {\\lambda}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Together these imply that if  <span class="math">f</span>  is  <span class="math">\\mu - i</span>  linear but  <span class="math">\\phi_a(i, f / N) = 0</span>  then, since either  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; B_i<span class="math">  or  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &gt; B_i<span class="math"> , the probability over the random challenges that the final element  </span>h_\\mu<span class="math">  of the list returned by Extend satisfies  </span>\\phi_a(\\mu, h_\\mu) = 1$  is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Subclaim 3. For any  <span class="math">i \\in [\\mu - 1]</span> , given a valid (accepting) transcript with commitments  <span class="math">(\\mathcal{C}_0, \\dots, \\mathcal{C}_\\mu)</span> , round challenges  <span class="math">(\\alpha_1, \\dots, \\alpha_\\mu)</span> , and openings  <span class="math">(o_i, \\dots, o_\\mu)</span>  of the last  <span class="math">\\mu - i + 1</span>  commitments to rational polynomials  <span class="math">(h_i, \\dots, h_\\mu)</span> , where  <span class="math">\\phi_b(i, h_i) = 1</span>  and  <span class="math">\\phi_a(j, h_j) = 1</span>  for all  <span class="math">j \\in [i + 1, \\mu]</span> , then either  <span class="math">\\text{Extend}(i, h_i, \\alpha_{i+1}, \\dots, \\alpha_\\mu)</span>  returns  <span class="math">h_{i+1}, \\dots, h_\\mu</span>  or  <span class="math">\\text{Break}(i, h_i, (h_i, o_i), \\dots, (h_\\mu, o_\\mu))</span>  returns for some  <span class="math">j \\geq i</span>  a valid opening of  <span class="math">\\mathcal{C}_j</span>  to  <span class="math">h_j&#x27; \\neq h_j</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">(h_{i+1}&#x27;, \\dots, h_{\\mu}&#x27;)</span>  denote the output of  <span class="math">\\text{Extend}(i, h_i, \\alpha_{i+1}, \\dots, \\alpha_\\mu)</span>  and suppose it is not equal to  <span class="math">(h_{i+1}, \\dots, h_\\mu)</span> . Let  <span class="math">j \\in [i, \\mu)</span>  denote the first index for which  <span class="math">h_{j+1} \\neq h_{j+1}&#x27;</span> . This means that  <span class="math">h_j = h_j&#x27;</span>  and thus  <span class="math">h_{j+1}&#x27; = h_{j,L} + \\alpha_{j+1} \\cdot h_{j,R}</span>  where  <span class="math">h_{j,L}</span>  and  <span class="math">h_{j,R}</span>  are the left/right halves of  <span class="math">h_j</span> . Additionally,  <span class="math">\\phi_b(j, h_j) = 1</span>  implies  <span class="math">h_{j+1}&#x27; \\in \\mathcal{M}(2^{2\\lambda+2}B_jD_j, 2^{\\lambda+1}B_j^2) \\subseteq \\mathcal{M}(\\beta_n, \\beta_d)</span> .</p>

    <p class="text-gray-300">(Note that for <span class="math">j \\geq i + 1</span>, the condition <span class="math">\\phi_{a}(j, h_{j}) = 1</span> also implies <span class="math">\\phi_{b}(j, h_{j}) = 1</span>).</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}_{j+1} = ((C_{j+1,L}, y_{j+1,L}), (C_{j+1,R}, y_{j+1,R}))</span> and <span class="math">\\mathcal{C}_j = ((C_{j,L},y_{j,L}),(C_{j,R},y_{j,R}))</span>. Let <span class="math">o_j = (f_j,N_j)</span> denote the opening of <span class="math">\\mathcal{C}_j</span> to <span class="math">h_j = \\frac{f_j}{N_j}</span> where <span class="math">f_j = f_{j,L} + X_{\\mu - j}f_{j,R}</span>. Validity of the opening implies <span class="math">N_{j}\\cdot C_{j,L} = f_{j,L}(q)\\cdot \\mathsf{G}</span> and <span class="math">N_{j}\\cdot C_{j,R} = f_{j,R}(q)\\cdot \\mathsf{G}</span>. Furthermore, in a valid transcript:</p>

    <div class="my-4 text-center"><span class="math-block">C _ {j + 1} = C _ {j, L} + \\alpha_ {j + 1} \\cdot C _ {j, R} = C _ {j + 1, L} + q ^ {2 ^ {\\mu - j}} C _ {j + 1, R}</span></div>

    <p class="text-gray-300">Thus, <span class="math">(N_{j},f_{j,L} + \\alpha_{j + 1}\\cdot f_{j,R})</span> is a valid opening of <span class="math">C_{j + 1}</span> to <span class="math">h_{j + 1}^{\\prime}</span> as <span class="math">N_{j}\\cdot C_{j + 1} = (f_{j,L}(q) + \\alpha_{j + 1}\\cdot f_{j,R}(q))\\cdot \\mathsf{G}</span>.</p>

    <p class="text-gray-300"><strong>Witness-extended emulation</strong> By corollary 1 and if the DARK commitment is binding then this shows that Eval has witness extended emulation for the relation <span class="math">\\mathcal{R}_{\\mathrm{Eval}}(\\mathsf{pp})</span> for polynomials in <span class="math">\\mathbb{F}_p</span>. The binding property of DARK depends on the random order assumption which is implied by the adaptive root assumption (Lemmas 2 and 10). Further by Lemma 5 this implies that Eval has witness-extended emulation for the same relation under the adaptive root assumption.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Recently, [Wik21, AFK21] showed that for <span class="math">\\mu</span>-round special sound protocols the non-interactive Fiat-Shamir transform of these protocols only suffers a security loss that is linear in the number of queries the adversary makes to the random oracle. These proofs do not directly apply to almost-special-sound protocols. In particular, in a non-interactive protocol, we cannot guarantee that the challenges on <span class="math">\\mathsf{Ipath}(\\nu)</span> are mutually independent. An adversary might grind each challenge and pick one depending on the previous challenges. Concretely, for DARK the composite Schwartz-Zippel lemma analyzes the probability that <span class="math">f(x_{1},\\ldots ,x_{\\mu})\\equiv 0\\bmod N</span> for independently sampled <span class="math">x_{1},\\ldots ,x_{\\mu}</span>. If the adversary, can grind challenges, i.e. try different challenges per prover message, then it can for each challenge <span class="math">x_{i}</span> ensure that <span class="math">f(x_{1},\\dots,x_{i},X_{i + 1},\\dots,X_{\\mu})\\equiv 0\\bmod N_{i}</span> where <span class="math">N_{i}</span> is a factor of <span class="math">N</span> of size roughly <span class="math">N^{\\frac{1}{\\mu}}</span>. The proof of theorem 1 relies on the fact that <span class="math">\\mathbb{P}_{(\\alpha_{i + 1},\\dots,\\alpha_{\\mu})\\leftarrow [0,2^{\\lambda}]^{\\mu -i}}[g(\\alpha_{i + 1},\\dots,\\alpha_{\\mu})\\equiv 0\\bmod N] = \\delta</span> is negligible for sufficiently large <span class="math">N</span>. Analyzing a grinding adversary of the non-interactive protocol that makes at most <span class="math">T</span> queries to the random oracle corresponds to analyzing the probability that for any set of <span class="math">T</span> values <span class="math">\\mathbb{P}_{S = \\{\\alpha_{i,j}\\}_{i\\in [\\mu ],j\\in [T]}}\\leftarrow [0,2^{\\lambda}]^{\\mu}\\cdot T\\exists (j_1,\\dots,j_\\mu)</span> s.t. <span class="math">[g(\\alpha_{1,j_1},\\dots,\\alpha_{\\mu,j_\\mu})\\equiv 0\\bmod N]</span> which using a union bound is less than <span class="math">T^{\\mu}\\cdot \\delta</span>.</p>

    <p class="text-gray-300">However, what if it is impossible for the adversary to actually grind the prover message. We know that in almost-special-sound protocols the prover message is a commitment. If that commitment is unique, i.e. for a given opening there exists only one possible commitment, then a grinding adversary couldn't choose a different commitment. We capture this notion formally and show that even if the commitment is only computationally unique the Fiat-Shamir transform of these almost-special-sound protocols is secure. The DARK protocol has precisely this property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 13 (Random Oracle).</strong> In our version of the random oracle model, all random oracle algorithms have black-box access to a shared random function <span class="math">\\mathcal{H}:\\mathcal{M}^{\\leq u}\\to \\mathcal{X}</span> where <span class="math">\\mathcal{M}^{\\leq u}</span> consists of all vectors <span class="math">(m_{1},\\dots,m_{i})\\in \\mathcal{M}^{i}</span> for each <span class="math">i\\leq u</span>. <span class="math">\\mathcal{H}</span> assigns to each of the $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{u + 1} - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math"> unique elements of </span>\\mathcal{M}^{\\leq u}<span class="math"> an output independently and uniformly distributed in </span>\\mathcal{X}<span class="math">. Random oracles may be assigned indices from a set </span>\\mathcal{I}<span class="math">, where for any distinct </span>i,j\\in \\mathcal{I}<span class="math"> the oracles </span>\\mathcal{H}_i<span class="math"> and </span>\\mathcal{H}_j<span class="math"> are independently distributed random functions. For any </span>k &lt; u<span class="math"> and fixed </span>\\mathbf{m} = (m_1,\\dots,m_k)<span class="math"> we will use the notation </span>\\mathcal{H}_{\\mathbf{m}}:\\mathcal{M}^{\\leq u - k}\\to \\mathcal{X}<span class="math"> where </span>\\mathcal{H}_{\\mathbf{m}}(m_1',\\dots,m_i') = \\mathcal{H}(\\mathbf{m},m_1',\\dots,m_i')<span class="math"> for any </span>i\\leq u - k<span class="math">. This is equivalent to a random oracle family indexed by </span>\\mathcal{M}^k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A <span class="math">Q</span>-query random oracle algorithm is an algorithm that makes at most <span class="math">Q</span> queries to the random oracle.</p>

    <p class="text-gray-300"><strong>Definition 14 (Non-interactive Proof of Knowledge in RO).</strong> An non-interactive protocol <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span> between a prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> in the random oracle model (i.e., with shared</p>

    <p class="text-gray-300">oracle access to the random function <span class="math">\\mathcal{H}</span>) is a proof of knowledge for a relation <span class="math">\\mathcal{R}</span> with knowledge error <span class="math">\\delta : \\mathbb{N}^2 \\to [0,1]</span> if the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: for all <span class="math">(x, w) \\in \\mathcal{R}</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P} \\left[ \\mathcal{V}^{\\mathcal{H}}(x, \\pi) = 1 : \\pi \\leftarrow \\mathcal{P}^{\\mathcal{H}}(x, w) \\right] = 1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-Knowledge Soundness: There exists a polynomial <span class="math">\\mathsf{poly}(\\cdot)</span> and a probabilistic oracle machine <span class="math">\\mathcal{E}</span> called the extractor such that given oracle access to any <span class="math">Q</span>-query random oracle algorithm <span class="math">\\mathcal{A}</span> and any input <span class="math">x \\in \\mathcal{L}_R</span> the following holds<span class="math">^{17}</span>: if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P} \\left[ \\mathcal{V}^{\\mathcal{H}}(x, \\pi) = 1 : \\pi \\leftarrow \\mathcal{A}^{\\mathcal{H}}(x) \\right] = \\epsilon(x)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then <span class="math">\\mathcal{E}^{\\mathcal{A}}(x)</span> outputs <span class="math">w</span> such that <span class="math">(x, w) \\in \\mathcal{R}</span> in an expected $\\frac{\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{\\epsilon(x) - \\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, Q)}<span class="math"> number of steps. In the course of running with black-box access to </span>\\mathcal{A}<span class="math">, </span>\\mathcal{E}^{\\mathcal{A}}(x)<span class="math"> implements the random oracle for </span>\\mathcal{A}<span class="math">, i.e., it intercepts all queries that </span>\\mathcal{A}<span class="math"> makes to </span>\\mathcal{H}$ and simulates the response.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pi</span> is called "knowledge sound" or a "proof of knowledge" for <span class="math">\\mathcal{R}</span> if for all <span class="math">Q</span> polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the knowledge error </span>\\delta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, Q)<span class="math"> is a negligible function of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 15</strong> (Non-interactive argument of knowledge in SRS/RO). A non-interactive proof system <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}^{\\mathcal{H}}, \\mathcal{V}^{\\mathcal{H}})</span> with setup procedure <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda)</span> in the random oracle model, where <span class="math">\\mathcal{P}^{\\mathcal{H}}</span> and <span class="math">\\mathcal{V}^{\\mathcal{H}}</span> are given shared access to both the random oracle <span class="math">\\mathcal{H}</span> and the parameters <span class="math">\\mathsf{pp}</span> (where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\lambda<span class="math">), is an argument of knowledge for relation </span>\\mathcal{R}<span class="math"> with knowledge error </span>\\mathsf{err} : \\mathbb{N}^2 \\to [0,1]<span class="math"> if there exists a polynomial time extractor </span>\\mathcal{E}<span class="math"> such that for any non-uniform polynomial time adversary </span>\\mathcal{A}<span class="math"> and deterministic </span>Q<span class="math">-query polynomial time prover </span>P^*<span class="math"> the following holds: </span>^{18}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{P} \\left[ \\begin{array}{cc} &amp;amp; \\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda) \\\\ (x, w) \\in \\mathcal{R} \\text{ and} &amp;amp; (x, \\mathsf{st}) \\gets \\mathcal{A}(\\mathsf{pp}) \\\\ \\mathcal{V}^{\\mathcal{H}}(\\mathsf{pp}, x, \\pi) = 1 &amp;amp; : \\quad \\pi \\gets P^{*}(\\mathsf{st}) \\\\ &amp;amp; w \\gets \\mathcal{E}^{P^{*}(\\mathsf{st})}(\\mathsf{pp}, x) \\end{array} \\right] \\geq \\mathbb{P} \\left[ \\begin{array}{cc} \\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda) \\\\ \\mathsf{pp} \\gets \\mathcal{A}(\\mathsf{pp}) \\\\ \\pi \\gets P^{*}(\\mathsf{st}) \\end{array} \\right] - \\mathsf{err}(\\lambda, Q)</span></div>

    <p class="text-gray-300"><strong>Definition 16</strong> (FS Transform). For any <span class="math">\\mu</span>-round public-coin interactive proof <span class="math">\\Pi</span> the FS transform <span class="math">\\Pi_{FS}^{\\mathcal{H}}</span> of <span class="math">\\Pi</span> with respect to the random oracle <span class="math">\\mathcal{H}</span> is a non-interactive proof in the random oracle model which on public input <span class="math">\\mathbf{x}</span> simulates the interactive protocol <span class="math">\\Pi</span> by replacing each <span class="math">i</span>th round public-coin challenge, for <span class="math">i \\in [1, \\mu]</span>, with <span class="math">\\mathcal{H}(\\mathbf{x}, m_1, \\dots, m_i)</span>, where <span class="math">m_1, \\dots, m_i</span> denote the first <span class="math">i</span> prover messages.</p>

    <p class="text-gray-300"><strong>Lemma 5</strong> (FS for special-sound multiround protocols [AFK21, Wik21]). For any <span class="math">\\mu</span>-round interactive proof <span class="math">\\Pi = (\\mathcal{P}, \\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span> and its FS transform <span class="math">\\Pi_{FS} = (\\mathcal{P}^{\\mathcal{H}}, \\mathcal{V}^{\\mathcal{H}})</span> with random oracle <span class="math">\\mathcal{H}</span>, there exists a random oracle algorithm Tree which given black-box access to any <span class="math">Q</span>-query deterministic prover algorithm <span class="math">\\mathcal{P}^<em></span>, input <span class="math">x \\in \\mathcal{L}_R</span>, and <span class="math">k \\in \\mathbb{N}</span> makes at most <span class="math">Q + \\mu</span> queries to <span class="math">\\mathcal{H}</span> and returns a <span class="math">k</span>-ary forking transcript tree for <span class="math">\\Pi</span> in expected time <span class="math">k^\\mu + Q \\cdot (k^\\mu - 1)</span> and succeeds with probability <span class="math">\\frac{\\epsilon(x) - (Q + 1) \\cdot \\kappa}{(1 - \\kappa)}</span> where <span class="math">\\kappa = 1 - (1 - \\frac{k - 1}{2^N})^\\mu</span> and <span class="math">\\epsilon(x)</span> is the probability (over <span class="math">\\mathcal{H}</span>) that <span class="math">\\mathcal{P}^</em></span> outputs a non-interactive proof for <span class="math">x</span> that <span class="math">\\mathcal{V}^{\\mathcal{H}}</span> accepts. Moreover, the transcript tree satisfies additional properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Every root-to-leaf labelled path (i.e., transcript included in the tree) matches the output of <span class="math">\\mathcal{P}^{*\\mathcal{H}&#x27;}(x)</span> with a partially fresh random oracle <span class="math">\\mathcal{H}&#x27;</span>, and thus has the format of a valid <span class="math">\\Pi_{FS}</span> proof with respect to <span class="math">\\mathcal{H}&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">^{17}</span>The algorithm <span class="math">\\mathcal{A}</span> may explicitly hardcode a witness or may not have one, so no witness is given to <span class="math">\\mathcal{A}</span> as input.</p>

    <p class="text-gray-300"><span class="math">^{18}</span>This definition says that there is overwhelming intersection between the event where the adversary generates an input <span class="math">x</span> and corresponding proof <span class="math">\\pi</span> that convinces the verifier, and the event where the extractor succeeds in obtaining a witness from the input <span class="math">x</span> generated by the adversary. This not only ensures that extraction succeeds with close to the same probability of the adversary's success over randomly sampled parameters, but also excludes the pathological case that both the adversary and extractor succeed with noticeable probability on disjoint sets of inputs. This definition is also equivalent to fixing the transcript distinguisher in the definition of witness-extended emulation (Definition 8) to be the verifier decision algorithm. In WEE the transcript distinguisher could be arbitrary, which is a stronger property important for simulation analysis.</p>

    <p class="text-gray-300">53</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any node  <span class="math">\\nu</span> , the labels  <span class="math">L_{S_{\\nu}}</span>  on the subtree  <span class="math">S_{\\nu}</span>  are generated by a  <span class="math">(Q + \\mu)</span> -query random oracle algorithm independently from all labels  <span class="math">L_{\\nu^{*}}</span> , i.e. labels computed on lower indexed nodes that do not belong to  <span class="math">S_{\\nu}</span> . In particular, if  <span class="math">\\nu</span>  is the  <span class="math">k</span> th child of  <span class="math">\\omega</span>  then  <span class="math">L_{S_{\\nu}}</span>  is independent of the labels on the  <span class="math">(k - 1)</span> -ary left subtree of  <span class="math">\\omega</span> .</li>

    </ul>

    <p class="text-gray-300">Lemma 5 immediately implies that the FS transform of any  <span class="math">k^{(\\mu)}</span> -special sound protocol for  <span class="math">\\mathcal{R}</span>  is knowledge sound in the RO model. However, we need to work a bit harder to apply this lemma to almost-special-sound protocols. We will only be able to show computational knowledge soundness for protocols that are almost-special-sound with respect to a computationally-unique commitment scheme. The DARK proof system has this property.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 17 (RO relation hardness). Let  <span class="math">\\mathcal{R}^{\\mathcal{H}}(\\mathsf{pp})</span>  denote a family of relations parametrized by a random oracle  <span class="math">\\mathcal{H}</span>  and setup  <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(\\lambda)</span>  with security parameter  <span class="math">\\lambda</span>  where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pp}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\lambda<span class="math"> .  </span>\\mathcal{R}^{\\mathcal{H}}(\\mathsf{pp})<span class="math">  is  </span>(Q, \\epsilon(\\lambda))<span class="math"> -hard in the RO model if for any pair of polynomial time random oracle algorithms  </span>\\mathcal{A}_1, \\mathcal{A}_2<span class="math">  where  </span>\\mathcal{A}_1<span class="math">  makes at most  </span>Q<span class="math">  queries to a random oracle  </span>\\mathcal{H}'<span class="math">  (possibly distinct from  </span>\\mathcal{H}<span class="math"> ) and  </span>\\mathcal{A}_2<span class="math">  makes at most  </span>Q<span class="math">  queries to random oracle  </span>\\mathcal{H}$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ (\\mathsf {x}, \\mathsf {w}) \\in \\mathcal {R} ^ {\\mathcal {H}} (\\mathsf {p p}): &amp;amp; \\mathsf {x} \\leftarrow \\mathcal {A} _ {1} ^ {\\mathcal {H} ^ {\\prime}} (\\mathsf {p p}) \\\\ &amp;amp; \\mathsf {w} \\leftarrow \\mathcal {A} _ {2} ^ {\\mathcal {H}} (\\mathsf {p p}, \\mathsf {x}) \\end{array} \\right] \\leq \\epsilon (\\lambda)</span></div>

    <p class="text-gray-300">Definition 18 (Computationally Unique Commitments). A commitment scheme  <span class="math">\\Gamma = (\\text{Setup}, \\text{Commit}, \\text{Open})</span>  is computationally-unique if for any polynomial time adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}) \\\\ b _ {0} = b _ {1} = 1 \\wedge C _ {0} \\neq C _ {1}: &amp;amp; (C _ {0}, C _ {1}, x, r _ {0}, r _ {1}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; b _ {0} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p}, C _ {0}, x, r _ {0}) \\\\ &amp;amp; b _ {1} \\leftarrow \\mathsf {O p e n} (\\mathsf {p p}, C _ {1}, x, r _ {1}) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Lemma 5. The DARK commitment scheme satisfies computational uniqueness (Definition 18) under the adaptive root assumption.</p>

    <p class="text-gray-300">Proof. Given two commitments to the same message, we will construct a known order element. This element can be used to break the adaptive root assumption. Concretely, assume there exists an adversary  <span class="math">\\mathcal{A}_{\\mathsf{CU}}</span>  that with non-negligible probability  <span class="math">\\epsilon</span>  outputs  <span class="math">\\mathsf{C}</span>  and  <span class="math">\\mathsf{C}&#x27;</span>  as well as  <span class="math">h(X) = \\frac{f(X)}{N}</span>  such that  <span class="math">N \\cdot \\mathsf{C} = f(q) \\cdot \\mathsf{G}</span>  and  <span class="math">N \\cdot \\mathsf{C}&#x27; = f(q) \\cdot \\mathsf{G}</span> . This implies that  <span class="math">N \\cdot (\\mathsf{C} - \\mathsf{C}&#x27;) = 0</span> , i.e., that  <span class="math">N</span>  is a multiple of the order of  <span class="math">\\mathsf{C} - \\mathsf{C}&#x27;</span> , which by assumption is a non-trivial group element. We can use this to construct an adversary  <span class="math">\\mathcal{A}_{\\mathsf{AR}} = (\\mathcal{A}_1, \\mathcal{A}_2)</span>  for the adaptive root assumption, where  <span class="math">\\mathcal{A}_1</span>  outputs  <span class="math">\\mathsf{W} = \\mathsf{C} - \\mathsf{C}&#x27;</span>  and  <span class="math">\\mathcal{A}_2</span>  while  <span class="math">\\gcd(N, \\ell) \\neq 1</span>  computes  <span class="math">N&#x27; \\gets N / \\gcd(N, \\ell^k)</span>  for  <span class="math">k = \\lceil \\log_{\\ell}(N) \\rceil</span>  and computes  <span class="math">r \\gets \\ell^{-1} \\bmod N&#x27;</span>  and outputs  <span class="math">\\mathsf{U} \\gets \\mathsf{W}^r</span> . If  <span class="math">\\ell</span>  is co-prime with the order of  <span class="math">\\mathbb{G}</span>  and thus  <span class="math">\\mathsf{W}</span>  then  <span class="math">\\mathsf{U}^\\ell = \\mathsf{W}^{r \\cdot \\ell}</span>  which equals  <span class="math">\\mathsf{W}</span>  if  <span class="math">N&#x27;</span>  is a multiple of the order of  <span class="math">\\mathsf{U}</span> . This is the case with overwhelming probability as  <span class="math">N</span>  is a multiple of the order of  <span class="math">\\mathsf{U}</span>  and  <span class="math">\\ell</span>  divides the order of  <span class="math">\\mathsf{U}</span>  with only negligible probability. Thus  <span class="math">\\mathcal{A}_{\\mathsf{AR}}</span>  succeeds with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span> . This is a contradiction and shows that  <span class="math">\\Gamma</span>  is computationally unique.</p>

    <p class="text-gray-300">Lemma 5. For any  <span class="math">\\mu</span>  and  <span class="math">Q = \\mathsf{poly}(\\lambda)</span> , the relation  <span class="math">\\mathcal{R}_{\\mathrm{ext}}^{\\mathcal{H}}(\\mathsf{pp},\\mu ,\\rho)</span>  defined with respect to any computationally-unique commitment scheme  <span class="math">\\mathsf{com}</span> , predicate  <span class="math">\\rho :\\mathcal{M}^2\\times \\mathcal{X}^\\mu \\to \\{0,1\\}</span> , and  <span class="math">\\mathsf{ext}:\\mathcal{M}\\times \\mathcal{X}^{\\leq \\mu}\\to \\mathcal{M}</span>  such that  <span class="math">\\forall i,m\\in \\mathcal{M}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {\\alpha_ {1}, \\dots , \\alpha_ {\\mu}} [ \\rho_ {i} (m, m _ {\\mu}, \\alpha_ {1}, \\dots , \\alpha_ {\\mu}) = 1: \\operatorname {e x t} (m, \\alpha_ {1}, \\dots , \\alpha_ {\\mu}) = m _ {\\mu} ] \\leq \\delta</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {e x t}} ^ {\\mathcal {H}} (\\mathsf {p p}, \\mu , \\rho) = \\left\\{ \\begin{array}{c c} &amp;amp; \\mathsf {t r} = (C _ {1}, \\ldots , C _ {\\mu}) \\\\ &amp;amp; \\forall_ {i \\in [ \\mu ]} \\alpha_ {i} = \\mathcal {H} (C, C _ {1}, \\ldots , C _ {i - 1}) \\\\ &amp;amp; M = ((m _ {1}, o _ {1}), \\ldots , (m _ {\\mu}, o _ {\\mu})) \\\\ \\mathsf {c o m . O p e n} (\\mathsf {p p}, C, m, o) = 1 \\\\ &amp;amp; \\forall_ {i \\in [ \\mu ]} \\mathsf {c o m . O p e n} (\\mathsf {p p}, C _ {i}, m _ {i}, o _ {i}) = 1 \\\\ &amp;amp; \\forall_ {i \\in [ \\mu ]} \\mathsf {e x t} (m, \\alpha_ {1}, \\ldots , \\alpha_ {i}) = m _ {i} \\\\ &amp;amp; \\rho (m, m _ {\\mu}, \\alpha_ {1}, \\ldots , \\alpha_ {\\mu}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">is  <span class="math">(Q,\\delta +\\mathsf{negl}(\\lambda))</span>  -hard in the RO model.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider any pair of polynomial time random oracle algorithms <span class="math">\\mathsf{x}\\leftarrow\\mathcal{A}_{1}^{\\mathcal{H}^{\\prime}}(\\mathsf{pp})</span> and <span class="math">\\mathsf{w}\\leftarrow\\mathcal{A}_{2}^{\\mathcal{H}}(\\mathsf{pp},\\mathsf{x})</span> that for setup parameter <span class="math">\\lambda</span> make at most <span class="math">Q=\\mathsf{poly}(\\lambda)</span> queries to their respective oracles <span class="math">\\mathcal{H}^{\\prime}</span> and <span class="math">\\mathcal{H}</span>. For fixed <span class="math">\\mathsf{x}</span> let <span class="math">T_{\\mathcal{H}}(\\mathsf{x})=(T_{1},...,T_{\\mu})</span> denote a random variable representing the output <span class="math">\\mathsf{tr}</span> included in <span class="math">\\mathsf{w}</span> <em>conditioned on</em> the event that <span class="math">w</span> satisfies at least all validity criteria other than possibly the last, i.e. <span class="math">\\rho(m,m_{\\mu},\\alpha_{1},...,\\alpha_{\\mu})=1</span>. Note that <span class="math">T_{\\mathcal{H}}(\\mathsf{x})</span> is also dependent on the randomness of the oracle <span class="math">\\mathcal{H}</span>. Presuming this event occurs with probability at least <span class="math">\\epsilon(\\mathsf{x})</span>, we can repeat <span class="math">\\mathcal{A}_{2}^{\\mathcal{H}}(\\mathsf{pp},\\mathsf{x})</span> on fresh internal randomness (not changing <span class="math">\\mathcal{H}</span>) in expectation <span class="math">1/\\epsilon(\\mathsf{x})</span> times until it outputs <span class="math">\\mathsf{w}</span> satisfying this event with a particular assignment <span class="math">\\mathsf{tr}=(C_{1},...,C_{\\mu})</span> to the random variable <span class="math">T_{\\mathcal{H}}(\\mathsf{x})</span>. Suppose that for any <span class="math">i\\in[\\mu]</span> we then reprogrammed <span class="math">\\mathcal{H}</span> to an oracle <span class="math">\\mathcal{H}^{<em>}</span> by sampling new answers to any subset of the queries <span class="math">\\{q_{j}=(C,C_{1},...,C_{j})\\}_{i\\leq j&lt;\\mu}</span> but keeping all other queries consistent with <span class="math">\\mathcal{H}</span>. For <span class="math">i=\\mu</span> we do not change the oracle and <span class="math">\\mathcal{H}^{</em>}=\\mathcal{H}</span>. Define the random variable <span class="math">T_{\\mathcal{H}^{<em>}}(\\mathsf{x})</span> in the same way for the new oracle <span class="math">\\mathcal{H}^{</em>}</span>. Suppose further that repeating the same experiment with <span class="math">\\mathcal{A}_{2}^{\\mathcal{H}^{<em>}}(\\mathsf{pp},\\mathsf{x})</span> were to return with probability greater than <span class="math">\\delta^{\\prime}(\\mathsf{x})</span> a vector <span class="math">\\mathsf{tr}^{\\prime}=(C_{1}^{\\prime},...,C_{\\mu}^{\\prime})\\neq\\mathsf{tr}</span> where the first distinct index between <span class="math">\\mathsf{tr}^{\\prime}</span> and <span class="math">\\mathsf{tr}</span> is some <span class="math">k\\leq i</span>. For <span class="math">i=\\mu</span> we just repeat the same experiment with <span class="math">\\mathcal{H}</span>. For all <span class="math">i\\in[\\mu]</span> let <span class="math">\\alpha_{i}=\\mathcal{H}(C,C_{1},...,C_{i-1})</span>, let <span class="math">m_{i}=\\mathsf{ext}(m,\\alpha_{1},...,\\alpha_{i})</span>, let <span class="math">\\alpha_{i}^{\\prime}=\\mathcal{H}^{</em>}(C,C_{1}^{\\prime},...,C_{i-1}^{\\prime})</span>, and let <span class="math">m_{i}^{\\prime}=\\mathsf{ext}(m,\\alpha_{1}^{\\prime},...,\\alpha_{i}^{\\prime})</span>. Since the oracle answers to queries <span class="math">C</span> and <span class="math">\\{q_{j}=(C,C_{1},...,C_{\\ell})\\}_{1\\leq\\ell&lt;k}</span> have not changed and <span class="math">(C_{1},...,C_{k-1})=(C_{1}^{\\prime},...,C_{k-1}^{\\prime})</span> it follows that <span class="math">(\\alpha_{1},...,\\alpha_{k})=(\\alpha_{1}^{\\prime},...,\\alpha_{k}^{\\prime})</span> and <span class="math">(m_{1},...,m_{k})=(m_{1}^{\\prime},...,m_{k}^{\\prime})</span>. The result of these two experiments would thus include openings of the distinct commitments <span class="math">C_{k}\\neq C_{k}^{\\prime}</span> to the same message <span class="math">m_{k}=m_{k}^{\\prime}</span>. By computational uniqueness of the commitment scheme, for <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda)</span> and <span class="math">\\mathsf{x}\\leftarrow\\mathcal{A}_{1}^{\\mathcal{H}^{\\prime}}(\\mathsf{pp})</span> either <span class="math">\\delta^{\\prime}(\\mathsf{x})</span> or <span class="math">\\epsilon(\\mathsf{x})</span> is negligible in <span class="math">\\lambda</span>, as we have shown that it is possible to construct and adversary using <span class="math">\\mathcal{A}_{1}</span> and <span class="math">\\mathcal{A}_{2}</span> that on input <span class="math">\\mathsf{pp}</span> breaks the uniqueness of the commitment scheme (Definition 18) in expected time <span class="math">(\\frac{1}{\\epsilon(\\mathsf{x})}+\\frac{1}{\\delta^{\\prime}(\\mathsf{x})})\\cdot\\mathsf{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300">We draw two conclusions from this. For <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(\\lambda)</span> and <span class="math">\\mathsf{x}\\leftarrow\\mathcal{A}_{1}^{\\mathcal{H}^{\\prime}}(\\mathsf{pp})</span>, if <span class="math">\\mathcal{A}_{2}^{\\mathcal{H}}(\\mathsf{pp},\\mathsf{x})</span> succeeds in returning <span class="math">w</span> satisfying the aforementioned event (i.e., all criteria except the last predicate) with non-negligible probability then there is a unique vector <span class="math">(C_{1},...,C_{\\mu})</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{P}[T_{\\mathcal{H}}(\\mathsf{x})=(C_{1},...,C_{\\mu})]\\geq 1-\\mathsf{negl}(\\lambda)</span></li>

      <li>While this unique vector of high support may depend on <span class="math">\\mathcal{H}</span>, for all <span class="math">i\\in[\\mu]</span> the first <span class="math">i</span> components <span class="math">(C_{1},...,C_{i})</span> are independent of the answers to the values <span class="math">\\mathcal{H}(q)</span> for <span class="math">q\\in\\{(C,C_{1},...,C_{j})\\}_{i\\leq j&lt;\\mu}</span>.</li>

    </ol>

    <p class="text-gray-300">If (a) were false then running the experiment above for case <span class="math">i=\\mu</span> would succeed with non-negligible probability <span class="math">\\delta^{\\prime}</span> in returning a distinct assignment to <span class="math">\\mathcal{T}_{\\mathcal{H}}(\\mathsf{x})</span>, which contradicts the computational uniqueness of the commitment scheme as shown above. If (b) were false, then for some <span class="math">i&lt;\\mu</span> the experiment would succeed with non-negligible probability <span class="math">\\delta^{\\prime}</span> in returning a distinct assignment to <span class="math">\\mathcal{T}_{\\mathcal{H}}(\\mathsf{x})</span> where the first index of distinction is <span class="math">k\\leq i</span>, again contradicting the computational uniqueness of the commitment scheme as shown above.</p>

    <p class="text-gray-300">Finally, (b) implies that <span class="math">(\\alpha_{1},...,\\alpha_{\\mu})</span> where <span class="math">\\alpha_{i}=\\mathcal{H}(C,C_{1},...,C_{i})</span> is uniformly distributed and hence <span class="math">\\mathbb{P}[\\rho(m,m_{\\mu},\\alpha_{1},...,\\alpha_{\\mu})=1]\\leq\\delta</span> as stated in the hypothesis. Thus, conditioned on the event that <span class="math">w</span> satisfies at least all validity criteria except the predicate, then its first component is <span class="math">\\mathsf{tr}=(C_{1},...,C_{\\mu})</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>, in which case it fails the last criteria (i.e., the predicate) with probability <span class="math">1-\\delta</span>. In conclusion, by a union bound it satisfies all criteria with probability at most <span class="math">\\delta+\\mathsf{negl}(\\lambda)</span>. ∎</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi</span> is a <span class="math">(k^{(\\mu)},\\delta,\\mathsf{com},\\phi)</span>-almost-special-sound protocol for a relation <span class="math">\\mathcal{R}</span> and a computationally-unique commitment scheme <span class="math">\\mathsf{com}</span> (Definition 18) whose setup runs <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{com}\\text{.}\\mathsf{Setup}(\\lambda)</span> then its FS transform <span class="math">\\Pi_{FS}</span> is an argument of knowledge for <span class="math">\\mathcal{R}</span> in the RO model (Definition 15) with knowledge error:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{err}(\\lambda,Q)=\\frac{(Q+1)\\kappa}{1-\\kappa}+2\\lambda(k^{\\mu}+Q\\cdot(k^{\\mu}-1))\\cdot\\delta+\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa=1-(1-\\frac{k}{2^{\\lambda}})^{\\mu}</span>.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{V}^{\\mathcal{H}}</span> denote the resulting verifier for <span class="math">\\Pi_{FS}</span>. We will construct an extractor <span class="math">\\mathcal{E}</span> which is given black-box access to any <em>deterministic</em> <span class="math">Q</span>-query prover algorithm <span class="math">\\mathcal{P}^{<em>}</span>, where <span class="math">Q</span> is assumed to be polynomial in <span class="math">\\lambda</span>. <span class="math">\\mathcal{E}</span> has the power to intercept and respond to the queries <span class="math">\\mathcal{P}^{</em>}</span> makes to the random oracle, simulating (i.e., reprogramming) the oracle responses. On input <span class="math">x</span> and parameters <span class="math">\\mathsf{pp}</span>, <span class="math">\\mathcal{E}</span> first tests that <span class="math">\\mathcal{P}^{*}</span> outputs a proof <span class="math">\\pi</span> such that <span class="math">\\mathcal{V}^{\\mathcal{H}}(\\mathsf{pp},x,\\pi)=1</span> and</p>

    <p class="text-gray-300">otherwise aborts. If this first step succeeds, then <span class="math">\\mathcal{E}</span> continues by running the tree generation algorithm from Lemma 5 to generate a <span class="math">(k + 1)</span>-ary forking transcript tree. Given black-box access to a deterministic <span class="math">Q</span>-query prover algorithm, this tree generation algorithm runs in expected polynomial time <span class="math">k^{\\mu} + Q \\cdot (k^{\\mu} - 1)</span> succeeding with probability <span class="math">\\frac{\\epsilon(x) - (Q + 1)\\cdot\\kappa}{(1 - \\kappa)}</span> where <span class="math">\\kappa = 1 - (1 - \\frac{k}{2^{\\lambda}})^{\\mu}</span> and <span class="math">\\epsilon(x)</span> is the probability over the randomness of <span class="math">\\mathcal{H}</span> that <span class="math">\\mathcal{P}^{\\star}</span> outputs a non-interactive proof that <span class="math">\\mathcal{V}^{\\mathcal{H}}</span> accepts. <span class="math">\\mathcal{E}</span> will repeat <span class="math">\\lambda</span> iterations of running this tree generation algorithm for <span class="math">2(k^{\\mu} + Q \\cdot (k^{\\mu} - 1))</span> steps each time, and returns the first trial that succeeds. By Markov, this results in a new tree generation algorithm that runs in strict polynomial time <span class="math">2\\lambda (k^{\\mu} + Q \\cdot (k^{\\mu} - 1))</span> with negligible loss <span class="math">2^{-\\lambda}</span> in its probability of success.</p>

    <p class="text-gray-300">For any <span class="math">(k + 1)</span>-ary transcript tree, there is a polynomial time procedure (Definition 11) which as shown in Lemma 14 either:</p>

    <p class="text-gray-300">(a) Extracts a witness <span class="math">w</span> such that <span class="math">(x, w) \\in \\mathcal{R}</span>.</p>

    <p class="text-gray-300">(b) Extracts a break to the binding of the commitment scheme, i.e. an element of <span class="math">\\mathcal{L}_{\\mathrm{break}}(\\mathsf{pp})</span> defined in Theorem 7.</p>

    <p class="text-gray-300">(c) Extracts an opening <span class="math">(m_{\\omega}, o_{\\omega})</span> for the commitment label on some node <span class="math">\\omega</span> at some level <span class="math">i</span> with rightmost child <span class="math">\\nu</span> at level <span class="math">i + 1</span> such that <span class="math">\\phi_8(i, m_{\\omega}) = 1</span>, <span class="math">\\phi_a(i, m_{\\omega}) = 0</span>, openings of all commitment labels on the leftmost path <span class="math">\\mathsf{lpath}(\\nu)</span> extending down from <span class="math">\\nu</span> to messages equal to <span class="math">\\mathsf{Extend}(i, m, \\alpha_i, \\dots, \\alpha_\\mu) = (m_i, \\dots, m_\\mu)</span> where <span class="math">(\\alpha_i, \\dots, \\alpha_\\mu)</span> are the verifier challenges along this path such that <span class="math">\\forall_{j \\geq i} \\phi_a(j, m_j) = 1</span>.</p>

    <p class="text-gray-300">The third extraction event was ruled out (with overwhelming probability) from any transcript tree generated via the Path Predicate Forking Lemma, see Theorem 7 and Lemma 11. In particular, the transcript tree generated there was shown to satisfy a predicate (with overwhelming probability) that eliminates the possibility that <span class="math">\\phi_a(i, m_\\omega) = 0</span> yet <span class="math">\\phi_a(\\mu, m_\\mu) = 1</span>. The analysis leveraged the way that transcripts are sampled by that tree generation algorithm. However, we will need to use a slightly different analysis this time.</p>

    <p class="text-gray-300">First, we define the relation for all <span class="math">i \\in [\\mu]</span>, commitment scheme parameters <span class="math">\\mathsf{pp}</span>, and random oracle <span class="math">\\mathcal{H}^{\\star}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {e v t}} ^ {\\mathcal {H} ^ {\\star}} (\\mathsf {p p}, \\mu - i) = \\left\\{ \\begin{array}{c} \\mathsf {t r} = (\\mathsf {x}, C _ {1}, \\dots , C _ {\\mu - i}) \\\\ \\forall_ {j \\in [ \\mu - i ]} \\alpha_ {j} = \\mathcal {H} ^ {\\star} (C, C _ {1}, \\dots , C _ {j - 1}) \\\\ M = ((m _ {1}, o _ {1}), \\dots , (m _ {\\mu - i}, o _ {\\mu - i})) \\\\ \\forall_ {j \\in [ \\mu - i ]} \\mathsf {c o m}. \\mathsf {O p e n} (\\mathsf {p p}, C _ {j}, m _ {j}, o _ {j}) = 1 \\\\ \\mathsf {E x t e n d} (i, m, \\alpha_ {1}, \\dots , \\alpha_ {\\mu - i}) = (m _ {1}, \\dots , m _ {\\mu - i}) \\\\ \\phi_ {8} (i, m) = 1, \\phi_ {a} (i, m) = 0, \\phi_ {a} (\\mu , m _ {\\mu - i}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">We note that by Lemma 5, in case (c) occurs, there is a <span class="math">(Q + \\mu)</span>-query polynomial time algorithm <span class="math">\\mathcal{A}_1</span> that generates <span class="math">(C,m,o)</span> and transcript prefix <span class="math">\\mathbf{y}</span>, and an independent <span class="math">(Q + \\mu)</span>-query adversary <span class="math">\\mathcal{A}_2^{\\mathcal{H}^\\star}</span> which generates the witness <span class="math">(\\operatorname{tr},M)</span> such that <span class="math">((C,m,o),(\\operatorname{tr},M)) \\in \\mathcal{R}_{\\mathrm{ext}}^{\\mathcal{H}_2^\\star}(\\mathsf{pp},\\mu -i)</span> for some <span class="math">i</span>. <span class="math">\\mathcal{A}_1</span> represents the algorithm that ran the partial tree generation that created all labels on the left <span class="math">k</span>-ary subtree of <span class="math">\\omega</span> and also the prefix <span class="math">\\mathbf{y}</span> labeling the trunk (i.e., from root to <span class="math">\\omega</span>) of subtree <span class="math">S_{\\nu}</span>, and then also ran the tree extraction algorithm (Definition 11) on this left <span class="math">k</span>-ary subtree of <span class="math">\\omega</span>. Note that conditioned on event (c), <span class="math">\\omega</span> is the first node and index <span class="math">i</span> for which this tree extraction succeeds in producing an opening <span class="math">(m_{\\omega},o_{\\omega})</span> such that <span class="math">\\phi_8(i,m_\\omega) = 1</span> but <span class="math">\\phi_a(i,m_\\omega) = 0</span>. By Lemma 5 the root-to-leaf path that includes the prefix <span class="math">\\mathbf{y}</span> and <span class="math">\\mathsf{lpath}(\\nu)</span> matches the output of some <span class="math">\\mathcal{A}_2^{\\mathcal{H}^\\star}(x)</span> with partially fresh random oracle <span class="math">\\mathcal{H}^\\star</span>, and there is also a subtree generation algorithm that is a <span class="math">(Q + \\mu)</span>-query algorithm which generated the labels on subtree <span class="math">S_{\\nu}</span>. <span class="math">\\mathcal{A}_2^{\\mathcal{H}^\\star}</span> represents the combination of these two algorithms and also the subtree extractor that opens the commitments on these labels. Conditioned on <span class="math">(c)</span>, the openings of the commitment labels within this subtree all satisfy predicate <span class="math">\\phi_a</span> and the opened messages of the commitment labels <span class="math">\\mathsf{lpath}(\\nu)_0</span> along the leftmost path from <span class="math">\\nu</span> match the output of <span class="math">\\mathsf{Extend}(i,m,\\mathsf{lpath}(v)_1)</span> where <span class="math">\\mathsf{lpath}(\\nu)_1</span> are the challenge labels along this path.</p>

    <p class="text-gray-300">Let <span class="math">\\rho_{i}</span> denote the predicate such that <span class="math">\\rho_{i}(m,m^{\\prime},\\alpha_{1},\\dots,\\alpha_{\\mu -i}) = 1</span> iff <span class="math">\\phi_8(i,m) = 1</span>, <span class="math">\\phi_{a}(i,m) = 0</span>, and <span class="math">\\phi_{a}(\\mu ,m^{\\prime}) = 1</span>. By the definition of <span class="math">(k^{(\\mu)},\\delta ,\\mathsf{com},\\phi)</span>-almost-special-soundness, for uniform random <span class="math">\\beta_{1},\\ldots ,\\beta_{\\mu -i}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} _ {\\beta_ {1}, \\dots , \\beta_ {\\mu - i}} [ \\rho (m, m _ {\\mu - i}, \\beta_ {1}, \\dots , \\beta_ {\\mu - i}) = 1: \\mathsf {E x t e n d} (i, m, \\beta_ {1}, \\dots , \\beta_ {\\mu - i}) = (m _ {1}, \\dots , m _ {\\mu - i}) ] \\leq \\delta</span></div>

    <p class="text-gray-300">Thus, since <span class="math">Q + \\mu</span> is polynomial in <span class="math">\\lambda</span>, by Lemma 5 the relation <span class="math">\\mathcal{R}_{\\mathrm{set}}^{H^*}(\\mathsf{pp}, \\mu - i)</span> is <span class="math">(Q + \\mu, \\delta + \\mathrm{negl}(\\lambda))</span>-hard in the RO model for <span class="math">Q = \\mathrm{poly}(\\lambda)</span>. This shows that for any particular index in the transcript tree, the event of type (c) occurs with probability at most <span class="math">\\delta + \\mathrm{negl}(\\lambda)</span> when running the extractor with polynomial time provers making a polynomial number of queries to the RO. This experiment may effectively occur times over the course of the tree generation algorithm, but we can loosely union bound the probability that event (c) ever occurs by the runtime of the tree generation algorithm. Similarly, we can eliminate event (b) as occurring with <span class="math">\\mathrm{negl}(\\lambda)</span> by the computational binding property of the commitment scheme, which does not require an additional union bound.</p>

    <p class="text-gray-300">Finally, letting <span class="math">\\epsilon(x, \\mathbf{st})</span> denote the probability over the parameters and random oracle that the verifier accepts the proof <span class="math">\\pi</span> output by <span class="math">P^{*}(\\mathbf{st})</span> for public input <span class="math">x</span>, we conclude that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {P} \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ (x, w) \\in \\mathcal {R} a n d &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\mathcal {V} ^ {\\mathcal {H}} (\\mathsf {p p}, x, \\pi) = 1 &amp;amp; \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\\\ &amp;amp; w \\leftarrow \\mathcal {E} ^ {P ^ {*} (\\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right] = \\mathbb {P} \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ (x, w) \\in \\mathcal {R}: &amp;amp; (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\\\ &amp;amp; w \\leftarrow \\mathcal {E} ^ {P ^ {*} (\\mathsf {s t})} (\\mathsf {p p}, x) \\end{array} \\right]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\sum_ {x, \\mathbf {s t}} \\left(\\frac {\\epsilon (x , \\mathbf {s t}) - (Q + 1) \\kappa}{1 - \\kappa} - 2 \\lambda (k ^ {\\mu} + Q \\cdot (k ^ {\\mu} - 1)) \\cdot \\delta - \\mathrm {n e g l} (\\lambda)\\right) \\cdot \\mathbb {P} [ \\mathcal {A} (\\mathsf {p p}) = (x, \\mathbf {s t}): \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) ]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\geq \\mathbb {P} \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (\\lambda) \\\\ \\mathcal {V} ^ {\\mathcal {H}} (\\mathsf {p p}, x, \\pi) = 1 &amp;amp; : (x, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}) \\\\ &amp;amp; \\pi \\leftarrow P ^ {*} (\\mathsf {s t}) \\end{array} \\right] - \\frac {(Q + 1) \\kappa}{1 - \\kappa} - 2 \\lambda (k ^ {\\mu} + Q \\cdot (k ^ {\\mu} - 1)) \\cdot \\delta - \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">The first equality holds because <span class="math">\\mathcal{E}^{P^<em>(\\mathrm{st})}(\\mathrm{pp}, x)</span> aborts in its first step if the deterministic <span class="math">\\mathcal{P}^</em>(\\mathrm{st})</span> outputs <span class="math">\\pi</span> such that <span class="math">\\mathcal{V}^{\\mathcal{H}}(\\mathrm{pp}, x, \\pi) \\neq 1</span>.</p>

    <h2 id="sec-100" class="text-2xl font-bold">E Proof of Theorem 4 (Polynomial IOP Compilation)</h2>

    <p class="text-gray-300">Theorem 4. If the polynomial commitment scheme <span class="math">\\Gamma</span> has witness-extended emulation, and if the <span class="math">t</span>-round Polynomial IOP for <span class="math">\\mathcal{R}</span> has negligible knowledge error, then <span class="math">\\Pi</span> is a public-coin interactive argument for <span class="math">\\mathcal{R}</span> that has witness-extended emulation. The compilation also preserves HVZK if <span class="math">\\Gamma</span> is hiding and Eval is HVZK.</p>

    <p class="text-gray-300">The fact that the compilation preserves HVZK is straightforward. We prove this part first and then move on to proving witness-extended emulation.</p>

    <h2 id="sec-101" class="text-2xl font-bold">HVZK</h2>

    <p class="text-gray-300">Proof. Let <span class="math">S_{\\mathsf{Eval}}</span> denote the HVZK simulator for Eval and <span class="math">S_{\\mathsf{IOP}}</span> denote the HVZK simulator for the original polynomial IOP. We construct an HVZK simulator <span class="math">S</span> for the compiled interactive argument as follows. <span class="math">S</span> begins by running <span class="math">S_{\\mathsf{IOP}}</span> on the input <span class="math">x</span>, which produces a series of query/response pairs to arbitrarily labeled oracles that are "sent" from the IOP prover to the verifier. <span class="math">S</span> simulates the view of the honest verifier in the compiled interactive proof by replacing each distinctly labeled oracle with a fresh <span class="math">\\Gamma</span> commitment to 0, i.e., the zero polynomial over <span class="math">\\mathbb{F}_p</span>. By the hiding property of <span class="math">\\Gamma</span> this has negligible distance <span class="math">\\delta_0</span> from the commitment sent in the real protocol. (It places this commitment at the location in the transcript where the commitment to this oracle would be sent in the compiled protocol). For each query/response pair <span class="math">(z,y)</span> to an oracle, <span class="math">S</span> runs <span class="math">S_{\\mathsf{Eval}}</span> to simulate the view of an honest-verifier in the Eval protocol opening a hiding polynomial commitment to the value <span class="math">y</span> at the point <span class="math">z</span>. Let <span class="math">P</span> denote an upper bound on the total number of oracles sent and <span class="math">Q</span> denote an upper bound on the total number of queries to IOP oracles. If the simulation of <span class="math">S_{\\mathsf{IOP}}</span> has statistical distance <span class="math">\\delta_1</span> from the real IOP verifier's view, and each simulated Eval subprotocol has statistical distance <span class="math">\\delta_2</span> to the real Eval verifier's view, then the output of <span class="math">S</span> has statistical distance at most <span class="math">P\\delta_0 + \\delta_1 + Q\\delta_2</span> from <span class="math">\\mathsf{View}_{(P(x,w),V(x))}</span>. For <span class="math">P,Q &amp;lt; \\mathsf{poly}(\\lambda)</span> and <span class="math">\\delta_0,\\delta_1,\\delta_2 &amp;lt; \\mathsf{negl}(\\lambda)</span> this statistical distance is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Witness-extended emulation (knowledge)</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Without loss of generality, assume the original IOP makes at least one query to each oracle sent. An oracle which is never queried can be omitted from the IOP.</p>

    <p class="text-gray-300">We denote by <span class="math">\\mathcal{V}</span> the IP verifier for the compiled IP, and <span class="math">\\mathcal{V}_{O}</span> the verifier for the original IOP. Given a record oracle <span class="math">\\mathsf{Record}(P^{<em>},\\mathsf{pp},x,\\mathsf{st})</span> for an IP prover <span class="math">P^{</em>}</span> that produces accepting transcripts with non-negligible probability, we build an emulator <span class="math">E</span> for the compiled IP. <span class="math">E</span> begins by constructing an IOP adversary <span class="math">P^{\\prime}_{O}</span>, which succeeds also with non-negligible probability on input <span class="math">x</span>. Every successful interaction of <span class="math">P^{\\prime}_{O}</span> with <span class="math">\\mathcal{V}_{O}</span> on input <span class="math">x</span> corresponds to a successful transcript of <span class="math">P^{*}</span> with <span class="math">V</span> on <span class="math">x</span>. In showing how <span class="math">E</span> builds <span class="math">P^{\\prime}_{O}</span> we also show how <span class="math">E</span> can obtain this corresponding transcript. <span class="math">E</span> will make use of the emulator <span class="math">E_{\\mathsf{Eval}}</span> for the commitment scheme <span class="math">\\Gamma</span>.</p>

    <p class="text-gray-300">Finally, <span class="math">E</span> can use the IOP knowledge extractor <span class="math">E_{\\mathsf{IOP}}^{P^{\\prime}_{O}}(x)</span> in order to output a witness for <span class="math">x</span> along with the corresponding transcript.</p>

    <h4 id="sec-103" class="text-lg font-semibold mt-6">Constructing <span class="math">P^{\\prime}_{O}</span> (IOP adversary)</h4>

    <p class="text-gray-300"><span class="math">P^{\\prime}_{O}</span> runs as follows on initial state <span class="math">\\mathsf{st}_{0}</span> and input <span class="math">x</span>. It internally simulates the interaction of <span class="math">P^{<em>}</span> and <span class="math">V</span>, using the record oracle <span class="math">\\mathsf{Record}(P^{</em>},\\mathsf{pp},x,\\mathsf{st})</span>. It begins by running this for the first round on state <span class="math">\\mathsf{st}_{0}</span>. For every message that <span class="math">P^{<em>}</span> sends in this first round, <span class="math">P^{\\prime}_{O}</span> continues simulation until there is an <span class="math">\\mathsf{Eval}</span> on this commitment. (There is guaranteed to be at least one <span class="math">\\mathsf{Eval}</span> on each commitment, independent of the randomness). Therefore, denoting by <span class="math">E_{\\mathsf{Eval}}</span> the extractor for the <span class="math">\\mathsf{Eval}</span> subprotocol between <span class="math">P^{</em>}</span> and <span class="math">\\mathcal{V}</span> on a given commitment and evaluation point, the record oracle can be used to simulate <span class="math">E_{\\mathsf{Eval}}</span>’s record oracle.</p>

    <p class="text-gray-300">For each message <span class="math">m</span> that <span class="math">P^{*}</span> sends to <span class="math">V</span> at the beginning of the first round, <span class="math">P^{\\prime}_{O}</span> interprets <span class="math">m</span> as a commitment, and attempts to extract from it a polynomial by running the PPT emulator <span class="math">E_{\\mathsf{Eval}}</span>, simulating its record oracle as just described. If it fails in any extraction attempt it aborts.</p>

    <p class="text-gray-300">If <span class="math">P^{\\prime}_{O}</span> succeeds in all these extractions, then it uses these extracted polynomials as its first round proof oracles that it gives to <span class="math">\\mathcal{V}_{O}</span>. Upon receiving the first public-coin challenge from the IOP verifier, <span class="math">P^{\\prime}</span> uses the query function to derive the corresponding queries to each of these proof oracles. Before answering, it rewinds <span class="math">P^{<em>}</span> and <span class="math">\\mathcal{V}</span> back to the point immediately after <span class="math">P</span> sent its first messages, and now substitutes random challenge from <span class="math">\\mathcal{V}_{O}</span> in order to simulate <span class="math">P^{</em>}</span> and <span class="math">V</span> on these same queries. It checks that <span class="math">P^{*}</span>’s answers are consistent with the answers it can compute on its own from the extracted polynomials. If any answers are inconsistent, <span class="math">P^{\\prime}_{O}</span> aborts. Otherwise, it sends the answers to <span class="math">\\mathcal{V}_{O}</span>.</p>

    <p class="text-gray-300">At the end of this first round (assuming <span class="math">P^{\\prime}</span> has not yet aborted), <span class="math">P^{\\prime}_{O}</span> has stored an updated state <span class="math">\\mathsf{st}^{\\prime}</span> for <span class="math">P^{<em>}</span> based on this simulation. It proceeds to the next round and repeats the same process, using the record oracle <span class="math">\\mathsf{Record}(P^{</em>},\\mathsf{pp},x,\\mathsf{st}^{\\prime})</span>. Finally, if <span class="math">P^{\\prime}</span> makes it through all rounds without aborting, then it has a final state <span class="math">\\mathsf{st}_{V}</span> for <span class="math">\\mathcal{V}_{O}</span> based on its internal simulation of <span class="math">P^{*}</span> and <span class="math">V</span> up through the end of the last round. Finally, <span class="math">\\mathcal{V}_{O}(\\mathsf{st}_{V})</span> outputs <span class="math">\\mathsf{Accept}</span> or <span class="math">\\mathsf{Reject}</span>.</p>

    <h4 id="sec-104" class="text-lg font-semibold mt-6">Analysis of <span class="math">P^{\\prime}_{O}</span> success probability</h4>

    <p class="text-gray-300">We claim that if <span class="math">\\mathsf{Record}(P^{*},\\mathsf{pp},x,\\mathsf{st}_{0})</span> outputs an accepting transcript <span class="math">\\mathsf{tr}</span> with non-negligible probability, then <span class="math">P^{\\prime}_{O}</span> succeeds with non-negligible probability.</p>

    <p class="text-gray-300">Observe that for any accepting <span class="math">\\mathsf{tr}</span> between <span class="math">P^{*}</span> and <span class="math">V</span>, if <span class="math">P^{\\prime}_{O}</span> happens to follow the same exact sequence of query/responses without ever aborting then it succeeds because <span class="math">\\mathcal{V}_{O}</span> and <span class="math">\\mathcal{V}</span> run the same decision algorithm on the final state of query/response pairs. Thus, it remains only to take a closer look at what events cause <span class="math">P^{\\prime}_{O}</span> to abort, and bound the fraction of accepting <span class="math">\\mathsf{tr}</span> for which this occurs.</p>

    <p class="text-gray-300">As indicated in bold above, there are two kinds of events that cause <span class="math">P^{\\prime}_{O}</span> to abort:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It fails to extract from a “commitment” message <span class="math">m</span> sent by <span class="math">P^{*}</span></li>

      <li>After successfully extracting a polynomial <span class="math">f</span> from a commitment, <span class="math">P^{*}</span> answer queries to <span class="math">f</span> in a way that is inconsistent with <span class="math">f</span>.</li>

    </ul>

    <p class="text-gray-300">The second type of event contradicts the evaluation binding property of <span class="math">\\Gamma</span>, therefore it occurs with negligible probability.</p>

    <p class="text-gray-300">To analyze the first type of event, let us define “bad commitments” for a parameter <span class="math">D</span>. We define this as a property of a message <span class="math">m</span> (purportedly a commitment) sent in a transcript state <span class="math">\\mathsf{st}</span></p>

    <h5 id="sec-105" class="text-base font-semibold mt-4">Bounding probability of commitment extraction failure</h5>

    <p class="text-gray-300">The pair <span class="math">(m,\\mathsf{st})</span> is a “bad commitment” if there is less than a <span class="math">1/D</span> probability that extending the transcript between <span class="math">P^{*}</span> and <span class="math">\\mathcal{V}</span>, starting from state <span class="math">\\mathsf{st}</span>, will contain a successful execution of <span class="math">\\mathsf{Eval}</span> on <span class="math">m</span>. This probability is over the randomness of the public-coins of <span class="math">\\mathcal{V}</span> in the extended transcript.</p>

    <p class="text-gray-300">Let <span class="math">A(\\mathsf{tr})</span> denote the event that a transcript <span class="math">\\mathsf{tr}</span> sampled from <span class="math">\\mathsf{Record}(P^{*},\\mathsf{pp},x,\\mathsf{st}_{0})</span> is accepting. Let <span class="math">B(\\mathsf{tr})</span> denote the event that <span class="math">\\mathsf{tr}</span> contains a “bad commitment” (i.e. some message <span class="math">m</span> sent in state <span class="math">\\mathsf{st}</span> such that <span class="math">\\mathsf{Bad}(m,\\mathsf{st})=1</span>). The conditional probability of event <span class="math">A(\\mathsf{tr})</span> conditioned on event <span class="math">B(\\mathsf{tr})</span> is less than <span class="math">1/D</span>. To see this, fix <span class="math">(m,\\mathsf{st})</span> with <span class="math">\\mathsf{Bad}(m,\\mathsf{st})=1</span> and consider “sampling” a random <span class="math">\\mathsf{tr}</span> that contains <span class="math">m</span> at state <span class="math">\\mathsf{st}</span>. This is done by first choosing randomly from all partial transcripts that result in <span class="math">(m,\\mathsf{st})</span> via brute force, and then running the transcript normally from state <span class="math">\\mathsf{st}</span> on random public-coins. No matter how <span class="math">(m,\\mathsf{st})</span> is chosen, the probability that this process produces an accepting transcript is by definition less than <span class="math">1/D</span>. (The second part of the transcript following <span class="math">(m,\\mathsf{st})</span> contains at least one execution of <span class="math">\\mathsf{Eval}</span> on <span class="math">m</span> by hypothesis, and by the definition of <span class="math">B(m,\\mathsf{st})=1</span> this execution is accepting with probability less than <span class="math">1/D</span>).</p>

    <p class="text-gray-300">Assume that <span class="math">P(A(\\mathsf{tr}))\\geq 1/\\mathsf{poly}(\\lambda)</span>. Applying Bayes’ law,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P[B(\\mathsf{tr})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A(\\mathsf{tr}))\\leq\\frac{P[A(\\mathsf{tr})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B(\\mathsf{tr})]}{P(A(\\mathsf{tr}))}\\leq\\mathsf{poly}(\\lambda)/D\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, at least a <span class="math">1-\\mathsf{poly}(\\lambda)/D</span> fraction of accepting transcripts do not contain “bad commitments”. Furthermore, so long as a commitment <span class="math">m</span> is not “bad”, we can invoke the witness-emulation property of <span class="math">\\mathsf{Eval}</span> to say that the PPT <span class="math">E_{\\Gamma}</span> emulator extracts a witness polynomial from each <span class="math">m</span> with overwhelming probability.</p>

    <p class="text-gray-300">Setting <span class="math">D=2\\mathsf{poly}(\\lambda)</span> we get that on at least a <span class="math">1/2</span> fraction of accepting transcripts, <span class="math">P_{\\mathcal{O}}^{\\prime}</span>s simulation also succeeds (i.e. successfully extracts from each prover commitment message) with probability at least <span class="math">1/2</span>. This means that <span class="math">P_{\\mathcal{O}}^{\\prime}</span> has a non-negligible success probability conditioned on the event that <span class="math">\\mathsf{tr}</span> is an accepting transcript.</p>

    <p class="text-gray-300">In conclusion, if <span class="math">\\mathsf{tr}</span> is accepting with non-negligible probability, then there is a non-negligible probability that <span class="math">P_{\\mathcal{O}}^{\\prime}</span> succeeds. ∎</p>

    <h2 id="sec-106" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Transparent SNARKs from DARK Compilers (2019/1229)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1229
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
