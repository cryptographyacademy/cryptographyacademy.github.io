---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/119';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Breaking &#x27;128-bit Secure&#x27; Supersingular Binary Curves?';
const AUTHORS_HTML = '(or how to solve discrete logarithms in F24·&lt;sup&gt;1223&lt;/sup&gt; and F212·367)';

const CONTENT = `    <p class="text-gray-300">(or how to solve discrete logarithms in F24·&lt;sup&gt;1223&lt;/sup&gt; and F212·367)</p>

    <p class="text-gray-300">Robert Granger&lt;sup&gt;1&lt;/sup&gt; , Thorsten Kleinjung&lt;sup&gt;1&lt;/sup&gt; , and Jens Zumbr¨agel&lt;sup&gt;2&lt;/sup&gt;</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; Laboratory for Cryptologic Algorithms, EPFL, Switzerland 2 Institute of Algebra, TU Dresden, Germany robbiegranger@gmail.com, thorsten.kleinjung@epfl.ch, jens.zumbragel@ucd.ie</p>

    <p class="text-gray-300">Abstract. In late 2012 and early 2013 the discrete logarithm problem (DLP) in finite fields of small characteristic underwent a dramatic series of breakthroughs, culminating in a heuristic quasipolynomial time algorithm, due to Barbulescu, Gaudry, Joux and Thom´e. Using these developments, Adj, Menezes, Oliveira and Rodr´ıguez-Henr´ıquez analysed the concrete security of the DLP, as it arises from pairings on (the Jacobians of) various genus one and two supersingular curves in the literature, which were originally thought to be 128-bit secure. In particular, they suggested that the new algorithms have no impact on the security of a genus one curve over F2&lt;sup&gt;1223&lt;/sup&gt; , and reduce the security of a genus two curve over F2&lt;sup&gt;367&lt;/sup&gt; to 94.6 bits. In this paper we propose a new field representation and efficient general descent principles which together make the new techniques far more practical. Indeed, at the '128-bit security level' our analysis shows that the aforementioned genus one curve has approximately 59 bits of security, and we report a total break of the genus two curve.</p>

    <p class="text-gray-300">Keywords: Discrete logarithm problem, finite fields, supersingular binary curves, pairings</p>

    <p class="text-gray-300">The role of small characteristic supersingular curves in cryptography has been a varied and an interesting one. Having been eschewed by the cryptographic community for succumbing spectacularly to the subexponential MOV attack in 1993 [40], which maps the DLP from an elliptic curve (or more generally, the Jacobian of a higher genus curve) to the DLP in a small degree extension of the base field of the curve, they made a remarkable comeback with the advent of pairing-based cryptography in 2001 [42, 31, 9]. In particular, for the latter it was reasoned that the existence of a subexponential attack on the DLP does not ipso facto warrant their complete exclusion; rather, provided that the finite field DLP into which the elliptic curve DLP embeds is sufficiently hard, this state of affairs would be acceptable.</p>

    <p class="text-gray-300">Neglecting the possible existence of native attacks arising from the supersingularity of these curves, much research effort has been expended in making instantiations of the required cryptographic operations on such curves as efficient as possible [6, 17, 14, 28, 27, 5, 30, 7, 11, 18, 3, 1], to name but a few, with the associated security levels having been estimated using Coppersmith's algorithm from 1984 [12, 39]. Alas, a series of dramatic breakthrough results for the DLP in finite fields of small characteristic have potentially rendered all of these efforts in vain.</p>

    <p class="text-gray-300">The first of these results was due to Joux, in December 2012, and consisted of a more efficient method — dubbed 'pinpointing' — to obtain relations between factor base elements [32]. For medium-sized base fields, this technique has heuristic complexity as low as L(1/3, 2 1/3 ) ≈ L(1/3, 1.260)† , where as usual L(α, c) = LQ(α, c) = exp((c + o(1))(log Q) &lt;sup&gt;α&lt;/sup&gt;(log log Q) &lt;sup&gt;1&lt;/sup&gt;−α), with</p>

    <p class="text-gray-300">&lt;sup&gt;?&lt;/sup&gt; The second author acknowledges the support of the Swiss National Science Foundation, via grant numbers 206021-128727 and 200020-132160, while the third author acknowledges the support of the Irish Research Council, grant number ELEVATEPD/2013/82.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt; The original paper states a complexity of L(1/3,(8/9)&lt;sup&gt;1&lt;/sup&gt;/&lt;sup&gt;3&lt;/sup&gt; ) ≈ L(1/3, 0.961); however, on foot of recent communications the constant should be as stated.</p>

    <p class="text-gray-300">Q the cardinality of the field. This improved upon the previous best complexity of  <span class="math">L(1/3,3^{1/3}) \\approx L(1/3,1.442)</span>  due to Joux and Lercier [37]. Using this technique Joux solved example DLPs in fields of bitlength 1175 and 1425, both with prime base fields.</p>

    <p class="text-gray-300">Then in February 2013, Göloğlu, Granger, McGuire and Zumbrägel used a specialisation of the Joux-Lercier doubly-rational function field sieve (FFS) variant [37], in order to exploit a well-known family of 'splitting polynomials', i.e., polynomials which split completely over the base field [19]. For fields of the form  <span class="math">\\mathbb{F}_{q^{kn}}</span>  with  <span class="math">k \\geq 3</span>  fixed (k = 2 is even simpler) and  <span class="math">n \\approx dq</span>  for a fixed integer  <span class="math">d \\geq 1</span> , they showed that for binary (and more generally small characteristic) fields, relation generation for degree one elements runs in heuristic polynomial time, as does finding the logarithms of degree two elements (if  <span class="math">q^k</span>  can be written as  <span class="math">q&#x27;^{k&#x27;}</span>  for  <span class="math">k&#x27; \\geq 4</span> ), once degree one logarithms are known. For medium-sized base fields of small characteristic a heuristic complexity as low as  <span class="math">L(1/3, (4/9)^{1/3}) \\approx L(1/3, 0.763)</span>  was attained; this approach was demonstrated via the solution of example DLPs in the fields  <span class="math">\\mathbb{F}_{2^{1971}}</span>  [21] and  <span class="math">\\mathbb{F}_{2^{3164}}</span> .</p>

    <p class="text-gray-300">After the initial publication of [19], Joux released a preprint [33] detailing an algorithm for solving the discrete logarithm problem for fields of the form  <span class="math">\\mathbb{F}_{q^{2n}}</span> , with  <span class="math">n \\leq q+d</span>  for some very small d, which was used to solve a DLP in  <span class="math">\\mathbb{F}_{2^{1778}}</span>  [34] and later in  <span class="math">\\mathbb{F}_{2^{4080}}</span>  [35]. For  <span class="math">n \\approx q</span>  this algorithm has heuristic complexity L(1/4+o(1),c) for some undetermined c, and also has a heuristic polynomial time relation generation method, similar in principle to that in [19]. While the degree two element elimination method in [19] is arguably superior – since elements can be eliminated on the fly – for other small degrees Joux's elimination method is faster, resulting in the stated complexity.</p>

    <p class="text-gray-300">In April 2013 Göloğlu <em>et al.</em> combined their approach with Joux's to solve an example DLP in the field  <span class="math">\\mathbb{F}_{2^{6120}}</span>  [22] and later demonstrated that Joux's algorithm can be tweaked to have heuristic complexity L(1/4,c) [20], where c can be as low as  <span class="math">(\\omega/8)^{1/4}</span>  [24], with  <span class="math">\\omega</span>  the linear algebra constant, i.e., the exponent of matrix multiplication. Then in May 2013, Joux announced the solution of a DLP in the field  <span class="math">\\mathbb{F}_{2^{6168}}</span>  [36].</p>

    <p class="text-gray-300">Most recently, in June 2013, Barbulescu, Gaudry, Joux and Thomé announced a quasi-polynomial time for solving the DLP [4], for fields  <span class="math">\\mathbb{F}_{q^{kn}}</span>  with  <span class="math">k \\geq 2</span>  fixed and  <span class="math">n \\leq q+d</span>  with d very small, which for  <span class="math">n \\approx q</span>  has heuristic complexity</p>

    <p class="text-gray-300"><span class="math">$(\\log q^{kn})^{O(\\log\\log q^{kn})}. (1)</span>$</p>

    <p class="text-gray-300">Since (1) is smaller than  <span class="math">L(\\alpha, c)</span>  for any  <span class="math">\\alpha &gt; 0</span> , it is asymptotically the most efficient algorithm known for solving the DLP in finite fields of small characteristic, which can always be embedded into a field of the required form. Interestingly, the algorithmic ingredients and analysis of this algorithm are much simpler than for Joux's L(1/4 + o(1), c) algorithm.</p>

    <p class="text-gray-300">Taken all together, one would expect the above developments to have a substantial impact on the security of small characteristic parameters appearing in the pairing-based cryptography literature. However, all of the record DLP computations mentioned above used Kummer or twisted Kummer extensions (those with n dividing  <span class="math">q^k \\mp 1</span> ), which allow for a reduction in the size of the factor base by a factor of kn and make the descent phase for individual logarithms relatively easy. While such parameters are preferable for setting records (most recently in  <span class="math">\\mathbb{F}_{2^{9234}}</span>  [26]), none of the parameters featured in the literature are of this form, and so it is not a priori clear whether the new techniques weaken existing pairing-based protocol parameters.</p>

    <p class="text-gray-300">A recent paper by Adj, Menezes, Oliveira and Rodríguez-Henríquez has begun to address this very issue [2]. Using the time required to compute a single multiplication modulo the cardinality of the relevant prime order subgroup as their basic unit of time, which we denote by  <span class="math">M_r</span> , they showed that the DLP in the field  <span class="math">\\mathbb{F}_{3^{6\\cdot509}}</span>  costs at most  <span class="math">2^{73.7}</span>   <span class="math">M_r</span> . One can arguably interpret this</p>

    <p class="text-gray-300">result to mean that this field has 73.7 bits of security† . This significantly reduces the intended security level of 128 bits (or 111 bits as estimated by Shinohara et al. [43], or 102.7 bits for the Joux-Lercier FFS variant with pinpointing, as estimated in [2]). An interesting feature of their analysis is that during the descent phase, some elimination steps are performed using the method from the quasi-polynomial time algorithm of Barbulescu et al., when one might have expected these steps to only come into play at much higher bitlengths, due to the high arity of the arising descent nodes.</p>

    <p class="text-gray-300">In the context of binary fields, Adj et al. considered in detail the DLP in the field F&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;12&lt;/sup&gt;·&lt;sup&gt;367&lt;/sup&gt; , which arises via a pairing from the DLP on the Jacobian of a supersingular genus two curve over F&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;367&lt;/sup&gt; , first proposed in [3], with embedding degree 12. Using all of the available techniques they provided an upper bound of 294.&lt;sup&gt;6&lt;/sup&gt; M&lt;sup&gt;r&lt;/sup&gt; for the cost of breaking the DLP in the embedding field, which is some way below the intended 128-bit security level. In their conclusion Adj et al. also suggest that a commonly implemented genus one supersingular curve over F&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;1223&lt;/sup&gt; with embedding degree 4 [30, 7, 11, 18, 1], is not weakened by the new algorithmic advances, i.e., its security remains very close to 128 bits.</p>

    <p class="text-gray-300">In this work we show that the above security estimates were incredibly optimistic. Our techniques and results are summarised as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Field representation: We introduce a new field representation that can have a profound effect on the resulting complexity of the new algorithms. In particular it permits the use of a smaller q than before, which not only speeds up the computation of factor base logarithms, but also the descent (both classical and new).</li>
      <li>Exploit subfield membership: During the descent phase we apply a principle of parsimony, by which one should always try to eliminate an element in the target field, and only when this is not possible should one embed it into an extension field. So although the very small degree logarithms may be computed over a larger field, the descent cost is greatly reduced relative to solving a DLP in the larger field.</li>
      <li>Further descent tricks: The above principle also means that elements can automatically be rewritten in terms of elements of smaller degree, via factorisation over a larger field, and that elements can be eliminated via Joux's Gr¨obner basis computation method [33] with k = 1, rather than k &gt; 1, which increases its degree of applicability.</li>
      <li>'128-bit secure' genus one DLP: We show that the DLP in F&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;4&lt;/sup&gt;·&lt;sup&gt;1223&lt;/sup&gt; can be solved in approximately 2&lt;sup&gt;40&lt;/sup&gt; s, or 2&lt;sup&gt;59&lt;/sup&gt; Mr, with r a 1221-bit prime.</li>
      <li>'128-bit secure' genus two DLP: We report a total break of the DLP in F&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;12&lt;/sup&gt;·&lt;sup&gt;367&lt;/sup&gt; (announced in [25]), which took about 52240 core-hours.</li>
      <li>L(1/4, c) technique only: Interestingly, using our approach the elimination steps \`a la Barbulesu et al. [4] were not necessary for the above estimate and break.</li>
    </ul>

    <p class="text-gray-300">The rest of the paper is organised as follows. In §2 we describe our field representation and our target fields. In §3 we present the corresponding polynomial time relation generation method for degree one elements and degree two elements (although we do not need the latter for the fields targeted in the present paper), as well as how to apply Joux's small degree elimination method [33] with the new representation. We then apply these and other techniques to F&lt;sup&gt;2&lt;/sup&gt; 4·1223 in §4 and to F&lt;sup&gt;2&lt;/sup&gt; &lt;sup&gt;12&lt;/sup&gt;·&lt;sup&gt;367&lt;/sup&gt; in §5 . Finally, we conclude in §6.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt; The notion of bit security is quite fuzzy; for the elliptic curve DLP it is usually intended to mean the logarithm to the base 2 of the expected number of group operations, however for the finite field DLP different authors have used different units, perhaps because the cost of various constituent algorithms must be amortised into a single cost measure. In this work we time everything in seconds, while to achieve a comparison with [2] we convert to Mr.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">2 Field Representation and Target Fields</h4>

    <p class="text-gray-300">In this section we introduce our new field representation and the fields whose DLP security we will address. This representation, as well as some preliminary security estimates, were initially presented in [23].</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Field Representation</h3>

    <p class="text-gray-300">Although we focus on binary fields in this paper, for the purposes of generality, in this section we allow for extension fields of arbitrary characteristic. Hence let  <span class="math">q = p^l</span>  for some prime p, and let  <span class="math">\\mathbb{K} = \\mathbb{F}_{q^{kn}}</span>  be the field under consideration, with  <span class="math">k \\geq 1</span> .</p>

    <p class="text-gray-300">We choose a positive integer  <span class="math">d_h</span>  such that  <span class="math">n \\leq qd_h + 1</span> , and then choose  <span class="math">h_0, h_1 \\in \\mathbb{F}_{q^k}[X]</span>  with  <span class="math">\\max\\{\\deg(h_0), \\deg(h_1)\\} = d_h</span>  such that</p>

    <p class="text-gray-300"><span class="math">$h_1(X^q)X - h_0(X^q) \\equiv 0 \\pmod{I(X)},\\tag{2}</span>$</p>

    <p class="text-gray-300">where I(X) is an irreducible degree n polynomial in  <span class="math">\\mathbb{F}_{q^k}[X]</span> . Then  <span class="math">\\mathbb{K} = \\mathbb{F}_{q^k}[X]/(I(X))</span> . Denoting by x a root of I(X), we introduce the auxiliary variable  <span class="math">y = x^q</span> , so that one has two isomorphic representations of  <span class="math">\\mathbb{K}</span> , namely  <span class="math">\\mathbb{F}_{q^k}(x)</span>  and  <span class="math">\\mathbb{F}_{q^k}(y)</span> , with  <span class="math">\\sigma : \\mathbb{F}_{q^k}(y) \\to \\mathbb{F}_{q^k}(x) : y \\mapsto x^q</span> . To establish the inverse isomorphism, note that by (2) in  <span class="math">\\mathbb{K}</span>  we have  <span class="math">h_1(y)x - h_0(y) = 0</span> , and hence  <span class="math">\\sigma^{-1} : \\mathbb{F}_{q^k}(x) \\to \\mathbb{F}_{q^k}(y) : x \\mapsto h_0(y)/h_1(y)</span> .</p>

    <p class="text-gray-300">The knowledgeable reader will have observed that our representation is a synthesis of two other useful representations: the one used by Joux [33], in which one searches for a degree n factor I(X) of  <span class="math">h_1(X)X^q - h_0(X)</span> ; and the one used by Göloğlu  <span class="math">et\\ al.</span>  [19, 20], in which one searches for a degree n factor I(X) of  <span class="math">X - h_0(X^q)</span> . The problem with the former is that it constrains n to be approximately q. The problem with the latter is that the polynomial  <span class="math">X - h_0(X^q)</span>  is insufficiently general to represent all degrees n up to  <span class="math">qd_h</span> . By changing the coefficient of X in the latter from 1 to  <span class="math">h_1(X^q)</span> , we greatly increase the probability of overcoming the second problem, thus combining the higher degree coverage of Joux's representation with the higher degree possibilities of [19, 20].</p>

    <p class="text-gray-300">The raison d'être of using this representation rather than Joux's representation is that for a given n, by choosing  <span class="math">d_h &gt; 1</span> , one may use a smaller q. So why is this useful? Well, since the complexity of the new descent methods is typically a function of q, then subject to the satisfaction of certain constraints, one may use a smaller q, thus reducing the complexity of solving the DLP. This observation was our motivation for choosing field representations of the above form.</p>

    <p class="text-gray-300">Another advantage of having an  <span class="math">h_1</span>  coefficient (which also applies to Joux's representation) is that it increases the chance of there being a suitable  <span class="math">(h_1, h_0)</span>  pair with coefficients defined over a proper subfield of  <span class="math">\\mathbb{F}_{q^k}</span> , which then permits one to apply the factor base reduction technique of [37], see §4 and §5.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2.2 Target Fields</h4>

    <p class="text-gray-300">For  <span class="math">i \\in \\{0,1\\}</span>  let  <span class="math">E_i/\\mathbb{F}_{2^p}: Y^2+Y=X^3+X+i</span> . These elliptic curves are supersingular and can have prime or nearly prime order only for p prime, and have embedding degree 4 [16, 6, 17]. We focus on the curve</p>

    <p class="text-gray-300"><span class="math">$E_0/\\mathbb{F}_{2^{1223}}: Y^2 + Y = X^3 + X,\\tag{3}</span>$</p>

    <p class="text-gray-300">which has a prime order subgroup of cardinality  <span class="math">r_1 = (2^{1223} + 2^{612} + 1)/5</span> , of bitlength 1221. This curve was initially proposed for 128-bit secure protocols [30] and has enjoyed several optimised</p>

    <p class="text-gray-300">implementations [7, 11, 1, 18]. Many smaller p have also been proposed in the literature (see [5, 16], for instance), and are clearly weaker.</p>

    <p class="text-gray-300">For  <span class="math">i \\in \\{0,1\\}</span>  let  <span class="math">H_i/\\mathbb{F}_{2^p}: Y^2+Y=X^5+X^3+i</span> . These genus two hyperelliptic curves are supersingular and can have a nearly prime order Jacobian only for p prime (note that 13 is always a factor of  <span class="math">\\#\\mathrm{Jac}_{H_0}(\\mathbb{F}_{2^p})</span> , since  <span class="math">\\#\\mathrm{Jac}_{H_0}(\\mathbb{F}_2)=13</span> ), and have embedding degree 12 [5, 16]. We focus on the curve</p>

    <p class="text-gray-300"><span class="math">$H_0/\\mathbb{F}_{2^{367}}: Y^2 + Y = X^5 + X^3, \\tag{4}</span>$</p>

    <p class="text-gray-300">with  <span class="math">\\#\\text{Jac}_{H}(\\mathbb{F}_{2^{367}}) = 13 \\cdot 7170258097 \\cdot r_{2}</span> , and  <span class="math">r_{2} = (2^{734} + 2^{551} + 2^{367} + 2^{184} + 1)/(13 \\cdot 7170258097)</span>  is a 698-bit prime, since this was proposed for 128-bit secure protocols [3], and whose security was analysed in depth by Adj <em>et al.</em> in [2].</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">3 Computing the Logarithms of Small Degree Elements</h3>

    <p class="text-gray-300">In this section we adapt the polynomial time relation generation method from [19] and Joux's small degree elimination method [33] to the new field representation as detailed in §2.1. Note that henceforth, we shall refer to elements of  <span class="math">\\mathbb{F}_{q^{kn}} = \\mathbb{F}_{q^k}[X]/(I(X))</span>  as field elements or as polynomials, as appropriate, and thus use x and X (and y and Y) interchangeably. We therefore freely apply polynomial ring concepts, such as degree, factorisation and smoothness, to field elements.</p>

    <p class="text-gray-300">In order to compute discrete logarithms in our target fields we apply the usual index calculus method. It consists of a precomputation phase in which by means of (sparse) linear algebra techniques one obtains the logarithms of the factor base elements, which will consist of the low degree irreducible polynomials. Afterwards, in the individual logarithm phase, one applies procedures to recursively rewrite each element as a product of elements of smaller degree, in this way building up a descent tree, which has the target element as its root and factor base elements as its leaves. This proceeds in several stages, starting with a continued fraction descent of the target element, followed by a special-Q lattice descent (referred to as degree-balanced classical descent, see [19]), and finally using Joux's Gröbner basis descent [33] for the lower degree elements. Details of the continued fraction and classical descent steps are given in §4, while in this section we provide details of how to find the logarithms of elements of small degree.</p>

    <p class="text-gray-300">We now describe how the logarithms of degree one and two elements (when needed) are to be computed. We use the relation generation method from [19], rather than Joux's method [33], since it automatically avoids duplicate relations. For  <span class="math">k \\geq 2</span>  we first precompute the set  <span class="math">\\mathcal{S}_k</span> , where</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{S}_k = \\{(a, b, c) \\in (\\mathbb{F}_{q^k})^3 \\mid X^{q+1} + aX^q + bX + c \\text{ splits completely over } \\mathbb{F}_{q^k}\\}.</span>$</p>

    <p class="text-gray-300">For k=2, this set of triples is parameterised by  <span class="math">(a,a^q,\\mathbb{F}_q\\ni c\\neq a^{q+1})</span> , of which there are precisely  <span class="math">q^3-q^2</span>  elements. For  <span class="math">k\\geq 3</span> ,  <span class="math">\\mathcal{S}_k</span>  can also be computed very efficiently, as follows. Assuming  <span class="math">c\\neq ab</span>  and  <span class="math">b\\neq a^q</span> , the polynomial  <span class="math">X^{q+1}+aX^q+bX+c</span>  may be transformed (up to a scalar factor) into the polynomial  <span class="math">f_B(\\overline{X})=\\overline{X}^{q+1}+B\\overline{X}+B</span> , where  <span class="math">B=\\frac{(b-a^q)^{q+1}}{(c-ab)^q}</span> , and  <span class="math">X=\\frac{c-ab}{b-a^q}\\overline{X}-a</span> . The set  <span class="math">\\mathcal{L}</span>  of  <span class="math">B\\in\\mathbb{F}_{q^k}</span>  for which  <span class="math">f_B</span>  splits completely over  <span class="math">\\mathbb{F}_{q^k}</span>  can be computed by simply testing for each such B whether this occurs, and there are precisely  <span class="math">(q^{k-1}-1)/(q^2-1)</span>  such B if k is odd, and  <span class="math">(q^{k-1}-q)/(q^2-1)</span>  such B if k is even [8]. Then for any (a,b) such that  <span class="math">b\\neq a^q</span>  and for each  <span class="math">B\\in\\mathcal{L}</span> , we compute via  <span class="math">B=\\frac{(b-a^q)^{q+1}}{(c-ab)^q}</span>  the corresponding (unique)  <span class="math">c\\in\\mathbb{F}_{q^k}</span> , which thus ensures that  <span class="math">(a,b,c)\\in\\mathcal{S}_k</span> . Note that in all cases we have  <span class="math">|\\mathcal{S}_k|\\approx q^{3k-3}</span> .</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">3.1 Degree 1 Logarithms</h4>

    <p class="text-gray-300">We define the factor base  <span class="math">\\mathcal{B}_1</span>  to be the set of linear elements in x, i.e.,  <span class="math">\\mathcal{B}_1 = \\{x - a \\mid a \\in \\mathbb{F}_{q^k}\\}</span> . Observe that the elements linear in y are each expressible in  <span class="math">\\mathcal{B}_1</span> , since  <span class="math">(y - a) = (x - a^{1/q})^q</span> .</p>

    <p class="text-gray-300">As in [37, 19, 20], the basic idea is to consider elements of the form xy + ay + bx + c with  <span class="math">(a, b, c) \\in \\mathcal{S}_k</span> . The above two field isomorphisms induce the following equality in  <span class="math">\\mathbb{K}</span> :</p>

    <p class="text-gray-300"><span class="math">$x^{q+1} + ax^q + bx + c = \\frac{1}{h_1(y)} (yh_0(y) + ayh_1(y) + bh_0(y) + ch_1(y)).</span>$
(5)</p>

    <p class="text-gray-300">When the r.h.s. of (5) also splits completely over  <span class="math">\\mathbb{F}_{q^k}</span> , one obtains a relation between elements of  <span class="math">\\mathcal{B}_1</span>  and the logarithm of  <span class="math">h_1(y)</span> . One can either adjoin  <span class="math">h_1(y)</span>  to the factor base, or simply use an  <span class="math">h_1(y)</span>  which splits completely over  <span class="math">\\mathbb{F}_{q^k}</span> .</p>

    <p class="text-gray-300">We assume that for each  <span class="math">(a, b, c) \\in \\hat{S}_k</span>  that the r.h.s. of (5) – which has degree  <span class="math">d_h + 1</span>  – splits completely over  <span class="math">\\mathbb{F}_{q^k}</span>  with probability  <span class="math">1/(d_h + 1)!</span> . Hence in order for there to be sufficiently many relations we require that</p>

    <p class="text-gray-300"><span class="math">$\\frac{q^{3k-3}}{(d_h+1)!} &gt; q^k</span>$
, or equivalently  <span class="math">q^{2k-3} &gt; (d_h+1)!</span> . (6)</p>

    <p class="text-gray-300">When this holds, the expected cost of relation generation is  <span class="math">(d_h + 1)! \\cdot q^k \\cdot S_{q^k}(1, d_h + 1)</span> , where  <span class="math">S_{q^k}(m, n)</span>  denotes the cost of testing whether a degree n polynomial is m-smooth, i.e., has all of its irreducible factors of degree  <span class="math">\\leq m</span> , see Appendix B. The cost of solving the resulting linear system using sparse linear algebra techniques is  <span class="math">O(q^{2k+1})</span>  arithmetic operations modulo the order r subgroup in which one is working.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.2 Degree 2 Logarithms</h3>

    <p class="text-gray-300">For degree two logarithms, there are several options. The simplest is to apply the degree one method over a quadratic extension of  <span class="math">\\mathbb{F}_{q^k}</span> , but in general (without any factor base automorphisms) this will cost  <span class="math">O(q^{4k+1})</span>  modular arithmetic operations. If  <span class="math">k \\geq 4</span>  then subject to a condition on q, k and  <span class="math">d_h</span> , it is possible to find the logarithms of irreducible degree two elements on the fly, using the techniques of [19, 20]. In fact, for the DLP in  <span class="math">\\mathbb{F}_{2^{12\\cdot367}}</span>  we use both of these approaches, but for different base fields, see §5.</p>

    <p class="text-gray-300">Although not used in the present paper, for completeness we include here the analogue in our field representation of Joux's approach [33]. Since this approach forms the basis of the higher degree elimination steps in the quasi-polynomial time algorithm of Barbulescu <em>et al.</em>, its analogue in our field representation should be clear.</p>

    <p class="text-gray-300">We define  <span class="math">\\mathcal{B}_{2,u}</span>  to be the set of irreducible elements of  <span class="math">\\mathbb{F}_{q^k}[X]</span>  of the form  <span class="math">X^2 + uX + v</span> . For each  <span class="math">u \\in \\mathbb{F}_{q^k}</span>  one expects there to be about  <span class="math">q^k/2</span>  such elements&lt;sup&gt;†&lt;/sup&gt;. As in [33], for each  <span class="math">u \\in \\mathbb{F}_{q^k}</span>  we find the logarithms of all the elements of  <span class="math">\\mathcal{B}_{2,u}</span>  simultaneously. To do so, consider (5) but with x on the l.h.s. replaced with  <span class="math">Q = x^2 + ux</span> . Using the field isomorphisms we have that  <span class="math">Q^{q+1} + aQ^q + bQ + c</span>  is equal to</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;(y^2+u^qy)((h_0(y)/h_1(y))^2+u(h_0(y)/h_1(y)))+a(y^2+u^qy)+b((h_0(y)/h_1(y))^2+u(h_0(y)/h_1(y)))+c\\\\ &amp;=\\frac{1}{h_1(y)^2}\\big((y^2+u^qy)(h_0(y)^2+uh_0(y)h_1(y))+a(y^2+u^qy)h_1(y)^2+b(h_0(y)^2+uh_0(y)h_1(y))+ch_1(y)^2\\big). \\end{split}</span>$</p>

    <p class="text-gray-300">The degree of the r.h.s. is  <span class="math">2(d_h + 1)</span> , and when it splits completely over  <span class="math">\\mathbb{F}_{q^k}</span>  we have a relation between elements of  <span class="math">\\mathcal{B}_{2,u}</span>  and degree one elements, whose logarithms are presumed known, which we assume occurs with probability  <span class="math">1/(2(d_h+1))!</span> . Hence in order for there to be sufficiently many relations we require that</p>

    <p class="text-gray-300"><span class="math">$\\frac{q^{3k-3}}{(2(d_h+1))!} &gt; \\frac{q^k}{2}, \\text{ or equivalently } q^{2k-3} &gt; (2(d_h+1))!/2.</span>$
(7)</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;†&lt;/sup&gt; For binary fields there are precisely  <span class="math">q^k/2</span>  irreducibles, since  <span class="math">X^2 + uX + v</span>  is irreducible if and only if  <span class="math">\\text{Tr}_{\\mathbb{F}_{q^k}/\\mathbb{F}_2}(v/u^2) = 1</span> .</p>

    <p class="text-gray-300">Observe that (7) implies (6). When this holds, the expected cost of relation generation is  <span class="math">(2(d_h+1))! \\cdot q^k \\cdot S_{q^k}(1,2(d_h+1))/2</span> . The cost of solving the resulting linear system using sparse linear algebra techniques is again  <span class="math">O(q^{2k+1})</span>  modular arithmetic operations, where now both the number of variables and the average weight is halved relative to the degree one case. Since there are  <span class="math">q^k</span>  such u, the total expected cost of this stage is  <span class="math">O(q^{3k+1})</span>  modular arithmetic operations, which may of course be parallelised.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.3 Joux's Small Degree Elimination with the New Representation</h3>

    <p class="text-gray-300">As in [33], let Q be a degree  <span class="math">d_Q</span>  element to be eliminated, let  <span class="math">F(X) = \\sum_{i=0}^{d_F} f_i X^i, G(X) = \\sum_{j=0}^{d_G} g_j X^j \\in \\mathbb{F}_{q^k}[X]</span>  with  <span class="math">d_F + d_G + 2 \\ge d_Q</span> , and assume without loss of generality  <span class="math">d_F \\ge d_G</span> . Consider the following expression:</p>

    <p class="text-gray-300"><span class="math">$G(X) \\prod_{\\alpha \\in \\mathbb{F}_q} (F(X) - \\alpha G(X)) = F(X)^q G(X) - F(X)G(X)^q</span>$
(8)</p>

    <p class="text-gray-300">The l.h.s. is  <span class="math">\\max(d_F, d_G)</span> -smooth. The r.h.s. can be expressed modulo  <span class="math">h_1(X^q)X - h_0(X^q)</span>  in terms of  <span class="math">Y = X^q</span>  as a quotient of polynomials of relatively low degree by using</p>

    <p class="text-gray-300"><span class="math">$F(X)^q = \\sum_{i=0}^{d_F} f_i^q Y^i, \\ G(X)^q = \\sum_{j=0}^{d_G} g_j^q Y^j \\text{ and } X \\equiv \\frac{h_0(Y)}{h_1(Y)}.</span>$</p>

    <p class="text-gray-300">Then the numerator of the r.h.s. becomes</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{i=0}^{d_F} f_i^q Y^i\\right) \\left(\\sum_{j=0}^{d_G} g_j^q h_0(Y)^j h_1(Y)^{d_F - j}\\right) - \\left(\\sum_{i=0}^{d_F} f_i^q h_0(Y)^i h_1(Y)^{d_F - i}\\right) \\left(\\sum_{j=0}^{d_G} g_j^q Y^j\\right). \\tag{9}</span>$</p>

    <p class="text-gray-300">Setting (9) to be 0 modulo Q(Y) gives a system of  <span class="math">d_Q</span>  equations over  <span class="math">\\mathbb{F}_{q^k}</span>  in the  <span class="math">d_F + d_G + 2</span>  variables  <span class="math">f_0, \\ldots, f_{d_F}, g_0, \\ldots, g_{d_G}</span> . By choosing a basis for  <span class="math">\\mathbb{F}_{q^k}</span>  over  <span class="math">\\mathbb{F}_q</span>  and expressing each of the  <span class="math">d_F + d_G + 2</span>  variables  <span class="math">f_0, \\ldots, f_{d_F}, g_0, \\ldots, g_{d_G}</span>  in this basis, this system becomes a bilinear quadratic system&lt;sup&gt;†&lt;/sup&gt; of  <span class="math">kd_Q</span>  equations in  <span class="math">(d_F + d_G + 2)k</span>  variables. To find solutions to this system, one can specialise  <span class="math">(d_F + d_G + 2 - d_Q)k</span>  of the variables in order to make the resulting system generically zero-dimensional while keeping its bilinearity, and then compute the corresponding Gröbner basis, which may have no solution, or a small number of solutions. For each solution, one checks whether (9) divided by Q(Y) is  <span class="math">(d_Q - 1)</span> -smooth: if so then Q has successfully been rewritten as a product of elements of smaller degree; if no solutions give a  <span class="math">(d_Q - 1)</span> -smooth cofactor, then one begins again with another specialisation.</p>

    <p class="text-gray-300">The degree of the cofactor of Q(Y) is upper bounded by  <span class="math">d_F(1+d_h)-d_Q</span> , so assuming that it behaves as a uniformly chosen polynomial of such a degree one can calculate the probability  <span class="math">\\rho</span>  that it is  <span class="math">(d_Q-1)</span> -smooth using standard combinatorial techniques.</p>

    <p class="text-gray-300">Generally, in order for Q to be eliminable by this method with good probability, the number of solutions to the initial bilinear system must be greater than  <span class="math">1/\\rho</span> . To estimate the number of solutions, consider the action of  <span class="math">\\mathrm{Gl}_2(\\mathbb{F}_{q^k})</span>  on the set of pairs (F,G). The subgroups  <span class="math">\\mathrm{Gl}_2(\\mathbb{F}_q)</span>  and  <span class="math">\\mathbb{F}_{q^k}^{\\times}</span>  (via diagonal embedding) both act trivially on the set of relations, modulo multiplication by elements in  <span class="math">\\mathbb{F}_{q^k}^{\\times}</span> . Assuming that the set of (F,G) quotiented out by the action of the compositum of these subgroups (which has cardinality  <span class="math">\\approx q^{k+3}</span> ), generates distinct relations, one must satisfy the condition</p>

    <p class="text-gray-300"><span class="math">$q^{(d_F + d_G + 1 - d_Q)k - 3} &gt; 1/\\rho . (10)</span>$</p>

    <p class="text-gray-300">Note that while (10) is preferable for an easy descent, one may yet violate it and still successfully eliminate elements by using various tactics, as demonstrated in §5.</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;†&lt;/sup&gt; The bilinearity makes finding solutions to this system easier [45], and is essential for the complexity analysis in [33] and its variant in [20].</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">4 Concrete Security Analysis of <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span></h3>

    <p class="text-gray-300">In this section we focus on the DLP in the 1221-bit prime order  <span class="math">r_1</span>  subgroup of  <span class="math">\\mathbb{F}_{2^{4\\cdot1223}}^{\\times}</span> , which arises from the MOV attack applied to the genus one supersingular curve (3). By embedding  <span class="math">\\mathbb{F}_{2^{4\\cdot1223}}</span>  into its degree two extension  <span class="math">\\mathbb{F}_{2^{8\\cdot1223}} = \\mathbb{F}_{2^{9784}}</span>  we show that, after a precomputation taking approximately  <span class="math">2^{40}</span>  s, individual discrete logarithms can be computed in less than  <span class="math">2^{34}</span>  s.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4.1 Setup</h3>

    <p class="text-gray-300">We consider the field  <span class="math">\\mathbb{F}_{2^{8\\cdot 1223}} = \\mathbb{F}_{q^n}</span>  with  <span class="math">q = 2^8</span>  and n = 1223 given by the irreducible factor of degree n of  <span class="math">h_1(X^q)X - h_0(X^q)</span> , with</p>

    <p class="text-gray-300"><span class="math">$h_0 = X^5 + tX^4 + tX^3 + X^2 + tX + t</span>$
,  <span class="math">h_1 = X^5 + X^4 + X^3 + X^2 + X + t</span> ,</p>

    <p class="text-gray-300">where t is an element of  <span class="math">\\mathbb{F}_{2^2} \\setminus \\mathbb{F}_2</span> . Note that the field of definition of this representation is  <span class="math">\\mathbb{F}_{2^2}</span> . Since the target element is contained in the subfield  <span class="math">\\mathbb{F}_{2^{4\\cdot 1223}}</span> , we begin the classical descent over  <span class="math">\\mathbb{F}_{2^4}</span> , we switch to  <span class="math">\\mathbb{F}_q = \\mathbb{F}_{2^8}</span> , i.e., k = 1, for the Gröbner basis descent, and, as explained below, we work over  <span class="math">\\mathbb{F}_{q^k}</span>  with either k = 1 or a few k &gt; 1 to obtain the logarithms of all factor base elements.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4.2 Linear Algebra Cost Estimate</h3>

    <p class="text-gray-300">In this precomputation we obtain the logarithms of all elements of degree at most four over  <span class="math">\\mathbb{F}_q</span> . Since the degree 1223 extension is defined over  <span class="math">\\mathbb{F}_{2^2}</span>  in our field representation, by the action of the Galois group  <span class="math">\\operatorname{Gal}(\\mathbb{F}_q/\\mathbb{F}_{2^2})</span>  on the factor base, the number of irreducible elements of degree j whose logarithms are to be computed can be reduced to about  <span class="math">2^{8j}/(4j)</span>  for  <span class="math">j \\in \\{1, 2, 3, 4\\}</span> .</p>

    <p class="text-gray-300">One way to obtain the logarithms of these elements is to carry out the degree 1 relation generation method from §3.1, together with the elementary observation that an irreducible polynomial of degree k over  <span class="math">\\mathbb{F}_q</span>  splits completely over  <span class="math">\\mathbb{F}_{q^k}</span> . First, computing degree one logarithms over  <span class="math">\\mathbb{F}_{q^3}</span>  gives the logarithms of irreducible elements of degrees one and three over  <span class="math">\\mathbb{F}_q</span> . Similarly, computing degree one logarithms over  <span class="math">\\mathbb{F}_{q^4}</span>  gives the logarithms of irreducible elements of degrees one, two, and four over  <span class="math">\\mathbb{F}_q</span> . The main computational cost consists in solving the latter system arising from  <span class="math">\\mathbb{F}_{q^4}</span> , which has size  <span class="math">2^{28}</span>  and an average row weight of 256.</p>

    <p class="text-gray-300">However, we propose to reduce the cost of finding these logarithms by using k=1 only, in the following easy way. Consider §3.3, and observe that for each polynomial pair (F,G) of degree at most d, one obtains a relation between elements of degree at most d when the numerator of the r.h.s. is d-smooth (ignoring factors of  <span class="math">h_1</span> ). Note that we are not setting the r.h.s. numerator to be zero modulo Q or computing any Gröbner bases. Up to the action of  <span class="math">\\mathrm{Gl}_2(\\mathbb{F}_q)</span>  (which gives equivalent relations) there are about  <span class="math">q^{2d-2}</span>  such polynomial pairs. Hence, for  <span class="math">d \\geq 3</span>  there are more relations than elements if the smoothness probability of the r.h.s. is sufficiently high. Notice that k=1 implies that the r.h.s. is divisible by  <span class="math">h_1(Y)Y - h_0(Y)</span> , thus increasing its smoothness probability and resulting in enough relations for d=3 and for d=4. After having solved the much smaller system for d=3 we know the logarithms of all elements up to degree three, so that the average row weight for the system for d=4 can be reduced to about  <span class="math">\\frac{1}{4} \\cdot 256 = 64</span>  (irreducible degree four polynomials on the l.h.s.). As above the size of this system is  <span class="math">2^{28}</span> .</p>

    <p class="text-gray-300">The cost for generating the linear systems is negligible compared to the linear algebra cost. For estimating the latter cost we consider Lanczos' algorithm to solve a sparse  <span class="math">N \\times N</span> ,  <span class="math">N = 2^{28}</span> , linear system with average row weight W = 64. As noted in [41,20] this algorithm can be implemented such that</p>

    <p class="text-gray-300"><span class="math">$N^{2} (2 W ADD + 2 SQR + 3 MULMOD)</span>$
(11)</p>

    <p class="text-gray-300">operations are used. On our benchmark system, an AMD Opteron 6168 processor at 1.9 GHz, using [29] our implementation of these operations took 62 ns, 467 ns and 1853 ns for an ADD, a SQR and a MULMOD, respectively, resulting in a linear algebra cost of  <span class="math">2^{40}</span>  s.</p>

    <p class="text-gray-300">As in [2], the above estimate ignores communication costs and other possible slowdowns which may arise in practice. An alternative estimate can be obtained by considering a problem of a similar size over  <span class="math">\\mathbb{F}_2</span>  and extrapolating from [38]. This gives an estimated time of  <span class="math">2^{42}</span>  s, or for newer hardware slightly less. Note that this computation was carried out using the block Wiedemann algorithm [13], which we recommend in practice because it allows one to distribute the main part of the computation. For the sake of a fair comparison with [2] we use the former estimate of  <span class="math">2^{40}</span>  s.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.3 Descent Cost Estimate</h4>

    <p class="text-gray-300">We assume that the logarithms of elements up to degree four are known, and that computing these logarithms with a lookup table is free.</p>

    <p class="text-gray-300"><strong>Small Degree Descent.</strong> We have implemented the small degree descent of §3.3 in Magma [10] V2.20-1, using Faugere's F4 algorithm [15]. For each degree from 5 to 15, on the same AMD Opteron 6168 processor we timed the Gröbner basis computation between 10&lt;sup&gt;6&lt;/sup&gt; and 100 times, depending on the degree. Then using a bottom-up recursive strategy we estimated the following average running times in seconds for a full logarithm computation, which we present to two significant figures:</p>

    <p class="text-gray-300"><span class="math">$C[5,\\ldots,15] = [\\ 0.038\\ ,\\ 2.1\\ ,\\ 2.1\\ ,\\ 93\\ ,\\ 95\\ ,\\ 180\\ ,\\ 190\\ ,\\ 3200\\ ,\\ 3500\\ ,\\ 6300\\ ,\\ 11000\\ ]\\ .</span>$</p>

    <p class="text-gray-300"><strong>Degree-Balanced Classical Descent.</strong> From now on, we make the conservative assumption that a degree n polynomial which is m-smooth, is a product of n/m degree m polynomials. In practice the descent cost will be lower than this, however, the linear algebra cost is dominating, so this issue is inconsequential for our security estimate. The algorithms we used for smoothness testing are detailed in Appendix B.</p>

    <p class="text-gray-300">For a classical descent step with degree balancing we consider polynomials  <span class="math">P(X^{2^a}, Y) \\in \\mathbb{F}_q[X, Y]</span>  for a suitably chosen integer  <span class="math">0 \\le a \\le 8</span> . It is advantageous to choose P such that its degree in one variable is one; let d be the degree in the other variable. In the case  <span class="math">\\deg_{X^{2^a}}(P) = 1</span> , i.e.,  <span class="math">P = v_1(Y)X^{2^a} + v_0(Y)</span> ,  <span class="math">\\deg v_i \\le d</span> , this gives rise to the relation</p>

    <p class="text-gray-300"><span class="math">$L_v^{2^a} = \\left(\\frac{R_v}{h_1(X)^{2^a}}\\right)^{2^8} \\quad \\text{where} \\quad L_v = \\tilde{v}_1(X^{2^{8-a}})X + \\tilde{v}_0(X^{2^{8-a}}), \\\\ R_v = v_1(X)h_0(X)^{2^a} + v_0(X)h_1(X)^{2^a}</span>$</p>

    <p class="text-gray-300">in  <span class="math">\\mathbb{F}_q[X]/(h_1(X^q)X - h_0(X^q))</span>  with  <span class="math">\\deg L_v \\leq 2^{8-a}d + 1</span> ,  <span class="math">\\deg R_v \\leq d + 5 \\cdot 2^a</span> , and  <span class="math">\\tilde{v}_i</span>  being  <span class="math">v_i</span>  with its coefficients powered by  <span class="math">2^{8-a}</span> , for i = 0, 1. Similarly, in the case  <span class="math">\\deg_Y(P) = 1</span> , i.e.,  <span class="math">P = w_1(X^{2^a})Y + w_0(X^{2^a})</span> ,  <span class="math">\\deg w_i \\leq d</span> , we have the relation</p>

    <p class="text-gray-300"><span class="math">$L_w^{2^a} = \\left(\\frac{R_w}{h_1(X)^{2^a d}}\\right)^{2^8} \\quad \\text{where} \\quad L_w = \\tilde{w}_1(X)X^{2^{8-a}} + \\tilde{w}_0(X), \\\\ R_w = h_1(X)^{2^a d} \\left(w_1\\left(\\left(\\frac{h_0(X)}{h_1(X)}\\right)^{2^a}\\right)X + w_0\\left(\\left(\\frac{h_0(X)}{h_1(X)}\\right)^{2^a}\\right)\\right)</span>$</p>

    <p class="text-gray-300">with deg  <span class="math">L_w \\leq d + 2^{8-a}</span> , deg  <span class="math">R_w \\leq 5 \\cdot 2^a d + 1</span>  and again  <span class="math">\\tilde{w}_i</span>  being  <span class="math">w_i</span>  with its coefficients powered by  <span class="math">2^{8-a}</span> , for i = 0, 1.</p>

    <p class="text-gray-300">The polynomials  <span class="math">v_i</span>  (respectively  <span class="math">w_i</span> ) are chosen in such a way that either the l.h.s. or the r.h.s. is divisible by a polynomial Q(X) of degree  <span class="math">d_Q</span> . Gaussian reduction provides a lattice basis  <span class="math">(u_0, u_1), (u&#x27;_0, u&#x27;_1)</span>  such that the polynomial pairs satisfying the divisibility condition above are</p>

    <p class="text-gray-300">given by  <span class="math">ru_i + su_i&#x27;</span>  for i = 0, 1, where  <span class="math">r, s \\in \\mathbb{F}_q[X]</span> . For nearly all polynomials Q it is possible to choose a lattice basis of polynomials with degree  <span class="math">\\approx d_Q/2</span>  which we will assume for all Q appearing in the analysis; extreme cases can be avoided by look-ahead or backtracking techniques. Notice that a polynomial Q over  <span class="math">\\mathbb{F}_{2^4} \\subset \\mathbb{F}_q</span>  can be rewritten as a product of polynomials which are also over  <span class="math">\\mathbb{F}_{2^4}</span> , by choosing the basis as well as r and s to be over  <span class="math">\\mathbb{F}_{2^4}</span> . This will be done in all steps of the classical descent. The polynomials r and s are chosen to be of degree four, resulting in  <span class="math">2^{36}</span>  possible pairs (multiplying both by a common non-zero constant gives the same relation).</p>

    <p class="text-gray-300">In the final step of the classical eliminations (from degree 26 to 15) we relax the criterion that the l.h.s. and r.h.s. are 15-smooth, allowing also irreducibles of even degree up to degree 30, since these can each be split over  <span class="math">\\mathbb{F}_q</span>  into two polynomials of half the degree, thereby increasing the smoothness probabilities. Admittedly, if we follow our worst-case analysis stipulation that all polynomials at this step have degree 26, then one could immediately split each of them into two degree 13 polynomials. However, in practice one will encounter polynomials of all degrees  <span class="math">\\leq</span>  26 and we therefore carry out the analysis without using the splitting shortcut, which will still provide an overestimate of the cost of this step.</p>

    <p class="text-gray-300">In the following we will state the logarithmic cost (in seconds) of a classical descent step as  <span class="math">c_l + c_r + c_s</span> , where  <span class="math">2^{c_l}</span>  and  <span class="math">2^{c_r}</span>  denote the number of trials to get the left hand side and the right hand side m-smooth, and  <span class="math">2^{c_s}</span>  s is the time required for the corresponding smoothness test. See Table 1 for the smoothness timings that we benchmarked on the AMD Opteron 6168 processor.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbf{d_Q} = \\mathbf{26}</span>  to  <span class="math">\\mathbf{m} = \\mathbf{15}</span> : We choose  <span class="math">\\deg_{X^{2^a}} P = 1</span> , a = 5, Q on the right, and we have d = 17,  <span class="math">(\\deg(L_v), \\deg(R_v)) = (137, 151)</span> , and logarithmic cost 13.4 + 15.6 9.0, hence  <span class="math">2^{20.0}</span>  s; the expected number of factors is 19.2, so the subsequent cost will be less than  <span class="math">2^{17.7}</span>  s. Note that, as explained above, we use the splitting shortcut for irreducibles of even degree up to 30, resulting in the higher than expected smoothness probabilities.</li>
      <li><span class="math">\\mathbf{d_Q} = \\mathbf{36}</span>  to  <span class="math">\\mathbf{m} = \\mathbf{26}</span> : We choose  <span class="math">\\deg_{X^{2^a}} P = 1</span> , a = 5, Q on the right, and we have d = 22,  <span class="math">(\\deg(L_v), \\deg(R_v)) = (177, 146)</span> , and logarithmic cost 18.7 + 13.6 9.0, hence  <span class="math">2^{23.3}</span>  s; the expected number of factors is 12.4, so the subsequent cost will be less than  <span class="math">2^{23.9}</span>  s.</li>
      <li><span class="math">\\mathbf{d_Q} = \\mathbf{94}</span>  to  <span class="math">\\mathbf{m} = \\mathbf{36}</span> : We choose  <span class="math">\\deg_Y P = 1</span> , a = 0, Q on the left, and we have d = 51,  <span class="math">(\\deg(L_w), \\deg(R_w)) = (213, 256)</span> , and logarithmic cost 15.0 + 20.3 7.5, hence  <span class="math">2^{27.8}</span>  s; the expected number of factors is 13.0, so the subsequent cost will be less than  <span class="math">2^{28.4}</span>  s.</li>
    </ul>

    <p class="text-gray-300"><strong>Table 1.</strong> Timings for testing a degree n polynomial over  <span class="math">\\mathbb{F}_{2^4}</span>  for m-smoothness.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mid m \\mid</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">time</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">137</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30 26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1.9\\mathrm{ms}</span>&lt;br&gt;<span class="math">1.9\\mathrm{ms}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{146}{213}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5.1\\mathrm{ms}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">611</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">94\\mathrm{ms}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Continued Fraction Descent. For the continued fraction descent we multiply the target element by random powers of the generator and express the product as a ratio of two polynomials of degree at most 611. For each such expression we test if both the numerator and the denominator are 94-smooth. The logarithmic cost here is 17.7 + 17.7 - 3.4, hence the cost is  <span class="math">2^{32.0}</span>  s. The expected number of degree 94 factors on both sides will be 13, so the subsequent cost will be less than  <span class="math">2^{32.8}</span>  s.</p>

    <p class="text-gray-300"><strong>Total Descent Cost</strong> The cost for computing an individual logarithm is therefore upper-bounded by  <span class="math">2^{32.0}</span>  s +  <span class="math">2^{32.8}</span>  s &lt;  <span class="math">2^{34}</span>  s.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.4 Summary</h3>

    <p class="text-gray-300">The main cost in our analysis is the linear algebra computation which takes about  <span class="math">2^{40}</span>  s, with the individual logarithm stage being considerably faster. In order to compare with the estimate in [2], we write the main cost in terms of  <span class="math">M_r</span>  which gives  <span class="math">2^{59}</span>   <span class="math">M_r</span> , and thus an improvement by a factor of  <span class="math">2^{69}</span> . Nevertheless, solving a system of cardinality  <span class="math">2^{28}</span>  is still a formidable challenge, but perhaps not so much for a well-funded adversary. For completeness we note that if one wants to avoid a linear algebra step of this size, then one can work over different fields, e.g., with  <span class="math">q = 2^{10}</span>  and k = 2, or  <span class="math">q = 2^{12}</span>  and k = 1. However, while this allows a partitioning of the linear algebra into smaller steps as described in §3.2 but at a slightly higher cost, the resulting descent cost is expected to be significantly higher.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">5 Solving the DLP in <span class="math">\\mathbb{F}_{2^{12\\cdot 367}}</span></h3>

    <p class="text-gray-300">In this section we present the details of our solution of a DLP in the 698-bit prime order  <span class="math">r_2</span>  subgroup of  <span class="math">\\mathbb{F}_{2^{12\\cdot367}}^{\\times} = \\mathbb{F}_{2^{4404}}^{\\times}</span> , which arises from the MOV attack applied to the Jacobian of the genus two supersingular curve (4). Magma verification code is provided in Appendix A. Note that the prime order elliptic curve  <span class="math">E_1/\\mathbb{F}_{2^{367}}: Y^2 + Y = X^3 + X + 1</span>  with embedding degree 4 also embeds into  <span class="math">\\mathbb{F}_{2^{4404}}</span> , so that logarithms on this curve could have easily been computed as well.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">5.1 Setup</h3>

    <p class="text-gray-300">To compute the target logarithm, as stated in §1 we applied a principle of parsimony, namely, we tried to solve all intermediate logarithms in  <span class="math">\\mathbb{F}_{2^{12\\cdot367}}</span> , considered as a degree 367 extension of  <span class="math">\\mathbb{F}_{2^{12}}</span> , and only when this was not possible did we embed elements into the extension field  <span class="math">\\mathbb{F}_{2^{24\\cdot367}}</span>  (by extending the base field to  <span class="math">\\mathbb{F}_{2^{24}}</span> ) and solve them there.</p>

    <p class="text-gray-300">All of the classical descent down to degree 8 was carried out over  <span class="math">\\mathbb{F}_{2^{12\\cdot367}}</span> , which we formed as the compositum of the following two extension fields. We defined  <span class="math">\\mathbb{F}_{2^{12}}</span>  using the irreducible polynomial  <span class="math">U^{12}+U^3+1</span>  over  <span class="math">\\mathbb{F}_2</span> , and defined  <span class="math">\\mathbb{F}_{2^{367}}</span>  over  <span class="math">\\mathbb{F}_2</span>  using the degree 367 irreducible factor of  <span class="math">h_1(X^{64})X - h_0(X^{64})</span> , where  <span class="math">h_1 = X^5 + X^3 + X + 1</span> , and  <span class="math">h_0 = X^6 + X^4 + X^2 + X + 1</span> . Let u and x be roots of the extension defining polynomials in U and X respectively, and let  <span class="math">c = (2^{4404} - 1)/r_2</span> . Then  <span class="math">g = x + u^7</span>  is a generator of  <span class="math">\\mathbb{F}_{2^{4404}}^{\\times}</span>  and  <span class="math">\\bar{g} = g^c</span>  is a generator of the subgroup of order  <span class="math">r_2</span> . As usual, our target element was chosen to be  <span class="math">\\bar{x}_{\\pi} = x_{\\pi}^c</span>  where</p>

    <p class="text-gray-300"><span class="math">$x_{\\pi} = \\sum_{i=0}^{4403} (\\lfloor \\pi \\cdot 2^{i+1} \\rfloor \\mod 2) \\cdot u^{11 - (i \\mod 12)} \\cdot x^{\\lfloor i/12 \\rfloor}.</span>$</p>

    <p class="text-gray-300">The remaining logarithms were computed using a combination of tactics, over  <span class="math">\\mathbb{F}_{2^{12}}</span>  when possible, and over  <span class="math">\\mathbb{F}_{2^{24}}</span>  when not. These fields were constructed as degree 2 and 4 extensions of  <span class="math">\\mathbb{F}_{2^6}</span> , respectively. To define  <span class="math">\\mathbb{F}_{2^6}</span>  we used the irreducible polynomial  <span class="math">T^6+T+1</span> . We then defined  <span class="math">\\mathbb{F}_{2^{12}}</span>  using the irreducible polynomial  <span class="math">V^2+tV+1</span>  over  <span class="math">\\mathbb{F}_{2^6}</span> , and  <span class="math">\\mathbb{F}_{2^{24}}</span>  using the irreducible polynomial  <span class="math">W^4+W^3+W^2+t^3</span>  over  <span class="math">\\mathbb{F}_{2^6}</span> .</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">5.2 Degree 1 Logarithms</h4>

    <p class="text-gray-300">It was not possible to find enough relations for degree 1 elements over  <span class="math">\\mathbb{F}_{2^{12}}</span> , so in accordance with our stated principle, we extended the base field to  <span class="math">\\mathbb{F}_{2^{24}}</span>  to compute the logarithms of all  <span class="math">2^{24}</span>  degree 1 elements. We used the polynomial time relation generation from §3.1, which took 47 hours. This relative sluggishness was due to the r.h.s. having degree  <span class="math">d_h + 1 = 7</span> , which must split over  <span class="math">\\mathbb{F}_{2^{24}}</span> . However, this was faster by a factor of 24 than it would have been otherwise, thanks to  <span class="math">h_0</span>  and  <span class="math">h_1</span>  being defined over  <span class="math">\\mathbb{F}_2</span> . This allowed us to use the technique from [37] to reduce the size of the factor base via the automorphism  <span class="math">(x+a) \\mapsto (x+a)^{2^{367}}</span> , which fixes x but has order 24 on all non-subfield elements of  <span class="math">\\mathbb{F}_{2^{24}}</span> , since  <span class="math">367 \\equiv 7 \\mod 24</span>  and  <span class="math">\\gcd(7, 24) = 1</span> . This reduced the factor base size to 699252 elements, which was solved in 4896 core hours on a 24 core cluster using Lanczos' algorithm, approximately  <span class="math">24^2</span>  times faster than if we had not used the automorphisms.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">5.3 Individual Logarithm</h4>

    <p class="text-gray-300">We performed the standard continued fraction initial split followed by degree-balanced classical descent as in §4.3, using Magma [10] and NTL [44], to reduce the target element to an 8-smooth product in 641 and 38224 core hours respectively. The most interesting part of the descent was the elimination of the elements of degree up to 8 over  <span class="math">\\mathbb{F}_{2^{12}}</span>  into elements of degree one over  <span class="math">\\mathbb{F}_{2^{24}}</span> , which we detail below. This phase was completed using Magma and took a further 8432 core hours. However, we think that the combined time of the classical and non-classical parts could be reduced significantly via a backwards-induction analysis of the elimination times of each degree.</p>

    <p class="text-gray-300">Small Degree Elimination As stated above we used several tactics to achieve these eliminations. The first was the splitting of an element of even degree over  <span class="math">\\mathbb{F}_{2^{12}}</span>  into two elements of half the degree (which had the same logarithm modulo  <span class="math">r_2</span> ) over the larger field. This automatically provided the logarithms of all degree 2 elements over  <span class="math">\\mathbb{F}_{2^{12}}</span> . Similarly elements of degree 4 and 8 over  <span class="math">\\mathbb{F}_{2^{12}}</span>  were rewritten as elements of degree 2 and 4 over  <span class="math">\\mathbb{F}_{2^{24}}</span> , while we found that degree 6 elements were eliminable more efficiently by initially continuing the descent over  <span class="math">\\mathbb{F}_{2^{12}}</span> , as with degree 5 and 7 elements.</p>

    <p class="text-gray-300">The second tactic was the application of Joux's Gröbner basis elimination method from §3.3 to elements over  <span class="math">\\mathbb{F}_{2^{12}}</span> , as well as elements over  <span class="math">\\mathbb{F}_{2^{24}}</span> . However, in many cases condition (10) was violated, in which case we had to employ various recursive strategies in order to eliminate elements. In particular, elements of the same degree were allowed on the r.h.s. of relations, and we then attempted to eliminate these using the same (recursive) strategy. For degree 3 elements over  <span class="math">\\mathbb{F}_{2^{12}}</span> , we even allowed degree 4 elements to feature on the r.h.s. of relations, since these were eliminable via the factorisation into degree 2 elements over  <span class="math">\\mathbb{F}_{2^{24}}</span> .</p>

    <p class="text-gray-300">In Figure 1 we provide a flow chart for the elimination of elements of degree up to 8 over  <span class="math">\\mathbb{F}_{2^{12}}</span> , and for the supporting elimination of elements of degree up to 4 over  <span class="math">\\mathbb{F}_{2^{24}}</span> . Nearly all of the arrows in Figure 1 were necessary for these field parameters (the exceptions being that for degrees 4 and 8 over  <span class="math">\\mathbb{F}_{2^{12}}</span>  we could have initially continued the descent along the bottom row, but this would have been slower). The reason this 'non-linear' descent arises is due to q being so small, and  <span class="math">d_H</span>  being relatively large, which increases the degree of the r.h.s. cofactors, thus decreasing the smoothness probability. Indeed these tactics were only borderline applicable for these parameters; if  <span class="math">h_0</span>  or  <span class="math">h_1</span>  had degree any larger than 6 then not only would most of the descent have been much harder, but it seems that one would be forced to compute the logarithms of degree 2 elements over  <span class="math">\\mathbb{F}_{2^{24}}</span>  using Joux's linear system method from §3.2, greatly increasing</p>

    <p class="text-gray-300">    <img src="_page_12_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. This diagram depicts the set of strategies employed to eliminate elements over  <span class="math">\\mathbb{F}_{2^{12}}</span>  of degree up to 8. The encircled numbers represent the degrees of elements over  <span class="math">\\mathbb{F}_{2^{12}}</span>  on the bottom row, and over  <span class="math">\\mathbb{F}_{2^{24}}</span>  on the top row. The arrows indicate how an element of a given degree is rewritten as a product of elements of other degrees, possibly over the larger field. Unadorned solid arrows indicate the maximum degree of elements obtained on the l.h.s. of the Gröbner basis elimination method; likewise dashed arrows indicate the degrees of elements obtained on the r.h.s. of the Gröbner basis elimination method, when these are greater than those obtained on the l.h.s. Dotted arrows indicate a fall-back strategy when the initial strategy fails. An s indicates that the element is to be split over the larger field into two elements of half the degree. An  <span class="math">\\iota</span>  indicates that an element is promoted to the larger field. Finally, a loop indicates that one must use a recursive strategy in which further instances of the elimination in question must be solved in order to eliminate the element in question.</p>

    <p class="text-gray-300">the required number of core hours. As it was, we were able to eliminate degree 2 elements over  <span class="math">\\mathbb{F}_{2^{24}}</span>  on the fly, as we describe explicitly below.</p>

    <p class="text-gray-300">Finally, we note that our descent strategy is considerably faster than the alternative of embedding the DLP into  <span class="math">\\mathbb{F}_{2^{24\\cdot367}}</span>  and performing a full descent in this field, even with the elimination on the fly of degree 2 elements over  <span class="math">\\mathbb{F}_{2^{24}}</span> , since much of the resulting computation would constitute superfluous effort for the task in hand.</p>

    <p class="text-gray-300"><strong>Degree 2 Elimination over</strong>  <span class="math">\\mathbb{F}_{2^{24}}</span>  Let Q(Y) be a degree two element which is to be eliminated, i.e., written as a product of degree one elements. As in [19, 20] we first precompute the set of 64 elements  <span class="math">B \\in \\mathbb{F}_{2^{24}}</span>  such that the polynomial  <span class="math">f_B(X) = X^{65} + BX + B</span>  splits completely over  <span class="math">\\mathbb{F}_{2^{24}}</span>  (in fact these B's happen to be in  <span class="math">\\mathbb{F}_{2^{12}}</span> , but this is not relevant to the method). We then find a Gaussian-reduced basis of the lattice  <span class="math">L_{Q(Y)}</span>  defined by</p>

    <p class="text-gray-300"><span class="math">$L_{Q(Y)} = \\{(w_0(Y), w_1(Y)) \\in \\mathbb{F}_{2^{24}}[Y]^2 : w_0(Y) \\, h_0(Y) + w_1(Y) \\, h_1(Y) \\equiv 0 \\pmod{Q(Y)} \\} \\, .</span>$</p>

    <p class="text-gray-300">Such a basis has the form  <span class="math">(u_0, Y + u_1), (Y + v_0, v_1)</span> , with  <span class="math">u_i, v_i \\in \\mathbb{F}_{2^{24}}</span> , except in rare cases, see Remark 1. For  <span class="math">s \\in \\mathbb{F}_{2^{24}}</span>  we obtain lattice elements  <span class="math">(w_0(Y), w_1(Y)) = (Y + v_0 + su_0, sY + v_1 + su_1)</span> .</p>

    <p class="text-gray-300">Using the transformation detailed in §3, for each  <span class="math">B \\in \\mathbb{F}_{2^{24}}</span>  such that  <span class="math">f_B</span>  splits completely over  <span class="math">\\mathbb{F}_{2^{24}}</span>  we perform a Gröbner basis computation to find the set of  <span class="math">s \\in \\mathbb{F}_{2^{24}}</span>  that satisfy</p>

    <p class="text-gray-300"><span class="math">$B = \\frac{(s^{64} + u_0 s + v_0)^{65}}{(u_0 s^2 + (u_1 + v_0) s + v_1)^{64}},</span>$</p>

    <p class="text-gray-300">by first expressing s in a  <span class="math">\\mathbb{F}_{2^{24}}/\\mathbb{F}_{2^6}</span>  basis, which results in a quadratic system in 4 variables. This ensures that the l.h.s. splits completely over  <span class="math">\\mathbb{F}_{2^{24}}</span> . For each such s we check whether the r.h.s. cofactor of Q(Y), which has degree 5, is 1-smooth. If this occurs, we have successfully eliminated Q(Y).</p>

    <p class="text-gray-300">However, one expects on average just one s per B, and so the probability of Q(Y) being eliminated in this way is  <span class="math">1-(1-1/5!)^{64} \\approx 0.415</span> , which was borne out in practice to two decimal places. Hence, we adopted a recursive strategy in which we stored all of the r.h.s. cofactors whose factorisation degrees had the form (1,1,1,2) (denoted type 1), or (1,2,2) (denoted type</p>

    <p class="text-gray-300">2). Then for each type 1 cofactor we checked to see if the degree 2 factor was eliminable by the above method. If none were eliminable we stored every type 1 cofactor of each degree 2 irreducible occurring in the list of type 1 cofactors of Q(Y). If none of these were eliminable (which occurred with probability just 0.003), then we reverted to the type 2 cofactors, and adopted the same strategy just specified for each of the degree 2 irreducible factors. Overall, we expected our strategy to fail about once in every  <span class="math">6 \\cdot 10^6</span>  such Q(Y). This happened just once during our descent, and so we multiplied this Q(Y) by a random linear polynomial over  <span class="math">\\mathbb{F}_{2^{24}}</span>  and performed a degree 3 elimination, which necessitates an estimated 32 degree 2 polynomials being simultaneously eliminable by the above method, which thanks to the high probability of elimination, will very likely be successful for any linear multiplier.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.4 Summary</h3>

    <p class="text-gray-300">Finally, after a total of approximately 52240 core hours (or  <span class="math">2^{48}~M_{r_2}</span> ), we found that  <span class="math">\\bar{x}_{\\pi} = \\bar{g}^{\\log}</span> , with  <span class="math">\\log =</span></p>

    <p class="text-gray-300"><span class="math">40932089202142351640934477339007025637256140979451423541922853874473604\\\\39015351684721408233687689563902511062230980145272871017382542826764695\\\\59843114767895545475795766475848754227211594761182312814017076893242 \\ .</span></p>

    <p class="text-gray-300">Remark 1. During the descent, we encountered several polynomials Q(Y) that were apparently not eliminable via the Gröbner basis method. We discovered that they were all factors of  <span class="math">h_1(Y) \\cdot c + h_0(Y)</span>  for  <span class="math">c \\in \\mathbb{F}_{2^{12}}</span>  or  <span class="math">\\mathbb{F}_{2^{24}}</span> , and hence  <span class="math">h_0(Y)/h_1(Y) \\equiv c \\pmod{Q(Y)}</span> . This implies that (9) is equal to  <span class="math">F(c)G^{(q)}(Y) + F^{(q)}(Y)G(c)</span>  modulo Q(Y), where  <span class="math">G^{(q)}</span>  denotes the Frobenius twisted G and similarly for  <span class="math">F^{(q)}</span> . This cannot become 0 modulo Q(Y) if the degrees of F and G are smaller than the degree of F0, unless F1 and F2 are both constants. However, thanks to the field representation, finding the logarithm of these Q(Y) turns out to be easy. In particular, if  <span class="math">h_1(Y) \\cdot c + h_0(Y) = Q(Y) \\cdot R(Y)</span>  then  <span class="math">P(Y) = h_1(Y) \\cdot ((h_0/h_1)(Y) + c)/R(Y) = h_1(Y) \\cdot (X + c)/R(Y)</span> , and thus modulo  <span class="math">P(Y) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y)) = h_1(Y) \\cdot (h_0(Y))</span></p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">6 Conclusion</h4>

    <p class="text-gray-300">We have introduced a new field representation and efficient descent principles which together make the recent DLP advances far more practical. As example demonstrations, we have applied these techniques to two binary fields of central interest to pairing-based cryptography, namely  <span class="math">\\mathbb{F}_{2^{4\\cdot1223}}</span>  and  <span class="math">\\mathbb{F}_{2^{12\\cdot367}}</span> , which arise as the embedding fields of (the Jacobians of) a genus one and a genus two supersingular curve, respectively. When initially proposed, these fields were believed to be 128-bit secure, and even in light of the recent DLP advances, were believed to be 128-bit and 94.6-bit secure. On the contrary, our analysis indicates that the former field has approximately 59 bits of security and we have implemented a total break of the latter.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">References</h3>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Jithra Adikari, M. Anwar Hasan, and Christophe Nègre. Towards faster and greener cryptoprocessor for eta pairing on supersingular elliptic curve over  <span class="math">\\mathbb{F}_{2^{1223}}</span> . In Selected Areas in Cryptography—SAC 2012, volume 7707 of LNCS, pages 166–183. Springer, 2012.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodr´ıguez-Henr´ıquez. Weakness of F36·&lt;sup&gt;509&lt;/sup&gt; for discrete logarithm cryptography. In Pairing-based Cryptography—Pairing 2013, volume 8365 of LNCS, pages 20–44. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Diego F. Aranha, Jean-Luc Beuchat, J´er´emie Detrey, and Nicolas Estibals. Optimal eta pairing on supersingular genus-2 binary hyperelliptic curves. In Topics in Cryptology—CT-RSA 2012, volume 7178 of LNCS, pages 98–115. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thom´e. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Advances in Cryptology— EUROCRYPT 2014, volume 8441 of LNCS, pages 1–16. Springer, 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Paulo S. L. M. Barreto, Steven D. Galbraith, Colm O' H´eigeartaigh, and Michael Scott. Efficient pairing ´ computation on supersingular abelian varieties. Des. Codes Cryptography, 42(3):239–271, March 2007.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Paulo S. L. M. Barreto, Hae Yong Kim, Ben Lynn, and Michael Scott. Efficient algorithms for pairing-based cryptosystems. In Advances in Cryptology—CRYPTO 2002, volume 2442 of LNCS, pages 354–368. Springer, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Jean-Luc Beuchat, Emmanuel L´opez-Trejo, Luis Mart´ınez-Ramos, Shigeo Mitsunari, and Francisco Rodr´ıguez-Henr´ıquez. Multi-core implementation of the Tate pairing over supersingular elliptic curves. In Cryptology and Network Security—CANS 2009, volume 5888 of LNCS, pages 413–432. Springer, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antonia W. Bluher. On x &lt;sup&gt;q&lt;/sup&gt;+1 + ax + b. Finite Fields and Their Applications, 10(3):285–305, 2004.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Dan Boneh and Matt Franklin. Identity-based encryption from the Weil pairing. In Advances in Cryptology— CRYPTO 2001, volume 2139 of LNCS, pages 213–229. Springer, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wieb Bosma, John Cannon, and Catherine Playoust. The Magma algebra system. I. The user language. J. Symbolic Comput., 24(3-4):235–265, 1997.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sanjit Chatterjee, Darrel Hankerson, and Alfred Menezes. On the efficiency and security of pairing-based protocols in the type 1 and type 4 settings. In Arithmetic of Finite Fields, volume 6087 of LNCS, pages 114–134. Springer, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Don Coppersmith. Fast evaluation of logarithms in fields of characteristic two. IEEE Transactions on Information Theory, 30(4):587–593, 1984.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Don Coppersmith. Solving homogeneous linear equations over GF(2) via block Wiedemann algorithm. Mathematics of Computation, 62(205):333–350, 1994.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Iwan Duursma and Hyang-Sook Lee. Tate pairing implementation for hyperelliptic curves y &lt;sup&gt;2&lt;/sup&gt; = x &lt;sup&gt;p&lt;/sup&gt; − x + d. In Advances in Cryptology—ASIACRYPT 2003, volume 2894 of LNCS, pages 111–123. Springer, 2003.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Jean-Charles Faug\`ere. A new efficient algorithm for computing Gr¨obner bases (F4). J. Pure Appl. Algebra, 139(1-3):61–88, 1999.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Steven D. Galbraith. Supersingular curves in cryptography. In Advances in Cryptology—ASIACRYPT 2001, volume 2248 of LNCS, pages 495–513. Springer, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Steven D. Galbraith, Keith Harrison, and David Soldera. Implementing the Tate pairing. In Algorithmic Number Theory—ANTS-V, volume 2369 of LNCS, pages 324–337. Springer, 2002.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Santosh Ghosh, Dipanwita Roychowdhury, and Abhijit Das. High speed cryptoprocessor for η&lt;sup&gt;t&lt;/sup&gt; pairing on 128-bit secure supersingular elliptic curves over characteristic two fields. In Cryptographic Hardware and Embedded Systems—CHES 2011, volume 6917 of LNCS, pages 442–458. Springer, 2011.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Faruk G¨olo˘glu, Robert Granger, Gary McGuire, and Jens Zumbr¨agel. On the function field sieve and the impact of higher splitting probabilities: Application to discrete logarithms in F2&lt;sup&gt;1971&lt;/sup&gt; and F2&lt;sup&gt;3164&lt;/sup&gt; . In Advances in Cryptology—CRYPTO 2013, volume 8043 of LNCS, pages 109–128. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Faruk G¨olo˘glu, Robert Granger, Gary McGuire, and Jens Zumbr¨agel. Solving a 6120-bit DLP on a desktop computer. In Selected Areas in Cryptography—SAC 2013, volume 8282 of LNCS, pages 136–152. Springer, 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Faruk G¨olo˘glu, Robert Granger, Gary McGuire, and Jens Zumbr¨agel. Discrete Logarithms in GF(2&lt;sup&gt;1971&lt;/sup&gt;). NMBRTHRY list, 19/2/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Faruk G¨olo˘glu, Robert Granger, Gary McGuire, and Jens Zumbr¨agel. Discrete Logarithms in GF(2&lt;sup&gt;6120&lt;/sup&gt;). NMBRTHRY list, 11/4/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger. On the function field sieve and the impact of higher splitting probabilities, 2013. Presentation at the 17th Workshop on Elliptic Curve Cryptography, 16/9/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger. Solving a 6120-bit DLP on a desktop computer, 2013. Presentation at Selected Areas in Cryptography 2013, 15/8/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger, Thorsten Kleinjung, and Jens Zumbr¨agel. Discrete logarithms in the Jacobian of a genus 2 supersingular curve over GF(2&lt;sup&gt;367&lt;/sup&gt;). NMBRTHRY list, 30/1/2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger, Thorsten Kleinjung, and Jens Zumbr¨agel. Discrete Logarithms in GF(2&lt;sup&gt;9234&lt;/sup&gt;). NMBRTHRY list, 31/1/2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger, Dan Page, and Martijn Stam. Hardware and software normal basis arithmetic for pairingbased cryptography in characteristic three. IEEE Trans. Computers, 54(7):852–860, 2005.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Robert Granger, Dan Page, and Martijn Stam. On small characteristic algebraic tori in pairing-based cryptography. LMS J. Comput. Math., 9:64–85, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Torbjörn Granlund and the GMP development team. GNU MP: The GNU Multiple Precision Arithmetic Library, 5.0.5 edition, 2012. http://gmplib.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Darrel Hankerson, Alfred Menezes, and Michael Scott. Software implementation of pairings. In <em>Identity-Based Cryptography</em>, vol. 2, Cryptology and Information Security, pages 188–206. IOS Press, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. A one round protocol for tripartite Diffie-Hellman. In <em>Algorithmic Number Theory—ANTS-VI</em>, volume 1838 of <em>Lecture Notes in Comput. Sci.</em>, pages 385–393. Springer, 2000.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. Faster index calculus for the medium prime case. Application to 1175-bit and 1425-bit finite fields. In <em>Advances in Cryptology—EUROCRYPT 2013</em>, volume 7881 of <em>LNCS</em>, pages 177–193. Springer, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. A new index calculus algorithm with complexity L(1/4 + o(1)) in very small characteristic. In Selected Areas in Cryptography—SAC 2013, volume 8282 of LNCS, pages 355–379. Springer, 2014.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. Discrete Logarithms in  <span class="math">GF(2^{1778})</span> . NMBRTHRY list, 11/2/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. Discrete Logarithms in  <span class="math">GF(2^{4080})</span> . NMBRTHRY list, 22/3/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux. Discrete Logarithms in  <span class="math">GF(2^{6168})</span> . NMBRTHRY list, 21/5/2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Antoine Joux and Reynald Lercier. The function field sieve in the medium prime case. In <em>Advances in Cryptology—EUROCRYPT 2006</em>, volume 4004 of <em>LNCS</em>, pages 254–270. Springer, 2006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Thorsten Kleinjung, Kazumaro Aoki, Jens Franke, Arjen K. Lenstra, Emmanuel Thomé, Joppe W. Bos, Pierrick Gaudry, Alexander Kruppa, Peter L. Montgomery, Dag Arne Osvik, Herman J. J. te Riele, Andrey Timofeev, and Paul Zimmermann. Factorization of a 768-bit RSA modulus. In <em>Advances in Cryptology—CRYPTO 2010</em>, volume 6223 of <em>LNCS</em>, pages 333–350. Springer, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Arjen K. Lenstra. Unbelievable security: Matching AES security using public key systems. In <em>Advances in Cryptology—ASIACRYPT 2001</em>, volume 2248 of <em>LNCS</em>, pages 67–86. Springer, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Alfred J. Menezes, Tatsuaki Okamoto, and Scott A. Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. <em>IEEE Trans. Inform. Theory</em>, 39(5):1639–1646, 1993.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ilya Popovyan. Efficient parallelization of lanczos type algorithms. Cryptology ePrint Archive, Report 2011/416, 2011. http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ryuichi Sakai, Shigeo Mitsunari, and Masao Kasahara. Cryptographic schemes based on pairing over elliptic curve. <em>IEIC Technical Report</em>, 101(214):75–80, 2001.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Naoyuki Shinohara, Takeshi Shimoyama, Takuya Hayashi, and Tsuyoshi Takagi. Key length estimation of pairing-based cryptosystems using  <span class="math">\\eta_t</span>  pairing. In <em>Information Security Practice and Experience</em>, volume 7232 of <em>LNCS</em>, pages 228–244. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Victor Shoup. NTL: A library for doing number theory, 5.5.2 edition, 2009. http://www.shoup.net/ntl/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pierre-Jean Spaenlehauer. Solving multihomogeneous and determinantal systems algorithms complexity applications. Ph.D. thesis, Université Pierre et Marie Curie (UPMC), 2012.</li>
    </ol></li>
    </ul>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">Appendix A</h3>

    <p class="text-gray-300">The following Magma script verifies the solution of the chosen DLP in the order  <span class="math">r_2</span>  subgroup of  <span class="math">\\mathbb{F}_{2^{12}\\cdot 367}^{\\times}</span> :</p>

    <pre><code class="language-text">// Field setup
F2 := GF(2);
F2U&lt;U&gt; := PolynomialRing(F2);
F2_12&lt;u&gt; := ext&lt; F2 | U^12 + U^3 + 1&gt;;
F2_12X&lt;X&gt; := PolynomialRing(F2_12);
modulus := (2^734 + 2^551 + 2^367 + 2^184 + 1) div (13 * 7170258097);
cofactor := (2^4404 - 1) div modulus;
h1 := X^5 + X^3 + X + 1;
h0 := X^6 + X^4 + X^2 + X + 1;
temp1 := Evaluate(h1, X^64) * X + Evaluate(h0, X^64);
temp2 := X^17 + X^15 + X^14 + X^13 + X^12 + X^11 + X^10 + X^6 + 1;
polyx := temp1 div temp2;
Fqx&lt;x&gt; := ext&lt; F2_12 \\mid polyx &gt;;
// This is a generator for the entire multiplicative group of GF(2^4404).
g := x + u^7;
// Generate the target element.
</code></pre>

    <pre><code class="language-text">pi := Pi(RealField(1500));
xpi := &amp;+[ (Floor(pi * 2^(i+1)) mod 2) * u^(11-(i mod 12)) * x^(i div 12) : i in [0..4403]];
</code></pre>

    <p class="text-gray-300"><span class="math">\\label{eq:log:series} \\log := 4093208920214235164093447733900702563725614097945142354192285387447 \\\\ 36043901535168472140823368768956390251106223098014527287101738254282676469 \\\\ 559843114767895545475795766475848754227211594761182312814017076893242;</span></p>

    <p class="text-gray-300">// If the following is true, then verification was successful
(g^cofactor)^log eq xpi^cofactor;</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">Appendix B</h3>

    <p class="text-gray-300">This section provides the algorithmic details of the smoothness testing function used in §4 and §5. Given a polynomial f(X) of degree n over  <span class="math">\\mathbb{F}_q</span> , in order to test its m-smoothness we compute</p>

    <p class="text-gray-300"><span class="math">$t(X) := f&#x27;(X) \\prod_{\\lfloor m/2 \\rfloor + 1}^{m} (X^{q^i} - X) \\mod f</span>$
.</p>

    <p class="text-gray-300">Let R be the quotient ring  <span class="math">\\mathbb{F}_q[X]/\\langle f \\rangle</span>  (so that  <span class="math">R \\cong \\mathbb{F}_q^n</span>  as vector spaces), and denote a residue class in R by [a(X)]. A multiplication in R can be computed using  <span class="math">2n^2</span>   <span class="math">\\mathbb{F}_q</span> -multiplications. In order to obtain the above product our main task is to compute  <span class="math">[X^{q^i}]</span>  for  <span class="math">i \\in \\{\\lfloor m/2 \\rfloor + 1, \\ldots, m\\}</span> , after which we can compute t(X) using  <span class="math">\\lceil m/2 \\rceil</span>  R-multiplications.</p>

    <p class="text-gray-300">First we explain a method how to obtain a general power  <span class="math">[X^{p^{rs}}]</span> , where p is the characteristic of  <span class="math">\\mathbb{F}_q</span> . We precompute  <span class="math">[X^{p^r}], [X^{2p^r}], \\ldots, [X^{(n-1)p^r}]</span>  by consecutively multiplying by [X] (i.e., shifting). This requires  <span class="math">(n-1)(p^r-1)</span>  shifts, each using n  <span class="math">\\mathbb{F}_q</span> -multiplications, so less than  <span class="math">n^2p^r</span>   <span class="math">\\mathbb{F}_q</span> -multiplications in total.</p>

    <p class="text-gray-300">With this precomputation we then can compute  <span class="math">p^r</span> -powering in R, i.e., one application of the map  <span class="math">\\varphi: R \\to R</span> ,  <span class="math">\\alpha \\to \\alpha^{p^r}</span> , in the following way:</p>

    <p class="text-gray-300"><span class="math">$\\left[\\sum_{i=0}^{n-1} a_i X^i\\right]^{p^r} = \\sum_{i=0}^{n-1} a_i^{p^r} \\left[X^{ip^r}\\right]</span>$</p>

    <p class="text-gray-300">This requires n  <span class="math">p^r</span> -powering operations in  <span class="math">\\mathbb{F}_q</span>  (which we ignore) and n scalar multiplications in R, hence  <span class="math">n^2</span>   <span class="math">\\mathbb{F}_q</span> -multiplications. Finally, we compute the powers  <span class="math">[X^{p^{ri}}]</span>  by repeatedly applying the map  <span class="math">\\varphi</span> , i.e.,  <span class="math">[X^{p^{ri}}] = \\varphi^i([X]) = \\varphi^{i-1}([X^{p^r}])</span> , for  <span class="math">i \\in \\{2, \\ldots, s\\}</span> , which requires (s-1)  <span class="math">p^r</span> -powerings in R. Altogether we can compute  <span class="math">[X^{p^{rs}}]</span>  in less than  <span class="math">n^2(p^r + s)</span>   <span class="math">\\mathbb{F}_q</span> -operations.</p>

    <p class="text-gray-300">For an alternative method of computing  <span class="math">[X^{p^r}], [X^{2p^r}], \\ldots, [X^{(n-1)p^r}]</span>  we assume that  <span class="math">[X^{p^r}]</span>  is already known. First, by multiplying by [X] we obtain  <span class="math">[X^{p^r+1}], [X^{p^r+2}], \\ldots, [X^{p^r+(n-1)}]</span>  using (n-1) shifts, hence less than  <span class="math">n^2</span>   <span class="math">\\mathbb{F}_q</span> -multiplications. With this we can compute a multiplication by  <span class="math">X^{p^r}</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\left[\\sum_{i=0}^{n-1} a_i X^i\\right] \\cdot [X^{p^r}] = \\sum_{i=0}^{n-1} a_i [X^{p^r+i}],</span>$</p>

    <p class="text-gray-300">using  <span class="math">n^2</span>   <span class="math">\\mathbb{F}_q</span> -multiplications. We apply this multiplication map repeatedly in order to compute  <span class="math">[X^{p^r}], [X^{2p^r}], \\dots, [X^{(n-1)p^r}]</span> ; instead of  <span class="math">n^2p^r</span>   <span class="math">\\mathbb{F}_q</span> -multiplications, this method requires  <span class="math">n^3</span>   <span class="math">\\mathbb{F}_q</span> -multiplications.</p>

    <h2 id="sec-22" class="text-2xl font-bold">Computing the Powers <span class="math">[X^{q^i}]</span></h2>

    <p class="text-gray-300">We outline two strategies to compute the powers  <span class="math">[X^{q^i}]</span>  for  <span class="math">i \\in \\{1, ..., m\\}</span> .</p>

    <p class="text-gray-300">Strategy 1 Write  <span class="math">q = (p^r)^s = p^{rs}</span> . As in the method outlined above we do a precomputation in order to represent the  <span class="math">p^r</span> -powering map in R. We then apply this map repeatedly in order to compute  <span class="math">[X^{p^{rj}}]</span>  for  <span class="math">j \\in \\{2, \\ldots, sm\\}</span> , and obtain this way the powers  <span class="math">[X^{q^i}] = [X^{p^{rsi}}]</span> .</p>

    <p class="text-gray-300">This method requires about  <span class="math">n^2(p^r + sm)</span>   <span class="math">\\mathbb{F}_q</span> -multiplications.</p>

    <p class="text-gray-300">Strategy 2 First we compute  <span class="math">[X^q]</span>  by writing  <span class="math">q = p^{rs}</span>  and using the above method, which requires  <span class="math">n^2(p^r + s)</span>   <span class="math">\\mathbb{F}_q</span> -multiplications. With this we can use the alternative method outlined above for precomputing the q-powering map in R; here we let s = 1, i.e.,  <span class="math">q = p^r</span> . We then apply this map repeatedly to obtain the powers  <span class="math">[X^{q^i}]</span> . This method requires about  <span class="math">n^2(p^r + s + n + m)</span>   <span class="math">\\mathbb{F}_q</span> -multiplications, and corresponds to the smoothness test in the Adj et al. paper; but the version here has an improved running time (the previous one was  <span class="math">n^2(2n+m+4\\log q)</span>   <span class="math">\\mathbb{F}_q</span> -multiplications).</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">Examples</h3>

    <p class="text-gray-300">In the case  <span class="math">q=2^8</span>  the running time (in  <span class="math">\\mathbb{F}_q</span> -multiplications) using Strategy 1 and s=2 is  <span class="math">n^2(16+2m)</span> , while using Strategy 2 and s=4 it is  <span class="math">n^2(8+n+m)</span> . When  <span class="math">q=2^4</span>  the running time using Strategy 1 and s=1 is  <span class="math">n^2(16+m)</span> , and using Strategy 2 and s=2 is  <span class="math">n^2(6+n+m)</span> . Hence, for typical values of n and m we prefer and implement Strategy 1. For example, if  <span class="math">q=2^4</span> , n=611, m=94 (see §4.3) we need  <span class="math">110n^2</span>   <span class="math">\\mathbb{F}_q</span> -multiplications.</p>

    <p class="text-gray-300">Remark 2. Recall that in either case, in order to obtain t(X) and thus to complete the smoothness test, we have to consider the final  <span class="math">\\lceil m/2 \\rceil</span>  R-multiplications. This requires an additional cost of about  <span class="math">n^2m</span>   <span class="math">\\mathbb{F}_q</span> -multiplications.</p>

`;
---

<BaseLayout title="Breaking &#x27;128-bit Secure&#x27; Supersingular Binary Curves? (2014/119)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/119
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="breaking-128-bit-secure-supersingular-binary-curves-2014" />
  </article>
</BaseLayout>
