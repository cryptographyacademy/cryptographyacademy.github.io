---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1487';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="An Efficient Verifiable State for zk-EVM and Beyond from the Anemoi Hash Function (2022/1487)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        An Efficient Verifiable State for zk-EVM and Beyond
        from the Anemoi Hash Function
      </h1>
      <p class="text-gray-400 mb-2">
        Jianwei Liu, Harshad Patil, Akhil Sai Peddireddy,
        Kevin Singh, Haifeng Sun, Huachuang Sun, Weikeng Chen
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Full Version &middot; eprint 2022/1487
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Our Approach: Use the Standard TurboPlonk
                Recipe on Anemoi</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Applications on Scalability</a>
            </li>
            <li>
              <a href="#sec-1.3"
                class="hover:text-white">
                Applications on Security</a>
            </li>
            <li>
              <a href="#sec-1.4"
                class="hover:text-white">
                Rest of the Note</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Background</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">TurboPlonk</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Flystel S-box</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Anemoi Permutation</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Jive Mode of Operation</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                Anemoi Variable-Length Hash</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Starting Point</a>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Initial Attempt</a>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Optimization</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Use Processed Round Key Polynomials as
                Selectors</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Skip Unnecessary Opening During
                Linearization</a>
            </li>
            <li>
              <a href="#sec-5.3"
                class="hover:text-white">
                Connect the Output Wire to the Next Gate</a>
            </li>
            <li>
              <a href="#sec-5.4"
                class="hover:text-white">
                Other Unexplored Optimization</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Final Protocol</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-6.1"
                class="hover:text-white">Indexer</a>
            </li>
            <li>
              <a href="#sec-6.2"
                class="hover:text-white">Prover</a>
            </li>
            <li>
              <a href="#sec-6.3"
                class="hover:text-white">Verifier</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">Design and Implementation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-7.1"
                class="hover:text-white">3-ary Merkle Tree</a>
            </li>
            <li>
              <a href="#sec-7.2"
                class="hover:text-white">
                Domain Separation in the Jive CRH</a>
            </li>
            <li>
              <a href="#sec-7.3"
                class="hover:text-white">
                Concrete Instantiation for the Jive CRH</a>
            </li>
            <li>
              <a href="#sec-7.4"
                class="hover:text-white">
                Concrete Instantiation for the Merkle Tree
                Membership Proof</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">Reference Materials</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgments"
            class="hover:text-white">Acknowledgments</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        In our survey of the various zk-EVM constructions, it becomes
        apparent that verifiable storage of the EVM state starts to be
        one of the dominating costs. This is not surprising because a
        big differentiator of EVM from UTXO is exactly the ability to
        carry states and, most importantly, their transitions; i.e.,
        EVM is a <em>state</em> machine.
      </p>
      <p class="text-gray-300">
        In other words, to build an efficient zk-EVM, one must first
        build an efficient verifiable state. The common approach, which
        has been used in production, is a Merkle forest to authenticate
        the memory that would be randomly accessed within zk-SNARK, and
        optimize the verification of such memory accesses.
      </p>
      <p class="text-gray-300">
        In this note, we describe a way to instantiate a Merkle tree
        with very few gates in TurboPlonk. We use customized gates in
        TurboPlonk to implement a SNARK-friendly hash function called
        Anemoi and its Jive mode of operation [Bou+22], by
        Cl&eacute;mence Bouvier, Pierre Briaud, Pyrros Chaidos,
        L&eacute;o Perrin, Robin Salen, Vesselin Velichkov, and
        Danny Willems.
      </p>
      <p class="text-gray-300">
        We demonstrate that with 16 gates
        (<span class="math">\approx 1</span> gate per round in a
        14-round Anemoi hash), one can verify a 3-to-1 compression
        in a 3-ary Merkle tree. Before this, prior implementations
        would often require hundreds of gates. We anticipate this
        technique to benefit a large number of applications built off
        zk-SNARK.
      </p>
      <p class="text-gray-300">
        <strong>Code:</strong>
        <a
          href="https://github.com/FindoraNetwork/noah"
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >github.com/FindoraNetwork/noah</a>
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        Verifiable accesses to persistent storage (referred to as
        &ldquo;state&rdquo; in the rest of the note) have been a
        recurring topic in the research of zero-knowledge proofs for
        many years. The history of finding an efficient instantiation
        can be summarized as follows.
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 my-4">
        <li>
          SNARK with a quasilinear prover is a critical enabler of the
          original Zerocash paper [Ben+14], which uses SHA256 to build
          a Merkle tree for a verifiable state. In the paper, for each
          layer of the binary Merkle tree, it takes 28161 R1CS
          constraints.
        </li>
        <li>
          Ajtai hash, or the subset sum hash, is used in an SOSP paper
          for verifiable state [BFRSBW13] and then the proof-carrying
          data via cycles of curves paper [BCTV14].
        </li>
        <li>
          Pedersen hash over a suitable embedded curve is used in
          production first in the Sapling upgrade to Zcash. In the end,
          Pedersen hash shows that for each layer, one can do with
          about 1000 R1CS constraints.
        </li>
        <li>
          Starting from MiMC [AGRRT16], we have witnessed a number of
          algebraic hash functions that are designed to be
          SNARK-friendly. Many prior instantiations have about 300 R1CS
          constraints and about 150 customized gates for verification
          of each layer of the Merkle tree.
        </li>
      </ul>
      <p class="text-gray-300">
        <strong>Trend: algebraic-hash-proof-system co-design.</strong>
        There is a trend of research for algebraic hashes to be
        designed, not just as standalone cryptographic instantiations,
        but also related to a particular proof system. The future will
        be a closer collaboration between practitioners and
        cryptanalysts, i.e., a co-design of algebraic hashes and
        proof systems.
      </p>

      <!-- 1.1 -->
      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Our Approach: Use the Standard TurboPlonk Recipe
        on Anemoi
      </h3>
      <p class="text-gray-300">
        Our approach is to leverage a recent algebraic hash
        function&mdash;Anemoi [Bou+22]&mdash;and tweak an existing
        TurboPlonk implementation to inline Anemoi as part of the
        proof system. We do not claim novelty for our work of tweaking,
        as it follows the standard recipe of TurboPlonk.
      </p>
      <p class="text-gray-300">
        <strong>Our approach: inline Anemoi in TurboPlonk.</strong>
        The Anemoi hash follows the substitution-permutation network
        (SPN). It consists of four steps: constant additions, MDS
        diffusion, pseudo-Hadamard transform, and S-box. A round with
        input <span class="math">(a, b, c, d)</span> is being
        processed correctly resulting in output
        <span class="math">(a'', b'', c'', d'')</span> if and only if
        the following equations are satisfied.
      </p>
      <div class="math-block">
        (c' - c'')^5 + g \cdot (c')^2 = a'
      </div>
      <div class="math-block">
        (d' - d'')^5 + g \cdot (d')^2 = b'
      </div>
      <div class="math-block">
        (c' - c'')^5 + g \cdot (c'')^2 + g^&#123;-1&#125; = a''
      </div>
      <div class="math-block">
        (d' - d'')^5 + g \cdot (d'')^2 + g^&#123;-1&#125; = b''
      </div>
      <p class="text-gray-300">
        where <span class="math">g</span> is a generator of the field
        <span class="math">\mathbb&#123;F&#125;</span>,
        <span class="math">(a', b', c', d')</span> is the result of
        applying the linear layer and the pseudo-Hadamard transform to
        <span class="math">(a, b, c, d)</span>, defined as follows:
      </p>
      <div class="math-block">
        a' = (2a+d) + g \cdot (2b+c) + \text&#123;prk&#125;_1[i]
        \quad
        b' = g \cdot (2a+d) + (g^2+1) \cdot (2b+c) +
        \text&#123;prk&#125;_2[i]
      </div>
      <div class="math-block">
        c' = (a+d) + g \cdot (b+c) + \text&#123;prk&#125;_3[i]
        \quad
        d' = g \cdot (a+d) + (g^2+1) \cdot (b+c) +
        \text&#123;prk&#125;_4[i]
      </div>
      <p class="text-gray-300">
        If we use a TurboPlonk with four input wires
        (<span class="math">w_1, w_2, w_3, w_4</span>), we can
        replace <span class="math">(a, b, c, d)</span> and
        <span class="math">(a'', b'', c'', d'')</span> as the input
        for the <span class="math">j</span>-th gate and the
        <span class="math">(j+1)</span>-th gate. Using an additional
        selector polynomial
        <span class="math">q_&#123;sel1&#125;(X)</span>, the
        constraint can be expressed such that all gates satisfy the
        equations. The prover convinces the verifier by committing
        witness polynomials and opening them at a random point
        <span class="math">\zeta</span>.
      </p>
      <p class="text-gray-300">
        <strong>Experiment results.</strong> To demonstrate the
        efficiency of using Anemoi hash function, measurements were
        conducted over the BN254 curve on a c6i.xlarge AWS instance:
      </p>
      <ul class="list-disc list-inside space-y-1 text-gray-300 my-4">
        <li>Number of gates: 16 per Jive compression</li>
        <li>Indexer time: 2.51 ms per Jive compression</li>
        <li>Re-indexer time: 1.25 ms per Jive compression</li>
        <li>Prover time: 1.61 ms per Jive compression</li>
        <li>Verifier time: 4.55 ms (constant verification cost)</li>
      </ul>
      <p class="text-gray-300">
        Compared with previous techniques that take hundreds of gates,
        using Anemoi reduces the number of gates needed for a Merkle
        tree membership proof by about
        <span class="math">7\times</span>.
      </p>

      <!-- 1.2 -->
      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Applications on Scalability: zk-Rollup, zk-EVM,
        and zk-BatchVerify
      </h3>
      <p class="text-gray-300">
        An efficient SNARK-friendly hash implementation benefits
        applications that seek for improving blockchain efficiency:
        zk-Rollup, zk-EVM, and zk-BatchVerify.
      </p>
      <p class="text-gray-300">
        <strong>zk-Rollup:</strong> Rolling up a number of coin
        transfer operations is often done by maintaining and updating a
        Merkle tree of all accounts and their associated balances, with
        a zero-knowledge proof showing all operations are legitimate.
        By making the proving cost for the Merkle tree membership proof
        cheaper, we reduce the overhead to maintain and update account
        balances.
      </p>
      <p class="text-gray-300">
        <strong>zk-EVM:</strong> In zk-EVM, layer 2 rolls up not only
        simple transactions but also smart contract executions.
        A more pressing challenge for zk-EVM is the &ldquo;random
        access&rdquo; part&mdash;the EVM may access a few locations in
        a large memory, and these locations cannot be easily predicted.
        One can build an application-specific SNARK-friendly state
        representation through a Merkle forest.
      </p>
      <p class="text-gray-300">
        <strong>zk-BatchVerify:</strong> A proposed substitute for
        layer-1 on-chain proof verification. Layer 2 verifies proofs
        and returns verification results to layer 1 via a Merkle tree
        arrangement. The SNARK-friendly hash function is used in
        various places in this system, and improvement on the hash
        function reduces overhead throughout the construction.
      </p>

      <!-- 1.3 -->
      <h3 id="sec-1.3" class="text-xl font-semibold mt-8 mb-3">
        1.3 Applications on Security: Zerocash, zk-DID,
        and zk-Bridge
      </h3>
      <p class="text-gray-300">
        An efficient SNARK-friendly hash implementation also benefits
        various applications that offer security: Zerocash, zk-DID,
        and zk-Bridge. It is important to realize that efficiency is
        a crucial limiting factor for the adoption of these
        applications.
      </p>
      <p class="text-gray-300">
        <strong>Zerocash:</strong> In many dApps, the prover runs in
        WebAssembly, leading to a performance penalty of
        <span class="math">10\times</span>. With a SNARK-friendly
        hash, the SRS can be shorter and the prover lighter.
        <strong>zk-DID:</strong> Privacy ensures minimal information
        disclosure; the same prover efficiency issue arises.
        <strong>zk-Bridge (redundancy bridge):</strong> Zero-knowledge
        proofs can verify source chain consensus and expected contract
        executions; the use of a SNARK-friendly hash benefits the
        persistent state access via Merkle trees.
      </p>

      <!-- 1.4 -->
      <h3 id="sec-1.4" class="text-xl font-semibold mt-8 mb-3">
        1.4 Rest of the Note
      </h3>
      <p class="text-gray-300">
        The rest of the note is organized as follows:
        Section 2 provides background on TurboPlonk and Anemoi
        components; Section 3 provides the starting point;
        Section 4 presents an initial (unoptimized) construction;
        Section 5 discusses standard optimization techniques;
        Section 6 gives the detailed final construction;
        Section 7 describes a design and implementation of privacy
        token transfer using Anemoi-based Merkle trees; and
        Section 8 lists reference materials.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. BACKGROUND                                                -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Background</h2>
      <p class="text-gray-300">
        This section provides the necessary background on TurboPlonk,
        the Flystel S-box, the Anemoi permutation, the Jive mode of
        operation, and the Anemoi variable-length hash.
      </p>

      <!-- 2.1 -->
      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 TurboPlonk
      </h3>
      <p class="text-gray-300">
        TurboPlonk is Plonk [GWC19] with customized gates. There are
        many different ways to construct customized gates, and as a
        result, TurboPlonk does not mean a specific construction, but
        a family of proof systems based on Plonk.
      </p>
      <p class="text-gray-300">
        <strong>Circuit representation.</strong> TurboPlonk expresses
        the statement to be proven in zero knowledge as a circuit of
        gates. Each gate has the same number of wires. TurboPlonk
        enforces that these gates satisfy certain conditions, consisting
        of a <em>gate check</em> and a <em>copy check</em>.
      </p>
      <p class="text-gray-300">
        <strong>Gate check:</strong> Each gate has parameters
        (&ldquo;selectors&rdquo;) that define a gate predicate
        <span class="math">G_i(w_1, w_2, w_3, w_4, w_o)
        \in \&#123;0, 1\&#125;</span>. The gate check passes if for
        every gate
        <span class="math">G_i(w_1, w_2, w_3, w_4, w_o) = 0</span>.
      </p>
      <p class="text-gray-300">
        <strong>Copy check:</strong> To combine gates and represent a
        full statement, wires between different gates are connected.
        These connections are expressed as a permutation
        <span class="math">\sigma</span> over all wires, ensuring
        connected wires carry the same value.
      </p>
      <p class="text-gray-300">
        <strong>Arithmetization.</strong> TurboPlonk interpolates wire
        values into polynomials
        <span class="math">w_1(X), w_2(X), w_3(X), w_4(X),
        w_o(X)</span> and gate parameters into selector polynomials.
        The gate check becomes the existence of a polynomial
        <span class="math">g(X)</span> such that:
      </p>
      <div class="math-block">
        q_1(X) \cdot w_1(X) + q_2(X) \cdot w_2(X) + q_3(X) \cdot
        w_3(X) + q_4(X) \cdot w_4(X)
        + q_&#123;m1&#125;(X) \cdot w_1(X) \cdot w_2(X)
        + q_&#123;m2&#125;(X) \cdot w_3(X) \cdot w_4(X)
        + q_c(X) + \text&#123;PI&#125;(X)
        + q_&#123;ecc&#125;(X) \cdot w_1(X) \cdot w_2(X) \cdot
        w_3(X) \cdot w_4(X) \cdot w_o(X)
        - q_o(X) \cdot w_o(X) = g(X) \cdot Z_H(X)
      </div>
      <p class="text-gray-300">
        The copy check uses a permutation polynomial
        <span class="math">S(X)</span> defined via a recursion
        involving a universal one-way hash
        <span class="math">H(x, y) = x + \beta y + \gamma</span>.
        Both checks are verified via polynomial IOPs: the prover sends
        polynomial commitments and opens them at a random point, and
        the verifier checks by the DeMillo&ndash;Lipton&ndash;Zippel
        &ndash;Schwartz lemma.
      </p>
      <p class="text-gray-300">
        <strong>&ldquo;Supergates&rdquo;:</strong> An important
        observation is that the gate function can check multiple
        equations simultaneously. For example, boolean testing
        constraints
        <span class="math">q_b(X) \cdot w_i(X) \cdot
        (w_i(X) - 1) = 0</span> can be enforced alongside the main
        gate equation.
      </p>

      <!-- 2.2 -->
      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Flystel S-box: Rotating an Algebraic Butterfly
      </h3>
      <p class="text-gray-300">
        The Flystel S-box [Bou+22] is based on the butterfly structure.
        It takes input <span class="math">(x, y)</span> and outputs
        <span class="math">(x', y')</span>. The open butterfly
        formulas are:
      </p>
      <div class="math-block">
        x' = x - \beta y^2 + \beta(y -
        (x - \beta y^2))^&#123;2/\alpha&#125; + g^&#123;-1&#125;
      </div>
      <div class="math-block">
        y' = y - (x - \beta y^2)^&#123;1/\alpha&#125;
      </div>
      <p class="text-gray-300">
        Computing <span class="math">(\cdot)^&#123;1/\alpha&#125;</span>
        is expensive. The key insight is that by <em>rotating</em> the
        butterfly counterclockwise, we obtain the closed form:
      </p>
      <div class="math-block">
        x = \beta \cdot y^2 + (y - y')^\alpha
      </div>
      <div class="math-block">
        x' = \beta \cdot (y')^2 + (y - y')^\alpha + g^&#123;-1&#125;
      </div>
      <p class="text-gray-300">
        This is a low-degree polynomial (for BLS12-381,
        <span class="math">\alpha = 5</span>). Although slightly
        expensive to compute, it is easy to verify given both input
        and output, making it ideal for use in a
        substitution-permutation network within zk-SNARK.
      </p>

      <!-- 2.3 -->
      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Anemoi Permutation: a Substitution-Permutation
        Network
      </h3>
      <p class="text-gray-300">
        The Anemoi permutation [Bou+22] follows the standard SPN
        structure with <span class="math">N</span> rounds. Each
        round consists of four steps for input
        <span class="math">(\vec&#123;x&#125;, \vec&#123;y&#125;)
        \in (\mathbb&#123;F&#125;^\ell,
        \mathbb&#123;F&#125;^\ell)</span>:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 my-4">
        <li>
          <strong>Constant addition:</strong> Output
          <span class="math">(\vec&#123;x&#125; + \vec&#123;c&#125;_r,
          \vec&#123;y&#125; + \vec&#123;d&#125;_r)</span> using
          round-specific constants.
        </li>
        <li>
          <strong>MDS matrix:</strong> Apply a fixed MDS matrix
          <span class="math">M \in
          \mathbb&#123;F&#125;^&#123;\ell \times \ell&#125;</span>
          to both halves (with a shift on
          <span class="math">\vec&#123;y&#125;</span>).
        </li>
        <li>
          <strong>Pseudo-Hadamard transform:</strong> Mix
          <span class="math">\vec&#123;x&#125;</span> and
          <span class="math">\vec&#123;y&#125;</span> via
          <span class="math">\vec&#123;v&#125; :=
          \vec&#123;y&#125; + \vec&#123;x&#125;</span> and
          <span class="math">\vec&#123;u&#125; :=
          \vec&#123;y&#125; + 2\vec&#123;x&#125;</span>.
        </li>
        <li>
          <strong>S-box:</strong> Apply the Flystel S-box
          component-wise.
        </li>
      </ul>
      <p class="text-gray-300">
        The operations are repeated for
        <span class="math">N</span> rounds, followed by an additional
        MDS step, yielding a permutation
        <span class="math">\mathbb&#123;F&#125;^&#123;2\ell&#125;
        \to
        \mathbb&#123;F&#125;^&#123;2\ell&#125;</span>.
      </p>

      <!-- 2.4 -->
      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 Jive Mode of Operation:
        <span class="math">k</span>-to-1 Compression
        for Merkle Trees
      </h3>
      <p class="text-gray-300">
        An important observation in [Bou+22] is that for Merkle trees
        in zk-SNARK, we only need a collision-resistant hash function
        (CRH), not a full random oracle. The Anemoi paper shows a CRH
        construction directly from the permutation
        <span class="math">P(\vec&#123;x&#125;, \vec&#123;y&#125;)
        \to (\vec&#123;u&#125;, \vec&#123;v&#125;)</span>:
      </p>
      <div class="math-block">
        \text&#123;CRH&#125;(\vec&#123;x&#125;, \vec&#123;y&#125;)
        = P(\vec&#123;x&#125;, \vec&#123;y&#125;) +
        \sum_&#123;i=1&#125;^&#123;\ell&#125;
        (x[i] + y[i] + u[i] + v[i])
      </div>
      <p class="text-gray-300">
        The cost of the CRH is therefore very close to the cost of the
        permutation itself, and it is used to instantiate the Merkle
        tree in zk-SNARK.
      </p>

      <!-- 2.5 -->
      <h3 id="sec-2.5" class="text-xl font-semibold mt-8 mb-3">
        2.5 Anemoi Variable-Length Hash: a Sponge Construction
      </h3>
      <p class="text-gray-300">
        The Anemoi permutation can be used to construct a sponge using
        the Hirose variant [Hir18]. When the field
        <span class="math">\mathbb&#123;F&#125;</span> is sufficiently
        large, for a permutation from
        <span class="math">\mathbb&#123;F&#125;^&#123;2\ell&#125;</span>
        to
        <span class="math">\mathbb&#123;F&#125;^&#123;2\ell&#125;</span>,
        one can create a sponge with rate
        <span class="math">(2\ell - 1)</span> and capacity 1. The
        sponge construction is naturally immune to length-extension
        attacks.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. STARTING POINT                                            -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. Starting Point</h2>
      <p class="text-gray-300">
        The starting point is a regular TurboPlonk implementation,
        specified via polynomial identity relations and a strategy
        to open the polynomials. The standard copy check is used.
        For any element <span class="math">x</span> in a domain
        <span class="math">H</span>, the gate check includes:
      </p>
      <div class="math-block">
        q_1(X) \cdot w_1(X) + q_2(X) \cdot w_2(X) + q_3(X) \cdot
        w_3(X) + q_4(X) \cdot w_4(X)
        + q_&#123;m1&#125;(X) \cdot w_1(X) \cdot w_2(X)
        + q_&#123;m2&#125;(X) \cdot w_3(X) \cdot w_4(X)
        + q_c(X) + \text&#123;PI&#125;(X)
        + q_&#123;ecc&#125;(X) \cdot w_1(X) \cdot w_2(X)
        \cdot w_3(X) \cdot w_4(X) \cdot w_o(X)
        = q_o(X) \cdot w_o(X)
      </div>
      <p class="text-gray-300">
        along with boolean testing supergates:
      </p>
      <div class="math-block">
        q_b(X) \cdot w_i(X) \cdot (w_i(X) - 1) = 0
        \quad \text&#123;for&#125; \; i \in \&#123;2, 3, 4\&#125;
      </div>
      <p class="text-gray-300">
        In the linearization step, polynomials are opened at random
        points, replacing polynomial evaluations with their values
        at <span class="math">\zeta</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. INITIAL ATTEMPT                                           -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4. Initial Attempt</h2>
      <p class="text-gray-300">
        The note focuses on the case where
        <span class="math">\ell = 2</span>. The customized gates are
        designed by representing the equations directly into polynomial
        identity relations and inlining the linear layer into these
        relations. The key relationship is between the state after the
        S-box in a round
        <span class="math">(x[Abdelrahaman20], x[Martin16], y[Abdelrahaman20], y[Martin16])</span> and the
        state after S-box in the following round
        <span class="math">(x'[Abdelrahaman20], x'[Martin16], y'[Abdelrahaman20], y'[Martin16])</span>.
      </p>
      <p class="text-gray-300">
        <strong>Processed round keys (PRK).</strong> After applying
        constant addition, MDS matrix, and pseudo-Hadamard transform,
        we define processed round keys for each round
        <span class="math">r</span>:
      </p>
      <div class="math-block">
        \text&#123;prk1&#125;_r := 2c_r[Abdelrahaman20] + d_r[Martin16] + g \cdot
        (2c_r[Martin16] + d_r[Abdelrahaman20])
      </div>
      <div class="math-block">
        \text&#123;prk2&#125;_r := g \cdot (2c_r[Abdelrahaman20] + d_r[Martin16]) +
        (g^2+1) \cdot (2c_r[Martin16] + d_r[Abdelrahaman20])
      </div>
      <div class="math-block">
        \text&#123;prk3&#125;_r := c_r[Abdelrahaman20] + d_r[Martin16] + g \cdot
        (c_r[Martin16] + d_r[Abdelrahaman20])
      </div>
      <div class="math-block">
        \text&#123;prk4&#125;_r := g \cdot (c_r[Abdelrahaman20] + d_r[Martin16]) +
        (g^2+1) \cdot (c_r[Martin16] + d_r[Abdelrahaman20])
      </div>
      <p class="text-gray-300">
        The wire assignments use
        <span class="math">w_1(X) = x[Abdelrahaman20]</span>,
        <span class="math">w_2(X) = x[Martin16]</span>,
        <span class="math">w_3(X) = y[Abdelrahaman20]</span>,
        <span class="math">w_4(X) = y[Martin16]</span>, with
        <span class="math">w_i(X\omega)</span> for the next-round
        values. Four selector polynomials
        <span class="math">q_&#123;sel1&#125;(X)</span> through
        <span class="math">q_&#123;sel4&#125;(X)</span> control
        whether each Anemoi equation applies to a given gate. The four
        polynomial identity relations for the closed Flystel butterfly
        are:
      </p>
      <div class="math-block">
        q_&#123;sel1&#125;(X) \cdot \bigl(
        (w_1(X) + w_4(X) + g \cdot (w_2(X) + w_3(X)) +
        q_&#123;prk3&#125;(X) - w_3(X\omega))^5
        + g \cdot (w_1(X) + w_4(X) + g \cdot (w_2(X) + w_3(X)) +
        q_&#123;prk3&#125;(X))^2
        - (2w_1(X) + w_4(X) + g \cdot (2w_2(X) + w_3(X)) +
        q_&#123;prk1&#125;(X)) \bigr) = 0
      </div>
      <div class="math-block">
        q_&#123;sel2&#125;(X) \cdot \bigl(
        (g \cdot (w_1(X) + w_4(X)) + (g^2+1) \cdot (w_2(X)+w_3(X))
        + q_&#123;prk4&#125;(X) - w_4(X\omega))^5
        + g \cdot (g \cdot (w_1(X)+w_4(X)) + (g^2+1) \cdot
        (w_2(X)+w_3(X)) + q_&#123;prk4&#125;(X))^2
        - (g \cdot (2w_1(X)+w_4(X)) + (g^2+1) \cdot (2w_2(X)+w_3(X))
        + q_&#123;prk2&#125;(X)) \bigr) = 0
      </div>
      <div class="math-block">
        q_&#123;sel3&#125;(X) \cdot \bigl(
        (w_1(X)+w_4(X)+g \cdot (w_2(X)+w_3(X))+q_&#123;prk3&#125;(X)
        -w_3(X\omega))^5
        + g \cdot (w_3(X\omega))^2 + g^&#123;-1&#125;
        - w_1(X\omega) \bigr) = 0
      </div>
      <div class="math-block">
        q_&#123;sel4&#125;(X) \cdot \bigl(
        (g \cdot (w_1(X)+w_4(X)) + (g^2+1) \cdot (w_2(X)+w_3(X))
        + q_&#123;prk4&#125;(X) - w_4(X\omega))^5
        + g \cdot (w_4(X\omega))^2 + g^&#123;-1&#125;
        - w_2(X\omega) \bigr) = 0
      </div>
      <p class="text-gray-300">
        <strong>Cost analysis.</strong> The initial attempt has cost
        <strong>8 + 12</strong>: additional indexing for 4 selector
        and 4 processed key polynomials, plus additional openings for
        all 4 selectors, 4 processed keys, and 4 witness polynomials
        at shifted points.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. OPTIMIZATION                                              -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Optimization</h2>
      <p class="text-gray-300">
        This section discusses standard optimization techniques applied
        to the initial construction. These ideas have been used in
        production TurboPlonk implementations.
      </p>

      <!-- 5.1 -->
      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 Use Processed Round Key Polynomials as Selectors
      </h3>
      <p class="text-gray-300">
        For Anemoi-related gates, the processed round key polynomials
        are nonzero with overwhelming probability. For non-Anemoi
        gates, we set
        <span class="math">q_&#123;prk1&#125;(X)</span> through
        <span class="math">q_&#123;prk4&#125;(X)</span> to zero.
        This allows replacing the four selector polynomials
        <span class="math">q_&#123;sel1&#125;(X)</span> through
        <span class="math">q_&#123;sel4&#125;(X)</span> with
        <span class="math">q_&#123;prk3&#125;(X)</span> for all four
        equations, reducing the cost to <strong>4 + 8</strong>.
      </p>

      <!-- 5.2 -->
      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Skip Unnecessary Opening During Linearization
      </h3>
      <p class="text-gray-300">
        Not all polynomials need to be opened. The polynomials
        <span class="math">q_&#123;prk3&#125;(X)</span> and
        <span class="math">q_&#123;prk4&#125;(X)</span> appear inside
        a bracket of
        <span class="math">(\cdot)^5</span>, requiring them to be
        opened. However,
        <span class="math">q_&#123;prk1&#125;(X)</span> and
        <span class="math">q_&#123;prk2&#125;(X)</span> are linear
        components and can use commitment-based verification. This
        reduces the cost to <strong>4 + 6</strong>.
      </p>

      <!-- 5.3 -->
      <h3 id="sec-5.3" class="text-xl font-semibold mt-8 mb-3">
        5.3 Connect the Output Wire to the Next Gate
      </h3>
      <p class="text-gray-300">
        The construction uses
        <span class="math">w_1(\zeta), \ldots, w_4(\zeta)</span> and
        <span class="math">w_1(\zeta\omega), \ldots,
        w_3(\zeta\omega)</span> but never
        <span class="math">w_o(\zeta)</span>. By substituting
        <span class="math">w_4(\zeta\omega)</span> with
        <span class="math">w_o(\zeta)</span> and enforcing
        correctness via the copy check, we save one opening. The final
        optimized equations use
        <span class="math">w_o(X)</span> in place of
        <span class="math">w_4(X\omega)</span> in the second and
        fourth equations, reducing the cost to
        <strong>4 + 5</strong>.
      </p>

      <!-- 5.4 -->
      <h3 id="sec-5.4" class="text-xl font-semibold mt-8 mb-3">
        5.4 Other Unexplored Optimization
      </h3>
      <p class="text-gray-300">
        Several additional optimizations were not explored: explicitly
        structured round keys (may reduce the number of processed round
        key polynomials), more than five wires (may reduce gates but
        increases FFT and MSM costs), using
        <span class="math">\alpha = 3</span> where permissible (not
        applicable for BLS12-381 since
        <span class="math">3 \mid (q-1)</span>), and using a higher
        <span class="math">\alpha</span> in the S-box (minor round
        reduction but increased costs).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. FINAL PROTOCOL                                            -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Final Protocol</h2>
      <p class="text-gray-300">
        The final polynomial identity relations combine the standard
        TurboPlonk gate check, boolean testing supergates, and four
        Anemoi/Jive equations using
        <span class="math">q_&#123;prk3&#125;(X)</span> as the
        selector and <span class="math">w_o(X)</span> replacing
        <span class="math">w_4(X\omega)</span> in the second and
        fourth equations.
      </p>

      <!-- 6.1 -->
      <h3 id="sec-6.1" class="text-xl font-semibold mt-8 mb-3">
        6.1 Indexer
      </h3>
      <p class="text-gray-300">
        The indexer computes commitments and openings for 14 selector
        polynomials
        (<span class="math">q_1, q_2, q_3, q_4, q_o, q_&#123;m1&#125;,
        q_&#123;m2&#125;, q_c, q_&#123;ecc&#125;, q_b,
        q_&#123;prk1&#125;, q_&#123;prk2&#125;, q_&#123;prk3&#125;,
        q_&#123;prk4&#125;</span>)
        and 5 permutation polynomials
        (<span class="math">S_&#123;\sigma 1&#125;, \ldots,
        S_&#123;\sigma o&#125;</span>). The indexer proceeds in three
        steps: (1) commit all polynomials, (2) precompute helper
        polynomials <span class="math">L_1(X)</span> and
        <span class="math">Z_H(X)</span>, and (3) compute the
        Lagrange interpolation constants
        <span class="math">c_j</span>.
      </p>

      <!-- 6.2 -->
      <h3 id="sec-6.2" class="text-xl font-semibold mt-8 mb-3">
        6.2 Prover
      </h3>
      <p class="text-gray-300">
        The prover follows 11 steps:
      </p>
      <ol class="list-decimal list-inside space-y-2 text-gray-300
        my-4">
        <li>
          <strong>Assemble public inputs.</strong>
        </li>
        <li>
          <strong>Instantiate the verifier</strong> (Fiat-Shamir
          sponge).
        </li>
        <li>
          <strong>Commit witness polynomials with hiding.</strong>
          Given <span class="math">w_1(X), \ldots, w_o(X)</span>,
          add random blinding polynomials:
          <div class="math-block">
            \widetilde&#123;w_1&#125;(X) = w_1(X) + Z_H(X) \cdot
            (b_1 X^2 + b_2 X + b_3)
          </div>
        </li>
        <li>
          <strong>Build the sigma polynomial</strong> for wiring
          (using challenges
          <span class="math">\beta, \gamma</span>).
        </li>
        <li>
          <strong>Commit the sigma polynomial with hiding.</strong>
        </li>
        <li>
          <strong>Compute the quotient polynomial</strong>
          <span class="math">t(X)</span> using challenge
          <span class="math">\alpha</span>, incorporating all gate
          checks, copy checks, boolean tests, and four Anemoi/Jive
          terms
          <span class="math">t_&#123;h1&#125;(X)</span> through
          <span class="math">t_&#123;h4&#125;(X)</span>.
        </li>
        <li>
          <strong>Commit the split quotient polynomials</strong>
          <span class="math">t_1(X), \ldots, t_5(X)</span>.
        </li>
        <li>
          <strong>Open the polynomials at a random point</strong>
          <span class="math">\zeta</span>: 15 evaluations including
          <span class="math">q_&#123;prk3&#125;(\zeta),
          q_&#123;prk4&#125;(\zeta),
          \widetilde&#123;w_1&#125;(\zeta\omega),
          \widetilde&#123;w_2&#125;(\zeta\omega),
          \widetilde&#123;w_3&#125;(\zeta\omega)</span>.
        </li>
        <li>
          <strong>Compute the linearization polynomial</strong>
          <span class="math">r(X)</span>.
        </li>
        <li>
          <strong>Compute the opening proof polynomials</strong>
          <span class="math">W_\zeta(X)</span> and
          <span class="math">W_&#123;\zeta\omega&#125;(X)</span>.
        </li>
        <li>
          <strong>Output the full proof.</strong>
        </li>
      </ol>
      <p class="text-gray-300">
        The final proof consists of 5 witness commitments, 1 sigma
        commitment, 5 quotient commitments, 15 field element openings,
        and 2 opening proof commitments.
      </p>

      <!-- 6.3 -->
      <h3 id="sec-6.3" class="text-xl font-semibold mt-8 mb-3">
        6.3 Verifier
      </h3>
      <p class="text-gray-300">
        The verifier proceeds in 7 steps:
      </p>
      <ol class="list-decimal list-inside space-y-2 text-gray-300
        my-4">
        <li>
          <strong>Compute all challenges</strong>
          <span class="math">\beta, \gamma, \alpha, \zeta, v,
          u</span> via the Fiat-Shamir sponge.
        </li>
        <li>
          <strong>Compute
          <span class="math">r(\zeta)</span></strong> from the
          opening evaluations, including the four Anemoi/Jive terms.
        </li>
        <li>
          <strong>Assemble
          <span class="math">\text&#123;cm&#125;_r</span></strong>
          from available commitments using linear homomorphism.
        </li>
        <li>
          <strong>Compute linear combination of
          commitments</strong> <span class="math">\text&#123;cm&#125;</span>.
        </li>
        <li>
          <strong>Compute linear combination of
          evaluations</strong> <span class="math">s</span>.
        </li>
        <li>
          <strong>Pairing:</strong> Compute
          <span class="math">L = e((\text&#123;cm&#125;_\zeta +
          u \cdot \text&#123;cm&#125;_&#123;\zeta\omega&#125;),
          x \cdot H)</span>
          and
          <span class="math">R = e((\zeta \cdot
          \text&#123;cm&#125;_\zeta + u \cdot \zeta \cdot \omega
          \cdot \text&#123;cm&#125;_&#123;\zeta\omega&#125; +
          \text&#123;cm&#125; - s \cdot G), H)</span>.
        </li>
        <li>
          <strong>Decision:</strong> Accept if
          <span class="math">L = R</span>.
        </li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- 7. DESIGN AND IMPLEMENTATION                                 -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">
        7. Design and Implementation
      </h2>
      <p class="text-gray-300">
        This section presents an application of the Anemoi hash
        function and the proof system: an anonymous privacy token
        transfer based on the Zerocash construction [Ben+14], focusing
        on the Merkle tree membership proof in zk-SNARK. The code is
        available in the
        <a
          href="https://github.com/FindoraNetwork/noah/"
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >Noah library</a>.
      </p>

      <!-- 7.1 -->
      <h3 id="sec-7.1" class="text-xl font-semibold mt-8 mb-3">
        7.1 3-ary Merkle Tree
      </h3>
      <p class="text-gray-300">
        Coin commitments are organized into a 3-ary Merkle tree storing
        about <span class="math">2^&#123;32&#125;</span> coin
        commitments. Internal node values are
        <span class="math">h = H(\text&#123;left&#125; \|
        \text&#123;mid&#125; \|
        \text&#123;right&#125;)</span>. The 3-to-1 compression is
        implemented using Jive CRH with
        <span class="math">\ell = 2</span>, which actually provides
        4-to-1 compression; a constant is used for the 4th input for
        domain separation.
      </p>

      <!-- 7.2 -->
      <h3 id="sec-7.2" class="text-xl font-semibold mt-8 mb-3">
        7.2 Domain Separation in the Jive CRH
      </h3>
      <p class="text-gray-300">
        The Anemoi hash function uses the first 200 digits of
        <span class="math">\pi</span> to generate round keys. The
        next 200 digits are used through the opened Flystel structure
        to generate 20 padding constants. For the
        <span class="math">i</span>-th level of the Merkle tree,
        the <span class="math">i</span>-th padding constant is used
        during compression.
      </p>

      <!-- 7.3 -->
      <h3 id="sec-7.3" class="text-xl font-semibold mt-8 mb-3">
        7.3 Concrete Instantiation for the Jive CRH
      </h3>
      <p class="text-gray-300">
        The constraint system for the Jive CRH is organized as follows:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 my-4">
        <li>
          <strong>1st round:</strong> Create a gate with
          <span class="math">w_1 = x[Abdelrahaman20], w_2 = x[Martin16], w_3 = y[Abdelrahaman20],
          w_4 = y[Martin16], w_o = y'[Martin16]</span>. Apply the Anemoi
          constraint with appropriate PRK values and enforce
          <span class="math">w_4 = \text&#123;salt&#125;</span>.
        </li>
        <li>
          <strong>Rounds 2&ndash;14:</strong> Progress the state and
          create a gate per round with the Anemoi constraint; suppress
          all other constraints.
        </li>
        <li>
          <strong>Sum of output:</strong> Create a gate computing the
          sum of the final permutation output with appropriate
          coefficients
          (<span class="math">q_1 = 2g</span>,
          <span class="math">q_2 = g^2 + g + 1</span>, etc.).
        </li>
        <li>
          <strong>Sum of input and output:</strong> Create a gate
          computing the Jive CRH result as the sum of inputs, output
          sum, and salt.
        </li>
      </ul>
      <p class="text-gray-300">
        In total, one invocation of the Jive CRH takes 14 gates (plus
        2 for output summation, totaling 16).
      </p>

      <!-- 7.4 -->
      <h3 id="sec-7.4" class="text-xl font-semibold mt-8 mb-3">
        7.4 Concrete Instantiation for the Merkle Tree
        Membership Proof
      </h3>
      <p class="text-gray-300">
        The Merkle tree membership proof in zk-SNARK verifies a path
        from a leaf to the root:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300 my-4">
        <li>
          Compute the leaf hash by applying the Anemoi variable-length
          hash function.
        </li>
        <li>
          Going up the tree path, compute three binary variables:
          <span class="math">\text&#123;is-left-child&#125;</span>,
          <span class="math">\text&#123;is-mid-child&#125;</span>,
          <span class="math">\text&#123;is-right-child&#125;</span>,
          with boolean and summation checks enforced via gates.
        </li>
        <li>
          In each layer, verify the node is in the correct location
          using two gates: one for partial sum via multiplication
          gates, another for combining via a linear gate.
        </li>
        <li>
          Use the Jive CRH to check hashes layer by layer.
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- 8. REFERENCE MATERIALS                                       -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8. Reference Materials</h2>
      <p class="text-gray-300">
        <strong>SNARK-friendly hash functions.</strong> Cryptographically
        secure hash functions for prime fields have been increasingly
        researched. Notable examples include MiMC [AGRRT16], Poseidon
        [GKRRS21], Rescue [AABSDS20], and Anemoi [Bou+22]. These
        commonly serve two roles in zk-SNARK: as collision-resistant
        hash functions for Merkle trees, and as Fiat-Shamir sponges
        for proof recursion.
      </p>
      <p class="text-gray-300">
        <strong>TurboPlonk variants.</strong> Since the invention of
        TurboPlonk [Tur], many variants have been deployed including
        Matter Labs&rsquo;s Franklin crypto library [Fra], Polygon
        Zero&rsquo;s Plonky2 [Plo], Dusk Network&rsquo;s PLONK [Dus],
        and Zcash&rsquo;s Halo2 [Hal].
      </p>
      <p class="text-gray-300">
        <strong>Verifiable data structures.</strong> Four common types
        are used in zk-SNARK: Merkle trees [Mer87], RSA accumulators
        [BM93; LLX07; BBF19], offline memory checking [BEGKN91;
        CDDGS03; SAGL18; Set20], and table lookup [ZBKMNS22; PK22;
        GK22].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGMENTS                                              -->
    <!-- ============================================================ -->

    <section id="acknowledgments" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>
      <p class="text-gray-300">
        We had a discussion with the authors of [Bou+22] and learned a
        lot about Anemoi. We would like to thank Daira Hopwood,
        Yuncong Hu, Dmitry Khovratovich, Pratyush Mishra, Robin Salen,
        Markus Sch&ouml;fnegger, Danny Willems, and Zhenfei Zhang for
        discussions that eventually helped make this work.
      </p>
      <p class="text-gray-300">
        We would also like to thank the researchers who have pioneered
        the study of SNARK-friendly hash functions, despite the fact
        that it is known among researchers that these constructive
        cryptanalysis papers have a harder time in the peer-review
        process.
      </p>
      <p class="text-gray-300">
        <strong>Update:</strong> We would like to congratulate Anemoi
        (as well as Griffin) for being accepted in CRYPTO 2023. This is
        a breakthrough over prior constructive SNARK-friendly hash
        function papers. The progression includes: LowMC (EUROCRYPT
        2015), MiMC (ASIACRYPT 2016), GMiMC (ESORICS 2019), Rescue
        (FSE 2020), Poseidon (USENIX Security 2021), Reinforced
        Concrete (CCS 2022), Ciminion (EUROCRYPT 2022), and now
        Anemoi and Griffin (CRYPTO 2023).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="space-y-2 text-gray-400 text-sm list-none">
        <li>
          [AABSDS20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson,
          Siemen Dhooghe, and Alan Szepieniec. &ldquo;Design of
          symmetric-key primitives for advanced cryptographic
          protocols&rdquo;. In: <em>FSE &rsquo;20</em>. 2020.
        </li>
        <li>
          [AGRRT16] Martin Albrecht, Lorenzo Grassi, Christian
          Rechberger, Arnab Roy, and Tyge Tiessen. &ldquo;MiMC:
          Efficient encryption and cryptographic hashing with minimal
          multiplicative complexity&rdquo;. In:
          <em>ASIACRYPT &rsquo;16</em>. 2016.
        </li>
        <li>
          [BBF19] Dan Boneh, Benedikt B&uuml;nz, and Ben Fisch.
          &ldquo;Batching techniques for accumulators with applications
          to IOPs and stateless blockchains&rdquo;. In:
          <em>CRYPTO &rsquo;19</em>. 2019.
        </li>
        <li>
          [BCMS20] Benedikt B&uuml;nz, Alessandro Chiesa, Pratyush
          Mishra, and Nicholas Spooner. &ldquo;Proof-carrying data
          from accumulation schemes&rdquo;. In:
          <em>TCC &rsquo;20</em>. 2020.
        </li>
        <li>
          [BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas
          Spooner. &ldquo;Interactive oracle proofs&rdquo;. In:
          <em>TCC &rsquo;16b</em>. 2016.
        </li>
        <li>
          [BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer,
          and Madars Virza. &ldquo;Scalable zero knowledge via cycles
          of elliptic curves&rdquo;. In:
          <em>CRYPTO &rsquo;14</em>. 2014.
        </li>
        <li>
          [BEGKN91] Manuel Blum, Will Evans, Peter Gemmell, Sampath
          Kannan, and Moni Naor. &ldquo;Checking the correctness of
          memories&rdquo;. In: <em>FOCS &rsquo;91</em>. 1991.
        </li>
        <li>
          [BFRSBW13] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren,
          Srinath Setty, Andrew J. Blumberg, and Michael Walfish.
          &ldquo;Verifying computations with state&rdquo;. In:
          <em>SOSP &rsquo;13</em>. 2013.
        </li>
        <li>
          [BM93] Josh Benaloh and Michael de Mare. &ldquo;One-way
          accumulators: A decentralized alternative to digital
          signatures&rdquo;. In:
          <em>EUROCRYPT &rsquo;93</em>. 1993.
        </li>
        <li>
          [Ben+14] Eli Ben-Sasson, Alessandro Chiesa, Christina
          Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars
          Virza. &ldquo;Zerocash: Decentralized anonymous payments
          from Bitcoin&rdquo;. In: <em>S&amp;P &rsquo;14</em>. 2014.
        </li>
        <li>
          [Bou+22] Cl&eacute;mence Bouvier, Pierre Briaud, Pyrros
          Chaidos, Robin Salen, L&eacute;o Perrin, Vesselin Velichkov,
          and Danny Willems. &ldquo;New design techniques for efficient
          arithmetization-oriented hash functions: Anemoi permutations
          and Jive compression&rdquo;. In:
          <em>IACR ePrint 2022/840</em>. 2022.
          <a href="/papers/anemoi-2022"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [CCZ98] Claude Carlet, Pascale Charpin, and Victor Zinoviev.
          &ldquo;Codes, bent functions and permutations suitable for
          DES-like cryptosystems&rdquo;. In: <em>Designs, Codes and
          Cryptography &rsquo;98</em>. 1998.
        </li>
        <li>
          [CDDGS03] Dwaine Clarke, Srinivas Devadas, Marten van Dijk,
          Blaise Gassend, and G. Edward Suh. &ldquo;Incremental
          multiset hash functions and their application to memory
          integrity checking&rdquo;. In:
          <em>ASIACRYPT &rsquo;03</em>. 2003.
        </li>
        <li>
          [CHMMVW20] Alessandro Chiesa, Yuncong Hu, Mary Maller,
          Pratyush Mishra, Noah Vesely, and Nicholas Ward.
          &ldquo;Marlin: Preprocessing zkSNARKs with universal and
          updatable SRS&rdquo;. In:
          <em>EUROCRYPT &rsquo;20</em>. 2020.
        </li>
        <li>
          [CL20] Alessandro Chiesa and Siqi Liu. &ldquo;On the
          impossibility of probabilistic proofs in relativized
          worlds&rdquo;. In: <em>ITCS &rsquo;20</em>. 2020.
        </li>
        <li>
          [CL99] Miguel Castro and Barbara Liskov. &ldquo;Practical
          Byzantine fault tolerance&rdquo;. In:
          <em>OSDI &rsquo;99</em>. 1999.
        </li>
        <li>
          [CP17] Anne Canteaut, S&eacute;bastien Duval, and
          L&eacute;o Perrin. &ldquo;A generalisation of Dillon&rsquo;s
          APN permutation with the best known differential and
          nonlinear properties for all fields of size
          <span class="math">2^&#123;4k+2&#125;</span>&rdquo;. In:
          <em>IEEE Trans. Information Theory &rsquo;17</em>. 2017.
        </li>
        <li>
          [Can01] Ran Canetti. &ldquo;Universally composable security:
          A new paradigm for cryptographic protocols&rdquo;. In:
          <em>FOCS &rsquo;01</em>. 2001.
        </li>
        <li>
          [DL78] Richard A. Demillo and Richard J. Lipton. &ldquo;A
          probabilistic remark on algebraic program testing&rdquo;. In:
          <em>Information Processing Letters &rsquo;78</em>. 1978.
        </li>
        <li>
          [Dai] Daira Hopwood. Response in &ldquo;choose improved
          hash function for Merkle Tree (or replace Merkle Tree)&rdquo;
          PR #2258 to zcash/zcash. url:
          <a
            href="https://github.com/zcash/zcash/issues/2258#issuecomment-339801513"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/zcash/zcash/issues/2258</a>.
        </li>
        <li>
          [Dus] <em>Dusk Plonk</em>. url:
          <a
            href="https://github.com/dusk-network/plonk"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/dusk-network/plonk</a>.
        </li>
        <li>
          [Fra] <em>franklin-crypto: Gadget library for
          PLONK/Plookup</em>. url:
          <a
            href="https://github.com/matter-labs/franklin-crypto"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/matter-labs/franklin-crypto</a>.
        </li>
        <li>
          [GK22] Ariel Gabizon and Dmitry Khovratovich.
          &ldquo;flookup: Fractional decomposition-based lookups in
          quasi-linear time independent of table size&rdquo;. In:
          <em>IACR ePrint 2022/1447</em>. 2022.
          <a href="/papers/flookup-2022"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [GKLRSW21] Lorenzo Grassi, Dmitry Khovratovich, Reinhard
          L&uuml;ftenegger, Christian Rechberger, Markus
          Sch&ouml;fnegger, and Roman Walch. &ldquo;Reinforced
          Concrete: A fast hash function for verifiable
          computation&rdquo;. In:
          <em>IACR ePrint 2021/1038</em>. 2021.
          <a href="/papers/reinforced-concrete-2021"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [GKRRS21] Lorenzo Grassi, Dmitry Khovratovich, Christian
          Rechberger, Arnab Roy, and Markus Sch&ouml;fnegger.
          &ldquo;Poseidon: A new hash function for zero-knowledge
          proof systems&rdquo;. In:
          <em>USENIX Security &rsquo;21</em>. 2021.
          <a href="/papers/poseidon-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana
          Ciobotaru. &ldquo;PLONK: Permutations over Lagrange-bases
          for oecumenical noninteractive arguments of
          knowledge&rdquo;. In:
          <em>IACR ePrint 2019/953</em>. 2019.
          <a href="/papers/plonk-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [Gab19] Ariel Gabizon. &ldquo;AuroraLight: Improved prover
          efficiency and SRS size in a Sonic-like system&rdquo;. In:
          <em>IACR ePrint 2019/601</em>. 2019.
          <a href="/papers/auroralight-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [Gro16] Jens Groth. &ldquo;On the size of pairing-based
          non-interactive arguments&rdquo;. In:
          <em>EUROCRYPT &rsquo;16</em>. 2016.
        </li>
        <li>
          [HBHW] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan
          Wilcox. <em>Zcash protocol specification</em>. url:
          <a
            href="https://zips.z.cash/protocol/protocol.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >zips.z.cash/protocol/protocol.pdf</a>.
        </li>
        <li>
          [Hal] <em>halo2</em>. url:
          <a
            href="https://github.com/zcash/halo2"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/zcash/halo2</a>.
        </li>
        <li>
          [Hir18] Shoichi Hirose. &ldquo;Sequential hashing with
          minimum padding&rdquo;. In:
          <em>MDPI Cryptography &rsquo;18</em>. 2018.
        </li>
        <li>
          [Jub] <em>What is Jubjub?</em> url:
          <a
            href="https://z.cash/technology/jubjub/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >z.cash/technology/jubjub/</a>.
        </li>
        <li>
          [KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg.
          &ldquo;Constant-size commitments to polynomials and their
          applications&rdquo;. In:
          <em>ASIACRYPT &rsquo;10</em>. 2010.
        </li>
        <li>
          [LLX07] Jiangtao Li, Ninghui Li, and Rui Xue.
          &ldquo;Universal accumulators with efficient nonmembership
          proofs&rdquo;. In: <em>ACNS &rsquo;07</em>. 2007.
        </li>
        <li>
          [LTYW18] Yongqiang Li, Shizhu Tian, Yuyin Yu, and Mingsheng
          Wang. &ldquo;On the generalization of butterfly
          structure&rdquo;. In: <em>IACR Transactions on Symmetric
          Cryptology &rsquo;18</em>. 2018.
        </li>
        <li>
          [MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and
          Sarah Meiklejohn. &ldquo;Sonic: Zero-knowledge SNARKs from
          linear-size universal and updateable structured reference
          strings&rdquo;. In: <em>CCS &rsquo;19</em>. 2019.
        </li>
        <li>
          [Man] <em>WASM Z-prize challenge proposal (draft)</em>. url:
          <a
            href="https://github.com/Manta-Network/wasm-zkp-challenge"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/Manta-Network/wasm-zkp-challenge</a>.
        </li>
        <li>
          [Mer87] Ralph C. Merkle. &ldquo;A digital signature based on
          a conventional encryption function&rdquo;. In:
          <em>CRYPTO &rsquo;87</em>. 1987.
        </li>
        <li>
          [PBCWC96] Calton Pu, Andrew P. Black, Crispin Cowan,
          Jonathan Walpole, and Charles Consel. &ldquo;A specialization
          toolkit to increase the diversity of operating
          systems&rdquo;. In: <em>ICMAS Workshop on Immunity-Based
          Systems &rsquo;96</em>. 1996.
        </li>
        <li>
          [PK22] Jim Posen and Assimakis A. Kattis.
          &ldquo;Caulk+: Table-independent lookup arguments&rdquo;.
          In: <em>IACR ePrint 2022/957</em>. 2022.
          <a href="/papers/caulk-plus-2022"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [PST13] Charalampos Papamanthou, Elaine Shi, and Roberto
          Tamassia. &ldquo;Signatures of Correct Computation&rdquo;.
          In: <em>TCC &rsquo;13</em>. 2013.
        </li>
        <li>
          [PUB16] L&eacute;o Perrin, Aleksei Udovenko, and Alex
          Biryukov. &ldquo;Cryptanalysis of a theorem: Decomposing the
          only known solution to the big APN problem&rdquo;. In:
          <em>CRYPTO &rsquo;16</em>. 2016.
        </li>
        <li>
          [Plo] <em>Plonky2 &amp; more</em>. url:
          <a
            href="https://github.com/mir-protocol/plonky2"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/mir-protocol/plonky2</a>.
        </li>
        <li>
          [RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum.
          &ldquo;Constant-round interactive proofs for delegating
          computation&rdquo;. In: <em>STOC &rsquo;16</em>. 2016.
        </li>
        <li>
          [SAGL18] Srinath Setty, Sebastian Angel, Trinabh Gupta, and
          Jonathan Lee. &ldquo;Proving the correct execution of
          concurrent services in zero-knowledge&rdquo;. In:
          <em>OSDI &rsquo;18</em>. 2018.
        </li>
        <li>
          [Sch80] Jack T. Schwartz. &ldquo;Fast probabilistic
          algorithms for verification of polynomial identities&rdquo;.
          In: <em>JACM &rsquo;80</em>. 1980.
        </li>
        <li>
          [Set20] Srinath Setty. &ldquo;Spartan: Efficient and
          general-purpose zkSNARKs without trusted setup&rdquo;. In:
          <em>CRYPTO &rsquo;20</em>. 2020.
          <a href="/papers/spartan-2019"
            class="text-blue-400 hover:text-blue-300">
            [page on this site]</a>
        </li>
        <li>
          [Sin] <em>Sinsemilla</em>. url:
          <a
            href="https://zcash.github.io/halo2/design/gadgets/sinsemilla.html"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >zcash.github.io/halo2/design/gadgets/sinsemilla.html</a>.
        </li>
        <li>
          [Tur] <em>Proposal: The Turbo-PLONK program syntax for
          specifying SNARK programs</em>. url:
          <a
            href="https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >docs.zkproof.org/.../proposal-turbo_plonk.pdf</a>.
        </li>
        <li>
          [Wu21] Alexander Wu. &ldquo;Optimizations and improvements
          to cryptographic libraries for zkSNARKs&rdquo;. MA thesis.
          EECS Department, University of California, Berkeley, 2021.
        </li>
        <li>
          [Xie+22] Tiancheng Xie, Jiaheng Zhang, Zerui Cheng, Fan
          Zhang, Yupeng Zhang, Yongzheng Jia, Dan Boneh, and Dawn
          Song. &ldquo;zkBridge: Trustless cross-chain bridges made
          practical&rdquo;. In: <em>CCS &rsquo;22</em>. 2022.
        </li>
        <li>
          [ZBKMNS22] Arantxa Zapico, Vitalik Buterin, Dmitry
          Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin.
          &ldquo;Caulk: Lookup arguments in sublinear time&rdquo;. In:
          <em>CCS &rsquo;22</em>. 2022.
        </li>
        <li>
          [Zip79] Richard Zippel. &ldquo;Probabilistic algorithms for
          sparse polynomials&rdquo;. In:
          <em>EUROSAM &rsquo;79</em>. 1979.
        </li>
        <li>
          [Zks] <em>zkSync</em>. url:
          <a
            href="https://zksync.io/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >zksync.io</a>.
        </li>
      </ul>
    </section>

  </article>
</BaseLayout>
