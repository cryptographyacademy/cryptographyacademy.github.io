---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/808';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SNARGs for $\\mathcal{P}$ from LWE';
const AUTHORS_HTML = 'Arka Rai Choudhuri, Abhishek Jain, Zhengzhong Jin';

const CONTENT = `    <p class="text-gray-300">Arka Rai Choudhuri Abhishek Jain Zhengzhong Jin</p>

    <p class="text-gray-300">Johns Hopkins University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We provide the first construction of a succinct non-interactive argument (SNARG) for all polynomial time deterministic computations based on standard assumptions. For <span class="math">T</span> steps of computation, the size of the proof and the common random string (CRS) as well as the verification time are poly-logarithmic in <span class="math">T</span>. The security of our scheme relies on the hardness of the Learning with Errors (LWE) problem against polynomial-time adversaries. Previously, SNARGs based on standard assumptions could support bounded-depth computations and required sub-exponential hardness assumptions [Jawale-Kalai-Khurana-Zhang, STOC’21].</p>

    <p class="text-gray-300">Along the way, we also provide the first construction of non-interactive batch arguments for NP based solely on the LWE assumption.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Our Results  3 1.2 Related Work  4</p>

    <p class="text-gray-300">2  Technical Overview  5 2.1 Background  5 2.2 Delegating Polynomial-Time Computations  8 2.3 Non-interactive Batch Arguments for NP  12 2.3.1 Batch Arguments for Index Languages  13 2.3.2 Batch Arguments for NP  17</p>

    <p class="text-gray-300">3  Preliminaries  18 3.1 Notations  18 3.2 Low-degree Extensions  18 3.3 Learning with Error  18 3.4 Correlation Intractable Hash  19 3.5 Somewhere Extractable Commitment  20 3.6 No-Signaling Somewhere Extractable Commitments  21</p>

    <p class="text-gray-300">4  Non-interactive Batch Arguments  22 4.1 Definition  23 4.2 PCP with Fast Online Verification  24 4.3 BARGs for Index Languages  28 4.4 BARGs for NP  33</p>

    <p class="text-gray-300">5  RAM Delegation  35 5.1 Turing Machine Delegation  35 5.2 RAM Delegation  36 5.3 Hash Tree  37 5.4 Protocol  38 5.4.1 Efficiency  39 5.4.2 Security Proof  41</p>

    <p class="text-gray-300">6  More Efficient Batch Arguments for NP  47</p>

    <p class="text-gray-300">7  Acknowledgments  49</p>

    <p class="text-gray-300">A  Proof of Theorem 5  54</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Consider the following scenario: a client wishes to evaluate a program <span class="math">P</span> (say, represented as a Turing machine) on an input <span class="math">x</span> but does not have the necessary computational resources. Instead, it delegates the computation to an untrusted server who provides the output <span class="math">P(x)</span> together with a proof <span class="math">\\Pi</span>. The key requirement is that the proof <span class="math">\\Pi</span> should be much faster to verify than the time it takes to compute <span class="math">P(x)</span>.</p>

    <p class="text-gray-300">The focus of this work is on constructing such proof systems in the non-interactive setting, where they are referred to as <em>succinct non-interactive arguments</em> (SNARGs). The de facto model for such proof systems allows for an initial setup that samples a (reusable) common reference string (CRS) and distributes it to the parties. Furthermore, the soundness guarantee is computational, i.e., it only holds against computationally-bounded provers <em>[x1]</em>. The key benefit of such proof systems is that they can be used as short certificates for the correctness of long computations that can be verified by anyone. Applications of SNARGs abound in the literature and include popular real-world systems such as blockchains <em>[BCG+14]</em>.</p>

    <p class="text-gray-300">In this work, we focus on the task of constructing SNARGs based on <em>standard assumptions</em>. Despite extensive research over the years (see Section 1.2 for a summary), the following basic question has remained open:</p>

    <p class="text-gray-300"><em>Do there exist SNARGs for all polynomial-time (deterministic) computations based on standard assumptions?</em></p>

    <p class="text-gray-300">A recent beautiful work of Jawale, Kalai, Khurana and Zhang <em>[x10]</em> makes progress on this front. They construct SNARGs for <em>bounded-depth</em> deterministic computations based on the sub-exponential hardness of the Learning with Errors (LWE) assumption. The goal of our work is to support arbitrary-depth polynomial-time computations, while relying only on standard polynomial-time assumptions.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">We construct SNARGs for all polynomial-time deterministic computations based on the hardness of LWE against polynomial time adversaries. Our construction is in the common <em>random</em> string model and achieves adaptive soundness.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1 (Informal).</h6>

    <p class="text-gray-300">Assuming the hardness of LWE, for every polynomial <span class="math">T=T(\\lambda)</span>, there exists a publicly-verifiable non-interactive delegation scheme with adaptive soundness for any time <span class="math">T</span> Turing machine. The verifier running time, size of the CRS and proof are all <span class="math">\\poly(\\log T,\\lambda)</span> while the prover running time is <span class="math">\\poly(T,\\lambda)</span>.</p>

    <p class="text-gray-300">Our result also extends, with the same parameters, to delegation of RAM computation.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Non-interactive Batch Arguments.</h4>

    <p class="text-gray-300">Towards obtaining our main result, we study the related problem of <em>non-interactive batch arguments</em> (BARGs) for NP. Informally speaking, such an argument system allows an efficient prover to compute a non-interactive and publicly verifiable “batch proof” of <span class="math">k</span> NP instances, with size smaller than the combined witness length. If any of the <span class="math">k</span> instances is false, then no polynomial-time cheating prover must be able to produce an accepting proof. BARGs allow for delegating non-deterministic computation for a specific sub-class of NP, namely, conjunction of NP statements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Very recently, Choudhuri, Jain and Jin <em>[x4]</em> provided the first construction of BARGs for NP based on standard assumptions. In their scheme, the size of the proof for proving <span class="math">k</span> statements for the circuit satisfiability problem defined by a circuit <span class="math">C</span> is $\\tilde{O}((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\sqrt{k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\cdot\\lambda)$. The security of their scheme is based on the hardness of Quadratic Residuosity (QR) <em>and</em> either LWE or sub-exponential Decisional Diffie-Hellman (DDH).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We improve upon their work along several dimensions that are important towards obtaining our main result in Theorem 1:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We consider (and achieve) a notion of <em>semi-adaptive somewhere soundness</em> which is stronger than the non-adaptive soundness notion considered in <em>[x10]</em>. We discuss this further in Section 2.</li>

      <li>We reduce the dependence on the number of statements in the proof and CRS size to only <em>polylogarithmic</em>.</li>

      <li>We simplify the hardness assumptions and base the security of our scheme <em>solely</em> on LWE.</li>

    </ul>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 2 (Informal).</h6>

    <p class="text-gray-300">Assuming the hardness of LWE, there exists a BARG for NP with the following parameters: in order to prove <span class="math">k</span> instances of a language <span class="math">\\mathcal{L}</span> whose NP-relation can be decided by a Turing machine in time <span class="math">T</span>, the size of the CRS and proof are <span class="math">\\mathrm{poly}(\\log k,\\log T,n,m,\\lambda)</span>, the prover running time is <span class="math">\\mathrm{poly}(k,T,n,m,\\lambda)</span> and the verifier running time is <span class="math">\\mathrm{poly}(\\log k,\\log T,n,m,\\lambda)+\\mathrm{poly}(k,n,\\lambda)</span>, where <span class="math">n</span> is the length of a single instance and <span class="math">m</span> is the length of a single witness.</p>

    <p class="text-gray-300">Finally, we note that our scheme is in the common random string. In contrast, <em>[x10]</em> requires a common <em>reference</em> string.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">We now provide a brief overview of the related work on delegating computation. We borrow from the excellent summaries in <em>[x14, x22]</em> and some of the text below is taken verbatim from these works.</p>

    <p class="text-gray-300">Prior work on delegating computation can be roughly divided in three categories, described below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SNARGs. There is a large body of work, starting from <em>[x23]</em>, that constructs SNARGs for non-deterministic computation (see, e.g., <em>[x22, x13, x11, x12, x16, BCI^{+}13, x1, BCC^{+}17]</em>. These schemes are either in the Random Oracle model or require non-falsifiable assumptions <em>[x24]</em>. However, some of these schemes form the basis of efficient implementations used in practice. Other constructions of SNARGs for deterministic computations are known based on assumptions related to obfuscation or multilinear maps <em>[x11, x18, BGL^{+}15, x12, ACC^{+}16, CCC^{+}16, x19]</em>.</li>

    </ul>

    <p class="text-gray-300">Recently, <em>[x22]</em> constructed SNARGs for deterministic computations (as well as batch arguments for NP) from a new falsifiable but non-standard assumption on groups with bilinear maps (which can be broken with quantum attacks). Independently, <em>[CCH^{+}19]</em> constructed SNARGs for bounded-depth computations based on a very strong assumption, namely, the existence of fully homomorphic encryption with optimal circular security.</p>

    <p class="text-gray-300">Even more recently, <em>[x14]</em> constructed SNARGs for bounded-depth computations from sub-exponential hardness of LWE. Our work overcomes both limitations of their work, i.e. support for bounded-depth computations and use of sub-exponential hardness assumptions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Designated Verifier Proofs. An influential line of work starting from <em>[x15, x16]</em> and continuing with <em>[x21, x3, BKK^{+}18, x17, x18]</em> construct delegation schemes for deterministic computations and various sub-classes of non-deterministic computations (such as batch arguments) based on standard assumptions. The main drawback of these schemes is that they can only be verified by a designated verifier, who knows the “secret key” corresponding to the CRS. The main benefit of our work compared to this line of work is that we achieve public verifiability.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interactive Proofs. In the setting of interactive protocols, publicly verifiable delegation schemes for NP are known from standard assumptions <em>[x10]</em>. The work of <em>[x1]</em> constructs three message protocols based on multi-collision resistant hash functions, and <em>[x18]</em> constructs two-message schemes (in addition to CRS) for low-depth circuits from attribute-based encryption.</li>

    </ul>

    <p class="text-gray-300">Finally, we note that in the interactive setting, delegation schemes with even unconditional soundness are known. The works of <em>[x13, x15]</em> construct such schemes for bounded depth and bounded space computations, respectively. Furthermore, <em>[x13, x15, x16]</em> construct batch proofs (with unconditional soundness) for UP, a subclass of NP where each statement in the language has a unique witness of membership.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">More Related Work.</h4>

    <p class="text-gray-300">We also mention recent works of <em>[x11, x12]</em> that study publicly verifiable non-interactive argument systems for deterministic computations. In particular, assuming standard assumptions on groups with bilinear maps, <em>[x11]</em> constructs a publicly verifiable non-interactive argument system for polynomial-time computations where the proof size does not grow with the size of the computation. Their scheme (as well as <em>[x12]</em>), however, requires a long CRS (and hence, long verification time) proportional to the circuit size.</p>

    <p class="text-gray-300">The work of <em>[x11]</em> introduces the notion of no-signaling commitment schemes. We use this primitive in our construction of SNARGs for polynomial-time computations.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Concurrent Work.</h4>

    <p class="text-gray-300">In a concurrent and independent work, Kalai, Vaikuntanathan and Zhang <em>[x14]</em> provide an elegant alternative transformation from non-interactive batch arguments for NP to a non-interactive delegation scheme. Unlike our transformation, they make use of no-signaling PCPs and additionally require sub-exponential security from non-interactive batch arguments for NP.</p>

    <p class="text-gray-300">As a corollary, they obtain a non-interactive delegation for P assuming sub-exponential hardness of LWE by instantiating their transformation with a sub-exponential secure variant of the non-interactive batch argument presented in this paper.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2 Technical Overview</h2>

    <p class="text-gray-300">Towards our goal of achieving publicly verifiable delegation schemes for all polynomial time computations, we depart significantly from prior approaches in the designated-verifier setting. We leverage advances in the instantiation of the Fiat-Shamir transformation, recently applied in the context of publicly verifiable delegation schemes for bounded-depth computation <em>[CCH^{+}19, x10]</em>. We start with an overview of the necessary background before describing the main ideas underlying our work.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.1 Background</h3>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Fiat-Shamir (FS) Paradigm.</h4>

    <p class="text-gray-300">At a very high level, the Fiat-Shamir transform <em>[x10]</em> is a round collapsing transformation that allows one to start with an <em>interactive proof</em> of a specified structure, and transform it into a <em>non-interactive argument</em> in the CRS model. Specifically, the starting interactive proof system <span class="math">(\\mathsf{P},\\mathsf{V})</span> must be public coin i.e. a protocol where the verifier only sends random coins as its messages.</p>

    <p class="text-gray-300">The transformation is defined with respect to some hash function family <span class="math">\\mathcal{H}</span>, where the sampled hash function, <span class="math">h\\leftarrow\\mathcal{H}</span>, is set to be the CRS. The prover can then derive the verifier’s messages non-interactively by applying <span class="math">h</span> on the protocol transcript. Consider the following interactive protocol between the prover <span class="math">\\mathsf{P}</span> and verifier <span class="math">\\mathsf{V}</span> establishing that <span class="math">x\\in\\mathcal{L}</span>, where <span class="math">\\mathsf{V}</span>’s message <span class="math">\\beta</span> is a uniformly random string.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">To generate a non-interactive proof, P computes <span class="math">\\beta=h(x,\\alpha)</span> with the resultant proof being <span class="math">(\\alpha,\\gamma)</span>. V can recompute <span class="math">\\beta</span> (from <span class="math">x</span> and <span class="math">\\alpha</span>) and check if the transcript <span class="math">(x,\\alpha,\\beta,\\gamma)</span> is accepting. Note that the total communication from the prover to the verifier remains unchanged by the transformation. Therefore, when proof size is the main concern in the non-interactive setting, it is important to start with an interactive protocol that already satisfies the communication requirements.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Soundness of Fiat-Shamir transform and C1.</h4>

    <p class="text-gray-300">Initially, the soundness (i.e. inability of a cheating prover to generate an accepting proof when <span class="math">x\\notin\\mathcal{L}</span>) of the Fiat-Shamir transform was proven by modeling the hash family as a random oracle. An exciting line of recent results have shown that for several applications <em>[x21, x13, x12, CCH^{+}19, x20, x1, x11, x12]</em>, the Fiat-Shamir transformation can be soundly instantiated by a hash function family that is <em>correlation intractable</em>.</p>

    <p class="text-gray-300">First, let us see why there is a need to “re-prove” the soundness in the transformed non-interactive protocol. Unlike in the interactive setting, where the prover has no control over the verifier message <span class="math">\\beta</span>, in the transformed protocol, a cheating prover could try various values of <span class="math">\\alpha</span> as inputs to <span class="math">h</span> until it arrives on a <span class="math">\\beta</span> it finds favorable. Specifically, for every <span class="math">x\\notin\\mathcal{L}</span>, and every <span class="math">\\alpha</span>, we define the set of “bad” <span class="math">\\beta</span>s,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{B}_{x,\\alpha}\\coloneqq\\left\\{\\beta\\,\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,\\exists\\gamma\\text{ s.t. }\\mathsf{V}(x,\\alpha,\\beta,\\gamma)=1\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Intuitively, these are the set of verifier challenges that could lead the verifier to accept, even if the statement is not in the language. We want it to be computationally intractable to find an <span class="math">\\alpha</span> such that <span class="math">h(x,\\alpha)\\in\\mathcal{B}_{x,\\alpha}</span>, i.e. hard to find <span class="math">\\alpha</span> that would result in a <em>bad</em> verifier challenge. This is exactly what <em>correlation intractability</em> of a hash family captures. Specifically, we say that <span class="math">\\mathcal{H}</span> is correlation intractable for a function <span class="math">f</span> if the following holds for all probabilistic polynomial time adversaries (PPT) <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{h\\leftarrow\\mathcal{H}}[h(x)=f(x)\\mid\\mathcal{A}(h)=x]\\leq\\textsf{negl}(\\lambda).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume for the moment that there exists at most one <em>bad</em> verifier challenge for every pair <span class="math">(x,\\alpha)</span>. Then one can define a function <span class="math">f(\\cdot)\\coloneqq\\textsf{BAD}(\\cdot)</span> that on input <span class="math">(x,\\alpha)</span> outputs the unique <span class="math">\\beta\\in\\mathcal{B}_{x,\\alpha}</span> (if it exists). If <span class="math">\\mathcal{H}</span> is a CIH for <span class="math">f</span>, then any cheating prover producing an accepting transcript <span class="math">(\\alpha,\\gamma)</span> for <span class="math">x\\notin\\mathcal{L}</span> must break the correlation intractability of <span class="math">\\mathcal{H}</span>, since by definition <span class="math">h(x,\\alpha)\\in\\mathcal{B}_{x,\\alpha}</span>. For any set <span class="math">\\mathcal{B}_{x,\\alpha}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}_{x,\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is <em>polynomially bounded</em>, one can set </span>f_{i}(\\cdot)\\coloneqq\\textsf{BAD}(\\cdot,i)<span class="math"> to output the </span>i<span class="math">-th element of </span>\\mathcal{B}_{x,\\alpha}<span class="math">. By a simple application of union bound, one can observe that it remains computationally intractable for an adversary to find an </span>\\alpha<span class="math"> such that </span>h(x,\\alpha)<span class="math"> is the output of any </span>f_{i}<span class="math">, and thereby remains intractable to output <em>any</em> element in </span>\\mathcal{B}_{x,\\alpha}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above ideas can be extended to multi-round protocols that additionally satisfy certain properties such as <em>round-by-round soundness</em> <em>[CCH^{+}19]</em>.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Fiat-Shamir Instantiation for Product Relations.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While we described above an extension to <em>any</em> polynomially bounded $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}_{x,\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, this approach no longer works when </span>\\mathcal{B}_{x,\\alpha}$ is super-polynomial. Looking ahead, the set of bad challenges we consider in our work will <em>not</em> be of a polynomially bounded size, and therefore the ideas discussed above do not suffice. Instead, we will borrow upon the recent exciting work</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">of <em>[x10]</em>. Their work consider sets <span class="math">\\mathcal{B}_{x,\\alpha}</span> that for every <span class="math">x</span> and <span class="math">\\alpha</span>, can be represented as a Cartesian product of <span class="math">t</span> sets,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{x,\\alpha}=\\mathcal{B}^{(1)}_{x,\\alpha}\\times\\cdots\\times\\mathcal{B}^{(t)}_{x,\\alpha},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where each <span class="math">\\mathcal{B}^{(i)}_{x,\\alpha}</span> can be efficiently verified, i.e. there is a circuit <span class="math">C</span> that on input <span class="math">(x,\\alpha)</span>, <span class="math">\\beta_{i}</span> and <span class="math">i</span> outputs <span class="math">1</span> if and only <span class="math">\\beta_{i}\\in\\mathcal{B}^{(i)}_{x,\\alpha}</span>. For such sets, <em>[x10]</em> show that one can construct <span class="math">\\mathsf{CI}</span> hash families assuming only the hardness of <span class="math">\\mathsf{LWE}</span> even if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}_{x,\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is not polynomially bounded.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Main Barriers.</h4>

    <p class="text-gray-300">Since the Fiat-Shamir transformation preserves prover communication, it is imperative that our starting interactive protocol already has low communication. A natural candidate for such an interactive protocol is the public coin succinct argument system for <span class="math">\\mathsf{NP}</span> by Kilian <em>[x14]</em> with total communication smaller than the size of the witness. A recent work of <em>[BBH^{+}19]</em>, however, established non-trivial barriers to instantiating the hash function in the Fiat-Shamir transformation of Kilian’s protocol.</p>

    <p class="text-gray-300">There is in fact a broader point to consider: Kilian’s protocol is an <em>argument</em>, i.e. its soundness holds only against computationally bounded cheating provers. In general, successful applications of the Fiat-Shamir paradigm when used in conjunction with <span class="math">\\mathsf{CIH}</span>, have been largely limited to starting with interactive <em>proofs</em>, i.e. protocols for which even a computationally unbounded adversary cannot convince a verifier of the validity of a false statement. In fact there are examples of certain interactive arguments that are not sound on the application of the Fiat-Shamir transformation (see e.g. <em>[x3, x11]</em>).</p>

    <p class="text-gray-300">For this reason, the state of the art non-interactive delegation schemes that follow this approach <em>[CCH^{+}19, x12]</em> rely upon known interactive delegation schemes with unconditional soundness – in particular, the scheme of <em>[x13]</em> for bounded-depth computations. The only other known interactive delegation scheme is for bounded-space computations <em>[x21]</em> (with verification time and communication sublinear in the number of computation steps). As such, it is unclear how to use this approach to achieve our goal of non-interactive delegation for <em>all</em> polynomial time computations.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Our Work.</h4>

    <p class="text-gray-300">In light of the challenges described above, we take a different approach. We choose to view the problem of delegation of deterministic computations through the lens of <em>batch arguments for <span class="math">\\mathsf{NP}</span></em>. Here the prover is trying to convince the verifier of the veracity of <span class="math">k</span> different statements for an <span class="math">\\mathsf{NP}</span> language, with communication smaller than the combined length of the witnesses for all the statements. This is an independently interesting problem, and has seen recent progress in the non-interactive setting based on standard assumptions <em>[x7]</em>.</p>

    <p class="text-gray-300">More specifically, we reduce the task of constructing delegation schemes for polynomial-time computations to the task of constructing non-interactive batch arguments (BARGs) for NP. We then use the Fiat-Shamir methodology to construct BARGs for NP. As is to be expected, the same challenges as discussed earlier in the context of using the Fiat-Shamir transformation apply to the problem of constructing BARGs as well. Indeed, presently interactive batch <em>proofs</em> are only known for UP (a subset of <span class="math">\\mathsf{NP}</span> for which each statement has a unique witness) <em>[x21, x22, x23]</em>, and it is an open problem to construct batch proofs for NP. Nevertheless, as we will discuss later in Section 2.3, we will build upon the “<em>dual-mode methodology</em>” from the recent work of <em>[x7]</em> to circumvent these challenges and construct BARGs (with necessary security and efficiency properties that we discuss below) based on LWE via the Fiat-Shamir methodology. For now, however, we simply assume that such BARGs exist and proceed to describe the main ideas underlying our construction of a delegation scheme for polynomial-time computations.</p>

    <p class="text-gray-300">We remark that some works <em>[x6, x15]</em> have previously studied both of these problems – delegations schemes for deterministic computations and batch arguments for NP –and used common tools and techniques to solve both the problems. We make this connection more explicit by reducing the problem of delegation of deterministic computations to batch arguments for NP. A similar approach was taken in</p>

    <p class="text-gray-300">the work of <em>[x20]</em> who consider the problem of batch verifying <em>interactive proofs</em> in the setting of (unconditionally sound) interactive delegation for bounded space computation. At a very high level, in their work, the prover sends several intermediate steps of the computation and then batches proofs that these intermediate steps were computed correctly. We use a similar blueprint; however, our focus is on the non-interactive setting, and all polynomial-time computations. Furthermore, we require stronger efficiency – poly-logarithmic dependence on the number of computation steps, as opposed to sublinear in <em>[x20]</em>.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">2.2 Delegating Polynomial-Time Computations</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We start our discussion with the problem of delegating the computation of a Turing machine. Here, for a Turing machine <span class="math">\\mathcal{M}</span> and input <span class="math">x</span>, the prover produces a proof <span class="math">\\Pi</span> to convince the verifier that <span class="math">\\mathcal{M}</span> accepts <span class="math">x</span> within <span class="math">T</span> steps, with the requirement that both the proof size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the verifier’s running time are </span>\\operatorname{polylog}(T)<span class="math">. As stated earlier, we want to cast the problem of delegation as a problem of BARGs for NP. Intuitively, a BARG for an NP language </span>\\mathcal{L}<span class="math"> allows the prover to prove that </span>k<span class="math"> statements </span>x_{1},\\cdots,x_{k}<span class="math"> <em>all</em> belong to </span>\\mathcal{L}$ such that communication cost is “small” (we defer the exact communication requirements to later).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To cast the delegation problem as a BARG, we look at the intermediate states of the Turing machine computation. Let <span class="math">\\mathrm{st}_{i}</span> be the encoding of the state of <span class="math">\\mathcal{M}</span> and its tapes after exactly <span class="math">i</span> steps of the computation. We want to prove that for every <span class="math">i\\in[T-1]</span>, <span class="math">\\mathrm{st}_{i+1}=\\mathrm{Step}(\\mathrm{st}_{i})</span>, where <span class="math">\\mathrm{Step}</span> is the <em>deterministic</em> algorithm computing the state transition of a single step. The states <span class="math">\\mathrm{st}_{i}</span> are thus a “witness” to the entire computation. On the surface, this already appears to be a batch problem of <span class="math">T</span> instances, but an observant reader may notice that for each <span class="math">i</span>, the witnesses for <span class="math">i</span> and <span class="math">i+1</span> “overlap”, specifically the overlapping state <span class="math">\\mathrm{st}_{i+1}</span>. If this overlap of witnesses are not ensured, then a cheating prover could use witnesses <span class="math">(\\mathrm{st}_{i},\\mathrm{st}_{i+1})</span> and <span class="math">(\\mathrm{st}^{\\prime}_{i+1},\\mathrm{st}^{\\prime}_{i+2})</span> such that <span class="math">\\mathrm{st}_{i+1}=\\mathrm{Step}(\\mathrm{st}_{i})\\wedge\\mathrm{st}^{\\prime}_{i+2}=\\mathrm{Step}(\\mathrm{st}^{\\prime}_{i+1})</span> but <span class="math">\\mathrm{st}_{i+1}\\neq\\mathrm{st}^{\\prime}_{i+1}</span>. This is clearly undesirable since the overlap of witnesses is necessary to establish <em>continuity</em> in the computation - otherwise a cheating prover is proving <span class="math">T</span> independent statements, unhelpful to establish correctness of computation. Unfortunately, the notion of batch arguments we have described does not enforce any constraints across statements.</p>

    <p class="text-gray-300">We overcome this problem as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Step 1:</em> First, the prover commits to <em>all</em> the internal states $\\mathrm{st}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{st}_{T}<span class="math">. Let this committed value be </span>c$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Step 2:</em> The prover now proves that for every <span class="math">i\\in[T]</span>, <span class="math">(x,c,i)\\in\\mathcal{L}</span>, where <span class="math">\\mathcal{L}</span> is defined by the relation circuit <span class="math">C</span> below.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{Statement: }x,c,i</span> Witness: <span class="math">\\mathrm{st}_{i},\\mathrm{st}_{i+1},\\mathrm{open}_{\\mathrm{st}_{i}},\\mathrm{open}_{\\mathrm{st}_{i+1}}</span> Output: Output 1 if and only if the following verify</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>check if <span class="math">\\mathrm{Com.Verify}(c,\\mathrm{st}_{i},\\mathrm{open}_{\\mathrm{st}_{i}})\\stackrel{{\\scriptstyle?}}{{=}}1</span>.</li>

      <li>check if <span class="math">\\mathrm{Com.Verify}(c,\\mathrm{st}_{i+1},\\mathrm{open}_{\\mathrm{st}_{i+1}})\\stackrel{{\\scriptstyle?}}{{=}}1</span>.</li>

      <li>if <span class="math">i=1</span>, check if <span class="math">\\mathrm{st}_{1}</span> encodes input <span class="math">x</span>.</li>

      <li>if <span class="math">i=T-1</span>, check if <span class="math">\\mathrm{st}_{T}</span> is the <em>accept</em> state.</li>

      <li>Check if <span class="math">\\mathrm{Step}(\\mathrm{st}_{i})=\\mathrm{st}_{i+1}</span>.</li>

    </ol>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\text{open}_{\\text{st}_{i}}</span> corresponds to a proof of opening that <span class="math">\\text{st}_{i}</span> was indeed the <span class="math">i</span>-th vector that was committed to in <span class="math">c</span>.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Weaker Goal: Bounded-Space Computation.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For now, we consider the weaker goal of bounded-space computation since it already highlights the main challenges. Specifically, we allow the total communication and the verification time to be $\\text{poly}(\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, i.e., grow with the size of the internal state. We shall later see how to go beyond the space constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Towards achieving this weaker goal, we establish some efficiency properties of the commitment scheme used in Step 1:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Size of the commitment:</em> Enforcing the same communication constraints as above on the size of the commitment - we have that the commitment to a vector of size $T\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is at most </span>\\text{poly}(\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, i.e. the commitment is <em>succinct</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us now shift our focus to Step 2. Our initial idea is to use a batch argument for NP language to prove all the instances <span class="math">(x,c,i)</span> for the relation circuit <span class="math">C</span>. Note, however, that the verifier of a batch argument inevitably runs in time <span class="math">\\Omega(T)</span> for <span class="math">T</span> instances as it needs to at least read the <span class="math">T</span> instances. This is prohibitive for us since we require the verifier of our delegation scheme to run in time polylogarithmic in <span class="math">T</span>.</p>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Using BARGs for Index Language.</h5>

    <p class="text-gray-300">To overcome this issue, our key observation is that the statements above are <em>identical</em> except for the index <span class="math">i</span>. Hence, the verifier in our case need not suffer from the <span class="math">\\Omega(T)</span> running time barrier, since the number of instances <span class="math">T</span> provides all the necessary information about the instances. This motivates us to adopt the following useful abstraction we call <em>batch arguments for index languages</em>. Formally, the index language is defined as follows,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}^{\\text{idx}}=\\{(C,i)\\mid\\exists w\\text{ s.t. }C(i,w)=1\\}</span></p>

    <p class="text-gray-300">where <span class="math">C</span> represents a circuit, and <span class="math">i</span> an index. In a BARG for an index language, the prover tries to convince the verifier that <span class="math">(C,1),\\cdots,(C,T)\\in\\mathcal{L}^{\\text{idx}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To implement Step 2, we can set the index language such that <span class="math">C</span> contains hard-coded the <em>common inputs</em> across all <span class="math">T</span> instances, namely, the commitment <span class="math">c</span> and input <span class="math">x</span>, and only takes in as input an index <span class="math">i</span>. The witness to <span class="math">C</span> remains unchanged. Towards achieving the relaxed goal of delegating bounded-space computation, we allow the proof size and the verification time of batch argument for <span class="math">T</span> statements to be $\\text{poly}(\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, as long as </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. We note that this already rules out using existing batch arguments based on standard assumptions <em>[x10]</em> since the proof size in their scheme depends on </span>\\sqrt{T}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Security.</h5>

    <p class="text-gray-300">Let us now turn our attention to the security of our approach. Along the way, we will establish the required security properties from the commitment scheme and BARGs for index language.</p>

    <p class="text-gray-300">Since the commitment used in Step 1 is succinct, for every <span class="math">i</span> there could always <em>exist</em> states <span class="math">\\text{st}_{i}^{\\prime}</span> and <span class="math">\\text{st}_{i+1}^{\\prime}</span> with corresponding local commitment openings to <span class="math">c</span> such that <span class="math">\\text{Step}(\\text{st}_{i}^{\\prime})=\\text{st}_{i+1}^{\\prime}</span> even if it is computationally hard to find them. Thus for all <span class="math">i</span> it may always be the case that <span class="math">(C,i)\\in\\mathcal{L}^{\\text{idx}}</span>, making soundness of the batch argument a vacuous notion. The fix is to use <em>somewhere statistical binding commitments</em> <em>[x14]</em> such that for a commitment key generated on input <span class="math">i^{<em>}</span> there is a </em>unique<em> (except with negligible probability) local opening to <span class="math">\\text{st}_{i^{</em>}}^{\\prime},\\text{st}_{i^{<em>}+1}^{\\prime}</span>. Thus, if <span class="math">\\text{Step}(\\text{st}_{i^{</em>}}^{\\prime})\\neq\\text{st}_{i^{<em>}+1}^{\\prime}</span>, then <span class="math">(C,i^{</em>})\\notin\\mathcal{L}^{\\text{idx}}</span>.</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In more detail, let <span class="math">S_{i}</span> be the set of indices corresponding to <span class="math">\\mathrm{st}_{i}</span> in the vector $\\mathrm{st}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{st}_{T}<span class="math">. We will require the somewhere statistical binding property to be at indices </span>S_{i}\\cup S_{i+1}<span class="math"> when the commitment key is generated in the <em>trapdoor mode</em> on input </span>S_{i}\\cup S_{i+1}<span class="math">. We shall shortly see why this is the case. In fact, looking forward, we will actually require something stronger. Namely, generating a key in trapdoor mode on input </span>S_{i}\\cup S_{i+1}<span class="math"> produces a trapdoor that allows for <em>unique extraction</em> at positions </span>S_{i}\\cup S_{i+1}$ even for a commitment produced by an <em>unbounded cheating prover</em>. We refer to this as the <em>somewhere extractable</em> property, and use the shorthand SE to refer to it in the sequel.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From the discussion above, by setting the SE commitment to be extractable for <span class="math">\\mathrm{st}_{i},\\mathrm{st}_{i+1}</span>, the best that one can hope for in terms of BARG soundness is that a cheating prover is not able to produce an accepting proof when the <span class="math">i</span>-th statement is false, i.e. <span class="math">\\mathrm{st}_{i+1}\\neq\\mathrm{Step}(\\mathrm{st}_{i})</span>. This motivates a notion of <em>somewhere soundness</em> where the CRS for the BARG is generated on an index <span class="math">i</span> such that it is hard for a cheating prover to produce an accepting proof when <span class="math">(C,i)\\notin\\mathcal{L}^{\\mathrm{idx}}</span>.</p>

    <p class="text-gray-300">The work of <em>[x10]</em> considered <em>non-adaptive</em> security for BARG, where the statements are fixed <em>before</em> the CRS is generated. In our approach, however, a cheating prover gets to choose the commitment <span class="math">c</span>, which is hardcoded into the circuit <span class="math">C</span>, effectively allowing it to adaptively pick the statements <em>after</em> the CRS is generated. Unfortunately, as observed in <em>[x4]</em>, there are significant barriers to achieving <em>full adaptivity</em>, where the cheating prover can choose the statements <em>after</em> the CRS is generated.</p>

    <p class="text-gray-300">We overcome this seeming conundrum by considering an intermediate notion of security that we call <em>semi-adaptive somewhere soundness</em>. We explain it here for the case of index language. Intuitively, the cheating prover must declare an index <span class="math">i^{<em>}</span> of its choice before the CRS is generated. However, it can choose the circuit <span class="math">C</span> after viewing the CRS. The soundness guarantee states that it will not be able to produce an accepting batch proof if <span class="math">(C,i^{</em>})\\notin\\mathcal{L}</span>. More specifically, for any computationally bounded cheating prover <span class="math">\\mathrm{P}^{*}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\Pi\\text{ accepting}\\\\ (C,i^{<em>})\\notin\\mathcal{L}\\end{array}\\right.\\begin{array}[]{l}i^{</em>}\\leftarrow\\mathrm{P}^{<em>}\\\\ \\mathrm{crs}^{</em>}\\leftarrow\\mathrm{TrapdoorMode}(i^{<em>})\\\\ (\\Pi,C)\\leftarrow\\mathrm{P}^{</em>}(\\mathrm{crs}^{*})\\end{array}\\Bigg{]}<\\mathrm{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">Now that we have seemingly fixed the issues raised above, how do we prove that the above scheme is secure? A natural proof strategy is the following: (1) set the index <span class="math">i</span> for the trapdoor generation of the CRS for BARG, and index <span class="math">S_{i}\\cup S_{i+1}</span> for the commitment key for the SE commitment; (2) extract <span class="math">\\widetilde{\\mathrm{st}}_{i}</span> and <span class="math">\\widetilde{\\mathrm{st}}_{i+1}</span> from the SE commitment using the trapdoor; (3) if <span class="math">\\mathrm{Step}(\\widetilde{\\mathrm{st}}_{i})\\neq\\widetilde{\\mathrm{st}}_{i+1}</span>, but the proof <span class="math">\\Pi</span> is accepting, output <span class="math">(\\Pi,C)</span> as the cheating proof of the BARG scheme.</p>

    <p class="text-gray-300">Let us see why this is the case. From the somewhere extractability property of the SE commitment, we know that other than with negligible probability, the extracted value is the <em>only</em> valid opening. So, if <span class="math">\\mathrm{Step}(\\widetilde{\\mathrm{st}}_{i})\\neq\\widetilde{\\mathrm{st}}_{i+1}</span>, then <span class="math">(C^{\\prime},i)\\notin\\mathcal{L}</span>, and therefore we can break the soundness of the BARG scheme for index languages.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Local vs global soundness.</h4>

    <p class="text-gray-300">By the above, we are guaranteed that if the proof is accepting, then the <span class="math">i</span>-th instance must be true: <span class="math">(C,i)\\in\\mathcal{L}</span>, i.e. it must be the case that the extracted values do indeed satisfy <span class="math">C</span>. This gives us a <em>local soundness</em> guarantee (<span class="math">i</span>-th statement is true), but for the entire computation to be true, we want local soundness to hold simultaneously for all <span class="math">i\\in[T]</span>, i.e. we want <em>global soundness</em>. If one stops to think about this, our argument above for the soundness of the <span class="math">i</span>-th instance crucially relied on extractability at position <span class="math">i</span> and <span class="math">i+1</span>. For simultaneous local soundness to hold, we would require extractability at <em>all</em> positions, which is not achievable in a succinct manner (the commitment size would grow with <span class="math">T</span> instead of <span class="math">\\mathrm{poly}(\\log T)</span> as desired). One might propose an alternate hybrid strategy where one starts by proving the first instance is locally sound, then switch to proving the same for the second</p>

    <p class="text-gray-300">instance and so on. But a local witness, i.e. the extracted value in each case, could satisfy <span class="math">C</span> even though there exists no global witness, i.e. <span class="math">\\mathcal{M}</span> does not accept <span class="math">x</span> in <span class="math">T</span> steps.</p>

    <p class="text-gray-300">This problem is not new to our setting, and is in fact well documented in delegation literature starting with <em>[x11]</em> - either in the construction of no-signaling PCPs <em>[x12, x13, x14, x15, x7, BKK^{∗}18, x6]</em>, or more recently in the use of so-called quasi-arguments <em>[x16]</em> to construct delegation schemes.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">No-signaling commitments.</h4>

    <p class="text-gray-300">We take a slightly different approach and describe the notion of no-signaling with respect to <span class="math">\\mathsf{SE}</span> commitments as done very recently in <em>[x10]</em>. Specifically, an extractor for an <span class="math">\\mathsf{SE}</span> scheme is said to be <em>computationally no-signaling</em> if for any sets <span class="math">S</span> and <span class="math">S^{\\prime}</span>, both of size at most <span class="math">L</span>, the extracted values in the intersection <span class="math">S\\cap S^{\\prime}</span> have computationally indistinguishable marginal distributions whether extracted on set <span class="math">S</span> or <span class="math">S^{\\prime}</span>. Specifically, for any computationally bounded adversary <span class="math">\\mathcal{A}</span>, the following distributions are computationally indistinguishable:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\{(c,y_{S\\cap S^{\\prime}})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(K,\\mathsf{td})\\leftarrow\\mathsf{TrapdoorMode}(L,S)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">c\\leftarrow\\mathcal{A}(K)\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y=\\mathsf{Ext}(\\mathsf{td},c)\\end{array}\\right.\\right.\\right\\}\\approx\\left\\{(c,y_{S\\cap S^{\\prime}})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(K,\\mathsf{td})\\leftarrow\\mathsf{TrapdoorMode}(L,S^{\\prime})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">c\\leftarrow\\mathcal{A}(K)\\\\ y=\\mathsf{Ext}(\\mathsf{td},c)\\end{array}\\right.\\right\\} \\]</p>

    <p class="text-gray-300"><em>[x10]</em> also describe a generic compiler that transforms <em>any</em> <span class="math">\\mathsf{SE}</span> scheme to a no-signaling one (NS-SE) without additional assumptions, thereby preserving the assumptions from the underlying <span class="math">\\mathsf{SE}</span> commitment. We observe that the transformation also preserves the desired efficiency requirements. For completeness, we discuss the transformation in the technical sections of our paper.</p>

    <p class="text-gray-300">It is the no signaling property of the <span class="math">\\mathsf{SE}</span>, in conjunction with the BARG for index languages, that finally gives us a delegation scheme. Consider two experiments:</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathsf{EXP}_{1}}</span>: (a) the BARG CRS is generated on input <span class="math">1</span>, the NS-SE key generated on <span class="math">S_{1}\\cup S_{2}</span>; (b) extract <span class="math">\\mathsf{st}_{1}</span> and <span class="math">\\mathsf{st}_{2}</span> from the NS-SE and output it along with proof <span class="math">\\Pi</span> if <span class="math">\\Pi</span> is accepting.</p>

    <p class="text-gray-300"><span class="math">\\underline{\\mathsf{EXP}_{2}}</span>: (a) the BARG CRS is generated on input <span class="math">2</span>, the NS-SE key generated on <span class="math">S_{2}\\cup S_{3}</span>; (b) extract <span class="math">\\mathsf{st}_{2}^{\\prime}</span> and <span class="math">\\mathsf{st}_{3}^{\\prime}</span> from the NS-SE and output it along with proof <span class="math">\\Pi</span> if <span class="math">\\Pi</span> is accepting.</p>

    <p class="text-gray-300">By our earlier argument, due of the (local) soundness of BARG, we have already established that <span class="math">\\mathsf{st}_{2}</span> is consistent with <span class="math">\\mathsf{st}_{1}</span> in <span class="math">\\mathsf{EXP}_{1}</span>, and <span class="math">\\mathsf{st}_{2}^{\\prime}</span> with <span class="math">\\mathsf{st}_{3}^{\\prime}</span> in <span class="math">\\mathsf{EXP}_{2}</span>. By the description of <span class="math">C</span>, we additionally know that the start state <span class="math">\\mathsf{st}_{1}</span> is consistent with the input <span class="math">x</span>, where by consistent we mean that it is the unique correct state at step <span class="math">1</span> with respect to <span class="math">x</span>. Now, the no-signaling property of the <span class="math">\\mathsf{SE}</span> commitment scheme ensures that <span class="math">\\mathsf{st}_{2}</span> and <span class="math">\\mathsf{st}_{2}^{\\prime}</span> have computationally indistinguishable distributions. This suffices to ensure that <span class="math">\\mathsf{st}_{2}</span> and <span class="math">\\mathsf{st}_{2}^{\\prime}</span> must both be consistent with <span class="math">x</span>, since otherwise there is an efficient distinguisher - compute <span class="math">\\widetilde{\\mathsf{st}}_{2}</span> from <span class="math">x</span> and see which of the two it matches. Therefore, by the fact that <span class="math">\\mathsf{st}_{2}^{\\prime}</span> is consistent with <span class="math">\\mathsf{st}_{3}^{\\prime}</span>, <span class="math">\\mathsf{st}_{3}^{\\prime}</span> is consistent with <span class="math">x</span>. By a hybrid argument we can extend this approach all the way to <span class="math">\\mathsf{st}_{T}</span> establishing that <span class="math">\\mathsf{st}_{T}</span> is indeed consistent with <span class="math">x</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Note that in each experiment the adversary could choose to output a different <span class="math">x</span>, but the above distinguishing check is done with respect to the <span class="math">x</span> output by the adversary, guaranteeing that the extracted <span class="math">\\mathsf{st}_{i}</span> is consistent with the <span class="math">x</span> that the adversary output.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From the proof size of the underlying BARG scheme, the total proof size for the delegation scheme is $\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{st}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log T)<span class="math">. The same is true of the size of the CRS, which depends on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and thus only on </span>\\mathsf{st}$ in our setting. This ensures that the above scheme is a <em>delegation scheme for space bounded computation</em> with a short CRS. Unlike prior work <em>[x16]</em>, our CRS is already “small”, and therefore we do not need an additional bootstrapping step to reduce the CRS size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Beyond bounded space computation.</h5>

    <p class="text-gray-300">To go beyond delegation for bounded space computation, we use ideas from prior works <em>[x13, x1, x12]</em>. The main insight is to simulate a Turing machine <span class="math">\\mathcal{M}</span> with large space via a RAM machine <span class="math">\\mathcal{R}</span>, where the RAM machine has access to a large untrusted external memory but a small internal memory. A digest of the external memory, in the form of the root of the hash tree, is stored in the internal memory. This has two benefits: (i) the root of the hash tree is small (<span class="math">\\operatorname{poly}(\\lambda)</span>), and thus can be stored in the internal memory; and (ii) the hash tree allows for authenticated access, both read and write, to the external memory where the proof size logarithmic in the size of the external memory. Applying these ideas to our bounded space computation, we achieve a RAM delegation protocol. Since the size of the CRS is small in the bounded space computation, it continues to be so in the RAM delegation setting.</p>

    <p class="text-gray-300">The notion of RAM delegation we achieve is similar to that considered in <em>[x12]</em>. Here a prover is convincing the verifier that a RAM machine <span class="math">\\mathcal{R}</span> starting at configuration <span class="math">x</span> (including the large external memory) transitions to configuration <span class="math">y</span> in <span class="math">T</span> steps where the verifier is only given digests <span class="math">\\mathsf{h}_{x}</span> and <span class="math">\\mathsf{h}_{y}</span> of the two configurations. The notion of security is that a computationally bounded cheating prover, other than with negligible probability, should not be able to produce a configuration <span class="math">x</span>, digest <span class="math">\\mathsf{h}</span> and proof <span class="math">\\Pi</span> such that: (i) <span class="math">\\Pi</span> is accepting for the digests <span class="math">(\\mathsf{h}_{x},\\mathsf{h})</span> where <span class="math">\\mathsf{h}_{x}</span> is digest for configuration <span class="math">x</span>; and (ii) <span class="math">\\mathsf{h}</span> is <em>not</em> the digest of the (unique) configuration of <span class="math">\\mathcal{R}</span>, <span class="math">T</span> steps after <span class="math">x</span>. We refer the reader to <em>[x12]</em> for a detailed discussion of the various notions of RAM delegation considered in prior works.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">2.3 Non-interactive Batch Arguments for NP</h3>

    <p class="text-gray-300">Now that we have constructed a delegation scheme for polynomial-time computations assuming the existence of BARGs for index languages, we revisit the problem of constructing such a primitive. In fact, we will consider the more general case of constructing BARGs for NP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that in a <span class="math">\\mathsf{BARG}</span> for <span class="math">\\mathsf{NP}</span>, a prover wants to convince a verifier of the veracity of <span class="math">k</span> statements <span class="math">(x_{1},\\cdots,x_{k})</span> in <span class="math">\\mathcal{L}</span> by producing a non-interactive batch proof that is publicly verifiable, such that if <em>any</em> of the <span class="math">k</span> instances are false (i.e. <span class="math">\\exists i</span> s.t. <span class="math">x_{i}\\notin\\mathcal{L}</span>), then a computationally bounded cheating prover should not be able to generate an accepting proof. If the witness length is $m=m(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, we require the communication to be <em>smaller</em> than </span>k\\cdot m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Prior Work.</h5>

    <p class="text-gray-300">We know of only two solutions to this problem based on falsifiable assumptions: (i) <em>[x12]</em> construct such <span class="math">\\mathsf{BARG}</span> relying on a new non-standard hardness assumption on groups with bilinear maps; and (ii) more recently, <em>[x6]</em> construct the same by assuming the hardness of the quadratic residuosity (QR) assumption in addition to either the hardness of Learning with Errors (LWE) problem, or sub-exponential hardness of the decisional Diffie-Hellman (DDH) problem. In the context of this paper, of particular interest to us is the work of <em>[x6]</em> since they follow the Fiat-Shamir instantiation approach.</p>

    <p class="text-gray-300">As discussed earlier in the context of non-interactive delegation schemes for polynomial-time computation, there are challenges to starting with an interacting <em>argument</em> if we want to go the “Fiat-Shamir instantiation” approach. Instead of tackling the (seemingly harder) problem of constructing interactive batch proofs for <span class="math">\\mathsf{NP}</span>, <em>[x6]</em> choose an alternate starting point to apply the Fiat-Shamir transform. They introduce the notion of a <em>dual-mode interactive batch arguments</em> in the common reference string (CRS) model. The CRS in such protocols can be generated in two <em>computationally indistinguishable</em> modes - <em>normal mode</em> and <em>trapdoor mode</em>. (We have already seen a flavor of this notion when describing the delegation scheme.) For an honest protocol execution, the CRS is generated in the normal mode, while trapdoor mode is used in the proof of soundness. Specifically, in the trapdoor mode, an index <span class="math">i</span> is specified during CRS generation such that if <span class="math">x_{i}\\notin\\mathcal{L}</span>, then even a computationally unbounded cheating prover cannot provide an accepting proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Such a protocol provides two complementary benefits: (i) building a batch argument is easier than building a batch proof; and (ii) it allows for the possibility of instantiating the Fiat-Shamir transform in the trapdoor mode. <em>[x10]</em>, building on the Spartan protocol <em>[x29]</em>, construct such a dual-mode interactive batch argument with non-adaptive soundness. They then show that the specific dual-mode interactive batch argument constructed is Fiat-Shamir <em>compatible</em>, i.e. there exists a hash function family such that the Fiat-Shamir transformation when instantiated with this family is a sound non-interactive batch argument. The size of the batch proof in their protocol is $\\tilde{O}((</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\sqrt{k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})\\cdot\\lambda)<span class="math"> where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the relation circuit for </span>\\mathcal{L}<span class="math">, </span>\\lambda<span class="math"> is the security parameter and </span>\\widetilde{O}<span class="math"> hides factors that are poly-logarithmic in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Our Work.</h4>

    <p class="text-gray-300">In our overview of the delegation scheme for polynomial-time computations, we identified both security and efficiency properties for BARGs we deemed essential for the construction of said delegation scheme. The properties achieved by the BARG scheme of <em>[x10]</em>, however, do not meet these requirements.</p>

    <p class="text-gray-300">To construct BARGs with the desired properties, we adopt the same “dual mode methodology” introduced in <em>[x10]</em>, but deviate from their approach in a couple of crucial aspects. First, instead of building upon the Spartan protocol, we work directly with <em>probabilistic checkable proofs</em> (PCPs), in a manner conceptually similar to Kilian’s protocol. Next, we leverage this change of approach to recurse over the number of statements (akin to <em>[x32]</em>), allowing us to depend only poly-logarithmically on the number of instances. We will elaborate on these points below.</p>

    <p class="text-gray-300">To summarize our improvements over the BARG in <em>[x10]</em>: (i) we achieve the stronger security notion of <em>semi-adaptive somewhere soundness</em>, (ii) we improve upon the size of the batch proofs to incur only poly-logarithmic dependence on <span class="math">k</span>, (iii) we simplify the underlying assumptions - we no longer additionally require the quadratic residuosity (QR) assumption. Our protocol is also conceptually simpler.</p>

    <p class="text-gray-300">The rest of this section is organized as follows: first, we describe our construction of batch arguments for index languages. Next, we discuss how to extend our result to obtain BARGs for <span class="math">\\mathsf{NP}</span>.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">2.3.1 Batch Arguments for Index Languages</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that in a BARG for index languages, the prover is trying to prove that <span class="math">(C,1),\\cdots,(C,k)\\in\\mathcal{L}^{\\mathrm{idx}}</span>. Our goal is to construct such batch arguments with proof size and verification time $\\mathrm{poly}(\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our construction involves the use of PCPs, namely, proofs where the verification procedure only needs to query a few locations of the PCP to be reasonably convinced of the validity of the statement. For now, consider a PCP where the length of the PCP is $m=\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the query </span>Q<span class="math"> is of size </span>\\mathrm{polylog}(m)<span class="math">, where </span>C<span class="math"> is the relation circuit for </span>\\mathcal{L}<span class="math">. The verification procedure only takes in </span>\\mathrm{PCP}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q}<span class="math">, the values of the PCP at the locations specified by </span>Q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The prover generates <span class="math">k</span> PCPs <span class="math">\\mathrm{PCP}_{1},\\cdots,\\mathrm{PCP}_{k}</span> using the corresponding witnesses <span class="math">w_{1},\\cdots,w_{k}</span>. It then arranges the PCPs in rows, and commits to them in a column-wise fashion. On receiving the commitment, the verifier sends the PCP query <span class="math">Q</span> to the prover, who then opens the commitments of the corresponding columns. To be convinced of the proof, the verifier checks if (i) the commitment openings are valid; and (ii) all <span class="math">k</span> PCP proofs verify. Note that the same <span class="math">Q</span> is used for <em>all</em> PCPs. As in the case of our delegation scheme, we use a <em>succinct</em> SE <em>commitment with local opening</em> to commit to each column.</p>

    <p class="text-gray-300">This high level overview is represented in Figure 1.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Delegating the Verification, Recursively.</h4>

    <p class="text-gray-300">The main efficiency bottleneck in the above approach is the third round message consisting of commitment openings that require at least <span class="math">k</span> bits of communication</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: High level overview of initial approach</p>

    <p class="text-gray-300">(length of the message committed). In order to achieve only poly-logarithmic dependence on  <span class="math">k</span> , we delegate the verification process to the prover, building on ideas from prior works [RRR16].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Specifically, we observe that the verification of the commitment openings and the PCP responses constitutes a new index language defined w.r.t. the following relation circuit VerifyC: it takes as input an index  <span class="math">i</span> , and verifies the commitment openings and the PCP responses for the  <span class="math">i</span> -th instance. The PCP query  <span class="math">Q</span>  and the corresponding commitments  $c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_Q$  are hardwired in VerifyC.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hardcoded: The commitments on the coordinates specified by  <span class="math">Q</span> :  $c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_Q, Q$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Input Instance: An index  <span class="math">i</span></p>

    <p class="text-gray-300">Witness: The PCP responses for the  <span class="math">i</span> -th instance  <span class="math">\\{\\mathrm{PCP}[j]\\}_{j\\in Q}</span> , and commitment openings  <span class="math">\\{\\mathrm{open}_j\\}_{j\\in Q}</span> .</p>

    <p class="text-gray-300">Output: Output 1 if and only if the following verify</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify commitment openings:  <span class="math">\\forall j\\in Q</span></li>

    </ol>

    <p class="text-gray-300">Com.Verify  <span class="math">(c_{j},i,\\mathrm{PCP}[j],\\mathrm{open}_{j})\\stackrel {?}{=}1.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify PCP proofs,</li>

    </ol>

    <p class="text-gray-300">PCP.Verify(i, {PCP[j]}j∈Q, Q) = 1.</p>

    <p class="text-gray-300">To delegate the verification work to the prover, we no longer require the prover to explicitly send the openings. Instead, the prover provides another BARG that convinces the verifier that <span class="math">\\mathsf{VerifyC}(i,\\cdot)</span> is satisfiable for all <span class="math">i</span>. If we can ensure that the verification time of the new BARG is smaller, then we can apply this idea <em>recursively</em> until the commitment openings are small enough to send directly.</p>

    <p class="text-gray-300">A naive implementation of this strategy, however, does not provide any benefit since at every recursion level, the new BARG still has <span class="math">k</span> instances, and thus the verifier still needs at least <span class="math">\\Omega(k)</span> time to verify.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Grouping the Instances.</h4>

    <p class="text-gray-300">To save on verification time, our first idea is to reduce the number of instances by “grouping” two instances together. More specifically, we group the indices <span class="math">1,2,\\ldots,k</span> into <span class="math">k/2</span> pairs <span class="math">(1,2),(3,4),\\ldots,(k-1,k)</span>, and use the following “grouped” new circuit <span class="math">\\mathsf{NewRel}</span> as the relation circuit for the new index language. The circuit <span class="math">\\mathsf{NewRel}</span> takes as input the new “grouped” instance <span class="math">(2i-1,2i)</span> and the new witness <span class="math">(\\omega,\\omega^{\\prime})</span>, and checks whether <span class="math">\\mathsf{VerifyC}(2i-1,\\omega)</span> and <span class="math">\\mathsf{VerifyC}(2i,\\omega^{\\prime})</span> both output <span class="math">1</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{NewRel}((2i-1,2i),(\\omega,\\omega^{\\prime}))=\\mathsf{VerifyC}(2i-1,\\omega)\\land\\mathsf{VerifyC}(2i,\\omega^{\\prime}).</span></p>

    <p class="text-gray-300">In this manner, we halve the number of instances at each recursion level and thus the recursion ends in <span class="math">\\log k</span> levels.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unfortunately, the above idea also does not save on verification time. The problem is that the relation circuit size grows exponentially with the number of levels. To see this, let us denote the relation circuit at the <span class="math">L</span>-th recursion level as <span class="math">\\mathsf{NewRel}_{L}</span> and the verification circuit at <span class="math">L</span>-th level as <span class="math">\\mathsf{VerifyC}_{L}</span>. Then since <span class="math">\\mathsf{NewRel}_{L}</span> contains two copies of <span class="math">\\mathsf{VerifyC}_{L}</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{VerifyC}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Furthermore, since </span>\\mathsf{VerifyC}_{L}<span class="math"> contains the PCP verification circuit PCP.Verify for the relation </span>\\mathsf{NewRel}_{L-1}<span class="math"> at the previous level, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{VerifyC}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Combining them, we obtain </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since we have </span>\\log k<span class="math"> levels in total, in the last level </span>L=\\log k<span class="math">, the new relation circuit size becomes at least </span>\\Omega(2^{\\log k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\Omega(k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Thus, the verifier would still run in time </span>\\Omega(k)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">PCPs with Fast Online Verification.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To resolve the above problem, we take a closer look at the PCP verification algorithm. The work of <em>[BCI^{+}13]</em> considers <em>Linear</em> PCPs where the verification algorithm is split into two parts: an input-oblivious query phase, and a very fast online verification phase. The query phase only takes the relation circuit <span class="math">C</span> as input, and outputs some queries <span class="math">Q</span> and a “short” state st. The online-verification phase takes as input an instance <span class="math">x</span> and the state st, and runs in $\\widetilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time to decide to accept or reject. We observe that the same property also holds for many existing <em>standard</em> PCPs. As an example, in this work, we show that the PCP in <em>[x21]</em> can be slightly modified to satisfy almost the same property, except that we allow the online-verification time to be </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ in order to be general enough.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now use the above property of the PCP verification to remove the dependence on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in the size of the new relation circuit </span>\\mathsf{NewRel}_{L}<span class="math"> at level </span>L<span class="math">. Since the query phase is oblivious to the instance </span>x<span class="math"> – which in our case corresponds to the index </span>i<span class="math"> or </span>(2i-1,2i)<span class="math"> etc. – this part can be <em>shared</em> across all the instances at a recursion level. Namely, we have the verifier execute the input-oblivious query phase only <em>once</em> for <em>all</em> the instances, and then use the same state st and the query </span>Q<span class="math"> for the online-verification phase of all instances. Then we replace PCP.Verify in our verification circuit </span>\\mathsf{VerifyC}<span class="math"> with the PCP online verification phase that contains the state st hardwired. Since the online verification phase of PCP runs in time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> where </span>x_{L}<span class="math"> is the length of the instance at the </span>L<span class="math">-th recursion level, we have now improved the size of the new relation circuit </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Avoiding Instance Length Growth.</h4>

    <p class="text-gray-300">An observant reader may notice that even the above improvement does not fully solve our problem. This is because the instance length grows at every recursion level. At the top level, the instances are <span class="math">1,2,\\ldots,k</span>, each of which has bit-length <span class="math">\\log k</span>. Then in the first recursion level,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the instances become <span class="math">(1,2),(3,4),\\ldots,(k-1,k)</span>, which have length <span class="math">2\\log k</span>. At the bottom level <span class="math">L=\\log k</span>, the instance length becomes <span class="math">\\Omega(2^{\\log k})=\\Omega(k)</span>. Therefore, the size of the new relation circuit $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the verification time at the bottom level is still </span>\\Omega(k)$. Thus, it would seem that we have made no progress.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to prevent the growth of the instance length during recursion, we crucially exploit the nature of the index language. Specifically, instead of providing <span class="math">(2i-1,2i)</span> as input to the circuit <span class="math">\\text{NewRel}</span>, we simply provide <span class="math">i</span> as the input instance and then require <span class="math">\\text{NewRel}</span> to generate <span class="math">(2i-1,2i)</span> <em>on its own</em>. Then, it feeds <span class="math">2i-1</span> and <span class="math">2i</span> to two copies of the PCP online verification circuit <span class="math">\\text{VerifyC}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this way, the instance length at each recursion level stays <span class="math">\\log k</span>, while the size of the <span class="math">\\text{NewRel}</span> only increases by <span class="math">\\text{polylog }k</span> for the computation of <span class="math">(2i-1,i)</span>. Hence, the relation circuit size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> at recursion level </span>L<span class="math"> is only </span>\\text{poly}(\\log k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. This allows us to bound </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ for all levels.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Summary of Our Construction.</h4>

    <p class="text-gray-300">In summary, our construction of BARG for index language uses <span class="math">\\log k</span> levels of recursion. In each level, the number of instances is half of the previous level. At each level, the prover commits to the PCP proofs for all instances in a “column-wise” fashion, and sends them to the verifier. Then the verifier uses the input-oblivious PCP query generation algorithm to compute query <span class="math">Q</span> and a short state st once for all the instances. Next, both the parties recursively execute a new BARG for the “grouped” relation circuit <span class="math">\\text{NewRel}</span> with st hardwired. Finally, when they reach the the last level of recursion, the prover sends the witness directly to the verifier.</p>

    <p class="text-gray-300">We now briefly analyze the efficiency of the construction. The verification process consists of two parts:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- PCP query generation algorithm at each level, which runs in time $\\text{poly}(\\lambda,\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda,\\log k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where at the top level, </span>\\text{NewRel}_{0}=C<span class="math">. Hence, we can bound the circuit size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> at each level by </span>\\text{poly}(\\lambda,\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and hence the total verification time is bounded by </span>\\text{poly}(\\lambda,\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover, at recursion level <span class="math">L</span>, computes the witness and instance for the next recursion level in time $\\text{poly}(\\lambda,k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Hence, the prover runs in time </span>\\text{poly}(\\lambda,k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ in total.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The CRS consists of <span class="math">\\log k</span> SE commitment keys for each level of the recursion. By the specific instantiations of the SE commitment scheme<em>[11]</em> (and the correlation intractable hash family <em>[10]</em>), we have that for each level of the recursion, the CRS is of size $\\text{poly}(\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, for a total of </span>\\text{poly}(\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Security.</h4>

    <p class="text-gray-300">Recall that our goal is to achieve <em>semi-adaptive somewhere soundness</em>, which requires that a cheating prover after specifying an index <span class="math">i</span> should not be able to produce an accepting proof when <span class="math">(C,i)\\notin\\mathcal{L}</span>, where the CRS is generated in the trapdoor mode on index <span class="math">i</span>. Taking the approach in <em>[2]</em> of <em>dual mode</em> proofs, we extend the same definition to the interactive setting, but here we allow the adversary to be unbounded once the index to the trapdoor is fixed. Specifically, for any (potentially) cheating prover <span class="math">\\text{P}^{*}</span>,</p>

    <p class="text-gray-300">\\[ \\text{Pr}\\left[\\begin{array}[]{l l}&{\\Pi\\text{ accepting}}\\\\ &(C,i^{<em>})\\notin\\mathcal{L}\\end{array}\\right]\\begin{array}[]{l l}&i^{</em>}\\leftarrow\\text{P}^{<em>}\\\\ &\\text{crs}^{</em>}\\leftarrow\\text{TrapdoorMode}(i^{<em>})\\\\ &(\\Pi,C)\\leftarrow\\langle\\text{P}^{</em>}(\\text{crs}^{*}),\\text{V}\\rangle\\end{array}\\Bigg{]}<\\text{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">where <span class="math">\\langle\\text{P}^{<em>}(\\text{crs}^{</em>}),\\text{V}\\rangle</span> indicates the interaction between the cheating prover <span class="math">\\text{P}^{<em>}</span>, and verifier V with output the proof <span class="math">\\Pi</span> and the circuit the prover chooses <span class="math">C</span>. Note that the </em>mode indistinguishability<em>, i.e. ability to distinguish between the CRS generated for two different indices <span class="math">i</span> and <span class="math">j</span> is still </em>computational*.</p>

    <p class="text-gray-300">Thus for security, in the trapdoor mode, the SE key for each column is generated on a set <span class="math">\\{i\\}</span>, ensuring that the prover is uniquely bound to <span class="math">\\text{PCP}_{i}</span> <em>before</em> it sees the queries <span class="math">Q</span>. This then allows us to rely on the (statistical) soundness of the PCP at index <span class="math">i</span>.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Applying the Fiat-Shamir Transform.</h4>

    <p class="text-gray-300">Given our interactive protocol, we want to compress it to a non-interactive protocol via the Fiat-Shamir transform. As discussed earlier, crucial to this transformation is defining the set of bad verifier challenges.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{B}_{C,c}=\\left\\{Q\\ \\mid\\ \\text{PCP.Verify}(C,\\text{PCP}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1\\ \\land\\ (C,i)\\notin\\mathcal{L}\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\text{PCP}_{i}</span> is extracted using the trapdoor for the SE commitment with the commitment key in the trapdoor mode generated on index <span class="math">i</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we are able to demonstrate that the above set is a Cartesian product of efficiently verifiable sets, then we can apply the <em>[x13]</em> result directly, achieving a result based on LWE. At a very high level, this simply follows from the soundness amplification by parallel repetition in the PCP. Specifically, for the desired parameters, the PCPs we consider have soundness <span class="math">(1-\\varepsilon)</span> for $\\varepsilon=1/\\text{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Since we want the soundness to be negligible, we amplify soundness by parallel repetition, generating </span>t=\\lambda/\\varepsilon<span class="math"> sets of queries </span>Q_{1},\\cdots,Q_{t}<span class="math"> for the same PCP. This gives the desired negligible soundness as </span>(1-\\varepsilon)^{t}=2^{-\\Omega(\\lambda)}$. Thus we have the following set of bad challenges for negligible soundness,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{C,c}=\\mathcal{B}_{C,c}^{(1)}\\times\\cdots\\times\\mathcal{B}_{C,c}^{(t)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where for each <span class="math">i</span>, $\\mathcal{B}_{C,c}^{(i)}=\\{Q_{i}\\mid\\text{PCP.Verify}(C,\\text{PCP}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q_{i}})=1\\land(C,i)\\notin\\mathcal{L}\\}<span class="math">. Each </span>\\mathcal{B}_{C,c}^{(i)}<span class="math"> is also clearly efficiently verifiable since the PCP.Verify can be used to verify if queries </span>Q_{i}\\in\\mathcal{B}_{C,c}^{(i)}<span class="math">. One also needs to verify that </span>(C,i)\\notin\\mathcal{L}<span class="math">, which can be done after extracting </span>\\text{PCP}_{i}$ if we require further properties from the underlying PCP. We note that while the above description is not fully technically precise, it is helpful in providing the main ideas, and we refer the reader to the technical section for the details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It should be noted that the unrolled recursion is a multi-round protocol, while the above argument considers the set of bad challenges for a single level of recursion. <em>[CCH^{+}19]</em> showed that this approach suffices if the protocol is <em>round-by-round sound</em> which in this case intuitively means that if the (batch) claim at one level of the recursion is false, then other than with negligible probability (over the verifier’s random coins), the claim remains false in the next level of recursion. Here, when we set the commitment key to be generated in the trapdoor mode for index <span class="math">i</span>, if at the <span class="math">j</span>-th level of recursion <span class="math">(C^{(j)},i)</span> is false, then other than with negligible probability over the choice of PCP queries <span class="math">Q</span>, <span class="math">(C^{(j+1)},\\lceil i/2\\rceil)</span> is also false.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">2.3.2. Batch Arguments for NP</h4>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">BARG for NP from BARG for index languages.</h4>

    <p class="text-gray-300">We now describe how to transform any BARG for index languages into a BARG for NP. Recall that in a BARG for an NP language <span class="math">\\mathcal{L}</span>, the prover is trying to convince the verifier of the validity of <span class="math">k</span> statements <span class="math">x_{1},\\cdots,x_{k}</span>, i.e. <span class="math">\\mathcal{L}</span> has a relation circuit <span class="math">\\mathcal{R}_{\\mathcal{L}}</span> such that if <span class="math">x_{i}\\in\\mathcal{L}</span>, there exists a witness <span class="math">w_{i}</span> such that <span class="math">\\mathcal{R}_{\\mathcal{L}}(x_{i},w_{i})=1</span>. Contrast this with our discussed notion of BARG for index languages, where there is a <em>single</em> circuit <span class="math">C</span> that takes in inputs <span class="math">i</span> and witness <span class="math">w_{i}</span>, and outputs <span class="math">1</span> if <span class="math">C(i,w_{i})=1</span>.</p>

    <p class="text-gray-300">An immediate idea is to set <span class="math">w_{i}^{\\prime}=(x_{i},w_{i})</span> such that <span class="math">C</span> implements the relation circuit <span class="math">\\mathcal{R}_{\\mathcal{L}}</span>. Since our BARG for index languages allows the prover to choose any witness, the above idea allows a cheating prover to choose new statements different from <span class="math">x_{1},\\cdots,x_{k}</span>, thus the soundness does not translate. The next natural idea is to hardcode the statements <span class="math">x_{1},\\cdots,x_{k}</span> into the circuit <span class="math">C</span>, which now only takes in input <span class="math">(i,w_{i})</span>, but still implements <span class="math">\\mathcal{R}_{\\mathcal{L}}</span>. While we have solved our earlier issue, we have introduced a new one since <span class="math">C</span> now grows linearly in <span class="math">k</span>, and from the efficiency of the BARG scheme, so does the size of the proof.</p>

    <p class="text-gray-300">We solve the communication issue as before, by having the prover arrange the <em>statements</em> in rows, and commit to them column-wise using an SE commitment scheme. <span class="math">C</span> now hardcodes the commitment <span class="math">c</span> instead, where the witness additionally consists of <span class="math">x_{i}</span> along with a proof of (local) opening. We require the prover to use fixed randomness (e.g. <span class="math">0</span>) to compute the commitment. This allows the verifier to check that the prover has indeed committed to the correct statements.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Improving parameters for BARG for NP.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that our constructed batch arguments for NP has proof size $\\operatorname{poly}(\\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. These parameters sufficed for the construction of our delegation scheme for polynomial-time computations since there the circuit size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(\\lambda)<span class="math">, where </span>\\lambda<span class="math"> is the security parameter (which we have not included thus far in our discussion to avoid notation clutter). But in the case of BARG, we want to remove the dependence on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, since the circuit may be large.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To do so, we leverage our delegation scheme for deterministic polynomial-time computations. Consider the NP language <span class="math">\\mathcal{L}=\\{x\\mid\\exists w\\text{ s.t. }\\mathcal{M}(x,w)\\text{ outputs }1\\text{ in }T\\text{ steps }\\}</span>. The high-level idea is the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The prover generates <span class="math">k</span> delegation proofs <span class="math">\\{\\Pi_{i}\\}_{i\\in[k]}</span> that <span class="math">\\mathcal{M}</span> outputs <span class="math">1</span> for each of the inputs <span class="math">(x_{1},w_{1}),\\ldots,</span> <span class="math">(x_{k},w_{k})</span>. By the efficiency of the delegation scheme, each of these proofs are of size $\\operatorname{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, the prover computes a BARG to prove that the delegation verifier will accept <span class="math">(x_{i},w_{i},\\Pi_{i})</span> for every <span class="math">i</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in the BARG now corresponds to the size of the delegation verifier circuit, which is only </span>\\operatorname{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. This gives us the desired efficiency properties.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-41" class="text-2xl font-bold">3 Preliminaries</h2>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">3.1 Notations</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any positive integer <span class="math">n</span>, denote <span class="math">[n]=\\{1,2,\\ldots,n\\}</span>. For any positive integer <span class="math">n</span>, any vector <span class="math">x=(x_{1},x_{2},\\ldots,x_{n})</span>, and any subset <span class="math">S\\subseteq[n]</span>, we denote $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S}=\\{x_{i}\\}_{i\\in S}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">3.2 Low-degree Extensions</h3>

    <p class="text-gray-300">For any field <span class="math">\\mathbb{H}</span> and any extension field <span class="math">\\mathbb{F}</span> of <span class="math">\\mathbb{H}</span>, any index <span class="math">(i_{1},i_{2},\\ldots,i_{m})\\in\\mathbb{H}^{m}</span>, let <span class="math">\\widetilde{\\operatorname{Eq}}_{i_{1},i_{2},\\ldots,i_{m}}</span> be the following polynomial over <span class="math">\\mathbb{F}[x_{1},x_{2},\\ldots,x_{m}]</span>.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\operatorname{Eq}}_{i_{1},i_{2},\\ldots,i_{m}}(x_{1},x_{2},\\ldots,x_{m})=\\frac{\\prod_{j_{1}\\in\\mathbb{H}\\setminus\\{i_{1}\\}}(x_{1}-j_{1})\\cdot\\prod_{j_{2}\\in\\mathbb{H}\\setminus\\{i_{2}\\}}(x_{1}-j_{1})\\ldots\\prod_{j_{m}\\in\\mathbb{H}\\setminus\\{i_{m}\\}}(x_{m}-j_{m})}{\\prod_{j_{1}\\in\\mathbb{H}\\setminus\\{i_{1}\\}}(i_{1}-j_{1})\\cdot\\prod_{j_{2}\\in\\mathbb{H}\\setminus\\{i_{2}\\}}(i_{1}-j_{1})\\ldots\\prod_{j_{m}\\in\\mathbb{H}\\setminus\\{i_{m}\\}}(i_{m}-j_{m})}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any string <span class="math">x\\in\\{0,1\\}^{n}</span>, where $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m}<span class="math">, we identify the set </span>\\mathbb{H}^{m}<span class="math"> with the index set </span>[n]<span class="math">. Then we define the low-degree extension of </span>x<span class="math">, </span>\\mathsf{LDE}(x)<span class="math">, as the following polynomial in </span>\\mathbb{F}[x_{1},x_{2},\\ldots,x_{m}]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{LDE}(x)=\\sum_{i_{1},i_{2},\\ldots i_{m}\\in\\mathbb{H}}x_{i_{1},i_{2},\\ldots,i_{m}}\\cdot\\widetilde{\\operatorname{Eq}}_{i_{1},i_{2},\\ldots,i_{m}}(x_{1},x_{2},\\ldots,x_{m}).</span></p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">3.3 Learning with Error</h3>

    <p class="text-gray-300">The central cryptographic assumption we will require in our work is the Learning with Error (LWE) assumption that we define below.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 1 (Learning with Error Assumption).</h6>

    <p class="text-gray-300">For any positive integers <span class="math">n,q</span>, any <span class="math">\\mathbf{s}\\in\\mathbb{Z}^{n}</span>, and any error distribution <span class="math">\\chi</span> over <span class="math">\\mathbb{Z}</span>, the LWE (Learning with Error) distribution <span class="math">A_{\\mathbf{s},\\chi}</span> is defined by uniformly sampling a vector <span class="math">\\mathbf{a}</span>, and outputting <span class="math">(\\mathbf{a},\\langle\\mathbf{a},\\mathbf{s}\\rangle+e)\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span>, where <span class="math">e\\leftarrow\\chi</span>.</p>

    <p class="text-gray-300">The <span class="math">\\mathsf{LWE}_{n,q,\\chi}</span> assumption states that no non uniform <span class="math">\\mathsf{PPT}</span> adversary can distinguish, with non-negligible probability, between (i) the distribution <span class="math">A_{\\mathbf{s},\\chi}</span> for a single <span class="math">\\mathbf{s}\\leftarrow\\mathbb{Z}_{q}^{n}</span>; and (ii) the uniform distribution over <span class="math">\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">A standard instantiation of LWE chooses <span class="math">\\chi</span> as discrete Gaussian distribution over <span class="math">\\mathbb{Z}</span> with parameters <span class="math">r=2\\sqrt{n}</span>. For this parameterization, LWE is at least as hard as quantumly approximating some “short vector” problem on <span class="math">n</span>-dimensional lattices in the worst case to <span class="math">\\tilde{O}(q\\sqrt{n})</span> factors <em>[x23, x25]</em>. There are also classical reductions for different parameterizations <em>[x24, BLP^{+}13]</em>.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">3.4 Correlation Intractable Hash</h3>

    <p class="text-gray-300">We start by describing a hash family <span class="math">\\mathcal{H}=\\{\\mathcal{H}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span>, which is defined by the two following algorithms:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a <span class="math">\\mathsf{PPT}</span> algorithm that on input the security parameter <span class="math">1^{\\lambda}</span>, outputs key <span class="math">k</span>.</li>

      <li>a deterministic polynomial algorithm than on input a key <span class="math">k\\in\\mathsf{Gen}(1^{\\lambda})</span>, and an element <span class="math">x\\in\\{0,1\\}^{n(\\lambda)}</span> outputs an element <span class="math">y\\in\\{0,1\\}^{\\lambda}</span>.</li>

    </ol>

    <p class="text-gray-300">Given a hash family <span class="math">\\mathcal{H}</span>, we are now ready to define what it means for <span class="math">\\mathcal{H}</span> to be correlation intractable.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 2 (<em>[x1]</em>).</h6>

    <p class="text-gray-300">A hash family <span class="math">\\mathcal{H}=(\\mathcal{H}.\\mathsf{Gen},\\mathcal{H}.\\mathsf{Hash})</span> is said to be correlation intractable (C1) for a relation family <span class="math">\\mathcal{R}=\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> if the following property holds:</p>

    <p class="text-gray-300">For every <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\mathsf{negl}(\\cdot)</span> such that for every <span class="math">R\\in\\mathcal{R}_{\\lambda}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{k\\leftarrow\\mathcal{H}.\\mathsf{Gen}(1^{\\lambda})\\atop x\\leftarrow\\mathcal{A}(k)}[(x,\\mathcal{H}.\\mathsf{Hash}(k,x))\\in R]\\leq\\mathsf{negl}(\\lambda).</span></p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">CIH for Efficiently Verifiable Product Relations.</h4>

    <p class="text-gray-300">We take the following definitions of product relations, and efficiently verifiable relations, from <em>[x14]</em>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 3 (Product Relation, Definition 3.1 <em>[x14]</em>).</h6>

    <p class="text-gray-300">A relation <span class="math">R\\subseteq\\mathcal{X}\\times\\mathcal{Y}^{t}</span> is a product relation, if for any <span class="math">x</span>, the set <span class="math">R_{x}=\\{y\\mid(x,y)\\in R\\}</span> is the Cartesian product of several sets <span class="math">S_{1,x},S_{2,x},\\ldots,S_{t,x}</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">R_{x}=S_{1,x}\\times S_{2,x}\\times\\ldots\\times S_{t,x}.</span></p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 4 (Efficient Product Verifiability, Definition 3.3 <em>[x14]</em>).</h6>

    <p class="text-gray-300">A relation <span class="math">R</span> is efficiently product verifiable, if there exists a circuit <span class="math">C</span> such that, for any <span class="math">x</span>, the sets <span class="math">S_{1,x},S_{2,x}\\ldots S_{t,x}</span> (in Definition 3) satisfy that, for any <span class="math">i</span>, <span class="math">y_{i}\\in S_{i,x}</span> if and only if <span class="math">C(x,y_{i},i)=1</span>.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 5 (Product Sparsity, Definition 3.4 <em>[x14]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A relation <span class="math">R\\subseteq\\mathcal{X}\\times\\mathcal{Y}^{t}</span> has sparsity <span class="math">\\rho</span>, if for any <span class="math">x</span>, the sets <span class="math">S_{1,x},S_{2,x},\\ldots,S_{t,x}</span> (in Definition 3) satisfies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i,x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>[x14]</em> show that for efficient product verifiable relations, there exists a CIH assuming only the hardness of <span class="math">\\mathsf{LWE}</span>.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 3 (CIH for Efficient Product Verifiable Relations, Theorem 5.5 <em>[x14]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">R\\subseteq\\mathcal{X}\\times\\mathcal{Y}^{t}</span> be a <span class="math">T</span>-time product verifiable relation with sparsity at most <span class="math">1-\\epsilon</span>, for <span class="math">\\epsilon\\geq\\lambda^{-O(1)}</span>. Then, if <span class="math">t&gt;\\lambda/\\epsilon</span>, there exists a hash family <span class="math">\\mathcal{H}=\\{\\mathcal{H}_{\\lambda}:\\mathcal{X}_{\\lambda}\\to\\mathcal{Y}_{\\lambda}^{t_{\\lambda}}\\}_{\\lambda}</span> that is correlation intractable for <span class="math">R</span> under LWE assumption. Furthermore, <span class="math">\\mathcal{H}</span> only depends on <span class="math">(\\mathcal{X}_{\\lambda},\\mathcal{Y}_{\\lambda},T_{\\lambda},t_{\\lambda},\\epsilon)</span>, and can be evaluated in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t,T)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">3.5 Somewhere Extractable Commitment</p>

    <p class="text-gray-300">In this subsection, we define <em>somewhere extractable commitments</em>. A somewhere extractable commitment has a key with two computationally indistinguishable modes: (i) In the <em>normal mode</em>, the key is <em>uniformly random</em>; and (ii) in the <em>trapdoor mode</em>, the key is generated according to a subset <span class="math">S</span> denoting the coordinates of the committed message.</p>

    <p class="text-gray-300">Furthermore, we require the following properties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Efficiency: We require that the size of the CRS and commitment roughly grow with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Extraction: The trapdoor mode commitment key is associated with a trapdoor <span class="math">\\operatorname{td}</span>, such that given the trapdoor, one can extract the message on coordinates in <span class="math">S</span>. Note that the extraction implies the statistical binding property for the coordinates in <span class="math">S</span>.</li>

      <li>Local Opening: We allow the prover to generate a <em>local opening</em> for any single coordinate of the message. The local opening needs to have a small size, which only grows poly-logarithmically with the total length of the message. Moreover, we require that the value from the local opening should be consistent with the extracted value.</li>

    </ul>

    <p class="text-gray-300">We note that this notion is essentially the same as somewhere statistical binding hash <em>[x13]</em>, except that we explicitly require an extraction property (although as we will see, this property is already satisfied by the construction of <em>[x13]</em>). This notion is also similar to the notion of somewhere-extractable linearly homomorphic commitment in <em>[x7]</em>, except that here we do not require linear homomorphism property, but we further require local opening property.</p>

    <p class="text-gray-300">We now move to the formal definition. A somewhere extractable commitment scheme is a tuple of algorithms (Gen, TGen, Com, Open, Verify, Ext) described below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname{Gen}(1^{\\lambda},1^{N},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">: On input a security parameter, the length of the message </span>N<span class="math">, and the size of a subset </span>S\\subseteq[N]<span class="math">, the “normal mode” key generation algorithm outputs a <em>uniformly random</em> commitment key </span>K$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\operatorname{TGen}(1^{\\lambda},1^{N},S)</span>: On input a security parameter, the length of the message <span class="math">N</span>, an extraction subset <span class="math">S\\subseteq[N]</span>, the “trapdoor mode” key generation algorithm outputs a commitment key <span class="math">K^{*}</span> and a trapdoor <span class="math">\\operatorname{td}</span>.</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Com}(K,\\mathbf{m}\\in\\{0,1\\}^{N};r)</span>: On input the commitment key <span class="math">K</span>, a vector <span class="math">\\mathbf{m}=(m_{1},m_{2},\\ldots,m_{N})\\in\\{0,1\\}^{N}</span>, and the random coins <span class="math">r</span>, it outputs a commitment <span class="math">c</span>.</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Open}(K,\\mathbf{m},i,r)</span>: On input the commitment key <span class="math">K</span>, a vector <span class="math">\\mathbf{m}=(m_{1},m_{2},\\ldots,m_{N})\\in\\{0,1\\}^{N}</span>, an index <span class="math">i\\in[N]</span>, and the random coins <span class="math">r</span>, the opening algorithm outputs a <em>local opening</em> <span class="math">\\pi_{i}</span> to <span class="math">m_{i}</span>.</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Verify}(K,c,m_{i},i,\\pi_{i})</span>: On input the commitment key <span class="math">K</span>, a commitment <span class="math">c</span>, a bit <span class="math">m_{i}\\in\\{0,1\\}</span>, and a local opening <span class="math">\\pi_{i}</span>, the verification algorithm decides to accept (output 1) or reject (output 0) the local opening.</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Ext}(c,\\operatorname{td})</span>: On input a commitment <span class="math">c</span>, and the trapdoor <span class="math">\\operatorname{td}</span> generated by the trapdoor key generation algorithm TGen with respect to the subset <span class="math">S</span>, the extraction algorithm outputs an extraction string <span class="math">m^{*}_{S}</span> on the subset <span class="math">S</span>.</p>

    <p class="text-gray-300">Furthermore, we require the commitment scheme to satisfy the following properties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinct CRS. The size of the CRS is bounded by $\\operatorname{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinct Commitment. The size of the commitment <span class="math">c</span> is bounded by $\\operatorname{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinct Local Opening. The size of the local opening <span class="math">\\pi_{i}\\leftarrow\\operatorname{Open}(K,m,i,r)</span> is bounded by $\\operatorname{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinct Verification. The running time of the verification algorithm is bounded by $\\operatorname{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Key Indistinguishability. For any non-uniform PPT adversary <span class="math">\\mathcal{A}</span> and any polynomial <span class="math">N=N(\\lambda)</span>, there exists a negligible function <span class="math">\\nu(\\lambda)</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[S\\leftarrow\\mathcal{A}(1^{\\lambda},1^{N}),K\\leftarrow\\mathrm{Gen}(1^{\\lambda},1^{N},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}):\\mathcal{A}(K)=1\\right]-\\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Opening Completeness. For any commitment key <span class="math">K</span>, any message <span class="math">\\mathbf{m}=(m_{1},\\ldots,m_{N})\\in\\{0,1\\}^{N}</span>, any randomness <span class="math">r</span>, and any index <span class="math">i\\in[N]</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[c\\leftarrow\\mathrm{Com}(K,\\mathbf{m};r),\\pi_{i}\\leftarrow\\mathrm{Open}(K,\\mathbf{m},i,r):\\mathsf{Verify}(K,c,m_{i},i,\\pi_{i})=1\\right]=1.</span></p>

    <p class="text-gray-300">Extraction Correctness. For any subset <span class="math">S\\subseteq[N]</span>, any trapdoor key <span class="math">(K^{<em>},\\mathrm{td})\\leftarrow\\mathsf{TGen}(1^{\\lambda},1^{N},S)</span>, any commitment <span class="math">c</span>, any index <span class="math">i\\in[N]</span>, any bit <span class="math">m_{i^{</em>}}\\in\\{0,1\\}</span>, and any proof <span class="math">\\pi_{i^{*}}</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathsf{Verify}(K,c,m_{i^{<em>}},i^{</em>},\\pi_{i^{*}})=1\\Rightarrow\\mathrm{Ext}(c,\\mathrm{td})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{i^{<em>}}=m_{i^{</em>}}\\right]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since the extracted value $\\mathrm{Ext}(c,\\mathrm{td})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{i^{*}}$ is unique, the extraction correctness implies statistical binding property.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">There exists a construction of somewhere extractable commitment from LWE.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof Sketch.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4 is implicit in <em>[x13]</em>. We briefly recall the construction of the somewhere statistical binding hash in <em>[x13]</em> here. For the ease of presentation, we only describe the construction for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> as in <em>[x13]</em>. The construction for general </span>S$ can be obtained by using multiple copies of such commitments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The commitment key consists of a fully homomorphic encryption of the index <span class="math">i^{<em>}</span> in the set <span class="math">S.</span> To hash a message <span class="math">(m_{1},m_{2},\\ldots,m_{N})</span>, they build a Merkle Tree, where each node of the Merkle Tree is associated with a ciphertext. The leaf nodes contains the encryption of <span class="math">m_{i}</span>’s, and for the path from <span class="math">m_{i^{</em>}}</span> to the root, the ciphertext contains an encryption of <span class="math">m_{i^{<em>}}</span>. This is achieved by homomorphically evaluating a circuit that selects the left or the right child according to <span class="math">i^{</em>}</span> on each node of the Merkle Tree. Since the fully homomorphic encryption ciphertext is computationally indistinguishable with uniformly random string, we can use uniformly random string in the “normal mode”. The local opening follows from the Merkle Tree structure.</p>

    <p class="text-gray-300">The extraction property is implicitly satisfied by the construction. Specifically, the trapdoor corresponds to the secret key of the fully homomorphic encryption. Given the secret key, we can decrypt the root node to extract <span class="math">m_{i^{*}}</span>. ∎</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">3.6 No-Signaling Somewhere Extractable Commitments</h3>

    <p class="text-gray-300">We consider here a slight variant of no-signaling somewhere extractable (NS-SE) commitments introduced in the work of <em>[x10]</em>. The no-signaling property, as described in the technical overview is imposed on the extractor of the SE commitment scheme. Intuitively, an extractor for an SE scheme is said to be <em>computationally no-signaling</em> if for any sets <span class="math">S^{\\prime}\\subseteq S</span>, where <span class="math">S</span> is of size at most <span class="math">L</span>, the extracted values corresponding to the indices in <span class="math">S^{\\prime}</span> have computationally indistinguishable marginal distributions whether extracted on set <span class="math">S</span> or <span class="math">S^{\\prime}</span>.</p>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 6. The extractor of an SECOM commitment scheme (Gen, TGen, Com, Open, Verify, Ext) is no-signaling if for any  <span class="math">S&#x27; \\subseteq S \\subseteq [N]</span> , where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq L<span class="math"> , and any PPT adversary  </span>\\mathcal{D} = (\\mathcal{D}_1, \\mathcal{D}_2)<span class="math">  there exists a negligible function  </span>\\mathrm{negl}(\\cdot)<span class="math">  such that for every  </span>\\lambda \\in \\mathbb{N}$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l l} \\mathcal {D} _ {2} (K ^ {<em>}, c, \\vec {y}, z) &amp; (K ^ {</em>}, \\mathrm {t d}) \\leftarrow \\mathrm {T G e n} (1 ^ {\\lambda}, 1 ^ {N}, S ^ {\\prime}) \\\\ &amp; (c, z) \\leftarrow \\mathcal {D} _ {1} (K ^ {<em>}) \\\\ &amp; \\vec {y} := \\operatorname {E x t} (c, \\mathrm {t d}) \\end{array} \\right] \\right. \\\\ - \\Pr \\left[ \\begin{array}{l l} \\mathcal {D} _ {2} (K ^ {</em>}, c, \\vec {y} _ {S ^ {\\prime}}, z) &amp; (K ^ {<em>}, \\mathrm {t d}) \\leftarrow \\mathrm {T G e n} (1 ^ {\\lambda}, 1 ^ {N}, S) \\\\ &amp; (c, z) \\leftarrow \\mathcal {D} _ {1} (K ^ {</em>}) \\\\ &amp; \\vec {y} := \\operatorname {E x t} (c, \\mathrm {t d}) \\end{array} \\right] \\right] \\leq \\operatorname {n e g l} (\\lambda) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We will refer to SECOM schemes satisfying the above definition to be an  <span class="math">L</span> -no-signaling NS-SECOM commitment.</p>

    <p class="text-gray-300">Theorem 5 ([GZ21]). Given  <span class="math">L</span>  instances of an SECOM commitment scheme (Gen, TGen, Com, Open, Verify, Ext) with locality parameter 1, one can construct an  <span class="math">L</span> -no-signaling NS-SECOM.</p>

    <p class="text-gray-300"><strong>Construction sketch.</strong> We sketch the construction from [GZ21] here, and defer details to Appendix A. For simplicity we consider here the case that  <span class="math">S \\coloneqq \\{s_1, \\dots, s_L\\}</span>  has size exactly  <span class="math">L</span> . The rough idea is to generate  <span class="math">L</span>  different commitment keys  <span class="math">K&#x27; = (K_1, \\dots, K_L)</span>  such that to commit to a vector  <span class="math">\\vec{m}</span> , one produces  <span class="math">L</span>  commitments  <span class="math">\\operatorname{Com}(K_i, \\vec{m})</span>  (with different randomness for each  <span class="math">i</span> ). For the trapdoor key generation algorithm,  <span class="math">K&#x27;^<em> = (K_1^</em>, \\dots, K_L^<em>)</span> , where each  <span class="math">K_i^</em></span>  is generated for the single element set  <span class="math">\\{s_i\\}</span> . Therefore the size of the keys and commitment in the  <span class="math">L</span> -no-signaling NS-SECOM are larger by a multiplicative factor of  <span class="math">L</span> .</p>

    <p class="text-gray-300">For a full construction and proof of required properties, see Appendix A.</p>

    <p class="text-gray-300">Preservation of succinct local opening. In our work, we will require local opening of the  <span class="math">L</span> -no-signaling NS-SECOM to be succinct. From the above construction it is clear that if the underlying SECOM has a succinct local opening, then the size of the succinct opening of the  <span class="math">L</span> -no-signaling NS-SECOM is larger by a multiplicative factor of  <span class="math">L</span>  - one simply provides succinct local openings to each of the  <span class="math">L</span>  underlying SECOMs.</p>

    <p class="text-gray-300">This section is organized as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In section 4.1, we define non-interactive batch arguments (BARGs) for the circuit satisfiability language SAT.</li>

      <li>Next, in section 4.2, we define and construct PCP with fast online verification which will be necessary for our construction of BARGs.</li>

      <li>In Section 4.3, we define BARGs for index languages. We then construct them generically from PCP with fast online verification, and somewhere extractable commitments.</li>

      <li>Finally, in section 4.4, we construct BARGs for circuit satisfiability SAT generically from BARGs for the index languages, and somewhere extractable commitments.</li>

    </ul>

    <p class="text-gray-300">4.1 Definition</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Circuit Satisfiability Language.</h4>

    <p class="text-gray-300">Let <span class="math">\\mathsf{SAT}</span> be the following language</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SAT}=\\{(C,x)\\mid\\exists\\ w\\ \\text{s.t.}\\ C(x,w)=1\\},</span></p>

    <p class="text-gray-300">where <span class="math">C:\\{0,1\\}^{n}\\times\\{0,1\\}^{m}\\to\\{0,1\\}</span> is a Boolean function, and <span class="math">x\\in\\{0,1\\}^{n}</span> is an instance.</p>

    <p class="text-gray-300">A non-interactive batch argument for <span class="math">\\mathsf{SAT}</span> is a protocol between a prover and a verifier. The prover and the verifier first agree on a circuit <span class="math">C</span>, and a series of <span class="math">T</span> instances <span class="math">x_{1},x_{2},\\ldots,x_{T}</span>. Then the prover sends a single message to the verifier and tries to convince the verifier that <span class="math">(C,x_{1}),(C,x_{2}),\\ldots,(C,x_{T})\\in\\mathsf{SAT}</span>.</p>

    <p class="text-gray-300">More formally, such a protocol is specified by a tuple of algorithms <span class="math">(\\mathsf{Gen},\\mathsf{TGen},\\mathsf{P},\\mathsf{V})</span> that work as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathsf{Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}):<span class="math"> On input a security parameter </span>\\lambda<span class="math">, the number of instances </span>T<span class="math">, and the size of the circuit </span>C$, the CRS generation algorithm outputs crs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}(\\text{crs},C,x_{1},x_{2},\\ldots,x_{T},\\omega_{1},\\omega_{2},\\ldots,\\omega_{T}):</span> On input crs, a circuit <span class="math">C</span>, and <span class="math">T</span> instances <span class="math">x_{1},x_{2},\\ldots,x_{T}</span> and their corresponding witnesses <span class="math">\\omega_{1},\\omega_{2},\\ldots,\\omega_{T}</span>, the prover algorithm outputs a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{V}(\\text{crs},C,x_{1},x_{2},\\ldots,x_{T},\\pi):</span> On input crs, a circuit <span class="math">C</span>, a series of instances <span class="math">x_{1},x_{2},\\ldots,x_{T}</span>, and a proof <span class="math">\\pi</span>, the verifier algorithm decides to accept (output 1) or reject (output 0).</li>

    </ul>

    <p class="text-gray-300">Furthermore, we require the aforementioned algorithms to satisfy the following properties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct Communication. The size of <span class="math">\\pi</span> is bounded by $\\text{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Succinct Verification. The verification algorithm runs in time $\\text{poly}(\\lambda,T,n)+\\text{poly}(\\lambda,\\log T,</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)$. Moreover, it can be split into the following two parts:</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Pre-processing: There exists a deterministic algorithm <span class="math">\\mathsf{PreVerify}(\\text{crs},x_{1},x_{2},\\ldots,x_{T})</span> that takes as input the CRS, and <span class="math">T</span> instances <span class="math">x_{1},x_{2},\\ldots,x_{T}</span>, and outputs a short sketch <span class="math">c</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS Indistinguishability. For any non-uniform PPT adversary <span class="math">\\mathcal{A}</span>, and any polynomial <span class="math">T=T(\\lambda)</span>, there exists a negligible function <span class="math">\\nu(\\lambda)</span> such that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[i^{*}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{T}),\\text{crs}\\leftarrow\\mathsf{Gen}(1^{\\lambda},1^{T}):\\mathcal{A}(\\text{crs})=1\\right]-\\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any circuit <span class="math">C</span>, any <span class="math">T</span> instances <span class="math">x_{1},\\ldots,x_{T}</span> such that <span class="math">(C,x_{1}),(C,x_{2}),\\ldots,(C,x_{T})\\in</span> SAT and witnesses <span class="math">\\omega_{1},\\omega_{2},\\ldots,\\omega_{T}</span> for <span class="math">(C,x_{1}),(C,x_{2}),\\ldots,(C,x_{T})</span>, we have</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\operatorname{crs}\\leftarrow\\operatorname{Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}),\\pi\\leftarrow\\mathsf{P}(\\operatorname{crs},C,x_{1},x_{2},\\ldots,x_{T},\\omega_{1},\\omega_{2},\\ldots,\\omega_{T}):\\mathsf{V}(\\operatorname{crs},C,x_{1},x_{2},\\ldots,x_{T},\\pi)=1\\right]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Semi-Adaptive Somewhere Soundness. For any non-uniform PPT adversary <span class="math">\\mathcal{A}</span>, and any polynomial <span class="math">T=T(\\lambda)</span>, there exists a negligible function <span class="math">\\nu(\\lambda)</span> such that <span class="math">\\operatorname{Adv}^{\\text{sound}}_{\\mathcal{A}}(\\lambda)\\leq\\nu(\\lambda)</span>, where <span class="math">\\operatorname{Adv}^{\\text{sound}}_{\\mathcal{A}}(\\lambda)</span> is defined as</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[i^{<em>}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{T}),\\operatorname{crs}^{</em>}\\leftarrow\\mathsf{T}\\operatorname{Gen}(1^{\\lambda},1^{T},i^{<em>}),(C,x_{1},x_{2},\\ldots,x_{T},\\Pi)\\leftarrow\\mathcal{A}(\\operatorname{crs}^{</em>}):\\right.</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad i^{<em>}\\in[T]\\wedge(C,x_{i^{</em>}})\\notin\\operatorname{SAT}\\wedge\\mathsf{V}(\\operatorname{crs},C,x_{1},x_{2},\\ldots,x_{T},\\Pi)=1\\bigg{]}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Somewhere Argument of Knowledge. There exists a PPT extractor <span class="math">E</span> such that, for any non-uniform PPT adversary <span class="math">\\mathcal{A}</span>, and any polynomial <span class="math">T=T(\\lambda)</span>, there exists a negligible function <span class="math">\\nu(\\lambda)</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[i^{<em>}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{T}),\\operatorname{crs}^{</em>}\\leftarrow E(1^{\\lambda},1^{T},i^{<em>}),(C,x_{1},x_{2},\\ldots,x_{T},\\Pi)\\leftarrow\\mathcal{A}(\\operatorname{crs}^{</em>}),\\right.</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad(0,\\lambda,1^{T}),</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad(0,\\lambda,1^{T}),</span></p>

    <p class="text-gray-300">Moreover, the CRS generated by the extractor <span class="math">\\operatorname{crs}^{<em>}\\leftarrow E(1^{\\lambda},1^{T},i^{</em>})</span> and the CRS in real execution <span class="math">\\operatorname{crs}\\leftarrow\\operatorname{Gen}(1^{\\lambda},1^{T})</span> are computationally indistinguishable.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">4.2 PCP with Fast Online Verification</h3>

    <p class="text-gray-300">In this subsection, we define PCPs with a <em>fast online verification property</em>. At a high level, such a property requires that for any PCP for the circuit satisfiability language</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C}\\text{-}\\mathsf{SAT}=\\{x\\mid\\exists w:C(x,w)=1\\},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the verification algorithm can be split into two parts: (i) a query algorithm <span class="math">\\mathsf{Q}</span> which generates the PCP queries that depend on <span class="math">C</span> but are independent of <span class="math">x</span>; and (ii) an online verification algorithm <span class="math">\\mathsf{D}</span>, which depends on <span class="math">x</span> but its running time grows only <em>polylogarithmically</em> in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and polynomially in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Previously, such a property is implicit in the construction of the linear PCPs in <em>[BCI^{+}13]</em>. In this work, we focus on the original definition of PCPs (as opposed to linear PCPs).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More formally, for any Boolean circuit $C:\\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\times\\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\to\\{0,1\\}<span class="math">, a PCP with fast online verification for </span>\\mathsf{C}\\text{-}\\mathsf{SAT}<span class="math"> is a tuple of polynomial-time algorithms </span>(\\mathsf{P},\\mathsf{Q},\\mathsf{D})$, with the following syntax.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}(1^{\\lambda},C,x,\\omega):</span> The prover algorithm takes as input a security parameter <span class="math">\\lambda</span>, the circuit <span class="math">C</span>, an instance <span class="math">x</span> and its witness <span class="math">\\omega</span>, and outputs a PCP proof <span class="math">\\pi\\in\\{0,1\\}^{*}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{Q}(1^{\\lambda},C,r):</span> On input the security parameter <span class="math">\\lambda</span>, the circuit <span class="math">C</span>, and the random coin <span class="math">r</span>, the query algorithm generates a subset $Q\\subseteq[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$, and a state</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathrm{D}(x,\\mathrm{st},\\pi^{\\prime}):\\mathrm{On}</span> input an instance <span class="math">x</span>, a state <span class="math">\\mathrm{st}</span>, and a binary string $\\pi^{\\prime}\\in\\{0,1\\}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, the online verification algorithm </span>\\mathrm{D}$ <em>deterministically</em> decides to accept (output 1) or reject (output 0).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Furthermore, we require the following properties of the PCP.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any circuit <span class="math">C</span>, any instance <span class="math">x\\in\\mathrm{C-SAT}</span>, and any witness <span class="math">\\omega</span> for <span class="math">x</span>, we have</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r}\\left[\\pi\\leftarrow\\mathrm{P}(1^{\\lambda},C,x,\\omega),(Q,\\mathrm{st})\\leftarrow\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{D}(x,\\mathrm{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1\\right]=1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho(\\lambda)</span>-Soundness. For any circuit <span class="math">C</span>, and any <span class="math">x\\notin\\mathrm{C-SAT}</span>, and any string <span class="math">\\pi^{<em>}\\in\\{0,1\\}^{</em>}</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r}\\left[(Q,\\mathrm{st})\\leftarrow\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{D}(x,\\mathrm{st},\\pi^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1\\right]\\leq\\rho(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Small Query Complexity. The size of the set <span class="math">Q</span> is bounded by $\\mathrm{poly}(\\lambda,\\log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Succinct Verification. The state <span class="math">\\mathrm{st}</span> can be represented in $\\mathrm{poly}(\\lambda,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">,\\log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math"> bits, and the online verification algorithm runs in time </span>\\mathrm{poly}(\\lambda,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">,\\log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math">. The query algorithm </span>\\mathrm{Q}<span class="math"> runs in time </span>\\mathrm{poly}(\\lambda,</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">\\rho</span>-Proof of Knowledge. For any PCP proof <span class="math">\\pi^{<em>}</span>, there exists a deterministic polynomial time extractor <span class="math">E</span> such that, if $\\Pr_{r}[(Q,\\mathrm{st})\\leftarrow\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{D}(x,\\mathrm{st},\\pi^{</em>}</td>

            <td class="px-3 py-2 border-b border-gray-700">_{Q})=1]>\\rho(\\lambda)<span class="math">, then </span>\\Pr[\\omega\\leftarrow E(\\pi^{*}):C(x,\\omega)=1]=1$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a PCP with fast online verification for the <span class="math">\\mathrm{C-SAT}</span> language with <span class="math">\\rho</span>-soundness, and <span class="math">\\rho</span>-proof of knowledge property, where $\\rho=1-1/\\mathrm{poly}\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-60" class="text-base font-medium mt-4">Proof Sketch.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that the PCP in <em>[x1]</em>, and the probabilistic checkable interactive proofs in <em>[x23]</em>, can be modified to obtain a PCP with fast online verification. For any circuit <span class="math">C</span>, by the Cook-Levin Theorem, there exists a <span class="math">3</span>-CNF <span class="math">\\phi</span> such that for any <span class="math">x</span>, <span class="math">\\phi(x,\\cdot)</span> is satisfiable if and only if <span class="math">x\\in\\mathrm{C-SAT}</span>. Furthermore, for any witness <span class="math">\\omega</span> of <span class="math">x\\in\\mathrm{C-SAT}</span>, we can derive a witness <span class="math">y</span> for <span class="math">\\phi(x,\\cdot)</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Parameters and Ingredients.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{H}</span> be a field of size $\\mathrm{polylog}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and let </span>\\mathbb{F}<span class="math"> be a large enough extension field of </span>\\mathbb{H}<span class="math"> with size </span>\\mathrm{poly}\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>m_{x}=\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>m_{y}=\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>m^{\\prime}=\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and </span>n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">I:\\mathbb{H}^{m^{\\prime}}\\rightarrow\\{0,1\\},K:\\mathbb{H}^{m^{\\prime}}\\rightarrow\\mathbb{H}^{\\max(m_{x},m_{y})}</span> be the following polynomials.</p>

    <p class="text-gray-300">\\[ I(i)=\\begin{cases}1&i\\leq n,\\\\ 0&\\text{Otherwise.}\\end{cases}\\quad K(i)=\\begin{cases}i&i\\leq n,\\\\ i-n&\\text{Otherwise.}\\end{cases} \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we identify the index set $[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> with </span>\\mathbb{H}^{m}<span class="math">. Let </span>\\widetilde{I},\\widetilde{K}<span class="math"> be the extension of </span>I,K<span class="math"> to </span>\\mathbb{F}<span class="math">, respectively. Then </span>\\widetilde{I}<span class="math"> and </span>\\widetilde{K}<span class="math"> has degree at most </span>\\mathrm{poly}(m^{\\prime})<span class="math">. Let </span>\\widetilde{x}=\\mathsf{LDE}(x),\\widetilde{y}=\\mathsf{LDE}(y)<span class="math"> be the low-degree extension of </span>x,y<span class="math"> over </span>\\mathbb{F}$, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\widetilde{P}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})</span> be the following polynomial.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{P}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})=\\prod_{j\\in\\{1,2,3\\}}\\left(\\widetilde{I}(i_{j})\\cdot\\widetilde{x}(\\widetilde{K}(i_{j}))+(1-\\widetilde{I}(i_{j}))\\cdot\\widetilde{y}(\\widetilde{K}(i_{j}))-b_{j}\\right)</span> (1)</p>

    <p class="text-gray-300">Let <span class="math">C^{\\prime}:\\mathbb{H}^{3m^{\\prime}+3}\\rightarrow\\{0,1\\}</span> be a circuit such that <span class="math">C^{\\prime}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})=1</span> if and only if <span class="math">b_{1},b_{2},b_{3}\\in\\{0,1\\}</span> and <span class="math">(x_{i_{1}}=b_{1})\\vee(x_{i_{2}}=b_{2})\\vee(x_{i_{3}}=b_{3})</span> is a clause in the <span class="math">3</span>-CNF <span class="math">\\phi</span>, and let <span class="math">\\widetilde{C}:\\mathbb{F}^{3m^{\\prime}+3}\\rightarrow\\mathbb{F}</span> be the extension of <span class="math">C^{\\prime}</span> to <span class="math">\\mathbb{F}</span>. Then we have that <span class="math">\\phi(x,\\cdot)</span> is satisfiable, if and only if there exists a <span class="math">\\widetilde{y}</span> such that the following polynomial <span class="math">F(z)</span> of <span class="math">3m^{\\prime}+3</span> variables is a zero polynomial:</p>

    <p class="text-gray-300"><span class="math">F(z)=\\sum_{i_{1},i_{2},i_{3}\\in\\mathbb{H}^{m^{\\prime}},b_{1},b_{2},b_{3}\\in\\{0,1\\}}\\widetilde{C}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})\\cdot\\widetilde{P}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})\\cdot\\widetilde{\\mathsf{Eq}}_{i_{1},i_{2},i_{3},b_{1},b_{2},b_{3}}(z)</span></p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Construction Sketch.</h4>

    <p class="text-gray-300">The PCP construction is the unrolling of the following interactive protocol consisting of two parts.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Low-Degree Testing: The prover sends <span class="math">\\widetilde{y}=\\mathsf{LDE}(y)</span>. The verifier performs a low-degree test on <span class="math">\\widetilde{y}</span>.</li>

      <li>Sumcheck: Then the verifier sends a random <span class="math">z^{<em>}\\in\\mathbb{F}^{3m^{\\prime}+3}</span>. The prover and the verifier then execute a sumcheck protocol to prove <span class="math">F(z^{</em>})=0</span>. Let</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\widetilde{\\phi}_{z^{<em>}}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})=\\mathsf{LDE}(\\{\\widetilde{\\mathsf{Eq}}_{i_{1},i_{2},i_{3},b_{1},b_{2},b_{3}}(z^{</em>})\\}_{i_{1},i_{2},i_{3}\\in\\mathbb{H}^{m^{\\prime}},b_{1},b_{2},b_{3}\\in\\{0,1\\}})</span></p>

    <p class="text-gray-300">be the low-degree extension of the linear coefficients <span class="math">\\widetilde{\\mathsf{Eq}}_{i_{1},i_{2},i_{3},b_{1},b_{2},b_{3}}(z^{*})</span>. Then the prover and the verifier run the sumcheck protocol for the sum</p>

    <p class="text-gray-300"><span class="math">\\sum_{i_{1},i_{2},i_{3}\\in\\mathbb{H}^{m^{\\prime}},b_{1},b_{2},b_{3}\\in\\{0,1\\}}\\widetilde{C}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})\\cdot\\widetilde{P}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})\\cdot\\widetilde{\\phi}_{z^{*}}(i_{1},i_{2},i_{3},b_{1},b_{2},b_{3})=0.</span></p>

    <p class="text-gray-300">At the end of the sumcheck protocol, the verifier obtains a random point <span class="math">(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})\\in\\mathbb{F}^{3m^{\\prime}+3}</span> (corresponding to its messages in the protocol) and a value <span class="math">v\\in\\mathbb{F}</span>. The verifier then checks whether</p>

    <p class="text-gray-300"><span class="math">\\widetilde{C}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},i_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})\\cdot\\widetilde{P}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})\\cdot\\widetilde{\\phi}_{z^{<em>}}(i_{1}^{</em>},i_{2}^{<em>},i_{3}^{</em>},b_{1}^{<em>},b_{2}^{</em>},b_{3}^{*})=v.</span> (2)</p>

    <p class="text-gray-300">We now describe how to fit this PCP construction into our definition of PCP with fast online verification.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PCP.<span class="math">\\mathsf{Q}(1^{\\lambda},C,r)</span>: We now show that the PCP queries can be generated independently of <span class="math">x</span>. The PCP query consists of the queries in (i) the low-degree testing of <span class="math">\\widetilde{y}</span>; and (ii) the sumcheck. The low-degree testing queries only query some values of <span class="math">\\widetilde{y}</span>. Hence, these queries are generated independently of <span class="math">x</span>. The sumcheck protocol is public-coin. Therefore, the queries in sumcheck can also be generated independent of <span class="math">x</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In addition, for the sumcheck, we do the following “preprocessing” to save time in online verification. For <span class="math">\\widetilde{C}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})</span>, we evaluate it directly, and store the resultant value in the state st. Furthermore, to help the online verification algorithm (described below) compute <span class="math">\\widetilde{P}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})</span> in time only polylogarithmic in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we compute </span>\\widetilde{K}(i_{j}^{<em>}),\\widetilde{I}(i_{j}^{</em>})<span class="math"> and </span>\\{\\widetilde{\\mathsf{Eq}}_{i_{1},i_{2},\\ldots,i_{m_{x}}}(\\widetilde{K}(i_{j}^{<em>}))\\}_{i_{1},i_{2},\\ldots,i_{m_{x}}\\in\\mathbb{H}}<span class="math"> for </span>j\\in\\{1,2,3\\}<span class="math"> in time </span>\\mathrm{poly}(C)<span class="math">, and also store the resultant values in the state st. Finally, we compute and store </span>\\widetilde{\\phi}_{z^{</em>}}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})$ in st.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since there are <span class="math">O(n)</span> number of field elements in the state st, the size of st is bounded by $\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the low-degree testing, the verifier performs the same verification procedure as the underlying low-degree testing. This takes time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the sumcheck, the verifier performs the same checks as in the underlying sumcheck protocol. At the end, the verifier uses the “preprocessed” values of <span class="math">\\widetilde{C}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})</span> present in the state st. To compute <span class="math">\\widetilde{P}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>}.b_{3}^{</em>})</span>, the verifier will obtain each term in Equation 1. For <span class="math">\\widetilde{K}(i_{j}^{<em>}),\\widetilde{I}(i_{j}^{</em>})</span>, the verifier can obtain them from the state st. For <span class="math">\\widetilde{y}(\\widetilde{K}(i_{j}^{<em>}))</span>, the verifier obtains it from the PCP response <span class="math">\\pi^{\\prime}</span>. For <span class="math">\\widetilde{x}(\\widetilde{K}(i_{j}^{</em>}))</span>, the verifier computes it by the definition of low-degree extension (see Section 3.2) using <span class="math">\\{\\widetilde{\\mathsf{Eq}}_{i_{1},i_{2},\\ldots,i_{m_{x}}}(\\widetilde{K}(i_{j}^{<em>}))\\}_{i_{1},i_{2},\\ldots,i_{m_{x}}}</span> in the state st. Now the verifier obtains all terms in Equation 1, and hence can compute <span class="math">\\widetilde{P}(i_{1}^{</em>},i_{2}^{<em>},i_{3}^{</em>},b_{1}^{<em>},b_{2}^{</em>},b_{3}^{<em>})</span>. Finally, the verifier obtains <span class="math">\\widetilde{\\phi}_{z^{</em>}}(i_{1}^{<em>},i_{2}^{</em>},i_{3}^{<em>},b_{1}^{</em>},b_{2}^{<em>},b_{3}^{</em>})</span> from the state st, and verifies Equation 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the running time, the computation of the low-degree extension <span class="math">\\widetilde{x}(\\widetilde{K}(i_{j}^{*}))</span> takes time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">. Hence, the online verification takes time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ in total.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the above running time analysis, the succinct verification property is satisfied. The small query complexity follows from the small query complexity of the low-degree testing and the sumcheck protocol. Since the sumcheck has <span class="math">O(m^{\\prime})</span>-rounds, and the prover sends <span class="math">O(1)</span> elements in <span class="math">\\mathbb{F}</span> in each round, the unrolled proof has size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{O(m^{\\prime})}=\\operatorname{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Hence, polynomial proof size property follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The completeness and soundness follows from the completeness and soundness of the zero-testing and the sumcheck protocol. The proof of knowledge property follows from the decoding of <span class="math">\\widetilde{y}</span>. ∎</p>

    <p class="text-gray-300">Next, we define the bad relation for any PCP with fast online verification with an eye towards our BARG construction we describe next. As described in the overview in section 2, we commit several PCP proofs “columnwise” using a somewhere extractable commitmentand apply a CIH to these commitments to obtain the query PCP <span class="math">Q</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the soundness proof, we first switch the commitment key to the trapdoor mode. The bad relation is defined with respect to the trapdoor <span class="math">\\operatorname{td}</span> of the commitment. Specifically, we can use <span class="math">\\operatorname{td}</span> to extract a PCP proof <span class="math">\\pi</span> from the commitment. Now given the extracted proof <span class="math">\\pi</span>, we define a query <span class="math">Q</span> to be bad, when $\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q}<span class="math"> is accepting but we cannot extract a witness from </span>\\pi<span class="math">. However, the verification algorithm not only needs </span>Q<span class="math">, but also the state </span>\\operatorname{st}<span class="math">. To resolve this issue, in the following definition, we have the CIH output the randomness </span>r<span class="math">. We then use this randomness to generate </span>Q<span class="math"> and </span>\\operatorname{st}$ via PCP.Q.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-63" class="text-base font-medium mt-4">Definition 7 (Bad relation for PCP).</h6>

    <p class="text-gray-300">Let <span class="math">\\operatorname{SECOM}=(\\operatorname{SECOM.Gen},\\operatorname{SECOM.TGen},\\operatorname{SECOM.Com},\\operatorname{SECOM.Open},\\operatorname{SECOM.Verify},\\operatorname{SECOM.Ext})</span> be a somewhere extractable commitment scheme, and <span class="math">\\operatorname{PCP}=(\\operatorname{P},\\operatorname{Q},\\operatorname{D})</span> be any PCP with fast online verification, we define the bad relation <span class="math">\\mathcal{R}=\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda}</span> for <span class="math">\\operatorname{PCP}</span> as follows.</p>

    <p class="text-gray-300">For any instance length <span class="math">n=n(\\lambda)</span>, witness length <span class="math">m=m(\\lambda)</span>, proof length <span class="math">\\ell=\\ell(\\lambda)</span>, and a parameter <span class="math">T=T(\\lambda)</span>, we define the bad relation for <span class="math">\\operatorname{PCP}</span> as <span class="math">\\mathcal{R}_{\\lambda}=\\{R_{\\lambda,x,\\operatorname{td}}\\}</span>, where <span class="math">\\operatorname{td}</span> is obtained from <span class="math">(K^{<em>},\\operatorname{td})\\leftarrow\\operatorname{SECOM.TGen}(1^{\\lambda},1^{T},i^{</em>})</span> for a index <span class="math">i^{*}\\in[T]</span>, and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$R_{\\lambda,x,\\operatorname{td}}=\\{((C,c),r)\\mid C(x,E(\\pi))\\neq 1\\wedge\\operatorname{D}(x,\\operatorname{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1\\},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">(Q,\\operatorname{st})=\\operatorname{Q}(1^{\\lambda},C,r)</span>, <span class="math">c=\\{c_{q}\\}_{q\\in[\\ell]}</span>, <span class="math">\\pi=\\{\\operatorname{SECOM.Ext}(c_{q},\\operatorname{td})\\}_{q\\in[\\ell]}</span>, <span class="math">C:\\{0,1\\}^{n}\\times\\{0,1\\}^{m}\\rightarrow\\{0,1\\}</span> is a Boolean circuit, and <span class="math">x</span> is a string of length <span class="math">n</span>, and <span class="math">E</span> is the proof of knowledge extractor.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 6 (CIH for PCP).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a PCP with fast online verification <span class="math">(\\operatorname{P},\\operatorname{Q},\\operatorname{D})</span> and a hash family <span class="math">\\mathcal{H}</span> such that, <span class="math">\\mathcal{H}</span> is correlation intractable for its bad relation family <span class="math">\\mathcal{R}=\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda}</span> (in Definition 7). Furthermore, <span class="math">\\mathcal{H}</span> can be evaluated in time $\\operatorname{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Intuitively, we will take the PCP in Lemma 1, and repeat its verification several times in parallel (with independent randomness), and apply Theorem 3 to the resulting PCP.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\operatorname{PCP}^{\\prime}=(\\operatorname{PCP}^{\\prime}.\\operatorname{P},\\operatorname{PCP}^{\\prime}.\\operatorname{Q},\\operatorname{PCP}^{\\prime}.\\operatorname{D})</span> be the <span class="math">(1-\\epsilon)</span>-sound PCP with fast online verification from Lemma 1, where $\\epsilon=1/\\operatorname{poly}\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We build a new </span>\\operatorname{PCP}=(\\operatorname{P},\\operatorname{Q},\\operatorname{D})$ as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{P}</span> is the same as <span class="math">\\operatorname{PCP}^{\\prime}.\\operatorname{P}</span>.</li>

      <li><span class="math">\\operatorname{Q}(1^{\\lambda},C,r)</span>: <span class="math">\\operatorname{Parse}\\&gt;r=(r_{1},r_{2},\\ldots,r_{t})</span>, where <span class="math">t=\\lambda/\\epsilon</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[t]</span>, let <span class="math">(Q_{i},\\operatorname{st}_{i})=\\operatorname{PCP}^{\\prime}.\\operatorname{Q}(1^{\\lambda},C,r_{i})</span>.</li>

      <li>Output <span class="math">Q=(Q_{1},Q_{2},\\ldots,Q_{t})</span>, <span class="math">\\operatorname{st}=(\\operatorname{st}_{1},\\operatorname{st}_{2},\\ldots,\\operatorname{st}_{t})</span>.</li>

      <li><span class="math">\\operatorname{D}(x,\\operatorname{st},\\pi^{\\prime})</span> <span class="math">\\operatorname{Parse}\\&gt;\\pi^{\\prime}=(\\pi^{\\prime}_{1},\\pi^{\\prime}_{2},\\ldots,\\pi^{\\prime}_{t})</span>, and <span class="math">\\operatorname{st}=(\\operatorname{st}_{1},\\operatorname{st}_{2},\\ldots,\\operatorname{st}_{t})</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[t]</span>, verify if <span class="math">\\operatorname{PCP}^{\\prime}.\\operatorname{D}(x,\\operatorname{st}_{i},\\pi^{\\prime}_{i})=1</span>.</li>

      <li>If all verification passes, then output <span class="math">1</span> (accept). Otherwise output <span class="math">0</span> (reject).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof of knowledge Extractor E: We use the proof of knowledge extractor of <span class="math">\\mathrm{PCP^{\\prime}}</span> as the extractor for PCP.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The resultant PCP satisfies <span class="math">\\rho=(1-\\epsilon)^{t}=2^{-\\Omega(\\lambda)}</span>-soundness and <span class="math">\\rho</span>-proof of knowledge property. By construction, for each security parameter <span class="math">\\lambda</span>, instance <span class="math">x</span>, and trapdoor <span class="math">\\mathrm{td}</span>, <span class="math">R_{\\lambda,x,\\mathrm{td}}</span> is a product relation, since the bad relation for PCP is the product of the bad relations for <span class="math">\\mathrm{PCP^{\\prime}}</span>. The bad relation for <span class="math">\\mathrm{PCP^{\\prime}}</span> is efficiently verifiable in time $\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To demonstrate sparsity, for any instance <span class="math">x</span> and extracted PCP proof <span class="math">\\pi</span>, if <span class="math">C(x,E(\\pi))\\neq 1</span>, then $\\Pr_{r}[(Q,\\mathrm{st})\\leftarrow\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{D}(x,\\mathrm{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1]\\leq\\rho<span class="math">, otherwise this contradicts the </span>\\rho$-soundness of PCP. Since our construction is a parallel repetition,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r}[(Q,\\mathrm{st})\\leftarrow\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{D}(x,\\mathrm{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1]=\\Pr_{r}[(Q,\\mathrm{st})\\leftarrow\\mathrm{PCP^{\\prime}}.\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{PCP^{\\prime}}.\\mathrm{D}(x,\\mathrm{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1]^{t}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, if the left hand is bounded by <span class="math">\\rho</span>, then we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r}[(Q,\\mathrm{st})\\leftarrow\\mathrm{PCP^{\\prime}}.\\mathrm{Q}(1^{\\lambda},C,r):\\mathrm{PCP^{\\prime}}.\\mathrm{D}(x,\\mathrm{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1]\\leq 1-\\epsilon.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, the relation <span class="math">R_{\\lambda,\\mathrm{td}}</span> has sparsity <span class="math">(1-\\epsilon)</span>. Therefore, by Theorem 3, there exists a correlation intractable hash family <span class="math">\\mathcal{H}</span> for <span class="math">\\mathcal{R}</span>. ∎</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">4.3 BARGs for Index Languages</h3>

    <h5 id="sec-67" class="text-base font-semibold mt-4">Index Language.</h5>

    <p class="text-gray-300">Let the index language be the following language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}^{\\mathrm{idx}}=\\{(C,i)\\mid\\exists\\ w\\ \\mathrm{s.t.}\\ C(i,w)=1\\},</span></p>

    <p class="text-gray-300">where <span class="math">C</span> is a Boolean function, and <span class="math">i</span> is an index.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Non-interactive batch arguments for the index language is a special case of BARGs for general circuit satisfiability when the instances <span class="math">x_{1},x_{2},\\ldots,x_{T}</span> are simply the indices <span class="math">1,2,\\ldots,T</span>. We therefore omit <span class="math">x_{1},x_{2},\\ldots,x_{T}</span> as inputs to the prover and the verifier algorithms <span class="math">\\mathrm{BARG.P},\\mathrm{BARG.V}</span> (and also as an output of the adversary <span class="math">\\mathcal{A}</span> describing the semi-adaptive somewhere soundness property). Furthermore, since the verifier does not need to read the instances, there is no pre-processing in this case, and the succinct verification property requires the verifier to run in time $\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this subsection, we mainly prove the following theorem.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Theorem 7 (BARGs for Index Language).</h6>

    <p class="text-gray-300">Assuming LWE, there exist batch arguments for the index language with succinct verification property.</p>

    <p class="text-gray-300">We proceed to describe the construction of the BARGs for the index language.</p>

    <h5 id="sec-69" class="text-base font-semibold mt-4">Ingredients.</h5>

    <p class="text-gray-300">Our construction is recursive. We use an index <span class="math">L</span> to index the level of recursion. Note that we can assume without loss of generality that <span class="math">T</span> is a power of two by padding the last instance <span class="math">(2^{\\lceil\\log_{2}T\\rceil}-T)</span> times. The BARGs at the <span class="math">L</span>-level can handle <span class="math">T=2^{L}</span> instances. To construct <span class="math">\\mathrm{BARG}_{L}=(\\mathrm{Gen},\\mathrm{TGen},\\mathrm{P},\\mathrm{V})</span> at the <span class="math">L</span>-level, we need the following ingredients.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A somewhere extractable commitment (section 3.5) <span class="math">\\mathrm{SECOM}=(\\mathrm{SECOM.Gen},\\mathrm{SECOM.TGen},\\mathrm{SECOM.Com},\\mathrm{SECOM.Open},\\mathrm{SECOM.Verify},\\mathrm{SECOM.Ext})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A PCP with fast online verification scheme <span class="math">\\mathrm{PCP}=(\\mathrm{PCP.P},\\mathrm{PCP.Q},\\mathrm{PCP.D})</span> with proof length $\\ell=\\ell(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ from Theorem 6.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A CIH (definition 2)  <span class="math">\\mathcal{H} = (\\mathcal{H}. \\text{Gen}, \\mathcal{H}. \\text{Hash})</span>  for the bad relation of PCP with fast online verification from Theorem 6.</li>

      <li>A non-interactive batch arguments at the  <span class="math">(L - 1)</span> -level  <span class="math">\\mathrm{BARG}_{L - 1} = (\\mathrm{BARG}_{L - 1}.\\mathrm{Gen},\\mathrm{BARG}_{L - 1}.\\mathrm{TGen},</span> <span class="math">\\mathrm{BARG}_{L - 1}.\\mathrm{P},\\mathrm{BARG}_{L - 1}.\\mathrm{V})</span></li>

    </ul>

    <p class="text-gray-300"><strong>Construction.</strong> We proceed to describe the construction. In the base case  <span class="math">L = 0</span>  and  <span class="math">T = 1</span> , we have the prover send the witness directly to the verifier, and have the verifier verify the witness. When  <span class="math">L \\geq 1</span> , we reduce the batch argument to verify a batch of  <span class="math">T/2</span>  instances, and apply the  <span class="math">(L-1)</span> -level BARG recursively. In more detail, we construct BARG for  <span class="math">L \\geq 1</span>  as follows.</p>

    <p class="text-gray-300">Circuit NewRel  <span class="math">[K,Q,\\{c_q\\}_{q\\in Q,\\mathrm{st}}]</span> <span class="math">(i,(\\vec{\\rho},\\pi^{\\prime},\\vec{\\rho}^{\\prime},\\pi^{\\prime \\prime}))</span></p>

    <p class="text-gray-300">Output Verify  <span class="math">C_{[K,Q,\\{c_q\\}_{q\\in Q,\\mathrm{st}}]}(2i - 1,\\vec{\\rho},\\pi^{\\prime})\\wedge \\mathrm{Verify}C_{[K,Q,\\{c_q\\}_{q\\in Q,\\mathrm{st}}]}(2i,\\vec{\\rho}^{\\prime},\\pi^{\\prime \\prime}).</span></p>

    <p class="text-gray-300">Figure 2: The grouped new circuit, where the ungrouped new circuit VerifyC is depicted in Figure 3.</p>

    <p class="text-gray-300">Circuit Verify  <span class="math">C_{[K,Q,\\{c_q\\}_{q\\in Q,\\mathrm{st}}]}(i,\\vec{\\rho},\\pi^{\\prime})</span></p>

    <p class="text-gray-300">Hardwired: The commitment key  <span class="math">K</span> , the set  <span class="math">Q</span> , the commitments  <span class="math">\\{c_q\\}_{q \\in Q}</span> , and the state st for PCP verification.</p>

    <p class="text-gray-300">Parse the input  <span class="math">\\vec{\\rho} = \\{\\rho_q\\}_{q\\in Q}</span> , and  <span class="math">\\pi^{\\prime} = \\{\\pi_{q}^{\\prime}\\}_{q\\in Q}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">q \\in Q</span> , verify the opening  <span class="math">\\pi_q&#x27;</span>  to the commitment  <span class="math">c_q</span> . Specifically, verify</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\forall q \\in Q, \\text{SECOM.Verify}(K, c_q, \\pi_q&#x27;, i, \\rho_q) = 1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify  <span class="math">\\pi&#x27;</span>  is accepted by the PCP online verification, i.e. verify PCP.D(st,  <span class="math">i, \\pi&#x27;) = 1</span> .</li>

      <li>If all verification passes, then output 1 (accept), otherwise output 0 (reject).</li>

    </ul>

    <p class="text-gray-300">Figure 3: The ungrouped new circuit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\mathrm{Gen}(1^{\\lambda}, 1^{T=2^{L}}, 1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> : The CRS generation algorithm generates a CRS, which contains (i) a somewhere extractable commitment key; (ii) a CRS for the smaller non-interactive batch arguments  </span>\\mathrm{BARG}_{L-1}<span class="math"> ; and (ii) a key for the CIH  </span>\\mathcal{H}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  <span class="math">K \\gets \\mathrm{SECOM}.\\mathrm{Gen}(1^{\\lambda}, 1^{T}, 1^{1})</span> ,  $\\mathrm{crs}' \\gets \\mathrm{BARG}_{L-1}.\\mathrm{Gen}(1^{\\lambda}, 1^{T'}, 1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{NewRel}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> , and  </span>\\mathcal{H}.k \\gets \\mathcal{H}.\\mathrm{Gen}(1^{\\lambda})<span class="math"> , where  </span>T' = T/2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\operatorname{crs} = (K, \\operatorname{crs}&#x27;, \\mathcal{H}.k)</span>  and output  <span class="math">\\operatorname{crs}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\mathrm{TGen}(1^{\\lambda}, 1^{T}, 1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, i^{*})$ : The trapdoor CRS generation algorithm generates the trapdoor CRS as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate  <span class="math">(K^{<em>},\\mathrm{td})\\gets \\mathrm{SECOM.TGen}(1^{\\lambda},1^{T},\\{i^{</em>}\\})</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\operatorname{crs}^{<em>/}\\leftarrow\\text{BARG.TGen}(1^{\\lambda},1^{T^{\\prime}},1^{\\lvert\\text{NewRel}\\rvert},\\lfloor(i^{</em>}+1)/2\\rfloor)</span>, and <span class="math">\\mathcal{H}.k\\leftarrow\\mathcal{H}.\\operatorname{Gen}(1^{\\lambda})</span>.</li>

      <li>Let <span class="math">\\operatorname{crs}^{<em>}=(K^{</em>},\\operatorname{crs}^{<em>/},\\mathcal{H}.k)</span>, and output <span class="math">\\operatorname{crs}^{</em>}</span>.</li>

      <li><span class="math">\\mathsf{P}(\\operatorname{crs},C,\\omega_{1},\\omega_{2},\\ldots,\\omega_{T})</span>: The prover algorithm first commits to all PCP strings in a “columnwise” manner, and then applies the CIH to the commitment.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[T]</span>, compute the PCP proof <span class="math">\\pi_{i}\\leftarrow\\mathsf{PCP.P}(1^{\\lambda},C,i,\\omega_{i})</span> for <span class="math">i</span>-th instance <span class="math">(C,i)</span>.</li>

      <li>Committing the <span class="math">\\pi=\\{\\pi_{i}\\}_{i\\in[T]}</span> “columnwise”,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\forall q\\in[\\ell],c_{q}\\leftarrow\\mathsf{SECOM.Com}(K,\\{\\pi_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{q}\\}_{i\\in[T]};r_{q}),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with uniformly random <span class="math">r_{q}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Applying the CIH to <span class="math">c=\\{c_{q}\\}_{q\\in[\\ell]}</span>, <span class="math">r\\leftarrow\\mathcal{H}.\\operatorname{Hash}(\\mathcal{H}.k,(C,c))</span>, and let <span class="math">(Q,\\mathrm{st})\\leftarrow\\mathsf{PCP.Q}(1^{\\lambda},C,r)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For each <span class="math">i\\in[T]</span>, let <span class="math">\\vec{\\rho}_{i}</span> be the opening of $\\pi_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q}$. Specifically,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\vec{\\rho}_{i}=\\{\\mathsf{SECOM.Open}(K,\\{\\pi_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{q}\\}_{i\\in[T]},i,r_{q})\\}_{q\\in Q}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a smaller BARG proof, let</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pi^{\\prime}\\leftarrow\\text{BARG}^{\\prime}.\\mathsf{P}(\\operatorname{crs}^{\\prime},\\text{NewRel}_{[K,Q,\\{c_{q}\\}_{q\\in Q},\\mathrm{st}]},\\{\\vec{\\rho}_{2i-1},\\pi_{2i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q},\\vec{\\rho}_{2i},\\pi_{2i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q}\\}_{i\\in[T^{\\prime}]}),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\text{NewRel}</span> is depicted in Figure 2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the proof <span class="math">\\Pi=(c,\\Pi^{\\prime})</span>.</li>

      <li><span class="math">\\mathsf{V}(\\operatorname{crs},C,\\Pi)</span>: The verification algorithm parses the proof <span class="math">\\Pi</span> as the commitment and the proof for the smaller BARG, then it utilizes the fast online verification property of the PCP to delegate the online verification to the smaller BARG.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Pi=(c,\\Pi^{\\prime})</span>. Applying CIH to <span class="math">c</span>, let <span class="math">r\\leftarrow\\mathcal{H}.\\operatorname{Hash}(\\mathcal{H}.k,(C,c))</span>.</li>

      <li>Generate the PCP query, <span class="math">(Q,\\mathrm{st})\\leftarrow\\mathsf{PCP.Q}(1^{\\lambda},C,r)</span>.</li>

      <li>Verify the smaller BARG, output <span class="math">\\text{BARG}_{L-1}.\\mathsf{V}(\\operatorname{crs}^{\\prime},\\text{NewRel}_{[K,Q,\\{c_{q}\\}_{q\\in Q},\\mathrm{st}]},\\Pi^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">Before analysing the efficiency, we first bound the size of the circuit <span class="math">\\text{NewRel}_{[K,Q,\\{c_{q}\\}_{q\\in Q},\\mathrm{st}]}.</span></p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">In the construction of <span class="math">\\text{NewRel}</span> in Figure 2, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}_{[K,Q,\\{c_{q}\\}_{q\\in Q},\\mathrm{st}]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\text{poly}(\\lambda,\\log T,\\log C).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the construction of <span class="math">\\text{NewRel}</span>, since <span class="math">2i-1</span> and <span class="math">2i</span> can be computed by a circuit of size <span class="math">O(\\log T)</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{NewRel}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\tilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{VerifyC}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For </span>\\text{VerifyC}$, we analyse the size of the circuit computing each step.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- First, <span class="math">\\text{VerifyC}</span> verifies if the opening <span class="math">\\pi_{q}^{\\prime}</span> is accepted with respect to <span class="math">c_{q}</span>. By the succinct verification property of the somewhere extractable commitment, this step can be computed by a circuit of size $\\text{poly}(\\lambda,\\log T)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By the small query complexity of the PCP, this term is bounded by </span>\\text{poly}(\\lambda,\\log T,\\log C)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Second, <span class="math">\\text{VerifyC}</span> verifies the PCP proof. By the succinct verification property of PCP, this step can be computed by a circuit of size <span class="math">\\text{poly}(\\lambda,\\log T,\\log C)</span>.</li>

    </ul>

    <p class="text-gray-300">Since each step of <span class="math">\\text{VerifyC}</span> can be computed by a circuit of size <span class="math">\\text{poly}(\\lambda,\\log T,\\log C)</span>, which completes the proof. ∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Lemma 3 (Succinct Proof).</h6>

    <p class="text-gray-300">The aforementioned construction satisfies the succinct proof property.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We analyse the length of the proof recursively. By construction, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\Pi_{L-1}</span> is the proof length of the <span class="math">(L-1)</span>-level BARG. By the succinct commitment property, the size of <span class="math">c</span> is bounded by <span class="math">\\mathrm{poly}(\\lambda,\\log T)\\cdot\\ell</span>. Since the length of the PCP proof is bounded by $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, we have that </span>\\ell=\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Hence, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Hence, recursively applying Lemma 2, we have </span>\\Pi_{L}=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 4 (Succinct Verification).</h6>

    <p class="text-gray-300">The aforementioned construction satisfies succinct verification property.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathrm{Time}_{L}</span> and <span class="math">\\mathrm{Time}_{L-1}</span> be the verification time for <span class="math">\\mathrm{BARG}_{L}</span> and <span class="math">\\mathrm{BARG}_{L-1}</span> respectively. Then we have</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Time}_{L}=\\mathrm{Time}_{\\mathcal{H},\\mathrm{Hash}}+\\mathrm{Time}_{\\mathrm{PCP},\\mathrm{Q}}+\\mathrm{Time}_{L-1},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathrm{Time}_{\\mathcal{H},\\mathrm{Hash}}</span> is the running time of <span class="math">\\mathcal{H}.\\mathrm{Hash}</span>, and <span class="math">\\mathrm{Time}_{\\mathrm{PCP},\\mathrm{Q}}</span> is the running time of PCP.Q. From Theorem 6, $\\mathrm{Time}_{\\mathcal{H},\\mathrm{Hash}}=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. From the PCP construction, PCP.Q needs to be a polynomial time algorithm. Hence, we have </span>\\mathrm{Time}_{\\mathrm{PCP},\\mathrm{Q}}=\\mathrm{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Therefore,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{Time}_{L}=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+\\mathrm{Time}_{L-1}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recursively applying this equation, we obtain $\\mathrm{Time}=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-76" class="text-base font-medium mt-4">Lemma 5 (Compact CRS).</h6>

    <p class="text-gray-300">The aforementioned construction satisfies compact CRS property.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By construction,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{H}.k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathrm{crs}_{L}</span> and <span class="math">\\mathrm{crs}_{L-1}</span> are the CRS of the BARG at the <span class="math">L</span>-the level and <span class="math">(L-1)</span>-th level respectively. From succinct CRS property of the commitment scheme, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log T)<span class="math">. The size of the hash key is bounded by the running time of </span>\\mathcal{H}.\\mathrm{Hash}<span class="math">, which is </span>\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Hence, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}_{L-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recursively applying this equation, by Lemma 2, we obtain $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 6 (CRS indistinguishability).</h6>

    <p class="text-gray-300">The aforementioned construction satisfies CRS indistinguishability.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since the construction is recursive, we prove the CRS indistinguishability by induction. In the base case, when <span class="math">T=1</span>, the CRS generated by <span class="math">\\mathrm{Gen}</span> and <span class="math">\\mathrm{TGen}</span> is clearly indistinguishable. Now, assuming <span class="math">\\mathrm{BARG}_{L-1}</span> satisfies CRS indistinguishability, we prove the CRS indistinguishability of BARG by the following hybrid arguments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\underline{\\mathrm{Hyb}}_{0}</span>: Let $\\mathrm{crs}\\leftarrow\\mathrm{Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">. Output </span>\\mathrm{crs}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This hybrid is computationally indistinguishable with <span class="math">\\mathrm{Hyb}_{0}</span>, from the key indistinguishability of the commitment scheme <span class="math">\\mathrm{SECOM}</span>.</p>

    <p class="text-gray-300">######</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\underline{\\text{Hyb}_{2}}</span>: Let <span class="math">(K^{<em>},\\text{td})\\leftarrow\\text{SECOM.TGen}(1^{\\lambda},1^{T},\\{i^{</em>}\\})</span>, <span class="math">\\operatorname{crs}^{<em>/}\\leftarrow\\text{BARG.Gen}(1^{\\lambda},1^{T^{\\prime}},1^{\\lvert\\text{NewRel}\\rvert},\\lfloor(i^{</em>}+1)/2\\rfloor</span>, and <span class="math">\\mathcal{H}.k\\leftarrow\\mathcal{H}.\\text{Gen}(1^{\\lambda})</span>. Output <span class="math">\\operatorname{crs}=(K^{*},\\operatorname{crs}^{\\prime},\\mathcal{H}.k)</span></li>

    </ul>

    <p class="text-gray-300">This hybrid is computationally indistinguishable with <span class="math">\\text{Hyb}_{1}</span>, from the CRS indistinguishability of the smaller BARG. This hybrid is identical to <span class="math">\\operatorname{crs}^{<em>}\\leftarrow\\text{TGen}(1^{\\lambda},1^{T},1^{\\lvert C\\rvert},i^{</em>})</span>.</p>

    <p class="text-gray-300">By the hybrid argument, we finish the proof. ∎</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 7 (Completeness).</h6>

    <p class="text-gray-300">The aforementioned construction satisfies the completeness property.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove the completeness by induction. For the base case <span class="math">L=0,T=1</span>, since the prover sends the witness directly, the completeness is satisfied. Now, assuming the <span class="math">\\text{BARG}_{L-1}</span> satisfies the completeness, we need to show the completeness of <span class="math">\\text{BARG}_{L}</span>. Since the verification algorithm of <span class="math">\\text{BARG}_{L}</span> invokes <span class="math">\\text{BARG}_{L-1}</span> and verifies <span class="math">\\Pi^{\\prime}</span>, it suffices to show that $\\{\\vec{\\rho}_{2i-1},\\pi_{2i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q},\\vec{\\rho}_{2i},\\pi_{2i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q}\\}_{i\\in[T^{\\prime}]}<span class="math"> are the witnesses for </span>\\text{NewRel}_{\\{K,Q,\\{c_{q}\\}_{q\\in Q},\\text{st}\\}}<span class="math">. According to the construction, to prove this we only need to show </span>(\\vec{\\rho}_{2i-1},\\pi_{2i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})<span class="math"> is a witness for </span>\\text{VerifyC}_{\\{K,c,C\\}}$. This follows from the completeness of the local opening and completeness of the PCP. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Before proving the semi-adaptive somewhere soundness, we first show in Lemma 8 that any adversary for the semi-adaptive somewhere soundness of <span class="math">\\text{BARG}_{L}</span> can be used to build a new adversary for the semi-adaptive somewhere soundness of <span class="math">\\text{BARG}_{L-1}</span>. Then in Lemma 9, we will apply this Lemma recursively to prove the semi-adaptive somewhere soundness of <span class="math">\\text{BARG}_{L}</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 8.</h6>

    <p class="text-gray-300">For any level <span class="math">L</span> and non-uniform PPT adversary <span class="math">\\mathcal{A}</span> for the semi-adaptive somewhere soundness of <span class="math">\\text{BARG}_{L}</span> with advantage <span class="math">\\text{Adv}_{\\mathcal{A}}^{\\text{sound}}(\\lambda)</span>, there exists a non-uniform PPT adversary <span class="math">\\mathcal{A}^{\\prime}</span> for <span class="math">\\text{BARG}_{L-1}</span> such that <span class="math">\\text{Adv}_{\\mathcal{A}^{\\prime}}^{\\text{sound}}(\\lambda)\\geq\\text{Adv}_{\\mathcal{A}}^{\\text{sound}}(\\lambda)-\\text{negl}(\\lambda)</span>. Furthermore, let <span class="math">\\text{Time}_{\\mathcal{A}}</span> and <span class="math">\\text{Time}_{\\mathcal{A}^{\\prime}}</span> be the running time of <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{A}^{\\prime}</span> respectively. Then <span class="math">\\text{Time}_{\\mathcal{A}^{\\prime}}=\\text{Time}_{\\mathcal{A}}+\\text{poly}(\\lambda)</span>.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We build the adversary <span class="math">\\mathcal{A}^{\\prime}</span> trying to break the semi-adaptive somewhere soundness for the underlying <span class="math">(L-1)</span>-level BARG scheme <span class="math">\\text{BARG}_{L-1}</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}^{\\prime}(1^{\\lambda},1^{T^{\\prime}})</span>: Invoke the adversary <span class="math">i^{<em>}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{T})</span>. Output <span class="math">i^{</em>}{}^{\\prime}=\\lfloor(i^{*}+1)/2\\rfloor</span>.</li>

      <li><span class="math">\\mathcal{A}^{\\prime}(\\operatorname{crs}^{*}{}^{\\prime})</span>: The adversary generates <span class="math">\\operatorname{crs}</span> for <span class="math">\\mathcal{A}</span>, and obtains the proof from <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate <span class="math">(K^{<em>},\\text{td})\\leftarrow\\text{SECOM.TGen}(1^{\\lambda},1^{T},\\{i^{</em>}\\})</span>, and <span class="math">\\mathcal{H}.k\\leftarrow\\mathcal{H}.\\text{Gen}(1^{\\lambda})</span>.</li>

      <li>Compose the CRS for BARG, let <span class="math">\\operatorname{crs}^{<em>}=(K^{</em>},\\operatorname{crs}^{<em>}{}^{\\prime},\\mathcal{H}.k)</span>. Feed it to <span class="math">\\mathcal{A}</span>, <span class="math">(C,\\Pi)\\leftarrow\\mathcal{A}(\\operatorname{crs}^{</em>})</span>.</li>

      <li>Parse <span class="math">\\Pi=(c,\\Pi^{\\prime})</span>. Applying CIH to <span class="math">c</span>, <span class="math">r\\leftarrow\\mathcal{H}.\\text{Hash}(\\mathcal{H}.k,c)</span>, and <span class="math">(Q,\\text{st})\\leftarrow\\text{PCP.Q}(1^{\\lambda},C,r)</span>.</li>

      <li>Output <span class="math">(\\text{NewRel}_{\\{K,Q,\\{c_{q}\\}_{q\\in Q},\\text{st}\\}},\\Pi^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">To argue <span class="math">\\text{Adv}_{\\mathcal{A}^{\\prime}}^{\\text{sound}}(\\lambda)\\geq\\text{Adv}_{\\mathcal{A}}^{\\text{sound}}(\\lambda)-\\text{negl}(\\lambda)</span>, we build the following adversary <span class="math">\\mathcal{B}</span> for the correlation intractable hash family <span class="math">\\mathcal{H}</span>.</p>

    <p class="text-gray-300">First, the adversary <span class="math">\\mathcal{B}</span> invokes the adversary <span class="math">\\mathcal{A}</span> by executing <span class="math">i^{<em>}\\leftarrow\\mathcal{A}(1^{\\lambda},1^{T=2^{L}})</span>. Then it generates a SECOM key <span class="math">(K^{</em>},\\text{td})\\leftarrow\\text{SECOM.TGen}(1^{\\lambda},1^{T},\\{i^{<em>}\\})</span>. The adversary then chooses the bad relation <span class="math">R_{\\lambda,i^{</em>},\\text{td}}\\in\\mathcal{R}_{\\lambda}</span> to break the correlation intractability. Next, <span class="math">\\mathcal{B}</span> is given a CIH key <span class="math">\\mathcal{H}.k</span>. <span class="math">\\mathcal{B}</span> generates the CRS for the smaller BARG <span class="math">\\operatorname{crs}^{<em>}{}^{\\prime}\\leftarrow\\text{BARG.TGen}(1^{\\lambda},1^{T^{\\prime}=T/2},1^{\\lvert\\text{NewRel}\\rvert},\\lfloor(i^{</em>}+1)/2\\rfloor)</span>, and composes the CRS <span class="math">\\operatorname{crs}=(K^{<em>},\\operatorname{crs}^{</em>}{}^{\\prime},\\mathcal{H}.k)</span>, and feeds it to <span class="math">\\mathcal{A}</span>. Let <span class="math">(C,\\Pi)\\leftarrow\\mathcal{A}(\\operatorname{crs})</span>. Parse <span class="math">\\Pi=(c,\\Pi^{\\prime})</span>. Output <span class="math">(C,c)</span>.</p>

    <p class="text-gray-300">By the correlation intractability, on the one hand we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathcal{H}.k\\leftarrow\\mathcal{H}.\\text{Gen}(1^{\\lambda}),(C,c)\\leftarrow\\mathcal{B}(\\mathcal{H}.k):((C,c),\\mathcal{H}.\\text{Hash}(\\mathcal{H}.k,(C,c)))\\in R_{\\lambda,i^{*},\\text{td}}\\right]\\leq\\text{negl}(\\lambda).</span> (3)</p>

    <p class="text-gray-300">But on the other hand,</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Adv}_{\\mathcal{A}}^{\\text{sound}}(\\lambda)</span> <span class="math">=\\Pr\\left[(C,i^{<em>})\\notin L\\wedge\\mathsf{V}(\\operatorname{crs},C,\\Pi)=1\\right]</span> <span class="math">=\\Pr\\left[(C,i^{</em>})\\notin L\\wedge\\mathsf{V}(\\operatorname{crs},C,\\Pi)=1\\wedge(\\operatorname{NewRel},i^{<em>}{{}^{\\prime}})\\in L\\right]+\\Pr\\left[(C,i^{</em>})\\notin L\\wedge\\mathsf{V}(\\operatorname{crs},C,\\Pi)=1\\wedge(\\operatorname{NewRel},i^{*}{{}^{\\prime}})\\notin L\\right].</span></p>

    <p class="text-gray-300">By the definition of <span class="math">\\operatorname{Adv}_{\\mathcal{A}^{\\prime}}^{\\text{sound}}(\\lambda)</span>, we have that <span class="math">\\operatorname{Adv}_{\\mathcal{A}^{\\prime}}^{\\text{sound}}(\\lambda)\\geq\\Pr\\left[(C,i^{<em>})\\notin L\\wedge\\mathsf{V}(\\operatorname{crs},C,\\Pi)=1\\wedge(\\operatorname{NewRel},i^{</em>}{{}^{\\prime}})\\notin L\\right]</span>. Hence, it suffices to bound the first term <span class="math">\\Pr[(C,i^{<em>})\\notin L\\wedge\\mathsf{V}(\\operatorname{crs},C,\\Pi)=1\\wedge(\\operatorname{NewRel},i^{</em>}{{}^{\\prime}})\\in L]</span>. We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[(C,i^{<em>})\\notin L\\wedge(\\operatorname{NewRel},i^{</em>}{{}^{\\prime}})\\in L]</span> <span class="math">=\\Pr[(C,i^{<em>})\\notin L\\wedge\\operatorname{NewRel}(i^{</em>}{{}^{\\prime}},\\cdot)\\text{ is satisfiable}]</span> <span class="math">\\leq\\Pr[(C,i^{<em>})\\notin L\\wedge\\operatorname{VerifyC}(i^{</em>},\\cdot)\\text{ is satisfiable}].</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that in the last term, if <span class="math">\\operatorname{VerifyC}(i^{<em>},\\cdot)</span> is satisfiable, then there exists <span class="math">\\vec{\\rho},\\pi^{\\prime}</span> such that <span class="math">\\vec{\\rho}</span> is the opening of <span class="math">\\pi^{\\prime}</span> and the PCP verification of <span class="math">\\pi^{\\prime}</span> accepts. By the extraction correctness of <span class="math">\\operatorname{SECOM}</span>, <span class="math">\\pi^{\\prime}</span> here should be equal to the <span class="math">\\{\\operatorname{SECOM.Ext}(c_{q},\\operatorname{td})\\}_{q\\in[\\ell]}</span> in the bad relation <span class="math">R_{\\lambda,i^{</em>},\\operatorname{td}}</span> definition. Hence, $\\operatorname{PCP.D}(i^{*},\\operatorname{st},\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Q})=1<span class="math">, which implies that </span>((C,c),r)\\in R_{\\lambda,i^{*},\\operatorname{td}}$. By correlation intractability (Equation 3), this event is bounded by a negligible probability, which completes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-84" class="text-base font-medium mt-4">Lemma 9 (Semi-adaptive Somewhere Soundness).</h6>

    <p class="text-gray-300">The aforementioned construction satisfies the semi-adaptive somewhere soundness.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We recursively apply the Lemma 8 <span class="math">L=\\log_{2}T</span> times. At the end, we obtain a polynomial time adversary for the <span class="math">0</span>-level base case construction. Since the base case protocol has the prover send the witness directly, it is statistically sound. Hence, we reach a contradiction, which completes the proof. ∎</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">The proof of Lemma 9 can be extended to show somewhere argument of knowledge property. We provide a proof sketch here. For the base case <span class="math">L=0,T=1</span>, since the prover sends the witness, we can extract the witness from the proof directly. For any <span class="math">L\\geq 1</span>, we firstly use the extractor of <span class="math">\\operatorname{SECOM}</span> to extract the PCP proof <span class="math">\\pi</span> as in the soundness proof, and then apply the proof of knowledge property of the PCP to obtain a witness.</p>

    <h3 id="sec-87" class="text-xl font-semibold mt-8">4.4 BARGs for NP</h3>

    <p class="text-gray-300">In this subsection, we present a generic approach to generalize the BARG for index language and obtain BARGs for SAT.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Theorem 8.</h6>

    <p class="text-gray-300">If there exists a batch argument <span class="math">\\operatorname{BARG}^{\\prime}=(\\operatorname{BARG}^{\\prime}.\\operatorname{Gen},\\operatorname{BARG}^{\\prime}.\\operatorname{TGen},\\operatorname{BARG}^{\\prime}.\\operatorname{P},\\operatorname{BARG}^{\\prime}.\\mathsf{V})</span> for the index language <span class="math">\\mathcal{L}^{\\operatorname{idx}}</span>, then there exists a batch argument <span class="math">\\operatorname{BARG}=(\\operatorname{Gen},\\operatorname{TGen},\\operatorname{P},\\mathsf{V})</span> for <span class="math">\\operatorname{SAT}</span> with succinct verification property.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof Sketch.</h6>

    <p class="text-gray-300">We construct the BARG as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\operatorname{Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">: When generating the CRS, in addition to generating the CRS for </span>\\operatorname{BARG}^{\\prime}<span class="math">, we also generate a somewhere extractable commitment key </span>K$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let $\\operatorname{crs}^{\\prime}\\leftarrow\\operatorname{BARG}^{\\prime}.\\operatorname{Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, where the circuit </span>C^{\\prime}$ is depicted in Figure 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">K\\leftarrow\\operatorname{SECOM.Gen}(1^{\\lambda},1^{T},1^{1})</span> be a somewhere extractable commitment key with set size <span class="math">1</span>.</li>

      <li>Output <span class="math">\\operatorname{crs}=(K,\\operatorname{crs}^{\\prime})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\operatorname{TGen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},i^{<em>})<span class="math">: In the trapdoor CRS generation algorithm, we generate the trapdoor CRS of </span>\\operatorname{BARG}^{\\prime}<span class="math">, and also generate the trapdoor somewhere extractable commitment key which is extractable at </span>i^{</em>}$-th coordinate</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hardwired: The commitment key  <span class="math">K</span> , the commitments  <span class="math">c = \\{c_j\\}_{j \\in [n]}</span> , and a circuit  <span class="math">C</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the opening  <span class="math">\\{\\rho_j\\}_{j \\in [n]}</span>  and the instance  <span class="math">x</span>  are the  <span class="math">i</span> -th coordinate of  <span class="math">c</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\forall j \\in [n]</span> , verify SECOM.Verify  <span class="math">(K, c_j, x[j], i, \\rho_j) = 1</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify the C-SAT: verify if  <span class="math">C(x, \\omega) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">If all verification passes, then output 1. Otherwise, output 0.</p>

    <p class="text-gray-300">Figure 4: The new circuit  <span class="math">C&#x27;</span>  for batch argument.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  $\\mathrm{crs}^{*^{\\prime}}\\gets \\mathrm{BARG}^{\\prime}.\\mathrm{Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},i^{<em>})<span class="math">  be the trapdoor CRS of  </span>\\mathrm{BARG}^{\\prime}<span class="math">  for  </span>i^{</em>}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">K^{<em>} \\gets \\mathrm{SECOM.Gen}(1^{\\lambda}, 1^{T}, 1^{1}, \\{i^{</em>}\\})</span>  be the trapdoor somewhere extractable commitment key.</li>

      <li>Output  <span class="math">\\mathrm{crs}^<em> = (K^</em>, \\mathrm{crs}^{*&#x27;})</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{P}(\\mathrm{crs}, C, x_1, \\ldots, x_T, \\omega_1, \\ldots, \\omega_T)</span> : The prover first uses the somewhere extractable commitment to commit all the instances, and obtain a short commitment  <span class="math">c</span> . Then we have the prover use BARG' to prove the statement: "for each  <span class="math">i \\in [T]</span> , there exists an accepting local opening  <span class="math">x_i</span>  at the  <span class="math">i</span> -th coordinate for the commitment  <span class="math">c</span> , and there exists a witness  <span class="math">\\omega_i</span>  such that  <span class="math">C(x_i, \\omega_i) = 1</span> ".</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathrm{crs} = (K, \\mathrm{crs}&#x27;)</span> , where  <span class="math">K</span>  is a somewhere extractable commitment key, and  <span class="math">\\mathrm{crs}&#x27;</span>  is a CRS for BARG'.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Recall that  $n =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is the length of the instances. Commit the instances by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall j \\in [n], c_j := \\text{SECOM.}\\operatorname{Com}(K, x_1[j], x_2[j], \\ldots, x_T[j]; 0)^7,</span></p>

    <p class="text-gray-300">where  <span class="math">x_{i}[j]</span>  is the  <span class="math">j</span> -th bit of the string  <span class="math">x_{i}</span> . Let  <span class="math">c = \\{c_{j}\\}_{j \\in n}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in [T], j \\in [n]</span> , generate the opening  <span class="math">\\rho_{i,j} \\gets \\text{SECOM.Open}(K, (x_1[j], \\ldots, x_T[j]), i)</span> .</li>

      <li>Generate batch argument with witness  <span class="math">(\\{\\rho_{i,j}\\}_{j\\in [n]},x_i,\\omega_i)</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pi^{\\prime}\\gets \\mathrm{BARG}^{\\prime}.\\mathrm{P}\\left(\\mathrm{crs}^{\\prime},C_{[K,c,C]}^{\\prime},\\{\\{\\rho_{i,j}\\}_{j\\in [n]},x_i,\\omega_i\\}_{i\\in [T]}\\right).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\Pi = \\Pi&#x27;</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}(\\mathrm{crs}, C, x_1, x_2, \\ldots, x_T, \\Pi)</span> : The verifier parses  <span class="math">\\Pi = \\Pi&#x27;</span>  and  <span class="math">\\mathrm{crs} = (K, \\mathrm{crs}&#x27;)</span> . We construct the following pre-processing and online verification algorithms.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pre-processing PreVerify(crs,  <span class="math">x_{1}, x_{2}, \\ldots, x_{T}</span> ): Commit the instances by</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\forall j \\in [n], c_j := \\text{SECOM.}\\operatorname{Com}(K, x_1[j], x_2[j], \\ldots, x_T[j]; 0)</span> .</p>

    <p class="text-gray-300">Output the short sketch  <span class="math">c = \\{c_j\\}_{j\\in [n]}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Online Verification OnlineVerify(crs, <span class="math">c,C,\\Pi^{\\prime}</span>): Output BARG^{′}.V(crs^{′}, <span class="math">C^{\\prime}_{[K,c,C]}</span>, <span class="math">\\Pi^{\\prime}</span>).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The succinct communication property follows directly from the succinct communication property of the BARGs for the index language. The succinct verification property follows from the construction. The compact CRS property is also satisfied, since the underlying BARGs for index language satisfy compact CRS property, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is also bounded by </span>\\text{poly}(\\lambda,\\log T)$ from the succinct CRS property of somewhere extractable commitment. The CRS indistinguishability proprty follows from the key indistinguishability of somewhere extractable commitment and the CRS indistinguishability of BARG^{′}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove semi-adaptive somewhere soundness, for any adversary <span class="math">\\mathcal{A}</span> for the semi-adaptive somewhere soundness of BARG, we construct a new adversary <span class="math">\\mathcal{A}^{\\prime}</span> for BARG^{′}, as follows: <span class="math">\\mathcal{A}^{\\prime}</span> first invokes <span class="math">\\mathcal{A}</span>, and obtain a index <span class="math">i^{<em>}</span> which it outputs directly. Then, <span class="math">\\mathcal{A}^{\\prime}</span> receives a CRS <span class="math">\\text{crs}^{\\prime}</span>, generates a trapdoor commitment key <span class="math">K^{</em>}</span> which is extractable at the <span class="math">i^{<em>}</span>-th coordinate, and feeds <span class="math">\\text{crs}=(K=K^{</em>},\\text{crs}^{\\prime})</span> to <span class="math">\\mathcal{A}</span>. Next, <span class="math">\\mathcal{A}</span> outputs <span class="math">(C,x_{1},x_{2},\\ldots,x_{T},\\Pi)</span>. <span class="math">\\mathcal{A}^{\\prime}</span> computes <span class="math">c=\\text{PreVerify}(\\text{crs},x_{1},x_{2},\\ldots,x_{T})</span>, and outputs <span class="math">(C^{\\prime}_{[K,c,C]},\\Pi)</span>. The adversary <span class="math">\\mathcal{A}^{\\prime}</span> simulates the environment for the adversary <span class="math">\\mathcal{A}</span>. Furthermore, if <span class="math">(C,x_{i^{<em>}})\\notin\\text{SAT}</span>, then by the extraction correctness of the commitment, we have <span class="math">(C^{\\prime},i^{</em>})\\notin\\mathcal{L}^{\\text{idx}}</span>. Hence, if the attack of <span class="math">\\mathcal{A}</span> succeeds, then <span class="math">\\mathcal{A}^{\\prime}</span> also succeeds. Since the underlying BARG^{′} is somewhere sound, we prove the semi-adaptive somewhere soundness of BARG. ∎</p>

    <h2 id="sec-91" class="text-2xl font-bold">5 RAM Delegation</h2>

    <p class="text-gray-300">We follow the notions of delegation, for both Turing Machines and RAM, as defined in <em>[x10]</em> who further show that their notion of RAM delegation implies Turing Machine delegation. This allows us to focus on constructing RAM delegation schemes for the rest of the paper.</p>

    <h3 id="sec-92" class="text-xl font-semibold mt-8">5.1 Turing Machine Delegation</h3>

    <p class="text-gray-300">Consider a Turing machine <span class="math">\\mathcal{M}</span>. A publicly verifiable non-interactive delegation scheme for <span class="math">\\mathcal{M}</span> consists of the following polynomial time algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>randomized setup algorithm that on input security parameter <span class="math">1^{\\lambda}</span>, time bound <span class="math">T</span> and input length <span class="math">n</span> outputs a pair of public keys - prover key pk and verifier key vk.</li>

      <li>deterministic prover algorithm that on input prover key pk and an input <span class="math">x\\in\\{0,1\\}^{n}</span> outputs a proof <span class="math">\\Pi</span>.</li>

      <li>deterministic verifier algorithm that on input verifier key pk, input <span class="math">x\\in\\{0,1\\}^{n}</span> and proof <span class="math">\\Pi</span> outputs either 0 or 1.</li>

    </ul>

    <p class="text-gray-300">For any Turing machine <span class="math">\\mathcal{M}</span>, we define the corresponding language <span class="math">\\mathcal{U}_{\\mathcal{M}}</span> below,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{U}_{\\mathcal{M}}\\coloneqq\\big{\\{}(x,T)\\;\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\;\\mathcal{M}\\text{ accepts }x\\text{ within }T\\text{ steps}\\big{\\}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-93" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">A publicly verifiable non-interactive delegation scheme <span class="math">(\\text{Del.S},\\text{Del.P},\\text{Del.V})</span> for <span class="math">\\mathcal{M}</span> with setup time <span class="math">T_{\\text{S}}=T_{\\text{S}}(\\lambda,T)</span> and proof length <span class="math">L_{\\Pi}=L_{\\Pi}(\\lambda,T)</span>.</p>

    <p class="text-gray-300">Completeness. For every <span class="math">\\lambda,T,n\\in\\mathbb{N}</span> such that <span class="math">n\\leq T\\leq 2^{\\lambda}</span>, and <span class="math">x\\in\\{0,1\\}^{n}</span> such that <span class="math">(x,T)\\in\\mathcal{U}_{\\mathcal{M}}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\biggl{[}\\;\\;\\text{Del.V}(\\text{vk},x,\\Pi)=1\\;\\;\\;\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(\\text{pk},\\text{vk})\\leftarrow\\text{Del.S}(1^{\\lambda},T,n)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\Pi\\coloneqq\\text{Del.P}(\\text{pk},x)\\end{array}\\right.\\biggr{]}=1 \\]</p>

    <p class="text-gray-300">Efficiency. In the completeness experiment above,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Del.S runs in time <span class="math">T_{\\text{S}}</span>.</li>

      <li>Del.P runs in time <span class="math">\\text{poly}(\\lambda,T)</span> and outputs a proof of length <span class="math">L_{\\Pi}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Del.V runs in time  <span class="math">O(L_{\\Pi}) + n \\cdot \\mathrm{poly}(\\lambda)</span> .</li>

    </ul>

    <p class="text-gray-300">Soundness. For every PPT adversary  <span class="math">\\mathcal{A}</span>  and pair of polynomials  <span class="math">T = T(\\lambda)</span>  and  <span class="math">n = n(\\lambda)</span>  there exists a negligible function  <span class="math">\\mathrm{negl}(\\mathrm{cot})</span>  such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} \\operatorname {D e l . V} (\\mathrm {v k}, x, \\Pi) = 1 &amp;amp; (\\mathrm {p k}, \\mathrm {v k}) \\leftarrow \\operatorname {D e l . S} (1 ^ {\\lambda}, T, n) \\\\ (x, T) \\notin \\mathcal {U} _ {\\mathcal {M}} &amp;amp; (x, \\Pi) \\leftarrow \\mathcal {A} (\\mathrm {p k}, \\mathrm {v k}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <h2 id="sec-94" class="text-2xl font-bold">5.2 RAM Delegation</h2>

    <p class="text-gray-300">A RAM machine of word size  <span class="math">\\ell</span>  is modeled as a deterministic machine with random access to memory of size  <span class="math">2^{\\ell}</span>  where the local state of the machine has size only  <span class="math">O(\\ell)</span> . At each time step, the machine updates its local state by either reading or writing a single memory. At any given time, the memory and the local state together represent the configuration of the machine. For simplicity, we assume that the machine has no input outside of its local state and memory, and the word size  <span class="math">\\ell</span>  will correspond to the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">A publicly verifiable non-interactive delegation scheme for  <span class="math">\\mathcal{R}</span>  consists of the following polynomial time algorithms:</p>

    <p class="text-gray-300">RDel.S - randomized setup algorithm that on input security parameter  <span class="math">1^{\\lambda}</span> , time bound  <span class="math">T</span>  outputs a triple of public keys - prover key pk, verifier key vk and a digest key dk.</p>

    <p class="text-gray-300">RDel.D - deterministic digest algorithm that on input digest key dk and configuration cf outputs a digest h.</p>

    <p class="text-gray-300">RDel.P - deterministic prover algorithm that on input prover key pk and a pair of source and destination configurations cf, cf' outputs a proof Π.</p>

    <p class="text-gray-300">RDel.V - deterministic verifier algorithm that on verifier key pk, pair of digests h, h' and proof Π outputs either 0 or 1.</p>

    <p class="text-gray-300">For any machine  <span class="math">\\mathcal{R}</span> , we define the corresponding language  <span class="math">\\mathcal{U}_{\\mathcal{R}}</span>  below,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {U} _ {\\mathcal {R}} := \\left\\{\\left(\\ell , \\operatorname {c f}, \\operatorname {c f} ^ {\\prime}, T\\right) \\mid \\mathcal {R} \\text { with word size } \\ell \\text { transitions from } \\operatorname {c f} \\text { to } \\operatorname {c f} ^ {\\prime} \\text { in } T \\text { steps} \\right\\}</span></div>

    <p class="text-gray-300">Definition 9. A publicly verifiable non-interactive delegation scheme (RDel.S, RDel.D, RDel.P, RDel.V) for  <span class="math">\\mathcal{R}</span>  with setup time  <span class="math">T_{\\mathrm{S}} = T_{\\mathrm{S}}(\\lambda, T)</span>  and proof length  <span class="math">L_{\\Pi} = L_{\\Pi}(\\lambda, T)</span> .</p>

    <p class="text-gray-300">Completeness. For every  <span class="math">\\lambda, T \\in \\mathbb{N}</span>  such that  <span class="math">n \\leq T \\leq 2^{\\lambda}</span> , and  <span class="math">\\operatorname{cf}, \\operatorname{cf}&#x27; \\in \\{0,1\\}^{*}</span>  such that  <span class="math">(\\lambda, \\operatorname{cf}, \\operatorname{cf}&#x27;, T) \\in \\mathcal{U}_{\\mathcal{R}}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} \\operatorname {R D e l . V} (\\mathrm {v k}, \\mathrm {h}, \\mathrm {h} ^ {\\prime}, \\Pi) = 1 &amp;amp; \\begin{array}{l} (\\mathrm {p k}, \\mathrm {v k}, \\mathrm {d k}) \\leftarrow \\operatorname {R D e l . S} (1 ^ {\\lambda},) \\\\ \\mathrm {h} := \\operatorname {R D e l . D} (\\mathrm {d k}, \\mathrm {c f}) \\\\ \\mathrm {h} ^ {\\prime} := \\operatorname {R D e l . D} (\\mathrm {d k}, \\mathrm {c f} ^ {\\prime}) \\\\ \\Pi := \\operatorname {D e l . P} (\\mathrm {p k}, \\mathrm {c f}, \\mathrm {c f} ^ {\\prime}) \\end{array} \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">Efficiency. In the completeness experiment above,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RDel.S runs in time  <span class="math">T_{\\mathrm{S}}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- RDel.D on input cf runs in time  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{cf}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathrm{poly}(\\lambda)<span class="math">  and outputs a digest of length  </span>\\lambda$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RDel.V runs in time  <span class="math">O(L_{\\Pi}) + \\mathrm{poly}(\\lambda)</span> .</li>

    </ul>

    <p class="text-gray-300">Collision resistance. For every PPT adversary  <span class="math">\\mathcal{A}</span>  and pair of polynomials  <span class="math">T = T(\\lambda)</span>  there exists a negligible function  <span class="math">\\mathrm{negl}(\\mathrm{cot})</span>  such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} \\operatorname {c f} \\neq \\operatorname {c f} ^ {\\prime} &amp;amp; (\\operatorname {p k}, \\operatorname {v k}, \\operatorname {d k}) \\leftarrow \\operatorname {R D e l . S} (1 ^ {\\lambda}, T, n) \\\\ \\operatorname {R D e l . D} (\\operatorname {d k}, \\operatorname {c f}) = \\operatorname {R D e l . D} (\\operatorname {d k}, \\operatorname {c f} ^ {\\prime}) &amp;amp; (\\operatorname {c f}, \\operatorname {c f} ^ {\\prime}) \\leftarrow \\mathcal {A} (\\operatorname {p k}, \\operatorname {v k}, \\operatorname {d k}) \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <h6 id="sec-95" class="text-base font-medium mt-4">Soundness.</h6>

    <p class="text-gray-300">For every <span class="math">\\mathrm{PPT}</span> adversary <span class="math">\\mathcal{A}</span> and pair of polynomials <span class="math">T=T(\\lambda)</span>there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ll}\\mathrm{RDel.V(vk,h,h^{\\prime},\\Pi)=1}&\\\\ (\\lambda,\\mathrm{cf},\\mathrm{cf^{\\prime}},T)\\in\\mathcal{U}_{\\mathcal{R}}&(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})\\leftarrow\\mathrm{RDel.S}(1^{\\lambda},T,n)\\\\ \\mathrm{h}=\\mathrm{RDel.D(dk,cf)}&(\\mathrm{cf},\\mathrm{cf^{\\prime}},h,h^{\\prime},\\Pi)\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})\\end{array}\\right]\\leq\\mathrm{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">As discussed in <em>[x10]</em>, the notion of RAM delegation considered in their work is different from those in prior works <em>[x11, x3]</em> - namely that in prior works the adversary was not required to output the full configuration explicitly, only that it was difficult to produce accepting proofs for two different statements <span class="math">(\\mathrm{h},\\mathrm{h^{\\prime}})</span> and <span class="math">(\\mathrm{h},\\mathrm{h^{\\prime\\prime}})</span> that share the same initial digest. We refer the reader to <em>[x10]</em> for a more detailed comparison of the notions.</p>

    <p class="text-gray-300">The following theorem establishes that RAM delegation implies Turing machine delegation for the definitions described above.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Theorem 9 (<em>[x10]</em>).</h6>

    <p class="text-gray-300">Suppose that for any RAM machine there exists a publicly verifiable non-interactive delegation scheme with setup time <span class="math">T^{\\prime}_{S}</span> and proof length <span class="math">L^{\\prime}_{\\Pi}</span>. Then for any Turing machine there exists a publicly verifiable non-interactive delegation scheme with setup time <span class="math">T_{S}</span> and proof length <span class="math">L_{\\Pi}</span> where <span class="math">T_{S}(\\lambda,T)=T^{\\prime}_{S}(\\lambda,T^{\\prime})</span>, <span class="math">L_{\\Pi}(\\lambda,T)=L^{\\prime}_{\\Pi}(\\lambda,T^{\\prime})</span> for <span class="math">T^{\\prime}=O(T)</span>.</p>

    <h3 id="sec-97" class="text-xl font-semibold mt-8">5.3 Hash Tree</h3>

    <p class="text-gray-300">For going beyond space bounded computation, we recall the definition of hash trees as defined in <em>[x10]</em>. A <em>hash tree</em> consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>randomized algorithm that on input the security parameter <span class="math">1^{\\lambda}</span> outputs a hash key <span class="math">\\mathrm{dk}</span></li>

      <li>deterministic algorithm that on input the hash key <span class="math">\\mathrm{dk}</span> and string <span class="math">D\\in\\{0,1\\}^{L}</span> outputs a hash tree tree and a root <span class="math">\\mathrm{rt}</span>.</li>

      <li>deterministic algorithm that on input hash tree tree and memory location <span class="math">\\ell</span> outputs a bit <span class="math">b</span> along with a proof <span class="math">\\Pi</span>.</li>

      <li>deterministic algorithm that on input hash tree tree, memory location <span class="math">\\ell</span> and bit <span class="math">b</span> outputs a new tree tree^{′}, a new root <span class="math">\\mathrm{rt^{\\prime}}</span> along with a proof <span class="math">\\Pi</span>.</li>

    </ul>

    <p class="text-gray-300">-邓式- deterministic algorithm on input hash key <span class="math">\\mathrm{dk}</span>, root <span class="math">\\mathrm{rt}</span>, memory location <span class="math">\\ell</span>, bit <span class="math">b</span> and proof <span class="math">\\Pi</span> outputs either 0 or 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>deterministic algorithm on input hash key <span class="math">\\mathrm{dk}</span>, root <span class="math">\\mathrm{rt}</span>, memory location <span class="math">\\ell</span>, bit <span class="math">b</span>, new root <span class="math">\\mathrm{rt^{\\prime}}</span> and proof <span class="math">\\Pi</span> outputs either 0 or 1.</li>

    </ul>

    <h6 id="sec-98" class="text-base font-medium mt-4">Definition 10 (Hash Tree).</h6>

    <p class="text-gray-300">A hash tree scheme (HT.Gen, HT.Hash, HT.Read, HT.Write, HT.VerRead, HT.VerWrite) satisfies the following properties:</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Completeness.</h6>

    <p class="text-gray-300">For every <span class="math">\\lambda\\in\\mathbb{N},D\\in\\{0,1\\}^{L}</span> for <span class="math">L\\leq 2^{\\lambda}</span> and <span class="math">\\ell\\in[L]</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ll}\\mathrm{HT.VerRead}(\\mathrm{dk},\\mathrm{rt},\\ell,b,\\Pi)=1&\\\\ D[\\ell]=b&\\\\ \\end{array}\\right]\\begin{array}[]{ll}\\mathrm{dk}\\leftarrow\\mathrm{HT.Gen}(1^{\\lambda})&\\\\ (\\mathrm{tree},\\mathrm{rt}):=\\mathrm{HT.Hash}(\\mathrm{dk},D)&\\\\ (b,\\Pi):=\\mathrm{HT.Read}(\\mathrm{tree},\\ell)\\end{array}\\left]=1\\right. \\]</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Efficiency.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the completeness experiment, the running time of HT.Hash is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathrm{poly}(\\lambda)<span class="math">. The length of the root </span>\\mathrm{rt}<span class="math">, and proofs produced by HT.Read and HT.Write are </span>\\mathrm{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Soundness of Read.</h6>

    <p class="text-gray-300">For every polynomial size adversary <span class="math">\\mathcal{A}</span> there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\text{<span class="math">b_{1}\\neq b_{2}</span>}\\\\ \\text{HT.VerRead}(\\mathrm{dk},\\mathrm{rt},\\ell,b_{1},\\Pi_{1})=1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{HT.VerRead}(\\mathrm{dk},\\mathrm{rt},\\ell,b_{2},\\Pi_{2})=1\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\mathrm{dk}\\leftarrow\\text{HT.Gen}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\mathrm{rt},\\ell,b_{1},\\Pi_{1},b_{2},\\Pi_{2})\\leftarrow\\mathcal{A}(\\mathrm{dk})\\end{array}\\Bigg{]}\\leq\\mathrm{negl}(\\lambda) \\]</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Soundness of Write.</h6>

    <p class="text-gray-300">For every polynomial size adversary <span class="math">\\mathcal{A}</span> there exists a negligible function <span class="math">\\mathrm{negl}(\\cdot)</span> such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathrm{rt}_{1}\\neq\\mathrm{rt}_{2}\\\\ \\text{HT.VerWrite}(\\mathrm{dk},\\mathrm{rt},\\ell,b,\\mathrm{rt}_{1},\\Pi_{1})=1\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{HT.VerWrite}(\\mathrm{dk},\\mathrm{rt},\\ell,b,\\mathrm{rt}_{2},\\Pi_{2})=1\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\mathrm{dk}\\leftarrow\\text{HT.Gen}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\mathrm{rt},\\ell,b,\\mathrm{rt}_{1},\\Pi_{1},\\mathrm{rt}_{2},\\Pi_{2})\\leftarrow\\mathcal{A}(\\mathrm{dk})\\end{array}\\Bigg{]}\\leq\\mathrm{negl}(\\lambda) \\]</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Theorem 10 (<em>[x18]</em>).</h6>

    <p class="text-gray-300">From any family of collision resistant hash functions, one can construct a hash tree scheme.</p>

    <h3 id="sec-104" class="text-xl font-semibold mt-8">5.4 Protocol</h3>

    <p class="text-gray-300">The protocol follows the construction of the base case for RAM delegation in <em>[x20]</em>. The crucial difference in our setting is that we are able to reduce the computation to an instance of a non-interactive BARG for index languages with a short CRS. The benefit of this is that we no longer have to do the bootstrapping since the CRS is already small. Our proof also closely follows the proof structure of their construction, although the no-signaling properties used in our proof are derived from the commitment rather than the underlying argument scheme.</p>

    <h5 id="sec-105" class="text-base font-semibold mt-4">RAM machine steps to circuit satisfiability.</h5>

    <p class="text-gray-300">We use the translation from a <em>single</em> step of the machine <span class="math">\\mathcal{R}</span> as described in <em>[x20]</em>. Without loss of generality, assume that every step of <span class="math">\\mathcal{R}</span> consists of a <em>single read operation, followed by a single write operation</em>. Therefore, a single step can be decomposed into the following <em>deterministic</em> polynomial time algorithms:</p>

    <p class="text-gray-300">On input the local state <span class="math">\\mathrm{st}</span> of <span class="math">\\mathcal{R}</span>, outputs the memory location <span class="math">\\ell</span> that <span class="math">\\mathcal{R}</span> while in state <span class="math">\\mathrm{st}</span> would read from. On input the local state <span class="math">\\mathrm{st}</span> and bit <span class="math">b</span>, outputs a bit <span class="math">b^{\\prime}</span>, memory location <span class="math">\\ell^{\\prime}</span> and state <span class="math">\\mathrm{st}^{\\prime}</span> such that <span class="math">\\mathcal{R}</span> while in state <span class="math">\\mathrm{st}</span> on reading bit <span class="math">b</span> would write <span class="math">b^{\\prime}</span> to location <span class="math">\\ell^{\\prime}</span> and then transition to new local state <span class="math">\\mathrm{st}^{\\prime}</span>.</p>

    <p class="text-gray-300">We denote by <span class="math">\\varphi</span> the circuit representing a single step of <span class="math">\\mathcal{R}</span>, i.e. given a pair of digests <span class="math">\\mathsf{h}=(\\mathrm{st},\\mathrm{rt})</span>, <span class="math">\\mathsf{h}^{\\prime}=(\\mathrm{st}^{\\prime},\\mathrm{rt}^{\\prime})</span>, bit <span class="math">b</span> and proof <span class="math">\\Pi,\\Pi^{\\prime}</span> there exists an efficiently computable <span class="math">w</span> (given <span class="math">(\\mathsf{h},\\mathsf{h}^{\\prime},b,\\Pi,\\Pi^{\\prime})</span>) such that <span class="math">\\varphi(\\mathsf{h},\\mathsf{h}^{\\prime},b,\\Pi,\\Pi^{\\prime},w)=1</span> <em>if and only if</em></p>

    <p class="text-gray-300"><span class="math">\\ell</span> <span class="math">=\\mathrm{StepR}(\\mathrm{st})</span> <span class="math">(b^{\\prime},\\ell^{\\prime},\\mathrm{st}^{\\prime\\prime})</span> <span class="math">=\\mathrm{StepW}(\\mathrm{st},b)</span> <span class="math">\\mathrm{st}^{\\prime}</span> <span class="math">=\\mathrm{st}^{\\prime\\prime}</span> <span class="math">\\mathrm{HT.VerRead}(\\mathrm{dk},\\mathrm{rt},\\ell,b,\\Pi)</span> <span class="math">=1</span> <span class="math">\\mathrm{HT.VerWrite}(\\mathrm{dk},\\mathrm{rt},\\ell^{\\prime},b^{\\prime},\\mathrm{rt}^{\\prime},\\Pi^{\\prime})</span> <span class="math">=1</span></p>

    <p class="text-gray-300">From the efficiency of the hash tree scheme, there exists a <span class="math">\\varphi</span> such that the above can be represented as a formula of <span class="math">L=\\mathrm{poly}(\\lambda)</span> variables.</p>

    <p class="text-gray-300">We will use <span class="math">\\varphi_{i}</span> to denote the <span class="math">i</span>-th step in the above formula <span class="math">\\phi</span>. Note that the subscript will be helpful in our discussion of security, but the circuits themselves are identical for all <span class="math">i</span>.</p>

    <p class="text-gray-300">For <span class="math">T</span> steps of <span class="math">\\mathcal{R}</span>, we then have the following formula <span class="math">\\phi</span> over <span class="math">M\\coloneqq O(L\\cdot T)</span> variables:</p>

    <p class="text-gray-300"><span class="math">\\phi\\left(\\mathsf{h}_{0},\\left\\{\\mathsf{h}_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i}\\right\\}_{i\\in[T]}\\right)\\coloneqq\\bigwedge_{i\\in[T]}\\varphi_{i}(\\mathsf{h}_{i-1},\\mathsf{h}_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i})</span></p>

    <p class="text-gray-300">Note that the above formula is <em>not an index language</em>. This is because for all <span class="math">i</span>, <span class="math">\\varphi_{i}</span> and <span class="math">\\varphi_{i+1}</span> share a part of the witness, something not handled by the index language since we would have to ensure that the (partial) witness is the <em>same</em>. As described in the technical overview, we handle this by using a NS-SECOM to commit to the witnesses, and then prove for each <span class="math">i</span> that values in the commitment satisfy the clause <span class="math">\\phi_{i}</span>. The no-signaling property will help ensure consistency of the shared witness across different clauses <span class="math">\\varphi_{i}</span> and <span class="math">\\varphi_{i+1}</span>.</p>

    <p class="text-gray-300">The components we require for our delegation scheme are listed below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An <span class="math">L</span>-no-signaling-SECOM commitment scheme (Definition 6) <span class="math">\\textsc{NS-SECOM}=(\\textsc{Gen},\\textsc{TGen},\\textsc{Com},\\textsc{Open},\\textsc{Verify},\\textsc{Ext})</span>.</li>

      <li>A non interactive batch argument (Section 4.1) for an index language <span class="math">(\\textsc{BARG},\\textsc{Gen},\\textsc{BARG},\\textsc{TGen},\\textsc{BARG},\\textsc{P},\\textsc{BARG},\\textsc{V})</span> (Section 4.3).</li>

    </ul>

    <p class="text-gray-300">We present our RAM delegation scheme in Figure 5.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">Assuming the hardness of the Learning with Errors (<span class="math">\\mathsf{LWE}</span>) (Definition 1), for every polynomial <span class="math">T=T(\\lambda)</span>, the protocol in Figure 5 is a publicly-verifiable non-interactive RAM delegation scheme (Definition 9) with CRS size, proof size and verifier time all <span class="math">\\mathrm{poly}(\\lambda,\\log T)</span> while the prover running time is <span class="math">\\mathrm{poly}(\\lambda,T)</span>.</p>

    <p class="text-gray-300">The assumptions required for our construction follow from the assumptions of the underlying primitives. We focus on proving the efficiency and security of our protocol below.</p>

    <h4 id="sec-107" class="text-lg font-semibold mt-6">5.4.1 Efficiency</h4>

    <p class="text-gray-300">Before proving security, we prove that the language above is indeed an index language, and that the efficiency criteria for a RAM delegation scheme are satisfied.</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Claim 1.</h6>

    <p class="text-gray-300">For all <span class="math">i\\in[T]</span>, <span class="math">(C_{\\mathrm{index}},i)\\in\\mathcal{L}</span>.</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This just follows from the construction in Figure 6. The witness corresponds to the inputs as in the delegation protocol. ∎</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Claim 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathrm{poly}(\\lambda,\\log T)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-111" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ consists of the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The hardcoded commitment key <span class="math">K</span>: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=L\\cdot\\mathrm{poly}(\\lambda,\\log M)=\\mathrm{poly}(\\lambda,\\log T)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- The hardcoded circuit <span class="math">\\varphi</span>: $</td>

            <td class="px-3 py-2 border-b border-gray-700">\\varphi_{i}</td>

            <td class="px-3 py-2 border-b border-gray-700">=O(L)=\\mathrm{poly}(\\lambda)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Size of openings as a part of the witness of size <span class="math">L\\cdot\\mathrm{poly}(\\lambda,\\log M)=\\mathrm{poly}(\\lambda,\\log T)</span></li>

    </ul>

    <p class="text-gray-300">RDel.S(1 <span class="math">\\lambda</span> , T): Generate the public parameters for the underlying primitives</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$K\\gets \\mathrm{Gen}(1^{\\lambda},1^{M}),\\mathrm{crs}\\gets \\mathrm{BARG.Gen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}),\\mathrm{dk}\\gets \\mathrm{HT.Gen}(1^{\\lambda}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Output  <span class="math">(\\mathrm{pk}\\coloneqq (K,\\mathrm{crs},\\mathrm{dk}),\\mathrm{vk}\\coloneqq (K,\\mathrm{crs}),\\mathrm{dk}).</span></p>

    <p class="text-gray-300">RDel.D(dk, cf = (st, D)): Compute the hash tree,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{(tree,rt)}\\coloneqq \\mathrm{HT.Hash(dk,D)}</span></p>

    <p class="text-gray-300">Output  <span class="math">\\mathsf{h} \\coloneqq (\\mathsf{st}, \\mathsf{rt})</span> .</p>

    <p class="text-gray-300">RDel.P((pk, dk), cf, cf'): Prover emulates  <span class="math">\\mathcal{R}</span>  for  <span class="math">T</span>  steps from cf to cf' to obtain the satisfying assignment for  <span class="math">\\phi</span>  as follows: define</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathrm{st}_0,D_0\\right)\\coloneqq \\mathrm{cf},\\quad \\left(\\mathrm{tree}_0,\\mathrm{rt}_0\\right)\\coloneqq \\mathrm{HT.Hash}(\\mathrm{dk},D_0),\\quad \\mathrm{h}_0\\coloneqq \\left(\\mathrm{st}_0,\\mathrm{rt}_0\\right)</span></p>

    <p class="text-gray-300">Then for every  <span class="math">i\\in [T]</span></p>

    <p class="text-gray-300"><span class="math">\\ell_{i} = \\mathrm{StepR}(\\mathrm{st}_{i - 1}),\\quad (b_{i},\\Pi_{i})\\coloneqq \\mathrm{HT.Read}(\\mathrm{tree}_{i - 1},\\ell_{i})</span> <span class="math">(b_i&#x27;, \\ell_i&#x27;, \\mathrm{st}_i) := \\mathrm{StepW}(\\mathrm{st}_{i-1}, b_i), \\quad (\\mathrm{tree}_i, \\mathrm{rt}_i, \\Pi_i&#x27;) := \\mathrm{HT.Read}(\\mathrm{tree}_{i-1}, \\ell_i&#x27;, b_i&#x27;)</span> <span class="math">\\mathrm{h}_i\\coloneqq (\\mathrm{st}_i,\\mathrm{rt}_i)</span></p>

    <p class="text-gray-300">and then compute (efficiently)  <span class="math">w_{i}</span>  be such that  <span class="math">\\varphi_{i}(\\mathsf{h}_{i - 1},\\mathsf{h}_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},w_{i}) = 1</span> .</p>

    <p class="text-gray-300">Compute the no-signaling commitment to  <span class="math">(\\mathsf{h}_0,\\{\\mathsf{h}_i,\\Pi_i,\\Pi_i&#x27;,w_i\\}_{i\\in [T]})</span></p>

    <p class="text-gray-300"><span class="math">c\\gets \\mathrm{Com}\\left(K,\\left(\\mathsf{h}_0,\\left\\{\\mathsf{h}_i,b_i,\\Pi_i,\\Pi_i&#x27;,w_i\\right\\}_{i\\in [T]}\\right);R\\right)</span></p>

    <p class="text-gray-300">For every  <span class="math">i\\in [T]</span>  , compute the local opening to the commitment:</p>

    <p class="text-gray-300">For  <span class="math">A\\in \\{\\mathsf{h}_{i - 1},\\mathsf{h}_i,b_i,\\Pi_i,\\Pi_i&#x27;,w_i\\}</span></p>

    <p class="text-gray-300"><span class="math">\\rho_{A}\\coloneqq \\mathrm{Open}(K,A,R)^{\\delta}</span></p>

    <p class="text-gray-300">Compute the circuit  <span class="math">C_{\\mathrm{index}}</span>  as described in Figure 6, and then compute the proof of the underlying BARG</p>

    <p class="text-gray-300"><span class="math">\\Pi \\coloneqq \\mathrm{BARG.P}\\left(\\mathrm{crs},C_{\\mathrm{index}},\\left\\{\\mathsf{h}_{i - 1},\\mathsf{h}_i,b_i,\\Pi_i,\\Pi_i&#x27;,w_i,\\rho_{\\mathsf{h}_{i - 1}},\\rho_{\\mathsf{h}_i},\\rho_{\\Pi_i},\\rho_{\\Pi_i&#x27;},\\rho_{\\mathsf{w}_i}\\right\\}_{i\\in [T]}\\right)</span></p>

    <p class="text-gray-300">Output  <span class="math">(c,\\Pi)</span></p>

    <p class="text-gray-300">RDel.V(vk,h,h',Π): Given  <span class="math">c</span>  and  <span class="math">K</span> , compute  <span class="math">C_{\\mathrm{index}}</span>  (as in Figure 6) and output 1 if and only if</p>

    <p class="text-gray-300">BARG.V (crs,  <span class="math">C_{\\mathrm{index}}, \\Pi) = 1</span></p>

    <p class="text-gray-300">Figure 5: RAM delegation scheme</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier circuit for commitment of size  <span class="math">\\mathrm{poly}(\\lambda, \\log M) = \\mathrm{poly}(\\lambda, \\log T)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CRS size. The CRS consists of the commitment key  <span class="math">K</span> , the BARG CRS crs and the digest key  <span class="math">\\mathrm{dk}</span> . By the corresponding properties of the underlying scheme we have:  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{dk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda, \\log T) +$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hardwired:  <span class="math">K, c, \\varphi</span></p>

    <p class="text-gray-300">Input:  <span class="math">i, h_{i-1}, h_i, b_i, \\Pi_i, \\Pi_i&#x27;, w_i, \\rho_{h_{i-1}}, \\rho_{h_i}, \\rho_{b_i}, \\rho_{\\Pi_i}, \\rho_{\\Pi_i&#x27;}, \\rho_{w_i}</span></p>

    <p class="text-gray-300">Output: Output 1 if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify commitment openings:</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\operatorname{Verify}(K, c, h_{i-1}, \\rho_{h_{i-1}}) = 1^9</span></p>

    <p class="text-gray-300">(d) Verify  <span class="math">(K, c, \\Pi_i, \\rho_{\\Pi_i}) = 1</span></p>

    <p class="text-gray-300">(b)  <span class="math">\\operatorname{Verify}(K, c, h_i, \\rho_{h_i}) = 1</span></p>

    <p class="text-gray-300">(e) Verify  <span class="math">(K, c, \\Pi_i&#x27;, \\rho_{\\Pi_i&#x27;}) = 1</span></p>

    <p class="text-gray-300">(c)  <span class="math">\\operatorname{Verify}(K, c, b_i, \\rho_{b_i}) = 1</span></p>

    <p class="text-gray-300">(f) Verify  <span class="math">(K, c, w_i, \\rho_{w_i}) = 1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\varphi_{i}(h_{i - 1},h_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},w_{i}) = 1</span></li>

    </ol>

    <p class="text-gray-300">Figure 6: Circuit</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{poly}(\\lambda ,\\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\lambda ,\\log T).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof length. The proof consists of the commitment  <span class="math">c</span>  and the BARG proof:  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\lambda, \\log T) + \\mathrm{poly}(\\lambda, \\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\lambda, \\log T)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time: The verification time is the time taken to compute the circuit  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and verify the BARG proof:  </span>\\mathrm{poly}(\\lambda, \\log T,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\lambda, \\log T)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let us assume for the sake of contradiction that the soundness of the above scheme does not hold. Then fix  <span class="math">\\mathcal{A}</span>  and  <span class="math">T</span>  such that there exists a polynomial  <span class="math">\\mathfrak{p}(\\cdot)</span>  where, for infinitely many values of  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} \\mathrm {R D e l . V} (\\mathrm {v k}, \\mathrm {h}, \\mathrm {h} ^ {\\prime}, \\Pi) = 1 &amp;amp; (\\mathrm {p k}, \\mathrm {v k}, \\mathrm {d k}) \\leftarrow \\mathrm {R D e l . S} (1 ^ {\\lambda}, T, n) \\\\ (\\lambda , \\mathrm {c f}, \\mathrm {c f} ^ {\\prime}, T) \\in \\mathcal {U} _ {\\mathcal {R}} &amp;amp; (\\mathrm {c f}, \\mathrm {c f} ^ {\\prime}, \\mathrm {h}, \\mathrm {h} ^ {\\prime}, \\Pi) \\leftarrow \\mathcal {A} (\\mathrm {p k}, \\mathrm {v k}, \\mathrm {d k}) \\end{array} \\right] \\geq \\frac {1}{\\mathrm {p} (\\lambda)}. \\tag {4}</span></div>

    <p class="text-gray-300">We now use an averaging argument to fix a bad digest key  <span class="math">\\mathrm{dk}</span> . Specifically, a digest key  <span class="math">\\mathrm{dk}</span>  is bad if Equation (4) holds with probability at least  <span class="math">1 / 2\\mathrm{p}(\\lambda)</span>  when  <span class="math">\\mathrm{dk}</span>  is sampled by RDel.S. By an averaging argument the fraction of such bad digest keys must be at least  <span class="math">1 / 2\\mathrm{p}(\\lambda)</span> . Therefore, conditioned on a fixed bad digest key  <span class="math">\\mathrm{dk}^*</span>  we have,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l l} \\mathrm {R D e l . V} (\\mathrm {v k}, \\mathrm {h}, \\mathrm {h} ^ {\\prime}, \\Pi) = 1 &amp; (\\mathrm {p k}, \\mathrm {v k}, \\mathrm {d k}) \\leftarrow \\mathrm {R D e l . S} (1 ^ {\\lambda}, T, n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\mathrm {d k} = \\mathrm {d k} ^ {<em>}} \\\\ (\\lambda , \\mathrm {c f}, \\mathrm {c f} ^ {\\prime}, T) \\in \\mathcal {U} _ {\\mathcal {R}} &amp; (\\mathrm {c f}, \\mathrm {c f} ^ {\\prime}, \\mathrm {h}, \\mathrm {h} ^ {\\prime}, \\Pi) \\leftarrow \\mathcal {A} (\\mathrm {p k}, \\mathrm {v k}, \\mathrm {d k} ^ {</em>}) \\end{array} \\right] \\geq \\frac {1}{\\mathrm {p} (\\lambda)}. \\tag {5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})\\gets \\mathrm{RDel.S}(1^{\\lambda},T,n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{dk} = \\mathrm{dk}^{<em>}}<span class="math">  is the setup algorithm RDel.S conditioned on the digest key output being  </span>\\mathrm{dk}^</em><span class="math"> . Moving forward, for ease of notation, the fixed bad  </span>\\mathrm{dk}^*<span class="math">  will be denoted simply by  </span>\\mathrm{dk}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we change the setup algorithm in both the underlying commitment scheme (NS-SECOM) and the batch argument (BARG) to be the trapdoor setup algorithm with the <span class="math">\\emptyset</span> as the argument. We want to argue that the distribution of <span class="math">\\mathcal{A}</span>’s output (cf, cf’, h, h’) does not change by more than a negligible probability. Specifically,</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Claim 3.</h6>

    <p class="text-gray-300">For all <span class="math">\\mathrm{PPT}</span> distinguisher <span class="math">\\mathcal{D}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\begin{array}[]{c}\\mathcal{D}(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})=1\\end{array}\\right.\\right.<span class="math"> </span>\\left.\\left.\\begin{array}[]{c}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})\\leftarrow\\mathrm{RDel.S}(1^{\\lambda},T,n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{dk}}\\cr(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})\\end{array}\\right.\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})\\end{array}\\right.\\right]\\right]\\leq\\mathrm{negl}(\\lambda).$ (6)</p>

    <p class="text-gray-300">where in each experiment above <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})=\\bot</span> if <span class="math">\\mathrm{RDel.V}(\\mathrm{vk},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)=0</span>.</p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider <span class="math">\\mathrm{Hyb}_{0}</span> to be the experiment</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})</span> $\\leftarrow\\mathrm{RDel.S}(1^{\\lambda},T,n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{dk}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})</span></p>

    <p class="text-gray-300">with output <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})</span>. Similarly, <span class="math">\\mathrm{Hyb}_{1}</span> is the experiment</p>

    <p class="text-gray-300"><span class="math">K\\leftarrow\\mathrm{TGen}(1^{\\lambda},1^{M},\\emptyset)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{crs}\\leftarrow\\mathrm{BARG.TGen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\emptyset)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{pk}\\coloneqq(K,\\mathrm{crs},\\mathrm{dk}),\\ \\mathrm{vk}\\coloneqq(K,\\mathrm{crs})</span> <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk})</span></p>

    <p class="text-gray-300">with output <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})</span>. It then suffices to show that <span class="math">\\mathrm{Hyb}_{0}\\approx\\mathrm{Hyb}_{1}</span>. For this we introduce an intermediate hybrid <span class="math">\\mathrm{Hyb}^{\\prime}</span> that has the same output, but the experiment is:</p>

    <p class="text-gray-300"><span class="math">K\\leftarrow\\mathrm{Gen}(1^{\\lambda},1^{M})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{crs}\\leftarrow\\mathrm{BARG.TGen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\emptyset)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{pk}\\coloneqq(K,\\mathrm{crs},\\mathrm{dk}),\\ \\mathrm{vk}\\coloneqq(K,\\mathrm{crs})</span> <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk}).</span></p>

    <p class="text-gray-300">Note that for all of the above experiments, set <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)</span> to <span class="math">\\bot</span> if <span class="math">\\Pi</span> is not accepting.</p>

    <p class="text-gray-300">We now prove the following:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Hyb}_{0}\\approx\\mathrm{Hyb}^{\\prime}</span>: We rely on the <em>key-indistinguishability</em> property of the BARG scheme. Specifically, if there exists a <span class="math">\\mathrm{PPT}</span> distinguisher <span class="math">\\mathcal{D}</span> that distinguishes <span class="math">\\mathrm{Hyb}_{0}</span> and <span class="math">\\mathrm{Hyb}^{\\prime}</span>, we can construct an adversary <span class="math">\\mathcal{B}</span> (with a bad <span class="math">\\mathrm{dk}</span> as an additional argument) as below,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(1^{\\lambda},\\mathrm{dk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">\\emptyset</span> to the BARG key indistinguishability.</li>

      <li>On obtaining <span class="math">\\mathrm{crs}</span> from the challenger, run the rest of the experiment.</li>

      <li>Check if <span class="math">\\Pi</span> is accepting. If not, set <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\Pi)</span> to <span class="math">\\bot</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\mathcal{D}(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">Depending on the response received from the challenger, the experiment corresponds either to <span class="math">\\mathrm{Hyb}_{0}</span> or <span class="math">\\mathrm{Hyb}^{\\prime}</span>, and <span class="math">\\mathcal{B}</span> succeeds if <span class="math">\\mathcal{D}</span> succeeds.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Hyb}^{\\prime}\\approx\\mathrm{Hyb}_{1}</span>: We rely on the <em>key-indistinguishability</em> property of the NS-SECOM scheme. The proof follows identically as in the above case.</p>

    <p class="text-gray-300">This completes the proof. ∎</p>

    <p class="text-gray-300">If <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})\\neq\\bot</span>, i.e. the proof is accepting, then starting with configuration <span class="math">\\mathrm{cf}</span> we define the “<em>true</em>” configuration <span class="math">\\overline{\\mathrm{cf}}_{i}</span> after <span class="math">i</span>-steps of computation. Formally, for each <span class="math">i\\in[0,T]</span>, <span class="math">\\overline{\\mathrm{cf}}_{i}</span> is the <em>unique configuration</em> such that <span class="math">(\\lambda,\\mathrm{cf},\\overline{\\mathrm{cf}}_{i},i)\\in\\mathcal{U}_{R}</span>. The corresponding digest <span class="math">\\overline{\\mathrm{h}}_{i}</span> is defined to be <span class="math">\\mathrm{RDel.D}(\\mathrm{dk},\\overline{\\mathrm{cf}}_{i})</span>. We will refer to such configurations (resp. digests) to be the “true” configuration (resp. digest). We define below the event and experiment that will be relevant to the analysis.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{CHEAT}</span>: The event that <span class="math">\\mathrm{BARG.Vf}(\\mathrm{crs},C_{\\mathrm{index}},\\pi)=1</span>, and <span class="math">\\mathrm{h}=\\overline{\\mathrm{h}}_{0}</span> but <span class="math">\\mathrm{h}^{\\prime}\\neq\\overline{\\mathrm{h}}_{T}</span>.</li>

      <li><span class="math">\\mathrm{EXP}_{i}</span>: Let <span class="math">S_{i}</span> denote the set of <span class="math">\\phi</span>’s variables that represent the variables for the <span class="math">i</span>-th clause - <span class="math">\\mathrm{h}_{i-1},\\mathrm{h}_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},w_{i}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{EXP}_{i}</span> then corresponds to the experiment where the keys for the commitment scheme and the batch argument are generated with trapdoor for <span class="math">S_{i}</span> and <span class="math">i</span> respectively. More formally</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$K\\leftarrow\\mathrm{TGen}(1^{\\lambda},1^{M},S_{i}),\\ \\mathrm{crs}\\leftarrow\\mathrm{BARG.TGen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},i)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If the proof <span class="math">\\pi</span> is non-accepting, the output of the experiment is <span class="math">\\bot</span>. Otherwise the output is <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})</span> along with the extracted value</p>

    <p class="text-gray-300">We claim that in the above experiment, the adversary still cheats with an inverse polynomial probability.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Claim 4.</h6>

    <p class="text-gray-300">For all <span class="math">i\\in[T]</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}_{\\mathrm{EXP}_{i}}[\\mathrm{CHEAT}]\\geq\\frac{1}{\\mathrm{poly}(\\lambda)}</span> (7)</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows in an identical manner to Claim 3 from the key indistinguishability of the underlying schemes, and the fact that the event <span class="math">\\mathrm{CHEAT}</span> is efficiently checkable. ∎</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Claim 5.</h6>

    <p class="text-gray-300">For all <span class="math">i\\in[T]</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}_{\\mathrm{EXP}_{i}}\\big{[}\\ \\mathrm{CHEAT}\\implies\\varphi_{i}(\\mathrm{h}_{i-1},\\mathrm{h}_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},w_{i})=1\\ \\ \\big{]}\\geq 1-\\mathrm{negl}(\\lambda)</span> (8)</p>

    <p class="text-gray-300">where <span class="math">\\mathrm{h}_{i-1},\\mathrm{h}_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},w_{i}</span> is extracted from the commitment using the trapdoor.</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Given that <span class="math">\\mathrm{CHEAT}</span> holds, we know that the proof <span class="math">\\Pi</span> output by <span class="math">\\mathcal{A}</span> is accepting. We first use the semi-adaptive somewhere soundness of the <span class="math">\\mathrm{BARG}</span> to show that the <span class="math">(C_{\\mathrm{index}},i)\\in\\mathcal{L}</span>. If not, we construct an adversary <span class="math">\\mathcal{B}</span> as below</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(1^{\\lambda},\\mathrm{dk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">i</span> to the <span class="math">\\mathrm{BARG}</span> challenger and receive <span class="math">\\mathrm{crs}</span>.</li>

      <li>Compute the rest of the experiment <span class="math">\\mathrm{EXP}_{i}</span> using <span class="math">\\mathrm{crs}</span>.</li>

      <li>Return <span class="math">(C_{\\mathrm{index}},\\Pi)</span></li>

    </ol>

    <p class="text-gray-300">Thus, we have <span class="math">(C_{\\mathrm{index}},i)\\in\\mathcal{L}</span> which means that there is an accepting witness to <span class="math">C_{\\mathrm{index}}</span> in Figure 6. Now, from the somewhere statistical binding property of the NS-SECOM for <span class="math">S_{i}</span>, we have that other than with negligible probability the extracted values <span class="math">(h_{i-1},h_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i})</span> (along with their opening proofs) are the only valid local openings to <span class="math">c</span> on <span class="math">S_{i}</span>. Therefore, since <span class="math">(C_{\\mathrm{index}},i)\\in\\mathcal{L}</span> and <span class="math">(h_{i-1},h_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i})</span> is the only valid opening to <span class="math">c</span> we have that other than with negligible probability, <span class="math">C_{\\mathrm{index}}</span> for index <span class="math">i</span> has a <em>unique</em> (partial) witness <span class="math">(h_{i-1},h_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i})</span>.</p>

    <p class="text-gray-300">This in turn implies (by the construction of <span class="math">C_{\\mathrm{index}}</span>), we have <span class="math">\\varphi_{i}(h_{i-1},h_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i})=1</span>. ∎</p>

    <p class="text-gray-300">Therefore we have</p>

    <p class="text-gray-300">\\[ \\Pr_{\\mathrm{EXP}_{i}}\\left[\\begin{array}[]{c}\\mathrm{CHEAT}\\wedge\\\\ \\varphi_{i}(h_{i-1},h_{i},b_{i},\\Pi_{i},\\Pi^{\\prime}_{i},w_{i})=0\\end{array}\\right]<\\mathrm{negl}(\\lambda) \\] (9)</p>

    <p class="text-gray-300">In <span class="math">\\mathrm{EXP}_{1}</span>, <span class="math">\\varphi_{1}</span> is consistent with <span class="math">h</span>, therefore <span class="math">h=h_{0}</span> which gives us,</p>

    <p class="text-gray-300">\\[ \\Pr_{\\mathrm{EXP}_{1}}\\left[\\begin{array}[]{c}\\mathrm{CHEAT}\\wedge\\\\ h_{0}\\neq\\overline{h}_{0}\\end{array}\\right]<\\mathrm{negl}(\\lambda) \\] (10)</p>

    <p class="text-gray-300">In <span class="math">\\mathrm{EXP}_{T}</span>, <span class="math">\\varphi_{T}</span> is consistent with <span class="math">h^{\\prime}</span>, therefore <span class="math">h^{\\prime}=h_{T}</span> which, because the adversary is cheating, gives us</p>

    <p class="text-gray-300">\\[ \\Pr_{\\mathrm{EXP}_{T}}\\left[\\begin{array}[]{c}\\mathrm{CHEAT}\\wedge\\\\ h_{T}=\\overline{h}_{T}\\end{array}\\right]<\\mathrm{negl}(\\lambda) \\] (11)</p>

    <p class="text-gray-300">We now want to use the no-signaling property to claim that in both <span class="math">\\mathrm{EXP}_{i}</span> and <span class="math">\\mathrm{EXP}_{i+1}</span> it must be the case that the extracted <span class="math">h_{i}</span> is the corresponding “true” digest at the <span class="math">i</span>-step of the execution.</p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Claim 6.</h6>

    <p class="text-gray-300">For all <span class="math">i\\in[T-1]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{\\mathrm{EXP}_{i}}\\left[\\begin{array}[]{c}\\mathrm{CHEAT}\\wedge\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">h_{i}=\\overline{h}_{i}\\end{array}\\right]-\\Pr_{\\mathrm{EXP}_{i+1}}\\left[\\begin{array}[]{c}\\mathrm{CHEAT}\\wedge\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{i}=\\overline{h}_{i}\\end{array}\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\mathrm{negl}(\\lambda)$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-122" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We will prove this using a sequence of hybrids. Let <span class="math">\\mathrm{Hyb}_{0}</span> be the distribution in <span class="math">\\mathrm{EXP}_{i}</span> with output <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},h,h^{\\prime},h_{i})</span> where <span class="math">h_{i}</span> is extracted from the NS-SECOM commitment scheme using the trapdoor for <span class="math">S_{i}</span>. Similarly, let <span class="math">\\mathrm{Hyb}_{1}</span> be the distribution in <span class="math">\\mathrm{EXP}_{i}</span> with output <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},h,h^{\\prime},h_{i})</span> where <span class="math">h_{i}</span> is extracted from the NS-SECOM commitment scheme using the trapdoor for <span class="math">S_{i+1}</span>.</p>

    <p class="text-gray-300">It suffices to show these two distributions are indistinguishable since given <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},h,h^{\\prime},h_{i})</span> one can compute <span class="math">\\overline{h}_{i}</span> and check if <span class="math">\\overline{h}_{i}=h_{i}</span>. If the probability of the check succeeded differed in the <span class="math">\\mathrm{Hyb}_{0}</span> and <span class="math">\\mathrm{Hyb}_{1}</span> by a non-negligible amount, we would have an efficient distinguisher.</p>

    <p class="text-gray-300">We introduce an intermediate distribution <span class="math">\\mathrm{Hyb}^{\\prime}</span> where the experiment is:</p>

    <p class="text-gray-300"><span class="math">K</span> <span class="math">\\leftarrow\\mathrm{TGen}(1^{\\lambda},1^{M},S_{i+1})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathrm{crs}</span> $\\leftarrow\\mathrm{BARG.TGen}(1^{\\lambda},1^{T},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{\\mathrm{index}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},i)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathrm{pk}</span> <span class="math">\\coloneqq(K,\\mathrm{crs},\\mathrm{dk}),\\ \\mathrm{vk}\\coloneqq(K,\\mathrm{crs})</span> <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},h,h^{\\prime},\\Pi)</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathrm{pk},\\mathrm{vk},\\mathrm{dk}).</span></p>

    <p class="text-gray-300">with the output being <span class="math">(\\mathrm{cf},\\mathrm{cf}^{\\prime},h,h^{\\prime},h_{i})</span>.</p>

    <p class="text-gray-300">We rely on the <em>no-signaling</em> property of the commitment scheme NS-SECOM. Specifically, if there exists a <span class="math">\\mathrm{PPT}</span> distinguisher <span class="math">\\mathcal{D}</span> that distinguishes <span class="math">\\mathrm{Hyb}_{0}</span> and <span class="math">\\mathrm{Hyb}^{\\prime}</span>, we can construct an adversary <span class="math">\\mathcal{B}=(\\mathcal{B}_{1},\\mathcal{B}_{2})</span> (with a bad <span class="math">\\mathrm{dk}</span> as non-uniform advice) as below,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{1}(1^{\\lambda},\\mathrm{dk})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input <span class="math">K</span>, run the rest of the experiment with <span class="math">K</span> as the NS-SECOM key.</li>

      <li>Separate <span class="math">c</span> from <span class="math">\\mathcal{A}</span>’s proof.</li>

      <li>Set <span class="math">z\\coloneqq(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime})</span> as the auxiliary input, setting <span class="math">z</span> to <span class="math">\\bot</span> if <span class="math">\\Pi</span> is not accepting.</li>

      <li>Output <span class="math">(c,z)</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{B}_{2}(1^{\\lambda},\\mathrm{dk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input <span class="math">K,c,z,\\mathrm{h}_{i}</span>, output <span class="math">\\mathcal{D}(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\mathrm{h}_{i})</span>.</li>

    </ol>

    <p class="text-gray-300">Depending on the response received from the challenger, the experiment corresponds either to <span class="math">\\mathrm{Hyb}_{0}</span> or <span class="math">\\mathrm{Hyb}^{\\prime}</span>, and <span class="math">\\mathcal{B}</span> succeeds if <span class="math">\\mathcal{D}</span> succeeds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We rely on the <em>key-indistinguishability</em> property of the BARG scheme. Specifically, if there exists a PPT distinguisher <span class="math">\\mathcal{D}</span> that distinguishes <span class="math">\\mathrm{Hyb}^{\\prime}</span> and <span class="math">\\mathrm{Hyb}_{0}</span> we construct an adversary <span class="math">\\mathcal{B}</span> (with a bad <span class="math">\\mathrm{dk}</span> as non-uniform advice) as below,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(1^{\\lambda},\\mathrm{dk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">i,i+1</span> to the BARG key indistinguishability challenger.</li>

      <li>On receiving <span class="math">\\mathrm{crs}</span> run the rest of the experiment using received <span class="math">\\mathrm{crs}</span>.</li>

      <li>Use the NS-SECOM to extract <span class="math">\\mathrm{h}_{i}</span>.</li>

      <li>Output <span class="math">\\mathcal{D}(\\mathrm{cf},\\mathrm{cf}^{\\prime},\\mathrm{h},\\mathrm{h}^{\\prime},\\mathrm{h}_{i})</span>.</li>

    </ol>

    <p class="text-gray-300">Note that we have directly reduced to the key indistinguishability of the BARG between keys generated for <span class="math">i</span> and <span class="math">i+1</span>, while our security definition only states that it is computationally intractable to differentiate between the key generated in the normal mode, and the key generated for an index <span class="math">i</span>. It is easy to see that our definition also implies key indistinguishability on any two inputs <span class="math">i</span> and <span class="math">j</span> (with the normal mode as the intermediate hybrid experiment).</p>

    <p class="text-gray-300">This completes the proof. ∎</p>

    <p class="text-gray-300">From the above equations, given that <span class="math">\\mathrm{h}_{T}\\neq\\overline{\\mathrm{h}}_{T}</span> (other than with negligible probability), it must be the case that there exists an <span class="math">i^{<em>}</span> such that the input digest is “true”, while the output digest is not “true”. Formally, from equations (7) to (12), we have that there exists <span class="math">i^{</em>}\\in[T]</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr_{\\mathrm{EXP}_{i^{<em>}}}\\left[\\begin{array}[]{l}\\mathrm{CHEAT}\\wedge\\\\ \\mathrm{h}_{i^{</em>}-1}=\\overline{\\mathrm{h}}_{i^{<em>}-1}\\wedge\\\\ \\mathrm{h}_{i^{</em>}}\\neq\\overline{\\mathrm{h}}_{i^{<em>}}\\wedge\\\\ \\varphi_{i}(\\mathrm{h}_{i^{</em>}-1},\\mathrm{h}_{i^{<em>}},\\mathrm{b}_{i^{</em>}},\\Pi_{i^{<em>}},\\Pi^{\\prime}_{i^{</em>}},\\mathrm{w}_{i^{*}})=1\\end{array}\\right]\\geq\\frac{1}{T\\cdot\\mathrm{poly}(\\lambda)}=\\frac{1}{\\mathrm{poly}(\\lambda)} \\] (13)</p>

    <p class="text-gray-300">Let <span class="math">i\\coloneqq i^{*}</span> as described above. Then for <span class="math">(\\mathrm{st}_{i-1},\\mathrm{rt}_{i-1})\\coloneqq\\mathrm{h}_{i-1}</span>,</p>

    <p class="text-gray-300"><span class="math">\\ell_{i}</span> <span class="math">\\coloneqq\\mathrm{StepR}(\\mathrm{st}_{i-1})</span> <span class="math">(b^{\\prime}_{i},\\ell^{\\prime}_{i},\\mathrm{st}_{i})</span> <span class="math">\\coloneqq\\mathrm{StepW}(\\mathrm{st}_{i-1},b_{i})</span></p>

    <p class="text-gray-300">Next, compute the corresponding “true” variables starting from <span class="math">(\\overline{\\mathrm{st}}_{i-1},\\overline{D}_{i-1})\\coloneqq\\overline{\\mathrm{cf}}_{i-1}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\overline{\\mathrm{tree}}_{i},\\overline{\\mathrm{rt}}_{i})</span> <span class="math">\\coloneqq\\mathrm{HT.Hash}(\\mathrm{dk},\\overline{D}_{i-1})</span> <span class="math">\\overline{\\ell}_{i}</span> <span class="math">\\coloneqq\\mathrm{StepR}(\\overline{\\mathrm{st}}_{i-1})</span> <span class="math">(\\overline{b}_{i},\\overline{\\Pi}_{i})</span> <span class="math">\\coloneqq\\mathrm{HT.Read}(\\overline{\\mathrm{tree}}_{i-1},\\overline{\\ell}_{i})</span> <span class="math">(\\overline{b}_{i}^{\\prime},\\overline{\\ell}_{i}^{\\prime},\\overline{\\mathrm{st}}_{i})</span> <span class="math">\\coloneqq\\mathrm{StepW}(\\overline{\\mathrm{st}}_{i-1},\\overline{b}_{i})</span> <span class="math">(\\overline{\\mathrm{tree}}_{i},\\overline{\\mathrm{rt}}_{i},\\overline{\\Pi}_{i}^{\\prime})</span> <span class="math">\\coloneqq\\mathrm{HT.Read}(\\overline{\\mathrm{tree}}_{i-1},\\overline{\\ell}_{i}^{\\prime},\\overline{b}_{i}^{\\prime})</span></p>

    <p class="text-gray-300">We describe two events below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the event that the following is true</li>

    </ul>

    <p class="text-gray-300"><span class="math">b_{i}\\neq\\overline{b}_{i}</span> <span class="math">\\mathrm{HT.VerRead}(\\mathrm{dk},\\mathrm{rt}_{i-1},\\ell_{i},b_{i},\\Pi_{i})=1</span> <span class="math">\\mathrm{HT.VerRead}(\\mathrm{dk},\\mathrm{rt}_{i-1},\\ell_{i},\\overline{b}_{i},\\overline{\\Pi}_{i})=1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the event that the following is true</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{rt}_{i}\\neq\\overline{\\mathrm{rt}}_{i}</span> <span class="math">\\mathrm{HT.VerWrite}(\\mathrm{dk},\\mathrm{rt}_{i-1},\\ell_{i}^{\\prime},b_{i}^{\\prime},\\mathrm{rt}_{i}^{\\prime},\\Pi_{i}^{\\prime})=1</span> <span class="math">\\mathrm{HT.VerWrite}(\\mathrm{dk},\\mathrm{rt}_{i-1},\\ell_{i}^{\\prime},b_{i}^{\\prime},\\overline{\\mathrm{rt}}_{i}^{\\prime},\\overline{\\Pi}_{i}^{\\prime})=1</span></p>

    <p class="text-gray-300">As observed in <em>[x20]</em>, the following claim establishes that by the completeness of the hash tree scheme, either the read or the write operation. We have reproduced the proof here for completeness.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Claim 7.</h6>

    <p class="text-gray-300">\\[ \\Pr_{\\mathrm{EXP}_{i}}\\left[\\begin{array}[]{l}\\mathrm{CHEAT}\\wedge\\\\ \\mathrm{h}_{i-1}=\\overline{\\mathrm{h}}_{i-1}\\wedge\\\\ \\mathrm{h}_{i}\\neq\\overline{\\mathrm{h}}_{i}\\wedge\\\\ \\varphi_{i}(\\mathrm{h}_{i-1},\\mathrm{h}_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},\\mathrm{w}_{i})=1\\end{array}\\right]\\Longrightarrow\\mathrm{CHEAT}_{1}\\vee\\mathrm{CHEAT}_{2} \\] (14)</p>

    <h6 id="sec-124" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows from the completeness of the hash tree scheme. Specifically, by definition, we have that <span class="math">\\overline{\\mathrm{h}}_{i-1}=(\\overline{\\mathrm{st}}_{i-1},\\overline{\\mathrm{rt}}_{i-1})</span> and <span class="math">\\overline{\\mathrm{h}}_{i}=(\\overline{\\mathrm{st}}_{i},\\overline{\\mathrm{rt}}_{i})</span>. By the completeness of the hash tree scheme we have,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{HT.VerRead}(\\mathrm{dk},\\overline{\\mathrm{rt}}_{i-1},\\overline{\\ell}_{i},\\overline{b}_{i},\\overline{\\Pi}_{i})=1</span> <span class="math">\\mathrm{HT.VerWrite}(\\mathrm{dk},\\overline{\\mathrm{rt}}_{i-1},\\overline{\\ell}_{i}^{\\prime},\\overline{b}_{i}^{\\prime},\\overline{\\mathrm{rt}}_{i}^{\\prime},\\overline{\\Pi}_{i}^{\\prime})=1</span></p>

    <p class="text-gray-300">Now from the claim, we have that <span class="math">\\mathrm{h}_{i-1}=\\overline{\\mathrm{h}}_{i-1}</span>, which means that <span class="math">(\\mathrm{st}_{i-1},\\mathrm{rt}_{i-1})=(\\overline{\\mathrm{st}}_{i-1},\\overline{\\mathrm{rt}}_{i-1})</span>. Since StepR is a deterministic algorithm, we also have <span class="math">\\ell_{i}=\\overline{\\ell}_{i}</span>. Finally, since <span class="math">\\varphi_{i}(\\mathrm{h}_{i-1},\\mathrm{h}_{i},b_{i},\\Pi_{i},\\Pi_{i}^{\\prime},\\mathrm{w}_{i})=1</span> we have,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{h}_{i}=(\\mathrm{st}_{i},\\mathrm{rt}_{i})</span> <span class="math">\\mathrm{HT.VerRead}(\\mathrm{dk},\\mathrm{rt}_{i-1},\\ell_{i},b_{i},\\Pi_{i})=1</span> <span class="math">\\mathrm{HT.VerWrite}(\\mathrm{dk},\\mathrm{rt}_{i-1},\\ell_{i}^{\\prime},b_{i}^{\\prime},\\mathrm{rt}_{i}^{\\prime},\\Pi_{i}^{\\prime})=1</span></p>

    <p class="text-gray-300">We consider two cases below to complete the proof. Note that in both the cases, the required proofs from the events verify, so we omit them in the discussion below.</p>

    <p class="text-gray-300"><span class="math">b_{i}\\neq\\overline{b}_{i}</span>: <span class="math">\\text{CHEAT}_{1}</span> holds. <span class="math">b_{i}\\neq\\overline{b}_{i}</span>: Then, because StepW is deterministic, we have that <span class="math">(\\ell_{i}^{\\prime},b_{i}^{\\prime},\\text{st}_{i})=(\\overline{\\ell}_{i}^{\\prime},\\overline{b}_{i}^{\\prime},\\overline{\\text{st}}_{i})</span> . Combining this with the fact that <span class="math">h_{i}\\neq\\overline{h}_{i}</span>, it must be the case that <span class="math">rt_{i}\\neq\\overline{rt}_{i}</span>. This ensures that <span class="math">\\text{CHEAT}_{2}</span> holds in this case.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">From the above claims, since <span class="math">\\text{CHEAT}_{1}\\vee\\text{CHEAT}_{2}</span> happens with probability <span class="math">1/\\text{poly}(\\lambda)</span>. We can now construct an adversary <span class="math">\\mathcal{B}</span> for the hash tree scheme that breaks either the soundness of read (when <span class="math">\\text{CHEAT}_{1}</span> holds) or the soundness of write (when <span class="math">\\text{CHEAT}_{2}</span> holds). Specifically,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(1^{\\lambda})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive dk from the HT challenger.</li>

      <li>Runs <span class="math">\\text{EXP}_{i}</span> (from the above claim either <span class="math">\\text{CHEAT}_{1}</span> or <span class="math">\\text{CHEAT}_{2}</span> hold).</li>

      <li>If <span class="math">\\text{CHEAT}_{1}</span> holds, output <span class="math">(rt_{i-1},\\ell_{i},b_{i},\\Pi_{i},\\overline{b}_{i},\\overline{\\Pi}_{i})</span>.</li>

      <li>Else, if <span class="math">\\text{CHEAT}_{2}</span> holds, output <span class="math">(dk,rt_{i-1},\\ell_{i}^{\\prime},b_{i}^{\\prime},rt_{i}^{\\prime},\\overline{rt}_{i}^{\\prime},\\overline{\\Pi}_{i}^{\\prime})</span></li>

    </ol>

    <p class="text-gray-300">Correctness follows from the description of the events. Since we have that the received <span class="math">dk</span> is <em>bad</em> with probability <span class="math">1/2p(\\lambda)</span>, <span class="math">\\mathcal{B}</span> successfully breaks the soundness of the hash tree scheme. This completes the security proof.</p>

    <h2 id="sec-125" class="text-2xl font-bold">6 More Efficient Batch Arguments for NP</h2>

    <p class="text-gray-300">In this section, we show how to use batch arguments for NP and the Turing machine delegation scheme to build more efficient batch arguments for NP by removing the dependence on the circuit size. The idea is to delegate the verification of an NP instance to the Turing machine, and then use the batch argument to prove that the verifier in the delegation scheme will accept the delegation proof for all instances.</p>

    <p class="text-gray-300">In more detail, we use batch arguments for SAT and a Turing machine delegation scheme to construct BARGs for the following NP language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}=\\{x\\mid\\exists\\omega:\\mathcal{M}(x,\\omega)\\text{ outputs }1\\text{ (accepts) in }T\\text{ steps}\\},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathcal{M}</span> is a Turing machine. The proof size and CRS size are polynomial in $\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\log T$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-126" class="text-base font-medium mt-4">Theorem 12.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\text{Del}=(\\text{Del.S},\\text{Del.P},\\text{Del.V})</span> be a Turing machine delegation scheme, and <span class="math">\\text{BARG}^{\\prime}=(\\text{BARG}^{\\prime}.\\text{Gen},\\text{BARG}^{\\prime}.\\text{TGen},\\text{BARG}^{\\prime}.\\text{P},\\text{BARG}^{\\prime}.\\text{V})</span> be a batch argument for SAT with efficient online verification property. Then we can construct a batch argument <span class="math">\\text{BARG}=(\\text{Gen},\\text{TGen},\\text{P},\\text{V})</span> with efficient online verification property for <span class="math">\\mathcal{L}</span> with the following efficiency. Let $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> be the length of the instances, </span>m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> be the length of the witnesses, and </span>k$ be the number of instances.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRS size: The size of the CRS is <span class="math">\\text{poly}(\\lambda,n,m,\\log k,\\log T)</span>.</li>

      <li>Proof size: The size of the argument is <span class="math">\\text{poly}(\\lambda,n,m,\\log k,\\log T)</span>.</li>

      <li>Efficient Online Verification: The running time of the offline preprocessing is <span class="math">\\text{poly}(\\lambda,k,n)</span>, and the online verification algorithm runs in <span class="math">\\text{poly}(\\lambda,n,m,\\log k,\\log T)</span>.</li>

    </ul>

    <h6 id="sec-127" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We build the BARG as follows. We will use a circuit DelVerify in Figure 7.</p>

    <p class="text-gray-300">Hardwired: The CRS  <span class="math">(\\mathrm{pk},\\mathrm{vk})</span>  for the Turing machine delegation scheme. Output Del.V(pk,  <span class="math">(x,\\omega),\\Pi)</span></p>

    <p class="text-gray-300">Figure 7: The new circuit  <span class="math">C&#x27;</span>  for batch argument.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Gen}(1^{\\lambda}, 1^{k}, 1^{T})</span> : Generate a CRS for the Turing machine delegation scheme, and a CRS for the batch argument for C-SAT.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  <span class="math">(\\mathrm{pk},\\mathrm{vk})\\gets \\mathrm{Del.S}(1^{\\lambda},T)</span> , and  $\\mathrm{crs}^{\\prime}\\gets \\mathrm{BARG}^{\\prime}.\\mathrm{Gen}(1^{\\lambda},1^{k},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{DelVerify}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\mathrm{crs} = ((\\mathrm{pk},\\mathrm{vk}),\\mathrm{crs}^{\\prime})</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{TGen}(1^{\\lambda}, 1^{k}, 1^{T}, i^{*})</span> : The trapdoor CRS generation algorithm generates (pk, vk) in the same way as Gen, and generates a trapdoor CRS for BARG'.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let  <span class="math">(\\mathrm{pk},\\mathrm{vk})\\gets \\mathrm{Del.S}(1^{\\lambda},T)</span> , and  $\\mathrm{crs}^{*^{\\prime}}\\gets \\mathrm{BARG}^{\\prime}.\\mathrm{Gen}(1^{\\lambda},1^{k},1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{DelVerify}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},i^{*})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\mathrm{crs}^<em> = ((\\mathrm{pk},\\mathrm{vk}),\\mathrm{crs}^{</em>&#x27;})</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{P}(\\mathrm{crs}, x_1, \\ldots, x_k, \\omega_1, \\ldots, \\omega_k)</span> : The prover first delegates each instance using Turing machine delegation, and then uses batch arguments to prove all the delegated instances verify.</li>

    </ul>

    <p class="text-gray-300">Parse  <span class="math">\\mathrm{crs} = ((\\mathrm{pk},\\mathrm{vk}),\\mathrm{crs}^{\\prime})</span> , where  <span class="math">(\\mathrm{pk},\\mathrm{vk})</span>  is the CRS for Turing machine delegation, and  <span class="math">\\mathrm{crs}^{\\prime}</span>  is the CRS for the batch argument.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Delegate the computation of  <span class="math">\\mathcal{M}</span>  using Turing machine delegation.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in [ k ], \\Pi_ {i} \\leftarrow \\operatorname {D e l}. P (\\mathrm {p k}, x _ {i}, \\omega_ {i}).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use batch arguments to generate the proof.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pi^ {\\prime} \\leftarrow \\mathrm {B A R G} ^ {\\prime}. \\mathrm {P} (\\mathrm {c r s} ^ {\\prime}, \\mathrm {D e l V e r i f y} _ {[ (\\mathrm {p k}, \\mathrm {v k}) ]}, x _ {1}, \\dots , x _ {k}, \\{(\\omega_ {i}, \\Pi_ {i}) \\} _ {i \\in [ k ]}).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\Pi = \\Pi^{\\prime}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}(\\mathrm{crs}, x_1, \\ldots, x_k, \\Pi)</span> : The verifier parses  <span class="math">\\Pi = \\Pi&#x27;</span> , and verifies</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {B A R G} ^ {\\prime}. \\mathrm {V} (\\mathrm {c r s} ^ {\\prime}, \\mathrm {D e l V e r i f y}, x _ {1}, \\dots , x _ {k}, \\Pi^ {\\prime}) = 1.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The CRS size is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathrm{pk},\\mathrm{vk})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{crs}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Since the delegation scheme has CRS size poly  </span>(\\lambda, \\log T)<span class="math"> , and  </span>\\mathrm{crs}^{\\prime}<span class="math">  is bounded by poly  </span>(\\lambda, \\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{DelVerify}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\lambda, \\log k, \\mathrm{poly}(\\lambda, \\log k, n, \\log T, m))<span class="math"> , the CRS size is bounded by poly  </span>(\\lambda, \\log T, n, m)<span class="math"> . The proof size is the same as the proof size of BARG&#x27;, where the DelVerify size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathrm{poly}(\\lambda, \\log T) = \\mathrm{poly}(\\lambda, n, m, \\log T)<span class="math"> . Hence, the proof size is bounded by poly  </span>(\\lambda, \\log k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{DelVerify}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(\\lambda, n, m, \\log k, \\log T)$ . Finally, since the verification algorithm is the same as the verification of BARG'. The efficient online verification property follows from the same property of the underlying BARG'.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The completeness follows from the completeness of the delegation scheme Del and the batch argument BARG'. The CRS indistinguishability follows the same property of BARG'.</p>

    <p class="text-gray-300">To prove the semi-adaptive somewhere soundness, we require the somewhere argument of knowledge property of the underlying batch argument BARG', which allows us extraction a witness for the  <span class="math">i^{*}</span> -th instance from an accepting proof (See Remark 2).</p>

    <p class="text-gray-300">Given somewhere argument of knowledge property, we can extract the witness <span class="math">(\\omega_{i^{<em>}},\\Pi^{\\prime}_{i^{</em>}})</span> for the <span class="math">i^{<em>}</span>-th instance from any cheating prover for BARG, and output <span class="math">\\Pi^{\\prime}_{i^{</em>}}</span> as the attacking proof for the underlying delegation scheme Del, with input <span class="math">(x_{i^{<em>}},\\omega_{i^{</em>}})</span>. Since the delegation scheme is sound, this proves the soundness of our batch argument construction. ∎</p>

    <h2 id="sec-129" class="text-2xl font-bold">7 Acknowledgments</h2>

    <p class="text-gray-300">Arka Rai Choudhuri, Abhishek Jain and Zhengzhong Jin are supported in part by NSF CNS-1814919, NSF CAREER 1942789 and Johns Hopkins University Catalyst award. Arka Rai Choudhuri and Abhishek Jain are also supported in part by the Office of Naval Research Grant N00014-19-1-2294. Arka Rai Choudhuri is also supported in part by NSF Grant CNS-1908181. Zhengzhong Jin is also supported in part by NSF CAREER 1845349.</p>

    <p class="text-gray-300">We would like to thank Yael Tauman Kalai for useful feedback on a previous version of the paper.</p>

    <h2 id="sec-130" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACC^{+}16] Prabhanjan Ananth, Yu-Chi Chen, Kai-Min Chung, Huijia Lin, and Wei-Kai Lin. Delegating RAM computations with adaptive soundness and privacy. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 3–30. Springer, Heidelberg, October / November 2016.</li>

      <li>[Bar01] Boaz Barak. How to go beyond the black-box simulation barrier. In 42nd FOCS, pages 106–115. IEEE Computer Society Press, October 2001.</li>

      <li>[BBH^{+}19] James Bartusek, Liron Bronfman, Justin Holmgren, Fermi Ma, and Ron D. Rothblum. On the (in)security of kilian-based SNARGs. In Dennis Hofheinz and Alon Rosen, editors, TCC 2019, Part II, volume 11892 of LNCS, pages 522–551. Springer, Heidelberg, December 2019.</li>

      <li>[BCC88] Gilles Brassard, David Chaum, and Claude Crépeau. Minimum disclosure proofs of knowledge. J. Comput. Syst. Sci., 37(2):156–189, 1988.</li>

      <li>[BCC^{+}17] Nir Bitansky, Ran Canetti, Alessandro Chiesa, Shafi Goldwasser, Huijia Lin, Aviad Rubinstein, and Eran Tromer. The hunting of the SNARK. Journal of Cryptology, 30(4):989–1066, October 2017.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, 45th ACM STOC, pages 111–120. ACM Press, June 2013.</li>

      <li>[BCG^{+}14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014, pages 459–474. IEEE Computer Society, 2014.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, Heidelberg, March 2013.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In 23rd ACM STOC, pages 21–31. ACM Press, May 1991.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BGL^{+}15] Nir Bitansky, Sanjam Garg, Huijia Lin, Rafael Pass, and Sidharth Telang. Succinct randomized encodings and their applications. In Rocco A. Servedio and Ronitt Rubinfeld, editors, 47th ACM STOC, pages 439–448. ACM Press, June 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BHK17] Zvika Brakerski, Justin Holmgren, and Yael Tauman Kalai. Non-interactive delegation and batch NP verification from standard computational assumptions. In Hamed Hatami, Pierre McKenzie, and Valerie King, editors, 49th ACM STOC, pages 474–482. ACM Press, June 2017.</li>

      <li>[BK20] Zvika Brakerski and Yael Kalai. Witness indistinguishability for any single-round argument with applications to access control. In Aggelos Kiayias, Markulf Kohlweiss, Petros Wallden, and Vassilis Zikas, editors, PKC 2020, Part II, volume 12111 of LNCS, pages 97–123. Springer, Heidelberg, May 2020.</li>

      <li>[BKK^{+}18] Saikrishna Badrinarayanan, Yael Tauman Kalai, Dakshita Khurana, Amit Sahai, and Daniel Wichs. Succinct delegation for low-space non-deterministic computation. In Ilias Diakonikolas, David Kempe, and Monika Henzinger, editors, 50th ACM STOC, pages 709–721. ACM Press, June 2018.</li>

      <li>[BKM20] Zvika Brakerski, Venkata Koppula, and Tamer Mour. NIZK from LPN and trapdoor hash via correlation intractability for approximable relations. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 738–767. Springer, Heidelberg, August 2020.</li>

      <li>[BKP18] Nir Bitansky, Yael Tauman Kalai, and Omer Paneth. Multi-collision resistance: a paradigm for keyless hash functions. In Ilias Diakonikolas, David Kempe, and Monika Henzinger, editors, 50th ACM STOC, pages 671–684. ACM Press, June 2018.</li>

      <li>[BLP^{+}13] Zvika Brakerski, Adeline Langlois, Chris Peikert, Oded Regev, and Damien Stehlé. Classical hardness of learning with errors. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, 45th ACM STOC, pages 575–584. ACM Press, June 2013.</li>

      <li>[CCC^{+}16] Yu-Chi Chen, Sherman S. M. Chow, Kai-Min Chung, Russell W. F. Lai, Wei-Kai Lin, and Hong-Sheng Zhou. Cryptography for parallel RAM from indistinguishability obfuscation. In Madhu Sudan, editor, ITCS 2016, pages 179–190. ACM, January 2016.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 1082–1090. ACM Press, June 2019.</li>

      <li>[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D. Rothblum. Fiat-Shamir and correlation intractability from strong KDM-secure encryption. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 91–122. Springer, Heidelberg, April / May 2018.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557–594, July 2004.</li>

      <li>[CH16] Ran Canetti and Justin Holmgren. Fully succinct garbled RAM. In Madhu Sudan, editor, ITCS 2016, pages 169–178. ACM, January 2016.</li>

    </ul>

    <p class="text-gray-300">[CHJV15] Ran Canetti, Justin Holmgren, Abhishek Jain, and Vinod Vaikuntanathan. Succinct garbling and indistinguishability obfuscation for RAM programs. In Rocco A. Servedio and Ronitt Rubinfeld, editors, 47th ACM STOC, pages 429–437. ACM Press, June 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CJJ21] Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. Non-interactive batch arguments for np from standard assumptions. In CRYPTO, Lecture Notes in Computer Science. Springer, 2021.</li>

      <li>[CKU20] Geoffroy Couteau, Shuichi Katsumata, and Bogdan Ursu. Non-interactive zero-knowledge in pairing-free groups from weaker assumptions. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part III, volume 12107 of LNCS, pages 442–471. Springer, Heidelberg, May 2020.</li>

      <li>[CPV20] Michele Ciampi, Roberto Parisella, and Daniele Venturi. On adaptive security of delayed-input sigma protocols and fiat-shamir NIZKs. In Clemente Galdi and Vladimir Kolesnikov, editors, SCN 20, volume 12238 of LNCS, pages 670–690. Springer, Heidelberg, September 2020.</li>

      <li>[DFH12] Ivan Damgård, Sebastian Faust, and Carmit Hazay. Secure two-party computation with low communication. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 54–74. Springer, Heidelberg, March 2012.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</li>

      <li>[GK03] Shafi Goldwasser and Yael Tauman Kalai. On the (in)security of the Fiat-Shamir paradigm. In 44th FOCS, pages 102–115. IEEE Computer Society Press, October 2003.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 113–122. ACM Press, May 2008.</li>

      <li>[GR19] Alonso González and Carla Ràfols. Shorter pairing-based arguments under standard assumptions. In Steven D. Galbraith and Shiho Moriai, editors, ASIACRYPT 2019, Part III, volume 11923 of LNCS, pages 728–757. Springer, Heidelberg, December 2019.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, Heidelberg, December 2010.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press, June 2011.</li>

      <li>[GZ21] Alonso González and Alexandros Zacharakis. Succinct publicly verifiable computation. Cryptology ePrint Archive, Report 2021/353, 2021. https://eprint.iacr.org/2021/353.</li>

    </ul>

    <p class="text-gray-300">[HL18] Justin Holmgren and Alex Lombardi. Cryptographic hashing from strong one-way functions (or: One-way product functions and their applications). In Mikkel Thorup, editor, 59th FOCS, pages 850–858. IEEE Computer Society Press, October 2018.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[HLR21] Justin Holmgren, A. Lombardi, and R. Rothblum. Fiat-shamir via list-recoverable codes (or: Parallel repetition of gmw is not zero-knowledge). STOC, 2021.</li>

      <li>[HR18] Justin Holmgren and Ron Rothblum. Delegating computations with (almost) minimal time and space overhead. In Mikkel Thorup, editor, 59th FOCS, pages 124–135. IEEE Computer Society Press, October 2018.</li>

      <li>[HW15] Pavel Hubacek and Daniel Wichs. On the communication complexity of secure function evaluation with long output. In Tim Roughgarden, editor, ITCS 2015, pages 163–172. ACM, January 2015.</li>

      <li>[JJ21] Abhishek Jain and Zhengzhong Jin. Non-Interactive Zero Knowledge from Sub-exponential DDH. In EUROCRYPT, Lecture Notes in Computer Science. Springer, 2021.</li>

      <li>[JKKZ21] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Zhang. SNARGs for Bounded Depth Computations and PPAD Hardness from Sub-Exponential LWE. In STOC. ACM, 2021.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>[KLW15] Venkata Koppula, Allison Bishop Lewko, and Brent Waters. Indistinguishability obfuscation for turing machines with unbounded memory. In Rocco A. Servedio and Ronitt Rubinfeld, editors, 47th ACM STOC, pages 419–428. ACM Press, June 2015.</li>

      <li>[KP16] Yael Tauman Kalai and Omer Paneth. Delegating RAM computations. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 91–118. Springer, Heidelberg, October / November 2016.</li>

      <li>[KPY19] Yael Tauman Kalai, Omer Paneth, and Lisa Yang. How to delegate computations publicly. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 1115–1124. ACM Press, June 2019.</li>

      <li>[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for bounded space. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, 45th ACM STOC, pages 565–574. ACM Press, June 2013.</li>

      <li>[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. How to delegate computations: the power of no-signaling proofs. In David B. Shmoys, editor, 46th ACM STOC, pages 485–494. ACM Press, May / June 2014.</li>

      <li>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum. From obfuscation to the security of Fiat-Shamir for proofs. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 224–251. Springer, Heidelberg, August 2017.</li>

      <li>[KVZ21] Yael Tauman Kalai, Vinod Vaikuntanathan, and Rachel Yun Zhang. Somewhere statistical soundness, post-quantum security, and snargs. Cryptology ePrint Archive, Report 2021/788, 2021. https://ia.cr/2021/788.</li>

    </ul>

    <p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, Heidelberg, March 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Mer88] Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl Pomerance, editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, August 1988.</li>

      <li>[Mic94] Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994.</li>

      <li>[Nao03] Moni Naor. On cryptographic assumptions and challenges (invited talk). In Dan Boneh, editor, CRYPTO 2003, volume 2729 of LNCS, pages 96–109. Springer, Heidelberg, August 2003.</li>

      <li>[Pei09] Chris Peikert. Public-key cryptosystems from the worst-case shortest vector problem: extended abstract. In Michael Mitzenmacher, editor, 41st ACM STOC, pages 333–342. ACM Press, May / June 2009.</li>

      <li>[PR17] Omer Paneth and Guy N. Rothblum. On zero-testable homomorphic encryption and publicly verifiable non-interactive arguments. In Yael Kalai and Leonid Reyzin, editors, TCC 2017, Part II, volume 10678 of LNCS, pages 283–315. Springer, Heidelberg, November 2017.</li>

      <li>[PRS17] Chris Peikert, Oded Regev, and Noah Stephens-Davidowitz. Pseudorandomness of ring-LWE for any ring and modulus. In Hamed Hatami, Pierre McKenzie, and Valerie King, editors, 49th ACM STOC, pages 461–473. ACM Press, June 2017.</li>

      <li>[PRV12] Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: Verifiable computation from attribute-based encryption. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 422–439. Springer, Heidelberg, March 2012.</li>

      <li>[PS19] Chris Peikert and Sina Shiehian. Noninteractive zero knowledge for NP from (plain) learning with errors. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 89–114. Springer, Heidelberg, August 2019.</li>

      <li>[Reg09] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. J. ACM, 56(6), September 2009.</li>

      <li>[RR20] Guy N. Rothblum and Ron D. Rothblum. Batch verification and proofs of proximity with polylog overhead. In Rafael Pass and Krzysztof Pietrzak, editors, TCC 2020, Part II, volume 12551 of LNCS, pages 108–138. Springer, Heidelberg, November 2020.</li>

      <li>[RRR16] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for delegating computation. In Daniel Wichs and Yishay Mansour, editors, 48th ACM STOC, pages 49–62. ACM Press, June 2016.</li>

      <li>[RRR18] Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Efficient batch verification for UP. In Computational Complexity Conference, volume 102 of LIPIcs, pages 22:1–22:23. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018.</li>

      <li>[Set20] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Heidelberg, August 2020.</li>

    </ul>

    <p class="text-gray-300">A Proof of Theorem 5</p>

    <p class="text-gray-300">Theorem 13. Given <span class="math">\\ell</span> instances of an SECOM commitment scheme <span class="math">\\mathrm{SECOM} = (\\mathrm{SECOM.Gen}, \\mathrm{SECOM.TGen}, \\mathrm{SECOM.Com}, \\mathrm{SECOM.Open}, \\mathrm{SECOM.Verify}, \\mathrm{SECOM.Ext})</span> with locality parameter 1, one can construct an <span class="math">L</span>-no-signaling NS-SECOM.</p>

    <p class="text-gray-300">Proof. We construct the <span class="math">L</span>-no-signaling NS-SECOM as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{TGen}(1^{\\lambda}, 1^{N}, S)</span>: The key generation algorithm generates a 1-SECOM key for each element in <span class="math">S</span>, and also generates the remaining $(L -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$-SECOM keys. Then it outputs a random shuffle of all the generated keys.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Let $S = \\{s_1, s_2, \\ldots, s_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math">. For each </span>i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, let </span>(K_i^*, \\mathrm{td}_i) \\gets \\mathrm{SECOM.TGen}(1^\\lambda, 1^N, \\{s_i\\})$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Let <span class="math">\\pi : [L] \\to [L]</span> be a random shuffle. Output <span class="math">K^<em> = \\{K_{\\pi(i)}^</em>\\}_{i \\in [L]}</span>, and $\\mathrm{td} = (\\{\\mathrm{td}_i\\}_{i \\in [</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">]}, \\pi)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Com}(K, \\mathbf{m} \\in \\{0, 1\\}^N; r)</span>: The commitment algorithm commits the message <span class="math">\\mathbf{m}</span> for each key specified in <span class="math">K</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">r = r_1, r_2, \\ldots, r_L</span>, and <span class="math">K = \\{K_i&#x27;\\}_{i \\in [L]}</span>.</li>

      <li>For each <span class="math">i \\in [L]</span>, compute <span class="math">c_i \\gets \\mathrm{SECOM.Com}(K_i&#x27;, \\mathbf{m}; r_i)</span>. Output <span class="math">c = \\{c_i\\}_{i \\in [L]}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{Ext}(c, \\mathrm{td})</span>: The extraction algorithm extracts for each element in <span class="math">S</span>. It uses <span class="math">\\pi</span> to recover the order.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Parse <span class="math">c = \\{c_i\\}_{i \\in [L]}</span>, and $\\mathrm{td} = (\\{\\mathrm{td}_i\\}_{i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}, \\pi)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The local opening algorithm <span class="math">\\mathrm{Open}</span> and the local verification algorithm <span class="math">\\mathrm{Verify}</span> repeat the same algorithms in SECOM for <span class="math">L</span> times. We omit the details here.</p>

    <p class="text-gray-300">To prove the aforementioned construction is <span class="math">L</span>-no-signaling, we build a series of hybrids. For any two sets <span class="math">S&#x27; \\subseteq S</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_0</span>: This hybrid uses <span class="math">S</span> to generate the commitment key.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (K^<em>, \\mathrm{td}) \\leftarrow \\mathrm{TGen}(1^\\lambda, 1^N, S), (c, z) \\leftarrow \\mathcal{D}_1(K^</em>), \\vec{y} := \\mathrm{Ext}(c, \\mathrm{td}), \\text{Output } \\mathcal{D}_2(K^*, c, \\vec{y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S'}, z).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathrm{Hyb}_1</span>: This hybrid is almost the same as <span class="math">\\mathrm{Hyb}_0</span>, except that, we rearrange the elements in <span class="math">S</span> as $\\{s_1, s_2, \\ldots, s_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math"> such that the first </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> elements are exactly </span>S'<span class="math">, i.e. </span>S' = \\{s_1, s_2, \\ldots, s_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math">. Furthermore, we replace the computation of </span>\\vec{y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S'}<span class="math"> as direct computation without using </span>\\{\\mathrm{td}_i\\}_{i =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1, \\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(K^<em>, \\mathrm{td}) \\leftarrow \\mathrm{TGen}(1^\\lambda, 1^N, S), (c, z) \\leftarrow \\mathcal{D}_1(K^</em>).</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\operatorname{Parse} c = \\{c_i\\}_{i \\in [L]}<span class="math">. For each </span>i \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, let </span>y_i' := \\mathrm{SECOM.Ext}(c_{\\pi(i)}, \\mathrm{td}_i)<span class="math">. Output </span>\\mathcal{D}_2(K^*, c, \\{y_i'\\}_i, z)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This hybrid is identical to the hybrid <span class="math">\\mathrm{Hyb}_0</span>, because the random shuffle <span class="math">\\pi</span> completely hides the order we represent <span class="math">S</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Hyb}_2^{j^*}</span>: This hybrid is almost the same as <span class="math">\\mathrm{Hyb}_1</span>, except that we replace the <span class="math">\\mathrm{TGen}</span> as follows.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For each $i \\in</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, if </span>i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ j^<em><span class="math">, then let </span>K_i^</em> \\gets \\mathrm{SECOM.TGen}(1^\\lambda, 1^N, \\phi)<span class="math"> and </span>\\mathrm{td}_i = \\phi<span class="math">. For each </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ j^* &lt; i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, let </span>(K_i^*, \\mathrm{td}_i) \\gets \\mathrm{SECOM.TGen}(1^\\lambda, 1^N, \\{s_i\\})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">54</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For $[L] \\setminus [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, </span>K_{i}^{*} \\leftarrow \\mathrm{SECOM.TGen}(1^{\\lambda}, 1^{N}, \\phi)<span class="math">, where </span>\\phi$ is the empty set.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Hyb}_2^1</span> is computationally indistinguishable with <span class="math">\\mathsf{Hyb}_1</span>. Furthermore, <span class="math">\\mathsf{Hyb}_2^{i^<em>}</span> is computationally indistinguishable with <span class="math">\\mathsf{Hyb}_2^{i^</em> + 1}</span>. This follows from the key indistinguishability of SECOM.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\mathsf{Hyb}_3 = \\mathsf{Hyb}_2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. This hybrid is identical to the following hybrid.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(K^{*}, \\operatorname{td}) \\leftarrow \\operatorname{TGen}(1^{\\lambda}, 1^{N}, S&#x27;), (c, z) \\leftarrow \\mathcal{D}_1(K^{*}), \\vec{y} := \\operatorname{Ext}(c, \\operatorname{td}), \\text{Output } \\mathcal{D}_2(K^{*}, c, \\vec{y}, z).</span></div>

    <p class="text-gray-300">By the hybrid argument, <span class="math">\\mathsf{Hyb}_0</span> and <span class="math">\\mathsf{Hyb}_3</span> are computationally indistinguishable. We finish the proof.</p>

    <p class="text-gray-300">55</p>`;
---

<BaseLayout title="SNARGs for $\mathcal{P}$ from LWE (2021/808)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/808
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
