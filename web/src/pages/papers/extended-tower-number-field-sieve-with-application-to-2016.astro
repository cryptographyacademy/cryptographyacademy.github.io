---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/526';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Extended Tower Number Field Sieve with Application to Finite Fields of Arbitrary Composite Extension Degree';
const AUTHORS_HTML = 'Taechan Kim, Jinhyuck Jeong';

const CONTENT = `    <p class="text-gray-300">Taechan Kim [ NTT Secure Platform Laboratories, Japan ] Jinhyuck Jeong [ taechan.kim@lab.ntt.co.jp Seoul National University, Korea wlsyrlekd@snu.ac.kr ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We propose a generalization of exTNFS algorithm recently introduced by Kim and Barbulescu (CRYPTO 2016). The algorithm, exTNFS, is a state-of-the-art algorithm for discrete logarithm in <span class="math">\\mathbb{F}_{p^{n}}</span> in the medium prime case, but it only applies when <span class="math">n=\\eta\\kappa</span> is a composite with nontrivial factors <span class="math">\\eta</span> and <span class="math">\\kappa</span> such that <span class="math">\\gcd(\\eta,\\kappa)=1</span>. Our generalization, however, shows that exTNFS algorithm can be also adapted to the setting with an arbitrary composite <span class="math">n</span> maintaining its best asymptotic complexity. We show that one can solve discrete logarithm in medium case in the running time of <span class="math">L_{p^{n}}(1/3,\\sqrt[3]{48/9})</span> (resp. <span class="math">L_{p^{n}}(1/3,1.71)</span> if multiple number fields are used), where <span class="math">n</span> is an <em>arbitrary composite</em>. This should be compared with a recent variant by Sarkar and Singh (Asiacrypt 2016) that has the fastest running time of <span class="math">L_{p^{n}}(1/3,\\sqrt[3]{64/9})</span> (resp. <span class="math">L_{p^{n}}(1/3,1.88)</span>) when <span class="math">n</span> is a power of prime <span class="math">2</span>. When <span class="math">p</span> is of special form, the complexity is further reduced to <span class="math">L_{p^{n}}(1/3,\\sqrt[3]{32/9})</span>. On the practical side, we emphasize that the keysize of pairing-based cryptosystems should be updated following to our algorithm if the embedding degree <span class="math">n</span> remains composite.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">Discrete Logarithm Problem; Number Field Sieve; Finite Fields; Cryptanalysis</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Discrete logarithm problem (DLP) over a multiplicative subgroup of finite fields <span class="math">\\mathbb{F}_{Q}</span>, <span class="math">Q=p^{n}</span>, gathers its particular interest due to its prime importance in pairing-based cryptography. Over a generic group, the best known algorithm of the DLP takes exponential running time in the bitsize of the group order. However, in the case for the multiplicative group of finite fields one can exploit a special algebraic structure of the group to design better algorithms, where the DLP can be solved much more efficiently than in the exponential time. For example, when the characteristic <span class="math">p</span> is small compared to the extension degree <span class="math">n</span>, the best known algorithms have quasi-polynomial time complexity <em>[3, 10]</em>.</p>

    <p class="text-gray-300">Recall the usual <span class="math">L_{Q}</span>-notation,</p>

    <p class="text-gray-300"><span class="math">L_{Q}(\\ell,c)=\\exp\\big{(}(c+o(1))(\\log Q)^{\\ell}(\\log\\log Q)^{1-\\ell}\\big{)},</span></p>

    <p class="text-gray-300">for some constants <span class="math">0\\leq\\ell\\leq 1</span> and <span class="math">c&gt;0</span>. We call the characteristic <span class="math">p=L_{Q}(\\ell_{p},c_{p})</span> medium when <span class="math">1/3&lt;\\ell_{p}&lt;2/3</span> and large when <span class="math">2/3&lt;\\ell_{p}\\leq 1</span>. We say that a field <span class="math">\\mathbb{F}_{p^{n}}</span> is in the boundary case when <span class="math">\\ell_{p}=2/3</span>.</p>

    <p class="text-gray-300">For medium and large characteristic, all the best known attacks are variants of the number field sieve (NFS) algorithm. Initially used for factoring, NFS was rapidly introduced in DLP to target prime fields <em>[9, 20]</em>. It was about a decade later by Schirokauer <em>[21]</em> that NFS was adapted to target non-prime fields <span class="math">\\mathbb{F}_{p^{n}}</span> with <span class="math">n&gt;1</span>. This is known today as tower number field sieve (TNFS) <em>[4]</em>. On the other hand, an approach by Joux et al. <em>[12]</em>, which we denote by JLSV, was on a main stream of recent improvements on DLP over medium and large characteristic case. JLSV’s idea is similar to the variant used to target prime fields, except the step called polynomial selection. This polynomial selection method was later supplemented with generalized Joux-Lercier (GJL) method <em>[16, 2]</em>, Conjugation (Conj) method <em>[2]</em>, and Sarkar-Singh (SS) method <em>[19]</em> leading improvements on the complexity of the NFS algorithm. However, in all these algorithms the complexity for the medium prime case is slightly larger than that of large prime case. Moreover there was an anomaly that the best complexity was obtained in the boundary case, <span class="math">\\ell_{p}=2/3</span>.</p>

    <p class="text-gray-300">This abnormal behavior of the complexity in the NFS algorithm was partly removed in a recent breakthrough by Kim and Barbulescu <em>[15]</em> (exTNFS), where they obtained an algorithm of better complexity for the medium prime case than in the large prime case. Although this approach only applies to fields of extension degree <span class="math">n</span> where <span class="math">n=\\eta\\kappa</span> has factors <span class="math">\\eta,\\kappa&gt;1</span> such that <span class="math">\\gcd(\\eta,\\kappa)=1</span>, it was enough to frighten pairing-based community since a number of popular pairing-friendly curves, such as Barreto-Naehrig curve <em>[6]</em>, are in the category that exTNFS applies.</p>

    <p class="text-gray-300">Then one might ask a question whether transitioning into pairing-friendly curves with embedding degree <span class="math">n</span>, say, a prime power, would be immune to this recent attack by Kim and Barbulescu. Our answer is negative: we show that our algorithm has the same complexity as exTNFS algorithm for any composite <span class="math">n</span>, so the keysize of the pairing-based cryptosystems should be updated according to our algorithm whenever the embedding degree is composite.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Related works</h4>

    <p class="text-gray-300">When the extension degree <span class="math">n</span> cannot be factored into relatively prime factors (for example, <span class="math">n</span> is a prime power), the best known attacks for the medium prime case still had the complexity <span class="math">L_{Q}\\big{(}1/3,\\sqrt[3]{96/9}\\big{)}</span> until Sarkar and Singh proposed an algorithm <em>[18]</em> of the best complexity <span class="math">L_{Q}\\big{(}1/3,\\sqrt[3]{64/9}\\big{)}</span>. Note that, however, this is still slightly larger than the best complexity of Kim-Barbulescu’s exTNFS. One can see Table 1 for a comparison of these previous algorithms on the asymptotic complexity.</p>

    <p class="text-gray-300">All currently known variants of NFS admit variants with multiple number fields (MNFS) which have a slightly better asymptotic complexity. The complexity of these variants is shown in Table 2.</p>

    <p class="text-gray-300">When the characteristic <span class="math">p</span> has a special form, as it is the case for fields in pairing-based cryptosystems, one can further accelerate NFS algorithms using</p>

    <p class="text-gray-300">Table 1: The complexity of each algorithm. Each cell in the second indicates  <span class="math">c</span>  if the complexity is  <span class="math">L_{Q}(1/3, (c/9)^{\\frac{1}{3}})</span>  when  <span class="math">p = L_{Q}(\\ell_{p})</span> ,  <span class="math">1/3 &amp;lt; \\ell_{p} &amp;lt; 2/3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">complexity in the medium case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions on n</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">NFS-(Conj and GJL) [2]</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">n: any integers</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ 641</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i for some i > 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-KimBar [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ 481</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ (η, κ ≠ 1), gcd(η, κ) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-new (this article)</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ 481</td>

            <td class="px-3 py-2 border-b border-gray-700">n: any composite</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 54.28</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i for some i > 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: The complexity of each algorithm using multiple number fields. Each cell in the second column indicates an approximation of  <span class="math">c</span>  if the complexity is  <span class="math">L_{Q}(1/3, (c/9)^{\\frac{1}{3}})</span>  when  <span class="math">p = L_{Q}(\\ell_{p})</span> ,  <span class="math">1/3 &amp;lt; \\ell_{p} &amp;lt; 2/3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">complexity in the medium case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions on n</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MNFS-(Conj and GJL) [17]</td>

            <td class="px-3 py-2 border-b border-gray-700">89.45</td>

            <td class="px-3 py-2 border-b border-gray-700">n: any integers</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MexTNFS-C [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ 61.291</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i for some i > 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MexTNFS-KimBar [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ 45.001</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ (η, κ ≠ 1), gcd(η, κ) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MexTNFS-new (this article)</td>

            <td class="px-3 py-2 border-b border-gray-700">≥ 45.001</td>

            <td class="px-3 py-2 border-b border-gray-700">n: any composite</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 59.80</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i3j for some i + j > 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 50.76</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i for some i > 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">variants called special number field sieve (SNFS). In Table 3 we list asymptotic complexity of each algorithm. When  <span class="math">n</span>  is a prime power, the algorithm by Joux and Pierrot had been the best algorithm before our algorithm.</p>

    <p class="text-gray-300">Recently, Gullevic, Morain, and Thomé [11] observed that Kim-Barculescu's technique can be adapted to target the fields of extension degree 4. However, they did not pursue the idea to further analyze its complexity.</p>

    <p class="text-gray-300">Our contributions We propose an algorithm that is a state-of-the-art algorithm for the DLP in the medium prime case as far as we aware. We remark that our algorithm applies to target fields of arbitrary composite extension degree  <span class="math">n</span> . If  <span class="math">n</span>  can be written as  <span class="math">n = \\eta \\kappa</span>  for some  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  with  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> , our algorithm has the same complexity as Kim-Barculescu's exTNFS [15]. However, our algorithm allows to choose factors  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  freely from the co-primality condition, so we have more choices for the pair  <span class="math">(\\eta, \\kappa)</span> . This helps us to find a better  <span class="math">(\\eta, \\kappa)</span>  that</p>

    <p class="text-gray-300">Table 3: The complexity of each algorithm used when the characteristic has a special form (SNFS). Each cell indicates an approximation of  <span class="math">c</span>  if the complexity is  <span class="math">L_{Q}(1/3, (c/9)^{\\frac{1}{3}})</span>  when  <span class="math">p = L_{Q}(\\ell_{p})</span> ,  <span class="math">1/3 &amp;lt; \\ell_{p} &amp;lt; 2/3</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">complexity in the medium case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions on n</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SNFS-JP [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">n: any integers</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS-KimBar [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ (η, κ ≠ 1), gcd(η, κ) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS-new (this article)</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">n: any composite</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">practically yields a better performance, although the asymptotic complexity is unchanged.</p>

    <p class="text-gray-300">If  <span class="math">n</span>  is a prime power, the complexity of our algorithm is less than that of Sarkar-Singh's variant [18], a currently best-known algorithm for this case.</p>

    <p class="text-gray-300">When  <span class="math">n</span>  is a  <span class="math">b</span> -smooth integer for an integer  <span class="math">b \\leq 4</span> , we show an upper bound for the asymptotic complexity of our algorithm. For example, when  <span class="math">n</span>  is a power of 2, our algorithm always has the asymptotic complexity less than  <span class="math">L_{Q}(1/3, 1.82)</span> . If multiple NFS variants are used, the complexity can always be lowered to  <span class="math">L_{Q}(1/3, c)</span> ,  <span class="math">c \\leq 1.88</span> , when  <span class="math">n</span>  is a 4-smooth composite integer, and  <span class="math">L_{Q}(1/3, c)</span> ,  <span class="math">c \\leq 1.78</span> , when  <span class="math">n</span>  is a power of 2.</p>

    <p class="text-gray-300">When  <span class="math">p</span>  is of special form, pairings with embedding degree such as  <span class="math">n = 4, 9, 16</span>  was not affected by Kim-Barculescu's algorithm, however, due to our variant of SNFS, the keysize of such pairings should be also updated following to our new complexity.</p>

    <p class="text-gray-300">Organization We briefly recall exTNFS algorithm and introduce our algorithm in Section 2. The complexity analysis is given in Section 3. The variants such as multiple number field sieve and special number field sieve are discussed in Section 4. In Section 5, we make a precise comparison to the state-of-the-art algorithms at cryptographic sizes. We conclude with cryptographic implications of our result in Section 6.</p>

    <p class="text-gray-300">Throughout this paper, we target fields  <span class="math">\\mathbb{F}_Q</span>  with  <span class="math">Q = p^n</span>  where  <span class="math">n = \\eta \\kappa</span>  such that  <span class="math">\\eta, \\kappa \\neq 1</span>  and the characteristic  <span class="math">p</span>  is medium or large, i.e.  <span class="math">\\ell_p &amp;gt; 1/3</span> .</p>

    <p class="text-gray-300">We briefly review exTNFS algorithm and then explain our algorithm. Recall the commutative diagram that is familiar in the context of NFS algorithm (Fig. 1). First we select an irreducible polynomial  <span class="math">h(t) \\in \\mathbb{Z}[t]</span>  of degree  <span class="math">\\eta</span>  which is also irreducible modulo  <span class="math">p</span> . We put  <span class="math">R \\coloneqq \\mathbb{Z}[t] / h(t) = \\mathbb{Z}(\\iota)</span>  then  <span class="math">R / pR \\simeq \\mathbb{F}_{p^{\\eta}}</span> . We select</p>

    <p class="text-gray-300">two polynomials  <span class="math">f</span>  and  <span class="math">g</span>  with coefficients in  <span class="math">R</span>  so that they have a common factor  <span class="math">k(x)</span>  of degree  <span class="math">\\kappa</span>  modulo  <span class="math">p</span> . We further require  <span class="math">k</span>  to be irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . Note that the only difference of our algorithm from Kim-Barculescu's exTNFS is that the coefficients of  <span class="math">f</span>  and  <span class="math">g</span>  are chosen from  <span class="math">R</span>  instead of  <span class="math">\\mathbb{Z}</span> .</p>

    <p class="text-gray-300">The conditions on  <span class="math">f</span> ,  <span class="math">g</span>  and  <span class="math">h</span>  yield two ring homomorphisms from  <span class="math">R[x]</span>  to  <span class="math">(R / pR) / k(x) = \\mathbb{F}_{p^{\\eta \\kappa}}</span>  through  <span class="math">R[x] / f(x)</span>  (or  <span class="math">R[x] / g(x)</span> ). Thus one has the commutative diagram in Figure 1 which is a generalization of the classical diagram of NFS.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Commutative diagram of exTNFS. We can choose  <span class="math">f</span>  and  <span class="math">g</span>  to be irreducible polynomials over  <span class="math">R</span>  such that  <span class="math">k = \\gcd(f, g) \\mod p</span>  is irreducible over  <span class="math">R / pR = \\mathbb{F}_{p^{\\eta}}</span> .</p>

    <p class="text-gray-300">After the polynomial selection, the exTNFS algorithm proceeds as all other variants of NFS, following the same steps: relations collection, linear algebra and individual logarithm. We skip the description on it and refer to [15] for further details.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Choice of  <span class="math">h</span>  We have to select a polynomial  <span class="math">h(t) \\in \\mathbb{Z}[t]</span>  of degree  <span class="math">\\eta</span>  which is irreducible modulo  <span class="math">p</span>  and whose coefficients are as small as possible. As in TNFS [4] we try random polynomials  <span class="math">h</span>  with small coefficients and factor them in  <span class="math">\\mathbb{F}_p[t]</span>  to test irreducibility. Heuristically, one succeeds after  <span class="math">\\eta</span>  trials and since  <span class="math">\\eta \\leq 3^{\\eta}</span>  we expect to find  <span class="math">h</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 1$ . For a more rigorous description on the existence of such polynomials one can refer to [4].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Choice of  <span class="math">f</span>  and  <span class="math">g</span>  Next we select  <span class="math">f</span>  and  <span class="math">g</span>  in  <span class="math">R[x]</span>  which have a common factor  <span class="math">k(x)</span>  modulo  <span class="math">p</span>  of degree  <span class="math">\\kappa</span>  which remains irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}} = R / pR</span> . We can adapt all the polynomial selection methods discussed in the previous literatures, such as JLSV's method [12], GJL and Conj [2] method, and so on[19,13,5,17], except that one chooses the coefficients of  <span class="math">f</span>  and  <span class="math">g</span>  from  <span class="math">R</span>  instead of  <span class="math">\\mathbb{Z}</span> . To fix ideas, we describe polynomial selection methods based on JLSV <span class="math">_2</span>  method and Conjugation method. A similar idea also applies with GJL method, but we skip the details.</p>

    <p class="text-gray-300">Generalized  <span class="math">JLSV_{2}</span>  method We describe a generalized method of polynomial selection based on  <span class="math">JLSV_{2}</span>  method [12]. To emphasize that the coefficients of polynomial are taken from a ring  <span class="math">R = \\mathbb{Z}[i]</span>  instead of a smaller ring  <span class="math">\\mathbb{Z}</span> , we call it as generalized  <span class="math">JLSV_{2}</span>  method (gJLSV <span class="math">_{2}</span>  method).</p>

    <p class="text-gray-300">First, we select a bivariate polynomial  <span class="math">\\widetilde{g}(t,x) \\in \\mathbb{Z}[t,x]</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {g} (t, x) = g _ {0} (t) + g _ {1} (t) x + \\dots + g _ {\\kappa - 1} (t) x ^ {\\kappa - 1} + x ^ {\\kappa},</span></div>

    <p class="text-gray-300">where  <span class="math">g_{i}(t) \\in \\mathbb{Z}[t]</span> 's are polynomials of degree less than  <span class="math">\\eta</span>  with small integer coefficients. We also require  <span class="math">\\widetilde{g} \\mod (p, h(t))</span>  to be irreducible in  <span class="math">\\mathbb{F}_{p^{\\eta}}[x]</span> . Set an integer  <span class="math">W \\approx p^{1/(d+1)}</span>  where  <span class="math">d</span>  is a parameter such that  <span class="math">d \\geq \\kappa</span> . Take  <span class="math">g(t, x) := \\widetilde{g}(t, x + W)</span>  and consider the lattice of dimension  <span class="math">(d+1)\\eta</span>  defined by the following matrix  <span class="math">M</span> :</p>

    <div class="my-4 text-center"><span class="math-block">M := \\left( \\begin{array}{c} \\boxed {\\operatorname {v e c} (p t ^ {0} x ^ {0} \\bmod h)} \\\\ \\vdots \\\\ \\boxed {\\operatorname {v e c} (p t ^ {i} x ^ {j} \\bmod h)} \\\\ \\vdots \\\\ \\boxed {\\operatorname {v e c} (p t ^ {\\eta - 1} x ^ {\\kappa - 1} \\bmod h)} \\\\ \\boxed {\\operatorname {v e c} (g \\bmod h)} \\\\ \\vdots \\\\ \\boxed {\\operatorname {v e c} (t ^ {i} x ^ {j} g \\bmod h)} \\\\ \\vdots \\\\ \\boxed {\\operatorname {v e c} (t ^ {\\eta - 1} x ^ {d - \\kappa} g \\bmod h)} \\end{array} \\right) \\tag {1}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where, for all bivariate polynomial  <span class="math">w(t,x) = \\sum_{i=0}^{d} w_j(t)x^j</span>  with  <span class="math">w_j(t) = \\sum_{i=0}^{\\eta-1} w_{j,i} t^i</span> ,  <span class="math">\\operatorname{vec}(w) = (w_{0,0},\\ldots,w_{0,\\eta-1},\\ldots,w_{d,0},\\ldots,w_{d,\\eta-1})</span>  of dimension  <span class="math">(d+1)\\eta</span> . For instance,  <span class="math">\\operatorname{vec}(pt^i x^j) = (0,\\ldots,0,p,0,\\ldots,0)</span>  where only  <span class="math">(j\\eta + i+1)</span> -th entry is nonzero and  <span class="math">\\operatorname{vec}(g) = (g_{0,0},\\ldots,g_{0,\\eta-1},\\ldots,g_{\\kappa-1,0},\\ldots,g_{\\kappa-1,\\eta-1},1,0,\\ldots,0)</span>  for a monic polynomial  <span class="math">g</span>  of degree  <span class="math">\\kappa</span>  with respect to  <span class="math">x</span> . Note that the determinant of  <span class="math">M</span>  is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\det(M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p^{\\kappa\\eta}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, take the coefficients of  <span class="math">f(t,x) = \\sum_{j=0}^{d} f_j(t)x^j</span>  with  <span class="math">f_j(t) = \\sum_{i=0}^{\\eta-1} f_{j,i}t^i</span>  as the shortest vector of an LLL-reduced basis of the lattice  <span class="math">L</span>  and set  <span class="math">k = g \\mod p</span> . Then by construction we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\deg_x(f) = d\\geq \\kappa</span>  and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}:= \\max \\{f_{i,j}\\} = O\\big(p^{\\frac{\\kappa\\eta}{(d + 1)\\eta}}\\big) = O(p^{\\frac{\\kappa}{d + 1}});$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Example 1. We target a field  <span class="math">\\mathbb{F}_{p^4}</span>  for  <span class="math">p\\equiv 7</span>  mod 8 prime. For example, we take  <span class="math">p = 1000010903</span> . Set  <span class="math">\\eta = \\kappa = 2</span>  and  <span class="math">d = 2\\geq \\kappa</span> . Choose  <span class="math">h(t) = t^{2} + 1</span>  so that  <span class="math">h\\bmod p</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span> . Consider  <span class="math">R = \\mathbb{Z}(\\iota) = \\mathbb{Z}[t] / h(t)</span>  and  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p(\\iota) = \\mathbb{F}_p[t] / h(t)</span> . Choose  <span class="math">\\widetilde{g} = x^{2} + (t + 1)x + 1</span>  and  <span class="math">W = 1001\\geq p^{1 / (d + 1)}</span> . Then we set</p>

    <div class="my-4 text-center"><span class="math-block">g = \\left(\\widetilde {g} (t, x + W) \\bmod h\\right) = x ^ {2} + (\\iota + 2 0 0 3) x + 1 0 0 1 \\iota + 1 0 0 3 0 0 3.</span></div>

    <p class="text-gray-300">Construct a lattice of dimension 6 defined by the following matrix (blank entries are filled with zeros)</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c c c} p &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; p &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; p &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; p &amp;amp; &amp;amp; \\\\ 1 0 0 3 0 0 3 &amp;amp; 1 0 0 1 &amp;amp; 2 0 0 3 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ - 1 0 0 1 &amp;amp; 1 0 0 3 0 0 3 &amp;amp; - 1 &amp;amp; 2 0 0 3 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right).</span></div>

    <p class="text-gray-300">Run the LLL algorithm with this lattice and we obtain</p>

    <div class="my-4 text-center"><span class="math-block">f = (4 9 9 \\iota - 4 9 9 5 0 5) x ^ {2} + (4 9 9 9 9 2 \\iota - 4 9 8 1 1 1) x + 4 9 3 9 9 2 \\iota - 5 0 6 1 1.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One can check that  <span class="math">f, g, k = g \\mod p</span>  and  <span class="math">h</span>  are suitable for exTNFS algorithm. Note that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">  are of order  </span>p^{2/3}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Algorithm 1 Polynomial selection with the generalized JLSV <span class="math">_2</span>  method (gJLSV)</strong></p>

    <p class="text-gray-300">Input:  <span class="math">p</span>  prime,  <span class="math">n = \\eta \\kappa</span>  integer such that  <span class="math">\\eta, \\kappa &amp;gt; 1</span>  and  <span class="math">d \\geq \\kappa</span>  integer</p>

    <p class="text-gray-300">Output:  <span class="math">f, g, k, h</span>  with  <span class="math">h \\in \\mathbb{Z}[t]</span>  irreducible of degree  <span class="math">\\eta</span> , and  <span class="math">f, g \\in R[x]</span>  irreducible over  <span class="math">R = \\mathbb{Z}[t] / h\\mathbb{Z}[t]</span> , and  <span class="math">k = \\gcd(f \\bmod p, g \\bmod p)</span>  in  <span class="math">\\mathbb{F}_{p^\\eta} = \\mathbb{F}_p[t] / h(t)</span>  irreducible of degree  <span class="math">\\kappa</span></p>

    <p class="text-gray-300">1: Choose  <span class="math">h \\in \\mathbb{Z}[t]</span>  with small coefficients, irreducible of degree  <span class="math">\\eta</span>  such that  <span class="math">p</span>  is inert in  <span class="math">\\mathbb{Q}[t] / h(t)</span> ; 2: Choose a bivariate polynomial  <span class="math">\\widetilde{g}(t,x) = x^{\\kappa} + \\sum_{i=0}^{\\kappa-1} g_j(t)x^j</span>  with small coefficients; 3: Choose an integer  <span class="math">W \\approx p^{1/(d+1)}</span>  and set  <span class="math">g = \\widetilde{g}(t, x + W) \\mod h</span> ; 4: Reduce the rows of the matrix  <span class="math">L</span>  as defined in (1) using LLL, to get</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {L L L} (M) = \\left( \\begin{array}{c} f _ {0, 0}   f _ {0, 1}   \\dots   f _ {d, \\eta - 1} \\\\ * \\end{array} \\right)</span></div>

    <p class="text-gray-300">5: return  <span class="math">(f = \\sum_{0\\leq i\\leq d,0\\leq j &amp;lt;   \\eta}f_{i,j}t^{j}x^{i},g,k = g\\bmod p,h)</span></p>

    <p class="text-gray-300">Generalized Conjugation method We describe a polynomial selection method based on Conjugation method [15,2]. Again, we call it as the generalized Conjugation method (gConj method).</p>

    <p class="text-gray-300">First, one chooses two bivariate polynomials  <span class="math">g^{(1)}(t,x)</span>  and  <span class="math">g^{(0)}(t,x)</span>  in  <span class="math">\\mathbb{Z}[t,x]</span>  of form</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {(1)} (t, x) = g _ {0} ^ {(1)} (t) + g _ {1} ^ {(1)} (t) x + \\dots + g _ {\\kappa - 1} ^ {(1)} (t) x ^ {\\kappa - 1}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">g ^ {(0)} (t, x) = g _ {0} ^ {(0)} (t) + g _ {1} ^ {(0)} (t) x + \\dots + g _ {\\kappa} ^ {(0)} (t) x ^ {\\kappa},</span></div>

    <p class="text-gray-300">where <span class="math">g_{\\iota}^{(s)}(t)\\in\\mathbb{Z}[t]</span> are polynomials with small coefficients in <span class="math">\\mathbb{Z}</span> and of degree less than or equal to <span class="math">\\eta-1</span>. Then <span class="math">g^{(s)}\\bmod(p,h(t))</span> is a polynomial of degree <span class="math">\\leq\\kappa</span> over <span class="math">\\mathbb{F}_{p^{\\eta}}=\\mathbb{F}_{p}(\\iota)</span> for each <span class="math">s=1,2</span>.</p>

    <p class="text-gray-300">Next one chooses a quadratic, monic, irreducible polynomial <span class="math">\\mu(x)\\in\\mathbb{Z}[x]</span> with small coefficients. If <span class="math">\\mu(x)</span> has a root <span class="math">\\delta</span> modulo <span class="math">p</span> and <span class="math">g^{(0)}+\\delta g^{(1)}\\bmod(p,h)</span> is irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>, then set <span class="math">k(x)=g^{(0)}+\\delta g^{(1)}\\bmod(p,h)</span>. Otherwise, one repeats the above steps until such <span class="math">g^{(1)}</span>, <span class="math">g^{(0)}</span>, and <span class="math">\\delta</span> are found. Once it has been done, find <span class="math">u</span> and <span class="math">v</span> such that <span class="math">\\delta\\equiv u/v\\pmod{p}</span> and <span class="math">u,v\\leq O(\\sqrt{p})</span> using rational reconstruction. Finally, we set <span class="math">f=\\mathrm{Res}_{Y}(\\mu(Y),g^{(0)}+Yg^{(1)})</span> and <span class="math">g=vg^{(0)}+ug^{(1)}</span>. By construction we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\deg_{x}(f)=2\\kappa</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\max\\{f_{i,j}\\}=O(1)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The bound on $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> depends on the number of polynomials </span>g^{(0)}+\\delta g^{(1)}<span class="math"> tested before we find one which is irreducible over </span>\\mathbb{F}_{p^{\\eta}}<span class="math">. Heuristically this happens on average after </span>\\kappa<span class="math"> trials. Since there are </span>3^{2\\eta\\kappa}>\\kappa<span class="math"> choices of </span>g^{(0)}<span class="math"> and </span>g^{(1)}<span class="math"> of norm </span>1<span class="math"> we have </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)$. We give some examples in the followings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-10" class="text-base font-medium mt-4">Example 2</h6>

    <p class="text-gray-300">We target a field <span class="math">\\mathbb{F}_{p^{4}}</span> for <span class="math">p\\equiv 7\\bmod 8</span> prime. For example, we take <span class="math">p=1000010903</span>. If we choose <span class="math">h(t)=t^{2}+1</span> then <span class="math">h\\bmod p</span> is irreducible over <span class="math">\\mathbb{F}_{p}</span>. Consider <span class="math">R=\\mathbb{Z}(\\iota)=\\mathbb{Z}[t]/h(t)</span> and <span class="math">\\mathbb{F}_{p^{2}}=\\mathbb{F}_{p}(\\iota)=\\mathbb{F}_{p}[t]/h(t)</span>. Choose an irreducible polynomial <span class="math">\\mu(x)=x^{2}-2\\in\\mathbb{Z}[x]</span> with small coefficients. It has a root <span class="math">\\sqrt{2}=219983819\\in\\mathbb{F}_{p}</span> modulo <span class="math">p</span>. We take <span class="math">k(x)=(x^{2}+\\iota)+\\sqrt{2}x\\in\\mathbb{F}_{p^{2}}[x]</span> and <span class="math">f(x)=(x^{2}+\\iota+\\sqrt{2}x)(x^{2}+\\iota-\\sqrt{2}x)=x^{4}+(2\\iota-2)x^{2}+1\\in R[x]</span>. Then we find <span class="math">u,v\\in\\mathbb{Z}</span> such that <span class="math">u/v\\equiv\\sqrt{2}\\bmod p</span> where their orders are of <span class="math">\\sqrt{p}</span>. Now we take <span class="math">g(x)=v(x^{2}+\\iota)+ux=25834(x^{2}+\\iota)+18297x\\in R[x]</span>. One easily checks that <span class="math">f</span> and <span class="math">g</span> are irreducible over <span class="math">R</span> and <span class="math">k</span> is irreducible over <span class="math">\\mathbb{F}_{p^{2}}</span> so that they are suitable for exTNFS algorithm.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Example 3</h6>

    <p class="text-gray-300">Now we target a field <span class="math">\\mathbb{F}_{p^{9}}</span>. Again, we take <span class="math">p=1000010903</span> for example. Choose <span class="math">h(t)=t^{3}+t+1\\in\\mathbb{Z}[t]</span> which remains irreducible modulo <span class="math">p</span>. Let <span class="math">R=\\mathbb{Z}(\\iota)=\\mathbb{Z}[t]/h(t)</span> and <span class="math">\\mathbb{F}_{p^{3}}=\\mathbb{F}_{p}(\\iota)=\\mathbb{F}_{p}[t]/h(t)</span>. We set <span class="math">\\mu(x)=x^{2}-3</span>. Compute <span class="math">u</span> and <span class="math">v</span> such that <span class="math">u/v\\equiv\\sqrt{3}\\bmod p</span>. Then the polynomials <span class="math">k(x)=(x^{3}+\\iota)+\\sqrt{3}x\\in\\mathbb{F}_{p^{3}}[x]</span>, <span class="math">f(x)=(x^{3}+\\iota)^{2}-3x^{2}\\in R[x]</span> and <span class="math">g(x)=v(x^{3}+\\iota)+ux\\in R[x]</span> satisfy the conditions of polynomial selection for exTNFS algorithm.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">3.2.2 Relation Collection</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall the elements of <span class="math">R=\\mathbb{Z}[t]/h(t)</span> can be represented uniquely as polynomials of <span class="math">\\mathbb{Z}[t]</span> of degree less than <span class="math">\\deg h=\\eta</span>. In the setting of exTNFS, we sieve all the pairs <span class="math">(a,b)\\in\\mathbb{Z}[t]^{2}</span> of degree <span class="math">\\leq\\eta-1</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq A<span class="math"> (a parameter </span>A$ to be determined later) until we obtain a relation satisyfing</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">N_{f}(a,b)</span> <span class="math">:=\\mathrm{Res}_{t}(\\mathrm{Res}_{x}(a(t)-b(t)x,f(x)),h(t))\\text{ and }</span> <span class="math">N_{g}(a,b)</span> <span class="math">:=\\mathrm{Res}_{t}(\\mathrm{Res}_{x}(a(t)-b(t)x,g(x)),h(t))</span></p>

    <p class="text-gray-300">are <span class="math">B</span>-smooth for a parameter <span class="math">B</span> to be determined (an integer is <span class="math">B</span>-smooth if all its prime factors are less than <span class="math">B</span>). It is equivalent to say that the norm of</p>

    <p class="text-gray-300">Algorithm 2 Polynomial selection with the generalized Conjugation method (gConj) 0: <span class="math">p</span> prime and <span class="math">n=\\eta\\kappa</span> integer such that <span class="math">\\eta,\\kappa&gt;1</span> 0: <span class="math">f,g,k,h</span> with <span class="math">h\\in\\mathbb{Z}[t]</span> irreducible of degree <span class="math">\\eta</span>, and <span class="math">f,g\\in R[x]</span> irreducible over <span class="math">R=\\mathbb{Z}[t]/h\\mathbb{Z}[t]</span>, and <span class="math">k=\\gcd(f\\bmod p,g\\bmod p)</span> in <span class="math">\\mathbb{F}_{p^{\\eta}}=\\mathbb{F}_{p}[t]/h(t)</span> irreducible of degree <span class="math">\\kappa</span> 1: Choose <span class="math">h\\in\\mathbb{Z}[t]</span>, irreducible of degree <span class="math">\\eta</span> such that <span class="math">p</span> is inert in <span class="math">\\mathbb{Q}[t]/h(t)</span> 2: repeat 3: Select <span class="math">g_{0}^{(0)}(t),\\ldots,g_{\\kappa-1}^{(0)}(t)</span>, polynomials of degree <span class="math">\\leq\\eta-1</span> with small integer coefficients; 4: Select <span class="math">g_{0}^{(1)}(t),\\ldots,g_{\\kappa^{\\prime}-1}^{(1)}(t)</span>, polynomials of degree <span class="math">\\leq\\eta-1</span>, and <span class="math">g_{\\kappa^{\\prime}}^{(1)}(t)</span>, a constant polynomial with small integer coefficients, for an integer <span class="math">\\kappa^{\\prime}&lt;\\kappa</span>; 5: Set <span class="math">g^{(0)}(t,x)=x^{\\kappa}+\\sum_{i=0}^{\\kappa-1}g_{i}^{(0)}(t)x^{i}</span> and <span class="math">g^{(1)}(t,x)=\\sum_{i=0}^{\\kappa^{\\prime}}g_{i}^{(1)}(t)x^{i}</span>; 6: Select <span class="math">\\mu(x)</span> a quadratic, monic, irreducible polynomial over <span class="math">\\mathbb{Z}</span> with small coefficients; 7: until <span class="math">\\mu(x)</span> has a root <span class="math">\\delta</span> modulo <span class="math">p</span> and <span class="math">k=g^{(0)}+\\delta g^{(1)}\\bmod(p,h)</span> is irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>; 8: <span class="math">(u,v)\\leftarrow</span> a rational reconstruction of <span class="math">\\delta</span>; 9: <span class="math">f\\leftarrow\\text{Res}_{Y}(\\mu(Y),g_{0}+Yg_{1}\\bmod h)</span>; 10: <span class="math">g\\leftarrow vg_{0}+ug_{1}\\bmod h</span>; 11: return <span class="math">(f,g,k,h)</span></p>

    <p class="text-gray-300"><span class="math">a(\\iota)-b(\\iota)\\alpha_{f}</span> and <span class="math">a(\\iota)-b(\\iota)\\alpha_{g}</span> are simultaneously <span class="math">B</span>-smooth in <span class="math">K_{f}=\\mathbb{Q}(\\iota,\\alpha_{f})</span> and <span class="math">K_{g}=\\mathbb{Q}(\\iota,\\alpha_{g})</span>, respectively.</p>

    <p class="text-gray-300">For each pair <span class="math">(a,b)</span> one obtains a linear equation where the unknowns are logarithms of elements of the factor base as in the classical variant of NFS for discrete logarithms where the factor base is chosen as in <em>[15]</em>. Other than the polynomial selection step, our algorithm follows basically the same as the description of the exTNFS algorithm. For full description of the algorithm, refer to <em>[15]</em>.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 Complexity</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From now on, we often abuse the notation for a bivariate polynomial <span class="math">f(t,x)</span> in <span class="math">\\mathbb{Z}[t,x]</span> and a polynomial <span class="math">f(x)=f(t,x)\\bmod h=f(\\iota,x)</span> in <span class="math">R[x]</span>. Unless stated, <span class="math">\\deg(f)</span> denotes both the degree of <span class="math">f(x)\\in R[x]</span> and the degree of <span class="math">f(t,x)\\in\\mathbb{Z}[t,x]</span> with respect to <span class="math">x</span>. The norm of <span class="math">f(x)\\in R[x]</span>, denoted by $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, is defined by the maximum of the absolute value of the integer coefficients of </span>f(t,x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The complexity analysis of our algorithm basically follows that of all the other NFS variants. Recall that in the algorithm we test the smoothness of the norm of an element from the number field <span class="math">K_{f}</span> and <span class="math">K_{g}</span>. As a reminder to readers, we quote the formula for the complexity of exTNFS algorithm <em>[15]</em>,</p>

    <p class="text-gray-300"><span class="math">\\text{complexity}(\\text{exTNFS})=\\frac{B}{\\text{Prob}(N_{f},B)\\text{Prob}(N_{g},B)}+B^{2},</span> (2)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">N_{f}</span> denotes the norm of an element from <span class="math">K_{f}</span> over <span class="math">\\mathbb{Q}</span>, <span class="math">B</span> is a smoothness parameter, and <span class="math">\\mathrm{Prob}(x,y)</span> denotes the probability that an integer less than <span class="math">x</span> is <span class="math">y</span>-smooth.</p>

    <p class="text-gray-300">It leads us to consider the estimation of the norm sizes. We need the following lemma that can be found in <em>[15, Lemma 2]</em>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 1 (<em>[15]</em>, Lemma 2.).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">h\\in\\mathbb{Z}[t]</span> be an irreducible polynomial of degree <span class="math">\\eta</span> and <span class="math">f</span> be an irreducible polynomial over <span class="math">R=\\mathbb{Z}[t]/h(t)</span> of degree <span class="math">\\deg(f)</span>. Let <span class="math">\\iota</span> (resp. <span class="math">\\alpha</span>) be a root of <span class="math">h</span> (resp. <span class="math">f</span>) in its number field and set <span class="math">K_{f}:=\\mathbb{Q}(\\iota,\\alpha)</span>. Let <span class="math">A&gt;0</span> be a real number and <span class="math">T</span> an integer such that <span class="math">2\\leq T\\leq\\deg(f)</span>. For each <span class="math">i=0,\\ldots,\\deg(f)-1</span>, let <span class="math">a_{i}(t)\\in\\mathbb{Z}[t]</span> be polynomials of degree <span class="math">\\leq\\eta-1</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq A$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We have</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}N_{K_{f}/\\mathbb{Q}}\\big{(}\\sum_{i=0}^{T-1}a_{i}(\\iota)\\alpha^{i}\\big{)}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<A^{\\eta\\deg(f)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{(T-1)\\eta}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{(T+\\deg(f)-1)(\\eta-1)}D(\\eta,\\deg(f)),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">D(\\eta,\\kappa)=\\big{(}(2\\kappa-1)(\\eta-1)+1\\big{)}^{\\eta/2}(\\eta+1)^{(2\\kappa-1)(\\eta-1)/2}\\big{(}(2\\kappa-1)!\\eta^{2\\kappa}\\big{)}^{\\eta}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Assume in addition that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> is bounded by an absolute constant </span>H<span class="math"> and that </span>p=L_{Q}(\\ell_{p},c)<span class="math"> for some </span>\\ell_{p}>1/3<span class="math"> and </span>c>0$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$N_{f}(a,b)\\leq E^{\\deg(f)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\eta}L_{Q}(2/3,o(1)),$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">E=A^{\\eta}</span></p>

    <p class="text-gray-300">The above formula remains the same when we restrict the coefficients of <span class="math">f</span> to be integers.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof can be found in <em>[15]</em>.</p>

    <p class="text-gray-300">We summarize our results in the following theorem. The results are similar to Theorem 1 in <em>[15]</em>, however, we underline that in our algorithm <span class="math">n</span> is any composite. We also add the results on the upper bound of the complexity when <span class="math">n</span> is a <span class="math">b</span>-smooth number for <span class="math">b\\leq 4</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">(under the classical NFS heuristics) If <span class="math">Q=p^{n}</span> is a prime power such that <span class="math">p=L_{Q}(\\ell_{p},c_{p})</span> with <span class="math">1/3&lt;\\ell_{p}</span> and <span class="math">n=\\eta\\kappa</span> is a composite such that <span class="math">\\eta,\\kappa\\neq 1</span>, then the discrete logarithm over <span class="math">\\mathbb{F}_{Q}</span> can be solved in <span class="math">L_{Q}(1/3,(C/9)^{1/3})</span> where <span class="math">C</span> and the additional conditions are listed in Table 4.</p>

    <p class="text-gray-300">For each polynomial selection, the degree and the norm of the polynomials have the same formula as in <em>[15]</em>. Although in our case the polynomials <span class="math">f</span> and <span class="math">g</span> have coefficients in <span class="math">R</span>, the formula for the upper bound of the norm <span class="math">N_{f}(a,b)</span> remains the same as Kim-Barbulescu’s algorithm by Lemma 1. Finally, the analysis is simply rephrasing of the previous results, so we simply omit the proof. In the next subsection, we briefly explain how to obtain the upper bound of the complexity when <span class="math">n</span> has prime factors <span class="math">2</span> or <span class="math">3</span>. The case is interesting since most pairings use such fields to utilize tower extension field arithmetic for efficiency.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gJLSV2</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">κ = o((logQ/ log log Q)1/3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gGJL</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">κ ≤ (8/3)-4/3(logQ/ log log Q)1/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gConj</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">κ = 12-1/3(logQ/ log log Q)1/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 54.28</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i (i > 1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MexTNFS-gJLSV2</td>

            <td class="px-3 py-2 border-b border-gray-700">92+26√13/3</td>

            <td class="px-3 py-2 border-b border-gray-700">κ = o((logQ/ log log Q)1/3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MexTNFS-gGJL</td>

            <td class="px-3 py-2 border-b border-gray-700">92+26√13/3</td>

            <td class="px-3 py-2 border-b border-gray-700">κ ≤ (7+2√13/6)-1/3(logQ/ log log Q)1/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MexTNFS-gConj</td>

            <td class="px-3 py-2 border-b border-gray-700">(3+√33+12√6))3/14+6√6</td>

            <td class="px-3 py-2 border-b border-gray-700">κ = (56+24√6/12)-1/3(logQ/ log log Q)1/3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 59.80</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i 3j (i + j > 1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 50.76</td>

            <td class="px-3 py-2 border-b border-gray-700">n = 2i (i > 1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS-new</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">κ = o((logQ/ log log Q)1/3)p is d-SNFS with d = (2/3)3/3 + o(1)/κ(logQ/ log log Q)1/3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Complexity of exTNFS variants.</p>

    <p class="text-gray-300">Recall that our algorithm with Conjugation method has the same expression for the norms as in [2] replacing  <span class="math">p</span>  with  <span class="math">P = p^{\\eta}</span> . Write  <span class="math">P = L_{Q}(2/3, c_{P})</span>  and denote  <span class="math">\\tau - 1</span>  by the degree of sieving polynomials. Then the complexity of exTNFS-gConj is  <span class="math">L_{Q}(1/3, C_{\\mathrm{NFS}}(\\tau, c_{P}))</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">C _ {\\mathrm {N F S}} (\\tau , c _ {P}) = \\frac {2}{c _ {P} \\tau} + \\sqrt {\\frac {4}{(c _ {P} \\tau) ^ {2}} + \\frac {2}{3} c _ {P} (\\tau - 1)}. \\tag {4}</span></div>

    <p class="text-gray-300">Let  <span class="math">k_{0} = \\left(\\frac{\\log Q}{\\log \\log Q}\\right)^{1/3}</span> . When  <span class="math">n = 2^{i}</span>  for some  <span class="math">i &amp;gt; 1</span> , we can always find a factor  <span class="math">\\kappa</span>  of  <span class="math">n</span>  in the interval  <span class="math">\\left[\\frac{k_{0}}{3.31}, \\frac{k_{0}}{1.64}\\right]</span>  so that  <span class="math">c_{P}</span>  lies in the interval [1.64, 3.31] (observe that the ratio  <span class="math">(k_{0}/1.64)/(k_{0}/3.31)</span>  is larger than 2). Since  <span class="math">C(\\tau, c_{P})</span>  is less than 1.82 when  <span class="math">\\tau = 2</span>  and  <span class="math">1.64 \\leq c_{P} \\leq 3.31</span> , the complexity of exTNFS is always less than  <span class="math">L_{Q}(1/3, 1.82)</span>  in this case.</p>

    <p class="text-gray-300">This result shows that the DLP over  <span class="math">\\mathbb{F}_{p^n}</span>  can always be solved in the running time less than  <span class="math">L_{Q}(1/3, 1.82)</span>  when  <span class="math">n</span>  is a power of 2. Compare that exTNFS- <span class="math">\\mathcal{C}</span>  [18] has a larger asymptotic complexity of  <span class="math">L_{Q}(1/3, 1.92)</span>  and they even require the specified condition on a factor of  <span class="math">n</span> .</p>

    <p class="text-gray-300">A generalized polynomial selection method also admits a variant when the characteristic has a special form. It includes the case for the fields used in pairing-based cryptosystems. The previous SexTNFS by Kim and Barbulescu cannot be</p>

    <p class="text-gray-300">applied to pairing-friendly fields with prime power embedding degree, such as Kachisa-Schaefer-Scott curve <em>[14]</em> <span class="math">p=(u^{10}+2u^{9}+5u^{8}+48u^{6}+152u^{5}+240u^{4}+625u^{2}+2398u+3125)/980</span> of embedding degree 16.</p>

    <p class="text-gray-300">For a given integer <span class="math">d</span>, an integer <span class="math">p</span> is <span class="math">d</span>-SNFS if there exists an integer <span class="math">u</span> and a polynomial <span class="math">\\Pi(x)</span> with integer coefficients (up to a small denominator) so that</p>

    <p class="text-gray-300"><span class="math">p=\\Pi(u),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\deg\\Pi=d</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ is bounded by an absolute constant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We consider the case when <span class="math">n=\\eta\\kappa</span> (<span class="math">\\eta,\\kappa\\neq 1</span>) with <span class="math">\\kappa=o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{1/3}\\right)</span> and <span class="math">p</span> is <span class="math">d</span>-SNFS. In this case our exTNFS selects <span class="math">h</span>, <span class="math">f</span> and <span class="math">g</span> so that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">h</span> is a polynomial over <span class="math">\\mathbb{Z}</span> and irreducible modulo <span class="math">p</span>, <span class="math">\\deg h=\\eta</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f</span> and <span class="math">g</span> are two polynomials with coefficients from <span class="math">R=\\mathbb{Z}[\\iota]</span>, have a common factor <span class="math">k(x)</span> modulo <span class="math">p</span> which is irreducible over <span class="math">R/pR=\\mathbb{F}_{p^{\\eta}}=\\mathbb{F}(\\iota)</span> of degree <span class="math">\\kappa</span>.</li>

    </ul>

    <p class="text-gray-300">We choose such polynomials using the method of Joux and Pierrot <em>[13]</em>. Find a bivariate polynomial <span class="math">S</span> of degree <span class="math">\\kappa-1</span> with respect to <span class="math">x</span> such that</p>

    <p class="text-gray-300"><span class="math">S(t,x)=S_{0}(t)+S_{1}(t)x+\\cdots+S_{\\kappa-1}(t)x^{\\kappa-1}\\in\\mathbb{Z}[t,x],</span></p>

    <p class="text-gray-300">where <span class="math">S_{\\iota}(t)</span>’s have their coefficients in <span class="math">\\{-1,0,1\\}</span> and are of degree <span class="math">\\leq\\eta-1</span>. We further require that <span class="math">k=x^{\\kappa}+S(t,x)-u\\bmod(p,h)</span> is irreducible over <span class="math">\\mathbb{F}_{p^{\\eta}}</span>. Since the proportion of irreducible polynomials in <span class="math">\\mathbb{F}_{q}</span> (<span class="math">q</span>: a prime power) of degree <span class="math">\\kappa</span> is <span class="math">1/\\kappa</span> and there are <span class="math">3^{\\eta\\kappa}</span> choices we expect this step to succeed. Then we set</p>

    <p class="text-gray-300">\\[ \\left\\{g&=x^{\\kappa}+S(t,x)-u\\bmod h\\\\ f&=\\Pi(x^{\\kappa}+S(t,x))\\bmod h.\\right. \\]</p>

    <p class="text-gray-300">If <span class="math">f</span> is not irreducible over <span class="math">R[x]</span>, which happens with low probability, start over. Note that <span class="math">g</span> is irreducible modulo <span class="math">p</span> and that <span class="math">f</span> is a multiple of <span class="math">g</span> modulo <span class="math">p</span>. More precisely, as in <em>[13]</em>, we choose <span class="math">S(t,x)</span> so that the number of its terms is approximately <span class="math">O(\\log n)</span>. Since <span class="math">3^{\\log n}&gt;\\kappa</span>, this allows us enough chance to get an irreducible polynomial <span class="math">g</span>. The size of the largest integer coefficient of <span class="math">f</span> comes from the part <span class="math">S(t,x)^{d}</span> and it is bounded by <span class="math">\\sigma^{d}=O\\left((\\log n)^{d}\\right)</span>, where <span class="math">\\sigma</span> denotes the number of the terms in <span class="math">S(t,x)</span>. By construction we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\deg(g)=\\kappa</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=u=p^{1/d}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We inject these values in Equations (1) and obtain the same formula as in Kim-Barbulescu’s SexTNFS variant. Thus we obtain the same complexity as in their paper. Again, we note that our polynomial selection applies to fields of arbitrary composite extension degree <span class="math">n</span></p>

    <p class="text-gray-300">4.2 The multiple polynomial variants (MexTNFS-gConj)</p>

    <p class="text-gray-300">One can also accelerate the complexity of exTNFS with the generalized Conjugation method using multiple polynomial variants. The description is similar to the previous multiple variant of NFS: choose an irreducible quadratic polynomial <span class="math">\\mu(x)\\in\\mathbb{Z}[x]</span> such that it has small coefficients, and has a root <span class="math">\\delta</span> modulo <span class="math">p</span>. As before, choose <span class="math">k=g_{0}+\\delta g_{1}\\in\\mathbb{F}_{p^{\\eta}}[x]</span> and set <span class="math">f=Res_{Y}(\\mu(Y),g_{0}+Yg_{1})\\in R[x]</span>, where <span class="math">g_{0}</span> and <span class="math">g_{1}</span> are polynomials in <span class="math">R[x]</span>. We find two pairs of integers <span class="math">(u,v)</span> and <span class="math">(u^{\\prime},v^{\\prime})</span> using rational reconstrucion such that</p>

    <p class="text-gray-300"><span class="math">\\delta\\equiv u/v\\equiv u^{\\prime}/v^{\\prime}\\bmod p,</span></p>

    <p class="text-gray-300">where we require <span class="math">(u,v)</span> and <span class="math">(u^{\\prime},v^{\\prime})</span> are linearly independent over <span class="math">\\mathbb{Q}</span> and the integers <span class="math">u,v,u^{\\prime},v^{\\prime}</span> are all of the size of <span class="math">\\sqrt{p}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next we set <span class="math">f_{1}=f</span>, <span class="math">f_{2}=vg_{0}+ug_{1}</span> and <span class="math">f_{3}=v^{\\prime}g_{0}+u^{\\prime}g_{1}</span> and select other <span class="math">V-3</span> irreducible polynomials <span class="math">f_{i}:=\\mu_{i}f_{2}+\\nu_{i}f_{3}</span> where <span class="math">\\mu_{i}=\\sum_{j=0}^{\\eta-1}\\mu_{i,j}\\iota^{j}</span> and <span class="math">\\nu_{i}=\\sum_{j=0}^{\\eta-1}\\nu_{i,j}\\iota^{j}</span> are elements of <span class="math">R</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mu_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq V^{\\frac{1}{2\\eta}}<span class="math"> where </span>V=L_{Q}(1/3,c_{v})<span class="math"> is a parameter which will be selected later. Denote </span>\\alpha_{i}<span class="math"> a root of </span>f_{i}<span class="math"> for </span>i=1,2,\\ldots,V$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By construction, we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\deg(f_{1})=2\\kappa</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As before, evaluating these values into Equation (1), we obtain:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N_{f_{1}}(a,b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><E^{2\\kappa}L_{Q}(2/3,o(1))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We emphasize that <span class="math">\\left(V^{1/(2\\eta)}\\right)^{\\eta}=V^{1/2}=L_{Q}(2/3,o(1))</span>.</p>

    <p class="text-gray-300">Then, one can proceed the computation identical to <em>[17]</em>. When <span class="math">P=p^{\\eta}=L_{Q}(2/3,c_{P})</span> such that <span class="math">c_{P}&gt;(\\frac{7+2\\sqrt{13}}{6})^{1/3}</span> and <span class="math">\\tau-1</span> is the degree of the enumerated polynomials <span class="math">r</span>, then the complexity obtained is <span class="math">L_{Q}(1/3,C_{\\text{MNFS}}(\\tau,c_{P}))</span> where</p>

    <p class="text-gray-300"><span class="math">C_{\\text{MNFS}}(\\tau,c_{P})=\\frac{2}{c_{P}\\tau}+\\sqrt{\\frac{20}{9(c_{P}\\tau)^{2}}+\\frac{2}{3}c_{P}(\\tau-1)}.</span> (5)</p>

    <p class="text-gray-300">The best case occurs when <span class="math">c_{P}=(\\frac{56+24\\sqrt{6}}{12})^{1/3}</span> and <span class="math">\\tau=2</span> (linear polynomials):</p>

    <p class="text-gray-300"><span class="math">\\text{complexity(best case of MexTNFS-gConj)}=L_{Q}\\left(1/3,\\frac{3+\\sqrt{3(11+4\\sqrt{6})}}{\\left(18(7+3\\sqrt{6})\\right)^{1/3}}\\right).</span></p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">MexTNFS when <span class="math">n=2^{i}3^{j}</span></h4>

    <p class="text-gray-300">We separate this case into following two cases.</p>

    <p class="text-gray-300">Case 1: <span class="math">n=2^{i}3^{j}</span> for <span class="math">i+j&gt;1</span>. In this case, we can always find a factor <span class="math">\\kappa</span> of <span class="math">n</span> in the interval <span class="math">\\left[\\frac{k_{0}}{3.89},\\frac{k_{0}}{1.27}\\right]</span> where <span class="math">k_{0}=\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{1/3}</span> so that <span class="math">c_{P}</span>, where <span class="math">p^{\\eta}=L_{Q}(1/3,c_{P})</span>, is in the interval <span class="math">[1.27,3.89]</span>. Observe that the ratio <span class="math">(k_{0}/1.27)/(k_{0}/3.89)</span> is larger than <span class="math">3</span>. Since <span class="math">C_{\\text{MNFS}}(\\tau,c_{P})</span> in Equation (5) is less than <span class="math">1.88</span> when <span class="math">\\tau=2</span> and <span class="math">1.27\\leq c_{P}\\leq 3.89</span>, we have a result that the complexity of MexTNFS is always less than <span class="math">L_{Q}(1/3,1.88)</span>.</p>

    <p class="text-gray-300">Case 2: <span class="math">n=2^{i}</span> for some <span class="math">i&gt;1</span>. If <span class="math">n</span> is a power of <span class="math">2</span> we get a better result than Case 1. In this case we can always find a factor <span class="math">\\kappa</span> of <span class="math">n</span> in the interval <span class="math">\\left[\\frac{k_{0}}{3.09},\\frac{k_{0}}{1.52}\\right]</span> where <span class="math">k_{0}</span> is the same as Case 1. Again we check that the ratio <span class="math">(k_{0}/1.52)/(k_{0}/3.09)</span> is larger than <span class="math">2</span>. Since <span class="math">C_{\\text{MNFS}}(\\tau,c_{P})\\leq 1.78</span> for <span class="math">\\tau=2</span> and <span class="math">1.52\\leq c_{P}\\leq 3.09</span>, the complexity of MexTNFS is always less than <span class="math">L_{Q}(1/3,1.78)</span> in this case.</p>

    <p class="text-gray-300">This result shows that, if multiple variants are used, the DLP over <span class="math">\\mathbb{F}_{p^{n}}</span> can always be solved in the running time less than <span class="math">L_{Q}(1/3,1.88)</span> when <span class="math">n</span> is <span class="math">4</span>-smooth or less than <span class="math">L_{Q}(1/3,1.78)</span> when <span class="math">n</span> is a power of <span class="math">2</span> using MexTNFS algorithm. Recall that MexTNFS-<span class="math">\\mathcal{C}</span> <em>[18]</em> has the best asymptotic complexity <span class="math">L_{Q}(1/3,1.88)</span> only when <span class="math">n</span> is a power of <span class="math">2</span> and has a factor of the specified size.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Comparison and examples</h2>

    <p class="text-gray-300">In the context of NFS algorithm including its variants such as TNFS, exTNFS, we compute a large number of integers that are usually given by the norms of elements in number fields, and factor these numbers to test if they are <span class="math">B</span>-smooth for a parameter <span class="math">B</span>. These <span class="math">B</span>-smooth numbers are used to produce a linear relation of the discrete logarithm of the factor base elements, and we solve a linear system from those relations. Thus if we reduce the size of the norms computed in the algorithm we reduce the work of finding <span class="math">B</span>-smooth numbers, further it allows us to improve the total complexity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The term, the norm size, in this section is used for the bitsize of the product of the norms $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N_{f}(r\\bmod f)N_{g}(r\\bmod g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>r\\in R[x]<span class="math"> is a polynomial over </span>R<span class="math"> of degree less than </span>\\tau<span class="math"> and </span>f<span class="math"> and </span>g<span class="math"> are polynomials selected by each polynomial selection method. Each coefficient of </span>r<span class="math"> is considered as a polynomial in </span>\\mathbb{Z}[x]<span class="math"> of degree less than </span>\\eta<span class="math"> whose coefficients are bounded by a parameter </span>A=E^{1/\\eta}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As recent results <em>[15, 18]</em> show, the exTNFS variants have a smaller size of the norms than that in classical NFS. Thus, in this section, we mainly compare the norm size with exTNFS variants.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.1 A precise comparison when <span class="math">p</span> is arbitrary</h3>

    <p class="text-gray-300">We present the norm sizes in Table 5 depending on each variant of polynomial selection from exTNFS variants. Note that in our algorithm the extension degree <span class="math">n</span> can be any composite integer.</p>

    <p class="text-gray-300">We remark that a recent variant by Sarkar and Singh, exTNFS-<span class="math">\\mathcal{C}</span> <em>[18]</em>, is only interested in the case of <span class="math">\\lambda=\\eta</span> where <span class="math">\\lambda\\leq\\eta</span> denotes a parameter if</p>

    <p class="text-gray-300"><span class="math">k = k_{0} + k_{1}x + \\dots +k_{\\kappa}x^{\\kappa}\\in \\mathbb{F}_{p^{\\eta}}[x]</span>  such that  <span class="math">k_{i}\\in \\mathbb{F}_{p^{\\eta}}</span>  's are represented as polynomials over  <span class="math">\\mathbb{F}_p</span>  of degree  <span class="math">\\lambda -1</span>  . When  <span class="math">\\lambda = 1</span>  , all the coefficients of  <span class="math">k</span>  are in  <span class="math">\\mathbb{F}_p</span>  . Then  <span class="math">\\kappa = \\deg (k)</span>  and  <span class="math">\\eta</span>  should be relatively prime so that  <span class="math">k</span>  is irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span>  . Thus this case is not interesting since the case is already covered by Kim-Barbulescu's exTNFS. We do not consider the case when  <span class="math">1 &amp;lt;   \\lambda &amp;lt;  \\eta</span>  as mentioned in [18].</p>

    <p class="text-gray-300">We extrapolate the parameter  <span class="math">E</span>  using the formula  <span class="math">E = cL_{Q}(1/3, (8/9)^{1/3})</span>  such that  <span class="math">\\log_2 E = 30</span>  when  <span class="math">\\log_2 Q = 600</span>  (chosen from the record by Bouvier et al. [7]).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">norms product</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions and parameters</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-JLSV2 [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(κ+d)/τQτ-1/d+1</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, gcd(η, κ) = 1, d := deg(f) ≥ κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-GJL [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(2d+1)/τQτ-1/d+1</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, gcd(η, κ) = 1, d ≥ κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-Conj [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">E6κ/τQ(τ-1)/2κ</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, gcd(η, κ) = 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-C [18]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2κ0(2K+1)/τQ(τ-1)(K(λ-1)+κ1)/κ(Kλ+1)</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ = ηκ0κ1, K ≥ κ1, λ = η3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gJLSV2 (this)</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(κ+d)/τQτ-1/d+1</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, d := deg(f) ≥ κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gGJL (this)</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(2d+1)/τQτ-1/d+1</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, d ≥ κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">exTNFS-gConj (this)</td>

            <td class="px-3 py-2 border-b border-gray-700">E6κ/τQ(τ-1)/2κ</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Comparison of norm sizes, where  <span class="math">\\tau = \\deg r(x)</span> ,  <span class="math">d = \\deg(f)</span>  and  <span class="math">K, \\lambda</span>  are integer parameters subject to the conditions in the last column.</p>

    <p class="text-gray-300">The case of fields  <span class="math">\\mathbb{F}_{p^9}</span>  One of the interesting cases is when the extension degree  <span class="math">n</span>  is a prime power, e.g.  <span class="math">n = 4,9,16,32</span>  and so on. In this section, we particularly focus on the case  <span class="math">n = 9</span>  although one can also carry out a similar analysis for other cases.</p>

    <p class="text-gray-300">In this case the previous best polynomial selection method is exTNFS- <span class="math">\\mathcal{C}</span>  [18], so we compare our method with exTNFS- <span class="math">\\mathcal{C}</span> . We apply the algorithms with  <span class="math">\\eta = 3</span>  and  <span class="math">\\kappa = 3</span> . In particular, we have the following choices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>exTNFS- <span class="math">\\mathcal{C}</span>  with  <span class="math">\\kappa_0 = 3</span> ,  <span class="math">K = \\kappa_1 = 1</span>  and  <span class="math">\\lambda = 3</span>  has the optimal norm size of  <span class="math">E^9 Q^{1/4}</span>  when  <span class="math">\\tau = 2</span> .</li>

      <li>exTNFS- <span class="math">\\mathcal{C}</span>  with  <span class="math">\\kappa_0 = 1</span> ,  <span class="math">K = \\kappa_1 = 3</span>  and  <span class="math">\\lambda = 3</span>  has the optimal norm size of  <span class="math">E^7 Q^{3/10}</span>  when  <span class="math">\\tau = 2</span> .</li>

      <li>exTNFS-gJLSV <span class="math">_2</span>  has the optimal size of the norms  <span class="math">E^6 Q^{1/4}</span>  when  <span class="math">\\tau = 2</span> .</li>

      <li>exTNFS-gGJL has the optimal size of the norms  <span class="math">E^7 Q^{1/4}</span>  when  <span class="math">\\tau = 2</span> .</li>

      <li>exTNFS-gConj has the optimal size of the norms  <span class="math">E^9 Q^{1/6}</span>  when  <span class="math">\\tau = 2</span> .</li>

    </ul>

    <p class="text-gray-300">We plot the values of the norms in Figure 2. Note that exTNFS-gJLSV seems to be the best choice when the bitsize of target fields is between 300 and 1800 bits, otherwise exTNFS-gConj seems to be the best choice as the size of fields grows.</p>

    <p class="text-gray-300">The case of fields  <span class="math">\\mathbb{F}_{p^{12}}</span>  When  <span class="math">n</span>  is a composite that is not a prime power, such as  <span class="math">n = 6, 12, 18</span> , and so on, one can always find factors  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  such that  <span class="math">n = \\eta \\kappa</span>  and  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> . Thus it is possible to apply the polynomial selection as in Kim-Barculescu's exTNFS that is already the best choice in the sense of asymptotic complexity. However, from a practical perspective, one might have better choice by allowing to choose  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  that are not necessarily relatively prime. We plot the case of  <span class="math">n = 12</span>  as an example. Note that exTNFS-gConj with  <span class="math">\\kappa = 2</span>  seems to be the best choice when the size of fields is small (say, less than 500 bits) and exTNFS-gJLSV with  <span class="math">\\kappa = 2</span>  seems to be the best choice as the size of fields grows as shown in Figure 3. Remark that  <span class="math">\\kappa = 2</span>  seems to be the best choice in both cases. Note that this choice is not applicable with Kim-Barculescu's method since  <span class="math">\\eta = 6</span>  and  <span class="math">\\kappa = 2</span>  are not relatively prime.</p>

    <p class="text-gray-300">In Table 6, we provide precise norm sizes when  <span class="math">p</span>  is a  <span class="math">d</span> -SNFS prime. Note that our SexTNFS can be applied with arbitrary composite  <span class="math">n</span>  maintaining the same formula for the norm sizes as in [15].</p>

    <p class="text-gray-300">To compare the precise norm sizes, we choose the parameter  <span class="math">E</span>  using the formula  <span class="math">E = cL_{Q}(1/3, (4/9)^{1/3})</span>  and the pair  <span class="math">\\log_2 Q = 1039</span> ,  <span class="math">\\log_2 E = 30.38</span>  (due to the records by Aoki et al. [1]).</p>

    <p class="text-gray-300">We plot the norm sizes for each method in Figures 4 and 5. In our range of interest, each of the norm sizes has the minimum value when  <span class="math">\\tau = 2</span> , i.e. sieving only linear polynomials, so we only consider the case when  <span class="math">\\tau = 2</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">norms product</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conditions</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">STNFS [4]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2(d+1)/τQτ-1/d</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SNFS-JP [13]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2n(d+1)/τQτ-1/nd</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS-KimBar [15]</td>

            <td class="px-3 py-2 border-b border-gray-700">E2n(d+1)/τQτ-1/ed</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, gcd(κ, η) = 1 2 ≤ η < n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SexTNFS-new (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">E2n(d+1)/τQτ-1/ed</td>

            <td class="px-3 py-2 border-b border-gray-700">n = ηκ, 2 ≤ η < n</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Comparison of norm sizes when  <span class="math">p</span>  is  <span class="math">d</span> -SNFS prime.</p>

    <p class="text-gray-300">The case of  <span class="math">n = 12</span>  and  <span class="math">p</span>  is a 4-SNFS prime. This case is interesting due to Barreto-Naehrig pairing construction [6]. We plot the norm size in Figure 4 corresponding to each polynomial selection method. Note that exTNFS-gConj</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: Plot of the norms bitsize for several variants of NFS targeting  <span class="math">\\mathbb{F}_Q = \\mathbb{F}_{p^0}</span>  with  <span class="math">\\eta = \\kappa = 3</span> . Horizontal axis indicates the bitsize of  <span class="math">p^n</span>  while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: Plot of the norms bitsize for several variants of NFS targeting  <span class="math">\\mathbb{F}_Q = \\mathbb{F}_{p^{12}}</span>  with various choices for  <span class="math">\\kappa</span> . Horizontal axis indicates the bitsize of  <span class="math">p^n</span>  while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">with <span class="math">\\kappa=2</span> seems to be the best choice when the bitsize of fields is small (less than about 1000 bits) and SexTNFS with <span class="math">\\kappa=2</span> seems to be the best choice as the bitsize of fields grows. It should be remarked again that SexTNFS method with <span class="math">\\kappa=2</span> is impossible to apply with Kim-Barbulescu’s method.</p>

    <p class="text-gray-300">The case of <span class="math">n=16</span> and <span class="math">p</span> is a <span class="math">10</span>-SNFS prime. We consider another interesting case that appears in pairing-friendly constructions, Kachisa-Schaefer-Scott curve <em>[14]</em> with embedding degree 16.</p>

    <p class="text-gray-300">We compare the precise norm sizes of our SexTNFS with exTNFS-(g)Conj and exTNFS-<span class="math">\\mathcal{C}</span>. As shown in Figure 5, we suggest to use exTNFS-gConj with <span class="math">\\kappa=4</span> when the bitsize of target fields is small and to use SexTNFS with <span class="math">\\kappa=2</span> when the bitsize of target fields is large. The cross point appears when the bitsize is around 8000 bits.</p>

    <h2 id="sec-24" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">In this work, we show that the best complexity of Kim-Barbulescu’s exTNFS algorithm is still valid for fields of any composite extension degree <span class="math">n</span>. It asserts that pairings with embedding degree of a prime power cannot be an alternative to avoid the attack by Kim and Barbulescu and the keysize for such pairings also needs to be updated following to our attack.</p>

    <p class="text-gray-300">It is also interesting to remark that fields with extension degree of form <span class="math">n=2^{i}3^{j}</span> tend to be vulnerable to our attack compared to fields of any other extension degree. It is because when <span class="math">n</span> is a smooth number it is more likely to find a factor of <span class="math">n</span> so that its size is close to the desired size to obtain the best asymptotic complexity. Note that a large number of pairings have embedding degree only divisible by 2 or 3 for an efficient field arithmetic.</p>

    <p class="text-gray-300">From a practical point of view, our algorithm also performs better than Kim-Barbulescu’s algorithm although the asymptotic complexity remains the same. For example, when <span class="math">n=12</span>, the choice of <span class="math">(\\eta,\\kappa)=(6,2)</span> is better than <span class="math">(\\eta,\\kappa)=(4,3)</span> in terms of the norm sizes where the former case can only be covered by our algorithm.</p>

    <p class="text-gray-300">Precise evaluation of the keysize for pairing-based cryptosystems should be further studied. It would be also an interesting question to find efficient alternatives for Barreto-Naehrig curve that are not affected by our attack. Such curves potentially have a large embedding degree or a prime embedding degree. Pairings of embedding degree one might be also alternatives as considered in <em>[8]</em>. Nevertheless, such pairings might be very slow and still need to be further improved for cryptographers to use them.</p>

    <h2 id="sec-25" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] K. Aoki, J. Franke, T. Kleinjung, A. K. Lenstra, and D. A. Osvik. A kilobit special number field sieve factorization. In Advances in Cryptology – ASIACRYPT 2007, volume 4833 of Lecture Notes in Comput. Sci., pages 1–12, 2007.</li>

      <li>[</li>

    </ul>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4: Comparison when  <span class="math">n = 12</span>  and  <span class="math">p</span>  is a 4-SNFS for  <span class="math">300 \\leq \\log_2 Q \\leq 3000</span> . Horizontal axis indicates the bitsize of  <span class="math">Q = p^n</span>  while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5: Comparison when  <span class="math">n = 16</span>  and  <span class="math">p</span>  is a  <span class="math">d = 10</span> -SNFS prime. Horizontal axis indicates the bitsize of  <span class="math">p^n</span>  while the vertical axis the bitsize of the norms product.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture Notes in Comput. Sci., pages 129–155, 2015.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3. R. Barbulescu, P. Gaudry, A. Joux, and E. Thomé. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Advances in Cryptology - EUROCRYPT 2014, volume 8441 of Lecture Notes in Comput. Sci., pages 1–16, 2014.</li>

      <li>4. R. Barbulescu, P. Gaudry, and T. Kleinjung. The Towed Number Field Sieve. In Advances in Cryptology – ASIACRYPT 2015, volume 9453 of Lecture Notes in Comput. Sci., pages 31–55, 2015.</li>

      <li>5. R. Barbulescu and C. Pierrot. The multiple number field sieve for medium- and high-characteristic finite fields. LMS Journal of Computation and Mathematics, 17:230–246, 2014. The published version contains an error which is corrected in version 2 available at https://hal.inria.fr/hal-00952610.</li>

      <li>6. P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography – SAC 2005, volume 9566 of Lecture Notes in Comput. Sci., pages 319–331, 2005.</li>

      <li>7. C. Bouvier, P. Gaudry, L. Imbert, H. Jeljeli, and E. Thom. Discrete logarithms in GF(p) — 180 digits, 2014. Announcement available at the NMBRTHRY archives, item 004703.</li>

      <li>8. S. Chatterjee, A. Menezes, and F. Rodriguez-Henriquez. On implementing pairing-based protocols with elliptic curves of embedding degree one. Cryptology ePrint Archive, Report 2016/403, 2016. http://eprint.iacr.org/2016/403.</li>

      <li>9. D. M. Gordon. Discrete logarithms in <span class="math">GF(p)</span> using the number field sieve. SIAM J. Discret. Math., 6(1):124–138, Feb. 1993.</li>

      <li>10. R. Granger, T. Kleinjung, and J. Zumbrägel. On the powers of 2. Cryptology ePrint Archive, Report 2014/300, 2014. http://eprint.iacr.org/.</li>

      <li>11. A. Guillevic, F. Morain, and E. Thomé. Solving discrete logarithms on a 170-bit MNT curve by pairing reduction. In Selected Areas in Cryptography – SAC 2016, 2016.</li>

      <li>12. A. Joux, R. Lercier, N. P. Smart, and F. Vercauteren. The number field sieve in the medium prime case. In Advances in Cryptology - CRYPTO 2006, volume 4117 of Lecture Notes in Comput. Sci., pages 326–344, 2006.</li>

      <li>13. A. Joux and C. Pierrot. The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> – application to pairing-friendly constructions. In Pairing-Based Cryptography - Pairing 2013, volume 8365 of Lecture Notes in Comput. Sci., pages 45–61, 2013.</li>

      <li>14. E. J. Kachisa, E. F. Schaefer, and M. Scott. Constructing brezing-weng pairing-friendly elliptic curves using elements in the cyclotomic field. In Pairing-Based Cryptography - Pairing 2008, Second International Conference, Egham, UK, September 1-3, 2008. Proceedings, pages 126–135, 2008.</li>

      <li>15. T. Kim and R. Barbulescu. Extended Tower Number Field Sieve: A New Complexity for Medium Prime Case. In Advances in Cryptology – CRYPTO 2016.</li>

      <li>16. D. V. Matyukhin. Effective version of the number field sieve for discrete logarithm in a field <span class="math">GF(p^{k})</span>. Trudy po Diskretnoi Matematike, 9:121–151, 2006.</li>

      <li>17. C. Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture Notes in Comput. Sci., pages 156–170, 2015.</li>

      <li>18. P. Sarkar and S. Singh. A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm. IACR Cryptology ePrint Archive, 2016:485, 2016.</li>

    </ul>

    <p class="text-gray-300">19] P. Sarkar and S. Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Advances in Cryptology – EUROCRYPT 2016, volume 9665 of Lecture Notes in Comput. Sci., 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] O. Schirokauer. Discrete logarithms and local units. Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences, 345(1676):409–423, 1993.</li>

      <li>[21] O. Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comput., 69(231):1267–1283, 2000.</li>

    </ul>`;
---

<BaseLayout title="Extended Tower Number Field Sieve with Application to Finite... (2016/526)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/526
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
