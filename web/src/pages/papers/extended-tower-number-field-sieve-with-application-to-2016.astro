---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/526';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'Extended Tower Number Field Sieve with Application to Finite Fields of Arbitrary Composite Extension Degree';
const AUTHORS_HTML = 'Taechan Kim, Jinhyuck Jeong';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We propose a generalization of exTNFS algorithm recently introduced by Kim and Barbulescu (CRYPTO 2016). The algorithm, exTNFS, is a state-of-the-art algorithm for discrete logarithm in $\\mathbb{F}_{p^n}$ in the medium prime case, but it only applies when $n=\\eta\\kappa$ is a composite with nontrivial factors $\\eta$ and $\\kappa$ such that $\\gcd(\\eta,\\kappa)=1$. Our generalization, however, shows that exTNFS algorithm can be also adapted to the setting with an arbitrary composite $n$ maintaining its best asymptotic complexity. We show that one can solve discrete logarithm in medium case in the running time of $L_{p^n}(1/3, \\sqrt[3]{48/9})$ (resp. $L_{p^n}(1/3, 1.71)$ if multiple number fields are used), where $n$ is an \\textit{arbitrary composite}. This should be compared with a recent variant by Sarkar and Singh (Asiacrypt 2016) that has the fastest running time of $L_{p^n}(1/3, \\sqrt[3]{64/9})$ (resp. $L_{p^n}(1/3, 1.88)$) when $n$ is a power of prime 2. When $p$ is of special form, the complexity is further reduced to $L_{p^n}(1/3, \\sqrt[3]{32/9})$. On the practical side, we emphasize that the keysize of pairing-based cryptosystems should be updated following to our algorithm if the embedding degree $n$ remains composite.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Discrete Logarithm Problem &middot; Number Field Sieve &middot; Finite Fields &middot; Cryptanalysis</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Discrete logarithm problem (DLP) over a multiplicative subgroup of finite fields FQ, Q = p <sup>n</sup>, gathers its particular interest due to its prime importance in pairingbased cryptography. Over a generic group, the best known algorithm of the DLP takes exponential running time in the bitsize of the group order. However, in the case for the multiplicative group of finite fields one can exploit a special algebraic structure of the group to design better algorithms, where the DLP can be solved much more efficiently than in the exponential time. For example, when the characteristic p is small compared to the extension degree n, the best known algorithms have quasi-polynomial time complexity <a href="#page-19-0">[3</a><a href="#page-19-1">,10]</a>.</p>

    <p class="text-gray-300">Recall the usual LQ-notation,</p>

    <p class="text-gray-300"><span class="math">$L_Q(\\ell, c) = \\exp((c + o(1))(\\log Q)^{\\ell}(\\log \\log Q)^{1-\\ell}),</span>$</p>

    <p class="text-gray-300">for some constants 0 &le; <code> &le; 1 and c &gt; 0. We call the characteristic p = LQ(</code>p, cp) medium when 1/3 &lt; <code>&lt;sup&gt;p&lt;/sup&gt; &lt; 2/3 and large when 2/3 &lt; </code><sup>p</sup> &le; 1. We say that a field Fp<sup>n</sup> is in the boundary case when \`<sup>p</sup> = 2/3.</p>

    <p class="text-gray-300">For medium and large characteristic, all the best known attacks are variants of the number field sieve (NFS) algorithm. Initially used for factoring, NFS was rapidly introduced in DLP to target prime fields <a href="#page-19-2">[9,</a><a href="#page-20-0">20]</a>. It was about a decade later by Schirokauer <a href="#page-20-1">[21]</a> that NFS was adapted to target non-prime fields Fp<sup>n</sup> with n &gt; 1. This is known today as tower number field sieve (TNFS) <a href="#page-19-3">[4]</a>. On the other hand, an approach by Joux et al. <a href="#page-19-4">[12]</a>, which we denote by JLSV, was on a main stream of recent improvements on DLP over medium and large characteristic case. JLSV's idea is similar to the variant used to target prime fields, except the step called polynomial selection. This polynomial selection method was later supplemented with generalized Joux-Lercier (GJL) method <a href="#page-19-5">[16</a><a href="#page-19-6">,2]</a>, Conjugation (Conj) method <a href="#page-19-6">[2]</a>, and Sarkar-Singh (SS) method <a href="#page-20-2">[19]</a> leading improvements on the complexity of the NFS algorithm. However, in all these algorithms the complexity for the medium prime case is slightly larger than that of large prime case. Moreover there was an anomaly that the best complexity was obtained in the boundary case, \`<sup>p</sup> = 2/3.</p>

    <p class="text-gray-300">This abnormal behavior of the complexity in the NFS algorithm was partly removed in a recent breakthrough by Kim and Barbulescu <a href="#page-19-7">[15]</a> (exTNFS), where they obtained an algorithm of better complexity for the medium prime case than in the large prime case. Although this approach only applies to fields of extension degree n where n = &eta;&kappa; has factors &eta;, &kappa; &gt; 1 such that gcd(&eta;, &kappa;) = 1, it was enough to frighten pairing-based community since a number of popular pairing-friendly curves, such as Barreto-Naehrig curve <a href="#page-19-8">[6]</a>, are in the category that exTNFS applies.</p>

    <p class="text-gray-300">Then one might ask a question whether transitioning into pairing-friendly curves with embedding degree n, say, a prime power, would be immune to this recent attack by Kim and Barbulescu. Our answer is negative: we show that our algorithm has the same complexity as exTNFS algorithm for any composite n, so the keysize of the pairing-based cryptosystems should be updated according to our algorithm whenever the embedding degree is composite.</p>

    <p class="text-gray-300">Related works When the extension degree n cannot be factored into relatively prime factors (for example, n is a prime power), the best known attacks for the medium prime case still had the complexity L<sup>Q</sup> 1/3, p3 96/9 until Sarkar and Singh proposed an algorithm <a href="#page-19-9">[18]</a> of the best complexity L<sup>Q</sup> 1/3, p3 64/9 . Note that, however, this is still slightly larger than the best complexity of Kim-Barbulescu's exTNFS. One can see Table <a href="#page-2-0">1</a> for a comparison of these previous algorithms on the asymptotic complexity.</p>

    <p class="text-gray-300">All currently known variants of NFS admit variants with multiple number fields (MNFS) which have a slightly better asymptotic complexity. The complexity of these variants is shown in Table <a href="#page-2-1">2.</a></p>

    <p class="text-gray-300">When the characteristic p has a special form, as it is the case for fields in pairing-based cryptosystems, one can further accelerate NFS algorithms using</p>

    <p class="text-gray-300">Table 1: The complexity of each algorithm. Each cell in the second indicates c if the complexity is  <span class="math">L_Q(1/3, (c/9)^{\\frac{1}{3}})</span>  when  <span class="math">p = L_Q(\\ell_p)</span> ,  <span class="math">1/3 &lt; \\ell_p &lt; 2/3</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">complexity in the medium case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions on <span class="math">n</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-(Conj and GJL) [2]<br>exTNFS-C [18]<br>exTNFS-KimBar [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">96 \\ge 64^{1} \\ge 48^{1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n</span> : any integers <span class="math">n=2^i</span> for some <span class="math">i&gt;1</span> <span class="math">n=\\eta\\kappa\\;(\\eta,\\kappa\\neq 1),\\gcd(\\eta,\\kappa)=1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-new (this article)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\geq 48^1</span><br><span class="math">\\leq 54.28</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n</span> : any composite <span class="math">n=2^i</span> for some <span class="math">i&gt;1</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: The complexity of each algorithm using multiple number fields. Each cell in the second column indicates an approximation of c if the complexity is  <span class="math">L_Q(1/3, (c/9)^{\\frac{1}{3}})</span>  when  <span class="math">p = L_Q(\\ell_p)</span> ,  <span class="math">1/3 &lt; \\ell_p &lt; 2/3</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">complexity in the medium case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions on <span class="math">n</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MNFS-(Conj and GJL) [17]<br>MexTNFS-C [18]<br>MexTNFS-KimBar [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">89.45 \\\\ \\ge 61.29^{1} \\\\ \\ge 45.00^{1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n</span> : any integers <span class="math">n=2^i</span> for some <span class="math">i&gt;1</span> <span class="math">n=\\eta\\kappa\\;(\\eta,\\kappa\\neq 1),\\ \\gcd(\\eta,\\kappa)=1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MexTNFS-new (this article)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\geq 45.00^{1}</span><br><span class="math">\\leq 59.80</span><br><span class="math">\\leq 50.76</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n</span> : any composite <span class="math">n=2^i3^j</span> for some <span class="math">i+j&gt;1</span> <span class="math">n=2^i</span> for some <span class="math">i&gt;1</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">variants called special number field sieve (SNFS). In Table 3 we list asymptotic complexity of each algorithm. When n is a prime power, the algorithm by Joux and Pierrot had been the best algorithm before our algorithm.</p>

    <p class="text-gray-300">Recently, Gullevic, Morain, and Thom&eacute; [11] observed that Kim-Barbulescu's techinique can be adapted to target the fields of extension degree 4. However, they did not pursue the idea to further analyze its complexity.</p>

    <p class="text-gray-300">Our contributions We propose an algorithm that is a state-of-the-art algorithm for the DLP in the medium prime case as far as we aware. We remark that our algorithm applies to target fields of arbitrary composite extension degree n. If n can be written as  <span class="math">n = \\eta \\kappa</span>  for some  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  with  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> , our algorithm has the same complexity as Kim-Barbulescu's exTNFS [15]. However, our algorithm allows to choose factors  <span class="math">\\eta</span>  and  <span class="math">\\kappa</span>  freely from the co-primality condition, so we have more choices for the pair  <span class="math">(\\eta, \\kappa)</span> . This helps us to find a better  <span class="math">(\\eta, \\kappa)</span>  that</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup> The best complexity is obtained when n has a factor of the appropriate size (refer to each paper for details).</p>

    <p class="text-gray-300">Table 3: The complexity of each algorithm used when the characteristic has a special form (SNFS). Each cell indicates an approximation of c if the complexity is  <span class="math">L_Q(1/3, (c/9)^{\\frac{1}{3}})</span>  when  <span class="math">p = L_Q(\\ell_p)</span> ,  <span class="math">1/3 &lt; \\ell_p &lt; 2/3</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">complexity in the medium case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions on <span class="math">n</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-JP [13]<br>SexTNFS-KimBar [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64<br>32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n</span> : any integers <span class="math">n = \\eta \\kappa \\ (\\eta, \\kappa \\neq 1), \\gcd(\\eta, \\kappa) = 1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS-new (this article)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n: any composite</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">practically yields a better performance, although the asymptotic complexity is unchanged.</p>

    <p class="text-gray-300">If n is a prime power, the complexity of our algorithm is less than that of Sarkar-Singh's variant [18], a currently best-known algorithm for this case.</p>

    <p class="text-gray-300">When n is a b-smooth integer for an integer  <span class="math">b \\leq 4</span> , we show an upper bound for the asymptotic complexity of our algorithm. For example, when n is a power of 2, our algorithm always has the asymptotic complexity less than  <span class="math">L_Q(1/3, 1.82)</span> . If multiple NFS variants are used, the complexity can always be lowered to  <span class="math">L_Q(1/3,c)</span> ,  <span class="math">c \\leq 1.88</span> , when n is a 4-smooth composite integer, and  <span class="math">L_Q(1/3,c)</span> ,  <span class="math">c \\leq 1.78</span> , when n is a power of 2.</p>

    <p class="text-gray-300">When p is of special form, pairings with embedding degree such as n=4,9,16 was not affected by Kim-Barbulescu's algorithm, however, due to our variant of SNFS, the keysize of such pairings should be also updated following to our new complexity.</p>

    <p class="text-gray-300">Organization We briefly recall exTNFS algorithm and introduce our algorithm in Section 2. The complexity analysis is given in Section 3. The variants such as multiple number field sieve and special number field sieve are discussed in Section 4. In Section 5, we make a precise comparison to the state-of-the-art algorithms at cryptographic sizes. We conclude with cryptographic implications of our result in Section 6.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Extended TNFS</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Setting</h3>

    <p class="text-gray-300">Throughout this paper, we target fields  <span class="math">\\mathbb{F}_Q</span>  with  <span class="math">Q = p^n</span>  where  <span class="math">n = \\eta \\kappa</span>  such that  <span class="math">\\eta, \\kappa \\neq 1</span>  and the characteristic p is medium or large, i.e.  <span class="math">\\ell_p &gt; 1/3</span> .</p>

    <p class="text-gray-300">We briefly review exTNFS algorithm and then explain our algorithm. Recall the commutative diagram that is familiar in the context of NFS algorithm (Fig. 1). First we select an irreducible polynomial  <span class="math">h(t) \\in \\mathbb{Z}[t]</span>  of degree  <span class="math">\\eta</span>  which is also irreducible modulo p. We put  <span class="math">R := \\mathbb{Z}[t]/h(t) = \\mathbb{Z}(\\iota)</span>  then  <span class="math">R/pR \\simeq \\mathbb{F}_{p^{\\eta}}</span> . We select</p>

    <p class="text-gray-300">two polynomials f and g with coefficients in R so that they have a common factor k(x) of degree  <span class="math">\\kappa</span>  modulo p. We further require k to be irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . Note that the only difference of our algorithm from Kim-Barbulescu's exTNFS is that the coefficients of f and g are chosen from R instead of  <span class="math">\\mathbb{Z}</span> .</p>

    <p class="text-gray-300">The conditions on f, g and h yield two ring homomorphisms from R[x] to  <span class="math">(R/pR)/k(x) = \\mathbb{F}_{p^{\\eta\\kappa}}</span>  through R[x]/f(x) (or R[x]/g(x)). Thus one has the commutative diagram in Figure 1 which is a generalization of the classical diagram of NFS.</p>

    <p class="text-gray-300">    <img src="_page_4_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: Commutative diagram of exTNFS. We can choose f and g to be irreducible polynomials over R such that  <span class="math">k = \\gcd(f, g) \\mod p</span>  is irreducible over  <span class="math">R/pR = \\mathbb{F}_{p^{\\eta}}</span> .</p>

    <p class="text-gray-300">After the polynomial selection, the exTNFS algorithm proceeds as all other variants of NFS, following the same steps: relations collection, linear algebra and individual logarithm. We skip the description on it and refer to [15] for further details.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Detailed Descriptions</h3>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><strong>Polynomial Selection</strong></h4>

    <p class="text-gray-300">Choice of h We have to select a polynomial  <span class="math">h(t) \\in \\mathbb{Z}[t]</span>  of degree  <span class="math">\\eta</span>  which is irreducible modulo p and whose coefficients are as small as possible. As in TNFS [4] we try random polynomials h with small coefficients and factor them in  <span class="math">\\mathbb{F}_p[t]</span>  to test irreducibility. Heuristically, one succeeds after  <span class="math">\\eta</span>  trials and since  <span class="math">\\eta \\leq 3^{\\eta}</span>  we expect to find h such that  <span class="math">||h||_{\\infty} = 1</span> . For a more rigorous description on the existence of such polynomials one can refer to [4].</p>

    <p class="text-gray-300">Choice of f and g Next we select f and g in R[x] which have a common factor k(x) modulo p of degree  <span class="math">\\kappa</span>  which remains irreducible over  <span class="math">\\mathbb{F}_{p^\\eta}=R/pR</span> . We can adapt all the polynomial selection methods discussed in the previous literatures, such as JLSV's method [12], GJL and Conj [2] method, and so on[19,13,5,17], except that one chooses the coefficients of f and g from R instead of  <span class="math">\\mathbb{Z}</span> . To fix ideas, we describe polynomial selection methods based on JLSV<sub>2</sub> method and Conjugation method. A similar idea also applies with GJL method, but we skip the details.</p>

    <p class="text-gray-300">Generalized JLSV<sub>2</sub> method We describe a generalized method of polynomial selection based on JLSV<sub>2</sub> method [12]. To emphasize that the coefficients of polynomial are taken from a ring  <span class="math">R = \\mathbb{Z}[\\iota]</span>  instead of a smaller ring  <span class="math">\\mathbb{Z}</span> , we call it as generalized JLSV<sub>2</sub> method (gJLSV<sub>2</sub> method).</p>

    <p class="text-gray-300">First, we select a bivariate polynomial  <span class="math">\\widetilde{g}(t,x) \\in \\mathbb{Z}[t,x]</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{g}(t,x) = g_0(t) + g_1(t)x + \\dots + g_{\\kappa-1}(t)x^{\\kappa-1} + x^{\\kappa},</span>$</p>

    <p class="text-gray-300">where  <span class="math">g_i(t) \\in \\mathbb{Z}[t]</span> 's are polynomials of degree less than  <span class="math">\\eta</span>  with small integer coefficients. We also require  <span class="math">\\tilde{g} \\mod (p, h(t))</span>  to be irreducible in  <span class="math">\\mathbb{F}_{p^{\\eta}}[x]</span> . Set an integer  <span class="math">W \\approx p^{1/(d+1)}</span>  where d is a parameter such that  <span class="math">d \\geq \\kappa</span> . Take  <span class="math">g(t, x) := \\tilde{g}(t, x+W)</span>  and consider the lattice of dimension  <span class="math">(d+1)\\eta</span>  defined by the following matrix M:</p>

    <p class="text-gray-300">
<span class="math">$M := \\begin{pmatrix} \\boxed{ \\operatorname{vec}(pt^{0}x^{0} \\bmod h)} \\\\ \\vdots \\\\ \\operatorname{vec}(pt^{i}x^{j} \\bmod h) \\\\ \\vdots \\\\ \\operatorname{vec}(pt^{\\eta-1}x^{\\kappa-1} \\bmod h) \\\\ \\\\ \\vdots \\\\ \\operatorname{vec}(g \\bmod h) \\\\ \\vdots \\\\ \\operatorname{vec}(t^{i}x^{j}g \\bmod h) \\\\ \\\\ \\vdots \\\\ \\operatorname{vec}(t^{\\eta-1}x^{d-\\kappa}g \\bmod h) \\end{pmatrix}</span>$</p>

    <p class="text-gray-300"><span class="math">$(1)</span>$</p>

    <p class="text-gray-300">where, for all bivariate polynomial  <span class="math">w(t,x)=\\sum_{i=0}^d w_j(t)x^j</span>  with  <span class="math">w_j(t)=\\sum_{i=0}^{\\eta-1} w_{j,i}t^i</span> ,  <span class="math">\\operatorname{vec}(w)=(w_{0,0},\\ldots,w_{0,\\eta-1},\\ldots,w_{d,0},\\ldots,w_{d,\\eta-1})</span>  of dimension  <span class="math">(d+1)\\eta</span> . For instance,  <span class="math">\\operatorname{vec}(pt^ix^j)=(0,\\ldots,0,p,0,\\ldots,0)</span>  where only  <span class="math">(j\\eta+i+1)</span> -th entry is nonzero and  <span class="math">\\operatorname{vec}(g)=(g_{0,0},\\ldots,g_{0,\\eta-1},\\ldots,g_{\\kappa-1,0},\\ldots,g_{\\kappa-1,\\eta-1},1,0,\\ldots,0)</span>  for a monic polynomial g of degree  <span class="math">\\kappa</span>  with respect to x. Note that the determinant of M is  <span class="math">|\\det(M)|=p^{\\kappa\\eta}</span> .</p>

    <p class="text-gray-300">Finally, take the coefficients of  <span class="math">f(t,x) = \\sum_{j=0}^{d} f_j(t)x^j</span>  with  <span class="math">f_j(t) = \\sum_{i=0}^{\\eta-1} f_{j,i}t^i</span>  as the shortest vector of an LLL-reduced basis of the lattice L and set  <span class="math">k=g \\mod p</span> . Then by construction we have</p>

    <p class="text-gray-300"><span class="math">$- \\deg_x(f) = d \\ge \\kappa \\text{ and } ||f||_{\\infty} := \\max\\{f_{i,j}\\} = O\\left(p^{\\frac{\\kappa\\eta}{(d+1)\\eta}}\\right) = O(p^{\\frac{\\kappa}{d+1}});</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\deg_x(g) = \\kappa \\text{ and } ||g||_{\\infty} = \\max\\{g_{i,j}\\} = O(p^{\\frac{\\kappa}{d+1}}).</span>$</p>

    <p class="text-gray-300">Example 1. We target a field  <span class="math">\\mathbb{F}_{p^4}</span>  for  <span class="math">p \\equiv 7 \\mod 8</span>  prime. For example, we take p = 1000010903. Set  <span class="math">\\eta = \\kappa = 2</span>  and  <span class="math">d = 2 \\ge \\kappa</span> . Choose  <span class="math">h(t) = t^2 + 1</span>  so that  <span class="math">h \\mod p</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span> . Consider  <span class="math">R = \\mathbb{Z}(\\iota) = \\mathbb{Z}[t]/h(t)</span>  and  <span class="math">\\mathbb{F}_{p^2} = \\mathbb{F}_p(\\iota) = \\mathbb{F}_p[t]/h(t)</span> . Choose  <span class="math">\\widetilde{g} = x^2 + (t+1)x + 1</span>  and  <span class="math">W = 1001 \\ge p^{1/(d+1)}</span> . Then we set</p>

    <p class="text-gray-300"><span class="math">$g = (\\widetilde{g}(t, x + W) \\mod h) = x^2 + (\\iota + 2003)x + 1001\\iota + 1003003.</span>$</p>

    <p class="text-gray-300">Construct a lattice of dimension 6 defined by the following matrix (blank entries are filled with zeros)</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} p &amp; &amp; &amp; &amp; &amp; &amp; \\\\ &amp; p &amp; &amp; &amp; &amp; &amp; \\\\ &amp; &amp; p &amp; &amp; &amp; &amp;</span>$</p>

    <p class="text-gray-300">Run the LLL algorithm with this lattice and we obtain</p>

    <p class="text-gray-300"><span class="math">$f = (499\\iota - 499505)x^2 + (499992\\iota - 498111)x + 493992\\iota - 50611.</span>$</p>

    <p class="text-gray-300">One can check that  <span class="math">f, g, k = g \\mod p</span>  and h are suitable for exTNFS algorithm. Note that  <span class="math">||f||_{\\infty}</span>  and  <span class="math">||g||_{\\infty}</span>  are of order  <span class="math">p^{2/3}</span> .</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8">Algorithm 1 Polynomial selection with the generalized JLSV<sub>2</sub> method (gJLSV)</h3>

    <p class="text-gray-300"><strong>Input:</strong> p prime,  <span class="math">n = \\eta \\kappa</span>  integer such that  <span class="math">\\eta, \\kappa &gt; 1</span>  and  <span class="math">d \\ge \\kappa</span>  integer</p>

    <p class="text-gray-300"><strong>Output:</strong> f, g, k, h with  <span class="math">h \\in \\mathbb{Z}[t]</span>  irreducible of degree  <span class="math">\\eta</span> , and  <span class="math">f, g \\in R[x]</span>  irreducible over  <span class="math">R = \\mathbb{Z}[t]/h\\mathbb{Z}[t]</span> , and  <span class="math">k = \\gcd(f \\mod p, g \\mod p)</span>  in  <span class="math">\\mathbb{F}_{p^{\\eta}} = \\mathbb{F}_p[t]/h(t)</span>  irreducible of degree  <span class="math">\\kappa</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Choose  <span class="math">h \\in \\mathbb{Z}[t]</span>  with small coefficients, irreducible of degree  <span class="math">\\eta</span>  such that p is inert in  <span class="math">\\mathbb{Q}[t]/h(t)</span> ;</li>
      <li>2: Choose a bivariate polynomial  <span class="math">\\widetilde{g}(t,x) = x^{\\kappa} + \\sum_{i=0}^{\\kappa-1} g_j(t)x^j</span>  with small coefficients;</li>
      <li>3: Choose an integer  <span class="math">W \\approx p^{1/(d+1)}</span>  and set  <span class="math">g = \\widetilde{g}(t, x + W) \\mod h</span> ;</li>
      <li>4: Reduce the rows of the matrix L as defined in (1) using LLL, to get</li>
    </ul>

    <p class="text-gray-300"><span class="math">$LLL(M) = \\begin{pmatrix} f_{0,0} \\ f_{0,1} \\cdots f_{d,\\eta-1} \\\\ * \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">5: return
<span class="math">$(f = \\sum_{0 \\le i \\le d, 0 \\le j &lt; \\eta} f_{i,j} t^j x^i, g, k = g \\mod p, h)</span>$</p>

    <p class="text-gray-300">Generalized Conjugation method We describe a polynomial selection method based on Conjugation method [15,2]. Again, we call it as the generalized Conjugation method (gConj method).</p>

    <p class="text-gray-300">First, one chooses two bivariate polynomials  <span class="math">g^{(1)}(t,x)</span>  and  <span class="math">g^{(0)}(t,x)</span>  in  <span class="math">\\mathbb{Z}[t,x]</span>  of form</p>

    <p class="text-gray-300"><span class="math">$g^{(1)}(t,x) = g_0^{(1)}(t) + g_1^{(1)}(t)x + \\dots + g_{\\kappa-1}^{(1)}(t)x^{\\kappa-1}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$g^{(0)}(t,x) = g_0^{(0)}(t) + g_1^{(0)}(t)x + \\dots + g_{\\kappa}^{(0)}(t)x^{\\kappa},</span>$</p>

    <p class="text-gray-300">where  <span class="math">g_i^{(s)}(t) \\in \\mathbb{Z}[t]</span>  are polynomials with small coefficients in  <span class="math">\\mathbb{Z}</span>  and of degree less than or equal to  <span class="math">\\eta - 1</span> . Then  <span class="math">g^{(s)} \\mod (p, h(t))</span>  is a polynomial of degree  <span class="math">\\leq \\kappa</span>  over  <span class="math">\\mathbb{F}_{p^{\\eta}} = \\mathbb{F}_p(\\iota)</span>  for each s = 1, 2.</p>

    <p class="text-gray-300">Next one chooses a quadratic, monic, irreducible polynomial  <span class="math">\\mu(x) \\in \\mathbb{Z}[x]</span>  with small coefficients. If  <span class="math">\\mu(x)</span>  has a root  <span class="math">\\delta</span>  modulo p and  <span class="math">g^{(0)} + \\delta g^{(1)}</span>  mod (p,h) is irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> , then set  <span class="math">k(x) = g^{(0)} + \\delta g^{(1)}</span>  mod (p,h). Otherwise, one repeats the above steps until such  <span class="math">g^{(1)}</span> ,  <span class="math">g^{(0)}</span> , and  <span class="math">\\delta</span>  are found. Once it has been done, find u and v such that  <span class="math">\\delta \\equiv u/v \\pmod{p}</span>  and  <span class="math">u,v \\leq O(\\sqrt{p})</span>  using rational reconstruction. Finally, we set  <span class="math">f = \\mathrm{Res}_Y(\\mu(Y), g^{(0)} + Yg^{(1)})</span>  and  <span class="math">g = vg^{(0)} + ug^{(1)}</span> . By construction we have</p>

    <pre><code class="language-text"> - \\deg_x(f) = 2\\kappa \\text{ and } ||f||_{\\infty} = \\max\\{f_{i,j}\\} = O(1);
 - \\deg_x(g) = \\kappa \\text{ and } ||g||_{\\infty} = \\max\\{g_{i,j}\\} = O(\\sqrt{p}) = O(Q^{\\frac{1}{2\\eta\\kappa}}).
</code></pre>

    <p class="text-gray-300">The bound on  <span class="math">||f||_{\\infty}</span>  depends on the number of polynomials  <span class="math">g^{(0)} + \\delta g^{(1)}</span>  tested before we find one which is irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . Heuristically this happens on average after  <span class="math">\\kappa</span>  trials. Since there are  <span class="math">3^{2\\eta\\kappa} &gt; \\kappa</span>  choices of  <span class="math">g^{(0)}</span>  and  <span class="math">g^{(1)}</span>  of norm 1 we have  <span class="math">||f||_{\\infty} = O(1)</span> . We give some examples in the followings.</p>

    <p class="text-gray-300">Example 2. We target a field  <span class="math">\\mathbb{F}_{p^4}</span>  for  <span class="math">p\\equiv 7 \\mod 8</span>  prime. For example, we take p=1000010903. If we choose  <span class="math">h(t)=t^2+1</span>  then  <span class="math">h\\mod p</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span> . Consider  <span class="math">R=\\mathbb{Z}(\\iota)=\\mathbb{Z}[t]/h(t)</span>  and  <span class="math">\\mathbb{F}_{p^2}=\\mathbb{F}_p(\\iota)=\\mathbb{F}_p[t]/h(t)</span> . Choose an irreducible polynomial  <span class="math">\\mu(x)=x^2-2\\in\\mathbb{Z}[x]</span>  with small coefficients. It has a root  <span class="math">\\sqrt{2}=219983819\\in\\mathbb{F}_p</span>  modulo p. We take  <span class="math">k(x)=(x^2+\\iota)+\\sqrt{2}x\\in\\mathbb{F}_{p^2}[x]</span>  and  <span class="math">f(x)=(x^2+\\iota+\\sqrt{2}x)(x^2+\\iota-\\sqrt{2}x)=x^4+(2\\iota-2)x^2+1\\in R[x]</span> . Then we find  <span class="math">u,v\\in\\mathbb{Z}</span>  such that  <span class="math">u/v\\equiv\\sqrt{2}</span>  mod p where their orders are of  <span class="math">\\sqrt{p}</span> . Now we take  <span class="math">g(x)=v(x^2+\\iota)+ux=25834(x^2+\\iota)+18297x\\in R[x]</span> . One easily checks that f and g are irreducible over R and k is irreducible over  <span class="math">\\mathbb{F}_{p^2}</span>  so that they are suitable for exTNFS algorithm.</p>

    <p class="text-gray-300">Example 3. Now we target a field  <span class="math">\\mathbb{F}_{p^9}</span> . Again, we take p=1000010903 for example. Choose  <span class="math">h(t)=t^3+t+1\\in\\mathbb{Z}[t]</span>  which remains irreducible modulo p. Let  <span class="math">R=\\mathbb{Z}(\\iota)=\\mathbb{Z}[t]/h(t)</span>  and  <span class="math">\\mathbb{F}_{p^3}=\\mathbb{F}_p(\\iota)=\\mathbb{F}_p[t]/h(t)</span> . We set  <span class="math">\\mu(x)=x^2-3</span> . Compute u and v such that  <span class="math">u/v\\equiv\\sqrt{3}</span>  mod p. Then the polynomials  <span class="math">k(x)=(x^3+\\iota)+\\sqrt{3}x\\in\\mathbb{F}_{p^3}[x]</span> ,  <span class="math">f(x)=(x^3+\\iota)^2-3x^2\\in R[x]</span>  and  <span class="math">g(x)=v(x^3+\\iota)+ux\\in R[x]</span>  satisfy the conditions of polynomial selection for exTNFS algorithm.</p>

    <p class="text-gray-300"><strong>Relation Collection</strong> Recall the elements of  <span class="math">R = \\mathbb{Z}[t]/h(t)</span>  can be represented uniquely as polynomials of  <span class="math">\\mathbb{Z}[t]</span>  of degree less than deg  <span class="math">h = \\eta</span> . In the setting of exTNFS, we sieve all the pairs  <span class="math">(a,b) \\in \\mathbb{Z}[t]^2</span>  of degree  <span class="math">\\leq \\eta - 1</span>  such that  <span class="math">||a||_{\\infty}</span> ,  <span class="math">||b||_{\\infty} \\leq A</span>  (a parameter A to be determined later) until we obtain a relation satisfying</p>

    <p class="text-gray-300"><span class="math">$N_f(a,b) := \\operatorname{Res}_t(\\operatorname{Res}_x(a(t) - b(t)x, f(x)), h(t)) \\text{ and } N_g(a,b) := \\operatorname{Res}_t(\\operatorname{Res}_x(a(t) - b(t)x, g(x)), h(t))</span>$</p>

    <p class="text-gray-300">are B-smooth for a parameter B to be determined (an integer is B-smooth if all its prime factors are less than B). It is equivalent to say that the norm of</p>

    <p class="text-gray-300">Algorithm 2 Polynomial selection with the generalized Conjugation method (gConj)</p>

    <p class="text-gray-300"><strong>Input:</strong> p prime and  <span class="math">n = \\eta \\kappa</span>  integer such that  <span class="math">\\eta, \\kappa &gt; 1</span></p>

    <p class="text-gray-300"><strong>Output:</strong> f, g, k, h with  <span class="math">h \\in \\mathbb{Z}[t]</span>  irreducible of degree  <span class="math">\\eta</span> , and  <span class="math">f, g \\in R[x]</span>  irreducible over  <span class="math">R = \\mathbb{Z}[t]/h\\mathbb{Z}[t]</span> , and  <span class="math">k = \\gcd(f \\mod p, g \\mod p)</span>  in  <span class="math">\\mathbb{F}_{p^{\\eta}} = \\mathbb{F}_p[t]/h(t)</span>  irreducible of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1: Choose  <span class="math">h \\in \\mathbb{Z}[t]</span> , irreducible of degree  <span class="math">\\eta</span>  such that p is inert in  <span class="math">\\mathbb{Q}[t]/h(t)</span></p></li>
      <li><p class="text-gray-300">2: repeat</p></li>
      <li><p class="text-gray-300">Select  <span class="math">g_0^{(0)}(t), \\ldots, g_{\\kappa-1}^{(0)}(t)</span> , polynomials of degree  <span class="math">\\leq \\eta 1</span>  with small integer</p></li>
      <li><p class="text-gray-300">Select  <span class="math">g_0^{(1)}(t), \\ldots, g_{\\kappa&#x27;-1}^{(1)}(t)</span> , polynomials of degree  <span class="math">\\leq \\eta 1</span> , and  <span class="math">g_{\\kappa&#x27;}^{(1)}(t)</span> , a constant polynomial with small integer coefficients, for an integer  <span class="math">\\kappa&#x27; &lt; \\kappa</span> ; Set  <span class="math">g^{(0)}(t,x) = x^{\\kappa} + \\sum_{i=0}^{\\kappa-1} g_i^{(0)}(t)x^i</span>  and  <span class="math">g^{(1)}(t,x) = \\sum_{i=0}^{\\kappa&#x27;} g_i^{(1)}(t)x^i</span> ; Select  <span class="math">\\mu(x)</span>  a quadratic, monic, irreducible polynomial over  <span class="math">\\mathbb Z</span>  with small coefficients.</p></li>
      <li><p class="text-gray-300">7: <strong>until</strong>  <span class="math">\\mu(x)</span>  has a root  <span class="math">\\delta</span>  modulo p and  <span class="math">k = g^{(0)} + \\delta g^{(1)}</span>  mod (p, h) is irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> ;</p></li>
      <li><p class="text-gray-300">8:  <span class="math">(u, v) \\leftarrow</span>  a rational reconstruction of  <span class="math">\\delta</span> ;</p></li>
      <li><p class="text-gray-300">9:  <span class="math">f \\leftarrow \\operatorname{Res}_Y(\\mu(Y), g_0 + Yg_1 \\mod h)</span> ;</p></li>
      <li><p class="text-gray-300">10:  <span class="math">q \\leftarrow vq_0 + uq_1 \\mod h</span> ;</p></li>
      <li><p class="text-gray-300">11: <strong>return</strong> (f, g, k, h)</p></li>
    </ul>

    <p class="text-gray-300"><span class="math">a(\\iota) - b(\\iota)\\alpha_f</span>  and  <span class="math">a(\\iota) - b(\\iota)\\alpha_g</span>  are simultaneously B-smooth in  <span class="math">K_f = \\mathbb{Q}(\\iota, \\alpha_f)</span> and  <span class="math">K_q = \\mathbb{Q}(\\iota, \\alpha_q)</span> , respectively.</p>

    <p class="text-gray-300">For each pair (a, b) one obtains a linear equation where the unknowns are logarithms of elements of the factor base as in the classical variant of NFS for discrete logarithms where the factor base is chosen as in [15]. Other than the polynomial selection step, our algorithm follows basically the same as the description of the exTNFS algorithm. For full description of the algorithm, refer to [15].</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">Complexity 3</h4>

    <p class="text-gray-300">From now on, we often abuse the notation for a bivariate polynomial f(t,x) in  <span class="math">\\mathbb{Z}[t,x]</span>  and a polynomial  <span class="math">f(x)=f(t,x) \\mod h=f(\\iota,x)</span>  in R[x]. Unless stated,  <span class="math">\\deg(f)</span>  denotes both the degree of  <span class="math">f(x) \\in R[x]</span>  and the degree of  <span class="math">f(t,x) \\in \\mathbb{Z}[t,x]</span> with respect to x. The norm of  <span class="math">f(x) \\in R[x]</span> , denoted by  <span class="math">||f||_{\\infty}</span> , is defined by the maximum of the absolute value of the integer coefficients of f(t,x).</p>

    <p class="text-gray-300">The complexity analysis of our algorithm basically follows that of all the other NFS variants. Recall that in the algorithm we test the smoothness of the norm of an element from the number field  <span class="math">K_f</span>  and  <span class="math">K_g</span> . As a reminder to readers, we quote the formula for the complexity of exTNFS algorithm [15],</p>

    <p class="text-gray-300">complexity(exTNFS) =
<span class="math">$\\frac{B}{\\text{Prob}(N_f, B)\\text{Prob}(N_g, B)} + B^2</span>$
, (2)</p>

    <p class="text-gray-300">where  <span class="math">N_f</span>  denotes the norm of an element from  <span class="math">K_f</span>  over  <span class="math">\\mathbb{Q}</span> , B is a smoothness parameter, and  <span class="math">\\operatorname{Prob}(x,y)</span>  denotes the probability that an integer less than x is y-smooth.</p>

    <p class="text-gray-300">It leads us to consider the estimation of the norm sizes. We need the following lemma that can be found in [15, Lemma 2].</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> ([15], Lemma 2.). Let  <span class="math">h \\in \\mathbb{Z}[t]</span>  be an irreducible polynomial of degree  <span class="math">\\eta</span>  and f be an irreducible polynomial over  <span class="math">R = \\mathbb{Z}[t]/h(t)</span>  of degree  <span class="math">\\deg(f)</span> . Let  <span class="math">\\iota</span>  (resp.  <span class="math">\\alpha</span> ) be a root of h (resp. f) in its number field and set  <span class="math">K_f := \\mathbb{Q}(\\iota, \\alpha)</span> . Let A &gt; 0 be a real number and T an integer such that  <span class="math">2 \\le T \\le \\deg(f)</span> . For each  <span class="math">i = 0, \\ldots, \\deg(f) - 1</span> , let  <span class="math">a_i(t) \\in \\mathbb{Z}[t]</span>  be polynomials of degree  <span class="math">\\le \\eta - 1</span>  with  <span class="math">\\|a_i\\|_{\\infty} \\le A</span> .</p>

    <p class="text-gray-300">1. We have</p>

    <p class="text-gray-300"><span class="math">$\\left| N_{K_f/\\mathbb{Q}} \\Big( \\sum_{i=0}^{T-1} a_i(\\iota) \\alpha^i \\Big) \\right| &lt; A^{\\eta \\deg(f)} \\|f\\|_{\\infty}^{(T-1)\\eta} \\|h\\|_{\\infty}^{(T+\\deg(f)-1)(\\eta-1)} D(\\eta, \\deg(f)),</span>$</p>

    <p class="text-gray-300">where  <span class="math">D(\\eta, \\kappa) = ((2\\kappa - 1)(\\eta - 1) + 1)^{\\eta/2} (\\eta + 1)^{(2\\kappa - 1)(\\eta - 1)/2} ((2\\kappa - 1)!\\eta^{2\\kappa})^{\\eta}</span> . 2. Assume in addition that  <span class="math">||h||_{\\infty}</span>  is bounded by an absolute constant H and that  <span class="math">p = L_Q(\\ell_p, c)</span>  for some  <span class="math">\\ell_p &gt; 1/3</span>  and c &gt; 0. Then</p>

    <p class="text-gray-300"><span class="math">$N_f(a,b) \\le E^{\\deg(f)} \\|f\\|_{\\infty}^{\\eta} L_Q(2/3, o(1)),</span>$
(3)</p>

    <p class="text-gray-300">where  <span class="math">E = A^{\\eta}</span></p>

    <p class="text-gray-300">The above formula remains the same when we restrict the coefficients of f to be integers.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof can be found in [15].</p>

    <p class="text-gray-300">We summarize our results in the following theorem. The results are similar to Theorem 1 in [15], however, we underline that in our algorithm n is any composite. We also add the results on the upper bound of the complexity when n is a b-smooth number for  <span class="math">b \\leq 4</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> (under the classical NFS heuristics) If  <span class="math">Q = p^n</span>  is a prime power such that  <span class="math">p = L_Q(\\ell_p, c_p)</span>  with  <span class="math">1/3 &lt; \\ell_p</span>  and  <span class="math">n = \\eta \\kappa</span>  is a composite such that  <span class="math">\\eta, \\kappa \\neq 1</span> , then the discrete logarithm over  <span class="math">\\mathbb{F}_Q</span>  can be solved in  <span class="math">L_Q(1/3, (C/9)^{1/3})</span>  where C and the additional conditions are listed in Table 4.</p>

    <p class="text-gray-300">For each polynomial selection, the degree and the norm of the polynomials have the same formula as in [15]. Although in our case the polynomials f and g have coefficients in R, the formula for the upper bound of the norm  <span class="math">N_f(a,b)</span>  remains the same as Kim-Barbulescu's algorithm by Lemma 1. Finally, the analysis is simply rephrasing of the previous results, so we simply omit the proof. In the next subsection, we briefly explain how to obtain the upper bound of the complexity when n has prime factors 2 or 3. The case is interesting since most pairings use such fields to utilize tower extension field arithmetic for efficiency.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">C</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\text{exTNFS-gJLSV}_2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}\\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-gGJL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa \\le \\left(\\frac{8}{3}\\right)^{-\\frac{1}{3}} \\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-gConj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = 12^{-\\frac{1}{3}} \\left( \\frac{\\log Q}{\\log \\log Q} \\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\leq 54.28</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n=2^i \\ (i&gt;1)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\text{MexTNFS-gJLSV}_2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{92+26\\sqrt{13}}{3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}\\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">{\\bf MexTNFS\\text{-}gGJL}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{92+26\\sqrt{13}}{3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa \\le \\left(\\frac{7+2\\sqrt{13}}{6}\\right)^{-1/3} \\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MexTNFS-gConj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{(3+\\sqrt{33+12\\sqrt{6}})^3}{14+6\\sqrt{6}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = \\left(\\frac{56 + 24\\sqrt{6}}{12}\\right)^{-1/3} \\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = 2^i 3^j \\ (i+j&gt;1)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\leq 50.76</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = 2^i \\ (i &gt; 1)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS-new</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 90</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}\\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p \\text{ is } d\\text{-SNFS with } d = \\frac{(2/3)^{\\frac{1}{3}} + o(1)}{\\kappa} (\\frac{\\log Q}{\\log \\log Q})^{\\frac{1}{3}}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Complexity of exTNFS variants.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 exTNFS when <span class="math">n = 2^i</span></h3>

    <p class="text-gray-300">Recall that our algorithm with Conjugation method has the same expression for the norms as in [2] replacing p with  <span class="math">P = p^{\\eta}</span> . Write  <span class="math">P = L_Q(2/3, c_P)</span>  and denote  <span class="math">\\tau - 1</span>  by the degree of sieving polynomials. Then the complexity of exTNFS-gConj is  <span class="math">L_Q(1/3, C_{\\rm NFS}(\\tau, c_P))</span>  where</p>

    <p class="text-gray-300"><span class="math">$C_{\\text{NFS}}(\\tau, c_P) = \\frac{2}{c_P \\tau} + \\sqrt{\\frac{4}{(c_P \\tau)^2} + \\frac{2}{3} c_P(\\tau - 1)}.</span>$
(4)</p>

    <p class="text-gray-300">Let  <span class="math">k_0 = \\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{1/3}</span> . When  <span class="math">n=2^i</span>  for some i&gt;1, we can always find a factor  <span class="math">\\kappa</span>  of n in the interval  <span class="math">\\left[\\frac{k_0}{3.31},\\frac{k_0}{1.64}\\right]</span>  so that  <span class="math">c_P</span>  lies in the interval [1.64,3.31] (observe that the ratio  <span class="math">(k_0/1.64)/(k_0/3.31)</span>  is larger than 2). Since  <span class="math">C(\\tau,c_P)</span>  is less than 1.82 when  <span class="math">\\tau=2</span>  and  <span class="math">1.64 \\leq c_P \\leq 3.31</span> , the complexity of exTNFS is always less than  <span class="math">L_Q(1/3,1.82)</span>  in this case.</p>

    <p class="text-gray-300">This result shows that the DLP over  <span class="math">\\mathbb{F}_{p^n}</span>  can always be solved in the running time less than  <span class="math">L_Q(1/3, 1.82)</span>  when n is a power of 2. Compare that exTNFS- <span class="math">\\mathcal{C}</span>  [18] has a larger asymptotic complexity of  <span class="math">L_Q(1/3, 1.92)</span>  and they even require the specified condition on a factor of n.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Variants</h2>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 The case when p has a special form (SexTNFS)</h3>

    <p class="text-gray-300">A generalized polynomial selection method also admits a variant when the characteristic has a special form. It includes the case for the fields used in pairing-based cryptosystems. The previous SexTNFS by Kim and Barbulescu cannot be</p>

    <p class="text-gray-300">applied to pairing-friendly fields with prime power embedding degree, such as Kachisa-Schaefer-Scott curve [14]  <span class="math">p = (u^{10} + 2u^9 + 5u^8 + 48u^6 + 152u^5 + 240u^4 + 625u^2 + 2398u + 3125)/980</span>  of embedding degree 16.</p>

    <p class="text-gray-300">For a given integer d, an integer p is d-SNFS if there exists an integer u and a polynomial  <span class="math">\\Pi(x)</span>  with integer coefficients (up to a small denominator) so that</p>

    <p class="text-gray-300"><span class="math">$p = \\Pi(u),</span>$</p>

    <p class="text-gray-300"><span class="math">\\deg \\Pi = d</span>  and  <span class="math">\\|\\Pi\\|_{\\infty}</span>  is bounded by an absolute constant.</p>

    <p class="text-gray-300">We consider the case when  <span class="math">n=\\eta\\kappa</span>   <span class="math">(\\eta,\\kappa\\neq 1)</span>  with  <span class="math">\\kappa=o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{1/3}\\right)</span>  and p is d-SNFS. In this case our exTNFS selects h,f and g so that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>h is a polynomial over  <span class="math">\\mathbb{Z}</span>  and irreducible modulo p, deg  <span class="math">h = \\eta</span>  and  <span class="math">||h||_{\\infty} = O(1)</span> ;</li>
      <li>f and g are two polynomials with coefficients from  <span class="math">R = \\mathbb{Z}[\\iota]</span> , have a common factor k(x) modulo p which is irreducible over  <span class="math">R/pR = \\mathbb{F}_{p^{\\eta}} = \\mathbb{F}(\\iota)</span>  of degree  <span class="math">\\kappa</span> .</li>
    </ul>

    <p class="text-gray-300">We choose such polynomials using the method of Joux and Pierrot [13]. Find a bivariate polynomial S of degree  <span class="math">\\kappa-1</span>  with respect to x such that</p>

    <p class="text-gray-300"><span class="math">$S(t,x) = S_0(t) + S_1(t)x + \\dots + S_{\\kappa-1}(t)x^{\\kappa-1} \\in \\mathbb{Z}[t,x],</span>$</p>

    <p class="text-gray-300">where  <span class="math">S_i(t)</span> 's have their coefficients in  <span class="math">\\{-1,0,1\\}</span>  and are of degree  <span class="math">\\leq \\eta - 1</span> . We further require that  <span class="math">k = x^{\\kappa} + S(t,x) - u \\mod (p,h)</span>  is irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . Since the proportion of irreducible polynomials in  <span class="math">\\mathbb{F}_q</span>  (q: a prime power) of degree  <span class="math">\\kappa</span>  is  <span class="math">1/\\kappa</span>  and there are  <span class="math">3^{\\eta\\kappa}</span>  choices we expect this step to succeed. Then we set</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} g = x^{\\kappa} + S(t, x) - u \\mod h \\\\ f = \\Pi(x^{\\kappa} + S(t, x)) \\mod h. \\end{cases}</span>$</p>

    <p class="text-gray-300">If f is not irreducible over R[x], which happens with low probability, start over. Note that g is irreducible modulo p and that f is a multiple of g modulo p. More precisely, as in [13], we choose S(t,x) so that the number of its terms is approximately  <span class="math">O(\\log n)</span> . Since  <span class="math">3^{\\log n} &gt; \\kappa</span> , this allows us enough chance to get an irreducible polynomial g. The size of the largest integer coefficient of f comes from the part  <span class="math">S(t,x)^d</span>  and it is bounded by  <span class="math">\\sigma^d = O\\left((\\log n)^d\\right)</span> , where  <span class="math">\\sigma</span>  denotes the number of the terms in S(t,x). By construction we have:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp;-\\deg(g)=\\kappa \\text{ and } \\|g\\|_{\\infty}=u=p^{1/d};\\\\ &amp;-\\deg(f)=\\kappa d \\text{ and } \\|f\\|_{\\infty}=O((\\log n)^d). \\end{aligned}</span>$</p>

    <p class="text-gray-300">We inject these values in Equations (1) and obtain the same formula as in Kim-Barbulescu's SexTNFS variant. Thus we obtain the same complexity as in their paper. Again, we note that our polynomial selection applies to fields of arbitrary composite extension degree n.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 The multiple polynomial variants (MexTNFS-gConj)</h3>

    <p class="text-gray-300">One can also accelerate the complexity of exTNFS with the generalized Conjugation method using multiple polynomial variants. The description is similar to the previous multiple variant of NFS: choose an irreducible quadratic polynomial  <span class="math">\\mu(x) \\in \\mathbb{Z}[x]</span>  such that it has small coefficients, and has a root  <span class="math">\\delta</span>  modulo p. As before, choose  <span class="math">k = g_0 + \\delta g_1 \\in \\mathbb{F}_{p^\\eta}[x]</span>  and set  <span class="math">f = Res_Y(\\mu(Y), g_0 + Yg_1) \\in R[x]</span> , where  <span class="math">g_0</span>  and  <span class="math">g_1</span>  are polynomials in R[x]. We find two pairs of integers (u, v) and (u', v') using rational reconstruction such that</p>

    <p class="text-gray-300"><span class="math">$\\delta \\equiv u/v \\equiv u&#x27;/v&#x27; \\mod p</span>$
,</p>

    <p class="text-gray-300">where we require (u, v) and (u', v') are linearly independent over  <span class="math">\\mathbb{Q}</span>  and the integers u, v, u', v' are all of the size of  <span class="math">\\sqrt{p}</span> .</p>

    <p class="text-gray-300">Next we set  <span class="math">f_1 = f</span> ,  <span class="math">f_2 = vg_0 + ug_1</span>  and  <span class="math">f_3 = v&#x27;g_0 + u&#x27;g_1</span>  and select other V-3 irreducible polynomials  <span class="math">f_i := \\mu_i f_2 + \\nu_i f_3</span>  where  <span class="math">\\mu_i = \\sum_{j=0}^{\\eta-1} \\mu_{i,j} \\iota^j</span>  and  <span class="math">\\nu_i = \\sum_{j=0}^{\\eta-1} \\nu_{i,j} \\iota^j</span>  are elements of R such that  <span class="math">\\|\\mu_i\\|_{\\infty}, \\|\\nu_i\\|_{\\infty} \\leq V^{\\frac{1}{2\\eta}}</span>  where  <span class="math">V = L_Q(1/3, c_v)</span>  is a parameter which will be selected later. Denote  <span class="math">\\alpha_i</span>  a root of  <span class="math">f_i</span>  for  <span class="math">i = 1, 2, \\ldots, V</span> .</p>

    <p class="text-gray-300">By construction, we have:</p>

    <p class="text-gray-300"><span class="math">$- \\deg(f_1) = 2\\kappa \\text{ and } ||f_1||_{\\infty} = O(1);</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\deg(f_i) = \\kappa \\text{ and } ||f_i||_{\\infty} = V^{\\frac{1}{2\\eta}} (p^{\\eta \\kappa})^{1/(2\\kappa)} \\text{ for } 2 \\le i \\le V.</span>$</p>

    <p class="text-gray-300">As before, evaluating these values into Equation (1), we obtain:</p>

    <p class="text-gray-300"><span class="math">$|N_{f_1}(a,b)| &lt; E^{2\\kappa} L_Q(2/3,o(1))</span>$</p>

    <p class="text-gray-300"><span class="math">|N_{f_i}(a,b)| &lt; E^{\\kappa}(p^{\\kappa\\eta})^{\\frac{1}{2\\kappa}} L_Q(2/3,o(1)) \\text{ for } 2 \\le i \\le V.</span></p>

    <p class="text-gray-300">We emphasize that  <span class="math">(V^{1/(2\\eta)})^{\\eta} = V^{1/2} = L_Q(2/3, o(1)).</span></p>

    <p class="text-gray-300">Then, one can proceed the computation identical to [17]. When  <span class="math">P=p^{\\eta}=L_Q(2/3,c_P)</span>  such that  <span class="math">c_P&gt;(\\frac{7+2\\sqrt{13}}{6})^{1/3}</span>  and  <span class="math">\\tau-1</span>  is the degree of the enumerated polynomials r, then the complexity obtained is  <span class="math">L_Q(1/3,C_{\\text{MNFS}}(\\tau,c_P))</span>  where</p>

    <p class="text-gray-300">
<span class="math">$C_{\\text{MNFS}}(\\tau, c_P) = \\frac{2}{c_P \\tau} + \\sqrt{\\frac{20}{9(c_P \\tau)^2} + \\frac{2}{3}c_P(\\tau - 1)}.</span>$
(5)</p>

    <p class="text-gray-300">The best case occurs when  <span class="math">c_P=(\\frac{56+24\\sqrt{6}}{12})^{1/3}</span>  and  <span class="math">\\tau=2</span>  (linear polynomials):</p>

    <p class="text-gray-300"><span class="math">$\\text{complexity(best case of MexTNFS-gConj)} = L_Q\\left(1/3, \\frac{3+\\sqrt{3(11+4\\sqrt{6})}}{\\left(18(7+3\\sqrt{6})\\right)^{1/3}}\\right).</span>$</p>

    <p class="text-gray-300">MexTNFS when  <span class="math">n = 2^{i}3^{j}</span>  We separate this case into following two cases.</p>

    <p class="text-gray-300">Case 1:  <span class="math">n=2^i3^j</span>  for i+j&gt;1. In this case, we can always find a factor  <span class="math">\\kappa</span>  of n in the interval  <span class="math">\\left[\\frac{k_0}{3.89},\\frac{k_0}{1.27}\\right]</span>  where  <span class="math">k_0=\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{1/3}</span>  so that  <span class="math">c_P</span> , where  <span class="math">p^\\eta=L_Q(1/3,c_P)</span> , is in the interval [1.27,3.89]. Observe that the ratio  <span class="math">(k_0/1.27)/(k_0/3.89)</span>  is larger than 3. Since  <span class="math">C_{\\mathrm{MNFS}}(\\tau,c_P)</span>  in Equation (5) is less than 1.88 when  <span class="math">\\tau=2</span>  and  <span class="math">1.27\\leq c_P\\leq 3.89</span> , we have a result that the complexity of MexTNFS is always less than  <span class="math">L_Q(1/3,1.88)</span> .</p>

    <p class="text-gray-300">Case 2:  <span class="math">n=2^i</span>  for some i&gt;1. If n is a power of 2 we get a better result than Case 1. In this case we can always find a factor  <span class="math">\\kappa</span>  of n in the interval  <span class="math">\\left[\\frac{k_0}{3.09}, \\frac{k_0}{1.52}\\right]</span>  where  <span class="math">k_0</span>  is the same as Case 1. Again we check that the ratio  <span class="math">(k_0/1.52)/(k_0/3.09)</span>  is larger than 2. Since  <span class="math">C_{\\text{MNFS}}(\\tau, c_P) \\leq 1.78</span>  for  <span class="math">\\tau=2</span>  and  <span class="math">1.52 \\leq c_P \\leq 3.09</span> , the complexity of MexTNFS is always less than  <span class="math">L_Q(1/3, 1.78)</span>  in this case.</p>

    <p class="text-gray-300">This result shows that, if multiple variants are used, the DLP over  <span class="math">\\mathbb{F}_{p^n}</span>  can always be solved in the running time less than  <span class="math">L_Q(1/3, 1.88)</span>  when n is 4-smooth or less than  <span class="math">L_Q(1/3, 1.78)</span>  when n is a power of 2 using MexTNFS algorithm. Recall that MexTNFS- <span class="math">\\mathcal{C}</span>  [18] has the best asymptotic complexity  <span class="math">L_Q(1/3, 1.88)</span>  only when n is a power of 2 and has a factor of the specified size.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Comparison and examples</h2>

    <p class="text-gray-300">In the context of NFS algorithm including its variants such as TNFS, exTNFS, we compute a large number of integers that are usually given by the norms of elements in number fields, and factor these numbers to test if they are B-smooth for a parameter B. These B-smooth numbers are used to produce a linear relation of the discrete logarithm of the factor base elements, and we solve a linear system from those relations. Thus if we reduce the size of the norms computed in the algorithm we reduce the work of finding B-smooth numbers, further it allows us to improve the total complexity.</p>

    <p class="text-gray-300">The term, the norm size, in this section is used for the bitsize of the product of the norms  <span class="math">|N_f(r \\mod f)N_g(r \\mod g)|</span> , where  <span class="math">r \\in R[x]</span>  is a polynomial over R of degree less than  <span class="math">\\tau</span>  and f and g are polynomials selected by each polynomial selection method. Each coefficient of r is considered as a polynomial in  <span class="math">\\mathbb{Z}[x]</span>  of degree less than  <span class="math">\\eta</span>  whose coefficients are bounded by a parameter  <span class="math">A = E^{1/\\eta}</span> .</p>

    <p class="text-gray-300">As recent results [15,18] show, the exTNFS variants have a smaller size of the norms than that in classical NFS. Thus, in this section, we mainly compare the norm size with exTNFS variants.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 A precise comparison when p is arbitrary</h3>

    <p class="text-gray-300">We present the norm sizes in Table 5 depending on each variant of polynomial selection from exTNFS variants. Note that in our algorithm the extension degree n can be any composite integer.</p>

    <p class="text-gray-300">We remark that a recent variant by Sarkar and Singh, exTNFS- <span class="math">\\mathcal{C}</span>  [18], is only interested in the case of  <span class="math">\\lambda = \\eta</span>  where  <span class="math">\\lambda \\leq \\eta</span>  denotes a parameter if</p>

    <p class="text-gray-300"><span class="math">k = k_0 + k_1 x + \\dots + k_{\\kappa} x^{\\kappa} \\in \\mathbb{F}_{p^{\\eta}}[x]</span>  such that  <span class="math">k_i \\in \\mathbb{F}_{p^{\\eta}}</span> 's are represented as polynomials over  <span class="math">\\mathbb{F}_p</span>  of degree  <span class="math">\\lambda - 1</span> . When  <span class="math">\\lambda = 1</span> , all the coefficients of k are in  <span class="math">\\mathbb{F}_p</span> . Then  <span class="math">\\kappa = \\deg(k)</span>  and  <span class="math">\\eta</span>  should be relatively prime so that k is irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . Thus this case is not interesting since the case is already covered by Kim-Barbulescu's exTNFS. We do not consider the case when  <span class="math">1 &lt; \\lambda &lt; \\eta</span>  as mentioned in [18].</p>

    <p class="text-gray-300">We extrapolate the parameter E using the formula  <span class="math">E = cL_Q(1/3, (8/9)^{1/3})</span>  such that  <span class="math">\\log_2 E = 30</span>  when  <span class="math">\\log_2 Q = 600</span>  (chosen from the record by Bouvier et al. [7]).</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">norms product</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions and parameters</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-JLSV <sub>2</sub> [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(\\kappa+d)}{\\tau}}Q^{\\frac{\\tau-1}{d+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1,</span><br><span class="math">d := \\deg(f) \\ge \\kappa</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-GJL [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(2d+1)}{\\tau}}Q^{\\frac{\\tau-1}{d+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1,</span> <span class="math">d \\ge \\kappa</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-Conj [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{6\\kappa}{\\tau}}Q^{\\frac{(\\tau-1)}{2\\kappa}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS- <span class="math">C</span> [18]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa = \\eta \\kappa_0 \\kappa_1, K \\ge \\kappa_1, \\lambda = \\eta^3</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-gJLSV <sub>2</sub> (this)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(\\kappa+d)}{\\tau}}Q^{\\frac{\\tau-1}{d+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, d := \\deg(f) \\ge \\kappa</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-gGJL (this)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(2d+1)}{\\tau}}Q^{\\frac{\\tau-1}{d+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, d \\ge \\kappa</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-gConj (this)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{6\\kappa}{\\tau}}Q^{\\frac{(\\tau-1)}{2\\kappa}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5: Comparison of norm sizes, where  <span class="math">\\tau = \\deg r(x)</span> ,  <span class="math">d = \\deg(f)</span>  and  <span class="math">K, \\lambda</span>  are integer parameters subject to the conditions in the last column.</p>

    <p class="text-gray-300">The case of fields  <span class="math">\\mathbb{F}_{p^9}</span>  One of the interesting cases is when the extension degree n is a prime power, e.g. n=4,9,16,32 and so on. In this section, we particularly focus on the case n=9 although one can also carry out a similar analysis for other cases.</p>

    <p class="text-gray-300">In this case the previous best polynomial selection method is exTNFS- <span class="math">\\mathcal{C}</span>  [18], so we compare our method with exTNFS- <span class="math">\\mathcal{C}</span> . We apply the algorithms with  <span class="math">\\eta=3</span>  and  <span class="math">\\kappa=3</span> . In particular, we have the following choices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>exTNFS- <span class="math">\\mathcal{C}</span>  with  <span class="math">\\kappa_0 = 3</span> ,  <span class="math">K = \\kappa_1 = 1</span>  and  <span class="math">\\lambda = 3</span>  has the optimal norm size of  <span class="math">E^9 Q^{1/4}</span>  when  <span class="math">\\tau = 2</span> .</li>
      <li>exTNFS- <span class="math">\\mathcal{C}</span>  with  <span class="math">\\kappa_0 = 1</span> ,  <span class="math">K = \\kappa_1 = 3</span>  and  <span class="math">\\lambda = 3</span>  has the optimal norm size of  <span class="math">E^7 Q^{3/10}</span>  when  <span class="math">\\tau = 2</span> .</li>
      <li>exTNFS-gJLSV<sub>2</sub> has the optimal size of the norms  <span class="math">E^6Q^{1/4}</span>  when  <span class="math">\\tau=2</span> .</li>
      <li>exTNFS-gGJL has the optimal size of the norms  <span class="math">E^7Q^{1/4}</span>  when  <span class="math">\\tau=2</span> .</li>
      <li>exTNFS-gConj has the optimal size of the norms  <span class="math">E^9Q^{1/6}</span>  when  <span class="math">\\tau=2</span> .</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup> If  <span class="math">\\lambda = 1</span> , exTNFS- <span class="math">\\mathcal{C}</span>  is only applicable when  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> .</p>

    <p class="text-gray-300">We plot the values of the norms in Figure <a href="#page-16-0">2.</a> Note that exTNFS-gJLSV seems to be the best choice when the bitsize of target fields is between 300 and 1800 bits, otherwise exTNFS-gConj seems to be the best choice as the size of fields grows.</p>

    <p class="text-gray-300">The case of fields Fp<sup>12</sup> When n is a composite that is not a prime power, such as n = 6, 12, 18, and so on, one can always find factors &eta; and &kappa; such that n = &eta;&kappa; and gcd(&eta;, &kappa;) = 1. Thus it is possible to apply the polynomial selection as in Kim-Barbulescu's exTNFS that is already the best choice in the sense of asymptotic complexity. However, from a practical perspective, one might have better choice by allowing to choose &eta; and &kappa; that are not necessarily relatively prime. We plot the case of n = 12 as an example. Note that exTNFS-gConj with &kappa; = 2 seems to be the best choice when the size of fields is small (say, less than 500 bits) and exTNFS-gJLSV with &kappa; = 2 seems to be the best choice as the size of fields grows as shown in Figure <a href="#page-16-0">3.</a> Remark that &kappa; = 2 seems to be the best choice in both cases. Note that this choice is not applicable with Kim-Barbulescu's method since &eta; = 6 and &kappa; = 2 are not relatively prime.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Precise comparision when p is a special prime</h3>

    <p class="text-gray-300">In Table <a href="#page-15-0">6,</a> we provide precise norm sizes when p is a d-SNFS prime. Note that our SexTNFS can be applied with arbitrary composite n maintaining the same formula for the norm sizes as in <a href="#page-19-7">[15]</a>.</p>

    <p class="text-gray-300">To compare the precise norm sizes, we choose the parameter E using the formula E = cLQ(1/3,(4/9)1/<sup>3</sup> ) and the pair log<sup>2</sup> Q = 1039, log<sup>2</sup> E = 30.38 (due to the records by Aoki et al. <a href="#page-17-1">[1]</a>).</p>

    <p class="text-gray-300">We plot the norm sizes for each method in Figures <a href="#page-18-0">4</a> and <a href="#page-18-0">5.</a> In our range of interest, each of the norm sizes has the minimum value when &tau; = 2, i.e. sieving only linear polynomials, so we only consider the case when &tau; = 2.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">norms product</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">STNFS [4]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2(d+1)<br>&tau;&minus;1<br>E<br>Q<br>&tau;<br>d</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-JP [13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2n(d+1)<br>&tau;&minus;1<br>E<br>Q<br>&tau;<br>nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS-KimBar [15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&kappa;(d+1)<br>&tau;&minus;1<br>E<br>Q<br>&tau;<br>&kappa;d</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = &eta;&kappa;, gcd(&kappa;, &eta;) = 1<br>2 &le; &eta; &lt; n</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS-new (this work) E</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&kappa;(d+1)<br>&tau;&minus;1<br>Q<br>&tau;<br>&kappa;d</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = &eta;&kappa;, 2 &le; &eta; &lt; n</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6: Comparison of norm sizes when p is d-SNFS prime.</p>

    <p class="text-gray-300">The case of n = 12 and p is a 4-SNFS prime. This case is interesting due to Barreto-Naehrig pairing construction <a href="#page-19-8">[6]</a>. We plot the norm size in Figure <a href="#page-18-0">4</a> corresponding to each polynomial selection method. Note that exTNFS-gConj</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2: Plot of the norms bitsize for several variants of NFS targeting F<sup>Q</sup> = Fp<sup>9</sup> with &eta; = &kappa; = 3. Horizontal axis indicates the bitsize of p <sup>n</sup> while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3: Plot of the norms bitsize for several variants of NFS targeting F<sup>Q</sup> = Fp<sup>12</sup> with various choices for &kappa;. Horizontal axis indicates the bitsize of p <sup>n</sup> while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">with &kappa; = 2 seems to be the best choice when the bitsize of fields is small (less than about 1000 bits) and SexTNFS with &kappa; = 2 seems to be the best choice as the bitsize of fields grows. It should be remarked again that SexTNFS method with &kappa; = 2 is impossible to apply with Kim-Barbulescu's method.</p>

    <p class="text-gray-300">The case of n = 16 and p is a 10-SNFS prime. We consider another interesting case that appears in pairing-friendly constructions, Kachisa-Schaefer-Scott curve <a href="#page-19-14">[14]</a> with embedding degree 16.</p>

    <p class="text-gray-300">We compare the precise norm sizes of our SexTNFS with exTNFS-(g)Conj and exTNFS-C. As shown in Figure <a href="#page-18-0">5,</a> we suggest to use exTNFS-gConj with &kappa; = 4 when the bitsize of target fields is small and to use SexTNFS with &kappa; = 2 when the bitsize of target fields is large. The cross point appears when the bitsize is around 8000 bits.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">In this work, we show that the best complexity of Kim-Barbulescu's exTNFS algorithm is still valid for fields of any composite extension degree n. It asserts that pairings with embedding degree of a prime power cannot be an alternative to avoid the attack by Kim and Barbulescu and the keysize for such pairings also needs to be updated following to our attack.</p>

    <p class="text-gray-300">It is also interesting to remark that fields with extension degree of form n = 2<sup>i</sup>3 j tend to be vulnerable to our attack compared to fields of any other extension degree. It is because when n is a smooth number it is more likely to find a factor of n so that its size is close to the desired size to obtain the best asymptotic complexity. Note that a large number of pairings have embedding degree only divisible by 2 or 3 for an efficient field arithmetic.</p>

    <p class="text-gray-300">From a practical point of view, our algorithm also performs better than Kim-Barbulescu's algorithm although the asymptotic complexity remains the same. For example, when n = 12, the choice of (&eta;, &kappa;) = (6, 2) is better than (&eta;, &kappa;) = (4, 3) in terms of the norm sizes where the former case can only be covered by our algorithm.</p>

    <p class="text-gray-300">Precise evaluation of the keysize for pairing-based cryptosystems should be further studied. It would be also an interesting question to find efficient alternatives for Barreto-Naehrig curve that are not affected by our attack. Such curves potentially have a large embedding degree or a prime embedding degree. Pairings of embedding degree one might be also alternatives as considered in <a href="#page-19-16">[8]</a>. Nevertheless, such pairings might be very slow and still need to be further improved for cryptographers to use them.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">1. K. Aoki, J. Franke, T. Kleinjung, A. K. Lenstra, and D. A. Osvik. A kilobit special number field sieve factorization. In Advances in Cryptology &ndash; ASIACRYPT 2007, volume 4833 of Lecture Notes in Comput. Sci., pages 1&ndash;12, 2007.</p>

    <p class="text-gray-300">    <img src="_page_18_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4: Comparison when n = 12 and p is a 4-SNFS for 300 &le; log<sup>2</sup> Q &le; 3000. Horizontal axis indicates the bitsize of Q = p <sup>n</sup> while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">    <img src="_page_18_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5: Comparison when n = 16 and p is a d = 10-SNFS prime. Horizontal axis indicates the bitsize of p <sup>n</sup> while the vertical axis the bitsize of the norms product.</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">2. R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture Notes in Comput. Sci., pages 129&ndash;155, 2015.</p></li>
      <li><p class="text-gray-300">3. R. Barbulescu, P. Gaudry, A. Joux, and E. Thom&acute;e. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In Advances in Cryptology - EUROCRYPT 2014, volume 8441 of Lecture Notes in Comput. Sci., pages 1&ndash;16, 2014.</p></li>
      <li><p class="text-gray-300">4. R. Barbulescu, P. Gaudry, and T. Kleinjung. The Towed Number Field Sieve. In Advances in Cryptology &ndash; ASIACRYPT 2015, volume 9453 of Lecture Notes in Comput. Sci., pages 31&ndash;55, 2015.</p></li>
      <li><p class="text-gray-300">5. R. Barbulescu and C. Pierrot. The multiple number field sieve for medium- and high-characteristic finite fields. LMS Journal of Computation and Mathematics, 17:230&ndash;246, 2014. The published version contains an error which is corrected in version 2 available at <a href="https://hal.inria.fr/hal-00952610" target="_blank" rel="noopener noreferrer">https://hal.inria.fr/hal-00952610</a>.</p></li>
      <li><p class="text-gray-300">6. P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography &ndash; SAC 2005, volume 9566 of Lecture Notes in Comput. Sci., pages 319&ndash;331, 2005.</p></li>
      <li><p class="text-gray-300">7. C. Bouvier, P. Gaudry, L. Imbert, H. Jeljeli, and E. Thom. Discrete logarithms in GF(p) &mdash; 180 digits, 2014. Announcement available at the NMBRTHRY archives, item 004703.</p></li>
      <li><p class="text-gray-300">8. S. Chatterjee, A. Menezes, and F. Rodriguez-Henriquez. On implementing pairingbased protocols with elliptic curves of embedding degree one. Cryptology ePrint Archive, Report 2016/403, 2016. <a href="http://eprint.iacr.org/2016/403" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2016/403</a>.</p></li>
      <li><p class="text-gray-300">9. D. M. Gordon. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Discret. Math., 6(1):124&ndash;138, Feb. 1993.</p></li>
      <li><p class="text-gray-300">10. R. Granger, T. Kleinjung, and J. Zumbr&uml;agel. On the powers of 2. Cryptology ePrint Archive, Report 2014/300, 2014. <a href="http://eprint.iacr.org/" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">11. A. Guillevic, F. Morain, and E. Thom&acute;e. Solving discrete logarithms on a 170-bit MNT curve by pairing reduction. In Selected Areas in Cryptography &ndash; SAC 2016, 2016.</p></li>
      <li><p class="text-gray-300">12. A. Joux, R. Lercier, N. P. Smart, and F. Vercauteren. The number field sieve in the medium prime case. In Advances in Cryptology - CRYPTO 2006, volume 4117 of Lecture Notes in Comput. Sci., pages 326&ndash;344, 2006.</p></li>
      <li><p class="text-gray-300">13. A. Joux and C. Pierrot. The special number field sieve in Fp<sup>n</sup> &ndash; application to pairing-friendly constructions. In Pairing-Based Cryptography - Pairing 2013, volume 8365 of Lecture Notes in Comput. Sci., pages 45&ndash;61, 2013.</p></li>
      <li><p class="text-gray-300">14. E. J. Kachisa, E. F. Schaefer, and M. Scott. Constructing brezing-weng pairingfriendly elliptic curves using elements in the cyclotomic field. In Pairing-Based Cryptography - Pairing 2008, Second International Conference, Egham, UK, September 1-3, 2008. Proceedings, pages 126&ndash;135, 2008.</p></li>
      <li><p class="text-gray-300">15. T. Kim and R. Barbulescu. Extended Tower Number Field Sieve: A New Complexity for Medium Prime Case. In Advances in Cryptology &ndash; CRYPTO 2016.</p></li>
      <li><p class="text-gray-300">16. D. V. Matyukhin. Effective version of the number field sieve for discrete logarithm in a field GF(p k ). Trudy po Diskretnoi Matematike, 9:121&ndash;151, 2006.</p></li>
      <li><p class="text-gray-300">17. C. Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture Notes in Comput. Sci., pages 156&ndash;170, 2015.</p></li>
      <li><p class="text-gray-300">18. P. Sarkar and S. Singh. A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm. IACR Cryptology ePrint Archive, 2016:485, 2016.</p></li>
      <li><p class="text-gray-300">19. P. Sarkar and S. Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Advances in Cryptology &ndash; EUROCRYPT 2016, volume 9665 of Lecture Notes in Comput. Sci., 2016.</p></li>
      <li><p class="text-gray-300">20. O. Schirokauer. Discrete logarithms and local units. Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences, 345(1676):409&ndash;423, 1993.</p></li>
      <li><p class="text-gray-300">21. O. Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comput., 69(231):1267&ndash;1283, 2000.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Extended Tower Number Field Sieve with Application to Finite... (2016/526)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/526
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Extended TNFS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Setting</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Detailed Descriptions</a></li>
            <li><a href="#sec-3.1" class="hover:text-white">exTNFS when n = 2^i</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Variants</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">The case when p has a special form (SexTNFS)</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">The multiple polynomial variants (MexTNFS-gConj)</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Comparison and examples</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">A precise comparison when p is arbitrary</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Precise comparision when p is a special prime</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="extended-tower-number-field-sieve-with-application-to-2016" />
  </article>
</BaseLayout>
