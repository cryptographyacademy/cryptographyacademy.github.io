---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/254';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Towards Stream Ciphers for Efficient FHE  with Low-Noise Ciphertexts';
const AUTHORS_HTML = 'Pierrick Méaux, Anthony Journault, François-Xavier Standaert, Claude Carlet';

const CONTENT = `    <p class="text-gray-300">Towards Stream Ciphers for Efficient FHE with Low-Noise Ciphertexts</p>

    <p class="text-gray-300">Pierrick Méaux^{1}, Anthony Journault^{2}, François-Xavier Standaert^{2}, Claude Carlet^{3}.</p>

    <p class="text-gray-300">^{1} INRIA, CNRS, ENS and PSL Research University, Paris, France.</p>

    <p class="text-gray-300">^{2} ICTEAM/ELEN/Crypto Group, Université catholique de Louvain, Belgium.</p>

    <p class="text-gray-300">^{3} LAGA, Department of Mathematics, University of Paris VIII and University of Paris XIII, France.</p>

    <p class="text-gray-300">Abstract. Symmetric ciphers purposed for Fully Homomorphic Encryption (FHE) have recently been proposed for two main reasons. First, minimizing the implementation (time and memory) overheads that are inherent to current FHE schemes. Second, improving the homomorphic capacity, i.e. the amount of operations that one can perform on homomorphic ciphertexts before bootstrapping, which amounts to limit their level of noise. Existing solutions for this purpose suggest a gap between block ciphers and stream ciphers. The first ones typically allow a constant but small homomorphic capacity, due to the iteration of rounds eventually leading to complex Boolean functions (hence large noise). The second ones typically allow a larger homomorphic capacity for the first ciphertext blocks, that decreases with the number of ciphertext blocks (due to the increasing Boolean complexity of the stream ciphers’ output). In this paper, we aim to combine the best of these two worlds, and propose a new stream cipher construction that allows constant and small(er) noise. Its main idea is to apply a Boolean (filter) function to a public bit permutation of a constant key register, so that the Boolean complexity of the stream cipher outputs is constant. We also propose an instantiation of the filter function designed to exploit recent (3rd-generation) FHE schemes, where the error growth is quasi-additive when adequately multiplying ciphertexts with the same amount of noise. In order to stimulate further investigation, we then specify a few instances of this stream cipher, for which we provide a preliminary security analysis. We finally highlight the good properties of our stream cipher regarding the other goal of minimizing the time and memory complexity of calculus delegation (for 2nd-generation FHE schemes). We conclude the paper with open problems related to the large design space opened by these new constructions.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Purpose: calculus delegation. Recent years have witnessed massive changes in communication technologies, that can be summarized as a combination of two trends: (1) the proliferation of small embedded devices with limited storage and computing facilities, and (2) the apparition of cloud services with extensive storage and computing facilities. In this context, the outsourcing of data and the delegation of data processing gains more and more interest. Yet, such new opportunities also raise new security and privacy concerns. Namely, users typically want to prevent the server from learning about their data and processing. For this purpose, Gentry’s breakthrough Fully Homomorphic Encryption (FHE) scheme <em>[x10]</em> brought a perfect conceptual answer. Namely, it allows applying processing on ciphertexts in a homomorphic way so that after decryption, plaintexts have undergone the same operations as ciphertexts, but the server has not learned anything about these plaintexts.</p>

    <p class="text-gray-300">Application scenario. Cloud services can be exploited in a plethora of applications, some of them surveyed in <em>[x23]</em>. In general, they are always characterized by the aforementioned asymmetry between the communication parties. For illustration, we start by providing a simple example where data outsourcing and data processing delegation require security and privacy. Let us say that a patient, Alice, has undergone</p>

    <p class="text-gray-300">a surgery and is coming back home. The hospital gave her a monitoring watch (with limited storage) to measure her metabolic data on a regular basis. And this metabolic data should be made available to the doctor Bob, to follow the evolution of the post-surgery treatment. Quite naturally, Bob has numerous patients and no advanced computing facilities to store and process the data of all his patients. So this is a typical case where sending the data to a cloud service would be very convenient. That is, Alice’s data could be sent to and stored on the cloud, and associated to both her and the doctor Bob. And the cloud would provide Bob with processed information in a number of situations such as when the metabolic data of Alice is abnormal (in which case an error message should be sent to Bob), or during an appointment between Alice and Bob, so that Bob can follow the evolution of Alice’s data (possibly after some processing). Bob could in fact even be interested by accessing some other patient’s data, in order to compare the effect of different medications. And of course, we would like to avoid the cloud to know anything about the (private) data it is manipulating.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Typical Framework.</h4>

    <p class="text-gray-300">More technically, the previous exemplary application can be integrated in a quite general cloud service application framework, that can be seen as a combination of <span class="math">5</span> steps, combining a symmetric encryption scheme and an asymmetric homomorphic encryption scheme, as summarised in Figure 1 and described next:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialization. Alice runs the key generation algorithms <span class="math">H.\\mathsf{KeyGen}</span> and <span class="math">S.\\mathsf{KeyGen}</span> of the two schemes, and sends her homomorphic public key <span class="math">\\mathsf{pk}^{H}</span> and the homomorphic ciphertext of her symmetric key <span class="math">\\mathbf{C}^{H}(\\mathsf{sk}_{i}^{S})</span>.</li>

      <li>Storage. Alice encrypts her data <span class="math">m_{i}</span> with the symmetric encryption scheme, and sends <span class="math">\\mathbf{C}^{S}(m_{i})</span> to Claude.</li>

      <li>Evaluation. Claude homomorphically evaluates, with the <span class="math">H.\\mathsf{Eval}</span> algorithm, the decryption <span class="math">\\mathbf{C}^{H}(m_{i})</span> of the symmetric scheme on Alice’s data <span class="math">\\mathbf{C}^{S}(m_{i})</span>.</li>

      <li>Computation. Claude homomorphically executes the treatment <span class="math">f</span> on Alice’s encrypted data.</li>

      <li>Result. Claude sends a compressed encrypted result of the data treatment <span class="math">\\mathbf{c}^{H}(f(m_{i}))</span>, obtained with the <span class="math">H.\\mathsf{Comp}</span> algorithm, and Alice decrypts it.</li>

    </ol>

    <p class="text-gray-300">Note that if we assume the existence of a trusted third party active only during the initialization step, Alice can avoid Step 1, which needs a significant computational and memory storage effort. Note also that this framework is versatile: computation can be done in parallel (in a batch setting) or can be turned into a secret key FHE.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">FHE bottlenecks.</h4>

    <p class="text-gray-300">The main limitation for the deployment of cloud services based on such FHE frameworks relates to its important overheads, that can be related to two main concerns: computational and memory costs (especially on the client side) and limited homomorphic capacity (i.e. noise increase). More precisely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The computational and memory costs for the client depend overwhelmingly on the homomorphic encryption and decryption algorithms during the steps 1 and 5. The memory cost is mostly influenced by the homomorphic ciphertexts and public key sizes. Solving these two problems consists in building size-efficient FHE schemes with low computational cost <em>[x10, x16]</em>. On the server side, this computational cost further depends on the symmetric encryption scheme and function to evaluate.</li>

      <li>The homomorphic capacity relates to the fact that FHE constructions are built on noise-based cryptography, where the unbounded amount of homomorphic operations is guaranteed by an expensive bootstrapping technique. The homomorphic capacity corresponds to the amount of operations doable</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alice</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claude</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1: Initialization</td>

            <td class="px-3 py-2 border-b border-gray-700">(skH, pkH) ← H.KeyGen(λ)skS ← S.KeyGen(λ)CH(skS) = H.Enc(skS, pkH)</td>

            <td class="px-3 py-2 border-b border-gray-700">CH(skS), pkH</td>

            <td class="px-3 py-2 border-b border-gray-700">CH(skS), pkH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: Storage</td>

            <td class="px-3 py-2 border-b border-gray-700">CS(mi) = S.Enc(mi, skS)</td>

            <td class="px-3 py-2 border-b border-gray-700">CS(mi)</td>

            <td class="px-3 py-2 border-b border-gray-700">CS(mi)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: Evaluation</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CH(mi) = H.Eval(S.Dec(CS(mi), CH(skS), pkH))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">f</td>

            <td class="px-3 py-2 border-b border-gray-700">f</td>

            <td class="px-3 py-2 border-b border-gray-700">CH(f(mi)) = H.Eval(f(CH(mi))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: Result</td>

            <td class="px-3 py-2 border-b border-gray-700">cH(f(mi))f(mi) = H.Dec(cH(f(mi)), skH)</td>

            <td class="px-3 py-2 border-b border-gray-700">cH(f(mi))</td>

            <td class="px-3 py-2 border-b border-gray-700">cH(f(mi)) = H.Comp(CH(f(mi)))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig.1. Homomorphic Encryption - Symmetric Encryption framework.  <span class="math">H</span>  and  <span class="math">S</span>  respectively refer to homomorphic and symmetric encryption schemes, for algorithms (e.g.  <span class="math">H.\\mathrm{KeyGen}</span> ) or scheme components (e.g.  <span class="math">\\mathsf{sk}^S</span> ).</p>

    <p class="text-gray-300">before the noise growing too much forcing to use bootstrapping. Therefore, and in order to reduce the time and computational cost of the framework, it is important to manage the error growth during the homomorphic operations (i.e. steps 3 and 4). Furthermore, since the 4th step is the most important one from the application point-of-view (since this is where the useful operations are performed by the cloud), there is strong incentive to minimize the cost of the homomorphic decryption in the 3rd step.</p>

    <p class="text-gray-300">Previous works. In order to mitigate these bottlenecks, several works tried to reduce more and more the homomorphic cost of evaluating a symmetric decryption algorithm. First attempts in this direction, which were also used as benchmark for FHE implementations, used the AES for this purpose [GHS12, CLT14]. Various alternative schemes were also considered, all with error and sizes depending on the multiplicative depth of the symmetric encryption scheme, such as BGV [BGV12] and FV [FV12]. Additional optimizations exploited batching and bitslicing, leading to the best results of performing 120 AES decryptions in 4 minutes [GHS12].</p>

    <p class="text-gray-300">Since the multiplicative depth of the AES decryption evaluation was a restrictive bound in these works, other symmetric encryption schemes were then considered. The most representative attempts in this direction are the family of block ciphers LowMC  <span class="math">\\left[\\mathrm{ARS}^{+}15\\right]</span>  and the stream cipher Kreyvium  <span class="math">\\left[\\mathrm{CCF}^{+}15\\right]</span> . These constructions led to reduced and more suitable multiplicative depths. Yet, and intuitively, these attempts were still limited by complementary drawbacks. First for LowMC, the remaining multiplicative depth</p>

    <p class="text-gray-300">remains large enough to significantly reduce the homomorphic capacity (i.e. increase the noise). Such a drawback seems to be inherent in block cipher structures where the iteration of rounds eventually leads to Boolean functions with large algebraic degree, which inevitably imply a constant per block but high noise after homomorphic evaluation. For example, ciphers dedicated to efficient masking against side-channel attacks <em>[PRC12, GLSV14, GGNS13]</em>, which share the goal of minimizing the multiplicative complexity, suffer from similar issues and it seems hard to break the barrier of one multiplication per round (and therefore of 12 to 16 multiplications for 128-bit ciphers). Second for Kreyvium, the error actually grows with the number of evaluated ciphertexts, which implies that at some point, the output ciphertexts are too noisy, and cannot be decrypted (which requires either to bootstrap or to re-initialize the stream cipher).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our contribution.</h4>

    <p class="text-gray-300">In view of this state-of-the-art, a natural direction would be to try combining the best of these two previous works. That is, to design a cipher inheriting from the constant noise property offered by block ciphers, and the lower noise levels of stream ciphers (due to the lower algebraic degree of their outputs), leading to the following contributions.</p>

    <p class="text-gray-300">First, we introduce a new stream cipher construction, next denoted as a filter permutator (by analogy with filter generators). Its main design principle is to filter a constant key register with a variable (public) bit permutation. More precisely, at each cycle, the key register is (bit) permuted with a pseudorandomly generated permutation, and we apply a non-linear filtering function to the output of this permuted key register. The main advantage of this construction is to always apply the non-linear filtering directly on the key bits, which allows maintaining the noise level of our outputs constant. Conceptually, this type of construction seems appealing for any FHE scheme.</p>

    <p class="text-gray-300">Second, and going deeper in the specification of a concrete scheme, we discuss the optimization of the components in a filter permutator, with a focus on the filtering function (which determines the output noise after homomorphic evaluation). For this purpose, we first notice that existing FHE schemes can be split in (roughly) two main categories. On one hand the so-called 2nd-generation FHE (such as <em>[BGV12, CLT14]</em>) where the metric for the noise growth is essentially the multiplicative depth of the circuit to homomorphically evaluate. On the other hand, the so-called 3rd-generation FHE (such as <em>[GSW13, AP14]</em>) where the error growth is asymmetric, and in particular quasi-additive when considering a multiplicative chain. From these observations, we formalize a comb structure which can be represented as a (possibly long) multiplicative chain, in order to take the best advantage of 3rd-generation FHE schemes. We then design a filtering function based on this comb structure (combined with other technical ingredients in order to prevent various classes of possible attacks against stream ciphers) and specify a family of filter permutators (called FLIP ).</p>

    <p class="text-gray-300">Third, and in order to stimulate further investigations, we instantiate a few version of FLIP designs, for 80-bit and 128-bit security. We then provide a preliminary evaluation of their security against some of the prevailing cryptanalysis from the open literature – such as (fast) algebraic attacks, (fast) correlation attacks, BKW-like attacks <em>[BKW03]</em>, guess and determine attacks, etc. – based on state-of-the-art tools. We also analyze the noise brought by their filtering functions in the context of 3rd-generation FHE. In this respect, our main result is that we can limit the noise after the homomorphic evaluation of a decryption to a level of the same order of magnitude as for a single homomorphic multiplication - hence essentially making the impact of the symmetric encryption scheme as small as possible.</p>

    <p class="text-gray-300">We finally observe that our FLIP designs have a very reduced multiplicative depth, which makes them suitable for 2nd-generation FHE schemes as well, and provide preliminary results of prototype</p>

    <p class="text-gray-300">implementations using HElib that confirm their good behavior compared to state-of-the-art block and stream ciphers designed for efficient FHE.</p>

    <p class="text-gray-300">Overall, filter permutators in general and FLIP instances in particular open a large design space of new symmetric constructions to investigate. Hence, we conclude the paper with a list of open problems regarding these algorithms, their best cryptanalysis, the Boolean functions used in their filter and their efficient implementation if concrete applications.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Background</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Boolean functions</h3>

    <p class="text-gray-300">In this section, we recall the cryptographic properties of Boolean functions that we will need in the rest of the paper (mostly taken from <em>[x1]</em>).</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1 (Boolean Function).</h6>

    <p class="text-gray-300">A Boolean function <span class="math">f</span> with n variables is a function from <span class="math">\\mathbb{F}_{2}^{n}</span> to <span class="math">\\mathbb{F}_{2}</span>. The set of all Boolean functions in <span class="math">n</span> variables is denoted by <span class="math">\\mathcal{B}_{n}</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2 (Walsh Transform).</h6>

    <p class="text-gray-300">Let <span class="math">f\\in\\mathcal{B}_{n}</span> a Boolean function. Its Walsh Transform <span class="math">\\mathsf{W_{f}}</span> at <span class="math">a\\in\\mathbb{F}_{2}^{n}</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{W_{f}}(a)=\\sum_{x\\in\\mathbb{F}_{2}^{n}}(-1)^{f(x)+\\langle a,x\\rangle},</span></p>

    <p class="text-gray-300">where <span class="math">\\langle a,x\\rangle</span> denotes the inner product in <span class="math">\\mathbb{F}_{2}^{n}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 3 (Balancedness).</h6>

    <p class="text-gray-300">A Boolean function <span class="math">f\\in\\mathcal{B}_{n}</span> is said to be balanced if its outputs are uniformly distributed over <span class="math">\\{0,1\\}</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 4 (Non-linearity).</h6>

    <p class="text-gray-300">The non-linearity <span class="math">\\mathsf{NL}</span> of a Boolean function <span class="math">f\\in\\mathcal{B}_{n}</span>, where <span class="math">n</span> is a positive integer, is the minimum Hamming distance between <span class="math">f</span> and all the affine functions <span class="math">g</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{NL}(f)=\\min_{g}\\{d_{H}(f,g)\\},</span></p>

    <p class="text-gray-300">with <span class="math">d_{H}(f,g)=\\#\\{x\\in\\mathbb{F}_{2}^{n}\\mid f(x)\\neq g(x)\\}</span> the Hamming distance between <span class="math">f</span> and <span class="math">g</span>. The non-linearity of a Boolean function can also be defined by its Walsh Transform:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{NL}(f)=2^{n-1}-\\frac{1}{2}\\max_{a\\in\\mathbb{F}_{2}^{n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{W_{f}}(a)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 5 (Resiliency).</h6>

    <p class="text-gray-300">A Boolean function <span class="math">f\\in\\mathcal{B}_{n}</span> is said <span class="math">m</span>-resilient if any of its restrictions obtained by fixing at most <span class="math">m</span> of its coordinates is balanced. We will denote by <span class="math">\\mathsf{res}(f)</span> the resiliency <span class="math">m</span> of <span class="math">f</span> and set <span class="math">\\mathsf{res}(f)=-1</span> if <span class="math">f</span> is unbalanced.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 6 (Algebraic Immunity).</h6>

    <p class="text-gray-300">The algebraic immunity of a Boolean function <span class="math">f\\in\\mathcal{B}_{n}</span>, denoted as <span class="math">\\mathsf{Al}(f)</span>, is defined as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Al}(f)=\\min_{g\\neq 0}\\{\\mathsf{deg}(g)\\mid fg=0\\text{ or }(f\\oplus 1)g=0\\},</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{deg}(g)</span> is the degree of <span class="math">g</span>. The function <span class="math">g</span> is called an annihilator of <span class="math">f</span> (or (<span class="math">f\\oplus 1</span>)).</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 7 (Fast Algebraic Immunity).</h6>

    <p class="text-gray-300">The fast algebraic immunity of a Boolean function <span class="math">f\\in\\mathcal{B}_{n}</span>, denoted as <span class="math">\\mathsf{FAI}(f)</span>, is defined as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{FAI}(f)=\\min\\{2\\mathsf{AI}(f),\\min_{1\\leq\\mathsf{deg}(g)&lt;\\mathsf{AI}(f)}(\\max[\\mathsf{deg}(g)+\\mathsf{deg}(fg),3\\mathsf{deg}(g)])\\}.</span></p>

    <p class="text-gray-300">Summarizing, the good balancedness, non-linearity and resiliency properties have to be ensured to widthstand correlation attacks <em>[x20]</em> and fast correlation attacks <em>[x21]</em>. The high algebraic immunity and fast algebraic immunity have to be ensured to widthstand algebraic attacks <em>[x5]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.2 (Ring) Learning With Errors</h3>

    <p class="text-gray-300">In this section, we recall useful notations and definitions needed about the decisional LWE problem and its ring variation. For an integer modulus <span class="math">q</span>, we denote by <span class="math">\\mathbb{Z}_{q}</span> the quotient ring of integers modulo <span class="math">q</span>. We denote vectors with bold letters <span class="math">\\mathbf{e}</span> and matrices with bold capital letters <span class="math">\\mathbf{A}</span>. The notation <span class="math">s\\leftarrow_{\\</span>}S<span class="math"> (resp. </span>s\\leftarrow_{\\<span class="math">}\\chi</span>) denotes that <span class="math">s</span> is picked uniformly at random from a finite set <span class="math">S</span> (resp. from a distribution <span class="math">\\chi</span>).</p>

    <p class="text-gray-300">The decisional Learning With Error problem (dLWE) was introduced by Regev <em>[x18]</em>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 8 (dLWE).</h6>

    <p class="text-gray-300">For an integer <span class="math">q=q(n)\\geq 2</span>, an adversary <span class="math">\\mathcal{A}</span> and an error distribution <span class="math">\\chi=\\chi(n)</span> over <span class="math">\\mathbb{Z}_{q}</span>, we define the following advantage function:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Adv}^{\\mathsf{dLWE}_{n,m,q,\\chi}}_{\\mathcal{A}}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}(\\mathbf{A},\\mathbf{z}_{0})=1]-\\Pr[\\mathcal{A}(\\mathbf{A},\\mathbf{z}_{1})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\leftarrow_{\\</span>}\\mathbb{Z}_{q}^{n\\times m},\\mathbf{s}\\leftarrow_{\\<span class="math">}\\mathbb{Z}_{q}^{n},\\mathbf{e}\\leftarrow_{\\</span>}\\chi^{m},\\mathbf{z}_{0}:=\\mathbf{s}^{\\top}\\mathbf{A}+\\mathbf{e}^{\\top}\\quad\\text{and}\\quad\\mathbf{z}_{1}\\leftarrow_{\\<span class="math">}\\mathbb{Z}_{q}^{m}\\;.</span></p>

    <p class="text-gray-300">The <span class="math">\\mathsf{dLWE}_{n,m,q,\\chi}</span> assumption asserts that for all <span class="math">\\mathsf{PPT}</span> adversaries <span class="math">\\mathcal{A}</span>, the advantage <span class="math">\\mathsf{Adv}^{\\mathsf{dLWE}_{n,m,q,\\chi}}_{\\mathcal{A}}</span> is a negligible function in <span class="math">n</span>.</p>

    <p class="text-gray-300">The ring variant was introduced by Lyubashevsky, Peikert and Regev in <em>[x14]</em>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 9 (d<span class="math">R</span>-LWE).</h6>

    <p class="text-gray-300">For a polynomial ring <span class="math">R=\\mathbb{Z}[X]/f(X)</span> with <span class="math">f</span> of degree <span class="math">n</span>, an integer <span class="math">q\\geq 2</span>, an adversary <span class="math">\\mathcal{A}</span> and an error distribution <span class="math">\\chi</span> over <span class="math">R_{q}=R/qR</span>, <span class="math">R^{\\vee}</span> being <span class="math">R</span> dual fractional ideal, we define the following advantage function:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Adv}^{\\mathsf{dRLWE}_{R,q,\\chi}}_{\\mathcal{A}}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}(a,z_{0})=1]-\\Pr[\\mathcal{A}(a,z_{1})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">a\\leftarrow_{\\</span>}R_{q},\\;s\\leftarrow_{\\<span class="math">}R_{q}^{\\vee},\\;e\\leftarrow_{\\</span>}\\chi,\\;z_{0}:=a\\cdot s+e\\quad\\text{and}\\quad z_{1}\\leftarrow_{\\<span class="math">}R\\;.</span></p>

    <p class="text-gray-300">With <span class="math">f(X)</span> a cyclotomic polynomial, the <span class="math">\\mathsf{dRLWE}_{R,q,\\chi}</span> assumption asserts that for all <span class="math">\\mathsf{PPT}</span> adversaries <span class="math">\\mathcal{A}</span>, the advantage <span class="math">\\mathsf{Adv}^{\\mathsf{dRLWE}_{R,q,\\chi}}_{\\mathcal{A}}</span> is a negligible function in <span class="math">n</span>.</p>

    <p class="text-gray-300">For our constructions, we need to take the distribution <span class="math">\\chi</span> as a subgaussian random variable which we define hereafter. More details about the subgaussian distribution and the lemmas’ proof can be found in <em>[x1, x24]</em>.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 10 (Subgaussian Random Variables).</h6>

    <p class="text-gray-300">Let <span class="math">X</span> be a random variable. We say <span class="math">X</span> is subgaussian with parameter <span class="math">\\sigma</span> if there exists <span class="math">\\sigma</span> such that:</p>

    <p class="text-gray-300"><span class="math">\\forall t\\in\\mathbb{R},\\mathbb{E}[e^{tX}]\\leq e^{\\sigma^{2}t^{2}/2},</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{E}[e^{tX}]</span> is the moment generating function of <span class="math">X</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 1 (Subgaussian Random Variables properties).</h6>

    <p class="text-gray-300">Let <span class="math">X</span>, <span class="math">X^{\\prime}</span> be independent subgaussian random variables of parameter <span class="math">\\sigma</span> and <span class="math">\\sigma^{\\prime}</span> respectively. Assuming <span class="math">\\mathbb{E}(X)=\\mathbb{E}(X^{\\prime})=0</span> we have the following properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Tails: <span class="math">\\forall t\\geq 0</span> we have $Pr[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t]\\leq 2e^{-\\pi t^{2}/\\sigma^{2}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pythagorean additivity: <span class="math">X+X^{\\prime}</span> is subgaussian with parameter <span class="math">\\sqrt{\\sigma^{2}+\\sigma^{\\prime 2}}</span>.</li>

    </ul>

    <p class="text-gray-300">We extend the notion of subgaussianity to vectors and polynomials. Since the coefficients of a polynomial are seen as a vector, we call subgaussian vector of parameter <span class="math">\\sigma</span> a vector where each coefficient follows an independent subgaussian distribution with parameter <span class="math">\\sigma</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 2 (Subgaussian Vector Norm, adapted from <em>[x1]</em>, Lemma 2.1).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{x}\\in\\mathbb{R}^{n}</span> be a random vector where each coordinates follows an independent subgaussian distribution of parameter <span class="math">\\sigma</span>. Then for some universal constant <span class="math">C&gt;0</span> we have $Pr\\left[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}>C\\sigma\\sqrt{n}\\right]\\leq 2^{-\\Omega(n)}<span class="math"> and therefore </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}=\\mathcal{O}(\\sigma\\sqrt{n})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">2.3 Fully Homomorphic Encryption</h3>

    <p class="text-gray-300">In this section we recall the definition of (Fully) Homomorphic Encryption and present the Homomorphic Encryption schemes we will use, both based on GSW <em>[x10]</em>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 11 (Homomorphic Encryption Scheme).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{M}</span> be the plaintext space, <span class="math">\\mathcal{C}</span> the ciphertext space and <span class="math">\\lambda</span> the security parameter. A homomorphic encryption scheme consists of four algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H.\\mathsf{KeyGen}(1^{\\lambda})</span>. Output <span class="math">\\mathsf{pk}^{H}</span> and <span class="math">\\mathsf{sk}^{H}</span> the public and secret keys of the scheme.</li>

      <li><span class="math">H.\\mathsf{Enc}(m,\\mathsf{pk}^{H})</span>. From the plaintext <span class="math">m\\in\\mathcal{M}</span> and the public key, output a ciphertext <span class="math">c\\in\\mathcal{C}</span>.</li>

      <li><span class="math">H.\\mathsf{Dec}(c,\\mathsf{sk}^{H})</span>. From the ciphertext <span class="math">c\\in\\mathcal{C}</span> and the secret key, output <span class="math">m^{\\prime}\\in\\mathcal{M}</span>.</li>

      <li><span class="math">H.\\mathsf{Eval}(f,c_{1},\\cdots,c_{k},\\mathsf{pk}^{H})</span>. With <span class="math">c_{i}=H.\\mathsf{Enc}(m_{i},\\mathsf{pk}^{H})</span> for <span class="math">1\\leq i\\leq k</span>, output a ciphertext <span class="math">c_{f}\\in\\mathcal{C}</span> such that <span class="math">H.\\mathsf{Dec}(c_{f})=f(m_{1},\\cdots,m_{k})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A homomorphic encryption scheme is called a Fully Homomorphic Encryption (FHE) scheme when <span class="math">f</span> can be any function and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is finite. A simpler primitive to consider is the SomeWhat Homomorphic Encryption (SWHE) scheme, where </span>f$ is restricted to be any univariate polynomial of finite degree.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since the breakthrough work of Gentry <em>[x9]</em>, the only known way to obtain FHE consists in adding a bootstrapping technique to a SWHE. As bootstrapping computational cost is still expensive in comparison to the other FHE algorithms, in the following part of the article we will only consider SWHE for our applications.</p>

    <p class="text-gray-300">GSW Homomorphic Encryption Scheme. In 2013, Gentry, Sahai and Waters [GSW13] introduced a Homomorphic Encryption scheme based on LWE using a new technique stemming from the approximate eigenvector problem. This new technique led to a new family of FHE, called 3rd-generation FHE, consisting in Homomorphic Encryption schemes such that the multiplicative error growth is quasi-additive. Hereafter, we present two schemes belonging to this generation, the first one with security based on dLWE and the second one based on dRLWE. We first set some useful notations considering the different schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a matrix  <span class="math">\\mathbf{E}</span>  we refer to the  <span class="math">i</span> -th row as  <span class="math">\\mathbf{e}_i^r</span>  and to the  <span class="math">j</span> -th column as  <span class="math">\\mathbf{e}_j</span> . The  <span class="math">\\log q</span>  notation refers to the logarithm in base 2 of  <span class="math">q</span> . The notation  <span class="math">[a]_q</span>  is for  <span class="math">a \\mod q</span>  and  <span class="math">\\lfloor [a]_q \\rceil_2 \\in \\{0,1\\}</span>  is a function in  <span class="math">a \\in \\mathbb{Z}_q</span>  giving 1 if  <span class="math">\\lfloor \\frac{q}{4} \\rfloor \\leq a \\leq \\lfloor \\frac{3q}{4} \\rfloor \\mod q</span>  and 0 otherwise. We denote by  <span class="math">[n]</span>  the set of integers  <span class="math">\\{1, \\dots, n\\}</span> . We finally use  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math">  for the standard norms 1 and 2 on vectors  </span>x \\in \\mathbb{R}^n$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Batched GSW. This scheme is a batched version of GSW presented in [HAO15], enabling to pack independently  <span class="math">r</span>  plaintexts in one ciphertext. From the security parameter  <span class="math">\\lambda</span>  and the considered applications, we can derive the parameters  <span class="math">n, q, r, \\chi</span>  of the scheme described below.</p>

    <p class="text-gray-300"><span class="math">H.\\mathrm{KeyGen}(n,q,r,\\chi)</span> . On inputs the lattice dimension  <span class="math">n</span> , the modulus  <span class="math">q</span> , the number of bits by ciphertext  <span class="math">r</span>  and the error distribution  <span class="math">\\chi</span>  do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\ell = \\lceil \\log q \\rceil</span> ,  <span class="math">m = \\mathcal{O}(n\\ell)</span> ,  <span class="math">N = (r + n)\\ell</span> ,  <span class="math">\\mathcal{M} = \\{0,1\\}^r</span>  and  <span class="math">\\mathcal{C} = \\mathbb{Z}_q^{(r + n)\\times N}</span> .</li>

      <li>Pick  <span class="math">\\mathbf{A} \\gets_{\\S} \\mathbb{Z}_q^{n \\times m}</span> ,  <span class="math">\\mathbf{S}&#x27; \\gets_{\\S} \\chi^{r \\times n}</span>  and  <span class="math">\\mathbf{E} \\gets_{\\S} \\chi^{r \\times m}</span> .</li>

      <li>Set  <span class="math">\\mathbf{S} = [\\mathbf{I}] - \\mathbf{S}&#x27;] \\in \\mathbb{Z}_q^{r \\times (r + n)}</span>  and  <span class="math">\\mathbf{B} = \\left[\\frac{\\mathbf{S}&#x27;\\mathbf{A} + \\mathbf{E}}{\\mathbf{A}}\\right]_q \\in \\mathbb{Z}_q^{(r + n) \\times m}</span> .</li>

      <li>For all  <span class="math">\\mathbf{m} \\in \\{0,1\\}^r</span> :</li>

    </ul>

    <p class="text-gray-300">Pick  <span class="math">\\mathbf{R}_{\\mathbf{m}}\\gets_{\\S}\\{0,1\\}^{m\\times N}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\mathbf{P}_{\\mathbf{m}} = \\left[\\mathbf{BR}_{\\mathbf{m}} + \\left(\\frac{\\frac{m_1 \\cdot \\mathbf{s}_1^r}{\\vdots}}{\\frac{m_r \\cdot \\mathbf{s}_r^r}{\\mathbf{0}}}\\right)\\mathbf{G}\\right]_q \\in \\mathbb{Z}_q^{(r + n) \\times N}</span> .</li>

    </ul>

    <p class="text-gray-300">with  <span class="math">\\mathbf{s}_i^r</span>  the i-th row of  <span class="math">\\mathbf{S}</span>  and  <span class="math">\\mathbf{G} = (2^0, \\dots, 2^{\\ell - 1})^r \\otimes \\mathbf{I} \\in \\mathbb{Z}_q^{(r + n) \\times N}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\mathsf{pk}^H \\coloneqq (\\{\\mathbf{P}_{\\mathbf{m}}\\}, \\mathbf{B})</span>  and  <span class="math">\\mathsf{sk}^H \\coloneqq \\mathbf{S}</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">H.\\mathsf{Enc}(\\mathsf{pk}^H,\\mathbf{m})</span>  . On input  <span class="math">\\mathsf{pk}^H</span>  , and  <span class="math">\\mathbf{m}\\in \\{0,1\\} ^r</span>  , do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick  <span class="math">\\mathbf{R} \\gets_{\\S} \\{0,1\\}^{m \\times N}</span> , and output  <span class="math">\\mathbf{C} = [\\mathbf{BR} + \\mathbf{P}_{\\mathbf{m}}]_q \\in \\mathbb{Z}_q^{(r + n) \\times N}</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">H.\\mathrm{Dec}(\\mathbf{C},\\mathsf{sk}^H)</span> . On input the secret key  <span class="math">\\mathsf{sk}^H</span> , and a ciphertext  <span class="math">\\mathbf{C}</span> , do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all  <span class="math">i \\in [r] : m_i&#x27; = \\left\\lfloor \\left[\\langle \\mathbf{s}_i^r, \\mathbf{c}_{i\\ell} \\rangle \\right]_q \\right\\rceil_2</span>  where  <span class="math">\\mathbf{c}_{il}</span>  is the column  <span class="math">i\\ell</span>  of  <span class="math">\\mathbf{C}</span> .</li>

      <li>Output  <span class="math">m_1&#x27;, \\dots, m_r&#x27; \\in \\{0, 1\\}^r</span> .</li>

    </ul>

    <p class="text-gray-300">Note that  <span class="math">\\mathbf{SC} = \\mathbf{SBR} + \\mathbf{SP}_{\\mathbf{m}} = \\mathbf{ER} + \\mathbf{ER}_{\\mathbf{m}} + \\left( \\begin{array}{c}\\frac{m_1\\cdot\\mathbf{s}_1^r}{\\vdots}\\\\ \\frac{m_r\\cdot\\mathbf{s}_r^r}{\\vdots} \\end{array} \\right)\\mathbf{G} = \\mathbf{E}&#x27; + \\left( \\begin{array}{c}\\frac{m_1\\cdot\\mathbf{s}_1^r}{\\vdots}\\\\ \\frac{m_r\\cdot\\mathbf{s}_r^r}{\\vdots} \\end{array} \\right)\\mathbf{G}.</span></p>

    <p class="text-gray-300">The <span class="math">H</span>.Eval algorithm finally consists in iterating, following a circuit <span class="math">f</span>, the homomorphic operations <span class="math">H</span>.Add and <span class="math">H</span>.Mul:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H</span>.Add<span class="math">(\\mathbf{C}_{1},\\mathbf{C}_{2}):\\mathbf{C}_{+}=\\mathbf{C}_{1}+\\mathbf{C}_{2}</span>.</li>

      <li><span class="math">H</span>.Mul<span class="math">(\\mathbf{C}_{1},\\mathbf{C}_{2}):\\mathbf{C}_{\\times}=\\mathbf{C}_{1}\\times\\mathbf{G}^{-1}\\mathbf{C}_{2}</span> with <span class="math">\\mathbf{G}^{-1}</span> a function such that <span class="math">\\forall\\mathbf{C}\\in\\mathbb{Z}_{q}^{(r+n)\\times N},\\mathbf{G}\\mathbf{G}^{-1}(\\mathbf{C})=\\mathbf{C}</span> and the values of <span class="math">\\mathbf{G}^{-1}(\\mathbf{C})</span> follow a subgaussian distribution with parameter <span class="math">\\mathcal{O}(1)</span> (see <em>[x13]</em> for the existence and proof of <span class="math">\\mathbf{G}^{-1}</span>).</li>

    </ul>

    <p class="text-gray-300">The correctness and security of this scheme are proven in Appendix A.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">For practical use, we only need to store <span class="math">r+1</span> matrices <span class="math">\\mathbf{P}_{m}</span>, namely the <span class="math">r+1</span> ones with <span class="math">\\mathbf{m}</span> of hamming weight equal to <span class="math">0</span> or <span class="math">1</span> are sufficient to generate correct encryption of all <span class="math">\\mathbf{m}\\in\\{0,1\\}^{r}</span> with at most <span class="math">r</span> additions of the corresponding <span class="math">\\mathbf{P}_{m}</span> matrices.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Ring-GSW</h4>

    <p class="text-gray-300">This scheme is a ring version of GSW presented in <em>[x11]</em>, transposing the <em>approximate eigenvector problem</em> into the ring setting. From <span class="math">\\lambda</span> the security parameter and the considered applications, we can derive the parameters <span class="math">n,q</span> and <span class="math">\\mathcal{M}</span> of the scheme described below.</p>

    <p class="text-gray-300"><span class="math">H</span>.KeyGen<span class="math">(n,q,\\chi,\\mathcal{M})</span>. On inputs the lattice dimension <span class="math">n</span>, which is set to a power of 2, the modulus <span class="math">q</span>, the error distribution <span class="math">\\chi</span> and the plaintext space <span class="math">\\mathcal{M}</span> do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">R=\\mathbb{Z}[X]/(X^{n}+1)</span>, <span class="math">R_{q}=R/qR</span>, <span class="math">\\ell=\\lceil\\log q\\rceil</span>, <span class="math">N=2\\ell</span> and <span class="math">\\mathcal{C}=R_{q}^{2\\times N}</span>.</li>

      <li>Set <span class="math">R_{0,1}=\\{P\\in R_{q},p_{i}\\in\\{0,1\\},0\\leq i&lt;n\\}</span>.</li>

      <li>Pick <span class="math">a\\leftarrow_{\\</span>}R_{q}<span class="math">, </span>s^{\\prime}\\leftarrow_{\\<span class="math">}\\chi</span> and <span class="math">e\\leftarrow_{\\</span>}\\chi$.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Set $\\mathbf{s}=[1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-s^{\\prime}]^{\\scriptscriptstyle\\top}\\in R_{q}^{1\\times 2}<span class="math"> and </span>\\mathbf{b}=\\left(\\frac{s^{\\prime}a+e}{a}\\right)\\in R_{q}^{2\\times 1}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\mathsf{pk}^{H}:=\\mathbf{b}</span> and <span class="math">\\mathsf{sk}^{H}:=\\mathbf{s}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">H</span>.Enc<span class="math">(\\mathsf{pk}^{H},m)</span>. On input <span class="math">\\mathsf{pk}^{H}</span>, and <span class="math">m\\in\\mathcal{M}</span>, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pick <span class="math">\\mathbf{E}\\leftarrow_{\\</span>}\\chi^{2\\times N}$.</li>

      <li>Pick <span class="math">\\mathbf{r}\\leftarrow_{\\</span>}R_{0,1}^{N}<span class="math">, and output </span>\\mathbf{C}=[\\mathbf{br}^{\\scriptscriptstyle\\top}+m\\mathbf{G}+\\mathbf{E}]_{q}\\in R_{q}^{2\\times N}$ .</li>

    </ul>

    <p class="text-gray-300"><span class="math">H</span>.Dec<span class="math">(\\mathbf{C},\\mathsf{sk}^{H})</span>. On input the secret key <span class="math">\\mathsf{sk}^{H}</span>, and a ciphertext <span class="math">\\mathbf{C}</span>, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">m^{\\prime}=\\lfloor[&lt;\\mathbf{s},\\mathbf{c}_{l}&gt;]_{q}]_{2}</span>.</li>

      <li>Output <span class="math">m^{\\prime}\\in R_{q}</span>.</li>

    </ul>

    <p class="text-gray-300">The <span class="math">H</span>.Eval algorithm finally consists in iterating <span class="math">H</span>.Add and <span class="math">H</span>.Mul:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H</span>.Add<span class="math">(\\mathbf{C}_{1},\\mathbf{C}_{2}):\\mathbf{C}_{+}=\\mathbf{C}_{1}+\\mathbf{C}_{2}</span>.</li>

      <li><span class="math">H</span>.Mul<span class="math">(\\mathbf{C}_{1},\\mathbf{C}_{2}):\\mathbf{C}_{\\times}=\\mathbf{C}_{1}\\times\\mathbf{G}^{-1}\\mathbf{C}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">The correctness and security of this scheme are proven in Appendix B.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">The plaintext space <span class="math">\\mathcal{M}</span> has a major influence on the considered application in terms of quantity of information contained in a single ciphertext and error growth. For our application we choose <span class="math">\\mathcal{M}</span> as the set of polynomials with all coefficients of degree greater than <span class="math">0</span> being zero, and the constant coefficient being bounded.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.2. Filter permutator construction.</p>

    <p class="text-gray-300">In this section, we introduce our new stream cipher construction. We first describe the general filter permutator structure. Next we list a number of Boolean building blocks together with their necessary cryptographic properties. Third, we specify a family of filter permutators (denoted as FLIP) and analyze its security based on state-of-the-art cryptanalysis and design tools. Finally, we propose a couple of parameters to fully instantiate a few examples of FLIP designs.</p>

    <p class="text-gray-300">The general structure of filter permutators is depicted in Figure 2. It is composed of three parts: a register where the key is stored, a (bit) permutation generator parametrised by a Pseudo Random Number Generator (PRNG) [BM84, KL07] (which is initialized with a public IV), and a filtering function which generates a keystream. The filter permutator can be compared to a filter generator, in which the LFSR is replaced by a permuted key register. In other words, the register is no longer updated by means of the LFSR, but with pseudorandom bit permutations. More precisely, at each cycle (i.e. each time the filtering function outputs a bit), a pseudo-random permutation is applied to the register and the permuted key register is filtered. Eventually, the encryption (resp. decryption) with a filter permutator simply consists in XORing the bits output by the filtering function with those of the plaintext (resp. ciphertext).</p>

    <p class="text-gray-300">We will first exploit direct sums of Boolean functions defined as follows:</p>

    <p class="text-gray-300">Definition 12 (Direct Sum). Let  <span class="math">f_{1}(x_{0},\\dots ,x_{n_{1} - 1})</span>  and  <span class="math">f_{2}(x_{n_{1}},\\dots ,x_{n_{1} + n_{2} - 1})</span>  be two Boolean functions in respectively  <span class="math">n_1</span>  and  <span class="math">n_2</span>  variables. The direct sum of  <span class="math">f_{1}</span>  and  <span class="math">f_{2}</span>  is defined as  <span class="math">f = f_{1}\\oplus f_{2}</span> , which is a</p>

    <p class="text-gray-300">Boolean function in <span class="math">n_1 + n_2</span> variables such that:</p>

    <div class="my-4 text-center"><span class="math-block">f(x_0, \\dots, x_{n_1 + n_2 - 1}) = f_1(x_0, \\dots, x_{n_1 - 1}) \\oplus f_2(x_{n_1}, \\dots, x_{n_1 + n_2 - 1}).</span></div>

    <p class="text-gray-300">They inherit from the following set of properties, proven in Appendix C.1.</p>

    <p class="text-gray-300"><strong>Lemma 3 (Direct sum properties).</strong> Let <span class="math">f</span> be the direct sum of <span class="math">f_1</span> and <span class="math">f_2</span> with <span class="math">n_1</span> and <span class="math">n_2</span> variables respectively. Then <span class="math">f</span> has the following cryptographic properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non Linearity: <span class="math">\\mathsf{NL}(f) = 2^{n_2}\\mathsf{NL}(f_1) + 2^{n_1}\\mathsf{NL}(f_2) - 2\\mathsf{NL}(f_1)\\mathsf{NL}(f_2)</span>.</li>

      <li>Resiliency: <span class="math">\\operatorname{res}(f) = \\operatorname{res}(f_1) + \\operatorname{res}(f_2) + 1</span>.</li>

      <li>Algebraic Immunity: <span class="math">\\mathsf{AI}(f_1) + \\mathsf{AI}(f_2) \\geq \\mathsf{AI}(f) \\geq \\max(\\mathsf{AI}(f_1), \\mathsf{AI}(f_2))</span>.</li>

      <li>Fast Algebraic Immunity: <span class="math">\\mathsf{FAI}(f) \\geq \\max(\\mathsf{FAI}(f_1), \\mathsf{FAI}(f_2))</span>.</li>

    </ol>

    <p class="text-gray-300">Our direct sums will then be based on three parts: a linear function, a quadratic function and triangular functions, defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 13 (Linear functions).</strong> Let <span class="math">n &amp;gt; 0</span> be a positive integer, the <span class="math">L_n</span> linear function is a <span class="math">n</span>-variable Boolean function defined as:</p>

    <div class="my-4 text-center"><span class="math-block">L_n(x_0, \\dots, x_{n-1}) = \\sum_{i=0}^{n-1} x_i.</span></div>

    <p class="text-gray-300"><strong>Definition 14 (Quadratic functions).</strong> Let <span class="math">n &amp;gt; 0</span> be a positive integer, the <span class="math">Q_n</span> linear function is a <span class="math">2n</span>-variable Boolean function defined as:</p>

    <div class="my-4 text-center"><span class="math-block">Q_n(x_0, \\dots, x_{2n-1}) = \\sum_{i=0}^{n-1} x_{2i} x_{2i+1}.</span></div>

    <p class="text-gray-300"><strong>Definition 15 (Triangular functions).</strong> Let <span class="math">k &amp;gt; 0</span> be a positive integer. The <span class="math">k</span>-th triangular function <span class="math">T_k</span> is a <span class="math">\\frac{k(k+1)}{2}</span>-variable Boolean function defined as:</p>

    <div class="my-4 text-center"><span class="math-block">T_k(x_0, \\dots, x_{\\frac{k(k+1)}{2} - 1}) = \\Sigma_{i=1}^{k} \\Pi_{j=0}^{i-1} x_{j + \\Sigma_{\\ell=0}^{i-1} \\ell}.</span></div>

    <p class="text-gray-300">For example, the 4th triangular function <span class="math">T_4</span> is:</p>

    <div class="my-4 text-center"><span class="math-block">T_4 = x_0 \\oplus x_1 x_2 \\oplus x_3 x_4 x_5 \\oplus x_6 x_7 x_8 x_9.</span></div>

    <p class="text-gray-300">These three types of functions allow us to guarantee the following properties.</p>

    <p class="text-gray-300"><strong>Lemma 4 (Linear functions properties).</strong> Let <span class="math">L_n</span> be a linear function in <span class="math">n</span> variables, then <span class="math">L_n</span> has the following cryptographic properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non Linearity: <span class="math">\\mathsf{NL}(L_n) = 0</span>.</li>

      <li>Resiliency: <span class="math">\\operatorname{res}(L_n) = n - 1</span>.</li>

      <li>Algebraic Immunity: <span class="math">\\mathsf{AI}(L_n) = 1</span>.</li>

      <li>Fast Algebraic Immunity: <span class="math">\\mathsf{FAI}(L_n) = 2</span>.</li>

    </ol>

    <p class="text-gray-300">10</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 5</h6>

    <p class="text-gray-300">(Quadratic functions properties). Let <span class="math">Q_{n}</span> be a linear function in <span class="math">2n</span> variables, then <span class="math">Q_{n}</span> has the following cryptographic properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non Linearity: <span class="math">\\mathsf{NL}(Q_{n})=2^{2n-1}-2^{n-1}</span>.</li>

      <li>Resiliency: <span class="math">\\mathsf{res}(Q_{n})=-1</span>.</li>

      <li>Algebraic Immunity: <span class="math">\\mathsf{AI}(Q_{1})=1</span> and <span class="math">\\forall n&gt;1,\\mathsf{AI}(Q_{n})=2</span>.</li>

      <li>Fast Algebraic Immunity: <span class="math">\\mathsf{FAI}(Q_{1})=2</span> and <span class="math">\\forall n&gt;1,\\ \\mathsf{FAI}(Q_{n})=4</span>.</li>

    </ol>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 6</h6>

    <p class="text-gray-300">(Triangular functions properties). Let <span class="math">k</span> a positive integer and let <span class="math">T_{k}</span> the <span class="math">k</span>-th triangular function. Then the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non Linearity follows the recursive formula defined as:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(i)\\ \\mathsf{NL}(T_{1}=0)</span>,</p>

    <p class="text-gray-300"><span class="math">(ii)\\ \\mathsf{NL}(T_{k+1})=(2^{k+1}-2)\\mathsf{NL}(T_{k})+2^{k(k+1)/2}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Resiliency: <span class="math">\\mathsf{res}(T_{k})=0</span>.</li>

      <li>Algebraic Immunity: <span class="math">\\mathsf{AI}(T_{k})=k</span>.</li>

      <li>Fast Algebraic Immunity: <span class="math">\\mathsf{FAI}(T_{k})=k+1</span>.</li>

    </ol>

    <p class="text-gray-300">The proof of Lemma 6 can be found in Appendix C.2 (Lemmas 4 and 5 are standard).</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">3.3 The FLIP family of stream ciphers</h3>

    <p class="text-gray-300">Based on the previous definitions, we specify the FLIP family of stream ciphers as a filter permutator using a forward secure PRNG <em>[x1]</em> based on the AES-128 (e.g. as instantiated in the context of leakage-resilient cryptography <em>[x20]</em>), the Knuth shuffle (see below) as bit permutation generator and such that the filter <span class="math">F</span> is the <span class="math">N</span>-variable Boolean function defined by the direct sum of three Boolean functions <span class="math">f_{1}</span>, <span class="math">f_{2}</span> and <span class="math">f_{3}</span> of respectively <span class="math">n_{1}</span>, <span class="math">n_{2}</span> and <span class="math">n_{3}</span> variables, such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{1}(x_{0},\\cdots,x_{n_{1}-1})=L_{n_{1}}</span> ,</li>

      <li><span class="math">f_{2}(x_{n_{1}},\\cdots,x_{n_{1}+n_{2}-1})=Q_{n_{2}/2}</span>,</li>

      <li><span class="math">f_{3}(x_{n_{1}+n_{2}},\\cdots,x_{n_{1}+n_{2}+n_{3}-1})</span> is the direct sum of <span class="math">nb</span> triangular function <span class="math">T_{k}</span>, i.e. such that each <span class="math">T_{k}</span> acts on different and independent variables, that we denote as <span class="math">{}^{nb}\\Delta^{k}</span>.</li>

    </ul>

    <p class="text-gray-300">That is, we have <span class="math">F:\\mathbb{F}_{2}^{n_{1}+n_{2}+n_{3}}\\rightarrow\\mathbb{F}_{2}</span> the Boolean function such that:</p>

    <p class="text-gray-300"><span class="math">F(x_{0},\\cdots,x_{n_{1}+n_{2}+n_{3}-1})=L_{n_{1}}\\oplus Q_{n_{2}/2}\\oplus\\bigoplus_{i=1}^{nb}T_{k}.</span></p>

    <p class="text-gray-300">In the following section, we provide a preliminary security analysis of the FLIP filter permutators against a couple of standard attacks against stream ciphers, based on state-of-the-art tools. For this purpose, we will assume that no additional weaknesses arise from its PRNG and bit permutation generator. In this respect, we note that our forward secure PRNG does not allow malleability, so it should be hard to obtain a collision in the chosen IV model better than with birthday probability. This should prevent collisions on the generated permutations. Besides, the Knuth shuffle <em>[x14]</em> (or Fisher-Yates shuffle) is an algorithm allowing to generate a random permutation on a finite set. This algorithm has the interesting property of giving the same probability to all permutations if used with a random number generator. As a result, we</p>

    <p class="text-gray-300">expect that any deviation between a bit permutation based on a Knuth shuffle fed with the PRNG will be hard to exploit by an adversary. Our motivation for this assumption is twofold. First, it allows us to focus on whether the filter permutator construction is theoretically sound. Second, if such a choice was leading to an exploitable weakness, it remains possible to build a pseudorandom permutation based on standard cryptographic constructions <em>[x11]</em>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">Since the permutation generation part of FLIP has only birthday security (with respect to the size of the PRNG), it implies that it is only secure up to <span class="math">2^{64}</span> PRNG outputs when implemented with the AES-128. Generating more keystream using larger block ciphers should be feasible. However, in view of the novelty of the FLIP instances, our claims are only made for this limited (birthday) data complexity so far, which should not be limiting for the intended FHE applications. We leave the investigation of their security against attacks using larger data complexities as a scope for further research. Besides, we note that using a PRNG based on a tweakable block cipher <em>[x12]</em> (where a part of the larger IV would be used as tweak) could be an interesting track to reduce the impact of a collision on the PRNG output in the known IV model, which we also leave as an open research direction.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">3.4 Security analysis</h3>

    <p class="text-gray-300">Since the filter permutator shares similarities with a filter generator, it is natural to start our investigations with the typical attacks considered against such types of stream ciphers. For this purpose, we next study the applicability of algebraic attacks and correlation attacks, together with more specialized cryptanalyses that have been considered against stream ciphers. Note that the attacks considered in the rest of this section frequently require to solve systems of equations and to implement a Gaussian reduction. Our complexity estimations will consider Strassen’s algorithm for this purpose and assume <span class="math">\\omega=\\log 7</span> to be the exponent in a Gaussian reduction. Admittedly, approaches based on Gröbner bases <em>[x5]</em> or taking advantage of the sparsity of the matrices <em>[x23]</em> could lead to even faster algorithms. We ignore them for simplicity in these preliminary investigations. Note also that we only claim security in the single-key setting.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Algebraic Attacks</h4>

    <p class="text-gray-300">were first introduced by Courtois and Meier in <em>[x6]</em> and applied to the stream cipher Toyocrypt. Their main idea is to build an over-defined system of equations with the initial state of the LFSR as unknown, and to solve this system with Gaussian elimination. More precisely, by using a nonzero function <span class="math">g</span> such that both <span class="math">g</span> and <span class="math">h=gF</span> have low algebraic degree, an adversary is able to obtain <span class="math">T</span> equations with monomials of degree at most <span class="math">AI(f)</span>. It is easily shown that <span class="math">g</span> can be taken equal to the annihilator of <span class="math">F</span> or of <span class="math">F\\oplus 1</span>, i.e. such that <span class="math">gF=0</span> or <span class="math">g(F\\oplus 1)=0</span>. After a linearisation step, the adversary obtains a system of <span class="math">T</span> equations in <span class="math">D=\\sum_{i=0}^{\\mathsf{AI}(F)}\\binom{N}{i}</span> variables. Therefore, the time complexity of the algebraic attack is <span class="math">\\mathcal{O}(D^{\\omega})</span>, that is, <span class="math">\\mathcal{O}(N^{\\omega AI(f)})</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Fast Algebraic Attacks</h4>

    <p class="text-gray-300">are a variation of the previous algebraic attacks introduced by Courtois at Crypto 2003 <em>[x7]</em>. Considering the relation <span class="math">gF=h</span>, their goal is to find and use functions <span class="math">g</span> of low algebraic degree <span class="math">e</span>, possibly smaller than <span class="math">AI(f)</span>, and <span class="math">h</span> of low but possibly larger degree <span class="math">d</span>, and to lower the degree of the resulting equations by an off-line elimination of the monomials of degrees larger than <span class="math">e</span> (several equations being needed to obtain each one with degree at most <span class="math">e</span>). Following <em>[ACG^{+}06]</em>, this attack can be decomposed into four steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The search of the polynomials <span class="math">g</span> and <span class="math">h</span> generating a system of <span class="math">D+E</span> equations in <span class="math">D+E</span> unknowns, where <span class="math">D=\\sum_{i=0}^{d}\\binom{N}{i}</span> and <span class="math">E=\\sum_{i=0}^{e}\\binom{N}{i}</span>. This step has a time complexity in <span class="math">\\mathcal{O}(\\sum_{i=0}^{d}\\binom{n}{i}+\\sum_{i=0}^{e}\\binom{n}{i})^{\\omega}</span>.</li>

      <li>The search of linear relations which allows the suppression of the monomials of degree more than <span class="math">e</span>. This step has a time complexity in <span class="math">\\mathcal{O}(D\\log^{2}(D))</span>.</li>

      <li>The elimination of monomials of degree larger than <span class="math">e</span> using the Berlekamp-Massey algorithm. This step has a time complexity in <span class="math">\\mathcal{O}(ED\\log(D))</span>.</li>

      <li>The resolution of the system. This step has a time complexity in <span class="math">\\mathcal{O}(E^{\\omega})</span>.</li>

    </ol>

    <p class="text-gray-300">Given the <span class="math">\\mathsf{FAI}</span> of <span class="math">F</span>, the time complexity of this attack is in <span class="math">\\mathcal{O}(N^{\\mathsf{FAI}})</span>, or more precisely <span class="math">O(D\\log^{2}D+E^{2}D+E^{\\omega})</span> (ignoring Step 1 which is trivial for our choice of <span class="math">F</span>).</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Correlation Attacks.</h4>

    <p class="text-gray-300">In their basic versions, correlation attacks try to distinguish the output sequence of a stream cipher from a random one, by exploiting the bias <span class="math">\\delta</span> of the filtering function. We can easily rule out such attacks by considering a (much) simplified version of filter permutator where the bit permutations <span class="math">P_{i}</span>’s would be made on two independent permutations <span class="math">P_{i}^{1}</span> and <span class="math">P_{i}^{2,3}</span> (respectively acting on the <span class="math">n_{1}+1</span> bits of the linear part and the <span class="math">n_{2}+n_{3}-1</span> bits of the non-linear part of <span class="math">F</span>). Suppose for simplicity that <span class="math">P_{i}^{1}</span> is kept constant <span class="math">t</span> times, then the output distribution of <span class="math">F</span> has a bias <span class="math">\\delta</span> and it can be distinguished for the right choice of the <span class="math">n_{1}+1=\\mathsf{res}+1</span> bits of the linear part. In this case, a correlation attack would have a data complexity of <span class="math">\\mathcal{O}(\\delta^{-2})</span> and a time complexity of <span class="math">\\mathcal{O}(2^{\\mathsf{res}(F)+1}\\delta^{-2})</span>, with <span class="math">\\delta=\\frac{1}{2}-\\left(\\frac{\\mathsf{NL}(F)}{2^{N}}\\right)</span>. For simplicity, we will consider this conservative estimation in our following selection of security parameters. Yet, we note that since the permutation <span class="math">P_{i}</span> of a filter permutator is acting on all the <span class="math">N</span> bits of the filter <span class="math">F</span>, the probability that the linear part of <span class="math">F</span> is kept invariant by the permutations <span class="math">t</span> times is in fact considerably smaller than what is predicted by the resilience.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">BKW-like Attack.</h4>

    <p class="text-gray-300">The BKW algorithm was introduced in <em>[x1]</em> as a solution to solve the LPN problem using smart combinations of well chosen vectors and their associated bias. Intuitively, our stream cipher construction simplified as just explained (with two independent permutations <span class="math">P_{i}^{1}</span> and <span class="math">P_{i}^{2,3}</span> rather than a single one <span class="math">P_{i}</span>) also shares similarities with this problem. Indeed, we could see the linear part as the parity of an LPN problem and the non-linear one (with a small bias) as a (large) noise. Adapting the BKW algorithm to our setting amounts to XOR some linear parts of <span class="math">F</span> in order to obtain vectors of low Hamming weight, and then to consider a distinguishing attack with the associated bias. Denoting <span class="math">h</span> the target Hamming weight, <span class="math">x</span> the log of the number of XORs and <span class="math">\\delta</span> the bias, the resulting attack (which can be viewed as an extension of the previous correlation attack) has data complexity <span class="math">\\mathcal{O}(2^{h}\\delta^{-2(x+1)})</span> (more details are given in Appendix D).</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Higher-Order Correlation Attacks</h4>

    <p class="text-gray-300">were introduced by Courtois <em>[x10]</em> and exploit the so-called XL algorithm. They look for good correlations between <span class="math">F</span> and an approximation <span class="math">g</span> of degree <span class="math">d&gt;1</span>, in order to solve a linearised system based on the values of this approximation. The value <span class="math">\\varepsilon</span> is defined such that <span class="math">g</span> is equal to <span class="math">F</span> with probability greater than <span class="math">1-\\varepsilon</span>. Such attacks have a (conservative) time complexity estimate:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(\\binom{N}{D}^{\\omega}(1-\\varepsilon)^{-m}\\right),\\;\\mathrm{where}\\;D\\geq d\\;\\mathrm{and}\\;m\\geq\\frac{\\binom{N}{D}}{\\binom{N}{D-d}}.</span></p>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Guess and Determine Attacks.</h5>

    <p class="text-gray-300">Note that this section has been motivated by a private communication from Sébastien Duval, Virginie Lallemand and Yann Rotella, of which the details will be available in an upcoming ePrint report <em>[x11]</em>. Guess and determine attacks are generic attacks which consist in guessing <span class="math">\\ell</span> bits of the key in order to cancel some monomials. In our context, it allows an adversary to focus on a filtering function restricted to a subset of variables. This weaker function can then be cryptanalyzed, <em>e.g.</em> analyzed with the four aforementioned attacks, <em>i.e.</em> the algebraic attack, the fast algebraic attack, the correlation/BKW-like attacks and the higher-order correlation attack. The complexity of a guess and determine attack against a function <span class="math">F</span> of <span class="math">N</span> variables is <span class="math">\\min_{\\ell}\\{2^{\\ell}C(F[\\ell])\\}</span> where <span class="math">F[\\ell]</span> is a function of <span class="math">N[\\ell]</span> variables obtained by fixing <span class="math">\\ell</span> variables of <span class="math">F</span>, <span class="math">C(F)</span> is the complexity of the best of the four attacks considered on the filtering function <span class="math">F</span> and the minimum is taken over all <span class="math">\\ell</span>’s. The case <span class="math">\\ell=0</span> corresponds to attack the scheme without guess and determine. We next bound the minimal complexity over these four attacks considering the weakest functions obtained by guessing. To do so, we introduce some notations and criteria allowing us to specify the cryptographic properties of Boolean functions obtained by guessing <span class="math">\\ell</span> variables of Boolean functions being direct sums of monomials. As the impact of guessing is most relevant for fast algebraic attacks and CA/BKW-like attacks, we defer the other part of the analysis and extra lemmas to the Appendix E.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 16 (Direct Sum Vector).</h6>

    <p class="text-gray-300">For a boolean function <span class="math">F</span> of <span class="math">N</span> variables obtained as a direct sum of monomials we associate its direct sum vector : <span class="math">\\mathbf{m}_{F}</span> of length <span class="math">k=\\deg(F)</span> : <span class="math">[m_{1},m_{2},\\cdots,m_{k}]</span> such that <span class="math">m_{i}</span> is the number of monomials of degree <span class="math">i</span> of <span class="math">F</span> and <span class="math">N=\\sum_{i=1}^{k}im_{i}</span>. We define two quantities related to this vector :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{m}_{F}^{*}</span> is the number of nonzero values of <span class="math">\\mathbf{m}_{F}</span>.</li>

      <li><span class="math">\\delta_{\\mathbf{m}_{F}}=\\frac{1}{2}-\\frac{\\text{NL}(F)}{2^{N}}</span>.</li>

    </ul>

    <p class="text-gray-300">These notations will be useful to quantify the impact of guessing some bits on the cryptographic properties of a Boolean function obtained by direct sums. <span class="math">\\mathbf{m}_{F}</span>, <span class="math">\\mathbf{m}_{F}^{*}</span> and <span class="math">\\delta_{\\mathbf{m}_{F}}</span> are easily computable from the description of <span class="math">F</span>, the latter can be computed recursively using Lemma 3.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 7 (Guessing and Direct Sum Vector).</h6>

    <p class="text-gray-300">For all guessing of <span class="math">0\\leq\\ell\\leq N</span> variables of a Boolean function <span class="math">F</span> in <span class="math">N</span> variables obtained by direct sums associated with <span class="math">\\mathbf{m}_{F}</span>, we obtain a function <span class="math">F[\\ell]</span> in <span class="math">N[\\ell]</span> variables associated with <span class="math">\\mathbf{m}_{F[\\ell]}</span> such that :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sum_{i=1}^{\\deg(F[\\ell])}m_{i}[\\ell]\\geq(\\sum_{i=1}^{\\deg(F)}m_{i})-\\ell</span>.</li>

      <li><span class="math">\\mathbf{m}_{F[\\ell]}^{<em>}\\geq\\mathbf{m}_{F}^{</em>}-\\lfloor\\frac{\\ell}{\\min_{1\\leq i\\leq\\deg(F)}m_{i}}\\rfloor</span>.</li>

      <li><span class="math">\\delta_{\\mathbf{m}_{F[\\ell]}}\\leq\\delta_{\\mathbf{m}_{F}}2^{\\ell}</span>.</li>

    </ol>

    <p class="text-gray-300">Hereafter we describe the bounds we have used in order to assess the security of our instances.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Lemma 8 (Guess And Determine & Fast Algebraic Attacks).</h6>

    <p class="text-gray-300">Let <span class="math">F</span> be a boolean function in <span class="math">N</span> variables and <span class="math">C_{GDFAA}(F)</span> be the minimum complexity of the Guess And Determine with Fast Algebraic Attacks on <span class="math">F</span>, then :</p>

    <p class="text-gray-300"><span class="math">C_{GDFAA}(F)\\geq\\min_{0\\leq\\ell\\leq N}\\left[2^{\\ell}\\binom{\\min N[\\ell]}{\\mathbf{m}_{F[\\ell]}^{<em>}}\\log^{2}\\binom{\\min N[\\ell]}{\\mathbf{m}_{F[\\ell]}^{</em>}}+(\\min N[\\ell])^{2}\\left(\\frac{\\min N[\\ell]}{\\mathbf{m}_{F[\\ell]}^{*}}\\right)+(\\min N[\\ell])^{\\omega}\\right],</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{m}_{F[\\ell]}^{<em>}=\\mathbf{m}_{F}^{</em>}-\\lfloor\\frac{\\ell}{\\min_{i\\in[\\deg(F)]}m_{i}}\\rfloor</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 9 (Guess and Determine & CA/BKW-like Attacks).</h6>

    <p class="text-gray-300">Let <span class="math">F</span> be a boolean function in <span class="math">N</span> variables and <span class="math">C_{GDCA/BKW}(F)</span> be the minimum complexity of the Guess And Determine with Correlation/BKW Attacks on <span class="math">F</span>, then :</p>

    <p class="text-gray-300"><span class="math">C_{GDCA/BKW}(F)\\geq\\min_{0\\leq\\ell\\leq N}\\{2^{-\\ell}\\delta_{\\mathbf{m}_{F}}^{-2}\\}.</span></p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">Other attacks.</h4>

    <p class="text-gray-300">Besides the previous attacks that will be taken into account quantitatively when selecting our concrete instances of FLIP designs, we also investigated the following other cryptanalyses. First, <em>fast correlation attacks</em> were introduced by Meier and Staffelbach at Eurocrypt 1988 <em>[x18]</em>. A recent survey can be found in <em>[x17]</em>. The attack is divided into two phases. The first one aims at looking for relations between the output bits <span class="math">a_{i}</span> of the LFSR to generate a system of parity-check equations. The second one uses a fast decoding algorithm (<em>e.g.</em> the belief propagation algorithm) in order to decode the words of the code <span class="math">z_{i}=F(a_{i})</span> satisfying the previous relations, where the channel has an error probability <span class="math">p=\\frac{\\mathsf{NL}(F)}{2^{N}}</span>. The working principles of this attack are quite similar to the ones of the previously mentioned correlation attacks and BKW-like attacks. So we assume that the previous (conservative) complexity estimates rule out this variation as well. Besides, note that intuitively, the belief propagation algorithm is best suited to the decoding of low-density parities, which is what our construction (and the LPN problem) typically avoid.</p>

    <p class="text-gray-300">Second, <em>weak keys</em> (<em>i.e.</em> keys of low or high hamming weights) can produce a keystream sufficiently biased to determine this hamming weight, and then to recover the key among the small amount of possible ones. The complexity of such attacks can be computed from the resiliency of <span class="math">F</span>. However, since our <span class="math">N</span> parameter will typically be significantly larger than the bit-security of our filter permutator instances, we suggest to restrict the key space to keys of Hamming weight <span class="math">N/2</span> to rule out this concern. For this purpose, master keys can simply be generated by applying a first (secret) random permutation to any stream with Hamming weight <span class="math">N/2</span>.</p>

    <p class="text-gray-300">Third, <em>augmented function attacks</em> are attacks focusing on multiple outputs of the function rather than one. The goal is to find coefficients <span class="math">j_{1},\\cdots,j_{r}</span> such that a relation between the key and the outputs <span class="math">s_{i+j_{1}},\\cdots,s_{i+j_{r}}</span> can be exploited. This relation can be a correlation (as explained in <em>[x3]</em>) or simply algebraic <em>[x10]</em>. In both cases, a prerequisite is that the relation holds on a sufficient number of <span class="math">i</span>. As each bit output by FLIP depends on a different permutation, we believe that there is no exploitable relation between different outputs.</p>

    <p class="text-gray-300">Eventually, <em>cube attacks</em> were introduced by Dinur and Shamir at Eurocrypt 2009 <em>[x12]</em> as a variant of algebraic attacks taking advantage of the public parameters of a cryptographic protocol (plaintext in block ciphers, IV in stream cipher) in order to generate a system of equations of low degree. However in filter permutator constructions, the only such public parameter is the seed of the PRNG allowing to generate the pseudo-random bit permutations <span class="math">P_{i}</span>. Since controlling this seed hardly allow any control of the <span class="math">F</span> function’s inputs, such attacks do not seem applicable. A similar observation holds for conditional differential cryptanalysis <em>[x15]</em> and for integral/zero-sum distinguishers <em>[x5, x19]</em>.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">3.5 Cautionary note and design tweaks</h3>

    <p class="text-gray-300">As already mentioned, all the previous analyzes are based on standard cryptanalysis and design tools. In particular, the security of our FLIP designs is based on properties of Boolean functions that are generally computed assuming a uniform input distribution. Yet, for filter permutators this condition is not strictly</p>

    <p class="text-gray-300">respected since the Hamming weight of the key register is fixed (we decided to set it to  <span class="math">N / 2</span>  in order to avoid weak keys, but even without this condition, it would be fixed to an unknown value). This means the input distribution of our linear, quadratic and triangle functions is not uniform. We verified experimentally that the output of FLIP is sufficiently balanced despite this non-uniformity. More precisely, we could not detect biases larger than  <span class="math">2^{\\frac{9}{2}}</span>  when generating  <span class="math">2^{q}</span>  bits of keystream (based on small-scale experiments with  <span class="math">q = 32</span> ). But we did not study the impact of this non-uniformity for other attacks, which we leave as an important research scope, both from the cryptanalysis and the Boolean functions points-of-view.</p>

    <p class="text-gray-300">Note that in case the filter permutator of Section 3.1 turns out to have weaknesses specifically due to the imbalanced  <span class="math">F</span>  function's inputs, there are tweaks that could be used to mitigate their impact. The simplest one is to apply a public whitening to the input bits of the non-linear parts of  <span class="math">F</span>  (using additional public PRNG outputs), which has no impact on the homomorphic capacity. The adversary could then bias the  <span class="math">F</span>  function's inputs based on his knowledge of the whitening bits, but to a lower extent than with our fixed Hamming weight keys. Alternatively, one could add a (more or less complex) linear layer before the nonlinear part of  <span class="math">F</span> , which would then make the filter permutator conceptually more similar to filter generators, and (at least for certain layers) only imply moderate cost from the FHE point-of-view.</p>

    <p class="text-gray-300">We selected a few instances aiming at 80- and 128-bit security based on the previous bounds, leading to the attack complexities listed in Table 1, where  <span class="math">\\mathsf{FLIP}(n_1,n_2,n^b\\Delta^k)</span>  denotes the instantiation of FLIP with linear part of  <span class="math">n_1</span>  bits, quadratic part of  <span class="math">n_2</span>  bits and  <span class="math">nb</span>  triangular functions of degree  <span class="math">k</span> . These instances are naturally contrasted. On the one hand, the bounds taken are conservative with respect to the attacks</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instance</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FAA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CA/BKW</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">HOC</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(42,128,8Δ9)</td>

            <td class="px-3 py-2 border-b border-gray-700">530</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(46,136,4Δ15)</td>

            <td class="px-3 py-2 border-b border-gray-700">662</td>

            <td class="px-3 py-2 border-b border-gray-700">91</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(82,224,8Δ16)</td>

            <td class="px-3 py-2 border-b border-gray-700">1394</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">112</td>

            <td class="px-3 py-2 border-b border-gray-700">140</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">155</td>

            <td class="px-3 py-2 border-b border-gray-700">109</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(86,238,5Δ23)</td>

            <td class="px-3 py-2 border-b border-gray-700">1704</td>

            <td class="px-3 py-2 border-b border-gray-700">149</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">137</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">74</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Attack complexities in function of  <span class="math">n_1</span> ,  <span class="math">n_2</span>  and  <span class="math">^{nb}\\Delta^k</span> . AA stands for algebraic attacks, FAA stands for fast algebraic attacks, CA/BKW stands for correlation or BKW-like attacks, HOC stands for higher-order correlation attacks and  <span class="math">\\ell</span>  stands for the number of bits guessed leading to the best complexity for guess and determine attacks. For the CA/BKW column, we reported the minimum complexity between the correlation and BKW-like attack. Eventually,  <span class="math">\\lambda</span>  stands for the security parameter of  <span class="math">F</span>  and is simply taken as the minimum between AA, FAA,CA/BKW and HOC.</p>

    <p class="text-gray-300">considered: if these attacks were the best ones, more aggressive instances could be proposed (e.g. in order to reduce the key size). On the other hand, filter permutators are based on non-standard design principles, and our security analysis is only preliminary, which naturally suggests the need of security margins. Overall, we believe the proposed instances are a reasonable trade-off between efficiency and security based on our current understanding of filter permutators, and therefore are a good target for further investigations.</p>

    <p class="text-gray-300">Before analyzing the FHE properties of filter permutators, we finally suggest FLIP designs based on indirect sums as another interesting topic for evaluation, since they lead to quite different challenges. Namely, the main motivation to use direct sums in the previous sections was the possibility to assess their cryptographic properties based on existing tools. By contrast, filter permutator designs based on indirect sums seem harder to analyze (both for designers and cryptanalysts). This is mainly because in this case, not only the inputs of the Boolean functions vary, but also the Boolean functions themselves. For illustration, we can specify “multi-FLIP” designs, next denoted as <span class="math">b</span>-FLIP designs, such that we compute <span class="math">b</span> instances of FLIP in parallel, each with the same filtering function but with different permutations, and then to XOR the <span class="math">b</span> computed bits in order to produce a keystream bit. We conjecture that such <span class="math">b</span>-FLIP designs could lead to secure stream ciphers with smaller states, and suggest <span class="math">10</span>-FLIP<span class="math">(10,20,{{}^{1}\\Delta^{20}})</span> and <span class="math">15</span>-FLIP<span class="math">(15,30,{{}^{1}\\Delta^{30}})</span> as exemplary instances for 80- and 128-bit security.</p>

    <h2 id="sec-47" class="text-2xl font-bold">4 Application to FHE</h2>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">4.1 80- &amp; 128-bit security parameters</h3>

    <p class="text-gray-300">For the security parameters choices, we follow the analysis of Lindner and Peikert <em>[x10]</em> for the hardness of LWE and RLWE, considering distinguishing and decoding attacks using BKZ <em>[x13, x5]</em>. We assume that the distribution <span class="math">\\chi</span> in the considered LWE instances is the discrete Gaussian distribution with mean <span class="math">0</span> and standard deviation <span class="math">\\sigma</span>. First we compute the best root Hermite factor <span class="math">\\delta</span> of a basis (see <em>[x11]</em>) computable with complexity <span class="math">2^{\\lambda}</span> from the conservative lower bound of <em>[x10]</em>:</p>

    <p class="text-gray-300"><span class="math">\\log(\\delta)=1.8/(110+\\lambda).</span> (1)</p>

    <p class="text-gray-300">The distinguishing attack described in <em>[x12, x14, x10]</em> is successful with advantage <span class="math">\\varepsilon</span> by finding vectors of length <span class="math">\\alpha\\frac{q}{\\sigma}</span> with <span class="math">\\alpha=\\sqrt{\\ln(1/\\varepsilon)/\\pi}</span>. The length of the shortest vector that can be computed is <span class="math">2^{2\\sqrt{n\\log q\\log\\delta}}</span>, leading to the inequation:</p>

    <p class="text-gray-300"><span class="math">\\alpha\\frac{q}{\\sigma}&amp;lt;2^{2\\sqrt{n\\log q\\log\\delta}}.</span> (2)</p>

    <p class="text-gray-300">Given <span class="math">\\sigma\\geq 2\\sqrt{n}</span> from Regev’s reduction <em>[x16]</em>, we can choose parameters for <span class="math">n</span> and <span class="math">q</span> matching equation (2) for the considered security parameter <span class="math">\\lambda</span>. The parameters we select for our application are summarized in Table 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security <span class="math">\\lambda</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">n</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\log q</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: (R)LWE parameters used in our applications.</p>

    <p class="text-gray-300">4.2 Noise analysis</p>

    <p class="text-gray-300">Considering our framework of Figure 1, Claude has at its disposal the homomorphic encryption of the symmetric key <span class="math">\\mathbf{C}^{H}(\\mathsf{sk}_{i}^{S})</span>, the homomorphic public key <span class="math">\\mathsf{pk}^{H}</span> and the symmetric encrypted messages <span class="math">\\mathbf{C}^{S}(m_{i})</span>. He has to perform the homomorphic evaluation of the symmetric decryption circuit, i.e. to perform homomorphic operations on the ciphertexts <span class="math">\\mathbf{C}^{H}(\\mathsf{sk}_{i}^{S})</span> in order to get <span class="math">\\mathbf{C}^{H}(m_{i})</span>, the homomorphic encryption of <span class="math">m_{i}</span>. In this section, we study the error growth in these ciphertexts after the application of the homomorphic operations. As we are considering SWHE, we need to control the magnitude of the error and keep it below a critical level to ensure the correctness of a final ciphertext. This noise management is crucial for the applications, it is directly linked with the quantity of computation that the server can do for the client. We now study the error growth stemming from the homomorphic evaluation of FLIP. In this case, all the ciphertexts used by the server in the computation step will have a same starting error. The knowledge of this starting error (defined by some parameter) and its growth for additions and multiplications (in a chosen order) is enough to determine the amount of computation that can be performed correctly by the server.</p>

    <p class="text-gray-300">In the remaining of this section we proceed in three steps. First we recall the error growth implied by the <span class="math">H.\\mathsf{Add}</span> and <span class="math">H.\\mathsf{Mul}</span> operations: for GSW-like HE it has already been done in <em>[x10, x1, x11, x12, x13]</em>. As our homomorphic encryption schemes are slightly differently written to fit our applications (batched version to perform in parallel the same computations, generic notations for various frameworks), we give these error growth with our notations for completeness and consistency of the paper. Then we analyse the error for a sub-case of homomorphic product, namely <span class="math">H.\\mathsf{Comb}</span>, which gives a practical tool to study the error growth in FLIP. As the asymmetric property of GSW multiplication and plaintext norm have been pointed out relatively to the error growth, we consider important to focus on both when analysing this error metric. Considering <span class="math">H.\\mathsf{Comb}</span> types of operations is therefore suited to be consistent with this metric and is very important for practical purpose (in term of real life applications). Finally we analyse the error in a ciphertext output by FLIP and study some optimizations to reduce the noise growth further.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Error Growth in <span class="math">H.\\mathsf{Add}</span> and <span class="math">H.\\mathsf{Mul}</span>.</h4>

    <p class="text-gray-300">We first need to evaluate the error growth of the basic homomorphic operations, the addition and the multiplication of ciphertexts. We use the analysis of <em>[x10]</em> based on subgaussian distributions to study the error growth in these homomorphic operations. From a coefficient or a vector following a subgaussian distribution of parameter <span class="math">\\sigma</span>, we can bound its norm with overwhelming probability and then study the evolution of this parameter while performing the homomorphic operations. Hence we can bound the final error to ensure correctness.</p>

    <p class="text-gray-300">For simplicity we use two notations arising in the error growth depending on the arithmetic of the underlying ring of the two schemes, <span class="math">\\gamma</span> the expansion factor (see <em>[x2]</em>) and <span class="math">Norm(m_{j})</span> such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Batched GSW: <span class="math">\\gamma=1</span> and $Norm(m_{j})=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (arithmetic in </span>\\mathbb{Z}$) .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 10 (<span class="math">H.\\mathsf{Add}</span> error growth).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\mathbf{C}_{i}</span> for <span class="math">1\\leq i\\leq k</span> are ciphertexts of a GSW based Homomorphic Encryption scheme with error components <span class="math">\\mathbf{e}_{i}</span> of coefficients following a distribution of parameter <span class="math">\\sigma_{i}</span>. Let <span class="math">\\mathbf{C}_{f}=H.\\mathsf{Add}(\\mathbf{C}_{i}</span>, for <span class="math">1\\leq i\\leq k)</span> and <span class="math">\\mathbf{e}_{f}</span> the related error with subgaussian parameter <span class="math">\\sigma^{\\prime}</span> such that:</p>

    <p class="text-gray-300"><span class="math">\\sigma^{\\prime}=\\sqrt{\\sum_{i=1}^{k}\\sigma_{i}^{2}}\\quad\\text{or}\\quad\\,\\,\\sigma^{\\prime}=\\sigma\\sqrt{k}\\,\\,\\,\\text{if}\\,\\,\\,\\sigma_{i}=\\sigma,\\forall i\\in[k].</span></p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 11 (<span class="math">H.\\mathsf{Mul}</span> error growth).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\mathbf{C}_{i}</span> for <span class="math">1\\leq i\\leq k</span> are ciphertexts of a GSW based Homomorphic Encryption scheme with error components <span class="math">\\mathbf{e}_{i}</span>, of coefficients following a subgaussian distribution of parameter <span class="math">\\sigma_{i}</span>, and plaintext <span class="math">m_{i}</span>. <span class="math">\\mathbf{C}_{f}</span> is the result of a multiplicative homomorphic chain such that:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}_{f}=H.\\mathsf{Mul}(\\mathbf{C}_{1},H.\\mathsf{Mul}(\\mathbf{C}_{2},H.\\mathsf{Mul}(\\cdots,H.\\mathsf{Mul}(\\mathbf{C}_{k},\\mathbf{G})))),</span></p>

    <p class="text-gray-300">and <span class="math">\\mathbf{e}_{f}</span> the corresponding error with subgaussian parameter <span class="math">\\sigma^{\\prime}</span> such that:</p>

    <p class="text-gray-300"><span class="math">\\sigma^{\\prime}=\\mathcal{O}\\left(\\sqrt{N\\gamma}\\sqrt{\\sigma_{1}^{2}+\\sum_{i=2}^{k}\\left(\\sigma_{i}\\Pi_{j=1}^{i-1}Norm(m_{j})\\right)^{2}}\\right).</span></p>

    <p class="text-gray-300">Lemmas 10 and 11 are proven in Appendix F.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Error Growth in <span class="math">H.\\mathsf{Comb}</span>.</h4>

    <p class="text-gray-300">For the sake of clarity, we formalize hereafter the comb homomorphic product <span class="math">H.\\mathsf{Comb}</span> and the quantity <span class="math">\\sigma_{comb}</span> which stands for the subgaussian parameter. We study the error growth of <span class="math">H.\\mathsf{Comb}</span> as we will use it as a tool for the error growth analysis of FLIP.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 17 (homomorphic comb <span class="math">H.\\mathsf{Comb}</span>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{C}_{1},\\cdots,\\mathbf{C}_{k}</span> be <span class="math">k</span> ciphertexts of a GSW based Homomorphic Encryption scheme with error coefficients from independent distributions with same subgaussian parameter <span class="math">\\sigma</span>. We define <span class="math">H.\\mathsf{Comb}(y,\\sigma,c,k)=H.\\mathsf{Mul}(\\mathbf{C}_{1},\\cdots,\\mathbf{C}_{k},\\mathbf{G})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">y=\\sqrt{N\\gamma}</span> is a constant depending on the ring,</li>

      <li><span class="math">c=\\max_{1\\leq i\\leq k}(Norm(m_{i}))</span> is a constant which depends on the plaintexts,</li>

    </ul>

    <p class="text-gray-300">and <span class="math">\\mathbf{C}_{comb}=H.\\mathsf{Comb}(y,\\sigma,c,k)</span> as error components following a subgaussian distribution of parameter <span class="math">\\mathcal{O}(\\sigma_{comb})</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 12 (<span class="math">\\sigma_{comb}</span> quantity).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{C}_{1},\\cdots,\\mathbf{C}_{k}</span> be <span class="math">k</span> ciphertexts of a GSW based Homomorphic Encryption scheme with same error parameter <span class="math">\\sigma</span> and <span class="math">\\mathbf{C}_{comb}=H.\\mathsf{Comb}(y,\\sigma,c,k)</span>. Then we have:</p>

    <p class="text-gray-300"><span class="math">\\sigma_{comb}(y,\\sigma,c,k)=y\\sigma c_{k},\\quad\\text{ where }c_{k}=\\sqrt{\\sum_{i=0}^{k-1}c^{2i}}.</span></p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Thanks to Lemma 11 we obtain:</p>

    <p class="text-gray-300"><span class="math">\\sigma_{comb}</span> <span class="math">=\\sqrt{N\\gamma}\\sqrt{\\sigma^{2}+\\sum_{i=2}^{k}(\\sigma\\Pi_{j=1}^{i-1}Norm(m_{j}))^{2}},</span> <span class="math">\\sigma_{comb}</span> <span class="math">=y\\sqrt{\\sigma^{2}+\\sum_{i=2}^{k}(\\sigma c^{i-1})^{2}},</span> <span class="math">\\sigma_{comb}</span> <span class="math">=y\\sigma\\sqrt{\\sum_{i=1}^{k}(c^{i-1})^{2}},</span> <span class="math">\\sigma_{comb}</span> <span class="math">=y\\sigma c_{k}.</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">The compatibility of this comb structure with the asymmetric multiplicative error growth property of GSW enables us to easily quantify the error in our construction, with a better accuracy than computing the multiplicative depth. In order to minimize the quantity <span class="math">\\sigma_{comb}</span>, we choose the plaintext space such that <span class="math">c=1</span></p>

    <p class="text-gray-300">for freshly generated ciphertexts. The resulting <span class="math">\\sigma_{comb}(y,\\sigma,1,k)</span> quantity is therefore <span class="math">y\\sigma\\sqrt{k}</span>, growing less than linearly in the number of ciphertexts. Fixing the constant <span class="math">c</span> to be <span class="math">1</span> is usual with FHE. As we mostly consider Boolean circuits, it is usual to use plaintexts in <span class="math">\\{-1,0,1\\}</span> to encrypt bits, leading to <span class="math">c=1</span> and therefore <span class="math">c_{k}=\\sqrt{k}</span>.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Error Growth in FLIP</h4>

    <p class="text-gray-300">In the previous paragraphs, we have evaluated the error growth in the basic homomorphic operations <span class="math">H.\\mathsf{Add}</span>, <span class="math">H.\\mathsf{Mul}</span> and <span class="math">H.\\mathsf{Comb}</span>. We will use them as building blocks in order to evaluate the error growth in the homomorphic evaluation of FLIP. Coming back to the framework of Figure 1, the error in the ciphertexts <span class="math">\\mathbf{C}^{H}(m_{i})</span> is of major importance as it will determine the possible number of homomorphic computations <span class="math">f</span> that Claude is able to perform.</p>

    <p class="text-gray-300">The main feature of the filter permutator model, considering FHE settings, is that it allows to handle with ciphertexts having the same error level, whatever the number of output bits. Consequently all ciphertexts obtained by FLIP evaluation will have the same constant and small amount of noise and will be considered as fresh start for more computation.</p>

    <p class="text-gray-300">Evaluating homomorphically the FLIP decryption (resp. encryption) algorithm consists in applying three steps of homomorphic operations on the ciphertexts <span class="math">\\mathbf{C}^{H}(\\mathsf{sk}_{i}^{S})</span> in our application framework, each one encoding one bit of the key register. For each ciphertext bit, these steps are: a (bit) permutation, the application of the filtering function <span class="math">F</span> and a XOR with the ciphertext (resp. plaintext). The (bit) permutation consists only in a public rearrangement of the key ciphertexts, leading to a noise-free operation. The last XOR is done with a freshly encrypted bit. Hence the error growth depends mostly on the homomorphic evaluation of <span class="math">F</span>.</p>

    <p class="text-gray-300">As <span class="math">H.\\mathsf{Dec}</span> outputs quantities modulus <span class="math">2</span>, we can evaluate the XORs of <span class="math">F</span> by <span class="math">H.\\mathsf{Add}</span> and the ANDs by <span class="math">H.\\mathsf{Mul}</span>. We then determine the subgaussian parameter of the error of a ciphertext from the homomorphic evaluation of <span class="math">F</span>. For a given encrypted key, this parameter will be the same for every homomorphic evaluation of FLIP and is computed from <span class="math">\\sigma_{comb}</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 13 (Error growth evaluating <span class="math">F</span>).</h6>

    <p class="text-gray-300">Let <span class="math">F</span> be the FLIP filtering function in <span class="math">N</span> variables defined in Section 3.3. Assume that <span class="math">\\mathbf{C}_{i}</span> for <span class="math">0\\leq i\\leq N-1</span> are ciphertexts of a GSW HE scheme with same subgaussian parameter <span class="math">\\sigma</span> and <span class="math">c=1</span>. We define <span class="math">\\mathbf{C}_{F}=H.\\mathsf{Eval}(F,\\mathbf{C}_{i})</span> the output of the homomorphic evaluation of the ciphertexts <span class="math">\\mathbf{C}_{i}</span>’s along the circuit <span class="math">F</span>. Then the error parameter <span class="math">\\sigma^{\\prime}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\sigma^{\\prime}=\\mathcal{O}\\left(\\sigma\\sqrt{n_{1}+y^{2}(n_{2}+n_{3})}\\right)\\approx\\mathcal{O}\\left(\\sigma y\\sqrt{N}\\right).</span></p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first evaluate the noise brought by <span class="math">F</span> for each of its components <span class="math">L_{n_{1}}</span>, <span class="math">Q_{n_{2}}</span>, <span class="math">{}^{nb}\\Delta^{k}</span>, defining the respective ciphertexts <span class="math">\\mathbf{C}_{L_{n_{1}}},\\mathbf{C}_{Q_{n_{2}}},\\mathbf{C}_{T_{k}}</span>(the last one standing for one triangle only) and the subgaussian parameter of the respective error distributions (of the components of the error vectors) <span class="math">\\sigma_{L_{n_{1}}},\\sigma_{Q_{n_{2}}},\\sigma_{T_{k}}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_{n_{1}}</span>: <span class="math">\\mathbf{C}_{L_{n_{1}}}=H.\\mathsf{Eval}(L_{n_{1}},\\mathbf{C}_{0},\\cdots,\\mathbf{C}_{n_{1}-1})=H.\\mathsf{Add}(\\mathbf{C}_{0},\\cdots,\\mathbf{C}_{n_{1}-1})</span> then <span class="math">\\sigma_{L_{n_{1}}}=\\sigma\\sqrt{n_{1}}</span>.</li>

      <li><span class="math">Q_{n_{2}}</span>: <span class="math">\\mathbf{C}_{Q_{n_{2}}}=H.\\mathsf{Add}(H.\\mathsf{Mul}(\\mathbf{C}_{n_{1}+2j},\\mathbf{C}_{n_{1}+2j+1},\\mathbf{G}))</span> for <span class="math">0\\leq j\\leq n_{2}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">H.\\mathsf{Mul}(\\mathbf{C}_{n_{1}+2j},\\mathbf{C}_{n_{1}+2j+1},\\mathbf{G})=H.\\mathsf{Comb}(y,\\sigma,1,2)</span> has subgaussian parameter <span class="math">\\mathcal{O}(\\sigma_{comb}(y,\\sigma,1,2))=\\mathcal{O}(y\\sigma\\sqrt{2})</span> for <span class="math">0\\leq j\\leq n_{2}</span>. Then <span class="math">\\sigma_{Q_{n_{2}}}=\\mathcal{O}(y\\sigma\\sqrt{2}\\sqrt{\\frac{n_{2}}{2}})=\\mathcal{O}(y\\sigma\\sqrt{n_{2}})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{k}</span>: <span class="math">\\mathbf{C}_{T_{k}}=H.\\mathsf{Add}(H.\\mathsf{Mul}(\\mathbf{C}_{n_{1}+n_{2}+j+(i-1)(i-2)/2};1\\leq j\\leq i);1\\leq i\\leq k)</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{C}_{T_{k}}=H.\\mathsf{Add}(H.\\mathsf{Comb}(y,\\sigma,1,i),1\\leq i\\leq k)</span>.</p>

    <p class="text-gray-300"><span class="math">\\sigma_{T_{k}}=\\mathcal{O}(\\sqrt{\\sum_{i=1}^{k}(y\\sigma\\sqrt{i})^{2}})=\\mathcal{O}(y\\sigma\\sqrt{\\frac{k(k+1)}{2}}).</span></p>

    <p class="text-gray-300">As <span class="math">{}^{nb}\\Delta^{k}</span> is obtained by adding <span class="math">nb</span> independent triangles, we get:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}_{{}^{nb}\\Delta^{k}}=H.\\mathsf{Add}(\\mathbf{C}_{T_{k},i},1\\leq i\\leq nb)</span>,</p>

    <p class="text-gray-300">and <span class="math">\\sigma_{{}^{nb}\\Delta^{k}}=\\mathcal{O}(y\\sigma\\sqrt{nb}\\sqrt{\\frac{k(k+1)}{2}})=\\mathcal{O}(y\\sigma\\sqrt{n_{3}})</span>.</p>

    <p class="text-gray-300">By Pythagorean additivity the subgaussian parameter of <span class="math">\\mathbf{C}_{F}</span> is finally:</p>

    <p class="text-gray-300"><span class="math">\\sigma^{\\prime}=\\mathcal{O}(\\sqrt{(\\sigma\\sqrt{n_{1}})^{2}+(y\\sigma\\sqrt{n_{2}})^{2}+(y\\sigma\\sqrt{n_{3}})^{2}})=\\mathcal{O}(\\sigma\\sqrt{n_{1}+y^{2}(n_{2}+n_{3})}).</span></p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Optimizations</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The particular error growth in GSW Homomorphic Encryption enables to use more optimizations to reduce the error norm and perform more operations without increasing the parameter sizes. The error growth in <span class="math">H.\\mathsf{Comb}</span> depends on the quantity <span class="math">c_{k}</span> derived from bounds on norms of the plaintexts; these quantities can be reduced using negative numbers. A typical example is in the LWE-based scheme to use <span class="math">m\\in\\{-1,0,1\\}</span> rather than <span class="math">\\{0,1\\}</span>; the <span class="math">c_{k}</span> quantity is the same and in average the sums in <span class="math">\\mathbb{Z}</span> are smaller. Then the norm $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum m_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is smaller which is important when multiplying. Conserving this norm as low as possible gives better bounds and </span>c_{k}<span class="math"> coefficients, leading to smaller noise when performing distinct levels of operations. An equivalent way of minimizing the error growth is to still use </span>\\mathcal{M}=\\{0,1\\}<span class="math"> but with </span>H.\\mathsf{Add}(\\mathbf{C}_{1},\\mathbf{C}_{2})=\\mathbf{C}_{1}\\pm\\mathbf{C}_{2}$. This homomorphic addition is still correct because:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{S}-\\mathbf{C}_{2}=-\\mathbf{E}_{2}^{\\prime}-\\frac{\\left(\\frac{m_{2,1}\\cdot\\mathbf{s}_{1}^{\\top}}{\\vdots}\\right)}{\\left(m_{2,r}\\cdot\\mathbf{s}_{r}^{\\top}\\right)}\\mathbf{G}=\\mathbf{E}_{2}^{\\prime\\prime}+\\frac{\\left(\\frac{-m_{2,1}\\cdot\\mathbf{s}_{1}^{\\top}}{\\vdots}\\right)}{\\left(-m_{2,r}\\cdot\\mathbf{s}_{r}^{\\top}\\right)}\\,,</span></p>

    <p class="text-gray-300">where the coefficients in <span class="math">\\mathbf{E}_{2}^{\\prime\\prime}</span> rows follow distribution of same subgaussian parameter as the one in <span class="math">\\mathbf{E}_{2}^{\\prime}</span> by homogeneity and <span class="math">-m=m\\mod 2</span>.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">4.3 Concrete results</h3>

    <p class="text-gray-300">Contrary to other works published in the context of symmetric encryption schemes for efficient FHE <em>[x10, CCF^{+}15, ARS^{+}15]</em>, our primary focus is not on the performances (see SHIELD <em>[x17]</em> for efficient implementation of Ring-GSW) but rather on the error growth. As pointed out in <em>[CCF^{+}15]</em>, in most of these previous works, after the decryption process the noise inside the ciphertexts was too high to perform any other operation on them, whereas it is the main motivation for a practical use of FHE.</p>

    <p class="text-gray-300">In this section, we consequently provide experimental results about this error growth in the ciphertexts after different operations evaluated on the Ring GSW scheme. As the link between subgaussian parameter, ciphertext error and homomorphic computation is not direct, we make some choices for representing these results focusing on giving intuition on how the error behaves.</p>

    <p class="text-gray-300">The choice of the Ring GSW setting rather than Batched GSW is for convenience. It allows to deal with smaller matrices and faster evaluations, providing the same confirmation on the heuristic error growth. We give the parameters <span class="math">n</span> and <span class="math">\\ell</span> defining the polynomial ring and fix <span class="math">\\sigma=2\\lceil\\sqrt{n}\\rceil</span> for the error distribution.</p>

    <p class="text-gray-300">An efficient way of measuring the error growth within the ciphertexts is to compute the difference by applying the rounding <span class="math">\\lfloor\\cdot\\rceil_{2}</span> in <span class="math">H.\\mathsf{Dec}</span> between various ciphertexts with known plaintext. This difference</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(for each polynomial coefficient or vector component) corresponds to the amount of noise contained in this ciphertext. The correctness requires this quantity to be inferior to  <span class="math">2^{\\ell - 2}</span> . Then, considering its logarithm in base 2, it enables to have an intuitive and practical measure of the ciphertext noise: this quantity grows with the homomorphic operations until this log equals  <span class="math">\\ell - 2</span> . Concretely, in our experiments we encrypt polynomials being  <span class="math">m = 0</span>  or  <span class="math">m = 1</span> , compute on the constant coefficient the quantity  $e =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\langle \\mathbf{s}, \\mathbf{c}_{\\ell} \\rangle - m2^{\\ell - 1}) \\mod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and give its logarithm. We give another quantity in order to provide intuition about the homomorphic computation possibilities over the ciphertexts, by simply computing a percentage of the actual level of noise relatively to the maximal level  </span>\\ell - 2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 4. The quantity exhibited by our measures is roughly the subgaussian parameter of the distribution of the error contained in the ciphertexts. Considering the simpler case of a real Gaussian distribution  <span class="math">\\mathcal{N}(0,\\sigma^2)</span> , the difference that we compute then follows a half normal distribution with mean  <span class="math">\\sigma \\frac{\\sqrt{2}}{\\sqrt{\\pi}}</span> .</p>

    <p class="text-gray-300">We based our prototype implementation on the NTL library combined with GMP and the discrete gaussian sampler of BLISS [DDLL13]. We report in Table 3 experimental results on the error growth for different RLWE and FLIP parameters, based on an average over a hundred of samples.</p>

    <p class="text-gray-300">The results confirm the quasi-additive error growth when considering the specific metric of GSW given by the asymptotic bounds. The main conclusion of these results is that the error inside the ciphertexts after a homomorphic evaluation of FLIP is of the same order of magnitude as the one after a multiplication. The only difference between these noise increases is a term provided by the root of the symmetric key register size, that is linear in  <span class="math">\\lambda</span> . Therefore, with the FLIP construction the error growth is roughly the basic multiplicative error growth of two ciphertexts. Hence, we conclude that filter permutators as FLIP release the bottleneck of evaluating symmetric decryption, and lead the further improvement of the calculus delegation framework to depend overwhelmingly on improvements of the homomorphic operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ring (n, l)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FLIP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fresh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H.Add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H.Mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H.Eval(FLIP)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">log e</td>

            <td class="px-3 py-2 border-b border-gray-700">%</td>

            <td class="px-3 py-2 border-b border-gray-700">log e</td>

            <td class="px-3 py-2 border-b border-gray-700">%</td>

            <td class="px-3 py-2 border-b border-gray-700">log e</td>

            <td class="px-3 py-2 border-b border-gray-700">%</td>

            <td class="px-3 py-2 border-b border-gray-700">log e</td>

            <td class="px-3 py-2 border-b border-gray-700">%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">(42, 128, 8Δ9)</td>

            <td class="px-3 py-2 border-b border-gray-700">13, 07</td>

            <td class="px-3 py-2 border-b border-gray-700">17 %</td>

            <td class="px-3 py-2 border-b border-gray-700">13, 96</td>

            <td class="px-3 py-2 border-b border-gray-700">18%</td>

            <td class="px-3 py-2 border-b border-gray-700">19, 82</td>

            <td class="px-3 py-2 border-b border-gray-700">25%</td>

            <td class="px-3 py-2 border-b border-gray-700">24, 71</td>

            <td class="px-3 py-2 border-b border-gray-700">31%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">(82, 224, 8Δ16)</td>

            <td class="px-3 py-2 border-b border-gray-700">14, 68</td>

            <td class="px-3 py-2 border-b border-gray-700">12 %</td>

            <td class="px-3 py-2 border-b border-gray-700">15, 14</td>

            <td class="px-3 py-2 border-b border-gray-700">13%</td>

            <td class="px-3 py-2 border-b border-gray-700">23, 27</td>

            <td class="px-3 py-2 border-b border-gray-700">20%</td>

            <td class="px-3 py-2 border-b border-gray-700">28, 77</td>

            <td class="px-3 py-2 border-b border-gray-700">24%</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Experimental error growth of Ring-GSW. Fresh,  <span class="math">H</span> .Add,  <span class="math">H</span> .Mul and  <span class="math">H</span> .Eval(FLIP) respectively stands for the noise  <span class="math">e</span>  measure after a fresh homomorphic encryption, the homomorphic addition of two fresh ciphertexts, the homomorphic multiplication of two fresh ciphertexts and the homomorphic evaluation of FLIP on fresh ciphertexts. The first value is the log of the error  <span class="math">e</span>  inside the corresponding ciphertexts and the percentage represents the proportion of the noise with respect to the capacity of decryption (i.e.  <span class="math">\\ell - 2</span> ).</p>

    <p class="text-gray-300">Despite our new constructions are primarily designed for 3rd-generation FHE, a look at Table 4 suggests that also from the multiplicative depth point of view, FLIP instances bring good results compared to their natural competitors such as LowMC  <span class="math">\\left[\\mathrm{ARS}^{+}15\\right]</span>  and Trivium/Kreyvium  <span class="math">\\left[\\mathrm{CCF}^{+}15\\right]</span> . In Trivium/Kreyvium, the multiplicative depth of the decryption circuit is at most 13, while the LowMC family has a record</p>

    <p class="text-gray-300">multiplicative depth of 11 which is still larger than our FLIP instances. For completeness, we finally investigated the performances of some instances of FLIP for 2nd-generation FHE schemes using HElib, as reported in Table 5, where the latency is the amount of time (in seconds) needed to homomorphically decrypt (Nb <em> Number of Slots) bits, and the throughput is calculated as (Nb </em> Number of Slots * 60)/latency. As</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Multiplicative depth</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON-32/64</td>

            <td class="px-3 py-2 border-b border-gray-700">[LN14]</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">[CCF+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">[CCF+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMc-80</td>

            <td class="px-3 py-2 border-b border-gray-700">[ARS+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(42, 128, 8Δ9)</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">[log 9] = 4</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES-128</td>

            <td class="px-3 py-2 border-b border-gray-700">[GHS12, CLT14]</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SIMON-64/128</td>

            <td class="px-3 py-2 border-b border-gray-700">[LN14]</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prince</td>

            <td class="px-3 py-2 border-b border-gray-700">[DSES14]</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">[CCF+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">[CCF+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMc-128</td>

            <td class="px-3 py-2 border-b border-gray-700">[ARS+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(82, 224, 8Δ16)</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">[log 16] = 4</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Multiplicative depth of different symmetric ciphers.</p>

    <p class="text-gray-300">in  <span class="math">\\left[\\mathrm{CCF}^{+}15\\right]</span> , we have considered two noise levels: a first one that does not allow any other operations on the ciphertexts, and a second one where we allow operations of multiplicative depth up to 7. Note that the (max) parenthesis in the Nb column recalls that for Trivium/Kreyvium, the homomorphic capacity decreases with the number of keystream bits generated, which therefore bounds the number of such bits before re-keying. We observe that for 80-bit security, our instances outperform the ones based on Trivium. As for 128-bit security, the gap between our instances and Kreyvium is limited (despite the larger state of FLIP), and LowMC has better throughput in this context. Note also that our results correspond to the evaluation of the  <span class="math">F</span>  function of FLIP (we verified that the time needed to generate the permutations only marginally affects the overall performances of homomorphic FLIP evaluations). We finally mention that these results should certainly not be viewed as strict comparisons, since obtained on different computers and for relatively new ciphers for which we have limited understanding of the security margins (especially for LowMC [DLMW15, DEM15] and FLIP). So they should mainly be seen as an indication that besides their excellent features from the FHE capacity point-of-view, filter permutators inherently have good properties for efficient 2nd-generation FHE implementations as well.</p>

    <p class="text-gray-300">In the context of our Homomorphic Encryption - Symmetric Encryption framework, where most of the computations are delegated to a server, we have designed a symmetric encryption scheme which fits the FHE settings, with as main goal to get the homomorphic evaluation of the symmetric decryption circuit as cheap</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Nb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Number of Slots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Latency (sec)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughput (bits/min)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">45 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">1417.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1143.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">45 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">4420.3</td>

            <td class="px-3 py-2 border-b border-gray-700">439.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Trivium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">136 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">3650.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1341.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">136 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">11379.7</td>

            <td class="px-3 py-2 border-b border-gray-700">516.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-12</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">42 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">504</td>

            <td class="px-3 py-2 border-b border-gray-700">1715.0</td>

            <td class="px-3 py-2 border-b border-gray-700">740.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">42 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">756</td>

            <td class="px-3 py-2 border-b border-gray-700">4956.0</td>

            <td class="px-3 py-2 border-b border-gray-700">384.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Kreyvium-13</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">124 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">682</td>

            <td class="px-3 py-2 border-b border-gray-700">3987.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1272.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">124 (max)</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">420</td>

            <td class="px-3 py-2 border-b border-gray-700">12450.8</td>

            <td class="px-3 py-2 border-b border-gray-700">286.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LowMC-128</td>

            <td class="px-3 py-2 border-b border-gray-700">? ≤ 128</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">682</td>

            <td class="px-3 py-2 border-b border-gray-700">3368.8</td>

            <td class="px-3 py-2 border-b border-gray-700">3109.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">? ≤ 128</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">9977.1</td>

            <td class="px-3 py-2 border-b border-gray-700">739.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(42, 128, 8Δ9)</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">378</td>

            <td class="px-3 py-2 border-b border-gray-700">4.72</td>

            <td class="px-3 py-2 border-b border-gray-700">4805.08</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">600</td>

            <td class="px-3 py-2 border-b border-gray-700">17.39</td>

            <td class="px-3 py-2 border-b border-gray-700">2070.16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FLIP(82, 224, 8Δ16)</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">630</td>

            <td class="px-3 py-2 border-b border-gray-700">14.53</td>

            <td class="px-3 py-2 border-b border-gray-700">2601,51</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">720</td>

            <td class="px-3 py-2 border-b border-gray-700">102.51</td>

            <td class="px-3 py-2 border-b border-gray-700">421.42</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Timings of the homomorphic evaluation of several instances of the Boolean function of FLIP using HElib on an Intel Core i7-3770. The other results are taken from  <span class="math">\\left[\\mathrm{CCF}^{+}15\\right]</span> . L and Number of Slots are HElib parameters which stand respectively for the level of noise and the number of bits packed in one ciphertext. (Nb * Number of Slots) corresponds to the number of decrypted bits.</p>

    <p class="text-gray-300">as possible, with respect to the error growth. In particular the error growth obtained by our construction, only one level of multiplication considering the metric of third generation FHE, achieves the lowest bound we can get with a secure symmetric encryption scheme. The use of zero-noise operations as permutations enables us to combine the advantages of block ciphers and stream ciphers evaluation, namely constant noise on the one hand and starting low noise on the other hand. As a result, the homomorphic evaluation of filter permutators can be made insignificant relatively to a complete FHE framework.</p>

    <p class="text-gray-300">The general construction of our encryption scheme – i.e. the filter permutator – and its FLIP instances are admittedly provocative. As a result, we believe an important contribution of this paper is to open a wide design space of symmetric constructions to investigate, ranging from the very efficient solutions we suggest to more classical stream ciphers such as filter generators. Such a design space leads to various interesting directions for further research. Overall, the main question raised by filter permutators is whether it is possible to build a secure symmetric encryption scheme with aggressively reduced algebraic degree. Such a question naturally relates to several more concrete problems. First, and probably most importantly, additional cryptanalysis is needed in view of the non-standard design principles exploited in filter permutators. It typically includes algebraic attacks tacking advantage of the sparsity of their systems of equations, attacks exploiting the imbalances at the input of the filter, and the possibility to exploit chosen IVs to improve those attacks. Second, our analyses also raise interesting problems in the field of Boolean functions, e.g. the analysis of such functions with non-uniform input distributions and the investigation of the best fixed degree approximations of a Boolean function (which is needed in our study of higher-order correlation attacks). More directly related to the FLIP instances, it would also be interesting to refine our security analyses, with a stronger focus on the attacks data complexity, and to evaluate whether instances with smaller key register could be sufficiently secure. In case of new cryptanalysis results, the design tweaks we suggest in the paper are yet another interesting research path. Eventually, and from the FHE application point-of-view, optimizing the implementations of filter permutators, e.g. by taking advantage of parallel computing clusters that we did not exploit so far, would be useful in order to evaluate their applicability to real-world scenarii.</p>

    <p class="text-gray-300">Acknowledgements. We are highly grateful to Sébastien Duval, Virginie Lallemand and Yann Rotella for sharing their ideas about guess and determine attacks before the publication of this paper, which allowed us to modify the instances of FLIP accordingly. We are also indebted to Anne Canteaut for numerous useful suggestions about the design of filter permutators, and for putting forward some important open problems they raise. Finally, we would like to thank Thierry Berger, Sergiu Carpov, Raphaël Delpino, Malika Izabachene, Nicky Mouha, Thomas Prest and Renaud Sirdey for their feedback about early (and less early) versions of this paper. This work was funded in parts by the H2020 ICT COST CryptoAction, by the H2020 ICT Project SAFECrypto, by the H2020 ERC Staring Grant CRASH and by the INNOVIRIS SCAUT project. François-Xavier Standaert is a research associate of the Belgian Fund for Scientific Research (F.R.S.-FNRS).</p>

    <h2 id="sec-63" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACG^{+}06] Frederik Armknecht, Claude Carlet, Philippe Gaborit, Simon Künzli, Willi Meier, and Olivier Ruatta. Efficient Computation of Algebraic Immunity for Algebraic and Fast Algebraic Attacks. In Advances in Cryptology - EUROCRYPT 2006, 25th Annual International Conference on the Theory and Applications of Cryptographic Techniques, St. Petersburg, Russia, May 28 - June 1, 2006, Proceedings, pages 147–164, 2006.</li>

      <li>[And94] Ross J. Anderson. Searching for the optimum correlation attack. In Fast Software Encryption: Second International Workshop. Leuven, Belgium, 14-16 December 1994, Proceedings, pages 137–143, 1994.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[AP12] Jacob Alperin-Sheriff and Chris Peikert. Circular and KDM security for identity-based encryption. In Public Key Cryptography - PKC 2012 - 15th International Conference on Practice and Theory in Public Key Cryptography, Darmstadt, Germany, May 21-23, 2012. Proceedings, pages 334–352, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AP14] Jacob Alperin-Sheriff and Chris Peikert. Faster bootstrapping with polynomial error. In Advances in Cryptology - CRYPTO 2014 - 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2014, Proceedings, Part I, pages 297–314, 2014.</li>

      <li>[ARS^{+}15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 430–454, 2015.</li>

      <li>[BC10] Christina Boura and Anne Canteaut. Zero-sum distinguishes for iterated permutations and application to keccak-f and hamsi-256. In Alex Biryukov, Guang Gong, and Douglas R. Stinson, editors, Selected Areas in Cryptography - 17th International Workshop, SAC 2010, Waterloo, Ontario, Canada, August 12-13, 2010, Revised Selected Papers, volume 6544 of Lecture Notes in Computer Science, pages 1–17. Springer, 2010.</li>

      <li>[BGV12] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In Innovations in Theoretical Computer Science 2012, Cambridge, MA, USA, January 8-10, 2012, pages 309–325, 2012.</li>

      <li>[BKW03] Avrim Blum, Adam Kalai, and Hal Wasserman. Noise-tolerant learning, the parity problem, and the statistical query model. J. ACM, 50(4):506–519, 2003.</li>

      <li>[BM84] Manuel Blum and Silvio Micali. How to generate cryptographically strong sequences of pseudo random bits. SIAM J. Comput., 13(4):850–864, 1984.</li>

      <li>[BV14] Zvika Brakerski and Vinod Vaikuntanathan. Lattice-based FHE as secure as PKE. In Innovations in Theoretical Computer Science, ITCS’14, Princeton, NJ, USA, January 12-14, 2014, pages 1–12, 2014.</li>

      <li>[BY01] Mihir Bellare and Bennet S. Yee. Forward-security in private-key cryptography. IACR Cryptology ePrint Archive, 2001:35, 2001.</li>

      <li>[Car10] Claude Carlet. Boolean Models and Methods in Mathematics, Computer Science, and Engineering, chapter Boolean Functions for Cryptography and Error Correcting Codes., pages 257–397,. 2010.</li>

      <li>[CCF^{+}15] Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancrède Lepoint, María Naya-Plasencia, Pascal Paillier, and Renaud Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext. IACR Cryptology ePrint Archive, 2015:113, 2015.</li>

      <li>[CLT14] Jean-Sébastien Coron, Tancrède Lepoint, and Mehdi Tibouchi. Scale-invariant fully homomorphic encryption over the integers. In Public-Key Cryptography - PKC 2014 - 17th International Conference on Practice and Theory in Public-Key Cryptography, Buenos Aires, Argentina, March 26-28, 2014. Proceedings, pages 311–328, 2014.</li>

      <li>[CM03] Nicolas Courtois and Willi Meier. Algebraic Attacks on Stream Ciphers with Linear Feedback. In Advances in Cryptology - EUROCRYPT 2003, International Conference on the Theory and Applications of Cryptographic Techniques, Warsaw, Poland, May 4-8, 2003, Proceedings, pages 345–359, 2003.</li>

      <li>[CN11] Yuanmi Chen and Phong Q. Nguyen. BKZ 2.0: Better lattice security estimates. In Advances in Cryptology - ASIACRYPT 2011 - 17th International Conference on the Theory and Application of Cryptology and Information Security, Seoul, South Korea, December 4-8, 2011. Proceedings, pages 1–20, 2011.</li>

      <li>[Cou02] Nicolas Courtois. Higher Order Correlation Attacks, XL Algorithm and Cryptanalysis of Toyocrypt. In Information Security and Cryptology - ICISC 2002, 5th International Conference Seoul, Korea, November 28-29, 2002, Revised Papers, pages 182–199, 2002.</li>

      <li>[Cou03] Nicolas Courtois. Fast Algebraic Attacks on Stream Ciphers with Linear Feedback. In Advances in Cryptology - CRYPTO 2003, 23rd Annual International Cryptology Conference, Santa Barbara, California, USA, August 17-21, 2003, Proceedings, pages 176–194, 2003.</li>

      <li>[CT15] Claude Carlet and Deng Tang. Enhanced Boolean functions suitable for the filter model of pseudo-random generator. Des. Codes Cryptography, 76(3):571–587, 2015.</li>

      <li>[DDLL13] Léo Ducas, Alain Durmus, Tancrède Lepoint, and Vadim Lyubashevsky. Lattice signatures and bimodal gaussians. In Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part I, pages 40–56, 2013.</li>

      <li>[DEM15] Christoph Dobraunig, Maria Eichlseder, and Florian Mendel. Higher-order cryptanalysis of lowmc. IACR Cryptology ePrint Archive, 2015:407, 2015.</li>

      <li>[DLMW15] Itai Dinur, Yunwen Liu, Willi Meier, and Qingju Wang. Optimized interpolation attacks on lowmc. IACR Cryptology ePrint Archive, 2015:418, 2015.</li>

    </ul>

    <p class="text-gray-300">[DLR16] Sébastien Duval, Virginie Lallemand, and Yann Rotella. Cryptanalysis of the FLIP family of stream ciphers. Cryptology ePrint Archive, Report 2016/???, 2016. http://eprint.iacr.org/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DM15] Léo Ducas and Daniele Micciancio. FHEW: bootstrapping homomorphic encryption in less than a second. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, pages 617–640, 2015.</li>

      <li>[DS09] Itai Dinur and Adi Shamir. Cube Attacks on Tweakable Black Box Polynomials. In Advances in Cryptology - EUROCRYPT 2009, 28th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cologne, Germany, April 26-30, 2009. Proceedings, pages 278–299, 2009.</li>

      <li>[DSES14] Yarkin Doröz, Aria Shahverdi, Thomas Eisenbarth, and Berk Sunar. Toward practical homomorphic evaluation of block ciphers using prince. In Financial Cryptography and Data Security - FC 2014 Workshops, BITCOIN and WAHC 2014, Christ Church, Barbados, March 7, 2014, Revised Selected Papers, pages 208–220, 2014.</li>

      <li>[Fau99] Jean-Charles Faugre. A new efficient algorithm for computing grbner bases (f4). Journal of Pure and Applied Algebra, 139(13):61 – 88, 1999.</li>

      <li>[FM07] Simon Fischer and Willi Meier. Algebraic immunity of s-boxes and augmented functions. In Fast Software Encryption, 14th International Workshop, FSE 2007, Luxembourg, Luxembourg, March 26-28, 2007, Revised Selected Papers, pages 366–381, 2007.</li>

      <li>[FV12] Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. IACR Cryptology ePrint Archive, 2012:144, 2012.</li>

      <li>[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. In Proceedings of the 41st Annual ACM Symposium on Theory of Computing, STOC 2009, Bethesda, MD, USA, May 31 - June 2, 2009, pages 169–178, 2009.</li>

      <li>[GGNS13] Benoît Gérard, Vincent Grosso, María Naya-Plasencia, and François-Xavier Standaert. Block ciphers that are easier to mask: How far can we go? In Cryptographic Hardware and Embedded Systems - CHES 2013 - 15th International Workshop, Santa Barbara, CA, USA, August 20-23, 2013. Proceedings, pages 383–399, 2013.</li>

      <li>[GHS12] Craig Gentry, Shai Halevi, and Nigel P. Smart. Homomorphic evaluation of the AES circuit. In Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2012. Proceedings, pages 850–867, 2012.</li>

      <li>[GLSV14] Vincent Grosso, Gaëtan Leurent, François-Xavier Standaert, and Kerem Varici. Ls-designs: Bitslice encryption for efficient masked software implementations. In Fast Software Encryption - 21st International Workshop, FSE 2014, London, UK, March 3-5, 2014. Revised Selected Papers, pages 18–37, 2014.</li>

      <li>[GN08] Nicolas Gama and Phong Q. Nguyen. Predicting Lattice Reduction. In Advances in Cryptology - EUROCRYPT 2008, 27th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Istanbul, Turkey, April 13-17, 2008. Proceedings, pages 31–51, 2008.</li>

      <li>[GSW13] Craig Gentry, Amit Sahai, and Brent Waters. Homomorphic Encryption from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster, Attribute-Based. In Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part I, pages 75–92, 2013.</li>

      <li>[HAO15] Ryo Hiromasa, Masayuki Abe, and Tatsuaki Okamoto. Packing Messages and Optimizing Bootstrapping in GSW-FHE. In Public-Key Cryptography - PKC 2015 - 18th IACR International Conference on Practice and Theory in Public-Key Cryptography, Gaithersburg, MD, USA, March 30 - April 1, 2015, Proceedings, pages 699–715, 2015.</li>

      <li>[HS14] Shai Halevi and Victor Shoup. Algorithms in helib. In Advances in Cryptology - CRYPTO 2014 - 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2014, Proceedings, Part I, pages 554–571, 2014.</li>

      <li>[KGV14] Alhassan Khedr, P. Glenn Gulak, and Vinod Vaikuntanathan. SHIELD: scalable homomorphic implementation of encrypted data-classifiers. IACR Cryptology ePrint Archive, 2014:838, 2014.</li>

      <li>[KL07] Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography. Chapman and Hall/CRC Press, 2007.</li>

      <li>[KMN10] Simon Knellwolf, Willi Meier, and María Naya-Plasencia. Conditional differential cryptanalysis of nlfsr-based cryptosystems. In Masayuki Abe, editor, Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings, volume 6477 of Lecture Notes in Computer Science, pages 130–145. Springer, 2010.</li>

      <li>[Knu69] Donald E. Knuth. The Art of Computer Programming, Volume II: Seminumerical Algorithms. Addison-Wesley, 1969.</li>

      <li>[KW02] Lars R. Knudsen and David Wagner. Integral cryptanalysis. In Joan Daemen and Vincent Rijmen, editors, Fast Software Encryption, 9th International Workshop, FSE 2002, Leuven, Belgium, February 4-6, 2002, Revised Papers, volume 2365 of Lecture Notes in Computer Science, pages 112–127. Springer, 2002.</li>

      <li>[LF06] Éric Levieil and Pierre-Alain Fouque. An Improved LPN Algorithm. In Security and Cryptography for Networks, 5th International Conference, SCN 2006, Maiori, Italy, September 6-8, 2006, Proceedings, pages 348–359, 2006.</li>

    </ul>

    <p class="text-gray-300">[LN14] Tancrède Lepoint and Michael Naehrig. A comparison of the homomorphic encryption schemes FV and YASHE. In Progress in Cryptology - AFRICACRYPT 2014 - 7th International Conference on Cryptology in Africa, Marrakesh, Morocco, May 28-30, 2014. Proceedings, pages 318–335, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LP11] Richard Lindner and Chris Peikert. Better Key Sizes (and Attacks) for LWE-Based Encryption. In Topics in Cryptology - CT-RSA 2011 - The Cryptographers’ Track at the RSA Conference 2011, San Francisco, CA, USA, February 14-18, 2011. Proceedings, pages 319–339, 2011.</li>

      <li>[LPR10] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. On Ideal Lattices and Learning with Errors over Rings. In Advances in Cryptology - EUROCRYPT 2010, 29th Annual International Conference on the Theory and Applications of Cryptographic Techniques, French Riviera, May 30 - June 3, 2010. Proceedings, pages 1–23, 2010.</li>

      <li>[LR88] Michael Luby and Charles Rackoff. How to Construct Pseudorandom Permutations from Pseudorandom Functions. SIAM J. Comput., 17(2):373–386, 1988.</li>

      <li>[LRW11] Moses Liskov, Ronald L. Rivest, and David Wagner. Tweakable block ciphers. J. Cryptology, 24(3):588–613, 2011.</li>

      <li>[Mei11] Willi Meier. Fast Correlation Attacks: Methods and Countermeasures. In Fast Software Encryption - 18th International Workshop, FSE 2011, Lyngby, Denmark, February 13-16, 2011, Revised Selected Papers, pages 55–67, 2011.</li>

      <li>[MP12] Daniele Micciancio and Chris Peikert. Trapdoors for lattices: Simpler, tighter, faster, smaller. In Advances in Cryptology - EUROCRYPT 2012 - 31st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cambridge, UK, April 15-19, 2012. Proceedings, pages 700–718, 2012.</li>

      <li>[MR09] Daniele Micciancio and Oded Regev. Lattice-based cryptography. Springer, 2009.</li>

      <li>[MS88] Willi Meier and Othmar Staffelbach. Fast Correlation Attacks on Stream Ciphers (Extended Abstract). In Advances in Cryptology - EUROCRYPT ’88, Workshop on the Theory and Application of of Cryptographic Techniques, Davos, Switzerland, May 25-27, 1988, Proceedings, pages 301–314, 1988.</li>

      <li>[NLV11] Michael Naehrig, Kristin E. Lauter, and Vinod Vaikuntanathan. Can homomorphic encryption be practical? In Proceedings of the 3rd ACM Cloud Computing Security Workshop, CCSW 2011, Chicago, IL, USA, October 21, 2011, pages 113–124, 2011.</li>

      <li>[PRC12] Gilles Piret, Thomas Roche, and Claude Carlet. PICARO - A block cipher allowing efficient higher-order side-channel resistance. In Applied Cryptography and Network Security - 10th International Conference, ACNS 2012, Singapore, June 26-29, 2012. Proceedings, pages 311–328, 2012.</li>

      <li>[Reg05] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. In Proceedings of the 37th Annual ACM Symposium on Theory of Computing, Baltimore, MD, USA, May 22-24, 2005, pages 84–93, 2005.</li>

      <li>[RS10] Markus Rückert and Michael Schneider. Estimating the security of lattice-based cryptosystems. IACR Cryptology ePrint Archive, 2010:137, 2010.</li>

      <li>[SE94] Claus-Peter Schnorr and M. Euchner. Lattice basis reduction: Improved practical algorithms and solving subset sum problems. Math. Program., 66:181–199, 1994.</li>

      <li>[Sie85] Thomas Siegenthaler. Decrypting a Class of Stream Ciphers Using Ciphertext Only. IEEE Trans. Computers, 34(1):81–85, 1985.</li>

      <li>[SPY13] François-Xavier Standaert, Olivier Pereira, and Yu Yu. Leakage-resilient symmetric cryptography under empirically verifiable assumptions. In Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part I, pages 335–352, 2013.</li>

      <li>[Ver10] Roman Vershynin. Introduction to the non-asymptotic analysis of random matrices. CoRR, abs/1011.3027, 2010.</li>

      <li>[Wie86] Douglas H. Wiedemann. Solving sparse linear equations over finite fields. IEEE Transactions on Information Theory, 32(1):54–62, 1986.</li>

    </ul>

    <h2 id="sec-64" class="text-2xl font-bold">Appendix A Correctness and security of Batch GSW</h2>

    <h6 id="sec-65" class="text-base font-medium mt-4">Lemma 14 (Correctness of Batch GSW scheme ).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every <span class="math">({\\sf pk}^{H},{\\sf sk}^{H})\\leftarrow H.\\textsf{KeyGen}(n,q,r,\\chi),{\\bf m}\\in\\{0,1\\}^{r}</span> and <span class="math">{\\bf C}\\leftarrow H.\\textsf{Enc}({\\sf pk}^{H},{\\bf m})</span> (respectively <span class="math">{\\bf C}_{f}\\leftarrow H.\\textsf{Eval}(f,{\\bf C}_{1},\\cdots,{\\bf C}_{k},{\\sf pk}^{H})</span> such that for all $i\\in[r],</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\bf s}_{i}^{\\top}{\\bf c}_{i\\ell}-m_{i}2^{\\ell-1}\\mod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><2^{\\ell-2}<span class="math"> (where </span>x\\mod q\\in[-q/2+1,q/2]<span class="math">) we have </span>{\\bf m}=H.\\textsf{Dec}({\\bf C},{\\sf sk}^{H})<span class="math"> (respectively </span>f({\\bf m}_{1},\\cdots,{\\bf m}_{k})\\mod 2=H.\\textsf{Dec}({\\bf C}_{f},{\\sf sk}^{H})$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. With the expression of <span class="math">\\mathbf{SC}</span> for all <span class="math">i\\in[r]</span>, <span class="math">\\mathbf{s}_i^\\top \\mathbf{c}_{i\\ell}</span> can be written as <span class="math">(\\mathbf{SC})_{i,i\\ell} = e_{i,i\\ell}&#x27; + 2^{\\ell -1}m_i \\mod q</span>. Then if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{i,i\\ell}' \\mod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2^{\\ell -2}<span class="math">, the rounding in the decryption algorithm outputs </span>m_i<span class="math">. If the inequality is correct for all </span>i\\in[r]<span class="math">, </span>\\mathbf{m} = H.\\mathrm{Dec}(\\mathbf{C},\\mathsf{sk}^H)<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that a sufficient condition for correctness is to ensure: $\\forall (i,j)\\in [r]\\times [N],</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{i,j}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2^{\\ell -2};$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-66" class="text-2xl font-bold">Lemma 15 (Security of Batch GSW scheme)</h2>

    <p class="text-gray-300">Let <span class="math">\\mathbf{B},\\mathbf{R}_m,\\mathbf{R}</span> be generated in <span class="math">H.\\mathrm{KeyGen}</span> and <span class="math">H.\\mathrm{Enc}</span>. Then the joint distribution <span class="math">(\\mathbf{B},\\mathbf{BR}_m,\\mathbf{BR})</span> is computationally indistinguishable from uniform over <span class="math">\\mathbf{Z}_q^{(n + r)\\times m} \\times \\mathbf{Z}_q^{(n + r)\\times N} \\times \\mathbf{Z}_q^{(n + r)\\times N}</span>.</p>

    <p class="text-gray-300">Proof. <span class="math">\\mathbf{B}</span> is indistinguishable from uniform over <span class="math">\\mathbf{Z}_q^{(n + r)\\times m}</span> using the <span class="math">\\mathrm{dLWE}_{q,n,m,\\chi}</span> assumption <span class="math">r</span> times. Then we can apply the leftover hash lemma on <span class="math">(\\mathbf{B},\\mathbf{BR}_m)</span> and <span class="math">(\\mathbf{B},\\mathbf{BR})</span> which concludes the proof. <span class="math">\\square</span></p>

    <h2 id="sec-67" class="text-2xl font-bold">B Correctness and security of Ring-GSW</h2>

    <h2 id="sec-68" class="text-2xl font-bold">Lemma 16 (Correctness of Ring-GSW scheme)</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every <span class="math">(\\mathsf{pk}^H,\\mathsf{sk}^H)\\gets H.\\mathrm{KeyGen}(n,q,\\chi ,\\mathcal{M})</span>, <span class="math">m\\in \\mathcal{M}</span> and <span class="math">\\mathbf{C}\\gets H.\\mathrm{Enc}(\\mathsf{pk}^H,m)</span> (respectively <span class="math">\\mathbf{C}_f\\gets H.\\mathrm{Eval}(f,\\mathbf{C}_1,\\dots ,\\mathbf{C}_k,\\mathsf{pk}^H)</span>) such that all the coefficients of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}^{\\top}\\mathbf{c}_{\\ell} - m2^{\\ell -1}\\mod q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are inferiors to </span>2^{\\ell -2}<span class="math"> then we have </span>m = H.\\mathrm{Dec}(\\mathbf{C},\\mathsf{sk}^H)<span class="math"> (respectively </span>f(m_{1},\\dots ,m_{k})\\mod 2 = H.\\mathrm{Dec}(\\mathbf{C}_{f},\\mathsf{sk}^{H})$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof follows directly the one of lemma 14 for each coefficient of the polynomial.</p>

    <h2 id="sec-69" class="text-2xl font-bold">Lemma 17 (Security of Ring-GSW scheme)</h2>

    <p class="text-gray-300">Let <span class="math">\\mathsf{pk}^H \\gets H.\\mathrm{KeyGen}</span> and <span class="math">\\mathbf{C} \\gets H.\\mathrm{Enc}(\\mathsf{pk}^H, m)</span>. Then the joint distribution <span class="math">(\\mathbf{b}, \\mathbf{C})</span> is computationally indistinguishable from uniform over <span class="math">R_q^{2 \\times 1} \\times R_q^{2 \\times N}</span>.</p>

    <p class="text-gray-300">Proof. <span class="math">\\mathbf{b}</span> is computationally indistinguishable from uniform over <span class="math">R_q^2</span> using the <span class="math">\\mathrm{dRLWE}_{R,q,\\chi}</span> assumption. Applying the <span class="math">\\mathrm{dRLWE}_{R,q,\\chi}</span> assumption with a secret from <span class="math">R_{0,1}</span> on <span class="math">(\\mathbf{b},\\mathbf{r},\\mathbf{E})</span>, <span class="math">(\\mathbf{b},\\mathbf{C})</span> is indistinguishable from uniform over <span class="math">R_q^{2\\times 1}\\times R_q^{2\\times N}</span> which concludes the proof.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <h2 id="sec-70" class="text-2xl font-bold">C Proofs</h2>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">C.1 Proof of Lemma 3</h3>

    <p class="text-gray-300">1,2. see [Car10] page 125.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the first part of the inequality:</li>

    </ol>

    <p class="text-gray-300">For <span class="math">i \\in \\{1,2\\}</span>, let <span class="math">h_i</span> be an annihilator of <span class="math">f_i</span> or <span class="math">1 \\oplus f_i</span> of degree <span class="math">\\mathsf{Al}(f_i)</span>. Then <span class="math">h_1 \\cdot h_2 \\cdot f = 0</span> or <span class="math">h_1 \\cdot h_2 \\cdot (1 \\oplus f) = 0</span>.</p>

    <p class="text-gray-300">Finally <span class="math">\\deg (h_1h_2) = \\mathsf{Al}(f_1) + \\mathsf{Al}(f_2)</span>, so <span class="math">\\mathsf{Al}(f) \\leq \\mathsf{Al}(f_1) + \\mathsf{Al}(f_2)</span>.</p>

    <p class="text-gray-300">We prove the second part of the inequality by contradiction:</p>

    <p class="text-gray-300">Consider that <span class="math">\\mathsf{Al}(f) &amp;lt; \\max (\\mathsf{Al}(f_1),\\mathsf{Al}(f_2))</span>. Without loss of generality we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\max  \\left\\{\\mathrm {A l} \\left(f _ {1}\\right), \\mathrm {A l} \\left(f _ {2}\\right) \\right\\} = \\mathrm {A l} \\left(f _ {2}\\right) \\text { and } \\mathrm {A l} (f) &amp;lt;   \\mathrm {A l} \\left(f _ {2}\\right).</span></div>

    <p class="text-gray-300">Then <span class="math">\\exists h</span> such that <span class="math">fh = 0</span> or <span class="math">(1 \\oplus f)h = 0</span> with <span class="math">\\deg(h) = \\mathsf{Al}(f)</span>.</p>

    <p class="text-gray-300">Hence we have two possibilities. Either we have:</p>

    <div class="my-4 text-center"><span class="math-block">f (0, \\dots , 0, x _ {n _ {1}}, \\dots , x _ {n _ {1} + n _ {2} - 1}) h (0, \\dots , 0, x _ {n _ {1}}, \\dots , x _ {n _ {1} + n _ {2} - 1}) = 0 \\Rightarrow f _ {2} h = 0,</span></div>

    <p class="text-gray-300">that is <span class="math">h</span> is an annihilator of <span class="math">f_{2}</span> of degree <span class="math">&amp;lt; \\mathsf{AI}(f_2)</span>: there is a contradiction,</p>

    <p class="text-gray-300">or we have:</p>

    <div class="my-4 text-center"><span class="math-block">(f (0, \\dots , 0, x _ {n _ {1}}, \\dots , x _ {n _ {1} + n _ {2} - 1}) \\oplus 1) h (0, \\dots , 0, x _ {n _ {1}}, \\dots , x _ {n _ {1} + n _ {2} - 1}) = 0 \\Rightarrow (f _ {2} \\oplus 1) h = 0,</span></div>

    <p class="text-gray-300">that is <span class="math">h</span> annihilator of <span class="math">1 \\oplus f_{2}</span> of degree <span class="math">&amp;lt; \\mathsf{AI}(f_2)</span>: there is a contradiction.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Analog to 3.</li>

    </ol>

    <h2 id="sec-72" class="text-2xl font-bold">C.2 Proof of Lemma 6</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The proof is by induction. <span class="math">T_{1}</span> is a linear function so <span class="math">\\mathsf{NL}(T_1) = 0</span>. Then using Lemma 3.1, <span class="math">\\forall k\\in \\mathbb{N}^{*},T_{k + 1} = T_{k}\\oplus \\varPi_{k + 1}</span> (where <span class="math">\\varPi_{k + 1}</span> is the monomial of degree <span class="math">k + 1</span> in the <span class="math">k + 1</span> last variables). We have the following implications:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Rightarrow \\mathrm {N L} (T _ {k + 1}) = \\mathrm {N L} (T _ {k} \\oplus \\Pi_ {k + 1}), \\\\ \\Rightarrow \\mathrm {N L} (T _ {k + 1}) = 2 ^ {k + 1} \\mathrm {N L} (T _ {k}) + 2 ^ {k (k + 1) / 2} \\mathrm {N L} (\\Pi_ {k + 1}) - 2 \\mathrm {N L} (T _ {k}) \\mathrm {N L} (\\Pi_ {k + 1}), \\\\ \\Rightarrow \\mathrm {N L} (T _ {k + 1}) = (2 ^ {k + 1} - 2) \\mathrm {N L} (T _ {k}) + 2 ^ {k (k + 1) / 2} \\text { as } \\mathrm {N L} (\\Pi_ {n}) = 1, \\forall n \\geq 2. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By induction suppose that for <span class="math">k \\geq 1</span>, <span class="math">\\operatorname{res}(T_k) = 0</span>. The function <span class="math">T_1</span> has one variable and therefore its resiliency is 0. By construction, for <span class="math">\\ell \\geq 1</span>, <span class="math">T_{\\ell + 1}</span> is the direct sum of <span class="math">T_\\ell</span> and a monomial of degree <span class="math">\\ell + 1</span>. This monomial has a resiliency of <span class="math">-1</span>. By Lemma 3.2, <span class="math">\\operatorname{res}(T_{\\ell + 1}) = 1 + \\operatorname{res}(T_\\ell) + \\operatorname{res}(\\Pi_{\\ell + 1}) = 0</span>. In conclusion for all <span class="math">k \\in \\mathbb{N}^*</span> we have <span class="math">\\operatorname{res}(T_k) = 0</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By induction on <span class="math">k</span> we prove that for all <span class="math">k \\in \\mathbb{N}^*</span>, <span class="math">\\operatorname{Al}(T_k) = k</span>.</li>

    </ol>

    <p class="text-gray-300">For <span class="math">k = 1</span> we have <span class="math">T_{1} = x_{0}</span> of algebraic immunity <span class="math">\\mathsf{Al}(x_0) \\geq 1</span> by definition. Hence <span class="math">1 \\oplus x_{0}</span> is a degree 1 annihilator of <span class="math">x_{0}</span> and we have <span class="math">\\mathsf{Al}(T_1) = 1</span>.</p>

    <p class="text-gray-300">For <span class="math">k = \\ell</span>, by the induction hypothesis we have that <span class="math">\\mathsf{Al}(T_{\\ell}) = \\ell</span>. We want now to determine <span class="math">\\mathsf{Al}(T_{\\ell + 1})</span> where <span class="math">T_{\\ell + 1} = T_{\\ell} \\oplus \\Pi_{\\ell + 1}</span> with <span class="math">\\Pi_{\\ell + 1}</span> the product of the <span class="math">\\ell + 1</span> variables which are not in <span class="math">T_{\\ell}</span>. <span class="math">\\Pi_{\\ell + 1}</span> is a monomial of degree <span class="math">\\ell + 1</span>, therefore its <span class="math">\\mathsf{Al}</span> is 1. By Lemma 3 we have that <span class="math">\\ell + 1 \\geq \\mathsf{Al}(T_{\\ell + 1}) \\geq \\ell</span>.</p>

    <p class="text-gray-300">We prove the induction hypothesis by contradiction: suppose that <span class="math">\\mathsf{Al}(T_{\\ell +1}) = \\ell</span>, then <span class="math">\\exists h</span> such that <span class="math">\\deg (h) = \\ell</span> and <span class="math">h\\cdot T_{\\ell +1} = 0</span> or <span class="math">h\\cdot (1\\oplus T_{\\ell +1}) = 0</span>. Hence we have two different cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">h \\cdot T_{\\ell + 1} = 0</span>. Let decompose <span class="math">h</span> as <span class="math">h_T \\oplus h_{\\Pi} \\oplus h_{mix}</span>, a decomposition of monomials of variables taken respectively from <span class="math">T_\\ell</span>, <span class="math">\\Pi_{\\ell + 1}</span> and the mixed part between the two.</li>

    </ul>

    <p class="text-gray-300">Restricting the equation <span class="math">h \\cdot T_{\\ell + 1} = 0</span> to the variables from <span class="math">T_{\\ell}</span> we obtain <span class="math">h_T \\cdot T_{\\ell} = 0</span>. So by induction hypothesis we have <span class="math">\\deg(h_T) = \\ell</span> or <span class="math">h_T = 0</span>. Again two cases are possible:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\deg(h_T) = \\ell</span>. Then <span class="math">h \\cdot T_{\\ell+1} = 0 \\Leftrightarrow (h_T \\oplus h_{\\Pi} \\oplus h_{mix}) \\cdot T_{\\ell+1} = h_T \\cdot \\Pi_{\\ell+1} \\oplus h_{\\Pi} \\cdot T_{\\ell} \\oplus h_{mix} \\cdot T_{\\ell} \\oplus h_{mix} \\cdot \\Pi_{\\ell+1} = 0</span>. The first polynomial <span class="math">h_T \\cdot \\Pi_{\\ell+1}</span> contains at least one monomial of degree <span class="math">2\\ell + 1</span> divisible by <span class="math">\\Pi_{\\ell+1}</span>. The degrees of the second and third polynomials are at most <span class="math">2\\ell \\geq \\deg(h) + \\deg(T_\\ell)</span>. By construction all the monomials of <span class="math">h_{mix}</span> have at most <span class="math">\\ell - 1</span> variables from <span class="math">T_\\ell</span> then <span class="math">h_{mix} \\cdot \\Pi_{\\ell+1}</span> has no monomial of degree <span class="math">2\\ell + 1</span> and the equation is leading to a contradiction.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">h_T = 0</span>. Then <span class="math">h \\cdot T_{\\ell + 1} = 0 \\Leftrightarrow (0 \\oplus h_{\\Pi} \\oplus h_{mix}) \\cdot T_{\\ell + 1} = h_{\\Pi} \\cdot T_{\\ell} \\oplus h_{mix} \\cdot T_{\\ell} + h_{mix} \\cdot \\Pi_{\\ell + 1} = 0</span>. Only the last polynomial contains monomials with all variables of <span class="math">\\Pi_{\\ell + 1}</span>, then the equation is false or <span class="math">h = 0</span>, both leading to a contradiction.</li>

    </ul>

    <p class="text-gray-300">30</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">h\\cdot(1\\oplus T_{\\ell+1})=0</span>. We use the same decomposition technique leading to a contradiction.</li>

    </ul>

    <p class="text-gray-300">To sum up, <span class="math">\\mathsf{AI}(T_{\\ell+1})=\\ell+1</span>, so from the initialization step <span class="math">k=1</span> and the induction step <span class="math">k=\\ell</span> we conclude that <span class="math">\\forall k\\in\\mathbb{N}^{*}</span>, <span class="math">\\mathsf{AI}(T_{k})=k</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By contradiction, let consider that <span class="math">\\mathsf{FAI}(T_{k})&lt;k+1</span>.</li>

    </ol>

    <p class="text-gray-300">By definition we have:</p>

    <p class="text-gray-300"><span class="math">\\min\\{2AI(T_{k}),\\max\\{\\deg(g\\cdot T_{k})+\\deg(g),3\\deg(g)\\}\\mid 1\\leq\\deg(g)&lt;\\mathsf{AI}(T_{k})\\}&lt;k+1.</span></p>

    <p class="text-gray-300">And by Lemma 6 we have:</p>

    <p class="text-gray-300"><span class="math">\\min\\{2k,\\max\\{\\deg(g\\cdot T_{k})+\\deg(g),3\\deg(g)\\}\\mid 1\\leq\\deg(g)&lt;k)\\}&lt;k+1.</span></p>

    <p class="text-gray-300">Hence it implies that:</p>

    <p class="text-gray-300"><span class="math">\\exists g\\mid\\deg(g\\cdot T_{k})+\\deg(g)&lt;k+1\\quad\\text{and}\\quad 3\\cdot\\deg(g)&lt;k+1.</span></p>

    <p class="text-gray-300">We have that <span class="math">T_{k}\\oplus 1</span> is an annihilator of <span class="math">g\\cdot T_{k}</span>. Then <span class="math">T_{k}(g\\cdot T_{k}\\oplus g)=0</span> implies that <span class="math">g\\cdot T_{k}\\oplus g=0</span> or <span class="math">\\deg(g\\cdot T_{k}\\oplus g)\\geq k</span>.</p>

    <p class="text-gray-300">If <span class="math">g\\cdot T_{k}\\oplus g=0</span> , we have either <span class="math">g=0</span> or <span class="math">\\deg(g)\\geq k</span>, which is a contradiction.</p>

    <p class="text-gray-300">If <span class="math">\\deg(gT_{k}\\oplus g)\\geq k</span> then we get <span class="math">\\deg(g)\\geq k</span> or <span class="math">\\deg(gT_{k})\\geq k</span>. The first inequation leads to a contradiction.</p>

    <p class="text-gray-300">The second inequation leads to <span class="math">\\deg(g\\cdot T_{k})+\\deg(g)\\geq k+1</span> which is a contradiction.</p>

    <p class="text-gray-300">To sum up, <span class="math">\\mathsf{FAI}(T_{k})\\geq k+1</span> and taking <span class="math">g=1\\oplus x_{k(k+1)/2-1}</span>, we have that <span class="math">\\deg(g\\cdot T_{k})+\\deg(g)=k+1</span> and therefore <span class="math">\\mathsf{FAI}(T_{k})=k+1</span>.</p>

    <h2 id="sec-73" class="text-2xl font-bold">Appendix D Details on BKW-like attack</h2>

    <p class="text-gray-300">Decomposing <span class="math">F</span> in a linear and non-linear part, we can study our filtering function by analogy with LPN and therefore consider the impact of BKW <em>[x1]</em> on our construction. Let <span class="math">\\mathbf{s}\\leftarrow_{\\S}\\{0,1\\}^{N}</span>. A LPN sample is a couple <span class="math">(\\mathbf{a},\\langle\\mathbf{a},\\mathbf{s}\\rangle+\\nu)</span> such that <span class="math">\\mathbf{a}\\leftarrow_{\\S}\\{0,1\\}^{N}</span> and <span class="math">\\nu\\leftarrow_{\\S}</span> Bernoulli(<span class="math">\\varepsilon</span>) . At each cycle of the filter permutator, the permutation on the linear part of <span class="math">F</span> of <span class="math">\\ell</span> bits is analogous to the random choice of <span class="math">\\mathbf{a}</span>, with the restriction that its hamming weight is fixed to <span class="math">\\ell</span>. Then the non-linear part of <span class="math">F</span> can be considered as the <span class="math">\\nu</span> part of a LPN sample, such that the output bit follows a Bernoulli distribution with parameter <span class="math">\\varepsilon=\\frac{\\mathsf{NL}(F)}{2^{N}}</span>. As in our case the <span class="math">\\mathbf{a}</span> distribution is restricted and the output bits are produced from dependent distributions, we cannot formally reduce the filter permutator key recovery to the search-LPN problem. Nevertheless, we can evaluate the computational cost of a strategy similar to the BKW algorithm to recover the key, based on the LF1 algorithm complexity <em>[x21]</em>.</p>

    <p class="text-gray-300">Namely, writing <span class="math">N</span> as <span class="math">a*b</span>, the main point of the attack is to find a lot of groups of <span class="math">2^{a}</span> well-chosen vectors such that <span class="math">\\mathbf{a}_{1}\\oplus\\cdots\\oplus\\mathbf{a}_{2^{a}}=\\mathbf{e}_{j}</span>. With <span class="math">2^{a}</span> a small number, the bias introduced by XORing <span class="math">2^{a}</span> LPN samples is not too small, enabling to recover <span class="math">\\mathbf{s}_{j}</span> from a majority vote over the different groups of <span class="math">2^{a}</span> vectors, since <span class="math">\\langle\\mathbf{s},\\mathbf{a}_{1}\\oplus\\cdots\\oplus\\mathbf{a}_{2^{a}}\\rangle=\\langle\\mathbf{s},\\mathbf{e}_{j}\\rangle=\\mathbf{s}_{j}</span>. For our construction, the case <span class="math">a=1</span> is impossible: as the Hamming weight of each <span class="math">\\mathbf{a}_{i}</span> is the same, no difference can give a vector of Hamming weight <span class="math">1</span>. Therefore, at least two XORs are needed to obtain a new vector with Hamming weight <span class="math">1</span>. Let <span class="math">\\delta=0.5-\\varepsilon</span> be the bias of the original vectors. This implies that the bias of such new vectors is <span class="math">\\delta^{3}</span>. To distinguish this bias and to recover <span class="math">\\mathbf{s}_{j}</span>, we therefore need <span class="math">\\mathcal{O}(\\delta^{-6})</span> operations. Such an attack can be extended by finding vectors such that the sum is</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_{i}\\oplus\\mathbf{e}_{j}</span>, which leads to perform at least one XOR to obtain a targeted vector if <span class="math">\\ell&gt;2</span>. The computational cost of recovering one sum is then <span class="math">\\mathcal{O}(\\delta^{-4})</span>. It leads to a complexity <span class="math">\\mathcal{O}(N\\delta^{-4})</span> to recover all the key. For the case where <span class="math">\\ell=2</span>, there is no need to perform XORs: the <span class="math">\\mathbf{a}_{i}</span>’s are already of Hamming weight <span class="math">2</span> and the corresponding attacks are therefore the correlation attack described in Section 3.4. But we can extend this attack considering vectors of Hamming weight <span class="math">h\\leq\\ell</span>, and number of XORs <span class="math">x</span>, leading to a (conservative) complexity of <span class="math">\\mathcal{O}(2^{h}\\delta^{-2(x+1)})</span>.</p>

    <h2 id="sec-74" class="text-2xl font-bold">Appendix E Guess And Determine Proofs</h2>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof of lemma 7.</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We prove this property by induction on <span class="math">\\ell</span>.</li>

    </ol>

    <p class="text-gray-300">For <span class="math">\\ell=0</span> : without guessing <span class="math">F[0]=F</span> therefore <span class="math">\\sum_{i=1}^{\\deg(F[\\ell])}m_{i}[\\ell]=\\sum_{i=1}^{\\deg(F)}m_{i}</span> and the property is true.</p>

    <p class="text-gray-300">From <span class="math">j</span> to <span class="math">j+1</span> : After guessing <span class="math">j</span> variables we obtain <span class="math">F[j]</span> satisfying the induction property. Without loss of generality, let consider that we guess an extra variable <span class="math">x_{d}</span> contributing in a monomial of degree <span class="math">d</span>. We have then two distinct cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case <span class="math">x_{d}=0</span>. The monomial of degree <span class="math">d</span> containing <span class="math">x_{d}</span> is cancelled therefore <span class="math">\\mathbf{m}_{F[j+1]}</span> the resulting vector is such that <span class="math">m_{d}[j+1]=m_{d}[j]-1</span> and <span class="math">\\forall i\\neq d;m_{i}[j+1]=m_{i}[j]</span> for all the coefficients correctly defined (by definition <span class="math">m_{i}</span> is defined if <span class="math">\\exists k\\geq i</span> such that <span class="math">m_{k}&gt;0</span>, i.e. <span class="math">\\mathbf{m}_{F[j+1]}</span> can be shorter than <span class="math">\\mathbf{m}_{F[j]}</span>). Then <span class="math">\\sum_{i=1}^{\\deg(F[j+1])}m_{i}[j+1]=(\\sum_{i=1}^{\\deg(F[j])}m_{i}[j])-1\\geq(\\sum_{i=1}^{\\deg(F)}m_{i})-(j+1)\\geq(\\sum_{i=1}^{\\deg(F)}m_{i})-\\ell</span> ; the property is verified.</li>

      <li>Case <span class="math">x_{d}=1</span>. The monomial of degree <span class="math">d</span> containing <span class="math">x_{d}</span> is turned into a degree <span class="math">d-1</span> monomial therefore <span class="math">\\mathbf{m}_{F[j+1]}</span> the resulting vector is such that <span class="math">m_{d}[j+1]=m_{d}[j]-1</span>, <span class="math">m_{d-1}[j+1]=m_{d-1}[j]+1</span> and <span class="math">\\forall i\\neq d</span> or <span class="math">d-1;m_{i}[j+1]=m_{i}[j]</span> for all the coefficients correctly defined (by definition <span class="math">m_{i}</span> is defined if <span class="math">i&gt;0</span>, i.e. <span class="math">d=1</span> is the only case diminishing the sum). Then <span class="math">\\sum_{i=1}^{\\deg(F[j+1])}m_{i}[j+1]\\geq(\\sum_{i=1}^{\\deg(F[j])}m_{i}[j])-1\\geq(\\sum_{i=1}^{\\deg(F)}m_{i})-(j+1)\\geq(\\sum_{i=1}^{\\deg(F)}m_{i})-\\ell</span> ; the property is verified.</li>

    </ul>

    <p class="text-gray-300">In conclusion the property is true for all <span class="math">0\\leq\\ell\\leq N</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The precedent property on <span class="math">\\mathbf{m}_{F}</span> stands that at most one <span class="math">m_{i}</span> is diminished by each guessing therefore :</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{m}_{F[\\ell]}^{<em>}\\geq\\mathbf{m}_{F}^{</em>}-\\max_{\\pi\\in S_{\\deg(F)}}\\{j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\sum_{k=1}^{j}m_{\\pi(k)})\\leq\\ell\\}<span class="math"> with </span>S_{\\deg(F)}<span class="math"> the group of permutation of </span>\\deg(F)$ elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This maximum corresponds to the maximal number of <span class="math">m_{i}</span>’s that can be cancelled with <span class="math">\\ell</span> guesses. We can bound it by: $\\max_{\\pi\\in S_{\\deg(F)}}\\{j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\sum_{k=1}^{j}m_{\\pi(k)})\\leq\\ell\\}\\leq\\lfloor\\frac{\\ell}{\\min_{1\\leq i\\leq\\deg(F)}m_{i}}\\rfloor$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Using this bound corresponding to the worst case (all <span class="math">m_{i}</span>’s being minimal) we get:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{m}_{F[\\ell]}^{<em>}\\geq\\mathbf{m}_{F}^{</em>}-\\lfloor\\frac{\\ell}{\\min_{1\\leq i\\leq\\deg(F)}m_{i}}\\rfloor.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First we study the parameter <span class="math">\\delta_{\\mathbf{m}_{F}}</span> on similar functions. We focus on <span class="math">\\delta_{\\mathbf{m}_{F}}</span> and <span class="math">\\delta_{\\mathbf{m}_{G}}</span> where <span class="math">F</span> is the direct sum of <span class="math">G</span> (of <span class="math">N-d</span> variables) and a monomial of degree <span class="math">d&gt;1</span>.</li>

    </ol>

    <p class="text-gray-300">By the property of nonlinearity of direct sums we have <span class="math">\\mathsf{NL}(F)=(2^{d}-2)\\mathsf{NL}(G)+2^{N-d}</span>, then</p>

    <p class="text-gray-300"><span class="math">\\mathsf{NL}(G)=\\frac{\\mathsf{NL}(F)-2^{N-d}}{2^{d}-2}.</span></p>

    <p class="text-gray-300">Therefore <span class="math">\\delta_{\\mathbf{m}_{G}}=\\frac{1}{2}-\\frac{\\mathsf{NL}(G)}{2^{N-d}}=\\frac{(2^{d-1}-1)2^{N-d}-\\mathsf{NL}(F)+2^{N-d}}{(2^{d-1}-1)2^{N-d+1}}=\\frac{2^{N-1}-\\mathsf{NL}(F)}{2^{N}}\\frac{2^{d-1}}{2^{d-1}-1}</span>, meaning that</p>

    <p class="text-gray-300"><span class="math">\\delta_{\\mathbf{m}_{G}}=\\delta_{\\mathbf{m}_{F}}\\frac{2^{d-1}}{2^{d-1}-1}.</span></p>

    <p class="text-gray-300">The last case to consider is when <span class="math">d=1</span>, then <span class="math">\\mathsf{NL}(F)=2\\mathsf{NL}(G)</span> by the property of nonlinearity of direct sums and therefore <span class="math">\\delta_{\\mathbf{m}_{F}}=\\delta_{\\mathbf{m}_{G}}</span>.</p>

    <p class="text-gray-300">Then, using the property on <span class="math">\\mathbf{m}_{F}</span> and that <span class="math">\\frac{2^{d-1}}{2^{d-1}-1}</span> decreases when <span class="math">d</span> increases we obtain the bound <span class="math">\\delta_{\\mathbf{m}_{F[\\ell]}}\\leq\\delta_{\\mathbf{m}_{F}}\\Pi_{i=2}^{\\deg(F)}(\\frac{2^{i-1}}{2^{i-1}-1})^{\\ell_{i}}</span> such that <span class="math">\\forall i,\\ell_{i}\\leq m_{i}</span> and <span class="math">\\sum_{i=1}^{\\deg(F)}\\ell_{i}=\\ell</span>.</p>

    <p class="text-gray-300">This bound corresponds to the case when all variables are fixed to <span class="math">0</span>, otherwise fixing a variable to <span class="math">1</span> is equivalent to cancel a monomial and add a new one (except if <span class="math">d=1</span> which does not add a new one).</p>

    <p class="text-gray-300">Optimizing the choices for the <span class="math">\\ell_{i}</span> we can give a tight upper bound on the product ; let denote <span class="math">j</span> the integer such that <span class="math">\\sum_{2\\leq i&lt;j}m_{i}\\leq\\ell&lt;\\sum_{2\\leq i\\leq j}m_{i}</span>. Then we have:</p>

    <p class="text-gray-300"><span class="math">\\Pi_{i=2}^{\\deg(F)}(\\frac{2^{i-1}}{2^{i-1}-1})^{\\ell_{i}}\\leq(\\Pi_{2\\leq i&lt;j}(\\frac{2^{i-1}}{2^{i-1}-1})^{m_{i}})(\\frac{2^{j-1}}{2^{j-1}-1})^{\\ell-\\sum_{2\\leq i&lt;j}m_{i}}.</span></p>

    <p class="text-gray-300">As <span class="math">\\ell_{2}\\leq\\ell</span> we consider the worst case : <span class="math">\\ell_{2}=\\ell</span>, giving <span class="math">\\Pi_{i=2}^{\\deg(F)}(\\frac{2^{i-1}}{2^{i-1}-1})^{\\ell_{i}}\\leq 2^{\\ell}</span> and therefore the conservative bound <span class="math">\\delta_{\\mathbf{m}_{F[\\ell]}}\\leq\\delta_{\\mathbf{m}_{F}}2^{\\ell}</span> .</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">Algebraic Attacks</h3>

    <h6 id="sec-77" class="text-base font-medium mt-4">Lemma 18 ( Algebraic Attack on Direct Sums).</h6>

    <p class="text-gray-300">Let <span class="math">F</span> be a boolean function in <span class="math">N</span> variables obtained by direct sums, therefore <span class="math">\\mathsf{Al}(F)\\geq\\mathbf{m}_{F}^{*}</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">F</span> is an <span class="math">N</span> variables function with associated vector <span class="math">\\mathbf{m}_{F}</span>, we thereafter write <span class="math">F</span> as <span class="math">F(x_{1},\\cdots,x_{N})</span>. Let <span class="math">d</span> be the highest integer such that <span class="math">m_{d}=0</span> and is well defined (i.e. it cannot be <span class="math">m_{k}</span>), we can pick two variables of one monomial of <span class="math">F</span> of degree <span class="math">d+1</span> and denote their product by the variable <span class="math">X_{N-1}</span>.</p>

    <p class="text-gray-300">Reordering the variables we obtain a function <span class="math">F_{N-1}(x_{1},\\cdots,x_{N-2},X_{N-1})</span> with an associated vector without <span class="math">0</span> in <span class="math">d</span>-th coordinate and with <span class="math">m_{d+1}</span> inferior by one from the previous vector or nonexistent if it reached <span class="math">0</span> and was the last coefficient of the vector and such that <span class="math">\\mathbf{m}_{F_{N-1}}^{<em>}\\geq\\mathbf{m}_{F}^{</em>}</span>.</p>

    <p class="text-gray-300">Therefore we can recursively apply this technique to obtain the function <span class="math">G=F(x_{1},\\cdots,X_{j})</span> in <span class="math">j</span> variables with associated vector <span class="math">\\mathbf{m}_{G}</span> being null or without coefficients equal to zero (the recursion is ending because <span class="math">N=\\sum_{i=1}^{k}im_{i}</span> is finite and applying the technique reduces <span class="math">N</span> and the recursion ends if <span class="math">N=0</span>).</p>

    <p class="text-gray-300">Considering the last function <span class="math">G</span> and <span class="math">\\mathbf{m}_{G}</span> of length <span class="math">k^{\\prime}=\\mathbf{m}_{G}^{<em>}\\geq\\mathbf{m}_{F}^{</em>}</span> we have that <span class="math">G</span> is the direct sum of <span class="math">T_{k^{\\prime}}</span> (<span class="math">\\mathbf{m}_{T_{n}}</span> is the <span class="math">n</span>-length vector with all components being <span class="math">1</span> by definition of <span class="math">T_{n}</span>) and another function. Then by the property of direct sums <span class="math">\\mathsf{Al}(G)\\geq\\mathsf{Al}(T_{k^{\\prime}})</span> therefore <span class="math">\\mathsf{Al}(G)\\geq\\mathbf{m}_{G}^{*}</span>.</p>

    <p class="text-gray-300">That means that there exists no annihilator of degree strictly inferior to <span class="math">\\mathbf{m}_{G}^{<em>}</span> for <span class="math">G</span> or <span class="math">G+1</span> in the variables <span class="math">x_{1},\\cdots,X_{j}</span>. Then by construction of the variables <span class="math">X</span> there exists no annihilator of degree strictly inferior to <span class="math">\\mathbf{m}_{F}^{</em>}</span> for <span class="math">F</span> or <span class="math">F+1</span> in the variables <span class="math">x_{1},\\cdots,x_{N}</span>. We conclude that <span class="math">\\mathsf{Al}(F)\\geq\\mathbf{m}_{F}^{*}</span>. ∎</p>

    <p class="text-gray-300">Now we consider the best complexity of combining Guess And Determine and Algebraic Attacks.</p>

    <p class="text-gray-300">Lemma 19 (Guess And Determine &amp; Algebraic Attack). Let <span class="math">F</span> be a boolean function in <span class="math">N</span> variables and <span class="math">C_{GDAA}(F)</span> (respectively <span class="math">C_{AA}(F)</span>) be the minimum complexity of the Guess And Determine with Algebraic Attack (respectively Algebraic Attack) on <span class="math">F</span>, then:</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left[ 2^{\\ell} \\binom{\\min N[\\ell]}{\\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor} \\right]^{\\omega}.</span></div>

    <p class="text-gray-300">Proof. <span class="math">C_{GDAA}(F) = \\min(2^{\\ell} C_{AA}(F[\\ell]))</span> by definition, with the minimum taken over all guessing of <span class="math">\\ell</span> variables, with <span class="math">0 \\leq \\ell \\leq N</span>.</p>

    <p class="text-gray-300">We then have <span class="math">C_{GDAA}(F) = \\min[2^{\\ell} (\\sum_{i=1}^{\\mathsf{Al}(F[\\ell])} \\binom{N[\\ell]}{i})^{\\omega}] \\geq \\min[2^{\\ell} \\binom{N[\\ell]}{\\mathsf{Al}(F[\\ell])}]</span>.</p>

    <p class="text-gray-300">As for all Boolean functions the algebraic immunity is less than half the number of its variables, for all fixed <span class="math">\\ell</span> we can use the bound <span class="math">\\binom{N[\\ell]}{\\mathsf{Al}(F[\\ell])} \\geq \\binom{\\min N[\\ell]}{\\min \\mathsf{Al}(F[\\ell])}</span> where the minimum is taken over all functions obtained by guessing <span class="math">\\ell</span> variables.</p>

    <p class="text-gray-300">Moreover <span class="math">\\mathsf{Al}(F[\\ell]) \\geq \\mathbf{m}_{F[\\ell]}^<em> \\geq \\mathbf{m}_F^</em> - \\lfloor \\frac{\\ell}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor</span> by lemmas 7.2 and 18. We recall that <span class="math">\\min N[\\ell]</span> is the smallest number of variables of a function obtained by cancelling <span class="math">\\ell</span> variables of <span class="math">F</span>; this quantity is easily computable and may be smaller than the number of variables of the function used for the actual attack.</p>

    <p class="text-gray-300">Putting all these together leads to: <span class="math">C_{GDAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} [2^{\\ell} \\left( \\frac{\\min N[\\ell]}{\\min_{i \\in [\\deg(F)]} m_i} \\right)]</span>.</p>

    <p class="text-gray-300">Proof. Proof of Lemma 8</p>

    <p class="text-gray-300"><span class="math">C_{GDAA}(F) = \\min(2^{\\ell} C_{FAA}(F[\\ell]))</span> by definition, with the minimum taken over all guessing of <span class="math">\\ell</span> variables, with <span class="math">0 \\leq \\ell \\leq N</span>.</p>

    <p class="text-gray-300">Then for all Boolean functions <span class="math">f</span>, <span class="math">C_{FAA}(f) = \\min[(D \\log^2 D + E^2 D + E^\\omega)]</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the minimum is taken over all Boolean functions <span class="math">g</span> and <span class="math">h</span> such that <span class="math">fg = h</span>,</li>

      <li><span class="math">d = \\deg(h)</span> and <span class="math">e = \\deg(g)</span>,</li>

      <li><span class="math">D = \\sum_{i=1}^{d} \\binom{N}{i}</span> and <span class="math">E = \\sum_{i=1}^{e} \\binom{N}{i}</span>,</li>

      <li><span class="math">\\omega</span> is the exponent appearing in solving a linear system.</li>

    </ul>

    <p class="text-gray-300">As we need to bound <span class="math">d</span> and <span class="math">e</span> for all guesses, we use the following property of the algebraic immunity: <span class="math">fg = h \\Rightarrow g = fh \\Rightarrow f(g + h) = 0</span>. By definition of <span class="math">\\mathsf{Al}(f)</span>, <span class="math">\\deg(g + h) \\geq \\mathsf{Al}(f)</span> therefore <span class="math">\\max(d, e) \\geq \\mathsf{Al}(f)</span>.</p>

    <p class="text-gray-300">As <span class="math">C_{FAA}(f)</span> is defined as a minimal value over all choices of <span class="math">g</span> and <span class="math">h</span> such that <span class="math">fg = h</span>, we can restrict the choices to <span class="math">1 \\leq e \\leq d</span> with <span class="math">d \\geq \\mathsf{Al}(f)</span>. Therefore we get:</p>

    <div class="my-4 text-center"><span class="math-block">C_{FAA}(f) = \\min \\left(D \\log^2 D + E^2 D + E^\\omega\\right) \\geq \\min \\left( \\binom{N}{d} \\log^2 \\binom{N}{d} + \\binom{N}{e}^2 \\binom{N}{d} + \\binom{N}{e}^\\omega \\right) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">C_{FAA}(f) \\geq \\binom{N}{\\mathsf{Al}(f)} \\log^2 \\binom{N}{\\mathsf{Al}(f)} + \\binom{N}{1}^2 \\binom{N}{\\mathsf{Al}(f)} + \\binom{N}{1}^\\omega.</span></div>

    <p class="text-gray-300">Using lemma 18 on our particular functions <span class="math">F[\\ell]</span> we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">C_{FAA}(F[\\ell]) \\geq \\binom{N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} \\log^2 \\binom{N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} + (N[\\ell])^2 \\binom{N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} + (N[\\ell])^\\omega.</span></div>

    <p class="text-gray-300">We can use the bound <span class="math">\\binom{N[\\ell]}{\\mathbf{m}_F^<em>[\\ell]} \\geq \\left( \\mathbf{m}_F^</em> - \\left[ \\frac{\\min N[\\ell]}{\\ell} \\right] \\right)</span> using that <span class="math">\\mathsf{AI}(F[\\ell]) \\leq \\frac{N[\\ell]}{2}</span> and lemma 7. Therefore:</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDFAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left[ 2^{\\ell} \\left( C \\log^2 C + (\\min N[\\ell])^2 C + (\\min N[\\ell])^{\\omega} \\right) \\right],</span></div>

    <p class="text-gray-300">where <span class="math">C = \\left( \\frac{\\min N[\\ell]}{\\ell} \\right)</span> (Gauss and Determine &amp; CA/BKW-like Attack). Let <span class="math">F</span> be a boolean function in <span class="math">N</span> variables and <span class="math">C_{GDCA/BKW}(F)</span> be the minimum complexity of the Gauss And Determine with Correlation/BKW Attack on <span class="math">F</span>, then:</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDCA/BKW}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left\\{ 2^{-\\ell} \\delta_{\\mathbf{m}_F}^{-2} \\right\\}.</span></div>

    <p class="text-gray-300">Proof. <span class="math">C_{GDCA/BKW}(F) = \\min \\{2^{\\ell} C_{CA}(F[\\ell]), 2^{\\ell} C_{BKW}(F[\\ell])\\} \\geq \\min \\{2^{\\ell} (\\delta_{\\mathbf{m}_{F[\\ell]}})^{-2}\\}</span> where <span class="math">C_{CA}</span> and <span class="math">C_{BKW}</span> stand for the (data) complexity of the correlation and the BKW attack and <span class="math">\\delta_{\\mathbf{m}_{F[\\ell]}}</span> is the bias of the function <span class="math">F[\\ell]</span>, the minimum is taken over all guessing of <span class="math">\\ell</span> variables, with <span class="math">0 \\leq \\ell \\leq N</span>.</p>

    <p class="text-gray-300">From Lemma 7 we know that the bias increases the most when considering the restriction of <span class="math">F</span> to the <span class="math">N[\\ell]</span> variables canceling the monomials of degree 2. We can then derive the following bound from Lemma 7:</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\delta_{\\mathbf{m}_{F[\\ell]}} \\right)^{-2} \\geq \\delta_{\\mathbf{m}_F}^{-2} \\cdot 2^{-2\\ell}.</span></div>

    <p class="text-gray-300">Hence we have</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDCA/BKW}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left\\{ 2^{-\\ell} \\delta_{\\mathbf{m}_F}^{-2} \\right\\}.</span></div>

    <p class="text-gray-300">☐</p>

    <p class="text-gray-300">HOC Attack The HOC attack leads to consider the best approximation of fixed degree of a Boolean function, which corresponds to determine its non-linearity of order greater than 1. As this characteristic is still generally unknown for almost all functions up to our knowledge, we approximate the non-linearity of order <span class="math">d</span> of a direct sum of monomials <span class="math">F</span> by the distance between <span class="math">F</span> and its restriction <span class="math">F_d</span> to degrees up to <span class="math">d</span> monomials. We define <span class="math">G_d = F \\oplus F_d</span>.</p>

    <p class="text-gray-300">Let <span class="math">F</span> be associated to <span class="math">\\mathbf{m}_F = [m_1, \\dots, m_d, \\dots, m_k]</span>, thereafter we consider <span class="math">F_d</span> associated to <span class="math">\\mathbf{m}_{F_d} = [m_1, \\dots, m_d, 0, \\dots, 0]</span> and <span class="math">G_d</span> associated to <span class="math">\\mathbf{m}_{G_d} = [0, \\dots, 0, m_{d+1}, \\dots, m_k]</span>.</p>

    <p class="text-gray-300">Lemma 21 (Guess and Determine and HOC). Let <span class="math">F</span> be a boolean function in <span class="math">N</span> variables of degree <span class="math">k</span> such that <span class="math">\\mathbf{m}_F = [m_1, \\dots, m_k]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDHOC} = \\min_{0 \\leq \\ell \\leq N} \\left( 2^{\\ell} \\min_{1 \\leq d \\leq \\deg(F)} \\left[ \\binom{\\min N[\\ell]}{D}^{\\omega} \\left( \\frac{1}{2} + \\delta_{\\mathbf{m}_{G_d}} \\left( \\frac{2^d}{2^d - 1} \\right)^{\\ell} \\right)^{-m} \\right] \\right),</span></div>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">d \\leq D \\leq \\frac{\\min N[\\ell]}{2}</span>, for each <span class="math">\\ell</span>.</li>

      <li><span class="math">m \\geq \\frac{\\binom{\\min N[\\ell]}{D}}{\\binom{\\min N[\\ell]}{D-d}}</span>, for each <span class="math">\\ell</span>.</li>

    </ul>

    <p class="text-gray-300">Proof. <span class="math">C_{GDHOC} = \\min(2^{\\ell} C_{HOC}(F[\\ell]))</span> By definition, with the minimum taken over all guessing of <span class="math">\\ell</span> variables, with <span class="math">0 \\leq \\ell \\leq N</span>.</p>

    <p class="text-gray-300">Applying the complexity bound for the HOC attack:</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDHOC} = \\min \\left(2^{\\ell} \\min_{1 \\leq d \\leq \\deg(F)} \\left[ \\binom{N[\\ell]}{D}^{\\omega} (1 - \\varepsilon)^{-m} \\right]\\right),</span></div>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">d \\leq D \\leq N</span>.</li>

      <li><span class="math">\\varepsilon = \\frac{d_H(F[\\ell], g)}{2^{N[\\ell]}}</span> with <span class="math">g</span> a Boolean function of degree at most <span class="math">d</span>.</li>

      <li><span class="math">m \\geq \\frac{\\binom{N[\\ell]}{D}}{\\binom{N[\\ell]}{D-d}}</span>.</li>

    </ul>

    <p class="text-gray-300">First we bound the term <span class="math">(1 - \\varepsilon)</span>, by definition of the non-linearity of order <span class="math">d</span>, <span class="math">\\min_g\\left(\\frac{d_H(F[\\ell], g)}{2^{N[\\ell]}}\\right) = \\mathsf{NL}_d(F[\\ell])</span>. We approximate <span class="math">F[\\ell]</span> by <span class="math">F[\\ell]_d</span> and as <span class="math">F[\\ell] \\oplus F[\\ell]_d</span> is a direct sum of monomials we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{NL}_d(F[\\ell]) \\approx \\frac{d_H(F[\\ell], F[\\ell]_d)}{2^{N[\\ell]}} = \\frac{\\mathsf{NL}(F[\\ell] \\oplus F[\\ell]_d)}{2^{N[\\ell]}}.</span></div>

    <p class="text-gray-300">We write <span class="math">G[\\ell]_d = F[\\ell] \\oplus F[\\ell]_d</span> for simplicity, then <span class="math">\\frac{1}{2} - \\frac{\\mathsf{NL}(F[\\ell] \\oplus F[\\ell]_d)}{2^{N[\\ell]}} = \\delta_{\\mathbf{m}_{G[\\ell]_d}}</span>. As <span class="math">G[\\ell]_d</span> contains only monomials of degree greater than <span class="math">d</span> we use Lemma 7(part 3) and get <span class="math">\\delta_{\\mathbf{m}_{G[\\ell]_d}} \\leq \\delta_{\\mathbf{m}_{G_d}}\\left(\\frac{2^d}{2^d - 1}\\right)^\\ell</span>.</p>

    <p class="text-gray-300">We conclude <span class="math">(1 - \\varepsilon) \\geq \\left(\\frac{1}{2} + \\delta_{\\mathbf{m}_{G_d}}\\left(\\frac{2^d}{2^d - 1}\\right)^\\ell\\right)</span>.</p>

    <p class="text-gray-300">Then we bound the term <span class="math">\\binom{N[\\ell]}{D}</span> and <span class="math">m</span> in consequences. Following [Cou02] we assume <span class="math">D &amp;lt;&amp;lt; N</span> and more precisely <span class="math">D \\leq \\frac{\\min N[\\ell]}{2}</span> where the minimum is taken over all guesses of <span class="math">\\ell</span> bits.</p>

    <p class="text-gray-300">Putting all together we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">C_{GDHOC} = \\min_{0 \\leq \\ell \\leq N} \\left(2^{\\ell} \\min_{1 \\leq d \\leq \\deg(F)} \\left[ \\binom{\\min N[\\ell]}{D}^{\\omega} \\left(\\frac{1}{2} + \\delta_{\\mathbf{m}_{G_d}} \\left(\\frac{2^d}{2^d - 1}\\right)^\\ell\\right)^{-m} \\right]\\right),</span></div>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">d \\leq D \\leq \\frac{\\min N[\\ell]}{2}</span>, for each <span class="math">\\ell</span>.</li>

      <li><span class="math">m \\geq \\frac{\\binom{\\min N[\\ell]}{D}}{\\binom{\\min N[\\ell]}{D-d}}</span>, for each <span class="math">\\ell</span>.</li>

    </ul>

    <p class="text-gray-300">F Error Growth Proofs</p>

    <p class="text-gray-300">Proof of lemma 10</p>

    <p class="text-gray-300">Proof. We first prove the lemma in the batched GSW setting following the analysis in [AP14] for the sum of two ciphertexts. Considering the addition of two ciphertexts we can write:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{S C}_{+} = \\mathbf{S C}_{1} + \\mathbf{S C}_{2} = \\mathbf{E}_{1}^{\\prime} + \\left( \\begin{array}{c} \\dfrac{m_{1,1} \\cdot \\mathbf{s}_{1}^{\\vee}}{\\vdots} \\\\ \\dfrac{m_{1,r} \\cdot \\mathbf{s}_{r}^{\\vee}}{\\vdots} \\end{array} \\right) \\mathbf{G} + \\mathbf{E}_{2}^{\\prime} + \\left( \\begin{array}{c} \\dfrac{m_{2,1} \\cdot \\mathbf{s}_{1}^{\\vee}}{\\vdots} \\\\ \\dfrac{m_{2,r} \\cdot \\mathbf{s}_{r}^{\\vee}}{\\vdots} \\end{array} \\right) \\mathbf{G}.</span></div>

    <p class="text-gray-300">The error of <span class="math">\\mathbf{C}_{+}</span> is therefore <span class="math">\\mathbf{E}_{+} = \\mathbf{E}_{1}^{\\prime} + \\mathbf{E}_{2}^{\\prime} \\in \\mathbb{Z}_{q}^{r \\times N}</span>; each row <span class="math">\\mathbf{e}_{+,j}^{\\top}</span> for <span class="math">1 \\leq j \\leq r</span> is the sum of <span class="math">\\mathbf{e}_{1,j}^{\\top}</span> and <span class="math">\\mathbf{e}_{2,j}^{\\top}</span>. Then for <span class="math">1 \\leq j \\leq r</span> the <span class="math">N</span> coefficients of <span class="math">\\mathbf{e}_{1,j}^{\\top}</span> (respectively <span class="math">\\mathbf{e}_{2,j}^{\\top}</span>) follow a subgaussian distribution of parameter <span class="math">\\sigma_{1}</span> (respectively <span class="math">\\sigma_{2}</span>) and by Pythagorean additivity each coefficient of <span class="math">\\mathbf{e}_{+,j}^{\\top}</span> as subgaussian parameter <span class="math">\\sigma_{+} = \\sqrt{\\sigma_{1}^{2} + \\sigma_{2}^{2}}</span>.</p>

    <p class="text-gray-300">Then we prove the analogous property in the ring setting. To add two ciphertexts we consider:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {s} ^ {\\top} \\mathbf {C} _ {+} = \\mathbf {s} ^ {\\top} \\mathbf {C} _ {1} + \\mathbf {s} ^ {\\top} \\mathbf {C} _ {2} = \\mathbf {e} _ {1} ^ {r r} + m _ {1} \\mathbf {s} ^ {\\top} \\mathbf {G} + \\mathbf {e} _ {2} ^ {r r} + m _ {2} \\mathbf {s} ^ {\\top} \\mathbf {G}.</span></div>

    <p class="text-gray-300">The error of <span class="math">\\mathbf{C}_{+}</span> is therefore <span class="math">\\mathbf{e}_{+}^{\\top} = \\mathbf{e}_{1}^{rr} + \\mathbf{e}_{2}^{rr} \\in R^{N}</span> where each <span class="math">N</span> coefficient is the sum of polynomials where each component follows a subgaussian distribution of parameter respectively <span class="math">\\sigma_{1}</span> or <span class="math">\\sigma_{2}</span>. By Pythagorean additivity on subgaussian parameters, each component of the polynomials of the vector <span class="math">\\mathbf{e}_{+}^{\\top}</span> has therefore subgaussian parameter <span class="math">\\sigma_{+} = \\sqrt{\\sigma_{1}^{2} + \\sigma_{2}^{2}}</span>.</p>

    <p class="text-gray-300">Finally, in both cases the subgaussian parameter for the addition of <span class="math">k</span> ciphertexts is simply obtained by applying successively the formula of the addition of two ciphertexts. The case <span class="math">\\sigma&#x27; = \\sigma \\sqrt{k}</span> is a subcase when all ciphertexts error distributions have identical parameter <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300">Proof of lemma 11</p>

    <p class="text-gray-300">Proof. We first prove the statement on batched-GSW following the same direction as [AP12] (considering only the subcase of diagonal matrices as plaintexts). Let consider the noise in a product of two ciphertexts <span class="math">\\mathbf{SC}_{\\times}</span>. We have the following relations:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {S C} _ {\\times} = \\mathbf {S C} _ {1} \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}) = \\left(\\mathbf {E} _ {1} ^ {\\prime} + \\frac {\\left(\\frac {m _ {1 , 1} \\cdot \\mathbf {s} _ {1} ^ {\\top}}{\\vdots}\\right)}{\\left(\\frac {m _ {1 , r} \\cdot \\mathbf {s} _ {r} ^ {\\top}}{\\vdots}\\right)} \\mathbf {G}\\right) \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}), \\\\ = \\mathbf {E} _ {1} ^ {\\prime} \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}) + \\left(\\frac {\\frac {m _ {1 , 1} \\cdot \\mathbf {s} _ {1} ^ {\\top}}{\\vdots}}{\\frac {m _ {1 , r} \\cdot \\mathbf {s} _ {r} ^ {\\top}}{\\vdots}}\\right) \\mathbf {C} _ {2} = \\mathbf {E} _ {1} ^ {\\prime} \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}) + \\left(\\frac {m _ {1 , 1} \\quad 0 \\quad \\ldots \\quad 0}{0 \\quad m _ {1 , 2} \\ldots \\quad 0} \\right. \\\\ = \\mathbf {E} _ {1} ^ {\\prime} \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}) + \\left(\\frac {m _ {1 , 1} \\quad 0 \\quad \\ldots \\quad 0}{0 \\quad m _ {1 , 2} \\ldots \\quad 0} \\right. \\\\ = \\mathbf {E} _ {1} ^ {\\prime} \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}) + \\left(\\frac {m _ {1 , r} m _ {2 , r} \\cdot \\mathbf {s} _ {r} ^ {\\top}}{\\vdots}\\right) \\mathbf {G}. \\end{array}</span></div>

    <p class="text-gray-300">The error of <span class="math">\\mathbf{C}_{\\times}</span> is therefore <span class="math">\\mathbf{E}_{\\times} = \\mathbf{E}_1^{\\prime}\\mathbf{G}^{-1}(\\mathbf{C}_2) + \\left( \\begin{array}{cccc}m_{1,1} &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0\\\\ 0 &amp;amp; m_{1,2} &amp;amp; \\ldots &amp;amp; 0\\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; m_{1,n} \\end{array} \\right)\\mathbf{E}_2^{\\prime}.</span></p>

    <p class="text-gray-300">As <span class="math">\\mathbf{G}^{-1}(\\mathbf{C}_2)</span> is an <span class="math">N\\times N</span> matrix from independent subgaussian distribution with parameter <span class="math">\\sigma_{\\mathbf{G}^{-1}} = 1</span>, we can consider independently the <span class="math">r</span> rows of <span class="math">\\mathbf{E}_{\\times}</span>, leading to:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_{\\times,j}^{\\gamma}=\\mathbf{e}_{1,j}^{\\gamma}\\mathbf{G}^{-1}(\\mathbf{C}_{2})+m_{1,j}\\mathbf{e}_{2,j}^{\\gamma}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The components of <span class="math">m_{1,j}\\mathbf{e}_{2,j}^{\\gamma}</span> follow a subgaussian distribution of parameter $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2}<span class="math"> by homogeneity, with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathbb{N}<span class="math"> the absolute norm of </span>m_{1,j}<span class="math">. By Pythagorean additivity, the components of </span>\\mathbf{e}_{1,j}^{\\gamma}\\mathbf{G}^{-1}(\\mathbf{C}_{2})<span class="math"> follow a subgaussian distribution of parameter </span>\\sqrt{\\sum_{\\ell=1}^{N}(\\sigma_{\\mathbf{G}^{-1}}\\mathbf{e}_{1,j,\\ell}^{\\gamma})^{2}}=\\sigma_{\\mathbf{G}^{-1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}_{1,j}^{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}=\\mathcal{O}(\\sigma_{1}\\sqrt{N})$ by Lemma 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The components of <span class="math">\\mathbf{e}_{\\times,j}^{\\gamma}</span> are therefore following independent subgaussian distribution of parameter $\\sigma^{\\prime}=\\mathcal{O}\\left(\\sqrt{(\\sigma_{1}\\sqrt{N})^{2}+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2})^{2}}\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Applying this formula recursively for a multiplicative chain we obtain the following one for <span class="math">\\sigma^{\\prime}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{O}\\left(\\sqrt{(\\sigma_{1}\\sqrt{N})^{2}+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{1,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{2}\\sqrt{N})^{2}+\\cdots+((\\Pi_{i=1}^{k-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\sigma_{k}\\sqrt{N})^{2}+((\\Pi_{i=1}^{k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\sigma_{\\mathbf{G}})^{2}}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As <span class="math">\\mathbf{G}</span> is a noiseless encryption of <span class="math">\\mathbf{I}</span>, <span class="math">\\sigma_{\\mathbf{G}}=0</span> and we can conclude:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma^{\\prime}=\\mathcal{O}\\left(\\sqrt{N}\\sqrt{\\sigma_{1}^{2}+\\sum_{i=2}^{k}(\\sigma_{i}\\Pi_{j=1}^{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2}}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then we prove the property in the ring setting.</p>

    <p class="text-gray-300">We first recall that <span class="math">R</span> is a cyclotomic polynomial of degree being a power of two. Hence we have the following relations on a product of <span class="math">a,b\\in R_{q}</span>:</p>

    <p class="text-gray-300"><span class="math">ab=\\sum_{i=0}^{n-1}\\left(\\sum_{j=0}^{i}a_{j}b_{i-j}X^{i}\\right)+\\sum_{i=0}^{n-2}\\left(\\sum_{j=i+1}^{n-1}a_{j}b_{n+i-j}X^{n+i}\\right)\\mod X^{n}+1.</span></p>

    <p class="text-gray-300">Using the reduction modulus <span class="math">X^{n}+1</span> we get:</p>

    <p class="text-gray-300"><span class="math">ab=\\sum_{i=0}^{n-1}\\left(\\sum_{j=0}^{i}a_{j}b_{i-j}X^{i}\\right)-\\sum_{i=0}^{n-2}\\left(\\sum_{j=i+1}^{n-1}a_{j}b_{n+i-j}X^{i}\\right),</span></p>

    <p class="text-gray-300">and for each coefficient:</p>

    <p class="text-gray-300"><span class="math">(ab)_{i}=\\left(\\sum_{j=0}^{i}a_{j}b_{i-j}\\right)-\\left(\\sum_{j=i+1}^{n-1}a_{j}b_{n+i-j}\\right),</span></p>

    <p class="text-gray-300">where each coefficient of <span class="math">a</span> and <span class="math">b</span> appears only once in the sum. This expression on the coefficients enables then to obtain the subgaussian parameter of a product of subgaussian polynomials.</p>

    <p class="text-gray-300">With <span class="math">a,b\\in R_{q}</span>, each coefficient of <span class="math">b</span> following independent subgaussian distributions of parameter <span class="math">\\sigma_{b}</span>, by Pythagorean additivity we obtain the subgaussian parameter <span class="math">\\sigma_{ab}</span> of the coefficients of <span class="math">ab</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sigma_{ab}=\\sqrt{\\sum_{j=0}^{n-1}(a_{j}\\sigma_{b})^{2}}=\\sigma_{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}.$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hereafter, as in the batched setting, we obtain the subgaussian parameter in the simpler case of a product of two ciphertexts. Multiplying two ciphertexts <span class="math">\\mathbf{C}_1</span> and <span class="math">\\mathbf{C}_2</span> we can consider the resultant error vector:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {e} _ {\\times} ^ {\\top} = \\mathbf {e} _ {1} ^ {\\top} \\mathbf {G} ^ {- 1} (\\mathbf {C} _ {2}) + m _ {1} \\mathbf {e} _ {2} ^ {\\top} \\in R _ {q} ^ {N}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the second part, we consider all polynomial of <span class="math">\\mathbf{e}_2</span> with coefficient from subgaussian independent distributions of parameter <span class="math">\\sigma_2</span>. Then the subgaussian parameter obtained is $\\sigma_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2$ using relation 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the first component <span class="math">\\mathbf{e}_1^\\top \\mathbf{G}^{-1}(\\mathbf{C}_2)</span>, each polynomial of the result is the sum of <span class="math">N</span> independent products from an element of <span class="math">\\mathbf{e}_1^\\top</span> and a polynomial with coefficients following subgaussian distributions of parameter 1 (by construction of <span class="math">\\mathbf{G}^{-1}</span>). The subgaussian parameter of the first part is $\\sqrt{\\sum_{i=1}^{N}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}_{1i}^\\top</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2)^2}$ by Relation 3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally the subgaussian parameter <span class="math">\\sigma_{\\times}</span> of the coefficients of the polynomials of <span class="math">\\mathbf{e}_{\\times}</span> is:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_ {\\times} = \\mathcal {O} \\left(\\sqrt {(\\sigma_ {1} \\sqrt {n N}) ^ {2} + (\\sigma_ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}) ^ {2}}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">using Lemma 2 on the <span class="math">\\mathbf{e}_{1i}</span> and Pythagorean additivity.</p>

    <p class="text-gray-300">We apply this formula recursively for a multiplicative chain ending by <span class="math">\\mathbf{G}</span>. The resulting subgaussian parameter is <span class="math">\\sigma&#x27;</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {O} \\left(\\sqrt {(\\sigma_ {1} \\sqrt {n N}) ^ {2} + (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {1 , j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\sigma_ {2} \\sqrt {n N}) ^ {2} + \\cdots + ((\\Pi_ {i = 1} ^ {k - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {i , j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}) \\sigma_ {k} \\sqrt {n N}) ^ {2} + ((\\Pi_ {i = 1} ^ {k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {i , j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}) \\sigma_ {\\mathbf {G}}) ^ {2}}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As <span class="math">\\mathbf{G}</span> is a noiseless encryption of <span class="math">\\mathbf{I}</span>, <span class="math">\\sigma_{\\mathbf{G}} = 0</span> and we can conclude:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma^ {\\prime} = \\mathcal {O} \\left(\\sqrt {n N} \\sqrt {\\sigma_ {1} ^ {2} + \\sum_ {i = 2} ^ {k} (\\sigma_ {i} \\Pi_ {j = 1} ^ {i - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}) ^ {2}}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">□</p>`;
---

<BaseLayout title="Towards Stream Ciphers for Efficient FHE  with Low-Noise Cip... (2016/254)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/254
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
