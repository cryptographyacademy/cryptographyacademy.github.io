---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/254';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'Towards Stream Ciphers for Efficient FHE with Low-Noise Ciphertexts';
const AUTHORS_HTML = 'Pierrick Meaux ´ 1 , Anthony Journault&lt;sup&gt;2&lt;/sup&gt; , Franc¸ois-Xavier Standaert&lt;sup&gt;2&lt;/sup&gt; , Claude Carlet&lt;sup&gt;3&lt;/sup&gt; .';

const CONTENT = `    <p class="text-gray-300">Pierrick Meaux ´ 1 , Anthony Journault&lt;sup&gt;2&lt;/sup&gt; , Franc¸ois-Xavier Standaert&lt;sup&gt;2&lt;/sup&gt; , Claude Carlet&lt;sup&gt;3&lt;/sup&gt; .</p>

    <p class="text-gray-300">1 INRIA, CNRS, ENS and PSL Research University, Paris, France. 2 ICTEAM/ELEN/Crypto Group, Universite catholique de Louvain, Belgium. ´ &lt;sup&gt;3&lt;/sup&gt; LAGA, Department of Mathematics, University of Paris VIII and University of Paris XIII, France.</p>

    <p class="text-gray-300">Abstract. Symmetric ciphers purposed for Fully Homomorphic Encryption (FHE) have recently been proposed for two main reasons. First, minimizing the implementation (time and memory) overheads that are inherent to current FHE schemes. Second, improving the homomorphic capacity, <em>i.e.</em> the amount of operations that one can perform on homomorphic ciphertexts before bootstrapping, which amounts to limit their level of noise. Existing solutions for this purpose suggest a gap between block ciphers and stream ciphers. The first ones typically allow a constant but small homomorphic capacity, due to the iteration of rounds eventually leading to complex Boolean functions (hence large noise). The second ones typically allow a larger homomorphic capacity for the first ciphertext blocks, that decreases with the number of ciphertext blocks (due to the increasing Boolean complexity of the stream ciphers' output). In this paper, we aim to combine the best of these two worlds, and propose a new stream cipher construction that allows constant and small(er) noise. Its main idea is to apply a Boolean (filter) function to a public bit permutation of a constant key register, so that the Boolean complexity of the stream cipher outputs is constant. We also propose an instantiation of the filter function designed to exploit recent (3rd-generation) FHE schemes, where the error growth is quasi-additive when adequately multiplying ciphertexts with the same amount of noise. In order to stimulate further investigation, we then specify a few instances of this stream cipher, for which we provide a preliminary security analysis. We finally highlight the good properties of our stream cipher regarding the other goal of minimizing the time and memory complexity of calculus delegation (for 2nd-generation FHE schemes). We conclude the paper with open problems related to the large design space opened by these new constructions.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">Purpose: calculus delegation. Recent years have witnessed massive changes in communication technologies, that can be summarized as a combination of two trends: (1) the proliferation of small embedded devices with limited storage and computing facilities, and (2) the apparition of cloud services with extensive storage and computing facilities. In this context, the outsourcing of data and the delegation of data processing gains more and more interest. Yet, such new opportunities also raise new security and privacy concerns. Namely, users typically want to prevent the server from learning about their data and processing. For this purpose, Gentry's breakthrough Fully Homomorphic Encryption (FHE) scheme <a href="#page-27-0">[Gen09]</a> brought a perfect conceptual answer. Namely, it allows applying processing on ciphertexts in a homomorphic way so that after decryption, plaintexts have undergone the same operations as ciphertexts, but the server has not learned anything about these plaintexts.&lt;sup&gt;1&lt;/sup&gt;</p>

    <p class="text-gray-300">Application scenario. Cloud services can be exploited in a plethora of applications, some of them surveyed in <a href="#page-28-0">[NLV11]</a>. In general, they are always characterized by the aforementioned asymmetry between the communication parties. For illustration, we start by providing a simple example where data outsourcing and data processing delegation require security and privacy. Let us say that a patient, Alice, has undergone</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; In the remaining of the paper, and when not specified otherwise, the term FHE will also be used for related schemes such as Leveled HE, SomeWhat HE, Scalable HE, <em>etc.</em></p>

    <p class="text-gray-300">a surgery and is coming back home. The hospital gave her a monitoring watch (with limited storage) to measure her metabolic data on a regular basis. And this metabolic data should be made available to the doctor Bob, to follow the evolution of the post-surgery treatment. Quite naturally, Bob has numerous patients and no advanced computing facilities to store and process the data of all his patients. So this is a typical case where sending the data to a cloud service would be very convenient. That is, Alice's data could be sent to and stored on the cloud, and associated to both her and the doctor Bob. And the cloud would provide Bob with processed information in a number of situations such as when the metabolic data of Alice is abnormal (in which case an error message should be sent to Bob), or during an appointment between Alice and Bob, so that Bob can follow the evolution of Alice's data (possibly after some processing). Bob could in fact even be interested by accessing some other patient's data, in order to compare the effect of different medications. And of course, we would like to avoid the cloud to know anything about the (private) data it is manipulating.</p>

    <p class="text-gray-300"><strong>Typical Framework.</strong> More technically, the previous exemplary application can be integrated in a quite general cloud service application framework, that can be seen as a combination of 5 steps, combining a symmetric encryption scheme and an asymmetric homomorphic encryption scheme, as summarised in Figure 1 and described next:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Initialization</em>. Alice runs the key generation algorithms H.KeyGen and S.KeyGen of the two schemes, and sends her homomorphic public key  <span class="math">pk^H</span>  and the homomorphic ciphertext of her symmetric key  <span class="math">\\mathbf{C}^H(\\mathsf{sk}_i^S)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Storage. Alice encrypts her data  <span class="math">m_i</span>  with the symmetric encryption scheme, and sends  <span class="math">\\mathbf{C}^S(m_i)</span>  to Claude.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Evaluation. Claude homomorphically evaluates, with the H. Eval algorithm, the decryption  <span class="math">\\mathbf{C}^H(m_i)</span>  of the symmetric scheme on Alice's data  <span class="math">\\mathbf{C}^S(m_i)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Computation. Claude homomorphically executes the treatment f on Alice's encrypted data.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Result. Claude sends a compressed encrypted result of the data treatment  <span class="math">\\mathbf{c}^H(f(m_i))</span> , obtained with the H.Comp algorithm, and Alice decrypts it.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note that if we assume the existence of a trusted third party active only during the initialization step, Alice can avoid Step 1, which needs a significant computational and memory storage effort. Note also that this framework is versatile: computation can be done in parallel (in a batch setting) or can be turned into a secret key FHE.</p>

    <p class="text-gray-300"><strong>FHE bottlenecks.</strong> The main limitation for the deployment of cloud services based on such FHE frameworks relates to its important overheads, that can be related to two main concerns: computational and memory costs (especially on the client side) and limited homomorphic capacity (<em>i.e.</em> noise increase). More precisely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The computational and memory costs for the client depend overwhelmingly on the homomorphic encryption and decryption algorithms during the steps 1 and 5. The memory cost is mostly influenced by the homomorphic ciphertexts and public key sizes. Solving these two problems consists in building size-efficient FHE schemes with low computational cost [HS14, KGV14]. On the server side, this computational cost further depends on the symmetric encryption scheme and function to evaluate.</li>
      <li>The homomorphic capacity relates to the fact that FHE constructions are built on noise-based cryptography, where the unbounded amount of homomorphic operations is guaranteed by an expensive bootstrapping technique. The homomorphic capacity corresponds to the amount of operations doable</li>
    </ul>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&lt;u&gt;Alice&lt;/u&gt;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&lt;u&gt;Claude&lt;/u&gt;</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1: Initialization</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{aligned} (sk^H,pk^H) &amp;\\leftarrow H.KeyGen(\\lambda) \\\\ sk^S &amp;\\leftarrow S.KeyGen(\\lambda) \\\\ \\mathbf{C}^H(sk_i^S) &amp;= H.Enc(sk_i^S,pk^H) \\end{aligned}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\underline{\\mathbf{C}^H(sk_i^S),pk_{\\rightarrow}^H}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{C}^H(sk_i^S),pk^H</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2: Storage</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{C}^S(m_i) = S.Enc(m_i,sk^S)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{c} \\mathbf{C}^S(m_i) \\\\ \\end{array}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{C}^S(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3: Evaluation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{C}^H(m_i)</span> <span class="math">=</span> <span class="math">H.Eval(S.Dec(\\mathbf{C}^S(m_i),\\mathbf{C}^H(sk_i^S),pk^H)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4: Computation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">f</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\xrightarrow{\\hspace*{1cm}} f</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{C}^H(f(m_i)) = H.Eval(f(\\mathbf{C}^H(m_i))</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5: Result</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{c}^H(f(m_i))</span> <span class="math">f(m_i) = H.Dec(\\mathbf{c}^H(f(m_i)),sk^H)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\leftarrow</span> <span class="math">\\mathbf{c}^H(f(m_i))</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{c}^H(f(m_i)) = H.Comp(\\mathbf{C}^H(f(m_i)))</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;<strong>Fig. 1.</strong> Homomorphic Encryption - Symmetric Encryption framework. H and S respectively refer to homomorphic and symmetric encryption schemes, for algorithms (e.g. H.KeyGen) or scheme components (e.g.  <span class="math">\\mathsf{sk}^S</span> ).</p>

    <p class="text-gray-300">before the noise growing too much forcing to use bootstrapping. Therefore, and in order to reduce the time and computational cost of the framework, it is important to manage the error growth during the homomorphic operations (<em>i.e.</em> steps 3 and 4). Furthermore, since the 4th step is the most important one from the application point-of-view (since this is where the useful operations are performed by the cloud), there is strong incentive to minimize the cost of the homomorphic decryption in the 3rd step.</p>

    <p class="text-gray-300"><strong>Previous works.</strong> In order to mitigate these bottlenecks, several works tried to reduce more and more the homomorphic cost of evaluating a symmetric decryption algorithm. First attempts in this direction, which were also used as benchmark for FHE implementations, used the AES for this purpose [GHS12, CLT14]. Various alternative schemes were also considered, all with error and sizes depending on the multiplicative depth of the symmetric encryption scheme, such as BGV [BGV12] and FV [FV12]. Additional optimizations exploited batching and bitslicing, leading to the best results of performing 120 AES decryptions in 4 minutes [GHS12].</p>

    <p class="text-gray-300">Since the multiplicative depth of the AES decryption evaluation was a restrictive bound in these works, other symmetric encryption schemes were then considered. The most representative attempts in this direction are the family of block ciphers LowMC [ARS&lt;sup&gt;+&lt;/sup&gt;15] and the stream cipher Kreyvium [CCF&lt;sup&gt;+&lt;/sup&gt;15]. These constructions led to reduced and more suitable multiplicative depths. Yet, and intuitively, these attempts were still limited by complementary drawbacks. First for LowMC, the remaining multiplicative depth</p>

    <p class="text-gray-300">remains large enough to significantly reduce the homomorphic capacity (<em>i.e.</em> increase the noise). Such a drawback seems to be inherent in block cipher structures where the iteration of rounds eventually leads to Boolean functions with large algebraic degree, which inevitably imply a constant per block but high noise after homomorphic evaluation. For example, ciphers dedicated to efficient masking against side-channel attacks <a href="#page-28-1">[PRC12,</a> <a href="#page-27-5">GLSV14,</a> <a href="#page-27-6">GGNS13]</a>, which share the goal of minimizing the multiplicative complexity, suffer from similar issues and it seems hard to break the barrier of one multiplication per round (and therefore of 12 to 16 multiplications for 128-bit ciphers). Second for Kreyvium, the error actually grows with the number of evaluated ciphertexts, which implies that at some point, the output ciphertexts are too noisy, and cannot be decrypted (which requires either to bootstrap or to re-initialize the stream cipher).</p>

    <p class="text-gray-300">Our contribution. In view of this state-of-the-art, a natural direction would be to try combining the best of these two previous works. That is, to design a cipher inheriting from the constant noise property offered by block ciphers, and the lower noise levels of stream ciphers (due to the lower algebraic degree of their outputs), leading to the following contributions.</p>

    <p class="text-gray-300">First, we introduce a new stream cipher construction, next denoted as a filter permutator (by analogy with filter generators). Its main design principle is to filter a constant key register with a variable (public) bit permutation. More precisely, at each cycle, the key register is (bit) permuted with a pseudorandomly generated permutation, and we apply a non-linear filtering function to the output of this permuted key register. The main advantage of this construction is to always apply the non-linear filtering directly on the key bits, which allows maintaining the noise level of our outputs constant. Conceptually, this type of construction seems appealing for any FHE scheme.</p>

    <p class="text-gray-300">Second, and going deeper in the specification of a concrete scheme, we discuss the optimization of the components in a filter permutator, with a focus on the filtering function (which determines the output noise after homomorphic evaluation). For this purpose, we first notice that existing FHE schemes can be split in (roughly) two main categories. On one hand the so-called <em>2nd-generation</em> FHE (such as <a href="#page-26-1">[BGV12,</a> <a href="#page-26-0">CLT14]</a>) where the metric for the noise growth is essentially the multiplicative depth of the circuit to homomorphically evaluate. On the other hand, the so-called <em>3rd-generation</em> FHE (such as <a href="#page-27-7">[GSW13,</a> <a href="#page-26-4">AP14]</a>) where the error growth is asymmetric, and in particular quasi-additive when considering a multiplicative chain. From these observations, we formalize a <em>comb</em> structure which can be represented as a (possibly long) multiplicative chain, in order to take the best advantage of 3rd-generation FHE schemes. We then design a filtering function based on this comb structure (combined with other technical ingredients in order to prevent various classes of possible attacks against stream ciphers) and specify a family of filter permutators (called FLIP ).</p>

    <p class="text-gray-300">Third, and in order to stimulate further investigations, we instantiate a few version of FLIP designs, for 80-bit and 128-bit security. We then provide a preliminary evaluation of their security against some of the prevailing cryptanalysis from the open literature – such as (fast) algebraic attacks, (fast) correlation attacks, BKW-like attacks <a href="#page-26-5">[BKW03]</a>, guess and determine attacks, <em>etc.</em> – based on state-of-the-art tools. We also analyze the noise brought by their filtering functions in the context of 3rd-generation FHE. In this respect, our main result is that we can limit the noise after the homomorphic evaluation of a decryption to a level of the same order of magnitude as for a single homomorphic multiplication - hence essentially making the impact of the symmetric encryption scheme as small as possible.</p>

    <p class="text-gray-300">We finally observe that our FLIP designs have a very reduced multiplicative depth, which makes them suitable for 2nd-generation FHE schemes as well, and provide preliminary results of prototype implementations using HElib that confirm their good behavior compared to state-of-the-art block and stream ciphers designed for efficient FHE.</p>

    <p class="text-gray-300">Overall, filter permutators in general and FLIP instances in particular open a large design space of new symmetric constructions to investigate. Hence, we conclude the paper with a list of open problems regarding these algorithms, their best cryptanalysis, the Boolean functions used in their filter and their efficient implementation if concrete applications.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2 Background</h3>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2.1 Boolean functions</h4>

    <p class="text-gray-300">In this section, we recall the cryptographic properties of Boolean functions that we will need in the rest of the paper (mostly taken from [Car10]).</p>

    <p class="text-gray-300"><strong>Definition 1</strong> (Boolean Function). A Boolean function f with n variables is a function from  <span class="math">\\mathbb{F}_2^n</span>  to  <span class="math">\\mathbb{F}_2</span> . The set of all Boolean functions in n variables is denoted by  <span class="math">\\mathcal{B}_n</span> .</p>

    <p class="text-gray-300"><strong>Definition 2</strong> (Walsh Transform). Let  <span class="math">f \\in \\mathcal{B}_n</span>  a Boolean function. Its Walsh Transform  <span class="math">W_f</span>  at  <span class="math">a \\in \\mathbb{F}_2^n</span>  is defined as:</p>

    <p class="text-gray-300"><span class="math">$W_{\\mathsf{f}}(a) = \\sum_{x \\in \\mathbb{F}_2^n} (-1)^{f(x) + \\langle a, x \\rangle},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\langle a, x \\rangle</span>  denotes the inner product in  <span class="math">\\mathbb{F}_2^n</span> .</p>

    <p class="text-gray-300"><strong>Definition 3</strong> (Balancedness). A Boolean function  <span class="math">f \\in \\mathcal{B}_n</span>  is said to be balanced if its outputs are uniformly distributed over  <span class="math">\\{0,1\\}</span> .</p>

    <p class="text-gray-300"><strong>Definition 4</strong> (Non-linearity). The non-linearity NL of a Boolean function  <span class="math">f \\in \\mathcal{B}_n</span> , where n is a positive integer, is the minimum Hamming distance between f and all the affine functions g:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{NL}(f) = \\min_{g} \\{ d_H(f, g) \\},</span>$</p>

    <p class="text-gray-300">with  <span class="math">d_H(f,g) = \\#\\{x \\in \\mathbb{F}_2^n \\mid f(x) \\neq g(x)\\}</span>  the Hamming distance between f and g. The non-linearity of a Boolean function can also be defined by its Walsh Transform:</p>

    <p class="text-gray-300"><span class="math">$NL(f) = 2^{n-1} - \\frac{1}{2} \\max_{a \\in \\mathbb{F}_2^n} |W_f(a)|.</span>$</p>

    <p class="text-gray-300"><strong>Definition 5</strong> (Resiliency). A Boolean function  <span class="math">f \\in \\mathcal{B}_n</span>  is said m-resilient if any of its restrictions obtained by fixing at most m of its coordinates is balanced. We will denote by res(f) the resiliency m of f and set res(f) = -1 if f is unbalanced.</p>

    <p class="text-gray-300"><strong>Definition 6 (Algebraic Immunity).</strong> The algebraic immunity of a Boolean function  <span class="math">f \\in \\mathcal{B}_n</span> , denoted as Al(f), is defined as:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{AI}(f) = \\min_{g \\neq 0} \\{ \\mathsf{deg}(g) \\mid fg = 0 \\text{ or } (f \\oplus 1)g = 0 \\},</span>$</p>

    <p class="text-gray-300">where deg(g) is the degree of g. The function g is called an annihilator of f (or  <span class="math">(f \\oplus 1)</span> ).</p>

    <p class="text-gray-300"><strong>Definition 7 (Fast Algebraic Immunity).</strong> The fast algebraic immunity of a Boolean function  <span class="math">f \\in \\mathcal{B}_n</span> , denoted as  <span class="math">\\mathsf{FAI}(f)</span> , is defined as:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{FAI}(f) = \\min\\{2\\mathsf{AI}(f), \\min_{\\substack{1 &lt; \\deg(q) &lt; \\mathsf{AI}(f)}} (\\max[\\deg(g) + \\deg(fg), 3\\deg(g)])\\}.</span>$</p>

    <p class="text-gray-300">Summarizing, the good balancedness, non-linearity and resiliency properties have to be ensured to widthstand correlation attacks [Sie85] and fast correlation attacks [MS88]. The high algebraic immunity and fast algebraic immunity have to be ensured to widthstand algebraic attacks [CT15].</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.2 (Ring) Learning With Errors</h3>

    <p class="text-gray-300">In this section, we recall useful notations and definitions needed about the decisional LWE problem and its ring variation. For an integer modulus q, we denote by  <span class="math">\\mathbb{Z}_q</span>  the quotient ring of integers modulo q. We denote vectors with bold letters  <span class="math">\\mathbf{e}</span>  and matrices with bold capital letters  <span class="math">\\mathbf{A}</span> . The notation  <span class="math">s \\leftarrow_{\\</span>} S$  (resp.  <span class="math">s \\leftarrow_{\\</span>} \\chi$ ) denotes that s is picked uniformly at random from a finite set S (resp. from a distribution  <span class="math">\\chi</span> ).</p>

    <p class="text-gray-300">The decisional Learning With Error problem (dLWE) was introduced by Regev [Reg05].</p>

    <p class="text-gray-300"><strong>Definition 8 (dLWE).</strong> For an integer  <span class="math">q = q(n) \\ge 2</span> , an adversary A and an error distribution  <span class="math">\\chi = \\chi(n)</span>  over  <span class="math">\\mathbb{Z}_q</span> , we define the following advantage function:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{dLWE}_{n,m,q,\\chi}}_{\\mathcal{A}} := |\\Pr[\\mathcal{A}(\\mathbf{A},\\mathbf{z}_0) = 1] - \\Pr[\\mathcal{A}(\\mathbf{A},\\mathbf{z}_1) = 1]|,</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A} \\leftarrow_{\\</span>} \\mathbb{Z}<em>q^{n \\times m}, \\mathbf{s} \\leftarrow</em>{$} \\mathbb{Z}<em>q^n, \\mathbf{e} \\leftarrow</em>{$} \\chi^m, \\mathbf{z}<em>0 := \\mathbf{s}^{\\mathsf{T}} \\mathbf{A} + \\mathbf{e}^{\\mathsf{T}} \\quad \\textit{and} \\quad \\mathbf{z}_1 \\leftarrow</em>{$} \\mathbb{Z}_q^m.$$</p>

    <p class="text-gray-300">The dLWE&lt;sub&gt; <span class="math">n,m,q,\\chi</span> &lt;/sub&gt; assumption asserts that for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the advantage  <span class="math">Adv_{\\mathcal{A}}^{dLWE_{n,m,q,\\chi}}</span>  is a negligible function in n.</p>

    <p class="text-gray-300">The ring variant was introduced by Lyubashevsky, Peikert and Regev in [LPR10].</p>

    <p class="text-gray-300"><strong>Definition 9</strong> (dR-LWE). For a polynomial ring  <span class="math">R = \\mathbb{Z}[X]/f(X)</span>  with f of degree n, an integer  <span class="math">q \\geq 2</span> , an adversary A and an error distribution  <span class="math">\\chi</span>  over  <span class="math">R_q = R/qR</span> ,  <span class="math">R^{\\vee}</span>  being R dual fractional ideal, we define the following advantage function:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}^{\\mathsf{d}R\\mathsf{LWE}_{R,q,\\chi}}_{\\mathcal{A}} := |\\Pr[\\mathcal{A}(a,z_0) = 1] - \\Pr[\\mathcal{A}(a,z_1) = 1]|,</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$a \\leftarrow_{\\</span>} R_q, \\ s \\leftarrow_{$} R_q^{\\lor}, \\ e \\leftarrow_{$} \\chi, \\ z_0 := a \\cdot s + e \\quad and \\quad z_1 \\leftarrow_{$} R \\ .$$</p>

    <p class="text-gray-300">With f(X) a cyclotomic polynomial, the  <span class="math">dRLWE_{R,q,\\chi}</span>  assumption asserts that for all PPT adversaries  <span class="math">\\mathcal{A}</span> , the advantage  <span class="math">Adv_{\\mathcal{A}}^{dRLWE_{R,q,\\chi}}</span>  is a negligible function in n.</p>

    <p class="text-gray-300">For our constructions, we need to take the distribution  <span class="math">\\chi</span>  as a subgaussian random variable which we define hereafter. More details about the subgaussian distribution and the lemmas' proof can be found in [AP14, Ver10].</p>

    <p class="text-gray-300"><strong>Definition 10</strong> (Subgaussian Random Variables). Let X be a random variable. We say X is subgaussian with parameter  <span class="math">\\sigma</span>  if there exists  <span class="math">\\sigma</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\forall t \\in \\mathbb{R}, \\mathbb{E}[e^{tX}] \\le e^{\\sigma^2 t^2/2},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbb{E}[e^{tX}]</span>  is the moment generating function of X.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> (Subgaussian Random Variables properties). Let X, X' be independent subgaussian random variables of parameter  <span class="math">\\sigma</span>  and  <span class="math">\\sigma&#x27;</span>  respectively. Assuming  <span class="math">\\mathbb{E}(X) = \\mathbb{E}(X&#x27;) = 0</span>  we have the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Tails:  <span class="math">\\forall t \\geq 0</span>  we have  <span class="math">Pr[|X| \\geq t] \\leq 2e^{-\\pi t^2/\\sigma^2}</span> .</li>
      <li>Homogeneity:  <span class="math">\\forall c \\in \\mathbb{R}</span> , cX is subgaussian with parameter  <span class="math">|c|\\sigma</span> .</li>
      <li>Pythagorean additivity: X + X' is subgaussian with parameter  <span class="math">\\sqrt{\\sigma^2 + {\\sigma&#x27;}^2}</span> .</li>
    </ul>

    <p class="text-gray-300">We extend the notion of subgaussianity to vectors and polynomials. Since the coefficients of a polynomial are seen as a vector, we call subgaussian vector of parameter  <span class="math">\\sigma</span>  a vector where each coefficient follows an independent subgaussian distribution with parameter  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;Lemma 2 (Subgaussian Vector Norm, adapted from [AP14], Lemma 2.1). Let  <span class="math">\\mathbf{x} \\in \\mathbb{R}^n</span>  be a random vector where each coordinates follows an independent subgaussian distribution of parameter  <span class="math">\\sigma</span> . Then for some universal constant C &gt; 0 we have  <span class="math">Pr[||\\mathbf{x}||_2 &gt; C\\sigma\\sqrt{n}] \\leq 2^{-\\Omega(n)}</span>  and therefore  <span class="math">||\\mathbf{x}||_2 = \\mathcal{O}(\\sigma\\sqrt{n})</span> .</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.3 Fully Homomorphic Encryption</h3>

    <p class="text-gray-300">In this section we recall the definition of (Fully) Homomorphic Encryption and present the Homomorphic Encryption schemes we will use, both based on GSW [GSW13].</p>

    <p class="text-gray-300"><strong>Definition 11</strong> (Homomorphic Encryption Scheme). Let  <span class="math">\\mathcal{M}</span>  be the plaintext space,  <span class="math">\\mathcal{C}</span>  the ciphertext space and  <span class="math">\\lambda</span>  the security parameter. A homomorphic encryption scheme consists of four algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H.Key <span class="math">Gen(1^{\\lambda})</span> . Output  <span class="math">pk^H</span>  and  <span class="math">sk^H</span>  the public and secret keys of the scheme.</li>
      <li><span class="math">H.\\mathsf{Enc}(m, \\mathsf{pk}^H)</span> . From the plaintext  <span class="math">m \\in \\mathcal{M}</span>  and the public key, output a ciphertext  <span class="math">c \\in \\mathcal{C}</span> .</li>
      <li><span class="math">H.\\mathsf{Dec}(c,\\mathsf{sk}^H)</span> . From the ciphertext  <span class="math">c\\in\\mathcal{C}</span>  and the secret key, output  <span class="math">m&#x27;\\in\\mathcal{M}</span> .</li>
      <li><span class="math">H.\\mathsf{Eval}(f, c_1, \\cdots, c_k, \\mathsf{pk}^H)</span> . With  <span class="math">c_i = H.\\mathsf{Enc}(m_i, \\mathsf{pk}^H)</span>  for  <span class="math">1 \\le i \\le k</span> , output a ciphertext  <span class="math">c_f \\in \\mathcal{C}</span>  such that  <span class="math">H.\\mathsf{Dec}(c_f) = f(m_1, \\cdots, m_k)</span> .</li>
    </ul>

    <p class="text-gray-300">A homomorphic encryption scheme is called a Fully Homomorphic Encryption (FHE) scheme when f can be any function and  <span class="math">|\\mathcal{C}|</span>  is finite. A simpler primitive to consider is the SomeWhat Homomorphic Encryption (SWHE) scheme, where f is restricted to be any univariate polynomial of finite degree.</p>

    <p class="text-gray-300">Since the breakthrough work of Gentry [Gen09], the only known way to obtain FHE consists in adding a bootstrapping technique to a SWHE. As bootstrapping computational cost is still expensive in comparison to the other FHE algorithms, in the following part of the article we will only consider SWHE for our applications.</p>

    <p class="text-gray-300"><strong>GSW Homomorphic Encryption Scheme.</strong> In 2013, Gentry, Sahai and Waters [GSW13] introduced a Homomorphic Encryption scheme based on LWE using a new technique stemming from the <em>approximate eigenvector problem</em>. This new technique led to a new family of FHE, called 3rd-generation FHE, consisting in Homomorphic Encryption schemes such that the multiplicative error growth is quasi-additive. Hereafter, we present two schemes belonging to this generation, the first one with security based on dLWE and the second one based on dRLWE. We first set some useful notations considering the different schemes.</p>

    <p class="text-gray-300">For a matrix  <span class="math">\\mathbf E</span>  we refer to the i-th row as  <span class="math">\\mathbf e_i^{\\!\\!\\top}</span>  and to the j-th column as  <span class="math">\\mathbf e_j</span> . The  <span class="math">\\log q</span>  notation refers to the logarithm in base 2 of q. The notation  <span class="math">[a]_q</span>  is for  <span class="math">a \\mod q</span>  and  <span class="math">\\lfloor [a]_q \\rceil_2 \\in \\{0,1\\}</span>  is a function in  <span class="math">a \\in \\mathbb Z_q</span>  giving 1 if  <span class="math">\\lfloor \\frac{q}{4} \\rfloor \\leq a \\leq \\lfloor \\frac{3q}{4} \\rfloor \\mod q</span>  and 0 otherwise. We denote by [n] the set of integers  <span class="math">\\{1,\\cdots,n\\}</span> . We finally use |x| and  <span class="math">||x||_2</span>  for the standard norms 1 and 2 on vectors  <span class="math">x \\in \\mathbb R^n</span> .</p>

    <p class="text-gray-300"><strong>Batched GSW.</strong> This scheme is a batched version of GSW presented in [HAO15], enabling to pack independently r plaintexts in one ciphertext. From the security parameter  <span class="math">\\lambda</span>  and the considered applications, we can derive the parameters  <span class="math">n, q, r, \\chi</span>  of the scheme described below.</p>

    <p class="text-gray-300"><span class="math">H.\\mathsf{KeyGen}(n,q,r,\\chi).</span>  On inputs the lattice dimension n, the modulus q, the number of bits by ciphertext r and the error distribution  <span class="math">\\chi</span>  do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Set
<span class="math">$\\ell = \\lceil \\log q \\rceil</span>$
,  <span class="math">m = \\mathcal{O}(n\\ell)</span> ,  <span class="math">N = (r+n)\\ell</span> ,  <span class="math">\\mathcal{M} = \\{0,1\\}^r</span>  and  <span class="math">\\mathcal{C} = \\mathbb{Z}_q^{(r+n)\\times N}</span> .</p></li>
      <li><p class="text-gray-300">Pick
<span class="math">$\\mathbf{A} \\leftarrow_{\\</span>} \\mathbb{Z}<em>q^{n \\times m}$$
,  $\\mathbf{S}' \\leftarrow</em>{$} \\chi^{r \\times n}$  and  <span class="math">\\mathbf{E} \\leftarrow_{\\</span>} \\chi^{r \\times m}$ .</p></li>
      <li><p class="text-gray-300">Set
<span class="math">$\\mathbf{S} = [\\mathbf{I}| - \\mathbf{S}&#x27;] \\in \\mathbb{Z}_q^{r \\times (r+n)}</span>$
and  <span class="math">\\mathbf{B} = \\left[ \\frac{\\mathbf{S}&#x27;\\mathbf{A} + \\mathbf{E}}{\\mathbf{A}} \\right]_q \\in \\mathbb{Z}_q^{(r+n) \\times m}</span> .</p></li>
    </ul>

    <p class="text-gray-300">– For all  <span class="math">\\mathbf{m} \\in \\{0,1\\}^r</span> :</p>

    <p class="text-gray-300">• Pick
<span class="math">$\\mathbf{R_m} \\leftarrow_{\\</span>} {0,1}^{m \\times N}$$
.</p>

    <p class="text-gray-300">• Set
<span class="math">$\\mathbf{P_m} = \\begin{bmatrix} \\mathbf{BR_m} + \\begin{pmatrix} \\frac{m_1 \\cdot \\mathbf{s}_1^{\\mathsf{T}}}{\\vdots} \\\\ \\frac{m_r \\cdot \\mathbf{s}_r^{\\mathsf{T}}}{0} \\end{bmatrix} \\mathbf{G} \\end{bmatrix}_q \\in \\mathbb{Z}_q^{(r+n) \\times N}.</span>$</p>

    <p class="text-gray-300">with  <span class="math">\\mathbf{s}_i^{\\! {\\scriptscriptstyle \\mathsf{T}}}</span>  the i-th row of  <span class="math">\\mathbf{S}</span>  and  <span class="math">\\mathbf{G} = (2^0, \\cdots, 2^{\\ell-1})^{\\! {\\scriptscriptstyle \\mathsf{T}}} \\otimes \\mathbf{I} \\in \\mathbb{Z}_q^{(r+n) \\times N}</span> .</p>

    <p class="text-gray-300">– Output  <span class="math">pk^H := (\\{\\mathbf{P_m}\\}, \\mathbf{B})</span>  and  <span class="math">sk^H := \\mathbf{S}</span> .</p>

    <p class="text-gray-300"><span class="math">H.\\mathsf{Enc}(\\mathsf{pk}^H,\\mathbf{m}).</span>  On input  <span class="math">\\mathsf{pk}^H,</span>  and  <span class="math">\\mathbf{m} \\in \\{0,1\\}^r,</span>  do:</p>

    <p class="text-gray-300">– Pick
<span class="math">$\\mathbf{R} \\leftarrow_{\\</span>} {0,1}^{m \\times N}$$
, and output  <span class="math">\\mathbf{C} = [\\mathbf{B}\\mathbf{R} + \\mathbf{P_m}]_q \\in \\mathbb{Z}_q^{(r+n) \\times N}</span> .</p>

    <p class="text-gray-300"><span class="math">H.\\mathsf{Dec}(\\mathbf{C},\\mathsf{sk}^H).</span>  On input the secret key  <span class="math">\\mathsf{sk}^H,</span>  and a ciphertext  <span class="math">\\mathbf{C},</span>  do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For all  <span class="math">i \\in [r]: m_i&#x27; = \\lfloor [\\langle \\mathbf{s}_i^{\\mathsf{\\scriptscriptstyle T}}, \\mathbf{c}_{i\\ell} \\rangle]_q \\rceil_2</span>  where  <span class="math">\\mathbf{c}_{il}</span>  is the column  <span class="math">i\\ell</span>  of  <span class="math">\\mathbf{C}</span> .</li>
      <li>Output  <span class="math">m&#x27;_1, \\dots, m&#x27;_r \\in \\{0, 1\\}^r</span> .</li>
    </ul>

    <p class="text-gray-300">Note that
<span class="math">$\\mathbf{SC} = \\mathbf{SBR} + \\mathbf{SP_m} = \\mathbf{ER} + \\mathbf{ER_m} + \\left( \\frac{\\underline{m_1 \\cdot \\mathbf{s}_1^{\\mathsf{T}}}}{\\vdots \\underline{m_r \\cdot \\mathbf{s}_r^{\\mathsf{T}}}} \\right) \\mathbf{G} = \\mathbf{E}&#x27; + \\left( \\frac{\\underline{m_1 \\cdot \\mathbf{s}_1^{\\mathsf{T}}}}{\\vdots \\underline{m_r \\cdot \\mathbf{s}_r^{\\mathsf{T}}}} \\right) \\mathbf{G}.</span>$</p>

    <p class="text-gray-300">The H.Eval algorithm finally consists in iterating, following a circuit f, the homomorphic operations H.Add and H.Mul:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">H.Add(C_1, C_2) : C_+ = C_1 + C_2.</span></li>
      <li><span class="math">H.\\mathsf{Mul}(\\mathbf{C}_1, \\mathbf{C}_2) : \\mathbf{C}_{\\times} = \\mathbf{C}_1 \\times \\mathbf{G}^{-1}\\mathbf{C}_2</span>  with  <span class="math">\\mathbf{G}^{-1}</span>  a function such that  <span class="math">\\forall \\mathbf{C} \\in \\mathbb{Z}_q^{(r+n)\\times N}, \\mathbf{G}\\mathbf{G}^{-1}(\\mathbf{C}) = \\mathbf{C}</span>  and the values of  <span class="math">\\mathbf{G}^{-1}(\\mathbf{C})</span>  follow a subgaussian distribution with parameter  <span class="math">\\mathcal{O}(1)</span>  (see [MP12] for the existence and proof of  <span class="math">\\mathbf{G}^{-1}</span> ).</li>
    </ul>

    <p class="text-gray-300">The correctness and security of this scheme are proven in Appendix A.</p>

    <p class="text-gray-300">Remark 1. For practical use, we only need to store r+1 matrices  <span class="math">\\mathbf{P}_m</span> , namely the r+1 ones with  <span class="math">\\mathbf{m}</span>  of hamming weight equal to 0 or 1 are sufficient to generate correct encryption of all  <span class="math">\\mathbf{m} \\in \\{0,1\\}^r</span>  with at most r additions of the corresponding  <span class="math">\\mathbf{P}_m</span>  matrices.</p>

    <p class="text-gray-300"><strong>Ring-GSW</strong> This scheme is a ring version of GSW presented in [KGV14], transposing the <em>approximate</em> eigenvector problem into the ring setting. From  <span class="math">\\lambda</span>  the security parameter and the considered applications, we can derive the parameters n, q and  <span class="math">\\mathcal{M}</span>  of the scheme described below.</p>

    <p class="text-gray-300">H.KeyGen <span class="math">(n, q, \\chi, \\mathcal{M})</span> . On inputs the lattice dimension n, which is set to a power of 2, the modulus q, the error distribution  <span class="math">\\chi</span>  and the plaintext space  <span class="math">\\mathcal{M}</span>  do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set  <span class="math">R = \\mathbb{Z}[X]/(X^n + 1)</span> ,  <span class="math">R_q = R/qR</span> ,  <span class="math">\\ell = \\lceil \\log q \\rceil</span> ,  <span class="math">N = 2\\ell</span>  and  <span class="math">\\mathcal{C} = R_q^{2 \\times N}</span> .</li>
      <li>Set  <span class="math">R_{0,1} = \\{ P \\in R_q, p_i \\in \\{0,1\\}, 0 \\le i &lt; n \\}.</span></li>
      <li>Pick  <span class="math">a \\leftarrow_{\\</span>} R_q, s' \\leftarrow_{$} \\chi$  and  <span class="math">e \\leftarrow_{\\</span>} \\chi$ .</li>
      <li><span class="math">\\textbf{-} \\ \\operatorname{Set} \\mathbf{s} = [1|-s&#x27;]^{\\!\\top} \\in R_q^{1 \\times 2} \\ \\text{and} \\ \\mathbf{b} = \\left(\\!\\frac{s&#x27;a+e}{a}\\!\\right) \\in R_q^{2 \\times 1} \\ .</span></li>
      <li>Output  <span class="math">pk^H := b</span>  and  <span class="math">sk^H := s</span> .</li>
    </ul>

    <p class="text-gray-300"><span class="math">H.\\mathsf{Enc}(\\mathsf{pk}^H, m).</span>  On input  <span class="math">\\mathsf{pk}^H,</span>  and  <span class="math">m \\in \\mathcal{M},</span>  do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pick  <span class="math">\\mathbf{E} \\leftarrow_{\\</span>} \\chi^{2 \\times N}$ .</li>
      <li>Pick  <span class="math">\\mathbf{r} \\leftarrow_\\</span> R_{0,1}^N$ , and output  <span class="math">\\mathbf{C} = [\\mathbf{b}\\mathbf{r}^{\\scriptscriptstyle \\top} + m\\mathbf{G} + \\mathbf{E}]_q \\in R_q^{2 \\times N}</span>  .</li>
    </ul>

    <p class="text-gray-300"><span class="math">H.\\mathsf{Dec}(\\mathbf{C},\\mathsf{sk}^H)</span> . On input the secret key  <span class="math">\\mathsf{sk}^H</span> , and a ciphertext  <span class="math">\\mathbf{C}</span> , do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">m&#x27; = \\lfloor [\\langle \\mathbf{s}, \\mathbf{c}_l \\rangle]_a \\rceil_2</span> .</li>
      <li>Output  <span class="math">m&#x27; \\in R_q</span> .</li>
    </ul>

    <p class="text-gray-300">The  <span class="math">H.\\mathsf{Eval}</span>  algorithm finally consists in iterating  <span class="math">H.\\mathsf{Add}</span>  and  <span class="math">H.\\mathsf{Mul}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">H.\\mathsf{Add}(\\mathbf{C}_1,\\mathbf{C}_2):\\mathbf{C}_+=\\mathbf{C}_1+\\mathbf{C}_2.</span></li>
      <li><span class="math">H.\\mathsf{Mul}(\\mathbf{C}_1, \\mathbf{C}_2) : \\mathbf{C}_{\\times} = \\mathbf{C}_1 \\times \\mathbf{G}^{-1}\\mathbf{C}_2.</span></li>
    </ul>

    <p class="text-gray-300">The correctness and security of this scheme are proven in Appendix B.</p>

    <p class="text-gray-300">Remark 2. The plaintext space  <span class="math">\\mathcal{M}</span>  has a major influence on the considered application in terms of quantity of information contained in a single ciphertext and error growth. For our application we choose  <span class="math">\\mathcal{M}</span>  as the set of polynomials with all coefficients of degree greater than 0 being zero, and the constant coefficient being bounded.</p>

    <p class="text-gray-300">    <img src="_page_9_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. Filter permutator construction.</p>

    <h2 id="sec-6" class="text-2xl font-bold">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;3 New stream cipher constructions</h2>

    <p class="text-gray-300">In this section, we introduce our new stream cipher construction. We first describe the general filter permutator structure. Next we list a number of Boolean building blocks together with their necessary cryptographic properties. Third, we specify a family of filter permutators (denoted as FLIP) and analyze its security based on state-of-the art cryptanalysis and design tools. Finally, we propose a couple of parameters to fully instantiate a few examples of FLIP designs.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;3.1 Filter permutators</h4>

    <p class="text-gray-300">The general structure of filter permutators is depicted in Figure <a href="#page-9-0">2.</a> It is composed of three parts: a register where the key is stored, a (bit) permutation generator parametrised by a Pseudo Random Number Generator (PRNG) <a href="#page-26-8">[BM84,</a> <a href="#page-27-9">KL07]</a> (which is initialized with a public IV), and a filtering function which generates a keystream. The filter permutator can be compared to a filter generator, in which the LFSR is replaced by a permuted key register. In other words, the register is no longer updated by means of the LFSR, but with pseudorandom bit permutations. More precisely, at each cycle (<em>i.e.</em> each time the filtering function outputs a bit), a pseudo-random permutation is applied to the register and the permuted key register is filtered. Eventually, the encryption (<em>resp.</em> decryption) with a filter permutator simply consists in XORing the bits output by the filtering function with those of the plaintext (<em>resp.</em> ciphertext).</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.2 Boolean building blocks for the filter permutator</h4>

    <p class="text-gray-300">We will first exploit direct sums of Boolean functions defined as follows:</p>

    <p class="text-gray-300">Definition 12 (Direct Sum). <em>Let</em> f1(x0, · · · , xn1−1) <em>and</em> f2(xn&lt;sup&gt;1&lt;/sup&gt; , · · · , xn1+n2−1) <em>be two Boolean functions in respectively</em> n&lt;sup&gt;1&lt;/sup&gt; <em>and</em> n&lt;sup&gt;2&lt;/sup&gt; <em>variables. The direct sum of</em> f&lt;sup&gt;1&lt;/sup&gt; <em>and</em> f&lt;sup&gt;2&lt;/sup&gt; <em>is defined as</em> f = f&lt;sup&gt;1&lt;/sup&gt; ⊕ f2<em>, which is a</em> <em>Boolean function in</em> n&lt;sup&gt;1&lt;/sup&gt; + n&lt;sup&gt;2&lt;/sup&gt; <em>variables such that:</em></p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-2&quot;&gt;&lt;/span&gt;
<span class="math">$f(x_0, \\dots, x_{n_1+n_2-1}) = f_1(x_0, \\dots, x_{n_1-1}) \\oplus f_2(x_{n_1}, \\dots, x_{n_1+n_2-1}).</span>$</p>

    <p class="text-gray-300">They inherit from the following set of properties, proven in Appendix <a href="#page-29-1">C.1.</a></p>

    <p class="text-gray-300">Lemma 3 (Direct sum properties). <em>Let</em> f <em>be the direct sum of</em> f&lt;sup&gt;1&lt;/sup&gt; <em>and</em> f&lt;sup&gt;2&lt;/sup&gt; <em>with</em> n&lt;sup&gt;1&lt;/sup&gt; <em>and</em> n&lt;sup&gt;2&lt;/sup&gt; <em>variables respectively. Then</em> f <em>has the following cryptographic properties:</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>1. Non Linearity:</em> NL(f) = 2n2NL(f1) + 2n1NL(f2) − 2NL(f1)NL(f2)<em>.</em></li>
      <li><em>2. Resiliency:</em> res(f) = res(f1) + res(f2) + 1<em>.</em></li>
      <li><em>3. Algebraic Immunity:</em> AI(f1) + AI(f2) ≥ AI(f) ≥ max(AI(f1), AI(f2))<em>.</em></li>
      <li><em>4. Fast Algebraic Immunity:</em> FAI(f) ≥ max(FAI(f1), FAI(f2))<em>.</em></li>
    </ul>

    <p class="text-gray-300">Our direct sums will then be based on three parts: a linear function, a quadratic function and triangular functions, defined as follows.</p>

    <p class="text-gray-300">Definition 13 (Linear functions). <em>Let</em> n &gt; 0 <em>be a positive integer, the</em> L&lt;sup&gt;n&lt;/sup&gt; <em>linear function is a</em> n<em>-variable Boolean function defined as:</em></p>

    <p class="text-gray-300"><span class="math">$L_n(x_0, \\dots, x_{n-1}) = \\sum_{i=0}^{n-1} x_i.</span>$</p>

    <p class="text-gray-300">Definition 14 (Quadratic functions). <em>Let</em> n &gt; 0 <em>be a positive integer, the</em> Q&lt;sup&gt;n&lt;/sup&gt; <em>linear function is a</em> 2n<em>variable Boolean function defined as:</em></p>

    <p class="text-gray-300"><span class="math">$Q_n(x_0, \\dots, x_{2n-1}) = \\sum_{i=0}^{n-1} x_{2i} x_{2i+1}.</span>$</p>

    <p class="text-gray-300">Definition 15 (Triangular functions). <em>Let</em> k &gt; 0 <em>be a positive integer. The</em> k<em>-th triangular function</em> T&lt;sup&gt;k&lt;/sup&gt; <em>is a</em> k(k+1) 2 <em>-variable Boolean function defined as:</em></p>

    <p class="text-gray-300"><span class="math">$T_k(x_0, \\cdots, x_{\\frac{k(k+1)}{2}-1}) = \\sum_{i=1}^k \\prod_{j=0}^{i-1} x_{j+\\sum_{\\ell=0}^{i-1} \\ell}.</span>$</p>

    <p class="text-gray-300">For example, the 4th triangular function T&lt;sup&gt;4&lt;/sup&gt; is:</p>

    <p class="text-gray-300"><span class="math">$T_4 = x_0 \\oplus x_1 x_2 \\oplus x_3 x_4 x_5 \\oplus x_6 x_7 x_8 x_9.</span>$</p>

    <p class="text-gray-300">These three types of functions allow us to guarantee the following properties.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;Lemma 4 (Linear functions properties). <em>Let</em> L&lt;sup&gt;n&lt;/sup&gt; <em>be a linear function in</em> n <em>variables, then</em> L&lt;sup&gt;n&lt;/sup&gt; <em>has the following cryptographic properties:</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>1. Non Linearity:</em> NL(Ln) = 0<em>.</em></li>
      <li><em>2. Resiliency:</em> res(Ln) = n − 1<em>.</em></li>
      <li><em>3. Algebraic Immunity:</em> AI(Ln) = 1<em>.</em></li>
      <li>&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;<em>4. Fast Algebraic Immunity:</em> FAI(Ln) = 2<em>.</em></li>
    </ul>

    <p class="text-gray-300"><strong>Lemma 5</strong> (Quadratic functions properties). Let  <span class="math">Q_n</span>  be a linear function in 2n variables, then  <span class="math">Q_n</span>  has the following cryptographic properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Non Linearity:  <span class="math">NL(Q_n) = 2^{2n-1} 2^{n-1}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Resiliency:  <span class="math">res(Q_n) = -1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Algebraic Immunity:  <span class="math">AI(Q_1) = 1</span>  and  <span class="math">\\forall n &gt; 1</span> ,  <span class="math">AI(Q_n) = 2</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Fast Algebraic Immunity:  <span class="math">\\mathsf{FAI}(Q_1) = 2</span>  and  <span class="math">\\forall n &gt; 1</span> ,  <span class="math">\\mathsf{FAI}(Q_n) = 4</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;<strong>Lemma 6</strong> (Triangular functions properties). Let k a positive integer and let  <span class="math">T_k</span>  the k-th triangular function. Then the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Non Linearity follows the recursive formula defined as:</li>
    </ol>

    <p class="text-gray-300">(i)
<span class="math">$NL(T_1 = 0)</span>$
,
(ii)  <span class="math">NL(T_{k+1}) = (2^{k+1} - 2)NL(T_k) + 2^{k(k+1)/2}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Resiliency:  <span class="math">res(T_k) = 0</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Algebraic Immunity:  <span class="math">AI(T_k) = k</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Fast Algebraic Immunity:  <span class="math">FAI(T_k) = k + 1</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The proof of Lemma 6 can be found in Appendix C.2 (Lemmas 4 and 5 are standard).</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;3.3 The FLIP family of stream ciphers</h3>

    <p class="text-gray-300">Based on the previous definitions, we specify the FLIP family of stream ciphers as a filter permutator using a forward secure PRNG [BY01] based on the AES-128 (e.g. as instantiated in the context of leakage-resilient cryptography [SPY13]), the Knuth shuffle (see below) as bit permutation generator and such that the filter F is the N-variable Boolean function defined by the direct sum of three Boolean functions  <span class="math">f_1</span> ,  <span class="math">f_2</span>  and  <span class="math">f_3</span>  of respectively  <span class="math">n_1</span> ,  <span class="math">n_2</span>  and  <span class="math">n_3</span>  variables, such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1(x_0, \\cdots, x_{n_1-1}) = L_{n_1},</span> -  <span class="math">f_2(x_{n_1}, \\cdots, x_{n_1+n_2-1}) = Q_{n_2/2},</span></li>
      <li><span class="math">f_3(x_{n_1+n_2}, \\dots, x_{n_1+n_2+n_3-1})</span>  is the direct sum of nb triangular function  <span class="math">T_k</span> , <em>i.e.</em> such that each  <span class="math">T_k</span>  acts on different and independent variables, that we denote as  <span class="math">nb \\Delta^k</span> .</li>
    </ul>

    <p class="text-gray-300">That is, we have  <span class="math">F: \\mathbb{F}_2^{n_1+n_2+n_3} \\to \\mathbb{F}_2</span>  the Boolean function such that:</p>

    <p class="text-gray-300"><span class="math">$F(x_0, \\dots, x_{n_1+n_2+n_3-1}) = L_{n_1} \\oplus Q_{n_2/2} \\oplus \\bigoplus_{i=1}^{nb} T_k.</span>$</p>

    <p class="text-gray-300">In the following section, we provide a preliminary security analysis of the FLIP filter permutators against a couple of standard attacks against stream ciphers, based on state-of-the-art tools. For this purpose, we will assume that no additional weaknesses arise from its PRNG and bit permutation generator. In this respect, we note that our forward secure PRNG does not allow malleability, so it should be hard to obtain a collision in the chosen IV model better than with birthday probability. This should prevent collisions on the generated permutations. Besides, the Knuth shuffle [Knu69] (or Fisher-Yates shuffle) is an algorithm allowing to generate a random permutation on a finite set. This algorithm has the interesting property of giving the same probability to all permutations if used with a random number generator. As a result, we</p>

    <p class="text-gray-300">expect that any deviation between a bit permutation based on a Knuth shuffle fed with the PRNG will be hard to exploit by an adversary. Our motivation for this assumption is twofold. First, it allows us to focus on whether the filter permutator construction is theoretically sound. Second, if such a choice was leading to an exploitable weakness, it remains possible to build a pseudorandom permutation based on standard cryptographic constructions [LR88].</p>

    <p class="text-gray-300">Remark 3. Since the permutation generation part of FLIP has only birthday security (with respect to the size of the PRNG), it implies that it is only secure up to  <span class="math">2^{64}</span>  PRNG outputs when implemented with the AES-128. Generating more keystream using larger block ciphers should be feasible. However, in view of the novelty of the FLIP instances, our claims are only made for this limited (birthday) data complexity so far, which should not be limiting for the intended FHE applications. We leave the investigation of their security against attacks using larger data complexities as a scope for further research. Besides, we note that using a PRNG based on a tweakable block cipher [LRW11] (where a part of the larger IV would be used as tweak) could be an interesting track to reduce the impact of a collision on the PRNG output in the known IV model, which we also leave as an open research direction.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;3.4 Security analysis</h4>

    <p class="text-gray-300">Since the filter permutator shares similarities with a filter generator, it is natural to start our investigations with the typical attacks considered against such types of stream ciphers. For this purpose, we next study the applicability of algebraic attacks and correlation attacks, together with more specialized cryptanalyses that have been considered against stream ciphers. Note that the attacks considered in the rest of this section frequently require to solve systems of equations and to implement a Gaussian reduction. Our complexity estimations will consider Strassen's algorithm for this purpose and assume  <span class="math">\\omega = \\log 7</span>  to be the exponent in a Gaussian reduction. Admittedly, approaches based on Gröbner bases [Fau99] or taking advantage of the sparsity of the matrices [Wie86] could lead to even faster algorithms. We ignore them for simplicity in these preliminary investigations. Note also that we only claim security in the single-key setting.</p>

    <p class="text-gray-300"><strong>Algebraic Attacks</strong> were first introduced by Courtois and Meier in [CM03] and applied to the stream cipher Toyocrypt. Their main idea is to build an over-defined system of equations with the initial state of the LFSR as unknown, and to solve this system with Gaussian elimination. More precisely, by using a nonzero function g such that both g and h=gF have low algebraic degree, an adversary is able to obtain T equations with monomials of degree at most AI(f). It is easily shown that g can be taken equal to the annihilator of F or of  <span class="math">F\\oplus 1</span> , i.e. such that gF=0 or  <span class="math">g(F\\oplus 1)=0</span> . After a linearisation step, the adversary obtains a system of T equations in  <span class="math">D=\\sum_{i=0}^{\\operatorname{AI}(F)} \\binom{N}{i}</span>  variables. Therefore, the time complexity of the algebraic attack is  <span class="math">\\mathcal{O}(D^\\omega)</span> , that is,  <span class="math">\\mathcal{O}(N^{\\omega AI(f)})</span> .</p>

    <p class="text-gray-300">Fast Algebraic Attacks are a variation of the previous algebraic attacks introduced by Courtois at Crypto 2003 [Cou03]. Considering the relation gF = h, their goal is to find and use functions g of low algebraic degree e, possibly smaller than AI(f), and h of low but possibly larger degree d, and to lower the degree of the resulting equations by an off-line elimination of the monomials of degrees larger than e (several equations being needed to obtain each one with degree at most e). Following [ACG&lt;sup&gt;+&lt;/sup&gt;06], this attack can be decomposed into four steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The search of the polynomials g and h generating a system of D + E equations in D + E unknowns, where  <span class="math">D = \\sum_{i=0}^{d} \\binom{N}{i}</span>  and  <span class="math">E = \\sum_{i=0}^{e} \\binom{N}{i}</span> . This step has a time complexity in  <span class="math">\\mathcal{O}(\\sum_{i=0}^{d} \\binom{n}{i})</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The search of linear relations which allows the suppression of the monomials of degree more than e. This step has a time complexity in  <span class="math">\\mathcal{O}(D \\log^2(D))</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The elimination of monomials of degree larger than e using the Berlekamp-Massey algorithm. This step has a time complexity in  <span class="math">\\mathcal{O}(ED \\log(D))</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The resolution of the system. This step has a time complexity in  <span class="math">\\mathcal{O}(E^{\\omega})</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Given the FAI of F, the time complexity of this attack is in  <span class="math">\\mathcal{O}(N^{\\text{FAI}})</span> , or more precisely  <span class="math">O(D \\log^2 D +</span>  <span class="math">E^2D + E^{\\omega}</span> ) (ignoring Step 1 which is trivial for our choice of F).</p>

    <p class="text-gray-300"><strong>Correlation Attacks.</strong> In their basic versions, correlation attacks try to distinguish the output sequence of a stream cipher from a random one, by exploiting the bias  <span class="math">\\delta</span>  of the filtering function. We can easily rule out such attacks by considering a (much) simplified version of filter permutator where the bit permutations  <span class="math">P_i</span> 's would be made on two independent permutations  <span class="math">P_i^1</span>  and  <span class="math">P_i^{2,3}</span>  (respectively acting on the  <span class="math">n_1 + 1</span>  bits of the linear part and the  <span class="math">n_2 + n_3 - 1</span>  bits of the non-linear part of F). Suppose for simplicity that  <span class="math">P_i^1</span>  is kept constant t times, then the output distribution of F has a bias  <span class="math">\\delta</span>  and it can be distinguished for the right choice of the  <span class="math">n_1 + 1 = res + 1</span>  bits of the linear part. In this case, a correlation attack would have a data</p>

    <p class="text-gray-300">complexity of  <span class="math">\\mathcal{O}(\\delta^{-2})</span>  and a time complexity of  <span class="math">\\mathcal{O}(2^{\\mathsf{res}(F)+1}\\delta^{-2})</span> , with  <span class="math">\\delta = \\frac{1}{2} - \\left(\\frac{\\mathsf{NL}(F)}{2^N}\\right)</span> . For simplicity,</p>

    <p class="text-gray-300">we will consider this conservative estimation in our following selection of security parameters. Yet, we note that since the permutation  <span class="math">P_i</span>  of a filter permutator is acting on all the N bits of the filter F, the probability that the linear part of F is kept invariant by the permutations t times is in fact considerably smaller than what is predicted by the resilience.</p>

    <p class="text-gray-300"><strong>BKW-like Attack.</strong> The BKW algorithm was introduced in [BKW03] as a solution to solve the LPN problem using smart combinations of well chosen vectors and their associated bias. Intuitively, our stream cipher construction simplified as just explained (with two independent permutations  <span class="math">P_i^1</span>  and  <span class="math">P_i^{2,3}</span>  rather than a single one  <span class="math">P_i</span> ) also shares similarities with this problem. Indeed, we could see the linear part as the parity of an LPN problem and the non-linear one (with a small bias) as a (large) noise. Adapting the BKW algorithm to our setting amounts to XOR some linear parts of F in order to obtain vectors of low Hamming weight, and then to consider a distinguishing attack with the associated bias. Denoting h the target Hamming weight, x the log of the number of XORs and  <span class="math">\\delta</span>  the bias, the resulting attack (which can be viewed as an extension of the previous correlation attack) has data complexity  <span class="math">\\mathcal{O}(2^h\\delta^{-2(x+1)})</span>  (more details are given in Appendix D).</p>

    <p class="text-gray-300"><strong>Higher-Order Correlation Attacks</strong> were introduced by Courtois [Cou02] and exploit the so-called XL algorithm. They look for good correlations between F and an approximation q of degree d &gt; 1, in order to solve a linearised system based on the values of this approximation. The value  <span class="math">\\varepsilon</span>  is defined such that q is equal to F with probability greater than  <span class="math">1 - \\varepsilon</span> . Such attacks have a (conservative) time complexity estimate:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\binom{N}{D}^{\\omega}(1-\\varepsilon)^{-m}\\right), \\text{ where } D \\geq d \\text{ and } m \\geq \\frac{\\binom{N}{D}}{\\binom{N}{D-d}}.</span>$</p>

    <p class="text-gray-300">Guess and Determine Attacks. Note that this section has been motivated by a private communication from Sébastien Duval, Virginie Lallemand and Yann Rotella, of which the details will be available in an upcoming ePrint report [DLR16]. Guess and determine attacks are generic attacks which consist in guessing  <span class="math">\\ell</span>  bits of the key in order to cancel some monomials. In our context, it allows an adversary to focus on a filtering function restricted to a subset of variables. This weaker function can then be cryptanalyzed, e.g. analyzed with the four aforementioned attacks, i.e. the algebraic attack, the fast algebraic attack, the correlation/BKWlike attacks and the higher-order correlation attack. The complexity of a guess and determine attack against a function F of N variables is  <span class="math">\\min_{\\ell} \\{ 2^{\\ell} C(F[\\ell]) \\}</span>  where  <span class="math">F[\\ell]</span>  is a function of  <span class="math">N[\\ell]</span>  variables obtained by fixing  <span class="math">\\ell</span>  variables of F, C(F) is the complexity of the best of the four attacks considered on the filtering function F and the minimum is taken over all  <span class="math">\\ell</span> 's. The case  <span class="math">\\ell=0</span>  corresponds to attack the scheme without guess and determine. We next bound the minimal complexity over these four attacks considering the weakest functions obtained by guessing. To do so, we introduce some notations and criteria allowing us to specify the cryptographic properties of Boolean functions obtained by guessing  <span class="math">\\ell</span>  variables of Boolean functions being direct sums of monomials. As the impact of guessing is most relevant for fast algebraic attacks and CA/BKW-like attacks, we defer the other part of the analysis and extra lemmas to the Appendix E.</p>

    <p class="text-gray-300"><strong>Definition 16</strong> (Direct Sum Vector). For a boolean function F of N variables obtained as a direct sum of monomials we associate its <strong>direct sum vector</strong>:  <span class="math">\\mathbf{m}_F</span>  of length  <span class="math">k = \\deg(F)</span> :  <span class="math">[m_1, m_2, \\cdots, m_k]</span>  such that  <span class="math">m_i</span> is the number of monomials of degree i of F and  <span class="math">N = \\sum_{i=1}^k im_i</span> . We define two quantities related to this vector:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbf{m}_F^*</span>  is the number of nonzero values of  <span class="math">\\mathbf{m}_F</span> .</li>
    </ul>

    <p class="text-gray-300"><span class="math">$- \\delta_{\\mathbf{m}_F} = \\frac{1}{2} - \\frac{\\mathsf{NL}(F)}{2^N}.</span>$</p>

    <p class="text-gray-300">These notations will be useful to quantify the impact of guessing some bits on the cryptographic properties of a Boolean function obtained by direct sums.  <span class="math">\\mathbf{m}_F</span> ,  <span class="math">\\mathbf{m}_F^*</span>  and  <span class="math">\\delta_{\\mathbf{m}_F}</span>  are easily computable from the description of F, the latter can be computed recursively using Lemma 3.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;<strong>Lemma 7</strong> (Guessing and Direct Sum Vector). For all guessing of  <span class="math">0 \\le \\ell \\le N</span>  variables of a Boolean function F in N variables obtained by direct sums associated with  <span class="math">\\mathbf{m}_F</span> , we obtain a function  <span class="math">F[\\ell]</span>  in  <span class="math">N[\\ell]</span> variables associated with  <span class="math">\\mathbf{m}_{F[\\ell]}</span>  such that :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">$\\sum_{i=1}^{\\deg(F[\\ell])} m_i[\\ell] \\ge (\\sum_{i=1}^{\\deg(F)} m_i) - \\ell.</span>$</p></li>
      <li><p class="text-gray-300"><span class="math">\\mathbf{m}_{F[\\ell]}^* \\ge \\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{1 \\le i \\le \\deg(F)} m_i} \\rfloor.</span></p></li>
      <li><p class="text-gray-300"><span class="math">$\\mathbf{m}_{F[\\ell]}^* \\geq \\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{1 \\leq i \\leq \\deg(F)} m_i} \\rfloor</span>$</p></li>
      <li></li>
    </ol>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;3.
<span class="math">$\\delta_{\\mathbf{m}_F[\\ell]} \\leq \\delta_{\\mathbf{m}_F} 2^{\\ell}</span>$
.</p>

    <p class="text-gray-300">Hereafter we describe the bounds we have used in order to assess the security of our instances.</p>

    <p class="text-gray-300"><strong>Lemma 8</strong> (Guess And Determine &amp; Fast Algebraic Attacks). Let F be a boolean function in N variables and  <span class="math">C_{GDFAA}(F)</span>  be the minimum complexity of the Guess And Determine with Fast Algebraic Attacks on F, then:</p>

    <p class="text-gray-300"><span class="math">$C_{GDFAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left[ 2^{\\ell} \\binom{\\min N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} \\log^2 \\binom{\\min N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} + (\\min N[\\ell])^2 \\binom{\\min N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} + (\\min N[\\ell])^{\\omega} \\right],</span>$</p>

    <p class="text-gray-300">where
<span class="math">$\\mathbf{m}_{F[\\ell]}^* = \\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor</span>$
.</p>

    <p class="text-gray-300">Lemma 9 (Guess and Determine &amp; CA/BKW-like Attacks). <em>Let</em> F <em>be a boolean function in</em> N <em>variables and</em> CGDCA/BKW (F) <em>be the minimum complexity of the Guess And Determine with Correlation/BKW Attacks on</em> F<em>, then :</em></p>

    <p class="text-gray-300"><span class="math">$C_{GDCA/BKW}(F) \\ge \\min_{0 \\le \\ell \\le N} \\{ 2^{-\\ell} \\delta_{\\mathbf{m}_F}^{-2} \\}.</span>$</p>

    <p class="text-gray-300">Other attacks. Besides the previous attacks that will be taken into account quantitatively when selecting our concrete instances of FLIP designs, we also investigated the following other cryptanalyses. First, <em>fast correlation attacks</em> were introduced by Meier and Staffelbach at Eurocrypt 1988 <a href="#page-28-3">[MS88]</a>. A recent survey can be found in <a href="#page-28-13">[Mei11]</a>. The attack is divided into two phases. The first one aims at looking for relations between the output bits a&lt;sup&gt;i&lt;/sup&gt; of the LFSR to generate a system of parity-check equations. The second one uses a fast decoding algorithm (<em>e.g.</em> the belief propagation algorithm) in order to decode the words of the code z&lt;sup&gt;i&lt;/sup&gt; = F(ai) satisfying the previous relations, where the channel has an error probability p = NL(F) 2&lt;sup&gt;N&lt;/sup&gt; . The working principles of this attack are quite similar to the ones of the previously mentioned correlation attacks and BKW-like attacks. So we assume that the previous (conservative) complexity estimates rule out this variation as well. Besides, note that intuitively, the belief propagation algorithm is best suited to the decoding of low-density parities, which is what our construction (and the LPN problem) typically avoid.</p>

    <p class="text-gray-300">Second, <em>weak keys</em> (<em>i.e.</em> keys of low or high hamming weights) can produce a keystream sufficiently biased to determine this hamming weight, and then to recover the key among the small amount of possible ones. The complexity of such attacks can be computed from the resiliency of F. However, since our N parameter will typically be significantly larger than the bit-security of our filter permutator instances, we suggest to restrict the key space to keys of Hamming weight N/2 to rule out this concern. For this purpose, master keys can simply be generated by applying a first (secret) random permutation to any stream with Hamming weight N/2.</p>

    <p class="text-gray-300">Third, <em>augmented function attacks</em> are attacks focusing on multiple outputs of the function rather than one. The goal is to find coefficients j1, · · · , j&lt;sup&gt;r&lt;/sup&gt; such that a relation between the key and the outputs si+j&lt;sup&gt;1&lt;/sup&gt; , · · · , si+j&lt;sup&gt;r&lt;/sup&gt; can be exploited. This relation can be a correlation (as explained in <a href="#page-25-1">[And94]</a>) or simply algebraic <a href="#page-27-13">[FM07]</a>. In both cases, a prerequisite is that the relation holds on a sufficient number of i. As each bit output by FLIP depends on a different permutation, we believe that there is no exploitable relation between different outputs.</p>

    <p class="text-gray-300">Eventually, <em>cube attacks</em> were introduced by Dinur and Shamir at Eurocrypt 2009 <a href="#page-27-14">[DS09]</a> as a variant of algebraic attacks taking advantage of the public parameters of a cryptographic protocol (plaintext in block ciphers, IV in stream cipher) in order to generate a system of equations of low degree. However in filter permutator constructions, the only such public parameter is the seed of the PRNG allowing to generate the pseudo-random bit permutations P&lt;sup&gt;i&lt;/sup&gt; . Since controlling this seed hardly allow any control of the F function's inputs, such attacks do not seem applicable. A similar observation holds for conditional differential cryptanalysis <a href="#page-27-15">[KMN10]</a> and for integral/zero-sum distinguishers <a href="#page-26-13">[BC10,</a> <a href="#page-27-16">KW02]</a>.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.5 Cautionary note and design tweaks</h4>

    <p class="text-gray-300">As already mentioned, all the previous analyzes are based on standard cryptanalysis and design tools. In particular, the security of our FLIP designs is based on properties of Boolean functions that are generally computed assuming a uniform input distribution. Yet, for filter permutators this condition is not strictly respected since the Hamming weight of the key register is fixed (we decided to set it to N/2 in order to avoid weak keys, but even without this condition, it would be fixed to an unknown value). This means the input distribution of our linear, quadratic and triangle functions is not uniform. We verified experimentally that the output of FLIP is sufficiently balanced despite this non-uniformity. More precisely, we could not detect biases larger than  <span class="math">2^{\\frac{q}{2}}</span>  when generating  <span class="math">2^q</span>  bits of keystream (based on small-scale experiments with q=32). But we did not study the impact of this non-uniformity for other attacks, which we leave as an important research scope, both from the cryptanalysis and the Boolean functions points-of-view.</p>

    <p class="text-gray-300">Note that in case the filter permutator of Section 3.1 turns out to have weaknesses specifically due to the imbalanced F function's inputs, there are tweaks that could be used to mitigate their impact. The simplest one is to apply a public whitening to the input bits of the non-linear parts of F (using additional public PRNG outputs), which has no impact on the homomorphic capacity. The adversary could then bias the F function's inputs based on his knowledge of the whitening bits, but to a lower extent than with our fixed Hamming weight keys. Alternatively, one could add a (more or less complex) linear layer before the non-linear part of F, which would then make the filter permutator conceptually more similar to filter generators, and (at least for certain layers) only imply moderate cost from the FHE point-of-view.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">3.6 80- &amp; 128-bit security instances</h4>

    <p class="text-gray-300">We selected a few instances aiming at 80- and 128-bit security based on the previous bounds, leading to the attack complexities listed in Table 1, where  <span class="math">\\mathsf{FLIP}(n_1,n_2,{}^{nb}\\Delta^k)</span>  denotes the instantiation of  <span class="math">\\mathsf{FLIP}</span>  with linear part of  <span class="math">n_1</span>  bits, quadratic part of  <span class="math">n_2</span>  bits and nb triangular functions of degree k. These instances are naturally contrasted. On the one hand, the bounds taken are conservative with respect to the attacks</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Instance</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">N</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">AA</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\ell</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">FAA</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">l</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">CA/BKW</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\ell</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">HOC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\ell</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">λ</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">FLIP(42, 128, {}^8\\varDelta^9)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">530</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">95</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">94</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">FLIP(46, 136, {}^4\\varDelta^{15})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">662</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">91</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">90</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">FLIP(82, 224, {}^8\\varDelta^{16})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1394</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">156</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">140</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">134</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">155</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">109</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">134</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">FLIP(86, 238, {}^5\\varDelta^{23})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1704</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">149</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">137</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">133</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">124</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">74</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;<strong>Table 1.</strong> Attack complexities in function of  <span class="math">n_1</span> ,  <span class="math">n_2</span>  and  <span class="math">{}^{nb}\\Delta^k</span> . AA stands for algebraic attacks, FAA stands for fast algebraic attacks, CA/BKW stands for correlation or BKW-like attacks, HOC stands for higher-order correlation attacks and  <span class="math">\\ell</span>  stands for the number of bits guessed leading to the best complexity for guess and determine attacks. For the CA/BKW column, we reported the minimum complexity between the correlation and BKW-like attack. Eventually,  <span class="math">\\lambda</span>  stands for the security parameter of F and is simply taken as the minimum between AA, FAA,CA/BKW and HOC.</p>

    <p class="text-gray-300">considered: if these attacks were the best ones, more aggressive instances could be proposed (<em>e.g.</em> in order to reduce the key size). On the other hand, filter permutators are based on non-standard design principles, and our security analysis is only preliminary, which naturally suggests the need of security margins. Overall, we believe the proposed instances are a reasonable trade-off between efficiency and security based on our current understanding of filter permutators, and therefore are a good target for further investigations.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.7 Indirect sums</h4>

    <p class="text-gray-300">Before analyzing the FHE properties of filter permutators, we finally suggest FLIP designs based on indirect sums as another interesting topic for evaluation, since they lead to quite different challenges. Namely, the main motivation to use direct sums in the previous sections was the possibility to assess their cryptographic properties based on existing tools. By contrast, filter permutator designs based on indirect sums seem harder to analyze (both for designers and cryptanalysts). This is mainly because in this case, not only the inputs of the Boolean functions vary, but also the Boolean functions themselves. For illustration, we can specify &quot;multi-FLIP &quot; designs, next denoted as b-FLIP designs, such that we compute b instances of FLIP in parallel, each with the same filtering function but with different permutations, and then to XOR the b computed bits in order to produce a keystream bit. We conjecture that such b-FLIP designs could lead to secure stream ciphers with smaller states, and suggest 10-FLIP(10, 20, &lt;sup&gt;1&lt;/sup&gt;∆20) and 15-FLIP(15, 30, &lt;sup&gt;1&lt;/sup&gt;∆30) as exemplary instances for 80- and 128-bit security.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4 Application to FHE</h3>

    <h2 id="sec-15" class="text-2xl font-bold">4.1 80- &amp; 128-bit security parameters</h2>

    <p class="text-gray-300">For the security parameters choices, we follow the analysis of Lindner and Peikert <a href="#page-28-14">[LP11]</a> for the hardness of LWE and RLWE, considering distinguishing and decoding attacks using BKZ <a href="#page-28-15">[SE94,</a> <a href="#page-26-14">CN11]</a>. We assume that the distribution χ in the considered LWE instances is the discrete Gaussian distribution with mean 0 and standard deviation σ. First we compute the best root Hermite factor δ of a basis (see <a href="#page-27-17">[GN08]</a>) computable with complexity 2 λ from the conservative lower bound of <a href="#page-28-14">[LP11]</a>:</p>

    <p class="text-gray-300"><span class="math">$\\log(\\delta) = 1.8/(110 + \\lambda). \\tag{1}</span>$</p>

    <p class="text-gray-300">The distinguishing attack described in <a href="#page-28-16">[MR09,</a> <a href="#page-28-17">RS10,</a> <a href="#page-28-14">LP11]</a> is successful with advantage ε by finding vectors of length α q &lt;sup&gt;σ&lt;/sup&gt; with α = p ln(1/ε)/π. The length of the shortest vector that can be computed is 2 2 √ n log q log δ , leading to the inequation:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\alpha \\frac{q}{\\sigma} &lt; 2^{2\\sqrt{n\\log q \\log \\delta}}.</span>$
(2)</p>

    <p class="text-gray-300">Given σ ≥ 2 √ n from Regev's reduction <a href="#page-28-4">[Reg05]</a>, we can choose parameters for n and q matching equation <a href="#page-17-0">(2)</a> for the considered security parameter λ. The parameters we select for our application are summarized in Table <a href="#page-17-1">2.</a></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security&lt;br&gt;λ</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">log&lt;br&gt;q</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;Table 2. (R)LWE parameters used in our applications.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.2 Noise analysis</h3>

    <p class="text-gray-300">Considering our framework of Figure <a href="#page-2-0">1,</a> Claude has at its disposal the homomorphic encryption of the symmetric key CH(sk&lt;sup&gt;S&lt;/sup&gt; i ), the homomorphic public key pk&lt;sup&gt;H&lt;/sup&gt; and the symmetric encrypted messages C&lt;sup&gt;S&lt;/sup&gt; (mi). He has to perform the homomorphic evaluation of the symmetric decryption circuit, <em>i.e.</em> to perform homomorphic operations on the ciphertexts CH(sk&lt;sup&gt;S&lt;/sup&gt; i ) in order to get CH(mi), the homomorphic encryption of m&lt;sup&gt;i&lt;/sup&gt; . In this section, we study the error growth in these ciphertexts after the application of the homomorphic operations. As we are considering SWHE, we need to control the magnitude of the error and keep it below a critical level to ensure the correctness of a final ciphertext. This noise management is crucial for the applications, it is directly linked with the quantity of computation that the server can do for the client. We now study the error growth stemming from the homomorphic evaluation of FLIP. In this case, all the ciphertexts used by the server in the computation step will have a same starting error. The knowledge of this starting error (defined by some parameter) and its growth for additions and multiplications (in a chosen order) is enough to determine the amount of computation that can be performed correctly by the server.</p>

    <p class="text-gray-300">In the remaining of this section we proceed in three steps. First we recall the error growth implied by the H.Add and H.Mul operations: for GSW-like HE it has already been done in <a href="#page-27-7">[GSW13,</a> <a href="#page-26-4">AP14,</a> <a href="#page-26-15">BV14,</a> <a href="#page-27-8">HAO15,</a> <a href="#page-27-18">DM15]</a>. As our homomorphic encryption schemes are slightly differently written to fit our applications (batched version to perform in parallel the same computations, generic notations for various frameworks), we give these error growth with our notations for completeness and consistency of the paper. Then we analyse the error for a sub-case of homomorphic product, namely H.Comb, which gives a practical tool to study the error growth in FLIP. As the asymmetric property of GSW multiplication and plaintext norm have been pointed out relatively to the error growth, we consider important to focus on both when analysing this error metric. Considering H.Comb types of operations is therefore suited to be consistent with this metric and is very important for practical purpose (in term of real life applications). Finally we analyse the error in a ciphertext output by FLIP and study some optimizations to reduce the noise growth further.</p>

    <p class="text-gray-300">Error Growth in H.Add and H.Mul. We first need to evaluate the error growth of the basic homomorphic operations, the addition and the multiplication of ciphertexts. We use the analysis of <a href="#page-26-4">[AP14]</a> based on subgaussian distributions to study the error growth in these homomorphic operations. From a coefficient or a vector following a subgaussian distribution of parameter σ, we can bound its norm with overwhelming probability and then study the evolution of this parameter while performing the homomorphic operations. Hence we can bound the final error to ensure correctness.</p>

    <p class="text-gray-300">For simplicity we use two notations arising in the error growth depending on the arithmetic of the underlying ring of the two schemes, γ the expansion factor (see <a href="#page-26-1">[BGV12]</a>) and Norm(m&lt;sup&gt;j&lt;/sup&gt; ) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Batched GSW: γ = 1 and Norm(m&lt;sup&gt;j&lt;/sup&gt; ) = |m&lt;sup&gt;j&lt;/sup&gt; | (arithmetic in Z) .</li>
      <li>Ring GSW: γ = n and Norm(m&lt;sup&gt;j&lt;/sup&gt; ) = ||m&lt;sup&gt;j&lt;/sup&gt; ||&lt;sup&gt;2&lt;/sup&gt; (arithmetic in R).</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;Lemma 10 (H.Add error growth). <em>Suppose</em> C&lt;sup&gt;i&lt;/sup&gt; <em>for</em> 1 ≤ i ≤ k <em>are ciphertexts of a GSW based Homomorphic Encryption scheme with error components</em> e&lt;sup&gt;i&lt;/sup&gt; <em>of coefficients following a distribution of parameter</em> σ&lt;sup&gt;i&lt;/sup&gt; <em>. Let</em> C&lt;sup&gt;f&lt;/sup&gt; = H.Add(C&lt;sup&gt;i&lt;/sup&gt; <em>, for</em> 1 ≤ i ≤ k) <em>and</em> e&lt;sup&gt;f&lt;/sup&gt; <em>the related error with subgaussian parameter</em> σ 0 <em>such that:</em></p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = \\sqrt{\\sum_{i=1}^{k} \\sigma_i^2}</span>$
or  <span class="math">\\sigma&#x27; = \\sigma \\sqrt{k}</span>  if  <span class="math">\\sigma_i = \\sigma, \\forall i \\in [k]</span> .</p>

    <p class="text-gray-300"><strong>Lemma 11</strong> (H.Mul <strong>error growth</strong>). Suppose  <span class="math">C_i</span>  for  <span class="math">1 \\le i \\le k</span>  are ciphertexts of a GSW based Homomorphic Encryption scheme with error components  <span class="math">e_i</span> , of coefficients following a subgaussian distribution of parameter  <span class="math">\\sigma_i</span> , and plaintext  <span class="math">m_i</span> .  <span class="math">C_f</span>  is the result of a multiplicative homomorphic chain such that:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}_f = H.\\mathsf{Mul}(\\mathbf{C}_1, H.\\mathsf{Mul}(\\mathbf{C}_2, H.\\mathsf{Mul}(\\cdots, H.\\mathsf{Mul}(\\mathbf{C}_k, \\mathbf{G})))),</span>$</p>

    <p class="text-gray-300">and  <span class="math">e_f</span>  the corresponding error with subgaussian parameter  <span class="math">\\sigma&#x27;</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = \\mathcal{O}\\left(\\sqrt{N\\gamma}\\sqrt{\\sigma_1^2 + \\sum_{i=2}^k \\left(\\sigma_i \\Pi_{j=1}^{i-1} Norm(m_j)\\right)^2}\\right).</span>$</p>

    <p class="text-gray-300">Lemmas 10 and 11 are proven in Appendix F.</p>

    <p class="text-gray-300"><strong>Error Growth in</strong> H<strong>.Comb.</strong> For the sake of clarity, we formalize hereafter the comb homomorphic product H.Comb and the quantity  <span class="math">\\sigma_{comb}</span>  which stands for the subgaussian parameter. We study the error growth of H.Comb as we will use it as a tool for the error growth analysis of FLIP.</p>

    <p class="text-gray-300"><strong>Definition 17</strong> (homomorphic comb H.Comb). Let  <span class="math">\\mathbf{C}_1, \\dots, \\mathbf{C}_k</span>  be k ciphertexts of a GSW based Homomorphic Encryption scheme with error coefficients from independent distributions with same subgaussian parameter  <span class="math">\\sigma</span> . We define H.Comb <span class="math">(y, \\sigma, c, k) = H</span> .Mul <span class="math">(\\mathbf{C}_1, \\dots, \\mathbf{C}_k, \\mathbf{G})</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">y = \\sqrt{N\\gamma}</span>  is a constant depending on the ring,</li>
      <li><span class="math">c = \\max_{1 \\le i \\le k}(Norm(m_i))</span>  is a constant which depends on the plaintexts,</li>
    </ul>

    <p class="text-gray-300">and  <span class="math">\\mathbf{C}_{comb} = H.\\mathsf{Comb}(y, \\sigma, c, k)</span>  as error components following a subgaussian distribution of parameter  <span class="math">\\mathcal{O}(\\sigma_{comb})</span> .</p>

    <p class="text-gray-300"><strong>Lemma 12</strong> ( <span class="math">\\sigma_{comb}</span>  quantity). Let  <span class="math">\\mathbf{C}_1, \\dots, \\mathbf{C}_k</span>  be k ciphertexts of a GSW based Homomorphic Encryption scheme with same error parameter  <span class="math">\\sigma</span>  and  <span class="math">\\mathbf{C}_{comb} = H.\\mathsf{Comb}(y, \\sigma, c, k)</span> . Then we have:</p>

    <p class="text-gray-300"><span class="math">$\\sigma_{comb}(y,\\sigma,c,k) = y\\sigma c_k, \\quad \\text{where } c_k = \\sqrt{\\sum_{i=0}^{k-1} c^{2i}}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Thanks to Lemma 11 we obtain:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sigma_{comb} = \\sqrt{N\\gamma} \\sqrt{\\sigma^2 + \\sum_{i=2}^k (\\sigma \\Pi_{j=1}^{i-1} Norm(m_j))^2}, \\\\ &amp;\\sigma_{comb} = y \\sqrt{\\sigma^2 + \\sum_{i=2}^k (\\sigma c^{i-1})^2}, \\\\ &amp;\\sigma_{comb} = y \\sigma \\sqrt{\\sum_{i=1}^k (c^{i-1})^2}, \\\\ &amp;\\sigma_{comb} = y \\sigma c_k. \\end{split}</span>$</p>

    <p class="text-gray-300">The compatibility of this comb structure with the asymmetric multiplicative error growth property of GSW enables us to easily quantify the error in our construction, with a better accuracy than computing the multiplicative depth. In order to minimize the quantity  <span class="math">\\sigma_{comb}</span> , we choose the plaintext space such that c=1</p>

    <p class="text-gray-300">for freshly generated ciphertexts. The resulting  <span class="math">\\sigma_{comb}(y,\\sigma,1,k)</span>  quantity is therefore  <span class="math">y\\sigma\\sqrt{k}</span> , growing less than linearly in the number of ciphertexts. Fixing the constant c to be 1 is usual with FHE. As we mostly consider Boolean circuits, it is usual to use plaintexts in  <span class="math">\\{-1,0,1\\}</span>  to encrypt bits, leading to c=1 and therefore  <span class="math">c_k=\\sqrt{k}</span> .</p>

    <p class="text-gray-300">Error Growth in FLIP In the previous paragraphs, we have evaluated the error growth in the basic homomorphic operations H.Add, H.Mul and H.Comb. We will use them as building blocks in order to evaluate the error growth in the homomorphic evaluation of FLIP. Coming back to the framework of Figure 1, the error in the ciphertexts  <span class="math">\\mathbf{C}^H(m_i)</span>  is of major importance as it will determine the possible number of homomorphic computations f that Claude is able to perform.</p>

    <p class="text-gray-300">The main feature of the filter permutator model, considering FHE settings, is that it allows to handle with ciphertexts having the same error level, whatever the number of output bits. Consequently all ciphertexts obtained by FLIP evaluation will have the same constant and small amount of noise and will be considered as fresh start for more computation.</p>

    <p class="text-gray-300">Evaluating homomorphically the FLIP decryption ( <span class="math">\\mathit{resp}</span> . encryption) algorithm consists in applying three steps of homomorphic operations on the ciphertexts  <span class="math">\\mathbf{C}^H(\\mathsf{sk}_i^S)</span>  in our application framework, each one encoding one bit of the key register. For each ciphertext bit, these steps are: a (bit) permutation, the application of the filtering function F and a XOR with the ciphertext ( <span class="math">\\mathit{resp}</span> . plaintext). The (bit) permutation consists only in a public rearrangement of the key ciphertexts, leading to a noise-free operation. The last XOR is done with a freshly encrypted bit. Hence the error growth depends mostly on the homomorphic evaluation of F.</p>

    <p class="text-gray-300">As H.Dec outputs quantities modulus 2, we can evaluate the XORs of F by H.Add and the ANDs by H.Mul. We then determine the subgaussian parameter of the error of a ciphertext from the homomorphic evaluation of F. For a given encrypted key, this parameter will be the same for every homomorphic evaluation of FLIP and is computed from  <span class="math">\\sigma_{comb}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 13</strong> (Error growth evaluating F). Let F be the FLIP filtering function in N variables defined in Section 3.3. Assume that  <span class="math">\\mathbf{C}_i</span>  for  <span class="math">0 \\le i \\le N-1</span>  are ciphertexts of a GSW HE scheme with same subgaussian parameter  <span class="math">\\sigma</span>  and c=1. We define  <span class="math">\\mathbf{C}_F=H.\\mathsf{Eval}(F,\\mathbf{C}_i)</span>  the output of the homomorphic evaluation of the ciphertexts  <span class="math">\\mathbf{C}_i</span> 's along the circuit F. Then the error parameter  <span class="math">\\sigma&#x27;</span>  is:</p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = \\mathcal{O}\\left(\\sigma\\sqrt{n_1 + y^2(n_2 + n_3)}\\right) \\approx \\mathcal{O}\\left(\\sigma y \\sqrt{N}\\right).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We first evaluate the noise brought by F for each of its components  <span class="math">L_{n_1}</span> ,  <span class="math">Q_{n_2}</span> ,  <span class="math">^{nb}\\Delta^k</span> , defining the respective ciphertexts  <span class="math">\\mathbf{C}_{L_{n_1}}</span> ,  <span class="math">\\mathbf{C}_{Q_{n_2}}</span> ,  <span class="math">\\mathbf{C}_{T_k}</span>  (the last one standing for one triangle only) and the subgaussian parameter of the respective error distributions (of the components of the error vectors)  <span class="math">\\sigma_{L_{n_1}}</span> ,  <span class="math">\\sigma_{Q_{n_2}}</span> ,  <span class="math">\\sigma_{T_k}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\begin{array}{l} \\textbf{-} \\ L_{n_1} \\colon \\mathbf{C}_{L_{n_1}} = H. \\mathsf{Eval}(L_{n_1}, \\mathbf{C}_0, \\cdots, \\mathbf{C}_{n_1-1}) = H. \\mathsf{Add}(\\mathbf{C}_0, \\cdots, \\mathbf{C}_{n_1-1}) \\ \\text{then} \\ \\sigma_{L_{n_1}} = \\sigma \\sqrt{n_1}. \\\\ \\textbf{-} \\ Q_{n_2} \\colon \\mathbf{C}_{Q_{n_2}} = H. \\mathsf{Add}(H. \\mathsf{Mul}(\\mathbf{C}_{n_1+2j}, \\mathbf{C}_{n_1+2j+1}, \\mathbf{G})) \\ \\text{for} \\ 0 \\leq j \\leq n_2. \\\\ H. \\mathsf{Mul}(\\mathbf{C}_{n_1+2j}, \\mathbf{C}_{n_1+2j+1}, \\mathbf{G}) = H. \\mathsf{Comb}(y, \\sigma, 1, 2) \\ \\text{has subgaussian parameter} \\ \\mathcal{O}(\\sigma_{comb}(y, \\sigma, 1, 2)) = \\\\ \\mathcal{O}(y\\sigma\\sqrt{2}) \\ \\text{for} \\ 0 \\leq j \\leq n_2. \\\\ \\mathsf{Then} \\ \\sigma_{Q_{n_2}} = \\mathcal{O}(y\\sigma\\sqrt{2}\\sqrt{\\frac{n_2}{2}}) = \\mathcal{O}(y\\sigma\\sqrt{n_2}). \\end{array}</span></li>
      <li><span class="math">T_k</span> :  <span class="math">\\mathbf{C}_{T_k} = H</span> . Add(H. Mul <span class="math">(\\mathbf{C}_{n_1+n_2+j+(i-1)(i-2)/2}; 1 \\leq j \\leq i); 1 \\leq i \\leq k)</span> .  <span class="math">\\mathbf{C}_{T_k} = H</span> . Add(H. Comb <span class="math">(y, \\sigma, 1, i), 1 \\leq i \\leq k)</span> .</li>
    </ul>

    <p class="text-gray-300">then
<span class="math">$\\sigma_{T_k} = \\mathcal{O}(\\sqrt{\\sum_{i=1}^k (y\\sigma\\sqrt{i})^2}) = \\mathcal{O}(y\\sigma\\sqrt{\\frac{k(k+1)}{2}}).</span>$
As  <span class="math">{}^{nb}\\Delta^k</span>  is obtained by adding  <span class="math">nb</span>  independent triangles, we get:  <span class="math">\\mathbf{C}_{nb\\Delta^k} = H.\\mathsf{Add}(\\mathbf{C}_{T_k,i}, 1 \\leq i \\leq nb),</span>  and  <span class="math">\\sigma_{nb\\Delta^k} = \\mathcal{O}(y\\sigma\\sqrt{nb}\\sqrt{\\frac{k(k+1)}{2}}) = \\mathcal{O}(y\\sigma\\sqrt{n_3}).</span></p>

    <p class="text-gray-300">By Pythagorean additivity the subgaussian parameter of  <span class="math">\\mathbf{C}_F</span>  is finally:</p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = \\mathcal{O}(\\sqrt{(\\sigma\\sqrt{n_1})^2 + (y\\sigma\\sqrt{n_2})^2 + (y\\sigma\\sqrt{n_3})^2}) = \\mathcal{O}(\\sigma\\sqrt{n_1 + y^2(n_2 + n_3)}).</span>$</p>

    <p class="text-gray-300"><strong>Optimizations</strong> The particular error growth in GSW Homomorphic Encryption enables to use more optimizations to reduce the error norm and perform more operations without increasing the parameter sizes. The error growth in H. Comb depends on the quantity  <span class="math">c_k</span>  derived from bounds on norms of the plaintexts; these quantities can be reduced using negative numbers. A typical example is in the LWE-based scheme to use  <span class="math">m \\in \\{-1,0,1\\}</span>  rather than  <span class="math">\\{0,1\\}</span> ; the  <span class="math">c_k</span>  quantity is the same and in average the sums in  <span class="math">\\mathbb Z</span>  are smaller. Then the norm  <span class="math">|\\sum m_i|</span>  is smaller which is important when multiplying. Conserving this norm as low as possible gives better bounds and  <span class="math">c_k</span>  coefficients, leading to smaller noise when performing distinct levels of operations. An equivalent way of minimizing the error growth is to still use  <span class="math">\\mathcal{M} = \\{0,1\\}</span>  but with H. Add( <span class="math">\\mathbf{C}_1, \\mathbf{C}_2</span> ) =  <span class="math">\\mathbf{C}_1 \\pm \\mathbf{C}_2</span> . This homomorphic addition is still correct because:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{S} - \\mathbf{C}_2 = -\\mathbf{E}_2&#x27; - \\left( \\frac{m_{2,1} \\cdot \\mathbf{s}_1^{\\mathsf{T}}}{\\vdots \\atop m_{2,r} \\cdot \\mathbf{s}_r^{\\mathsf{T}}} \\right) \\mathbf{G} = \\mathbf{E}_2&#x27;&#x27; + \\left( \\frac{-m_{2,1} \\cdot \\mathbf{s}_1^{\\mathsf{T}}}{\\vdots \\atop -m_{2,r} \\cdot \\mathbf{s}_r^{\\mathsf{T}}} \\right),</span>$</p>

    <p class="text-gray-300">where the coefficients in  <span class="math">\\mathbf{E}_2&#x27;&#x27;</span>  rows follow distribution of same subgaussian parameter as the one in  <span class="math">\\mathbf{E}_2&#x27;</span>  by homogeneity and  <span class="math">-m = m \\mod 2</span> .</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">4.3 Concrete results</h4>

    <p class="text-gray-300">Contrary to other works published in the context of symmetric encryption schemes for efficient FHE [GHS12, CCF&lt;sup&gt;+&lt;/sup&gt;15, ARS&lt;sup&gt;+&lt;/sup&gt;15], our primary focus is not on the performances (see SHIELD [KGV14] for efficient implementation of Ring-GSW) but rather on the error growth. As pointed out in [CCF&lt;sup&gt;+&lt;/sup&gt;15], in most of these previous works, after the decryption process the noise inside the ciphertexts was too high to perform any other operation on them, whereas it is the main motivation for a practical use of FHE.</p>

    <p class="text-gray-300">In this section, we consequently provide experimental results about this error growth in the ciphertexts after different operations evaluated on the Ring GSW scheme. As the link between subgaussian parameter, ciphertext error and homomorphic computation is not direct, we make some choices for representing these results focusing on giving intuition on how the error behaves.</p>

    <p class="text-gray-300">The choice of the Ring GSW setting rather than Batched GSW is for convenience. It allows to deal with smaller matrices and faster evaluations, providing the same confirmation on the heuristic error growth. We give the parameters n and  <span class="math">\\ell</span>  defining the polynomial ring and fix  <span class="math">\\sigma = 2\\lceil \\sqrt{n} \\rceil</span>  for the error distribution.</p>

    <p class="text-gray-300">An efficient way of measuring the error growth within the ciphertexts is to compute the difference by applying the rounding  <span class="math">\\lfloor \\cdot \\rceil_2</span>  in H.Dec between various ciphertexts with known plaintext. This difference</p>

    <p class="text-gray-300">(for each polynomial coefficient or vector component) corresponds to the amount of noise contained in this ciphertext. The correctness requires this quantity to be inferior to 2 <code>−2 . Then, considering its logarithm in base 2, it enables to have an intuitive and practical measure of the ciphertext noise: this quantity grows with the homomorphic operations until this log equals </code> − 2. Concretely, in our experiments we encrypt polynomials being m = 0 or m = 1, compute on the constant coefficient the quantity e = |(hs, c<code>i − m2 </code>−1 ) mod q|, and give its logarithm. We give another quantity in order to provide intuition about the homomorphic computation possibilities over the ciphertexts, by simply computing a percentage of the actual level of noise relatively to the maximal level \` − 2.</p>

    <p class="text-gray-300"><em>Remark 4.</em> The quantity exhibited by our measures is roughly the subgaussian parameter of the distribution of the error contained in the ciphertexts. Considering the simpler case of a real Gaussian distribution N (0, σ&lt;sup&gt;2&lt;/sup&gt; ), the difference that we compute then follows a half normal distribution with mean σ √ √ 2 π .</p>

    <p class="text-gray-300">We based our prototype implementation on the NTL library combined with GMP and the discrete gaussian sampler of BLISS <a href="#page-26-16">[DDLL13]</a>. We report in Table <a href="#page-22-0">3</a> experimental results on the error growth for different RLWE and FLIP parameters, based on an average over a hundred of samples.</p>

    <p class="text-gray-300">The results confirm the quasi-additive error growth when considering the specific metric of GSW given by the asymptotic bounds. The main conclusion of these results is that the error inside the ciphertexts after a homomorphic evaluation of FLIP is of the same order of magnitude as the one after a multiplication. The only difference between these noise increases is a term provided by the root of the symmetric key register size, that is linear in λ. Therefore, with the FLIP construction the error growth is roughly the basic multiplicative error growth of two ciphertexts. Hence, we conclude that filter permutators as FLIP release the bottleneck of evaluating symmetric decryption, and lead the further improvement of the calculus delegation framework to depend overwhelmingly on improvements of the homomorphic operations.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ring&lt;br&gt;(n, \`)&lt;br&gt;FLIP</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Fresh</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">H.Add</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">H.Mul</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">H.Eval(FLIP)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log&lt;br&gt;e</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log&lt;br&gt;e</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log&lt;br&gt;e</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log&lt;br&gt;e</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8∆9&lt;br&gt;(42,&lt;br&gt;128,&lt;br&gt;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13,&lt;br&gt;07</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17 %</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13,&lt;br&gt;96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19,&lt;br&gt;82</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24,&lt;br&gt;71</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8∆16)&lt;br&gt;(82,&lt;br&gt;224,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14,&lt;br&gt;68</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12 %</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15,&lt;br&gt;14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23,&lt;br&gt;27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20%</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28,&lt;br&gt;77</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24%</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;Table 3. Experimental error growth of Ring-GSW. Fresh, H.Add, H.Mul and H.Eval(FLIP) respectively stands for the noise e measure after a fresh homomorphic encryption, the homomorphic addition of two fresh ciphertexts, the homomorphic multiplication of two fresh ciphertexts and the homomorphic evaluation of FLIP on fresh ciphertexts. The first value is the log of the error e inside the corresponding ciphertexts and the percentage represents the proportion of the noise with respect to the capacity of decryption (<em>i.e.</em> \` − 2).</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">4.4 Performances for 2nd-generation schemes</h4>

    <p class="text-gray-300">Despite our new constructions are primarily designed for 3rd-generation FHE, a look at Table <a href="#page-23-0">4</a> suggests that also from the multiplicative depth point of view, FLIP instances bring good results compared to their natural competitors such as LowMC <a href="#page-26-2">[ARS</a>+15] and Trivium/Kreyvium <a href="#page-26-3">[CCF</a>+15]. In Trivium/Kreyvium, the multiplicative depth of the decryption circuit is at most 13, while the LowMC family has a record multiplicative depth of 11 which is still larger than our FLIP instances. For completeness, we finally investigated the performances of some instances of FLIP for 2nd-generation FHE schemes using HElib, as reported in Table <a href="#page-24-0">5,</a> where the latency is the amount of time (in seconds) needed to homomorphically decrypt (Nb * Number of Slots) bits, and the throughput is calculated as (Nb * Number of Slots * 60)/latency. As</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Multiplicative depth</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON-32/64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[LN14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Trivium-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CCF+15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Trivium-13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CCF+15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMc-80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[ARS+15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8∆9&lt;br&gt;FLIP(42,&lt;br&gt;128,&lt;br&gt;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">dlog 9e&lt;br&gt;= 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AES-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GHS12, CLT14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SIMON-64/128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[LN14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Prince</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DSES14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Kreyvium-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CCF+15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Kreyvium-13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CCF+15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMc-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[ARS+15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8∆16)&lt;br&gt;FLIP(82,&lt;br&gt;224,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">dlog 16e&lt;br&gt;= 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;Table 4. Multiplicative depth of different symmetric ciphers.</p>

    <p class="text-gray-300">in <a href="#page-26-3">[CCF</a>+15], we have considered two noise levels: a first one that does not allow any other operations on the ciphertexts, and a second one where we allow operations of multiplicative depth up to 7. Note that the (max) parenthesis in the Nb column recalls that for Trivium/Kreyvium, the homomorphic capacity decreases with the number of keystream bits generated, which therefore bounds the number of such bits before re-keying. We observe that for 80-bit security, our instances outperform the ones based on Trivium. As for 128-bit security, the gap between our instances and Kreyvium is limited (despite the larger state of FLIP), and LowMC has better throughput in this context. Note also that our results correspond to the evaluation of the F function of FLIP (we verified that the time needed to generate the permutations only marginally affects the overall performances of homomorphic FLIP evaluations). We finally mention that these results should certainly not be viewed as strict comparisons, since obtained on different computers and for relatively new ciphers for which we have limited understanding of the security margins (especially for LowMC <a href="#page-26-17">[DLMW15,</a> <a href="#page-26-18">DEM15]</a> and FLIP). So they should mainly be seen as an indication that besides their excellent features from the FHE capacity point-of-view, filter permutators inherently have good properties for efficient 2nd-generation FHE implementations as well.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">5 Conclusions and open problems</h4>

    <p class="text-gray-300">In the context of our Homomorphic Encryption - Symmetric Encryption framework, where most of the computations are delegated to a server, we have designed a symmetric encryption scheme which fits the FHE settings, with as main goal to get the homomorphic evaluation of the symmetric decryption circuit as cheap</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Nb</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">L</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Latency</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Throughput</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of Slots</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(sec)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(bits/min)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1417.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1143.0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Trivium-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">720</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4420.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">439.8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">136 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600&lt;br&gt;3650.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1341.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Trivium-13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">136 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">720</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11379.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">516.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">504</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1715.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">740.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Kreyvium-12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">756</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4956.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">124 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">682</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3987.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1272.6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Kreyvium-13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">124 (max)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">420</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12450.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">286.8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">?&lt;br&gt;≤&lt;br&gt;128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">682</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3368.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3109.6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">LowMC-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">≤&lt;br&gt;?&lt;br&gt;128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">480</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9977.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">739.0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8∆9&lt;br&gt;FLIP(42,&lt;br&gt;128,&lt;br&gt;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">378</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.72</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4805.08</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">600</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2070.16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8∆16)&lt;br&gt;FLIP(82,&lt;br&gt;224,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">630</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.53</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2601,51</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">720</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">102.51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">421.42</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;Table 5. Timings of the homomorphic evaluation of several instances of the Boolean function of FLIP using HElib on an Intel Core i7-3770. The other results are taken from <a href="#page-26-3">[CCF</a>+15]. L and Number of Slots are HElib parameters which stand respectively for the level of noise and the number of bits packed in one ciphertext. (Nb * Number of Slots) corresponds to the number of decrypted bits.</p>

    <p class="text-gray-300">as possible, with respect to the error growth. In particular the error growth obtained by our construction, only one level of multiplication considering the metric of third generation FHE, achieves the lowest bound we can get with a secure symmetric encryption scheme. The use of zero-noise operations as permutations enables us to combine the advantages of block ciphers and stream ciphers evaluation, namely constant noise on the one hand and starting low noise on the other hand. As a result, the homomorphic evaluation of filter permutators can be made insignificant relatively to a complete FHE framework.</p>

    <p class="text-gray-300">The general construction of our encryption scheme – <em>i.e.</em> the filter permutator – and its FLIP instances are admittedly provocative. As a result, we believe an important contribution of this paper is to open a wide design space of symmetric constructions to investigate, ranging from the very efficient solutions we suggest to more classical stream ciphers such as filter generators. Such a design space leads to various interesting directions for further research. Overall, the main question raised by filter permutators is whether it is possible to build a secure symmetric encryption scheme with aggressively reduced algebraic degree. Such a question naturally relates to several more concrete problems. First, and probably most importantly, additional cryptanalysis is needed in view of the non-standard design principles exploited in filter permutators. It typically includes algebraic attacks tacking advantage of the sparsity of their systems of equations, attacks exploiting the imbalances at the input of the filter, and the possibility to exploit chosen IVs to improve those attacks. Second, our analyses also raise interesting problems in the field of Boolean functions, <em>e.g.</em> the analysis of such functions with non-uniform input distributions and the investigation of the best fixed degree approximations of a Boolean function (which is needed in our study of higher-order correlation attacks). More directly related to the FLIP instances, it would also be interesting to refine our security analyses, with a stronger focus on the attacks data complexity, and to evaluate whether instances with smaller key register could be sufficiently secure. In case of new cryptanalysis results, the design tweaks we suggest in the paper are yet another interesting research path. Eventually, and from the FHE application point-of-view, optimizing the implementations of filter permutators, <em>e.g.</em> by taking advantage of parallel computing clusters that we did not exploit so far, would be useful in order to evaluate their applicability to real-world scenarii.</p>

    <p class="text-gray-300">Acknowledgements. We are highly grateful to Sebastien Duval, Virginie Lallemand and Yann Rotella for ´ sharing their ideas about guess and determine attacks before the publication of this paper, which allowed us to modify the instances of FLIP accordingly. We are also indebted to Anne Canteaut for numerous useful suggestions about the design of filter permutators, and for putting forward some important open problems they raise. Finally, we would like to thank Thierry Berger, Sergiu Carpov, Raphael Delpino, Malika ¨ Izabachene, Nicky Mouha, Thomas Prest and Renaud Sirdey for their feedback about early (and less early) versions of this paper. This work was funded in parts by the H2020 ICT COST CryptoAction, by the H2020 ICT Project SAFECrypto, by the H2020 ERC Staring Grant CRASH and by the INNOVIRIS SCAUT project. Franc¸ois-Xavier Standaert is a research associate of the Belgian Fund for Scientific Research (F.R.S.-FNRS).</p>

    <h2 id="sec-20" class="text-2xl font-bold">References</h2>

    <p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;[ACG&lt;sup&gt;+&lt;/sup&gt;06] Frederik Armknecht, Claude Carlet, Philippe Gaborit, Simon Kunzli, Willi Meier, and Olivier Ruatta. Efficient ¨ Computation of Algebraic Immunity for Algebraic and Fast Algebraic Attacks. In <em>Advances in Cryptology - EUROCRYPT 2006, 25th Annual International Conference on the Theory and Applications of Cryptographic Techniques, St. Petersburg, Russia, May 28 - June 1, 2006, Proceedings</em>, pages 147–164, 2006.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;[And94] Ross J. Anderson. Searching for the optimum correlation attack. In <em>Fast Software Encryption: Second International Workshop. Leuven, Belgium, 14-16 December 1994, Proceedings</em>, pages 137–143, 1994.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-19&quot;&gt;&lt;/span&gt;[AP12] Jacob Alperin-Sheriff and Chris Peikert. Circular and KDM security for identity-based encryption. In <em>Public Key Cryptography - PKC 2012 - 15th International Conference on Practice and Theory in Public Key Cryptography, Darmstadt, Germany, May 21-23, 2012. Proceedings</em>, pages 334–352, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-4&quot;&gt;&lt;/span&gt;[AP14] Jacob Alperin-Sheriff and Chris Peikert. Faster bootstrapping with polynomial error. In <em>Advances in Cryptology - CRYPTO 2014 - 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2014, Proceedings, Part I</em>, pages 297–314, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-13&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-26-2&quot;&gt;&lt;/span&gt;[ARS&lt;sup&gt;+&lt;/sup&gt;15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In <em>Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I</em>, pages 430–454, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[BC10] Christina Boura and Anne Canteaut. Zero-sum distinguishers for iterated permutations and application to keccak-<em>f</em> and hamsi-256. In Alex Biryukov, Guang Gong, and Douglas R. Stinson, editors, <em>Selected Areas in Cryptography - 17th International Workshop, SAC 2010, Waterloo, Ontario, Canada, August 12-13, 2010, Revised Selected Papers</em>, volume 6544 of <em>Lecture Notes in Computer Science</em>, pages 1–17. Springer, 2010.</li>
    </ul></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;[BGV12] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (leveled) fully homomorphic encryption without bootstrapping. In <em>Innovations in Theoretical Computer Science 2012, Cambridge, MA, USA, January 8-10, 2012</em>, pages 309–325, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-15&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-26-8&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-26-5&quot;&gt;&lt;/span&gt;[BKW03] Avrim Blum, Adam Kalai, and Hal Wasserman. Noise-tolerant learning, the parity problem, and the statistical query model. <em>J. ACM</em>, 50(4):506–519, 2003.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[BM84] Manuel Blum and Silvio Micali. How to generate cryptographically strong sequences of pseudo random bits. <em>SIAM J. Comput.</em>, 13(4):850–864, 1984.</li>
      <li>[BV14] Zvika Brakerski and Vinod Vaikuntanathan. Lattice-based FHE as secure as PKE. In <em>Innovations in Theoretical Computer Science, ITCS'14, Princeton, NJ, USA, January 12-14, 2014</em>, pages 1–12, 2014.</li>
      <li>[BY01] Mihir Bellare and Bennet S. Yee. Forward-security in private-key cryptography. <em>IACR Cryptology ePrint Archive</em>, 2001:35, 2001.</li>
      <li>[Car10] Claude Carlet. <em>Boolean Models and Methods in Mathematics, Computer Science, and Engineering</em>, chapter Boolean Functions for Cryptography and Error Correcting Codes., pages 257–397,. 2010.</li>
    </ul></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-9&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-26-6&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-26-3&quot;&gt;&lt;/span&gt;[CCF&lt;sup&gt;+&lt;/sup&gt;15] Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancrede Lepoint, Mar \` ´ıa Naya-Plasencia, Pascal Paillier, and Renaud Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext. <em>IACR Cryptology ePrint Archive</em>, 2015:113, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;[CLT14] Jean-Sebastien Coron, Tancr ´ ede Lepoint, and Mehdi Tibouchi. Scale-invariant fully homomorphic encryption over \` the integers. In <em>Public-Key Cryptography - PKC 2014 - 17th International Conference on Practice and Theory in Public-Key Cryptography, Buenos Aires, Argentina, March 26-28, 2014. Proceedings</em>, pages 311–328, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-10&quot;&gt;&lt;/span&gt;[CM03] Nicolas Courtois and Willi Meier. Algebraic Attacks on Stream Ciphers with Linear Feedback. In <em>Advances in Cryptology - EUROCRYPT 2003, International Conference on the Theory and Applications of Cryptographic Techniques, Warsaw, Poland, May 4-8, 2003, Proceedings</em>, pages 345–359, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-14&quot;&gt;&lt;/span&gt;[CN11] Yuanmi Chen and Phong Q. Nguyen. BKZ 2.0: Better lattice security estimates. In <em>Advances in Cryptology - ASIACRYPT 2011 - 17th International Conference on the Theory and Application of Cryptology and Information Security, Seoul, South Korea, December 4-8, 2011. Proceedings</em>, pages 1–20, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-12&quot;&gt;&lt;/span&gt;[Cou02] Nicolas Courtois. Higher Order Correlation Attacks, XL Algorithm and Cryptanalysis of Toyocrypt. In <em>Information Security and Cryptology - ICISC 2002, 5th International Conference Seoul, Korea, November 28-29, 2002, Revised Papers</em>, pages 182–199, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-11&quot;&gt;&lt;/span&gt;[Cou03] Nicolas Courtois. Fast Algebraic Attacks on Stream Ciphers with Linear Feedback. In <em>Advances in Cryptology - CRYPTO 2003, 23rd Annual International Cryptology Conference, Santa Barbara, California, USA, August 17-21, 2003, Proceedings</em>, pages 176–194, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-7&quot;&gt;&lt;/span&gt;[CT15] Claude Carlet and Deng Tang. Enhanced Boolean functions suitable for the filter model of pseudo-random generator. <em>Des. Codes Cryptography</em>, 76(3):571–587, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-16&quot;&gt;&lt;/span&gt;[DDLL13] Leo Ducas, Alain Durmus, Tancr ´ ede Lepoint, and Vadim Lyubashevsky. Lattice signatures and bimodal gaussians. \` In <em>Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part I</em>, pages 40–56, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-18&quot;&gt;&lt;/span&gt;[DEM15] Christoph Dobraunig, Maria Eichlseder, and Florian Mendel. Higher-order cryptanalysis of lowmc. <em>IACR Cryptology ePrint Archive</em>, 2015:407, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-17&quot;&gt;&lt;/span&gt;[DLMW15] Itai Dinur, Yunwen Liu, Willi Meier, and Qingju Wang. Optimized interpolation attacks on lowmc. <em>IACR Cryptology ePrint Archive</em>, 2015:418, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-12&quot;&gt;&lt;/span&gt;[DLR16] Sebastien Duval, Virginie Lallemand, and Yann Rotella. Cryptanalysis of the FLIP family of stream ciphers. ´ Cryptology ePrint Archive, Report 2016/???, 2016. <a href="http://eprint.iacr.org/">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-18&quot;&gt;&lt;/span&gt;[DM15] Leo Ducas and Daniele Micciancio. FHEW: bootstrapping homomorphic encryption in less than a second. In ´ <em>Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I</em>, pages 617–640, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-14&quot;&gt;&lt;/span&gt;[DS09] Itai Dinur and Adi Shamir. Cube Attacks on Tweakable Black Box Polynomials. In <em>Advances in Cryptology - EUROCRYPT 2009, 28th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cologne, Germany, April 26-30, 2009. Proceedings</em>, pages 278–299, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-19&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-27-13&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-27-11&quot;&gt;&lt;/span&gt;[DSES14] Yarkin Doroz, Aria Shahverdi, Thomas Eisenbarth, and Berk Sunar. Toward practical homomorphic evaluation of ¨ block ciphers using prince. In <em>Financial Cryptography and Data Security - FC 2014 Workshops, BITCOIN and WAHC 2014, Christ Church, Barbados, March 7, 2014, Revised Selected Papers</em>, pages 208–220, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[Fau99] Jean-Charles Faugre. A new efficient algorithm for computing grbner bases (f4). <em>Journal of Pure and Applied Algebra</em>, 139(13):61 – 88, 1999.</li>
      <li>[FM07] Simon Fischer and Willi Meier. Algebraic immunity of s-boxes and augmented functions. In <em>Fast Software Encryption, 14th International Workshop, FSE 2007, Luxembourg, Luxembourg, March 26-28, 2007, Revised Selected Papers</em>, pages 366–381, 2007.</li>
      <li>[FV12] Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. <em>IACR Cryptology ePrint Archive</em>, 2012:144, 2012.</li>
    </ul></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-4&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;[Gen09] Craig Gentry. Fully homomorphic encryption using ideal lattices. In <em>Proceedings of the 41st Annual ACM Symposium on Theory of Computing, STOC 2009, Bethesda, MD, USA, May 31 - June 2, 2009</em>, pages 169–178, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-6&quot;&gt;&lt;/span&gt;[GGNS13] Benoˆıt Gerard, Vincent Grosso, Mar ´ ´ıa Naya-Plasencia, and Franc¸ois-Xavier Standaert. Block ciphers that are easier to mask: How far can we go? In <em>Cryptographic Hardware and Embedded Systems - CHES 2013 - 15th International Workshop, Santa Barbara, CA, USA, August 20-23, 2013. Proceedings</em>, pages 383–399, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-3&quot;&gt;&lt;/span&gt;[GHS12] Craig Gentry, Shai Halevi, and Nigel P. Smart. Homomorphic evaluation of the AES circuit. In <em>Advances in Cryptology - CRYPTO 2012 - 32nd Annual Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2012. Proceedings</em>, pages 850–867, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-17&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-27-5&quot;&gt;&lt;/span&gt;[GLSV14] Vincent Grosso, Gaetan Leurent, Franc¸ois-Xavier Standaert, and Kerem Varici. Ls-designs: Bitslice encryption for ¨ efficient masked software implementations. In <em>Fast Software Encryption - 21st International Workshop, FSE 2014, London, UK, March 3-5, 2014. Revised Selected Papers</em>, pages 18–37, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[GN08] Nicolas Gama and Phong Q. Nguyen. Predicting Lattice Reduction. In <em>Advances in Cryptology EUROCRYPT 2008, 27th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Istanbul, Turkey, April 13-17, 2008. Proceedings</em>, pages 31–51, 2008.</li>
    </ul></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-7&quot;&gt;&lt;/span&gt;[GSW13] Craig Gentry, Amit Sahai, and Brent Waters. Homomorphic Encryption from Learning with Errors: Conceptually-Simpler, Asymptotically-Faster, Attribute-Based. In <em>Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part I</em>, pages 75–92, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-8&quot;&gt;&lt;/span&gt;[HAO15] Ryo Hiromasa, Masayuki Abe, and Tatsuaki Okamoto. Packing Messages and Optimizing Bootstrapping in GSW-FHE. In <em>Public-Key Cryptography - PKC 2015 - 18th IACR International Conference on Practice and Theory in Public-Key Cryptography, Gaithersburg, MD, USA, March 30 - April 1, 2015, Proceedings</em>, pages 699–715, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[HS14] Shai Halevi and Victor Shoup. Algorithms in helib. In <em>Advances in Cryptology CRYPTO 2014 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2014, Proceedings, Part I</em>, pages 554–571, 2014.</li>
    </ul></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt;[KGV14] Alhassan Khedr, P. Glenn Gulak, and Vinod Vaikuntanathan. SHIELD: scalable homomorphic implementation of encrypted data-classifiers. <em>IACR Cryptology ePrint Archive</em>, 2014:838, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-9&quot;&gt;&lt;/span&gt;[KL07] Jonathan Katz and Yehuda Lindell. <em>Introduction to Modern Cryptography</em>. Chapman and Hall/CRC Press, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-15&quot;&gt;&lt;/span&gt;[KMN10] Simon Knellwolf, Willi Meier, and Mar´ıa Naya-Plasencia. Conditional differential cryptanalysis of nlfsr-based cryptosystems. In Masayuki Abe, editor, <em>Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings</em>, volume 6477 of <em>Lecture Notes in Computer Science</em>, pages 130–145. Springer, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-10&quot;&gt;&lt;/span&gt;[Knu69] Donald E. Knuth. <em>The Art of Computer Programming, Volume II: Seminumerical Algorithms</em>. Addison-Wesley, 1969.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-16&quot;&gt;&lt;/span&gt;[KW02] Lars R. Knudsen and David Wagner. Integral cryptanalysis. In Joan Daemen and Vincent Rijmen, editors, <em>Fast Software Encryption, 9th International Workshop, FSE 2002, Leuven, Belgium, February 4-6, 2002, Revised Papers</em>, volume 2365 of <em>Lecture Notes in Computer Science</em>, pages 112–127. Springer, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-20&quot;&gt;&lt;/span&gt;[LF06] Eric Levieil and Pierre-Alain Fouque. An Improved LPN Algorithm. In ´ <em>Security and Cryptography for Networks, 5th International Conference, SCN 2006, Maiori, Italy, September 6-8, 2006, Proceedings</em>, pages 348–359, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-18&quot;&gt;&lt;/span&gt;[LN14] Tancrède Lepoint and Michael Naehrig. A comparison of the homomorphic encryption schemes FV and YASHE. In <em>Progress in Cryptology - AFRICACRYPT 2014 - 7th International Conference on Cryptology in Africa, Marrakesh, Morocco, May 28-30, 2014. Proceedings</em>, pages 318–335, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-14&quot;&gt;&lt;/span&gt;[LP11] Richard Lindner and Chris Peikert. Better Key Sizes (and Attacks) for LWE-Based Encryption. In <em>Topics in Cryptology - CT-RSA 2011 - The Cryptographers' Track at the RSA Conference 2011, San Francisco, CA, USA, February 14-18, 2011. Proceedings</em>, pages 319–339, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-5&quot;&gt;&lt;/span&gt;[LPR10] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. On Ideal Lattices and Learning with Errors over Rings. In Advances in Cryptology - EUROCRYPT 2010, 29th Annual International Conference on the Theory and Applications of Cryptographic Techniques, French Riviera, May 30 - June 3, 2010. Proceedings, pages 1–23, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-10&quot;&gt;&lt;/span&gt;[LR88] Michael Luby and Charles Rackoff. How to Construct Pseudorandom Permutations from Pseudorandom Functions. <em>SIAM J. Comput.</em>, 17(2):373–386, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-11&quot;&gt;&lt;/span&gt;[LRW11] Moses Liskov, Ronald L. Rivest, and David Wagner. Tweakable block ciphers. J. Cryptology, 24(3):588-613, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-13&quot;&gt;&lt;/span&gt;[Mei11] Willi Meier. Fast Correlation Attacks: Methods and Countermeasures. In Fast Software Encryption - 18th International Workshop, FSE 2011, Lyngby, Denmark, February 13-16, 2011, Revised Selected Papers, pages 55–67, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-7&quot;&gt;&lt;/span&gt;[MP12] Daniele Micciancio and Chris Peikert. Trapdoors for lattices: Simpler, tighter, faster, smaller. In Advances in Cryptology - EUROCRYPT 2012 - 31st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cambridge, UK, April 15-19, 2012. Proceedings, pages 700–718, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-16&quot;&gt;&lt;/span&gt;[MR09] Daniele Micciancio and Oded Regev. Lattice-based cryptography. Springer, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-3&quot;&gt;&lt;/span&gt;[MS88] Willi Meier and Othmar Staffelbach. Fast Correlation Attacks on Stream Ciphers (Extended Abstract). In <em>Advances in Cryptology - EUROCRYPT '88, Workshop on the Theory and Application of of Cryptographic Techniques, Davos, Switzerland, May 25-27, 1988, Proceedings</em>, pages 301–314, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;[NLV11] Michael Naehrig, Kristin E. Lauter, and Vinod Vaikuntanathan. Can homomorphic encryption be practical? In <em>Proceedings of the 3rd ACM Cloud Computing Security Workshop, CCSW 2011, Chicago, IL, USA, October 21, 2011</em>, pages 113–124, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;[PRC12] Gilles Piret, Thomas Roche, and Claude Carlet. PICARO - A block cipher allowing efficient higher-order side-channel resistance. In <em>Applied Cryptography and Network Security - 10th International Conference, ACNS 2012, Singapore, June 26-29, 2012. Proceedings</em>, pages 311–328, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-4&quot;&gt;&lt;/span&gt;[Reg05] Oded Regev. On lattices, learning with errors, random linear codes, and cryptography. In <em>Proceedings of the 37th Annual ACM Symposium on Theory of Computing, Baltimore, MD, USA, May 22-24, 2005</em>, pages 84–93, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-17&quot;&gt;&lt;/span&gt;[RS10] Markus Rückert and Michael Schneider. Estimating the security of lattice-based cryptosystems. <em>IACR Cryptology ePrint Archive</em>, 2010:137, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-15&quot;&gt;&lt;/span&gt;[SE94] Claus-Peter Schnorr and M. Euchner. Lattice basis reduction: Improved practical algorithms and solving subset sum problems. <em>Math. Program.</em>, 66:181–199, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-2&quot;&gt;&lt;/span&gt;[Sie85] Thomas Siegenthaler. Decrypting a Class of Stream Ciphers Using Ciphertext Only. <em>IEEE Trans. Computers</em>, 34(1):81–85, 1985.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-9&quot;&gt;&lt;/span&gt;[SPY13] François-Xavier Standaert, Olivier Pereira, and Yu Yu. Leakage-resilient symmetric cryptography under empirically verifiable assumptions. In <em>Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part I</em>, pages 335–352, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-6&quot;&gt;&lt;/span&gt;[Ver10] Roman Vershynin. Introduction to the non-asymptotic analysis of random matrices. CoRR, abs/1011.3027, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-12&quot;&gt;&lt;/span&gt;[Wie86] Douglas H. Wiedemann. Solving sparse linear equations over finite fields. <em>IEEE Transactions on Information Theory</em>, 32(1):54–62, 1986.</p></li>
    </ul>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-28-8&quot;&gt;&lt;/span&gt;A Correctness and security of Batch GSW</h3>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-28-19&quot;&gt;&lt;/span&gt;Lemma 14 (Correctness of Batch GSW scheme).</h4>

    <p class="text-gray-300">For every  <span class="math">(pk^H, sk^H) \\leftarrow H</span> . Key <span class="math">Gen(n, q, r, \\chi)</span> ,  <span class="math">\\mathbf{m} \\in \\{0, 1\\}^r</span>  and  <span class="math">\\mathbf{C} \\leftarrow H</span> .  <span class="math">Enc(pk^H, \\mathbf{m})</span>  (respectively  <span class="math">\\mathbf{C}_f \\leftarrow H</span> .  <span class="math">Eval(f, \\mathbf{C}_1, \\cdots, \\mathbf{C}_k, pk^H)</span>  such that for all  <span class="math">i \\in [r]</span> ,  <span class="math">|\\mathbf{s}_i^{\\mathsf{T}} \\mathbf{c}_{i\\ell} - m_i 2^{\\ell-1} \\mod q| &lt; 2^{\\ell-2}</span>  (where  <span class="math">x \\mod q \\in [-q/2+1, q/2]</span> ) we have  <span class="math">\\mathbf{m} = H</span> .  <span class="math">Dec(\\mathbf{C}, sk^H)</span>  (respectively  <span class="math">f(\\mathbf{m}_1, \\cdots, \\mathbf{m}_k) \\mod 2 = H</span> .  <span class="math">Dec(\\mathbf{C}_f, sk^H)</span> ).</p>

    <p class="text-gray-300"><em>Proof.</em> With the expression of  <span class="math">\\mathbf{SC}</span>  for all  <span class="math">i \\in [r]</span> ,  <span class="math">\\mathbf{s}_i^{\\mathsf{T}} \\mathbf{c}_{i\\ell}</span>  can be written as  <span class="math">(\\mathbf{SC})_{i,i\\ell} = e&#x27;_{i,i\\ell} + 2^{\\ell-1} m_i \\mod q</span> . Then if  <span class="math">|e&#x27;_{i,i\\ell}| \\mod q | &lt; 2^{\\ell-2}</span> , the rounding in the decryption algorithm outputs  <span class="math">m_i</span> . If the inequality is correct for all  <span class="math">i \\in [r]</span> ,  <span class="math">\\mathbf{m} = H.\\mathsf{Dec}(\\mathbf{C},\\mathsf{sk}^H)</span> .</p>

    <p class="text-gray-300">Note that a sufficient condition for correctness is to ensure:  <span class="math">\\forall (i,j) \\in [r] \\times [N], |e&#x27;_{i,j}| &lt; 2^{\\ell-2};</span></p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Lemma 15 (Security of Batch GSW scheme).</h4>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{B}, \\mathbf{R}_m, \\mathbf{R}</span>  be generated in H. KeyGen and H. Enc. Then the joint distribution  <span class="math">(\\mathbf{B}, \\mathbf{B}\\mathbf{R}_m, \\mathbf{B}\\mathbf{R})</span>  is computationally indistinguishable from uniform over  <span class="math">\\mathbf{Z}_q^{(n+r)\\times m} \\times \\mathbf{Z}_q^{(n+r)\\times N} \\times \\mathbf{Z}_q^{(n+r)\\times N}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> <strong>B</strong> is indistinguishable from uniform over  <span class="math">\\mathbf{Z}_q^{(n+r)\\times m}</span>  using the dLWE <span class="math">_{q,n,m,\\chi}</span>  assumption r times. Then we can apply the leftover hash lemma on  <span class="math">(\\mathbf{B},\\mathbf{B}\\mathbf{R}_m)</span>  and  <span class="math">(\\mathbf{B},\\mathbf{B}\\mathbf{R})</span>  which concludes the proof.</p>

    <h2 id="sec-24" class="text-2xl font-bold">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;B Correctness and security of Ring-GSW</h2>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">Lemma 16 (Correctness of Ring-GSW scheme).</h3>

    <p class="text-gray-300">For every  <span class="math">(pk^H, sk^H) \\leftarrow H</span> . Key <span class="math">Gen(n, q, \\chi, \\mathcal{M}), m \\in \\mathcal{M}</span>  and  <span class="math">\\mathbf{C} \\leftarrow H</span> .  <span class="math">Enc(pk^H, m)</span>  (respectively  <span class="math">\\mathbf{C}_f \\leftarrow H</span> .  <span class="math">Eval(f, \\mathbf{C}_1, \\cdots, \\mathbf{C}_k, pk^H)</span> ) such that all the coefficients of  <span class="math">|\\mathbf{s}^\\top \\mathbf{c}_\\ell - m2^{\\ell-1} \\mod q|</span>  are inferiors to  <span class="math">2^{\\ell-2}</span>  then we have m = H.  <span class="math">Dec(\\mathbf{C}, sk^H)</span>  (respectively  <span class="math">f(m_1, \\cdots, m_k) \\mod 2 = H</span> .  <span class="math">Dec(\\mathbf{C}_f, sk^H)</span> ).</p>

    <p class="text-gray-300">The proof follows directly the one of lemma 14 for each coefficient of the polynomial.</p>

    <p class="text-gray-300"><strong>Lemma 17</strong> (Security of Ring-GSW scheme ). Let  <span class="math">pk^H \\leftarrow H</span> . KeyGen and  <span class="math">\\mathbf{C} \\leftarrow H</span> . Enc <span class="math">(pk^H, m)</span> . Then the joint distribution  <span class="math">(\\mathbf{b}, \\mathbf{C})</span>  is computationally indistinguishable from uniform over  <span class="math">R_q^{2\\times 1} \\times R_q^{2\\times N}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> <strong>b</strong> is computationally indistinguishable from uniform over  <span class="math">R_q^2</span>  using the  <span class="math">dRLWE_{R,q,\\chi}</span>  assumption. Applying the  <span class="math">dRLWE_{R,q,\\chi}</span>  assumption with a secret from  <span class="math">R_{0,1}</span>  on  <span class="math">(\\mathbf{b},\\mathbf{r},\\mathbf{E})</span> ,  <span class="math">(\\mathbf{b},\\mathbf{C})</span>  is indistinguishable from uniform over  <span class="math">R_q^{2\\times 1}\\times R_q^{2\\times N}</span>  which concludes the proof.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">C Proofs</h4>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-29-1&quot;&gt;&lt;/span&gt;C.1 Proof of Lemma 3</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1,2. see [Car10] page 125.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the first part of the inequality:</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">For  <span class="math">i \\in \\{1,2\\}</span> , let  <span class="math">h_i</span>  be an annihilator of  <span class="math">f_i</span>  or  <span class="math">1 \\oplus f_i</span>  of degree  <span class="math">\\mathsf{AI}(f_i)</span> . Then  <span class="math">h_1 \\cdot h_2 \\cdot f = 0</span>  or  <span class="math">h_1 \\cdot h_2 \\cdot (1 \\oplus f) = 0</span> .</p>

    <p class="text-gray-300">Finally  <span class="math">deg(h_1h_2) = AI(f_1) + AI(f_2)</span> , so  <span class="math">AI(f) \\le AI(f_1) + AI(f_2)</span> .</p>

    <p class="text-gray-300">We prove the second part of the inequality by contradiction:</p>

    <p class="text-gray-300">Consider that  <span class="math">AI(f) &lt; \\max(AI(f_1), AI(f_2))</span> . Without loss of generality we have:</p>

    <p class="text-gray-300"><span class="math">$\\max\\{AI(f_1),AI(f_2)\\} = AI(f_2) \\text{ and } AI(f) &lt; AI(f_2).</span>$</p>

    <p class="text-gray-300">Then  <span class="math">\\exists h</span>  such that fh = 0 or  <span class="math">(1 \\oplus f)h = 0</span>  with  <span class="math">\\deg(h) = \\mathsf{AI}(f)</span> .</p>

    <p class="text-gray-300">Hence we have two possibilities. Either we have:</p>

    <p class="text-gray-300"><span class="math">$f(0,\\dots,0,x_{n_1},\\dots,x_{n_1+n_2-1})h(0,\\dots,0,x_{n_1},\\dots,x_{n_1+n_2-1})=0 \\Rightarrow f_2h=0,</span>$</p>

    <p class="text-gray-300">that is h is an annihilator of f&lt;sup&gt;2&lt;/sup&gt; of degree &lt; AI(f2): there is a contradiction, or we have:</p>

    <p class="text-gray-300"><span class="math">$(f(0,\\cdots,0,x_{n_1},\\cdots,x_{n_1+n_2-1})\\oplus 1)h(0,\\cdots,0,x_{n_1},\\cdots,x_{n_1+n_2-1})=0 \\Rightarrow (f_2\\oplus 1)h=0,</span>$</p>

    <p class="text-gray-300">that is h annihilator of 1 ⊕ f&lt;sup&gt;2&lt;/sup&gt; of degree &lt; AI(f2): there is a contradiction.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Analog to 3.</li>
    </ol>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;C.2 Proof of Lemma <a href="#page-11-0">6</a></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The proof is by induction. T&lt;sup&gt;1&lt;/sup&gt; is a linear function so NL(T1) = 0. Then using Lemma <a href="#page-10-2">3.</a>1, ∀k ∈ N ∗ , Tk+1 = T&lt;sup&gt;k&lt;/sup&gt; ⊕ Πk+1 (where Πk+1 is the monomial of degree k + 1 in the k + 1 last variables). We have the following implications:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>⇒ NL(Tk+1) = NL(T&lt;sup&gt;k&lt;/sup&gt; ⊕ Πk+1),</li>
      <li>⇒ NL(Tk+1) = 2k+1NL(Tk) + 2k(k+1)/2NL(Πk+1) − 2NL(Tk)NL(Πk+1),</li>
      <li>⇒ NL(Tk+1) = (2k+1 − 2)NL(Tk) + 2k(k+1)/&lt;sup&gt;2&lt;/sup&gt; as NL(Πn) = 1, ∀n ≥ 2.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By induction suppose that for k ≥ 1,res(Tk) = 0. The function T&lt;sup&gt;1&lt;/sup&gt; has one variable and therefore its resiliency is 0. By construction, for <code> ≥ 1, T</code>+1 is the direct sum of T<code>and a monomial of degree</code> + 1. This monomial has a resiliency of −1. By Lemma <a href="#page-10-2">3.</a>2, res(T<code>+1) = 1 + res(T</code>) + res(Π\`+1) = 0. In conclusion for all k ∈ N &lt;sup&gt;∗&lt;/sup&gt; we have res(Tk) = 0.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By induction on k we prove that for all k ∈ N ∗ , AI(Tk) = k. For k = 1 we have T&lt;sup&gt;1&lt;/sup&gt; = x&lt;sup&gt;0&lt;/sup&gt; of algebraic immunity AI(x0) ≥ 1 by definition. Hence 1 ⊕ x&lt;sup&gt;0&lt;/sup&gt; is a degree 1 annihilator of x&lt;sup&gt;0&lt;/sup&gt; and we have AI(T1) = 1.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For k = <code>, by the induction hypothesis we have that AI(T</code>) = <code>. We want now to determine AI(T</code>+1) where T<code>+1 = T</code> ⊕ Π<code>+1 with Π</code>+1 the product of the <code> + 1 variables which are not in T</code> . Π<code>+1 is a monomial of degree </code> + 1, therefore its AI is 1. By Lemma <a href="#page-10-2">3</a> we have that <code> + 1 ≥ AI(T</code>+1) ≥ \`.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">We prove the induction hypothesis by contradiction: suppose that AI(T<code>+1) = </code>, then ∃h such that deg(h) = <code> and h · T</code>+1 = 0 or h · (1 ⊕ T\`+1) = 0. Hence we have two different cases:</p>

    <p class="text-gray-300">– Case h·T<code>+1 = 0. Let decompose h as h&lt;sup&gt;T&lt;/sup&gt; ⊕h&lt;sup&gt;Π&lt;/sup&gt; ⊕hmix, a decomposition of monomials of variables taken respectively from T</code> , Π\`+1 and the mixed part between the two.</p>

    <p class="text-gray-300">Restricting the equation h·T<code>+1 = 0 to the variables from T</code> we obtain h&lt;sup&gt;T&lt;/sup&gt; ·T<code>= 0. So by induction hypothesis we have deg(h&lt;sup&gt;T&lt;/sup&gt; ) =</code> or h&lt;sup&gt;T&lt;/sup&gt; = 0. Again two cases are possible:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">When deg(h&lt;sup&gt;T&lt;/sup&gt; ) = <code>. Then h · T</code>+1 = 0 ⇔ (h&lt;sup&gt;T&lt;/sup&gt; ⊕ h&lt;sup&gt;Π&lt;/sup&gt; ⊕ hmix) · T<code>+1 = h&lt;sup&gt;T&lt;/sup&gt; · Π</code>+1 ⊕ h&lt;sup&gt;Π&lt;/sup&gt; · T<code> ⊕ hmix · T</code> ⊕ hmix · Π<code>+1 = 0 The first polynomial h&lt;sup&gt;T&lt;/sup&gt; · Π</code>+1 contains at least one monomial of degree 2<code> + 1 divisible by Π</code>+1. The degrees of the second and third polynomials are at most 2<code> ≥ deg(h) + deg(T</code>). By construction all the monomials of hmix have at most <code> − 1 variables from T</code> then hmix · Π<code>+1 has no monomial of degree 2</code> + 1 and the equation is leading to a contradiction.</p></li>
      <li><p class="text-gray-300">When h&lt;sup&gt;T&lt;/sup&gt; = 0. Then h·T<code>+1 = 0 ⇔ (0⊕hΠ⊕hmix)·T</code>+1 = hΠ·T<code>⊕hmix·T</code>+hmix·Π<code>+1 = 0. Only the last polynomial contains monomials with all variables of Π</code>+1, then the equation is false or h = 0, both leading to a contradiction.</p></li>
      <li><p class="text-gray-300">Case  <span class="math">h \\cdot (1 \\oplus T_{\\ell+1}) = 0</span> . We use the same decomposition technique leading to a contradiction.</p></li>
    </ul>

    <p class="text-gray-300">To sum up,  <span class="math">AI(T_{\\ell+1}) = \\ell + 1</span> , so from the initialization step k = 1 and the induction step  <span class="math">k = \\ell</span>  we conclude that  <span class="math">\\forall k \\in \\mathbb{N}^*</span> ,  <span class="math">AI(T_k) = k</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By contradiction, let consider that  <span class="math">FAI(T_k) &lt; k + 1</span> .</li>
    </ol>

    <p class="text-gray-300">By definition we have:</p>

    <p class="text-gray-300"><span class="math">$\\min\\{2AI(T_k), \\max\\{\\deg(g \\cdot T_k) + \\deg(g), 3\\deg(g)\\} \\mid 1 \\leq \\deg(g) &lt; \\mathsf{AI}(T_k)\\} &lt; k+1.</span>$</p>

    <p class="text-gray-300">And by Lemma 6 we have:</p>

    <p class="text-gray-300"><span class="math">$\\min\\{2k, \\max\\{\\deg(g \\cdot T_k) + \\deg(g), 3\\deg(g)\\} \\mid 1 \\le \\deg(g) &lt; k\\} &lt; k+1.</span>$</p>

    <p class="text-gray-300">Hence it implies that:</p>

    <p class="text-gray-300"><span class="math">$\\exists g \\mid \\deg(g \\cdot T_k) + \\deg(g) &lt; k+1</span>$
and  <span class="math">3 \\cdot \\deg(g) &lt; k+1</span> .</p>

    <p class="text-gray-300">We have that  <span class="math">T_k \\oplus 1</span>  is an annihilator of  <span class="math">g \\cdot T_k</span> . Then  <span class="math">T_k(g \\cdot T_k \\oplus g) = 0</span>  implies that  <span class="math">g \\cdot T_k \\oplus g = 0</span>  or  <span class="math">\\deg(g \\cdot T_k \\oplus g) \\geq k</span> .</p>

    <p class="text-gray-300">If  <span class="math">g \\cdot T_k \\oplus g = 0</span> , we have either g = 0 or  <span class="math">\\deg(g) \\ge k</span> , which is a contradiction.</p>

    <p class="text-gray-300">If  <span class="math">\\deg(gT_k \\oplus g) \\geq k</span>  then we get  <span class="math">\\deg(g) \\geq k</span>  or  <span class="math">\\deg(gT_k) \\geq k</span> . The first inequation leads to a contradiction.</p>

    <p class="text-gray-300">The second inequation leads to  <span class="math">\\deg(g \\cdot T_k) + \\deg(g) \\ge k + 1</span>  which is a contradiction.</p>

    <p class="text-gray-300">To sum up,  <span class="math">\\mathsf{FAI}(T_k) \\ge k+1</span>  and taking  <span class="math">g = 1 \\oplus x_{k(k+1)/2-1}</span> , we have that  <span class="math">\\deg(g \\cdot T_k) + \\deg(g) = k+1</span>  and therefore  <span class="math">\\mathsf{FAI}(T_k) = k+1</span> .</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;D Details on BKW-like attack</h4>

    <p class="text-gray-300">Decomposing F in a linear and non-linear part, we can study our filtering function by analogy with LPN and therefore consider the impact of BKW [BKW03] on our construction. Let  <span class="math">\\mathbf{s} \\leftarrow_\\</span> {0,1}^N$ . A LPN sample is a couple  <span class="math">(\\mathbf{a}, \\langle \\mathbf{a}, \\mathbf{s} \\rangle + \\nu)</span>  such that  <span class="math">\\mathbf{a} \\leftarrow_\\</span> {0,1}^N$  and  <span class="math">\\nu \\leftarrow_\\</span>$  Bernoulli <span class="math">(\\varepsilon)</span> . At each cycle of the filter permutator, the permutation on the linear part of F of  <span class="math">\\ell</span>  bits is analogous to the random choice of  <span class="math">\\mathbf{a}</span> , with the restriction that its hamming weight is fixed to  <span class="math">\\ell</span> . Then the non-linear part of F can be considered as the  <span class="math">\\nu</span>  part of a LPN sample, such that the output bit follows a Bernoulli distribution with parameter  <span class="math">\\varepsilon = \\frac{\\mathsf{NL}(F)}{2^N}</span> . As in our case the  <span class="math">\\mathbf{a}</span>  distribution is restricted and the output bits are produced from dependent distributions, we cannot formally reduce the filter permutator key recovery to the search-LPN problem. Nevertheless, we can evaluate the computational cost of a strategy similar to the BKW algorithm to recover the key, based on the LF1 algorithm complexity [LF06].</p>

    <p class="text-gray-300">Namely, writing N as a*b, the main point of the attack is to find a lot of groups of  <span class="math">2^a</span>  well-chosen vectors such that  <span class="math">\\mathbf{a}_1 \\oplus \\cdots \\oplus \\mathbf{a}_{2^a} = \\mathbf{e}_j</span> . With  <span class="math">2^a</span>  a small number, the bias introduced by XORing  <span class="math">2^a</span>  LPN samples is not too small, enabling to recover  <span class="math">\\mathbf{s}_j</span>  from a majority vote over the different groups of  <span class="math">2^a</span>  vectors, since  <span class="math">\\langle \\mathbf{s}, \\mathbf{a}_1 \\oplus \\cdots \\oplus \\mathbf{a}_{2^a} \\rangle = \\langle \\mathbf{s}, \\mathbf{e}_j \\rangle = \\mathbf{s}_j</span> . For our construction, the case a=1 is impossible: as the Hamming weight of each  <span class="math">\\mathbf{a}_i</span>  is the same, no difference can give a vector of Hamming weight 1. Therefore, at least two XORs are needed to obtain a new vector with Hamming weight 1. Let  <span class="math">\\delta = 0.5 - \\varepsilon</span>  be the bias of the original vectors. This implies that the bias of such new vectors is  <span class="math">\\delta^3</span> . To distinguish this bias and to recover  <span class="math">\\mathbf{s}_j</span> , we therefore need  <span class="math">\\mathcal{O}(\\delta^{-6})</span>  operations. Such an attack can be extended by finding vectors such that the sum is</p>

    <p class="text-gray-300"><span class="math">\\mathbf{e}_i \\oplus \\mathbf{e}_j</span> , which leads to perform at least one XOR to obtain a targeted vector if  <span class="math">\\ell &gt; 2</span> . The computational cost of recovering one sum is then  <span class="math">\\mathcal{O}(\\delta^{-4})</span> . It leads to a complexity  <span class="math">\\mathcal{O}(N\\delta^{-4})</span>  to recover all the key. For the case where  <span class="math">\\ell = 2</span> , there is no need to perform XORs: the  <span class="math">\\mathbf{a}_i</span> 's are already of Hamming weight 2 and the corresponding attacks are therefore the correlation attack described in Section 3.4. But we can extend this attack considering vectors of Hamming weight  <span class="math">h \\leq \\ell</span> , and number of XORs x, leading to a (conservative) complexity of  <span class="math">\\mathcal{O}(2^h\\delta^{-2(x+1)})</span> .</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-32-0&quot;&gt;&lt;/span&gt;<strong>E</strong> Guess And Determine Proofs</h4>

    <p class="text-gray-300"><em>Proof of lemma 7.</em> 1. We prove this property by induction on  <span class="math">\\ell</span> .</p>

    <p class="text-gray-300">For  <span class="math">\\ell=0</span> : without guessing F[0]=F therefore  <span class="math">\\sum_{i=1}^{\\deg(F[\\ell])} m_i[\\ell]=\\sum_{i=1}^{\\deg(F)} m_i</span>  and the property is true.</p>

    <p class="text-gray-300">From j to j+1: After guessing j variables we obtain F[j] satisfying the induction property. Without loss of generality, let consider that we guess an extra variable  <span class="math">x_d</span>  contributing in a monomial of degree d. We have then two distinct cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Case  <span class="math">x_d=0</span> . The monomial of degree d containing  <span class="math">x_d</span>  is cancelled therefore  <span class="math">\\mathbf{m}_{F[j+1]}</span>  the resulting vector is such that  <span class="math">m_d[j+1]=m_d[j]-1</span>  and  <span class="math">\\forall i\\neq d; m_i[j+1]=m_i[j]</span>  for all the coefficients correctly defined (by definition  <span class="math">m_i</span>  is defined if  <span class="math">\\exists k\\geq i</span>  such that  <span class="math">m_k&gt;0</span> , i.e.  <span class="math">\\mathbf{m}_{F[j+1]}</span>  can be shorter than  <span class="math">\\mathbf{m}_{F[j]}</span> ). Then  <span class="math">\\sum_{i=1}^{\\deg(F[j+1])}m_i[j+1]=(\\sum_{i=1}^{\\deg(F[j])}m_i[j])-1\\geq (\\sum_{i=1}^{\\deg(F)}m_i)-(j+1)\\geq (\\sum_{i=1}^{\\deg(F)}m_i)-\\ell</span> ; the property is verified.</li>
      <li>Case  <span class="math">x_d=1</span> . The monomial of degree d containing  <span class="math">x_d</span>  is turned into a degree d-1 monomial therefore  <span class="math">\\mathbf{m}_{F[j+1]}</span>  the resulting vector is such that  <span class="math">m_d[j+1]=m_d[j]-1</span> ,  <span class="math">m_{d-1}[j+1]=m_{d-1}[j]+1</span>  and  <span class="math">\\forall i\\neq d</span>  or d-1;  <span class="math">m_i[j+1]=m_i[j]</span>  for all the coefficients correctly defined (by definition  <span class="math">m_i</span>  is defined if i&gt;0, i.e. d=1 is the only case diminishing the sum). Then  <span class="math">\\sum_{i=1}^{\\deg(F[j+1])} m_i[j+1] \\geq (\\sum_{i=1}^{\\deg(F)} m_i[j]) 1 \\geq (\\sum_{i=1}^{\\deg(F)} m_i) (j+1) \\geq (\\sum_{i=1}^{\\deg(F)} m_i) \\ell</span> ; the property is verified. In conclusion the property is true for all  <span class="math">0\\leq \\ell \\leq N</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The precedent property on  <span class="math">\\mathbf{m}_F</span>  stands that at most one  <span class="math">m_i</span>  is diminished by each guessing therefore :  <span class="math">\\mathbf{m}_{F[\\ell]}^* \\geq \\mathbf{m}_F^* \\max_{\\pi \\in S_{\\deg(F)}} \\{j | (\\sum_{k=1}^j m_{\\pi(k)}) \\leq \\ell \\}</span>  with  <span class="math">S_{\\deg(F)}</span>  the group of permutation of  <span class="math">\\deg(F)</span>  elements.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">This maximum corresponds to the maximal number of  <span class="math">m_i</span> 's that can be cancelled with  <span class="math">\\ell</span>  guesses. We can bound it by:  <span class="math">\\max_{\\pi \\in S_{\\deg(F)}} \\{j | (\\sum_{k=1}^j m_{\\pi(k)}) \\leq \\ell\\} \\leq \\lfloor \\frac{\\ell}{\\min_{1 \\leq i &lt; \\deg(F)} m_i} \\rfloor</span> .</p>

    <p class="text-gray-300">Using this bound corresponding to the worst case (all  <span class="math">m_i</span> 's being minimal) we get:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{m}_{F[\\ell]}^* \\ge \\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{1 \\le i \\le \\deg(F)} m_i} \\rfloor.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First we study the parameter  <span class="math">\\delta_{\\mathbf{m}_F}</span>  on similar functions. We focus on  <span class="math">\\delta_{\\mathbf{m}_F}</span>  and  <span class="math">\\delta_{\\mathbf{m}_G}</span>  where F is the direct sum of G (of N-d variables) and a monomial of degree d&gt;1.</li>
    </ol>

    <p class="text-gray-300">By the property of nonlinearity of direct sums we have  <span class="math">\\mathsf{NL}(F) = (2^d - 2)\\mathsf{NL}(G) + 2^{N-d}</span> , then</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{NL}(G) = \\frac{\\mathsf{NL}(F) - 2^{N-d}}{2^d - 2}.</span>$</p>

    <p class="text-gray-300">Therefore
<span class="math">$\\delta_{\\mathbf{m}_G} = \\frac{1}{2} - \\frac{\\mathsf{NL}(G)}{2^{N-d}} = \\frac{(2^{d-1}-1)2^{N-d} - \\mathsf{NL}(F) + 2^{N-d}}{(2^{d-1}-1)2^{N-d+1}} = \\frac{2^{N-1} - \\mathsf{NL}(F)}{2^N} \\frac{2^{d-1}}{2^{d-1}-1},</span>$
meaning that</p>

    <p class="text-gray-300"><span class="math">$\\delta_{\\mathbf{m}_G} = \\delta_{\\mathbf{m}_F} \\frac{2^{d-1}}{2^{d-1} - 1}.</span>$</p>

    <p class="text-gray-300">The last case to consider is when d=1, then  <span class="math">\\mathsf{NL}(F)=2\\mathsf{NL}(G)</span>  by the property of nonlinearity of direct sums and therefore  <span class="math">\\delta_{\\mathbf{m}_F}=\\delta_{\\mathbf{m}_G}</span> .</p>

    <p class="text-gray-300">Then, using the property on  <span class="math">\\mathbf{m}_F</span>  and that  <span class="math">\\frac{2^{d-1}}{2^{d-1}-1}</span>  decreases when d increases we obtain the bound  <span class="math">\\delta_{\\mathbf{m}_F[\\ell]} \\leq \\delta_{\\mathbf{m}_F} \\Pi_{i=2}^{\\deg(F)} (\\frac{2^{i-1}}{2^{i-1}-1})^{\\ell_i}</span>  such that  <span class="math">\\forall i, \\ell_i \\leq m_i</span>  and  <span class="math">\\sum_{i=1}^{\\deg(F)} \\ell_i = \\ell</span> .</p>

    <p class="text-gray-300">This bound corresponds to the case when all variables are fixed to 0, otherwise fixing a variable to 1 is equivalent to cancel a monomial and add a new one (except if d=1 which does not add a new one).</p>

    <p class="text-gray-300">Optimizing the choices for the  <span class="math">\\ell_i</span>  we can give a tight upper bound on the product; let denote j the integer such that  <span class="math">\\sum_{2 \\le i \\le j} m_i \\le \\ell &lt; \\sum_{2 \\le i \\le j} m_i</span> . Then we have:</p>

    <p class="text-gray-300"><span class="math">$\\varPi_{i=2}^{\\deg(F)}(\\frac{2^{i-1}}{2^{i-1}-1})^{\\ell_i} \\leq (\\varPi_{2 \\leq i &lt; j}(\\frac{2^{i-1}}{2^{i-1}-1})^{m_i})(\\frac{2^{j-1}}{2^{j-1}-1})^{\\ell-\\sum_{2 \\leq i &lt; j} m_i}.</span>$</p>

    <p class="text-gray-300">As  <span class="math">\\ell_2 \\leq \\ell</span>  we consider the worst case :  <span class="math">\\ell_2 = \\ell</span> , giving  <span class="math">\\Pi_{i=2}^{\\deg(F)}(\\frac{2^{i-1}}{2^{i-1}-1})^{\\ell_i} \\leq 2^{\\ell}</span>  and therefore the conservative bound  <span class="math">\\delta_{\\mathbf{m}_F[\\ell]} \\leq \\delta_{\\mathbf{m}_F} 2^{\\ell}</span> .</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-33-0&quot;&gt;&lt;/span&gt;<strong>Algebraic Attacks</strong></h3>

    <p class="text-gray-300"><strong>Lemma 18</strong> (Algebraic Attack on Direct Sums). Let F be a boolean function in N variables obtained by direct sums, therefore  <span class="math">Al(F) \\ge \\mathbf{m}_F^*</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> F is an N variables function with associated vector  <span class="math">\\mathbf{m}_F</span> , we thereafter write F as  <span class="math">F(x_1, \\dots, x_N)</span> . Let d be the highest integer such that  <span class="math">m_d = 0</span>  and is well defined (i.e. it cannot be  <span class="math">m_k</span> ), we can pick two variables of one monomial of F of degree d+1 and denote their product by the variable  <span class="math">X_{N-1}</span> .</p>

    <p class="text-gray-300">Reordering the variables we obtain a function  <span class="math">F_{N-1}(x_1, \\cdots, x_{N-2}, X_{N-1})</span>  with an associated vector without 0 in d-th coordinate and with  <span class="math">m_{d+1}</span>  inferior by one from the previous vector or nonexistent if it reached 0 and was the last coefficient of the vector and such that  <span class="math">\\mathbf{m}_{F_{N-1}}^* \\geq \\mathbf{m}_F^*</span> .</p>

    <p class="text-gray-300">Therefore we can recursively apply this technique to obtain the function  <span class="math">G = F(x_1, \\dots, X_j)</span>  in j variables with associated vector  <span class="math">\\mathbf{m}_G</span>  being null or without coefficients equal to zero (the recursion is ending because  <span class="math">N = \\sum_{i=1}^k i m_i</span>  is finite and applying the technique reduces N and the recursion ends if N = 0).</p>

    <p class="text-gray-300">Considering the last function G and  <span class="math">\\mathbf{m}_G</span>  of length  <span class="math">k&#x27; = \\mathbf{m}_G^* \\ge \\mathbf{m}_F^*</span>  we have that G is the direct sum of  <span class="math">T_{k&#x27;}</span>  ( <span class="math">\\mathbf{m}_{T_n}</span>  is the n-length vector with all components being 1 by definition of  <span class="math">T_n</span> ) and another function. Then by the property of direct sums  <span class="math">\\mathsf{AI}(G) \\ge \\mathsf{AI}(T_{k&#x27;})</span>  therefore  <span class="math">\\mathsf{AI}(G) \\ge \\mathbf{m}_G^*</span> .</p>

    <p class="text-gray-300">That means that there exists no annihilator of degree strictly inferior to  <span class="math">\\mathbf{m}_G^*</span>  for G or G+1 in the variables  <span class="math">x_1, \\dots, x_j</span> . Then by construction of the variables X there exists no annihilator of degree strictly inferior to  <span class="math">\\mathbf{m}_F^*</span>  for F or F+1 in the variables  <span class="math">x_1, \\dots, x_N</span> . We conclude that  <span class="math">\\mathsf{Al}(F) \\geq \\mathbf{m}_F^*</span> .</p>

    <p class="text-gray-300">Now we consider the best complexity of combining Guess And Determine and Algebraic Attacks.</p>

    <p class="text-gray-300"><strong>Lemma 19</strong> (Guess And Determine &amp; Algebraic Attack). Let F be a boolean function in N variables and  <span class="math">C_{GDAA}(F)</span>  (respectively  <span class="math">C_{AA}(F)</span> ) be the minimum complexity of the Guess And Determine with Algebraic Attack (respectively Algebraic Attack) on F, then:</p>

    <p class="text-gray-300"><span class="math">$C_{GDAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left[ 2^{\\ell} \\binom{\\min N[\\ell]}{\\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor}^{\\omega} \\right].</span>$</p>

    <p class="text-gray-300"><em>Proof.</em>  <span class="math">C_{GDAA}(F) = \\min(2^{\\ell}C_{AA}(F[\\ell]))</span>  by definition, with the minimum taken over all guessing of  <span class="math">\\ell</span> variables, with  <span class="math">0 \\le \\ell \\le N</span> .</p>

    <p class="text-gray-300">We then have
<span class="math">$C_{GDAA}(F) = \\min[2^{\\ell}(\\sum_{i=1}^{\\mathsf{AI}(F[\\ell])} \\binom{N[\\ell]}{i})^{\\omega}] \\ge \\min[2^{\\ell}\\binom{N[\\ell]}{\\mathsf{AI}(F[\\ell])}].</span>$</p>

    <p class="text-gray-300">As for all Boolean function the algebraic immunity is less than half the number of its variables, for all fixed  <span class="math">\\ell</span>  we can use the bound  <span class="math">\\binom{N[\\ell]}{\\mathsf{Al}(F[\\ell])} \\geq \\binom{\\min N[\\ell]}{\\min \\mathsf{Al}(F[\\ell])}</span>  where the minimum is taken over all functions obtained by guessing  <span class="math">\\ell</span>  variables.</p>

    <p class="text-gray-300">Moreover  <span class="math">\\mathsf{AI}(F[\\ell]) \\geq \\mathbf{m}_{F[\\ell]}^* \\geq \\mathbf{m}_F^* - \\lfloor \\frac{\\ell}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor</span>  by lemmas 7.2 and 18. We recall that  <span class="math">\\min N[\\ell]</span> is the smallest number of variables of a function obtained by cancelling  <span class="math">\\ell</span>  variables of F; this quantity is easily computable and may be smaller than the number of variables of the function used for the actual attack.</p>

    <p class="text-gray-300">Putting all thing together leads to:
<span class="math">$C_{GDAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} \\left[ 2^{\\ell} \\binom{\\min N[\\ell]}{\\min_{i \\in [\\deg(F)]} m_i} \\right]</span>$
.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8"><strong>Fast Algebraic Attacks</strong></h3>

    <p class="text-gray-300"><em>Proof.</em> Proof of Lemma 8</p>

    <p class="text-gray-300"><span class="math">C_{GDFAA}(F) = \\min(2^{\\ell}C_{FAA}(F[\\ell]))</span>  by definition, with the minimum taken over all guessing of  <span class="math">\\ell</span> variables, with  <span class="math">0 \\le \\ell \\le N</span> .</p>

    <p class="text-gray-300">Then for all Boolean function f,  <span class="math">C_{FAA}(f) = \\min[(D \\log^2 D + E^2 D + E^{\\omega})]</span>  where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the minimum is taken over all Boolean functions g and h such that fg = h,</li>
      <li><span class="math">-d = \\deg(h)</span>  and  <span class="math">e = \\deg(q)</span> ,</li>
      <li><span class="math">-D = \\sum_{i=1}^{d} {N \\choose i}</span>  and  <span class="math">E = \\sum_{i=1}^{e} {N \\choose i}</span> ,</li>
      <li><span class="math">\\omega</span>  is the exponent appearing in solving a linear system.</li>
    </ul>

    <p class="text-gray-300">As we need to bound d and e for all guesses, we use the following property of the algebraic immunity:  <span class="math">fg = h \\Rightarrow g = fh \\Rightarrow f(g+h) = 0</span> . By definition of Al(f),  <span class="math">\\deg(g+h) \\geq \\operatorname{Al}(f)</span>  therefore  <span class="math">\\max(d,e) \\geq \\operatorname{Al}(f)</span> AI(f).</p>

    <p class="text-gray-300">As  <span class="math">C_{FAA}(f)</span>  is defined as a minimal value over all choices of g and h such that fg = h, we can restrict the choices to  <span class="math">1 \\le e \\le d</span>  with  <span class="math">d \\ge \\mathsf{AI}(f)</span> . Therefore we get:</p>

    <p class="text-gray-300"><span class="math">$C_{FAA}(f) = \\min(D\\log^2 D + E^2 D + E^{\\omega}) \\ge \\min(\\binom{N}{d}\\log^2\\binom{N}{d} + \\binom{N}{e}^2\\binom{N}{d} + \\binom{N}{e}^{\\omega}).</span>$</p>

    <p class="text-gray-300"><span class="math">$C_{FAA}(f) \\ge {N \\choose \\mathsf{AI}(f)} \\log^2 {N \\choose \\mathsf{AI}(f)} + {N \\choose 1}^2 {N \\choose \\mathsf{AI}(f)} + {N \\choose 1}^{\\omega}</span>$
. Using lemma 18 on our particular functions  <span class="math">F[\\ell]</span>  we obtain:</p>

    <p class="text-gray-300"><span class="math">$C_{FAA}(F[\\ell]) \\ge \\binom{N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} \\log^2 \\binom{N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} + (N[\\ell])^2 \\binom{N[\\ell]}{\\mathbf{m}_{F[\\ell]}^*} + (N[\\ell])^{\\omega}.</span>$</p>

    <p class="text-gray-300">We can use the bound  <span class="math">\\binom{N[\\ell]}{\\mathbf{m}_F^*[\\ell]} \\geq \\binom{\\min N[\\ell]}{\\mathbf{m}_F^* - \\lfloor \\frac{\\min N[\\ell]}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor}</span>  using that  <span class="math">\\mathsf{AI}(F[\\ell]) \\leq \\frac{N[\\ell]}{2}</span>  and lemma 7. Therefore :</p>

    <p class="text-gray-300"><span class="math">$C_{GDFAA}(F) \\geq \\min_{0 \\leq \\ell \\leq N} [2^{\\ell} (C \\log^2 C + (\\min N[\\ell])^2 C + (\\min N[\\ell])^{\\omega})],</span>$
where  <span class="math">C = {\\min_{\\mathbf{m}^* - \\lfloor \\frac{\\min N[\\ell]}{\\min_{i \\in [\\deg(F)]} m_i} \\rfloor}.</span></p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6"><strong>CA/BKW-like Attack</strong></h4>

    <p class="text-gray-300"><strong>Lemma 20</strong> (Guess and Determine &amp; CA/BKW-like Attack). Let F be a boolean function in N variables and  <span class="math">C_{GDCA/BKW}(F)</span>  be the minimum complexity of the Guess And Determine with Correlation/BKW Attack on F, then :</p>

    <p class="text-gray-300"><span class="math">$C_{GDCA/BKW}(F) \\ge \\min_{0 \\le \\ell \\le N} \\{ 2^{-\\ell} \\delta_{\\mathbf{m}_F}^{-2} \\}.</span>$</p>

    <p class="text-gray-300">Proof.  <span class="math">C_{GDCA/BKW}(F) = \\min\\{2^{\\ell}C_{CA}(F[\\ell]), 2^{\\ell}C_{BKW}(F[\\ell])\\} \\geq \\min\\{2^{\\ell}(\\delta_{\\mathbf{m}_{F[\\ell]}})^{-2}\\}</span>  where  <span class="math">C_{CA}</span>  and  <span class="math">C_{BKW}</span>  stand for the (data) complexity of the correlation and the BKW attack and  <span class="math">\\delta_{\\mathbf{m}_{F[\\ell]}}</span>  is the bias of the function  <span class="math">F[\\ell]</span> , the minimum is taken over all guessing of  <span class="math">\\ell</span>  variables, with  <span class="math">0 \\leq \\ell \\leq N</span> .</p>

    <p class="text-gray-300">From Lemma 7 we know that the bias increases the most when considering the restriction of F to the  <span class="math">N[\\ell]</span>  variables canceling the monomials of degree 2. We can then derive the following bound from Lemma 7:</p>

    <p class="text-gray-300"><span class="math">$(\\delta_{\\mathbf{m}_{F[\\ell]}})^{-2} \\ge \\delta_{\\mathbf{m}_{F}}^{-2} \\cdot 2^{-2\\ell}.</span>$</p>

    <p class="text-gray-300">Hence we have</p>

    <p class="text-gray-300"><span class="math">$C_{GDCA/BKW}(F) \\ge \\min_{0 \\le \\ell \\le N} \\{ 2^{-\\ell} \\delta_{\\mathbf{m}_F}^{-2} \\}.</span>$</p>

    <p class="text-gray-300"><strong>HOC Attack</strong> The HOC attack leads to consider the best approximation of fixed degree of a Boolean function, which corresponds to determine its non-linearity of order greater than 1. As this characteristic is still generally unknown for almost all functions up to our knowledge, we approximate the non-linearity of order d of a direct sum of monomials F by the distance between F and its restriction  <span class="math">F_d</span>  to degrees up to d monomials. We define  <span class="math">G_d = F \\oplus F_d</span> .</p>

    <p class="text-gray-300">Let F be associated to  <span class="math">\\mathbf{m}_F = [m_1, \\cdots, m_d, \\cdots, m_k]</span> , thereafter we consider  <span class="math">F_d</span>  associated to  <span class="math">\\mathbf{m}_{F_d} = [m_1, \\cdots, m_d, 0, \\cdots, 0]</span>  and  <span class="math">G_d</span>  associated to  <span class="math">\\mathbf{m}_{G_d} = [0, \\cdots, 0, m_{d+1}, \\cdots, m_k]</span> .</p>

    <p class="text-gray-300"><strong>Lemma 21</strong> (Guess and Determine and HOC). Let F be a boolean function in N variables of degree k such that  <span class="math">\\mathbf{m}_F = [m_1, \\dots, m_k]</span> :</p>

    <p class="text-gray-300"><span class="math">$C_{GDHOC} = \\min_{0 \\le \\ell \\le N} \\left( 2^{\\ell} \\min_{1 \\le d \\le \\deg(F)} \\left[ \\binom{\\min N[\\ell]}{D}^{\\omega} \\left( \\frac{1}{2} + \\delta_{\\mathbf{m}_{G_d}} \\left( \\frac{2^d}{2^d - 1} \\right)^{\\ell} \\right)^{-m} \\right] \\right),</span>$</p>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">$d \\le D \\le \\frac{\\min N[\\ell]}{2}</span>$
, for each  <span class="math">\\ell</span> .</p></li>
      <li><p class="text-gray-300"><span class="math">m \\ge \\frac{\\binom{\\min N[\\ell]}{D}}{\\binom{\\min N[\\ell]}{N}}</span> , for each  <span class="math">\\ell</span> .</p></li>
      <li><p class="text-gray-300"><span class="math">$m \\ge \\frac{\\binom{\\min N[\\ell]}{D}}{\\binom{\\min N[\\ell]}{D-d}}</span>$
, for each  <span class="math">\\ell</span> .</p></li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em>  <span class="math">C_{GDHOC} = \\min(2^{\\ell}C_{HOC}(F[\\ell]))</span>  By definition, with the minimum taken over all guessing of  <span class="math">\\ell</span> variables, with  <span class="math">0 \\le \\ell \\le N</span> .</p>

    <p class="text-gray-300">Applying the complexity bound for the HOC attack:</p>

    <p class="text-gray-300"><span class="math">$C_{GDHOC} = \\min(2^{\\ell} \\min_{1 \\leq d \\leq \\deg(F)} [\\binom{N[\\ell]}{D}^{\\omega} (1 - \\varepsilon)^{-m}]),</span>$
where:</p>

    <p class="text-gray-300"><span class="math">$-d \\leq D \\leq N.</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">d \\le D \\le N</span> . -  <span class="math">\\varepsilon = \\frac{d_H(F[\\ell],g)}{2^{N[\\ell]}}</span>  with g a Boolean function of degree at most d.</li>
    </ul>

    <p class="text-gray-300"><span class="math">$- m \\ge \\frac{\\binom{N[\\ell]}{D}}{\\binom{N[\\ell]}{D-d}}.</span>$</p>

    <p class="text-gray-300">First we bound the term  <span class="math">(1-\\varepsilon)</span> , by definition of the non-linearity of order d,  <span class="math">\\min_g(\\frac{d_H(F[\\ell],g)}{2^{N[\\ell]}}) = \\operatorname{NL}_d(F[\\ell])</span> . We approximate  <span class="math">F[\\ell]</span>  by  <span class="math">F[\\ell]_d</span>  and as  <span class="math">F[\\ell] \\oplus F[\\ell]_d</span>  is a direct sum of monomials we obtain :  <span class="math">\\operatorname{NL}_d(F[\\ell]) \\approx \\frac{d_H(F[\\ell],F[\\ell]_d)}{2^{N[\\ell]}} = \\frac{\\operatorname{NL}(F[\\ell] \\oplus F[\\ell]_d)}{2^{N[\\ell]}}.</span></p>

    <p class="text-gray-300"><span class="math">$\\operatorname{NL}_d(F[\\ell]) \\approx \\frac{d_H(F[\\ell], F[\\ell]_d)}{2^{N[\\ell]}} = \\frac{\\operatorname{NL}(F[\\ell] \\oplus F[\\ell]_d)}{2^{N[\\ell]}}</span>$</p>

    <p class="text-gray-300">We write  <span class="math">G[\\ell]_d = F[\\ell] \\oplus F[\\ell]_d</span>  for simplicity, then  <span class="math">\\frac{1}{2} - \\frac{\\mathsf{NL}(F[\\ell] \\oplus F[\\ell]_d)}{2^{N[\\ell]}} = \\delta_{\\mathbf{m}_{G[\\ell]_d}}</span> . As  <span class="math">G[\\ell]_d</span>  contains only monomials of degree greater than d we use Lemma 7(part 3) and get  <span class="math">\\delta_{\\mathbf{m}_{G[\\ell]}} \\leq \\delta_{\\mathbf{m}_{G_d}} (\\frac{2^d}{2^d-1})^\\ell</span> .</p>

    <p class="text-gray-300">We conclude
<span class="math">$(1-\\varepsilon) \\geq (\\frac{1}{2} + \\delta_{\\mathbf{m}_{G_d}}(\\frac{2^d}{2^d-1})^\\ell).</span>$</p>

    <p class="text-gray-300">Then we bound the term  <span class="math">\\binom{N[\\ell]}{D}</span>  and m in consequences. Following [Cou02] we assume D &lt;&lt; N and more precisely  <span class="math">D \\leq \\frac{\\min N[\\ell]}{2}</span>  where the minimum is taken over all guess of  <span class="math">\\ell</span>  bits.</p>

    <p class="text-gray-300">Putting all together we obtain:</p>

    <p class="text-gray-300"><span class="math">$C_{GDHOC} = \\min_{0 \\leq \\ell \\leq N} (2^{\\ell} \\min_{1 \\leq d \\leq \\deg(F)} [\\binom{\\min N[\\ell]}{D}^{\\omega} (\\frac{1}{2} + \\delta_{\\mathbf{m}_{G_d}} (\\frac{2^d}{2^d - 1})^{\\ell})^{-m}]),</span>$
where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300"><span class="math">$d \\le D \\le \\frac{\\min N[\\ell]}{2}</span>$
, for each  <span class="math">\\ell</span> .</p></li>
      <li><p class="text-gray-300"><span class="math">$d \\leq D \\leq \\frac{\\min N[\\ell]}{2}</span>$
, for each  <span class="math">\\ell</span> .</p></li>
      <li><p class="text-gray-300"><span class="math">m \\geq \\frac{\\binom{\\min N[\\ell]}{D}}{\\binom{\\min N[\\ell]}{D-d}}</span> , for each  <span class="math">\\ell</span> .</p></li>
    </ul>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-36-0&quot;&gt;&lt;/span&gt;<strong>Error Growth Proofs</strong></h4>

    <p class="text-gray-300">Proof of lemma 10</p>

    <p class="text-gray-300"><em>Proof.</em> We first prove the lemma in the batched GSW setting following the analysis in [AP14] for the sum of two ciphertexts. Considering the addition of two ciphertexts we can write:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{SC}_{+} = \\mathbf{SC}_{1} + \\mathbf{SC}_{2} = \\mathbf{E}_{1}&#x27; + \\left( \\frac{\\underline{m}_{1,1} \\cdot \\mathbf{s}_{1}^{\\mathsf{T}}}{\\vdots} \\right) \\mathbf{G} + \\mathbf{E}_{2}&#x27; + \\left( \\frac{\\underline{m}_{2,1} \\cdot \\mathbf{s}_{1}^{\\mathsf{T}}}{\\vdots} \\right) \\mathbf{G}.</span>$</p>

    <p class="text-gray-300">The error of  <span class="math">\\mathbf{C}_+</span>  is therefore  <span class="math">\\mathbf{E}_+ = \\mathbf{E}_1&#x27; + \\mathbf{E}_2&#x27; \\in \\mathbb{Z}_q^{r \\times N}</span> ; each row  <span class="math">\\mathbf{e}_{+,j}^{\\mathsf{T}}</span>  for  <span class="math">1 \\leq j \\leq r</span>  is the sum of  <span class="math">\\mathbf{e}_{1,j}^{\\mathsf{T}}</span>  and  <span class="math">\\mathbf{e}_{2,j}^{\\mathsf{T}}</span> . Then for  <span class="math">1 \\leq j \\leq r</span>  the N coefficients of  <span class="math">\\mathbf{e}_{1,j}^{\\mathsf{T}}</span>  (respectively  <span class="math">\\mathbf{e}_{2,j}^{\\mathsf{T}}</span> ) follow a subgaussian distribution of parameter  <span class="math">\\sigma_1</span>  (respectively  <span class="math">\\sigma_2</span> ) and by Pythagorean additivity each coefficient of  <span class="math">\\mathbf{e}_{+,j}^{\\mathsf{T}}</span>  as subgaussian parameter  <span class="math">\\sigma_+ = \\sqrt{\\sigma_1^2 + \\sigma_2^2}</span> .</p>

    <p class="text-gray-300">Then we prove the analogous property in the ring setting. To add two ciphertexts we consider:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{s}^{\\mathsf{T}}\\mathbf{C}_{+} = \\mathbf{s}^{\\mathsf{T}}\\mathbf{C}_{1} + \\mathbf{s}^{\\mathsf{T}}\\mathbf{C}_{2} = \\mathbf{e}_{1}^{\\mathsf{T}} + m_{1}\\mathbf{s}^{\\mathsf{T}}\\mathbf{G} + \\mathbf{e}_{2}^{\\mathsf{T}} + m_{2}\\mathbf{s}^{\\mathsf{T}}\\mathbf{G}.</span>$</p>

    <p class="text-gray-300">The error of  <span class="math">\\mathbf{C}_+</span>  is therefore  <span class="math">\\mathbf{e}_+^{\\mathsf{T}} = \\mathbf{e}_1&#x27;^{\\mathsf{T}} + \\mathbf{e}_2&#x27;^{\\mathsf{T}} \\in \\mathbb{R}^N</span>  where each N coefficient is the sum of polynomials where each component follows a subgaussian distribution of parameter respectively  <span class="math">\\sigma_1</span>  or  <span class="math">\\sigma_2</span> . By Pythagorean additivity on subgaussian parameters, each component of the polynomials of the vector  <span class="math">\\mathbf{e}_+^{\\mathsf{T}}</span>  has therefore subgaussian parameter  <span class="math">\\sigma_+ = \\sqrt{\\sigma_1^2 + \\sigma_2^2}</span> .</p>

    <p class="text-gray-300">Finally, in both cases the subgaussian parameter for the addition of k ciphertexts is simply obtained by applying successively the formula of the addition of two ciphertexts. The case  <span class="math">\\sigma&#x27; = \\sigma \\sqrt{k}</span>  is a subcase when all ciphertexts error distributions have identical parameter  <span class="math">\\sigma</span> .</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Proof of lemma 11</h4>

    <p class="text-gray-300"><em>Proof.</em> We first prove the statement on batched-GSW following the same direction as [AP12] (considering only the subcase of diagonal matrices as plaintexts). Let consider the noise in a product of two ciphertexts  <span class="math">SC_{\\times}</span> . We have the following relations:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{SC}_{\\times} &amp;= \\mathbf{SC}_{1}\\mathbf{G}^{-1}(\\mathbf{C}_{2}) = \\left(\\mathbf{E}_{1}^{\\prime} + \\left(\\frac{m_{1,1} \\cdot \\mathbf{s}_{1}^{\\top}}{\\vdots}\\right) \\mathbf{G}\\right) \\mathbf{G}^{-1}(\\mathbf{C}_{2}), \\\\ &amp;= \\mathbf{E}_{1}^{\\prime}\\mathbf{G}^{-1}(\\mathbf{C}_{2}) + \\left(\\frac{m_{1,1} \\cdot \\mathbf{s}_{1}^{\\top}}{\\vdots}\\right) \\mathbf{C}_{2} = \\mathbf{E}_{1}^{\\prime}\\mathbf{G}^{-1}(\\mathbf{C}_{2}) + \\begin{pmatrix} m_{1,1} &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; m_{1,2} &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; m_{1,n} \\end{pmatrix} \\mathbf{SC}_{2}, \\\\ &amp;= \\mathbf{E}_{1}^{\\prime}\\mathbf{G}^{-1}(\\mathbf{C}_{2}) + \\begin{pmatrix} m_{1,1} &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; m_{1,2} &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; m_{1,n} \\end{pmatrix} \\mathbf{E}_{2}^{\\prime} + \\left(\\frac{m_{1,1}m_{2,1} \\cdot \\mathbf{s}_{1}^{\\top}}{\\vdots}\\right) \\mathbf{G}. \\end{split}</span>$</p>

    <p class="text-gray-300">The error of
<span class="math">$\\mathbf{C}_{\\times}</span>$
is therefore  <span class="math">\\mathbf{E}_{\\times} = \\mathbf{E}_1&#x27; \\mathbf{G}^{-1}(\\mathbf{C}_2) + \\begin{pmatrix} m_{1,1} &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; m_{1,2} &amp; \\dots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\dots &amp; m_{1,n} \\end{pmatrix} \\mathbf{E}_2&#x27;.</span></p>

    <p class="text-gray-300">As  <span class="math">G^{-1}(C_2)</span>  is an  <span class="math">N \\times N</span>  matrix from independent subgaussian distribution with parameter  <span class="math">\\sigma_{G^{-1}} = 1</span> , we can consider independently the r rows of  <span class="math">E_{\\times}</span> , leading to:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}_{\\times,j}^{\\mathsf{T}} = \\mathbf{e}_{1,j}^{\\mathsf{T}} \\mathbf{G}^{-1}(\\mathbf{C}_2) + m_{1,j} \\mathbf{e}_{2,j}^{\\mathsf{T}}</span>$</p>

    <p class="text-gray-300">The components of  <span class="math">m_{1,j}\\mathbf{e}_{2,j}^{\\mathsf{T}}</span>  follow a subgaussian distribution of parameter  <span class="math">|m_{1,j}|\\sigma_2</span>  by homogeneity, with  <span class="math">|m_{1,j}|\\in\\mathbb{N}</span>  the absolute norm of  <span class="math">m_{1,j}</span> . By Pythagorean additivity, the components of  <span class="math">\\mathbf{e}_{1,j}^{\\mathsf{T}}\\mathbf{G}^{-1}(\\mathbf{C}_2)</span>  follow a subgaussian distribution of parameter  <span class="math">\\sqrt{\\sum_{\\ell=1}^{N}(\\sigma_{\\mathbf{G}^{-1}}\\mathbf{e}_{1,j,\\ell}^{\\mathsf{T}})^2}=\\sigma_{\\mathbf{G}^{-1}}||\\mathbf{e}_{1,j}^{\\mathsf{T}}||_2=\\mathcal{O}(\\sigma_1\\sqrt{N})</span>  by Lemma 2.</p>

    <p class="text-gray-300">The components of  <span class="math">\\mathbf{e}_{\\times,j}^{\\mathsf{T}}</span>  are therefore following independent subgaussian distribution of parameter  <span class="math">\\sigma&#x27; = \\mathcal{O}\\left(\\sqrt{(\\sigma_1\\sqrt{N})^2 + (|m_{1,j}|\\sigma_2)^2}\\right)</span> .</p>

    <p class="text-gray-300">Applying this formula recursively for a multiplicative chain we obtain the following one for  <span class="math">\\sigma&#x27;</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\sqrt{(\\sigma_1\\sqrt{N})^2 + (|m_{1,j}|\\sigma_2\\sqrt{N})^2 + \\dots + ((\\Pi_{i=1}^{k-1}|m_{i,j}|)\\sigma_k\\sqrt{N})^2 + ((\\Pi_{i=1}^k|m_{i,j}|)\\sigma_{\\mathbf{G}})^2}\\right).</span>$</p>

    <p class="text-gray-300">As G is a noiseless encryption of I,  <span class="math">\\sigma_G = 0</span>  and we can conclude:</p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = \\mathcal{O}\\left(\\sqrt{N_{\\chi}} \\sqrt{\\sigma_1^2 + \\sum_{i=2}^k (\\sigma_i \\Pi_{j=1}^{i-1} |m_j|)^2}\\right).</span>$</p>

    <p class="text-gray-300">Then we prove the property in the ring setting.</p>

    <p class="text-gray-300">We first recall that R is a cyclotomic polynomial of degree being a power of two. Hence we have the following relations on a product of  <span class="math">a, b \\in R_q</span> :</p>

    <p class="text-gray-300"><span class="math">$ab = \\sum_{i=0}^{n-1} \\left( \\sum_{j=0}^{i} a_j b_{i-j} X^i \\right) + \\sum_{i=0}^{n-2} \\left( \\sum_{j=i+1}^{n-1} a_j b_{n+i-j} X^{n+i} \\right) \\mod X^n + 1.</span>$</p>

    <p class="text-gray-300">Using the reduction modulus  <span class="math">X^n + 1</span>  we get:</p>

    <p class="text-gray-300"><span class="math">$ab = \\sum_{i=0}^{n-1} \\left( \\sum_{j=0}^{i} a_j b_{i-j} X^i \\right) - \\sum_{i=0}^{n-2} \\left( \\sum_{j=i+1}^{n-1} a_j b_{n+i-j} X^i \\right),</span>$</p>

    <p class="text-gray-300">and for each coefficient:</p>

    <p class="text-gray-300"><span class="math">$(ab)_i = \\left(\\sum_{j=0}^i a_j b_{i-j}\\right) - \\left(\\sum_{j=i+1}^{n-1} a_j b_{n+i-j}\\right),</span>$</p>

    <p class="text-gray-300">where each coefficient of a and b appears only once in the sum. This expression on the coefficients enables then to obtain the subgaussian parameter of a product of subgaussian polynomials.</p>

    <p class="text-gray-300">With  <span class="math">a, b \\in R_q</span> , each coefficient of b following independent subgaussian distributions of parameter  <span class="math">\\sigma_b</span> , by Pythagorean additivity we obtain the subgaussian parameter  <span class="math">\\sigma_{ab}</span>  of the coefficients of ab:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-38-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\sigma_{ab} = \\sqrt{\\sum_{j=0}^{n-1} (a_j \\sigma_b)^2} = \\sigma_b ||a||_2.</span>$
(3)</p>

    <p class="text-gray-300">Hereafter, as in the batched setting, we obtain the subgaussian parameter in the simpler case of a product of two ciphertexts. Multiplying two ciphertexts  <span class="math">C_1</span>  and  <span class="math">C_2</span>  we can consider the resultant error vector:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{e}_{\\times}^{\\mathsf{T}} = \\mathbf{e}_{1}^{\\mathsf{T}} \\mathbf{G}^{-1}(\\mathbf{C}_{2}) + m_{1} \\mathbf{e}_{2}^{\\mathsf{T}} \\in R_{q}^{N}.</span>$</p>

    <p class="text-gray-300">For the second part, we consider all polynomial of  <span class="math">e_2</span>  with coefficient from subgaussian independent distributions of parameter  <span class="math">\\sigma_2</span> . Then the subgaussian parameter obtained is  <span class="math">\\sigma_2 ||m_1||_2</span>  using relation 3.</p>

    <p class="text-gray-300">For the first component  <span class="math">\\mathbf{e}_1^{\\mathsf{T}}\\mathbf{G}^{-1}(\\mathbf{C}_2)</span> , each polynomial of the result is the sum of N independent products from an element of  <span class="math">\\mathbf{e}_1^{\\mathsf{T}}</span>  and a polynomial with coefficients following subgaussian distributions of parameter 1 (by construction of  <span class="math">\\mathbf{G}^{-1}</span> ). The subgaussian parameter of the first part is  <span class="math">\\sqrt{\\sum_{i=1}^{N}(||\\mathbf{e}_{1i}^{\\mathsf{T}}||_2)^2}</span>  by Relation 3. Finally the subgaussian parameter  <span class="math">\\sigma_{\\times}</span>  of the coefficients of the polynomials of  <span class="math">\\mathbf{e}_{\\times}</span>  is:</p>

    <p class="text-gray-300"><span class="math">$\\sigma_{\\times} = \\mathcal{O}\\left(\\sqrt{(\\sigma_1\\sqrt{nN})^2 + (\\sigma_2||m_1||_2)^2}\\right).</span>$</p>

    <p class="text-gray-300">using Lemma 2 on the  <span class="math">e_{1i}</span>  and Pythagorean additivity.</p>

    <p class="text-gray-300">We apply this formula recursively for a multiplicative chain ending by G. The resulting subgaussian parameter is  <span class="math">\\sigma&#x27;</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{O}\\left(\\sqrt{(\\sigma_1\\sqrt{nN})^2 + (||m_{1,j}||_2\\sigma_2\\sqrt{nN})^2 + \\cdots + ((\\Pi_{i=1}^{k-1}||m_{i,j}||_2)\\sigma_k\\sqrt{nN})^2 + ((\\Pi_{i=1}^k||m_{i,j}||_2)\\sigma_{\\mathbf{G}})^2}\\right).</span>$</p>

    <p class="text-gray-300">As G is a noiseless encryption of I,  <span class="math">\\sigma_G = 0</span>  and we can conclude:</p>

    <p class="text-gray-300"><span class="math">$\\sigma&#x27; = \\mathcal{O}\\left(\\sqrt{nN}\\sqrt{\\sigma_1^2 + \\sum_{i=2}^k (\\sigma_i \\Pi_{j=1}^{i-1}||m_j||_2)^2}\\right).</span>$</p>

`;
---

<BaseLayout title="Towards Stream Ciphers for Efficient FHE with Low-Noise Ciph... (2016/254)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/254
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="towards-stream-ciphers-for-efficient-fhe-with-low-noise-2016" />
  </article>
</BaseLayout>
