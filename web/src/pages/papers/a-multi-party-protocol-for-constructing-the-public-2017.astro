---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/602';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A multi-party protocol for constructing the public parameters of the Pinocchio zk-SNARK';
const AUTHORS_HTML = 'Sean Bowe, Ariel Gabizon, Matthew D.  Green';

const CONTENT = `    <p class="text-gray-300">Sean Bowe, Ariel Gabizon, Matthew D. Green</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Recent efficient constructions of zero-knowledge Succinct Non-interactive Arguments of Knowledge (zk-SNARKs), require a setup phase in which a common-reference string (CRS) with a certain structure is generated. This CRS is sometimes referred to as the <em>public parameters of the system</em>, and is used for constructing and verifying proofs. A drawback of these constructions is that whomever runs the setup phase subsequently possesses trapdoor information enabling them to produce fraudulent pseudoproofs.</p>

    <p class="text-gray-300">Building on a work of Ben-Sasson, Chiesa, Green, Tromer and Virza <em>[BCG^{+}15]</em>, we construct a multi-party protocol for generating the CRS of the Pinocchio zk-SNARK <em>[x14]</em>, such that as long as at least one participating party is not malicious, no party can later construct fraudulent proofs except with negligible probability. The protocol also provides a strong zero-knowledge guarantee <em>even in the case that all participants are malicious</em>.</p>

    <p class="text-gray-300">This method has been used in practice to generate the required CRS for the Zcash cryptocurrency blockchain.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The recently deployed Zcash cryptocurrency supports shielded (private) transactions where sender, receiver and amount are not revealed; and yet, an outside observer can still distinguish between a valid and non-valid transaction. The “cryptographic engine” that enables these shielded transactions is a zero-knowledge Succinct Non-interactive Argument of Knowledge (zk-SNARK); currently, Zcash uses the Pinocchio zk-SNARK <em>[x14]</em>, or more precisely, the variant of it described in <em>[x2]</em> as implemented in libsnark[lib].</p>

    <p class="text-gray-300">A potential weakness of Zcash, is that if anybody obtained the trapdoor information corresponding to the Common Reference String (CRS) used for constructing and verifying the SNARKs, they could forge unlimited amounts of the currency, potentially without anyone detecting they are doing so.</p>

    <p class="text-gray-300">Motivated by this, Zcash generated the required CRS in an elaborate “ceremony” <em>[x20]</em> to reduce the chance of this happening. The purpose of this technical report is to give a detailed description of the multi-party protocol that was used in the ceremony.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Our results</h4>

    <p class="text-gray-300">Ben-Sasson, Chiesa, Green, Tromer and Virza <em>[BCG^{+}15]</em> presented a generic method for computing CRSs of zk-SNARKs in a multi-party protocol, with the property that only if all players collude together they can reconstruct the trapdoor, or, more generally, deduce any other useful information beyond the resultant CRS.</p>

    <p class="text-gray-300">Based on <em>[BCG^{+}15]</em>, we devise an arguably simpler method for generating the CRS of the Pinocchio zk-SNARK <em>[x21]</em> with a similar security guarantee: Namely, given that the CRS generated by the protocol is later used to verify proofs; a party controlling all but one of the players will not be able to construct fraudulent proofs except with negligible probability. See Theorem 4.8 for details.</p>

    <p class="text-gray-300">Moreover, we show that even if a malicious party controls <em>all</em> players, statistical zero-knowledge holds when constructing proofs according to the resultant parameters. Interestingly, this means the protocol is useful also when <em>run by one player</em>; as the transcript will provide proof to the prover that sending her proof will not leak additional information.</p>

    <p class="text-gray-300">This property has been recently called <em>subversion Zero-Knowledge</em> <em>[x1]</em>. As opposed to the soundness guarantee, zero-knowledge only requires the random oracle model; and in particular, no knowledge assumptions in contrast to some recent works on subversion-ZK <em>[x12, x1]</em>. On the other hand, our proof only obtains statistical-ZK with polynomially small error as opposed to the mentioned recent works that can obtain negligible error (again, using knowledge assumptions). See Theorem 4.10 for details.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Organization of paper</h4>

    <p class="text-gray-300">Section 2 introduces some terminology and auxiliary methods that will be used in the protocol. Section 3 describes the protocol in detail. Section 4 describes the security proof of the protocol.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Definitions, notation and auxiliary methods</h2>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Terminology:</h4>

    <p class="text-gray-300">We always assume we are working with a field <span class="math">\\mathbb{F}_{r}</span> for prime <span class="math">r</span> chosen according to a desired security parameter (more details on this in Section 4). We assume together with <span class="math">\\mathbb{F}_{r}</span> we have generated groups <span class="math">\\mathbb{G}_{1}</span>,<span class="math">\\mathbb{G}_{2}</span>,<span class="math">\\mathbb{G}_{t}</span>, all cyclic of order <span class="math">r</span>; where we write <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> in additive notation and <span class="math">\\mathbb{G}_{t}</span> in multiplicative notation. Furthermore, we have access to generators <span class="math">g_{1}\\in\\mathbb{G}_{1},g_{2}\\in\\mathbb{G}_{2}</span>, and an efficiently computable pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{t}</span>, i.e., a non-trivial map such that for any <span class="math">a,b\\in\\mathbb{F}_{r}</span></p>

    <p class="text-gray-300"><span class="math">e(a\\cdot g_{1},b\\cdot g_{2})=g_{T}^{a\\cdot b},</span></p>

    <p class="text-gray-300">for a fixed generator <span class="math">g_{T}\\in\\mathbb{G}_{t}</span>. We use the notations <span class="math">g:=(g_{1},g_{2})</span> and <span class="math">G^{*}:=\\mathbb{G}_{1}\\setminus\\{0\\}\\times\\mathbb{G}_{2}\\setminus\\{0\\}</span>.</p>

    <p class="text-gray-300">We think of the field size <span class="math">r</span> as a parameter against which we measure efficiency. In particular, we say a circuit <span class="math">A</span> is <em>efficient</em> if its size is polynomial in <span class="math">\\log r</span>. More precisely, when we refer in the security analysis to an efficient adversary or efficient algorithm, we mean it is a (non-uniform) sequence of circuits indexed by <span class="math">r</span>, of size <span class="math">\\operatorname{poly}\\log r</span>. When we say “with probability <span class="math">p</span>”, we mean “with probability at least <span class="math">p</span>”.</p>

    <p class="text-gray-300">We assume we have at our disposal a function COMMIT taking as input strings of arbitrary length; that, intuitively speaking, behaves like a commitment scheme. That is, it is infeasible to deduce COMMIT’s input from seeing its output, and it is infeasible to find two inputs that COMMIT maps to the same output. In our implementation we use the BLAKE-2 hash function as COMMIT. For the actual security proof, we need to assume that COMMIT’s outputs are chosen by a random oracle.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Symmetric definitions</h4>

    <p class="text-gray-300">In the following sections we introduce several methods that receive as parameters elements of both <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. We assume implicitly that whenever such a definition is made, we also have the symmetric definition where the roles are reversed between what parameters come from <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. For example, if we define a method receiving as input a vector of <span class="math">\\mathbb{G}_{1}</span> elements and a pair of <span class="math">\\mathbb{G}_{2}</span> elements. We assume thereafter that we also have the symmetric method receiving as input a vector of <span class="math">\\mathbb{G}_{2}</span> elements and a pair of <span class="math">\\mathbb{G}_{1}</span> elements.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Comparing ratios of pairs using pairings</h3>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2.1.</h6>

    <p class="text-gray-300">Given <span class="math">s\\in\\mathbb{F}_{r}^{*}</span>, an <span class="math">s</span>-pair is a pair <span class="math">(p,q)</span> such that <span class="math">p,q\\in\\mathbb{G}_{1}\\setminus\\{0\\}</span>, or <span class="math">p,q\\in\\mathbb{G}_{2}\\setminus\\{0\\}</span>; and <span class="math">s\\cdot p=q</span>. When not clear from the context whether <span class="math">p,q</span> are in <span class="math">\\mathbb{G}_{1}</span> or <span class="math">\\mathbb{G}_{2}</span>, we use the terms <span class="math">\\mathbb{G}_{1}</span>-<span class="math">s</span>-pair and <span class="math">\\mathbb{G}_{2}</span>-<span class="math">s</span>-pair.</p>

    <p class="text-gray-300">A recurring theme in the protocol will be to check that two pairs of elements in <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> respectively, “have the same ratio”, i.e., are <span class="math">s</span>-pairs for the same <span class="math">s\\in\\mathbb{F}_{r}^{*}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SameRatio}((p,q),(f,H))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If one of the elements <span class="math">p,q,f,H</span> is zero; return <span class="math">\\mathsf{rej}</span>.</li>

      <li>Return <span class="math">\\mathsf{acc}</span> if <span class="math">e(p,H)=e(q,f)</span>; return <span class="math">\\mathsf{rej}</span> otherwise.</li>

    </ol>

    <h6 id="sec-11" class="text-base font-medium mt-4">Claim 2.2.</h6>

    <p class="text-gray-300">Given <span class="math">p,q\\in\\mathbb{G}_{1}</span> and <span class="math">f,H\\in\\mathbb{G}_{2}</span>, <span class="math">\\mathsf{SameRatio}((p,q),(f,H))=\\mathsf{acc}</span> if and only if there exists <span class="math">s\\in\\mathbb{F}_{r}^{*}</span> such that <span class="math">(p,q)</span> is a <span class="math">\\mathbb{G}_{1}</span>-<span class="math">s</span>-pair and <span class="math">(f,H)</span> is a <span class="math">\\mathbb{G}_{2}</span>-<span class="math">s</span>-pair.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">s\\cdot p=q</span> and <span class="math">s^{\\prime}\\cdot f=H</span>. Write <span class="math">p=a\\cdot g_{1},f=b\\cdot g_{2}</span> for some <span class="math">a,b\\in\\mathbb{F}_{r}</span>. Note that if one of <span class="math">\\{a,b,s,s^{\\prime}\\}</span> is <span class="math">0</span>, we return <span class="math">\\mathsf{rej}</span> in the first step.</p>

    <p class="text-gray-300">Otherwise, we have</p>

    <p class="text-gray-300"><span class="math">e(p,H)=(a\\cdot g_{1},bs^{\\prime}\\cdot g_{2})=g_{T}^{abs^{\\prime}},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">e(q,f)=(as\\cdot g_{1},b\\cdot g_{2})=g_{T}^{abs},</span></p>

    <p class="text-gray-300">and thus <span class="math">\\mathsf{SameRatio}((p,q),(f,H))=1</span> if and only if <span class="math">s=s^{\\prime}</span> (<span class="math">mod</span> <span class="math">r</span>). ∎</p>

    <p class="text-gray-300">Let <span class="math">V=((p_{i},q_{i}))_{i\\in[d]}</span>, be a vector of pairs in <span class="math">\\mathbb{G}_{1}</span>. We say <span class="math">V</span> is an <span class="math">s</span>-vector in <span class="math">\\mathbb{G}_{1}</span> if for each <span class="math">i\\in[d]</span>, <span class="math">(p_{i},q_{i})</span> is a <span class="math">\\mathbb{G}_{1}</span>-<span class="math">s</span>-pair, or is equal to <span class="math">(0,0)</span>. We make the analogous definition for <span class="math">\\mathbb{G}_{2}</span>, and similarly to above, sometimes omit the group name when it is clear from the context what group the elements are in, simply using the term <span class="math">s</span>-vector. In our protocol we often want to check if a long vector <span class="math">((p_{i},q_{i}))_{i\\in[d]}</span> is an <span class="math">s</span>-vector for some <span class="math">s\\in\\mathbb{F}_{r}^{*}</span>. The next claim enables us to do so with just one pairing.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Claim 2.3.</h6>

    <p class="text-gray-300">Suppose that <span class="math">((p_{i},q_{i}))_{i\\in[d]}</span> is a vector of elements in <span class="math">\\mathbb{G}_{1}\\setminus\\{0\\}</span> that is not an <span class="math">s</span>-vector. Choose random <span class="math">c_{1},\\ldots,c_{d}\\in\\mathbb{F}_{r}</span> and define</p>

    <p class="text-gray-300"><span class="math">p\\triangleq\\sum_{i\\in[d]}c_{i}\\cdot p_{i},\\;\\;\\;q\\triangleq\\sum_{i\\in[d]}c_{i}\\cdot q_{i}.</span></p>

    <p class="text-gray-300">Then, with probability at least <span class="math">1-2/r</span>, both <span class="math">(p,q)\\neq(0,0)</span> and <span class="math">(p,q)</span> is not an <span class="math">s</span>-pair</p>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Write <span class="math">p_i = a_i \\cdot g_1</span> for <span class="math">a_i \\in \\mathbb{F}_r</span>, and <span class="math">q_i = s_i \\cdot p_i</span> for some <span class="math">s_i \\in \\mathbb{F}_r</span>. Thus, we have <span class="math">p = a \\cdot g_1</span> for <span class="math">a \\triangleq \\sum_{i \\in [d]} c_i a_i</span> and <span class="math">q = b \\cdot g_1</span> for <span class="math">b \\triangleq \\sum_{i \\in [d]} \\alpha_i a_i s_i</span>. Let us assume <span class="math">a \\neq 0</span>. This happens with probability <span class="math">1 - 1/r</span>. Write <span class="math">[d]</span> as a disjoint union <span class="math">S \\cup T</span> where <span class="math">S</span> is the set of indices of the <span class="math">s</span>-pairs. That is $S \\triangleq \\{i \\in [d]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_i = s\\}$. We have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">b / a = \\frac {\\sum_ {i \\in [ d ]} c _ {i} a _ {i} s _ {i}}{\\sum_ {i \\in [ d ]} c _ {i} a _ {i}} = s + \\frac {\\sum_ {i \\in T} c _ {i} \\cdot (s - s _ {i})}{\\sum_ {i \\in [ d ]} c _ {i} a _ {i}} = s + \\frac {\\sum_ {i \\in T} c _ {i} \\cdot (s - s _ {i})}{a}.</span></div>

    <p class="text-gray-300">Thus, <span class="math">b / a = s</span> if and only if the fraction in the right hand side is zero. As the numerator is a random combination of non-zero elements, this happens with probability <span class="math">1 / r</span>.</p>

    <p class="text-gray-300">We conclude that with probability at least <span class="math">1 - 2 / r</span>, <span class="math">(p,q)</span> is not an <span class="math">s</span>-pair</p>

    <p class="text-gray-300">Claim 2.3 implies the correctness of <span class="math">\\mathsf{sameRatio}(V, (f, H))</span> that given an <span class="math">s</span>-pair <span class="math">(f, H)</span> in <span class="math">\\mathbb{G}_2</span>, checks whether <span class="math">V</span> is an <span class="math">s</span>-vector in <span class="math">\\mathbb{G}_1</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{sameRatio}(V = ((p_i,q_i))_{i\\in [d]},(f,H))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If there exists a pair of the form <span class="math">(0,a)</span> or <span class="math">(a,0)</span> for some <span class="math">a\\neq 0</span> in <span class="math">V</span>; return rej.</li>

      <li>"Put aside" all elements of the form <span class="math">(0,0)</span>, and from now on assume all pairs in <span class="math">V</span> are in <span class="math">\\mathbb{G}_1 \\setminus \\{0\\}</span>. (If all pairs are of the form <span class="math">(0,0)</span> then return acc).</li>

      <li>Choose random <span class="math">c_{1},\\ldots ,c_{d}\\in \\mathbb{F}_{r}</span></li>

      <li>Define <span class="math">p \\triangleq \\sum_{i \\in [d]} c_i \\cdot p_i</span>, and <span class="math">q \\triangleq \\sum_{i \\in [d]} c_i \\cdot q_i</span>.</li>

      <li>If <span class="math">p = q = 0</span>, return acc.</li>

      <li>Otherwise, return <span class="math">\\mathsf{SameRatio}((p,q),(f,H))</span></li>

    </ol>

    <p class="text-gray-300">Corollary 2.4. Suppose <span class="math">\\mathsf{rp}_s</span> in a <span class="math">\\mathbb{G}_2</span>-s-pair, and <span class="math">V</span> is a vector of pairs of <span class="math">\\mathbb{G}_1</span> elements. If <span class="math">V</span> is an <span class="math">s</span>-vector, <span class="math">\\mathsf{sameRatio}(V,\\mathsf{rp}_s)</span> accepts with probability one. If <span class="math">V</span> is not an <span class="math">s</span>-vector, <span class="math">\\mathsf{sameRatio}(V,\\mathsf{rp}_s)</span> accepts with probability at most <span class="math">2 / r</span>.</p>

    <p class="text-gray-300">Let <span class="math">V</span> be a vector of <span class="math">\\mathbb{G}_1</span>-elements and <span class="math">\\mathsf{rp}_s</span> be a pair of <span class="math">\\mathbb{G}_2</span>-elements. We also use a method sameRatioSeq <span class="math">(V, \\mathsf{rp}_s)</span> that given an <span class="math">s</span>-pair <span class="math">\\mathsf{rp}_s</span>, checks that each two consecutive elements of <span class="math">V</span> are an <span class="math">s</span>-pair. It does so by calling sameRatio <span class="math">(V&#x27;, \\mathsf{rp}_s)</span> with <span class="math">V&#x27; = ((V_0, V_1), (V_1, V_2), \\ldots, (V_{d-1}, V_d))</span>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2.2 Schnorr NIZKs for knowledge of discrete log</h2>

    <p class="text-gray-300">We review and define notation for using the well-known Schnorr protocol [Sch89]. Given an <span class="math">s</span>-pair <span class="math">\\mathsf{rp}_s = (f, H = s \\cdot f)</span>, and a string <span class="math">h</span>, we define the (randomized) string <span class="math">\\mathrm{NIZK}(\\mathsf{rp}_s, h)</span> that can be interpreted as a proof that the generator of the string knows <span class="math">s</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{NIZK}(\\mathsf{rp}_s,h)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose random <span class="math">a \\in \\mathbb{F}_r^*</span> and let <span class="math">R \\coloneqq a \\cdot f</span>.</li>

      <li>Let <span class="math">c \\coloneqq \\mathsf{COMMIT}(R \\circ h)</span> and interpret <span class="math">c</span> as an element of <span class="math">\\mathbb{F}_r</span>, e.g. by taking its first log <span class="math">r</span> bits.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">u := a + cs</span>.</li>

      <li>Define <span class="math">\\mathrm{NIZK}(\\mathsf{rp}_s, h) := (R, u)</span>.</li>

    </ol>

    <p class="text-gray-300">Let us denote by <span class="math">\\pi</span> a string that is supposedly of the form <span class="math">\\mathrm{NIZK}(\\mathsf{rp}_s, h)</span>, for some string <span class="math">h</span>.</p>

    <p class="text-gray-300">VERIFY-NIZK<span class="math">(\\mathsf{rp}_s, \\pi, h)</span> is a boolean predicate that verifies that <span class="math">\\pi</span> is indeed of this form for the same given <span class="math">h</span>.</p>

    <p class="text-gray-300">VERIFY-NIZK<span class="math">((f,H),\\pi,h)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">R, u</span> be as in the description above.</li>

      <li>Compute <span class="math">c \\coloneqq \\mathsf{COMMIT}(R \\circ h)</span>.</li>

      <li>Return <span class="math">\\mathsf{acc}</span> when <span class="math">u \\cdot f = R + c \\cdot H</span>; and <span class="math">\\mathsf{rej}</span> otherwise.</li>

    </ol>

    <h2 id="sec-15" class="text-2xl font-bold">2.3 The random-coefficient subprotocol</h2>

    <p class="text-gray-300">A large part of the protocol will consist of invocations of the random-coefficient subprotocol. In this subprotocol, we multiply a vector of <span class="math">\\mathbb{G}_1</span> elements coordinate-wise by the same scalar <span class="math">\\alpha \\in \\mathbb{F}_r^*</span>. <span class="math">\\alpha</span> here is a product of secret elements <span class="math">\\{\\alpha_i\\}_{i \\in [n]}</span>, that we refer to later as comitted elements. By this we mean, that before the subprotocol is invoked, for each <span class="math">i \\in [n]</span>, <span class="math">P_i</span> has broadcasted a <span class="math">\\mathbb{G}_2</span>-<span class="math">\\alpha_i</span>-pair, denoted <span class="math">\\mathsf{rp}_{\\alpha_i}</span>, that is accessible to the protocol verifier. (This will become clearer in the context of Section 3).</p>

    <p class="text-gray-300"><span class="math">\\mathrm{RCPC}(V,\\alpha)</span></p>

    <p class="text-gray-300"><strong>Common Input:</strong> vector <span class="math">V \\in \\mathbb{G}_1^d</span>.</p>

    <p class="text-gray-300"><strong>Individual inputs:</strong> element <span class="math">\\alpha_i \\in \\mathbb{F}_r^*</span> for each <span class="math">i \\in [n]</span>.</p>

    <p class="text-gray-300"><strong>Output:</strong> vector <span class="math">\\alpha \\cdot V \\in \\mathbb{G}_1^d</span>, where <span class="math">\\alpha = \\prod_{i=1}^{n} \\alpha_i</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_1</span> computes broadcasts <span class="math">V_1 \\coloneqq \\alpha_1 \\cdot V</span>.</li>

      <li>For <span class="math">i = 2, \\ldots, n</span>, <span class="math">P_i</span> broadcasts <span class="math">V_i \\coloneqq \\alpha_i \\cdot V_{i-1}</span>.</li>

      <li>Players output <span class="math">V_n</span> (which should equal <span class="math">\\alpha \\cdot V</span>).</li>

    </ol>

    <p class="text-gray-300">Before discussing the transcript verification we define one more useful notation. For vectors <span class="math">S, T \\in \\mathbb{G}_1^d</span> and a <span class="math">\\mathbb{G}_2</span>-<span class="math">\\alpha</span>-pair <span class="math">\\mathsf{rp}_{\\alpha}</span>, <span class="math">\\mathsf{sameRatio}((S, T), \\mathsf{rp}_{\\alpha})</span> returns <span class="math">\\mathsf{sameRatio}(V, \\mathsf{rp}_{\\alpha})</span>, where <span class="math">V_i := (S_i, T_i)</span>. The transcript verification procedure receives as input <span class="math">V, V_1, \\ldots, V_n</span>, and for each <span class="math">i \\in [n]</span>, the <span class="math">\\mathbb{G}_2</span>-<span class="math">\\alpha_i</span>-pair, <span class="math">\\mathsf{rp}_{\\alpha_i}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{verifyRCPC}(V,\\alpha)</span></p>

    <p class="text-gray-300"><strong>Input:</strong> <span class="math">V</span>, protocol transcript <span class="math">V_1, \\ldots, V_n \\in \\mathbb{G}_1^d</span>, for each <span class="math">i \\in [n]</span> a <span class="math">\\mathbb{G}_2</span>-<span class="math">\\alpha_i</span>-pair <span class="math">\\mathsf{rp}_{\\alpha_i}</span>.</p>

    <p class="text-gray-300">5</p>

    <p class="text-gray-300">Output: acc or rej.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run sameRatio<span class="math">((V,V_{1}),\\mathsf{rp}_{\\alpha_{1}})</span>.</li>

      <li>For <span class="math">i=2,\\ldots,n</span>, run sameRatio<span class="math">((V_{i-1},V_{i}),\\mathsf{rp}_{\\alpha_{i}})</span>.</li>

      <li>Return acc if all invocations returned acc; and return rej otherwise.</li>

    </ol>

    <p class="text-gray-300">From the correctness of the sameRatio<span class="math">(,)</span> method (Corollary 2.4) we have that</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Claim 2.5.</h6>

    <p class="text-gray-300">If the players follow the protocol correctly, the output is <span class="math">\\alpha\\cdot V</span>, and transcript verification outputs acc with probability one. Otherwise, transcript verification outputs acc with probability at most <span class="math">2/r</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3 Protocol description</h2>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">The participants</h4>

    <p class="text-gray-300">The protocol is conducted by <span class="math">n</span> players, a coordinator, and a protocol verifier. In the implementation the role of the coordinator and protocol verifier can be played by the same server. We find it useful to separate these roles, though, as the actions of the protocol verifier may be executed only after the protocol has terminated, if one wishes to reduce the time the players have to be engaged. Moreover, any party wishing to check the validity of the transcript and generated parameters can do so solely with access to the protocol transcript. On the other hand, this has the disadvantage that non-valid messages will be detected only in hindsight, and the whole process will have to be restarted if one wishes to generate valid SNARK parameters.</p>

    <p class="text-gray-300">Similarly, the role of the coordinator is not strictly necessary if one assumes a blackboard model where each player sees all messages broadcasted. (In our actual implementation the coordinator passes messages between the players). Our security analysis holds when all messages are seen by all players. However, even in such a blackboard model there is an advantage of having of a coordinator role: At the beginning of Round 3 a heavy computation needs to performed (Subsection 3.3) that in theory could be performed by the first player before he sends his message for that round. However, as this heavy computation does not require access to any secrets of the players, having the coordinator perform it can save much time, if the coordinator is run on a strong server, and the players have weaker machines.</p>

    <p class="text-gray-300">The protocol consists of four “round-robin” rounds, where for each <span class="math">i\\in[n]</span>, player <span class="math">P_{i}</span> can send his message after receiving the message of <span class="math">P_{i-1}</span>. <span class="math">P_{1}</span> can send his message after receiving an “initializer message” from the coordinator, which is empty in some of the rounds. An exception of this is the first round, where all players may send their message to the coordinator in parallel. However, security is not harmed if a player sees other players’ messages before sending his in that round. Round 2 is divided into several parts for clarity, however the messages of a player <span class="math">P_{i}</span> in all parts of that round can be sent in parallel. Similarly, Round 3 and 4 consist of several one round round-robin subprotocols; however, the messages of a player <span class="math">P_{i}</span> in all these subprotocols can be sent in parallel.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.1 Round 1: commitments</h3>

    <p class="text-gray-300">For each <span class="math">i\\in[n]</span>, <span class="math">P_{i}</span> does the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate a set of uniform elements in <span class="math">\\mathbb{F}_r^*</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{secrets}_i := \\left\\{ \\tau_i, \\rho_{A,i}, \\rho_{B,i}, \\alpha_{A,i}, \\alpha_{B,i}, \\alpha_{C,i}, \\beta_i, \\gamma_i \\right\\}.</span></div>

    <p class="text-gray-300">Omitting the index <span class="math">i</span> for readability from now on, let</p>

    <div class="my-4 text-center"><span class="math-block">\\text{elements}_i := \\left\\{ \\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\beta, \\gamma, \\rho_A \\alpha_A, \\rho_B \\alpha_B, \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left. \\rho_A \\rho_B, \\rho_A \\rho_B \\alpha_C, \\beta \\gamma \\right\\}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now <span class="math">P_i</span> generates the set of group elements²</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{e}_i := \\left( \\tau, \\rho_A, \\rho_A \\rho_B, \\rho_A \\alpha_A, \\rho_A \\rho_B \\alpha_B, \\rho_A \\rho_B \\alpha_C, \\gamma, \\beta \\gamma \\right) \\cdot g.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_i</span> computes <span class="math">h_i := \\mathsf{COMMIT}(\\mathsf{e}_i)</span> and broadcasts <span class="math">h_i</span>.</li>

    </ol>

    <h2 id="sec-20" class="text-2xl font-bold">3.2 Round 2</h2>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">Part 1: Revealing commitments</h3>

    <p class="text-gray-300">For each <span class="math">i \\in [n]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_i</span> broadcasts <span class="math">\\mathsf{e}_i</span>.</li>

      <li>The protocol verifies checks that indeed <span class="math">h_i = \\mathsf{COMMIT}(\\mathsf{e}_i)</span>.</li>

    </ol>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">Committed elements</h3>

    <p class="text-gray-300">From the end of Round 2, part 1 of the protocol, we refer to the elements of <span class="math">\\text{elements}_i</span> for some <span class="math">i \\in [n]</span> as committed elements. The reason is that by this stage of the protocol, for each <span class="math">s \\in \\text{elements}_i</span>, <span class="math">P_i</span> has sent an <span class="math">s</span>-pair in both <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span>, effectively committing him to the value of <span class="math">s</span>. For each such element <span class="math">s</span>, we refer to the <span class="math">s</span>-pair in <span class="math">\\mathbb{G}_1</span> by <span class="math">\\mathsf{rp}_s</span> and the <span class="math">s</span>-pair in <span class="math">\\mathbb{G}_2</span> by <span class="math">\\mathsf{rp}_s^2</span>. We list the corresponding elements and <span class="math">s</span>-pairs, omitting the <span class="math">i</span> subscript for readability:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau</span>: <span class="math">(\\mathsf{rp}_{\\tau}^{1}, \\mathsf{rp}_{\\tau}^{2}) = (g, \\tau \\cdot g)</span>.</li>

      <li><span class="math">\\rho_A</span>: <span class="math">(\\mathsf{rp}_{\\rho_A}^1, \\mathsf{rp}_{\\rho_A}^2) = (g, \\rho_A \\cdot g)</span>.</li>

      <li><span class="math">\\rho_B</span>: <span class="math">(\\mathsf{rp}_{\\rho_B}^1, \\mathsf{rp}_{\\rho_B}^2) = (g, \\rho_B \\cdot g)</span>.</li>

      <li><span class="math">\\alpha_A</span>: <span class="math">(\\mathsf{rp}_{\\alpha_A}^1, \\mathsf{rp}_{\\alpha_A}^2) = (\\rho_A \\cdot g, \\rho_A \\alpha_A \\cdot g)</span>.</li>

      <li><span class="math">\\alpha_B</span>: <span class="math">(\\mathsf{rp}_{\\alpha_B}^1, \\mathsf{rp}_{\\alpha_B}^2) = (\\rho_A \\rho_B \\cdot g, \\rho_A \\rho_B \\alpha_B \\cdot g)</span>.</li>

      <li><span class="math">\\alpha_C</span>: <span class="math">(\\mathsf{rp}_{\\alpha_C}^1, \\mathsf{rp}_{\\alpha_C}^2) = (\\rho_A \\rho_B \\cdot g, \\rho_A \\rho_B \\alpha_C \\cdot g)</span>.</li>

      <li><span class="math">\\beta</span>: <span class="math">(\\mathsf{rp}_{\\beta}^1, \\mathsf{rp}_{\\beta}^2) = (\\gamma \\cdot g, \\beta \\gamma \\cdot g)</span>.</li>

    </ul>

    <p class="text-gray-300">²In the actual code a more complex set of elements is used that can be efficiently derived from <span class="math">\\text{elements}_i</span>, as described in Appendix A. The reason we use the more complex set is that it potentially provides more security as it contains less information about <span class="math">\\text{secrets}_i</span>. However, the proof works as well with this definition of <span class="math">\\mathsf{e}_i</span> and it provides a significantly simpler presentation. We explain in Appendix A the slight modification for protocol and proof for using the more complex element set.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\gamma</span>: <span class="math">(\\mathsf{rp}_{\\gamma}^{1},\\mathsf{rp}_{\\gamma}^{2})=(g,\\gamma\\cdot g)</span>.</li>

      <li><span class="math">\\rho_{A}\\alpha_{A}</span>: <span class="math">(\\mathsf{rp}_{\\rho_{A}\\alpha_{A}}^{1},\\mathsf{rp}_{\\rho_{A}\\alpha_{A}}^{2})=(g,\\rho_{A}\\alpha_{A}\\cdot g)</span>.</li>

      <li><span class="math">\\rho_{B}\\alpha_{B}</span>: <span class="math">(\\mathsf{rp}_{\\rho_{B}\\alpha_{B}}^{1},\\mathsf{rp}_{\\rho_{B}\\alpha_{B}}^{2})=(p_{A}\\cdot g,\\rho_{A}\\rho_{B}\\alpha_{B}\\cdot g)</span>.</li>

      <li><span class="math">\\rho_{A}\\rho_{B}</span>: <span class="math">(\\mathsf{rp}_{\\rho_{A}\\rho_{B}}^{1},\\mathsf{rp}_{\\rho_{A}\\rho_{B}}^{2})=(g,\\rho_{A}\\rho_{B}\\cdot g)</span>.</li>

      <li><span class="math">\\rho_{A}\\rho_{B}\\alpha_{C}</span>: <span class="math">(\\mathsf{rp}_{\\rho_{A}\\rho_{B}\\alpha_{C}}^{1},\\mathsf{rp}_{\\rho_{A}\\rho_{B}\\alpha_{C}}^{2})=(g,\\rho_{A}\\rho_{B}\\alpha_{C}\\cdot g)</span>.</li>

      <li><span class="math">\\beta\\gamma</span>: <span class="math">(\\mathsf{rp}_{\\beta\\gamma}^{1},\\mathsf{rp}_{\\beta\\gamma}^{2})=(g,\\beta\\gamma\\cdot g)</span>.</li>

    </ul>

    <p class="text-gray-300">Of course, we need to check that <span class="math">P_{i}</span> has committed to the <em>same</em> element <span class="math">s\\in\\mathbb{F}_{r}^{*}</span> by <span class="math">\\mathsf{rp}_{s}</span> and <span class="math">\\mathsf{rp}_{s}^{2}</span>. This is done by the protocol verifier in the next stage.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">Part 2: Checking commitment consistency between both groups</h3>

    <p class="text-gray-300">For each <span class="math">i\\in[n]</span>, and <span class="math">s\\in\\mathsf{elements}_{i}</span>, the protocol verifier runs <span class="math">\\mathsf{SameRatio}(\\mathsf{rp}_{s},\\mathsf{rp}_{s}^{2})</span>, and outputs <span class="math">\\mathsf{rej}</span> if any invocation returned <span class="math">\\mathsf{rej}</span>.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">Part 3: Proving and verifying knowledge of discrete logs</h3>

    <p class="text-gray-300">Let <span class="math">h:=\\mathsf{COMMIT}(h_{1}\\circ\\ldots\\circ h_{n})</span> be the hash of the transcript of Round 1. <span class="math">P_{1}</span> computes and broadcasts <span class="math">h</span>.</p>

    <p class="text-gray-300">For each <span class="math">i\\in[n]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">s\\in\\mathsf{secrets}_{i}</span>, let <span class="math">h_{i,s}:=h\\circ\\mathsf{rp}_{s}^{1}</span>. Note that both <span class="math">P_{i}</span> and the protocol verifier, seeing the transcript up to this point, can efficiently compute the elements <span class="math">\\{h_{i,s}\\}</span>.</li>

      <li>For each <span class="math">s\\in\\mathsf{secrets}_{i}</span>, <span class="math">P_{i}</span> broadcasts <span class="math">\\pi_{i,s}:=\\mathrm{NIZK}(\\mathsf{rp}_{s}^{1},h_{i,s})</span>.</li>

      <li>The protocol verifier checks for each <span class="math">s\\in\\mathsf{secrets}_{i}</span> that VERIFY-NIZK<span class="math">(\\mathsf{rp}_{s}^{1},\\pi_{i,s},h_{i,s})=\\mathsf{acc}</span>.</li>

    </ol>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">Part 4: The random powers subprotocol:</h3>

    <p class="text-gray-300">The purpose of the subprotocol is to output the vector</p>

    <p class="text-gray-300"><span class="math">\\mathrm{POWERS}_{\\tau}:=\\left((1,\\tau,\\tau^{2},\\ldots,\\tau^{d})\\cdot g_{1},(1,\\tau,\\tau^{2},\\ldots,\\tau^{d})\\cdot g_{2}\\right),</span></p>

    <p class="text-gray-300">where <span class="math">\\tau:=\\tau_{1}\\cdots\\tau_{n}</span>. Recall that <span class="math">\\tau_{1},\\ldots,\\tau_{n}</span> are committed values from Round 1.</p>

    <p class="text-gray-300">For a vector <span class="math">V\\in\\mathbb{G}_{1}^{d+1}</span>, and <span class="math">a\\in\\mathbb{F}_{r}</span>, we use below the notation <span class="math">\\mathsf{powerMult}(V,a)\\in\\mathbb{G}_{1}^{d+1}</span>, defined as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{powerMult}(V,a)_{i}\\triangleq a^{i}\\cdot V,</span></p>

    <p class="text-gray-300">for <span class="math">i\\in\\{0,\\ldots,d\\}</span>. We use the analogous notation for a vector <span class="math">V\\in\\mathbb{G}_{2}^{d+1}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">9</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{1}</span>  does the following.</li>

    </ol>

    <p class="text-gray-300">(a) Computing <span class="math">V_{1} = (1, \\tau_{1}, \\tau_{1}^{2}, \\ldots, \\tau_{1}^{d}) \\cdot g_{1}</span>  and  <span class="math">V_{1}&#x27; = (1, \\tau_{1}, \\tau_{1}^{2}, \\ldots, \\tau_{1}^{d}) \\cdot g_{2}</span> . (b) Broadcasts  <span class="math">(V_{1}, V_{1}^{\\prime})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 2, \\ldots, n</span> ,  <span class="math">P_i</span>  does the following:</li>

    </ol>

    <p class="text-gray-300">(a) Compute  <span class="math">V_{i} \\triangleq \\text{powerMult}(V_{i-1}, \\tau_{i})</span>  and  <span class="math">V_{i}&#x27; \\triangleq \\text{powerMult}(V_{i-1}&#x27;, \\tau_{i-1})</span> . (b) Broadcasts  <span class="math">(V_{i}, V_{i}^{\\prime})</span> .</p>

    <p class="text-gray-300">The protocol verifier performs the following checks on the broadcasted data from Phase 1:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\text{sameRatioSeq}(V_{1}, \\mathsf{rp}_{\\tau_{1}}^{2}),</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\text{sameRatioSeq}(V_{1}&#x27;, (V_{1,0}, V_{1,1}))</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in [n] \\setminus \\{1\\}</span>  check that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\text{sameRatioSeq}(V_{i}, (V_{i,0}&#x27;, V_{i,1}&#x27;)),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{sameRatioSeq}(V_{i}&#x27;, (V_{i,0}, V_{i,1})),</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\text{SameRatio}((V_{i-1,1}, V_{i,1}), \\mathsf{rp}_{\\tau_{i}}^{2})</span></div>

    <p class="text-gray-300">The protocol verifier rejects the transcript if one of the checks failed; otherwise, the coordinator defines  <span class="math">(PK_{H} \\triangleq V_{n}, PK_{H}&#x27; \\triangleq V_{n}&#x27;)</span>  is taken as the subprotocol output.</p>

    <p class="text-gray-300">The zero-knowledge property of the SNARK requires we weren't unlucky and  <span class="math">\\tau</span>  landed in the zeroes of  <span class="math">Z(X) := X^d - 1</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Protocol verifier and all players check that  <span class="math">Z(\\tau) \\cdot g_1 = (\\tau^d - 1) \\cdot g_1 = V_{n,d} - V_{n,0} \\neq 1</span> . If the check fails the protocol is aborted and restarted.</li>

    </ul>

    <p class="text-gray-300">3The checks below could be simplified if we had also used  <span class="math">\\mathsf{rp}_{\\tau_i}^1</span> . We do not use it as in the actual code, as explained in Appendix A, we do not have a  <span class="math">\\mathbb{G}_1</span> - <span class="math">\\tau_i</span> -pair.</p>

    <p class="text-gray-300">3.3 Coordinator after Round 2: Computing Lagrange basis using FFT, and preparing the vectors <span class="math">\\vec{A},\\vec{B}</span> and <span class="math">\\vec{C}</span></p>

    <p class="text-gray-300">To avoid a quadratic proving time the polynomials in the QAP must be evaluated in a Lagrange basis. There seems to be no way of directly computing a Lagrange basis at <span class="math">\\tau</span> in a 1-round MPC in a similar way we did for the standard basis in the Random-Powers subprotocol. Thus we will do ‘FFT in the coefficient’ to compute the Lagrange basis on the output of the random-powers subprotocol. Details and definitions follow. Let <span class="math">\\omega\\in\\mathbb{F}_{r}</span> be a primitive root of unity of order <span class="math">d=2^{\\ell}</span>, in code <span class="math">d</span> is typically the first power of two larger or equal to the circuit size.</p>

    <p class="text-gray-300">For <span class="math">i=1,\\ldots,d</span>, we define <span class="math">L_{i}</span> to be the <span class="math">i</span>’th Lagrange polynomial over the points <span class="math">\\left\\{\\omega^{i}\\right\\}_{i\\in[d]}</span>. That is, <span class="math">L_{i}</span> is the unique polynomial of degree smaller than <span class="math">d</span>, such that <span class="math">L_{i}(\\omega^{i})=1</span> and <span class="math">L_{i}(\\omega^{j})=0</span>, for <span class="math">j\\in[d]\\setminus\\{i\\}</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Claim 3.1.</h6>

    <p class="text-gray-300">For <span class="math">i\\in[d]</span> we have</p>

    <p class="text-gray-300"><span class="math">L_{i}(X):=c_{d}\\cdot\\sum_{j=0}^{d-1}(X/\\omega^{i})^{j},</span></p>

    <p class="text-gray-300">for <span class="math">c_{d}:=\\frac{1}{d}</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Substituting <span class="math">X=\\omega^{i^{\\prime}}</span> for <span class="math">i^{\\prime}\\neq i</span> we have a sum over all roots of unity of order <span class="math">d</span> which is <span class="math">0</span>. Substituting <span class="math">X=\\omega^{i}</span> we have a sum of <span class="math">d</span> ones divided by <span class="math">d</span> which is one. ∎</p>

    <p class="text-gray-300">For <span class="math">\\tau\\in\\mathbb{F}^{*}_{\\tau}</span>, denote by we denote by <span class="math">\\mathrm{LAG}_{\\tau}\\in\\mathbb{G}_{1}^{d}\\times\\mathbb{G}_{2}^{d}</span> the vector</p>

    <p class="text-gray-300"><span class="math">\\mathrm{LAG}_{\\tau}:=\\left((L_{i}(\\tau)\\cdot g_{1})_{i\\in[d]},(L_{i}(\\tau)\\cdot g_{2})_{i\\in[d]}\\right).</span></p>

    <p class="text-gray-300">The purpose of the FFT-protocol is to compute <span class="math">\\mathrm{LAG}_{\\tau}</span> from <span class="math">\\mathrm{POWERS}_{\\tau}</span>. Let us focus for simplicity how to compute the first half containing the <span class="math">\\mathbb{G}_{1}</span> elements. Computing the second half is completely analogous. We define the polynomial <span class="math">P(Y)(=P_{\\tau}(Y))</span> by</p>

    <p class="text-gray-300"><span class="math">P(Y):=\\sum_{j=0}^{&lt;d}(\\tau\\cdot Y)^{j}.</span></p>

    <p class="text-gray-300">It is easy to check that</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Claim 3.2.</h6>

    <p class="text-gray-300">For <span class="math">i\\in[d]</span></p>

    <p class="text-gray-300"><span class="math">L_{i}(\\tau)=P(\\omega^{-i})=P(\\omega^{d-i}),</span></p>

    <p class="text-gray-300">and thus</p>

    <p class="text-gray-300"><span class="math">\\mathrm{LAG}_{\\tau}=(P(\\omega^{-i}))_{i\\in[d]}\\cdot g</span></p>

    <p class="text-gray-300">Thus our task reduces to computing the vector <span class="math">(P(\\omega^{i}))_{i\\in[d]}\\cdot g_{1}</span> (and then reordering accordingly). We describe an algorithm to compute the vector <span class="math">(P(\\omega^{i}))_{i\\in[d]}</span> using the vector <span class="math">(1,\\tau,\\tau^{2},\\ldots,\\tau^{d})</span> as input and only linear combination gates. This suffices as these linear combinations can be simulated by scalar multiplication and addition in <span class="math">\\mathbb{G}_{1}</span>, when operating on <span class="math">\\mathrm{POWERS}_{\\tau}</span>. We proceed to review standard FFT tricks that will be used.</p>

    <p class="text-gray-300">For a polynomial <span class="math">P(Y) = \\sum_{i=0}^{&lt;d} a_i \\cdot=&quot;&quot; of=&quot;&quot; degree=&quot;&quot; smaller=&quot;&quot; than=&quot;&quot; of=&quot;&quot; of,=&quot;&quot; we=&quot;&quot;&gt; = \\sum_{i=0}^{&lt;d=&quot;&quot; d=&quot;&quot; d</span>="">} a_{2i} \\cdot Y^i,$</p>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">P_{\\mathrm{ODD}}(Y) := \\sum_{i=0}^{&lt;d 2}=&quot;&quot; a_{2i+1}=&quot;&quot; a_{2i+1} \\cdot=&quot;&quot; t}=&quot;&quot; y^i.</span></div>

    <p class="text-gray-300">It is easy to see that</p>

    <div class="my-4 text-center"><span class="math-block">P(Y) = P_{\\mathrm{EVEN}}(Y^2) + Y \\cdot P_{\\mathrm{ODD}}(Y^2).</span></div>

    <p class="text-gray-300">In particular, for <span class="math">i \\in [d]</span></p>

    <div class="my-4 text-center"><span class="math-block">P(\\omega^i) = P_{\\mathrm{EVEN}}(\\omega^{2i}) + \\omega^i \\cdot P_{\\mathrm{ODD}}(\\omega^{2i})</span></div>

    <p class="text-gray-300">For <span class="math">j = 0, \\ldots, \\ell - 1</span> denote <span class="math">\\omega_j \\triangleq \\omega^{2^j}</span>. Note further that <span class="math">\\{\\omega^{2i}\\}_{i \\in [d]}</span> is a subgroup if size <span class="math">d/2</span> generated by <span class="math">\\omega_1</span>. More generally, for <span class="math">j = 1, \\ldots, \\ell - 1</span> <span class="math">\\left\\{\\omega_{j-1}^{2i}\\right\\}_{i \\in [d]}</span> is a subgroup of size <span class="math">2^{d-j}</span> generated by <span class="math">\\omega_j</span>. The above discussion suggests the following (well-known FFT) recursive algorithm.</p>

    <p class="text-gray-300"><strong>FFT</strong></p>

    <p class="text-gray-300"><strong>input:</strong> Polynomial <span class="math">P</span>, given as list of coefficients, element <span class="math">\\omega \\in \\mathbb{F}_r</span> generating a group of size <span class="math">d = 2^\\ell</span>.</p>

    <p class="text-gray-300"><strong>output:</strong> The vector <span class="math">V = (P(\\omega^i))_{i \\in [d]}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">d = 2</span> compute <span class="math">V</span> directly.</li>

      <li>Otherwise,</li>

    </ol>

    <p class="text-gray-300">(a) Call the method recursively twice; first with <span class="math">P_{\\mathrm{EVEN}}</span> and <span class="math">\\omega^2</span> to obtain output <span class="math">E := (P_{\\mathrm{EVEN}}(\\omega^{2i}))_{i \\in [d/2]}</span>, and then with <span class="math">P_{\\mathrm{ODD}}</span> and <span class="math">\\omega^2</span> to obtain the vector <span class="math">O := (P_{\\mathrm{ODD}}(\\omega^{2i}))_{i \\in [d/2]}</span>.</p>

    <p class="text-gray-300">(b) Compute the vector <span class="math">V</span> using <span class="math">E, O</span> and the equality mentioned above. More specifically, each element <span class="math">V_i</span> of <span class="math">V</span> is computed as</p>

    <div class="my-4 text-center"><span class="math-block">V_i = P(\\omega^i) = P_{\\mathrm{EVEN}}(\\omega^{2i}) + \\omega^i \\cdot P_{\\mathrm{ODD}}(\\omega^{2i}) = E_i + \\omega^i \\cdot O_i,</span></div>

    <p class="text-gray-300">(where we subtract <span class="math">d/2</span> from indices of <span class="math">E</span> and <span class="math">O</span> when they are larger than <span class="math">d/2</span>).</p>

    <p class="text-gray-300">In summary, we obtain <span class="math">\\mathrm{LAG}_{\\tau}</span> by applying the FFT and the polynomial <span class="math">P</span> described above, with coefficients <span class="math">1, \\tau, \\ldots, \\tau^{d-1}</span> and an <span class="math">\\omega</span> of order <span class="math">d</span> - which should be the same <span class="math">\\omega</span> used in the QAP construction. After getting the result from the FFT, we reverse the order of the vector and multiply each element by the scalar <span class="math">1/d</span>.</p>

    <p class="text-gray-300"><strong>Preparing the vectors</strong> <span class="math">\\vec{A}, \\vec{B}</span> and <span class="math">\\vec{C}</span>  We need to compute the vectors <span class="math">\\vec{A} := (A_i(\\tau))_{i \\in [0..m+1]} \\cdot g_1</span>, <span class="math">\\vec{B} := (B_i(\\tau))_{i \\in [0..m+1]} \\cdot g_1</span>, <span class="math">\\vec{B_2} := (B_i(\\tau))_{i \\in [0..m+1]} \\cdot g_2</span>, and <span class="math">\\vec{C} := (C_i(\\tau))_{i \\in [0..m+1]} \\cdot g_1</span>. We remark that [BCTV14] use the same notation for vectors of polynomials, while we are looking at the vector of these polynomials evaluated at <span class="math">\\tau</span>.</p>

    <p class="text-gray-300">11</d></d></d></p>

    <p class="text-gray-300">Note that <span class="math">A_{m+1} = B_{m+1} = C_{m+1} := Z[\\tau] \\cdot g_1 = (\\tau^d - 1) \\cdot g_1</span>. After the FFT, we have obtained  <span class="math">\\mathrm{LAG}_{\\tau}</span> , so each such element is a linear combination of elements of  <span class="math">\\mathrm{LAG}_{\\tau}</span> ; except  <span class="math">Z(\\tau) \\cdot g</span> , that can be computed using the elements  <span class="math">\\tau^d \\cdot g</span>  in  <span class="math">\\mathrm{POWERS}_{\\tau}</span> .</p>

    <h2 id="sec-32" class="text-2xl font-bold">3.4 Round 3</h2>

    <p class="text-gray-300">After the random-powers subprotocol and the FFT, the MPC consists of a few invocations of the random-coefficient subprotocol. These invocations add a total of two rounds to the MPC, as sometimes and random-coefficient subprotocol will need the output of a previous random-coefficient subprotocol as input.</p>

    <p class="text-gray-300"><strong>Part 1: broadcasting result of FFT</strong> The coordinator broadcasts the vectors  <span class="math">\\vec{A},\\vec{B},\\vec{C},\\vec{B}_2</span></p>

    <p class="text-gray-300"><strong>Part 2: Random coefficient subprotocol invocations</strong> We apply the random-coefficient subprotocol numerous times to obtain the different key elements. For an element  <span class="math">\\alpha_{i} \\in \\text{elements}_{i}</span> , we abuse notation here and denote  <span class="math">\\alpha := \\alpha_{1} \\cdots \\alpha_{n}</span>  (as opposed to omitting the index  <span class="math">i</span>  and writing  <span class="math">\\alpha</span>  for  <span class="math">\\alpha_{i}</span>  which we did when describing Round 1).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">PK_{A} = \\mathrm{RCPC}(\\vec{A},\\rho_{A})</span></li>

      <li><span class="math">PK_{B} = \\mathrm{RCPC}(\\vec{B}_{2},\\rho_{B})</span></li>

      <li><span class="math">PK_{C} = \\mathrm{RCPC}(\\vec{C},\\rho_{A}\\rho_{B})</span></li>

      <li><span class="math">PK_{A}^{\\prime} = \\mathrm{RCPC}(\\vec{A},\\rho_{A}\\alpha_{A})</span></li>

      <li><span class="math">PK_{B}^{\\prime} = \\mathrm{RCPC}(\\vec{B},\\rho_{B}\\alpha_{B})</span></li>

      <li><span class="math">PK_{C}^{\\prime} = \\mathrm{RCPC}(\\vec{C},\\rho_{A}\\rho_{B}\\alpha_{C}))</span></li>

      <li><span class="math">temp_{B} = \\mathrm{RCPC}(\\vec{B},\\rho_{B})</span></li>

      <li><span class="math">VK_{Z} = \\mathrm{RCPC}(g_{2} \\cdot Z(\\tau), \\rho_{A}\\rho_{B})</span> . We use that  <span class="math">g_{2} \\cdot Z(\\tau) = g_{2} \\cdot (\\tau^{d} - 1)</span>  can be computed from  <span class="math">PK_{H}^{\\prime}</span>  that was computed in Round 2, part 2, as described in Section 3.2.</li>

      <li><span class="math">VK_{A} = \\mathrm{RCPC}(g_{2},\\alpha_{A})</span></li>

      <li><span class="math">VK_{B} = \\mathrm{RCPC}(g_{1},\\alpha_{B})</span></li>

      <li><span class="math">VK_{C} = \\mathrm{RCPC}(g_{2},\\alpha_{C})</span></li>

    </ol>

    <p class="text-gray-300">3.5 Round 4: Computing key elements involving <span class="math">\\beta</span>, especially <span class="math">PK_{K}</span></p>

    <p class="text-gray-300">Each player (or just the coordinator) computes <span class="math">V:=PK_{A}+temp_{B}+PK_{C}</span>. The players compute</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">PK_{K}=\\text{RCPC}(V,\\beta)</span></li>

      <li><span class="math">VK_{\\gamma}=\\text{RCPC}(g_{2},\\gamma)</span></li>

      <li><span class="math">VK^{1}_{\\beta\\gamma}=\\text{RCPC}(g_{1},\\beta\\gamma)</span>.</li>

      <li><span class="math">VK^{2}_{\\beta\\gamma}=\\text{RCPC}(g_{2},\\beta\\gamma)</span>.</li>

    </ol>

    <p class="text-gray-300">Finally, the protocol verifier will run verifyRCPC(,) on the input and transcript of each subprotocol executed in Round 3 or 4; and output acc if and only if all invocations of verifyRCPC(,) returned acc.</p>

    <h2 id="sec-33" class="text-2xl font-bold">4 Security proof</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix a QAP instance <span class="math">\\phi</span> and input <span class="math">x</span> for <span class="math">\\phi</span>. Let V be the snark verifier of <em>[x13]</em>. We denote by <span class="math">T\\subset[n]</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n-1<span class="math">, the subset of players controlled by the adversary </span>B<span class="math">. Our goal is to show that under certain cryptographic assumptions, most notably the Knowledge of Exponent (KEA) assumption, if </span>B<span class="math"> can generate a proof that </span>\\textsf{V}(\\phi,x)<span class="math"> accepts with non-negligible probability, when V is using the parameters generated in the protocol, then there exists an extractor </span>E<span class="math"> generating a witness </span>\\omega<span class="math"> satisfying </span>(\\phi,x)<span class="math"> with non-negligible probability. Our proofs hold in the random oracle model where a random oracle </span>\\mathcal{R}$ takes the place of COMMIT in the protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Notational conventions</h4>

    <p class="text-gray-300">To simplify notations we will refer to a fixed pair of groups <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2})</span>. of order <span class="math">r</span>; we implicitly assume that we have a generator <span class="math">\\mathcal{G}</span> that when given integer <span class="math">t</span> as parameter, returns a prime <span class="math">r</span> with <span class="math">r=\\text{poly}(t)</span> and groups <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t}</span> of order <span class="math">r</span>, with the property that for all cryptographic problems described next (Knowledge of Exponent, Strong Diffie-Helman, Power Diffie-Helman) an efficient adversary has <span class="math">\\textsf{negl}(\\log r)</span> success probability; where we remind that by efficient adversary we mean a non-uniform (sequence of) circuit(s) of size <span class="math">\\text{poly}(\\log r)</span>.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">4.1 Cryptographic assumptions</h3>

    <p class="text-gray-300">We use bilinear versions of the Strong Diffie-Helman, Power Diffie-Helman, and Knowledge of Exponent assumption as in <em>[CFH^{+}15]</em>. It will be convenient to denote <span class="math">G^{*}:=\\mathbb{G}_{1}\\setminus\\{0\\}\\times\\mathbb{G}_{2}\\setminus\\{0\\}</span>, and as before by <span class="math">g=(g_{1},g_{2})</span> a pair of generators for both groups.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 4.1 (Knowledge of Exponent Assumption (KEA)).</h6>

    <p class="text-gray-300">For any efficient <span class="math">A</span> there exists an efficient <span class="math">E</span> such that the following holds. Fix positive integer <span class="math">d</span>, and an efficient randomized circuit <span class="math">S</span> with input domain <span class="math">(G^{*})^{2(d+1)}</span>. Consider the following experiment.</p>

    <p class="text-gray-300"><span class="math">\\tau,\\alpha\\in\\mathbb{F}_{r}^{<em>}</span> and <span class="math">g\\in G^{</em>}</span> are chosen uniformly. We denote <span class="math">V:=(1,\\tau,\\ldots,\\tau^{d},\\alpha,\\alpha\\tau,\\ldots,\\alpha\\tau^{d})\\cdot g</span> Then <span class="math">A</span> is given as input <span class="math">S(V)</span>; and outputs a pair of the form <span class="math">(c,d)</span> in <span class="math">\\mathbb{G}_{1}\\setminus\\{0\\}</span>, which he “hopes” is of the form <span class="math">(c,\\alpha c)</span>. <span class="math">E</span>, given the same input, outputs <span class="math">a_{0},a_{1},\\ldots,a_{d}\\in\\mathbb{F}_{r}</span> such that the probability that both</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> “succeeded”, i.e., <span class="math">d=\\alpha\\cdot c</span>. But,</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">E</span> “failed”, i.e., <span class="math">c \\neq (\\sum_{i=0}^{d} a_i \\tau^i) \\cdot g_1</span>.</li>

    </ol>

    <p class="text-gray-300">is <span class="math">\\operatorname{negl}(\\log r)</span>. The same holds when <span class="math">\\mathbb{G}_1 \\setminus \\{0\\}</span> is replaced by <span class="math">\\mathbb{G}_2 \\setminus \\{0\\}</span> and <span class="math">g_1</span> is replaced by <span class="math">g_2</span>.</p>

    <p class="text-gray-300"><strong>Remark 4.2.</strong> Bitansky et. al [BCPR14], in fact show that the above assumption is false, assuming the existence of indistinguishability obfuscation, when allowing a general <span class="math">S</span>. If one is troubled by this, one may replace the general <span class="math">S</span> in the above definition, by limiting <span class="math">S</span> to be a circuit that computes one of the functions in Claim 4.5, after computing its inputs from a uniformly chosen vector <span class="math">\\mathsf{secrets} \\in (\\mathbb{F}_r^*)^8</span>.</p>

    <p class="text-gray-300">We preferred to stick with the less cumbersome definition above, particularly, as the existence of indistinguishability obfuscation is questionable.</p>

    <p class="text-gray-300"><strong>Definition 4.3 (q-SDH assumption).</strong> Fix positive integer <span class="math">q</span>. Consider the following experiment. <span class="math">\\tau \\in \\mathbb{F}_r^<em></span> and <span class="math">g \\in G^</em></span> are chosen uniformly. Then an efficient <span class="math">A</span> is given as input <span class="math">(1, \\tau, \\dots, \\tau^q) \\cdot g</span>. Then the probability that <span class="math">A</span> outputs <span class="math">e(g_1, g_2)^{\\frac{1}{\\tau + c}}</span>, for some <span class="math">c \\in \\mathbb{F}_r^*</span> is <span class="math">\\mathsf{negl}(\\log r)</span>.</p>

    <p class="text-gray-300"><strong>Definition 4.4 (q-PDH assumption).</strong> Fix positive integer <span class="math">q</span>. Consider the following experiment. <span class="math">\\tau \\in \\mathbb{F}_r^<em></span> and <span class="math">g \\in G^</em></span> are chosen uniformly. Then an efficient <span class="math">A</span> is given as input <span class="math">(1, \\tau, \\dots, \\tau^q, \\tau^{q+2}, \\dots, \\tau^{2q}) \\cdot g</span>. Then the probability that <span class="math">A</span> outputs <span class="math">\\tau^{q+1} \\cdot g_1</span> is <span class="math">\\mathsf{negl}(\\log r)</span>.</p>

    <h2 id="sec-37" class="text-2xl font-bold">4.2 The Pinocchio Theorem</h2>

    <p class="text-gray-300">We refer to Appendix B of [BCTV14] for a description of the Pinocchio protocol [PHGR16] with notation close to what is used here. We also give a semi-formal description of the protocol in Appendix B.</p>

    <p class="text-gray-300">Furthermore, one may refer to [PHGR16] and [BCTV14] for definitions relating to quadratic arithmetic programs (QAPs), that we assume familiarity with here. Given a QAP instance <span class="math">\\phi</span> of degree <span class="math">d</span>, we typically denote by <span class="math">\\mathsf{params}_{\\phi}</span> a legitimate set of Pinocchio parameters, i.e., proving key and verification key, for <span class="math">\\phi</span>. We can think of <span class="math">\\mathsf{params}_{\\phi}</span> as a deterministic function of the values <span class="math">\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta \\in \\mathbb{F}_r^<em></span>; or alternatively of a vector <span class="math">\\mathsf{secrets} \\in (\\mathbb{F}_r^</em>)^8</span> consisting of these values. Actually, for our security proof we need to define <span class="math">\\mathsf{params}_{\\phi}</span> to include all Pinocchio key elements "given in both groups". Specifically, denoting <span class="math">g := (g_1, g_2)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{params}_{\\phi}(\\mathsf{secrets}) := (P_H, P_\\phi, P_{\\alpha\\phi}, P_K, V),</span></div>

    <p class="text-gray-300">where <span class="math">P_H := \\left\\{\\tau^i \\cdot g\\right\\}_{i \\in [d]}, P_\\phi := (P_A, P_B, P_C), P_{\\alpha\\phi} := (P_{\\alpha A}, P_{\\alpha B}, P_{\\alpha C}), P_K := \\beta \\cdot (P_A + P_B + P_C)</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">P_A := (A_i \\cdot g_A)_{i \\in [m]}, P_{\\alpha A} := (A_i \\alpha_A \\cdot g_A)_{i \\in [m]},</span></div>

    <p class="text-gray-300">and <span class="math">P_B, P_{\\alpha B}, P_C, P_{\\alpha C}</span> defined similarly, where <span class="math">g_A := \\rho_A \\cdot g, g_B := \\rho_B \\cdot g</span> and <span class="math">g_C := \\rho_A \\rho_B \\cdot g</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">V := (\\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\rho_A \\rho_B Z(\\tau), \\gamma, \\beta\\gamma) \\cdot g</span></div>

    <p class="text-gray-300">The following claim enables us to use the knowledge of exponent assumption in the proof of Theorem 4.6.</p>

    <p class="text-gray-300"><strong>Claim 4.5.</strong> There are efficient (deterministic) functions <span class="math">F_A, F_B, F_C</span> such that the following holds. Fix any vector <span class="math">\\mathsf{secrets} = (\\tau, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta)</span> in <span class="math">(\\mathbb{F}_r^*)^8</span> and instance <span class="math">\\phi</span>. Denote by <span class="math">\\mathsf{secrets}_A, \\mathsf{secrets}_B</span> and <span class="math">\\mathsf{secrets}_C</span> the vector <span class="math">\\mathsf{secrets}</span> when omitting the element <span class="math">\\alpha_A, \\alpha_B</span> and <span class="math">\\alpha_C</span> respectively. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{params}_{\\phi}(\\mathsf{secrets}) = F_A(P_H, P_H \\cdot \\alpha_A, \\mathsf{secrets}_A, \\phi) \\\\ = F_B(P_H, P_H \\cdot \\alpha_B, \\mathsf{secrets}_B, \\phi) = F_C(P_H, P_H \\cdot \\alpha_C, \\mathsf{secrets}_C, \\phi) \\end{array}</span></div>

    <p class="text-gray-300">Proof. By simple examination of the elements of <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>. For example, the only elements in <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span> that are not a function of <span class="math">\\mathsf{secrets}_A</span> are <span class="math">P_{\\alpha A}</span> and <span class="math">\\alpha_A \\cdot g \\in V</span>. Both are a joint efficient function of <span class="math">\\rho_A</span> and <span class="math">P_H \\cdot \\alpha_A</span>: We can compute <span class="math">P_H \\cdot \\alpha_A \\cdot \\rho_A = \\{\\tau^i \\rho_A \\alpha_A \\cdot g\\}_{i \\in [d]}</span> and then <span class="math">P_{\\alpha A}</span> elements are linear combinations of elements of this vector, and <span class="math">\\alpha_A \\cdot g</span> is simply the first element of <span class="math">P_H \\cdot \\alpha_A</span>.</p>

    <p class="text-gray-300">Recall that <span class="math">\\mathsf{V}</span> denotes the Pinocchio protocol verifier. The inputs of <span class="math">\\mathsf{V}</span> include the QAP instance <span class="math">\\phi</span>, the instance input <span class="math">x</span>, the CRS or public parameters <span class="math">\\mathsf{params}_{\\phi}</span>, and the purported proof <span class="math">\\pi</span> that indeed <span class="math">x</span> satisfies <span class="math">\\phi</span>, and that the prover knows a witness showing this. A slight modification of the security proof of [PHGR16] shows that</p>

    <p class="text-gray-300"><strong>Theorem 4.6.</strong> [Pinocchio proof of knowledge] For any efficient <span class="math">A</span> there exists an efficient extractor <span class="math">E</span> such that for any instance <span class="math">\\phi</span> and input <span class="math">x</span> the following holds. The probability over <span class="math">\\mathsf{secrets} \\in (\\mathbb{F}_r^*)^8</span>, when <span class="math">A</span> and <span class="math">E</span> are given <span class="math">(\\phi, x)</span> and <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span> as input that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> produces <span class="math">\\pi</span> such that <span class="math">\\mathsf{V}(\\phi, x, \\mathsf{params}_{\\phi}(\\mathsf{secrets}), \\pi) = \\mathsf{acc}</span>, but</li>

      <li><span class="math">E</span> does not output a witness <span class="math">\\omega</span> satisfying <span class="math">(\\phi, x)</span>,</li>

    </ol>

    <p class="text-gray-300">is <span class="math">\\mathsf{negl}(\\log r)</span>.</p>

    <p class="text-gray-300">The proof is almost identical to that of [PHGR16], but we present it here for completeness, at times referring to [PHGR16] for details. An advantage of this proof is that it works for the variant of Pinocchio actually implemented in libsnark, as described in Appendix B of [BCTV14]. To our knowledge, no proof for this variant is written elsewhere. We also recommend looking at the proofs of [GGPR13, <span class="math">\\mathrm{CFH}^{+}15</span>] for intuition and clarifications.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We are given <span class="math">A</span> and wish to construct <span class="math">E</span>. We describe how <span class="math">E</span> operates given inputs <span class="math">(\\phi, x)</span> and <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>. Recall that the purported proof <span class="math">\\pi</span> produced by <span class="math">A</span> has the structure, in the notation of [BCTV14],</p>

    <div class="my-4 text-center"><span class="math-block">\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi_A&#x27;, \\pi_B&#x27;, \\pi_C&#x27;, \\pi_K, \\pi_H).</span></div>

    <p class="text-gray-300">From the description of <span class="math">\\mathsf{V}</span>, we know that whenever <span class="math">A</span> produces a proof <span class="math">\\pi</span> accepted by <span class="math">\\mathsf{V}</span>, we have in particular, <span class="math">\\pi_A&#x27; = \\alpha_A \\cdot \\pi_A, \\pi_B&#x27; = \\alpha_B \\cdot \\pi_B</span> and <span class="math">\\pi_C&#x27; = \\alpha_C \\cdot \\pi_C</span>, where <span class="math">\\alpha_A, \\alpha_B, \\alpha_C</span> are the corresponding elements of the vector <span class="math">\\mathsf{secrets}</span>. <span class="math">E</span> works as follows. It gives <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span> as input to the extractors <span class="math">E_A, E_B, E_C</span> that exist by the KEA assumption together with Claim 4.5 and Remark 4.2. Let <span class="math">a_0, \\ldots, a_d</span> be <span class="math">E_A</span>'s output. Define <span class="math">A_{\\mathrm{mid}}(X) \\coloneqq \\sum_{i=0}^{d} a_i \\cdot X^i</span>. Let <span class="math">A_{io}</span> be the polynomial of degree at most <span class="math">d</span> defined by the io elements in <span class="math">x</span>; i.e., when <span class="math">x = (c_1, \\ldots, c_n)</span>, <span class="math">A_{io}(X) \\coloneqq A_0(X) + \\sum_{i=1}^{n} c_i \\cdot A_i(X)</span>. Define <span class="math">A(X) \\coloneqq A_{io}(X) + A_{\\mathrm{mid}}(X)</span>. <span class="math">E</span> does an analogous thing with <span class="math">E_B</span> and <span class="math">E_C</span> to obtain polynomials <span class="math">B, C</span>. Now, using linear algebra, <span class="math">E</span> determines whether there exists a set of coefficients <span class="math">c = (c_0 = 1, c_1, \\ldots, c_m)</span>, such that</p>

    <div class="my-4 text-center"><span class="math-block">A(X) = \\sum_{i=0}^{m} c_i \\cdot A_i(X), \\quad B(X) = \\sum_{i=0}^{m} c_i \\cdot B_i(X), \\quad C(X) \\cdot \\sum_{i=0}^{m} c_i \\cdot C_i(X).</span></div>

    <p class="text-gray-300">From the non-degeneracy property<span class="math">^5</span> [BCTV14], it follows that if there exists such <span class="math">c</span> it coincides with <span class="math">x</span> on <span class="math">c_1, \\ldots, c_n</span>. If such <span class="math">c</span> exists, output any such <span class="math">c</span> as the proposed QAP witness <span class="math">\\omega</span> for <span class="math">(\\phi, x)</span>.</p>

    <p class="text-gray-300"><span class="math">^5</span>One needs to make a stronger definition of non-degeneracy than given in [BCTV14]. Specifically, we require that <span class="math">A_0, \\ldots, A_n</span> are linearly independent and their span is disjoint from the span of <span class="math">\\{A_{n+1}, \\ldots, A_m\\}</span> except for 0.</p>

    <p class="text-gray-300">Otherwise, abort. Let <span class="math">\\eta</span> be the probability that <span class="math">A</span> produced a valid proof but <span class="math">E</span> did not produce a valid assignment for <span class="math">(\\phi, x)</span>. Let <span class="math">q := 4d + 4</span>. We construct an efficient <span class="math">B</span> with the following property. Given a challenge challenge = challenge<span class="math">_s := (1, s, \\ldots, s^q, s^{q+2}, \\ldots, s^{2q}) \\cdot g</span>, where <span class="math">s</span> is uniform in <span class="math">\\mathbb{F}_r^*</span>, <span class="math">B</span> outputs with probability <span class="math">\\eta - \\mathrm{negl}(\\log r)</span> either</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">s^{q+1} \\cdot g_1</span>, or</li>

      <li><span class="math">e(g_1, g_2)^{\\frac{1}{s + t}}</span>, for some <span class="math">t \\in \\mathbb{F}_r^*</span>.</li>

    </ul>

    <p class="text-gray-300">This implies that <span class="math">\\eta = \\mathrm{negl}(\\log r)</span>, as otherwise it would contradict the <span class="math">2q - SDH</span> or <span class="math">q - PDH</span> assumption. Thus, showing <span class="math">\\eta = \\mathrm{negl}(\\log r)</span> suffices to prove the theorem. <span class="math">^6</span></p>

    <p class="text-gray-300"><strong>Description of <span class="math">B</span></strong>: Given challenge, <span class="math">B</span> begins by constructing a valid set of parameters <span class="math">\\mathrm{params}^{\\mathrm{pin}}</span>, that are a randomized function <span class="math">\\mathrm{params}^{\\mathrm{pin}}(s)</span> of <span class="math">s \\in \\mathbb{F}_r^*</span>, as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\alpha_{A}, \\alpha_{B}, \\alpha_{C}, \\rho_{A}^{\\prime}, \\rho_{B}^{\\prime}, \\gamma^{\\prime}</span> are chosen uniformly in <span class="math">\\mathbb{F}_r^*</span></li>

      <li>We define <span class="math">\\rho_{A} := \\rho_{A}^{\\prime} \\cdot s^{d + 1}, \\rho_{B} := \\rho_{B}^{\\prime} \\cdot s^{2(d + 1)}</span></li>

      <li>For <span class="math">i \\in [0..m]</span>, define the polynomial <span class="math">P_{i}(X) := \\rho_{A}^{\\prime} X^{d + 1} \\cdot A_{i}(X) + \\rho_{B}^{\\prime} X^{2(d + 1)} \\cdot B_{i}(X) + \\rho_{A}^{\\prime} \\rho_{B}^{\\prime} X^{3(d + 1)} \\cdot C_{i}(X)</span>. Define <span class="math">V</span> to be the <span class="math">\\mathbb{F}_r</span>-linear space <span class="math">V := \\operatorname{span}\\{P_i\\}_{i \\in [0..m]}</span> and <span class="math">U</span> to be the <span class="math">\\mathbb{F}_r</span>-linear space of all polynomials <span class="math">f</span> of degree at most <span class="math">3d + 3</span> such that <span class="math">f \\cdot P_i</span> has a zero coefficient at <span class="math">X^q</span> for each <span class="math">i \\in [0..m]</span>.</li>

      <li>Choose random <span class="math">f \\in U</span>, and let <span class="math">\\beta := s \\cdot f(s)</span>.</li>

      <li>Let <span class="math">\\gamma := \\gamma&#x27; \\cdot s^{q+2}</span>.</li>

      <li>output <span class="math">\\mathrm{params}^{\\mathrm{pin}}(s) := \\mathrm{params}_{\\phi}(s, \\rho_A, \\rho_B, \\alpha_A, \\alpha_B, \\alpha_C, \\gamma, \\beta)</span>.</li>

    </ol>

    <p class="text-gray-300">It can be verified that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">s</span> is uniform in <span class="math">\\mathbb{F}_r^*</span>, <span class="math">\\mathrm{params}^{\\mathrm{pin}}(s)</span> is distributed as <span class="math">\\mathrm{params}_{\\phi}(\\mathrm{secrets})</span> for uniform value of <span class="math">\\mathrm{secrets}</span>.</li>

      <li><span class="math">\\mathrm{params}^{\\mathrm{pin}}(s)</span> can be efficiently computed from <span class="math">\\mathrm{challenge}_s</span>.</li>

    </ol>

    <p class="text-gray-300">The main point to see the second item is that the power <span class="math">s^{q+1}</span> does not appear in any of the elements of <span class="math">\\mathrm{params}^{\\mathrm{pin}}(s)</span> (this is immediate for most elements, and requires a calculation for elements containing <span class="math">\\beta</span>).</p>

    <p class="text-gray-300">Now <span class="math">B</span> runs <span class="math">A</span> on <span class="math">(\\phi, x, \\mathrm{params}^{\\mathrm{pin}}(s))</span> to obtain a purported proof <span class="math">\\pi = (\\pi_A, \\pi_B, \\pi_C, \\pi_A&#x27;, \\pi_B&#x27;, \\pi_C&#x27;, \\pi_K, \\pi_H)</span>.</p>

    <p class="text-gray-300"><span class="math">B</span> also runs <span class="math">E_A, E_B, E_C</span> on <span class="math">\\mathrm{params}^{\\mathrm{pin}}(s)</span> to obtain polynomials <span class="math">A, B, C</span> described above, and attempts to find a vector <span class="math">c</span> of coefficients as above. Because of Item 1, together with the KEA and the reasoning above, we know that with probability at least <span class="math">\\eta - \\mathrm{negl}(\\log r)</span> over <span class="math">s</span>,</p>

    <div class="my-4 text-center"><span class="math-block">A_{io}(s) \\rho_A \\cdot g_1 + \\pi_A = A(s) \\rho_A \\cdot g_1; \\pi_B = B(s) \\rho_B \\cdot g_2; \\pi_C = C(s) \\rho_A \\rho_B \\cdot g_1,</span></div>

    <p class="text-gray-300">but one of the following happened</p>

    <p class="text-gray-300"><span class="math">^6</span>For the completely precise argument one must also choose <span class="math">g \\in G^<em></span> randomly and take success probability over that. To avoid having to “carry the <span class="math">g</span>”, we implicitly assume that whenever a statement is made about fixed <span class="math">g</span> it happens with non-negligible probability over a uniform choice of <span class="math">g</span>. e.g. in the theorem statement we are actually assuming <span class="math">A</span> produces a valid proof for <span class="math">(\\phi, x, \\mathrm{params}_{\\phi}(\\mathrm{secrets}))</span> with probability <span class="math">\\delta</span>, for a non-negligible fraction of <span class="math">g \\in G^</em></span>.</p>

    <p class="text-gray-300">16</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There does not exist a vector <span class="math">c</span> as described above.</li>

      <li>Such <span class="math">c</span> exists but is not a valid QAP witness for <span class="math">(\\phi,x)</span></li>

    </ol>

    <p class="text-gray-300">Define the polynomial</p>

    <p class="text-gray-300"><span class="math">R(X):=\\rho_{A}^{\\prime}X^{d+1}\\cdot A(X)+\\rho_{B}^{\\prime}X^{2(d+1)}\\cdot B(X)+\\rho_{A}^{\\prime}\\rho_{B}^{\\prime}X^{3(d+1)}\\cdot C(X).</span></p>

    <p class="text-gray-300">These two cases are equivalent, respectively, to the following two.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R(X)</span> is not in the subspace <span class="math">V</span>.</li>

      <li><span class="math">P(X):=A(X)\\cdot B(X)-C(X)</span> is not a multiple of <span class="math">Z(X)</span>.</li>

    </ol>

    <p class="text-gray-300">Suppose that <span class="math">R(X)</span> is not in <span class="math">V</span>. We show that in this case <span class="math">B</span> can efficiently compute <span class="math">s^{q+1}\\cdot g_{1}</span>: It follows from Lemma 10 of <em>[x13]</em> that except with probability <span class="math">1/r</span> (over <span class="math">s</span> and the inner randomness of <span class="math">\\mathsf{params}^{\\mathsf{pin}}</span>), <span class="math">R^{\\prime}(X):=X\\cdot f(X)\\cdot R(X)</span> has a non-zero coefficient at <span class="math">X^{q+1}</span>. But note that as <span class="math">\\pi</span> was valid,</p>

    <p class="text-gray-300"><span class="math">\\pi_{K}=\\beta\\cdot(\\rho_{A}\\cdot A(s)+\\rho_{B}\\cdot B(s)+\\rho_{A}\\rho_{B}\\cdot C(s))\\cdot g_{1}=R^{\\prime}(s)\\cdot g_{1}.</span></p>

    <p class="text-gray-300"><span class="math">B</span> can thus use challenge to erase all elements of <span class="math">R^{\\prime}(s)\\cdot g_{1}</span> of powers different than <span class="math">q+1</span>, obtaining <span class="math">s^{q+1}\\cdot g_{1}</span>.</p>

    <p class="text-gray-300">Now suppose that <span class="math">P(X)</span> is not a multiple of <span class="math">Z(X)</span>. The same argument as in <em>[x20]</em> can now be used to obtain <span class="math">e(g_{1},g_{2})^{\\frac{1}{s+t}}</span>, for some <span class="math">t\\in\\mathbb{F}_{r}^{*}</span>. ∎</p>

    <p class="text-gray-300">We say an adversary <span class="math">A</span> defeats the protocol, if it is able to produce a set of parameters for which it can construct a valid proof, when COMMIT is replaced by a random oracle. More formally,</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 4.7.</h6>

    <p class="text-gray-300">Let <span class="math">B</span> be an adversary controlling <span class="math">n-1</span> out of <span class="math">n</span> players in our protocol. We assume <span class="math">B</span> is deterministic (as we can fix its randomness to maximize its success probability as defined next). Let <span class="math">P\\in\\{P_{1},\\ldots,P_{n}\\}</span> be the player not controlled by <span class="math">B</span>. We say <span class="math">B</span> <span class="math">\\delta</span>-defeats the protocol on <span class="math">(\\phi,x)</span> if with probability at least <span class="math">\\delta</span> over the randomness of <span class="math">P</span> in the protocol, and over the choices of a random oracle choosing the output values of COMMIT in the protocol description, the protocol verifier accepts the transcript, and <span class="math">B</span> afterwards produces a proof <span class="math">\\pi</span> such that <span class="math">\\mathsf{V}(\\phi,x,\\pi,\\mathsf{params}_{\\phi}^{B})=\\mathsf{acc}</span>, where <span class="math">\\mathsf{params}_{\\phi}^{B}</span> are the Pinocchio parameters for instance <span class="math">\\phi</span> that were generated by the protocol.</p>

    <p class="text-gray-300">The correctness of the protocol lies in the following theorem.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Theorem 4.8.</h6>

    <p class="text-gray-300">For any efficient <span class="math">B</span> controlling some subset of <span class="math">n-1</span> out of <span class="math">n</span> players, there is an efficient <span class="math">A</span> such that the following holds. Fix any instance <span class="math">\\phi</span> and input <span class="math">x</span>. Suppose that <span class="math">B</span> <span class="math">\\delta</span>-defeats the protocol on <span class="math">(\\phi,x)</span>. Then <span class="math">A</span> <span class="math">\\frac{\\delta}{\\mathrm{poly}(\\log r)}</span>-defeats Pinocchio on <span class="math">(\\phi,x)</span>. In particular, if <span class="math">B</span>’s success probability is non-negligible, so is <span class="math">A</span>’s success probability.</p>

    <p class="text-gray-300">Before proving the theorem note that an immediate corollary of Theorems 4.6 and 4.8 is</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Corollary 4.9.</h6>

    <p class="text-gray-300">[Knowledge Soundness of Protocol] For any efficient <span class="math">B</span> controlling some subset of <span class="math">n-1</span> out of <span class="math">n</span> players, there is an efficient extractor <span class="math">E</span> such that the following holds. Fix any instance <span class="math">\\phi</span> and input <span class="math">x</span>. Suppose that <span class="math">B</span> <span class="math">\\delta</span>-defeats the protocol on <span class="math">(\\phi,x)</span>. Then <span class="math">E</span> produces a witness <span class="math">\\omega</span> satisfying <span class="math">(\\phi,x)</span> with probability <span class="math">\\frac{\\delta}{\\mathrm{poly}(\\log r)}</span> over <span class="math">\\mathsf{secrets}\\in(\\mathbb{F}_{r}^{*})^{8}</span>, when given <span class="math">(\\phi,x,\\mathsf{params}_{\\phi}(\\mathsf{secrets}))</span> as input.</p>

    <p class="text-gray-300">We proceed to prove Theorem 4.8.</p>

    <p class="text-gray-300">Proof of Theorem 4.8</p>

    <p class="text-gray-300">For ease of notation, we assume that <span class="math">B</span> controls <span class="math">P_{2},\\ldots,P_{n}</span>. Also, we describe a non-uniform algorithm making choices depending on <span class="math">(\\phi,x)</span>. However, inspection shows that making all these choices uniformly (and independently of <span class="math">(\\phi,x)</span>) succeeds with probability <span class="math">\\delta/\\mathrm{poly}\\log r</span>. We denote by <span class="math">\\mathcal{R}</span> the random oracle that chooses the values of COMMIT in the protocol. We assume the range (i.e. domain of replies) of <span class="math">\\mathcal{R}</span> is of size <span class="math">\\mathsf{M}=\\mathrm{poly}(r)</span> which is exponential in our prespective. We will denote by <span class="math">\\pi</span> the purported proof and <span class="math">\\mathsf{params}_{\\phi}^{B}</span> the Pinocchio parameters generated in the protocol when <span class="math">B</span> is participating. (These are randomized functions of various elements as will be discussed below). We will say <span class="math">\\mathsf{params}_{\\phi}^{B}</span> and <span class="math">\\pi</span> are <em>accepted by</em> <span class="math">\\mathsf{V}</span>, if <span class="math">\\mathsf{V}(\\phi,x,\\mathsf{params}_{\\phi}^{B},\\pi)=\\mathsf{acc}</span>. It will be convenient to view the protocol as divided into two main phases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <em>commit and prove phase</em> which consists of Round 1 and Parts <span class="math">1-3</span> of Round 2, i.e., all parts of Round 2 except the random powers subprotocol.</li>

      <li>the <em>compute parameters phase</em> which consists of the random powers subprotocol in Round 2, together with Rounds 3 and 4.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathsf{e}=\\{\\mathsf{e}_{i}\\}_{i\\in[n]}</span> be the set of elements broadcast in Round 2 Part 1 during some execution of the protocol. Inspection of the protocol shows that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If all players follow the protocol, the transcript of the compute parameters phase is a deterministic function <span class="math">\\mathsf{comp}</span>-transcript<span class="math">(\\mathsf{e})</span> of <span class="math">\\mathsf{e}</span>.</li>

      <li>Using the correctness of the <span class="math">\\mathsf{sameRatio}(,)</span> method, given the value of <span class="math">\\mathsf{e}</span> in the commit and prove phase, if one of the players writes a message that does not coincide with <span class="math">\\mathsf{comp}</span>-transcript<span class="math">(\\mathsf{e})</span> in the compute parameters phase, the transcript will be accepted by the protocol verifier with probability at most <span class="math">2/r</span>. Thus, we assume that after the commit and prove phase, <span class="math">B</span> follows the protocol correctly in the compute parameters phase; as otherwise we may replace him by another adversary <span class="math">B</span>’ that does so, and <span class="math">\\delta-\\mathsf{negl}(\\log r)</span>-defeats the protocol.</li>

      <li>In Round 2 Part 3, whenever <span class="math">B</span> broadcasts an element <span class="math">R</span> in one of the nizks, if he has not queried <span class="math">\\mathcal{R}(R\\circ h)</span> where <span class="math">h</span> will be the appropriate element <span class="math">h_{s,j}</span>, the transcript will be accepted with probability at most <span class="math">1/\\mathsf{M}=\\mathsf{negl}(\\log r)</span>. Thus we can assume <span class="math">B</span> always makes these queries, as otherwise he may be replaced with an <span class="math">B</span>’ that does and <span class="math">\\delta-\\mathsf{negl}(\\log r)</span> defeats the protocol.</li>

      <li>Similarly, if <span class="math">B</span> has not queried <span class="math">\\mathcal{R}(\\mathsf{e}_{i})</span> before broadcasting <span class="math">h_{i}</span>, and has not indeed broadcasted <span class="math">\\mathcal{R}(\\mathsf{e}_{i})</span> as <span class="math">h_{i}</span>, where <span class="math">\\mathsf{e}_{i}</span> is what he will broadcast in Round 2 Part 1 his success probability is negligible, and we can assume this is not the case.</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">P_{1}</span>, acting honestly makes 10 calls to <span class="math">\\mathcal{R}</span>- one in the first round to compute his message <span class="math">h_{1}</span>, and 9 to compute the elements <span class="math">h,\\{h_{1,s}\\}</span> in Round 2 Part 3. Let us assume <span class="math">B</span> makes exactly <span class="math">Q^{\\prime}</span> queries to <span class="math">\\mathcal{R}</span> during Round one and two, and let <span class="math">Q:=Q^{\\prime}+10</span> be the total number of queries made to <span class="math">\\mathcal{R}</span>. Note that <span class="math">Q=\\mathrm{poly}(\\log r)</span> since the size of <span class="math">B</span> is <span class="math">\\mathrm{poly}(\\log r)</span>. Denote the answers of <span class="math">\\mathcal{R}</span> by <span class="math">C:=\\{c_{1},\\ldots,c_{Q}\\}</span>. Denote the queries by <span class="math">q_{1},\\ldots,q_{Q}</span>. Assume <span class="math">q_{1},\\ldots,q_{Q/2}</span> are exactly the ones made before the broadcast of <span class="math">\\mathsf{e}_{1}</span> in Round 2. Denote by <span class="math">M</span> the set of messages of <span class="math">P_{1}</span> in the Round 2 part of the commit and prove phase, that are not outputs of <span class="math">\\mathcal{R}</span>- so <span class="math">M</span> consists of the values <span class="math">\\mathsf{e}_{i}</span> and the outputs <span class="math">\\{\\pi_{1,s}\\}</span> of the nizks from Round 2 Part 3.</p>

    <p class="text-gray-300">Under this assumption, together with items 2 and 3 above, the whole protocol transcript, and in particular the Pinocchio parameters <span class="math">\\mathsf{params}_{\\phi}^{B}</span> and the purported proof <span class="math">\\pi</span> generated by <span class="math">B</span>, are a deterministic function <span class="math">F</span> of <span class="math">(C,M)</span>; i.e., we can denote <span class="math">(\\mathsf{params}_{\\phi}^{B},\\pi)=F(C,M)</span>. From the fact that <span class="math">B</span> <span class="math">\\delta</span>-defeats the protocol, we know that there is a set of density <span class="math">\\delta</span> of sequences <span class="math">(C,M)</span> that cause <span class="math">B</span> to produce a valid proof <span class="math">\\pi</span> when <span class="math">\\mathsf{V}</span> uses <span class="math">\\mathsf{params}_{\\phi}^{B}</span>. We can thus, using an averaging argument, fix a set of values <span class="math">S</span> for <span class="math">(C,M)</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S</span> has probability mass <span class="math">\\delta^{\\prime}=\\delta-\\mathsf{negl}(\\log r)</span> in the space of all possible values for <span class="math">(C,M)</span>, when <span class="math">C</span> is random, and <span class="math">M</span> is distributed according to an honest player <span class="math">P_{1}</span>’s messages.</li>

      <li><span class="math">C</span> contains all distinct elements.</li>

      <li>For any <span class="math">(C,M)\\in S</span>, <span class="math">F(C,M)</span> is accepted by <span class="math">\\mathsf{V}</span>.</li>

    </ol>

    <p class="text-gray-300">Denote <span class="math">E:=\\cup_{i\\in[2..n]}\\mathsf{secrets}_{i}</span>, and enumerate the elements of <span class="math">E</span> somehow as <span class="math">E_{1},\\ldots,E_{\\ell}</span>, where <span class="math">\\ell:=8\\cdot(n-1)</span>. Note that the elements of <span class="math">E</span> are determined (although not efficiently) by the protocol transcript and thus by <span class="math">(C,M)</span>. Note that in Round 2, <span class="math">B</span> has to present Schnorr nizk proofs for all elements of <span class="math">E</span>, each requiring a query to <span class="math">\\mathcal{R}</span> on the corresponding element <span class="math">R\\circ h</span>. By another averaging argument similar to the “forking lemma”, there exists a permutation <span class="math">\\sigma</span> on <span class="math">[\\ell]</span> and indices <span class="math">1\\leq i_{1}&lt;\\ldots&lt;i_{\\ell}\\leq Q</span> such that there is a subset of <span class="math">T\\subset S</span> of density (meaning probability mass) <span class="math">\\delta^{\\prime\\prime}:=\\delta^{\\prime}/Q^{\\ell}</span> (in the space of all values for <span class="math">(C,M)</span>) such that for each <span class="math">(C,M)\\in T</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">F(C,M)</span> is accepted by <span class="math">\\mathsf{V}</span>.</li>

      <li>When executing the protocol with <span class="math">(C,M)</span>, for each <span class="math">j\\in[\\ell]</span>, <span class="math">B</span> uses the value <span class="math">c_{i_{j}}</span> for the challenge <span class="math">c</span> in the nizk of <span class="math">E_{\\sigma(j)}</span>.</li>

    </ol>

    <p class="text-gray-300">We assume from now on that <span class="math">\\sigma</span> is the identity for simplicity of notation. Yet another averaging argument, using the non-negligibility of <span class="math">\\delta^{\\prime\\prime}</span>, allows us to construct a string <span class="math">C^{*}</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(C^{*},M)\\in T</span> with probability <span class="math">\\delta^{\\prime\\prime}</span> over <span class="math">M</span>.</li>

      <li>For any <span class="math">j\\in[\\ell]</span>, there are strings <span class="math">(C^{\\prime},M^{\\prime}),(C^{\\prime\\prime},M^{\\prime})\\in T</span>, i.e., that agree on the <span class="math">M^{\\prime}</span> part, such that <span class="math">C^{\\prime}</span> and <span class="math">C^{\\prime\\prime}</span> agree with <span class="math">C^{*}</span> on first <span class="math">i_{j}-1</span> indices, but disagree with each other on the <span class="math">i_{j}</span>’th coordinate.</li>

    </ol>

    <p class="text-gray-300">We now note an important point:</p>

    <p class="text-gray-300">Fix some <span class="math">j\\in[\\ell]</span>. Then any string <span class="math">(C^{\\prime},M^{\\prime})\\in T</span> in which <span class="math">C^{\\prime}</span> agrees with <span class="math">C^{<em>}</span> on indices <span class="math">1,\\ldots,i_{j}-1</span>, must lead to the same value of <span class="math">E_{j}</span>. This is because conditioned on being in <span class="math">T</span>, the query <span class="math">q_{i_{j}}</span> to <span class="math">\\mathcal{R}</span> will contain <span class="math">\\mathsf{rp}_{E_{j}}^{1}</span> which uniquely determines <span class="math">E_{j}</span>, and the value of <span class="math">q_{i_{j}}</span> is a deterministic function of <span class="math">c_{1},\\ldots,c_{i_{j}-1}</span>, when <span class="math">i_{j}\\leq Q/2</span>, and otherwise using item 4 <span class="math">E_{j}</span> is determined by <span class="math">c_{1},\\ldots,c_{Q/2}</span>. The second property above about the elements <span class="math">(C^{\\prime},M^{\\prime}),(C^{\\prime\\prime},M^{\\prime})\\in T</span> implies we have access to two valid Schnorr nizks for <span class="math">E_{j}</span> with the same <span class="math">R</span> but different challenges <span class="math">c</span>, which implies using the well-known Schnorr extractability property that <span class="math">A</span> can extract the value <span class="math">E_{j}</span> used by <span class="math">B</span> given any <span class="math">(C^{</em>},M)\\in T</span>.</p>

    <p class="text-gray-300">Now let <span class="math">T^{\\prime}</span> be the subset of <span class="math">T</span> consisting of elements beginning with <span class="math">C^{*}</span></p>

    <p class="text-gray-300">Now let <span class="math">\\mathsf{params}_{\\phi}=\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span> be the parameters given as a challenge to <span class="math">A</span> (for which he should construct an accepting proof). Let <span class="math">\\mathsf{secrets}_{1}:=\\mathsf{secrets}/(\\mathsf{secrets}_{2}\\cdots\\mathsf{secrets}_{n})</span> be the coordinate wise division of the corresponding secrets vectors. Recall <span class="math">E=\\mathsf{secrets}_{2}\\cup\\ldots\\cup\\mathsf{secrets}_{n}</span> is fixed</p>

    <p class="text-gray-300">conditioned on <span class="math">(C,M)\\in T^{\\prime}</span>, and <span class="math">A</span> has extracted the values <span class="math">E</span>. Inspection of the protocol shows that <span class="math">A</span> can efficiently play the role of <span class="math">P_{1}</span> when he chooses this value of <span class="math">\\mathsf{secrets}_{1}</span>, just from knowing <span class="math">E</span> and <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>, with one potential exception: Constructing valid nizks of the elements of <span class="math">\\mathsf{secrets}_{1}</span> which he does not know. However, he can do this also using his ability to program <span class="math">\\mathcal{R}</span>. He will choose random <span class="math">\\mathbb{F}_r</span> elements as the answers <span class="math">u</span> in the nizks and then compute <span class="math">R:=c\\cdot H-u\\cdot f</span>. and set <span class="math">\\mathcal{R}(R)=c</span>, unless <span class="math">\\mathcal{R}(R)</span> has been queried by <span class="math">B</span> in which case he aborts. He then conducts the protocol with <span class="math">B</span> using the values <span class="math">(C^{<em>},M)</span>, and outputs the proof <span class="math">\\pi</span> generated by <span class="math">B</span>. Note that when following this strategy <span class="math">\\mathsf{secrets}_{1}</span> and all the corresponding <span class="math">R</span>'s in the nizks are uniformly distributed. Thus the probability that <span class="math">(C^{</em>},M)\\in T^{\\prime}</span> when <span class="math">M</span> is derived from the <span class="math">R</span>'s and <span class="math">\\mathsf{secrets}_{1}</span> is at least <span class="math">\\delta^{\\prime\\prime}</span>. Thus the probability that <span class="math">F(C^{*},M)</span> will satisfy <span class="math">\\mathsf{V}</span> when using this strategy is at least <span class="math">\\delta^{\\prime\\prime}</span> which is non-negligible when <span class="math">\\delta</span> is non-negligible.</p>

    <h2 id="sec-41" class="text-2xl font-bold">4.3 Zero-Knowledge</h2>

    <p class="text-gray-300">Campanelli, Gennaro, Goldfeder and Nizzardo [CGGN17] have recently noted that a malicious choice of <span class="math">\\mathsf{params}_{\\phi}</span> can potentially break the zero-knowledge guarantee of the Pinocchio protocol. We prove that statistical zero-knowledge holds when using the parameters generated by our protocol, even in the case that all <span class="math">n</span> players are malicious and colluding, provided the prover verifies the protocol transcript before sending her proof.</p>

    <p class="text-gray-300">Denote by <span class="math">\\mathrm{P}</span> the (honest) prover of the Pinocchio protocol. We can think of <span class="math">\\mathrm{P}</span> as a randomized function <span class="math">\\mathrm{P}(\\phi, x, \\mathsf{params}_{\\phi}, \\omega)</span> generating a proof according to the instance, input, public parameters and witness. (See Appendix B of [BCTV14] for a full description of <span class="math">\\mathrm{P}</span>.) We slightly alter <span class="math">\\mathrm{P}</span> and think of it as an algorithm <span class="math">\\mathrm{P}(\\phi, x, \\mathsf{transcript}, \\omega)</span> that also receives a protocol transcript <span class="math">\\mathsf{transcript}</span>, and first applies the protocol verifier on <span class="math">\\mathsf{transcript}</span>. If the protocol verifier rejects, <span class="math">\\mathrm{P}</span> outputs <span class="math">\\mathsf{rej}</span> and nothing else. If the protocol verifier accepts, <span class="math">\\mathrm{P}</span> derives the parameters <span class="math">\\mathsf{params}_{\\phi}</span> from the transcript, and outputs <span class="math">\\mathrm{P}(\\phi, x, \\mathsf{params}_{\\phi}, \\omega)</span> for the original prover <span class="math">\\mathrm{P}</span>. We will assume further for simplicity that <span class="math">\\mathrm{P}</span> applies a deterministic protocol verifier. This mean she will not use the more efficient randomized checking of whether a vector is an <span class="math">s</span>-vector as described in Claim 2.3, but will check each <span class="math">s</span>-pair separately as described in Claim 2.2.</p>

    <p class="text-gray-300"><strong>Theorem 4.10.</strong> [Statistical Zero-Knowledge] For any polynomial <span class="math">P</span> and positive integer<span class="math">^8</span> <span class="math">n</span>, there is an efficient <span class="math">\\mathsf{sim}</span> such that the following holds. Fix any efficient <span class="math">B</span> controlling all <span class="math">n</span> players in the protocol, instance <span class="math">\\phi</span>, input <span class="math">x</span> and witness <span class="math">\\omega</span>. Let <span class="math">\\mathcal{D}</span> be the distribution obtained by outputting the protocol transcript <span class="math">\\mathsf{transcript}(B)</span> concatenated with the proof <span class="math">\\mathrm{P}(\\phi, x, \\mathsf{transcript}(B), \\omega)</span> (over the randomness of <span class="math">B</span> in the protocol, the randomness of the oracle <span class="math">\\mathcal{R}</span>, and that of <span class="math">\\mathrm{P}</span> in generating the proof). Then the distribution <span class="math">\\mathcal{D}_{\\mathrm{sim}}</span> of the output of <span class="math">\\mathsf{sim}^B</span> has distance at most <span class="math">1 / P(\\log r)</span> to <span class="math">\\mathcal{D}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Note that if we can simulate <span class="math">\\mathcal{D}</span> with error <span class="math">1 / P(\\log r)</span> conditioned on every fixing of the randomness of <span class="math">B</span>, we can simulate the fully randomized <span class="math">B</span> with the same error. So the simulator begins by choosing the randomness of <span class="math">B</span> uniformly, and we can assume we are working with a deterministic <span class="math">B</span>. Assume <span class="math">B</span> always makes exactly <span class="math">Q</span> queries to the random oracle <span class="math">\\mathcal{R}</span> emulating COMMIT (if this is just an upper bound we can think of <span class="math">B</span> not reading the last answers sometimes). As before, we denote by <span class="math">\\mathsf{M}</span> the range size of <span class="math">\\mathcal{R}</span> and assume <span class="math">r \\leq \\mathsf{M} \\leq \\mathrm{poly}(r)</span>. The transcript output</p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300"><span class="math">\\mathsf{transcript}(B)</span> is a deterministic function of a sequence <span class="math">\\mathsf{r}</span> of answers of <span class="math">\\mathcal{R}</span> to queries of <span class="math">B</span>. We denote this transcript <span class="math">\\mathsf{transcript}(\\mathsf{r})</span>. The corresponding set of queries <span class="math">\\{q_{1},\\ldots,q_{Q}\\}</span> of <span class="math">B</span> to <span class="math">\\mathcal{R}</span> is also a deterministic function of <span class="math">\\mathsf{r}</span>. More specifically, the first <span class="math">i+1</span> queries are a deterministic function of the first <span class="math">i</span> elements of <span class="math">\\mathsf{r}</span>. We denote by <span class="math">\\mathcal{D}_{\\mathsf{r}}</span> the distribution of <span class="math">\\mathrm{P}(\\phi,x,\\mathsf{transcript}(\\mathsf{r}),\\omega)</span>.</p>

    <p class="text-gray-300">We will show that for a <span class="math">(1-1/P(\\log r))</span>-fraction of the sequences <span class="math">\\mathsf{r}</span>, <span class="math">\\mathsf{sim}</span> can simulate <span class="math">\\mathcal{D}_{\\mathsf{r}}</span> with error <span class="math">\\mathsf{negl}(\\log r)</span> given <span class="math">\\mathsf{r}</span>. Clearly this suffices - as <span class="math">\\mathsf{sim}</span> can choose a random <span class="math">\\mathsf{r}</span>, output <span class="math">\\mathsf{transcript}(\\mathsf{r})</span> and then try to simulate <span class="math">\\mathcal{D}_{\\mathsf{r}}</span> using this method.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{sim}</span> begins by sampling a random sequence <span class="math">\\mathsf{r}</span> and characterizing it as either good, negligible or bad. This characterization will have the property that a bad sequence <span class="math">\\mathsf{r}</span> will have <span class="math">\\mathcal{D}_{\\mathsf{r}}</span> be <span class="math">\\mathsf{rej}</span> with probability <span class="math">1-\\mathsf{negl}(\\log r)</span>, and the negligible <span class="math">\\mathsf{r}</span> together will have probability <span class="math">\\mathsf{negl}(\\log r)</span>.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Characterizing <span class="math">\\mathsf{r}</span>:</h4>

    <p class="text-gray-300">If <span class="math">\\mathsf{r}</span> has repetitions it is labeled negligible - because since <span class="math">Q=\\mathrm{poly}\\log r</span>, such sequences are a <span class="math">\\mathsf{negl}(\\log r)</span> fraction. Otherwise <span class="math">\\mathsf{sim}</span> executes <span class="math">B(\\mathsf{r})</span>. If <span class="math">B</span> aborts before producing a full transcript, <span class="math">\\mathsf{r}</span> is labeled bad. In particular, <span class="math">\\mathsf{sim}</span> has checked if the values <span class="math">\\{\\mathsf{e}_{i}\\}_{i\\in[n]}</span> and nizk proofs <span class="math">\\{\\pi_{i,s}\\}_{i\\in[n],s\\in\\mathsf{secrets}_{i}}</span> are present in the Round 2 part of the transcript and otherwise labeled <span class="math">\\mathsf{r}</span> bad.</p>

    <p class="text-gray-300">It then checks if the queries <span class="math">\\{\\mathcal{R}(\\mathsf{e}_{i})\\}_{i\\in[n]},h:=\\mathcal{R}(\\mathcal{R}(\\mathsf{e}_{1})\\circ\\ldots\\circ\\mathcal{R}(\\mathsf{e}_{n})),\\big{\\{}\\mathcal{R}(R_{s}\\circ h\\circ\\mathsf{rp}_{s}^{1})\\big{\\}}_{i\\in[n],s\\in\\mathsf{secrets}_{i}}</span> were made (recall that <span class="math">B</span>’s sequence of queries is a deterministic function of <span class="math">\\mathsf{r}</span> that can be efficiently derived given blackbox access to <span class="math">B</span>); here <span class="math">R_{s}</span> is the first part of <span class="math">\\pi_{i,s}</span>. If not all queries were made, <span class="math">\\mathsf{r}</span> is labeled as bad - as the transcript is correct only if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the values <span class="math">\\{h_{i}\\}</span> in the transcript are equal to <span class="math">\\{\\mathcal{R}(\\mathsf{e}_{i})\\}</span>,</li>

      <li>the nizk proofs <span class="math">\\pi_{i,s}</span> are verified with challenges <span class="math">\\big{\\{}c_{i,s}(\\mathsf{r}):=\\mathcal{R}(R_{s}\\circ h\\circ\\mathsf{rp}_{s}^{1})\\big{\\}}</span>, which in turn determine a unique uniformly distributed correct second element of <span class="math">\\pi_{i,s}</span>,</li>

    </ul>

    <p class="text-gray-300">and this requires guessing in advance at least one output of <span class="math">\\mathcal{R}</span>, that can succeed only with probability <span class="math">1/\\mathsf{M}</span>.</p>

    <p class="text-gray-300">If all queries were made, <span class="math">\\mathsf{sim}</span> derives the sequence of indices <span class="math">I=I(\\mathsf{r})</span> of the queries <span class="math">\\mathcal{R}(\\mathsf{e}_{1}),\\ldots,\\mathcal{R}(\\mathsf{e}_{n})</span>, and a sequence of indices <span class="math">J=J(\\mathsf{r})</span> where the queries <span class="math">\\{c_{i,s}\\}</span> were made. Note that in this case the transcript validity is a deterministic function of <span class="math">\\mathsf{transcript}(\\mathsf{r})</span> and <span class="math">\\mathsf{r}</span>; as <span class="math">\\mathsf{r}</span> contains all queries to <span class="math">\\mathcal{R}</span> of the protocol verifier. <span class="math">\\mathsf{sim}</span> checks if the protocol verifier accepts and if not labels <span class="math">\\mathsf{r}</span> bad. <span class="math">\\mathsf{sim}</span> checks if the query to <span class="math">h</span> was made after all queries in <span class="math">I</span>, if not <span class="math">\\mathsf{r}</span> is labeled negligible as the transcript will only be valid if for some <span class="math">i\\in[n]</span>, denoting the query <span class="math">\\mathcal{R}(h_{1}\\circ\\ldots\\circ h_{n})</span>, <span class="math">h_{i}</span> corresponds to the later determined <span class="math">\\mathcal{R}(\\mathsf{e}_{i})</span>. <span class="math">\\mathsf{sim}</span> then checks if <span class="math">I&lt;J</span> in the sense that all elements of <span class="math">I</span> are smaller than all elements of <span class="math">J</span>. If this is not the case, <span class="math">\\mathsf{r}</span> is labeled negligible - as in this case the transcript is valid only if for some <span class="math">i\\in[n]</span> the value <span class="math">h</span> in the queries <span class="math">\\mathcal{R}(R_{s}\\circ h\\circ\\mathsf{rp}_{s}^{1})</span> equals the value <span class="math">\\mathcal{R}(\\mathcal{R}(\\mathsf{e}_{1}),\\circ\\ldots\\circ\\mathcal{R}(\\mathsf{e}_{n}))</span> determined later in the sequence <span class="math">\\mathsf{r}</span>. If <span class="math">\\mathsf{r}</span> has been labeled so far <span class="math">\\mathsf{sim}</span> outputs <span class="math">\\mathsf{rej}</span>. If <span class="math">\\mathsf{sim}</span> has not been labeled so far (as bad or neutral), it is labeled good. In this case we can define the vector <span class="math">\\mathsf{secrets}(\\mathsf{r})</span>, such that the parameters derived from <span class="math">\\mathsf{transcript}(\\mathsf{r})</span> are <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>, which is the vector of secrets uniquely determined by the product of secrets of each player which in turn are uniquely determined by the elements <span class="math">\\mathsf{e}_{1},\\ldots,\\mathsf{e}_{n}</span> in <span class="math">\\mathsf{transcript}(\\mathsf{r})</span>.</p>

    <p class="text-gray-300">The proof now follows from two claims. The first tells us that for a good <span class="math">\\mathsf{r}</span>, <span class="math">\\mathcal{D}_{\\mathsf{r}}</span> can be simulated given <span class="math">\\mathsf{secrets}(\\mathsf{r})</span>. The second tells us that for a <span class="math">(1-1/P(\\log r))</span>-fraction of good <span class="math">\\mathsf{r}</span>, we can obtain <span class="math">\\mathsf{secrets}(\\mathsf{r})</span> with probability <span class="math">1-1/r</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Claim 4.11.</h6>

    <p class="text-gray-300">For any polynomial <span class="math">P</span>, there is an algorithm <span class="math">\\mathsf{alg}</span> that for a <span class="math">(1-1/P(\\log r))</span>-fraction of good <span class="math">\\mathsf{r}</span>, obtains <span class="math">\\mathsf{secrets}(\\mathsf{r})</span> given <span class="math">\\mathsf{r}</span> with probability <span class="math">1-1/r</span> in time <span class="math">\\mathrm{poly}\\log r</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Denote <span class="math">S=\\cup_{i\\in[n]}\\mathsf{secrets}_{i}</span>, where <span class="math">\\mathsf{secrets}_{i}</span> is the vector of variables <span class="math">\\tau_{i},\\rho_{A,i},\\rho_{B,i},\\alpha_{A,i},\\alpha_{B,i},\\alpha_{C,i},\\gamma_{i},\\beta_{i}</span>. For good <span class="math">\\mathsf{r}</span>, and <span class="math">s\\in S</span> we denote by <span class="math">i_{s}(\\mathsf{r})</span> the index corresponding to <span class="math">s</span> in <span class="math">I(\\mathsf{r})</span> and by <span class="math">j_{s}(\\mathsf{r})</span> the index corresponding to <span class="math">s</span> in <span class="math">J(\\mathsf{r})</span>. Note that for good <span class="math">\\mathsf{r}</span> we always have <span class="math">i_{s}(\\mathsf{r})&lt;j_{s}(\\mathsf{r})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">j\\in[Q]</span>, and <span class="math">\\mathsf{r}\\in[\\mathsf{M}]^{Q}</span>, we denote by $W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{r}\\setminus j}<span class="math"> the strings </span>\\mathsf{r}^{\\prime}\\in[\\mathsf{M}]^{Q}<span class="math"> that are equal to </span>\\mathsf{r}<span class="math"> outside of </span>j<span class="math">. For </span>s\\in S<span class="math"> and good </span>\\mathsf{r}<span class="math">, we denote by </span>W_{\\mathsf{r},s}<span class="math"> the set of good </span>\\mathsf{r}^{\\prime}\\in[\\mathsf{M}]^{Q}<span class="math"> that are equal to </span>\\mathsf{r}<span class="math"> outside of </span>j_{s}(\\mathsf{r})<span class="math">, and have </span>i_{s}(\\mathsf{r}^{\\prime})=i_{s}(\\mathsf{r})<span class="math"> and </span>j_{s}(\\mathsf{r}^{\\prime})=j_{s}(\\mathsf{r})<span class="math">. Note that the set </span>W_{\\mathsf{r},s}<span class="math"> is determined by the two indices </span>i_{s}(\\mathsf{r}),j_{s}(\\mathsf{r})<span class="math"> and the values of </span>\\mathsf{r}<span class="math"> outside of </span>j_{s}(\\mathsf{r})<span class="math">; thus, there are at most </span>\\mathsf{M}^{Q-1}\\cdot Q^{2}<span class="math"> such distinct sets. Note also that </span>W_{\\mathsf{r},s}\\subseteq W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{r}\\setminus j_{s}(\\mathsf{r})}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now given good <span class="math">\\mathsf{r}</span>, <span class="math">\\mathsf{alg}</span> does the following. Denote <span class="math">P^{\\prime}:=2P\\cdot Q^{2}</span>. For each <span class="math">s\\in S</span>, letting <span class="math">j:=j_{s}(\\mathsf{r})</span>, <span class="math">\\mathsf{alg}</span> samples <span class="math">2P^{\\prime}(\\log r)\\cdot\\log r</span> strings <span class="math">\\mathsf{r}</span>’ from $W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{r}\\setminus j}<span class="math">. For each one he checks if </span>\\mathsf{r}^{\\prime}\\in W_{\\mathsf{r},s}<span class="math"> and if </span>\\mathsf{r}^{\\prime}_{j}\\neq\\mathsf{r}_{j}<span class="math">. If both checks hold, it means, that in </span>\\mathsf{transcript}(\\mathsf{r})<span class="math"> and </span>\\mathsf{transcript}(\\mathsf{r}^{\\prime})<span class="math"> he possesses two valid nizk proofs for </span>s<span class="math"> with the same first prover message </span>R_{s}<span class="math"> but different challenges. This means he can obtain </span>s(\\mathsf{r})$ using Schnorr’s extractability property.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now the question is what is the probability of not finding a sequence <span class="math">\\mathsf{r}</span>’ enabling extraction of <span class="math">s(\\mathsf{r})</span>. We claim this is at most <span class="math">1/r</span>, when the density of <span class="math">W_{\\mathsf{r},s}</span> in $W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{r}\\setminus j}<span class="math"> is at least </span>1/P^{\\prime}(\\log r)<span class="math">: In this case the density of elements of </span>W_{\\mathsf{r},s}<span class="math"> such that </span>\\mathsf{r}^{\\prime}_{j}\\neq\\mathsf{r}_{j}<span class="math"> is at least </span>1/P^{\\prime}(\\log r)-1/\\mathsf{M}\\geq 1/2P^{\\prime}(\\log r)<span class="math"> for large enough </span>r<span class="math">. Thus, the probability that no such element </span>\\mathsf{r}<span class="math">’ is found is at most </span>(1-1/2P^{\\prime}(\\log r))^{2P^{\\prime}(\\log r)\\cdot\\log r}\\leq 1/r$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the union bound, <span class="math">\\mathsf{alg}</span> extracts all secrets with probability <span class="math">1-8n/r</span> for <span class="math">\\mathsf{r}</span> such that the density of <span class="math">W_{\\mathsf{r},s}</span> in $W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{r}\\setminus j_{s}(\\mathsf{r})}<span class="math"> is at least </span>1/P^{\\prime}(\\log r)<span class="math"> for each </span>s\\in S<span class="math">. Now we must bound the density of good </span>\\mathsf{r}<span class="math"> that do not have this property. Each such </span>\\mathsf{r}<span class="math"> belongs to a set </span>W_{\\mathsf{r},s}<span class="math"> containing at most </span>\\mathsf{M}/P^{\\prime}(\\log r)$ elements. Thus, there at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\mathsf{M}\\cdot\\mathsf{M}^{Q-1}\\cdot Q^{2}}{P^{\\prime}(\\log r)}=\\frac{\\mathsf{M}^{Q}\\cdot Q^{2}}{2P(\\log r)\\cdot Q^{2}}=\\frac{\\mathsf{M}^{Q}}{2P(\\log r)}</span></p>

    <p class="text-gray-300">such elements, which is a <span class="math">1/2P(\\log r)</span> fraction of the space. ∎</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Claim 4.12.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\mathsf{r}</span> is good. Then given <span class="math">\\mathsf{secrets}(\\mathsf{r})</span>, <span class="math">\\mathcal{D}_{\\mathsf{r}}</span> can be efficiently simulated with no error</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is similar to that of Theorem 13 in <em>[x10]</em>. Note that when <span class="math">\\mathsf{r}</span> is good the elements <span class="math">A_{m+1}=B_{m+2}=C_{m+3}</span> in <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets}(\\mathsf{r}))</span> are non-zero, as this is required for the transcript to be accepted.</p>

    <p class="text-gray-300">We abuse notation and denote the discrete logs of the proof elements by themselves. As <span class="math">A_{m+1},B_{m+2},C_{m+3}</span> are non-zero, <span class="math">\\pi_{A},\\pi_{B},\\pi_{C}</span> are uniformly distributed in <span class="math">\\mathbb{F}_{r}</span> since <span class="math">c_{m+1},c_{m+2},c_{m+3}</span> are chosen uniformly by P. Now, in a valid proof the other proof elements <span class="math">\\pi^{\\prime}_{A},\\pi^{\\prime}_{B},\\pi^{\\prime}_{C},\\pi_{K},\\pi_{H}</span> are deterministic functions of <span class="math">\\pi_{A},\\pi_{B},\\pi_{C}</span>, derived from the verification constraints (see Appendix B). Moreover, given <span class="math">\\mathsf{secrets}</span> and the discrete logs of <span class="math">\\pi_{A},\\pi_{B},\\pi_{C}</span>, they can be efficiently derived: Defining <span class="math">A_{io}</span> as in the proof of Theorem 4.6, we have</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi^{\\prime}_{A}=\\alpha_{A}\\cdot\\pi_{A}</span></li>

      <li><span class="math">\\pi^{\\prime}_{B}=\\alpha_{B}\\cdot\\pi_{B}</span></li>

      <li><span class="math">\\pi^{\\prime}_{C}=\\alpha_{C}\\cdot\\pi_{C}</span></li>

      <li><span class="math">\\pi_{H}=((A_{io}(s)+\\pi_{A})\\cdot\\pi_{B}-\\pi_{C})/Z(s)</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{K}=\\beta\\cdot((A_{io}(s)+\\pi_{A})+\\pi_{B}+\\pi_{C})</span></li>

    </ol>

    <p class="text-gray-300">Thus, given the value of <span class="math">\\mathsf{secrets(r)}</span>, <span class="math">\\mathsf{sim}</span> can efficiently simulate the distribution <span class="math">\\mathcal{D}_{\\mathsf{r}}</span>. ∎</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-47" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Eli Ben-Sasson, Alessandro Chiesa, Jens Groth, Daira Hopwood, Hovav Shacham, Eran Tromer, Madars Virza, Nathan Wilcox and Zooko Wilcox for helpful discussions. We thank Daira Hopwood for pointing out some technical inaccuracies. We thank Eran Tromer for bringing to our attention the work of <em>[x1]</em>, and the relevance of our protocol to that work, and the connection to subversion zero-knowledge in general.</p>

    <h2 id="sec-48" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABLZ17] B. Abdolmaleki, K. Baghery, H. Lipmaa, and M. Zajc. A subversion-resistant snark. 2017.</li>

      <li>[BCG^{+}15] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015, pages 287–304, 2015.</li>

      <li>[BCPR14] N. Bitansky, R. Canetti, O. Paneth, and A. Rosen. On the existence of extractable one-way functions. In Symposium on Theory of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014, pages 505–514, 2014.</li>

      <li>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, San Diego, CA, USA, August 20-22, 2014., pages 781–796, 2014.</li>

      <li>[BFS16] M. Bellare, G. Fuchsbauer, and A. Scafuro. Nizks with an untrusted CRS: security in the face of parameter subversion. IACR Cryptology ePrint Archive, 2016:372, 2016.</li>

      <li>[CFH^{+}15] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile verifiable computation. In 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015, pages 253–270, 2015.</li>

      <li>[CGGN17] M. Campanelli, R. Gennaro, S. Goldfeder, and L. Nizzardo. Zero-knowledge contingent payments revisited: Attacks and payments for services. Commun. ACM, 2017.</li>

      <li>[Fuc17] G. Fuchsbauer. Subversion zero-knowledge snarks. 2017.</li>

      <li>[GGPR13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct nizks without pcps. In Advances in Cryptology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013. Proceedings, pages 626–645, 2013.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[lib] https://github.com/scipr-lab/libsnark,https://github.com/zcash/libsnark.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[PHGR16] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: nearly practical verifiable computation. Commun. ACM, 59(2):103–112, 2016.</li>

      <li>[Sch89] C. Schnorr. Efficient identification and signatures for smart cards. In Advances in Cryptology - CRYPTO ’89, 9th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 1989, Proceedings, pages 239–252, 1989.</li>

      <li>[Wil] Z. Wilcox. https://z.cash/blog/the-design-of-the-ceremony.html.</li>

    </ul>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix A Actual, more complicated version of <span class="math">\\mathtt{e}_{i}</span> in code</h2>

    <p class="text-gray-300">For each <span class="math">i\\in[n]</span>, <span class="math">P_{i}</span> first constructs <span class="math">\\mathtt{elements}_{i}</span> as in Subsection 3.1. That is</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As described in Generate a set of uniform elements in <span class="math">\\mathbb{F}^{*}_{r}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathtt{secrets}_{i}:=\\left\\{\\tau_{i},\\rho_{A,i},\\rho_{B,i},\\alpha_{A,i},\\alpha_{B,i},\\alpha_{C,i},\\beta_{i},\\gamma_{i}\\right\\}</span></p>

    <p class="text-gray-300">, and let</p>

    <p class="text-gray-300"><span class="math">\\mathtt{elements}_{i}:=\\left\\{\\tau_{i},\\rho_{A,i},\\rho_{B,i},\\alpha_{A,i},\\alpha_{B,i},\\alpha_{C,i},\\beta_{i},\\gamma_{i},\\rho_{A,i}\\alpha_{A,i},\\rho_{B,i}\\alpha_{B,i},\\right.</span> <span class="math">\\left.\\rho_{A,i}\\rho_{B,i},\\rho_{A,i}\\rho_{B,i}\\alpha_{C,i},\\beta_{i}\\gamma_{i}\\right\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now each player generates a somewhat complex set of group elements from its set of secrets. We omit the index <span class="math">i</span> for clarity of notation, but it should be appended to all elements below:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{i}</span> chooses random elements <span class="math">f_{1},f_{2},f_{3}\\in\\mathbb{G}_{2}\\setminus\\{0\\}</span> and random elements <span class="math">f_{4},f_{5},f_{6},f_{7},f_{8}\\in\\mathbb{G}_{1}\\setminus\\{0\\}</span>.</li>

      <li><span class="math">P_{i}</span> stores the sets of <span class="math">\\mathbb{G}_{2}</span> elements</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathtt{e}_{i}^{2}:=\\{f_{1},f_{1}\\cdot\\rho_{A},f_{1}\\cdot\\rho_{A}\\alpha_{A},f_{1}\\cdot\\rho_{A}\\rho_{B}\\alpha_{C},f_{1}\\cdot\\rho_{A}\\rho_{B},f_{1}\\cdot\\rho_{A}\\rho_{B}\\alpha_{B},</span> <span class="math">f_{2},f_{2}\\cdot\\beta,f_{2}\\cdot\\beta\\gamma,f_{3},f_{3}\\cdot\\tau\\},</span></p>

    <p class="text-gray-300">and the set of <span class="math">\\mathbb{G}_{1}</span> elements</p>

    <p class="text-gray-300"><span class="math">\\mathtt{e}_{i}^{1}:=\\left\\{f_{4},f_{4}\\cdot\\alpha_{A},f_{5},f_{5}\\cdot\\alpha_{C},f_{6},f_{6}\\cdot\\rho_{B},f_{7},f_{7}\\cdot\\rho_{A},f_{8},f_{8}\\cdot\\gamma\\right\\}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, define <span class="math">\\mathtt{e}_{i}:=\\mathtt{e}_{i}^{1}\\circ\\mathtt{e}_{i}^{2}</span>.</li>

    </ol>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Validity of more complicated definition</h4>

    <p class="text-gray-300">The only requirement for <span class="math">\\mathtt{e}_{i}</span> to run the protocol is that we always have the needed <span class="math">s</span>-pair for each <span class="math">s\\in\\mathtt{elements}_{i}</span>. Inspection shows this is the case with the definition here. For example, <span class="math">P_{i}</span> has broadcasted (omitting index <span class="math">i</span>) <span class="math">f_{1},f_{1}\\rho_{A}</span> and <span class="math">f_{1}\\rho_{A}\\rho_{B}</span> as part of <span class="math">\\mathtt{e}_{i}^{2}</span>, out of which we can construct the <span class="math">\\rho_{A}</span>-pair (<span class="math">f_{1},f_{1}\\rho_{A}</span>), the <span class="math">\\rho_{B}</span>-pair (<span class="math">f_{1}\\rho_{A},f_{1}\\rho_{A}\\rho_{B}</span>), and the <span class="math">\\rho_{A}\\rho_{B}</span>-pair (<span class="math">f_{1},f_{1}\\rho_{A}\\rho_{B}</span>). Since here we don’t have a <span class="math">\\mathbb{G}_{1}</span>-<span class="math">s</span>-pair and <span class="math">\\mathbb{G}_{2}</span>-<span class="math">s</span>-pair for each <span class="math">s\\in\\mathtt{elements}_{i}</span>, less consistency checks are performed in Part 2 of Round 2. (Note that to run the protocol we don’t need an <span class="math">s</span>-pair for each <span class="math">s\\in\\mathtt{elements}_{i}</span> in each group. For example, we only need a <span class="math">\\mathbb{G}_{2}</span>-<span class="math">\\rho_{A}</span>-pair which is used in Round 3 to compute <span class="math">PK_{A}</span>, but we never use a <span class="math">\\mathbb{G}_{1}</span>-<span class="math">\\rho_{A}</span>-pair).</p>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">B Implementation details</p>

    <p class="text-gray-300">In our implementation we use the libsnark alt_bn128 curve implementation where</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{G}_1 = E / \\mathbb{F}_q</span> is a BN curve over <span class="math">\\mathbb{F}_q</span>. That is the set of solutions in <span class="math">\\mathbb{F}_q^2</span> of an equation of the form <span class="math">y^{2} = x^{3} + b</span>.</li>

      <li><span class="math">\\mathbb{G}_2 = E&#x27; / \\mathbb{F}_{q^2}</span> is a subgroup of order <span class="math">r</span> of a sextic twist of <span class="math">\\mathbb{G}_1</span>. Where a sextic twist of <span class="math">\\mathbb{G}_1</span> means the set of solutions in <span class="math">\\mathbb{F}_{q^2}</span> of <span class="math">y^{2} = x^{3} + b / \\xi</span>, where <span class="math">\\xi \\in \\mathbb{F}_{q^2} \\setminus \\mathbb{F}_q</span> is an element such that the polynomial <span class="math">W^6 - \\xi</span> is irreducible over <span class="math">\\mathbb{F}_{q^2}</span>.</li>

      <li><span class="math">\\mathbb{G}_t</span> is a subgroup of order <span class="math">r</span> in <span class="math">\\mathbb{F}_{q^{12}}</span>.</li>

    </ol>

    <p class="text-gray-300">C Pinocchio reminder</p>

    <p class="text-gray-300">We give a brief reminder of how the proof and verification procedure of [PHGR16] look like using the notation of <span class="math">\\left[\\mathrm{BCG}^{+}15\\right]</span>. The prover has in his hand a QAP solution <span class="math">(c_{0} = 1, c_{1}, \\ldots, c_{m})</span> that coincides with the public input <span class="math">x = (c_{1}, \\ldots, c_{n})</span> and satisfies the following. If we define <span class="math">A := \\sum_{i=0}^{m} c_{i} \\cdot A_{i}</span>, <span class="math">B := \\sum_{i=0}^{m} c_{i} \\cdot B_{i}</span>, and <span class="math">C := \\sum_{i=0}^{m} c_{i} \\cdot C_{i}</span>; then the polynomial <span class="math">P := A \\cdot B - C</span> will be divisible by the target polynomial <span class="math">Z</span>. Given <span class="math">\\mathsf{params}_{\\phi}(\\mathsf{secrets})</span>, <span class="math">\\mathsf{V}</span> will compute</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_A := \\rho_A A(s) \\cdot g_1</span>, <span class="math">\\pi_A&#x27; := \\alpha_A \\rho_A A(s) \\cdot g_2</span>.</li>

      <li><span class="math">\\pi_B := \\rho_B B(s) \\cdot g_2</span>, <span class="math">\\pi_B&#x27; := \\alpha_B \\rho_B B(s) \\cdot g_1</span>.</li>

      <li><span class="math">\\pi_C := \\rho_A \\rho_B C(s) \\cdot g_1</span>, <span class="math">\\pi_C&#x27; := \\alpha_C \\rho_A \\rho_B C(s) \\cdot g_2</span>.</li>

      <li><span class="math">\\pi_K := \\beta (\\rho_A A(s) + \\rho_B B(s) + \\rho_A \\rho_B C(s)) \\cdot g_1</span>.</li>

      <li><span class="math">\\pi_H := (P(s) / Z(s)) \\cdot g_1</span>.</li>

    </ol>

    <p class="text-gray-300">Now, abuse notation and denote the discrete log of each element above in base <span class="math">g_{1}</span> or <span class="math">g_{2}</span> by the element itself. The verifier, using pairings and the verification key <span class="math">V</span>, will check the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_A&#x27; = \\alpha_A \\pi_A</span>.</li>

      <li><span class="math">\\pi_B&#x27; = \\alpha_B \\pi_B</span>.</li>

      <li><span class="math">\\pi_C&#x27; = \\alpha_C \\pi_C</span>.</li>

      <li><span class="math">\\pi_K = \\beta (\\pi_A + \\pi_B + \\pi_C)</span>.</li>

      <li><span class="math">\\pi_A \\cdot \\pi_B - \\pi_C = \\pi_H \\cdot Z(s) \\rho_A \\rho_B</span>.</li>

    </ol>

    <p class="text-gray-300">25</p>`;
---

<BaseLayout title="A multi-party protocol for constructing the public parameter... (2017/602)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/602
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
