---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1071';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fiat-Shamir Security of FRI and Related SNARKs';
const AUTHORS_HTML = 'Alexander R. Block, Albert Garreta, Jonathan Katz, Justin Thaler, Pratyush Ranjan Tiwari, Michał Zając';

const CONTENT = `    <p class="text-gray-300">Alexander R. Block^{1,2}, Albert Garreta^{3,6}, Jonathan Katz^{2}, Justin Thaler^{1,5}, Pratyush Ranjan Tiwari^{4}, and Michał Zając^{3}</p>

    <p class="text-gray-300">^{1}Georgetown University, justin.thaler@georgetown.edu ^{2}University of Maryland, {alexander.r.block,jkatz2}@gmail.com ^{3}Nethermind, {albert,michal}@nethermind.io ^{4}Johns Hopkins University, pratyush@cs.jhu.edu ^{5}a16z crypto research ^{6}Basque Center of Applied Mathematics (BCAM)</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We establish new results on the Fiat-Shamir (FS) security of several protocols that are widely used in practice, and we provide general tools for establishing similar results for others. More precisely, we: (1) prove the FS security of the FRI and batched FRI protocols; (2) analyze a general class of protocols, which we call <span class="math">\\delta</span>-correlated, that use low-degree proximity testing as a subroutine (this includes many “Plonk-like” protocols (e.g., Plonky2 and Redshift), ethSTARK, RISC Zero, etc.); and (3) prove FS security of the aforementioned “Plonk-like” protocols, and sketch how to prove the same for the others.</p>

    <p class="text-gray-300">We obtain our first result by analyzing the round-by-round (RBR) soundness and RBR knowledge soundness of FRI. For the second result, we prove that if a <span class="math">\\delta</span>-correlated protocol is RBR (knowledge) sound under the assumption that adversaries always send low-degree polynomials, then it is RBR (knowledge) sound in general. Equipped with this tool, we prove our third result by formally showing that “Plonk-like” protocols are RBR (knowledge) sound under the assumption that adversaries always send low-degree polynomials. We then outline analogous arguments for the remainder of the aforementioned protocols.</p>

    <p class="text-gray-300">To the best of our knowledge, ours is the first formal analysis of the Fiat-Shamir security of FRI and widely deployed protocols that invoke it.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Succinct Non-interactive ARguments of Knowledge (SNARKs) and their zero-knowledge variants (zkSNARKs) are a thriving field of study both in theory and practice. Allowing for fast verification of complex statements made by untrusted parties, zkSNARKs have now been deployed in a myriad of applications. A popular paradigm for constructing (zk)SNARKs is via the following two-step process: (1) construct a public-coin interactive protocol and (2) remove all interaction using the Fiat-Shamir (FS) transformation <em>[x10]</em>, adding zero-knowledge as necessary.</p>

    <p class="text-gray-300">Non-interactivity is essential in many applications of zkSNARKs. In general, interactive protocols are not publicly verifiable and hence cannot be used in settings where anyone in the world should be able to verify the proof. There are various proposals (e.g., <em>[x2]</em> ) to render interactive protocols publicly verifiable using so-called randomness beacons <em>[x21]</em> (i.e., publicly verifiable sources of random bits, such as contents blockchain block headers) and the transaction-ordering functionality offered by public blockchains (which enable the public to verify that the prover sent a</p>

    <p class="text-gray-300">message before it knew what the verifier’s response to that message would be). However, to the best of our knowledge, such proposals have not been deployed at scale. They are also fraught with performance and security considerations; for example, blockchain headers are at least somewhat biasable <em>[x21, x3]</em>, and splitting an interactive proof across many blockchain blocks can substantially increase latency and fees.</p>

    <p class="text-gray-300">Regardless, the Fiat-Shamir transformation is pervasive and has been used extensively in a variety of schemes beyond zkSNARKs; e.g., signature schemes and non-interactive zero-knowledge <em>[x13, x22, x24]</em>, inspiring a rich line of research into understanding both its applicability and pitfalls. The FS transformation is typically modeled and analyzed in the random oracle model (ROM) for security proofs. When using FS in practice, one then assumes that a suitable concrete hash function (e.g., SHA256) is an adequate replacement for said random oracle.</p>

    <p class="text-gray-300">However, there are surprisingly many open problems regarding specific applications of the FS transformation. In particular, the FS transformation is <em>not</em> secure in general <em>[x4, x11, BDG+13]</em>, even in the random oracle model, when applied to many-round protocols. Specifically, its use can lead to a loss in the number of “bits of security” that is linear in the number of rounds <span class="math">r</span> of the protocol to which it is applied. Here, the number of bits of security roughly refers to the logarithm of the amount of work an attacker has to do to succeed with probability close to <span class="math">1</span>.</p>

    <p class="text-gray-300">Accordingly, the FS transformation is often applied to many-round protocols without formal security proofs for the resulting SNARKs’ security. That is, the security analysis of these protocols is often provided only for their interactive versions. Without further analysis, the security (measured in bits) lost via the FS transformation may be a factor equal to the number of rounds of the protocol. Even a 30% loss in security would be devastating in practical deployments (e.g., reducing the number of bits of security from 100 down to 70), and (more than) such a loss can occur even when Fiat-Shamir is applied to protocols with just two rounds. There are also some works that claim FS-security of their protocols, but in fact show this only under the assumption that certain many-round sub-protocols used in the overall protocol are FS-secure <em>[x10, x12, x20]</em>.</p>

    <p class="text-gray-300">In this work, we fill this gap in these security analyses and provide general tools for doing so for certain varieties of protocols. Specifically, we show that for the protocols we are interested in, the security of the FS-transformed protocol resembles the security of the interactive one (pre-FS) (or more precisely, <em>what is currently known</em> about the interactive security). This adds to a recent fruitful line of work has introduced many tools to understand FS security of many-round protocols. These include the notions of state-restoration soundness <em>[x5]</em>, round-by-round soundness <em>[CCH+19]</em>, and (generalized) special soundness <em>[x12, x26, x1]</em>. Nonetheless, in the literature on SNARKs, relatively few protocols are known to be FS-secure, despite the above tools existing. These include the GKR protocol <em>[x11, CCH+19]</em> (or more generally, anything based on the sum-check protocol <em>[x21]</em>), the GMW protocol and other natural classes of “commit-and-open” protocols <em>[x14]</em>, and any protocol satisfying the notion of (generalized) special soundness <em>[x1]</em>, which includes IPA/Bulletproofs <em>[BCC+16, BBB+18]</em>. Bulletproofs <em>[BCC+16, BBB+18]</em> and Sonic <em>[x20]</em> have separately been shown to be FS-secure in the algebraic group model <em>[x15]</em>.</p>

    <p class="text-gray-300">In this introduction, we informally refer to protocols that experience little-to-no loss in the number of bits of security when the FS transformation is applied in the random oracle model as <em>FS-secure</em>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">We formally analyze and prove FS-security of the FRI protocol <em>[x3]</em> and of some protocols that have wide use in practice which use low-degree proximity testing as a subroutine. For the latter, we build a general tool that allows us to prove FS-security of a certain type of protocol, which we call a <span class="math">\\delta</span>-correlated IOP, by analyzing its round-by-round soundness assuming an adversary sends low-degree polynomials. We formally apply this tool to “Plonk-like” protocols such as Plonky2 <em>[x22]</em>, and we outline how the tool can be used on other constructions such as ethSTARK <em>[x27]</em>. In particular, we either formally prove or we outline a proof that the security of all these protocols, after applying the Fiat-Shamir transformation, (nearly) matches what is known about its security when run interactively.</p>

    <p class="text-gray-300">As mentioned, we focus on these protocols due to their current popularity. For example, FRI is currently used in various Layer-2 Ethereum projects <em>[x28]</em> to help secure hundreds of millions of dollars of assets <em>[x19]</em>. Some projects are deploying FRI with (at most) 80-bits (dYdX) or 96-bits (those using the SHARP prover) of <em>interactive security</em> before the FS transformation is applied <em>[BCI+20, x27, x28]</em>. More precisely, the <em>best known attacks</em> on these interactive protocols have success probability <span class="math">2^{-80}</span> or <span class="math">2^{-96}</span>. These attacks are conjectured to be optimal <em>[x27]</em>, though only partial results in this direction are known <em>[BCI+20]</em>. Similarly, Plonk-like protocols are utilized in a variety of</p>

    <p class="text-gray-300">blockchain networks and Layer 2 Ethereum projects (e.g., <em>[x11, x12, x13, x14]</em>),</p>

    <p class="text-gray-300">When it comes to the FRI protocol, we <em>do not</em> address the gaps between the conjectured and known soundness of the interactive protocol. We merely analyze the security of the FS-compiled protocol as a function of the security of the interactive protocol.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Technical Details</h3>

    <p class="text-gray-300">In a nutshell, we formally establish the <em>round-by-round (knowledge) soundness</em> <em>[CCH^{+}19]</em> of both FRI and several protocols that rely on a form of low-degree proximity testing. For analyzing round-by-round (RBR) soundness, there is a protocol <em>state</em> function that can either be “doomed” or not. The state of the protocol starts off as doomed whenever a prover falsely claims that an input is valid. If at the end of interaction the state is doomed, the verifier rejects. The protocol is said to be RBR sound if, whenever the state is doomed, the protocol is still doomed in the next round of interaction, except with negligible probability, no matter what a prover does. RBR knowledge soundness is a similar notion, except that in this case, the protocol always starts off in a doomed state, and after each round, except with negligible probability, it remains doomed unless the prover knows a valid witness; see Section 2.1 for more discussion.</p>

    <p class="text-gray-300">By establishing the round-by-round (knowledge) soundness of these protocols, we can then leverage the so-called BCS transformation <em>[x3]</em>, which (informally) compiles any interactive protocol into a (zk)SNARK via (a variant of) the Fiat-Shamir transformation in the random oracle model. Applying the BCS transformation on a round-by-round (knowledge) sound protocol preserves (knowledge) soundness (yielding a SNARK) <em>[x7, x8]</em>. In fact, round-by-round soundness of the interactive protocol was even shown to imply that the BCS-transformed SNARK is secure against quantum adversaries <em>[x8]</em>. Thus, we establish the Fiat-Shamir security of both FRI and the rest of protocols via proving their round-by-round (knowledge) soundness.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.2.1 Round-by-round Soundness of FRI</h4>

    <p class="text-gray-300">The FRI protocol <em>[x1]</em>, which stands for Fast Reed-Solomon Interactive Oracle Proof of Proximity is a logarithmic round <em>interactive oracle proof</em>. Briefly, an interactive oracle proof (IOP) <em>[x3]</em> is an interactive protocol where the verifier is given oracle (i.e., query) access to the (long) prover messages, and an IOP of Proximity (IOPP) is an IOP for proving proximity of a function to some pre-specified linear error-correcting code <em>[x1]</em>. The FRI protocol proves that a function is close to the space of Reed-Solomon codewords <em>[x15]</em> of a certain degree over some pre-specified domain over a finite field. This protocol is both of theoretical and practical interest. On the theory side, FRI gives a polylogarithmic-size proof for proving the proximity of messages to some pre-specified Reed-Solomon code, which is an important primitive in many proof systems <em>[x1]</em>. On the practical side, FRI is used as a sub-protocol in the design and construction of many SNARKs and has the benefit of being plausibly post-quantum secure due to its avoidance of elliptic curve cryptography (and in fact, it follows from our results that FRI, when run non-interactively via Fiat-Shamir, is unconditionally secure in the quantum random oracle model).</p>

    <p class="text-gray-300">Despite intense interest from both theorists and practitioners, we are unaware of any formal security proof for FRI under Fiat-Shamir.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1.1 (Informally Stated; see Theorem 4.1).</h6>

    <p class="text-gray-300">For finite field <span class="math">\\mathbb{F}</span>, evaluation domain <span class="math">L\\subset\\mathbb{F}</span> of size <span class="math">2^{n}</span>, constants <span class="math">\\rho\\in(0,1)</span>, <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span>, and positive integer <span class="math">\\ell</span>, the FRI protocol has round-by-round (knowledge) soundness error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\text{rbr}}^{\\text{FRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell)=\\max\\{O(2^{2n}/(\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)),(1-\\delta)^{\\ell}\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Establishing the round-by-round (knowledge) soundness of FRI is a crucial first step to establishing the Fiat-Shamir security of FRI. In particular, given the round-by-round soundness of FRI, we can now apply the BCS transformation <em>[x3]</em> to obtain a secure non-interactive argument in the random oracle model using FRI.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Corollary 1.2 (Informally Stated; see Corollary 4.3).</h6>

    <p class="text-gray-300">For finite field <span class="math">\\mathbb{F}</span>, evaluation domain <span class="math">L\\subset\\mathbb{F}</span> of size <span class="math">2^{n}</span>, constants <span class="math">\\rho\\in(0,1)</span>, <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span>, and positive integer <span class="math">\\ell</span>, given a random oracle with <span class="math">\\kappa</span>-bits of output and query bound <span class="math">Q\\geq 1</span>,</p>

    <p class="text-gray-300">compiling FRI with the BCS transformation yields a non-interactive argument in the random oracle model with adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\text{fs}}^{\\text{FRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,Q,\\kappa)=Q\\varepsilon_{\\text{rbr}}^{\\text{FRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell)+O(Q^{2}/2^{\\kappa}).</span></p>

    <p class="text-gray-300">Moreover, the transformed non-interactive argument has adaptive soundness error and knowledge error <span class="math">\\Theta(Q\\cdot\\varepsilon_{\\text{fs}}^{\\text{FRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,Q))</span> against <span class="math">O(Q)</span>-query quantum adversaries.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Extension to Batched FRI.</h4>

    <p class="text-gray-300">In practice, it is common to run a Batched FRI protocol, which allows a prover to simultaneously prove the <span class="math">\\delta</span>-correlated agreement of <span class="math">t</span> functions <span class="math">f_{1},\\ldots,f_{t}</span> by running the FRI protocol on the batched function <span class="math">G=\\sum_{i}\\alpha_{i}f_{i}</span> for randomly sampled <span class="math">\\alpha_{i}</span> provided by the verifier. We extend our analysis of FRI to this version of Batched FRI and establish its round-by-round (knowledge) soundness.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.3 (Informally Stated, see Theorem 4.2).</h6>

    <p class="text-gray-300">For finite field <span class="math">\\mathbb{F}</span>, evaluation domain <span class="math">L\\subset\\mathbb{F}</span> of size <span class="math">2^{n}</span>, constants <span class="math">\\rho\\in(0,1)</span>, <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span>, and positive integers <span class="math">\\ell,t</span>, the Batched FRI protocol has round-by-round (knowledge) soundness error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,t)=\\max\\{O((2^{2n})/(\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)),(1-\\delta)^{\\ell}\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As before, establishing round-by-round soundness allows us to securely apply the BCS transformation, obtaining a non-interactive argument in the random oracle model.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Corollary 1.4 (Informally Stated; see Corollary 4.4).</h6>

    <p class="text-gray-300">For finite field <span class="math">\\mathbb{F}</span>, evaluation domain <span class="math">L\\subset\\mathbb{F}</span> of size <span class="math">2^{n}</span>, constants <span class="math">\\rho\\in(0,1)</span>, <span class="math">\\delta\\in(0,1-\\sqrt{\\rho})</span>, and positive integers <span class="math">\\ell,t</span>, given a random oracle with <span class="math">\\kappa</span>-bits of output and query bound <span class="math">Q\\geq 1</span>, compiling Batched FRI with the BCS transformation yields a non-interactive argument in the random oracle model with adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\text{fs}}^{\\text{bFRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,t,Q,\\kappa)=Q\\cdot\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,t)+O(Q^{2}/2^{\\kappa}).</span></p>

    <p class="text-gray-300">Moreover, the transformed non-interactive argument has adaptive soundness error and knowledge error <span class="math">\\Theta(Q\\cdot\\varepsilon_{\\text{fs}}^{\\text{bFRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,t,Q,\\kappa))</span> against <span class="math">O(Q)</span>-query quantum adversaries.</p>

    <p class="text-gray-300">To the best of our knowledge, our results are the first to establish the security of non-interactive analogs of FRI and Batched FRI in the random oracle model.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">A Variant of Batched FRI.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To save on communication costs, a variant of Batched FRI is sometimes used, where the batched function <span class="math">G</span> has the form <span class="math">G=\\sum_{i}\\alpha^{i-1}f_{i}</span>, where <span class="math">\\alpha</span> is a randomly sampled challenge sent by the verifier. In both the context of regular soundness and round-by-round soundness, this version of Batched FRI incurs some soundness loss proportional to <span class="math">t</span>. In particular, in Theorem 1.3, the round-by-round soundness error for this Batched FRI protocol is $\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}(\\mathbb{F},\\rho,\\delta,n,\\ell,t)=\\max\\{O((2^{2n}\\cdot t)/(\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)),(1-\\delta)^{\\ell}\\}$; see Section 5.2 for details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Round-by-round Soundness Error versus Standard Soundness Error of FRI.</h4>

    <p class="text-gray-300">Ben-Sasson et al. <em>[BCI^{+}20]</em> give the best known provable soundness bounds for (Batched) FRI; in fact, we leverage many tools from their results to show our round-by-round soundness bounds. Roughly speaking, <em>[BCI^{+}20]</em> show that the soundness error of (Batched) FRI is <span class="math">\\varepsilon_{1}+\\varepsilon_{2}+\\varepsilon_{3}</span>, where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{1}=O(2^{2n}/(\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> </span>\\varepsilon_{2}=O((2^{n}\\cdot n\\sqrt{\\rho})/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> </span>\\varepsilon_{3}=(1-\\delta)^{\\ell}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then our RBR soundness bound for (Batched) FRI is given by <span class="math">\\max\\{\\varepsilon_{1},\\varepsilon_{3}\\}</span>.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Round-by-round Knowledge Error.</h4>

    <p class="text-gray-300">Both FRI and Batched FRI additionally have round-by-round knowledge error <em>[x10, x11, x14]</em> identical to the round-by-round soundness errors given in Theorems 1.1 and 1.3. The BCS transformation preserves this type of knowledge soundness, yielding a SNARK. See Section 2.1 for more discussion.</p>

    <p class="text-gray-300">We go on to analyze proof systems that rely on the FRI protocol as a subroutine. To this end, we introduce a family of IOPs which we call  <span class="math">\\delta</span> -correlated IOPs, where  <span class="math">\\delta \\geq 0</span>  is a parameter. This family encompasses all of the aforementioned protocols. In a nutshell, we say an IOP is  <span class="math">\\delta</span> -correlated if the prover is supposed to send oracles to maps that are  <span class="math">\\delta</span> -close to low-degree polynomials in a correlated manner. Correlation here means that the domain where these maps agree with low-degree polynomials is the same among all the maps. In a  <span class="math">\\delta</span> -correlated IOP, during the verification phase, the verifier: (1) checks some algebraic equalities involving some evaluations of these maps; and (2) verifies that all the received oracles correspond indeed to  <span class="math">\\delta</span> -correlated maps (we assume the verifier has another oracle to perform this check). When  <span class="math">\\delta = 0</span> , a  <span class="math">\\delta</span> -correlated IOPs can be seen as a subclass of RS-encoded IOPs [BCR+19, COS20]. We refer to Appendix B for further comparison.</p>

    <p class="text-gray-300">This points to a "recipe" for building a particular family of SNARKs: first, construct a  <span class="math">\\delta</span> -correlated IOP; then, instantiate the check for  <span class="math">\\delta</span> -correlation using an interactive protocol, e.g., batched FRI [BCI+20]. This produces an IOP as a result. Finally, use the aforementioned BCS transformation on this IOP to produce a non-interactive succinct argument. If this argument is knowledge sound, one has obtained a SNARK. Figure 1 summarizes this construction. It is immediate to see that the previously mentioned protocols (Plonky2, RISC Zero, ethSTARKs, etc.) are actual instantiations of this construction.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A recipe for building a succinct non-interactive argument.</p>

    <p class="text-gray-300">We then provide general results for proving that the resulting succinct non-interactive argument is knowledge sound. Precisely, we prove the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RBR soundness of batched FRI. As a general result, we prove that the (batched) FRI protocol is RBR sound and RBR knowledge sound. We remark that batched FRI can be used for checking  <span class="math">\\delta</span> -correlated agreement of a collection of maps [BCI+20].</li>

      <li>From RBR knowledge when the adversary sends low degree polynomials, to general RBR knowledge. Consider a  <span class="math">\\delta</span> -correlated IOP  <span class="math">\\Pi</span> , and suppose attackers always send oracles to low degree polynomials. We prove that if  <span class="math">\\Pi</span>  is RBR (knowledge) sound under this assumption, then it is also RBR (knowledge) sound in general, and that the soundness error only increases by a (relatively) small factor.</li>

      <li>From a RBR knowledge sound  <span class="math">\\delta</span> -correlated IOP to a RBR knowledge sound IOP. Again let  <span class="math">\\Pi</span>  be a  <span class="math">\\delta</span> -correlated IOP. By using an interactive protocol  <span class="math">\\Pi_{\\mathrm{CA}}</span>  to check for  <span class="math">\\delta</span> -correlation,  <span class="math">\\Pi</span>  can be turned into a regular IOP  <span class="math">\\Pi_{\\mathrm{compiled}}</span> . We prove that this compilation preserves RBR (knowledge) soundness, assuming  <span class="math">\\Pi_{\\mathrm{CA}}</span>  is RBR sound (not necessarily RBR knowledge sound).</li>

      <li>From a RBR knowledge sound IOP to a SNARK. We then apply the BCS compilation results from [BCS16] to obtain a SNARK.</li>

    </ol>

    <p class="text-gray-300">In conclusion, we show that given any succinct non-interactive argument constructed as in Figure 1 (using batched FRI to check for  <span class="math">\\delta</span> -correlation), one can show its knowledge soundness simply by proving RBR knowledge soundness of the underlying  <span class="math">\\delta</span> -correlated IOP under the assumption that the adversary is constrained to sending oracles to low-degree polynomials. The latter can greatly simplify the analysis since it allows one to work with the simplicity of IOPs (as opposed to arguments) and the convenient properties of polynomials.</p>

    <p class="text-gray-300">Thus, our methods not only allow us to prove FS-security, they also remove the complexity of dealing with maps that are close to low-degree polynomials when using FRI within a protocol. This allows us to analyze the interactive version of these protocols in a similar way as when one studies Polynomial IOPs [BFS20], where, by definition, soundness is only considered for adversaries that send low-degree polynomials.</p>

    <p class="text-gray-300">According to our formalism, a  <span class="math">\\delta</span> -correlated IOP where we constrain adversaries to always send low-degree polynomials is in fact a 0-correlated IOP. Then, Item (2) above can be seen as a result that relates the RBR knowledge soundness of a  <span class="math">\\delta</span> -correlated IOP for  <span class="math">\\delta = 0</span>  and for  <span class="math">\\delta &amp;gt; 0</span> . Overall, our security results can be organized and depicted as in Figure 2; see also Theorem 1.5.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Another recipe for building a SNARG/SNARK.</p>

    <p class="text-gray-300">Theorem 1.5 (Informally Stated, see Theorem 4.6). Let  <span class="math">\\Pi_{\\delta}^{O}</span>  be a  <span class="math">\\delta</span> -correlated IOP, where  <span class="math">O</span>  is an oracle for  <span class="math">\\delta</span> -correlated agreement. Let  <span class="math">0 &amp;lt; \\rho, \\eta \\leq 1</span>  and  <span class="math">\\delta = 1 - \\sqrt{\\rho} - \\eta</span> . Assume  <span class="math">\\Pi_0</span>  has RBR knowledge soundness with error  <span class="math">\\varepsilon</span> . Then  <span class="math">\\Pi_{\\delta}</span>  has RBR knowledge soundness with error  <span class="math">\\varepsilon / (2\\sqrt{\\rho}\\eta)</span> .</p>

    <p class="text-gray-300">Moreover, if  <span class="math">\\Pi&#x27;</span>  is an IOP for testing  <span class="math">\\delta</span> -correlated agreement in a Reed-Solomon code with RBR soundness error  <span class="math">\\varepsilon&#x27;</span> , then the protocol  <span class="math">\\Pi_{\\mathrm{compiled}}</span>  obtained by replacing  <span class="math">O</span>  in  <span class="math">\\Pi_{\\delta}</span>  with  <span class="math">\\Pi&#x27;</span>  has RBR knowledge soundness with error</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_ {\\text {c o m p i l e d}} = \\max  \\left\\{\\varepsilon / \\left(2 \\sqrt {\\rho} \\eta\\right), \\varepsilon^ {\\prime} \\right\\}.</span></div>

    <p class="text-gray-300">Finally, given a random oracle with  <span class="math">\\kappa</span> -bits of output and query bound  <span class="math">Q \\geq 1</span> , compiling  <span class="math">\\Pi_{\\mathrm{compiled}}</span>  with the BCS transformation yields a succinct non-interactive argument in the random oracle model with knowledge error</p>

    <div class="my-4 text-center"><span class="math-block">Q \\cdot \\max  \\left\\{\\varepsilon / \\left(2 \\sqrt {\\rho} \\eta\\right), \\varepsilon^ {\\prime} \\right\\} + O \\left(Q ^ {2} / 2 ^ {\\kappa}\\right).</span></div>

    <p class="text-gray-300">Remark 1.6. As we mentioned, the notion of  <span class="math">\\delta</span> -correlated IOP is closely related to that of RS-encoded IOP from [BCR+19, COS20]. The works of [BCR+19, COS20] also provide a method for compiling a RBR (knowledge) sound RS-encoded IOP into RBR (knowledge sound IOPs); e.g., see [COS20, Theorem 8.2]. However, our result allows us to use a proximity parameter up to the Johnson bound, i.e., we can select  <span class="math">\\delta = 1 - \\sqrt{\\rho} - \\eta</span>  for any arbitrarily small  <span class="math">\\eta &amp;gt; 0</span> , while the compilation results from [BCR+19, COS20] constrain  <span class="math">\\delta</span>  to be within the unique decoding radius  <span class="math">\\delta &amp;lt; \\frac{1 - \\rho}{2}</span> . On the other hand, in some sense, RS-encoded IOPs encompass a wider class of protocols than  <span class="math">\\delta</span> -correlated ones. See Appendix B for further discussion.</p>

    <p class="text-gray-300">Remark 1.7. Many security analyses of SNARKs obtained by combining Plonk-like protocols with so-called KZG polynomial commitments [KZG10] can assume that an adversary always sends oracles to polynomials of appropriate degree. Intuitively, this is due to the fact that the KZG polynomial commitment scheme ensures that a committed function is indeed a polynomial of appropriate degree.</p>

    <p class="text-gray-300">However, in our scenario, due to the usage of the FRI protocol instead of KZG, adversaries are only constrained to sending (oracles to) maps that are close to polynomials of appropriate degree. This makes the soundness analysis of our protocols more subtle. Indeed, as we mentioned, besides showing that FRI itself is RBR sound, most of our work is concerned with reducing the analysis to the case when the adversary actually sends oracles to polynomials of the appropriate degree.</p>

    <h2 id="sec-16" class="text-2xl font-bold">1.2.3 Round-by-round Soundness of Specific  <span class="math">\\delta</span> -correlated Proof Systems</h2>

    <p class="text-gray-300">We can apply all the tools developed so far to specific protocols whose construction follows the outline from Figures 1 and 2. In short, these are protocols resulting of compiling a  <span class="math">\\delta</span> -correlated IOP into a succinct non-interactive protocol via a protocol for  <span class="math">\\delta</span> -correlated agreement and the BCS transformation. Thanks to Theorems 1.3 and 1.5, we can prove the knowledge soundness of these protocols just by proving that the corresponding  <span class="math">0</span> -correlated IOP has RBR knowledge soundness. Recall that in a  <span class="math">0</span> -correlated IOP, the adversary is assumed to always send oracles to low-degree polynomials.</p>

    <p class="text-gray-300">Some of the protocols that fit into this framework are many "Plonk-like" proof systems that use FRI instead of the KZG polynomial commitment scheme; Plonky2 [Polb], Redshift [KPV22], and RISC Zero [Tea23] are examples. Here we use the term "Plonk-like" to loosely refer to protocols that use an interactive permutation argument</p>

    <p class="text-gray-300"><em>[x14, x15, BEG^{+}94, ZGK^{+}18, BCG^{+}18]</em> as a subroutine (we use the term “Plonk-like” because the Plonk SNARK <em>[x13]</em> helped popularize the use of this permutation-checking procedure). Other protocols that fit in our framework but are not “Plonk-like” are ethSTARK or DEEP-ALI <em>[x3]</em>.</p>

    <p class="text-gray-300">We focus our attention mostly on Plonky2 since we believe that, among all these protocols in <span class="math">0</span>-correlated IOP form, Plonky2 is the most involved to analyze. Indeed, Plonky2 was designed to be used over a small field (the 64-bit so-called Goldilocks field). Because of this, some checks are repeated in parallel in order to increase its security. The task of correctly designing these parallel repetitions is subtle, and indeed in Appendix C we describe an (arguably more natural) variation of Plonky2 with dramatically <em>less</em> security than Plonky2 itself. To the best of our knowledge, this variation is <em>not used</em> in practice—we are showcasing it here to illustrate a potential pitfall to be avoided.</p>

    <p class="text-gray-300">Accordingly, we rigorously define a general “Plonk-like” <span class="math">\\delta</span>-correlated IOP, which captures many “Plonk-like” protocols that rely on the FRI protocol. We denote this <span class="math">\\delta</span>-correlated IOP by <span class="math">\\mathsf{OPlonky}(\\delta)</span>. We then formally prove that when <span class="math">\\delta=0</span> (i.e., when adversaries are constrained to sending low-degree polynomials), <span class="math">\\mathsf{OPlonky}(0)</span> has RBR soundness and knowledge soundness. Together with our general results and our results on batched FRI, this proves in particular that the SNARK version of Plonky2 is indeed knowledge sound (as well as all other “Plonk-like” protocols of the form <span class="math">\\mathsf{OPlonky}(\\delta)</span>). Adapting Theorem 1.5 to our abstraction <span class="math">\\mathsf{OPlonky}</span>, we obtain the following result.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 1.8 (Informally Stated, see Lemmas 4.7 and 4.9).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">\\mathbb{K}</span> be a finite extension of <span class="math">\\mathbb{F}</span> and let <span class="math">D\\subseteq\\mathbb{F}</span> be an evaluation domain for maps. Let <span class="math">\\mathcal{P}=\\{P_{1},\\ldots,P_{k}\\}</span> be a list of <span class="math">2r+\\ell</span>-variate circuit constraint polynomials over <span class="math">\\mathbb{F}</span> for <span class="math">k,r,\\ell\\geq 1</span>. For parameters <span class="math">n,t,u\\geq 1</span>, <span class="math">s=\\lceil r/u\\rceil</span>, and $m\\geq 3,\\rho=(n+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in(0,1),\\eta\\in(0,\\sqrt{\\rho}/2m)<span class="math"> and </span>\\delta=1-\\sqrt{\\rho}-\\eta<span class="math">, the protocol </span>\\mathsf{OPlonky}^{O}<span class="math">, when the verifier is given an oracle </span>O<span class="math"> for </span>\\delta<span class="math">-correlated agreement in the Reed-Solomon code </span>\\mathsf{RS}[\\mathbb{F},D,n+1]$, has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky},O}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta)=\\frac{1}{2\\eta\\sqrt{\\rho}}\\cdot\\max\\left\\{O\\left(\\left(\\frac{n(r+u)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{t}\\right),O\\left(\\left(\\frac{k+st}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{t}\\right),\\frac{n\\cdot\\max\\{u+1,d\\}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}\\setminus D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">d=\\max_{i}\\{\\deg(P_{i})\\}</span> and <span class="math">D</span> is an evaluation domain for RS codes. Moreover, when <span class="math">\\delta=0</span> then we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky},O}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta)=\\max\\left\\{O\\left(\\left(\\frac{n(r+u)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{t}\\right),O\\left(\\left(\\frac{k+st}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{t}\\right),\\frac{n\\cdot\\max\\{u+1,d\\}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}\\setminus D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-18" class="text-base font-medium mt-4">Remark 1.9.</h6>

    <p class="text-gray-300">The parameter <span class="math">t</span> in Theorem 1.8 controls the number of times certain checks in <span class="math">\\mathsf{OPlonky}</span> are performed “in parallel”. In most Plonk-like protocols, one uses <span class="math">t=1</span> and a large field <span class="math">\\mathbb{F}</span> to ensure an adequate security level. However, some projects (e.g., Plonky2) currently feature a 64-bit field <span class="math">\\mathbb{F}</span>, and use <span class="math">t=2</span> to increase security.</p>

    <p class="text-gray-300">We show in this paper that, if done properly, the resulting FS-transformed protocol does achieve the targeted security level. However, in Appendix C we explain that this result is surprisingly subtle: certain natural ways of implementing the <span class="math">t</span>-fold repetition actually result in RBR security (and, correspondingly, the post-FS security <em>[x1]</em>) that is much lower than the one attained in Theorem 1.8. While (to our knowledge) all existing projects do implement the <span class="math">t</span>-fold repetition properly so as to ensure FS-security, we highlight this subtlety so that protocol designers continue to avoid this potential pitfall.</p>

    <p class="text-gray-300">We can instantiate the oracle <span class="math">O</span> in Theorem 1.8 with Batched FRI and obtain the following result.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 1.10 (Informally Stated, see Theorem 4.10).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">\\mathbb{K}</span> be a finite extension of <span class="math">\\mathbb{F}</span>, and <span class="math">D\\subset\\mathbb{F}^{*}</span>. Let <span class="math">\\mathcal{P}=\\{P_{1},\\ldots,P_{k}\\}</span> be a list of <span class="math">2r+\\ell</span>-variate circuit constraint polynomials over <span class="math">\\mathbb{F}</span> for <span class="math">k,r,\\ell,n\\geq 1</span>. For integer <span class="math">u\\geq 1</span>, <span class="math">s=\\lceil r/u\\rceil</span>, and parameters <span class="math">\\rho,\\eta&gt;0</span>, <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span>, and <span class="math">N,q\\geq 1</span>, the protocol <span class="math">\\mathsf{OPlonky}</span> composed with Batched FRI (replacing <span class="math">O</span>) has round-by-round soundness error:</p>

    <p class="text-gray-300">\\[ \\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky}}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta,N,q)\\\\ =\\max\\{\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky},O}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta),\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}(\\mathbb{F},D,\\rho,\\delta,N,q)\\}, \\]</p>

    <p class="text-gray-300">where <span class="math">d=\\max_{i}\\{\\deg(P_{i})\\}</span>.</p>

    <p class="text-gray-300">Given the above protocol is a round-by-round sound IOP, as in Theorem 1.5, we can now apply the BCS transformation to obtain a secure non-interactive argument in the random oracle model.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Corollary 1.11 (Informally Stated; see Corollary 7.6).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">\\mathbb{K}</span> be a finite extension of <span class="math">\\mathbb{F}</span>, and <span class="math">D\\subset\\mathbb{F}^{*}</span>. Let <span class="math">\\mathcal{P}=\\{P_{1},\\ldots,P_{k}\\}</span> be a list of <span class="math">2r+\\ell</span>-variate circuit constraint polynomials over <span class="math">\\mathbb{F}</span> for <span class="math">k,r,\\ell,n\\geq 1</span>. For integers <span class="math">u,t\\geq 1</span>, <span class="math">s=\\lceil r/u\\rceil</span>, and parameters <span class="math">\\rho,\\eta&gt;0</span>, <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span>, and <span class="math">N,q\\geq 1</span>, given a random oracle with <span class="math">\\kappa</span>-bits of output and a query bound <span class="math">Q\\geq 1</span>, using the BCS transformation to compile <span class="math">\\mathsf{OPlonky}</span> composed with Batched FRI yields a non-interactive argument in the random oracle model with adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs}}^{\\mathsf{OPlonky}}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta,N,q,\\kappa,Q)=Q\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky}}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta,N,q)+O(Q^{2}/2^{\\kappa}),</span></p>

    <p class="text-gray-300">where <span class="math">d=\\max_{i}\\{\\deg(P_{i})\\}</span>. Moreover, the the transformed non-interactive argument has adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\Theta(Q\\cdot\\varepsilon_{\\mathsf{fs}}^{\\mathsf{OPlonky}}(\\mathbb{F},\\mathbb{K},D,n,k,r,s,t,u,d,\\rho,\\eta,N,q,\\kappa,Q))</span></p>

    <p class="text-gray-300">versus <span class="math">O(Q)</span>-query quantum adversaries.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Remark 1.12.</h6>

    <p class="text-gray-300">We stress that the above theorems do not imply anything for the original work of Plonk <em>[x11]</em>, or any other Plonk variants that utilize the so-called KZG polynomial commitment scheme <em>[x20]</em> as their low-degree test. The tools we leverage to show Fiat-Shamir security of our protocols rely on the low-degree test also being an IOP or an IOP of Proximity, which the KZG scheme is not. While it is likely one can extend our analysis to handle using the KZG scheme, we do not explore that direction in this work.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">RISC Zero and ethSTARK.</h5>

    <p class="text-gray-300">When it comes to RISC Zero and ethSTARK, we sketch why their <span class="math">0</span>-correlated formulations have RBR knowledge soundness, as opposed to fully formally proving these facts. We do that due to brevity (since formally describing these protocols is a lengthy task), and because proving that these <span class="math">0</span>-correlated IOPs are RBR knowledge sound is a relatively straightforward task, as our analysis of <span class="math">\\mathsf{OPlonky}</span> indicates. Moreover, RISC Zero’s whitepaper is in draft form at the moment of writing <em>[x33]</em>. We hope practitioners can follow the techniques and ideas exposed in this paper to prove in a relatively simple way that their SNARKs are indeed FS-secure.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">1.3 Additional Related Work</h3>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Concurrent Independent Work.</h5>

    <p class="text-gray-300">As concurrent work, StarkWare has updated ethSTARK documentation to include a proof of Fiat-Shamir security of FRI and ethSTARK <em>[x34]</em>. Their techniques can be seen as an instantiation of our general framework. As pointed out in <em>[x34, Remark 5]</em>, since our techniques are more general, they can be used to prove FS security of many protocols (as demonstrated in this work). On the other hand, <em>[x34]</em> performs a more fine-grained analysis of the later rounds of FRI and of the usage of grinding within it.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Fiat-Shamir.</h5>

    <p class="text-gray-300">The Fiat-Shamir (FS) transform <em>[x14]</em> has been studied and used extensively to remove interaction from interactive protocols. While it is known that the FS transformation is secure when applied to sound protocols with a constant number of rounds in the random oracle model (ROM) <em>[x14, x21, x1]</em>, it is well-known that there exist protocols that are secure under FS in the ROM but insecure for <em>any</em> concrete instantiation of the random oracle <em>[x3, x13, BDG^{+}13]</em>. Furthermore, several natural classes of secure interactive protocols are rendered insecure when applying FS (e.g., sequential repetition of a protocol and parallel repetition of certain protocols) <em>[CCH^{+}19, x30, x1]</em>, and real-world implementations of FS are often done incorrectly, leading to vulnerabilities <em>[x6, x10]</em>. Despite this, Fiat-Shamir is widely deployed and is a critical component in the majority of SNARG or SNARK constructions.</p>

    <p class="text-gray-300">Recent work has extensively studied which protocols can be securely instantiated under Fiat-Shamir (either in the ROM or using suitable hash-function families). As mentioned before, the general tools of state-restoration soundness <em>[x5]</em>, round-by-round soundness <em>[CCH^{+}19]</em>, and special soundness <em>[x12, x30, x1]</em> have been introduced as soundness notions that “behave nicely” under Fiat-Shamir. Prior to these tools, a variety of works <em>[x22, x11, x17]</em> circumvented the impossibility results of <em>[BDG^{+}13]</em> by utilizing stronger hardness assumptions to construct Fiat-Shamir compatible hash function families. Another line of work <em>[x12, x15, x6, x13, x23, x24]</em> follows the frameworks of Kilian <em>[x18]</em> and Micali <em>[x25]</em> to compile interactive oracle proofs <em>[x5]</em> into efficient arguments and SNARKs via collision-resistant hash functions <em>[x6, x19]</em> or in the random oracle model <em>[x5, x25]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">1.4 Organization</p>

    <p class="text-gray-300">In Section 2, we give an overview of our main technical results. Section 3 contains the preliminaries for the rest of the paper. Section 4 presents our main results in full detail. Section 5 formally discusses and proves our results related to FRI and Batched FRI. In Section 6, we introduce a new notion for holographic interactive oracle proofs we call <span class="math">\\delta</span>-correlated holographic interactive oracle proofs, a technical tool we use in Section 6. In Section 7 we formally describe and establish the round-by-round soundness of <span class="math">\\mathsf{OPlonky}</span>, utilize the tools in Section 6 to establish round-by-round soundness of <span class="math">\\mathsf{OPlonky}</span> composed with (Batched) FRI, and discuss several Plonk-like protocols affected by our analysis. Finally, Section 8 discusses some future directions.</p>

    <p class="text-gray-300">In Appendix A, we formally analyze the concrete security of the non-interactive FRI protocol under various parameter settings, and in Appendix B we briefly discuss the relationship between <span class="math">\\delta</span>-correlated hIOPs and Reed-Solomon encoded IOPs. In Appendix C we discuss a subtle variation of <span class="math">\\mathsf{OPlonky}</span> that leads to a much larger RBR soundness error. This variation has to do in the way some “parallel” checks are performed.</p>

    <h2 id="sec-26" class="text-2xl font-bold">2 Technical Overview</h2>

    <p class="text-gray-300">Our main technical contributions are two-fold. First, formally proving the round-by-round (knowledge) soundness of the FRI protocol. Second, building a general tool for proving RBR (knowledge) soundness of a family of protocols that we call <span class="math">\\delta</span>-correlated IOPs, and actually proving or outlining a proof of this soundness property for some specific protocols, like some “Plonk-type” protocols, which we summarize in a general protocol that we call <span class="math">\\mathsf{OPlonky}</span>, and other <span class="math">\\delta</span>-correlated IOPs like ethSTARK. We give a high-level overview of these results here. In Section 2.1, we briefly discuss round-by-round soundness and its relation to Fiat-Shamir; in Section 2.2, we give an overview of the round-by-round soundness of FRI and Batched FRI; in Section 2.3, we introduce the concept of <span class="math">\\delta</span>-correlated IOP and prove our general results about them; in Section 2.4, we give an overview of the round-by-round (knowledge) soundness of <span class="math">\\mathsf{OPlonky}</span>; in Section 2.5, we discuss how a similar analysis can be conducted for the ethSTARK protocol.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">2.1 Round-by-round Soundness and Fiat-Shamir</h3>

    <p class="text-gray-300">Our tool of choice for establishing Fiat-Shamir security is round-by-round soundness <em>[CCH^{+}19]</em>. Informally, a public-coin interactive protocol for a language <span class="math">L</span> is round-by-round sound (RBR sound) if at any point during the execution of the protocol, the protocol is in a well-defined state (depending on the protocol execution so far) and some of these states are “doomed”, where being “doomed” means that no matter what message the prover sends, with overwhelming probability over the verifier messages, the protocol remains “doomed”. A bit more formally, RBR soundness error <span class="math">\\varepsilon</span> states that: (1) if <span class="math">x\\notin L</span> the initial state of the protocol is “doomed”; (2) if the protocol is in a “doomed” state during any non-final round of the protocol, then for any message sent by the prover, the protocol remains doomed with probability at least <span class="math">1-\\varepsilon</span> over the verifier messages; and (3) if the protocol terminates in a “doomed” state, then the verifier rejects. Chiesa et al. <em>[x10]</em> et al. extend RBR soundness to the notion of RBR knowledge soundness, which roughly says that if (1) the protocol is in a “doomed” state during any round of interaction, and (2) every prover message can force the protocol to leave this “doomed” state with probability at least <span class="math">\\varepsilon_{\\text{k}}</span> (over the verifier randomness), then an extractor can efficiently extract a witness (with probability 1) simply by examining the current protocol state and the prover’s next message.</p>

    <p class="text-gray-300">Canetti et al. <em>[CCH^{+}19]</em> introduced RBR soundness as a tool for showing Fiat-Shamir security of interactive proofs <em>[x14]</em> when used in conjunction with a suitable family of correlation intractable hash functions <em>[x11]</em>. In particular, random oracles are correlation intractable when the set of “doomed” states of a protocol is sufficiently sparse; i.e., for small enough RBR soundness error. RBR soundness readily extends to the language of interactive oracle proofs (IOPs) <em>[x3]</em>, and hence the Fiat-Shamir compiler result of <em>[CCH^{+}19]</em> readily extends to IOPs, and can be readily adapted to the random oracle model as well. However, applying this compiler to IOPs directly introduces some undesirable effects: the constructed non-interactive argument would have proof lengths proportional to the length of the oracle sent by the prover since the compiler of <em>[CCH^{+}19]</em> does not compress prover messages in any way. This leads to long proofs and long verification times, negating any succinct verification the IOP may have had. Moreover, the</p>

    <p class="text-gray-300">transformation of <em>[CCH^{+}19]</em> says nothing about the knowledge soundness of the resulting non-interactive argument, even in the random oracle model.</p>

    <p class="text-gray-300">While it is likely that, in the random oracle model, one could argue that the transformation of <em>[CCH^{+}19]</em> retains knowledge soundness if the underlying IOP is RBR knowledge sound, we do not prove this fact; moreover, the loss of verifier succinctness is still an issue even if knowledge soundness is retained. Thus to circumvent the above issues, we utilize the BCS transformation <em>[x1]</em> for IOPs. Informally, the BCS transformation first compresses oracles sent by the prover using a Merkle tree <em>[x13]</em> and then replaces any queries made by the verifier to prover oracles with additional rounds of interaction where the verifier asks the prover its queries, and the prover responds with said queries and Merkle authentication paths to verify consistency. It was shown that if an IOP is round-by-round sound then applying BCS to this IOP gives a SNARK in the random oracle model <em>[x5, x6]</em>. Thus showing the RBR soundness of FRI and <span class="math">\\mathsf{OPlonky}</span> allows us to readily show Fiat-Shamir security of these protocols under the BCS transformation in the random oracle model, yielding our results. Thus in what follows, we give a high-level overview of the round-by-round soundness proofs for both FRI and <span class="math">\\mathsf{OPlonky}</span>.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">2.2 Round-by-round Soundness of FRI</h3>

    <p class="text-gray-300">We give a high-level sketch of the round-by-round soundness of FRI in this section; for full details, see Section 5. As previously stated, FRI is an interactive oracle proof of proximity for testing whether or not a polynomial specified by a prover is “close to” a particular space of Reed-Solomon codewords. More formally, for finite field <span class="math">\\mathbb{F}</span>, multiplicative subgroup <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> of size <span class="math">N=2^{n}</span>, and degree bound <span class="math">d_{0}=2^{k}</span> for <span class="math">k\\in\\mathbb{N}</span>, <span class="math">\\mathsf{RS}:=\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]\\subset\\mathbb{F}^{N}</span> is the set of all polynomials <span class="math">f\\colon L_{0}\\to\\mathbb{F}</span> of degree at most <span class="math">d_{0}-1</span>, and the FRI protocol allows for a prover to succinctly prove to a verifier that a function <span class="math">G_{0}\\colon L_{0}\\to\\mathbb{F}</span> is within some proximity bound <span class="math">\\delta</span> of the <span class="math">\\mathsf{RS}</span> code. That is, if a verifier accepts the interaction, then the verifier is convinced that there exists <span class="math">f\\in\\mathsf{RS}</span> such that <span class="math">\\Delta(G_{0},f)&lt;\\delta N</span>, where <span class="math">\\Delta</span> is the Hamming distance between <span class="math">G_{0}</span> and <span class="math">f</span> (when viewing them as vectors in <span class="math">\\mathbb{F}^{N}</span>). We say that such a <span class="math">G_{0}</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}</span>; otherwise, we say that <span class="math">G_{0}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}</span> (i.e., <span class="math">\\Delta(G_{0},f)\\geq\\delta N</span> for all <span class="math">f\\in\\mathsf{RS}</span>).</p>

    <p class="text-gray-300">To achieve succinct verification, the FRI protocol first interactively compresses <span class="math">G_{0}</span> during a folding phase, which proceeds as follows. First, the prover sends oracle <span class="math">G_{0}</span> to the verifier. Next, the verifier samples <span class="math">x_{0}\\xleftarrow{*}\\mathbb{F}</span> uniformly at random and sends it to the verifier. Now the prover defines new oracle <span class="math">G_{1}\\colon L_{1}\\to\\mathbb{F}</span> over the new domain <span class="math">L_{1}=(L_{0})^{2}:=\\{z^{2}\\colon z\\in L_{0}\\}</span> of size <span class="math">N/2</span>, where for any <span class="math">s\\in L_{1}</span>, if <span class="math">s^{\\prime},s^{\\prime\\prime}\\in L_{0}</span> are the square roots of <span class="math">s</span>, then we have</p>

    <p class="text-gray-300"><span class="math">G_{1}(s)=(x_{0}-s^{\\prime})(s^{\\prime\\prime}-s^{\\prime})^{-1}G_{0}(s^{\\prime\\prime})+(x_{0}-s^{\\prime\\prime})(s^{\\prime}-s^{\\prime\\prime})^{-1}G_{0}(s^{\\prime}).</span> (1)</p>

    <p class="text-gray-300">Given <span class="math">G_{1}</span>, the prover and verifier now recursively engage in the above folding procedure with the function <span class="math">G_{1}</span>, where the claim is that <span class="math">G_{1}</span> is <span class="math">\\delta</span>-close to a new Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},L_{1},d_{1}]</span> for <span class="math">d_{1}=d_{0}/2</span>; this recursion continues until <span class="math">\\log(d_{0})=k</span> folds have been done which results in prover oracles <span class="math">G_{0},G_{1},\\ldots,G_{k-1}</span> and verifier challenges <span class="math">x_{0},x_{1},\\ldots,x_{k-1}</span>.</p>

    <p class="text-gray-300">After the folding phase, the prover and verifier now engage in the query phase. During this phase, the prover sends a constant value <span class="math">G_{k}\\in\\mathbb{F}</span> to the verifier, and the verifier samples a random challenge <span class="math">s_{0}\\xleftarrow{*}L_{0}</span> and uses this point to check the consistency of all pairs of functions <span class="math">G_{i-1},G_{i}</span> for <span class="math">i\\in\\{1,\\ldots,k\\}</span> as follows. The verifier first checks consistency of <span class="math">G_{0}</span> and <span class="math">G_{1}</span> using Eq. (1); in particular, if we set <span class="math">s_{1}=(s_{0})^{2}</span> and let <span class="math">t_{0}</span> be the other square root of <span class="math">s_{1}</span> (i.e., <span class="math">(t_{0})^{2}=s_{1}</span> and <span class="math">t_{0}\\neq s_{0}</span>), the verifier checks that <span class="math">G_{1}(s_{1})</span> is consistent with <span class="math">G_{0}(s_{0})</span> and <span class="math">G_{0}(t_{0})</span> via Eq. (1). This check is then performed for every pair of functions <span class="math">G_{i-1}</span> and <span class="math">G_{i}</span> via Eq. (1) using challenge <span class="math">x_{i-1}</span> and <span class="math">G_{i}(s_{i})</span>, <span class="math">G_{i-1}(s_{i-1})</span>, and <span class="math">G_{i-1}(t_{i-1})</span>, where <span class="math">s_{i}=(s_{i-1})^{2}</span> and <span class="math">t_{i-1}\\neq s_{i-1}</span> is the other square root of <span class="math">s_{i}</span>. The verifier accepts if and only if all of these checks pass. More generally, the verifier performs the above query phase (in parallel) <span class="math">\\ell\\geq 1</span> times, and outputs accept if and only if all consistency checks pass.</p>

    <p class="text-gray-300">To show round-by-round soundness of FRI, we first turn to the prior soundness analyses of FRI. Suppose that <span class="math">G_{0}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>, then it turns out a malicious prover has two strategies for fooling the verifier: (1) “luck out” in the sense that for <span class="math">x_{0}\\xleftarrow{*}\\mathbb{F}</span> sent by the verifier, the new function <span class="math">G_{1}</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[\\mathbb{F},L_{1},d_{1}]</span>; or (2) send some <span class="math">G_{1}^{\\prime}\\neq G_{1}</span> that is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[\\mathbb{F},L_{1},d_{1}]</span>. Intuitively, strategy (2) never increases the probability the prover can fool the verifier since even though <span class="math">G_{1}^{\\prime}</span> is closer to the Reed-Solomon codespace, this improvement is offset by the fact that <span class="math">G_{1}</span> and <span class="math">G_{1}^{\\prime}</span></p>

    <p class="text-gray-300">will differ at many different points. Thus the optimal prover strategy is to simply behave honestly by sending the correct function during every round using Eq. (1), and hoping to “luck out” from the verifier challenge during that round.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">2.2.1 FRI Round-by-round Soundness Overview</h4>

    <p class="text-gray-300">We adapt the above intuition for the round-by-round (RBR) soundness of FRI. Let <span class="math">P^{<em>}</span> be our (possibly malicious) prover. Let <span class="math">\\varepsilon_{1}</span> be the probability that <span class="math">P^{</em>}</span> “lucks out” as described above First, since <span class="math">G_{0}</span> is assumed to be <span class="math">\\delta</span>-far, and moreover <span class="math">G_{0}</span> is honestly sent to the verifier, the protocol, begins in a doomed state. Then if the verifier sends <span class="math">x_{0}</span> such that <span class="math">P^{*}</span> “lucks out” and the function <span class="math">G_{1}</span> is <span class="math">\\delta</span>-close, then we say the protocol is no longer in a doomed state. This happens with probability at most <span class="math">\\varepsilon_{1}</span>.</p>

    <p class="text-gray-300">Building on this, suppose the partial transcript so far consists of <span class="math">(G_{0},x_{0})</span> and suppose that this state is doomed; that is, both <span class="math">G_{0}</span> and <span class="math">G_{1}</span> are <span class="math">\\delta</span>-far functions. Now the prover <span class="math">P^{<em>}</span> may send some function <span class="math">G_{1}^{\\prime}</span> that may or may not be equal to <span class="math">G_{1}</span> (as given in Eq. (1)), and then the verifier responds with challenge <span class="math">x_{1}</span>. However, as described before, sending <span class="math">G_{1}^{\\prime}\\neq G_{1}</span> doesn’t increase the probability that the prover fools the verifier, and we want the RBR soundness analysis to reflect this as well. Thus we say that the current state of the protocol, given by <span class="math">(G_{0},x_{0},G_{1}^{\\prime},x_{1})</span> is not doomed if and only if <span class="math">G_{1}^{\\prime}=G_{1}</span> and <span class="math">P^{</em>}</span> “lucks out” with the function <span class="math">G_{2}</span> (again defined via Eq. (1) using <span class="math">x_{1}</span> and <span class="math">G_{1}</span>). In other words, the protocol remains in a doomed state if: (1) <span class="math">G_{1}^{\\prime}\\neq G_{1}</span>; or <span class="math">G_{2}</span> is <span class="math">\\delta</span>-far (i.e., the prover didn’t “luck out”). Thus the protocol leaves its doomed state with probability at most <span class="math">\\varepsilon_{1}</span>. This analysis generalizes to all rounds of the folding phase: given any partial transcript <span class="math">(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{i-1}^{\\prime},x_{i-1})</span> that is in a doomed state, if <span class="math">P^{*}</span> sends function <span class="math">G_{i}^{\\prime}</span> and the verifier sends challenge <span class="math">x_{i}</span>, then the protocol is no longer doomed if and only if (1) the prover “lucked out” and <span class="math">G_{i+1}</span> is <span class="math">\\delta</span>-close; and (2) all <span class="math">G_{j}^{\\prime}=G_{j}</span> for <span class="math">j\\in\\{1,\\ldots,i-1\\}</span>. And again, the protocol is no longer doomed with probability at most <span class="math">\\varepsilon_{1}</span>.</p>

    <p class="text-gray-300">To complete the RBR soundness analysis, we now consider the final round of the protocol, which consists of the query phase. Suppose that the partial transcript for this round is given by <span class="math">(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{k-1}^{\\prime},x_{k-1})</span> and suppose the protocol is in a doomed state. At this point, <span class="math">P^{<em>}</span>’s hands are tied: it must send a constant <span class="math">G_{k}\\in\\mathbb{F}</span> to the verifier, and the verifier then samples <span class="math">s_{0}^{(1)},\\ldots,s_{0}^{(\\ell)}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}L_{0}</span> and performs its verification checks. Thus, the only way the protocol can leave the doomed state is if all of the verifier checks pass; in particular, if a single check does not pass then the protocol remains doomed (and, in fact, the verifier rejects). Let <span class="math">\\varepsilon_{2}</span> denote the probability that a single verifier check passes; that is, a single chain of checks depending on <span class="math">s_{0}^{(1)}</span> passes (i.e., computing the squares and square roots at every level, and checking consistency across all levels with this check). Then the probability <span class="math">P^{</em>}</span> can leave the doomed state is exactly <span class="math">\\varepsilon_{2}</span>; extending this to <span class="math">\\ell</span> checks (which are performed uniformly and independently at random) gives us that the protocol leaves the doomed state with probability at most <span class="math">\\varepsilon_{2}^{\\ell}</span>. Considering the folding and query phases, the discussion above shows that the FRI protocol has RBR soundness error <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{FRI}}=\\max\\{\\varepsilon_{1},\\varepsilon_{2}^{\\ell}\\}</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">2.2.2 Batched FRI Round-by-round Soundness Overview</h4>

    <p class="text-gray-300">Extending the above analysis to Batched FRI is straightforward. Briefly, Batched FRI invokes FRI on a random linear combination of <span class="math">t</span> functions <span class="math">f_{1},\\ldots,f_{t}\\colon L_{0}\\to\\mathbb{F}</span>. In more detail, first the prover sends oracles <span class="math">f_{1},\\ldots,f_{t}</span> to the verifier, then the verifier responds with random challenges <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}</span>. The prover and verifier then engage in the FRI protocol using function <span class="math">G_{0}=\\sum_{i}\\alpha_{i}f_{i}</span>. Finally, Batched FRI modifies the query phase of FRI to also check consistency between <span class="math">f_{i}</span> and <span class="math">G_{0}</span> exactly via the equation <span class="math">G_{0}=\\sum_{i}\\alpha_{i}f_{i}</span>. Key to Batched FRI is that if all <span class="math">f_{i}</span> are <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>, then <span class="math">G_{0}</span> is also <span class="math">\\delta</span>-close, and if even one <span class="math">f_{j}</span> is <span class="math">\\delta</span>-far, then with high probability <span class="math">G_{0}</span> is also <span class="math">\\delta</span>-far.</p>

    <p class="text-gray-300">The RBR soundness analysis of Batched FRI proceeds as follows. Let <span class="math">P^{<em>}</span> again denote our (possibly malicious) prover. The protocol begins in a doomed state; namely, there exists at least one <span class="math">f_{j}</span> that is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>. Then <span class="math">P^{</em>}</span> honestly sends <span class="math">f_{1},\\ldots,f_{t}</span> to the verifier, and the verifier responds with <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}</span> sampled uniformly and independently at random. Let <span class="math">\\varepsilon_{t}</span> be the probability that <span class="math">G_{0}</span> is <span class="math">\\delta</span>-close given that there exists at least one <span class="math">f_{j}</span> that is <span class="math">\\delta</span>-far, where the probability is taken over the selection of <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}</span>. Then we say the protocol is no longer in a doomed state if and only if <span class="math">G_{0}</span> is <span class="math">\\delta</span>-close; thus during this round, <span class="math">P^{*}</span> can leave the doomed state with probability at most <span class="math">\\varepsilon_{t}</span>. Now</p>

    <p class="text-gray-300">suppose that <span class="math">(f_{0},\\ldots,f_{t},\\alpha_{1},\\ldots,\\alpha_{t})</span> is the current protocol state and that this state is doomed. The prover and verifier now engage in FRI using some function <span class="math">G_{0}^{\\prime}</span> constructed by <span class="math">P^{<em>}</span> as input. The observation here is that we can now invoke the RBR soundness analysis of FRI directly, with the following slight change for the first round of FRI. Suppose <span class="math">P^{</em>}</span> sends <span class="math">G_{0}^{\\prime}</span> to the verifier and the verifier responds with <span class="math">x_{0}</span>. Then the protocol is no longer in a doomed state if and only if <span class="math">G_{0}^{\\prime}=G_{0}</span> and <span class="math">G_{1}</span> is <span class="math">\\delta</span>-close, where <span class="math">G_{1}</span> is defined via Eq. 1 with respect to the correct function <span class="math">G_{0}</span>. In particular, the intuition behind the prover’s strategy remains the same: if <span class="math">P^{<em>}</span> sends some other <span class="math">G_{0}^{\\prime}\\neq G_{0}</span>, then the verifier is more likely to detect this change when checking consistency of <span class="math">G_{0}^{\\prime}</span> and <span class="math">f_{1},\\ldots,f_{t}</span>, so <span class="math">P^{</em>}</span> can only leaved the doomed state of the protocol if it behaves honestly and “lucks out” with verifier challenge <span class="math">x_{0}</span>. Finally, we remark that the final round (i.e., the query phase) of Batched FRI with the additional checks between <span class="math">f_{1},\\ldots,f_{t}</span> and <span class="math">G_{0}^{\\prime}</span> has the same RBR soundness error <span class="math">\\varepsilon_{2}</span> as with FRI. Thus the RBR soundness error of Batched FRI is <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}=\\max\\{\\varepsilon_{t},\\varepsilon_{1},\\varepsilon_{2}^{\\ell}\\}</span>, where <span class="math">\\ell</span> is the number of times the verifier repeats the query phase.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">2.2.3 Instantiating <span class="math">\\varepsilon_{1}</span>, <span class="math">\\varepsilon_{2}</span>, and <span class="math">\\varepsilon_{3}</span></h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the query phase, the best one can hope for is <span class="math">\\varepsilon_{2}=(1-\\delta)</span> <em>[x1, x3, x11, x12]</em>; for the folding phase, there is a long line of work done towards improving the bounds on <span class="math">\\varepsilon_{1}</span> <em>[x1, x3, x12]</em>. In our work, we utilize the best known provable bounds on <span class="math">\\varepsilon_{1}</span> given by Ben-Sasson et al. <em>[x1]</em>, and note that any improvements for <span class="math">\\varepsilon_{1}</span> directly improve the round-by-round soundness error of FRI. In particular, we have $\\varepsilon_{1}=O(2^{2n}/(\\rho\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, where </span>\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{n}<span class="math">. This yields our stated round-by-round soundness error in Theorem 1.1. Finally, <em>[x1]</em> also show that </span>\\varepsilon_{t}=\\varepsilon_{1}<span class="math"> for Batched FRI, which gives us Batched FRI round-by-round soundness error </span>\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}=\\max\\{\\varepsilon_{1},\\varepsilon_{2}^{\\ell}\\}$, yielding our stated round-by-round soundness error in Theorem 1.3. See Section 5 for a complete discussion and proof of the round-by-round soundness of FRI and Batched FRI.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">2.2.4 FRI Round-by-round Knowledge Overview</h4>

    <p class="text-gray-300">Recall that a protocol has round-by-round knowledge error <span class="math">\\varepsilon_{\\text{k}}</span> if for any “doomed” state of the protocol, if every message the prover can send will put the protocol in a non-“doomed” state with probability at least <span class="math">\\varepsilon_{\\text{k}}</span> over the verifier randomness, then an extractor can efficiently recover a witness (with probability 1) when given the current protocol state and the prover’s next message. In the context of FRI, RBR knowledge soundness means we can extract a <span class="math">\\delta</span>-close function <span class="math">G</span>, and for Batched FRI we can extract <span class="math">t</span> functions <span class="math">f_{1},\\ldots,f_{t}</span> that are all <span class="math">\\delta</span>-close. For both FRI and Batched FRI, it turns out we obtain RBR knowledge soundness more or less for free. Recall that both protocols have RBR soundness error <span class="math">\\max\\{\\varepsilon_{1},\\varepsilon_{2}^{\\ell}\\}</span> from our discussion above. Then we claim that these protocols both have RBR knowledge error exactly <span class="math">\\varepsilon_{\\text{k}}=\\max\\{\\varepsilon_{1},\\varepsilon_{2}^{\\ell}\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We give an efficient extractor for the RBR knowledge soundness of FRI. First consider any intermediate round <span class="math">i</span> of the folding phase of FRI (the analysis for Batched FRI is identical). Then the current protocol state is doomed and is given by the transcript <span class="math">(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{i-1}^{\\prime},x_{i-1})</span>. Suppose that for any function <span class="math">G_{i}^{\\prime}</span> sent by the prover, for <span class="math">x_{i}\\xleftarrow{\\text{s}}\\mathbb{P}</span> sampled by the verifier, the protocol state <span class="math">(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{i}^{\\prime},x_{i})</span> is not doomed with probability at least <span class="math">\\varepsilon_{\\text{k}}</span>. In particular, this happens with probability at least $\\varepsilon_{1}=O(2^{2n}/(\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">. Then our extractor, given </span>(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{i}^{\\prime})<span class="math"> simply reads and outputs the oracle </span>G_{0}<span class="math">. For the query phase, the analysis is identical: let the current protocol state be doomed for transcript </span>(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{k-1}^{\\prime},x_{k-1})<span class="math">. Suppose for every </span>G_{k}\\in\\mathbb{P}<span class="math"> sent by the prover and verifier challenges </span>s_{0,1},\\ldots,s_{0,\\ell}\\xleftarrow{\\text{s}}L_{0}<span class="math">, the protocol state </span>(G_{0},x_{0},G_{1}^{\\prime},x_{1},\\ldots,G_{k},(s_{0,j})_{j\\leq\\ell})<span class="math"> is not doomed with probability at least </span>\\varepsilon_{\\text{k}}<span class="math">. In particular, this happens with probability at least </span>\\varepsilon_{2}^{\\ell}=(1-\\delta)^{\\ell}<span class="math">. Then our extractor again simply reads and outputs oracle </span>G_{0}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now why should we expect <span class="math">G_{0}</span> to be a <span class="math">\\delta</span>-close function? It turns out that by the choices of <span class="math">\\varepsilon_{1}</span> and <span class="math">\\varepsilon_{2}</span>, if <em>all</em> prover messages can leave the doomed state with the above probabilities, it <em>unconditionally</em> implies that <span class="math">G_{0}</span> must be <span class="math">\\delta</span>-close in both cases, a result shown by <em>[x1]</em>. First, for any round of the folding, the function <span class="math">G_{i}^{\\prime}</span> can leave the doomed set if and only if <span class="math">G_{i}^{\\prime}=G_{i}</span> (i.e., it is computed as an honest prover would compute it) and <span class="math">G_{i+1}</span> is <span class="math">\\delta</span>-close. If <span class="math">G_{i+1}</span> is <span class="math">\\delta</span>-close with probability greater than <span class="math">\\varepsilon_{1}</span> over the verifier randomness, then it unconditionally implies that <span class="math">G_{i}</span> must have been <span class="math">\\delta</span>-close as well <em>[x1]</em>. This then recursively applies to <span class="math">G_{i-1}</span>, and so on, finally yielding that <span class="math">G_{0}</span> must have been <span class="math">\\delta</span>-close as well. <em>[x1]</em> show that a similar result must hold for the query phase: if all verifier checks pass with probability at least <span class="math">\\varepsilon_{2}^{\\ell}</span> during the query phase for any <span class="math">G_{k}\\in\\mathbb{P}</span> sent by the prover, then <span class="math">G_{0}</span> must be <span class="math">\\delta</span>-close as well.</p>

    <p class="text-gray-300">Thus the RBR knowledge error of FRI is identical to the RBR soundness error. Finally, the above analysis proceeds identically for Batched FRI as well; i.e., if during any round of folding or batching phase the prover can leave with probability at least <span class="math">\\varepsilon_{1}</span>, then it unconditionally implies that <span class="math">f_{1},\\ldots,f_{t}</span> must be <span class="math">\\delta</span>-close functions. The Batched FRI query phase is analogous.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">2.3 Correlated IOPs and Round-by-round Knowledge Soundness</h3>

    <p class="text-gray-300">To conduct our security analysis beyond FRI, we formulate an abstract type of IOP which we call <span class="math">\\delta</span>-correlated IOP. This is a notion related and inspired by that of Reed-Solomon Encoded IOPs <em>[BCR^{+}19, x11]</em> (see Appendix B for further comparison). In a nutshell, when <span class="math">\\delta=0</span>, a <span class="math">0</span>-correlated IOP is an IOP where:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier has access to an oracle <span class="math">\\mathcal{O}</span> that, given any number of maps <span class="math">f_{1},\\ldots,f_{k}:D\\to\\mathbb{F}</span>, determines whether each of the <span class="math">f_{i}</span> is the evaluation map of a polynomial of degree at most <span class="math">d</span>, for any $d<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Here </span>D<span class="math"> is a subset of </span>\\mathbb{F}$, called evaluation domain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, <span class="math">\\mathcal{O}</span> determines whether the maps (or words) <span class="math">f_{i}</span> belong to the Reed-Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},D,d+1]</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>During the interactive phase, the prover sends oracle access to some maps <span class="math">g_{1},\\ldots,g_{m}:D\\to\\mathbb{F}</span> (across several rounds of interaction).</li>

      <li>In the last round of interaction, the verifier sends a field element <span class="math">\\mathfrak{z}\\in\\mathbb{K}\\setminus D</span> to the prover, and the prover replies with values</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left\\{g_{i}(k_{i,j}\\mathfrak{z})\\mid i\\in[m],j\\in[n_{i}]\\right\\}</span> (2)</p>

    <p class="text-gray-300">where <span class="math">k_{i,j}</span> are some pre-defined field elements and <span class="math">n_{i}\\geq 1</span> are predefined positive integers. Here <span class="math">\\mathbb{K}</span> is either <span class="math">\\mathbb{F}</span> or a field extension of <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Importantly, each map <span class="math">g_{i}</span> appears at least once in the list Eq. (2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To decide whether to reject or accept the prover’s proof, the verifier:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check 1. Asserts that the values <span class="math">\\left\\{g_{i}(k_{i,j}\\mathfrak{z})\\mid i\\in[m],j\\in[n_{i}]\\right\\}</span> satisfy certain polynomial equations.</li>

      <li>Check 2. Uses its oracle <span class="math">\\mathcal{O}</span> to check that the following maps belong to <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathtt{quotients}\\coloneqq\\left\\{\\frac{g_{i}(X)-g_{i}(k_{i,j}\\mathfrak{z})}{X-\\mathfrak{z}}\\mid i\\in[m],j\\in[n_{i}]\\right\\}</span> (3)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When <span class="math">\\delta&gt;0</span>, a <span class="math">\\delta</span>-correlated IOP has the exact same form as above, except that now <span class="math">\\mathcal{O}</span> is an oracle for checking <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d+1]</span> for any $d<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. A sequence of maps </span>g_{1},\\ldots,g_{m}:D\\to\\mathbb{F}<span class="math"> has </span>\\delta<span class="math">-correlated agreement if there exists a subset </span>S\\subseteq D<span class="math"> and polynomials </span>q_{1},\\ldots,q_{m}<span class="math"> of degree </span>\\leq d<span class="math"> such that </span>g_{i}<span class="math"> coincides with </span>q_{i}<span class="math"> on </span>S<span class="math">, for all </span>i\\in[m]<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These type of IOP’s are interesting to us because several modern IOP’s can be understood as being built on top of a <span class="math">0</span>-correlated or <span class="math">\\delta</span>-correlated IOP for <span class="math">\\delta&gt;0</span>, e.g., all Plonk-type protocols that use FRI instead of KZG <em>[x13, x20, x26]</em>, ethSTARK (or DEEP-ALI) <em>[x5, x28]</em>, RISC Zero <em>[x32]</em>, etc.</p>

    <p class="text-gray-300">One of our main results states the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Result 1. If a <span class="math">0</span>-correlated IOP <span class="math">\\Pi_{0}</span> has round-by-round (RBR) soundness or knowledge <span class="math">\\varepsilon</span>, then replacing <span class="math">\\delta=0</span> by a larger <span class="math">\\delta&gt;0</span> results in a <span class="math">\\delta</span>-correlated IOP with RBR soundness or knowledge <span class="math">\\ell\\varepsilon</span>, where <span class="math">\\ell</span> is certain constant related to list decodability of Reed-Solomon (RS) codes. Namely, <span class="math">\\ell</span> is the maximum number of distinct RS codewords that can be <span class="math">\\delta</span>-close to any given word.</li>

    </ul>

    <p class="text-gray-300">Here, by “replacing <span class="math">\\delta=0</span> by a larger <span class="math">\\delta&gt;0</span>” we refer to the <span class="math">\\delta</span>-correlated IOP that results from taking <span class="math">\\Pi_{0}</span> and replacing the verifier’s oracle for checking membership to <span class="math">\\mathsf{RS}[\\mathbb{F},D,d+1]</span> (so, checking <span class="math">0</span>-correlated agreement) by an oracle that checks for <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d+1]</span>.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Result 2. Given a <span class="math">\\delta</span>-correlated IOP <span class="math">\\Pi</span> with RBR soundness or knowledge <span class="math">\\varepsilon</span>, and given a IOP or IOP of Proximity <span class="math">\\Pi_{\\mathsf{CA}}</span> for checking <span class="math">\\delta</span>-correlated agreement, we can construct a new IOP (in the standard sense, i.e. an “uncorrelated IOP”), call it <span class="math">\\Pi_{\\mathsf{compiled}}</span>, by replacing the oracle <span class="math">\\mathcal{O}</span> with the protocol <span class="math">\\Pi_{\\mathsf{CA}}</span>. We show that, if <span class="math">\\Pi_{\\mathsf{CA}}</span> has RBR-soundness, then <span class="math">\\Pi_{\\mathsf{compiled}}</span> has RBR (knowledge) soundness <span class="math">\\max\\{\\varepsilon,\\varepsilon_{\\mathsf{CA}}\\}</span>.</li>

    </ul>

    <p class="text-gray-300">Notice that, for RBR knowledge soundness, we don’t need <span class="math">\\Pi_{\\mathsf{CA}}</span> to have RBR knowledge soundness. It suffices for <span class="math">\\Pi</span> to have RBR knowledge soundness, and for <span class="math">\\Pi_{\\mathsf{CA}}</span> to be RBR sound.</p>

    <p class="text-gray-300">First, we explain how these results can be applied to existing protocols, and afterward we provide an intuitive explanation of their proof.</p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Using the Above Results.</h5>

    <p class="text-gray-300">In views of these results, one strategy for proving that an IOP <span class="math">\\Pi</span> has RBR soundness or knowledge soundness is to, if possible, formulate the IOP as being a <span class="math">\\delta</span>-correlated IOP <span class="math">\\Pi</span> that has been compiled with the method mentioned above. Then, prove that the corresponding <span class="math">0</span>-correlated IOP has RBR soundness or knowledge. Once this is done, our results provide RBR knowledge and RBR soundness error bounds for the initial IOP <span class="math">\\Pi</span>. Figure 2 schematizes this workflow.</p>

    <p class="text-gray-300">The latter task can suppose a significant simplification in comparison to analyzing the initial IOP <span class="math">\\Pi</span> directly. This is because when <span class="math">\\delta=0</span>, the verifier in <span class="math">\\Pi</span> has an oracle for checking that the maps from the verifier’s Check 2 are polynomials of low degree. This effectively forces the prover to send (oracles to) low degree polynomials throughout the interaction, and to provide correct openings in its last message. As a consequence, and roughly speaking, our methods allows to study the IOP as if it was a <em>Polynomial</em> IOP (PIOP), with the batched FRI part acting as a Polynomial Commitment Scheme (PCS) used to compile the PIOP into an interactive argument. Note however that, formally, FRI cannot be used as a PCS since it only guarantees <span class="math">\\delta</span>-closeness to low degree polynomials.</p>

    <p class="text-gray-300">Later, we showcase how these methods can be used on “Plonk-type” protocols, and briefly discuss how to use them on other protocols such as ethSTARK and RISC Zero.</p>

    <h5 id="sec-35" class="text-base font-semibold mt-4">Proof Sketch of Result 1.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\delta&gt;0</span> and let <span class="math">\\Pi_{\\delta}</span> be a <span class="math">\\delta</span>-correlated IOP, and let <span class="math">\\Pi_{0}</span> be the same IOP except that the verifier has access to an oracle for <span class="math">0</span>-correlated agreement instead of <span class="math">\\delta</span>-correlated agreement (equivalently, it has an oracle for checking membership to <span class="math">\\mathsf{RS}[\\mathbb{F},D,d^{\\prime}+1]</span>, for any $d^{\\prime}<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). Suppose </span>\\Pi_{0}<span class="math"> is RBR sound or has RBR knowledge soundness with error </span>\\varepsilon<span class="math">. We focus first on RBR soundness, and discuss RBR knowledge soundness later. Let </span>\\tau<span class="math"> be a partial transcript produced during some rounds of interaction between the prover and the verifier from </span>\\Pi_{\\delta}<span class="math">. For ease of presentation, let us assume the prover simply sends maps to the verifier, as opposed to sending oracle access to these maps. Let </span>g_{1},\\ldots,g_{k}<span class="math"> be all prover’s maps in </span>\\tau<span class="math"> and write </span>\\tau=\\tau(g_{1},\\ldots,g_{k})<span class="math"> to reflect that </span>\\tau<span class="math"> contains such maps. Let </span>\\tau^{\\prime}=\\tau^{\\prime}(g_{1}^{\\prime},\\ldots,g_{k}^{\\prime})<span class="math"> be another partial transcript. We informally say </span>\\tau^{\\prime}<span class="math"> is a <em>low-degree-partial transcript</em> if all of the maps </span>g_{1}^{\\prime},\\ldots,g_{k}^{\\prime}<span class="math"> are codewords from </span>\\mathsf{RS}[\\mathbb{F},D,d+1]<span class="math">. We also say </span>\\tau^{\\prime}<span class="math"> has <em></span>\\delta<span class="math">-correlated agreement</em> with </span>\\tau<span class="math"> if there is </span>S\\subseteq D<span class="math"> such that </span>g_{i}<span class="math"> coincides with </span>g_{i}^{\\prime}<span class="math"> on </span>S<span class="math">, for all </span>i\\in[k]<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then we say that <span class="math">\\tau</span> is “doomed” in <span class="math">\\Pi_{\\delta}</span> if and only if one of the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All low-degree-partial transcripts <span class="math">\\tau^{\\prime}</span> that are <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span> are doomed in <span class="math">\\Pi_{0}</span>.</li>

      <li><span class="math">\\tau</span> is a complete transcript and Check 2 of the verifier fails, i.e. the maps quotients from Eq. 3 do not have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d+1]</span>.</li>

    </ul>

    <p class="text-gray-300">This defines the doomed states for <span class="math">\\Pi_{\\delta}</span>, i.e. the doomed states are those where the partial transcript so far is doomed.</p>

    <p class="text-gray-300">Now it remains to prove that <span class="math">\\Pi_{\\delta}</span> has RBR soundness or (RBR knowledge soundness) with error <span class="math">\\varepsilon/(2\\sqrt{\\rho}\\eta)</span>, with respect to these doomed states. In what follows we say that a partial transcript is <em>doomed in <span class="math">\\Pi_{\\delta}</span></em> or <em>in <span class="math">\\Pi_{0}</span></em> depending on whether it is doomed with respect to the doomed states of <span class="math">\\Pi_{\\delta}</span> or of <span class="math">\\Pi_{0}</span>, respectively. By a <span class="math">j</span>-round partial transcript we mean a partial transcript where both prover and verifier have sent <span class="math">j</span> messages each.</p>

    <p class="text-gray-300">Let <span class="math">\\tau</span> be a <span class="math">i</span>-partial transcript after that is doomed in <span class="math">\\Pi_{\\delta}</span>. By definition, all low-degree-partial transcripts that are <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span> are doomed in <span class="math">\\Pi_{0}</span>. Let <span class="math">m</span> be a prover’s message for Round <span class="math">i+1</span>. We want to show that the probability that <span class="math">(\\tau,m,c)</span> is not doomed in <span class="math">\\Pi_{\\delta}</span> is at most <span class="math">\\varepsilon/(2\\sqrt{\\rho}\\eta)</span>, where the probability is taken over the verifier’s <span class="math">(i+1)</span>-th message <span class="math">c</span>. Assume <span class="math">(\\tau,m,c)</span> is not doomed in <span class="math">\\Pi_{\\delta}</span> for some <span class="math">c</span>. Then, by definition of the doomed states of <span class="math">\\Pi_{\\delta}</span>, there is a low-degree-partial transcript <span class="math">\\nu</span> that is <span class="math">\\delta</span>-correlated with <span class="math">(\\tau,m,c)</span>, and that is not doomed in <span class="math">\\Pi_{0}</span>. This transcript</p>

    <p class="text-gray-300">must have the form <span class="math">\\nu=(\\tau^{\\prime},m^{\\prime},c)</span>, where <span class="math">\\tau^{\\prime}</span> is a <span class="math">i</span>-round low-degree-partial transcript that is <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span>. In particular, <span class="math">\\tau^{\\prime}</span> is doomed in <span class="math">\\Pi_{0}</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\Pi_{0}</span> is RBR sound with error <span class="math">\\varepsilon</span>, the fraction of challenges <span class="math">c</span> such that <span class="math">\\tau^{\\prime}</span> is doomed in <span class="math">\\Pi_{0}</span> but <span class="math">(\\tau^{\\prime},m^{\\prime},c)</span> is not, is at most <span class="math">\\varepsilon</span>. Thus the fraction of challenges <span class="math">c</span> such that <span class="math">\\tau</span> is doomed in <span class="math">\\Pi_{\\delta}</span> but <span class="math">(\\tau,m,c)</span> is not doomed in <span class="math">\\Pi_{\\delta}</span> is at most <span class="math">\\ell\\varepsilon</span>, where <span class="math">\\ell</span> is the number of <span class="math">i</span>-round low-degree-partial transcripts <span class="math">\\tau^{\\prime}</span> that are <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span>. Using a lemma from <em>[x21]</em> we bound <span class="math">\\ell</span> by <span class="math">1/(2\\sqrt{\\rho}\\eta)</span>.</p>

    <p class="text-gray-300">It remains to argue that doomed complete transcripts are rejected by the verifier. Let <span class="math">\\tau=\\tau(g_{1},\\ldots,g_{m})</span> be a doomed complete partial transcript, and let quotients be as in Eq. (3). If the maps quotients do not have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>, then the verifier rejects, and we are done. Hence assume they do have <span class="math">\\delta</span>-correlated agreement. Thus, for each <span class="math">i\\in[m]</span> and <span class="math">j\\in[n_{i}]</span> we have that <span class="math">(g_{i}(X)-g_{i}(k_{i,j}\\mathfrak{z}))/(X-k_{i,j}\\mathfrak{z})</span> agrees with a polynomial <span class="math">q_{i,j}(X)</span> on a set <span class="math">S</span> (this set is the same for all <span class="math">i,j</span>). In other words, <span class="math">g_{i}(X)</span> agrees with the polynomial</p>

    <p class="text-gray-300"><span class="math">u_{i,j}(X):=q_{i,j}(X)(X-k_{i,j}\\mathfrak{z})+g_{i}(k_{i,j}\\mathfrak{z})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">on <span class="math">S</span>. Moreover, both <span class="math">g_{i}</span> and <span class="math">u_{i,j}</span> take the same value on <span class="math">X=k_{i,j}\\mathfrak{z}</span>, i.e. <span class="math">g_{i}(k_{i,j}\\mathfrak{z})=u_{i,j}(k_{i,j}\\mathfrak{z})</span>. Additionally, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and by how </span>\\delta<span class="math"> is chosen, </span>(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d+1<span class="math">. This makes </span>u_{i,j}(X)<span class="math"> the same among all </span>j\\in[n_{i}]<span class="math">. As such we denote any </span>u_{i,j}(X)<span class="math"> simply as </span>u_{i}(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We have seen so far that <span class="math">g_{i}(X)</span> agrees with the polynomial <span class="math">u_{i}(X)</span> on <span class="math">S</span>, for all <span class="math">i\\in[m]</span>, and that <span class="math">g_{i}(k_{i,j}\\mathfrak{z})=u_{i}(k_{i,j}\\mathfrak{z})</span>, for all <span class="math">i,j</span>. Thus <span class="math">\\tau^{\\prime}=\\tau(u_{1},\\ldots,u_{m})</span> is a low-degree partial transcript that is <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span>. Since <span class="math">\\tau</span> is a doomed transcript and quotients have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>, we must have that <span class="math">\\tau^{\\prime}</span> is doomed in <span class="math">\\Pi_{0}</span>. Note that <span class="math">\\tau^{\\prime}</span> is a complete transcript, and so <span class="math">\\Pi_{0}</span>’s verifier rejects it. Clearly, <span class="math">\\tau^{\\prime}</span> passes the <span class="math">0</span>-correlated agreement check of <span class="math">\\Pi_{0}</span>’s verifier. Hence the first check of the verifier fails, i.e. the values <span class="math">\\left\\{u_{i}(k_{i,j}\\mathfrak{z})\\mid i\\in[m],j\\in[n_{i}]\\right\\}</span> do not satisfy the polynomial equations they are meant to satisfy. However, these values coincide with <span class="math">\\left\\{g_{i}(k_{i,j}\\mathfrak{z})\\mid i\\in[m],j\\in[n_{i}]\\right\\}</span>, and so the verifier of <span class="math">\\Pi_{\\delta}</span> rejects <span class="math">\\tau</span> because of the same reason: the values do not satisfy the polynomial equations they need to satisfy. This proofs that <span class="math">\\Pi_{\\delta}</span> has the claimed RBR soundness error.</p>

    <p class="text-gray-300">The proof that <span class="math">\\Pi_{\\delta}</span> has RBR knowledge soundness uses similar ideas. Precisely, suppose <span class="math">\\tau</span> is a <span class="math">i</span>-round partial transcript, doomed in <span class="math">\\Pi_{\\delta}</span>. Let <span class="math">m</span> be a prover’s <span class="math">(i+1)</span>-th round message, and assume the probability (over the verifier’s <span class="math">(i+1)</span>-th challenge <span class="math">c</span>) that <span class="math">(\\tau,m,c)</span> is not doomed is larger than <span class="math">\\varepsilon/(2\\sqrt{\\rho}\\eta)</span>. Since, as we argued, there are at most <span class="math">1/(2\\sqrt{\\rho}\\eta)</span> <span class="math">i</span>-round low-degree-partial transcripts <span class="math">\\tau^{\\prime}</span> that are <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span>, there must exist at least one such transcript <span class="math">\\tau^{\\prime}</span> that is doomed in <span class="math">\\Pi_{0}</span>, such that <span class="math">(\\tau^{\\prime},m^{\\prime},c)</span> is not doomed in <span class="math">\\Pi_{0}</span> with probability larger than <span class="math">\\varepsilon</span>. Then we can use the RBR knowledge soundness of <span class="math">\\Pi_{0}</span> to extract a valid witness from <span class="math">\\tau^{\\prime}</span>.</p>

    <p class="text-gray-300">Overall, we can build an extractor that, given <span class="math">\\tau</span>, computes all low-degree-partial transcripts <span class="math">\\tau^{\\prime}</span> that are <span class="math">\\delta</span>-correlated with <span class="math">\\tau</span>. This can be done in polynomial time using a method from <em>[x21]</em>. Then, for each such <span class="math">\\tau^{\\prime}</span>, the new extractor uses the extractor of <span class="math">\\Pi_{0}</span> on <span class="math">\\tau^{\\prime}</span>, until a valid witness is found.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Proof Sketch of Result 2.</h4>

    <p class="text-gray-300">The second general result stated above can be proved as follows: define a partial transcript <span class="math">\\tau</span> for <span class="math">\\Pi_{\\mathsf{compiled}}</span> to be doomed if one of the following hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau</span> is a non-complete partial transcript corresponding to some rounds of <span class="math">\\Pi</span>, and <span class="math">\\tau</span> is in a doomed state in <span class="math">\\Pi</span>.</li>

      <li><span class="math">\\tau</span> is a partial transcript of the form <span class="math">\\tau=(\\tau_{1},\\tau_{2})</span>, where <span class="math">\\tau_{1}</span> is a complete transcript of <span class="math">\\Pi</span>, and <span class="math">\\tau_{2}</span> is a (possibly empty) partial transcript corresponding to some rounds of <span class="math">\\Pi_{\\mathsf{CA}}</span>, and either</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau_{2}</span> is in a doomed state in <span class="math">\\Pi_{\\mathsf{CA}}</span>, or</li>

      <li>the verifier <span class="math">\\mathsf{V}_{\\Pi}</span> from <span class="math">\\Pi</span> would reject <span class="math">\\tau_{1}</span> due to Check 1 not passing.</li>

    </ol>

    <p class="text-gray-300">We then prove that <span class="math">\\Pi_{\\mathsf{compiled}}</span> is RBR sound (or has RBR knowledge soundness) with respect to these doomed states, with error <span class="math">\\max\\{\\varepsilon,\\varepsilon_{\\mathsf{CA}}\\}</span>. As before, we discuss first RBR soundness, and later RBR knowledge.</p>

    <p class="text-gray-300">The key observation is that if <span class="math">\\tau</span> is a non-complete doomed partial transcript of Type 1 above, then it remains doomed in the next round except with probability <span class="math">\\varepsilon</span>, due to the RBR soundness of <span class="math">\\Pi</span>. A similar argument can be used for a partial transcript of Type 2 of the form <span class="math">\\tau=(\\tau_{1},\\tau_{2})</span>, with <span class="math">\\tau_{2}\\neq\\emptyset</span>. The most noteworthy case is when <span class="math">\\tau</span> is of Type 2 and of the form <span class="math">\\tau=(\\tau_{1},\\emptyset)</span>, i.e. the case when <span class="math">\\tau</span> is exactly a complete transcript for <span class="math">\\Pi</span>. In this case, since <span class="math">\\tau</span> is doomed, the verifier <span class="math">\\mathsf{V}_{\\Pi}</span> in <span class="math">\\Pi</span> would reject <span class="math">\\tau</span>. Hence <span class="math">\\tau</span> fails either Check 1 or Check 2 of <span class="math">\\mathsf{V}_{\\Pi}</span>. In the first case, the probability of</p>

    <p class="text-gray-300">leaving the doomed state in <span class="math">\\Pi_{\\text{compiled}}</span> is <span class="math">0</span>, since any partial transcript <span class="math">\\tau^{\\prime}=(\\tau_{1}^{\\prime},\\tau_{2}^{\\prime})</span> of Type 2 such that <span class="math">\\tau_{1}^{\\prime}</span> fails Check 1 of <span class="math">\\mathsf{V}_{\\Pi}</span> is doomed by definition. In the latter case, <span class="math">\\Pi_{\\text{CA}}</span> is executed with input a set of words that do not have <span class="math">\\delta</span>-correlated agreement. As such, <span class="math">\\Pi_{\\text{CA}}</span> starts off in a doomed state, and so the probability that the state is not doomed in the next round of interaction is at most <span class="math">\\varepsilon_{\\text{CA}}</span>. This shows that <span class="math">\\Pi_{\\text{compiled}}</span> is RBR sound with error <span class="math">\\max\\{\\varepsilon,\\varepsilon_{\\text{CA}}\\}</span>.</p>

    <p class="text-gray-300">When it comes to RBR knowledge soundness, we make the following observations. First, we define doomed states for <span class="math">\\Pi_{\\text{compiled}}</span> as before, using the doomed states given by the RBR knowledge (as opposed to RBR soundness) for <span class="math">\\Pi</span>, and the doomed states given by the RBR soundness for <span class="math">\\Pi_{\\text{CA}}</span>. Now, let <span class="math">\\tau</span> be a doomed partial transcript for <span class="math">\\Pi_{\\text{compiled}}</span>. Assume the probability <span class="math">\\theta</span> that <span class="math">\\tau</span> stops being doomed at the next round is larger than <span class="math">\\max\\{\\varepsilon_{k},\\varepsilon_{\\text{CA}}\\}</span>, where <span class="math">\\varepsilon_{k}</span> is the RBR knowledge error of <span class="math">\\Pi</span>. Then, if <span class="math">\\tau</span> is of Type 1, we can use the extractor given by the RBR knowledge of <span class="math">\\Pi</span> to obtain a valid witness from <span class="math">\\tau</span>. On the other hand, we observe if <span class="math">\\theta&gt;\\max\\{\\varepsilon_{k},\\varepsilon_{\\text{CA}}\\}</span> then <span class="math">\\tau=(\\tau_{1},\\tau_{2})</span> cannot be of Type 2 because:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\tau_{2}</span> is in a doomed state in <span class="math">\\Pi_{\\text{CA}}</span>, then by definition of RBR soundness, the probability that <span class="math">\\tau_{2}</span> is not doomed in the next round of <span class="math">\\Pi_{\\text{CA}}</span> is at most <span class="math">\\varepsilon_{\\text{CA}}</span>.</li>

      <li>If <span class="math">\\tau_{1}</span> would be rejected by <span class="math">\\Pi</span>’s verifier due to Check 1 failing, then the partial transcript will be doomed at the next round because of the same reason, and so in this case <span class="math">\\tau</span> has probability <span class="math">0</span> of not being doomed in the next round.</li>

    </ul>

    <p class="text-gray-300">In other words, doomed partial transcripts of Type 2 are always doomed at the next round, except with probability at most <span class="math">\\max\\{\\varepsilon_{k},\\varepsilon_{\\text{CA}}\\}</span>. Thus, we do not need to describe an extractor for this type of partial transcripts.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">This approach yields better RBR soundness bounds than some prior known methods. For example, in <em>[x10]</em> the authors introduce RedShift, a Plonk-like IOP. The authors obtain a RBR knowledge error (modulo FRI) for RedShift which has a factor of the form, roughly, <span class="math">\\ell^{m}</span>, where <span class="math">\\ell</span> is the aforementioned “maximum list decoding set size”, and <span class="math">m</span> is the number of oracles sent by the prover during the interactive phase. For RedShift, <span class="math">m</span> is set to <span class="math">6</span>, but similar (though not fully identical) protocols such as Plonky2 <em>[x14]</em> use <span class="math">m\\geq 130</span>. On the contrary, as we mention later in this paper, with our method the factor <span class="math">\\ell^{m}</span> would be reduced to <span class="math">\\ell</span>. We remark again that <em>[x10]</em> also does not obtain FS security of their protocol, as that work does not analyze the FS security of FRI.</p>

    <p class="text-gray-300">In Section 2.5 we also point out that, when applied to the ethSTARK protocol, our approach leads to a better knowledge soundness than the one in <em>[x16]</em> (this improvement was already demonstrated in <em>[x11]</em>).</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">2.4 Round-by-round Knowledge of Plonk-like Protocols</h3>

    <p class="text-gray-300">We generalize and abstract Plonk-like protocols as a correlated IOP, which we call <span class="math">\\mathsf{OPlonky}</span>, where again by “Plonk-like” we specifically mean the interactive oracle proof abstractions underlying the protocols related to and built upon the Plonk SNARK. The abstraction is inspired mostly on Plonky2 <em>[x14]</em>, which we believe to be one of the most general Plonk-like IOP’s published currently.</p>

    <p class="text-gray-300">The protocol <span class="math">\\mathsf{OPlonky}</span> is an IOP for a Plonk-like relation <span class="math">\\mathbf{R}_{\\mathbf{ROPlonky}}</span> (related to <em>[x12]</em>), which generalizes arithmetic circuit satisfiability and seamlessly supports custom gates. Simplifying greatly, an instance of <span class="math">\\mathbf{R}_{\\mathbf{ROPlonky}}</span> is characterized by some multivariate polynomial equations <span class="math">P_{1}=0,\\ldots,P_{k}=0</span>, two integers <span class="math">\\mathsf{n},\\mathsf{r}</span> representing the dimensions of a matrix (usually called <em>execution trace</em>), and a permutation <span class="math">\\sigma:[n]\\times[r]\\to[n]\\times[r]</span>. An input and witness pair <span class="math">(\\pi,\\mathrm{w})</span> satisfies such an instance if <span class="math">\\mathrm{w}</span> is a <span class="math">n\\times r</span> matrix of field elements, <span class="math">\\pi</span> is a vector of field elements, and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The values in each row <span class="math">\\mathrm{w}_{i}</span> of <span class="math">\\mathrm{w}</span> satisfy <span class="math">P_{1}(\\mathrm{w}_{i})=\\ldots=P_{k}(\\mathrm{w}_{i})=0</span>.</li>

      <li>Certain pre-specified cells in <span class="math">\\mathrm{w}</span> have the values <span class="math">\\pi</span>.</li>

      <li>The entries in <span class="math">\\mathrm{w}</span> satisfy the <em>copy constraints</em> induced by <span class="math">\\sigma</span>. More precisely, <span class="math">\\mathrm{w}_{(i,j)}=\\mathrm{w}_{\\sigma(i,j)}</span> for all <span class="math">i,j\\in[n]\\times[r]</span>.</li>

    </ul>

    <p class="text-gray-300">The IOP <span class="math">\\mathsf{OPlonky}</span> proceeds in the following 4-round process. For the sake of presentation, we provide a greatly simplified exposition.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round 1. The prover sends <span class="math">r</span> polynomials <span class="math">a_{1}(X),\\ldots,a_{r}(X)</span> of degree <span class="math">&lt;n</span> to the verifier as oracles. Each of these polynomials is the result of interpolating the columns of <span class="math">\\mathrm{w}</span> over a multiplicative subgroup <span class="math">H</span> of <span class="math">\\mathbb{F}</span> or order <span class="math">n</span>. The verifier then replies with some random challenges.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round 2. The prover uses the verifier randomness from the prior round, to construct and send oracle access to so-called <em>permutation polynomials</em> <span class="math">\\pi_{1}(X),\\ldots,\\pi_{s}(X)</span> of degree less than <span class="math">n</span>. These polynomials will later be used to (again roughly) check that the copy constraints are satisfied. The verifier responds with a random challenge <span class="math">\\alpha</span>.</li>

      <li>Round 3. At this point, the goal of the prover is to convince the verifier that the polynomials</li>

    </ol>

    <p class="text-gray-300"><span class="math">Q_{j}:=P_{j}(a_{1}(X),\\ldots,a_{r}(X))</span></p>

    <p class="text-gray-300">and certain polynomials of the form</p>

    <p class="text-gray-300"><span class="math">\\delta_{i}(X):=R_{i}(\\pi_{1}(X),\\ldots,\\pi_{s}(X))</span></p>

    <p class="text-gray-300">vanish on <span class="math">H</span>, where the <span class="math">R_{i}0</span> is certain multivariate polynomial. To this end, the prover <em>batches</em> these constraints together by computing</p>

    <p class="text-gray-300"><span class="math">d(X)=Q_{1}(X)+\\alpha Q_{2}(X)+\\ldots+\\alpha^{k-1}Q_{k}(X)+\\alpha^{k}\\delta_{1}(X)+\\ldots+\\alpha^{k+s-1}\\delta_{s}(X)</span> (4)</p>

    <p class="text-gray-300">and proving that <span class="math">d(X)</span> vanishes in <span class="math">H</span>. To do so, the prover sends the verifier oracle access to the polynomial <span class="math">q(X):=d(X)/\\mathsf{Z}_{H}(X)</span>, where <span class="math">\\mathsf{Z}_{H}(X)</span> is the vanishing polynomial of <span class="math">H</span>.</p>

    <p class="text-gray-300">The verifier replies with a random field element <span class="math">\\mathfrak{z}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round 4. The prover replies with the values <span class="math">(a_{i}(\\mathfrak{z}))_{i},(\\pi_{j}(\\mathfrak{z}))_{j}</span> and <span class="math">q(\\mathfrak{z})</span>.</li>

      <li>Verification phase. The verifier performs two assertions. It accepts the proof if and only if both of them return true.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assert whether <span class="math">q(\\mathfrak{z})\\mathsf{Z}_{H}(\\mathfrak{z})=d(\\mathfrak{z})</span>, where the value <span class="math">d(\\mathfrak{z})</span> is obtained by replacing <span class="math">X</span> by <span class="math">\\mathfrak{z}</span> in Eq. 4, and querying the oracles to <span class="math">a_{1}(X),\\ldots,a_{r}(X),\\pi_{1}(X),\\ldots,\\pi_{s}(X)</span> .</li>

      <li>Use an oracle to assert whether the following set of words has <span class="math">\\delta</span>-correlated agreement in certain Reed-Solomon code:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left\\{\\frac{q(X)-q(\\mathfrak{z})}{X-\\mathfrak{z}},\\ \\left(\\frac{a_{i}(X)-q(\\mathfrak{z})}{X-\\mathfrak{z}}\\right)_{i},\\ \\left(\\frac{\\pi_{j}(X)-q(\\mathfrak{z})}{X-\\mathfrak{z}}\\right)_{j}\\right\\}.</span></p>

    <p class="text-gray-300">It is apparent from the description above that <span class="math">\\mathsf{OPlonky}</span> is indeed a <span class="math">\\delta</span>-correlated IOP.</p>

    <p class="text-gray-300">When compiled with the batched FRI protocol, <span class="math">\\mathsf{OPlonky}_{\\mathsf{compiled}}</span> becomes almost identical to Plonky2’s IOP <em>[x12]</em>, a general Plonk-like IOP based on the FRI protocol, with some similarities to Redshift <em>[x10]</em>. Alternatively, <span class="math">\\mathsf{OPlonky}</span> could also be compiled somehow with the KZG commitment scheme (which, in a sense, can act as a protocol for <span class="math">0</span>-correlated agreement). This would yield generalized versions of the original Plonk protocol and its variations (e.g., TurboPlonk). We leave this as future work.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">2.4.1 Round-by-round Soundness of <span class="math">\\mathsf{OPlonky}</span></h4>

    <p class="text-gray-300">With the above observations in mind, we then go on to show that <span class="math">\\mathsf{OPlonky}</span> with <span class="math">\\delta=0</span> has RBR soundness and knowledge. We now provide an intuitive idea of the proof, focusing on RBR soundness. To do so, we use the simplified description of <span class="math">\\mathsf{OPlonky}</span> provided above. As such, our analysis and resulting error bounds are also simplified.</p>

    <p class="text-gray-300">We let <span class="math">\\mathsf{OPlonky}^{O}</span> denote the <span class="math">\\mathsf{OPlonky}</span> protocol where the verifier has oracle access to <span class="math">0</span>-correlated agreement oracle <span class="math">O</span>. To prove that <span class="math">\\mathsf{OPlonky}^{O}</span> has RBR soundness and knowledge, we need to define a set of “doomed states” the protocol can be in. See Section 2.1 for intuition on RBR soundness and knowledge. As a general rule, we will always set the state to “doomed” if the prover has sent the verifier an oracle to a map that is not a polynomial of appropriate degree. As argued in Section 2.3, in this scenario it is impossible for a malicious prover to “recover” and eventually convince the verifier, since the verifier will detect the dishonesty when using <span class="math">O</span> in its Check 2. Moreover, by similar reasons, we can also assume that the prover provides correct openings as its last message.</p>

    <p class="text-gray-300">Next we describe the rest of scenarios in which we set the state to “doomed”, and analyse the probabilities of “recovering”, i.e., of not being in a doomed set in the next round. We proceed in a round-by-round fashion.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given an input <span class="math">\\pi</span> for the relation <span class="math">\\mathbf{R_{ROPlonky}}</span>, if <span class="math">\\pi</span> is not in the language <span class="math">\\mathcal{L}_{\\mathbf{R_{ROPlonky}}}</span> induced by <span class="math">\\mathbf{R_{ROPlonky}}</span>, we set the state to “doomed”.</li>

      <li>Now assume that, at the end of Round 1, it is not possible for the prover to compute polynomials <span class="math">\\pi_{1}(X),\\ldots,\\pi_{s}(X)</span> of degree <span class="math">&lt;n</span> such that all the polynomials <span class="math">\\delta_{i}(X)</span> vanish on <span class="math">H</span>. Then we set the state to “doomed”.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We see that, if the state was doomed before Round 1, then the chances of receiving verifier randomness such that the state is not doomed at the end of Round 1 are, roughly, $\\mathsf{rn}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. This probability comes from the soundness of permutation checking procedure used in Plonk and many other protocols.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now suppose that, right at the end of Round 2, the polynomial <span class="math">d(X)</span> does not vanish on <span class="math">\\mathsf{Z}_{H}(X)</span>. Then we set the state to “doomed”.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case, the probability of starting Round 2 in a doomed state and finishing it in a non-doomed state is at most, roughly, $(k+s)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This is deduced by taking an arbitrary </span>x\\in H<span class="math"> and looking at the equality </span>d(x)=0<span class="math"> as a polynomial equation on </span>\\alpha<span class="math">. This equation either has degree </span>\\approx k+s<span class="math"> (on </span>\\alpha<span class="math">), or it is identically zero. However, we see that if Round 2 started in a doomed state, then </span>R(x)=0<span class="math"> is not identically zero for at least one </span>x\\in H<span class="math">. Hence, there are at most </span>\\approx k+s<span class="math"> distinct values of </span>\\alpha<span class="math"> such that </span>d(x)=0<span class="math"> for all </span>x\\in H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above argument, at a high-level, establishes the round-by-round security of the <span class="math">0</span>-correlated hIOP <span class="math">\\mathsf{OPlonky}^{O}</span>; complete details are given in Sections 6 and 7.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Round-by-round Knowledge of RISC Zero.</h4>

    <p class="text-gray-300">RISC Zero <em>[x23]</em> is similar to the Plonky2 protocol. More precisely, and modulo technicalities, it can be thought of as being built on top of <span class="math">\\mathsf{OPlonky}</span> with the addition that RISC Zero implements a lookup argument <em>[x13]</em> in the same round as the permutation check is performed. We believe that similar methods as the ones exposed in the previous section can be used to establish the RBR knowledge soundness of RISC Zero, and thus, the knowledge soundness of the Fiat-Shamir transformed version of RISC Zero. Since RISC Zero’s whitepaper is in draft form at the moment of writing, we leave formally proving this claim as an open task.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">2.5 Round-by-round Knowledge of ethSTARK</h3>

    <p class="text-gray-300">We begin by discussing the ethSTARK protocol <span class="math">\\Pi_{\\mathsf{ethSTARK}}</span> <em>[x24]</em>, which is a close variation of the DEEP-ALI protocol <em>[x3]</em>. We briefly provide a rough overview of the protocol; see <em>[x24]</em> for complete details.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Description of the protocol</h4>

    <p class="text-gray-300">In <span class="math">\\Pi_{\\mathsf{ethSTARK}}</span>, first the honest prover sends oracle access to a list of degree <span class="math">\\leq d</span> polynomials <span class="math">f_{1},\\ldots,f_{m}</span> that interpolate the columns of a so-called Algebraic Intermediate Representation (AIR) instance over a multiplicative subgroup <span class="math">H</span> of a field <span class="math">\\mathbb{F}</span> (simply put, these polynomials encode the witness). Supposedly, these polynomials are such that certain maps of the form</p>

    <p class="text-gray-300"><span class="math">\\frac{Q_{i}(X,f_{1}(g_{i,1}X),\\ldots,f_{m}(g_{i,m}X))}{Z_{H_{i}}(X)},\\quad i\\in I,</span> (5)</p>

    <p class="text-gray-300">are polynomials of low-degree. Here, each <span class="math">Q_{i}(X,Y_{1},\\ldots,Y_{m})</span> is a pre-specified <span class="math">(m+1)</span>-variate polynomial; the <span class="math">g_{i,j}</span>’s are field elements; <span class="math">Z_{H_{i}}(X)</span> is the vanishing polynomial of a subgroup <span class="math">H_{i}</span> of <span class="math">H</span>; and <span class="math">I</span> is a list of indices.</p>

    <p class="text-gray-300">####</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier replies with $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> random elements </span>r_{1},r^{\\prime}_{1},\\ldots,r_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},r^{\\prime}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> from a field extension </span>\\mathbb{K}<span class="math"> of </span>\\mathbb{F}<span class="math">. As its second message, the honest prover sends oracle access to low degree polynomials </span>q_{1}(X),\\ldots,q_{k}(X)$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in I}(r_{i}+r^{\\prime}_{i}X^{c_{i}})\\frac{Q_{i}(X,f_{1}(g_{i,1}X),\\ldots,f_{m}(g_{i,m}X))}{Z_{H_{i}}(X)}=\\sum_{j=1}^{k}X^{j-1}q_{j}(X^{k})</span> (6)</p>

    <p class="text-gray-300">where the <span class="math">c_{i}</span>’s are pre-agreed positive integers such that that each summand on the left-hand side of 6 has the same degree, and <span class="math">k</span> is a conveniently pre-agreed positive integer. The reason why the prover sends <span class="math">k</span> polynomials <span class="math">q_{1}(X),\\ldots,q_{k}(X)</span> instead of just one polynomial <span class="math">q(X)</span> that equals the left-hand side of 6 is because the degree of <span class="math">q(X)</span> would be “too large”, and hence it is “split” into low degree polynomials.</p>

    <p class="text-gray-300">The verifier replies with a field element <span class="math">\\mathfrak{z}</span> uniformly sampled in a large subset <span class="math">S</span> of <span class="math">\\mathbb{K}</span>. The honest prover replies with evaluations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\{f_{1}(g_{i,j}\\mathfrak{z}),\\ldots,f_{m}(g_{i,j}\\mathfrak{z}),q_{1}(\\mathfrak{z}),\\ldots,q_{k}(\\mathfrak{z})\\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ i\\in I,j\\in[m]\\right\\}.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, the verifier checks that 6 holds after replacing <span class="math">X</span> by <span class="math">\\mathfrak{z}</span> (using the purported evaluations in 7), and it engages with the prover in the batched FRI protocol to verify that the following maps have <span class="math">\\delta</span>-correlated agreement in an appropriate Reed-Solomon code:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\{\\frac{f_{j}(X)-f_{j}(g_{i,j}\\mathfrak{z})}{X-g_{i,j}\\mathfrak{z}}\\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ i\\in I,j\\in[m]\\right\\}\\bigcup\\left\\{\\frac{q_{t}(X)-q_{t}(\\mathfrak{z})}{X-\\mathfrak{z}}\\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ t\\in[k]\\right\\}.$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">RBR knowledge soundness of the protocol</h4>

    <p class="text-gray-300">It is clear that <span class="math">\\Pi_{\\text{ethSTARK}}</span> is the compilation of a <span class="math">\\delta</span>-correlated IOP using the batched FRI protocol for <span class="math">\\delta</span>-correlated agreement. Thus, one can prove that <span class="math">\\Pi_{\\text{ethSTARK}}</span> has RBR (knowledge) soundness by showing that the underlying <span class="math">\\delta</span>-correlated IOP has RBR (knowledge) soundness when <span class="math">\\delta=0</span>. Once this is done, we obtain as a consequence that compiling <span class="math">\\Pi_{\\text{ethSTARK}}</span> with Merkle-tree commitments and the Fiat-Shamir transformation (i.e., the BCS transform) yields a knowledge sound succinct non-interactive argument, i.e., a SNARK.</p>

    <p class="text-gray-300">Here, the “underlying <span class="math">\\delta</span>-correlated IOP” is precisely the protocol <span class="math">\\Pi_{\\text{ethSTARK}}</span> without applying batched FRI. Instead, we assume the verifier has an oracle that allows for checking <span class="math">\\delta</span>-correlated agreement of the maps that are batched together in batched FRI. These are the quotient polynomials in 8.</p>

    <p class="text-gray-300">As we mentioned, due to our results (Theorem 1.5), it suffices to analyse the RBR knowledge soundness when <span class="math">\\delta=0</span>. This corresponds to the case when the verifier has an oracle for checking that the maps of 8 are low-degree polynomials. Note that if the maps in 8 have <span class="math">0</span>-correlated agreement, then so do all the (oracles to) maps sent by the adversary during the protocol execution. This is because if a map of the form <span class="math">(h(X)-y)/(X-z)</span> for constants <span class="math">y,z</span> agree with a polynomial <span class="math">q(X)</span> on a set <span class="math">S</span>, then <span class="math">h(X)</span> agrees with the polynomial <span class="math">q(X)(X-z)+y</span> on the same set <span class="math">S</span>. Moreover, for any map <span class="math">h(X)</span> sent by the prover there is a map of the form <span class="math">(h(X)-y)/(X-z)</span> in the list of 8. Hence we only need consider adversaries that send (oracles to) low-degree polynomials. Moreover, the check for <span class="math">0</span>-correlated agreement also forces the prover to provide correct openings for 7.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a <span class="math">1</span>-round partial transcript is doomed if the left-hand side of 6 is not a polynomial of appropriate degree. We say that a <span class="math">2</span>-round partial transcript is doomed if 6 does not hold for the received challenge <span class="math">\\mathfrak{z}</span>. Clearly, if a <span class="math">1</span>-round partial transcript is doomed, then a <span class="math">2</span>-round partial transcript is doomed except with probability $d^{\\prime}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>d^{\\prime}<span class="math"> is the degree of the polynomial equation obtained from 6 after multiplying it by </span>Z_{H}(X)<span class="math"> on each side. Also clearly, any doomed </span>2<span class="math">-round partial transcript is eventually rejected by the verifier, no matter how it is completed, since 6 does not hold for </span>X=\\mathfrak{z}<span class="math">. Finally, if </span>f_{1}(X),\\ldots,f_{m}(X)<span class="math"> do not “encode a valid witness”, then by how the AIRs are constructed, not all maps in 5 are polynomials of appropriate degree. Then we claim there are at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> tuples </span>(r_{1},r^{\\prime}_{1},\\ldots,r_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},r^{\\prime}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> such that the right-hand side of 6 is a polynomial of appropriate degree. If the claim is true, then an incorrect initial message </span>f_{1}(X),\\ldots,f_{m}(X)<span class="math"> leads to a doomed state after Round </span>1<span class="math"> except with probability </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. To prove the claim, consider the expression</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in I}(r_{i}+r^{\\prime}_{i}X^{c_{i}})Q_{i}(X,f_{1}(g_{i,1}X),\\ldots,f_{m}(g_{i,m}X))\\frac{Z_{H}(X)}{Z_{H_{i}}(X)}</span> (9)</p>

    <p class="text-gray-300">where we view <span class="math">Z_{H}(X)/Z_{H_{i}}(X)</span> as a polynomial since <span class="math">Z_{H_{i}}(X)</span> divides <span class="math">Z_{H}(X)</span>. Then the right-hand side of 6 is a polynomial of appropriate degree if and only if 9 vanishes on <span class="math">H</span>. The latter means that for each <span class="math">x\\in H</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">elements $(r_{1},r^{\\prime}_{1},\\ldots,r_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},r^{\\prime}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$ form a solution to the equation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in I}(r_{i}+r^{\\prime}_{i}x^{c_{i}})Q_{i}(x,f_{1}(g_{i,1}x),\\ldots,f_{m}(g_{i,m}x))\\frac{Z_{H}(x)}{Z_{H_{i}}(x)}=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">on the variables <span class="math">\\{r_{i},r^{\\prime}_{i}\\mid i\\in I\\}</span>. Unless the right-hand side of the equation is identically zero, there are at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> such solutions. On the other hand, if for all </span>x\\in H<span class="math"> the right-hand side of the equation was identically zero, then each of the maps 5 would be polynomials of appropriate degree (recall that the adversary is constrained to sending low-degree polynomials), contradicting the assumption that </span>f_{1}(X),\\ldots,f_{m}(X)$ encode an incorrect witness. This proves the claim.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that, in its <span class="math">0</span>-correlated form, <span class="math">\\Pi_{\\text{ethSTARK}}</span> has RBR soundness and RBR knowledge soundness with error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{0}:=\\max\\{1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d^{\\prime}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, due to the results from Sections 2.2 and 2.3, <span class="math">\\Pi_{\\text{ethSTARK}}</span> (as an IOP) has RBR (knowledge) soundness</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon:=\\max\\{\\ell/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ell d^{\\prime}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\ell=1/(2\\sqrt{\\rho}\\eta)</span> (here <span class="math">\\rho</span> and <span class="math">\\eta</span> are parameters related to the RS codes used within the protocol), and <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{bFRI}}</span> is the RBR soundness error of batched FRI.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark 2.2.</h6>

    <p class="text-gray-300">This analysis can be used to derive a knowledge soundness error for <span class="math">\\Pi_{\\text{ethSTARK}}</span> that slightly improves the one from <em>[x20]</em>. This improvement is already demonstrated in <em>[x13]</em>. Using the notation of Theorem 4 in <em>[x20]</em>, the improved knowledge soundness error is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\ell\\frac{\\text{d}_{\\max}+2^{\\text{h}}+\\text{a}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\text{a}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\varepsilon_{\\text{FRI}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Precisely, the improvement consists in having the factor <span class="math">\\ell</span> in the second summand, instead of <span class="math">\\ell^{2}</span>.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">2.6 From Round-by-round Soundness to Fiat-Shamir Security</h3>

    <p class="text-gray-300">As stated in Section 2.1, we utilize the BCS transformation for IOPs due to Ben-Sasson et al. <em>[x1]</em> to compile our round-by-round sound IOPs into secure non-interactive protocols in the random oracle model. At a high level, the transformation works by first compressing oracles sent by the prover with a Merkle tree <em>[x11]</em>; i.e., instead of sending oracle <span class="math">f</span> to the verifier, the prover sends <span class="math">M_{f}</span>, where <span class="math">M_{f}</span> is the root of the Merkle tree with leaves corresponding to <span class="math">f</span> (in some canonical way). Then whenever the verifier would query oracle <span class="math">f</span> at position <span class="math">i</span>, instead the prover provides the verifier with pair <span class="math">(f(i),\\pi_{i})</span>, where <span class="math">\\pi_{i}</span> is the Merkle authentication path for proving that <span class="math">f(i)</span> is consistent with <span class="math">M_{f}</span>. Finally, once the IOP is transformed in this way, it is then compressed using Fiat-Shamir to obtain a non-interactive protocol.</p>

    <p class="text-gray-300">Ben-Sasson et al. showed that applying the BCS transformation to an IOP yields a secure non-interactive protocol in the random oracle model if the IOP satisfied a notion of soundness called <em>state-restoration soundness</em>, which roughly says that the IOP remains secure even if the prover is allows to rewind the verifier to any prior state at most <span class="math">b</span> times for some upper bound <span class="math">b\\geq 1</span>; see <em>[x1]</em> for full details. However, it is known that round-by-round soundness is an upper bound on state-restoration soundness: in particular, if a protocol has state-restoration soundness error <span class="math">\\varepsilon_{\\text{sr}}(b)</span> and round-by-round soundness error <span class="math">\\varepsilon_{\\text{rbr}}</span>, then <span class="math">\\varepsilon_{\\text{sr}}(b)\\leq b\\varepsilon_{\\text{rbr}}</span> <em>[x6, x7, x12]</em>. Moreover, Chiesa et al. <em>[x6, x7]</em> showed that if an IOP is both round-by-round sound and round-by-round knowledge sound, then the BCS transformed IOP is both (adaptively) sound and (adaptively) knowledge sound versus both classical and quantum adversaries in the random oracle model.</p>

    <p class="text-gray-300">Applying BCS to FRI and Batched FRI directly gives us a SNARK in the random oracle model, establishing the Fiat-Shamir security for FRI and Batched FRI (i.e., Corollary 1.4). Similarly, for <span class="math">\\mathsf{OPlonky}^{\\mathcal{O}}</span>, we replace the <span class="math">\\delta</span>-correlated oracle <span class="math">\\mathcal{O}</span> with the Batched FRI protocol, leveraging our <span class="math">\\delta</span>-correlated IOP techniques to obtain a round-by-round sound IOP. Then again applying BCS to <span class="math">\\mathsf{OPlonky}</span> composed with Batched FRI gives us a SNARK in the random oracle model, establishing the Fiat-Shamir security of <span class="math">\\mathsf{OPlonky}</span> composed with Batched FRI (i.e., Corollary 1.11). Finally, our results allow us to obtain FS security for a variety of Plonk-like protocols; see Section 7.3 for details.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any positive integer <span class="math">m</span>, we let <span class="math">[m]</span> denote the set <span class="math">\\{1,\\ldots,m\\}</span>. Throughout this work, we let <span class="math">\\mathbb{F}</span> denote a finite field of prime <span class="math">p</span> elements and let <span class="math">\\mathbb{F}^{<em>}:=\\mathbb{F}\\setminus\\{0\\}</span> denote the multiplicative group of <span class="math">\\mathbb{F}</span>. Moreover, we let <span class="math">\\mathbb{F}[X]</span> denote the set of all univariate polynomials with coefficients in <span class="math">\\mathbb{F}</span> and indeterminate <span class="math">X</span>, and we let <span class="math">\\mathbb{F}^{\\leq k}[X]</span> denote the set of all univariate polynomials of degree at most <span class="math">k</span>. Given a subset <span class="math">S\\subseteq\\mathbb{F}</span>, by <span class="math">\\mathsf{Z}_{S}(X)</span> we denote the vanishing polynomial on <span class="math">S</span>, which is defined as <span class="math">\\mathsf{Z}_{S}(X):=\\prod_{s\\in S}(X-s)</span>. We say that <span class="math">L\\subseteq\\mathbb{F}^{</em>}</span> is a multiplicative subgroup if it is closed under multiplication; i.e., if <span class="math">x,y\\in L</span> then <span class="math">x\\cdot y\\in L</span>. Given <span class="math">\\omega\\in\\mathbb{F}</span>, we let <span class="math">\\langle\\omega\\rangle:=\\{1,\\omega,\\omega^{2},\\ldots,\\omega^{p-1}\\}</span> denote the multiplicative subgroup of <span class="math">\\mathbb{F}^{*}</span> generated by <span class="math">\\omega</span>. When $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\omega\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we say that </span>\\omega<span class="math"> is a </span>n<span class="math">-th primitive root of unity and sometimes denote such a root of unity as </span>\\omega_{n}<span class="math">. For any finite set </span>S<span class="math">, we let </span>s\\xleftarrow{s}S<span class="math"> denote the process of sampling an element of </span>S<span class="math"> uniformly and independently at random. Finally, for two finite sets </span>A,B<span class="math"> , we let </span>A^{B}<span class="math"> denote the set of maps of the form </span>f\\colon B\\to A<span class="math">. When given some fixed ordering of </span>B<span class="math">, we sometimes view </span>f<span class="math"> as the vector </span>(a_{1},\\ldots,a_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> where </span>f(b_{i})=a_{i}\\in A<span class="math"> for </span>b_{i}\\in B<span class="math">. We refer to </span>f\\in A^{B}<span class="math"> indistinctly as a word, a vector, or a map. In the latter case we use functional notation such as </span>f(X)<span class="math"> and </span>f(a),a\\in A$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For two vectors <span class="math">u,v\\in\\mathbb{F}^{n}</span>, we let <span class="math">\\Delta(u,v)</span> denote the relative Hamming distance between <span class="math">u</span> and <span class="math">v</span>, defined as $\\Delta(u,v):=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{u_{i}\\neq v_{i}\\mid i\\in[n]\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n<span class="math">. Moreover, for a set of vectors </span>S\\subset\\mathbb{F}^{n}<span class="math"> and any vector </span>u\\in\\mathbb{F}^{n}<span class="math">, we define </span>\\Delta(u,S)=\\Delta(S,u):=\\min_{v\\in S}\\{\\Delta(u,v)\\}<span class="math">. For </span>\\delta\\in(0,1)<span class="math">, we say that </span>u<span class="math"> is </span>\\delta<span class="math">-far from </span>S<span class="math"> if </span>\\Delta(u,S)\\geq\\delta<span class="math">; otherwise, we say that </span>u<span class="math"> is </span>\\delta<span class="math">-close to </span>S<span class="math">. Equivalently, </span>u<span class="math"> is </span>\\delta<span class="math">-far from </span>S<span class="math"> if </span>\\Delta(u,v)\\geq\\delta<span class="math"> for all </span>v\\in S<span class="math">, and </span>u<span class="math"> is </span>\\delta<span class="math">-close to </span>S<span class="math"> if there exists </span>v^{<em>}\\in S<span class="math"> such that </span>\\Delta(u,v^{</em>})<\\delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">3.1 Reed-Solomon Codes</h3>

    <p class="text-gray-300">Reed-Solomon codes <em>[x20]</em>, or <span class="math">\\mathsf{RS}</span> codes in short, are an extremely well-studied and widely used class of linear error correcting codes. In our case, we shall consider <span class="math">\\mathsf{RS}</span> codes parameterized by a finite field <span class="math">\\mathbb{F}</span>, a multiplicative subgroup <span class="math">L\\subseteq\\mathbb{F}^{*}</span>, and a degree bound <span class="math">d\\in\\mathbb{N}</span>. The code <span class="math">\\mathsf{RS}[\\mathbb{F},L,d]</span> is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{RS}[\\mathbb{F},L,d]:=\\left\\{(f(z))_{z\\in L}\\in\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mid f\\in\\mathbb{F}[X],\\deg(f)<d\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, <span class="math">\\mathsf{RS}[\\mathbb{F},L,d]</span> consists of vectors in $\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, where each vector is defined as the evaluation of a polynomial in </span>\\mathbb{F}[X]<span class="math"> of degree less than </span>d<span class="math"> at all points in </span>L<span class="math"> (in some canonical ordering). Note that </span>\\mathsf{RS}[\\mathbb{F},L,d]<span class="math"> in </span>\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> of dimension </span>d<span class="math">. Throughout this work, we assume that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{n}<span class="math">, </span>d=2^{k}<span class="math"> are integer powers of two with </span>k\\leq n/2<span class="math">. The rate of the </span>\\mathsf{RS}<span class="math"> code is defined as </span>\\rho:=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">. For our purposes, we require some additional structure on the subgroup </span>L<span class="math">; in particular, we require that </span>x\\in L\\iff\\omega_{k}^{i}\\cdot x\\in L<span class="math"> for all </span>i\\in[k-1]<span class="math"> where </span>\\omega_{k}<span class="math"> is a primitive </span>k<span class="math">-th root of unity in </span>\\mathbb{F}$. For ease of presentation, we refer to such a subgroup as a smooth multiplicative subgroup.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">\\mathsf{RS}[\\mathbb{F},L,d]</span> is <span class="math">(\\delta,\\ell)</span>-list decodable if for all $u\\in\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> there are at most </span>\\ell<span class="math"> codewords in </span>\\mathsf{RS}[\\mathbb{F},L,d]<span class="math"> that are within relative Hamming distance at most </span>\\delta<span class="math"> from </span>u$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-47" class="text-base font-medium mt-4">Theorem 3.1 (Johnson bound).</h6>

    <p class="text-gray-300">For every <span class="math">\\eta\\in(0,1-\\sqrt{\\rho})</span>, the code <span class="math">\\mathsf{RS}[\\mathbb{F},L,d]</span> is <span class="math">(1-\\sqrt{\\rho}-\\eta,1/(2\\eta\\sqrt{\\rho}))</span>-list decodable.</p>

    <p class="text-gray-300">A key notion we make use of in our work (both implicitly and explicitly) is that of correlated agreement with the Reed-Solomon code.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 3.2 (Correlated agreement <em>[BCI^{+}20, x23]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V=\\mathsf{RS}[\\mathbb{F},L,d]</span> and <span class="math">W=\\{w_{1},\\ldots,w_{k}\\}</span>, <span class="math">w_{k}\\in\\mathbb{F}^{L}</span> be a sequence of maps. Let <span class="math">\\delta\\in(0,1)</span>. We say <span class="math">W</span> has <span class="math">\\delta-</span>correlated agreement with <span class="math">V</span> if there exists <span class="math">S\\subseteq L</span>, called <em>set of agreement</em>, such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 1-\\delta<span class="math"> and there exists </span>v_{1},\\ldots,v_{k}\\in V<span class="math"> such that </span>w_{i}<span class="math"> agrees with </span>v_{i}<span class="math"> on </span>S<span class="math">. In this case we say that </span>W<span class="math"> and </span>\\{v_{1},\\ldots,v_{k}\\}<span class="math"> have </span>\\delta<span class="math">-correlated agreement on </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say <span class="math">S</span> is a <em>maximal</em> agreement domain if no set strictly containing <span class="math">S</span> is an agreement domain.</p>

    <p class="text-gray-300">Another technical tool we utilize is a so-called correlated agreement list decoder.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma 3.3 (Correlated agreement list decoder <em>[x23]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">V=\\mathsf{RS}[\\mathbb{K},L,d]</span> and <span class="math">W=\\{w_{1},\\ldots,w_{k}\\}</span>, $w_{k}\\in\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> be a sequence of vectors. Let </span>\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and let </span>\\delta=1-\\sqrt{\\rho}-\\eta<span class="math"> for some </span>\\eta>0$. Then there exists a randomized</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm running in expected time polynomial in $1/\\rho,1/\\eta,k,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that outputs a list </span>\\mathcal{S}=\\{S_{1},\\ldots,S_{\\ell}\\}<span class="math"> of all maximal </span>\\delta<span class="math">-correlated agreement sets of density at least </span>1-\\delta<span class="math">, and </span>\\ell\\leq 1/2\\eta\\sqrt{\\rho}<span class="math">. Additionally, for each </span>S_{i}<span class="math"> and </span>w_{j}\\in W<span class="math">, the element </span>v_{i,j}\\in V<span class="math"> that agrees with </span>w_{j}<span class="math"> on </span>S_{i}$ is uniquely defined.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">3.2 Interactive Oracle Proofs</h3>

    <p class="text-gray-300">A relation <span class="math">\\mathbf{R}</span> is a subset of pairs <span class="math">(\\pi;\\mathrm{w})\\in\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}</span>. The strings <span class="math">\\pi</span> are called inputs, statements, or instances, and the strings <span class="math">\\mathrm{w}</span> are called witnesses. To each relation <span class="math">\\mathbf{R}</span> there corresponds a language <span class="math">L_{\\mathbf{R}}\\subseteq\\{0,1\\}^{*}</span> consisting of all statements <span class="math">\\pi</span> such that <span class="math">(\\pi,\\mathrm{w})\\in\\mathbf{R}</span> for some <span class="math">\\mathrm{w}</span>. An indexed relation is a set of triples <span class="math">(\\mathrm{i},\\pi;\\mathrm{w})</span>. Intuitively, the index <span class="math">\\mathrm{i}</span> is fixed at setup time, and each <span class="math">\\mathrm{i}</span> determines a relation <span class="math">\\mathbf{R}_{\\mathrm{i}}:=\\left\\{(\\pi,\\mathrm{w})\\mid(\\mathrm{i},\\pi,\\mathrm{w})\\in\\mathbf{R}\\right\\}</span>. For example, in the indexed relation of satisfiable arithmetic circuit, the index <span class="math">\\mathrm{i}</span> is a description of a circuit, the statement <span class="math">\\mathrm{i}</span> is the value taken by the “public” wires in the circuit, and the witness <span class="math">\\mathrm{w}</span> is the value taken by the remaining “private” wires.</p>

    <p class="text-gray-300">Given a map <span class="math">f\\in A^{B}</span> for some sets <span class="math">A,B</span>, we denote by <span class="math">\\llbracket f\\rrbracket</span> an oracle to the map <span class="math">f</span>. This is a hypothetical algorithm that takes elements <span class="math">a\\in A</span> as input, and outputs <span class="math">f(a)</span> instantaneously. Given a vector of maps <span class="math">f=(f_{1},\\ldots,f_{n})</span>, where <span class="math">f_{i}\\in A_{i}^{B_{i}}</span> for some sets <span class="math">A_{i},B_{i}</span> for all <span class="math">i</span>, we let <span class="math">\\llbracket f\\rrbracket:=(\\llbracket f_{1}\\rrbracket,\\ldots,\\llbracket f_{n}\\rrbracket)</span>.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 3.4 ((Holographic) Interactive Oracle Proofs (hIOP)).</h6>

    <p class="text-gray-300">A <span class="math">\\mu</span>-round interactive oracle proof for a relation <span class="math">\\mathbf{R}</span> is a tuple of interactive algorithms <span class="math">\\Pi=(\\mathsf{P},\\mathsf{V})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\pi\\in L_{\\mathbf{R}}</span> and <span class="math">\\mathrm{w}</span> such that <span class="math">(\\pi,\\mathrm{w})\\in\\mathbf{R}</span>, before the start of the protocol, <span class="math">\\mathsf{P}</span> receives both <span class="math">(\\pi,\\mathrm{w})</span> as input and <span class="math">\\mathsf{V}</span> receives <span class="math">\\pi</span> as input.</li>

      <li><span class="math">\\mathsf{P}(\\pi,\\mathrm{w})</span> and <span class="math">\\mathsf{V}(\\pi)</span> exchange <span class="math">2\\mu(\\pi)+1</span> messages, where <span class="math">\\mathsf{P}</span> sends the first and last message, and during any round of interaction <span class="math">\\mathsf{P}</span> sends message <span class="math">m_{i}</span> and <span class="math">\\mathsf{V}</span> receives oracle access to <span class="math">m_{i}</span> via <span class="math">\\llbracket m_{i}\\rrbracket</span>. After <span class="math">\\mathsf{P}</span> sends <span class="math">m_{\\mu(\\pi)+1}</span>, <span class="math">\\mathsf{V}</span> either accepts or rejects.</li>

    </ul>

    <p class="text-gray-300">We require the following properties to hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\delta</span>-Completeness: for all <span class="math">(\\pi,\\mathrm{w})\\in\\mathbf{R}</span>, we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}\\left[\\langle\\mathsf{P}(\\mathrm{w}),\\mathsf{V}\\rangle(\\pi)=1\\right]\\geq\\delta,</span></p>

    <p class="text-gray-300">where <span class="math">\\langle\\mathsf{P}(\\mathrm{w}),\\mathsf{V}\\rangle(\\pi)</span> denotes the output of <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> interacting on common input <span class="math">\\pi</span> where <span class="math">\\mathsf{P}</span> is additionally given <span class="math">\\mathrm{w}</span> as input, and the above probability holds over the random coins of <span class="math">\\mathsf{V}</span>. If <span class="math">\\delta=1</span> for all <span class="math">\\pi</span> then the protocol is perfectly complete.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\epsilon</span>-Soundness: for any <span class="math">\\pi\\notin L_{\\mathbf{R}}</span> and any unbounded interactive algorithm <span class="math">\\mathsf{P}^{*}</span>, we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}\\left[\\langle\\mathsf{P}^{*},\\mathsf{V}\\rangle(\\pi)=1\\right]\\leq\\epsilon,</span></p>

    <p class="text-gray-300">where the probability is taken over the random coins of <span class="math">\\mathsf{V}</span>.</p>

    <p class="text-gray-300">We say that <span class="math">\\Pi</span> is <em>public-coin</em> if all messages sent by <span class="math">\\mathsf{V}</span> are independent uniform random strings of some bounded length and the output of <span class="math">\\mathsf{V}</span> does not depend on any secret state.</p>

    <p class="text-gray-300">A <span class="math">\\mu</span>-round holographic IOP for an indexed relation <span class="math">\\mathbf{R}</span> is a tuple of interactive algorithms <span class="math">\\Pi=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V})</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <em>indexer <span class="math">\\mathsf{Ind}</span></em> is a deterministic non-interactive polynomial-time algorithm that on input an index <span class="math">\\mathrm{i}</span> outputs an *encoding <span class="math">\\mathsf{Ind}(\\mathrm{i})</span>.</li>

      <li>For any fixed <span class="math">\\mathrm{i}</span>, <span class="math">\\mathsf{P}^{\\prime}(\\cdot):=\\mathsf{P}(\\mathsf{Ind}(\\mathrm{i}),\\cdot)</span>, and <span class="math">\\mathsf{V}^{\\prime}(\\cdot):=\\mathsf{V}^{\\llbracket\\mathsf{Ind}(\\mathrm{i})\\rrbracket}</span>, the tuple <span class="math">(\\mathsf{P}^{\\prime},\\mathsf{V}^{\\prime})</span> is a <span class="math">\\mu(\\mathrm{i},\\pi)</span>-round IOP for the relation <span class="math">\\mathbf{R}_{\\mathrm{i}}</span> with <span class="math">\\delta(\\mathrm{i})</span> completeness and <span class="math">\\epsilon(\\mathrm{i})</span> soundness.</li>

    </ul>

    <h6 id="sec-52" class="text-base font-medium mt-4">Remark 3.5.</h6>

    <p class="text-gray-300">In this work, we assume that the computation of <span class="math">\\mathsf{Ind}(\\mathrm{i})</span> is always carried out by a trusted party. Furthermore, all (h)IOPs in this work are assumed to be public-coin.</p>

    <p class="text-gray-300">Also important in this work is the notion of an <em>IOP of Proximity</em> (IOPP) <em>[x1]</em>. Since we are only concerned about proximity to the space of Reed-Solomon codewords, we define an IOPP with respect to these codes.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 3.6 (IOP of Proximity (IOPP) for Reed-Solomon Codes).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{RS}</span> denote the space $\\mathsf{RS}[\\mathbb{F},L,d]\\subset\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> of Reed-Solomon codewords with evaluation domain </span>L<span class="math"> over finite field </span>\\mathbb{F}<span class="math"> and degree bound </span>d<span class="math">. A </span>\\mu<span class="math">-round interactive oracle proof of proximity for </span>\\mathsf{RS}<span class="math"> is a pair of interactive algorithms </span>(\\mathsf{P},\\mathsf{V})<span class="math"> is a </span>\\mu$-round IOP with the following modifications:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First message format: the first prover message <span class="math">f_{0}\\colon L\\to\\mathbb{F}</span> is a purported codeword of <span class="math">\\mathsf{RS}</span>.</li>

      <li>Perfect Completeness: <span class="math">\\Pr[\\langle\\mathsf{P},\\mathsf{V}\\rangle=1\\mid\\Delta(f_{0},\\mathsf{RS})=0]=1</span>.</li>

      <li><span class="math">\\epsilon</span>-Soundness: For any unbounded <span class="math">\\mathsf{P}^{<em>}</span>, <span class="math">\\Pr[\\langle\\mathsf{P}^{</em>},\\mathsf{V}\\rangle=1\\mid\\Delta(f_{0},\\mathsf{RS})\\geq\\delta]\\leq\\epsilon</span>.</li>

    </ul>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 3.7 (Honest Verifier Zero-Knowledge).</h6>

    <p class="text-gray-300">We say that an IOP <span class="math">(\\mathsf{P},\\mathsf{V})</span> for relation <span class="math">\\mathbf{R}</span> has <span class="math">z</span>-statistical honest-verifier zero-knowledge if there exists a probabilistic polynomial-time simulator algorithm <span class="math">S</span> such that for every <span class="math">(\\pi,\\pi)\\in\\mathbf{R}</span>, the distribution <span class="math">S(\\pi)</span> is <span class="math">z(\\pi)</span>-close to the distribution <span class="math">\\mathsf{View}_{\\langle\\mathsf{P}(\\pi),\\mathsf{V}\\rangle(\\pi)}(\\mathsf{V}(\\pi))</span>. Here, we let <span class="math">\\mathsf{View}_{\\langle\\mathsf{P}(\\pi),\\mathsf{V}\\rangle(\\pi)}(\\mathsf{V}(\\pi))</span> denote the random variable denoting all values the <span class="math">\\mathsf{V}</span> queries from oracles provided by <span class="math">\\mathsf{P}</span>, along with any messages from <span class="math">\\mathsf{P}</span> that <span class="math">\\mathsf{V}</span> reads in full, during the interaction <span class="math">\\langle\\mathsf{P}(\\pi),\\mathsf{V}\\rangle(\\pi)</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 3.8.</h6>

    <p class="text-gray-300">Let <span class="math">H\\subseteq\\mathbb{F}</span> and <span class="math">d\\geq 0</span>. An indexed <span class="math">(\\mathbb{F},H,d)</span>-polynomial oracle relation <em>[2]</em> <span class="math">\\mathbf{R}</span> is an indexed relation where for each <span class="math">(\\i,\\pi,\\pi)\\in\\mathbf{R}</span>, the index <span class="math">\\i</span> and input <span class="math">\\pi</span> may contain oracles to codewords from <span class="math">\\mathsf{RS}[\\mathbb{F},H,d]</span>, and the actual codewords corresponding to these oracles are contained in <span class="math">\\pi</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Remark 3.9.</h6>

    <p class="text-gray-300">Note that the notion indexed polynomial oracle relations generalizes indexed relations and “standard” relations. For technical reasons, most of our results are stated for indexed polynomial oracle relations. Correspondingly, they also apply for simple indexed relations or relations. The notion of (h)IOP’s for indexed relations generalizes naturally to the notion of (h)IOP’s for indexed <span class="math">(\\mathbb{F},H,d)</span>-polynomial oracle relations.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 3.10 (Correlated Agreement).</h6>

    <p class="text-gray-300">Let <span class="math">0\\leq\\delta&lt;1</span>. By the <span class="math">\\delta</span>-correlated agreement relation for <span class="math">\\mathsf{RS}[\\mathbb{F},H,d]</span> we refer to the following indexed <span class="math">(\\mathbb{F},H,d)</span>-polynomial oracle relation:</p>

    <p class="text-gray-300">\\[ \\mathbf{CoAgg}:=\\left\\{\\begin{pmatrix}\\mathfrak{i}\\\\ \\pi\\\\ \\pi\\end{pmatrix}=\\begin{pmatrix}(\\mathbb{F},D,d,\\delta,r)\\\\ (\\llbracket f_{i}\\rrbracket)_{i\\in[r]}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(f_{i})_{i\\in[r]}\\end{pmatrix}\\right.\\quad\\begin{vmatrix}r,\\delta\\geq 0,\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">f_{i}\\in\\mathbb{F}^{H}\\ \\forall i\\in[r],\\\\ (f_{i})_{i\\in[r]}\\text{ has }\\delta\\text{-correlated}\\\\ \\text{ agreement with }\\mathsf{RS}[\\mathbb{F},H,d]\\end{pmatrix}. \\]</p>

    <p class="text-gray-300">Given <span class="math">0\\leq\\delta_{0}&lt;1</span>, we denote by <span class="math">\\mathbf{CoAgg}(\\delta_{\\mathbf{0}})</span> the subset of <span class="math">\\mathbf{CoAgg}</span> whose proximity parameter in the index is <span class="math">\\delta=\\delta_{0}</span>. Notice that, when <span class="math">\\delta=0</span>, the relation <span class="math">\\mathbf{CoAgg}(\\mathbf{0})</span> requires that the witness maps <span class="math">(f_{i})_{i\\in[r]}</span> are all codewords from <span class="math">\\mathsf{RS}[\\mathbb{F},H,d]</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 3.11 (Oracles for relations).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{R}</span> be an indexed relation. By oracle for <span class="math">\\mathbf{R}</span> we denote a hypothetical black-box algorithm <span class="math">\\mathcal{O}_{\\mathbf{R}}</span> that, on input arbitrary <span class="math">(\\mathfrak{i},\\pi)</span> where <span class="math">\\mathfrak{i}</span> is a valid index of <span class="math">\\mathbf{R}</span>, and <span class="math">\\pi</span> is an arbitrary input, instantly outputs whether <span class="math">\\pi\\in\\mathcal{L}_{\\mathbf{R}_{\\mathfrak{i}}}</span> or not.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">3.3 Round-by-round Soundness and Knowledge</h3>

    <p class="text-gray-300">We recall the notions of <em>round-by-round soundness</em> <em>[CCH^{+}19]</em> and <em>round-by-round knowledge</em> <em>[CMS19]</em> for interactive protocols. For round-by-round soundness, we use a definition due to Holmgren <em>[Holmgren19]</em>. This equivalent definition formulates round-by-round soundness in terms of a “doomed set” of partial transcripts (as opposed to using a “state function” for partial transcripts). For round-by-round knowledge, we modify the original definition from <em>[CMS19]</em> in an analogous way.</p>

    <p class="text-gray-300">Before we continue, we need to introduce some terminology. Given <span class="math">\\mathfrak{i}</span>, a <em>complete transcript</em> for an input <span class="math">\\mathfrak{i}</span> is a sequence of the form <span class="math">(\\pi,m_{1},c_{1},\\ldots,m_{\\mu},c_{\\mu},m_{\\mu+1})</span>, where the <span class="math">m_{i}</span>’s and <span class="math">c_{i}</span>’s are, respectively, prover’s and verifier’s messages while interacting during the execution of protocol <span class="math">\\Pi</span> on input <span class="math">\\mathfrak{i},\\pi</span> (and a witness for the prover). A <em>partial transcript</em> is a suffix of a complete transcript. A <em><span class="math">i</span>-round partial transcript</em> is a partial transcript of the form <span class="math">(\\pi,m_{1},c_{1},\\ldots,m_{i},c_{i})</span>. Throughout the paper we let <span class="math">\\mathcal{C}_{i}</span> denote the set of all potential verifier’s challenges at Round <span class="math">i</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 3.12 (Round-by-Round Soundness).</h6>

    <p class="text-gray-300">A (public-coin) holographic IOP <span class="math">\\Pi=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V})</span> for an indexed relation <span class="math">\\mathbf{R}</span> has round-by-round soundness with error <span class="math">\\varepsilon</span> if for all index <span class="math">\\mathbbm{i}</span> there exists a (not necessarily efficiently computable) “doomed set” <span class="math">\\mathcal{D}(\\mathbbm{i})</span> of partial and complete transcripts such that the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathbbm{x}\\notin\\mathcal{L}_{\\mathbf{R}_{\\mathbbm{i}}}</span>, then <span class="math">(\\mathbbm{x},\\emptyset)\\in\\mathcal{D}(\\mathbbm{i})</span>, where <span class="math">\\emptyset</span> denotes the empty transcript.</li>

      <li>For any complete transcript <span class="math">\\tau</span>, if <span class="math">(\\mathbbm{x},\\tau)\\in\\mathcal{D}(\\mathbbm{i})</span> then <span class="math">V^{\\mathsf{Ind}(\\mathbbm{i})}(\\mathbbm{x},\\tau)=\\mathsf{reject}</span>.</li>

      <li>If <span class="math">i\\in[\\mu]</span> and <span class="math">(\\mathbbm{x},\\tau)</span> is a <span class="math">(i-1)</span>-round partial transcript such that <span class="math">(\\mathbbm{x},\\tau)\\in\\mathcal{D}(\\mathbbm{i})</span>, then for every potential prover next message <span class="math">m</span>, it holds that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr_{c\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}C_{i}}[(\\mathbbm{x},\\tau,m,c)\\notin\\mathcal{D}(\\mathbbm{i})]\\leq\\varepsilon(\\mathbbm{i}).</span></p>

    <p class="text-gray-300">Definition 3.12 naturally extends to hPIOP’s for indexed polynomial oracle relations.</p>

    <p class="text-gray-300">The following notion was introduced in <em>[x10]</em> using the concept of a “state function”. Here, following the definition above, we formulate it using a doomed set of partial transcripts.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 3.13 (Round-by-Round Knowledge).</h6>

    <p class="text-gray-300">A (public-coin) holographic IOP <span class="math">\\Pi</span> for an indexed relation <span class="math">\\mathbf{R}</span> has round-by-round knowledge with error <span class="math">\\varepsilon_{\\mathrm{k}}</span> if there exists a polynomial-time extractor <span class="math">\\mathsf{Ext}</span> and for all <span class="math">\\mathbbm{i}</span> there exists a (not necessarily efficiently computable) “doomed set” <span class="math">\\mathcal{D}(\\mathbbm{i})</span> of partial and complete transcripts such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathbbm{x},\\emptyset)\\in\\mathcal{D}(\\mathbbm{i})</span> for all possible input <span class="math">\\mathbbm{x}</span>, regardless of whether <span class="math">\\mathbbm{x}\\in\\mathcal{L}_{\\mathbf{R}_{\\mathbbm{i}}}</span> or not.</li>

      <li>For any possible input <span class="math">\\mathbbm{x}</span> and any complete transcript <span class="math">(\\mathbbm{x},\\tau)</span>, if <span class="math">(\\mathbbm{x},\\tau)\\in\\mathcal{D}(\\mathbbm{i})</span> then <span class="math">V^{\\mathsf{Ind}(\\mathbbm{i})}(\\mathbbm{x},\\tau)=\\mathsf{reject}</span>.</li>

      <li>If <span class="math">i\\in[\\mu]</span> and <span class="math">(\\mathbbm{x},\\tau)</span> is a <span class="math">(i-1)</span>-round partial transcript such that <span class="math">(\\mathbbm{x},\\tau)\\in\\mathcal{D}(\\mathbbm{i})</span>, then for every potential prover next message <span class="math">m</span>, it holds that, if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr_{c\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}C_{i}}[(\\mathbbm{x},\\tau,m,c)\\notin\\mathcal{D}(\\mathbbm{i})]&gt;\\varepsilon_{\\mathrm{k}}(\\mathbbm{i}),</span></p>

    <p class="text-gray-300">then <span class="math">\\mathsf{Ext}(\\mathbbm{i},\\mathbbm{x},\\tau,m)</span> outputs a valid witness for <span class="math">\\mathbbm{x}</span>.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">3.4 The BCS Transformation for IOPs</h3>

    <p class="text-gray-300">The BCS transformation <em>[x3]</em> turns any IOP <span class="math">\\Pi=(\\mathsf{P},\\mathsf{V})</span> into a non-interactive argument. Informally speaking, this is achieved by giving access to <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> to a random oracle <span class="math">\\rho</span>. Then, every time that <span class="math">\\mathsf{P}</span> would send to <span class="math">\\mathsf{V}</span> oracle access to a map <span class="math">m:S\\to\\{0,1\\}^{<em>}</span>, instead it sends the Merkle tree root of the vector <span class="math">(m(s))_{s\\in S}</span>, using <span class="math">\\rho</span> as the “hash function”. Then, when <span class="math">\\mathsf{V}</span> wants to query <span class="math">m</span> at some point <span class="math">s\\in S</span>, the prover sends the value <span class="math">m(s)</span> to <span class="math">\\mathsf{V}</span>, along with a Merkle tree path certifying that <span class="math">m(s)</span> is a correct opening. Finally, to protocol is made non-interactive via the Fiat-Shamir transformation using the random oracle <span class="math">\\rho</span>. We refer to </em>[x3]* for a formal description of this transformation.</p>

    <p class="text-gray-300">It turns out that applying the BCS construction to a round-by-round sound IOP <span class="math">\\Pi</span> with round-by-round knowledge soundness yields a SNARK; i.e., a succinct non-interactive argument of knowledge <em>[x10]</em>. Moreover, if <span class="math">\\Pi</span> is zero-knowledge, then so is the resulting SNARK. Specifically, BCS compiles round-by-round sound IOPs into non-interactive random oracle proofs.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Definition 3.14 (Non-Interactive Random Oracle Proofs <em>[x3]</em>).</h6>

    <p class="text-gray-300">A non-interactive random oracle proof for a relation <span class="math">\\mathbf{R}</span> is a pair of probabilistic oracle algorithms <span class="math">(\\mathbb{P},\\mathbb{V})</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: for every <span class="math">(\\mathbbm{x},\\mathbbm{w})\\in\\mathbf{R}</span> and <span class="math">\\lambda\\in\\mathbb{N}</span>, we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbb{V}^{\\rho}(\\mathbbm{x},\\pi)=1\\mid\\rho\\leftarrow\\mathcal{U}(\\lambda),\\pi\\leftarrow\\mathbb{P}^{\\rho}(\\mathbbm{x},\\mathbbm{w})\\right]=1.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\epsilon</span>-Soundness: For every <span class="math">\\mathbbm{x}\\notin L_{\\mathbf{R}}</span>, <span class="math">Q</span>-query <span class="math">\\tilde{\\mathbb{P}}</span>, and <span class="math">\\lambda\\in\\mathbb{N}</span>, we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbb{V}^{\\rho}(\\mathbbm{x},\\pi)=1\\mid\\rho\\leftarrow\\mathcal{U}(\\lambda),\\pi\\leftarrow\\tilde{\\mathbb{P}}^{\\rho}\\right]\\leq\\epsilon(\\mathbbm{x},Q,\\lambda).</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{U}(\\lambda)</span> denotes the uniform distribution over all functions <span class="math">\\rho\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span>, and <span class="math">\\rho\\leftarrow\\mathcal{U}(\\lambda)</span> is the random oracle.</p>

    <p class="text-gray-300">We say that <span class="math">(\\mathbb{P},\\mathbb{V})</span> is a <em>proof of knowledge</em> with error <span class="math">\\epsilon_{\\mathrm{k}}</span> if there exists a PPT extractor algorithm <span class="math">\\mathbb{E}</span> such that for every <span class="math">\\mathrm{x}</span>, <span class="math">Q</span>-query <span class="math">\\hat{\\mathbb{P}}</span>. and <span class="math">\\lambda\\in\\mathbb{N}</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\left(\\mathrm{x},\\mathbb{E}^{\\hat{\\mathbb{P}}}(\\mathrm{x},1^{Q},1^{\\lambda})\\right)\\in\\mathbf{R}\\right]\\geq\\Pr\\left[\\mathbb{V}^{\\rho}(\\mathrm{x},\\pi)=1\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\rho\\leftarrow\\mathcal{U}(\\lambda)\\cr\\pi\\leftarrow\\mathbb{P}^{\\rho}\\end{array}\\right.\\right]-\\epsilon_{\\mathrm{k}}(\\mathrm{x},Q,\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we say that <span class="math">(\\mathbb{P},\\mathbb{V})</span> has <span class="math">z</span>-statistical zero-knowledge (in the explicitly programmable random oracle model) if there exists a probabilistic polynomial-time simulator <span class="math">\\mathbb{S}</span> such that for every <span class="math">(\\mathrm{x},\\mathrm{w})\\in\\mathbf{R}</span>, <span class="math">\\lambda\\in\\mathbb{N}</span>, and unbounded distinguisher <span class="math">D</span>, the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[D^{\\rho[\\mu]}(\\pi)=1\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\rho\\leftarrow\\mathcal{U}(\\lambda)\\cr(\\pi,\\mu)\\leftarrow\\mathbb{D}^{\\rho}(\\mathrm{x})\\end{array}\\right.\\right]-\\Pr\\left[D^{\\rho}(\\pi)=1\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}\\rho\\leftarrow\\mathcal{U}(\\lambda)\\cr\\pi\\leftarrow\\mathbb{P}^{\\rho}(\\mathrm{x},\\mathrm{w})\\end{array}\\right.\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq z(\\mathrm{x},\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, <span class="math">\\rho<a href="x">\\mu</a>=\\mu(x)</span> if <span class="math">\\mu(x)</span> is defined and <span class="math">\\rho<a href="x">\\mu</a>=\\rho(x)</span> otherwise.</p>

    <p class="text-gray-300">Below we state a “meta” theorem which captures all the relevant properties of the BCS transformation that we utilize in this work.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 3.15 (<em>[x1, x4, x5]</em>).</h6>

    <p class="text-gray-300">There exists a polynomial-time transformation <span class="math">\\mathsf{BCS}</span> such that for every relation <span class="math">\\mathbf{R}</span>, random oracle <span class="math">\\mathcal{H}\\colon\\{0,1\\}^{*}\\to\\{0,1\\}^{\\kappa}</span>, and random oracle query bound <span class="math">Q\\in\\mathbb{N}</span>, if <span class="math">(\\mathsf{P},\\mathsf{V})</span> is a public-coin IOP for <span class="math">\\mathcal{R}</span> with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proofs of length <span class="math">\\ell(\\mathrm{x})</span>;</li>

      <li>verifier query complexity <span class="math">q(\\mathrm{x})</span>;</li>

      <li>round-by-round soundness error <span class="math">\\varepsilon_{\\mathrm{rbr}}(\\mathrm{x})</span>;</li>

      <li>round-by-round knowledge error <span class="math">\\varepsilon_{\\mathrm{rbr-k}}(\\mathrm{x})</span>; and</li>

      <li><span class="math">z(\\mathrm{x})</span>-statistical honest-verifier zero-knowledge,</li>

    </ul>

    <p class="text-gray-300">then <span class="math">(\\mathbb{P},\\mathbb{V})\\coloneqq\\mathsf{BCS}^{\\mathcal{H}}(\\mathsf{P},\\mathsf{V})</span> is a non-interactive random oracle proof system for <span class="math">\\mathbf{R}</span> with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>adaptive soundness error <span class="math">\\varepsilon_{\\mathrm{fs}}(\\mathrm{x},Q,\\kappa)=Q\\varepsilon_{\\mathrm{rbr}}(\\mathrm{x})+3(Q^{2}+1)/2^{\\kappa}</span> and adaptive knowledge error <span class="math">\\varepsilon_{\\mathrm{fs-k}}(\\mathrm{x},Q,\\kappa)=Q\\varepsilon_{\\mathrm{rbr-k}}(\\mathrm{x})+3(Q^{2}+1)/2^{\\kappa}</span> against <span class="math">Q</span>-query adversaries;</li>

      <li>adaptive soundness error <span class="math">\\varepsilon_{\\mathrm{qfs}}(\\mathrm{x},Q,\\kappa)=\\Theta(Q\\cdot\\varepsilon_{\\mathrm{fs}}(\\mathrm{x}))</span> and adaptive knowledge error <span class="math">\\varepsilon_{\\mathrm{qfs-k}}(\\mathrm{x},Q,\\kappa)=\\Theta(Q\\cdot\\varepsilon_{\\mathrm{fs-k}}(\\mathrm{x}))</span> against <span class="math">Q-O(q(\\mathrm{x})\\log(\\ell(\\mathrm{x})))</span>-query quantum adversaries; and</li>

      <li>statistical zero-knowledge <span class="math">z^{\\prime}(\\mathrm{x},\\kappa)\\coloneqq z(\\mathrm{x})+4\\ell(\\mathrm{x})/2^{\\kappa/4}</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, the above results also hold if <span class="math">\\mathbf{R}</span> is an indexed relation and <span class="math">(\\mathsf{Ind},\\mathsf{P},\\mathsf{V})</span> is a holographic public-coin IOP for <span class="math">\\mathbf{R}</span> with the same complexities.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Remark 3.16 (Prover Time, Verifier Time, and Proof Lengths).</h6>

    <p class="text-gray-300"><em>Ben-Sasson et al. [x1]</em> also give a detailed analysis of the time complexities of <span class="math">\\mathbb{P}</span> and <span class="math">\\mathbb{V}</span> under the transformation, along with the size of the non-interactive proof. We omit these details as we are mainly concerned with soundness in this work; see <em>[x1]</em> for complete details.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">3.5 The Plonk SNARK</h3>

    <p class="text-gray-300">Plonk <em>[x7]</em> is a pre-processing SNARK with a universal structured reference string (SRS). Plonk improves on its predecessor Sonic <em>[x10]</em> mainly on prover efficiency metrics. The improvements come from the more direct arithmetization of a circuit compared to <em>[x10]</em>.</p>

    <p class="text-gray-300">####</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">Plonk’s Arithmetization.</h4>

    <p class="text-gray-300">Plonk’s constraint system captures arithmetic circuits with fan-in two and unlimited fan out. Assuming <span class="math">n</span> gates in the circuit and <span class="math">m</span> wires. The constraint system has two constituents: <span class="math">\\mathcal{V}=(\\mathbf{a},\\mathbf{b},\\mathbf{c})</span>, where <span class="math">\\mathbf{a},\\mathbf{b},\\mathbf{c}\\in[m]^{n}</span> and are respectively the left input, right input and output sequence for the gates; the second constituent is a list of selector vectors <span class="math">\\mathcal{Q}=(q_{L},q_{R},q_{O},q_{M},q_{C})\\in(\\mathbb{F}^{n})^{5}</span>. Every constraint in Plonk is then viewed as the following equality:</p>

    <p class="text-gray-300"><span class="math">q_{L}\\cdot x_{\\mathbf{a}}+q_{R}\\cdot x_{\\mathbf{b}}+q_{O}\\cdot x_{\\mathbf{c}}+q_{M}\\cdot x_{\\mathbf{a}}\\cdot x_{\\mathbf{b}}+q_{c}=0</span></p>

    <p class="text-gray-300">Here <span class="math">x_{a},x_{b},x_{c}</span> are wire values for the corresponding gates with labels <span class="math">a,b</span>, and <span class="math">c</span>. Such equations capture addition and multiplication gates with ease. For example, a multiplication gate computing <span class="math">x_{\\mathbf{c}}=x_{\\mathbf{a}}x_{\\mathbf{b}}</span>, take <span class="math">q_{M}=1,q_{O}=-1</span> and <span class="math">q_{L}=q_{R}=q_{C}=0</span>.</p>

    <p class="text-gray-300">With the above abstraction, any NP relation can then be converted into a corresponding algebraic circuit where each gate is modeled using Plonk constraints <span class="math">\\{(a_{i},b_{i},c_{i},sels_{i})\\}_{i\\in[n]}</span>. All the constraints can then be compiled into the following equation:</p>

    <p class="text-gray-300"><span class="math">(Q_{l}\\cdot A+Q_{r}\\cdot B+Q_{o}\\cdot C+Q_{m}\\cdot A\\cdot B+Q_{c})\\;(X)=0</span></p>

    <p class="text-gray-300">Here, the witness to the NP relation is encoded by polynomials <span class="math">A,B,C</span>, and the polynomial <span class="math">Q</span> represents the circuit.</p>

    <h4 id="sec-68" class="text-lg font-semibold mt-6">Plonk Over Polynomials.</h4>

    <p class="text-gray-300">Given the described constraint system, pre-processing in Plonk defines univariate polynomials <span class="math">q_{L}(X),q_{R}(X),q_{O}(X),q_{M}(X),q_{C}(X))\\in\\mathbb{Z}_{p}</span> that satisfy the following equalities:</p>

    <p class="text-gray-300"><span class="math">q_{L}\\left(\\omega_{n}^{i}\\right)=q_{L_{i}}\\quad q_{R}\\left(\\omega_{n}^{i}\\right)=q_{R_{i}}\\quad q_{O}\\left(\\omega_{n}^{i}\\right)=q_{O_{i}}\\quad q_{M}\\left(\\omega_{n}^{i}\\right)=q_{M_{i}}\\quad q_{C}\\left(\\omega_{n}^{i}\\right)=q_{C_{i}}</span></p>

    <p class="text-gray-300">for <span class="math">i\\in[n]</span>. Where <span class="math">\\omega_{n}</span> is the <span class="math">n</span>-th primitive root of unity. The circuit constraints explained above capture gates within the circuit. However, the circuit wiring (which gate is connected where) still needs to be checked. For this purpose, Plonk uses the following permutation-based argument: if the wire values are copied correctly across gate inputs/outputs in the circuit, then permuting the corresponding values in the resulting polynomial shouldn’t change it. The circuit wiring/“copying” is captured by the relationships between indices <span class="math">\\{a_{i},b_{i},c_{i}\\}</span>. If the correct wire values are copied, there exists a permutation <span class="math">\\sigma:[3n]\\rightarrow[3n]</span> can be decomposed into <span class="math">m</span> cycles where the <span class="math">j</span>-th cycle involves all the positions where the <span class="math">j</span>-th variable should be copied. This permutation is then transformed into 3 polynomials <span class="math">\\mathrm{S}_{\\sigma_{1}},\\;\\mathrm{S}_{\\sigma_{2}},\\;\\mathrm{S}_{\\sigma_{3}}</span>, that define “permutation identities”, that use two additional scalars <span class="math">\\beta,\\gamma\\in\\mathbb{Z}_{p}</span> :</p>

    <p class="text-gray-300"><span class="math">perm-ids^{\\sigma}_{\\beta,\\gamma}(\\mathrm{A}(X),\\mathrm{B}(X),\\mathrm{C}(X),\\mathrm{Z}(X))</span></p>

    <p class="text-gray-300">This defines two polynomials that should vanish over the subgroup <span class="math">\\mathcal{H}_{n}</span>. Details about the permutation argument are presented later in Definition 7.1. For now, it suffices to assume that if the polynomials <span class="math">A,B,C</span> are honestly generated from a satisfying assignment to the constraint system <span class="math">\\mathcal{C}</span>, then the polynomial <span class="math">Z</span> of degree <span class="math">&lt;=n</span> that satisfies <span class="math">perm-ids^{\\sigma}_{\\beta,\\gamma}</span> can be computed efficiently.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Polynomial Commitments.</h4>

    <p class="text-gray-300">A batched version of <em>[x10]</em> commitments is utilized for polynomial commitments. The homomorphism allows for efficient batch openings. The commitment to polynomial <span class="math">q_{L}</span> is <span class="math">\\psi_{q_{L}}</span>, and similarly <span class="math">\\psi_{q_{R}},\\psi_{q_{O}},\\psi_{q_{M}},\\psi_{q_{C}},\\psi_{S_{\\sigma_{1}}},\\psi_{S_{\\sigma_{2}}},\\psi_{S_{\\sigma_{3}}}</span> are polynomial commitments to the respective polynomials that part of Plonk’s public parameters.</p>

    <p class="text-gray-300">At a high level, the prover commits to polynomials <span class="math">A,B,C</span> since they represent a valid witness. The prover than convinces the verifier that the witness polynomials satisfy the circuit constraints across the subgroup <span class="math">\\mathcal{H}_{n}</span>. This can be checked by using the constraints with the witness polynomials and dividing by the subgroup’s vanishing polynomial <span class="math">Z_{\\mathcal{H}_{n}}</span>. Consequently, the prover commits to the quotient <span class="math">T</span> of this division and evaluates all committed points at a challenge point <span class="math">\\xi</span>. The verifier later checks whether <span class="math">Z_{\\mathcal{H}_{n}}(\\xi).T(\\xi)</span> matches the evaluations of the constraint identities on <span class="math">\\xi</span>. This ensures that the polynomial division was exact. This is guaranteed by the knowledge soundness of the polynomial commitment scheme and the Schwartz-Zippel lemma.</p>

    <p class="text-gray-300">3.5.1 Plonk Variations</p>

    <p class="text-gray-300">How (the polynomial IOP underlying) Plonk arithmetizes circuits into constraints is termed “Plonkish arithmetization”. The following are some other proof systems that follow the same arithmetization approach.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>HyperPlonk <em>[x10]</em>: In Plonk, the prover uses commitments to polynomials <span class="math">q_{L}</span>, <span class="math">q_{R}</span>, and <span class="math">q_{O}</span> (among others) to convince the verifier that these indeed encode a valid computation of the circuit in question <span class="math">\\mathcal{C}</span>. While in univariate Plonk, the prover’s encoding utilizes a cyclic subgroup of <span class="math">\\mathbb{F}</span>, HyperPlonk instead uses the boolean hypercube for the encoding. This change eliminates the need for an FFT during proof generation and uses a sum-check protocol <em>[x24]</em> instead: shaving off a <span class="math">\\log(s)</span> (for <span class="math">s</span> being the size of the circuit <span class="math">\\mathcal{C}</span>) factor in the prover’s asymptotic runtime. Furthermore, it also facilitates the use of custom gates of a much higher degree. Any function used multiple times in a circuit can be a custom gate <span class="math">G:\\mathbb{F}^{l}\\rightarrow\\mathbb{F}</span>. For example, the S-box in a block cipher can be efficiently implemented as a custom gate. A circuit <span class="math">\\mathcal{C}</span> with a custom gate <span class="math">G</span> can be represented as <span class="math">\\mathcal{C}[G]</span>.</li>

    </ul>

    <p class="text-gray-300">A recent work of Setty, Thaler, and Wahby <em>[x35]</em> shows that earlier SNARKs that were originally described for R1CS, such as Spartan <em>[x31]</em>, extend easily to Plonkish arithmetization and, in fact, a generalization of Plonkish arithmetization they call Customizable Constraint Systems (CCS).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Plonky2 <em>[x29]</em>: Plonky2 is a proof system proposed with recursive composition as the main goal. The key change it makes to Plonk is switching out <em>[x21]</em> commitments for a polynomial commitment scheme based on FRI. It makes more changes to support custom gates using techniques from a syntax improvement on Plonk <em>[x16]</em>. It also uses FRI with “grinding”, which requires every prover to compute a proof-of-work solution using some randomness and their commitment from the FRI commit phase as input. Plonky2 uses the Domain Extending for Eliminating Pretenders (DEEP) <em>[x6]</em> variant of FRI, where the verifier samples a single point <span class="math">z</span> outside the domain <span class="math">D</span> on which codewords are evaluated and asks the prover for the value at <span class="math">z</span> of the interpolating polynomial. At a high level, using this technique “forces” the prover to choose one codeword from a list of “pretenders” that are close to the target codeword.</li>

      <li>RedShift <em>[x22]</em>: This proof system follows a similar approach to Plonky2, using FRI-based polynomial commitments with Plonkish arithmetization. However, RedShift uses FRI to build a primitive they call list polynomial commitment (LPC). Instead of the prover claiming that it committed to a particular polynomial <span class="math">f</span> and then convincing the verifier that this polynomial is within the unique decoding radius of a valid Reed-Solomon codeword, using LPC a prover claims are about some polynomial <span class="math">f^{\\prime}</span> within list-decoding radius of <span class="math">f</span>. LPC is a relaxation of a polynomial commitment scheme where the prover commits to the evaluations of one of the polynomials in a <span class="math">\\delta</span>-radius around a valid RS codeword. RedShift then converts the LPC to a polynomial commitment scheme to come up with a transparent Plonkish SNARK. This proof system predates Plonky2, and hence, the FRI-based polynomial commitment approach from here is generalized in Plonky2.</li>

    </ul>

    <h2 id="sec-70" class="text-2xl font-bold">4 Our Results</h2>

    <p class="text-gray-300">In this section, we formally state all of our results.</p>

    <h3 id="sec-71" class="text-xl font-semibold mt-8">4.1 Round-by-round Soundness of FRI and Batched FRI</h3>

    <p class="text-gray-300">We formally present the FRI IOPP algorithm in Algorithm 1. The following theorem captures the round-by-round soundness of FRI.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 4.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{*}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, and function </span>G_{0}\\colon L_{0}\\rightarrow\\mathbb{F}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, Algorithm 1 has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell)=\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We extend the above theorem to the Batched FRI protocol, a variant of Algorithm 1 where the prover first sends <span class="math">t</span> oracles <span class="math">f_{1},\\ldots,f_{t}</span> to the verifier, and the verifier replies with <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}\\stackrel{{\\scriptstyle*}}{{\\leftarrow}}\\mathbb{F}</span>. The prover and verifier then engage in the FRI protocol for polynomial <span class="math">G_{0}=\\sum_{i}\\alpha_{i}f_{i}</span>. The following theorem captures the round-by-round soundness of Batched FRI.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Theorem 4.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{*}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, and functions </span>f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}<span class="math"> for </span>t\\geq 2<span class="math"> such that at least one </span>f_{i}^{(0)}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}^{(0)}$, the Batched FRI protocol has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}:=\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t)=\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">Fiat-Shamir Security of FRI and Batched FRI.</h4>

    <p class="text-gray-300">Given Theorems 4.1 and 4.2, we can apply the BCS transformation, with its guarantees stated in Theorem 3.15, to transform both FRI and Batched FRI into SNARKs in the random oracle model. The following corollaries capture this result.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Corollary 4.3 (FS Security of FRI).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{<em>}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, random oracle </span>\\mathcal{H}\\colon\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\kappa}<span class="math">, query bound </span>Q\\in\\mathbb{N}<span class="math">, and function </span>G_{0}\\colon L_{0}\\to\\mathbb{F}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, compiling Algorithm 1 with Theorem 3.15 gives a non-interactive random oracle proof with adaptive soundness error and knowledge error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{fs}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,Q,\\kappa)=Q\\cdot\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell)+\\frac{3(Q^{2}+1)}{2^{\\kappa}}.</span></p>

    <p class="text-gray-300">Moreover, if <span class="math">\\gamma:=\\gamma(\\mathbb{F},L_{0},\\rho,\\delta,\\ell)</span> denotes the length of a FRI proof for parameters <span class="math">\\mathbb{F},L_{0},\\rho,\\delta,\\ell</span>, then the above non-interactive random oracle proof has adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,Q,\\kappa)=\\Theta(Q\\cdot\\varepsilon_{\\mathsf{fs}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,Q,\\kappa))</span></p>

    <p class="text-gray-300">against quantum adversaries that can make at most <span class="math">Q-O(\\ell\\cdot\\log(\\gamma))</span> queries.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Corollary 4.4 (FS Security of Batched FRI).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{<em>}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, random oracle </span>\\mathcal{H}\\colon\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\kappa}<span class="math">, query bound </span>Q\\in\\mathbb{N}<span class="math">, and functions </span>f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}<span class="math"> for </span>t\\geq 2<span class="math"> such that at least one </span>f_{t}^{(0)}<span class="math"> is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, compiling Batched FRI with Theorem 3.15 gives a non-interactive random oracle proof with adaptive soundness error and knowledge error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs}}^{\\mathsf{bFRI}}:=\\varepsilon_{\\mathsf{fs}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t,Q,\\kappa)=Q\\cdot\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t)+\\frac{3(Q^{2}+1)}{2^{\\kappa}}.</span></p>

    <p class="text-gray-300">Moreover, if <span class="math">\\gamma:=\\gamma(\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t)</span> denotes the length of a Batched FRI proof for parameters <span class="math">\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t</span>, then the above non-interactive random oracle proof has adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{bFRI}}:=\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t,Q,\\kappa)=\\Theta(Q\\cdot\\varepsilon_{\\mathsf{fs}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t,Q,\\kappa))</span></p>

    <p class="text-gray-300">against quantum adversaries that can make at most <span class="math">Q-O(\\ell\\cdot\\log(\\gamma))</span> queries.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Remark 4.5.</h6>

    <p class="text-gray-300">A variety of works (e.g., <em>[BCI^{+}20, Sta23]</em>) make conjectures about the security of the FRI and Batched FRI protocols. We similarly adapt our above results when assuming these conjectured security bounds; see Section 5.5 for details.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">4.2 Correlated IOPs</p>

    <p class="text-gray-300">A key technical tool we introduce is the notion of a <span class="math">\\delta</span>-correlated (holographic) interactive oracle proof, or <span class="math">\\delta</span>-correlated hIOP in short. A <span class="math">\\delta</span>-correlated hIOP is an hIOP for indexed <span class="math">(\\mathbb{F},H,d)</span>-polynomial oracle relations, where we fix some <span class="math">0\\leq\\delta&lt;1</span> and assume the verifier has an oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> for the correlated agreement relation <span class="math">\\mathbf{CoAgg}(\\delta)</span> (see Definition 3.10). Furthermore, we assume that the final offline verification process consists of: (1) checking that the oracles sent by the prover satisfy a certain polynomial equation on a random point <span class="math">\\mathfrak{z}</span> (not necessarily from <span class="math">H</span>); and (2) using <span class="math">\\mathsf{OCoAgg}(\\delta)</span> to check that the maps corresponding to certain oracles have correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},H,d]</span> (see Definition 6.1 for details). We denote such a protocol as <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span>.</p>

    <p class="text-gray-300">Given a <span class="math">\\delta</span>-correlated hIOP, our first main result is showing that given a round-by-round sound <span class="math">0</span>-correlated hIOP, when replacing the oracle <span class="math">\\mathsf{OCoAgg}(0)</span> with another suitable IOP, results in a new hIOP that is also round-by-round sound.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Theorem 4.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V}^{\\mathsf{OCoAgg}(0)})</span> be a <span class="math">\\mu</span>-round <span class="math">0</span>-correlated hIOP for an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation <span class="math">\\mathbf{R}</span>. Let <span class="math">0&lt;\\delta&lt;1-\\sqrt{\\rho}</span>, where $\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and let </span>\\Pi_{\\mathsf{CA}}<span class="math"> be a IOPP for </span>\\delta<span class="math">-correlated agreement in </span>\\mathsf{RS}[\\mathbb{F},D,d]<span class="math">. Let </span>\\eta>0<span class="math"> be such that </span>\\delta=1-\\sqrt{\\rho}-\\eta<span class="math">. Assume </span>\\Pi_{\\mathsf{CA}}<span class="math"> is RBR sound with error </span>\\varepsilon_{\\mathsf{CA}}$. Then the following hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> is RBR sound with error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}</span>. Then there exists a hIOP <span class="math">\\Pi</span> for <span class="math">\\mathbf{R}</span> with RBR soundness error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\prime}(\\dot{\\mathrm{i}})\\coloneqq\\max\\left\\{\\frac{\\varepsilon_{\\mathsf{rbr-s}}(\\dot{\\mathrm{i}})}{2\\eta\\sqrt{\\rho}},\\varepsilon_{\\mathsf{CA}}(\\dot{\\mathrm{i}}_{\\mathsf{CA}})\\right\\},</span></p>

    <p class="text-gray-300">where <span class="math">\\dot{\\mathrm{i}}_{\\mathsf{CA}}=(\\mathbb{F},D,d,\\delta,N)</span>, and <span class="math">N</span> is the number of words whose <span class="math">\\delta</span>-correlated agreement is checked in the last verification check of <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\mu(\\dot{\\mathrm{i}},\\mathbf{x})\\geq 1</span> for all <span class="math">\\dot{\\mathrm{i}},\\mathbf{x}</span> and <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR knowledge error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}</span>, then <span class="math">\\Pi</span> has RBR knowledge error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\max\\left\\{\\frac{\\varepsilon_{\\mathsf{rbr-k}}(\\dot{\\mathrm{i}})}{2\\eta\\sqrt{\\rho}},\\varepsilon_{\\mathsf{CA}}(\\dot{\\mathrm{i}}_{\\mathsf{CA}})\\right\\},</span></p>

    <p class="text-gray-300">where <span class="math">\\dot{\\mathrm{i}}_{\\mathsf{CA}}</span> has the same meaning as in above.</p>

    <p class="text-gray-300">The proof of the above theorem relies on two technical lemmas. The first lemma states that if you have a round-by-round sound <span class="math">0</span>-correlated hIOP when given access to <span class="math">\\mathsf{OCoAgg}(0)</span>, then when given access to <span class="math">\\mathsf{OCoAgg}(\\delta)</span> for <span class="math">\\delta&gt;0</span>, the same hIOP is now <span class="math">\\delta</span>-correlated and is round-by-round sound (with some loss in the soundness error).</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Lemma 4.7.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V}^{\\mathsf{OCoAgg}(0)})</span> be a <span class="math">\\mu</span>-round <span class="math">0</span>-correlated hIOP for an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation <span class="math">\\mathbf{R}</span>. Let <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span>. The following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> is RBR sound with error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}</span>. Then <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}(\\dot{\\mathrm{i}})/(2\\eta\\sqrt{\\rho})</span>.</li>

      <li>Suppose that <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR knowledge with error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}</span>. Then <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR knowledge error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}(\\dot{\\mathrm{i}})/(2\\eta\\sqrt{\\rho})</span>,</li>

    </ul>

    <p class="text-gray-300">The second lemma then states that when one replaces the oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> in the above hIOP with another round-by-round sound IOP for <span class="math">\\delta</span>-correlated agreement, then the resulting composed protocol remains round-by-round sound.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 4.8.</h6>

    <p class="text-gray-300">Assume the notation and hypotheses of Theorem 4.6. Then there exists a hIOP <span class="math">\\Pi_{\\mathsf{compiled}}</span> (see Definition 6.2) for <span class="math">\\mathbf{R}</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness error <span class="math">\\varepsilon_{\\mathsf{rbr-s},\\delta}</span>. Then <span class="math">\\Pi_{\\mathsf{compiled}}</span> has RBR soundness error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\max\\left\\{\\varepsilon_{\\mathsf{rbr-s},\\delta}(\\dot{\\mathrm{i}}),\\varepsilon_{\\mathsf{CA}}(\\dot{\\mathrm{i}}_{\\mathsf{CA}})\\right\\}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR knowledge soundness error <span class="math">\\varepsilon_{\\mathsf{rbr-k},\\delta}</span>. Then <span class="math">\\Pi_{\\mathsf{compiled}}</span> has RBR knowledge soundness error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\max\\left\\{\\varepsilon_{\\mathsf{rbr-k},\\delta}(\\mathfrak{i}),\\varepsilon_{\\mathsf{CA}}(\\mathfrak{i}_{\\mathsf{CA}})\\right\\}.</span></p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">4.3 A Plonk-like Protocol Abstraction <span class="math">\\mathsf{OPlonky}</span></h3>

    <p class="text-gray-300">Building upon the <span class="math">\\delta</span>-correlated hIOP framework, we introduce a <span class="math">\\delta</span>-correlated hIOP we call <span class="math">\\mathsf{OPlonky}</span>, which abstracts the polynomial IOPs underlying many of the variants of Plonk. This generalization is inspired in part by Plonky2 <em>[x11]</em>. Our main technical result is establishing the round-by-round soundness of <span class="math">\\mathsf{OPlonky}(0):=\\mathsf{OPlonky}^{\\mathsf{OCoAgg}(0)}</span>, where we assume the verifier has oracle access to the <span class="math">0</span>-correlated agreement oracle <span class="math">\\mathsf{OCoAgg}(0)</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 4.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <span class="math">0</span>-correlated agreement encoded hIOP <span class="math">\\mathsf{OPlonky}(0)</span> has RBR soundness and RBR knowledge with the same error <span class="math">\\varepsilon</span>, where, for all index <span class="math">\\mathfrak{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t})</span> and any potential input <span class="math">\\preceq</span> we have, for $\\mathsf{n}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\varepsilon(\\mathfrak{i})</span> <span class="math">=\\max_{i\\in[3]}\\left\\{\\varepsilon_{i}(\\mathfrak{i})\\right\\},</span> <span class="math">\\varepsilon_{1}(\\mathfrak{i})</span> $:=\\left(\\frac{3\\mathsf{n}(\\mathsf{r}^{\\prime}+\\mathsf{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathsf{t}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given the above lemma and our results about <span class="math">\\delta</span>-correlated hIOPs, we arrive at our main theorem for <span class="math">\\mathsf{OPlonky}</span>; that is, compiling <span class="math">\\mathsf{OPlonky}^{\\mathsf{OCoAgg}(\\delta)}</span> with the Batched FRI protocol.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Theorem 4.10.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">D\\subseteq\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of <span class="math">\\mathbb{F}</span> of order <span class="math">2^{n}</span>, and <span class="math">H</span> a subgroup of <span class="math">D</span> of order <span class="math">\\mathsf{n}</span>. Let <span class="math">m\\geq 3</span>, <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span> for some <span class="math">\\eta\\in(0,\\sqrt{\\rho}/2m)</span>, and let <span class="math">\\mathsf{Plonky2hIOP}</span> be the hIOP obtained from <span class="math">\\mathsf{OPlonky}(\\delta)</span> after compiling it with the Batched FRI protocol (see Definition 6.2). Then <span class="math">\\mathsf{Plonky2hIOP}</span> is RBR sound and has RBR knowledge. For each <span class="math">\\mathfrak{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t})</span> and all <span class="math">q\\geq 1</span>, the error in both cases is given by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky}}(\\mathfrak{i},q)=</span> <span class="math">\\max\\left\\{\\left(\\frac{\\varepsilon_{i}(\\mathfrak{i})}{2\\eta\\sqrt{\\rho}}\\right)_{i\\in[3]},\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{hFRI}}(\\mathbb{F},D,\\rho,\\delta,N,q)\\right\\},</span></p>

    <p class="text-gray-300">where <span class="math">N</span> is the total number of codewords that are batched together in the batched FRI protocol, <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{hFRI}}</span> is the RBR soundness error of <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{hFRI}}</span> (which equals its RBR knowledge error, see Theorem 5.11) and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{1}(\\mathfrak{i}):=\\left(\\frac{3\\mathsf{n}(\\mathsf{r}^{\\prime}+\\mathsf{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathsf{t}},\\hskip 14.22636pt\\varepsilon_{2}(\\mathfrak{i}):=\\left(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(\\mathsf{s}+2)\\mathsf{t}-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathsf{t}},\\hskip 14.22636pt\\varepsilon_{3}(\\mathfrak{i}):=\\max\\{\\deg(P_{j})_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]},{\\mathsf{u}}+1\\}\\frac{\\mathsf{n}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}\\setminus D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-84" class="text-2xl font-bold">5 Round-by-round Soundness of the FRI Protocol</h2>

    <p class="text-gray-300">We now turn to analyzing the round-by-round soundness of the original FRI IOPP protocol of Ben-Sasson et al. <em>[x1]</em>. We present the protocol in Algorithm 1 (at the end of this section) and prove the following theorem.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Theorem 4.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{*}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, and function </span>G_{0}\\colon L_{0}\\to\\mathbb{F}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, Algorithm 1 has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell)=</span> $\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove Theorem 4.1, we need to define a suitable doomed set <span class="math">\\mathcal{D}</span> then bound the probability the prover can “leave” <span class="math">\\mathcal{D}</span> during any round of the protocol. We will define our doomed set <span class="math">\\mathcal{D}</span> in two steps. First, we consider the set of transcripts that are “doomed” in any round <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span> of the protocol (i.e., the Folding Phase), which we will denote as <span class="math">\\mathcal{D}_{k}</span>. Then, we consider the set of complete transcripts that are “doomed” for round <span class="math">i=k</span> of the protocol (i.e., the Query Phase), which we will denote as <span class="math">\\mathcal{D}_{\\mathsf{f}}</span>. Taking <span class="math">\\mathcal{D}=\\mathcal{D}_{k}\\cup\\mathcal{D}_{\\mathsf{f}}</span> gives us our final doomed set. Given this doomed</p>

    <p class="text-gray-300">set, we can suitably bound the probability that any (possibly malicious) prover <span class="math">P^{*}</span> can send a message that constructs a transcript that is not in the set <span class="math">\\mathcal{D}</span>, which establishes round-by-round soundness of Algorithm 1.</p>

    <p class="text-gray-300">Before proceeding, we introduce some notation. For index <span class="math">i\\in\\{0,1,\\ldots,k\\}</span>, we define <span class="math">\\mathsf{RS}^{(i)}:=\\mathsf{RS}[\\mathbb{F},L_{i},d_{i}]</span>, where <span class="math">L_{0}\\subset\\mathbb{F}^{<em>}</span> is a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, <span class="math">L_{i}:=\\{z^{2}\\colon z\\in L_{i-1}\\}</span>, and <span class="math">d_{i}=d_{i-1}/2</span>. Note that for every <span class="math">i\\in[k]</span>, <span class="math">L_{i}</span> is a smooth multiplicative subgroup if size <span class="math">2^{n-i}</span>. For function <span class="math">f\\colon L_{i}\\to\\mathbb{F}</span> and <span class="math">x\\in\\mathbb{F}</span>, we define a so-called “algebraic hash function” </em>[x1]* <span class="math">H_{x}[f]\\colon L_{i+1}\\to\\mathbb{F}</span> as</p>

    <p class="text-gray-300"><span class="math">H_{x}<a href="s">f</a>:=\\frac{(x-s^{\\prime})}{(s^{\\prime\\prime}-s^{\\prime})}\\cdot f(s^{\\prime\\prime})+\\frac{(x-s^{\\prime\\prime})}{(s^{\\prime}-s^{\\prime\\prime})}\\cdot f(s^{\\prime})</span> (10) <span class="math">s^{\\prime},s^{\\prime\\prime}\\in L_{i},s^{\\prime}\\neq s^{\\prime\\prime},(s^{\\prime})^{2}=(s^{\\prime\\prime})^{2}=s\\in L_{i+1}.</span></p>

    <p class="text-gray-300">This algebraic hash function <span class="math">H_{x}</span> has the useful property that <span class="math">f\\in\\mathsf{RS}^{(i)}</span> then <span class="math">H_{x}[f]\\in\\mathsf{RS}^{(i+1)}</span> for any <span class="math">x</span>. It also has the additional nice property that for arbitrary <span class="math">G_{i}\\colon L_{i}\\to\\mathbb{F}</span> and <span class="math">G_{i+1}=H_{x}[G_{i}]</span>, then <span class="math">G_{i}</span> and <span class="math">G_{i+1}</span> will pass all verifier checks during the Query Phase of the protocol, so long as <span class="math">d_{i+1}&gt;1</span> <em>[x27]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now proceed with defining our doomed sets <span class="math">\\mathcal{D}_{k}</span> and <span class="math">\\mathcal{D}_{l}</span>. We begin by analyzing the rounds <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span> of Algorithm 1, which correspond to the Folding Phase. First note that by definition for any <span class="math">x\\notin\\mathcal{L}</span> we have <span class="math">(x,\\emptyset)\\in\\mathcal{D}</span>. Now for round <span class="math">i=0</span>, we view the oracle <span class="math">G_{0}</span>, which is already given to the verifier before the start of the protocol, as being sent to the verifier during this round. It is assumed that <span class="math">G_{0}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span> and the prover honestly sends <span class="math">(G_{0}(z))_{z\\in L_{0}}</span> to the verifier. The verifier then responds with random challenge <span class="math">x_{0}\\stackrel{{\\scriptstyle*}}{{\\leftarrow}}\\mathbb{F}</span>. Let $\\tau_{0}:=(G_{0}(z))_{z\\in L_{0}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{0}$ denote the partial transcript of the protocol so far.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Looking ahead to the Query Phase, the verifier will check consistency of oracles <span class="math">G_{0}</span> and <span class="math">G_{1}^{<em>}</span>, where <span class="math">G_{1}^{</em>}</span> was the oracle sent by the prover during round <span class="math">i=1</span>. The verifier checks consistency as follows. First, it samples <span class="math">s_{0}\\leftarrow L_{0}</span> and computes <span class="math">s_{1}=(s_{0})^{2}</span>. Since <span class="math">L_{0}</span> is a smooth multiplicative subgroup of order <span class="math">2^{n}</span>, there also exists <span class="math">s_{0}^{\\prime}\\neq s_{0}</span> such that <span class="math">(s_{0}^{\\prime})^{2}=s_{1}</span>; i.e., <span class="math">s_{0}^{\\prime}</span> is the other square root of <span class="math">s_{1}</span>. The verifier then obtains points <span class="math">q_{0}=G_{0}(s_{0})</span> and <span class="math">q_{0}^{\\prime}=G_{0}(s_{0}^{\\prime})</span> and <span class="math">q_{1}=G_{1}^{<em>}(s_{1})</span>. Now the consistency check the verifier performs is exactly given by Eq. (10): using <span class="math">(s_{0},q_{0})</span>, <span class="math">(s_{0}^{\\prime},q_{0}^{\\prime})</span>, and challenge <span class="math">x_{0}</span>, the verifier computes the right hand side of Eq. (10) and checks if it is equal to <span class="math">q_{1}</span>; if not, the verifier rejects. Notice that if <span class="math">G_{1}^{</em>}=H_{x_{0}}[G_{0}]</span> for any <span class="math">G_{0}</span>, then <span class="math">G_{1}^{*}</span> passes all verifier checks with probability <span class="math">1</span> so long as <span class="math">d_{1}=d_{0}/2&gt;1</span>. Notice also that if <span class="math">d_{1}=1</span>, then the verifier expects <span class="math">G_{1}\\in\\mathbb{F}</span> to be sent, not an oracle; however, <span class="math">H_{x_{0}}[G_{0}]</span> may not be a constant function, so the verifier checks may fail in this case. This turns out to be crucial for soundness of the Query Phase.</p>

    <p class="text-gray-300">Now if <span class="math">H_{x_{0}}[G_{0}]</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(1)}</span>, then the malicious prover can send <span class="math">G_{1}^{*}=H_{x_{0}}[G_{0}]</span> and behave honestly for the rest of the protocol and break soundness; however, this is unlikely to happen by the following lemma.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma 5.1 (<em>[x3, Theorems 5.1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\rho=2^{-(n-k)}</span>. For all <span class="math">m\\geq 3</span>, <span class="math">\\eta\\in(0,\\sqrt{\\rho}/(2m)]</span> and <span class="math">\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)</span>, and any <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span>, if <span class="math">G_{i}\\colon L_{i}\\to\\mathbb{F}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i)}</span> then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\leftarrow\\mathbb{F}}\\left[\\Delta(H_{x}[G_{i}],\\mathsf{RS}^{(i+1)})\\leq\\delta\\right]<\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, it is unlikely that folding a function that is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i)}</span> results in a function that is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(i+1)}</span>. Intuitively, this tells us that for our doomed set <span class="math">\\mathcal{D}</span> we want <span class="math">(x,\\tau_{0})\\in\\mathcal{D}</span> if and only if <span class="math">H_{x_{0}}[G_{0}]</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(1)}</span>; equivalently, <span class="math">(x,\\tau_{0})\\notin\\mathcal{D}</span> if <span class="math">H_{x_{0}}[G_{0}]</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(1)}</span>. However, round <span class="math">i=0</span> is a special case of the protocol since we assume that <span class="math">G_{0}</span> is honestly sent by any prover (malicious or not). For rounds <span class="math">i\\in[k-1]</span>, a malicious prover <span class="math">P^{<em>}</span> does not have this restriction and thus can send an arbitrary oracle <span class="math">G_{i}^{</em>}</span> during round <span class="math">i</span>. To define the doomed set <span class="math">\\mathcal{D}</span> for these rounds, we intuitively want to ensure the following: if <span class="math">(x,\\tau_{i-1})\\in\\mathcal{D}</span> and <span class="math">(x,\\tau_{i})\\notin\\mathcal{D}</span>, then the prover <span class="math">P^{*}</span> can behave honestly for the remainder of the protocol and <span class="math">V(x,\\tau)=1</span> for the complete transcript (with good probability).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider round <span class="math">i=1</span> and let <span class="math">G_{1}^{<em>}</span> be the oracle sent by the prover <span class="math">P^{</em>}</span> and let <span class="math">G_{1}=H_{x_{0}}[G_{0}]</span> be the message that would be sent by the honest prover. In this case, for $\\tau_{1}=\\tau_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{1}^{*}(z))_{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}<span class="math">, we intuitively want </span>(x,\\tau_{1})\\notin\\mathcal{D}<span class="math"> if and only if </span>P^{<em>}<span class="math"> can behave honestly for the remainder of the protocol and pass all verifier checks during the Query Phase. This happens if and only if </span>G_{2}=H_{x_{1}}[G_{1}]<span class="math"> and </span>G_{1}^{</em>}=G_{1}<span class="math">. Note that if </span>G_{1}^{<em>}\\neq G_{1}<span class="math">, it is possible for some of the verifier checks during the Query Phase to fail; however, if </span>G_{1}^{</em>}=G_{1}<span class="math">, then all verifier checks with </span>G_{1}^{*}<span class="math"> will pass. We inductively extend this analysis to any round </span>i\\in[k-1]<span class="math"> (i.e., the Folding Phase, where </span>d_{i}>1$) via the following lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Lemma 5.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">x\\notin\\mathcal{L}</span>, <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{<em>}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\ell\\in\\mathbb{N}</span> be the inputs to the FRI protocol. Let <span class="math">m\\geq 3</span> be an integer and <span class="math">\\delta,\\eta&gt;0</span> such that <span class="math">\\eta&lt;\\sqrt{\\rho}/(2m)</span> and <span class="math">\\delta&lt;1-\\sqrt{\\rho}-\\eta</span>. Let <span class="math">G_{0}\\colon L_{0}\\to\\mathbb{F}</span> be <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span> given to the prover as input. For <span class="math">i\\in\\{1,\\ldots,k-1\\}</span>, let <span class="math">G_{i}\\coloneqq H_{x_{i-1}}[G_{i-1}]</span> denote the oracle sent by an honest prover <span class="math">P</span>, let <span class="math">G_{i}^{</em>}\\colon L_{i}\\to\\mathbb{F}</span> be some oracle sent by (possibly malicious) prover <span class="math">P^{<em>}</span>, and let <span class="math">x_{i}</span> denote the corresponding challenge sent by the verifier during round <span class="math">i</span> of the protocol, with <span class="math">G_{0}^{</em>}=G_{0}</span>. Let $\\tau_{i}\\coloneqq\\tau_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{i}^{*}(z))_{z\\in L_{i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}<span class="math"> for </span>L_{i}\\coloneqq\\{z^{2}\\colon z\\in L_{i-1}\\}<span class="math">. Define set </span>\\mathcal{D}_{k}$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x,\\emptyset)\\in\\mathcal{D}_{k}</span>;</li>

      <li><span class="math">(x,\\tau_{0})\\in\\mathcal{D}_{k}</span> if and only if <span class="math">G_{1}=H_{x_{0}}[G_{0}]</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(1)}</span>;</li>

      <li>For <span class="math">i\\in\\{1,\\ldots,k\\}</span>, <span class="math">(x,\\tau_{i})\\in\\mathcal{D}_{k}</span> if and only if <span class="math">\\exists j\\in[i]</span> such that <span class="math">G_{j}^{*}\\neq H_{x_{j-1}}[G_{j-1}]</span> or <span class="math">H_{x_{i}}[G_{i}]</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i+1)}</span>.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">(x,\\tau_{i-1})\\in\\mathcal{D}_{k}</span>, then for any oracle <span class="math">G_{i}^{<em>}\\colon L_{i}\\to\\mathbb{F}</span> sent by (possibly malicious) prover <span class="math">P^{</em>}</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x_{i}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}}[(x,\\tau_{i})\\notin\\mathcal{D}_{k}]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show the special case of <span class="math">i=0</span> then show <span class="math">i\\in\\{1,\\ldots,k-1\\}</span> by induction. For <span class="math">i=0</span>, we have <span class="math">(x,\\emptyset)\\in\\mathcal{D}_{k}</span> by definition; also note that <span class="math">\\Delta(G_{0},\\mathsf{RS}^{(0)})\\geq\\delta</span> by assumption. Let $\\tau_{0}=(G_{0}(z))_{z\\in L_{0}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{0}<span class="math"> for </span>x_{0}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}<span class="math">. By definition of </span>\\mathcal{D}_{k}<span class="math">, we know that </span>(x,\\tau_{0})\\in\\mathcal{D}_{k}<span class="math"> if and only if </span>\\Delta(G_{1},\\mathsf{RS}^{(1)})\\geq\\delta<span class="math"> for </span>G_{1}\\coloneqq H_{x_{0}}[G_{0}]<span class="math">; note we also assume that </span>G_{0}^{<em>}=G_{0}<span class="math"> for </span>P^{</em>}<span class="math">’s message. Equivalently, we have that </span>(x,\\tau_{0})\\notin\\mathcal{D}_{k}<span class="math"> if and only if </span>\\Delta(G_{1},\\mathsf{RS}^{(1)})<\\delta<span class="math">. Noting that </span>\\Pr[\\Delta(G_{1},\\mathsf{RS}^{(1)})<\\delta]\\leq\\Pr[\\Delta(G_{1},\\mathsf{RS}^{(1)})\\leq\\delta]<span class="math"> for </span>x_{0}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}$, Lemma 5.1 gives us</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x_{0}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}}[(x,\\tau_{0})\\notin\\mathcal{D}_{k}]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">i=1</span>, by round-by-round soundness we assume that <span class="math">(x,\\tau_{0})\\in\\mathcal{D}_{k}</span>. By definition, this implies <span class="math">G_{1}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(1)}</span>. Let <span class="math">G_{1}^{<em>}\\colon L_{1}\\to\\mathbb{F}</span> be the oracle sent by <span class="math">P^{</em>}</span> during this round, and let <span class="math">x_{1}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}</span> be the corresponding verifier challenge. Setting $\\tau_{1}=\\tau_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{1}^{*}(z))_{z\\in L_{1}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}<span class="math">, by definition we know that </span>(x,\\tau_{1})\\in\\mathcal{D}_{k}<span class="math"> if and only if </span>G_{1}^{<em>}\\neq G_{1}<span class="math"> or </span>G_{2}\\coloneqq H_{x_{1}}[G_{1}]<span class="math"> is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}^{(2)}<span class="math">. Equivalently, we have that </span>(x,\\tau_{1})\\notin\\mathcal{D}_{k}<span class="math"> if and only if </span>G_{1}^{</em>}=G_{1}<span class="math"> and </span>G_{2}<span class="math"> is </span>\\delta<span class="math">-close to </span>\\mathsf{RS}^{(2)}<span class="math">. Observe that if </span>G_{1}^{<em>}\\neq G_{1}<span class="math"> then </span>(x,\\tau_{1})\\in\\mathcal{D}_{k}<span class="math"> with probability </span>1<span class="math">, which implies that </span>(x,\\tau_{1})\\notin\\mathcal{D}_{k}<span class="math"> with probability </span>0<span class="math">. Thus assume that </span>G_{1}^{</em>}=G_{1}$. Now by Lemma 5.1, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x_{1}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}}[(x,\\tau_{1})\\notin\\mathcal{D}_{k}\\mid G_{1}^{*}=G_{1}]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which implies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x_{1}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}}[(x,\\tau_{1})\\notin\\mathcal{D}_{k}]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the induction step, let $\\tau_{i}=\\tau_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{i}^{*}(z))_{z\\in L_{i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}<span class="math"> for </span>i\\in[k-1]<span class="math">. By round-by-round soundness, we assume that </span>(x,\\tau_{i})\\in\\mathcal{D}_{k}<span class="math">. This implies that either </span>\\exists j\\in[i]<span class="math"> such that </span>G_{j}^{<em>}\\neq G_{j}=H_{x_{j-1}}[G_{j-1}]<span class="math"> or </span>G_{i+1}=H_{x_{i}}[G_{i}]<span class="math"> is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}^{(i+1)}<span class="math">. Let </span>G_{i+1}^{</em>}\\colon L_{i+1}\\to\\mathbb{F}<span class="math"> be the oracle sent by </span>P^{*}<span class="math"> and let </span>x_{i+1}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}<span class="math"> be the corresponding verifier message and let </span>\\tau_{i+1}=\\tau_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{i+1}^{*}(z))_{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i+1}<span class="math">. As before, suppose that there exists </span>j\\in[i]<span class="math"> such that </span>G_{j}^{<em>}\\neq G_{j}<span class="math">. This implies that there exists </span>j\\in[i+1]<span class="math"> such that </span>G_{j}^{</em>}\\neq G_{j}<span class="math">. In this case, we have that </span>\\Pr[(x,\\tau_{i+1})\\notin\\mathcal{D}_{k}]=0<span class="math">. For the other case, suppose that for all </span>j\\in[i]<span class="math"> we have that </span>G_{j}^{<em>}=G_{j}<span class="math">. Now if </span>G_{i}^{</em>}\\neq G_{i}<span class="math">, we again have that </span>(x,\\tau_{i+1})\\in\\mathcal{D}_{k}<span class="math"> with probability </span>1<span class="math"> by definition. Thus suppose that </span>G_{i}^{*}=G_{i}$. Then by Lemma 5.1, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x_{i+1}\\stackrel{{\\scriptstyle s}}{{\\leftarrow}}\\mathbb{F}}[(x,\\tau_{i+1})\\notin\\mathcal{D}\\mid G_{j}^{*}=G_{j}\\;\\forall j\\in[i+1]]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which again implies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x_{i+1}\\overset{s}{\\leftarrow}\\mathbb{F}}[(x,\\tau_{i+1})\\notin\\mathcal{D}]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 5.2 characterizes the round-by-round soundness of Algorithm 1 for all rounds <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span> of the Folding Phase of the protocol. In the final round <span class="math">i=k</span> of the protocol, the prover sends constant <span class="math">G_{k}^{<em>}=C\\in\\mathbb{F}</span> to the verifier; in particular, this message is </em>not<em> an oracle and is read by <span class="math">V</span> in full. The verifier then samples a query set <span class="math">(s_{0,1},\\ldots,s_{0,\\ell})</span> where <span class="math">s_{0,j}\\overset{s}{\\leftarrow}L_{0}</span> for every <span class="math">j\\in[\\ell]</span> and queries the oracles <span class="math">G_{0},G_{1}^{</em>},\\ldots,G_{k-1}^{<em>}</span> to perform some consistency checks. For the purposes of round-by-round soundness, we assume that the verifier sends these queries to the prover <span class="math">P^{</em>}</span> as well. This gives us a final transcript of <span class="math">(x,\\tau_{k})</span> for $\\tau_{k}=\\tau_{k-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{k}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(s_{0,1},\\ldots,s_{0,\\ell})$. Note that we are interpreting the entire Query Phase of Algorithm 1 as a single round in our analysis. This does not change the analysis because</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each verifier challenge <span class="math">s_{0,j}</span> is sampled uniformly and independently at random, so it can sample them all at once; and</li>

      <li>The verifier can compute all <span class="math">s_{i,j},s_{i,j}^{\\prime}</span> for all <span class="math">i\\in\\{0,1,\\ldots,k\\}</span> and <span class="math">j\\in[\\ell]</span> given <span class="math">(s_{0,1},\\ldots,s_{0,\\ell})</span>. Moreover, given these points, the verifier can perform all oracle queries and all consistency checks at once.</li>

    </ol>

    <p class="text-gray-300">Algorithm 1 is presented as-is for clarity. We characterize the round-by-round soundness of the Query Phase of Algorithm 1 with the following lemma.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Lemma 5.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">x\\notin\\mathcal{L}</span>, <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subseteq\\mathbb{F}^{<em>}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\ell\\in\\mathbb{N}</span> be the inputs to the FRI protocol and let <span class="math">m\\geq 3</span> and <span class="math">\\delta,\\eta&gt;0</span> such that <span class="math">\\eta&lt;\\sqrt{\\rho}/(2m)</span> and <span class="math">\\delta&lt;1-\\sqrt{\\rho}-\\eta</span>. Let <span class="math">\\tau_{k-1}</span> be the partial transcript such that <span class="math">(x,\\tau_{k-1})\\in\\mathcal{D}_{k}</span> for <span class="math">\\mathcal{D}_{k}</span> defined in Lemma 5.2. Let <span class="math">G_{k}^{</em>}=C\\in\\mathbb{F}</span> be a constant sent by <span class="math">P^{*}</span> and <span class="math">s_{0,j}\\overset{s}{\\leftarrow}L_{0}</span> for <span class="math">j\\in[\\ell]</span> be the corresponding verifier queries. Define set <span class="math">\\mathcal{D}_{\\mathsf{f}}</span> as follows: for $\\tau_{k}:=\\tau_{k-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{k}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(s_{0,1},\\ldots,s_{0,\\ell})<span class="math">, </span>(x,\\tau_{k})\\in\\mathcal{D}_{\\mathsf{f}}<span class="math"> if and only if there exists </span>i\\in[k]<span class="math">, </span>j\\in[\\ell]<span class="math"> such that </span>G_{i}^{*}(s_{i,j})\\neq\\widetilde{Q}_{i-1}(x_{i-1})$, where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">s_{i,j}=(s_{i-1,j})^{2}\\in L_{i}</span>,</li>

      <li><span class="math">\\widetilde{Q}_{i-1,j}(X)</span> is a linear polynomial obtained via Lagrange interpolation on the set <span class="math">\\{(s_{i-1,j},q_{i-1,j}),(s_{i-1,j}^{\\prime},q_{i-1,j}^{\\prime})\\}</span>, where <span class="math">s_{i-1,j}^{\\prime}\\neq s_{i-1,j}</span> such that <span class="math">(s_{i-1,j}^{\\prime})^{2}=s_{i,j}</span>, and <span class="math">q_{i-1,j}=G_{i-1}^{<em>}(s_{i-1,j})</span>, <span class="math">q_{i-1,j}^{\\prime}=G_{i-1}^{</em>}(s_{i-1,j}^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">Finally, define <span class="math">\\mathcal{D}=\\mathcal{D}_{k}\\cup\\mathcal{D}_{\\mathsf{f}}</span>. If <span class="math">(x,\\tau_{k-1})\\in\\mathcal{D}</span> then for any <span class="math">G_{k}^{<em>}=C\\in\\mathbb{F}</span> sent by <span class="math">P^{</em>}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{s_{0,1},\\ldots,s_{0,\\ell}\\overset{s}{\\leftarrow}L_{0}}[(x,\\tau_{k})\\notin\\mathcal{D}]\\leq(\\sqrt{\\rho}+\\eta)^{\\ell}\\leq(1-\\delta)^{\\ell}.</span></p>

    <p class="text-gray-300">The proof of Lemma 5.3 relies on the following lemma due to <em>[BCI^{+}20]</em>.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Lemma 5.4 (<em>[BCI^{+}20, Claim 8.5]</em>).</h6>

    <p class="text-gray-300">For <span class="math">\\delta</span>-far oracle <span class="math">G_{0}</span>, arbitrary oracles <span class="math">G_{i}^{<em>}\\colon L_{i}\\to\\mathbb{F}</span> for <span class="math">i\\in[k-1]</span>, and <span class="math">G_{k}^{</em>}\\in\\mathsf{RS}^{(k)}\\subset\\mathbb{F}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{s_{0}\\overset{s}{\\leftarrow}L_{0}}[V\\text{ of\\,Algorithm 1 accepts}]\\leq\\sqrt{\\rho}+\\eta.</span></p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Proof of Lemma 5.3.</h6>

    <p class="text-gray-300">Suppose that <span class="math">(x,\\tau_{k-1})\\in\\mathcal{D}</span> and <span class="math">G_{k}^{<em>}\\in\\mathbb{F}</span> is sent by <span class="math">P^{</em>}</span> during the final round of the protocol. By assumption, we know that <span class="math">\\Delta(G_{0}^{<em>},\\mathsf{RS}^{(0)})\\geq\\delta</span> for <span class="math">G_{0}^{</em>}=G_{0}</span>; we also know that <span class="math">G_{k}^{<em>}\\in\\mathsf{RS}^{(k)}</span> since <span class="math">\\mathsf{RS}^{(k)}</span> is the space of all constant-degree polynomials. Since <span class="math">(x,\\tau_{k-1})\\in\\mathcal{D}</span>, we also know that there exists index <span class="math">i\\in[k]</span> such that <span class="math">G_{i}^{</em>}\\neq H_{x_{i-1}}[G_{i-1}]</span> (as defined in Lemma 5.2) or <span class="math">H_{x_{i}}[G_{i}]</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i+1)}</span>. Then by Lemma 5.4, the probability the verifier accepts a single set of challenges induced by <span class="math">s_{0,1}\\overset{s}{\\leftarrow}L_{0}</span> is at most <span class="math">\\sqrt{\\rho}-\\eta\\leq(1-\\delta)</span> by definition of <span class="math">\\eta</span>. Noting that the <span class="math">\\ell</span> challenges are sampled independently and uniformly at random, this implies that the probability the verifier accepts all challenges induced by <span class="math">s_{0,1},\\ldots,s_{0,\\ell}</span> is at most <span class="math">(1-\\delta)^{\\ell}</span>. This implies that <span class="math">(x,\\tau_{k})\\notin\\mathcal{D}</span> with probability at most <span class="math">(\\sqrt{\\rho}+\\eta)^{\\ell}\\leq(1-\\delta)^{\\ell}</span>, as desired. ∎ ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Given Lemmas 5.2 and 5.3, we can now prove Theorem 4.1.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Proof of Theorem 4.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{D}</span> be the set defined in Lemma 5.3. By Lemma 5.2, we know that for any partial transcript <span class="math">(x,\\tau_{i-1})\\in\\mathcal{D}</span> for <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span> (where <span class="math">\\tau_{-1}:=\\emptyset</span>), we know that <span class="math">(x,\\tau_{i})\\notin\\mathcal{D}</span> with probability at most $[(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}]/[3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, where </span>\\tau_{i}=\\tau_{t-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{i}^{*}(z))_{z\\in L_{i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x_{i}}<span class="math"> for prover message </span>G_{i}^{*}<span class="math"> and verifier message </span>x_{i}<span class="math">. By Lemma 5.3, for any partial transcript </span>(x,\\tau_{k-1})\\in\\mathcal{D}<span class="math">, we know that </span>(x,\\tau_{k})\\notin\\mathcal{D}<span class="math"> with probability at most </span>(1-\\delta)^{\\ell}<span class="math">, where </span>\\tau_{k}=\\tau_{k-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{k}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(s_{0,1},\\ldots,s_{0,\\ell})<span class="math"> for prover message </span>G_{k}^{*}\\in\\mathbb{F}<span class="math"> and verifier message </span>(s_{0,1},\\ldots,s_{0,\\ell})<span class="math">. The result immediately follows: for any </span>i\\in\\{0,1,\\ldots,k\\}<span class="math"> if </span>(x,\\tau_{t-1})\\in\\mathcal{D}<span class="math"> then </span>(x,\\tau_{t})\\notin\\mathcal{D}<span class="math"> with probability at most </span>\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}$, where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell)=\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-93" class="text-xl font-semibold mt-8">5.1 Round-by-round Soundness of FRI in the Unique Decoding Radius</h3>

    <p class="text-gray-300">Theorem 4.1 holds for all <span class="math">\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)</span> where <span class="math">\\eta=\\sqrt{\\rho}/(2m)</span> for integer <span class="math">m\\geq 3</span> and <span class="math">\\rho</span> is the rate of the Reed-Solomon code <span class="math">\\mathsf{RS}^{(0)}</span>. However, we can also consider restricting <span class="math">\\delta</span> to the unique decoding radius of <span class="math">\\mathsf{RS}^{(0)}</span>, namely <span class="math">\\delta\\in(0,(1-\\rho)/2]</span>. In this case, we are able to get tighter bounds on the round-by-round soundness error of the FRI IOPP.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Corollary 5.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{*}<span class="math">. For any </span>\\delta\\in(0,(1-\\rho)/2]<span class="math"> and function </span>G_{0}\\colon L_{0}\\to\\mathbb{F}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, Algorithm 1 has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\delta,\\ell)=\\max\\left\\{\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The analysis of round-by-round soundness for Corollary 5.5 is identical to the analysis of Theorem 4.1. The new bound from the unique decoding regime follows from an improvement of Lemma 5.1 in the unique decoding regime.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Lemma 5.6 (<em>[BCI^{+}20, Theorem 4.1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\rho=2^{-(n-k)}</span>. For all <span class="math">\\delta\\in(0,(1-\\rho)/2]</span> and any <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span>, if <span class="math">G_{i}\\colon L_{i}\\to\\mathbb{F}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i)}</span> then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\stackrel{{\\scriptstyle x}}{{\\leftarrow}}\\mathbb{F}}\\left[\\Delta(H_{x}[G_{i}],\\mathsf{RS}^{(i+1)})\\leq\\delta\\right]<\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-96" class="text-xl font-semibold mt-8">5.2 Round-by-round Soundness of Batched FRI</h3>

    <p class="text-gray-300">A variant of the FRI protocol is the so-called Batched FRI protocol. In this protocol, the prover <span class="math">P</span> is given <span class="math">t\\geq 2</span> functions <span class="math">f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}</span> and needs to prove to the verifier <span class="math">V</span> that <span class="math">f_{i}^{(0)}\\in\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span> for all <span class="math">i\\in[t]</span>. Naïvely, the prover and verifier can simply run <span class="math">t</span> instances of Algorithm 1, but this is wasteful. Instead, the Batched FRI protocol does the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span> sends <span class="math">V</span> oracle access to <span class="math">f_{i}^{(0)}</span> for all <span class="math">i\\in[t]</span>.</li>

      <li><span class="math">V</span> samples <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}\\stackrel{{\\scriptstyle x}}{{\\leftarrow}}\\mathbb{F}</span> to <span class="math">P</span>.</li>

      <li><span class="math">P</span> and <span class="math">V</span> run Algorithm 1 on the function <span class="math">G_{0}(X):=\\sum_{i\\in[t]}\\alpha_{i}\\cdot f_{i}^{(0)}(X)</span>.</li>

    </ol>

    <p class="text-gray-300">In other words, Batched FRI has one additional round of interaction to obtain the function <span class="math">G_{0}</span>, then runs Algorithm 1 on this function.</p>

    <p class="text-gray-300">Notice that if <span class="math">f_{i}^{(0)}\\in\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span> for all <span class="math">i</span>, then <span class="math">G_{0}\\in\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>, so Batched FRI has the same completeness properties of Algorithm 1. The soundness guarantee of Batched FRI is that if at least one <span class="math">f_{i^{\\prime}}^{(0)}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span></p>

    <p class="text-gray-300">then the verifier rejects with high probability <em>[x1, BCI^{+}20, x26]</em>. Key to the soundness guarantee is arguing that if there is some <span class="math">i^{<em>}</span> such that <span class="math">f_{i^{</em>}}^{(0)}</span> is <span class="math">\\delta</span>-far, then with high probability the function <span class="math">G_{0}</span> is also <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>. We use this same guarantee to extend the round-by-round soundness analysis of Algorithm 1 to Batched FRI and prove the following theorem.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Theorem 4.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{+}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, and functions </span>f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}<span class="math"> for </span>t\\geq 2<span class="math"> such that at least one </span>f_{i}^{(0)}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}^{(0)}$, the Batched FRI protocol has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}:=\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t)=\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-98" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that Batched FRI is Algorithm 1 with one more round of communication between the prover and the verifier. Moreover, if <span class="math">G_{0}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>, then we are exactly in the same analysis as Theorem 4.1. Hence we analyze the first round of interaction of Batched FRI.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Towards round-by-round soundness, let $\\tau_{\\mathsf{batch}}:=\\{(f_{i}^{(0)}(z))_{z\\in L_{0}}\\}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\alpha_{1},\\ldots,\\alpha_{t})<span class="math"> denote the partial transcript of Batched FRI after the prover sends oracles </span>f_{i}^{(0)}<span class="math"> to the verifier and the verifier responds with challenges </span>\\alpha_{1},\\ldots,\\alpha_{t}<span class="math">. We define the set </span>\\mathcal{D}_{\\mathsf{batch}}<span class="math"> as follows: for </span>x\\notin\\mathcal{L}<span class="math"> (i.e., at least one </span>f_{i}^{(0)}<span class="math"> is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(x,\\emptyset)\\in\\mathcal{D}_{\\mathsf{batch}}</span>; and</li>

      <li><span class="math">(x,\\tau_{\\mathsf{batch}})\\in\\mathcal{D}_{\\mathsf{batch}}</span> if and only if <span class="math">G_{0}:=\\sum_{i}\\alpha_{i}f_{i}^{(0)}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>.</li>

    </ol>

    <p class="text-gray-300">By definition, we have <span class="math">(x,\\emptyset)\\in\\mathcal{D}_{\\mathsf{batch}}</span>, which tells us that at least one <span class="math">f_{i}^{(0)}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span>. Now over the sampling of <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}\\xleftarrow{s}\\mathbb{F}</span>, we want to bound the probability that <span class="math">(x,\\tau_{\\mathsf{batch}})\\notin\\mathcal{D}</span>; in other words, we bound the probability that <span class="math">G_{0}</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(0)}:=\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]</span> given that at least one <span class="math">f_{i}^{(0)}</span> is <span class="math">\\delta</span>-far. This probability is exactly given by the following lemma.</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Lemma 5.7 (<em>[x1, Theorem 7.4]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\rho=2^{-(n-k)}</span>. For all <span class="math">m\\geq 3</span>, <span class="math">\\eta\\in(0,\\sqrt{\\rho}/(2m)]</span> and <span class="math">\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)</span> and functions <span class="math">f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}</span> for <span class="math">t\\geq 2</span>, if at least one <span class="math">f_{i}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span> then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\alpha_{1},\\ldots,\\alpha_{t}\\xleftarrow{s}\\mathbb{F}}\\left[\\Delta(G_{0},\\mathsf{RS}^{(0)})<\\delta\\mid G_{0}=\\sum_{i}\\alpha_{i}f_{i}^{(0)}\\right]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above lemma immediately establishes the probability that <span class="math">(x,\\tau_{\\mathsf{batch}})\\notin\\mathcal{D}_{\\mathsf{batch}}</span> conditioned on <span class="math">(x,\\emptyset)\\in\\mathcal{D}_{\\mathsf{batch}}</span>; namely:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\alpha_{1},\\ldots,\\alpha_{t}\\xleftarrow{s}\\mathbb{F}}[(x,\\tau_{\\mathsf{batch}})\\notin\\mathcal{D}_{\\mathsf{batch}}]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now define doomed set <span class="math">\\mathcal{D}^{\\prime}:=\\mathcal{D}\\cup\\mathcal{D}_{\\mathsf{batch}}</span> where <span class="math">\\mathcal{D}</span> is defined in Lemma 5.3. Then clearly <span class="math">(x,\\emptyset)\\in\\mathcal{D}^{\\prime}</span> and <span class="math">(x,\\tau_{\\mathsf{batch}})\\notin\\mathcal{D}^{\\prime}_{t}</span> with the same probability as above. Finally, assume that <span class="math">(x,\\tau_{\\mathsf{batch}})\\in\\mathcal{D}^{\\prime}</span>. This implies that the prover and verifier now engage in Algorithm 1 on a function <span class="math">G_{0}</span> that is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span>, which is identical to the round-by-round soundness analysis of of Algorithm 1. Hence taking a max of the above probability and the probability stated in Theorem 4.1 gives us our final bound. ∎</p>

    <h4 id="sec-100" class="text-lg font-semibold mt-6">5.2.1 Round-by-round Soundness of Batched FRI in the Unique Decoding Regime</h4>

    <p class="text-gray-300">Much like Corollary 5.5, we can refine Theorem 4.2 in the unique decoding regime <span class="math">\\delta&lt;(1-\\rho)/2</span> via the following refinement of Lemma 5.7.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Lemma 5.8 (<em>[BCI^{+}20, Theorem 7.4]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\rho=2^{-(n-k)}</span>. For all <span class="math">\\delta\\in(0,(1-\\rho)/2]</span> and functions <span class="math">f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}</span> for <span class="math">t\\geq 2</span>, if at least one <span class="math">f_{i}^{(0)}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span> then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\alpha_{1},\\ldots,\\alpha_{t}\\overset{\\delta}{\\leftarrow}\\mathbb{F}}\\left[\\Delta(G_{0},\\mathsf{RS}^{(0)})<\\delta\\mid G_{0}=\\sum\\nolimits_{i}\\alpha_{i}f_{i}^{(0)}\\right]\\leq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Applying Lemma 5.8 in the proof of Theorem 4.2 gives us the following corollary.</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Corollary 5.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{+}<span class="math">. For any </span>\\delta\\in(0,(1-\\rho)/2]<span class="math"> and functions </span>f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}<span class="math"> for </span>t\\geq 2<span class="math"> such that at least one </span>f_{i}^{(0)}<span class="math"> is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}^{(0)}$, the Batched FRI protocol has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon^{\\mathsf{bFRI}}_{\\mathsf{rbr}}:=\\varepsilon^{\\mathsf{bFRI}}_{\\mathsf{rbr}}(\\mathbb{F},L_{0},\\delta,\\ell,t)=\\max\\left\\{\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-103" class="text-lg font-semibold mt-6">5.2.2 Communication-saving Batched FRI</h4>

    <p class="text-gray-300">As mentioned in Section 2.2, in practice Batched FRI often saves on communication complexity during the batched phase by having the verifier send a single <span class="math">\\alpha</span> to batch the functions <span class="math">f_{1}^{(0)},\\ldots,f_{t}^{(0)}</span>. The batching is then performed as <span class="math">G_{0}=\\sum_{i}\\alpha^{i-1}\\cdot f_{i}^{(0)}</span>. While this saves a factor of <span class="math">t</span> finite field elements in communication complexity, it comes at a cost of a factor <span class="math">t</span> blow-up in the soundness error, as characterized by the following lemma.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Lemma 5.10 (<em>[BCI^{+}20, Theorem 6.2]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\rho=2^{-(n-k)}</span>. For all <span class="math">m\\geq 3</span>, <span class="math">\\eta\\in(0,\\sqrt{\\rho}/(2m)]</span> and <span class="math">\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)</span> and functions <span class="math">f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}</span> for <span class="math">t\\geq 2</span>, if at least one <span class="math">f_{i}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span> then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\alpha\\overset{\\delta}{\\leftarrow}\\mathbb{F}}\\left[\\Delta(G_{0},\\mathsf{RS}^{(0)})<\\delta\\mid G_{0}=\\sum\\nolimits_{i}\\alpha^{i-1}f_{i}^{(0)}\\right]\\leq\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\cdot(t-1)}{3\\rho^{3/2}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, for <span class="math">\\delta\\leq(1-\\rho)/2</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\alpha\\overset{\\delta}{\\leftarrow}\\mathbb{F}}\\left[\\Delta(G_{0},\\mathsf{RS}^{(0)})<\\delta\\mid G_{0}=\\sum\\nolimits_{i}\\alpha^{i-1}f_{i}^{(0)}\\right]\\leq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(t-1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus using powers of <span class="math">\\alpha</span> for Batched FRI directly incurs a <span class="math">O(t)</span> blow-up in the round-by-round soundness error of the protocol.</p>

    <h3 id="sec-105" class="text-xl font-semibold mt-8">5.3 Round-by-round Knowledge Soundness of FRI</h3>

    <p class="text-gray-300">In this section, we show that the round-by-round knowledge error of FRI is identical to the round-by-round soundness error we established in Theorem 4.1 and Corollary 5.5.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Theorem 5.11.</h6>

    <p class="text-gray-300">For doomed set <span class="math">\\mathcal{D}</span> defined in Lemma 5.3, Algorithm 1 has round-by-round knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\mathsf{FRI}}_{\\mathsf{rbr-k}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell):=\\varepsilon^{\\mathsf{FRI}}_{\\mathsf{rbr}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell)</span></p>

    <p class="text-gray-300">for parameters <span class="math">\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell</span> and <span class="math">\\varepsilon^{\\mathsf{FRI}}_{\\mathsf{rbr}}</span> defined in Theorem 4.1. Moreover, for doomed set <span class="math">\\mathcal{D}^{\\prime}</span> defined in Section 5.2, Batched FRI has round-by-round knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\mathsf{bFRI}}_{\\mathsf{rbr-k}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t):=\\varepsilon^{\\mathsf{bFRI}}_{\\mathsf{rbr}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t)</span></p>

    <p class="text-gray-300">for parameters <span class="math">\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t</span> and <span class="math">\\varepsilon^{\\mathsf{bFRI}}_{\\mathsf{rbr}}</span> defined in Theorem 4.2.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{D}</span> be the doomed set defined in Lemma 5.3. We focus first on the Folding Phase of Algorithm 1. Let <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span> be the current round of the Folding Phase and let <span class="math">\\tau_{i-1}</span> be the partial transcript so far such that <span class="math">(x,\\tau_{i-1})\\in\\mathcal{D}</span>. By definition of <span class="math">\\mathcal{D}</span>, we have that either <span class="math">H_{x_{i-1}}[G_{i-1}]</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i)}</span> or there exists <span class="math">j\\in[i-1]</span> such that <span class="math">G_{j}^{<em>}\\neq H_{x_{j-1}}[G_{j-1}]</span>. Suppose that for any prover message <span class="math">G_{i}^{</em>}\\colon L_{i}\\to\\mathbb{F}</span>, it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\underset{x_{i}\\leftarrow\\mathbb{F}}{\\overset{\\mathrm{s}}{\\leftarrow}}}\\left[(x,\\tau_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(G_{i}^{*}(z))_{z\\in L_{i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i})\\notin\\mathcal{D}\\right]>\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First of all, this implies that <span class="math">G_{j}^{<em>}=H_{x_{j-1}}[G_{j-1}]</span> for all <span class="math">j\\in[i]</span> else the above expression does not hold. Thus we have that <span class="math">G_{i}^{</em>}=G_{i}=H_{x_{i-1}}[G_{i-1}]</span>; moreover, we have that <span class="math">G_{i-1}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i-1)}</span>. Rewriting the above probability, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{\\underset{x_{i}\\leftarrow\\mathbb{F}}{\\overset{\\mathrm{s}}{\\leftarrow}}}\\left[\\Delta(G_{i},\\mathsf{RS}^{(i)})\\leq\\delta\\mid\\Delta(G_{i-1},\\mathsf{RS}^{(i-1)})&gt;\\delta\\right]&gt;\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}.</span></p>

    <p class="text-gray-300">This is clearly a contradiction with Lemma 5.1, and thus it must hold that either the above probability is at most <span class="math">\\varepsilon</span> or that <span class="math">G_{i-1}</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(i-1)}</span>. The first case contradicts our assumption, so we turn to the second case. We now have that <span class="math">G_{i-1}</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(i-1)}</span>, which implies that <span class="math">(x,\\tau_{i-1})\\notin\\mathcal{D}</span>. Now this argument repeats for all <span class="math">G_{j}</span> for <span class="math">j\\in[i]</span>, which implies that <span class="math">G_{0}</span> is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(0)}</span>. Thus if we give our extractor the partial transcript <span class="math">\\tau_{i-1}</span> and oracle <span class="math">G_{i}^{*}</span>, the extractor simply outputs the first oracle <span class="math">G_{0}</span> contained in <span class="math">\\tau_{i-1}</span>, which is <span class="math">\\delta</span>-close to <span class="math">\\mathsf{RS}^{(0)}</span>, showing knowledge in this case.</p>

    <p class="text-gray-300">For partial transcript <span class="math">\\tau_{k-1}</span> such that <span class="math">(x,\\tau_{k-1})\\in\\mathcal{D}</span>, suppose that for all <span class="math">G_{k}^{*}\\in\\mathbb{F}</span> that the prover can send, it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\underset{x_{0,1},\\ldots,s_{0\\ell}\\leftarrow L_{0}}{\\overset{\\mathrm{s}}{\\leftarrow}}L_{0}}\\left[(x,\\tau_{k-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{k}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(s_{0,1},\\ldots,s_{0,\\ell}))\\notin\\mathcal{D}\\right]>\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This implies that with probability at least <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}</span>, the verifier of Algorithm 1 accepts. By the contrapositive of Lemma 5.4, this implies that either <span class="math">G_{k}^{<em>}\\notin\\mathsf{RS}^{(k)}</span> or <span class="math">G_{0}</span> is a <span class="math">\\delta</span>-close oracle. By definition of the protocol, we know that <span class="math">\\mathsf{RS}^{(k)}=\\mathbb{F}</span> and that the prover sends <span class="math">G_{K}^{</em>}\\in\\mathbb{F}</span> to the verifier. Thus it must hold that <span class="math">G_{0}</span> is a <span class="math">\\delta</span>-close oracle. Hence the extractor for this round and transcript again simply reads the first oracle message sent by the prover and outputs this as its witness. Finally, notice that the proof for Batched FRI proceeds identically as above with one more case to take into account a contradiction with Lemma 5.7. This completes the proof. ∎</p>

    <h3 id="sec-108" class="text-xl font-semibold mt-8">5.4 Non-interactive FRI in the Random Oracle Model</h3>

    <p class="text-gray-300">Finally, using the BCS transformation and its guarantees given in Theorem 3.15, we establish the Fiat-Shamir security of both FRI (Algorithm 1) and Batched FRI in the random oracle model. The results are stated below.</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Corollary 4.3 (FS Security of FRI).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{<em>}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, random oracle </span>\\mathcal{H}\\colon\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\kappa}<span class="math">, query bound </span>Q\\in\\mathbb{N}<span class="math">, and function </span>G_{0}\\colon L_{0}\\to\\mathbb{F}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, compiling Algorithm 1 with Theorem 3.15 gives a non-interactive random oracle proof with adaptive soundness error and knowledge error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{fs}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,Q,\\kappa)=Q\\cdot\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell)+\\frac{3(Q^{2}+1)}{2^{\\kappa}}.</span></p>

    <p class="text-gray-300">Moreover, if <span class="math">\\gamma:=\\gamma(\\mathbb{F},L_{0},\\rho,\\delta,\\ell)</span> denotes the length of a FRI proof for parameters <span class="math">\\mathbb{F},L_{0},\\rho,\\delta,\\ell</span>, then the above non-interactive random oracle proof has adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{FRI}}:=\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,Q,\\kappa)=\\Theta(Q\\cdot\\varepsilon_{\\mathsf{fs}}^{\\mathsf{FRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,Q,\\kappa))</span></p>

    <p class="text-gray-300">against quantum adversaries that can make at most <span class="math">Q-O(\\ell\\cdot\\log(\\gamma))</span> queries.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Corollary 4.4 (FS Security of Batched FRI).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> be a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, $\\rho=d_{0}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-(n-k)}<span class="math">, and </span>\\ell\\in\\mathbb{Z}^{<em>}<span class="math">. For any integer </span>m\\geq 3<span class="math">, </span>\\eta\\in(0,\\sqrt{\\rho}/(2m))<span class="math">, </span>\\delta\\in(0,1-\\sqrt{\\rho}-\\eta)<span class="math">, random oracle </span>\\mathcal{H}\\colon\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\kappa}<span class="math">, query bound </span>Q\\in\\mathbb{N}<span class="math">, and functions </span>f_{1}^{(0)},\\ldots,f_{t}^{(0)}\\colon L_{0}\\to\\mathbb{F}<span class="math"> for </span>t\\geq 2<span class="math"> such that at least one </span>f_{t}^{(0)}<span class="math"> is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}[\\mathbb{F},L_{0},d_{0}]$, compiling Batched FRI with Theorem 3.15 gives a non-interactive random oracle proof with adaptive soundness error and knowledge error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs}}^{\\mathsf{bFRI}}\\coloneqq\\varepsilon_{\\mathsf{fs}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t,Q,\\kappa)=Q\\cdot\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,m,\\ell,t)+\\frac{3(Q^{2}+1)}{2^{\\kappa}}.</span></p>

    <p class="text-gray-300">Moreover, if <span class="math">\\gamma\\coloneqq\\gamma(\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t)</span> denotes the length of a Batched FRI proof for parameters <span class="math">\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t</span>, then the above non-interactive random oracle proof has adaptive soundness error and knowledge error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{bFRI}}\\coloneqq\\varepsilon_{\\mathsf{fs-q}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t,Q,\\kappa)=\\Theta(Q\\cdot\\varepsilon_{\\mathsf{fs}}^{\\mathsf{bFRI}}(\\mathbb{F},L_{0},\\rho,\\delta,\\ell,t,Q,\\kappa))</span></p>

    <p class="text-gray-300">against quantum adversaries that can make at most <span class="math">Q-O(\\ell\\cdot\\log(\\gamma))</span> queries.</p>

    <p class="text-gray-300">Note that the security we obtain in Corollaries 4.3 and 4.4 depends on the values of <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}</span> and <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}</span>, respectively. In particular, in the unique decoding radius we can apply Corollaries 5.5 and 5.9 to obtain better security in Corollaries 4.3 and 4.4, and otherwise apply Theorems 4.1 and 4.2 when considering <span class="math">\\delta&gt;(1-\\rho)/2</span>.</p>

    <h3 id="sec-111" class="text-xl font-semibold mt-8">5.5 Conjectured Security of FRI</h3>

    <p class="text-gray-300">The error <span class="math">(1-\\delta)^{\\ell}</span> is the best one can hope for in the FRI Query Phase, and for the Folding Phase the best known provable security bounds for FRI and Batched FRI beyond the unique decoding radius are exactly given by Lemmas 5.1, 5.7 and 5.10. However, many implemented and deployed versions of FRI are running at parameters obtained by assuming certain conjectured security bounds for FRI and Batched FRI <em>[BCI^{+}20, Sta23]</em>. These conjectured security bounds roughly assume that the best-known attacks against FRI (a so-called “interpolation attack”) are, in fact, optimal. We do not make or claim any progress on the state of these conjectures; however, we state them here and show how they affect the round-by-round soundness errors of FRI and Batched FRI.</p>

    <p class="text-gray-300">We state two conjectures here. The first conjecture appears in the best known provable security bounds for FRI due to Ben-Sasson et al. <em>[BCI^{+}20]</em>, which we restate in a different way to fit our results.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Conjecture 5.12 (<em>[BCI^{+}20]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>, <span class="math">d_{0}=2^{k}</span>, and <span class="math">\\rho=2^{-(n-k)}</span>. There exists constants <span class="math">c_{1}</span> and <span class="math">c_{2}</span> such that for all <span class="math">\\eta&gt;0</span> and any <span class="math">\\delta\\leq 1-\\rho-\\eta</span>, for any function <span class="math">G_{i}\\colon L_{i}\\to\\mathbb{F}</span> that is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(i)}</span> we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\stackrel{{\\scriptstyle x}}{{\\leftarrow}}\\mathbb{F}}\\left[\\Delta(H_{x}[G_{i}],\\mathsf{RS}^{(i+1)})\\leq\\delta\\right]\\leq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{c_{2}}}{(\\rho\\eta)^{c_{1}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, for any <span class="math">f_{1},f_{2},\\ldots,f_{t}\\colon L_{0}\\to\\mathbb{F}</span> such that at least one <span class="math">f_{j}</span> is <span class="math">\\delta</span>-far from <span class="math">\\mathsf{RS}^{(0)}</span>, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\alpha_{1},\\ldots,\\alpha_{t}\\stackrel{{\\scriptstyle x}}{{\\leftarrow}}\\mathbb{F}}\\left[\\Delta(G_{0},\\mathsf{RS}^{(0)})\\leq\\delta\\mid G_{0}=\\sum_{i}\\alpha_{i}f_{i}\\right]\\leq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{c_{2}}}{(\\rho\\eta)^{c_{1}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">};$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ben-Sasson et al. <em>[BCI^{+}20]</em> state that “To the best of our knowledge, nothing contradicts setting <span class="math">c_{1}=c_{2}=2</span>”, and when <span class="math">\\mathbb{F}</span> has characteristic larger than <span class="math">d_{0}</span> similarly state that they “are not aware of anything contradicting <span class="math">c_{1}=c_{2}=1</span>”. However, they do note that if <span class="math">\\mathbb{F}</span> has characteristic 2 (e.g., $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{m}<span class="math"> for </span>m\\geq 1<span class="math">) then </span>c_{1}=c_{2}=1$ is impossible due to an attack given in <em>[BGKS20]</em>. Thus one can appropriately adjust Lemmas 5.1, 5.7 and 5.10 using Conjecture 5.12 to obtain better soundness guarantees in Theorems 4.1 and 4.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The second conjecture we state for round-by-round soundness of FRI is distilled from a (non-explicit) conjecture made in the ethSTARK documentation (See <em>[Sta23, Section 5.9.1]</em>) about the soundness of a small variant of FRI. While</p>

    <p class="text-gray-300">this conjecture is more aggressive than Conjecture 5.12, again the best known attacks do not contradict this conjecture. For context, we go over the ethSTARK conjecture here.</p>

    <p class="text-gray-300">The ethSTARK conjecture about a variant of FRI is actually a conjecture made about a “Toy Problem Protocol”. This Toy Problem Protocol operates as follows. Fix <span class="math">\\rho</span> to be a positive constant and fix <span class="math">L</span> to be a multiplicative subgroup of a finite field <span class="math">\\mathbb{F}</span> of size <span class="math">2^{k}/\\rho</span>, where <span class="math">k\\geq 0</span>. Then this toy protocol operates as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First a prover sends oracle access to some function <span class="math">f\\colon L_{0}\\to\\mathbb{F}</span> (e.g., purported to be an RS codeword).</li>

      <li>Next the verifier samples <span class="math">\\alpha\\xleftarrow{\\text{*}}\\mathbb{F}</span> and sends it to the prover.</li>

      <li>The prover and verifier run FRI with respect to the new function <span class="math">g(x)=(f(x)-\\alpha)/x</span>.</li>

    </ul>

    <p class="text-gray-300">Now the actual ethSTARK conjecture relates this toy problem to the ethSTARK IOP which invokes FRI. The actual conjecture is informally stated as follows.</p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Conjecture 5.13 (ethSTARK Conjecture, Informal).</h6>

    <p class="text-gray-300">If a <span class="math">T</span>-time malicious prover attacks the toy problem over finite field <span class="math">\\mathbb{F}</span>, rate <span class="math">\\rho</span>, and <span class="math">k\\geq 0</span>, and succeeds with probability <span class="math">\\epsilon</span>, then the ethSTARK IOP invoking FRI over <span class="math">\\mathbb{F}</span>, <span class="math">\\rho</span>, and <span class="math">k</span> can be attacked in time <span class="math">T</span> with success probability <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Conversely, if a <span class="math">T</span>-time malicious prover attacks the ethSTARK IOP using FRI over finite field <span class="math">\\mathbb{F}</span>, rate <span class="math">\\rho</span>, and <span class="math">k\\geq 0</span>, and succeeds with probability <span class="math">\\epsilon</span>, then the toy problem with finite field <span class="math">\\mathbb{F}</span>, rate <span class="math">\\rho</span>, and <span class="math">k</span> can be attacked in time <span class="math">T</span> with success probability <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">We remark that key to the above conjecture and the toy problem is that FRI is not being applied on the function <span class="math">f</span> but rather a function <span class="math">g</span> derived from <span class="math">f</span> in a randomized manner by the verifier. Moreover, this also occurs in the case of Batched FRI as well: the prover sends multiple <span class="math">f_{1},\\ldots,f_{t}</span> and the verifier sends <span class="math">\\alpha_{1},\\ldots,\\alpha_{t}</span>, and the prover and verifier engage in Batched FRI on the functions <span class="math">g_{i}(x)=(f_{i}(x)-\\alpha_{i})/x</span>.</p>

    <p class="text-gray-300">The above conjecture posits that soundness error of the toy problem characterizes the soundness error of commonly deployed FRI-based SNARKs. The following conjecture essentially states that known attacks on the toy problem are optimal. A conjecture in this vein is implicit in <em>[x23]</em>.</p>

    <h6 id="sec-114" class="text-base font-medium mt-4">Conjecture 5.14.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">L_{0}\\subset\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of size <span class="math">2^{n}</span>. For any $\\rho\\in(0,1-1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>d_{0}=\\rho\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and any </span>\\delta\\leq 1-\\rho<span class="math">, running the toy problem on function </span>f\\colon L_{0}\\to\\mathbb{F}<span class="math"> that is </span>\\delta<span class="math">-far from </span>\\mathsf{RS}^{(0)}$ has round-by-round soundness error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max\\left\\{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the toy problem applied FRI to <span class="math">f</span> itself, rather than to <span class="math">g</span>, then over some fields there are known attacks that would contradict the Conjecture 5.14 (in particular, the $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ term would need to increase) <em>[x1, Section 3.1]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-115" class="text-xl font-semibold mt-8">5.6 Concrete Security Analysis of Non-interactive FRI</h3>

    <p class="text-gray-300">Having established the Non-Interactive security of (Batched) FRI, we are interested in analyzing the concrete bits of security of this protocol under various parameter settings, including those used in practice. As this concrete security analysis is somewhat involved and of a different flavor the the rest of the paper, we refer the reader to Appendix A for the complete analysis.</p>

    <p class="text-gray-300">|  Algorithm 1: FRI-IOPP  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: Finite field F, smooth multiplicative subgroup L0 ⊂ F* of size 2n, degree bound d0 = 2k, and ℓ ∈ N. P has function G0: L0 → F and V has oracle (G0(z))z∈L0. Output: The verifier V outputs accept or reject.  |   |</p>

    <p class="text-gray-300">|  1 foreach i ∈ [k] do // Fold Phase  |   |</p>

    <p class="text-gray-300">|  2 V sends xi-1← F to P.  |   |</p>

    <p class="text-gray-300">|  3 P and V set di := di-1/2 and Li := {z2: z ∈ Li-1}.  |   |</p>

    <p class="text-gray-300">|  4 P computes unique bi-variate polynomial Qi-1(X,Y) such that 1. degX(Qi-1) = 1; 2. degY(Qi-1) < di; and 3. Gi-1(r) = Qi-1(r,r2) for all r ∈ Li-1.  |   |</p>

    <p class="text-gray-300">|  5 P defines Gi(Y) := Qi-1(xi-1,Y).  |   |</p>

    <p class="text-gray-300">|  6 if i = k then P sends Gk = C ∈ F to V.  |   |</p>

    <p class="text-gray-300">|  8 else P sends oracle (Gi(z))z∈Li to V.  |   |</p>

    <p class="text-gray-300">|  10 for all j ∈ [l] do // Query Phase; processed in parallel  |   |</p>

    <p class="text-gray-300">|  11 V samples s0,j← L0.  |   |</p>

    <p class="text-gray-300">|  12 foreach i ∈ [k] do  |   |</p>

    <p class="text-gray-300">|  13 V computes si,j = (si-1,j)2 and si-1,j ≠ si-1,j such that (si-1,j)2 = si,j.  |   |</p>

    <p class="text-gray-300">|  14 V queries and obtains qi-1,j = Gi-1(si-1,j) and qi-1,j = Gi-1(si-1,j).  |   |</p>

    <p class="text-gray-300">|  15 V computes linear polynomial Qi-1,j(X) via Lagrange interpolation on the set {(si-1,j, qi-1,j), (si-1,j, qi-1,j)}.  |   |</p>

    <p class="text-gray-300">|  16 V checks that Gi(si,j) = Qi-1,j(xi-1) by querying Gi.  |   |</p>

    <p class="text-gray-300">|  17 if Gi(si,j) ≠ Qi-1,j(xi-1) then V outputs reject.  |   |</p>

    <p class="text-gray-300">|  19 V outputs accept.  |   |</p>

    <p class="text-gray-300"><span class="math">\\delta</span>-Correlated Holographic IOPs</p>

    <p class="text-gray-300">In this section we introduce a specific type of hIOP for indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relations. In this type of hIOP, we fix <span class="math">0\\leq\\delta&lt;1</span> and assume the verifier has an oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> for the correlated agreement relation <span class="math">\\mathbf{CoAgg}(\\delta)</span> (defined in Definition 3.10). Furthermore, we assume that the verifier’s final verification process consists of: (1) checking that the oracles sent by the prover satisfy a certain polynomial equation on a random point <span class="math">\\mathfrak{z}</span> (not necessarily from <span class="math">D</span>); and (2) using <span class="math">\\mathsf{OCoAgg}(\\delta)</span> to check that the maps corresponding to certain oracles have correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span> (see Definition 6.1 for details). We call this type of hIOP a <span class="math">\\delta</span>-correlated hIOP and denote such a protocol as <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span>. Given a <span class="math">\\delta</span>-correlated hIOP <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span>, one can consider variations of it by changing the parameter <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">The main result of this section is a general result that proves that if a <span class="math">0</span>-correlated hIOP <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR soundness error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}</span> or RBR knowledge error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}</span>, then, for any <span class="math">\\delta&gt;0</span>, the <span class="math">\\delta</span>-correlated hIOP <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness or RBR knowledge with errors <span class="math">\\varepsilon_{\\mathsf{rbr-s}}/(2\\eta\\sqrt{\\rho})</span> or <span class="math">\\varepsilon_{\\mathsf{rbr-k}}/(2\\eta\\sqrt{\\rho})</span>, respectively, where <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span>, <span class="math">\\rho</span> is the rate of the RS code <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>, and <span class="math">\\eta&gt;0</span> is a parameter.</p>

    <p class="text-gray-300">Furthermore, we also prove that if <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness and RBR knowledge errors <span class="math">\\varepsilon_{\\mathsf{rbr-s}}^{\\prime}</span> and <span class="math">\\varepsilon_{\\mathsf{rbr-k}}^{\\prime}</span>, respectively, then one can replace the oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> from <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> with an IOPP <span class="math">\\Pi_{\\mathsf{CA}}</span> for <span class="math">\\delta</span>-correlated agreement (e.g., FRI) and the resulting protocol <span class="math">\\Pi_{\\mathsf{compiled}}</span> remains RBR sound and RBR knowledge sound so long as <span class="math">\\Pi_{\\mathsf{CA}}</span> is RBR sound. Furthermore, we also prove that if <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness and RBR knowledge errors <span class="math">\\varepsilon_{\\mathsf{rbr-s}}^{\\prime}</span> and <span class="math">\\varepsilon_{\\mathsf{rbr-k}}^{\\prime}</span>, respectively, then one can replace the oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> from <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> with an IOPP <span class="math">\\Pi_{\\mathsf{CA}}</span> for <span class="math">\\delta</span>-correlated agreement (e.g. batched FRI) and the resulting protocol <span class="math">\\Pi_{\\mathsf{compiled}}</span> remains RBR sound and RBR knowledge sound as long as <span class="math">\\Pi_{\\mathsf{CA}}</span> is RBR sound. In particular, it is not required that <span class="math">\\Pi_{\\mathsf{CA}}</span> is RBR knowledge sound to guarantee that <span class="math">\\Pi_{\\mathsf{compiled}}</span> is RBR knowledge sound, as long as <span class="math">\\Pi</span> is RBR knowledge sound and <span class="math">\\Pi_{\\mathsf{CA}}</span> is RBR sound. More formally, we show that the protocol <span class="math">\\Pi_{\\mathsf{compiled}}</span> has RBR soundness and RBR knowledge errors <span class="math">\\max\\{\\varepsilon_{\\mathsf{rbr-s}}^{\\prime},\\varepsilon_{\\mathsf{CA}}\\}</span> and <span class="math">\\max\\{\\varepsilon_{\\mathsf{rbr-k}}^{\\prime},\\varepsilon_{\\mathsf{CA}}\\}</span>, respectively, where <span class="math">\\varepsilon_{\\mathsf{CA}}</span> is the RBR soundness of <span class="math">\\Pi_{\\mathsf{CA}}</span>.</p>

    <p class="text-gray-300">As discussed in the introductory Section 1.2.2, our results can be used to “streamline” proving that some types of SNARGs have knowledge soundness by:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Formulating the SNARG as being built on top of a <span class="math">0</span>-correlated hIOP <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span>;</li>

      <li>Proving that <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR soundness and RBR knowledge;</li>

      <li>Using our results (Theorem 4.6) to obtain a compiled hIOP with RBR soundness and RBR knowledge; and</li>

      <li>Using the BCS transformation <em>[x1]</em> (i.e., Theorem 3.15) to obtain the final knowledge sound SNARG, i.e. the final SNARK.</li>

    </ul>

    <p class="text-gray-300">As we will see later, both Plonky2 (and some of its variations), and ethSTARK can be analyzed in this manner.</p>

    <p class="text-gray-300">Our notion of <span class="math">\\delta</span>-correlated hIOP takes inspiration, and is related to, the notion of <em>Reed-Solomon encoded IOP’s</em> <em>[x10]</em>; see Appendix B for a discussion. Before giving our definition, we introduce the following notation. Let <span class="math">\\Pi</span> be a hIOP for an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation. Given a (possibly partial) transcript <span class="math">(\\pi,\\tau)</span> generated during the interaction of a (possibly malicious) prover and the verifier, let <span class="math">\\llbracket\\mathsf{Words}(\\pi,\\tau)\\rrbracket</span> be all the oracles appearing in <span class="math">(\\pi,\\tau)</span>, and let <span class="math">\\mathsf{Words}(\\pi,\\tau)</span> be the words from <span class="math">\\mathbb{F}^{D}</span> behind these oracles (i.e., the full descriptions of these oracles). We fix <span class="math">D</span> to be a smooth multiplicative subgroup of <span class="math">\\mathbb{F}^{*}</span> of order <span class="math">d=2^{v}/\\rho</span> for some rate <span class="math">0&lt;\\rho&lt;1</span> and <span class="math">v\\geq 0</span>, and generated by an element <span class="math">\\omega</span>. This defines the RS code <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Definition 6.1 (<span class="math">\\delta</span>-correlated hIOP).</h6>

    <p class="text-gray-300">Let <span class="math">0\\leq\\delta&lt;1</span>, and let <span class="math">\\mathbf{R}</span> be an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation (as defined in Definition 3.8). We say a hIOP <span class="math">\\Pi</span> is <span class="math">\\delta</span>-correlated if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier has access to an oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> for the <span class="math">\\delta</span>-correlated agreement relation <span class="math">\\mathbf{CoAgg}(\\delta)</span>. As such, we use the notation <span class="math">\\mathsf{V}^{\\mathsf{OCoAgg}(\\delta)}</span> to refer to such a verifier.</li>

      <li>For all <span class="math">(\\mathfrak{i},\\pi,\\mathrm{w})\\in\\mathbf{R}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the last round of interaction between <span class="math">\\mathsf{P}(\\mathsf{Ind}(\\mathfrak{i}),\\pi,\\mathrm{w})</span> and <span class="math">\\mathsf{V}^{\\mathsf{Ind}(\\mathfrak{i}),\\mathsf{OCoAgg}(\\delta)}(\\pi)</span>, the verifier sends a field element <span class="math">\\mathfrak{z}</span>, uniformly sampled in a subset of <span class="math">\\mathbb{F}</span> or a field extension of <span class="math">\\mathbb{F}</span>, and the honest prover replies with the</li>

    </ul>

    <p class="text-gray-300">values</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Evals}(\\pi,\\tau,\\mathfrak{z}):=(w(\\omega^{k_{w,i}}\\mathfrak{z}),\\ldots,w(\\omega^{k_{w,n_{w}}}\\mathfrak{z})\\mid w\\in\\textit{Words}(\\pi,\\tau)),</span></p>

    <p class="text-gray-300">where <span class="math">\\tau</span> is the transcript so far, and</p>

    <p class="text-gray-300"><span class="math">\\kappa:=\\{k_{w,i}\\mid w\\in\\textit{Words}(\\pi,\\tau),i\\in[n_{w}]\\}</span></p>

    <p class="text-gray-300">is a fixed set of integers (which is output by <span class="math">\\mathsf{Ind}</span>).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To decide whether to accept or reject a proof, <span class="math">\\mathsf{V}^{\\mathsf{Ind}(\\mathfrak{i}),\\mathsf{OCoAgg}(\\delta)}(\\pi)</span> makes the following two checks:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check 1. Assert whether the received values <span class="math">\\mathsf{Evals}(\\tau,\\mathfrak{z})</span> are a root to certain multivariate polynomial <span class="math">F_{\\mathfrak{i},\\pi,\\tau}</span> (which depends on <span class="math">\\mathfrak{i},\\pi,\\tau</span>).</li>

      <li>Check 2. Assert whether the maps</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{quotients}(\\pi,\\tau,\\mathfrak{z}):=\\left\\{\\frac{w(X)-w(\\omega^{k_{w,j}}\\mathfrak{z})}{X-\\omega^{k_{w,j}}\\mathfrak{z}}\\mid w\\in\\textit{Words}(\\pi,\\tau),j\\in[n_{w}]\\right\\}</span></p>

    <p class="text-gray-300">have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d-1]</span> by using the oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> on the oracles to such maps.</p>

    <p class="text-gray-300">We will use the notation <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span> when referring to a <span class="math">\\delta</span>-correlated hIOP.</p>

    <p class="text-gray-300">We now turn to our main theorem of this section.</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Theorem 4.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(0)}=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V}^{\\mathsf{OCoAgg}(0)})</span> be a <span class="math">\\mu</span>-round <span class="math">0</span>-correlated hIOP for an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation <span class="math">\\mathbf{R}</span>. Let <span class="math">0&lt;\\delta&lt;1-\\sqrt{\\rho}</span>, where $\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and let </span>\\Pi_{\\mathsf{CA}}<span class="math"> be a IOPP for </span>\\delta<span class="math">-correlated agreement in </span>\\mathsf{RS}[\\mathbb{F},D,d]<span class="math">. Let </span>\\eta>0<span class="math"> be such that </span>\\delta=1-\\sqrt{\\rho}-\\eta<span class="math">. Assume </span>\\Pi_{\\mathsf{CA}}<span class="math"> is RBR sound with error </span>\\varepsilon_{\\mathsf{CA}}$. Then the following hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(0)}</span> is RBR sound with error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}</span>. Then there exists a hIOP <span class="math">\\Pi</span> for <span class="math">\\mathbf{R}</span> with RBR soundness error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\varepsilon^{\\prime}(\\mathfrak{i}):=\\max\\left\\{\\frac{\\varepsilon_{\\mathsf{rbr-s}}(\\mathfrak{i})}{2\\eta\\sqrt{\\rho}},\\varepsilon_{\\mathsf{CA}}(\\mathfrak{i}_{\\mathsf{CA}})\\right\\},</span></p>

    <p class="text-gray-300">where <span class="math">\\mathfrak{i}_{\\mathsf{CA}}=(\\mathbb{F},D,d,\\delta,N)</span>, and <span class="math">N</span> is the number of words whose <span class="math">\\delta</span>-correlated agreement is checked in the last verification check of <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\mu(\\mathfrak{i},\\pi)\\geq 1</span> for all <span class="math">\\mathfrak{i},\\pi</span> and <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(0)}</span> has RBR knowledge error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}</span>, then <span class="math">\\Pi</span> has RBR knowledge error</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\max\\left\\{\\frac{\\varepsilon_{\\mathsf{rbr-k}}(\\mathfrak{i})}{2\\eta\\sqrt{\\rho}},\\varepsilon_{\\mathsf{CA}}(\\mathfrak{i}_{\\mathsf{CA}})\\right\\},</span></p>

    <p class="text-gray-300">where <span class="math">\\mathfrak{i}_{\\mathsf{CA}}</span> has the same meaning as in above.</p>

    <p class="text-gray-300">We prove Theorem 4.6 in two steps. First, given the RBR soundness (knowledge) of <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(0)}</span>, we show that the <span class="math">\\delta</span>-correlated hIOP <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness (or knowledge) error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}(\\mathfrak{i})/2\\eta\\sqrt{\\rho}</span> (or <span class="math">\\varepsilon_{\\mathsf{rbr-k}}(\\mathfrak{i})/2\\eta\\sqrt{\\rho}</span>). Afterward, we use <span class="math">\\Pi_{\\mathsf{CA}}</span> to compile <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span> into a hIOP with the RBR soundness (and/or RBR knowledge) claimed in the theorem.</p>

    <p class="text-gray-300">Given <span class="math">\\mathfrak{i}</span> and <span class="math">\\pi</span>, we let <span class="math">\\text{PartTr}_{i}(\\mathfrak{i},\\pi)</span> be the set of partial transcripts <span class="math">(\\pi,\\tau)</span> where, using the index <span class="math">\\mathfrak{i}</span>, the prover and the verifier have exchanged each <span class="math">i</span> messages, and the prover is about to move (i.e., it is about to send a message to the verifier). We convene that <span class="math">\\text{PartTr}_{0}(\\mathfrak{i},\\pi)=\\{(\\pi)\\}</span>.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Lemma 4.7.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(0)}=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V}^{\\mathsf{OCoAgg}(0)})</span> be a <span class="math">\\mu</span>-round <span class="math">0</span>-correlated hIOP for an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation <span class="math">\\mathbf{R}</span>. Let <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span>. The following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> is RBR sound with error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}</span>. Then <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR soundness error <span class="math">\\varepsilon_{\\mathsf{rbr-s}}(\\dot{\\mathfrak{i}})/(2\\eta\\sqrt{\\rho})</span>.</li>

      <li>Suppose that <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR knowledge with error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}</span>. Then <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR knowledge error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}(\\dot{\\mathfrak{i}})/(2\\eta\\sqrt{\\rho})</span>,</li>

    </ul>

    <h6 id="sec-120" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We begin by introducing some terminology. Fix and index and input pair <span class="math">(\\dot{\\mathfrak{i}},\\pi)</span>. For ease of presentation we denote <span class="math">\\mathsf{P}(\\mathsf{Ind}(\\dot{\\mathfrak{i}}),\\pi,\\mathfrak{w})</span> and <span class="math">\\mathsf{V}^{\\mathsf{Ind}(\\dot{\\mathfrak{i}}),\\mathsf{OCoAgg}(\\delta)}(\\pi)</span> simply by <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}^{\\mathsf{OCoAgg}(\\delta)}</span>. Given a (possibly partial) transcript <span class="math">(\\pi,\\tau)</span> generated during the interaction of (a possibly malicious) <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}^{\\mathsf{OCoAgg}(\\delta)}</span>, we let <span class="math">\\mathrm{PolyTr}(\\pi,\\tau)</span> be the set of partial transcripts <span class="math">\\pi,\\tau^{\\prime}</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All words in <span class="math">\\mathrm{Words}(\\pi,\\tau^{\\prime})</span> are codewords from <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>.</li>

      <li>The words in <span class="math">\\mathrm{Words}(\\pi,\\tau)</span> have <span class="math">\\delta</span>-correlated agreement <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span> with the words in <span class="math">\\mathrm{Words}(\\pi,\\tau^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">We agree that <span class="math">\\mathrm{PolyTr}(\\pi)=\\{(\\pi)\\}</span>. We first prove the claim on the RBR soundness of <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span>. Assume <span class="math">\\pi\\notin\\mathcal{L}_{\\mathbf{R}_{i}}</span>. Let <span class="math">\\mathcal{A}</span> be a malicious prover. Let <span class="math">\\mathcal{D}_{0}(\\dot{\\mathfrak{i}})</span> be a doomed set for <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span>, with respect to which <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR soundness <span class="math">\\varepsilon_{\\mathsf{rbr-s}}(\\dot{\\mathfrak{i}})</span>. Define a new doomed set <span class="math">\\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}})</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\pi,\\emptyset)\\in\\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}})</span> if and only if <span class="math">(\\pi,\\emptyset)\\in\\mathcal{D}_{0}(\\dot{\\mathfrak{i}})</span>.</li>

      <li><span class="math">\\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}})</span> contains all partial transcripts <span class="math">(\\pi,\\tau)\\in\\mathrm{PartTr}_{i}(\\dot{\\mathfrak{i}},\\pi)</span> such that <span class="math">(\\pi,\\tau^{\\prime})\\in\\mathcal{D}_{0}(\\dot{\\mathfrak{i}})</span> for all <span class="math">(\\pi,\\tau^{\\prime})\\in\\mathrm{PolyTr}(\\pi,\\tau)</span>.</li>

    </ul>

    <p class="text-gray-300">Formally:</p>

    <p class="text-gray-300">\\[ \\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}}):=\\left\\{(\\pi,\\tau)\\begin{array}[]{l}\\exists\\ i=0,\\ldots,\\mu(\\dot{\\mathfrak{i}},\\pi)\\ \\ \\text{such that}\\ \\tau\\in\\mathrm{PartTr}_{i}(\\dot{\\mathfrak{i}},\\pi),\\\\ \\forall\\ (\\pi,\\tau^{\\prime})\\in\\mathrm{PolyTr}(\\pi,\\tau)\\ \\ \\text{we have}\\ (\\pi,\\tau^{\\prime})\\in\\mathcal{D}_{0}(\\dot{\\mathfrak{i}})\\end{array}\\right\\}, \\]</p>

    <p class="text-gray-300">We will prove that <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> is RBR sound (respectively, has RBR knowledge) with the errors claimed in the statement of the lemma, with respect to the doomed set <span class="math">\\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}})</span>.</p>

    <p class="text-gray-300">Indeed, suppose first that <span class="math">\\tau</span> is a complete transcript and <span class="math">\\mathsf{V}^{\\mathsf{OPlonky}(\\delta)}</span> accepts <span class="math">\\tau</span>. We will prove that then <span class="math">(\\pi,\\tau)\\notin\\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}})</span>. This will imply that all complete transcripts in <span class="math">\\mathcal{D}_{\\delta}(\\dot{\\mathfrak{i}})</span> are rejected by <span class="math">\\mathsf{V}^{\\mathsf{OPlonky}(\\delta)}</span>, which is one of the clauses in the definition of RBR soundness and RBR knowledge soundness.</p>

    <p class="text-gray-300">Let <span class="math">\\mathrm{Words}(\\pi,\\tau)=\\{w_{1},\\ldots,w_{K}\\}</span> and let <span class="math">\\mathsf{Evals}(\\pi,\\tau,\\mathfrak{z})</span> be the prover’s last message, containing, purportedly, the values <span class="math">w(\\omega^{k_{w,j}}\\mathfrak{z})</span> for each <span class="math">w\\in\\mathrm{Words}(\\tau)</span> and each <span class="math">j\\in[n_{w}]</span>. Suppose that the words</p>

    <p class="text-gray-300"><span class="math">\\mathsf{quotients}(\\pi,\\tau,\\mathfrak{z})</span></p>

    <p class="text-gray-300">have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d-1]</span> on a set <span class="math">S</span>. We claim that then <span class="math">\\mathrm{Words}(\\pi,\\tau)</span> have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>. Moreover, we claim that then there exists a list <span class="math">U(\\pi,\\tau):=\\{u_{w}\\mid w\\in\\mathrm{Words}(\\pi,\\tau)\\}</span> of polynomials of degree <span class="math">&lt;d</span> such that each <span class="math">u_{w}</span> agrees with <span class="math">w</span> on <span class="math">S</span>, and moreover <span class="math">w(\\omega^{k_{w,j}}\\mathfrak{z})=u_{w}(\\omega^{k_{w,j}}\\mathfrak{z})</span>, for all <span class="math">w\\in\\mathrm{Words}(\\pi,\\tau)</span> and <span class="math">j\\in[n_{w}]</span>.</p>

    <p class="text-gray-300">To prove these claims, note that, for all <span class="math">w\\in\\mathrm{Words}(\\pi,\\tau)</span> and <span class="math">j\\in[n_{w}]</span>, there exists a polynomial <span class="math">q_{w,j}(X)</span> of degree <span class="math">&lt;d</span> such that</p>

    <p class="text-gray-300"><span class="math">w(X)=(X-\\omega^{k_{w,j}}\\mathfrak{z})q_{w,j}(X)+w(\\omega^{k_{w,j}}\\mathfrak{z})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">on the set <span class="math">S</span>. Denote the right-hand side polynomial by <span class="math">v_{w,j}(X)</span>. Notice that since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we have </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d<span class="math">, since </span>(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>d<span class="math"> if and only if </span>(1-\\delta)=\\sqrt{\\rho}+\\eta>\\rho<span class="math">. Hence any two polynomials of degree smaller than </span>d<span class="math"> agreeing on </span>S<span class="math"> must be identical. It follows that for each </span>w\\in\\mathrm{Words}(\\pi,\\tau)<span class="math"> and any two </span>j,j^{\\prime}\\in[n_{w}]<span class="math">, we have </span>v_{w,j}(X)=v_{w,j^{\\prime}}(X)<span class="math"> as polynomials. Hence for each </span>w\\in\\mathrm{Words}(\\pi,\\tau)<span class="math"> there exists a degree </span><d<span class="math"> polynomial </span>u_{w}(X)<span class="math"> such that </span>u_{w}(X)=v_{w,j}(X)<span class="math"> for all </span>j\\in[n_{w}]<span class="math">. Let </span>U(\\pi,\\tau)=\\{u_{w}(X)\\mid w\\in\\mathrm{Words}(\\pi,\\tau)\\}$ be the collection of all these polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now notice that, for all <span class="math">w\\in\\mathrm{Words}(\\pi,\\tau)</span> and <span class="math">j\\in[n_{w}]</span>,</p>

    <p class="text-gray-300"><span class="math">u_{w}(\\omega^{k_{w,j}}\\mathfrak{z})=v_{w,j}(\\omega^{k_{w,j}}\\mathfrak{z})=(\\omega^{k_{w,j}}\\mathfrak{z}-\\omega^{k_{w,j}}\\mathfrak{z})q_{w,j}(\\omega^{k_{w,j}}\\mathfrak{z})+w_{i}(\\omega^{k_{w,j}}\\mathfrak{z})=w_{i}(\\omega^{k_{w,j}}\\mathfrak{z}).</span></p>

    <p class="text-gray-300">Hence <span class="math">U(\\pi,\\tau)</span> satisfies our claims.</p>

    <p class="text-gray-300">It follows that if <span class="math">\\mathsf{V}</span> accepts <span class="math">(\\pi,\\tau)</span>, then <span class="math">\\text{Words}(\\pi,\\tau)</span> has <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},H,d]</span> on a set <span class="math">S</span>, and that the purported openings <span class="math">\\mathsf{Evals}(\\pi,\\tau,\\mathfrak{z})</span> sent by <span class="math">\\mathcal{A}</span> are also purported openings of the polynomials in <span class="math">U(\\pi,\\tau,\\mathfrak{z})</span>. Let <span class="math">\\tau^{\\prime}</span> be the transcript obtained from <span class="math">(\\pi,\\tau)</span> by replacing <span class="math">\\llbracket w\\rrbracket</span> with <span class="math">\\llbracket u\\rrbracket</span>, for all <span class="math">w\\in\\text{Words}(\\pi,\\tau)</span>. Then the verifier in <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> accepts <span class="math">(\\pi,\\tau^{\\prime})</span>, since</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the polynomial openings in the prover’s last message do not change, so the first of the verifier’s check passes; and</li>

      <li>the openings are still valid, and so all words in <span class="math">\\mathsf{quotients}(\\pi,\\tau^{\\prime},\\mathfrak{z})</span> are actually codewords from <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>, and so the second verifier check also passes.</li>

    </ol>

    <p class="text-gray-300">Moreover, because of this and because all words in <span class="math">\\mathsf{quotients}(\\pi,\\tau^{\\prime},\\mathfrak{z})</span> are codewords from <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>, the transcript <span class="math">(\\pi,\\tau^{\\prime})</span> is also accepted by the verifier of <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span>.</p>

    <p class="text-gray-300">We conclude that <span class="math">(\\pi,\\tau^{\\prime})\\notin\\mathcal{D}_{0}</span>, since by assumption <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> is RBR sound with respect to the set <span class="math">\\mathcal{D}_{0}</span>. This proves that <span class="math">(\\pi,\\tau)\\notin\\mathcal{D}_{\\delta}</span>, as needed.</p>

    <p class="text-gray-300">To prove that <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> is RBR sound with the claimed errors we are left to prove that, for all <span class="math">i\\in[\\mu(\\mathrm{i},\\pi)]</span> and all <span class="math">(\\pi,\\tau_{i-1})\\in\\mathsf{PartTr}_{i-1}(\\mathrm{i},\\pi)</span>, if <span class="math">(\\pi,\\tau_{i-1})\\in\\mathcal{D}_{\\delta}(\\mathrm{i})</span>, then for any of <span class="math">\\mathcal{A}</span>’s <span class="math">i</span>-round message <span class="math">m_{i}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c_{i}}\\left[(\\pi,\\tau_{i-1},m_{i},c_{i})\\notin\\mathcal{D}_{\\delta}(\\mathrm{i})\\right]\\leq\\frac{\\varepsilon_{\\mathsf{rbr-s}}(\\mathrm{i})}{2\\eta\\sqrt{\\rho}}.</span> (13)</p>

    <p class="text-gray-300">To prove this, fix <span class="math">(\\pi,\\tau_{i-1})\\in\\mathcal{D}_{\\delta}(\\mathrm{i})</span>. Observe that if <span class="math">(\\pi,\\tau_{i-1},m_{i},c_{i})\\notin\\mathcal{D}_{\\delta}(\\mathrm{i})</span>, then by definition of <span class="math">\\mathcal{D}_{\\delta}(\\mathrm{i})</span>, there is <span class="math">(\\pi,\\tau_{i-1}^{\\prime},m_{i}^{\\prime},c_{i})\\in\\text{PolyTr}(\\pi,\\tau_{i-1},m_{i})</span> such that <span class="math">(\\pi,\\tau_{i-1}^{\\prime},m_{i}^{\\prime},c_{i})\\notin\\mathcal{D}_{0}(\\mathrm{i})</span>. However, since <span class="math">(\\pi,\\tau_{i-1})\\in\\mathcal{D}_{\\delta}(\\mathrm{i})</span>, we have <span class="math">(\\pi,\\tau_{i-1}^{\\prime})\\in\\mathcal{D}_{0}(\\mathrm{i})</span>. Hence</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c_{i}}\\left[(\\pi,\\tau_{i-1},m_{i},c_{i})\\notin\\mathcal{D}_{\\delta}(\\mathrm{i})\\right]</span> (14) <span class="math">\\leq\\sum_{(\\pi,\\tau_{i-1}^{\\prime},m_{i}^{\\prime})\\in\\text{PolyTr}(\\pi,\\tau_{i-1},m_{i})}\\Pr_{c_{i}}\\left[(\\pi,\\tau_{i-1}^{\\prime},m_{i}^{\\prime},c_{i})\\notin\\mathcal{D}_{0}(\\mathrm{i})\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{PolyTr}(\\pi,\\tau_{i-1},m_{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\varepsilon_{\\mathsf{rbr-s}}(\\mathrm{i}).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus it suffices to show that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{PolyTr}(\\pi,\\tau_{i-1},m_{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1/2\\eta\\sqrt{\\rho}<span class="math">. To prove this, it is enough to show that the total number of lists of codewords </span>U<span class="math"> from </span>\\mathsf{RS}[\\mathbb{F},D,d]<span class="math"> that agree with </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> on a set </span>S\\subseteq D<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is at most </span>1/2\\eta\\sqrt{\\rho}<span class="math">. To prove the latter we use the “correlated agreement list decoder” lemma (Lemma 3.3). This lemma yields that the words in </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> have </span>\\delta<span class="math">-correlated agreement in </span>\\mathsf{RS}[\\mathbb{F},D,d]<span class="math"> on at most </span>1/2\\eta\\sqrt{\\rho}<span class="math"> different maximal sets of density </span>1-\\delta<span class="math">. Next we use this fact to derive our desired claim. By our choice of parameters, and as argued previously, any set </span>S\\subseteq D<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> has at least </span>d<span class="math"> elements. Hence, for each word </span>w<span class="math"> from </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> there is a unique codeword </span>u_{w,S}<span class="math"> of degree at most </span>d<span class="math"> agreeing with </span>w<span class="math"> on </span>S<span class="math">. It follows that for any set </span>S<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> on which the maps </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> have </span>\\delta<span class="math">-correlated agreement, there is a unique list of codewords </span>U_{S,(\\pi,\\tau_{i-1},m_{i})}<span class="math"> agreeing (component-wise) with </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> on </span>S<span class="math">. Moreover, for any two such sets </span>S_{1},S_{2}<span class="math"> with </span>S_{1}\\subseteq S_{2}<span class="math">, we have </span>U_{S_{1},(\\tau_{i-1},m_{i})}=U_{S_{2},(\\pi,\\tau_{i-1},m_{i})}<span class="math">, by uniqueness and since the polynomials in </span>U_{S_{2},(\\pi,\\tau_{i-1},m_{i})}<span class="math"> agree component-wise with </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> on </span>S_{1}<span class="math">. In conclusion, the total number of lists of codewords </span>U<span class="math"> that agree component-wise with </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> on a set </span>S\\subseteq D<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1-\\delta)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is equal to the number of maximal sets on which </span>\\text{Words}(\\pi,\\tau_{i-1},m_{i})<span class="math"> has </span>\\delta<span class="math">-correlated agreement in </span>\\mathsf{RS}[\\mathbb{F},D,d]<span class="math">. As we observed before, this number is at most </span>1/2\\eta\\sqrt{\\rho}<span class="math">, as needed. This completes the proof that </span>\\Pi^{\\mathsf{OCoAgg}(\\delta)}<span class="math"> has RBR soundness with error </span>1/2\\eta\\sqrt{\\rho}\\varepsilon_{\\mathsf{rbr-s}}(\\mathrm{i})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next we prove that <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR knowledge with error <span class="math">1/2\\eta\\sqrt{\\rho}\\varepsilon_{\\mathsf{rbr-k}}(\\mathrm{i})</span>. Let <span class="math">\\mathcal{D}_{0,\\mathsf{ks}}</span> be a doomed set with respect to which <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span> has RBR knowledge with error <span class="math">\\varepsilon_{\\mathsf{rbr-k}}</span>. Let <span class="math">\\mathsf{Ext}_{0}</span> be the corresponding extractor algorithm. Given an index <span class="math">\\mathrm{i}</span>, define a doomed set for <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> similarly as before:</p>

    <p class="text-gray-300">\\[ \\mathcal{D}_{\\delta,\\mathsf{ks}}(\\mathrm{i})\\coloneqq\\left\\{(\\pi,\\tau)\\begin{array}[]{l}\\exists\\ i=0,\\ldots,\\mu(\\mathrm{i},\\pi)\\ \\ \\text{such that}\\ \\tau\\in\\text{PartTr}_{i}(\\mathrm{i},\\pi),\\\\ \\forall\\ (\\pi,\\tau^{\\prime})\\in\\text{PolyTr}(\\pi,\\tau)\\ \\ \\text{we have}\\ (\\pi,\\tau^{\\prime})\\in\\mathcal{D}_{0,\\mathsf{ks}}(\\mathrm{i})\\end{array}\\right\\}, \\]</p>

    <p class="text-gray-300">We will prove that <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR knowledge with respect to this set, with the claimed error. To this end, fix an index <span class="math">\\mathrm{i}</span> and an input <span class="math">\\pi</span>. First note that the exact same arguments as in our RBR analysis yield that all transcripts</p>

    <p class="text-gray-300"><span class="math">(\\Xi,\\tau)\\in\\mathcal{D}_{\\delta,\\mathrm{ks}}(\\dot{\\mathrm{i}})</span> are rejected by the verifier. Moreover, by definition, <span class="math">\\mathcal{D}_{\\delta,\\mathrm{ks}}(\\dot{\\mathrm{i}})</span> contains all transcripts of the form <span class="math">(\\Xi)</span>, for any input <span class="math">\\Xi</span> (independently of whether <span class="math">\\Xi\\in\\mathcal{L}_{\\mathbf{R}_{\\mathrm{i}}}</span> or not). Now fix a round number <span class="math">i\\in[\\mu(\\dot{\\mathrm{i}},\\Xi)]</span>, a partial transcript <span class="math">(\\Xi,\\tau)\\in\\mathcal{D}_{\\delta,\\mathrm{ks}}(\\dot{\\mathrm{i}})</span>, and a prover’s next message <span class="math">m_{i}</span>. Assume</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c_{i}}[(\\Xi,\\tau,m_{i},c_{i})\\notin\\mathcal{D}_{\\delta,\\mathrm{ks}}(\\dot{\\mathrm{i}})]&gt;\\frac{\\varepsilon_{\\mathrm{rbr-k}}(\\dot{\\mathrm{i}})}{2\\eta\\sqrt{\\rho}}.</span> (15)</p>

    <p class="text-gray-300">We claim that then there is <span class="math">(\\Xi,\\tau^{\\prime},m_{i}^{\\prime})\\in\\mathrm{PolyTr}(\\Xi,\\tau,m_{i})</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c_{i}}[(\\Xi,\\tau^{\\prime},m_{i}^{\\prime},c_{i})\\notin\\mathcal{D}_{0,\\mathrm{ks}}(\\dot{\\mathrm{i}})]&gt;\\varepsilon_{\\mathrm{rbr-k}}(\\dot{\\mathrm{i}}).</span></p>

    <p class="text-gray-300">Assuming the claim is true, then by our assumptions on the RBR knowledge of <span class="math">\\Pi^{\\mathsf{OCoAgg}(0)}</span>, we have that <span class="math">\\mathsf{Ext}_{0}(\\dot{\\mathrm{i}},\\Xi,\\tau^{\\prime},m_{i}^{\\prime})</span> outputs a witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\dot{\\mathrm{i}},\\Xi,\\mathfrak{w})\\in\\mathbf{R}</span>. In views of this, we define an extractor <span class="math">\\mathsf{Ext}_{\\delta}</span> for <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span> that, given an index <span class="math">\\dot{\\mathrm{i}}</span> and a (possibly partial) transcript <span class="math">(\\Xi,\\tau,m)</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computes <span class="math">\\mathrm{PolyTr}(\\Xi,\\tau,m)</span> using the list decoder algorithm from Lemma 3.3.</li>

      <li>Runs <span class="math">\\mathsf{Ext}_{0}(\\dot{\\mathrm{i}},\\Xi,\\tau^{\\prime},m^{\\prime})</span> for all <span class="math">(\\Xi,\\tau^{\\prime},m^{\\prime})\\in\\mathrm{PolyTr}(\\Xi,\\tau,m)</span>.</li>

      <li>If any of the outputs produced by <span class="math">\\mathsf{Ext}_{0}</span> is not a “fail” flag, <span class="math">\\mathsf{Ext}_{\\delta}</span> outputs it. Otherwise <span class="math">\\mathsf{Ext}_{\\delta}</span> outputs “fail”.</li>

    </ol>

    <p class="text-gray-300">Assuming our claim is true, we have that <span class="math">\\mathsf{Ext}_{\\delta}</span> successfully outputs a valid witness whenever Eq. (15) holds for some <span class="math">i\\in[\\mu]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next we argue that <span class="math">\\mathsf{Ext}_{\\delta}</span> runs in polynomial time. Indeed, due to Lemma 3.3, Step 1 runs in time polynomial on <span class="math">1/\\rho,1/\\eta,M,\\log\\mathbb{F}</span>, where <span class="math">M</span> is the number of words in <span class="math">(\\Xi,\\tau,m)</span>. Step 2 runs in polynomial time because <span class="math">\\mathsf{Ext}_{0}</span> runs in polynomial time on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathrm{i}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{PolyTr}(\\Xi,\\tau,m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{1}{2\\eta\\sqrt{\\rho}}<span class="math"> as argued previously. Step 3 also runs in polynomial time since </span>\\mathbf{R}<span class="math"> was implicitly assumed to be in the complexity class </span>\\mathsf{NP}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are left to prove the claim made above. For this, assume to the contrary that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c_{i}}[(\\Xi,\\tau^{\\prime},m_{i}^{\\prime},c_{i})\\notin\\mathcal{D}_{0,\\mathrm{ks}}(\\dot{\\mathrm{i}})]\\leq\\varepsilon_{\\mathrm{rbr-k}}(\\dot{\\mathrm{i}})\\quad\\text{for all}\\quad(\\Xi,\\tau^{\\prime},m_{i}^{\\prime})\\in\\mathrm{PolyTr}(\\Xi,\\tau,m_{i}).</span> (16)</p>

    <p class="text-gray-300">By the above assumption and similarly as in Eq. (14), we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{c_{i}}[(\\Xi,\\tau,m_{i},c_{i})\\notin\\mathcal{D}_{\\delta,\\mathrm{ks}}(\\dot{\\mathrm{i}})]</span> <span class="math">\\leq\\sum_{(\\Xi,\\tau^{\\prime}_{i-1},m_{i}^{\\prime})\\in\\mathrm{PolyTr}(\\Xi,\\tau_{i-1},m_{i})}\\Pr_{c_{i}}\\left[(\\Xi,\\tau^{\\prime}_{i-1},m_{i}^{\\prime},c_{i})\\notin\\mathcal{D}_{0,\\mathrm{ks}}(\\dot{\\mathrm{i}})\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\leq</span> $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{PolyTr}(\\Xi,\\tau_{i-1},m_{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\varepsilon_{\\mathrm{rbr-k}}(\\dot{\\mathrm{i}})\\leq\\frac{\\varepsilon_{\\mathrm{rbr-k}}(\\dot{\\mathrm{i}})}{2\\eta\\sqrt{\\rho}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, this contradicts the assumption in Eq. (15), and so Eq. (16) cannot be true. This completes the proof of our claim and of the theorem. ∎</p>

    <p class="text-gray-300">Next we describe how to use a IOPP for the <span class="math">\\delta</span>-correlated agreement relation <span class="math">\\mathbf{CoAgg}(\\delta)</span> to compile a <span class="math">\\delta</span>-correlated hIOP into a standard hIOP. Afterwards, we analyse the RBR security of this compilation.</p>

    <h6 id="sec-121" class="text-base font-medium mt-4">Definition 6.2 (Compilation of a <span class="math">\\delta</span>-correlated hIOP into a plain hIOP using a IOPP for correlated agreement).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}=(\\mathsf{Ind},\\mathsf{P},\\mathsf{V}^{\\mathsf{OCoAgg}(\\delta)})</span> be a <span class="math">\\mu</span>-round <span class="math">\\delta</span>-correlated hIOP for an indexed <span class="math">(\\mathbb{F},D,d)</span>-polynomial oracle relation <span class="math">\\mathbf{R}</span>, where <span class="math">0&lt;\\delta&lt;1-\\sqrt{\\rho}</span> and $\\rho=d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\Pi_{\\mathsf{CA}}=(\\mathsf{Ind}_{\\mathsf{CA}},\\mathsf{P}_{\\mathsf{CA}},\\mathsf{V}_{\\mathsf{CA}})<span class="math"> be a IOPP for the </span>\\delta<span class="math">-correlated agreement relation </span>\\mathbf{CoAgg}(\\delta)<span class="math"> in </span>\\mathsf{RS}[\\mathbb{F},D,d]<span class="math">. Define a hIOP </span>\\Pi_{\\mathsf{compiled}}=(\\mathsf{Ind}_{\\mathsf{compiled}},\\mathsf{P}_{\\mathsf{compiled}},\\mathsf{V}_{\\mathsf{compiled}})<span class="math"> for </span>\\mathbf{R}$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input <span class="math">\\dot{\\mathrm{i}}</span>, <span class="math">\\mathsf{Ind}_{\\mathsf{compiled}}</span> outputs <span class="math">\\mathsf{Ind}(\\dot{\\mathrm{i}})</span> and the index <span class="math">\\dot{\\mathrm{i}}_{\\mathsf{CA}}=(\\mathbb{F},D,d,\\delta,N)</span> for <span class="math">\\Pi_{\\mathsf{CA}}</span>, where <span class="math">N</span> is the number of words being checked for <span class="math">\\delta</span>-correlated agreement at the end of <span class="math">\\Pi^{\\mathsf{OCoAgg}(\\delta)}</span>.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\dot{\\mathrm{i}},\\mathrm{x},\\mathrm{w})\\in \\mathbf{R}</span>. Denote <span class="math">\\mathsf{P}_{\\mathrm{compiled}}(\\mathrm{Ind}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}}),\\mathrm{x},\\mathrm{w})</span> by <span class="math">\\mathsf{P}_{\\mathrm{compiled}}</span> and <span class="math">\\mathsf{V}_{\\mathrm{compiled}}^{\\mathrm{Ind}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}})}(\\mathrm{x})</span> by <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span>. We make an analogous notation abuse for the provers and verifiers of <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span> and <span class="math">\\Pi_{\\mathrm{CA}}</span>.</li>

    </ul>

    <p class="text-gray-300">During the interactive phase:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, <span class="math">\\mathsf{P}_{\\mathrm{compiled}}</span> and <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> simulate the <span class="math">\\mu(\\dot{\\mathrm{i}},\\mathrm{x})</span> rounds of the interactive phase of <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> (the prover and verifier of <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span>).</li>

    </ol>

    <p class="text-gray-300">After that, <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> replies with an empty "dummy" message.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{Evals}(\\mathfrak{z})</span> be the last message sent by <span class="math">\\mathsf{P}_{\\mathrm{compiled}}</span> in the previous phase, and let <span class="math">\\mathcal{W}</span> be the words on which <span class="math">\\mathsf{V}</span> would call the oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> during its final decision process.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Next, <span class="math">\\mathsf{P}_{\\mathrm{compiled}}</span> and <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> simulate the interactive phase between <span class="math">\\mathsf{P}_{\\mathrm{CA}}</span> and <span class="math">\\mathsf{V}_{\\mathrm{CA}}</span>, with index, input and witness, respectively, $\\dot{\\mathrm{i}}_{\\mathrm{CA}} = (\\mathbb{F}, D, d, \\delta,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{W}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathrm{x}_{\\mathrm{CA}} = [[\\mathcal{W}]]<span class="math">, and </span>\\mathrm{w}_{\\mathrm{CA}} = \\mathcal{W}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, given <span class="math">\\dot{\\mathrm{i}},\\mathrm{x}</span> and a complete transcript <span class="math">\\tau</span> for <span class="math">\\Pi_{\\mathrm{compiled}}</span>, <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> accepts if and only if <span class="math">\\mathsf{V}_{\\mathrm{CA}}</span> at the end of Step 3 above, and Check 1 of <span class="math">\\mathsf{V}</span> from Definition 6.1 would pass, i.e., if <span class="math">F_{\\dot{\\mathrm{i}},\\mathrm{x},\\tau}(\\mathsf{Evals}(\\mathfrak{z})) = 0</span>.</li>

    </ul>

    <p class="text-gray-300">Note that, given an index <span class="math">\\dot{\\mathrm{i}}</span> and an input <span class="math">\\mathrm{x}</span>, a complete transcript <span class="math">(\\mathrm{x},\\tau)</span> of the interaction between <span class="math">\\mathsf{P}_{\\mathrm{compiled}}</span> and <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> consists of <span class="math">2(\\mu(\\dot{\\mathrm{i}},\\mathrm{x}) + 1) + 2\\mu_{\\mathrm{CA}}(\\dot{\\mathrm{i}}_{\\mathrm{CA}},\\mathrm{x}_{\\mathrm{CA}}) + 1</span> messages in total.</p>

    <p class="text-gray-300">In what follows, given a (possibly partial) transcript <span class="math">(\\mathrm{x},\\tau)</span>, we will use the notation <span class="math">\\mathrm{x}_{\\mathrm{CA}}</span> and <span class="math">\\mathcal{W}</span> with the same meaning as above, without referring to <span class="math">(\\mathrm{x},\\tau)</span>, which will be clear from the context.</p>

    <p class="text-gray-300"><strong>Lemma 4.8.</strong> Assume the notation and hypotheses of Theorem 4.6. Then there exists a <span class="math">hIOP \\Pi_{\\mathrm{compiled}}</span> (see Definition 6.2) for <span class="math">\\mathbf{R}</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span> has RBR soundness error <span class="math">\\varepsilon_{\\mathrm{rbr - s},\\delta}</span>. Then <span class="math">\\Pi_{\\mathrm{compiled}}</span> has RBR soundness error</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\max \\left\\{\\varepsilon_ {\\mathrm {r b r} - \\mathrm {s}, \\delta} (\\mathrm {i}), \\varepsilon_ {\\mathrm {C A}} (\\mathrm {i} _ {\\mathrm {C A}}) \\right\\}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span> has RBR knowledge soundness error <span class="math">\\varepsilon_{\\mathrm{rbr - k},\\delta}</span>. Then <span class="math">\\Pi_{\\mathrm{compiled}}</span> has RBR knowledge soundness error</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\max \\left\\{\\varepsilon_ {\\mathrm {r b r} - \\mathrm {k}, \\delta} (\\mathrm {i}), \\varepsilon_ {\\mathrm {C A}} (\\mathrm {i} _ {\\mathrm {C A}}) \\right\\}.</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Fix an index <span class="math">\\dot{\\mathrm{i}}</span> and an input <span class="math">\\mathrm{x}</span>. Let <span class="math">\\mu(\\dot{\\mathrm{i}},\\mathrm{x})</span> and <span class="math">\\mu_{\\mathrm{CA}}(\\dot{\\mathrm{i}}_{\\mathrm{CA}},\\mathrm{x}_{\\mathrm{CA}})</span> be the number of rounds in the interactive phase of <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span> and in <span class="math">\\Pi_{\\mathrm{CA}}</span>, respectively. For simplicity, in what follows, we denote these by <span class="math">\\mu</span> and <span class="math">\\mu_{\\mathrm{CA}}</span>.</p>

    <p class="text-gray-300">Given a partial transcript <span class="math">(\\mathrm{x},\\tau)\\in \\mathrm{PartTr}_i(\\dot{\\mathrm{i}},\\mathrm{x})</span> for <span class="math">\\Pi_{\\mathrm{compiled}}</span>, with <span class="math">i &amp;gt; \\mu (\\dot{\\mathrm{i}},\\mathrm{x}) + 1</span>, let <span class="math">(\\mathrm{x},\\tau)[: \\mu +2]</span> be the partial transcript corresponding to the first <span class="math">\\mu +1</span> rounds in <span class="math">(\\mathrm{x},\\tau)</span>, i.e. <span class="math">(\\mathrm{x},\\tau)[: \\mu +2]</span> is the prefix of <span class="math">(\\mathrm{x},\\tau)</span> such that <span class="math">(\\mathrm{x},\\tau)[: \\mu +2]\\in \\mathrm{PartTr}_{\\mu +1}(\\dot{\\mathrm{i}},\\mathrm{x})</span>, which corresponds to the messages exchanged during the simulation of <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span>. Similarly, we let <span class="math">(\\mathrm{x},\\tau)[\\mu +2:]</span> be the suffix of <span class="math">(\\mathrm{x},\\tau)</span> corresponding to all rounds including and after the round <span class="math">\\mu +2</span>, so that <span class="math">(\\mathrm{x},\\tau)</span> is the concatenation of <span class="math">(\\mathrm{x},\\tau)[: \\mu +2]</span> and <span class="math">(\\mathrm{x},\\tau)[\\mu +2:]</span>. The transcript <span class="math">(\\mathrm{x},\\tau)[\\mu +2:]</span> contains messages exchanged during the simulation of <span class="math">\\Pi_{\\mathrm{CA}}</span>.</p>

    <p class="text-gray-300">Assume <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span> is RBR sound with respect to the set <span class="math">\\mathcal{D}(\\dot{\\mathrm{i}})</span> and <span class="math">\\Pi_{\\mathrm{CA}}</span> is RBR sound with respect to the set <span class="math">\\mathcal{D}_{\\mathrm{CA}}(\\dot{\\mathrm{i}}_{\\mathrm{CA}})</span>. We define a new doomed set <span class="math">\\mathcal{D}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}})</span> for <span class="math">\\Pi_{\\mathrm{compiled}}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">i \\in [\\mu]</span> and <span class="math">(\\mathrm{x},\\tau) \\in \\operatorname{PartTr}_i(\\dot{\\mathrm{i}},\\mathrm{x})</span> we let <span class="math">(\\mathrm{x},\\tau) \\in \\mathcal{D}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}})</span> if and only if <span class="math">(\\mathrm{x},\\tau) \\in \\mathcal{D}(\\dot{\\mathrm{i}})</span>.</li>

      <li>For <span class="math">(\\mathrm{x},\\tau) \\in \\operatorname{PartTr}_{\\mu + 1}(\\dot{\\mathrm{i}}, \\mathrm{x})</span>, we let <span class="math">(\\mathrm{x}, \\tau) \\in \\mathcal{D}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}})</span> if and only if the partial transcript <span class="math">(\\mathrm{x}, \\tau&#x27;)</span> obtained from <span class="math">(\\mathrm{x}, \\tau)</span> by removing the last prover and last (dummy) verifier message belongs to <span class="math">\\mathcal{D}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}})</span>.</li>

      <li>Let <span class="math">\\mu + 2 \\leq i \\leq \\mu + 1 + \\mu_{\\mathrm{CA}}</span> and let <span class="math">(\\mathrm{x}, \\tau) \\in \\operatorname{PartTr}_i(\\dot{\\mathrm{i}}, \\mathrm{x})</span>. Intuitively, we include <span class="math">(\\mathrm{x}, \\tau)</span> in <span class="math">\\mathcal{D}_{\\mathrm{compiled}}(\\dot{\\mathrm{i}})</span> if and only if the suffix <span class="math">(\\mathrm{x}, \\tau)[\\mu + 2:]</span> of <span class="math">(\\mathrm{x}, \\tau)</span> corresponding to the messages exchanged during the simulation of IOPP <span class="math">\\Pi_{\\mathrm{CA}}</span> is in <span class="math">\\Pi_{\\mathrm{CA}}</span>'s doomed set <span class="math">\\mathcal{D}_{\\mathrm{CA}}</span>, or if the first check of <span class="math">\\Pi^{\\mathrm{OCoAgg}(\\delta)}</span>'s verifier <span class="math">\\mathsf{V}</span> failed.</li>

    </ul>

    <p class="text-gray-300">9This is just a technicality so that, at each round of interaction, both the prover and the verifier send a message \\mathrm{in} The verifier constructs \\llbracket \\mathcal{W}\\rrbracket  with the oracles sent by \\mathsf{P}_{\\mathrm{compiled}}  so far and with \\mathsf{Evals}(\\mathfrak{z})</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{F}_{i,\\pi,\\tau}[\\mu+2]=\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span>. More formally, let <span class="math">\\mathfrak{z}</span> be the last nonempty challenge sent by <span class="math">\\mathsf{V}</span> in the partial transcript <span class="math">(\\pi,\\tau)[:\\mu+2]</span> and let <span class="math">\\mathsf{Evals}(\\mathfrak{z})</span> be the last message sent by <span class="math">\\mathsf{P}</span> in <span class="math">(\\pi,\\tau)[:\\mu+2]</span>. We say <span class="math">(\\pi,\\tau)</span> <em>passes Check 1 of <span class="math">\\mathsf{V}</span></em> if the elements <span class="math">\\mathsf{Evals}(\\tau)</span> are a root to the multivariate polynomial <span class="math">F_{\\mathfrak{i},\\pi,\\tau}</span> from Check 1 in Definition 6.1.</p>

    <p class="text-gray-300">Then we let <span class="math">(\\pi,\\tau)\\in\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span> if and only if <span class="math">(\\pi,\\tau)</span> does not pass Check 1 of <span class="math">\\mathsf{V}</span>, or if <span class="math">(\\pi_{\\mathrm{CA}},(\\pi,\\tau)[\\mu+2:])\\in\\mathcal{D}_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span>,</p>

    <p class="text-gray-300">Next we show that <span class="math">\\mathsf{\\Pi}_{\\mathrm{compiled}}</span> has the claimed RBR soundness with respect to the doomed set <span class="math">\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span>. Indeed, assume first that <span class="math">(\\pi,\\tau)</span> is a complete transcript for <span class="math">\\mathsf{\\Pi}_{\\mathrm{compiled}}</span> and <span class="math">(\\pi,\\tau)\\in\\mathcal{D}_{\\mathrm{compiled}}</span>. We claim that then <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> rejects <span class="math">(\\pi,\\tau)</span>. Indeed, if <span class="math">(\\pi_{\\mathrm{CA}},(\\pi,\\tau)[\\mu+2:])\\in\\mathcal{D}_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span>, then <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> rejects <span class="math">(\\pi,\\tau)</span> because <span class="math">\\mathsf{V}_{\\mathrm{CA}}</span> would reject the complete transcript <span class="math">(\\pi_{\\mathrm{CA}},(\\pi,\\tau)[\\mu+2:])</span> for <span class="math">\\mathsf{\\Pi}_{\\mathrm{CA}}</span>, given that <span class="math">\\mathsf{\\Pi}_{\\mathrm{CA}}</span> has RBR soundness with respect to <span class="math">\\mathcal{D}_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span>. On the other hand, if <span class="math">(\\pi,\\tau)</span> does not pass Check 1 of <span class="math">\\mathsf{V}</span>, then <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> rejects <span class="math">(\\pi,\\tau)</span> because <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> also performs Check 1, i.e. it asserts whether the elements <span class="math">\\mathsf{Evals}(\\mathfrak{z})</span> are a root to <span class="math">F_{\\mathfrak{i},\\pi,(\\pi,\\tau)[:\\mu+2]}</span>. This proves our claim.</p>

    <p class="text-gray-300">Next, notice that, by definition, <span class="math">(\\pi,\\emptyset)\\in\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span> for all <span class="math">\\mathfrak{i}</span> and all <span class="math">\\pi\\notin\\mathcal{L}_{\\mathsf{R}_{\\mathfrak{i}}}</span>. Hence, we are left with proving Item 3 in the definition of RBR soundness.</p>

    <p class="text-gray-300">To this end, let <span class="math">i\\in[\\mu+1+\\mu_{\\mathrm{CA}}]</span> and <span class="math">(\\pi,\\tau)\\in\\mathrm{PartTr}_{i-1}(\\mathfrak{i},\\pi)</span> be such that <span class="math">(\\pi,\\tau)\\in\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span>. Let <span class="math">m_{i}</span> be any <span class="math">\\mathsf{P}_{\\mathrm{compiled}}</span>’s potential <span class="math">i</span>-th message. Denote</p>

    <p class="text-gray-300"><span class="math">P_{i}:=\\Pr_{c_{i}}[(\\pi,\\tau,m_{i},c_{i})\\notin\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})],</span></p>

    <p class="text-gray-300">where the probability is taken uniformly over all potential <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span>’s challenges at round <span class="math">i</span>. If <span class="math">i\\leq\\mu</span>, then <span class="math">P_{i}\\leq\\varepsilon_{\\mathrm{rbr}-\\mathrm{s},\\delta}(\\mathfrak{i})</span> by the assumption on the RBR soundness of <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span>. If <span class="math">i=\\mu+1</span>, then <span class="math">(\\pi,\\tau,m_{i},\\tau)\\in\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span> by definition of <span class="math">\\mathcal{D}_{\\mathrm{compiled}}</span>. It follows that <span class="math">P_{\\mu+1}=0</span>.</p>

    <p class="text-gray-300">Assume <span class="math">i&gt;\\mu+2</span>. If <span class="math">(\\pi,\\tau)</span> does not pass Check 1 of <span class="math">\\mathsf{V}</span>, then by definition <span class="math">(\\pi,\\tau,m_{i},c_{i})</span> also does not pass Check 1. Hence in this case <span class="math">P_{i}=0</span>. Alternatively, if it does pass Check 1 of <span class="math">\\mathsf{V}</span>, but <span class="math">(\\pi_{\\mathrm{CA}},(\\pi,\\tau)[\\mu+2:])\\in\\mathcal{D}_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span>, then <span class="math">P_{i}\\leq\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span> due to the RBR soundness of <span class="math">\\mathsf{\\Pi}_{\\mathrm{CA}}</span>. It remains to analyze the case <span class="math">i=\\mu+2</span>, which corresponds to the scenario where the last prover message in <span class="math">(\\pi,\\tau)</span> is <span class="math">\\mathsf{Evals}(\\mathfrak{z})</span>, and <span class="math">m_{i}=m_{\\mu+2}</span> is the first message sent by <span class="math">\\mathsf{P}_{\\mathrm{CA}}</span>. By assumption, <span class="math">(\\pi,\\tau)\\in\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span>, and so by definition of <span class="math">\\mathcal{D}_{\\mathrm{compiled}}</span> the verifier <span class="math">\\mathsf{V}</span> of <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span> rejects the transcript <span class="math">(\\pi,\\tau)</span>, which is a complete transcript for the protocol <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span>. Then, by definition of correlated hIOP (Definition 6.1) either <span class="math">(\\pi,\\tau)</span> fails <span class="math">\\mathsf{V}</span>’s Check 1, or it fails Check 2. In the first case, we have <span class="math">P_{i}=0</span> due to the same reasons as before. In the second case, the words <span class="math">\\pi_{\\mathrm{CA}}=\\mathcal{W}</span> do not have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>. Hence <span class="math">\\pi_{\\mathrm{CA}}\\notin\\mathbf{CoAgg}(\\delta)</span>. Consequently, <span class="math">(\\pi_{\\mathrm{CA}},\\emptyset)\\in\\mathcal{D}_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span>, and then since <span class="math">\\mathsf{\\Pi}_{\\mathrm{CA}}</span> has RBR soundness <span class="math">\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i})</span> w.r.t. <span class="math">\\mathcal{D}_{\\mathrm{CA}}</span>, we obtain that <span class="math">(\\pi_{\\mathrm{CA}},m_{i},c_{i})\\in\\mathcal{D}_{\\mathrm{CA}}</span> except with probability <span class="math">\\varepsilon_{\\mathrm{CA}}</span>. Then by definition of <span class="math">\\mathcal{D}_{\\mathrm{compiled}}</span> we have <span class="math">P_{i}\\leq\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i})</span>. Thus <span class="math">\\mathsf{\\Pi}_{\\mathrm{compiled}}</span> has RBR soundness w.r.t. the set <span class="math">\\mathcal{D}_{\\mathrm{compiled}}</span>, with error <span class="math">\\varepsilon_{\\mathrm{rbr}-\\mathrm{s},\\mathrm{compiled}}:=\\max\\{\\varepsilon_{\\mathrm{rbr}-\\mathrm{s},\\delta},\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})\\}</span>.</p>

    <p class="text-gray-300">Now assume <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span> has RBR knowledge w.r.t. a set <span class="math">\\mathcal{D}^{\\prime}</span>, with error <span class="math">\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\delta}</span>. We define <span class="math">\\mathcal{D}^{\\prime}_{\\mathrm{compiled}}(\\mathfrak{i})</span> in the exact same manner as <span class="math">\\mathcal{D}_{\\mathrm{compiled}}(\\mathfrak{i})</span>, using <span class="math">\\mathcal{D}^{\\prime}</span> rather than <span class="math">\\mathcal{D}</span>. We will prove that <span class="math">\\mathsf{\\Pi}_{\\mathrm{compiled}}</span> has RBR knowledge w.r.t. this set, with error <span class="math">\\max\\left\\{\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\delta}(\\mathfrak{i}),\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i})\\right\\}</span>.</p>

    <p class="text-gray-300">Indeed, first notice that if <span class="math">(\\pi,\\tau)\\in\\mathcal{D}^{\\prime}_{\\mathrm{compiled}}(\\mathfrak{i})</span> is a complete transcript, then <span class="math">\\mathsf{V}_{\\mathrm{compiled}}</span> rejects <span class="math">(\\pi,\\tau)</span> by the same reasons as in our analysis of the RBR soundness of <span class="math">\\mathsf{\\Pi}_{\\mathrm{compiled}}</span>. Additionally, all transcripts of the form <span class="math">(\\pi,\\emptyset)</span> belong to <span class="math">\\mathcal{D}^{\\prime}_{\\mathrm{compiled}}(\\mathfrak{i})</span> by definition (because they belong to <span class="math">\\mathcal{D}^{\\prime}(\\mathfrak{i})</span>), and so the first two clauses in the definition of RBR knowledge hold.</p>

    <p class="text-gray-300">Next, we prove that the third clause also holds. To this end, let <span class="math">\\mathsf{Ext}</span> be the extractors given by the RBR knowledge of <span class="math">\\mathsf{\\Pi}^{\\mathsf{OCoAgg}(\\delta)}</span>. Let <span class="math">\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\mathrm{compiled}}(\\mathfrak{i}):=\\max\\{\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\delta}(\\mathfrak{i}),\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i})\\}</span>. Let <span class="math">i\\in[\\mu+1+\\mu_{\\mathrm{CA}}]</span>, and let <span class="math">\\tau\\in\\mathrm{PartTr}_{i-1}(\\mathfrak{i},\\pi)</span> be such that <span class="math">(\\pi,\\tau)\\in\\mathcal{D}^{\\prime}_{\\mathrm{compiled}}(\\mathfrak{i})</span>. Define <span class="math">m_{i}</span> and <span class="math">P_{i}</span> as before, and suppose <span class="math">i&lt;\\mu+1</span> and <span class="math">P_{i}&gt;\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\mathrm{compiled}}(\\mathfrak{i})</span>. Since <span class="math">\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\mathrm{compiled}}(\\mathfrak{i})&gt;\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\delta}(\\mathfrak{i})</span>, by definition of RBR knowledge, <span class="math">\\mathsf{Ext}(\\mathfrak{i},\\pi,\\tau,m_{i})</span> is a valid witness for the pair <span class="math">(\\mathfrak{i},\\pi)</span>.</p>

    <p class="text-gray-300">If <span class="math">i=\\mu+1</span>, then as we already saw, <span class="math">P_{i}=0</span>, and so there is nothing to analyse in this case. If <span class="math">i\\geq\\mu+2</span>, then by definition of <span class="math">\\mathcal{D}^{\\prime}_{\\mathrm{compiled}}(\\mathfrak{i})</span>, and as we saw previously, we have that either <span class="math">(\\pi,\\tau)</span> does not pass Check 1 of <span class="math">\\mathsf{V}</span>, in which case <span class="math">P_{i}=0</span>, or <span class="math">\\pi_{\\mathrm{CA}}=\\llbracket\\mathcal{W}\\rrbracket</span> does not have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,d]</span>. In the latter case, we have <span class="math">\\Pr_{c_{i}}[(\\pi_{\\mathrm{CA}},m_{i},c_{i})\\notin\\mathcal{D}_{\\mathrm{CA}}]\\leq\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span>, and so <span class="math">P_{i}\\leq\\varepsilon_{\\mathrm{CA}}(\\mathfrak{i}_{\\mathrm{CA}})</span> by definition of <span class="math">\\mathcal{D}^{\\prime}_{\\mathrm{compiled}}(\\mathfrak{i})</span>. Hence, for <span class="math">i\\geq\\mu+2</span>, there is never the need to use an extractor because <span class="math">P_{i}\\leq\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\mathrm{compiled}}(\\mathfrak{i})</span>. This completes the proof that <span class="math">\\mathsf{\\Pi}_{\\mathrm{compiled}}</span> has RBR knowledge with error <span class="math">\\varepsilon_{\\mathrm{rbr}-\\mathrm{k},\\mathrm{compiled}}(\\mathfrak{i})</span>. ∎</p>

    <p class="text-gray-300">Given Lemmas 4.7 and 4.8, Theorem 4.6 directly follows.</p>

    <p class="text-gray-300">7 Plonk-like Protocols</p>

    <p class="text-gray-300">In this section, we use the <span class="math">\\delta</span>-correlated hIOP framework we built in Section 6 to establish the round-by-round soundness of our Plonk-like protocol abstraction we call OPlonky.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout this section we let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">D\\subseteq\\mathbb{F}^{<em>}</span> a multiplicative subgroup of <span class="math">\\mathbb{F}</span>, called </em>evaluation domain*, and <span class="math">H</span> a subgroup of <span class="math">D</span> of order <span class="math">\\mathsf{n}</span>, generated by an element <span class="math">\\omega</span>. We also let $\\rho=n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and we fix </span>0\\leq\\delta<1-\\sqrt{\\rho}<span class="math">. Given a polynomial </span>q(X)\\in\\mathbb{F}[X]<span class="math"> (or </span>q(X)\\in\\mathbb{K}[X]<span class="math"> for some field extension </span>\\mathbb{K}<span class="math"> of </span>\\mathbb{F}<span class="math">), we often treat </span>q(X)<span class="math"> indistinctly as a polynomial, and as a word from </span>\\mathbb{F}^{D}<span class="math"> (i.e., as its restriction on </span>D$), and vice-versa.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-122" class="text-xl font-semibold mt-8">7.1 A <span class="math">\\delta</span>-correlated hIOP for the Permutation Relation</h3>

    <p class="text-gray-300">In this section we formulate a general version of permutation IOP that underlies part of the Plonk SNARK <em>[x10]</em> as a <span class="math">\\delta</span>-correlated hIOP. As we will see, this is a key component in Plonk-like hIOP’s. The generalized formulation we present is inspired, in part, by Plonky2’s variation on the permutation argument <em>[x21]</em>. We begin by defining a <em>permutation relation</em>, and then we describe an IOP for this relation, which we denote as <span class="math">\\Pi_{\\mathbf{R}_{\\mathbf{RPerm}}}(\\delta)</span>.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Definition 7.1 (Permutation Relation).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{r},\\mathsf{u}\\in\\mathbb{N}</span>, and let <span class="math">\\sigma:[\\mathsf{rn}]\\to[\\mathsf{rn}]</span> be a permutation. Let <span class="math">a_{i},b_{i}\\in\\mathbb{F}[X]</span> be polynomials of degree <span class="math">&lt;\\mathsf{n}</span> for all <span class="math">i\\in[\\mathsf{r}]</span>.</p>

    <p class="text-gray-300">For each <span class="math">0\\leq i\\leq\\mathsf{n}-1</span> and <span class="math">0\\leq j\\leq\\mathsf{r}-1</span> define vectors <span class="math">\\bm{a},\\bm{b}\\in\\mathbb{F}^{\\mathsf{rn}}</span> as</p>

    <p class="text-gray-300"><span class="math">\\bm{a}_{((j-1)\\mathsf{n}+i)}:=a_{j}(\\omega^{i}),\\quad\\bm{b}_{((j-1)\\mathsf{n}+i)}:=b_{j}(\\omega^{i}).</span> (17)</p>

    <p class="text-gray-300">We say that <span class="math">(a_{1},\\ldots,a_{r})=\\sigma(b_{1},\\ldots,b_{r})</span> if <span class="math">\\bm{a}_{i}=\\bm{b}_{\\sigma(i)}</span> for all <span class="math">i\\in[\\mathsf{rn}]</span>. For example, when <span class="math">\\mathsf{r}=1</span>, then <span class="math">a_{1}=\\sigma(b_{1})</span> if and only if <span class="math">a_{1}(\\omega^{i})=b_{1}(\\omega^{\\sigma(i)})</span> for all <span class="math">i\\in[\\mathsf{n}]</span>.</p>

    <p class="text-gray-300">We define <span class="math">\\mathbf{R}_{\\mathbf{RPerm}}</span> as the following indexed <span class="math">(\\mathbb{F},D,\\mathsf{n})</span>-polynomial oracle relation:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{R}_{\\mathbf{RPerm}}:=</span> (18)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\{\\left((\\mathsf{r},\\sigma),(\\llbracket a_{i}\\rrbracket,\\llbracket b_{i}\\rrbracket)_{i\\in[\\mathsf{r}]};(a_{i},b_{i})_{i\\in[\\mathsf{r}]}\\right)\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}(a_{1},\\ldots,a_{r})=\\sigma(b_{1},\\ldots,b_{r})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">a_{i},b_{i}\\in\\mathsf{RS}[\\mathbb{F},D,\\mathsf{n}]\\text{ for all }i\\in[\\mathsf{r}]\\end{array}\\right.\\right\\}.$</p>

    <p class="text-gray-300">Above, the tuple <span class="math">(\\mathsf{r},\\sigma)</span> is an index, <span class="math">(\\llbracket a_{i}\\rrbracket,\\llbracket b_{i}\\rrbracket)_{i\\in[\\mathsf{r}]}</span> is an input , and <span class="math">(a_{i},b_{i})_{i\\in[\\mathsf{r}]}</span> is a witness.</p>

    <p class="text-gray-300">Before describing a <span class="math">\\delta</span>-correlated hIOP <span class="math">\\Pi_{\\mathbf{R}_{\\mathbf{RPerm}}}(\\delta)</span> for this relation, we begin by introducing some terminology and notation. Let <span class="math">\\mathsf{L}_{i}(X)</span> be the <span class="math">i</span>-th element of a Lagrange basis for the elements <span class="math">(\\omega,\\ldots,\\omega^{\\mathsf{n}})</span>, so that <span class="math">\\mathsf{L}_{i}(\\omega^{j})=0</span> if <span class="math">j\\neq i</span> and <span class="math">\\mathsf{L}_{i}(\\omega^{i})=1</span>. Define two sets of polynomials <span class="math">\\mathsf{S}_{\\mathsf{idj}},\\mathsf{S}_{\\mathsf{σj}}</span>, for <span class="math">\\mathsf{j}\\in[\\mathsf{r}]</span>, as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{S}_{\\mathsf{id1}}(X)</span> <span class="math">:=k_{1}X,\\qquad\\mathsf{S}_{\\mathsf{σ1}}(X):=\\sum_{i=1}^{\\mathsf{n}}\\sigma^{<em>}(i)\\mathsf{L}_{i}(X),</span> (19) <span class="math">\\vdots</span> <span class="math">\\vdots</span> <span class="math">\\mathsf{S}_{\\mathsf{idr}}(X)</span> <span class="math">:=k_{r}X,\\qquad\\mathsf{S}_{\\mathsf{σr}}(X):=\\sum_{i=1}^{\\mathsf{n}}\\sigma^{</em>}((\\mathsf{r}-1)\\mathsf{n}+i)\\mathsf{L}_{i}(X),</span></p>

    <p class="text-gray-300">where <span class="math">k_{1},\\ldots,k_{r}\\in\\mathbb{F}</span> are such that <span class="math">k_{1}H,\\ldots,k_{r}H</span> are pairwise different (and hence disjoint) cosets of <span class="math">H</span>. The map <span class="math">\\sigma^{*}:\\left[\\mathsf{rn}\\right]\\to\\bigcup_{i=1}^{r}k_{i}H</span> is the bijection that results from composing the permutation <span class="math">\\sigma:\\left[\\mathsf{rn}\\right]\\to[\\mathsf{rn}]</span> and the natural bijection between <span class="math">\\left[\\mathsf{rn}\\right]</span> and <span class="math">\\bigcup_{i=1}^{r}k_{i}H</span>. More precisely,</p>

    <p class="text-gray-300"><span class="math">\\sigma^{*}((j-1)\\mathsf{n}+i)=k_{j}\\omega^{i}.</span> (20)</p>

    <p class="text-gray-300">for all <span class="math">j,i</span> with <span class="math">1\\leq j\\leq\\mathsf{r}-1</span> and <span class="math">0\\leq i\\leq\\mathsf{n}-1</span>.</p>

    <h4 id="sec-124" class="text-lg font-semibold mt-6">7.1.1 Description of <span class="math">\\Pi_{\\mathbf{R}_{\\mathbf{RPerm}}}(\\delta)</span></h4>

    <p class="text-gray-300">We now describe the <span class="math">\\delta</span>-correlated hIOP <span class="math">\\Pi_{\\mathbf{R}_{\\mathbf{RPerm}}}(\\delta)</span> for the relation <span class="math">\\mathbf{R}_{\\mathbf{RPerm}}</span>. To do so, we define a tuple of algorithms <span class="math">(\\mathsf{Ind}_{\\mathbf{R}_{\\mathbf{RPerm}}},\\mathsf{P}_{\\mathbf{R}_{\\mathbf{RPerm}}},\\mathsf{V}_{\\mathbf{R}_{\\mathbf{RPerm}}}^{\\mathsf{OCoAgg}(\\,\\delta)})</span> as follows. Given a triple <span class="math">(\\dot{\\mathsf{s}},\\mathtt{x},\\mathtt{w})\\in\\mathbf{R}_{\\mathbf{RPerm}}</span></p>

    <p class="text-gray-300">Indexer. <span class="math">\\operatorname{Ind}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\text{erm}}}(\\mathfrak{i})</span> outputs <span class="math">(\\mathfrak{i}, \\mathfrak{u}, (\\mathsf{S}_{idj}, \\mathsf{S}_{\\sigma j})_{j \\in [r]})</span>. Here <span class="math">\\mathfrak{u} \\geq 0</span> is a parameter whose use will become apparent later on.</p>

    <h2 id="sec-125" class="text-2xl font-bold">Online phase.</h2>

    <p class="text-gray-300"><strong>Prover's Message 1.</strong> As its first message, <span class="math">\\mathsf{P}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\text{erm}}}(\\operatorname{Ind}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\text{erm}}}(\\mathfrak{i}), \\mathbf{x}, \\mathbf{w})</span> sends an empty string.</p>

    <p class="text-gray-300"><strong>Verifier's Message 1.</strong> The verifier sends two uniformly sampled field elements <span class="math">\\beta, \\gamma \\in \\mathbb{F}</span>.</p>

    <p class="text-gray-300"><strong>Prover's Message 2.</strong> The prover computes degree <span class="math">&amp;lt; n</span> polynomials <span class="math">(f_j, g_j)_{j \\in [r]}</span> and two polynomials <span class="math">f(X), g(X)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">f_j(\\omega^i) := a_j(\\omega^i) + \\beta \\mathsf{S}_{\\mathrm{idj}}(\\omega^i) + \\gamma, \\quad g_j(\\omega^i) := b_j(\\omega^i) + \\beta \\mathsf{S}_{\\sigma \\mathrm{j}}(\\omega^i) + \\gamma</span></div>

    <p class="text-gray-300">for all <span class="math">i \\in [n]</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">f(X, \\beta, \\gamma) = f(X) := \\prod_{j \\in [r]} f_j(X), \\quad g(X, \\beta, \\gamma) = g(X) := \\prod_{j \\in [r]} g_j(X). \\tag{20}</span></div>

    <p class="text-gray-300">Now <span class="math">\\mathsf{P}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\text{erm}}}</span> computes a degree <span class="math">&amp;lt; n</span> polynomial <span class="math">z(X)</span> such that <span class="math">z(\\omega) = 1</span>, and for each <span class="math">i \\in \\{2, \\ldots, n\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">z(\\omega^i) = \\prod_{1 \\leq j &amp;lt; i} \\frac{f(\\omega^j)}{g(\\omega^j)}. \\tag{21}</span></div>

    <p class="text-gray-300">If some element <span class="math">g(\\omega^j)</span> is zero, then <span class="math">\\mathsf{P}</span> aborts. In the present context, <span class="math">z(X)</span> is sometimes called a permutation polynomial. Note that if <span class="math">z(X)</span> is well-defined then the following equality holds:</p>

    <div class="my-4 text-center"><span class="math-block">z(X) f(X) = z(\\omega X) g(X). \\tag{22}</span></div>

    <p class="text-gray-300">Note that if <span class="math">r</span> is large, then <span class="math">z(X)f(X)</span> can have degree up to <span class="math">(r + 1)n</span>, which could end up being too large. To avoid this, the prover splits <span class="math">f(X)</span> and <span class="math">g(X)</span> in the constraint of Eq. (22) into <span class="math">s := \\lceil r / u \\rceil</span> factors as follows: For each <span class="math">i \\in [s]</span>, <span class="math">\\mathsf{P}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\text{erm}}}</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">\\bar{f}_i(X, \\beta, \\gamma) = \\bar{f}_i(X) := \\prod_{j = u(i-1) + 1}^{\\mathfrak{u}i} f_j(X) \\tag{23}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bar{g}_i(X, \\beta, \\gamma) = \\bar{g}_i(X) := \\prod_{j = u(i-1) + 1}^{\\mathfrak{u}i} g_j(X)</span></div>

    <p class="text-gray-300">Note that <span class="math">f(X) = \\bar{f}_1(X) \\cdots \\bar{f}_s(X)</span> and <span class="math">g(X) = \\bar{g}_1(X) \\cdots \\bar{g}_s(X)</span>. Additionally, <span class="math">\\mathsf{P}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\text{erm}}}</span> computes polynomials <span class="math">\\pi_1(X), \\ldots, \\pi_{s-1}(X)</span> of degree less than <span class="math">n</span> such that, for all <span class="math">i \\in [n]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_1(\\omega^i) = z(\\omega^i) \\bar{f}_1(\\omega^i) \\bar{g}_1(\\omega^i)^{-1}, \\tag{24}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi_j(\\omega^i) = \\pi_{j-1}(\\omega^i) \\bar{f}_j(\\omega^i) \\bar{g}_j(\\omega^i)^{-1} \\quad \\text{for } j = 2, \\ldots, s-1.</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{P}</span> then sends <span class="math">\\llbracket z \\rrbracket, \\llbracket \\pi_1 \\rrbracket, \\ldots, \\llbracket \\pi_{s-1} \\rrbracket</span> to <span class="math">\\mathsf{V}</span>.</p>

    <p class="text-gray-300">Additionally, <span class="math">\\mathsf{P}</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_1(X) := (\\pi_1(X) \\bar{g}_1(X) - z(X) \\bar{f}_1(X)) / Z_H(X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_2(X) := (\\pi_2(X) \\bar{g}_2(X) - \\pi_1(X) \\bar{f}_2(X)) / Z_H(X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cdots</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_s(X) := (z(\\omega X) \\bar{g}_s(X) - \\pi_{s-1}(X) \\bar{f}_s(X)) / Z_H(X).</span></div>

    <p class="text-gray-300">Notice that each <span class="math">\\delta_i(X)</span> corresponds to a polynomial of degree at most <span class="math">\\mathfrak{un}</span>. Now, for each <span class="math">\\delta_i</span>, the prover computes <span class="math">\\mathfrak{u}</span> codewords <span class="math">(\\delta_{ij}(X))_{j \\in [\\mathfrak{u}]}</span> from <span class="math">\\mathsf{RS}[\\mathbb{F}, D, \\mathfrak{n}]</span> so that <span class="math">\\delta_i = \\sum_{j \\in [\\mathfrak{u}]} X^j \\delta_{ij}(X)</span>. Then the prover sends <span class="math">(\\llbracket f_{ij} \\rrbracket)_{i \\in [\\mathfrak{s}], j \\in [\\mathfrak{u}]}</span> to the verifier.</p>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Verifier’s Decision.</h6>

    <p class="text-gray-300">The verifier constructs oracles (using the oracles it already has access to) to the words <span class="math">(\\delta_{i}(X))_{i\\in[\\mathsf{s}]}</span>. Then it uses <span class="math">\\mathsf{OCoAgg}(\\delta)</span> to determine whether these words have <span class="math">\\delta</span>-correlated agreement in <span class="math">\\mathsf{RS}[\\mathbb{F},D,\\mathsf{n}]</span>. The verifier accepts if and only if this check is successful.</p>

    <h6 id="sec-127" class="text-base font-medium mt-4">Remark 7.2 (Recovering Plonk’s original permutation IOP).</h6>

    <p class="text-gray-300">Plonk’s original permutation hIOP can be recovered from <span class="math">\\Pi_{\\mathsf{R_{RPerm}}}(\\delta)</span> by letting <span class="math">\\delta=0</span>, and specializing the parameters <span class="math">\\mathsf{r}</span> and <span class="math">\\mathsf{u}</span> to <span class="math">\\mathsf{r}=3</span>, and <span class="math">\\mathsf{u}=1</span> (which leads to <span class="math">\\mathsf{s}=1</span>).</p>

    <p class="text-gray-300">Here we argue that the protocol <span class="math">\\Pi_{\\mathsf{R_{RPerm}}}(\\delta)</span> is a <span class="math">\\delta</span>-correlated hIOP (as per Definition 6.1). Indeed, the only part of the protocol that requires our inspection is the verifier’s decision phase. This is because the definition of <span class="math">\\delta</span>-correlated hIOP requires the verifier use the oracle <span class="math">\\mathsf{OCoAgg}(\\delta)</span> on a list of words of the form <span class="math">(w(X)-a)/(X-\\xi)</span> for some words <span class="math">w(X)</span> and some field elements <span class="math">a,\\xi</span>. However, in our formulation of <span class="math">\\Pi_{\\mathsf{R_{RPerm}}}(\\delta)</span>, the verifier uses <span class="math">\\mathsf{OCoAgg}(\\delta)</span> on the list of words <span class="math">(\\delta_{i}(X))_{i\\in[\\mathsf{s}]}</span>. This is in fact not a discrepancy, since each word <span class="math">\\delta_{i}(X)</span> can be written in the required manner, e.g. by letting <span class="math">\\mathsf{Z_{H}}(X)=(X-\\omega)\\mathsf{Z_{H}}^{\\prime}(X)</span> for some polynomial <span class="math">\\mathsf{Z_{H}}^{\\prime}(X)</span> and then writing</p>

    <p class="text-gray-300"><span class="math">\\delta_{i}(X)=\\frac{\\frac{\\mathsf{Z_{H}}(X)\\delta_{i}(X)}{\\mathsf{Z_{H}}^{\\prime}(X)}-0}{X-\\omega}.</span></p>

    <p class="text-gray-300">Hence, <span class="math">\\Pi_{\\mathsf{R_{RPerm}}}(\\delta)</span> fits the definition of <span class="math">\\delta</span>-correlated hIOP.</p>

    <h3 id="sec-128" class="text-xl font-semibold mt-8">7.2 A <span class="math">\\delta</span>-correlated hIOP for TurboPlonk’s and Plonky2’s Relation</h3>

    <p class="text-gray-300">In this section we describe the <span class="math">\\delta</span>-correlated hIOP <span class="math">\\mathsf{OPlonky}(\\delta)</span>. This is an hIOP for a indexed <span class="math">(\\mathbb{F},D,\\mathsf{n})</span>-polynomial oracle relation <span class="math">\\mathbf{R_{ROPlonky}}</span>, which we formulate next. We let an index <span class="math">\\mathbb{i}</span> of <span class="math">\\mathbf{R_{ROPlonky}}</span> be a tuple of the form <span class="math">(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t})</span>, where <span class="math">\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t}</span> are positive integers, and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{P}</span> is a list of <span class="math">(2\\mathsf{r}+\\ell)</span>-variate polynomials <span class="math">P_{i}=P_{i}(X_{1},\\ldots,X_{r},Y_{1},\\ldots,Y_{r},Z_{1},\\ldots,Z_{\\ell})</span> with coefficients in <span class="math">\\mathbb{F}</span>, for $i\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{Q}</span> is a list of <span class="math">\\ell</span> vectors <span class="math">(\\mathsf{sel}_{1},\\ldots,\\mathsf{sel}_{\\ell})\\in(\\mathbb{F}^{\\mathsf{n}})^{\\ell}</span>. We call these <em>selector vectors</em>.</li>

      <li><span class="math">\\mathsf{r}^{\\prime}\\leq\\mathsf{r}</span>. Intuitively speaking, execution traces have size <span class="math">\\mathsf{n}\\times\\mathsf{r}</span> and <span class="math">\\mathsf{r}^{\\prime}</span> is the number of columns in it whose entries are subject to “permutation constraints”.</li>

      <li><span class="math">\\sigma</span> is a permutation <span class="math">\\sigma:[\\mathsf{r}^{\\prime}\\mathsf{n}]\\to[\\mathsf{r}^{\\prime}\\mathsf{n}]</span>.</li>

      <li>A subset <span class="math">\\mathsf{Pl}\\subset[\\mathsf{rn}]</span> indicating, intuitively speaking, the location of the public inputs in an execution trace.</li>

      <li><span class="math">\\mathsf{t}</span> is a parameter that, roughly, controls the number that certain checks are performed.</li>

    </ul>

    <p class="text-gray-300">Usually, <span class="math">\\mathsf{t}=1</span>, but Plonky2 sets <span class="math">\\mathsf{t}=2</span> to account for usage of a small field.</p>

    <p class="text-gray-300">An <em>execution trace</em> for such an index <span class="math">\\mathbb{i}</span> is a vector <span class="math">\\mathbb{w}\\in\\mathbb{F}^{\\mathsf{nr}}</span>. For intuitive purpose, it may be helpful to think of <span class="math">\\mathbb{w}</span> as a <span class="math">\\mathsf{n}\\times\\mathsf{r}</span> matrix whose entry <span class="math">(i,j)</span> is <span class="math">\\mathbb{w}_{(i-1)\\mathsf{r}+j}</span> for all <span class="math">i\\in[\\mathsf{n}]</span> and <span class="math">j\\in[\\mathsf{r}]</span>. Such a trace is said to satisfy <span class="math">\\mathbb{i}</span> if both conditions below hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. (Index’s circuit constraint satisfaction) For all $j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> and all </span>i\\in[\\mathsf{n}-1]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P_{j}(\\mathbb{w}_{(i-1)\\mathsf{r}+1},\\ldots,\\mathbb{w}_{ir},\\mathbb{w}_{ir+1},\\ldots,\\mathbb{w}_{(i+1)\\mathsf{r}},\\mathsf{sel}_{1i},\\ldots,\\mathsf{sel}_{\\ell i})=0</span> (25)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Index’s copy constraint satisfaction) For all <span class="math">i\\in[\\mathsf{rn}]</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbb{w}_{i}=\\mathbb{w}_{\\sigma(i)}.</span> (26)</p>

    <p class="text-gray-300">We say that the <em>public part</em> of an execution trace <span class="math">\\mathbb{w}\\in\\mathbb{F}^{\\mathsf{nr}}</span> is the vector formed by the entries <span class="math">\\{\\mathbb{w}_{i}\\mid i\\in\\mathsf{Pl}\\}</span>. We denote the vector formed by these entries by <span class="math">\\mathbb{w}^{(\\mathsf{pi})}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Then we define the indexed relation <span class="math">\\mathbf{R}_{\\mathrm{ROPlonky}}</span> can as:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}_{\\mathrm{ROPlonky}} := \\left\\{ (\\mathfrak{i}, \\pi, \\mathfrak{w}) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathfrak{i} = (\\mathcal{P}, Q, H, \\sigma, \\mathsf{Pl}, \\mathsf{r}, \\mathsf{r}^{\\prime}, \\ell, \\mathsf{t}), \\\\ \\pi \\in \\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pl}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\mathfrak{w} \\in \\mathbb{F}^{\\mathsf{rh}}, \\\\ \\mathfrak{w} \\text{ satisfies } \\mathfrak{i}, \\\\ \\pi = \\mathfrak{w}^{(\\mathsf{pl})}. \\end{array} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Remark 7.3 (Routable and advice wires). Following Plonky2 [Polb], in <span class="math">\\mathbf{R}_{\\mathrm{ROPlonky}}</span> we allow to have an execution trace <span class="math">\\mathfrak{w} \\in \\mathbb{F}^{\\mathrm{rh}}</span> where the values in some columns are not subject to any copy constraint. Following the terminology in [Polb], such columns are called advice wires, while the rest of the columns are called routable wires.</p>

    <p class="text-gray-300">The number of columns that are not exempt from these constraints is precisely <span class="math">r&#x27;</span>. For simplicity, we always assume that <span class="math">\\mathfrak{w}</span> is set up in a way that its first <span class="math">r&#x27;</span> columns are routable wires, and the remaining columns are advice wires. Accordingly, we consider permutations <span class="math">\\sigma : [r&#x27;n] \\to [r&#x27;n]</span> rather than <span class="math">\\sigma : [\\mathsf{rn}] \\to [\\mathsf{rn}]</span>.</p>

    <p class="text-gray-300">Remark 7.4 (Enforcing public inputs). The clause <span class="math">\\pi = \\mathfrak{w}^{(\\mathrm{pl})}</span> from <span class="math">\\mathbf{R}_{\\mathrm{ROPlonky}}</span> can be "absorbed" in the circuit satisfaction and copy constraints (see for example [GW]). With this in mind, we will always assume that, given <span class="math">(\\mathfrak{i}, \\pi)</span> if a witness <span class="math">\\mathfrak{w}</span> satisfies both the circuit and copy constraints of given by <span class="math">\\mathfrak{i}</span>, then <span class="math">\\mathfrak{w}^{(\\mathrm{pl})} = \\pi</span>.</p>

    <p class="text-gray-300">In Section 7.3.2 we briefly discuss how this relation generalizes Plonk's [GWC19], Redshift's [KPV22], TurboPlonk's [GW] relation, and how it is, essentially, a formalization of Plonky2's [Polb] relation.</p>

    <h2 id="sec-129" class="text-2xl font-bold">7.2.1 Description of the hIOP</h2>

    <p class="text-gray-300">We proceed to describe a <span class="math">\\delta</span>-correlated hIOP for the relation <span class="math">\\mathbf{R}_{\\mathrm{ROPlonky}}</span>. We denote such protocol as <span class="math">\\mathsf{OPlonky}(\\delta) = (\\mathsf{Ind}_{\\mathsf{Plonky}}, \\mathsf{P}_{\\mathsf{OPlonky}}, \\mathsf{V}_{\\mathsf{OPlonky}}^{\\mathsf{OCoAgg}(\\delta)})</span>.</p>

    <p class="text-gray-300">The protocol works as follows for each triple <span class="math">(\\mathfrak{i} = (\\mathcal{P}, Q, H, \\sigma, \\mathsf{Pl}, \\mathsf{r}, \\mathsf{r}&#x27;, \\ell, \\mathsf{t}), \\pi, \\mathfrak{w}) \\in \\mathbf{R}_{\\mathrm{ROPlonky}}</span>.</p>

    <h2 id="sec-130" class="text-2xl font-bold">7.2.2 Indexer</h2>

    <p class="text-gray-300">The algorithm <span class="math">\\mathsf{Ind}_{\\mathsf{Plonky}}</span> receives <span class="math">\\mathfrak{i}</span> as input and outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Ind}_{\\mathsf{Plonky}}(\\mathfrak{i}) = (\\mathfrak{i}, (\\mathsf{sel}_j(X))_{j \\in [\\ell]}, (S_{\\mathrm{idj}}(X), S_{\\sigma \\mathrm{j}(X)})_{j \\in [\\mathsf{r}^{\\prime}]}, \\mathbb{K}, \\mathfrak{u}, \\mathfrak{t}),</span></div>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <span class="math">\\mathsf{sel}_j(X)</span> are polynomials defined as <span class="math">\\mathsf{sel}_j(X) = \\sum_{i=1}^{n} \\mathsf{sel}_{j,i} \\mathsf{L}_i(X)</span>, for each <span class="math">j \\in [\\ell]</span>.</li>

      <li>The <span class="math">S_{\\mathrm{idj}}(X), S_{\\sigma \\mathrm{j}}(X)</span> are the polynomials output by <span class="math">\\mathbf{R}_{\\mathbf{RPerm}}</span>'s indexer (see Eq. (18)) on input <span class="math">(r&#x27;, \\sigma)</span>.</li>

      <li><span class="math">\\mathbb{K}</span> is a finite field extension of <span class="math">\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathfrak{u}, \\mathfrak{t}</span> are positive integers.</li>

    </ul>

    <h2 id="sec-131" class="text-2xl font-bold">7.2.3 Online Phase</h2>

    <p class="text-gray-300">For convenience we denote <span class="math">\\mathsf{P}_{\\mathsf{OPlonky}}(\\mathsf{Ind}_{\\mathsf{Plonky}}(\\mathfrak{i}), \\pi, \\mathfrak{w})</span> by <span class="math">\\mathsf{P}_{\\mathsf{OPlonky}}</span> and denote <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}^{\\mathsf{Ind}_{\\mathsf{Plonky}}(\\mathfrak{i}), \\mathsf{OCoAgg}(\\delta)}(\\pi)</span> by <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}</span>. We emphasize again that for most Plonk-type IOPs, the parameter <span class="math">\\mathfrak{t} = 1</span>, and that in Plonky2 one has <span class="math">\\mathfrak{t} = 2</span> to account for the usage of a small field.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Prover's message 1</strong> <span class="math">\\mathsf{P}_{\\mathsf{OPlonky}}</span> computes <span class="math">\\mathsf{a}_1(X), \\ldots, \\mathsf{a}_r(X)</span> as <span class="math">\\mathsf{a}_j(X) = \\sum_{i=1}^{n} \\mathfrak{w}_{(j-1)n+i} \\mathsf{L}_i(X)</span> for each <span class="math">j \\in [\\mathsf{r}]</span>. It then sends oracles $\\llbracket \\mathsf{a}_1(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D \\rrbracket, \\ldots, \\llbracket \\mathsf{a}_r(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D \\rrbracket<span class="math"> to </span>\\mathsf{V}_{\\mathsf{OPlonky}}<span class="math">, where </span>\\mathsf{a}_i(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D<span class="math"> denotes the word from </span>\\mathbb{F}^D<span class="math"> obtained by restricting </span>\\mathsf{a}_i(X)<span class="math"> on </span>D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">51</p>

    <p class="text-gray-300">Permutation argument part (Verifier's challenge 1 and Prover's message 2) For  <span class="math">t</span>  times in parallel,  <span class="math">P_{OPlonky}</span>  and  <span class="math">V_{OPlonky}</span>  execute the online phase of the permutation proof  <span class="math">\\Pi_{R_{RProva}}</span>  for the triple</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\dot {z} ^ {\\prime}, \\Sigma^ {\\prime}, \\mathbb {W} ^ {\\prime}\\right) = \\left(\\left(r ^ {\\prime}, \\sigma\\right), \\left(\\llbracket a _ {i} \\rrbracket , \\llbracket a _ {i} \\rrbracket\\right) _ {i \\in [ r ^ {\\prime} ]}, \\left(a _ {i}, a _ {i}\\right) _ {i \\in [ r ^ {\\prime} ]}\\right).</span></div>

    <p class="text-gray-300">The indexer  <span class="math">\\mathrm{Ind}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\mathbb{P}\\mathbb{P}\\mathbb{P}\\mathbb{A}}}</span>  is not called since both  <span class="math">\\mathsf{P}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\mathbb{P}\\mathbb{P}\\mathbb{A}}}</span>  and  <span class="math">\\mathsf{V}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\mathbb{P}\\mathbb{P}\\mathbb{A}}}</span>  already have access to  <span class="math">\\mathrm{Ind}_{\\mathbb{R}_{\\mathbb{R}\\mathbb{P}\\mathbb{P}\\mathbb{P}\\mathbb{A}}}(\\dot{z}^{\\prime}) = (\\dot{z}^{\\prime},\\mathsf{u},(S_{\\mathrm{idj}}(X),S_{\\sigma \\mathrm{j}(X)})_{j\\in [r^{\\prime}]}).</span>  Only the interactive phase is executed, and  <span class="math">\\mathsf{V}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span>  does not execute the decision phase when the interactive phase is over.</p>

    <p class="text-gray-300">At the end of each of the  <span class="math">t</span>  executions of the interactive phase,  <span class="math">V_{OPlonky}</span>  has received oracles</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\llbracket z _ {k} \\rrbracket , \\llbracket \\pi_ {k, 1} \\rrbracket , \\dots , \\llbracket \\pi_ {k, (s - 1)} \\rrbracket\\right)</span></div>

    <p class="text-gray-300">for each  <span class="math">k \\in [t]</span> . Let  <span class="math">(\\beta_k, \\gamma_k)</span>  be the verifier's challenges on each of the executions.</p>

    <p class="text-gray-300">For each  <span class="math">k \\in [t]</span> , we denote by  <span class="math">(\\bar{f}_{ki}(X))_{i \\in [s]}</span>  the polynomials in Eq. (23) computed with the challenges  <span class="math">\\beta_k, \\gamma_k</span> .</p>

    <p class="text-gray-300">Verifier's challenge 2  <span class="math">\\mathsf{V}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span>  samples random challenges  <span class="math">\\alpha_{1},\\ldots ,\\alpha_{t}</span>  and sends them to  <span class="math">\\mathsf{P}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span></p>

    <p class="text-gray-300">Prover's message 3  <span class="math">\\mathsf{P}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span>  computes polynomials  <span class="math">(\\mathsf{u}_{k_1,k_2}(X),\\mathsf{d}_k(X),\\mathsf{q}_k(X))_{k_1,k_2,k\\in [\\mathsf{t}]}</span>  as follows (see Remark 7.5 and Appendix C for an intuition of why this polynomial is constructed as it is):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathrm {u} _ {k _ {1}, k _ {2}} (X) := \\left(\\bar {f} _ {k _ {1} 1} (X) \\mathrm {z} _ {k _ {1}} (X) - \\pi_ {k _ {1}, 1} (X) \\bar {g} _ {k _ {1} 1} (X)\\right) \\alpha_ {k _ {2}} \\\\ + \\sum_ {j = 2} ^ {s} \\left(\\bar {f} _ {k _ {1} j} (X) \\pi_ {k _ {1}, j - 1} (X) - \\pi_ {k _ {1}, j} (X) \\bar {g} _ {k _ {1} j} (X)\\right) \\alpha_ {k _ {2}} ^ {j} \\\\ + \\left(\\bar {f} _ {k _ {1} s} (X) \\pi_ {k _ {1}, s - 1} (X) - z _ {k _ {1}} (\\omega X) \\bar {g} _ {k _ {1} s} (X)\\right) \\alpha_ {k _ {2}} ^ {s + 1} \\\\ + \\left(z _ {k _ {1}} (X) - 1\\right) L _ {1} (X) \\alpha_ {k _ {2}} ^ {s + 2}. \\tag {27} \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {d} _ {k} (X) := \\sum_ {j \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]} \\alpha_ {k} ^ {j - 1} P _ {j} (\\mathsf {a} _ {1} (X), \\ldots , \\mathsf {a} _ {\\mathsf {r}} (X), \\mathsf {a} _ {1} (\\omega X), \\ldots , \\mathsf {a} _ {\\mathsf {r}} (\\omega X), \\mathsf {s e l} _ {1} (X), \\ldots , \\mathsf {s e l} _ {\\ell} (X)) \\\\ + \\alpha_ {k} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} \\left(u _ {1, k} (X) + \\alpha_ {k} ^ {s + 2} u _ {2, k} (X) + \\ldots + \\alpha_ {k} ^ {(t - 1) (s + 2)} u _ {t, k}\\right). \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {q} _ {k} (X) := \\mathrm {d} _ {k} (X) / \\mathrm {Z} _ {\\mathrm {H}} (X).</span></div>

    <p class="text-gray-300">Then  <span class="math">\\mathsf{P}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span>  splits the polynomials  <span class="math">\\mathfrak{q}_k(X)</span>  into degree  <span class="math">n</span>  polynomials  <span class="math">\\mathfrak{q}_{k,1}(X),\\ldots ,\\mathfrak{q}_{k,\\nu}(X)</span> , so that  <span class="math">\\mathfrak{q}_k(X) = \\sum_{i = 1}^{\\nu}X^{ni}P_{k,\\nu}(X)</span>  and sends oracle access to these to  <span class="math">\\mathsf{V}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span> .</p>

    <p class="text-gray-300">Verifier's challenge 3  <span class="math">\\mathsf{V}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span>  samples a challenge  <span class="math">\\mathfrak{z} \\in \\mathbb{K} \\setminus D</span>  and sends it to  <span class="math">\\mathsf{P}</span> .</p>

    <p class="text-gray-300">Prover's message 4  <span class="math">\\mathsf{P}_{\\mathsf{O}\\mathsf{P}\\mathsf{l}\\mathsf{o}\\mathsf{n}\\mathsf{k}\\mathsf{y}}</span>  replies with the evaluations</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {a} _ {j} (\\mathfrak {z}), \\mathsf {a} _ {j} (\\omega \\mathfrak {z}), \\mathsf {q} _ {k, j ^ {\\prime \\prime}} (\\mathfrak {z}), \\pi_ {k i} (\\mathfrak {z}), \\mathsf {z} _ {k} (\\mathfrak {z}), \\mathsf {z} _ {k} (\\omega \\mathfrak {z}), \\mathsf {s e l} _ {j ^ {\\prime}} (\\mathfrak {z}), \\mathsf {S} _ {\\mathrm {i d j}} (\\mathfrak {z}), \\mathsf {S} _ {\\sigma \\mathrm {j}} (\\mathfrak {z})\\right)</span></div>

    <p class="text-gray-300">for all  <span class="math">j\\in [\\mathsf{r}],j^{\\prime}\\in [\\ell ],j^{\\prime \\prime}\\in [\\nu ]k\\in [\\mathsf{t}],i\\in [\\mathsf{s} - 1]</span></p>

    <h2 id="sec-132" class="text-2xl font-bold">7.2.4 Verifier's Decision</h2>

    <p class="text-gray-300">Check 1 For each  <span class="math">k \\in [t]</span> ,  <span class="math">V_{\\mathsf{OPlonky}}</span>  computes  <span class="math">Z_{\\mathsf{H}}(\\mathfrak{z})</span> ,  <span class="math">q_k(\\mathfrak{z})</span> , and  <span class="math">\\mathsf{d}_k(\\mathfrak{z})</span>  with the purported polynomial openings</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {a} _ {j} (\\mathfrak {z}), \\mathsf {a} _ {j} (\\omega \\mathfrak {z}), \\mathsf {S} _ {\\sigma \\mathrm {j}} (\\mathfrak {z}), \\mathsf {q} _ {k, j ^ {\\prime}} (\\mathfrak {z}), \\pi_ {k i} (\\mathfrak {z}), \\mathsf {z} _ {k} (\\mathfrak {z}), \\mathsf {z} _ {k} (\\omega \\mathfrak {z})\\right) _ {j \\in [ \\mathsf {r} ], j ^ {\\prime} \\in [ \\nu ], k \\in [ \\mathsf {t} ], i \\in [ \\mathsf {s} - 1 ]}.</span></div>

    <p class="text-gray-300">Then it checks that  <span class="math">\\mathsf{d}_k(\\mathfrak{z}) = \\mathfrak{q}_k(\\mathfrak{z})Z_{\\mathsf{H}}(\\mathfrak{z})</span> . If this check fails,  <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}</span>  rejects the proof.</p>

    <p class="text-gray-300">Check 2 Given a word  <span class="math">m:L\\to \\mathbb{K}</span>  and  <span class="math">\\mathfrak{z}\\in \\mathbb{K},y\\in \\mathbb{K}</span> , define quotient  <span class="math">(m,\\mathfrak{z},y)\\coloneqq \\frac{m(X) - y}{X - \\mathfrak{z}}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}</span> uses its <span class="math">\\mathsf{OCoAgg}(\\delta)</span> on the input</p>

    <p class="text-gray-300"><span class="math">\\pi_{\\mathsf{CA}}:=(\\llbracket\\mathsf{quotient}(\\mathsf{a}(X),\\mathfrak{z},\\mathsf{a}_{j}(\\mathfrak{z}))\\rrbracket,\\llbracket\\mathsf{quotient}(\\mathsf{a}(\\omega X),\\mathfrak{z},\\mathsf{a}_{j}(\\omega\\mathfrak{z}))\\rrbracket,</span> <span class="math">\\llbracket\\mathsf{quotient}(\\mathsf{q}_{k}(X),\\mathfrak{z},\\mathsf{q}_{k,j^{\\prime\\prime}}(\\mathfrak{z}))\\rrbracket,\\llbracket\\mathsf{quotient}(\\pi_{ki}(X),\\mathfrak{z},\\pi_{ki}(\\mathfrak{z}))\\rrbracket,</span> <span class="math">\\llbracket\\mathsf{quotient}(\\mathsf{z}_{k}(X),\\mathfrak{z},\\mathsf{z}_{k}(\\mathfrak{z}))\\rrbracket,\\llbracket\\mathsf{quotient}(\\mathsf{z}_{k}(X),\\mathfrak{z},\\mathsf{z}_{k}(\\omega\\mathfrak{z}))\\rrbracket</span> (28) <span class="math">\\llbracket\\mathsf{quotient}(\\mathsf{sel}_{j^{\\prime}}(X),\\mathfrak{z},\\mathsf{sel}_{j^{\\prime}}(\\mathfrak{z}))\\rrbracket,\\llbracket\\mathsf{quotient}(\\mathsf{S}_{\\mathsf{idj}}(X),\\mathfrak{z},\\mathsf{S}_{\\mathsf{idj}}(\\mathfrak{z}))\\rrbracket</span> <span class="math">\\llbracket\\mathsf{quotient}(\\mathsf{S}_{\\mathsf{\\sigma j}}(X),\\mathfrak{z},\\mathsf{S}_{\\mathsf{\\sigma j}}(\\mathfrak{z}))\\rrbracket)_{j\\in[\\mathsf{r}],j^{\\prime}\\in[\\ell],j^{\\prime\\prime}\\in[\\mathsf{v}],k\\in[\\mathsf{t}],i\\in[\\mathsf{s-1}]}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and the index $\\mathsf{i}_{\\mathsf{CA}}:=(\\mathbb{F},D,\\mathsf{n},\\delta,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathsf{CA}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. If </span>\\mathsf{OCoAgg}(\\delta)<span class="math"> rejects, then </span>\\mathsf{V}_{\\mathsf{OPlonky}}$ rejects the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If all checks above pass, then <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}</span> accepts. This completes the description of <span class="math">\\mathsf{OPlonky}(\\delta)</span>.</p>

    <h6 id="sec-133" class="text-base font-medium mt-4">Remark 7.5 (Explaining the parameter <span class="math">\\mathsf{t}</span>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As we mentioned, the parameter <span class="math">\\mathsf{t}</span> roughly controls the number of times that certain checks are performed in <span class="math">\\mathsf{OPlonky}(\\delta)</span>. We see in Lemma 4.9 that the security of <span class="math">\\mathsf{OPlonky}(\\delta)</span> can be substantially increased by increasing <span class="math">\\mathsf{t}</span>. Thus, <span class="math">\\mathsf{t}</span> may be useful, for example, when one is aiming to work over a small field <span class="math">\\mathbb{F}</span>. This is precisely the case with <span class="math">\\mathsf{Plonky2}</span> <em>[x20]</em>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{64}<span class="math">. Setting </span>\\mathsf{t}=2<span class="math"> endows </span>\\mathsf{Plonky2}<span class="math"> with a security of roughly </span>\\mathsf{m}/2^{128}<span class="math">, where </span>\\mathsf{m}$ here is, roughly, the constraint size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is important to note that there are subtleties in the way this is achieved. For example, notice that the first round of <span class="math">\\mathsf{OPlonky}(\\delta)</span> is performed in parallel <span class="math">\\mathsf{t}</span> times. On the other hand, the second round is not repeated <span class="math">\\mathsf{t}</span> times in parallel, and instead a more involved procedure is taken.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This is crucial: if for example one simply repeated the second round in parallel (see Appendix C for the details), and set <span class="math">\\mathsf{t}=2</span>, then the resulting protocol would only have $\\approx\\mathsf{m}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> RBR soundness and RBR knowledge soundness. Moreover, when compiled into a SNARK, one could apply the attack from <em>[x1]</em>, which would break the soundness property of the SNARK with probability </span>\\approx\\mathsf{m}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. This is an attack on the Fiat-Shamir transformation of the parallel repetition of interactive proofs. We provide more details in Appendix C.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-134" class="text-xl font-semibold mt-8">7.3 RBR Soundness and Knowledge of <span class="math">\\mathsf{OPlonky}</span></h3>

    <p class="text-gray-300">Now that we have described <span class="math">\\mathsf{OPlonky}(\\delta)</span>, we can take any IOPP <span class="math">\\mathsf{\\Pi}_{\\mathsf{CA}}</span> for the <span class="math">\\delta</span>-correlated agreement relation <span class="math">\\mathbf{CoAgg}(\\delta)</span> (e.g. batched FRI), and compile <span class="math">\\mathsf{OPlonky}(\\delta)</span> into a hIOP for the relation <span class="math">\\mathbf{R}_{\\mathbf{ROPlonky}}</span> as per Definition 6.2. Recall that, essentially, this entails replacing the verifier’s call to <span class="math">\\mathsf{OCoAgg}(\\delta)</span> by an execution of <span class="math">\\mathsf{\\Pi}_{\\mathsf{CA}}</span>. The resulting hIOP, which we denote by <span class="math">\\mathsf{Plonky2hIOP}</span>, is essentially an abstraction of <span class="math">\\mathsf{Plonky2}</span>’s succinct interactive argument.</p>

    <p class="text-gray-300">We proceed to prove that <span class="math">\\mathsf{Plonky2hIOP}</span> is RBR sound and has RBR knowledge. To do so, we follow the general technique from Section 6 and first prove that <span class="math">\\mathsf{OPlonky}(0)</span> is RBR sound and has RBR knowledge. Then we obtain RBR soundness and knowledge of <span class="math">\\mathsf{Plonky2hIOP}</span> by applying Theorem 4.6.</p>

    <p class="text-gray-300">We fix <span class="math">\\mathsf{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t})</span> to be a valid index for <span class="math">\\mathbf{R}_{\\mathbf{ROPlonky}}</span> and <span class="math">\\mathtt{w}\\in(\\mathbb{F}^{n})^{\\mathsf{r}}</span>.</p>

    <h6 id="sec-135" class="text-base font-medium mt-4">Lemma 4.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <span class="math">0</span>-correlated agreement encoded hIOP <span class="math">\\mathsf{OPlonky}(0)</span> has RBR soundness and RBR knowledge with the same error <span class="math">\\varepsilon</span>, where, for all index <span class="math">\\mathsf{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t})</span> and any potential input <span class="math">\\pi</span> we have, for $\\mathsf{n}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\varepsilon(\\mathsf{i})=\\max_{i\\in[3]}\\left\\{\\varepsilon_{i}(\\mathsf{i})\\right\\},</span> $\\varepsilon_{1}(\\mathsf{i}):=\\left(\\frac{3\\mathsf{n}(\\mathsf{r}^{\\prime}+\\mathsf{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathsf{t}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-136" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Fix an index <span class="math">\\mathsf{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathsf{r},\\mathsf{r}^{\\prime},\\ell,\\mathsf{t})</span>, and potential input <span class="math">\\pi</span> and witnesses <span class="math">\\mathtt{w}\\in\\mathbb{F}^{m}</span>. For each of the notions of RBR soundness and knowledge we define four sets <span class="math">(\\mathcal{D}_{i}^{\\mathsf{s}}(\\mathsf{i}))_{i=0,\\ldots,3}</span> and <span class="math">(\\mathcal{D}_{i}^{\\mathsf{k}}(\\mathsf{i}))_{i=0,\\ldots,3}</span>. We let:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{D}_{0}^{\\mathsf{s}}(\\mathsf{i})</span> consist of all transcripts of the form <span class="math">(\\pi,\\emptyset)</span>, for <span class="math">\\pi\\notin\\mathcal{L}_{\\mathbf{R}_{\\mathbf{ROPlonky}},\\mathsf{i}}</span>,</li>

      <li><span class="math">\\mathcal{D}_{0}^{\\mathsf{k}}(\\mathsf{i})</span> consist of all transcripts of the form <span class="math">(\\pi,\\emptyset)</span> for any possible <span class="math">\\pi</span>, including those not in <span class="math">\\mathcal{L}_{\\mathbf{R}_{\\mathbf{ROPlonky}},\\mathsf{i}}</span>.</li>

      <li>We set <span class="math">\\mathcal{D}_{i}^{\\mathsf{s}}(\\mathsf{i})=\\mathcal{D}_{i}^{\\mathsf{k}}(\\mathsf{i})</span> for all <span class="math">i\\in[3]</span>. Among other transcripts (which we describe later) we include in each <span class="math">\\mathcal{D}_{i}^{\\mathsf{s}}(\\mathsf{i})=\\mathcal{D}_{i}^{\\mathsf{k}}(\\mathsf{i})</span> all transcripts after the <span class="math">i</span>-round where the prover did not send an oracle to a codeword from <span class="math">\\mathsf{RS}[\\mathbb{F},D,\\mathsf{n}]</span> when it was supposed to.</li>

    </ul>

    <p class="text-gray-300">Now, let <span class="math">(\\beta_{i},\\gamma_{i})_{i\\in[t]}\\in\\mathbb{F}^{2t}</span> be a first prover’s challenge. Let <span class="math">(\\pi,\\tau_{1})</span> be partial transcript after one round of interaction, so that <span class="math">\\tau_{1}=((\\mathsf{a}_{i}(X),)_{i\\in[r]},(\\beta_{i},\\gamma_{i})_{i\\in[t]})</span>. We define <span class="math">\\mathcal{D}_{1}^{\\mathsf{s}}(\\dot{\\mathsf{i}})=\\mathcal{D}_{1}^{\\mathsf{k}}(\\dot{\\mathsf{i}})</span> to consist of all <span class="math">(\\pi,\\tau_{1})</span> such that one of the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For some <span class="math">k\\in[t]</span> there do not exist polynomials <span class="math">\\mathsf{z}(X),\\pi_{1}(X),\\ldots,\\pi_{\\mathsf{s}-1}(X)</span> of degree at most <span class="math">\\mathsf{n}</span> with</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\delta_{1k}(X)</span> <span class="math">\\coloneqq\\pi_{1}(X)\\bar{g}_{1}(\\tau_{1k},X)-\\mathsf{z}(X)\\bar{f}_{1}(\\tau_{1k},X)</span> (29) <span class="math">\\delta_{2k}(X)</span> <span class="math">\\coloneqq\\pi_{2}(X)\\bar{g}_{2}(\\tau_{1k},X)-\\pi_{1}(X)\\bar{f}_{2}(\\tau_{1k},X)</span> <span class="math">\\ldots</span> <span class="math">\\delta_{\\mathsf{s}k}(X)</span> <span class="math">\\coloneqq\\mathsf{z}(\\omega X)\\bar{g}_{\\mathsf{s}}(\\tau_{1k},X)-\\pi_{\\mathsf{s}-1}(X)\\bar{f}_{\\mathsf{s}}(\\tau_{1k},X)</span> <span class="math">\\delta_{\\mathsf{s}+1,k}(X)</span> <span class="math">\\coloneqq\\mathsf{z}(X)(\\mathsf{L}_{1}(X)-1)=0.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- There exists some $j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ such that the word</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P_{j}(\\tau_{1})\\coloneqq P_{j}(\\mathsf{a}_{1}(X),\\ldots,\\mathsf{a}_{r}(X),\\mathsf{a}_{1}(\\omega X),\\ldots,\\mathsf{a}_{r}(\\omega X),\\mathsf{sel}_{1}(X),\\ldots,\\mathsf{sel}_{\\ell}(X))</span> (30)</p>

    <p class="text-gray-300">does not vanish on <span class="math">H</span>.</p>

    <p class="text-gray-300">Next, let <span class="math">(\\alpha_{i})_{i\\in[t]}\\in\\mathbb{F}^{t}</span> and let</p>

    <p class="text-gray-300"><span class="math">\\tau_{2}=(\\tau_{1},(\\mathsf{z}_{k}(X),\\pi_{ki}(X))_{k\\in[t],i\\in[\\mathsf{s}-1]},(\\alpha_{k})_{k\\in[t]})</span></p>

    <p class="text-gray-300">be a partial transcript after the second round of interaction. We define <span class="math">\\mathcal{D}_{3}^{\\mathsf{s}}(\\dot{\\mathsf{i}})=\\mathcal{D}_{3}^{\\mathsf{k}}(\\dot{\\mathsf{i}})</span> to consist of all <span class="math">(\\pi,\\tau_{2})</span> such that for some <span class="math">k\\in[t]</span> the word <span class="math">\\mathsf{d}_{k}(X)</span> does not vanish on <span class="math">H</span>, where <span class="math">\\mathsf{d}_{k}(X)</span> is defined as in Eq. 27.</p>

    <p class="text-gray-300">Finally, let <span class="math">\\mathfrak{z}\\in\\mathbb{K}</span> and let <span class="math">\\tau_{3}=(\\tau_{2},(\\mathsf{q}_{k}(X))_{k\\in[t]},\\mathfrak{z})</span> be a partial transcript after three rounds of interaction. We define <span class="math">\\mathcal{D}_{3}^{\\mathsf{s}}(\\dot{\\mathsf{i}})=\\mathcal{D}_{3}^{\\mathsf{k}}(\\dot{\\mathsf{i}})</span> to consist of all <span class="math">(\\pi,\\tau_{3})</span> such that <span class="math">\\mathsf{d}_{k}(\\mathfrak{z})\\neq\\mathsf{q}_{k}(\\mathfrak{z})\\mathsf{Z}_{\\mathsf{H}}(\\mathfrak{z})</span> for some <span class="math">k\\in[t]</span>. Then, we take</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}^{\\mathsf{s}}(\\dot{\\mathsf{i}})=\\bigcup_{i=0}^{3}\\mathcal{D}_{i}^{\\mathsf{s}}(\\dot{\\mathsf{i}}),\\quad\\mathcal{D}^{\\mathsf{k}}(\\dot{\\mathsf{i}})=\\bigcup_{i=0}^{3}\\mathcal{D}_{i}^{\\mathsf{k}}(\\dot{\\mathsf{i}})</span></p>

    <p class="text-gray-300">as doomed sets. We will prove that <span class="math">\\mathsf{OPlonky}(0)</span> is RBR sound and has RBR knowledge with the same error, when using these doomed sets, respectively.</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{D}_{i}^{\\mathsf{s}}(\\dot{\\mathsf{i}})=\\mathcal{D}_{i}^{\\mathsf{k}}(\\dot{\\mathsf{i}})</span> for all <span class="math">i\\in[3]</span>, we denote the latter by <span class="math">\\mathcal{D}_{i}(\\dot{\\mathsf{i}})</span>.</p>

    <p class="text-gray-300">Indeed, we begin by analyzing the RBR soundness of <span class="math">\\mathsf{OPlonky}(0)</span>. Let us start with an arbitrary input <span class="math">\\pi</span> (not necessarily outside of <span class="math">\\mathcal{L}_{\\mathsf{R}_{\\mathsf{ROPlonky}},\\dot{\\mathsf{i}}}</span>. Note first that <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}</span> rejects any complete transcript <span class="math">(\\pi,\\tau)\\in\\mathcal{D}_{3}(\\dot{\\mathsf{i}})</span>, since we defined <span class="math">\\mathcal{D}_{3}(\\dot{\\mathsf{i}})</span> to consists precisely of those transcripts that fail one of the two checks performed by <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}</span>. Now taking <span class="math">i\\in[3]</span> and <span class="math">(\\pi,\\tau)\\in\\mathcal{D}_{i-1}^{\\mathsf{s}}(\\dot{\\mathsf{i}})</span>, define</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{i}(\\dot{\\mathsf{i}})\\coloneqq\\max_{m_{i}}\\Pr_{c_{i}}[(\\pi,\\tau,m_{i},c_{i})\\notin\\mathcal{D}_{i}^{\\mathsf{s}}(\\dot{\\mathsf{i}})].</span></p>

    <p class="text-gray-300">It follows that <span class="math">\\mathsf{V}_{\\mathsf{OPlonky}}(0)</span> is RBR sound with error <span class="math">\\varepsilon(\\dot{\\mathsf{i}})=\\max_{i\\in[3]}\\{\\varepsilon_{i}(\\dot{\\mathsf{i}})\\}</span>.</p>

    <p class="text-gray-300">We claim that <span class="math">\\varepsilon_{i}(\\dot{\\mathsf{i}})</span> satisfies the bound in the lemma. Indeed, let <span class="math">\\tau_{1},\\tau_{2},\\tau_{3}</span> be as above. We bound first <span class="math">\\varepsilon_{2}(\\dot{\\mathsf{i}})</span> and <span class="math">\\varepsilon_{3}(\\dot{\\mathsf{i}})</span>, and address <span class="math">\\varepsilon_{1}(\\dot{\\mathsf{i}})</span> afterward. For <span class="math">i=2,3</span>, we observe, in general, that if <span class="math">(\\pi,\\tau_{i-1})</span> contains oracles to a word that is not a codeword, when it was supposed to be so, then <span class="math">(\\pi,\\tau_{i})\\in\\mathcal{D}_{i}(\\dot{\\mathsf{i}})</span> with probability <span class="math">1</span>. Hence we assume that all messages sent by the prover are polynomials of appropriate degree.</p>

    <p class="text-gray-300">We begin with <span class="math">\\varepsilon_{2}(\\dot{\\mathsf{i}})</span>. For each <span class="math">x\\in H</span>, consider the following polynomial on <span class="math">\\alpha</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{d}_{(\\pi,\\tau_{1},x)}(\\alpha)</span> $\\coloneqq\\sum_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\alpha^{j-1}P_{j}(\\mathsf{a}_{1}(x),\\ldots,\\mathsf{a}_{r}(x),\\mathsf{a}_{1}(\\omega x),\\ldots,\\mathsf{a}_{r}(\\omega x),\\mathsf{sel}_{1}(x),\\ldots,\\mathsf{sel}_{\\ell}(x))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{i}(\\alpha)</span> <span class="math">\\coloneqq\\left(\\bar{f}_{i1}(x)\\mathsf{z}_{i}(x)-\\pi_{i,1}(x)\\bar{g}_{i1}(x)\\right)\\alpha</span> <span class="math">\\qquad+\\sum_{j=2}^{\\mathsf{s}-1}\\left(\\bar{f}_{ij}(x)\\pi_{i,j-1}(x)-\\pi_{i,j}(x)\\bar{g}_{ij}(x)\\right)\\alpha^{j}</span> <span class="math">\\qquad+\\left(\\bar{f}_{k_{1}\\mathsf{s}}(x)\\pi_{i,\\mathsf{s}-1}(x)-\\mathsf{z}_{i}(\\omega x)\\bar{g}_{i\\mathsf{s}}(x)\\right)\\alpha^{\\mathsf{s}+1}</span> <span class="math">\\qquad+(\\mathsf{z}_{i}(x)-1)\\mathsf{L}_{1}(x)\\alpha^{\\mathsf{s}+2}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then <span class="math">(\\pi,\\tau_{2})\\notin\\mathcal{D}_{2}(\\mathfrak{i})</span> if and only if <span class="math">\\mathsf{d}_{\\pi,\\tau_{1},x}(\\alpha_{j})=0</span> for all <span class="math">j\\in[\\mathsf{t}]</span> and all <span class="math">x\\in H</span>. However, if <span class="math">(\\pi,\\tau_{1})\\in\\mathcal{D}_{1}(\\mathfrak{i})</span>, then either the polynomial <span class="math">P_{j}(\\tau_{1})</span> (see Eq. (30)) does not vanish on <span class="math">H</span>, or, for some <span class="math">k\\in[\\mathsf{t}]</span> and <span class="math">i\\in[\\mathsf{s}+1]</span>, <span class="math">\\delta_{i,k}(X)</span> (<span class="math">i\\in[\\mathsf{s}+1]</span>, see Eq. (29)) does not vanish on <span class="math">H</span>. It follows that there exists <span class="math">x\\in H</span> such that <span class="math">\\mathsf{d}_{\\pi,\\tau_{1},x}(\\alpha)</span> is a nonzero polynomial on <span class="math">\\alpha</span>. This polynomial has degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(\\mathsf{s}+2)\\mathsf{t}-1<span class="math">, and so the probability of sampling a random </span>\\alpha\\in\\mathbb{F}<span class="math"> that is a root of </span>\\mathsf{d}_{\\pi,\\tau_{1},x}(\\alpha)$ is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{2}(\\mathfrak{i})\\leq(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(\\mathsf{s}+2)\\mathsf{t}-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that <span class="math">\\varepsilon_{2}(\\mathfrak{i})</span> is at most the <span class="math">\\mathsf{t}</span>-th power of this probability.</p>

    <p class="text-gray-300">Next we bound <span class="math">\\varepsilon_{3}(\\mathfrak{i})</span>. Suppose <span class="math">(\\pi,\\tau_{2})\\in\\mathcal{D}_{2}(\\mathfrak{i})</span> but <span class="math">(\\pi,\\tau_{3})\\notin\\mathcal{D}_{3}(\\mathfrak{i})</span>. Since, as we discussed, all the words in <span class="math">\\pi_{\\mathsf{CA}}</span> must be polynomials of degree less than <span class="math">\\mathsf{n}</span>, we have that the purported openings in the prover’s last message are correct openings. Moreover, we have that <span class="math">\\mathsf{d}_{k}(\\mathfrak{z})=\\mathsf{q}_{k}(\\mathfrak{z})\\mathsf{Z}_{\\mathsf{H}}(\\mathfrak{z})</span> for all <span class="math">k\\in[\\mathsf{t}]</span>. However, since <span class="math">(\\pi,\\tau_{2})\\in\\mathcal{D}_{2}(\\mathfrak{i})</span>, there is <span class="math">k\\in[\\mathsf{t}]</span> such that <span class="math">\\mathsf{d}_{k}(X)</span> does not vanish on <span class="math">H</span>. This implies that <span class="math">\\mathsf{d}_{\\mathsf{k}}(X)-\\mathsf{q}_{k}(X)\\mathsf{z}_{\\mathsf{H}}(X)</span> is a nonzero polynomial of degree at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max\\{\\mathsf{n}\\max\\{\\deg(P_{j})_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\},\\mathsf{n}(\\mathsf{u}+1)\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, there are at most this number of possible challenges <span class="math">\\mathfrak{z}</span> such that <span class="math">(\\pi,\\tau_{3})\\notin\\mathcal{D}_{3}(\\mathfrak{i})</span>.</p>

    <p class="text-gray-300">We proceed to bound <span class="math">\\varepsilon_{1}(\\mathfrak{i})</span>. Towards also proving RBR knowledge later, on this occasion assume <span class="math">\\pi</span> is an arbitrary input, possibly in <span class="math">\\mathcal{L}_{\\mathsf{R}_{\\mathsf{ROPlonky}},\\mathfrak{i}}</span>. Assume <span class="math">(\\pi,\\tau_{1})\\notin\\mathcal{D}_{1}(\\mathfrak{i})</span>. Then, all (oracles of) the words sent by the prover are actual codewords from <span class="math">\\mathsf{RS}[\\mathbb{F},D,\\mathsf{n}]</span>, and for all <span class="math">i\\in[\\mathsf{s}+1]</span> and <span class="math">k\\in[\\mathsf{t}]</span>, <span class="math">\\delta_{i,k}(X)</span> vanishes on <span class="math">H</span>. Moreover, <span class="math">P_{k}(\\tau_{1})</span> vanishes on <span class="math">H</span> as well.</p>

    <p class="text-gray-300">Given <span class="math">\\beta,\\gamma\\in\\mathbb{F}</span>, define</p>

    <p class="text-gray-300"><span class="math">F(\\beta,\\gamma)=(\\bar{f}_{j}(X,\\beta,\\gamma))_{j\\in[\\mathsf{s}]},\\qquad G(\\beta,\\gamma)=(\\bar{g}_{j}(X,\\beta,\\gamma))_{j\\in[\\mathsf{s}]}</span></p>

    <p class="text-gray-300">where the <span class="math">\\bar{f}_{j}</span> and <span class="math">\\bar{g}_{j}</span> are defined as in Eq. (23).</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}</span> be the event that the first verifier challenge <span class="math">(\\beta_{k},\\gamma_{k})_{k\\in[\\mathsf{t}]}</span> is such that for all <span class="math">k\\in[\\mathsf{t}]</span> and all <span class="math">v(X)\\in F(\\beta,\\gamma)\\cup G(\\beta,\\gamma)</span> we have <span class="math">v(x)\\neq 0</span> for all <span class="math">x\\in H</span>.</p>

    <p class="text-gray-300">We claim that, if <span class="math">\\mathcal{E}</span> holds, then <span class="math">\\delta_{i,k}(X)</span> vanishes on <span class="math">H</span> for all <span class="math">i\\in[\\mathsf{s}+1]</span>, <span class="math">k\\in[\\mathsf{t}]</span> if and only if each one of the pairs <span class="math">(\\beta_{k},\\gamma_{k})</span> is a root to the following polynomial on <span class="math">\\beta,\\gamma</span>:</p>

    <p class="text-gray-300"><span class="math">\\prod_{x\\in H,j\\in[\\mathsf{s}]}\\bar{f}_{j}(x,\\beta,\\gamma)-\\prod_{x\\in H,j\\in[\\mathsf{s}]}\\bar{g}_{j}(x,\\beta,\\gamma).</span> (31)</p>

    <p class="text-gray-300">It is a well known property of the Plonk permutation argument that if Eq. (31) is the zero polynomial, then the polynomials <span class="math">\\mathsf{a}_{1}(X),\\ldots,\\mathsf{a}_{r}(X)</span> are the result of interpolating a witness <span class="math">\\mathfrak{w}</span> that satisfies the copy constraints of Eq. (26) in <span class="math">\\mathfrak{i}</span>, namely <span class="math">\\mathfrak{w}_{i}=\\mathfrak{w}_{\\sigma(i)}</span> for all <span class="math">i\\in[\\mathsf{rn}]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that, from our assumptions, we deduced that <span class="math">P_{k}(\\tau_{1})</span> vanishes on <span class="math">H</span> for all <span class="math">k\\in[\\mathsf{t}]</span>. Hence <span class="math">\\mathfrak{w}</span> satisfies the constraints of Eq. (30). Notice that this implies <span class="math">\\pi=\\mathfrak{w}^{(\\mathsf{pi})}</span> since, as pointed out in Remark 7.4, we assume that public inputs are “enforced” by the circuit and copy constraints. Thus, either <span class="math">\\mathfrak{w}</span> does not satisfy the copy constraints of Eq. (26), i.e., <span class="math">\\mathfrak{w}_{i}\\neq\\mathfrak{w}_{\\sigma(i)}</span> for some <span class="math">i</span>, or <span class="math">(\\mathfrak{i},\\pi,\\mathfrak{w})\\in\\mathsf{R}_{\\mathsf{ROPlonky}}</span>. In the former case, the polynomial of Eq. (31) is a nonzero bivariate polynomial with each variable having degree at most <span class="math">r^{\\prime}\\mathsf{n}</span>. Hence, it has at most $r^{\\prime}\\mathsf{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> roots </span>(\\beta,\\gamma)<span class="math">. We conclude that, if </span>\\pi\\notin\\mathcal{L}_{\\mathsf{R}_{\\mathsf{ROPlonky}}_{i}}$ then Eq. (31) is a nonzero polynomial and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{1}(\\mathfrak{i})\\leq\\left(\\frac{r^{\\prime}\\mathsf{n}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[\\mathcal{E}]+(1-\\Pr[\\mathcal{E}])\\right)^{\\mathsf{t}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\Pr[\\mathcal{E}]</span> is the probability of event <span class="math">\\mathcal{E}</span> occurring. On the other hand, each <span class="math">\\bar{f}_{j}(x,\\beta,\\gamma)</span> and <span class="math">\\bar{g}_{j}(x,\\beta,\\gamma)</span> is the product of <span class="math">\\mathsf{u}</span> linear polynomials on the variables <span class="math">\\beta,\\gamma</span>. Such a linear polynomial has at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> roots, and so there are at most </span>2\\mathsf{nsu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> pairs </span>(\\beta,\\gamma)<span class="math"> that make event </span>\\mathcal{E}$ not hold. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\mathcal{E}]\\geq 1-\\frac{2\\mathsf{nsu}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{1}(\\mathbb{i})\\leq\\left(\\frac{\\mathrm{r}^{\\prime}\\mathrm{n}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{2\\mathrm{n}\\mathrm{s}\\mathrm{u}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathrm{t}}\\leq\\left(\\frac{3\\mathrm{n}(\\mathrm{r}^{\\prime}+\\mathrm{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathrm{t}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This completes our proof of the RBR soundness of <span class="math">\\mathsf{OPlonky}(0)</span>.</p>

    <p class="text-gray-300">We now prove that <span class="math">\\mathsf{OPlonky}(0)</span> has RBR knowledge with error <span class="math">\\varepsilon(\\mathbb{i})</span> (with the bounds stated in the lemma). We define <span class="math">\\varepsilon_{i}</span> exactly as before, using the doomed set <span class="math">\\mathcal{D}_{0}^{\\mathrm{s}}(\\mathbb{i})</span> as the <span class="math">0</span>-th set, instead of <span class="math">\\mathcal{D}_{0}^{\\mathrm{k}}(\\mathbb{i})</span>.</p>

    <p class="text-gray-300">From the arguments provided while estimating <span class="math">\\varepsilon_{1}(\\mathbb{x})</span> above, we deduce that if <span class="math">\\Pr_{c_{1}}[(\\mathbb{x},\\tau_{1})\\notin\\mathcal{D}_{1}^{\\mathrm{k}}(\\mathbb{i})]&gt;\\varepsilon(\\mathbb{i})\\geq\\varepsilon_{1}(\\mathbb{i})</span>, then <span class="math">\\mathbb{w}</span> must satisfy both the copy constraints of Eq. (26) and the constraints of Eq. (25). Hence an extractor that has access to <span class="math">\\llbracket\\mathsf{a}_{1}(X)\\rrbracket,\\dots,\\llbracket\\mathsf{a}_{r}(X)\\rrbracket</span> can recover a witness <span class="math">\\mathbb{w}</span> such that <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})\\in\\mathbf{R}_{\\mathbf{ROPlonky}}</span> (the witness is taken to be the vector formed by the evaluations of each <span class="math">\\mathsf{a}_{i}(X)</span> on all of <span class="math">H</span>).</p>

    <p class="text-gray-300">Now, for <span class="math">i=2,3</span> and any <span class="math">(\\mathbb{x},\\tau)\\in\\mathcal{D}_{i-1}^{\\mathrm{s}}(\\mathbb{i})</span>, notice that by definition it is never the case that</p>

    <p class="text-gray-300"><span class="math">\\max_{m_{i}}\\Pr_{c_{i}}[(\\mathbb{x},\\tau,m_{i},c_{i})\\notin\\mathcal{D}_{i}^{\\mathrm{k}}(\\mathbb{i})]&gt;\\varepsilon(\\mathbb{i})\\geq\\varepsilon_{i}(\\mathbb{i}).</span></p>

    <p class="text-gray-300">In the case when <span class="math">i=1</span>, if <span class="math">\\mathbb{i}\\notin\\mathcal{L}_{\\mathbf{R}_{\\mathbf{ROPlonky}},\\mathbb{i}}</span>, then also <span class="math">\\max_{m_{1}}\\Pr_{c_{1}}[(\\mathbb{x},m_{1},c_{1})\\notin\\mathcal{D}_{1}^{\\mathrm{k}}(\\mathbb{i})]&gt;\\varepsilon(\\mathbb{i})\\geq\\varepsilon_{1}(\\mathbb{i})</span>. This completes the proof of the lemma. ∎</p>

    <h6 id="sec-137" class="text-base font-medium mt-4">Theorem 4.10.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">D\\subseteq\\mathbb{F}^{*}</span> a smooth multiplicative subgroup of <span class="math">\\mathbb{F}</span> of order <span class="math">2^{n}</span>, and <span class="math">H</span> a subgroup of <span class="math">D</span> of order <span class="math">\\mathrm{n}</span>. Let <span class="math">m\\geq 3</span>, <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span> for some <span class="math">\\eta\\in(0,\\sqrt{\\rho}/2m)</span>, and let <span class="math">\\mathsf{Plonky2hlOP}</span> be the hIOP obtained from <span class="math">\\mathsf{OPlonky}(\\delta)</span> after compiling it with the Batched FRI protocol (see Definition 6.2). Then <span class="math">\\mathsf{Plonky2hlOP}</span> is RBR sound and has RBR knowledge. For each <span class="math">\\mathbb{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathrm{r},\\mathrm{r}^{\\prime},\\ell,\\mathrm{t})</span> and all <span class="math">q\\geq 1</span>, the error in both cases is given by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky}}(\\mathbb{i},q)=\\max\\left\\{\\left(\\frac{\\varepsilon_{i}(\\mathbb{i})}{2\\eta\\sqrt{\\rho}}\\right)_{i\\in[3]},\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}(\\mathbb{F},D,\\rho,\\delta,N,q)\\right\\},</span></p>

    <p class="text-gray-300">where <span class="math">N</span> is the total number of codewords that are batched together in the batched FRI protocol, <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}</span> is the RBR soundness error of <span class="math">\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{bFRI}}</span> (which equals its RBR knowledge error, see Theorem 5.11) and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{1}(\\mathbb{i}):=\\left(\\frac{3\\mathrm{n}(\\mathrm{r}^{\\prime}+\\mathrm{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathrm{t}},\\quad\\ \\varepsilon_{2}(\\mathbb{i}):=\\left(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+(\\mathsf{s}+2)\\mathsf{t}-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{\\mathrm{t}},\\quad\\ \\varepsilon_{3}(\\mathbb{i}):=\\max\\{\\deg(P_{j})_{j\\in\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}},\\mathsf{u}+1\\}\\frac{\\mathrm{n}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}\\setminus D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-138" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This is a direct consequence of combining Lemma 4.9 and Theorem 4.6. ∎</p>

    <p class="text-gray-300">In Appendix C we discuss an a natural variation of <span class="math">\\mathsf{OPlonky}</span> which is significantly less sound than the actual protocol.</p>

    <h4 id="sec-139" class="text-lg font-semibold mt-6">7.3.1 Turning <span class="math">\\mathsf{Plonky2hlOP}</span> into a SNARK</h4>

    <p class="text-gray-300">Next, we apply the BCS construction to <span class="math">\\mathsf{Plonky2hlOP}</span> and Theorem 3.15, proving that the final non-interactive succinct argument <span class="math">\\mathsf{Plonky2}</span> is an argument of knowledge.</p>

    <h6 id="sec-140" class="text-base font-medium mt-4">Corollary 7.6.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">H\\subseteq\\mathbb{F}^{<em>}</span> a smooth multiplicative subgroup of <span class="math">\\mathbb{F}</span> of order <span class="math">2^{n}</span>, let <span class="math">\\delta=1-\\sqrt{\\rho}-\\eta</span> for some <span class="math">\\eta&gt;0</span>. Let <span class="math">\\mathsf{Plonky2}</span> be the non-interactive succinct argument resulting of applying the BCS constriction on <span class="math">\\mathsf{Plonky2hlOP}</span>. Then for each <span class="math">\\mathbb{i}=(\\mathcal{P},\\mathcal{Q},H,\\sigma,\\mathsf{Pl},\\mathrm{r},\\mathrm{r}^{\\prime},\\ell,\\mathrm{t})</span>, random oracle query bound <span class="math">Q\\in\\mathbb{N}</span>, random oracle <span class="math">\\mathcal{H}\\colon\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\kappa}</span>, and all <span class="math">q\\geq 1</span>, <span class="math">\\mathsf{Plonky2}</span> has both adaptive soundness and adaptive knowledge soundness error</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathsf{fs}}^{\\mathsf{OPlonky}}(\\mathbb{i},Q,\\kappa,q)=Q\\cdot\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{OPlonky}}(\\mathbb{i},q)+\\frac{3(Q^{2}+1)}{2^{\\kappa}}.</span></p>

    <h6 id="sec-141" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows directly from apply Theorem 3.15 to Theorem 4.10. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">7.3.2 Redshift, TurboPlonk, and Plonk</p>

    <p class="text-gray-300">Next we briefly discuss how Plonk <em>[x10]</em>, TurboPlonk <em>[x11]</em>, Redshift <em>[x23]</em>, and Plonky2 <em>[x25]</em> are related to <span class="math">\\mathsf{OPlonky}(\\delta),\\mathsf{Plonky2hlOP}</span>, and how their relations compare to <span class="math">\\mathbf{R_{ROPlonky}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When it comes to the relations, to recover Plonk’s and Redshift’s relation, it suffices to specialize <span class="math">\\mathbf{R_{ROPlonky}}</span> so that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, </span>\\mathsf{r}=\\mathsf{r}^{\\prime}=3<span class="math">, </span>\\ell=5$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P_{1}=P_{1}(X_{1},X_{2},X_{3},Y_{1},Y_{2},Y_{3},Z_{1},\\ldots,Z_{5})=Z_{1}X_{1}+Z_{2}X_{2}+Z_{3}X_{3}+Z_{4}X_{1}X_{2}+Z_{5}.</span></p>

    <p class="text-gray-300">Additionally, TurboPlonk’s relation can be recovered by setting <span class="math">\\mathsf{r}=\\mathsf{r}^{\\prime}</span>. Finally, as mentioned earlier, Plonky2’s relation is essentially <span class="math">\\mathbf{R_{ROPlonky}}</span>. We note that as far as we are aware this is the first work formalizing it.</p>

    <p class="text-gray-300">Plonk can be seen as being built on top of a <span class="math">0</span>-correlated IOP. Such correlated IOP is a particular instance of our <span class="math">\\mathsf{OPlonky}(0)</span>. As before, it suffices to take <span class="math">\\mathsf{r}=\\mathsf{r}^{\\prime}=3</span> and <span class="math">\\mathsf{t}=1</span>, <span class="math">\\ell=5</span>. Note that Plonk is later is compiled into succinct argument using the KZG commitment scheme. Hence, at that point, Plonk departs from our scheme.</p>

    <p class="text-gray-300">While Redshift uses the same relation as Plonk and is very similar to our <span class="math">\\mathsf{OPlonky}(\\delta)</span> and <span class="math">\\mathsf{Plonky2hlOP}</span>, it does not technically fit our framework. This is mainly because Redshift does not use an oracle (or an IOP in the compiled version) for <span class="math">\\delta</span>-correlated agreement. Instead, it checks individually that certain maps are <span class="math">\\delta</span>-close to a Reed-Solomon code. Additionally, the shape of these maps is slightly different. In any case, Redshift could be fit in a framework similar to ours, but it is unclear how one could obtain security bounds similar to the ones our framework provides.</p>

    <p class="text-gray-300">Plonky2 is essentially a non-interactive succinct argument instantiation of <span class="math">\\mathsf{OPlonky}(\\delta)_{\\mathsf{compiled}}</span>. We note that Plonky2 performs some low level implementation choices that we do not consider in this work, for example the usage of Merkle caps instead of Merkle trees (in the BCS construction).</p>

    <p class="text-gray-300">Finally, it does not make sense to speak about a TurboPlonk as an IOP, as TurboPlonk is vaguely defined.</p>

    <h2 id="sec-142" class="text-2xl font-bold">8 Conclusions and Open Problems</h2>

    <p class="text-gray-300">In this work, we formalized the FS-security of FRI and Plonk-like protocols. Our results on Plonk-like protocols cover multiple variants, some of which are already in production. There are other protocols that are amenable to our general framework for correlated IOP’s, e.g., ethSTARK <em>[x30]</em> and RISC Zero <em>[x32]</em>. We leave as future work to perform a RBR soundness/knowledge and FS analysis of these.</p>

    <p class="text-gray-300">Our generalization <span class="math">\\mathsf{OPlonky}</span> of IOPs using Plonk-like arithmetization along with a protocol for low-degree testing (specifically, FRI) does not address KZG-based Plonk-like schemes. Compiling a <span class="math">0</span>-correlated IOP with RBR soundness and knowledge using other commitment schemes and the FS-security of such schemes remain open problems.</p>

    <h2 id="sec-143" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">Alexander R. Block was supported by DARPA under Contract No. HR00112020022 and No. HR00112020025. Albert Garreta was supported by the Ethereum Foundation’s grant FY23-0885. Jonathan Katz was supported by NSF award CNS-2154705 and by DARPA under Contract No. HR00112020025. Justin Thaler was supported by NSF CAREER award CCF-1845125 and DARPA under Contract No. HR00112020022. Pratyush Ranjan Tiwari was partly supported by NSF CNS-1814919 and a Security and Privacy research award from Google to Matthew Green. Michał Zając was supported by the Ethereum Foundation’s grant FY23-0885. The views, opinions, findings, conclusions and/or recommendations expressed in this material are those of the authors and should not be interpreted as reflecting the position or policy of DARPA or the United States Government, and no official endorsement should be inferred.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AABN02] Michel Abdalla, Jee Hea An, Mihir Bellare, and Chanathip Namprempre. From identification to signatures via the Fiat-Shamir transform: Minimizing assumptions for security and forward-security. In Lars R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 418–433. Springer, Heidelberg, April / May 2002. doi:10.1007/3-540-46035-7_28.</li>

      <li>[AFK22] Thomas Attema, Serge Fehr, and Michael Klooß. Fiat-shamir transformation of multi-round interactive proofs. In Eike Kiltz and Vinod Vaikuntanathan, editors, TCC 2022, Part I, volume 13747 of LNCS, pages 113–142. Springer, Heidelberg, November 2022. doi:10.1007/978-3-031-22318-1_5.</li>

      <li>[Bar01] Boaz Barak. How to go beyond the black-box simulation barrier. In 42nd FOCS, pages 106–115. IEEE Computer Society Press, October 2001. doi:10.1109/SFCS.2001.959885.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018. doi:10.1109/SP.2018.00020.</li>

      <li>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl, July 2018. doi:10.4230/LIPIcs.ICALP.2018.14.</li>

      <li>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046.</li>

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016. doi:10.1007/978-3-662-49896-5_12.</li>

      <li>[BCG15] Joseph Bonneau, Jeremy Clark, and Steven Goldfeder. On bitcoin as a public randomness source. IACR Cryptol. ePrint Arch., page 1015, 2015.</li>

      <li>[BCG^{+}18] Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune Jakobsen, and Mary Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In International Conference on the Theory and Application of Cryptology and Information Security, pages 595–626. Springer, 2018.</li>

      <li>[BCGT13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems: extended abstract. In Robert D. Kleinberg, editor, ITCS 2013, pages 401–414. ACM, January 2013. doi:10.1145/2422436.2422481.</li>

      <li>[BCI^{+}20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for reed-solomon codes. Cryptology ePrint Archive, Paper 2020/654, 2020. Full version of the same work published at FOCS 2020. DOI: https://doi.org/10.1109/FOCS46700.2020.00088. URL: https://eprint.iacr.org/2020/654.</li>

      <li>[BCR^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019. doi:10.1007/978-3-030-17653-2_4.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016. doi:10.1007/978-3-662-53644-5_2.</li>

    </ul>

    <p class="text-gray-300">[BDG^{+}13] Nir Bitansky, Dana Dachman-Soled, Sanjam Garg, Abhishek Jain, Yael Tauman Kalai, Adriana López-Alt, and Daniel Wichs. Why “Fiat-Shamir for proofs” lacks a proof. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 182–201. Springer, Heidelberg, March 2013. doi:10.1007/978-3-642-36594-2_11.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BEG^{+}94] Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. Checking the correctness of memories. Algorithmica, 12:225–244, 1994.</li>

      <li>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020. doi:10.1007/978-3-030-45721-1_24.</li>

      <li>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling outside the box improves soundness. In Thomas Vidick, editor, ITCS 2020, volume 151, pages 5:1–5:32. LIPIcs, January 2020. doi:10.4230/LIPIcs.ITCS.2020.5.</li>

      <li>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In Rocco A. Servedio, editor, 33rd Computational Complexity Conference, CCC 2018, June 22-24, 2018, San Diego, CA, USA, volume 102 of LIPIcs, pages 24:1–24:23. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2018. doi:10.4230/LIPIcs.CCC.2018.24.</li>

      <li>[BPW12] David Bernhard, Olivier Pereira, and Bogdan Warinschi. How not to prove yourself: Pitfalls of the Fiat-Shamir heuristic and applications to Helios. In Xiaoyun Wang and Kazue Sako, editors, ASIACRYPT 2012, volume 7658 of LNCS, pages 626–643. Springer, Heidelberg, December 2012. doi:10.1007/978-3-642-34961-4_38.</li>

      <li>[BTVW14] Andrew J. Blumberg, Justin Thaler, Victor Vu, and Michael Walfish. Verifiable computation using multiple provers. Cryptology ePrint Archive, Report 2014/846, 2014. https://eprint.iacr.org/2014/846.</li>

      <li>[CBBZ22] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with linear-time prover and high-degree custom gates. Cryptology ePrint Archive, Report 2022/1355, 2022. https://eprint.iacr.org/2022/1355.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 1082–1090. ACM Press, June 2019. doi:10.1145/3313276.3316380.</li>

      <li>[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D. Rothblum. Fiat-Shamir and correlation intractability from strong KDM-secure encryption. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 91–122. Springer, Heidelberg, April / May 2018. doi:10.1007/978-3-319-78381-9_4.</li>

      <li>[CDS94] Ronald Cramer, Ivan Damgård, and Berry Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In Yvo Desmedt, editor, CRYPTO’94, volume 839 of LNCS, pages 174–187. Springer, Heidelberg, August 1994. doi:10.1007/3-540-48658-5_19.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited. J. ACM, 51(4):557–594, 2004. doi:10.1145/1008731.1008734.</li>

      <li>[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. Succinct arguments in the quantum random oracle model. In Dennis Hofheinz and Alon Rosen, editors, TCC 2019, Part II, volume 11892 of LNCS, pages 1–29. Springer, Heidelberg, December 2019. doi:10.1007/978-3-030-36033-7_1.</li>

      <li>[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. Practical verified computation with streaming interactive proofs. In Shafi Goldwasser, editor, ITCS 2012, pages 90–112. ACM, January 2012. doi:10.1145/2090236.2090245.</li>

    </ul>

    <p class="text-gray-300">[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 769–793. Springer, Heidelberg, May 2020. doi:10.1007/978-3-030-45721-1_27.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DMWG23] Quang Dao, Jim Miller, Opal Wright, and Paul Grubbs. Weak fiat-shamir attacks on modern proof systems. Cryptology ePrint Archive, Paper 2023/691, 2023. https://eprint.iacr.org/2023/691. URL: https://eprint.iacr.org/2023/691.</li>

      <li>[Dus] Dusk Network. Plonkup. https://github.com/dusk-network/plonkup. Accessed May 24, 2023.</li>

      <li>[FS87] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987. doi:10.1007/3-540-47721-7_12.</li>

      <li>[GK03] Shafi Goldwasser and Yael Tauman Kalai. On the (in)security of the Fiat-Shamir paradigm. In 44th FOCS, pages 102–115. IEEE Computer Society Press, October 2003. doi:10.1109/SFCS.2003.1238185.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 113–122. ACM Press, May 2008. doi:10.1145/1374376.1374396.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186–208, 1989. doi:10.1137/0218012.</li>

      <li>[GT21] Ashrujit Ghoshal and Stefano Tessaro. Tight state-restoration soundness in the algebraic group model. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part III, volume 12827 of LNCS, pages 64–93, Virtual Event, August 2021. Springer, Heidelberg. doi:10.1007/978-3-030-84252-9_3.</li>

      <li>[GW] Ariel Gabizon and Zachary J. Williamson. The turbo-plonk program syntax for specifying snark programs. https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf. Accessed May 23, 2023.</li>

      <li>[GW20] Ariel Gabizon and Zachary J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Paper 2020/315, 2020. https://eprint.iacr.org/2020/315. URL: https://eprint.iacr.org/2020/315.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[Hab22] Ulrich Haböck. A summary on the FRI low degree test. Cryptology ePrint Archive, Report 2022/1216, 2022. https://eprint.iacr.org/2022/1216.</li>

      <li>[HL18] Justin Holmgren and Alex Lombardi. Cryptographic hashing from strong one-way functions (or: One-way product functions and their applications). In Mikkel Thorup, editor, 59th FOCS, pages 850–858. IEEE Computer Society Press, October 2018. doi:10.1109/FOCS.2018.00085.</li>

      <li>[HLR21] Justin Holmgren, Alex Lombardi, and Ron D. Rothblum. Fiat-Shamir via list-recoverable codes (or: parallel repetition of GMW is not zero-knowledge). In Samir Khuller and Virginia Vassilevska Williams, editors, 53rd ACM STOC, pages 750–760. ACM Press, June 2021. doi:10.1145/3406325.3451116.</li>

      <li>[Hol19] Justin Holmgren. On round-by-round soundness and state restoration attacks. Cryptology ePrint Archive, Report 2019/1261, 2019. https://eprint.iacr.org/2019/1261.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992. doi:10.1145/129712.129782.</li>

    </ul>

    <p class="text-gray-300">[KPV22] Assimakis A. Kattis, Konstantin Panarin, and Alexander Vlasov. RedShift: Transparent SNARKs from list polynomial commitments. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 1725–1737. ACM Press, November 2022. doi:10.1145/3548606.3560657.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum. From obfuscation to the security of Fiat-Shamir for proofs. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 224–251. Springer, Heidelberg, August 2017. doi:10.1007/978-3-319-63715-0_8.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010. doi:10.1007/978-3-642-17373-8_11.</li>

      <li>[L2B] L2BEAT. L2beat total value locked. https://l2beat.com/scaling/tvl. Accessed May 22, 2023.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859–868, 1992. doi:10.1145/146585.146605.</li>

      <li>[Lip89] Richard J Lipton. Fingerprinting sets. Princeton University, Department of Computer Science, 1989.</li>

      <li>[Lip90] Richard J Lipton. Efficient checking of computations. In Annual Symposium on Theoretical Aspects of Computer Science, pages 207–215. Springer, 1990.</li>

      <li>[Mat] Matter Labs. zksync 2.0: Hello ethereum! https://blog.matter-labs.io/zksync-2-0-hello-ethereum-ca48588de179. Accessed May 24, 2023.</li>

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 2019. doi:10.1145/3319535.3339817.</li>

      <li>[Mer] Ralph Merkle. Secrecy, authentication, and public key systems.</li>

      <li>[Mic94] Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994. doi:10.1109/SFCS.1994.365746.</li>

      <li>[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253–1298, 2000. doi:10.1137/S0097539795284959.</li>

      <li>[Min] Mina. Mina book: Background on plonk. https://o1-labs.github.io/proof-systems/plonk/overview.html. Accessed May 24, 2023.</li>

      <li>[=ni] =nil; Foundation. Circuit definition library for =nil; foundation’s cryptography suite. https://github.com/NilFoundation/zkllvm-blueprint. Accessed May 24, 2023.</li>

      <li>[Pola] Polygon Labs. Fri verification procedures. https://wiki.polygon.technology/docs/miden/user_docs/stdlib/crypto/fri/. Accessed May 23, 2023.</li>

      <li>[Polb] Polygon Zero Team. Plonky2: Fast recursive arguments with plonk and fri. https://github.com/mir-protocol/plonky2/tree/main/plonky2. URL: https://github.com/mir-protocol/plonky2/tree/main/plonky2.</li>

      <li>[PS96] David Pointcheval and Jacques Stern. Security proofs for signature schemes. In Ueli M. Maurer, editor, EUROCRYPT’96, volume 1070 of LNCS, pages 387–398. Springer, Heidelberg, May 1996. doi:10.1007/3-540-68339-9_33.</li>

      <li>[PW18] Cécile Pierrot and Benjamin Wesolowski. Malleability of the blockchain’s entropy. Cryptography and Communications, 10(1):211–233, 2018.</li>

    </ul>

    <p class="text-gray-300">[Rab83] Michael O. Rabin. Transaction protection by beacons. J. Comput. Syst. Sci., 27(2):256–267, 1983. doi:10.1016/0022-0000(83)90042-9.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[RR20] Noga Ron-Zewi and Ron D. Rothblum. Local proofs approaching the witness length [extended abstract]. In 61st FOCS, pages 846–857. IEEE Computer Society Press, November 2020. doi:10.1109/FOCS46700.2020.00083.</li>

      <li>[RS60] I. S. Reed and G. Solomon. Polynomial codes over certain finite fields. Journal of the Society for Industrial and Applied Mathematics, 8(2):300–304, 1960. arXiv:https://doi.org/10.1137/0108018, doi:10.1137/0108018.</li>

      <li>[Set20] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Heidelberg, August 2020. doi:10.1007/978-3-030-56877-1_25.</li>

      <li>[Sta] StarkWare Industries. Starkex documentation: Customers and their deployment contract addresses. https://docs.starkware.co/starkex/deployments-addresses.html. Accessed May 22, 2023.</li>

      <li>[Sta23] StarkWare. ethstark documentation v1.2. Cryptology ePrint Archive, Paper 2021/582, 2023. https://eprint.iacr.org/2021/582. URL: https://eprint.iacr.org/2021/582.</li>

      <li>[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive, Paper 2023/552, 2023. https://eprint.iacr.org/2023/552. URL: https://eprint.iacr.org/2023/552.</li>

      <li>[Suc] Succinct Labs. gnark-plonky2-verifier. https://github.com/succinctlabs/gnark-plonky2-verifier. Accessed May 24, 2023.</li>

      <li>[Tea23] RISC Zero Team. Risc zero’s proof system for a zkvm, 2023. Github repository. URL: https://github.com/risc0/risc0.</li>

      <li>[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 71–89. Springer, Heidelberg, August 2013. doi:10.1007/978-3-642-40084-1_5.</li>

      <li>[Tha22] Justin Thaler. Proofs, arguments, and zero-knowledge. https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.html, 2022. Manuscript draft.</li>

      <li>[Wik21] Douglas Wikström. Special soundness in the random oracle model. Cryptology ePrint Archive, Report 2021/1265, 2021. https://eprint.iacr.org/2021/1265.</li>

      <li>[WTs^{+}18] Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926–943. IEEE Computer Society Press, May 2018. doi:10.1109/SP.2018.00060.</li>

      <li>[ZGK^{+}18] Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. vram: Faster verifiable ram with program-independent preprocessing. In 2018 IEEE Symposium on Security and Privacy (SP), pages 908–925. IEEE, 2018.</li>

    </ul>

    <p class="text-gray-300">A Concrete Security Analysis of Non-interactive FRI</p>

    <p class="text-gray-300">In this section, we focus on the concrete security achieved by compiling the FRI IOPP with the BCS transformation in the random oracle model; for ease of presentation, we readily refer to this protocol as FS-FRI in this section. We do this by analyzing the tradeoffs between round-by-round soundness of FRI under provable and conjectured security, the number of random oracle queries <span class="math">Q</span>, and the non-interactive soundness error <span class="math">\\varepsilon_{\\mathrm{fs-q}}^{\\mathrm{FRI}}</span>. The goal of this analysis is to provide a methodology for analyzing the above tradeoffs when using FS-FRI in practice; for example, how does one set the parameters of FRI (i.e., field size, message length, code rate, etc.) to achieve soundness error <span class="math">\\varepsilon_{\\mathrm{fs-q}}^{\\mathrm{FRI}}=2^{-\\nu}</span> when an attacker can make <span class="math">Q</span> queries to the random oracle (i.e., roughly the number of hashes an attacker can perform)? We hope this methodology is useful for those looking to use FRI in practice by being able to set targets for <span class="math">Q</span> and <span class="math">\\nu</span> then test out what FRI parameters are secure, or vice versa (setting FRI parameters and target <span class="math">Q</span> and seeing what <span class="math">\\nu</span> is achievable).</p>

    <p class="text-gray-300">To begin, recall that from 3.15 and 4.1, the soundness error of FS-FRI is given by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon_{\\mathrm{fs-q}}^{\\mathrm{FRI}}=Q\\cdot\\varepsilon_{\\mathrm{rbr}}^{\\mathrm{FRI}}+\\frac{3(Q^{2}+1)}{2^{\\kappa}},</span></p>

    <p class="text-gray-300">where <span class="math">\\kappa</span> is the output length of the random oracle (in bits) and <span class="math">\\varepsilon_{\\mathrm{rbr}}^{\\mathrm{FRI}}</span> is the round-by-round soundness error of the FRI IOPP. Given the above equation, we analyze the tradeoffs between <span class="math">\\varepsilon_{\\mathrm{rbr}}^{\\mathrm{FRI}}</span>, <span class="math">Q</span>, and a target <span class="math">\\nu</span> by analyzing the following constraints:</p>

    <p class="text-gray-300"><span class="math">Q\\cdot\\varepsilon_{\\mathrm{rbr}}^{\\mathrm{FRI}}</span> <span class="math">\\leq\\frac{2^{-\\nu}}{2}</span> (32) <span class="math">\\frac{3(Q^{2}+1)}{2^{\\kappa}}</span> <span class="math">\\leq\\frac{2^{-\\nu}}{2}.</span> (33)</p>

    <p class="text-gray-300">So long as the above constraints are satisfied, then we have <span class="math">\\varepsilon_{\\mathrm{fs-q}}^{\\mathrm{FRI}}\\leq 2^{-\\nu}</span> for a <span class="math">Q</span>-query adversary.</p>

    <p class="text-gray-300">We break down our analysis into two parts. In the first part (A.2), we set targets for the soundness error <span class="math">\\nu</span> and the FRI parameters <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, and <span class="math">\\rho</span> and analyze: (1) the upper bound on the number of RO queries <span class="math">Q</span> given by 33; and (2) for various settings of <span class="math">Q</span> less than or equal to the the computed upper bound, whether or not the constraint in 32 is satisfiable or not. The satisfiability of 32 for fixed values of <span class="math">\\nu</span>, <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, <span class="math">\\rho</span>, and <span class="math">Q</span> depends on how <span class="math">\\varepsilon_{\\mathrm{rbr}}^{\\mathrm{FRI}}</span> is computed (i.e., either via provable security or conjectured security). In the second part (A.3), we examine FRI parameters <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, <span class="math">\\rho</span>, and <span class="math">\\delta</span> used today in several projects and analyze what values of <span class="math">\\nu</span> are achievable under certain fixed values of <span class="math">Q</span>.</p>

    <p class="text-gray-300">For both parts of our analysis, we also obtain bounds on the number of verifier queries <span class="math">\\ell</span> (whenever possible) and analyze the size of the non-interactive proofs produced under these parameters, given in kilobytes or megabytes. Additionally, we focus on non-batched FRI. This is done for simplicity since:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is variation as to the number of polynomials that different projects choose to batch together;</li>

      <li>for both variants of Batched FRI, batching increases the proof sizes by only (roughly) an additive factor proportional to the number of batched polynomials (i.e., Batched FRI amortizes well); and</li>

      <li>communication-saving Batched FRI has round-by-round soundness error roughly <span class="math">t</span> times larger than non-Batched FRI or non-communication saving Batched FRI (i.e., it has worse RBR soundness error).</li>

    </ul>

    <h3 id="sec-144" class="text-xl font-semibold mt-8">A.1 Proof Sizes of FS-FRI</h3>

    <p class="text-gray-300">We first begin by giving an analysis of the proof sizes of FS-FRI. As a reminder, FS-FRI is the non-interactive protocol obtained by compiling the FRI IOPP with the BCS transformation (3.15). We remark that this version of FS-FRI may or may not be the non-interactive version of FRI used in practice, as there are many optimizations that can be made to reduce concrete proof sizes. We do not take into consideration any of these optimizations; for example, Merkle capping, which shortens the length of Merkle authentication paths at the cost of increasing commitment size.</p>

    <p class="text-gray-300">Thus our proof size analyses are overestimates; we believe that the proof sizes here can be reduced by roughly 33% via optimizations used in practice.</p>

    <p class="text-gray-300">Examining Algorithm 1 after compiling it with BCS via Merkle hashing, we can clearly determine the proof sizes for FS-FRI. Let <span class="math">\\kappa</span> be the output length of the random oracle <span class="math">\\mathcal{H}</span>, let <span class="math">\\mathbb{F}</span> be a finite field, let <span class="math">L_{0}</span> be the evaluation domain of size <span class="math">2^{n}</span>, let <span class="math">d_{0}=2^{k}</span> be the degree bound, and let <span class="math">\\ell</span> be the number of times the verifier repeats the Query Phase of FRI. Now first consider an intermediate version of FS-FRI, where instead of using the random oracle to compute verifier challenges and queries, there is still interaction with the verifier for its challenges. In particular, the prover sends Merkle roots of its various oracles to the verifier and responds to verifier queries to these oracles with Merkle authentication paths. We refer to this protocol as FRI-ARG. In this case, the transcript of the interaction consists of the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>During the Folding Phase:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Merkle roots <span class="math">M_{0},M_{1},\\ldots,M_{k-1}</span> and field element <span class="math">G_{k}</span> sent by the prover; and</li>

      <li>Field elements <span class="math">x_{0},x_{1},\\ldots,x_{k-1}</span> sent by the verifier.</li>

      <li>During the Query Phase:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Field elements <span class="math">s_{0,1},\\ldots,s_{0,\\ell}</span> sent by the verifier; and</li>

      <li>Field elements <span class="math">q_{i,j},q_{i,j}^{\\prime}</span> and Merkle authentication paths <span class="math">\\pi_{i,j},\\pi_{i,j}^{\\prime}</span> sent by the prover for <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span> and <span class="math">j\\in[\\ell]</span>.</li>

    </ul>

    <p class="text-gray-300">The size of this transcript is the proof size. From the above derivation, we have a transcript that consists of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k+\\ell+2k\\ell+1</span> field elements;</li>

      <li><span class="math">k</span> hashes of size <span class="math">\\kappa</span>; and</li>

      <li><span class="math">2k\\ell</span> Merkle authentication paths.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The size of the Merkle authentication paths differs for each <span class="math">i\\in\\{0,1,\\ldots,k-1\\}</span>. In particular, Merkle root <span class="math">M_{i}</span> is constructed with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{n-i}<span class="math"> many leaves, and thus the Merkle authentication paths </span>\\pi_{i,j}<span class="math"> and </span>\\pi_{i,j}^{\\prime}<span class="math"> consist of </span>n-i+1<span class="math"> hashes of size </span>\\kappa<span class="math"> for all </span>i\\in\\{0,1,\\ldots,k-1\\}<span class="math"> and </span>j\\in[\\ell]$. Thus the total number of hashes given by all the Merkle authentication paths is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">2\\ell\\sum_{i=0}^{k-1}n-i+1</span> <span class="math">=2\\ell\\sum_{i=n-k+2}^{n+1}i=2\\ell\\left(\\sum_{i=1}^{n+1}i-\\sum_{i=1}^{n-k+1}i\\right)=2\\ell\\left(\\frac{(n+1)(n+2)}{2}-\\frac{(n-k+1)(n-k+2)}{2}\\right)</span> <span class="math">=\\ell\\big{(}(n+1)(n+2)-(n-k+1)(n-k+2)\\big{)}.</span></p>

    <p class="text-gray-300">Thus our total proof size for FRI-ARG is</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k+\\ell+2k\\ell+1</span> field elements; and</li>

      <li><span class="math">k+\\ell\\cdot\\big{(}(n+1)(n+2)-(n-k+1)(n-k+2)\\big{)}</span> hashes of size <span class="math">\\kappa</span>.</li>

    </ul>

    <p class="text-gray-300">Now when we compile FRI-ARG into a non-interactive argument via Fiat-Shamir, the proof only consists of messages sent by the prover, and the verifier messages are obtained via the random oracle. This means that the <span class="math">k+\\ell</span> verifier messages in <span class="math">\\mathbb{F}</span> are not included in the non-interactive proof. Again assuming a random oracle <span class="math">\\mathcal{H}</span> with <span class="math">\\kappa</span> bits of output, the non-interactive proof consists of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">2k\\ell+1</span> field elements (i.e., the prover’s responses to the verifier queries and <span class="math">G_{k}</span>); and</li>

      <li><span class="math">k+\\ell\\cdot\\big{(}(n+1)(n+2)-(n-k+1)(n-k+2)\\big{)}</span> hashes of size <span class="math">\\kappa</span>.</li>

    </ul>

    <p class="text-gray-300">A.1.1 Batched FRI Proof Sizes</p>

    <p class="text-gray-300">While we do not consider Batched FRI in our security analyses, we provide an analysis of the Batched FRI proof sizes for completeness. For Batched FRI with <span class="math">t</span> polynomials batched together, the above proof now includes <span class="math">t</span> additional Merkle roots of length <span class="math">\\kappa</span> for each of these polynomials, <span class="math">t</span> additional field elements obtained from the verifier for batching these polynomials, and <span class="math">2\\ell t</span> additional field elements and Merkle authentication paths for each of these polynomials during the query phase. Each of these Merkle authentication paths consist of <span class="math">n+1</span> hashes of size <span class="math">\\kappa</span>. Thus for FS-Batched-FRI, our total proof size is</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k+\\ell+2\\ell k+2\\ell t+t+1</span> field elements; and</li>

      <li><span class="math">k+\\ell\\cdot\\big{(}(n+1)(n+2)-(n-k+1)(n-k+2)\\big{)}+t\\big{(}1+2\\ell(n+1)\\big{)}</span> hashes of size <span class="math">\\kappa</span>.</li>

    </ul>

    <p class="text-gray-300">Again compiling Batched FRI into a non-interactive argument, the proof only consists of prover messages and all verifier messages are derived via the random oracle and the prover messages. This gives us a total proof size of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">2\\ell(k+t)+1</span> field elements; and</li>

      <li><span class="math">k+\\ell\\cdot\\big{(}(n+1)(n+2)-(n-k+1)(n-k+2)\\big{)}+t\\big{(}1+2\\ell(n+1)\\big{)}</span> hashes of size <span class="math">\\kappa</span>.</li>

    </ul>

    <h3 id="sec-145" class="text-xl font-semibold mt-8">A.2 Part 1: Targeting Various Soundness Errors for FS-FRI</h3>

    <p class="text-gray-300">We turn to the first part of our analysis. That is, we set various targets for <span class="math">\\nu</span>, fix the parameters <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, and <span class="math">\\rho</span> of FRI, and analyze both the upper bound on <span class="math">Q</span> given by Eq. 33 and whether or not Eq. 32 is satisfiable for certain fixing of <span class="math">Q</span> within the upper bound. We perform this analysis with respect to provable security (Corollary 4.3) and conjectured security (Conjectures 5.12 and 5.14).</p>

    <p class="text-gray-300">Now notice that the constraint given by Eq. 33 is independent of the round-by-round soundness. Thus under this constraint, we can upper bound the number of queries <span class="math">Q</span> as</p>

    <p class="text-gray-300"><span class="math">\\frac{3(Q^{2}+1)}{2^{\\kappa}}\\leq\\frac{1}{2^{\\nu+1}}</span> <span class="math">Q^{2}\\leq\\frac{2^{\\kappa-\\nu-1}}{3}-1</span> <span class="math">Q\\leq\\left\\lfloor\\left(\\frac{2^{\\kappa-\\nu-1}}{3}-1\\right)^{1/2}\\right\\rfloor.</span> (34)</p>

    <p class="text-gray-300">Thus Eq. 34 is an upper bound on the number of RO queries any adversary is allowed to make when attacking the non-interactive proof system. Note we take the floor as the upper bound since the number of queries is an integer. Given this upper bound on <span class="math">Q</span>, we can turn to analyzing the other constraint given by Eq. 32:</p>

    <p class="text-gray-300"><span class="math">Q\\cdot\\varepsilon_{\\text{rbr}}^{\\text{FRI}}\\leq\\frac{1}{2^{\\nu+1}}</span> <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{FRI}}\\leq\\frac{1}{Q\\cdot 2^{\\nu+1}}.</span> (35)</p>

    <p class="text-gray-300">Now Eq. 35 give us an upper bound for <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{FRI}}</span>.</p>

    <p class="text-gray-300">Given these constraints, we can now turn to our main goal of setting various values of <span class="math">\\nu</span>, <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, and <span class="math">\\rho</span>, and analyzing <span class="math">Q</span> and <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{FRI}}</span>. For the remainder of this section, we consider the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hashes of length <span class="math">\\kappa=256</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Finite fields <span class="math">\\mathbb{F}</span> of bit length $\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\in\\{128,192,256\\}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Message lengths <span class="math">d_{0}=2^{k}</span> such that <span class="math">k\\in\\{10,15,20,25\\}</span>;</li>

      <li>Rates <span class="math">\\rho\\in\\{1/2,1/4,1/8,1/16\\}</span>; and</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\nu\\in\\{20,40,60,80\\}</span> (i.e., soundness error at most <span class="math">2^{-\\nu}</span> versus a <span class="math">Q</span>-query adversary).</li>

    </ul>

    <p class="text-gray-300">In the subsequent sections, all computations were performed in Sagemath version 9.5 using 1000 bits of precision, running on Ubuntu 22.04.2 LTS on Windows 10 x86_64 on an AMD Ryzen 7 3700X with 16GB of memory. See Appendix A.5 for the annotated Sagemath code.</p>

    <h4 id="sec-146" class="text-lg font-semibold mt-6">A.2.1 Provable Security</h4>

    <p class="text-gray-300">We first analyze the above parameters in the context of the provable RBR soundness of FRI given by Theorem 4.1. Before we begin, we first obtain constraints on <span class="math">\\varepsilon_{\\text{rbr}}^{\\text{FRI}}</span> under provable security guarantees. Towards this, recall that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\text{rbr}}^{\\text{FRI}}=\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining this expression with Eq. (35), we have the constraint</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}\\leq\\frac{1}{Q\\cdot 2^{\\nu+1}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This yields the additional constraints</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq\\frac{1}{Q\\cdot 2^{\\nu+1}}$ (36)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(1-\\delta)^{\\ell}\\leq\\frac{1}{Q\\cdot 2^{\\nu+1}}.</span> (37)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that in FRI, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{k}/\\rho<span class="math">, so under our fixing of </span>k<span class="math"> and </span>\\rho<span class="math">, the parameter </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is fixed as well. For provable security, we always consider maximal </span>\\delta<span class="math">, i.e., we set </span>\\delta=1-\\sqrt{\\rho}(1+1/(2m))<span class="math">. Moreover, </span>m<span class="math"> is the Johnson proximity parameter and must satisfy </span>m\\geq 3$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Notice that for any fixed values of <span class="math">Q</span> and <span class="math">\\nu</span>, the constraint of Eq. (37) is always satisfiable by taking <span class="math">\\ell=\\left\\lceil\\log(1/(Q\\cdot 2^{\\nu+1}))/\\log(1-\\delta)\\right\\rceil</span>. Notice also that for fixed values of <span class="math">Q</span> and <span class="math">\\nu</span>, the constraint of Eq. (36) gives an upper bound on the Johnson proximity parameter <span class="math">m</span>. Given that <span class="math">m\\geq 3</span> is required and Eq. (36) gives an upper bound on <span class="math">m</span>, it is possible that under certain parameters <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, <span class="math">\\rho</span>, <span class="math">Q</span>, and <span class="math">\\nu</span> we have <span class="math">m&lt;3</span>. In this case, we conclude that these parameters are <em>infeasible</em>.</p>

    <p class="text-gray-300">Given the above constraints, we can now turn to analyzing what provable security guarantees are achievable under the setting of parameters we are considering (i.e., the parameters given at the end of Appendix A.2). In what follows, we fix particular values of <span class="math">\\nu\\in\\{40,60,80,100\\}</span>, analyze the query upper bound via Eq. (34), then analyze whether or not Eq. (36) is satisfiable under certain fixings of <span class="math">Q</span>.</p>

    <h6 id="sec-147" class="text-base font-medium mt-4">Remark A.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In what follows, we are only discussing feasibility of parameters with respect to the parameters outlined at the end of Appendix A.2. It is entirely possible to find other feasible parameters for different settings of <span class="math">k</span>, $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\rho$. We do not exhaustively consider all such feasible parameters and only consider our setting of parameters as a guide to get a quick grasp on how certain settings of parameters behave.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To begin, for <span class="math">\\nu\\in\\{40,60,80,100\\}</span>, the constraint of Eq. (34) along with <span class="math">\\kappa=256</span> gives us the following ranges for <span class="math">Q</span>, which we present as powers of two for ease of presentation:</p>

    <p class="text-gray-300"><span class="math">2^{116}</span> <span class="math">\\leq Q&lt;2^{117}</span> <span class="math">\\nu=20</span> <span class="math">2^{106}</span> <span class="math">\\leq Q&lt;2^{107}</span> <span class="math">\\nu=40</span> <span class="math">2^{96}</span> <span class="math">\\leq Q&lt;2^{97}</span> <span class="math">\\nu=60</span> <span class="math">2^{86}</span> <span class="math">\\leq Q&lt;2^{87}</span> <span class="math">\\nu=80</span></p>

    <p class="text-gray-300">Thus, in our parameter analysis below, we consider two cases: <span class="math">Q=2^{60}</span> and <span class="math">Q=2^{80}</span>. We choose <span class="math">2^{80}</span> as our largest query bound since it is smaller than all of the bounds above, and thus can be used to compare parameters across different settings of <span class="math">\\nu</span>. The bound <span class="math">Q=2^{60}</span> is chosen simply as another point of comparison for when the hashing power of an adversary is lower.</p>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 20</span> . In Figure 3, we present our parameter analysis for target soundness error  <span class="math">\\nu = 20</span> . Examining the given table, we can conclude that for target soundness error  <span class="math">\\nu = 20</span>  and query range  <span class="math">Q \\in \\{2^{60}, 2^{80}\\}</span> , all the parameters we consider are feasible for both 192-bit and 256-bit finite fields, whereas none of the parameters we consider were feasible in the case of 128-bit finite fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 20 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 4.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 840 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 474 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 352 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 288 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 1.60 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 903 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 657 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 529 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 2.64 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 1.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 833 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.292, 163, 3.92 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 82, 2.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.645, 55, 1.49 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.749, 41, 1.17 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 866 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 487 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 361 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 295 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 1.64 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 923 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 670 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 538 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 2.69 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.45 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 1.04 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 846 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 163, 3.98 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 2.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 55, 1.51 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.19 MiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 20 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.292, 203, 2.00 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 102, 1.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.645, 68, 813 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.749, 51, 657 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.290, 205, 3.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.497, 102, 1.77 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.644, 68, 1.27 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.747, 51, 1.01 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.285, 209, 5.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.492, 104, 2.66 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.639, 69, 1.87 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.742, 52, 1.49 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 1.05 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 605 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 446 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 366 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 2.04 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.12 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 829 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 669 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 3.35 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.81 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 1.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.03 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 4.96 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 2.65 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 1.87 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.48 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 3: Numerical calculations for soundness error  <span class="math">\\nu = 20</span>  via Corollary 4.3, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>m \\geq 3<span class="math">  is violated for Johnson proximity parameter  </span>m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 40</span> . In Figure 4, we present our parameter analysis for target soundness error  <span class="math">\\nu = 40</span> . Examining the given table, we can conclude that for target soundness error  <span class="math">\\nu = 40</span>  and query upper bound  <span class="math">Q = 2^{60}</span> , all the parameters we consider are feasible for both 192-bit and 256-bit finite fields. For  <span class="math">Q = 2^{80}</span>  queries, all parameters we consider are feasible for 256-bit finite fields, and only 2 of 16 parameter settings are infeasible for 192-bit finite fields. Note that none of the parameters we consider were feasible for 128-bit finite fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 40 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 4.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 1.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 590 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 435 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 358 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.292, 203, 2.00 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 102, 1.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.645, 68, 813 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.749, 51, 657 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.290, 205, 3.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.497, 102, 1.77 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.644, 68, 1.27 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.747, 51, 1.01 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.285, 209, 5.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.492, 104, 2.66 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.639, 69, 1.87 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.742, 52, 1.49 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 1.05 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 605 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 446 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 366 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 2.04 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.12 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 829 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 669 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 3.35 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.81 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 1.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.03 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 203, 4.96 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 2.65 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 68, 1.87 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.48 MiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 40 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.285, 250, 2.46 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.492, 124, 1.33 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.639, 83, 992 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.742, 62, 799 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.272, 265, 4.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.479, 129, 2.24 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.624, 86, 1.60 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.725, 65, 1.29 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.234, 315, 7.57 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.438, 146, 3.73 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 1.26 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 724 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 531 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 438 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 2.45 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.34 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 987 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 801 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 4.01 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.16 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 1.53 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.23 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 5.93 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 3.17 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 2.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.77 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 4: Numerical calculations for soundness error  <span class="math">\\nu = 40</span>  via Corollary 4.3, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>m \\geq 3<span class="math">  is violated for Johnson proximity parameter  </span>m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 60</span> . In Figure 5, we present our parameter analysis for target soundness error  <span class="math">\\nu = 60</span> . Examining the given table, we can conclude that for target soundness error  <span class="math">\\nu = 60</span>  and query bound  <span class="math">Q = 2^{60}</span> , nearly all parameters are feasible for 192-bit and 256-bit finite fields, save for  <span class="math">k = 25</span>  with rates  <span class="math">\\rho = 1/8</span> , 1/16 when the field is 192-bits. For  <span class="math">Q = 2^{80}</span> , all parameters are feasible for 256-bit finite fields, and most parameters are infeasible for 192-bit finite fields, including all parameter settings for  <span class="math">k = 20</span>  and  <span class="math">k = 25</span> , and two parameter settings for  <span class="math">k = 15</span> . Note again that none of the parameters we consider were feasible for 128-bit finite fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 60 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 4.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.290, 245, 1.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.497, 122, 705 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.644, 82, 525 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.747, 61, 429 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.285, 250, 2.46 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.492, 124, 1.33 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.639, 83, 992 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.742, 62, 799 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.272, 265, 4.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.479, 129, 2.24 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.624, 86, 1.60 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.725, 65, 1.29 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.234, 315, 7.57 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.438, 146, 3.73 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 1.26 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 724 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 531 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 438 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 2.45 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.34 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 987 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 801 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 4.01 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.16 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 1.53 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.23 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 243, 5.93 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 3.17 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 81, 2.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.77 MiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 60 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.234, 367, 3.61 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.438, 170, 1.83 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 283, 1.47 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 843 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 623 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 510 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 283, 2.85 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 1.56 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 1.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 932 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 283, 4.66 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 2.51 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 1.80 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.43 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.292, 283, 6.91 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 142, 3.68 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 2.61 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.749, 71, 2.06 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 5: Numerical calculations for soundness error  <span class="math">\\nu = 60</span>  via Corollary 4.3, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>m \\geq 3<span class="math">  is violated for Johnson proximity parameter  </span>m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 80</span> . In Figure 6, we present our parameter analysis for target soundness error  <span class="math">\\nu = 112</span> . Examining the given table, again all parameters remain feasible for 256-bit finite fields. However, the feasible parameters for 192-bit finite fields continue to shrink. For  <span class="math">Q = 2^{60}</span> , 10 out of 16 parameter settings are infeasible, and for  <span class="math">Q = 2^{80}</span> , none of the parameter settings are feasible. This matches the trend with the prior tables that increasing  <span class="math">\\nu</span>  decreases the number of feasible parameters. As with the previous values of  <span class="math">\\nu</span> , none of the parameters we consider were feasible for 128-bit finite fields in this case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 80 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 4.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.272, 308, 1.55 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.479, 150, 867 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.624, 100, 640 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.725, 76, 534 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.234, 367, 3.61 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.438, 170, 1.83 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 283, 1.47 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 843 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 623 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 510 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 283, 2.85 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 1.56 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 1.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 932 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.293, 283, 4.66 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 2.51 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 1.80 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.43 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.292, 283, 6.91 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 142, 3.68 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 95, 2.61 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.749, 71, 2.06 MiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 80 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.292, 323, 3.25 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 162, 1.78 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.646, 108, 1.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.749, 81, 1.04 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.291, 325, 5.36 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.498, 162, 2.87 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.645, 108, 2.04 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.748, 81, 1.63 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.288, 329, 8.03 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.495, 164, 4.25 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.641, 109, 2.99 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.745, 82, 2.38 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 6: Numerical calculations for soundness error  <span class="math">\\nu = 80</span>  via Corollary 4.3, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>m \\geq 3<span class="math">  is violated for Johnson proximity parameter  </span>m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conclusions. Under provable security, the above tables highlight that larger fields, smaller messages, and larger rates (i.e.,  <span class="math">\\rho</span>  is larger) are necessary for feasibility of parameters under various settings of  <span class="math">\\nu</span> . None of the parameters we considered were feasible for 128-bit finite fields, though there may be finite fields between 128 and 192-bits in size where parameters are feasible (similarly for between 192 and 256-bit finite fields). As a reminder, a setting of parameters  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, k, \\rho, Q, \\nu)<span class="math">  was infeasible if Eq. (36) implied  </span>m &lt; 3<span class="math">  for  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^k / \\rho<span class="math"> , violating the constraint that  </span>m \\geq 3$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We next analyze the parameters we consider in the context of the conjectured RBR soundness given by Conjecture 5.12. To begin, under this conjecture, the RBR soundness error of FRI is given by</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon_ {\\mathrm {r b r}} ^ {\\mathrm {F R I}} = \\max  \\left\\{\\frac {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L _ {0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {c _ {2}}}{(\\rho \\eta) ^ {c _ {1}} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, (1 - \\delta) ^ {\\ell} \\right\\},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">c_{1}, c_{2} \\geq 1</span>  are constants and  <span class="math">\\eta &amp;gt; 0</span>  such that  <span class="math">\\delta \\leq 1 - \\rho - \\eta</span> . In our analysis, we assume our finite fields are of prime order, i.e., they are specified by a  <span class="math">\\{128, 192, 256\\}</span> -bit prime, respectively. This allows us to consider the best possible setting of  <span class="math">c_{1} = c_{2} = 1</span>  under this conjecture. Combining this setting with the above equation and with Eq. (33), we obtain the constraints</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L _ {0} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\rho \\eta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac {1}{Q \\cdot 2 ^ {\\nu + 1}} \\tag {38}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">(1 - \\delta) ^ {\\ell} \\leq \\frac {1}{Q \\cdot 2 ^ {\\nu + 1}}. \\tag {39}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here again we set  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^k / \\rho<span class="math">  and assume  </span>\\delta<span class="math">  is maximal, i.e.,  </span>\\delta = 1 - \\rho - \\eta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice again that for any fixed values of  <span class="math">Q</span>  and  <span class="math">\\nu</span> , constraint Eq. (39) is always satisfiable by taking  <span class="math">\\ell = \\lceil \\log(1/(Q \\cdot 2^{\\nu+1})) / \\log(1 - \\delta) \\rceil</span> . Notice also that for fixed  <span class="math">\\nu, Q, \\rho</span> , and  <span class="math">\\mathbb{F}</span> , Eq. (38) gives us a lower bound on the value  <span class="math">\\eta</span> . In particular, it tells us that  $\\eta \\geq (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot Q \\cdot 2^{\\nu+1}) / (\\rho \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . Moreover,  </span>\\eta &gt; 0<span class="math">  must be satisfied, and  </span>\\eta \\leq \\rho<span class="math">  must also be satisfied since  </span>\\delta \\leq 1<span class="math"> . If the lower bound on  </span>\\eta<span class="math">  given by Eq. (38) violates  </span>\\eta \\leq \\rho<span class="math">  (i.e., it gives us  </span>\\eta &gt; \\rho$ ), then we conclude that these parameters are infeasible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given the above constraints, we can now turn to analyzing what security guarantees are achievable under Conjecture 5.12 and the parameters we are considering (i.e., the parameters given at the end of Appendix A.2. In what follows, we fix particular values of <span class="math">\\nu\\in\\{20,40,60,80\\}</span>, analyze the query upper bound via Eq. (34), then analyze whether or not Eq. (38) is satisfiable under certain fixings of <span class="math">Q</span>. As before, we have the following ranges for <span class="math">Q</span>:</p>

    <p class="text-gray-300"><span class="math">2^{116}\\leq Q&lt;2^{117}</span> <span class="math">\\nu=20</span> <span class="math">2^{106}\\leq Q&lt;2^{107}</span> <span class="math">\\nu=40</span> <span class="math">2^{96}\\leq Q&lt;2^{97}</span> <span class="math">\\nu=60</span> <span class="math">2^{86}\\leq Q&lt;2^{87}</span> <span class="math">\\nu=80</span></p>

    <p class="text-gray-300">And again in this section we consider <span class="math">Q=2^{60}</span> and <span class="math">Q=2^{80}</span> in our parameter analyses.</p>

    <h5 id="sec-149" class="text-base font-semibold mt-4">Soundness Error <span class="math">\\nu=20</span>.</h5>

    <p class="text-gray-300">In Figure 7, we present our parameter analysis for target soundness error <span class="math">\\nu=20</span>. Examining the table, we obtain our first settings of parameters that are feasible for <span class="math">128</span>-bit finite fields. In fact, for <span class="math">Q=2^{60}</span>, all parameter settings are feasible for all finite field sizes. For <span class="math">Q=2^{80}</span>, all parameter settings are feasible for <span class="math">192</span>-bit and <span class="math">256</span>-bit finite fields, whereas 7 out of 16 parameter settings for <span class="math">128</span>-bit finite fields are infeasible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 20 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 410 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 230 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 175 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 144 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 807 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 442 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 328 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 266 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 718 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 525 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 420 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.94 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.03 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 766 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 607 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 423 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 237 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 179 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 147 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 826 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 452 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 335 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 271 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.33 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 730 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 534 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 427 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.97 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.05 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 777 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 616 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 435 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 243 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 184 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 151 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 846 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 461 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 341 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 276 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 1.35 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 743 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 543 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 433 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 82, 2.00 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.06 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 28, 788 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 21, 624 KiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 20 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 102, 1004 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.746, 52, 561 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.859, 36, 422 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.469, 111, 1.76 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.625, 72, 1.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 526 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 295 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 218 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 183 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.00 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 562 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 406 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 335 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.65 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 909 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 648 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 528 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 2.45 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 943 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 762 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 542 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 303 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 223 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 187 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.03 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 574 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 414 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 341 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.68 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 925 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 659 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 536 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 2.49 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 957 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 772 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 7: Numerical calculations for soundness error  <span class="math">\\nu = 20</span>  via Conjecture 5.12, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>0 &lt; \\eta &lt; \\rho<span class="math">  is violated for parameter  </span>\\eta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 40</span> . In Figure 8, we present our parameter analysis for target soundness error  <span class="math">\\nu = 40</span> . Examining the table, we see that less parameters are feasible for 128-bit finite fields than for the case of  <span class="math">\\nu = 20</span> . For  <span class="math">Q = 2^{60}</span> , most parameters are feasible for 128-bit finite fields, whereas for  <span class="math">Q = 2^{80}</span> , none of the parameters are feasible for 128-bit finite fields. On the plus side, all of the parameter settings we consider are feasible for both 192-bit and 256-bit finite fields, for both  <span class="math">Q = 2^{60}</span>  and  <span class="math">Q = 2^{80}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 40 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 510 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 287 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 212 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.936, 26, 179 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.499, 102, 1004 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.746, 52, 561 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.859, 36, 422 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.469, 111, 1.76 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.625, 72, 1.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 526 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 295 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 218 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 183 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.00 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 562 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 406 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 335 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.65 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 909 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 648 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 528 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 2.45 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 943 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 762 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 542 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 303 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 223 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 187 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.03 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 574 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 414 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 341 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 1.68 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 925 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 659 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 536 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 102, 2.49 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 957 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 26, 772 KiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 40 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.20 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 672 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 490 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 400 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.97 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.06 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 630 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.93 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.56 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.11 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 909 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 648 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 362 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 269 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 223 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 686 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 500 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 407 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.01 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.08 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 795 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 640 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.98 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.58 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 921 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 8: Numerical calculations for soundness error  <span class="math">\\nu = 40</span>  via Conjecture 5.12, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>0 &lt; \\eta &lt; \\rho<span class="math">  is violated for parameter  </span>\\eta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 60</span> . In Figure 9, we present our parameter analysis for target soundness error  <span class="math">\\nu = 60</span> . Examining the table, we again are in the case where none of the parameters we consider are feasible for 128-bit finite fields. However, all of the parameters we consider are feasible for both 192-bit and 256-bit finite fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 60 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 629 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 352 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 262 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 218 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.20 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 672 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 490 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 400 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.97 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.06 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 630 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.93 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.56 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.11 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 909 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 648 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 362 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 269 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 223 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 1.23 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 686 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 500 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 407 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.01 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.08 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 795 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 640 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 122, 2.98 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.58 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 31, 921 KiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 60 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 1.40 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 574 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 464 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 2.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.24 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 915 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 731 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 3.41 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.82 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 1.03 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 754 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 421 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 315 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 259 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 1.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 799 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 585 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 473 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 2.34 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.26 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 930 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 743 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 3.47 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.84 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 1.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 1.04 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 9: Numerical calculations for soundness error  <span class="math">\\nu = 60</span>  via Conjecture 5.12, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>0 &lt; \\eta &lt; \\rho<span class="math">  is violated for parameter  </span>\\eta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 80</span> . In Figure 10, we present our parameter analysis for target soundness error  <span class="math">\\nu = 80</span> . Examining the table, again all of the parameters we consider are infeasible for 128-bit finite fields. For  <span class="math">Q = 2^{60}</span>  queries, all parameters are feasible for both 192-bit and 256-bit finite fields. For  <span class="math">Q = 2^{80}</span> , all parameters are feasible for 256-bit finite fields, and 4 of 16 parameter settings are infeasible for 192-bit finite fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 80 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 732 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 410 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 307 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 253 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 1.40 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 574 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 464 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 2.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.24 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 915 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 731 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 3.41 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.82 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 1.03 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 754 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 421 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 315 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 259 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 1.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 799 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 585 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 473 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 2.34 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.26 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 930 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 743 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 142, 3.47 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.84 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 48, 1.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 36, 1.04 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ν = 80 Q = 280</td>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 162, 835 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 468 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 346 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 41, 288 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 162, 1.59 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 892 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.874, 54, 645 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.934, 42, 541 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.498, 162, 2.62 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.742, 83, 1.44 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.844, 61, 1.14 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.438, 194, 4.66 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 162, 860 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 481 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 354 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 41, 295 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 162, 1.63 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 911 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 658 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 41, 538 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 162, 2.67 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 1.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 1.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 41, 846 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 162, 3.96 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 2.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 1.48 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.937, 41, 1.19 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 10: Numerical calculations for soundness error  <span class="math">\\nu = 80</span>  via Conjecture 5.12, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}<span class="math">  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively; i.e., the constraint  </span>0 &lt; \\eta \\leq \\rho<span class="math">  is violated for parameter  </span>\\eta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conclusions. Under the conjectured security of FRI given in Conjecture 5.12 from  <span class="math">\\left[\\mathrm{BCI}^{+}20\\right]</span> , the above tables again highlight that larger fields, smaller messages, and larger rates are necessary for feasibility of parameters under various settings of  <span class="math">\\nu</span> . With provable security, none of the parameters we consider were feasible for 128-bit finite fields. In contrast with provable security, more parameters under Conjecture 5.12 were feasible; moreover, the overall proof sizes were smaller, the FRI proximity parameter  <span class="math">\\delta</span>  was larger, and the verifier query complexity  <span class="math">\\ell</span>  was smaller. As a reminder, in the above analysis, a setting of parameters  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, k, \\rho, Q, \\nu)<span class="math">  was infeasible if Eq. (38) implied that  </span>\\nu &gt; \\rho$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We conclude our analysis of the parameters we consider in the context of the conjectured RBR soundness given by Conjecture 5.14. We first remark that Conjecture 5.14 is made specifically about the toy problem; i.e., a slight variant of FRI where FRI is invoked on a function  <span class="math">g(x) = (f(x) - \\alpha) / x</span>  for  <span class="math">f\\colon L_0\\to \\mathbb{F}</span> . Throughout this appendix, for ease of presentation when referring to the RBR soundness error of "FRI" in the context of this conjecture specifically, we mean in the round-by-round soundness of this toy problem.</p>

    <p class="text-gray-300">To begin, under this conjecture, the RBR soundness error of FRI is given by</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon_ {\\mathrm {r b r}} ^ {\\mathrm {F R I}} = \\max  \\left\\{\\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\rho^ {\\ell} \\right\\},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\delta = 1 - \\rho</span> is the FRI proximity parameter. Combining this expression with Eq. (32), we have the constraints</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac {1}{Q \\cdot 2 ^ {\\nu + 1}} \\Longleftrightarrow Q \\cdot 2 ^ {\\nu + 1} \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tag {40}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho^ {\\ell} \\leq \\frac {1}{Q \\cdot 2 ^ {\\nu + 1}}. \\tag {41}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Again here we set $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^k / \\rho<span class="math">, so fixing </span>k<span class="math"> and </span>\\rho<span class="math"> fixes </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ as well.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in the case of prior sections, for any fixed <span class="math">Q</span> and <span class="math">\\nu</span>, the constraint of Eq. (41) is always satisfied by taking <span class="math">\\ell = \\left\\lceil \\log \\left(1 / \\left(Q\\cdot 2^{\\nu +1}\\right)\\right) / \\log (\\rho)\\right\\rceil</span>. The constraint of Eq. (40) gives us a lower bound on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of </span>Q\\cdot 2^{\\nu +1}<span class="math">, so feasibility only depends on having a sufficiently large field. Notice also that Eq. (40) gives an additional upper bound on </span>Q$ as well, along with the constraint of Eq. (34).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given these constraints, we can now turn to analyzing what provable security guarantees are achievable under the setting of parameters we are considering (i.e., the parameters given at the end of Appendix A.2). In what follows, we fix particular values of <span class="math">\\nu \\in \\{20, 40, 60, 80\\}</span> and $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math"> and analyze the feasibility of parameters </span>\\rho<span class="math"> and </span>k<span class="math"> for certain values of </span>Q<span class="math">. Again from Eq. (34) and </span>\\kappa = 256$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">2 ^ {1 1 6} \\leq Q &amp;lt;   2 ^ {1 1 7} \\quad \\nu = 2 0</span></div>

    <div class="my-4 text-center"><span class="math-block">2 ^ {1 0 6} \\leq Q &amp;lt;   2 ^ {1 0 7} \\quad \\nu = 4 0</span></div>

    <div class="my-4 text-center"><span class="math-block">2 ^ {9 6} \\leq Q &amp;lt;   2 ^ {9 7} \\quad \\nu = 6 0</span></div>

    <div class="my-4 text-center"><span class="math-block">2 ^ {8 6} \\leq Q &amp;lt;   2 ^ {8 7} \\quad \\nu = 8 0</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As before, we choose to consider <span class="math">Q = 2^{60}</span> and <span class="math">Q = 2^{80}</span> in our calculations. Note that we additionally have the constraint $Q \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2^{\\nu + 1}<span class="math">, which may be smaller than </span>2^{60}<span class="math"> or </span>2^{80}$. In this case, we consider the parameters as being infeasible and indicate them appropriately.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error <span class="math">\\nu = 20</span>. In Figure 11, we present our parameter analysis for target soundness error <span class="math">\\nu = 20</span>. Examining the table, for the first time we have all parameter settings are feasible for all finite field sizes, for both <span class="math">Q = 2^{60}</span> and <span class="math">Q = 2^{80}</span> query bounds.</p>

    <p class="text-gray-300">76</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 20 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 405 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 230 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 169 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 144 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 797 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 442 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 316 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 266 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 1.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 718 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 506 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 420 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 1.92 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.03 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 739 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 607 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 417 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 237 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 173 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 147 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 816 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 452 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 323 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 271 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 1.31 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 730 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 515 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 427 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 1.95 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.05 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 749 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 616 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 430 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 243 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 177 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 151 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 835 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 461 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 329 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 276 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 1.34 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 743 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 523 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 433 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 81, 1.98 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 41, 1.06 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 27, 760 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 21, 624 KiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 20 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 994 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 550 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 398 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 329 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.60 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 893 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 638 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 520 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 2.39 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.28 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 930 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 752 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 521 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 295 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 218 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 183 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1018 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 562 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 406 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 335 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.63 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 909 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 648 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 528 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 2.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 943 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 762 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 536 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 303 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 223 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 187 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 574 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 414 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 341 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.67 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 925 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 659 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 536 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 2.47 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 957 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 772 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 11: Numerical calculations for soundness error  <span class="math">\\nu = 20</span>  via Conjecture 5.14, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}$  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 40</span> . In Figure 12, we present our parameter analysis for target soundness error  <span class="math">\\nu = 40</span> . Examining the table, we finally have a setting where all of the parameters we consider are feasible for all finite field sizes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 40 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 505 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 287 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 212 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 179 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 994 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 550 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 398 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 329 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.60 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 893 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 638 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 520 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 2.39 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.28 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 930 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 752 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 521 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 295 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 218 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 183 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1018 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 562 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 406 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 335 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.63 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 909 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 648 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 528 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 2.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.30 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 943 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 762 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 536 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 303 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 223 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 187 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 574 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 414 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 341 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 1.67 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 925 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 659 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 536 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 101, 2.47 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 51, 1.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 34, 957 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 26, 772 KiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 40 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.16 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 658 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 480 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 392 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.92 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.04 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 769 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 620 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 2.86 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.54 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 896 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 624 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 352 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 262 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 218 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.19 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 672 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 490 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 400 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.96 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.06 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 630 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 2.91 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.56 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.11 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 909 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 643 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 362 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 269 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 223 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.22 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 686 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 500 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 407 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.99 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.08 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 795 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 640 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 2.95 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.58 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 921 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 12: Numerical calculations for soundness error  <span class="math">\\nu = 40</span>  via Conjecture 5.14, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}$  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness Error  <span class="math">\\nu = 60</span> . In Figure 13, we present our parameter analysis for target soundness error  <span class="math">\\nu = 60</span> . Examining the table, we see that in this case all parameters are feasible for  <span class="math">Q = 2^{60}</span> , but parameters for 128-bit finite fields become infeasible for  <span class="math">Q = 2^{80}</span> . However, all parameters remain feasible for  <span class="math">Q = 2^{80}</span>  and 192-bit or 256-bit finite fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 60 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 605 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 343 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 256 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 213 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.16 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 658 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 480 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 392 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.92 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.04 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 769 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 620 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 2.86 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.54 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 896 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 624 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 352 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 262 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 218 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.19 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 672 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 490 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 400 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.96 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.06 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 630 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 2.91 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.56 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.11 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 909 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 643 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 362 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 269 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 223 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.22 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 686 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 500 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 407 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 1.99 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.08 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 795 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 640 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 121, 2.95 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 61, 1.58 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 41, 1.13 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 31, 921 KiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 60 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 1.39 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 562 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 464 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 2.28 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.24 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 896 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 731 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 3.39 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.82 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 1.27 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 1.03 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 749 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 421 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 308 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 259 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 1.42 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 799 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 573 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 473 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 2.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.26 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 911 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 743 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 3.44 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.84 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 1.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 1.04 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 13: Numerical calculations for soundness error  <span class="math">\\nu = 60</span>  via Conjecture 5.14, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}$  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness Error  <span class="math">\\nu = 80</span> . In Figure 14, we present our parameter analysis for target soundness error  <span class="math">\\nu = 80</span> . Examining the table, we now are in a similar case to our other conjecture where parameters for 128-bit finite fields are infeasible. We remark, however, that in this case it is due to  $\\{2^{60}, 2^{80}\\} &gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 2^{81}<span class="math"> , which violates the constraint we have on the query bound. Smaller  </span>Q$  will reveal more feasibility results for 128-bit finite fields.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ν = 80 Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conjecture 5.14</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/2</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ = 1/16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 727 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 410 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 301 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 253 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 1.39 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 782 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 562 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 464 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 2.28 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.24 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 896 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 731 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 3.39 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.82 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 1.27 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 1.03 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 749 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 421 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 308 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 259 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 1.42 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 799 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 573 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 473 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 2.32 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.26 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 911 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 743 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 141, 3.44 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 71, 1.84 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 47, 1.29 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 36, 1.04 MiB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ν = 80 Q = 280 |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/8</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ = 1/16</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 1.59 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 892 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 645 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 529 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 2.60 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 1.41 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 1.01 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 833 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 3.87 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 2.07 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 1.46 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 1.17 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 855 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 481 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 354 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 295 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 1.62 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 911 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 658 KiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 538 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 2.65 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 1.43 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 1.02 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 846 KiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.500, 161, 3.93 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.750, 81, 2.10 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.875, 54, 1.48 MiB)</td>

            <td class="px-3 py-2 border-b border-gray-700">(0.938, 41, 1.19 MiB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(δ, ℓ,</td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 14: Numerical calculations for soundness error  <span class="math">\\nu = 80</span>  via Conjecture 5.14, where  <span class="math">d_0 = 2^k</span> ,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_0 / \\rho<span class="math"> ,  </span>\\ell<span class="math">  is the number of repetitions during the Query Phase,  </span>Q<span class="math">  is the allowed number of random oracle queries made by a malicious prover, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size. Parameters  </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\{128, 192, 256\\}<span class="math">  and  </span>k \\in \\{10, 15, 20, 25\\}$  are considered. Grayed out entries and/or entirely omitted rows indicate infeasibility of parameters for that entry or row, respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Conclusions. Under the conjectured security of FRI given in Conjecture 5.14, the above tables again highlight that larger fields, smaller messages, and larger rates are necessary for feasibility of parameters under various settings of  <span class="math">\\nu</span> . In contrast with both provable security given under Corollary 4.3 and conjectured security under Conjecture 5.12, the more aggressive conjecture of Conjecture 5.14 allows us to have some feasible parameters for 128-bit finite fields for lower values of  <span class="math">\\nu</span> . As a reminder, parameters we considered in this section were infeasible if Eq. (40) was violated for selections of  <span class="math">(\\mathbb{F}, Q, \\nu)</span> .</p>

    <p class="text-gray-300">We now turn to the second part of our analysis. That is, we analyze various parameter settings for FRI, set various targets for  <span class="math">Q</span> , and analyze the achievable soundness error  <span class="math">\\nu</span> . As a reminder,  <span class="math">Q</span>  is (an upper bound on) the number of random oracle queries an attacker is allowed to make when attacking FS-FRI. In this section, we are therefore interested in analyzing how Eqs. (32) and (33) upper bound the parameter  <span class="math">\\nu</span> . Rewriting these equations, we have the following constraints:</p>

    <div class="my-4 text-center"><span class="math-block">\\nu \\leq \\left\\lfloor \\log \\left(\\frac {1}{2 \\cdot Q \\cdot \\epsilon_ {\\mathrm {r f r}} ^ {\\mathrm {F R I}}}\\right) \\right\\rfloor \\tag {42}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\nu \\leq \\left\\lfloor \\log \\left(\\frac {2 ^ {\\kappa - 1}}{3 \\cdot \\left(Q ^ {2} + 1\\right)}\\right) \\right\\rfloor . \\tag {43}</span></div>

    <p class="text-gray-300">Therefore in what follows, we always set  <span class="math">\\nu = \\min \\{\\mathrm{Eq.}(42),\\mathrm{Eq.}(43)\\}</span>  in our analysis.</p>

    <p class="text-gray-300">For provable security, recall that Corollary 4.3 gives us</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}=\\max\\left\\{\\frac{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}}{3\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore combining this expression with Eq. (42) gives us</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\nu\\leq\\left\\lfloor\\log\\left(\\frac{1}{2Q}\\cdot\\min\\left\\{\\frac{3\\rho^{3/2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{(m+1/2)^{7}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}},\\frac{1}{(1-\\delta)^{\\ell}}\\right\\}\\right)\\right\\rfloor.$ (44)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, the security bounds given by Conjecture 5.12 for constants <span class="math">c_{1}=c_{2}=1</span> and parameter <span class="math">0&lt;\\eta&lt;\\rho</span> give us RBR soundness error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}=\\max\\left\\{\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\rho\\eta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},(1-\\delta)^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus combining this expression with Eq. (42) gives us</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\nu\\leq\\left\\lfloor\\log\\left(\\frac{1}{2Q}\\cdot\\min\\left\\{\\frac{\\rho\\eta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\frac{1}{(1-\\delta)^{\\ell}}\\right\\}\\right)\\right\\rfloor.$ (45)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, the security bounds given by Conjecture 5.14 give us RBR soundness error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\varepsilon_{\\mathsf{rbr}}^{\\mathsf{FRI}}=\\max\\left\\{\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\rho^{\\ell}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Again combining the above expression with Eq. (42) gives us</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\nu\\leq\\left\\lfloor\\log\\left(\\frac{1}{2Q}\\cdot\\min\\left\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\frac{1}{\\rho^{\\ell}}\\right\\}\\right)\\right\\rfloor.$ (46)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We use the constraints Eqs. (44) to (46), along with Eq. (43), to analyze several settings of parameters found in other works.</p>

    <h4 id="sec-152" class="text-lg font-semibold mt-6">A.3.1 Parameters from RISC Zero <em>[x103]</em></h4>

    <p class="text-gray-300">The RISC Zero <em>[x103]</em> project uses FRI in their system. Examining their codebase reveals the following setting of parameters for FRI:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=124$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\rho=1/4</span>;</li>

      <li><span class="math">\\ell=50</span>; and</li>

      <li><span class="math">k=24</span> and <span class="math">d_{0}=2^{24}</span>.</li>

    </ul>

    <p class="text-gray-300">These parameters target soundness error <span class="math">2^{-100}</span> <em>for the interactive FRI protocol</em>. We analyze the achievable soundness error of these parameters in the <em>non-interactive FRI proof</em>.</p>

    <p class="text-gray-300">As with prior sections, we analyze the above parameters with respect to provable and conjectured security. Using Eqs. (44) to (46), we analyze the achievable soundness error <span class="math">\\nu</span> for provable and conjectured security, respectively, versus <span class="math">Q=2^{20},2^{40},2^{60},2^{80}</span> query adversaries. Note that RISC Zero does not give any values for the Johnson proximity parameter <span class="math">m</span> (needed for Corollary 4.3), so we set <span class="math">m=3</span>, which is the minimum possible value for <span class="math">m</span>, and note that any larger <span class="math">m</span> only results in smaller <span class="math">\\nu</span>. Furthermore, RISC Zero does not specify parameter <span class="math">\\eta</span> (needed for Conjecture 5.12),</p>

    <p class="text-gray-300">so we simply set  <span class="math">\\eta = \\rho /6</span>  to provide a comparison with  <span class="math">m = 3</span>  considered for the provable security case. We summarize our findings in Figure 15.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 124, ρ = 1/4, k = 24 ℓ = 50,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1.17 MiB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 240</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 280</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 4.3 m = 3 δ = 1 - √ρ(1 + 1/(2m))</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 0.41667</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.12 η = ρ/6 δ = 1 - ρ - η</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 44</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 24</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 0.70833</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.14 δ = 1 - ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 79</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 59</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 39</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 19</td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 3/4</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 15: Soundness error calculations for FRI parameters in [Tea23] in the context of non-interactive FRI. The top left entry of the table indicates the fixed parameters. Note that [Tea23] does not give a Johnson proximity parameter  <span class="math">m</span> , so we choose  <span class="math">m = 3</span>  as any larger  <span class="math">m</span>  only makes  <span class="math">\\nu</span>  in the above calculations smaller. Each row corresponds to calculations with respect to Corollary 4.3 and Conjectures 5.12 and 5.14.  <span class="math">\\delta</span>  is the FRI proximity parameter,  <span class="math">\\ell</span>  is the verifier query complexity, and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size of non-interactive argument under these parameters. Each  </span>\\nu<span class="math">  entry of the table indicates the achievable soundness error versus a  </span>Q<span class="math"> -query adversary for  </span>Q<span class="math">  given in each column. The grayed out entry indicates  </span>\\nu \\leq 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Examining the Plonky2 system [Polb], we extract fixed parameters  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 128<span class="math">  and  </span>N = 2^{32}<span class="math"> . They have two configurations with  </span>(\\rho, \\ell) = (1/2, 84)<span class="math">  and  </span>(\\rho, \\ell) = (1/8, 28)<span class="math">  for rate  </span>\\rho<span class="math">  and verifier query complexity  </span>\\ell<span class="math"> , giving  </span>k = 31<span class="math">  and  </span>k = 29<span class="math"> , respectively. Both of these configuration target soundness error at most  </span>2^{-100}<span class="math"> , which includes 16-bits of grinding, where the prover computes a 16-bit proof of work on the computed non-interactive proof as an additional part of the proof. In particular, this translates to a target soundness error of  </span>2^{-84}<span class="math">  for the FRI part of the non-interactive proof (not including the grinding). However, the parameters used to achieve soundness error  </span>2^{-84}$  for the FRI part of the proof are chosen with respect to the interactive FRI soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As with prior sections, we analyze the above parameters with respect to provable and conjectured security for the non-interactive FRI proof. Using Eqs. (44) to (46), we analyze the achievable soundness error  <span class="math">\\nu</span>  for provable and conjectured security, respectively, versus a  <span class="math">Q = 2^{20}, 2^{40}, 2^{60}, 2^{80}</span>  query adversary. Note that Plonky2 does not give any values for the Johnson proximity parameter  <span class="math">m</span>  (needed for Corollary 4.3), so we set  <span class="math">m = 3</span> , which is the minimum possible value for  <span class="math">m</span> , and note that any larger  <span class="math">m</span>  only results in smaller  <span class="math">\\nu</span> . Furthermore, Plonky2 does not specify parameter  <span class="math">\\eta</span>  (needed for Conjecture 5.12), so we simply set  <span class="math">\\eta = \\rho / 6</span>  to provide a comparison with  <span class="math">m = 3</span>  considered for the provable security case. We summarize our findings in Figures 16 and 17.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 128, ρ = 1/2, k = 31 ℓ = 84,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2.94 MiB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 240</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 280</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 4.3 m = 3 δ = 1 - √ρ(1 + 1/(2m))</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 0.17504</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.12 η = ρ/6 δ = 1 - ρ - η</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 38</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 18</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 0.41667</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.14 δ = 1 - ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 63</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 43</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 23</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 3</td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 1/2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 16: Soundness error calculations for one set of FRI parameters in [Polb] in the context of non-interactive FRI. The top left entry of the table indicates the fixed parameters. Note that [Polb] does not give a Johnson proximity parameter  <span class="math">m</span> , so we choose  <span class="math">m = 3</span>  as any larger  <span class="math">m</span>  only makes  <span class="math">\\nu</span>  in the above calculations smaller. Each row corresponds to calculations with respect to Corollary 4.3 and Conjectures 5.12 and 5.14.  <span class="math">\\delta</span>  is the FRI proximity parameter,  <span class="math">\\ell</span>  is the verifier query complexity, and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size of non-interactive argument under these parameters. Each  </span>\\nu<span class="math">  entry of the table indicates the achievable soundness error versus a  </span>Q<span class="math"> -query adversary for  </span>Q<span class="math">  given in each column. The grayed out entry indicates  </span>\\nu \\leq 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 128, ρ = 1/8, k = 29 ℓ = 28,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 990 KiB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 240</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 260</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q = 280</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 4.3 m = 3 δ = 1 - √ρ(1 + 1/(2m))</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 0.58752</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.12 η = ρ/6 δ = 1 - ρ - η</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 34</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 0.93748</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjecture 5.14 δ = 1 - ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 63</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 43</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 23</td>

            <td class="px-3 py-2 border-b border-gray-700">ν = 3</td>

            <td class="px-3 py-2 border-b border-gray-700">δ = 7/8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 17: Soundness error calculations for another set of FRI parameters in [Polb] in the context of non-interactive FRI. The top left entry of the table indicates the fixed parameters. Note that [Polb] does not give a Johnson proximity parameter  <span class="math">m</span> , so we choose  <span class="math">m = 3</span>  as any larger  <span class="math">m</span>  only makes  <span class="math">\\nu</span>  in the above calculations smaller. Each row corresponds to calculations with respect to Corollary 4.3 and Conjectures 5.12 and 5.14.  <span class="math">\\delta</span>  is the FRI proximity parameter,  <span class="math">\\ell</span>  is the verifier query complexity, and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the proof size of non-interactive argument under these parameters. Each  </span>\\nu<span class="math">  entry of the table indicates the achievable soundness error versus a  </span>Q<span class="math"> -query adversary for  </span>Q<span class="math">  given in each column. The grayed out entries indicate  </span>\\nu \\leq 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Part 1 of our analysis, we consider various targets for the non-interactive soundness error  <span class="math">2^{-\\nu}</span>  of FS-FRI versus  <span class="math">Q</span> -query adversaries under some fixed parameters of FS-FRI  <span class="math">(\\mathbb{F}, k, \\text{and} \\rho)</span> . Given these targets and fixed parameters, we calculate upper bounds on the query complexity  <span class="math">Q</span>  of a non-interactive adversary attacking FS-FRI, which roughly translates to the hashing power of an adversary attacking FS-FRI when instantiating the random oracle with a cryptographic hash function. Given the upper bound on  <span class="math">Q</span> , we consider various values for  <span class="math">Q</span>  and compute the feasibility of achieving soundness error  <span class="math">2^{-\\nu}</span>  versus a  <span class="math">Q</span> -query adversary under the fixed parameters  <span class="math">\\mathbb{F}, k, \\text{and} \\rho</span> . For our parameter choices, our analysis shows that for provable security of FRI (Corollary 4.3), all parameter choices are infeasible when we consider 128-bit finite fields, most parameter choices are infeasible for 192-bit finite fields, and nearly all parameter choices are feasible for 256-bit finite fields; in this case, parameters were infeasible if Eq. (36) implied that  <span class="math">m &amp;lt; 3</span>  for Johnson proximity parameter  <span class="math">m</span> . Under the first conjectured security of FRI (Conjecture 5.12), the case is nearly</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">identical to the provable security case, save for more parameter choices are feasible for <span class="math">192</span>-bit finite fields; in this case, parameters were infeasible if Eq. (38) implied that parameter <span class="math">\\eta\\geq\\rho</span> or <span class="math">\\eta\\leq 0</span>. In the case of the most aggressive security conjecture (Conjecture 5.14), parameters become feasible for <span class="math">128</span>-bit finite fields, but only for small values of <span class="math">\\nu</span> (i.e., large soundness error), and all parameter choices are feasible for <span class="math">192</span>-bit and <span class="math">256</span>-bit finite fields; in this case, parameters were infeasible if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><Q\\cdot 2^{\\nu+1}<span class="math"> for finite field </span>\\mathbb{F}<span class="math"> and query bound </span>\\nu$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We remark that it is highly likely there exist parameters (e.g., smaller messages, <span class="math">200</span>-bit finite fields, etc.) where certain parameters that were infeasible in our setting become feasible. Thus we can offer the following methodology for choosing FRI parameters. First, for the non-interactive FRI protocol, one can set a desired non-interactive success probability <span class="math">\\nu</span> of a bounded-query adversary. Given <span class="math">\\nu</span>, one can calculate an upper bound on <span class="math">Q</span>, the adversarial power (i.e., the number of queries it can make to the random oracle). Given this upper bound, one can choose a some value <span class="math">Q</span> less than or equal to the computed upper bound as a target (i.e., protect your system only against adversaries that can make at most <span class="math">2^{100}</span> hashes). With all these parameters, one can set target parameters of FRI <span class="math">\\mathbb{F}</span>, <span class="math">k</span>, and <span class="math">\\rho</span> and then check if such parameters are feasible under the assumptions one is making about FRI (i.e., provable versus conjectured security).</p>

    <p class="text-gray-300">In Part 2 of our analysis, we analyze what soundness errors <span class="math">\\nu</span> are achievable for parameters of FRI that are deployed in practice. Our calculations of <span class="math">\\nu</span> are with respect to considering adversaries that can make <span class="math">Q\\in\\{2^{20},2^{40},2^{60},2^{80}\\}</span> random oracle queries when attacking FS-FRI. All parameters from <em>[x20]</em> we considered have large provable soundness errors (i.e., small <span class="math">\\nu</span>), even versus only a <span class="math">2^{20}</span>-query adversary. In the case of Conjecture 5.12, the same parameters from <em>[x20]</em> have large soundness errors, with the best <span class="math">\\nu=44</span> being only achieved when <span class="math">Q=2^{20}</span> (which gets worse for larger <span class="math">Q</span>). The parameters of <em>[x20]</em> and <em>[x24]</em> achieve their targeted soundness errors under the strongest conjecture, Conjecture 5.14.</p>

    <p class="text-gray-300">We stress that all of our analyses above are specifically for FS-FRI, the non-interactive random oracle proof obtained by compiling the FRI IOPP (Algorithm 1) with the BCS transformation (Theorem 3.15, <em>[x1]</em>). As such, our analysis is self-contained in the context of FS-FRI only: all restrictions, bounds, and calculations only apply to this protocol. When considering protocols that use FRI as a sub-protocol (e.g., in Section 7 we do this, and many other projects do this including <em>[x20, x24, x3]</em>), we stress that <em>additional constraints</em> may be introduced on the FRI parameters. Hence our calculations above should not be considered as a black-box when analyzing FRI when it is used as a sub-protocol, as the constraints we outlined above could be changed. In fact, it is possible that end-to-end analyses of protocols that invoke FRI as a sub-protocol may make the resulting provable soundness bounds even worse than what we have showcased here. Thus it is important to perform careful end-to-end security analyses of protocols that invoke FRI (and other protocols in general) in order to accurately assess the security of an overall system, and set parameters appropriately.</p>

    <h3 id="sec-155" class="text-xl font-semibold mt-8">A.5 Sagemath Code</h3>

    <p class="text-gray-300">The Sagemath code we used to evaluate the parameters we consider throughout this section can be found at the following Github link: https://github.com/alexander-r-block/FRI-Parameter-Testing-Sagemath.</p>

    <h2 id="sec-156" class="text-2xl font-bold">Appendix</h2>

    <h2 id="sec-157" class="text-2xl font-bold">Appendix B <span class="math">\\delta</span>-Correlated hIOPs and Reed-Solomon Encoded IOPs</h2>

    <p class="text-gray-300">As we mentioned, our notion of <span class="math">\\delta</span>-correlated hIOP is related to that of <em>Reed-Solomon (RS) encoded IOP’s</em> <em>[BCR^{+}19, x13]</em>. The main similarities and differences are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\delta=0</span>, <span class="math">\\delta</span>-correlated IOPs can be seen as a subclass of RS-encoded IOPs, modulo changing superficial formalization details (some of which we discuss next). This is because the two checks the verifier performs in a <span class="math">\\delta</span>-correlated IOP pass if and only if certain rational constraints (in the terminology of RS-encoded IOPs) are satisfied.</li>

    </ul>

    <p class="text-gray-300">The converse is, however, not true: for <span class="math">\\delta=0</span>, RS-encoded IOPs are more general than <span class="math">\\delta</span>-correlated IOPs, since they allow to use more varied <em>sets</em> of rational constraints. We emphasize the term “sets” here, because, individually, a rational constraint <span class="math">Q(X)=p(X,f_{1}(X),\\ldots,f_{m}(X))/q(X)</span> (following the notation in Definition 4.1 of <em>[x13]</em>) can always be written in the “<span class="math">0</span>-correlated compatible form”</p>

    <p class="text-gray-300"><span class="math">\\frac{Q(X)-Q(z)}{X-z}</span></p>

    <p class="text-gray-300">for an arbitrary <span class="math">z</span>. Then the latter is a low degree polynomial if and only if <span class="math">Q(X)</span> is.</p>

    <p class="text-gray-300">However, the set of “rational constraints” in a <span class="math">0</span>-correlated IOP stem from using the DEEP-ALI method on a set of polynomial constraints. In general, RS-encoded IOPs are more expressive than that.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In our terminology, RS-encoded IOP’s only consider the case <span class="math">\\delta=0</span>, while we allow for <span class="math">\\delta&gt;0</span>, which in our context was useful in formalization tasks. We remark that, when comparing to the works in <em>[BCR^{+}19, x13]</em>, this is not a deep distinction because the RS-encoded IOP from these references are compiled with a protocol <span class="math">\\Pi_{\\text{CA}}</span> for <span class="math">\\delta</span>-correlated agreement. Similarly, our results can be understood as compilation results for <span class="math">0</span>-correlated IOPs with the protocol <span class="math">\\Pi_{\\text{CA}}</span>.</li>

      <li>A RS-encoded IOP does not make use of an oracle for correlated agreement, but instead defines soundness for adversaries that are constrained on the type of messages they can send. More precisely, the soundness definition of a RS-encoded IOP only considers adversaries that send codewords from certain RS codes.</li>

    </ul>

    <p class="text-gray-300">Note however that, when <span class="math">\\delta=0</span>, this distinction makes no difference: whether one provides the verifier with oracles for <span class="math">0</span>-correlated agreement, or one constraints the definition of soundness, the resulting families of IOP’s are the same.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RS-encoded IOP’s are more relaxed in the degree bound of the codewords sent by the prover: while we ask that all codewords have the same degree bound <span class="math">d</span>, in RS-encoded IOP there is a degree bound for each codeword sent.</li>

    </ul>

    <p class="text-gray-300">It may be possible to generalize the notion of <span class="math">\\delta</span>-correlated IOPs in a similar fashion, and still obtain a compilation result similar to Theorem 4.6.</p>

    <p class="text-gray-300">C A Less Sound Variant of OPlonky</p>

    <p class="text-gray-300">In this appendix we discuss a variation of OPlonky that is arguably more natural than the original protocol, but whose RBR soundness error is, in principle, much larger. The difference between the two protocols is related to how the t “parallel” checks in Rounds 1 and 2 are performed. We emphasize that most protocols use t = 1 and a large field <span class="math">\\mathbb{F}</span>, in which case the considerations in this appendix do not apply. On the other hand, some projects (e.g., Plonky2) currently use t = 2 and a 64-bit field <span class="math">\\mathbb{F}</span>. In this scenario, the natural variation of OPlonky described here would lead to a non-interactive protocol with <span class="math">\\approx 50</span> bits of security, while the original (interactive) OPlonky achieves <span class="math">\\approx 100</span> bits of security.</p>

    <p class="text-gray-300">Recall that the first Round of OPlonky(<span class="math">\\delta</span>) is obtained as the t-parallel repetition of the protocol permutation hIOP <span class="math">\\Pi_{\\text{R}_{\\text{RPerm}}}(\\delta)</span>. The second round is also the result of repeating t checks in parallel: more precisely, for t random challenges <span class="math">\\alpha</span>, the prover aims to certify that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\alpha^{j-1}P_{j}(\\mathsf{a}_{1}(X),\\ldots,\\mathsf{a}_{r}(X),\\mathsf{a}_{1}(\\omega X),\\ldots,\\mathsf{a}_{r}(\\omega X),\\mathsf{sel}_{1}(X),\\ldots,\\mathsf{sel}_{\\ell}(X))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">vanishes on <span class="math">H</span>. Importantly, each one of these t verifications combines all the polynomials from the t checks of Round 1. This is in contrast to the the similar (and arguably more natural, though insecure) approach in which one repeats an entire IOP (or some rounds of it) t times in parallel. In full, such a variation of OPlonky(<span class="math">\\delta</span>) would proceed as follows (the protocol is essentially the same as the original OPlonky(<span class="math">\\delta</span>) except for the third prover’s message):</p>

    <h6 id="sec-158" class="text-base font-medium mt-4">Prover’s message 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exactly as in the original OPlonky(<span class="math">\\delta</span>), here <span class="math">\\mathsf{P}_{\\text{OPlonky}}</span> computes <span class="math">\\mathsf{a}_{1}(X),\\ldots,\\mathsf{a}_{r}(X)</span> as <span class="math">\\mathsf{a}_{j}(X)=\\sum_{i=1}^{n}\\mathbb{W}_{(j-1)n+i}\\mathsf{L}_{i}(X)</span> for each <span class="math">j\\in[\\mathsf{r}]</span>. It then sends oracles $\\llbracket\\mathsf{a}_{1}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}\\rrbracket,\\ldots,\\llbracket\\mathsf{a}_{r}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}\\rrbracket<span class="math"> to </span>\\mathsf{V}_{\\text{OPlonky}}<span class="math">, where </span>\\mathsf{a}_{i}(X)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D}<span class="math"> denotes the word from </span>\\mathbb{F}^{D}<span class="math"> obtained by restricting </span>\\mathsf{a}_{i}(X)<span class="math"> on </span>D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-159" class="text-base font-medium mt-4">Permutation argument part (Verifier’s challenge 1 and Prover’s message 2).</h6>

    <p class="text-gray-300">Again exactly as in OPlonky(<span class="math">\\delta</span>), for t times in parallel, <span class="math">\\mathsf{P}_{\\text{OPlonky}}</span> and <span class="math">\\mathsf{V}_{\\text{OPlonky}}</span> execute the online phase of the permutation proof <span class="math">\\Pi_{\\text{R}_{\\text{RPerm}}}</span> for the triple</p>

    <p class="text-gray-300"><span class="math">(\\mathrm{i}^{\\prime},\\mathbb{x}^{\\prime},\\mathbb{w}^{\\prime})=\\left((\\mathsf{r}^{\\prime},\\sigma),(\\llbracket\\mathsf{a}_{i}\\rrbracket,\\llbracket\\mathsf{a}_{i}\\rrbracket)_{i\\in[\\mathsf{r}^{\\prime}]},(\\mathsf{a}_{i},\\mathsf{a}_{i})_{i\\in[\\mathsf{r}^{\\prime}]}\\right).</span></p>

    <p class="text-gray-300">At the end of each of the t executions of the interactive phase, <span class="math">\\mathsf{V}_{\\text{OPlonky}}</span> has received oracles</p>

    <p class="text-gray-300"><span class="math">(\\llbracket\\mathsf{z}_{k}\\rrbracket,\\llbracket\\pi_{k,1}\\rrbracket,\\ldots,\\llbracket\\pi_{k,(\\mathsf{s}-1)}\\rrbracket)</span></p>

    <p class="text-gray-300">for each <span class="math">k\\in[\\mathsf{t}]</span>. Let <span class="math">(\\beta_{k},\\gamma_{k})</span> be the verifier’s challenges on each of the executions.</p>

    <p class="text-gray-300">For each <span class="math">k\\in[\\mathsf{t}]</span>, we denote by <span class="math">(\\bar{f}_{ki}(X))_{i\\in[\\mathsf{s}]}</span> the polynomials in Eq. (23) computed with the challenges <span class="math">\\beta_{k},\\gamma_{k}</span>.</p>

    <h6 id="sec-160" class="text-base font-medium mt-4">Verifier’s challenge 2.</h6>

    <p class="text-gray-300">As in the original protocol, <span class="math">\\mathsf{V}_{\\text{OPlonky}}</span> samples random challenges <span class="math">\\alpha_{1},\\ldots,\\alpha_{\\mathsf{t}}</span> and sends them to <span class="math">\\mathsf{P}_{\\text{OPlonky}}</span>.</p>

    <h6 id="sec-161" class="text-base font-medium mt-4">Prover’s message 3.</h6>

    <p class="text-gray-300">This step deviates from the original protocol. Specifically, <span class="math">\\mathsf{P}_{\\text{OPlonky}}</span> computes polynomials <span class="math">(\\mathsf{d}_{k}(X),\\mathsf{q}_{k}(X))_{k\\in[\\mathsf{t}]}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{k}(X)</span> <span class="math">:=</span> <span class="math">\\left(\\bar{f}_{k1}(X)\\mathsf{z}_{k}(X)-\\pi_{k,1}(X)\\bar{g}_{k1}(X)\\right)\\alpha_{k}</span> <span class="math">+\\sum_{j=2}^{\\mathsf{s}-1}\\left(\\bar{f}_{kj}(X)\\pi_{k,j-1}(X)-\\pi_{k,j}(X)\\bar{g}_{kj}(X)\\right)\\alpha_{k}^{j}</span> <span class="math">+\\left(\\bar{f}_{k\\mathsf{s}}(X)\\pi_{k,\\mathsf{s}-1}(X)-\\mathsf{z}_{k}(\\omega X)\\bar{g}_{k\\mathsf{s}}(X)\\right)\\alpha_{k}^{\\mathsf{s}+1}</span> <span class="math">+(\\mathsf{z}_{k}(X)-1)\\mathsf{L}_{1}(X)\\alpha_{k}^{\\mathsf{s}+2}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{d}_{k}(X)</span> <span class="math">:=</span> $\\sum_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}\\alpha_{k}^{j-1}P_{j}(\\mathsf{a}_{1}(X),\\ldots,\\mathsf{a}_{r}(X),\\mathsf{a}_{1}(\\omega X),\\ldots,\\mathsf{a}_{r}(\\omega X),\\mathsf{sel}_{1}(X),\\ldots,\\mathsf{sel}_{\\ell}(X))+\\alpha_{k}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\mathsf{u}_{k}(X).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{q}_{k}(X)</span> <span class="math">:=</span> <span class="math">\\mathsf{d}_{k}(X)/\\mathsf{Z}_{\\mathsf{H}}(X).</span></p>

    <p class="text-gray-300">Then <span class="math">\\mathsf{P}_{\\text{OPlonky}}</span> splits the polynomials <span class="math">\\mathsf{q}_{k}(X)</span> into degree <span class="math">n</span> polynomials <span class="math">\\mathsf{q}_{k,1}(X),\\ldots,\\mathsf{q}_{k,v}(X)</span>, so that <span class="math">\\mathsf{q}_{k}(X)=\\sum_{i=1}^{v}X^{ni}P_{k,v}(X)</span> and sends oracle access to these to <span class="math">\\mathsf{V}_{\\text{OPlonky}}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-162" class="text-lg font-semibold mt-6">Rest of the protocol.</h4>

    <p class="text-gray-300">The remaining steps of the protocol proceed identically as in <span class="math">\\mathsf{OPlonky}(\\delta)</span>.</p>

    <p class="text-gray-300">This variation of <span class="math">\\mathsf{OPlonky}</span> has much higher RBR soundness error than the original one. Moreover, when compiled into a SNARK (via the method described in Definition 6.2 and Section 7.3.1), an attack from <em>[x1]</em> can be applied to it (the <em>[x1]</em> attack applies more generally whenever the FS transformation is applied to an interactive protocol involving parallel repetition).</p>

    <p class="text-gray-300">To illustrate the attack, let us analyse the specific case <span class="math">\\mathtt{t}=2</span>. Suppose that an adversary <span class="math">\\mathcal{A}</span> receives <span class="math">(\\beta_{1},\\gamma_{1})</span>, <span class="math">(\\beta_{2},\\gamma_{2})</span> so that <span class="math">(\\beta_{1},\\gamma_{1})</span> allows <span class="math">\\mathcal{A}</span> to “cheat at Round 1”, in the sense that all of the maps</p>

    <p class="text-gray-300"><span class="math">\\widetilde{f}_{11}(X)\\mathtt{z}_{k}(X)-\\pi_{1,1}(X)\\bar{g}_{11}(X)</span> (48) <span class="math">\\pi_{1,j-1}(X)-\\pi_{1,j}(X)\\bar{g}_{1j}(X),\\quad j=2,\\ldots,\\mathtt{s}-1</span> <span class="math">\\widetilde{f}_{1\\mathtt{s}}(X)\\pi_{1,\\mathtt{s}-1}(X)-\\mathtt{z}_{1}(\\omega X)\\bar{g}_{1\\mathtt{s}}(X)</span> <span class="math">(\\mathtt{z}_{1}(X)-1)\\mathtt{L}_{1}(X).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vanish on <span class="math">H</span>. Notice that we make no assumption on the analogous polynomials constructed with the challenge <span class="math">(\\beta_{2},\\gamma_{2})</span>. From the arguments in the proof of Lemma 4.9, this event occurs with probability at most $\\frac{3\\mathtt{n}(r^{\\prime}+\\mathtt{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Observe that, in this case, </span>\\mathtt{d}_{1}(X)<span class="math"> vanishes on </span>H<span class="math"> for any </span>\\alpha_{1}<span class="math"> received. On the other hand, since we made no assumptions about </span>(\\beta_{2},\\gamma_{2})<span class="math">, </span>\\mathtt{d}_{2}(X)<span class="math"> may not vanish on </span>H<span class="math">. However, if it does, both </span>\\mathtt{d}_{1}(X),\\mathtt{d}_{2}(X)<span class="math"> vanish on </span>H<span class="math"> and then </span>\\mathcal{A}<span class="math"> is able to complete the protocol and convince the verifier with probability </span>1<span class="math">. In particular, </span>\\mathcal{A}$ escapes the doomed set of partial transcripts that we defined in Lemma 4.9.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using similar arguments to the ones used to estimate <span class="math">\\varepsilon_{2}</span> in the proof of Lemma 4.9, the probability that <span class="math">\\mathcal{A}</span> is “lucky” and receives <span class="math">\\alpha_{2}</span> such that <span class="math">\\mathtt{d}_{2}(X)</span> vanishes on <span class="math">H</span> is at most $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{s}+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Hence, if we take the same doomed sets as in the proof of Lemma 4.9, then the RBR soundness error of this variant of </span>\\mathsf{OPlonky}(\\delta)<span class="math"> is at least </span>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{s}+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, which is much higher than the one obtained in Lemma 4.9, and could be devastating if one were to use a small field </span>\\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Indeed, the FS compilation of such protocol into its non-interactive version would allow an attacker to repeatedly generate new challenges for Round 1 until obtaining a challenge <span class="math">(\\beta_{1},\\gamma_{1},\\beta_{2},\\gamma_{2})</span> that allows <span class="math">(\\beta_{1},\\gamma_{1})</span> to cheat the first permutation argument. Then, the adversary could move on to the next round, and again generate new Round 2 challenges <span class="math">(\\alpha_{1},\\alpha_{2})</span> until <span class="math">\\alpha_{2}</span> is such that <span class="math">\\mathtt{d}_{2}(X)</span> vanishes on <span class="math">H</span>. As we argued, it does not matter what <span class="math">\\alpha_{1}</span> is at this point, as <span class="math">\\mathtt{d}_{1}(X)</span> will always vanish on <span class="math">H</span>. At this point, the verifier will eventually accept the proof. This type of attack is introduced and described in <em>[x1]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intuitively, it is clear that the soundness error of this variation of <span class="math">\\mathsf{OPlonky}</span> is roughly $\\varepsilon\\coloneqq\\max\\{\\frac{3\\mathtt{n}(r^{\\prime}+\\mathtt{u})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathtt{s}+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math">. This is much larger than the error the original </span>\\mathsf{OPlonky}<span class="math"> would have (in the current setting), namely </span>\\varepsilon^{2}<span class="math">. However actually proving that the soundness error is roughly </span>\\varepsilon$ and cannot be made lower requires significant effort, and requires researching how to attack Plonk-like protocols in general. We leave this as upcoming work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Fiat-Shamir Security of FRI and Related SNARKs (2023/1071)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1071
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
